Project Path: arc_gmh5225_AutoOpenCAK_k15xv4eq

Source Tree:

```txt
arc_gmh5225_AutoOpenCAK_k15xv4eq
├── LICENSE
├── OpenCorepiAndBypass
│   ├── App.config
│   ├── OpenCorepiAndBypass.csproj
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   ├── Resources.resx
│   │   ├── Settings.Designer.cs
│   │   ├── Settings.settings
│   │   ├── Strings.en.resx
│   │   └── Strings.zh-CN.resx
│   ├── icon_ct_1bpp.ico
│   ├── packages.config
│   └── src
│       ├── FileUtils.cs
│       ├── IniFile.cs
│       ├── InternetUtil.cs
│       └── Program.cs
├── OpenCorepiAndBypass.sln
├── README-EN.md
└── README.md

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`OpenCorepiAndBypass.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.33328.57
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "OpenCorepiAndBypass", "OpenCorepiAndBypass\OpenCorepiAndBypass.csproj", "{19E39293-550A-4239-8C38-7FFE39CF38A9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{19E39293-550A-4239-8C38-7FFE39CF38A9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{19E39293-550A-4239-8C38-7FFE39CF38A9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{19E39293-550A-4239-8C38-7FFE39CF38A9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{19E39293-550A-4239-8C38-7FFE39CF38A9}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8A2E99C4-B1F1-44B1-861D-075595244084}
	EndGlobalSection
EndGlobal

```

`OpenCorepiAndBypass/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
</configuration>
```

`OpenCorepiAndBypass/OpenCorepiAndBypass.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{19E39293-550A-4239-8C38-7FFE39CF38A9}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>OpenCorepiAndBypass</RootNamespace>
    <AssemblyName>OpenCorepiAndBypass</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>icon_ct_1bpp.ico</ApplicationIcon>
  </PropertyGroup>
  <PropertyGroup>
    <NoWin32Manifest>true</NoWin32Manifest>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>OpenCorepiAndBypass.Program</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="AgileHttp, Version=0.0.6.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>..\packages\AgileHttp.0.0.6\lib\netstandard2.0\AgileHttp.dll</HintPath>
    </Reference>
    <Reference Include="Newtonsoft.Json, Version=12.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL">
      <HintPath>..\packages\Newtonsoft.Json.12.0.3\lib\net45\Newtonsoft.Json.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Management" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
      <DependentUpon>Settings.settings</DependentUpon>
    </Compile>
    <Compile Include="src\FileUtils.cs" />
    <Compile Include="src\IniFile.cs" />
    <Compile Include="src\InternetUtil.cs" />
    <Compile Include="src\Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
    <None Include="packages.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Strings.en.resx" />
    <EmbeddedResource Include="Properties\Strings.zh-CN.resx" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="icon_ct_1bpp.ico" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.7.2">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.7.2 %28x86 和 x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`OpenCorepiAndBypass/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 有关程序集的一般信息由以下
// 控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("OpenCorepiAndBypass")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("OpenCorepiAndBypass")]
[assembly: AssemblyCopyright("Copyright ©  2023")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// 将 ComVisible 设置为 false 会使此程序集中的类型
//对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型
//请将此类型的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("19e39293-550a-4239-8c38-7ffe39cf38a9")]

// 程序集的版本信息由下列四个值组成: 
//
//      主版本
//      次版本
//      生成号
//      修订号
//
//可以指定所有这些值，也可以使用“生成号”和“修订号”的默认值
//通过使用 "*"，如下所示:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`OpenCorepiAndBypass/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

namespace OpenCorepiAndBypass.Properties {
    using System;
    
    
    /// <summary>
    ///   一个强类型的资源类，用于查找本地化的字符串等。
    /// </summary>
    // 此类是由 StronglyTypedResourceBuilder
    // 类通过类似于 ResGen 或 Visual Studio 的工具自动生成的。
    // 若要添加或移除成员，请编辑 .ResX 文件，然后重新运行 ResGen
    // (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   返回此类使用的缓存的 ResourceManager 实例。
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("OpenCorepiAndBypass.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   重写当前线程的 CurrentUICulture 属性，对
        ///   使用此强类型资源类的所有资源查找执行重写。
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   查找类似 Hello, world! 的本地化字符串。
        /// </summary>
        internal static string Greeting {
            get {
                return ResourceManager.GetString("Greeting", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 ¡Hola, mundo! 的本地化字符串。
        /// </summary>
        internal static string Greeting_es {
            get {
                return ResourceManager.GetString("Greeting.es", resourceCulture);
            }
        }
    }
}

```

`OpenCorepiAndBypass/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Greeting" xml:space="preserve">
    <value>Hello, world!</value>
  </data>
  <data name="Greeting.es" xml:space="preserve">
    <value>¡Hola, mundo!</value>
  </data>
</root>
```

`OpenCorepiAndBypass/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

namespace OpenCorepiAndBypass.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "16.10.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}

```

`OpenCorepiAndBypass/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
</SettingsFile>

```

`OpenCorepiAndBypass/Properties/Strings.en.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccountSwitcher" xml:space="preserve">
    <value>Account switcher </value>
  </data>
  <data name="Bypass_Message" xml:space="preserve">
    <value>Bypass preparation is complete, if the game cannot be started due to failure to read the injector, please use the repair file to fix the anti-cheat</value>
  </data>
  <data name="Bypass_Name" xml:space="preserve">
    <value>Bypass the original God anti-cheat service</value>
  </data>
  <data name="Cahcoe_Bypass_Message" xml:space="preserve">
    <value>Fixed anti - cheating file to prevent entry failure</value>
  </data>
  <data name="Cancle_Open" xml:space="preserve">
    <value>unopened </value>
  </data>
  <data name="Change_message" xml:space="preserve">
    <value>Have confirmed to open the account switching program: please switch the account, the process will wait for you five seconds</value>
  </data>
  <data name="Conf_Path_CanceledOpenAccountSwitcher" xml:space="preserve">
    <value>Enabling the account switcher has been cancelled</value>
  </data>
  <data name="Conf_Path_Opened3dmModelSwitcher" xml:space="preserve">
    <value>The 3dm model switching tool is confirmed to be open</value>
  </data>
  <data name="Conf_Success" xml:space="preserve">
    <value>The configuration file is successfully loaded. Procedure</value>
  </data>
  <data name="Exit_Message" xml:space="preserve">
    <value>When the program is finished, press Enter to exit,If there is a bug or any problem can be sent to github issue feedback</value>
  </data>
  <data name="Game_Path_Error" xml:space="preserve">
    <value>Game path does not exist, please choose a new path.</value>
  </data>
  <data name="Game_Path_Length_Error" xml:space="preserve">
    <value>The selected path length is incorrect</value>
  </data>
  <data name="Game_Path_Select_Info" xml:space="preserve">
    <value>Select the Game path folder, incorrect selection may cause the game to not run folder name :Genshin Impact Game</value>
  </data>
  <data name="Hello" xml:space="preserve">
    <value>Hello, world!</value>
  </data>
  <data name="HoYoKProtect_no_exist" xml:space="preserve">
    <value>If HoYoKProtect sys or other two file does not exist, please download from https://github.com/Micah123321/AutoOpenCAK/releases/tag/v0.0.1-beta, and into the original god game directory</value>
  </data>
  <data name="Injector" xml:space="preserve">
    <value>injector</value>
  </data>
  <data name="Load_Path" xml:space="preserve">
    <value>Reading open corresponding program, make sure the path is accurate</value>
  </data>
  <data name="Name" xml:space="preserve">
    <value>My name is</value>
  </data>
  <data name="Open_Agree" xml:space="preserve">
    <value>Confirmed open</value>
  </data>
  <data name="Server_Info" xml:space="preserve">
    <value>The server you choose is:</value>
  </data>
  <data name="Wait_Injector_Time" xml:space="preserve">
    <value>Wait 15 seconds for injection. Please do not close the application. As a result, the game cannot be started or the Internet cannot be connected</value>
  </data>
</root>
```

`OpenCorepiAndBypass/Properties/Strings.zh-CN.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccountSwitcher" xml:space="preserve">
    <value>账号切换器</value>
  </data>
  <data name="Bypass_Message" xml:space="preserve">
    <value>绕过准备完成,如读取注入器失败导致无法启动游戏,请使用修复文件修复反作弊</value>
  </data>
  <data name="Bypass_Name" xml:space="preserve">
    <value>绕过原神反作弊服务</value>
  </data>
  <data name="Cahcoe_Bypass_Message" xml:space="preserve">
    <value>修复反作弊文件,防止进门失败</value>
  </data>
  <data name="Cancle_Open" xml:space="preserve">
    <value>已取消打开</value>
  </data>
  <data name="Change_message" xml:space="preserve">
    <value>已确定打开账户切换程序:请切换账号,过程将等待你五秒</value>
  </data>
  <data name="Conf_Path_CanceledOpenAccountSwitcher" xml:space="preserve">
    <value>已取消打开账号切换器</value>
  </data>
  <data name="Conf_Path_Opened3dmModelSwitcher" xml:space="preserve">
    <value>已确定打开3dm模型切换工具</value>
  </data>
  <data name="Conf_Success" xml:space="preserve">
    <value>配置文件加载成功</value>
  </data>
  <data name="Exit_Message" xml:space="preserve">
    <value>程序完成,回车退出,如果存在bug或者什么问题可以到github的issue反馈</value>
  </data>
  <data name="Game_Path_Error" xml:space="preserve">
    <value>游戏路径不存在，请重新选择路径。</value>
  </data>
  <data name="Game_Path_Length_Error" xml:space="preserve">
    <value>选择的路径长度不对</value>
  </data>
  <data name="Game_Path_Select_Info" xml:space="preserve">
    <value>选择游戏路径文件夹,选错可能导致游戏无法运行 文件夹名称为:Genshin Impact Game</value>
  </data>
  <data name="Hello" xml:space="preserve">
    <value>你好，世界！</value>
  </data>
  <data name="HoYoKProtect_no_exist" xml:space="preserve">
    <value>如果HoYoKProtect.sys或者其他两个文件不存在,请从https://github.com/Micah123321/AutoOpenCAK/releases/tag/v0.0.1-beta下载,并且放入到原神游戏目录</value>
  </data>
  <data name="Injector" xml:space="preserve">
    <value>注入器</value>
  </data>
  <data name="Load_Path" xml:space="preserve">
    <value>正在读取打开对应程序,确保路径准确</value>
  </data>
  <data name="Name" xml:space="preserve">
    <value>我的名字是</value>
  </data>
  <data name="Open_Agree" xml:space="preserve">
    <value>已确定打开</value>
  </data>
  <data name="Server_Info" xml:space="preserve">
    <value>你选择的服务器是: </value>
  </data>
  <data name="Wait_Injector_Time" xml:space="preserve">
    <value>等待15秒用于注入,请不要关闭该应用,可能会导致无法开启游戏或者无法联网</value>
  </data>
</root>
```

`OpenCorepiAndBypass/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="AgileHttp" version="0.0.6" targetFramework="net472" />
  <package id="Newtonsoft.Json" version="12.0.3" targetFramework="net472" />
</packages>
```

`OpenCorepiAndBypass/src/FileUtils.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Windows.Forms;

namespace OpenCorepiAndBypass.src
{
    class FileUtils
    {
        /// <summary>
        /// 修改文件名称
        /// </summary>
        /// <param name="oldName">旧名称路径</param>
        /// <param name="newName">新名称路径</param>
        /// <param name="fileName">文件名称</param>
        public static void ChangeFileName(string oldName, string newName, string fileName)
        {
            File.Delete(newName); // 删除已存在的文件

            string backupDir = @Environment.CurrentDirectory + @"\bak\";

            string backupFile = backupDir + fileName;
            try
            {
                //判断如果当前文件不存在则返回
                if (!File.Exists(oldName))
                {


                    //判断如何oldName+.bak存在 则改为非bak格式 (还原旧名称)
                    if (File.Exists(oldName + ".bak"))
                    {
                        File.Move(oldName + ".bak", oldName);
                    }
                    else if (File.Exists(backupFile))//判断如果/bak/目录存在则替换到该目录
                    {
                        File.Move(backupFile, oldName);
                    }
                    else
                    {
                        //否则抛出异常

                        throw new FileNotFoundException("要修改的文件不存在,文件为:" + oldName
                            + " 请检查游戏路径是否填错,或者游戏文件缺失 | The file to be modified does not exist. The file is:" +
                            oldName + " Please check whether the game path is filled in incorrectly or the game file is missing");
                    }

                }
            }
            catch (FileNotFoundException ex)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("发生异常：" + ex.Message);
                Console.Read();
                Environment.Exit(1);
            }

            //将要修改的名称备份到运行目录下的/bak/文件名称

            if (!Directory.Exists(backupDir))
            {
                Directory.CreateDirectory(backupDir);
            }

            //如果文件名称不包含.bak,则备份
            if (!fileName.EndsWith(".bak")&& !fileName.Contains("PCGameSDK"))
            {
                File.Copy(oldName, backupFile, true);
            }


            // 将旧文件名改为新文件名
            File.Move(oldName, newName);
        }

        /// <summary>
        /// 打开文件
        /// </summary>
        /// <param name="fileName">文件路径名称</param>
        public static void OpenFile(string fileName)
        {
            Process process = new Process();
            // 设置要启动的文件名，包括完整路径
            process.StartInfo.FileName = fileName;

            try
            {
                //判断要打开的文件存不存在
                if (!File.Exists(fileName))
                {
                    throw new FileNotFoundException("要打开的文件不存在,请检查路径,当前错误路径为:" + fileName
                        + " | The file you want to open does not exist, please check the path, the current error path is:" + fileName);
                }
            }
            catch (FileNotFoundException ex)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("发生异常：| An exception occurs:" + ex.Message);
                /*Environment.Exit(1);*/
                //手动选择路径 
                Console.ForegroundColor = ConsoleColor.DarkGreen;
                Console.WriteLine("");
                Console.WriteLine("是否手动选择路径：1)是 2)否 |  Whether to manually select a path: 1)yes 2)no");
                string input = Console.ReadLine();
                int choice;
                if (!int.TryParse(input, out choice) || (choice != 1 && choice != 2))
                {
                    Console.WriteLine("无效选择 | Invalid choice。");
                    Environment.Exit(1);
                }

                // 根据用户的选择执行相应的操作
                if (choice == 1)
                {
                    process.StartInfo.FileName = GetFilePath("选择要打开的文件 | Select the file you want to open", "");

                }
                else
                {
                    Console.WriteLine("不选择有可能导致游戏无法运行,等待后续修复 | Not selecting can result in the game not working, waiting for a later fix");
                    Console.ReadLine();
                    Environment.Exit(1);
                };

            }


            // 启动Process对象
            process.Start();
        }

        /// <summary>
        /// 换取文件路径
        /// </summary>
        /// <param name="title">打开窗口的标题</param>
        /// <param name="filter">过滤器文本</param>
        /// <returns></returns>
        public static string GetFilePath(string title, string filter)
        {
            string filePath = "";
            Thread t = new Thread((ThreadStart)(() =>
            {
                OpenFileDialog openFileDialog = new OpenFileDialog();
                openFileDialog.InitialDirectory = Environment.CurrentDirectory;
                openFileDialog.Filter = filter;
                openFileDialog.Title = title;
                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    filePath = openFileDialog.FileName;
                }
            }
            ));
            t.SetApartmentState(ApartmentState.STA);
            t.Start();
            t.Join();
            return filePath;
        }


        /// <summary>
        /// 换取文件夹路径
        /// </summary>
        /// <param name="title">打开窗口的标题</param>
        /// <returns></returns>
        public static string GetFolderPath(string title)
        {
            string folderPath = "";
            Thread t = new Thread((ThreadStart)(() =>
            {
                FolderBrowserDialog folderBrowserDialog = new FolderBrowserDialog();
                folderBrowserDialog.SelectedPath = Environment.CurrentDirectory;
                folderBrowserDialog.Description = title;
                if (folderBrowserDialog.ShowDialog() == DialogResult.OK)
                {
                    folderPath = folderBrowserDialog.SelectedPath;
                }
            }
            ));
            t.SetApartmentState(ApartmentState.STA);
            t.Start();
            t.Join();
            return folderPath + @"\";
        }
    }

}

```

`OpenCorepiAndBypass/src/IniFile.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Runtime.InteropServices;

namespace OpenCorepiAndBypass.src
{
    class IniFile
    {
        string path;

        [DllImport("kernel32")]
        private static extern long WritePrivateProfileString(string section, string key, string val, string filePath);

        [DllImport("kernel32")]
        private static extern int GetPrivateProfileString(string section, string key, string def, StringBuilder retVal, int size, string filePath);

        public IniFile(string INIPath)
        {
            path = INIPath;
        }
        /// <summary>
        /// 写ini文件值
        /// </summary>
        /// <param name="Section">所属区域</param>
        /// <param name="Key">k</param>
        /// <param name="Value">v</param>
        public void WriteValue(string Section, string Key, string Value)
        {
            try
            {
                WritePrivateProfileString(Section, Key, Value, path);
            }
            catch (Exception ex)
            {
                throw new Exception("无法写入 INI 文件。", ex);
            }
        }
        /// <summary>
        /// 读ini文件值
        /// </summary>
        /// <param name="Section">区域</param>
        /// <param name="Key">k</param>
        /// <returns>v</returns>
        public string ReadValue(string Section, string Key)
        {
            if (!File.Exists(path))
            {
                return "";
            }

            StringBuilder temp = new StringBuilder(255);
            int i = GetPrivateProfileString(Section, Key, "", temp, 255, path);
            return temp.ToString();
        }
    }
}

```

`OpenCorepiAndBypass/src/InternetUtil.cs`:

```cs
using System.Net.NetworkInformation;
using System.Management;
using System.Diagnostics;
namespace OpenCorepiAndBypass.src
{
    class InternetUtil
    {

        public static void OpenInternet()
        {


            ProcessStartInfo processStartInfo = new ProcessStartInfo("ipconfig", "/renew");
            processStartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            processStartInfo.UseShellExecute = true;
            Process.Start(processStartInfo);


        }   


        public static void OffInternet()
        {

            ProcessStartInfo processStartInfo = new ProcessStartInfo("ipconfig", "/release");
            processStartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            processStartInfo.UseShellExecute = true;
            Process.Start(processStartInfo);


        }

    }
}

```

`OpenCorepiAndBypass/src/Program.cs`:

```cs
using OpenCorepiAndBypass.src;
using System;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Resources;
using System.Threading;

namespace OpenCorepiAndBypass
{



    class Program
    {
        const string VERSION = "v0.0.6";

        /// <summary>
        /// 绘制版本启动
        /// </summary>
        private static void DrawVersion()
        {
            Console.ForegroundColor = ConsoleColor.Magenta;
            Console.WriteLine("╔══════════════════════════════════════════════════════════╗");
            Console.WriteLine("║                        AutoOpenCAK                       ║");
            Console.WriteLine("║                                                          ║");
            Console.Write("║                 ");
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.Write(VERSION);
            Console.ForegroundColor = ConsoleColor.Magenta;
            Console.Write(" : ");
            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.Write("原神");
            Console.ForegroundColor = ConsoleColor.Magenta;
            Console.Write(",");
            Console.ForegroundColor = ConsoleColor.Green;
            Console.Write("启动");
            Console.ForegroundColor = ConsoleColor.Magenta;
            Console.Write("!!!!");
            Console.WriteLine("                   ║");
            Console.WriteLine("║                      绕过米哈游检测                      ║");
            Console.WriteLine("║                请确定你已经配置好config.ini              ║");
            Console.WriteLine("║                       路径只支持英文                     ║");
            Console.WriteLine("║                                                          ║");
            Console.ForegroundColor = ConsoleColor.Magenta;
            Console.WriteLine("╚══════════════════════════════════════════════════════════╝");
            Console.ResetColor();

        }

        /// <summary>
        /// 获取资源管理器
        /// </summary>
        /// <returns>资源管理器</returns>
        private static ResourceManager GetResourceManager(bool faststart)
        {

            bool loop = true;

            // 使用while循环来重复执行以下代码，直到loop为false
            if (!faststart)
            {
                while (loop)
                {
                    // 输出语言选择菜单
                    Console.ForegroundColor = ConsoleColor.DarkCyan;
                    Console.WriteLine("请选择语言：| Please select a language:");
                    Console.ForegroundColor = ConsoleColor.DarkGreen;
                    Console.WriteLine("1. 中文 | 1. Chinese");
                    Console.WriteLine("2. 英文 | 2. English");
                    Console.ResetColor();

                    // 读取用户输入的选择
                    string choice = Console.ReadLine();

                    // 使用switch语句来根据选择设置语言和退出循环
                    switch (choice)
                    {
                        case "1":
                            Thread.CurrentThread.CurrentUICulture = new CultureInfo("zh-CN");
                            loop = false; // 设置loop为false，退出循环
                            break;
                        case "2":
                            Thread.CurrentThread.CurrentUICulture = new CultureInfo("en");
                            loop = false; // 设置loop为false，退出循环
                            break;
                        default:
                            Console.WriteLine("无效选择！| Invalid selection!");
                            break;
                    }
                }
            }
            // 创建资源管理器对象
            ResourceManager rm = new System.Resources.ResourceManager("OpenCorepiAndBypass.Properties.Strings", Assembly.GetExecutingAssembly());


            return rm;
        }


        static void Main(string[] args)
        {
            //判断是否使用快速启动模式
            bool faststart = false;
            if (args.Contains("--faststart"))
            {
                faststart = true;
                Console.ForegroundColor = ConsoleColor.DarkGreen;
                Console.WriteLine("开始快速启动模式 | FastStart Mode");
            }
            //绘制版本消息
            DrawVersion();

            //获取资源管理器
            ResourceManager rm = GetResourceManager(faststart);

            //判断是否存在配置文件
            Console.ForegroundColor = ConsoleColor.DarkGreen;

            //读取配置文件
            IniFile ini = new IniFile(@Environment.CurrentDirectory + @"\config.ini");
            if (ini != null)
            {
                Console.WriteLine(rm.GetString("Conf_Success"));
            }

            

            //获取服务器区别
            string server = ini.ReadValue("Settings", "server");

            //设置游戏data路径
            string GameDataPathName = "";
            string channelId = "";
            //获取游戏路径
            string GamePath = ini.ReadValue("Settings", "GamePath") + @"\";

            if (server.Contains("ys") || server.Contains("bilibili"))
            {
                GameDataPathName = @"\YuanShen_Data\";
                //添加b服sdk,从bak获取
                if (server.Contains("ys"))
                {
                    channelId = "1";
                    //如果存在sdk,则删除
                    File.Delete(@GamePath + GameDataPathName + @"\Plugins\" + "PCGameSDK.dll");

                }
                else
                {
                    channelId = "14";
                    //如果不存在,则添加
                    string backupDir = @Environment.CurrentDirectory + @"\bak\";

                    //从bak下复制一份
                    File.Copy(backupDir + "PCGameSDK.dll", @GamePath + GameDataPathName + @"\Plugins\" + "PCGameSDK.dll",true);
                }
            }
            else if (server.Contains("gs"))
            {
                GameDataPathName = @"\GenshinImpact_Data\";
            }

            //处理b服官服互转
            //读取官方文件config.ini
            IniFile GSini = new IniFile(@GamePath + @"\config.ini");
            GSini.WriteValue("General", "channel", channelId);


            Console.WriteLine(rm.GetString("Server_Info") + "  " + server);



            //账号切换器
            string genshinAccount = ini.ReadValue("Settings", "GenshinAccount");
            if (genshinAccount.Contains("true"))
            {
                Console.WriteLine(rm.GetString("Change_message"));
                string genshinAccountPath = ini.ReadValue("Settings", "GenshinAccountPath");

                Console.WriteLine(rm.GetString("Load_Path"));

                FileUtils.OpenFile(@genshinAccountPath);

                Thread.Sleep(5000);
            }
            else
            {
                Console.WriteLine(rm.GetString("Cancle_Open") + rm.GetString("AccountSwitcher"));
            }

            Console.WriteLine("");

            //3dm
            string ThreeDM = ini.ReadValue("Settings", "ThreeDM");
            if (ThreeDM.Contains("true"))
            {
                Console.WriteLine(rm.GetString("Open_Agree") + "3dm");
                string ThreeDMPath = ini.ReadValue("Settings", "ThreeDMPath");

                Console.WriteLine(rm.GetString("Load_Path"));
                FileUtils.OpenFile(ThreeDMPath);

                // 暂停1秒
                Thread.Sleep(2000);
            }
            else
            {
                Console.WriteLine(rm.GetString("Cancle_Open") + "3dm");
            }

            Console.WriteLine("");


            //执行过检测
            string ByPass = ini.ReadValue("Settings", "ByPass");
            if (ByPass.Contains("true"))
            {
                Console.WriteLine(rm.GetString("Open_Agree") + rm.GetString("Bypass_Name"));



                Console.WriteLine(GamePath);


                //判断文件夹是否存在,不存在报错并且重新选择
                if (!Directory.Exists(GamePath))
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine(rm.GetString("Game_Path_Error"));
                    // 重新选择路径的代码
                    GamePath = FileUtils.GetFolderPath(rm.GetString("Game_Path_Select_Info"));
                    if (GamePath.Length <= 3)
                    {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.WriteLine(rm.GetString("Game_Path_Length_Error"));
                        Console.Read();
                        Environment.Exit(1);
                    }
                }
                Console.ForegroundColor = ConsoleColor.DarkGreen;

                Console.WriteLine(rm.GetString("Bypass_Message"));
                Console.WriteLine("");
                Console.WriteLine(rm.GetString("HoYoKProtect_no_exist"));

                //绕过保护进程
                FileUtils.ChangeFileName(@GamePath + "HoYoKProtect.sys", @GamePath + "HoYoKProtect.sys.bak", "HoYoKProtect.sys");
                FileUtils.ChangeFileName(@GamePath + "mhypbase.dll", @GamePath + "mhypbase.dll.bak", "mhypbase.dll");
                FileUtils.ChangeFileName(@GamePath + "mhyprot3.Sys", @GamePath + "mhyprot3.Sys.bak", "mhyprot3.Sys");


                //处理上传错误程序
                FileUtils.ChangeFileName(@GamePath + GameDataPathName + "blueReporter.exe",
                    @GamePath + GameDataPathName + "blueReporter.exe.bak",
                    "blueReporter.exe");

                FileUtils.ChangeFileName(@GamePath + GameDataPathName + "upload_crash.exe",
                    @GamePath + GameDataPathName + "upload_crash.exe.bak",
                    "upload_crash.exe");

                FileUtils.ChangeFileName(@GamePath + GameDataPathName + @"\Plugins\" + "crashreport.exe",
                    @GamePath + GameDataPathName + @"\Plugins\" + "crashreport.exe.bak",
                    "crashreport.exe");


                //断开网络

                //判断是否断开
                string Internet = ini.ReadValue("Settings", "Internet");
                if (Internet.Contains("true"))
                {
                    InternetUtil.OffInternet();
                }

                // 暂停1秒
                Thread.Sleep(2000);

            }
            Console.WriteLine("");
            //执行注入

            string Injector = ini.ReadValue("Settings", "Injector");
            if (Injector.Contains("true"))
            {
                Console.WriteLine(rm.GetString("Open_Agree") + rm.GetString("Injector"));
                string InjectorPath = ini.ReadValue("Settings", "InjectorPath");
                FileUtils.OpenFile(InjectorPath);

                // 暂停15秒
                Console.WriteLine(rm.GetString("Wait_Injector_Time"));
                Thread.Sleep(20000);
            }
            else
            {
                //未选择执行注入器程序
                //直接运行游戏
                Console.WriteLine("未选择启动注入器,直接运行原神程序");

                GamePath = ini.ReadValue("Settings", "GamePath") + @"\";

                //根据服务器来选择 如果为 ys 为国服 gs为外服
                if (server.Contains("ys")|| server.Contains("bilibili"))
                {
                    FileUtils.OpenFile(GamePath + @"YuanShen.exe");
                }
                else if (server.Contains("gs"))
                {
                    FileUtils.OpenFile(GamePath + @"GenshinImpact.exe");
                }
                Thread.Sleep(20000);

            }


            //恢复文件操作
            if (ByPass.Contains("true"))
            {
                GamePath = ini.ReadValue("Settings", "GamePath") + @"\";

                Console.WriteLine(rm.GetString("Cahcoe_Bypass_Message"));

                FileUtils.ChangeFileName(@GamePath + "HoYoKProtect.sys.bak", @GamePath + "HoYoKProtect.sys", "HoYoKProtect.sys.bak");
                FileUtils.ChangeFileName(@GamePath + "mhypbase.dll.bak", @GamePath + "mhypbase.dll", "mhypbase.dll.bak");
                FileUtils.ChangeFileName(@GamePath + "mhyprot3.Sys.bak", @GamePath + "mhyprot3.Sys", "mhyprot3.Sys.bak");



                //处理上传错误程序
                FileUtils.ChangeFileName(@GamePath + GameDataPathName + "blueReporter.exe.bak",
                    @GamePath + GameDataPathName + "blueReporter.exe",
                    "blueReporter.exe.bak");

                FileUtils.ChangeFileName(@GamePath + GameDataPathName + "upload_crash.exe.bak",
                    @GamePath + GameDataPathName + "upload_crash.exe",
                    "upload_crash.exe.bak");

                FileUtils.ChangeFileName(@GamePath + GameDataPathName + @"\Plugins\" + "crashreport.exe.bak",
                    @GamePath + GameDataPathName + @"\Plugins\" + "crashreport.exe",
                    "crashreport.exe.bak");



                string Internet = ini.ReadValue("Settings", "Internet");
                if (Internet.Contains("true"))
                {
                    //开启网络
                    InternetUtil.OpenInternet();
                }

                // 暂停1秒
                Thread.Sleep(2000);
                Console.WriteLine("");
            }

            //CB运行
            string CB = ini.ReadValue("Settings", "CB");
            if (CB.Contains("true"))
            {
                string CBPath = ini.ReadValue("Settings", "CBPath");
                FileUtils.OpenFile(CBPath);
                Console.WriteLine(rm.GetString("Open_Agree") + "CB");

            }

            Console.WriteLine("");

            Console.ForegroundColor = ConsoleColor.Red;

            Console.WriteLine(rm.GetString("Exit_Message"));

            Console.Read();
            Console.Read();
        }


    }
}

```

`README-EN.md`:

```md
- ![image](https://github.com/Micah123321/AutoOpenCAK/assets/76832465/cf8591b4-a373-4e29-8c9c-6cd1a46b14d7)

  # AutoOpenCAK

  This Is A Genshin Impact Bypass Tool. that allows you to circumvent Akebi-like injectors' detection, provides bypass GI process protection, fixes startup anomalies, and supports one-click switching between CN Server, Bilibili Server, and OS Servers. This tool is compatible with 3DM model modification tools, account switching tools, and native startup tools that bypass detection methods.

  <!-- TOC -->

  * [AutoOpenCAK](#)
  * [Running Effect](#Running Effect)
  * [Purpose](#Purpose)
    * [How To Use](#How To Use)
    * [Note](#Note)
      <!-- TOC -->

  # Running Effect

  ![image](https://user-images.githubusercontent.com/76832465/236788391-98559835-a629-48e7-923b-ccdccf39f685.png)

  # Purpose

  - Bypass Genshin Impact AntiCheat and shield Upload logs program
  - Fix Startup Errors and Restore Game Files
  - Shield Process Protect, CheatEngine can be Attach to Genshin Impact
  - Supports one click Switching between CN servers, and Bilibili-server supports bilingual support for OS servers
  - One click launch of the 3DM model switching tool [Download](https://github.com/Micah123321/AutoOpenCAK/releases/tag/utils)
  - One click activation of account replacement tool [Download](https://github.com/Micah123321/AutoOpenCAK/releases/tag/utils)

  ## How To Use

  1. Download Latest Version [Click Me Download](https://github.com/Micah123321/AutoOpenCAK/releases/latest)
  2. Extract all files
  3. Configure config.ini! According to your own situation.![img](https://camo.githubusercontent.com/c6351f6b8b7a8100c5c027ecec4209c362447e8b1096b5a1aa63b87a789b65d3/68747470733a2f2f7777772e616b65312e636f6d2f6d6b6f73732f323032332d30352d30382f31333538336466372e706e67)
  4. Run as administrator ` OpenCorepiAndBypass.exe`

  ## Note

  - If starting the 3dm execution program causes flash back, please start the only direct connection. The driver may cause incompatible startup

  - Please use the administrator to run this program

  - The code in this project is only applicable to Windows.

  - If you encounter any problems using the application, review the application's log file for more information.

  - Make sure you have sufficient permissions to add and remove startup items for Windows.

  - If you want to change the startup Settings of your application, look at the code in the "OpenCorepiAndBypass\OpenCorepiAndBypass\src\Program.cs" file and make the necessary changes.

    ![Star History Chart](https://api.star-history.com/svg?repos=Micah123321/AutoOpenCAK&type=Date)](https://star-history.com/#Micah123321/AutoOpenCAK&Date)

```

`README.md`:

```md
![image](https://github.com/Micah123321/AutoOpenCAK/assets/76832465/cf8591b4-a373-4e29-8c9c-6cd1a46b14d7)

# AutoOpenCAK

[English README](https://github.com/Micah123321/AutoOpenCAK/blob/main/README-EN.md)

可以让你绕过类akebi的注入器的原神检测,进程保护,修复启动异常,一键切换中国服,b服,国际服,兼容3dm模型修改工具
,兼容账号切换工具,兼容过检测方式的原生启动的工具

<!-- TOC -->

* [AutoOpenCAK](#)
* [运行效果](#运行效果)
* [用途](#用途)
  * [如何使用](#如何使用)
  * [注意事项](#注意事项)
    <!-- TOC -->

# 运行效果

![image](https://user-images.githubusercontent.com/76832465/236788391-98559835-a629-48e7-923b-ccdccf39f685.png)

# 用途

- 绕过原神检测,屏蔽申报应用
- 修复启动报错,还原游戏文件
- 屏蔽进程保护,支持CheatEngine附加到原神
- 支持一键切换国服,B服 支持国际服 双语支持
- 一键启动3dm模型切换工具 [下载](https://github.com/Micah123321/AutoOpenCAK/releases/tag/utils)
- 一键启动账号更换工具 [下载](https://github.com/Micah123321/AutoOpenCAK/releases/tag/utils)

## 如何使用

1. 下载最新版本  [点我下载](https://github.com/Micah123321/AutoOpenCAK/releases/latest)
2. 将所有文件解压
3. 个性化配置 `config.ini` 文件
4. 以管理员方式运行 `OpenCorepiAndBypass.exe`

## 注意事项

- 如果启动3dm执行程序导致闪退 请开启独显直连 可能是驱动导致无法兼容启动。

- 使用本程序请使用管理员运行。

- 本项目中的代码仅适用于Windows系统。

- 如果您在使用应用程序时遇到任何问题，请查看应用程序的日志文件以获取更多信息。

- 请确保您具有足够的权限来添加和删除Windows系统的启动项。

- 如果您想要更改应用程序的启动项设置，请查看“OpenCorepiAndBypass\OpenCorepiAndBypass\src\Program.cs”文件中的代码并进行必要的更改。

  ![Star History Chart](https://api.star-history.com/svg?repos=Micah123321/AutoOpenCAK&type=Date)](https://star-history.com/#Micah123321/AutoOpenCAK&Date)

```