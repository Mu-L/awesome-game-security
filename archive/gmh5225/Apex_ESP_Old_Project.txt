Project Path: arc_gmh5225_Apex_ESP_Old_Project_ogan5rlg

Source Tree:

```txt
arc_gmh5225_Apex_ESP_Old_Project_ogan5rlg
├── README.md
├── apex
│   ├── DirectOverlay.h
│   ├── Includes.h
│   ├── Menu.h
│   ├── Offsets.h
│   ├── Render.cpp
│   ├── Render.h
│   ├── SDK.h
│   ├── Settings.h
│   ├── Source.cpp
│   ├── apex.vcxproj
│   ├── apex.vcxproj.filters
│   └── apex.vcxproj.user
├── apex.sln
└── x64
    └── Release
        ├── APEX_BaseAddress.ini
        └── Settings.ini

```

`README.md`:

```md
# Apex_ESP_Old_Project
D2DOvelay : https://github.com/coltonon/D2DOverlay

```

`apex.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29806.167
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "apex", "apex\apex.vcxproj", "{1E2333FA-3780-492A-91F5-E583C3B32B63}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1E2333FA-3780-492A-91F5-E583C3B32B63}.Debug|x64.ActiveCfg = Debug|x64
		{1E2333FA-3780-492A-91F5-E583C3B32B63}.Debug|x64.Build.0 = Debug|x64
		{1E2333FA-3780-492A-91F5-E583C3B32B63}.Debug|x86.ActiveCfg = Debug|Win32
		{1E2333FA-3780-492A-91F5-E583C3B32B63}.Debug|x86.Build.0 = Debug|Win32
		{1E2333FA-3780-492A-91F5-E583C3B32B63}.Release|x64.ActiveCfg = Release|x64
		{1E2333FA-3780-492A-91F5-E583C3B32B63}.Release|x64.Build.0 = Release|x64
		{1E2333FA-3780-492A-91F5-E583C3B32B63}.Release|x86.ActiveCfg = Release|Win32
		{1E2333FA-3780-492A-91F5-E583C3B32B63}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3899FB9C-CC0A-4F2F-8D0D-8E518B041396}
	EndGlobalSection
EndGlobal

```

`apex/DirectOverlay.h`:

```h
/*
	Direct2D Overlay by Coltonon
	Simple library used to make a Direct2d overlay over any application quickly.
	Simply set up your drawing loop, and initialize the overlay.

	Sample use:

-----------------------------------------------------------------------------------------
	#include "DirectOverlay.h"

	void drawLoop(int width, int height) {  // our loop to render in
		DrawString("The quick brown fox jumped over the lazy dog", 48, 100, 20, 0, 1, 1);
	}

	int main(){
		DirectOverlaySetOption(D2DOV_DRAW_FPS | D2DOV_FONT_IMPACT);	// set the font, and draw the fps
		DirectOverlaySetup(drawLoop);		// initialize our overlay
		getchar();	// The overlay operates in it's own thread, ours will continue as normal
	}
-----------------------------------------------------------------------------------------

	The #defines are settings for the window, pass them to the DirectOverlaySetOption function.
	You may OR them together '|', you must set them before calling DirectOverlaySetup.

*/

#include <Windows.h>
#include <string>

// Link the static library (make sure that file is in the same directory as this file)
#pragma comment(lib, "D2DOverlay.lib")

// Requires the targetted window to be active and the foreground window to draw.
#define D2DOV_REQUIRE_FOREGROUND	(1 << 0)

// Draws the FPS of the overlay in the top-right corner
#define D2DOV_DRAW_FPS				(1 << 1)

// Attempts to limit the frametimes so you don't render at 500fps
#define D2DOV_VSYNC					(1 << 2)

// Sets the text font to Calibri
#define D2DOV_FONT_CALIBRI			(1 << 3)

// Sets the text font to Arial
#define D2DOV_FONT_ARIAL			(1 << 4)

// Sets the text font to Courier
#define D2DOV_FONT_COURIER			(1 << 5)

// Sets the text font to Gabriola
#define D2DOV_FONT_GABRIOLA			(1 << 6)

// Sets the text font to Impact
#define D2DOV_FONT_IMPACT			(1 << 7)

// The function you call to set up the above options.  Make sure its called before the DirectOverlaySetup function
void DirectOverlaySetOption(DWORD option);

// typedef for the callback function, where you'll do the drawing.
typedef void(*DirectOverlayCallback)(int width, int height);

// Initializes a the overlay window, and the thread to run it.  Input your callback function.
// Uses the first window in the current process to target.  If you're external, use the next function
void DirectOverlaySetup(DirectOverlayCallback callbackFunction);

// Used to specify the window manually, to be used with externals.
void DirectOverlaySetup(DirectOverlayCallback callbackFunction, HWND targetWindow);

// Draws a line from (x1, y1) to (x2, y2), with a specified thickness.
// Specify the color, and optionally an alpha for the line.
void DrawLine(float x1, float y1, float x2, float y2, float thickness, float r, float g, float b, float a = 1);

// Draws a rectangle on the screen.  Width and height are relative to the coordinates of the box.  
// Use the "filled" bool to make it a solid rectangle; ignore the thickness.
// To just draw the border around the rectangle, specify a thickness and pass "filled" as false.
void DrawBox(float x, float y, float width, float height, float thickness, float r, float g, float b, float a, bool filled);

// Draws a circle.  As with the DrawBox, the "filled" bool will make it a solid circle, and thickness is only used when filled=false.
void DrawCircle(float x, float y, float radius, float thickness, float r, float g, float b, float a, bool filled);

// Allows you to draw an elipse.  Same as a circle, except you have two different radii, for width and height.
void DrawEllipse(float x, float y, float width, float height, float thickness, float r, float g, float b, float a, bool filled);

// Draw a string on the screen.  Input is in the form of an std::string.
void DrawString(std::string str, float fontSize, float x, float y, float r, float g, float b, float a = 1);
```

`apex/Includes.h`:

```h
#include <iostream>
#include <windows.h>
#include <TlHelp32.h>
#include <vector>
#include <d3dx9math.h>
#pragma comment(lib, "d3dx9.lib")
#include <algorithm>
#define _USE_MATH_DEFINES
#include <math.h>
#include <ctime>
#include <time.h>
#define pasteColor(x) x.r, x.g, x.b
#define pasteColorA(x) x.r, x.g, x.b, x.a

```

`apex/Menu.h`:

```h
#pragma once
#include <vector>
#include <time.h>
#include "Render.h"
#include "settings.h"
int get_frame_rate()
{
	static int i_fps, i_last_fps;
	static float fl_last_tick_count, fl_tick_count;
	fl_tick_count = clock() * 0.001f;
	i_fps++;
	if ((fl_tick_count - fl_last_tick_count) >= 1.0f)
	{
		fl_last_tick_count = fl_tick_count;
		i_last_fps = i_fps;
		i_fps = 0;
	}
	return i_last_fps;
};

class c_menu_framework
{
private:
public:
	float menu_x = 250, menu_y = 290;
	enum item_type : int {
		type_bool = 0,
		type_int = 1,
		type_float = 2
	};
	enum tab_type : int {
		type_on_off = 0,
		type_tab = 1,
		type_dont_draw = 2
	};
	static struct menu_item_t {
		std::string m_title;
		
		float* m_float;
		int* m_int;
		bool* m_bool = 0;
		int increment = 1;
		int minimum = 0;
		int maximum = 1;
		float m_float_step;
		int m_int_step;
		int m_type;
		int tab_type;

		float m_float_min;
		int m_int_min;

		float m_float_max;
		int m_int_max;

		std::string tool_tip;
	};

	//int m_total_items = 0;
	int m_current_pos = 0;
	int menu_page = 0;
	std::vector<menu_item_t> items;
public:

	void add_entry(std::string title, bool* value, int is_tab = 0, std::string tooltip = "") {
		menu_item_t m_item;
		m_item.m_title = title;
		m_item.m_bool = value;
		m_item.m_type = item_type::type_bool;
		m_item.tab_type = is_tab;
		m_item.tool_tip = tooltip;
		items.emplace_back(m_item);
	}

	template <class t>
	void add_entry(std::string title, t* value, t min, t max, t step) {
		menu_item_t m_item;
		m_item.m_title = title;
		if (std::is_same<t, float>()) {
			m_item.m_float = (float*)value;
			m_item.m_float_min = min;
			m_item.m_float_max = max;
			m_item.m_float_step = step;
			m_item.m_type = item_type::type_float;
		}
		else if (std::is_same<t, int>()) {
			m_item.m_int = (int*)value;
			m_item.m_int_min = min;
			m_item.m_int_max = max;
			m_item.m_int_step = step;
			m_item.m_type = item_type::type_int;
		}
		items.emplace_back(m_item);
	}

	void draw()
	{
		this->menu_x = settings::menux;
		this->menu_y = settings::menuy;

		static bool aimbot_tap = false;
		static bool espteam_tap = false;
		static bool espenemy_tab = false;
		static bool crosshair_tab = false;
		static bool color_tab = false;
		static bool misc_tab = false;
		static bool menu_tab = false;

		this->add_entry("AIMBOT", &aimbot_tap, true);
		if (aimbot_tap) {
			this->add_entry("  Active", &settings::aimbot);
			this->add_entry("  Auto Lock", &settings::autolock);
			this->add_entry("  Aim Knocked", &settings::aimknocked);
			this->add_entry("  Hitbox", &settings::aimbothitbox, 0,2, 1);
			this->add_entry("  Fov", &settings::aimbotfov, 1.f, 100.f, 1.f);
			this->add_entry("  Speed", &settings::aimspeed, 1.f, 100.f, 1.f);
			this->add_entry("  Lock", &settings::aimlock, 0.f, 20.f, 0.1f);
			this->add_entry("  Aim Spot", &settings::aimspot);
			this->add_entry("  Aim Spot Distance", &settings::aimspotdis, 1.f, 80.f, 1.f);
			this->add_entry("  Aim Spot Fov", &settings::aimspotfov, 1.f, 100.f, 1.f);
			this->add_entry("  Aim Spot Speed", &settings::aimspotspeed, 1.f, 100.f, 1.f);
			this->add_entry("  Draw Hitbox", &settings::aimbotdrawhitbox);
			this->add_entry("  Draw Fov", &settings::aimbotdrawfov);

		}

		this->add_entry("TEAM ESP", &espteam_tap, true);
		if (espteam_tap) {
			this->add_entry("  Boxes", &settings::teamBoxes);
			this->add_entry("  Snaplines", &settings::teamSnaplines);
			this->add_entry("  Healthbars", &settings::teamHealth);
			this->add_entry("  Shieldbars", &settings::teamShieldHealth);
			this->add_entry("  Distance", &settings::teamDistance);
			this->add_entry("  FilledBox", &settings::teamFilledbox);
			this->add_entry("  Knocked", &settings::teamKnocked);
			this->add_entry("  Weapon Name", &settings::teamWeaponName);
			this->add_entry("  Player Info", &settings::teamInfo);

		}

		this->add_entry("ENEMY ESP", &espenemy_tab, true);
		if (espenemy_tab) {
			this->add_entry("  Boxes", &settings::enemyBoxes);
			this->add_entry("  Snaplines", &settings::enemySnaplines);
			this->add_entry("  Healthbars", &settings::enemyHealth);
			this->add_entry("  Shieldbars", &settings::enemyShieldHealth);
			this->add_entry("  Distance", &settings::enemyDistance);
			this->add_entry("  FilledBox", &settings::enemyFilledbox);
			this->add_entry("  Knocked", &settings::enemyKnocked);
			this->add_entry("  Weapon Name", &settings::enemyWeaponName);
			this->add_entry("  Player Info", &settings::enemyInfo);

		}
		this->add_entry("CROSSHAIR", &crosshair_tab, true);
		if (crosshair_tab) {
			this->add_entry("  Enable", &settings::c_enable);
			this->add_entry("  Crosshair Style", &settings::crosshair, 0, 4, 1);
			this->add_entry("  Size", &settings::size, 1.f, 20.f, 1.f);
			this->add_entry("  Stroke", &settings::stroke, 1.f, 10.f, 1.f);

		}
		this->add_entry("SETTINGS ESP", &misc_tab, true);
		if (misc_tab) {
			this->add_entry("  ESP Outline", &settings::esp_Outline);
			this->add_entry("  Box Type", &settings::boxtype, 0, 1, 1);
			this->add_entry("  HealthBar Type", &settings::healthbartype, 0, 2, 1);
			this->add_entry("  ShildBar Type", &settings::shildbartype, 0, 2, 1);

			this->add_entry("  Player Weapon Type", &settings::PlayerWeapontype, 0, 1, 1);
			this->add_entry("  Players Distance", &settings::playersdis, 1.f, 700.f, 20.f);
		}
		static bool colorteam_tab = false;
		this->add_entry("COLORS", &color_tab, true);
		if (color_tab) {
			static bool colorteambox_tab = false;
			this->add_entry("  Team Box", &colorteambox_tab, true);
			if (colorteambox_tab) {
				static auto prim_r = 0.f, prim_g = 0.f, prim_b = 255.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::FriendBox = D3DXCOLOR(prim_r/ 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);


			}

			static bool colorteamline_tab = false;
			this->add_entry("  Team Line", &colorteamline_tab, true);
			if (colorteamline_tab) {
				static auto prim_r = 0.f, prim_g = 0.f, prim_b = 255.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::FriendLine = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}
			static bool colorteamfillbox_tab = false;
			this->add_entry("  Team FillBox", &colorteamfillbox_tab, true);
			if (colorteamfillbox_tab) {
				static auto prim_r = 0.f, prim_g = 0.f, prim_b = 255.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::FriendFillbox = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}
			static bool colorteamKnocked_tab = false;
			this->add_entry("  Team Knocked", &colorteamKnocked_tab, true);
			if (colorteamKnocked_tab) {
				static auto prim_r = 0.f, prim_g = 255.f, prim_b = 255.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::FriendKnocked = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}
			static bool colortenemybox_tab = false;
			this->add_entry("  Enemy Box", &colortenemybox_tab, true);
			if (colortenemybox_tab) {
				static auto prim_r = 255.f, prim_g = 0.f, prim_b = 0.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::EnemyBOX = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}

			static bool colortenemyline_tab = false;
			this->add_entry("  Enemy Line", &colortenemyline_tab, true);
			if (colortenemyline_tab) {
				static auto prim_r = 255.f, prim_g = 0.f, prim_b = 0.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::EnemyLine = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}

			static bool colortenemyfillbox_tab = false;
			this->add_entry("  Enemy Line", &colortenemyfillbox_tab, true);
			if (colortenemyfillbox_tab) {
				static auto prim_r = 255.f, prim_g = 0.f, prim_b = 0.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::EnemyFillbox = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}

			static bool colorenemyknocked_tab = false;
			this->add_entry("  Enemy Knocked", &colorenemyknocked_tab, true);
			if (colorenemyknocked_tab) {
				static auto prim_r = 255.f, prim_g = 255.f, prim_b = 255.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::EnemyKnocked = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}

			static bool colorclosed_tab = false;
			this->add_entry("  CLOSED", &colorclosed_tab, true);
			if (colorclosed_tab) {
				static auto prim_r = 255.f, prim_g = 255.f, prim_b = 0.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::Closed = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}


		}

		this->add_entry("MENU", &menu_tab, true);
		if (menu_tab) {
			this->add_entry("  Menu x", &settings::menux, 0.f, 2560.f, 50.f);
			this->add_entry("  Menu y", &settings::menuy, 0.f, 1440.f, 50.f);

		}

	}
	 time_t lastTime;
	bool ReadKeyOnce(unsigned int keycode, unsigned int timer) {
		if ((clock() - lastTime > timer) && GetAsyncKeyState(keycode)) {
			lastTime = clock();
			return true;
		}
		return false;
	}
	void do_menu_controls() {
		static bool show = true;
		if (show) {
			this->draw();
			static int item_gap = 14;
			static float alpha = 1.f;
			DrawBox(this->menu_x - 3, this->menu_y - 17, 154, 17, 1.f, 0.1f, 0.1f, 0.1f, alpha, true);
			DrawBox(this->menu_x - 3, this->menu_y - 17, 154, 17, 1.f, 1.0f, 1.0, 1.0f, alpha, false);

			DrawString("APEX HAX - " + std::to_string(get_frame_rate()), 12, this->menu_x + 28, this->menu_y - 18, 1.f, 1.f, 1.f, alpha);

			DrawBox(this->menu_x - 3, this->menu_y, 154, (items.size() * item_gap), 1.f, 0.1f, 0.1f, 0.1f, alpha, true);
			DrawBox(this->menu_x - 3, this->menu_y, 154, (items.size() * item_gap), 1.f, 1.0f, 1.0, 1.0f, alpha, false);

			DrawBox(this->menu_x - 3, this->menu_y + (item_gap * m_current_pos), 154, item_gap, 1.f, 0.1f, 0.1f, 0.1f, alpha, true);
			DrawBox(this->menu_x - 3, this->menu_y + (item_gap * m_current_pos), 154, item_gap, 1.f, 1.0f, 1.0, 1.0f, alpha, false);

			if (items.empty())
				return;
			if (m_current_pos > items.size())
				m_current_pos = items.size();

			if (!items[m_current_pos].tool_tip.empty()) {
				DrawBox(this->menu_x - 3, this->menu_y + (items.size() * item_gap) + 3, 1, 154, 28, 31, 31, 31, alpha, true);
				DrawBox(this->menu_x - 3, this->menu_y + (items.size() * item_gap) + 3, 1, 154, 28, 102, 0, 204, alpha, false);

				DrawString("NOTE:", 12, this->menu_x, this->menu_y + (items.size() * item_gap) + 5, 1, 1, 1, alpha);
				DrawString(items[m_current_pos].tool_tip.c_str(), 11, this->menu_x, this->menu_y + (items.size() * item_gap) + 16, 1, 1, 1, alpha);

			}

			for (auto item = 0; item < items.size(); ++item) {
				auto height = this->menu_y + (item_gap * item);
				char txt[1024];
				switch (items[item].m_type)
				{
				case item_type::type_bool: {
					D3DXCOLOR _bool = *items[item].m_bool ? D3DXCOLOR(0, 1.f, 0, alpha) : D3DXCOLOR(1.f, 0, 0, alpha);

					DrawString(items[item].m_title.c_str(), 12, this->menu_x, height, 1, 1, 1, alpha);
					if (items[item].tab_type == tab_type::type_on_off)
						DrawString(*items[item].m_bool ? "ON" : "OFF", 11, this->menu_x + 130, height, _bool.r, _bool.g, _bool.b, _bool.a);
					else if (items[item].tab_type == tab_type::type_tab)
						DrawString(*items[item].m_bool ? "[-]" : "[+]", 11, this->menu_x + 130, height, _bool.r, _bool.g, _bool.b, _bool.a);
					break;
				}
				case item_type::type_int: {
					DrawString(items[item].m_title.c_str(), 11, this->menu_x, height, 1, 1, 1, alpha);
					sprintf(txt, "%i", *items[item].m_int);
					DrawString(txt, 11, this->menu_x + 130, height, 1, 1, 1, alpha);
					break;
				}
				case item_type::type_float: {
					DrawString(items[item].m_title.c_str(), 11, this->menu_x, height, 1.f, 1.f, 1.f, alpha);
					sprintf(txt, "%.1f", *items[item].m_float);
					DrawString(txt, 11, this->menu_x + 130, height, 1, 1, 1, alpha);
					break;
				}
				default:
					break;
				}

				if (ReadKeyOnce(VK_UP,250)) {
					this->m_current_pos -= 1;
					if (this->m_current_pos < 0)
						m_current_pos = (m_current_pos > 0) ? (m_current_pos - 1) : items.size() - 1;
				}
				if (ReadKeyOnce(VK_DOWN,250)) {
					this->m_current_pos += 1;
					if (this->m_current_pos > items.size() - 1)
						this->m_current_pos = 0;
				}

				if (ReadKeyOnce(VK_LEFT, 250)) {
					switch (items[m_current_pos].m_type) {
					case item_type::type_bool: {
						if (*items[m_current_pos].m_bool == 1) {
							*items[m_current_pos].m_bool -= items[m_current_pos].increment;
							if (*items[m_current_pos].m_bool < items[m_current_pos].minimum)
								*items[m_current_pos].m_bool = items[m_current_pos].minimum;
						}
						break;
					}
					case item_type::type_int: {

						*items[m_current_pos].m_int -= items[m_current_pos].m_int_step;
						if (*items[m_current_pos].m_int < items[m_current_pos].m_int_min)
							*items[m_current_pos].m_int = items[m_current_pos].m_int_max;
						break;
					}
					case item_type::type_float: {
						*items[m_current_pos].m_float -= items[m_current_pos].m_float_step;
						if (*items[m_current_pos].m_float < items[m_current_pos].m_float_min)
							*items[m_current_pos].m_float = items[m_current_pos].m_float_max;
						break;
					}
					default:
						break;
					}

				}
				if (ReadKeyOnce(VK_RIGHT, 250)) {
					switch (items[m_current_pos].m_type) {
					case item_type::type_bool: {
						if (*items[m_current_pos].m_bool == 0) {
							*items[m_current_pos].m_bool += items[m_current_pos].increment;
							if (*items[m_current_pos].m_bool > items[m_current_pos].maximum)
								//*items[m_current_pos].m_bool = !*items[m_current_pos].m_bool;
								*items[m_current_pos].m_bool = items[m_current_pos].maximum;
						}
						break;
					}
					case item_type::type_int: {
						*items[m_current_pos].m_int += items[m_current_pos].m_int_step;
						if (*items[m_current_pos].m_int > items[m_current_pos].m_int_max)
							*items[m_current_pos].m_int = items[m_current_pos].m_int_min;
						break;
					}
					case item_type::type_float: {
						*items[m_current_pos].m_float += items[m_current_pos].m_float_step;
						if (*items[m_current_pos].m_float > items[m_current_pos].m_float_max)
							*items[m_current_pos].m_float = items[m_current_pos].m_float_min;
						break;
					}
					default:
						break;
					}


				}
			}
		}
		if (!items.empty())
			items.clear();
		if (GetAsyncKeyState(VK_DELETE)) {
			show = !show;
			Sleep(150);
		}
	}

};



```

`apex/Offsets.h`:

```h
#pragma once
#include "Includes.h"
#define NUM_ENT_ENTRIES			(1 << 12)
#define ENT_ENTRY_MASK			(NUM_ENT_ENTRIES - 1)

#define m_view_render 0xcb011e0
#define m_view_matrix 0x1b3bd0

#define m_LocalPlayer 0x1dea658 
#define m_cl_entitylist 0x1883c38

#define m_entity_origin 0x014c 
#define m_entity_team_num 0x03f0
#define m_entity_bones 0x0ee0
#define m_player_shields 0x0170
#define m_player_health 0x03e0
#define m_player_max_health 0x0510
#define m_shieldHealth 0x0170 
#define m_shieldHealthMax 0x0174
#define m_player_bleedout_state 0x2590
enum BoneId {
	head = 8,
	neck = 7,
	Left_shoulder = 11,
	Right_shoulder = 35,
	chest = 5,
	Spine = 3,
	Left_hand = 15,
	Right_hand = 39,
	Left_arm = 41,
	Right_arm = 16,
	Left_knee = 58,
	Right_knee = 63,
	Left_foot = 65,
	Right_foot = 60,
	Left_ElbowRoll = 13,
	Right_ElbowRoll = 37,

};
enum  WeaponID {
	BARE_HANDS = 14,

	HAVOC = 64,
	LSTAR = 65,

	KRABER = 54,
	MASTIFF = 55,
	DEVOTION = 48,

	SENTINEL = 1,
	CHARGE_RIFLE = 66,
	LONGBOW = 49,
	TRIPLE_TAKE = 62,

	WINGMAN = 63,
	SPITFIRE = 61,
	PROWLER = 57,
	HEMLOK = 53,
	FLATLINE = 51,

	RE45 = 47,
	P2020 = 60,
	R301 = 0,
	R99 = 59,
	ALTERNATOR = 46,
	G7_SCOUT = 52,

	MOZAMBIQUE = 56,
	PEACEKEEPER = 58,
	EVA8_AUTO = 50,
};
enum  HelmetID {
	HELMET_LV0,
	HELMET_LV1,
	HELMET_LV2,
	HELMET_LV3,
	HELMET_LV4,
};
enum  ArmorID {
	BODY_ARMOR_LV0,
	BODY_ARMOR_LV1,
	BODY_ARMOR_LV2,
	BODY_ARMOR_LV3,
	BODY_ARMOR_LV4,
};
class AxisAlignedBox
{
public:
	D3DXVECTOR4 Min;
	D3DXVECTOR4 Max;
};
```

`apex/Render.cpp`:

```cpp
#include "Render.h"

Renderer* Renderer::m_pInstance;
Renderer::Renderer()
{
}

Renderer::~Renderer()
{
}

void Renderer::DrawHorBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2)
{
	if (Health <= 0)
		Health = 1;
	if (MaxHealth < Health)
		MaxHealth = 100;

	int size = (w * Health / (MaxHealth / 100)) / 100;
	DrawBox(x, y, w, h,  1.f, 0.f, 0.f, 0.f, 1.f,false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, 1.f, pasteColorA(color2),true);

	if (size == w)
		DrawBox(x + 1, y + 1, size - 2, h - 2, 1.f, pasteColorA(color1),true);
	else
		DrawBox(x + 1, y + 1, size, h - 2, 1.f, pasteColorA(color1), true);
}

void Renderer::DrawVerBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2)
{
	if (Health <= 0)
		Health = 1;

	if (MaxHealth < Health)
		MaxHealth = 100;
	int size = (h * Health / (MaxHealth / 100)) / 100;

	DrawBox(x, y, w, h, 1.f,0.f, 0.f, 0.f, 1.f, false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, 1.f, pasteColorA(color2),true);

	if (size == h)
		DrawBox(x + 1, y + 1 + h - size, w - 2, size - 2, 1.f, pasteColorA(color1), true);
	else
		DrawBox(x + 1, y + 1 + h - size, w - 2, size, 1.f, pasteColorA(color1), true);
}
void Renderer::DrawOutlineBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness)
{
	DrawBox(x, y, w, h, thickness,0.f, 0.f, 0.f, 1.f, false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, thickness, pasteColorA(color), false);
	DrawBox(x + 2, y + 2, w - 4, h - 4, thickness,0.f, 0.f, 0.f, 1.f,false);
}

void Renderer::DrawCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness)
{
	int iw = w / 4;
	int ih = h / 4;
	// top
	DrawLine(x, y, x + iw, y, thickness, pasteColorA(color));					// left
	DrawLine(x + w - iw, y, x + w, y, thickness, pasteColorA(color));			// right
	DrawLine(x, y, x, y + ih, thickness, pasteColorA(color));					// top left
	DrawLine(x + w - 1, y, x + w - 1, y + ih, thickness, pasteColorA(color));	// top right
														// bottom
	DrawLine(x, y + h, x + iw, y + h, thickness, pasteColorA(color));			// left
	DrawLine(x + w - iw, y + h, x + w, y + h, thickness, pasteColorA(color));	// right
	DrawLine(x, y + h - ih, x, y + h, thickness, pasteColorA(color));			// bottom left
	DrawLine(x + w - 1, y + h - ih, x + w - 1, y + h, thickness, pasteColorA(color));	// bottom right
}

void Renderer::DrawOutlineCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness)
{
	int iw = w / 4;
	int ih = h / 4;

	DrawCoalBox(x, y, w, h, D3DXCOLOR(0.f, 0.f, 0.f, 1.f));

	// top left
	DrawLine(x + 1, y + 1, x + iw, y + 1, thickness, pasteColorA(color));
	DrawLine(x + iw, y, x + iw, y + 2, thickness,0.f, 0.f, 0.f, 1.f);
	DrawLine(x + 1, y + 1, x + 1, y + ih, 1.f, pasteColorA(color));
	DrawLine(x, y + ih, x + 2, y + ih, thickness,0.f, 0.f, 0.f, 1.f);

	// top right
	DrawLine(x + w - iw, y + 1, x + w - 1, y + 1, thickness, pasteColorA(color));
	DrawLine(x + w - iw - 1, y, x + w - iw, y + 2, thickness,0.f, 0.f, 0.f, 1.f);
	DrawLine(x + w - 2, y + 1, x + w - 2, y + ih, thickness, pasteColorA(color));
	DrawLine(x + w - 2, y + ih, x + w, y + ih, thickness, 0.f, 0.f, 0.f, 1.f);

	// bottom left
	DrawLine(x + 1, y + h - ih, x + 1, y + h, thickness, pasteColorA(color));
	DrawLine(x, y + h - ih - 1, x + 2, y + h - ih - 1, thickness, 0.f, 0.f, 0.f, 1.f);
	DrawLine(x + 1, y + h - 1, x + iw, y + h - 1, thickness, pasteColorA(color));
	DrawLine(x + iw, y + h - 1, x + iw, y + h + 1, thickness,0.f, 0.f, 0.f, 1.f);

	// bottom right
	DrawLine(x + w - iw, y + h - 1, x + w - 1, y + h - 1, thickness, pasteColorA(color));
	DrawLine(x + w - iw - 1, y + h - 1, x + w - iw, y + h + 1, thickness, 0.f, 0.f, 0.f, 1.f);
	DrawLine(x + w - 2, y + h - ih, x + w - 2, y + h, thickness, pasteColorA(color));
	DrawLine(x + w - 2, y + h - ih - 1, x + w, y + h - ih - 1, thickness,0.f, 0.f, 0.f, 1.f);

	this->DrawCoalBox(x + 2, y + 2, w - 4, h - 4, D3DXCOLOR(0.f, 0.f, 0.f, 1.f));
}

void Renderer::DrawWindow(int x, int y, int w, int h, D3DXCOLOR Border, D3DXCOLOR Background)
{
	DrawBox(x, y, w, h, 1.f, pasteColorA(Border),false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, 1.f,pasteColorA(Background),true);
}

void Renderer::DrawCrosshair(CrosshairStyle style, float x, float y, float size, float stroke, D3DXCOLOR color)
{
	if (style == CrosshairStyle::Dot)
	{
		DrawCircle(x, y, size,1.f, pasteColorA(color),true);
	}
	else if (style == CrosshairStyle::Plus)
	{
		DrawLine(x - size, y, x + size, y, stroke, pasteColorA(color));
		DrawLine(x, y - size, x, y + size, stroke, pasteColorA(color));
	}
	else if (style == CrosshairStyle::Cross)
	{
		DrawLine(x - size, y - size, x + size, y + size, stroke, pasteColorA(color));
		DrawLine(x + size, y - size, x - size, y + size, stroke, pasteColorA(color));
	}
	else if (style == CrosshairStyle::Gap)
	{
		DrawLine(x - size - stroke, y, x - stroke, y, stroke, pasteColorA(color));
		DrawLine(x + size + stroke, y, x + stroke, y, stroke, pasteColorA(color));
		DrawLine(x, y - size - stroke, x, y - stroke, stroke, pasteColorA(color));
		DrawLine(x, y + size + stroke, x, y + stroke, stroke, pasteColorA(color));
	}
	else if (style == CrosshairStyle::Diagonal)
	{
		DrawLine(x - size, y - size, x + size, y + size, stroke, pasteColorA(color));
		DrawLine(x + size, y - size, x - size, y + size, stroke, pasteColorA(color));
	}

}

Renderer* Renderer::GetInstance()
{
	if (!m_pInstance)
		m_pInstance = new Renderer();

	return m_pInstance;
}
```

`apex/Render.h`:

```h
#pragma once
#include "Includes.h"
#include "DirectOverlay.h"

class Renderer
{
public:
	static Renderer* GetInstance();
private:
	Renderer();
	~Renderer();
public:
	enum CrosshairStyle
	{
		Dot,
		Plus,
		Cross,
		Gap,
		Diagonal,
	};

	void DrawHorBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2);
	void DrawVerBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2);
	void DrawOutlineBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness = 1.0f);
	void DrawCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness = 1.0f);
	void DrawOutlineCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness = 1.0f);
	void DrawWindow(int x, int y, int w, int h, D3DXCOLOR Border, D3DXCOLOR Background);

	void DrawCrosshair(CrosshairStyle style, float x, float y, float size, float stroke, D3DXCOLOR color);
private:
	static Renderer* m_pInstance;
};
```

`apex/SDK.h`:

```h
#pragma once
#include "offsets.h"
#pragma warning(disable:4996)
static int S_width = 1920, S_height = 1080;
static DWORD_PTR base = 0;
float Distance(D3DXVECTOR3 EntityPos, D3DXVECTOR3 PlayerPos);
double GetCrossDistance(double x1, double y1, double x2, double y2);
class Inputs {
private:
	static DWORD SendScanCode(WORD scan, BOOL up)
	{
		INPUT inp = { 0 };
		inp.type = INPUT_KEYBOARD;
		inp.ki.wScan = scan;
		inp.ki.dwFlags = KEYEVENTF_SCANCODE | (up ? KEYEVENTF_KEYUP : 0);
		return SendInput(1, &inp, sizeof(inp)) ? NO_ERROR : GetLastError();
	}
public:
	static bool mouse_move(int x, int y)
	{
		INPUT input;
		input.type = INPUT_MOUSE;
		input.mi.mouseData = 0;
		input.mi.time = 0;
		input.mi.dx = x;
		input.mi.dy = y;
		input.mi.dwFlags = MOUSEEVENTF_MOVE;
		SendInput(1, &input, sizeof(input));
		return true;
	}
	static DWORD SendVirtualKey(UINT vk, BOOL up)
	{
		UINT scan = MapVirtualKey(vk, MAPVK_VK_TO_VSC);
		return scan ? SendScanCode(scan, up) : ERROR_NO_UNICODE_TRANSLATION;
	}
	bool static keydown(int key)
	{
		return (GetAsyncKeyState(key) & 0x8000) != 0;
	}
};

class Player {
private:

public:
	Player() {}
	Player(DWORD_PTR _ptr) {
		this->ptr = _ptr;
		if (!rpm.IsValid(this->ptr)) return;
		unsigned long long pBoneArray = rpm.read<DWORD_PTR>(ptr + m_entity_bones);
		if (!rpm.IsValid(pBoneArray)) return;
		DWORD_PTR latestPrimaryWeapons = rpm.read<DWORD_PTR>(ptr + 0x1944) & 0xFFFF;
		DWORD_PTR listPrimaryWeapons = rpm.read<DWORD_PTR>(base + m_cl_entitylist + (latestPrimaryWeapons * 0x20));

		this->Flags = rpm.read<INT>(this->ptr + 0x0098);
		this->helmetType = rpm.read<INT>(this->ptr + 0x410c);
		this->armorType = rpm.read<INT>(this->ptr + 0x4110);
		this->weaponNameIndex = rpm.read<int>(listPrimaryWeapons + 0x16EC);
		this->Team = rpm.read<INT>(ptr + m_entity_team_num);
		this->Health = rpm.read<INT>(ptr + m_player_health);
		this->ShieldHealth = rpm.read<INT>(ptr + m_shieldHealth);
		this->ShieldHealthMax = rpm.read<INT>(ptr + m_shieldHealthMax);
		this->HealthMax = rpm.read<INT>(ptr + m_player_max_health);
		this->origin = rpm.read<D3DXVECTOR3>(ptr + m_entity_origin); 
		this->IsDowned = rpm.read<INT>(ptr + m_player_bleedout_state);

		Head.x = rpm.read<float>(pBoneArray + 0xCC + (BoneId::head * 0x30)) + origin.x;
		Head.y = rpm.read<float>(pBoneArray + 0xDC + (BoneId::head * 0x30)) + origin.y;
		Head.z = rpm.read<float>(pBoneArray + 0xEC + (BoneId::head * 0x30)) + origin.z;

	}
	DWORD_PTR ptr = 0x0;
	INT Flags = 0;
	INT helmetType = 0;
	INT armorType = 0;
	INT Health = 0;
	INT HealthMax = 0;
	INT ShieldHealth = 0;
	INT ShieldHealthMax = 0;
	INT Team = 0;
	D3DXVECTOR3 origin = D3DXVECTOR3();
	D3DXVECTOR3 Head = D3DXVECTOR3();
	FLOAT Distance = 0;
	bool IsDowned = 0;
	int weaponNameIndex = 0;
	bool GetEntityBonePosition(uint32_t BoneId, D3DXVECTOR3& Out)
	{
		unsigned long long pBoneArray = rpm.read<DWORD_PTR>(ptr + m_entity_bones);
		if (!rpm.IsValid(pBoneArray)) return false;

		Out.x = rpm.read<float>(pBoneArray + 0xCC + (BoneId * 0x30)) + origin.x;
		Out.y = rpm.read<float>(pBoneArray + 0xDC + (BoneId * 0x30)) + origin.y;
		Out.z = rpm.read<float>(pBoneArray + 0xEC + (BoneId * 0x30)) + origin.z;
		return true;
	}

	BOOL IsValid() {
		if ((this->origin.x != NULL) &&
			(this->Team != 0) &&
			(this->Health > NULL) &&
			(this->ptr != NULL)) return true;
		return false;
	}
};

class Manager {
private:
	D3DMATRIX  vMatrix;
public:
	Player LocalPlayer = NULL;
	std::vector<Player> Players = std::vector<Player>();
	Player ClosestVisibleEnemy = NULL;
	Player ClosestCrosshairEnemy = NULL;
	INT Total = 0;

	Manager(int width, int height) {
		S_width = width;
		S_height = height;
		DWORD_PTR  ViewRender = rpm.read<DWORD_PTR>(base + m_view_render);
		if (!rpm.IsValid(ViewRender)) return;
		DWORD_PTR View_matrix = rpm.read<DWORD_PTR>(ViewRender + m_view_matrix);
		if (!rpm.IsValid(View_matrix)) return;
		vMatrix = rpm.read<D3DMATRIX>(View_matrix);

		this->LocalPlayer = Player(rpm.read<DWORD_PTR>(base + m_LocalPlayer));
		for (size_t i = 0; i < 64; i++) {
			Player player(rpm.read<DWORD_PTR>(base + m_cl_entitylist + (i * 0x20)));

			if (player.ptr != 0);// break;
			if (player.IsValid() && player.ptr != this->LocalPlayer.ptr) {
				player.Distance = Distance(this->LocalPlayer.origin,player.origin);
				this->Players.push_back(player);
			}
		}

		float closestcrosshair = FLT_MAX;
		for (size_t i = 0; i < this->Players.size(); i++) {
			if (!this->LocalPlayer.IsDowned) {
				D3DXVECTOR3 out;
				if (WorldToScreen(this->Players[i].origin, out)) {
					float crossdis = GetCrossDistance(out.x, out.y, S_width / 2, S_height / 2);
					if ((crossdis < closestcrosshair)) {
						if (this->Players[i].Team != this->LocalPlayer.Team && this->Players[i].Distance < 125) {
							if (this->Players[i].IsDowned) {
								if (settings::aimknocked)
									ClosestCrosshairEnemy = this->Players[i];
							}
							else {
								ClosestCrosshairEnemy = this->Players[i];
							}
							closestcrosshair = crossdis;
						}
					}
				}
			}
		}
		float closestdis = FLT_MAX;
		for (int i = 0; i < this->Players.size(); i++) {
				if ((this->Players[i].Distance < closestdis)) {
					if (this->Players[i].Team != this->LocalPlayer.Team) {
						ClosestVisibleEnemy = this->Players[i];
						closestdis = this->Players[i].Distance;
					}
				}
		}

		for (int i = 0; i < this->Players.size(); i++) {
			Total = this->Players.size();

		}
	}

	bool WorldToScreen(D3DXVECTOR3& vIn, D3DXVECTOR3& vOut)
	{

		vOut.x = vMatrix.m[0][0] * vIn.x + vMatrix.m[0][1] * vIn.y + vMatrix.m[0][2] * vIn.z + vMatrix.m[0][3];
		vOut.y = vMatrix.m[1][0] * vIn.x + vMatrix.m[1][1] * vIn.y + vMatrix.m[1][2] * vIn.z + vMatrix.m[1][3];

		float w = vMatrix.m[3][0] * vIn.x + vMatrix.m[3][1] * vIn.y + vMatrix.m[3][2] * vIn.z + vMatrix.m[3][3];

		if (w < 0.65f)
			return false;

		float invw = 1.0f / w;

		vOut.x *= invw;
		vOut.y *= invw;

		float x = S_width / 2;
		float y = S_height / 2;

		x += 0.5 * vOut.x * S_width + 0.5;
		y -= 0.5 * vOut.y * S_height + 0.5;

		vOut.x = x;
		vOut.y = y;

		return true;
	}


};
float Distance3D(D3DXVECTOR3  v1, D3DXVECTOR3 v2)
{
	float x_d = (v2.x - v1.x);
	float y_d = (v2.y - v1.y);
	float z_d = (v2.z - v1.z);
	return sqrt((x_d * x_d) + (y_d * y_d) + (z_d * z_d));
}
double GetCrossDistance(double x1, double y1, double x2, double y2)
{
	return sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2));
}
void AimAtPosV2(float x, float y, float speed,bool smooth)
{
	int ScreenCenterX = S_width / 2, ScreenCenterY = S_height / 2;

	float AimSpeed = (float)speed;
	float TargetX = 0;
	float TargetY = 0;

	//X Axis
	if (x != 0)
	{
		if (x > ScreenCenterX)
		{
			TargetX = -(ScreenCenterX - x);
			TargetX /= AimSpeed;
			TargetX += settings::aimlock;
			if (TargetX + ScreenCenterX > ScreenCenterX * 2) TargetX = 0;
		}

		if (x < ScreenCenterX)
		{
			TargetX = x - ScreenCenterX;
			TargetX /= AimSpeed;
			TargetX -= settings::aimlock;
			if (TargetX + ScreenCenterX < 0) TargetX = 0;
		}
	}

	//Y Axis

	if (y != 0)
	{
		if (y > ScreenCenterY)
		{
			TargetY = -(ScreenCenterY - y);
			TargetY /= AimSpeed;
			TargetY += settings::aimlock;
			if (TargetY + ScreenCenterY > ScreenCenterY * 2) TargetY = 0;
		}

		if (y < ScreenCenterY)
		{
			TargetY = y - ScreenCenterY;
			TargetY /= AimSpeed;
			TargetY -= settings::aimlock;
			if (TargetY + ScreenCenterY < 0) TargetY = 0;
		}
	}

	if (!smooth)
	{
		Inputs::mouse_move((int)TargetX, (int)(TargetY));
		return;
	}

	TargetX /= 10;
	TargetY /= 10;

	if (abs(TargetX) < 1)
	{
		if (TargetX > 0)
		{
			TargetX = 1;
		}
		if (TargetX < 0)
		{
			TargetX = -1;
		}
	}
	if (abs(TargetY) < 1)
	{
		if (TargetY > 0)
		{
			TargetY = 1;
		}
		if (TargetY < 0)
		{
			TargetY = -1;
		}
	}
	Inputs::mouse_move((int)TargetX, (int)(TargetY));

}
D3DXVECTOR3 CalcSoldierFuturePos(D3DXVECTOR3 InVec)
{
	Manager gm(S_width, S_height);
	D3DXVECTOR3 NewPos, OutPos;
	if (gm.WorldToScreen(InVec, NewPos)) {
		OutPos.x = NewPos.x;
		OutPos.y = NewPos.y;
		OutPos.z = NewPos.z;
	}
	else
	{
		OutPos.x = 0;
		OutPos.y = 0;
		OutPos.z = 0;
	}
	return OutPos;
}
float Distance(D3DXVECTOR3 EntityPos, D3DXVECTOR3 PlayerPos)
{
	float Dist = sqrt((PlayerPos.x - EntityPos.x) * (PlayerPos.x - EntityPos.x)
		+ (PlayerPos.y - EntityPos.y) * (PlayerPos.y - EntityPos.y)
		+ (PlayerPos.z - EntityPos.z) * (PlayerPos.z - EntityPos.z));
	return Dist * 0.01905f;
}
char* GetHelmetType(Player pPlayer)
{
	int HelmetId = pPlayer.helmetType;
	switch (HelmetId)
	{
		case (int)(HelmetID::HELMET_LV0) :
			return "Helmet LV0";
			break;
		case (int)(HelmetID::HELMET_LV1) :
			return "Helmet LV1";
			break;
		case (int)(HelmetID::HELMET_LV2) :
			return "Helmet LV2";
			break;
		case (int)(HelmetID::HELMET_LV3) :
			return "Helmet LV3";
			break;
		case (int)(HelmetID::HELMET_LV4) :
			return "Helmet LV4";
			break;
	}
	return "NULL";
}
char* GetArmorType(Player pPlayer)
{
	int ArmorId = pPlayer.armorType;
	switch (ArmorId)
	{
		case (int)(ArmorID::BODY_ARMOR_LV0) :
			return "Armor LV0";
			break;
		case (int)(ArmorID::BODY_ARMOR_LV1) :
			return "Armor LV1";
			break;
		case (int)(ArmorID::BODY_ARMOR_LV2) :
			return "Armor LV2";
			break;
		case (int)(ArmorID::BODY_ARMOR_LV3) :
			return "Armor LV3";
			break;
		case (int)(ArmorID::BODY_ARMOR_LV4) :
			return "Armor LV4";
			break;
	}
	return "NULL";
}

char* GetGunName(Player pPlayer)
{
	int WeaponId = pPlayer.weaponNameIndex;
	switch (WeaponId)
	{
	case (int)(WeaponID::BARE_HANDS):
		return "HANDS";
		break;
	case (int)WeaponID::HAVOC:
		return "HAVOC";
		break;
	case (int)WeaponID::LSTAR:
		return "LSTAR";
		break;
	case (int)WeaponID::KRABER:
		return "KRABER";
		break;
	case (int)WeaponID::MASTIFF:
		return "MASTIFF";
		break;
	case (int)WeaponID::DEVOTION:
		return "DEVOTION";
		break;
	case (int)WeaponID::SENTINEL:
		return "SENTINEL";
		break;
	case (int)WeaponID::CHARGE_RIFLE:
		return "CHARGE_RIFLE";
		break;
	case (int)WeaponID::LONGBOW:
		return "LONGBOW";
		break;
	case (int)WeaponID::TRIPLE_TAKE:
		return "TRIPLE_TAKE";
		break;
	case (int)WeaponID::WINGMAN:
		return "WINGMAN";
		break;
	case (int)WeaponID::SPITFIRE:
		return "SPITFIRE";
		break;
	case (int)WeaponID::PROWLER:
		return "PROWLER";
		break;
	case (int)WeaponID::HEMLOK:
		return "HEMLOK";
		break;
	case (int)WeaponID::FLATLINE:
		return "FLATLINE";
		break;
	case (int)WeaponID::RE45:
		return "RE45";
		break;
	case (int)WeaponID::P2020:
		return "P2020";
		break;
	case (int)WeaponID::R301:
		return "R301";
		break;
	case (int)WeaponID::R99:
		return "R99";
		break;
	case (int)WeaponID::ALTERNATOR:
		return "ALTERNATOR";
		break;
	case (int)WeaponID::G7_SCOUT:
		return "G7_SCOUT";
		break;
	case (int)WeaponID::MOZAMBIQUE:
		return "MOZAMBIQUE";
		break;
	case (int)WeaponID::PEACEKEEPER:
		return "PEACEKEEPER";
		break;
	case (int)WeaponID::EVA8_AUTO:
		return "EVA8_AUTO";
		break;
	
	}
	return "NULL";
}
char* GetGunType(Player pPlayer)
{
	int WeaponId = pPlayer.weaponNameIndex;
	switch (WeaponId)
	{
		case (int)WeaponID::BARE_HANDS:
			return "HANDS";
			break;
		case (int)WeaponID::KRABER:
		case (int)WeaponID::SENTINEL:
		case (int)WeaponID::LONGBOW:
		case (int)WeaponID::TRIPLE_TAKE:
		case (int)WeaponID::CHARGE_RIFLE:
			return "SNIPER";
			break;
		case (int)WeaponID::HEMLOK:
		case (int)WeaponID::FLATLINE:
		case (int)WeaponID::G7_SCOUT:
		case (int)WeaponID::R301:
		case (int)WeaponID::HAVOC:
			return "AR";
			break;
		case (int)WeaponID::DEVOTION:
		case (int)WeaponID::SPITFIRE:
		case (int)WeaponID::LSTAR:
			return "LMG";
			break;
		case (int)WeaponID::PROWLER:
		case (int)WeaponID::R99:
		case (int)WeaponID::ALTERNATOR:
			return "SMG";
			break;
		case (int)WeaponID::MASTIFF:
		case (int)WeaponID::EVA8_AUTO:
		case (int)WeaponID::PEACEKEEPER:
		case (int)WeaponID::MOZAMBIQUE:
			return "SHOTGUN";
			break;
		case (int)WeaponID::WINGMAN:
		case (int)WeaponID::RE45:
		case (int)WeaponID::P2020:
			return "PISTOL";
			break;

	}
	return "NULL";
}
bool IsPistol(Player pPlayer)
{
	int WeaponId = pPlayer.weaponNameIndex;
	if (WeaponId == NULL) return false;

	if (WeaponId == (int)WeaponID::RE45
		|| WeaponId == (int)WeaponID::P2020
		|| WeaponId == (int)WeaponID::WINGMAN)
		return true;
	else
		return false;
}
bool IsSniper(Player pPlayer)
{
	int WeaponId = pPlayer.weaponNameIndex;
	if (WeaponId == NULL) return false;

	if (WeaponId == (int)WeaponID::KRABER
		||WeaponId == (int)WeaponID::SENTINEL 
		||WeaponId == (int)WeaponID::LONGBOW 
		||WeaponId == (int)WeaponID::TRIPLE_TAKE
		||WeaponId == (int)WeaponID::CHARGE_RIFLE)
		return true;
	else
		return false;
}

bool IsLMG(Player pPlayer)
{
	int WeaponId = pPlayer.weaponNameIndex;
	if (WeaponId == NULL) return false;

	if (WeaponId == (int)WeaponID::DEVOTION || WeaponId == (int)WeaponID::SPITFIRE || WeaponId == (int)WeaponID::LSTAR)
		return true;
	else
		return false;
}
bool IsSmg(Player pPlayer)
{
	int WeaponId = pPlayer.weaponNameIndex;
	if (WeaponId == NULL) return false;

	if ( WeaponId == (int)WeaponID::PROWLER
		|| WeaponId == (int)WeaponID::R99
		|| WeaponId == (int)WeaponID::ALTERNATOR)
		return true;
	else
		return false;
}
bool IsShotgun(Player pPlayer)
{
	int WeaponId = pPlayer.weaponNameIndex;
	if (WeaponId == NULL) return false;

	if (WeaponId == (int)WeaponID::MASTIFF
		|| WeaponId == (int)WeaponID::PEACEKEEPER 
		|| WeaponId == (int)WeaponID::EVA8_AUTO
		|| WeaponId == (int)WeaponID::MOZAMBIQUE)
		return true;
	else
		return false;
}
bool IsAR(Player pPlayer)
{
	int WeaponId = pPlayer.weaponNameIndex;
	if (WeaponId == NULL) return false;

	if (WeaponId == (int)WeaponID::FLATLINE
		|| WeaponId == (int)WeaponID::G7_SCOUT
		|| WeaponId == (int)WeaponID::R301
		|| WeaponId == (int)WeaponID::HAVOC
		|| WeaponId == (int)WeaponID::HEMLOK)	
		return true;
	else
		return false;
}

```

`apex/Settings.h`:

```h
#pragma once
#include "Includes.h"
namespace settings {
	D3DXCOLOR FriendBox = D3DXCOLOR(0, 0, 1, 1);
	D3DXCOLOR EnemyBOX = D3DXCOLOR(1, 0, 0, 1);

	D3DXCOLOR FriendLine = D3DXCOLOR(0, 0, 1, 1);
	D3DXCOLOR EnemyLine = D3DXCOLOR(1, 0, 0, 1);

	D3DXCOLOR FriendFillbox = D3DXCOLOR(0, 0, 1, 1);
	D3DXCOLOR EnemyFillbox = D3DXCOLOR(1, 0, 0, 1);

	D3DXCOLOR FriendKnocked = D3DXCOLOR(0, 1, 1, 1);
	D3DXCOLOR EnemyKnocked = D3DXCOLOR(1, 1, 1, 1);

	D3DXCOLOR Closed = D3DXCOLOR(1, 1, 0, 1);

	bool teamBoxes = false;
	bool enemyBoxes = true;
	bool teamDistance = false;
	bool enemyDistance = true;
	bool teamInfo = false;
	bool enemyInfo = true;
	bool teamWeaponName = false;
	bool enemyWeaponName = true;
	bool teamSnaplines = false;
	bool enemySnaplines = true;
	bool teamHealth = false;
	bool enemyHealth = true;
	bool teamShieldHealth = false;
	bool enemyShieldHealth = true;
	bool teamFilledbox = false;
	bool enemyFilledbox = false;
	bool teamKnocked = false;
	bool enemyKnocked = true;

	bool aimbot = true;
	bool autolock = false;
	bool aimknocked = false;
	int aimbothitbox = 2;
	float aimspeed = 30;
	float aimbotfov = 9;
	float aimlock = 0.6;
	bool aimspot = false;
	float aimspotdis = 25;
	float aimspotspeed = 14;
	float aimspotfov = 16;
	bool aimbotdrawfov = true;
	bool aimbotdrawhitbox = true;

	int boxtype = 0;
	int healthbartype = 0;
	int shildbartype = 0;
	int PlayerWeapontype = 0;
	float playersdis = 250;
	bool esp_Outline = 1;

	bool c_enable = true;
	int crosshair = 6;
	float size = 0;
	float stroke = 0;

	float menux = 0;
	float menuy = 400;
}
```

`apex/Source.cpp`:

```cpp
#include "Menu.h"
#include "Settings.h"
#include "SDK.h"
#define checkSetting(teamval, enemyval) (((gm.LocalPlayer.Team == player.Team) && teamval) || ((gm.LocalPlayer.Team != player.Team) && enemyval))
LPCSTR FilePath = "./Settings.ini";
c_menu_framework* menu_framework = new c_menu_framework;
static class Text
{
public:
	std::string text;
	int side;
	int size;
	D3DXCOLOR color;
	Text(std::string text, int side, int size, D3DXCOLOR color) : text(text), side(side), size(size), color(color) {}
};
void CoutOffset(LPCSTR name, DWORD offset)
{
	std::cout << "[" << name << "]" << " = 0x" << std::uppercase << std::hex << offset << std::endl;
}
void Coutfloat(LPCSTR name, float option)
{
	std::cout << "[" << name << "]" << " = " << std::dec << option << std::endl;
}

void Coutbool(LPCSTR name, int boolean)
{
	if (boolean == 1)
		std::cout << "[" << name << "]" << " = " << "ON" << std::endl;
	else
		std::cout << "[" << name << "]" << " = " << "OFF" << std::endl;
}
float ReadConfig(LPCSTR Option, bool Float)
{
	if (Float)
	{
		char cfg[10];
		GetPrivateProfileString(TEXT("Config"), Option, TEXT("0"), cfg, 10, FilePath);
		float opt = atof(cfg);
		return opt;
	}
	else
		return GetPrivateProfileInt(TEXT("Config"), Option, NULL, FilePath);
}
DWORD ReadInt(LPCTSTR Offsetname)
{
	DWORD Offset = GetPrivateProfileInt(TEXT("Offsets"), Offsetname, NULL, FilePath);
	CoutOffset(Offsetname, Offset);
	return Offset;
}
void ReadSettings()
{
	settings::aimbot = ReadConfig(TEXT("Active"), false);
	settings::autolock = ReadConfig(TEXT("AutoLock"), false);
	settings::aimknocked = ReadConfig(TEXT("AimKnocket"), false);
	settings::aimbothitbox = ReadConfig(TEXT("HitBox"), true);
	settings::aimspeed = ReadConfig(TEXT("AimSpeed"), true);
	settings::aimbotfov = ReadConfig(TEXT("Fov"), true);
	settings::aimlock = ReadConfig(TEXT("aimlock"), true);
	settings::aimspot = ReadConfig(TEXT("AimSpot"), false);
	settings::aimspotdis = ReadConfig(TEXT("AimSpotDis"), true);
	settings::aimspotfov = ReadConfig(TEXT("AimSpotFov"), true);
	settings::aimspotspeed = ReadConfig(TEXT("AimSpotSpeed"), true);

	settings::aimbotdrawfov = ReadConfig(TEXT("DrawFov"), false);
	settings::aimbotdrawhitbox = ReadConfig(TEXT("DrawHitBox"), false);

	settings::teamBoxes = ReadConfig(TEXT("TeamBox"), false);
	settings::teamDistance = ReadConfig(TEXT("TeamDistance"), false);
	settings::teamSnaplines = ReadConfig(TEXT("TeamSnaplines"), false);
	settings::teamHealth = ReadConfig(TEXT("TeamHealth"), false);
	settings::teamShieldHealth = ReadConfig(TEXT("ShieldHealth"), false);
	settings::teamFilledbox = ReadConfig(TEXT("TeamFilledbox"), false);
	settings::teamKnocked = ReadConfig(TEXT("TeamKnocked"), false);

	settings::enemyBoxes = ReadConfig(TEXT("EnemyBoxes"), false);
	settings::enemyDistance = ReadConfig(TEXT("EnemyDistance"), false);
	settings::enemySnaplines = ReadConfig(TEXT("EnemySnaplines"), false);
	settings::enemyHealth = ReadConfig(TEXT("EnemyHealth"), false);
	settings::enemyShieldHealth = ReadConfig(TEXT("EnemyShieldHealth"), false);
	settings::enemyFilledbox = ReadConfig(TEXT("EnemyFilledbox"), false);
	settings::enemyKnocked = ReadConfig(TEXT("EnemyKnocked"), false);

	settings::c_enable = ReadConfig(TEXT("CrosshairEnable"), false);
	settings::crosshair = ReadConfig(TEXT("CrosshairStyle"), true);
	settings::size = ReadConfig(TEXT("Size"), true);
	settings::stroke = ReadConfig(TEXT("Stroke"), true);

	settings::boxtype = ReadConfig(TEXT("BoxType"), true);
	settings::healthbartype = ReadConfig(TEXT("HealthbarType"), true);
	settings::playersdis = ReadConfig(TEXT("PlayersDis"), true);

	settings::menux = ReadConfig(TEXT("MenuX"), true);
	settings::menuy = ReadConfig(TEXT("MenuY"), true);
	std::cout <<  std::endl << std::endl;
	std::cout << "AIMBOT" << std::endl << std::endl;
	Coutbool(TEXT("Active"), settings::aimbot);
	Coutbool(TEXT("AutoLock"), settings::autolock);
	Coutbool(TEXT("AimKnocket"), settings::aimknocked);
	Coutfloat(TEXT("HitBox"), settings::aimbothitbox);
	Coutfloat(TEXT("AimSpeed"), settings::aimspeed);
	Coutfloat(TEXT("Fov"), settings::aimbotfov);
	Coutfloat(TEXT("Lock"), settings::aimlock);
	Coutbool(TEXT("AimSpot"), settings::aimspot);
	Coutfloat(TEXT("AimSpotDis"), settings::aimspotdis);
	Coutfloat(TEXT("AimSpotFov"), settings::aimspotfov);
	Coutfloat(TEXT("AimSpotSpeed"), settings::aimspotspeed);
	Coutbool(TEXT("DrawFov"), settings::aimbotdrawfov);
	Coutbool(TEXT("DrawHitBox"), settings::aimbotdrawhitbox);
	std::cout << std::endl << std::endl;
	std::cout << "TEAM ESP" << std::endl << std::endl;
	Coutbool(TEXT("Box"), settings::teamBoxes);
	Coutbool(TEXT("Distance"), settings::teamDistance);
	Coutbool(TEXT("Snaplines"), settings::teamSnaplines);
	Coutbool(TEXT("Health"), settings::teamHealth);
	Coutbool(TEXT("ShieldHealth"), settings::teamShieldHealth);
	Coutbool(TEXT("Filledbox"), settings::teamFilledbox);
	Coutbool(TEXT("Knocked"), settings::teamKnocked);

	std::cout << std::endl << std::endl;
	std::cout << "ENEMY ESP" << std::endl << std::endl;
	Coutbool(TEXT("Box"), settings::enemyBoxes);
	Coutbool(TEXT("Distance"), settings::enemyDistance);
	Coutbool(TEXT("Snaplines"), settings::enemySnaplines);
	Coutbool(TEXT("Health"), settings::enemyHealth);
	Coutbool(TEXT("ShieldHealth"), settings::enemyShieldHealth);
	Coutbool(TEXT("Filledbox"), settings::enemyFilledbox);
	Coutbool(TEXT("Filledbox"), settings::enemyKnocked);
	std::cout << std::endl << std::endl;
	std::cout << "CROSSHAIR" << std::endl << std::endl;
	Coutbool(TEXT("CrosshairEnable"), settings::c_enable);
	Coutfloat(TEXT("CrosshairStyle"), settings::crosshair);
	Coutfloat(TEXT("Size"), settings::size);
	Coutfloat(TEXT("stroke"), settings::stroke);
	std::cout << std::endl << std::endl;
	std::cout << "SETTINGS ESP" << std::endl << std::endl;
	Coutfloat(TEXT("BoxType"), settings::boxtype);
	Coutfloat(TEXT("HealthbarType"), settings::healthbartype);
	Coutfloat(TEXT("PlayersDis"), settings::healthbartype);
	std::cout << std::endl << std::endl;
	std::cout << "MENU" << std::endl << std::endl;
	Coutfloat(TEXT("MenuX"), settings::menux);
	Coutfloat(TEXT("MenuY"), settings::menuy);
	std::cout << std::endl << std::endl;
}	


void Crosshair()
{
	switch (settings::crosshair)
	{
	case Renderer::CrosshairStyle::Dot:
		Renderer::GetInstance()->DrawCrosshair(Renderer::CrosshairStyle::Dot, S_width / 2, S_height / 2, settings::size, settings::stroke, D3DXCOLOR(0.f, 1.f, 0.f, 1.f));
		break;
	case Renderer::CrosshairStyle::Plus:
		Renderer::GetInstance()->DrawCrosshair(Renderer::CrosshairStyle::Plus, S_width / 2, S_height / 2, settings::size, settings::stroke, D3DXCOLOR(0.f, 1.f, 0.f, 1.f));
		break;
	case Renderer::CrosshairStyle::Cross:
		Renderer::GetInstance()->DrawCrosshair(Renderer::CrosshairStyle::Cross, S_width / 2, S_height / 2, settings::size, settings::stroke, D3DXCOLOR(0.f, 1.f, 0.f, 1.f));
		break;
	case Renderer::CrosshairStyle::Gap:
		Renderer::GetInstance()->DrawCrosshair(Renderer::CrosshairStyle::Gap, S_width / 2, S_height / 2, settings::size, settings::stroke, D3DXCOLOR(0.f, 1.f, 0.f, 1.f));
		break;
	case Renderer::CrosshairStyle::Diagonal:
		Renderer::GetInstance()->DrawCrosshair(Renderer::CrosshairStyle::Diagonal, S_width / 2, S_height / 2, settings::size, settings::stroke, D3DXCOLOR(0.f, 1.f, 0.f, 1.f));
		break;
	default:
		break;
	}
}

void drawLoop(int width, int height)
{
	float aimspeed = settings::aimspeed;
	float aimfov = settings::aimbotfov;
	D3DXCOLOR aimcolor = D3DXCOLOR(1,1,1,1);

	menu_framework->do_menu_controls();
	if(settings::c_enable)
	Crosshair();

	Manager gm(width, height);
	DrawString("Players " + std::to_string((int)gm.Total), 18, 10 , 10, 1.f, 0.f, 0.f, 1.f);

	for (Player& player : gm.Players) {
		D3DXVECTOR3 footLocation = player.origin;
		D3DXVECTOR3 headLocation = player.Head;
		D3DXVECTOR3 oheadLocation;
		D3DXVECTOR3 ofootLocation;
		D3DXCOLOR PlayerBox = D3DXCOLOR();
		D3DXCOLOR PlayerLine = D3DXCOLOR();
		D3DXCOLOR PlayerFillBox = D3DXCOLOR();
		D3DXCOLOR PlayerKnocked = D3DXCOLOR();

		if (player.Team == gm.LocalPlayer.Team) {
			PlayerBox = settings::FriendBox;
			PlayerLine = settings::FriendLine;
			PlayerFillBox = settings::FriendFillbox;
			PlayerKnocked = settings::FriendKnocked;
		}
		else {
			if (player.Distance < 80) {

				PlayerBox = settings::Closed;
				PlayerLine = settings::Closed;
				PlayerFillBox = settings::Closed;

			}
			else {
				PlayerBox = settings::EnemyBOX;
				PlayerLine = settings::EnemyLine;
				PlayerFillBox = settings::EnemyFillbox;
				PlayerKnocked = settings::EnemyKnocked;
			}
		}

		if (player.Team != gm.LocalPlayer.Team) {
			
			if (gm.ClosestVisibleEnemy.Distance < 80)
			{
				DrawBox((S_width / 2) - 30, 170, 220, 50, 1, 0, 0, 0, 0.5, true);
				DrawString("Enemy Closed " + std::to_string((int)gm.ClosestVisibleEnemy.Distance) + "m", 20, S_width / 2, 180, 1.f, 0.f, 0.f, 1.f);
			}
			if (settings::aimspot) {
				if (gm.ClosestVisibleEnemy.Distance < settings::aimspotdis)
				{
					aimspeed = settings::aimspotspeed;
					aimfov = settings::aimspotfov;
					aimcolor = D3DXCOLOR(1, 0, 0, 1);
				}
				else {
					aimspeed = settings::aimspeed;
					aimfov = settings::aimbotfov;
					aimcolor = D3DXCOLOR(1, 1, 1, 1);
				}
			}

		}
		if checkSetting(settings::teamKnocked, settings::enemyKnocked) {
			if (player.IsDowned)
			{
				PlayerBox = PlayerKnocked;
				PlayerLine = PlayerKnocked;
				PlayerFillBox = PlayerKnocked;
			}

		}
		if (player.Flags == 41) headLocation.y += 1.6;
		if (player.Flags == 43) headLocation.y += 1;

		if ((gm.WorldToScreen(footLocation, ofootLocation) && (gm.WorldToScreen(headLocation, oheadLocation)))) {
			float w2sHeight = Distance3D(ofootLocation, oheadLocation);
			float w2sWidth = w2sHeight;
			float heightoffset = Distance3D(ofootLocation, oheadLocation);
			float H = w2sHeight;
			float W = H / 2;
			float X = oheadLocation.x - W / 2;
			if (player.Flags == 41) w2sWidth /= 2;
			if (player.Flags == 43) w2sWidth /= 1.5;
			std::vector< Text > texts;
			if (player.Distance > settings::playersdis) continue;

			if checkSetting(settings::teamSnaplines, settings::enemySnaplines) {
				DrawLine(S_width / 2, 0, oheadLocation.x, oheadLocation.y, 1, pasteColorA(PlayerLine));
			}
			if checkSetting(settings::teamBoxes, settings::enemyBoxes) {
				if (settings::boxtype == 0)
				{
					if (!settings::esp_Outline)
						DrawBox(X, oheadLocation.y, W, H, 2.f, pasteColorA(PlayerBox), false);
					else if (settings::esp_Outline)
						Renderer::GetInstance()->DrawOutlineBox(X, oheadLocation.y, W, H, PlayerBox, 2.f);

				}
				else
				{
					if (!settings::esp_Outline)
						Renderer::GetInstance()->DrawCoalBox(X, oheadLocation.y, W, H, PlayerBox, 2.f);
					else if (settings::esp_Outline)
						Renderer::GetInstance()->DrawOutlineCoalBox(X, oheadLocation.y, W, H, PlayerBox, 2.f);

				}
			}
			if checkSetting(settings::teamFilledbox, settings::enemyFilledbox) {
				DrawBox(X, oheadLocation.y, W, H, 1, pasteColor(PlayerFillBox), 0.1, true);

			}
			if checkSetting(settings::teamHealth, settings::enemyHealth) {
				if(settings::healthbartype == 0)
					Renderer::GetInstance()->DrawHorBar(X, oheadLocation.y - 6, W, 4, (int)player.Health, (int)player.HealthMax, D3DXCOLOR(.48f, .98f, 0.f, 1.f), D3DXCOLOR(1.f, 0.f, 0.f, 1.f));
				else if(settings::healthbartype == 1)
					Renderer::GetInstance()->DrawVerBar(X - 6, oheadLocation.y, 4, H, (int)player.Health, (int)player.HealthMax, D3DXCOLOR(.48f, .98f, 0.f, 1.f), D3DXCOLOR(1.f, 0.f, 0.f, 1.f));
				else
					texts.push_back(Text("Health "+std::to_string((int)player.Health) + "%", 2, 11, D3DXCOLOR(.48f, .98f, 0.f, 1.f)));

			}
			if checkSetting(settings::teamShieldHealth, settings::enemyShieldHealth) {
				if (settings::shildbartype == 0) {
					if (player.ShieldHealth > 0)
						Renderer::GetInstance()->DrawHorBar(X, ofootLocation.y + 6, W, 4, player.ShieldHealth, player.ShieldHealthMax, D3DXCOLOR(1.f, 1.f, 1.f, 1.f), D3DXCOLOR(1.f, 0.f, 0.f, 1.f));
				}
				else if (settings::shildbartype == 1) {
					if (player.ShieldHealth > 0)
						Renderer::GetInstance()->DrawVerBar(X + W + 1, oheadLocation.y, 4, H, player.ShieldHealth, player.ShieldHealthMax,D3DXCOLOR(1.f, 1.f, 1.f, 1.f), D3DXCOLOR(1.f, 0.f, 0.f, 1.f));
				}
				else {
					if (player.ShieldHealth > 0)
						texts.push_back(Text("Shield " + std::to_string((int)player.ShieldHealth) + "%", 2, 11, D3DXCOLOR(1.f, 1.f, 1.f, 1.f)));
				}
			}
			if checkSetting(settings::teamInfo, settings::enemyInfo) {
				
				std::string status = "";
				D3DXCOLOR CHelmet = D3DXCOLOR(1, 1, 1, 1);
				D3DXCOLOR CArmor = D3DXCOLOR(1, 1, 1, 1);
				if (player.Flags == 49 || player.Flags == 0x4b)
					status = "Aiming";

				if (player.helmetType == 0)
					CHelmet = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
				else if(player.helmetType == 1)
					CHelmet = D3DXCOLOR(0.87f, 0.87f, 0.87f, 1.f);
				else if (player.helmetType == 2)
					CHelmet = D3DXCOLOR(0.f, 0.f, 1.f, 1.f);
				else if (player.helmetType == 3)
					CHelmet = D3DXCOLOR(0.65f, 0.03f, 0.83f, 1.f);
				else
					CHelmet = D3DXCOLOR(1.0f, 1.0f, 0.f, 1.f);

				if (player.armorType == 0)
					CArmor = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
				else if (player.armorType == 1)
					CArmor = D3DXCOLOR(0.87f, 0.87f, 0.87f, 1.f);
				else if (player.armorType == 2)
					CArmor = D3DXCOLOR(0.f, 0.f, 1.f, 1.f);
				else if (player.armorType == 3)
					CArmor = D3DXCOLOR(0.65f, 0.03f, 0.83f, 1.f);
				else
					CArmor = D3DXCOLOR(1.0f, 1.0f, 0.f, 1.f);


				texts.push_back(Text(GetHelmetType(player), 2, 11, CHelmet));
				texts.push_back(Text(GetArmorType(player), 2, 11, CArmor));
				texts.push_back(Text(status, 2, 11, D3DXCOLOR(1.f, 0.f, 0.f, 1.f)));

			}
			if checkSetting(settings::teamDistance, settings::enemyDistance) {

				texts.push_back(Text(std::to_string((int)player.Distance) + "m", 1, 9, D3DXCOLOR(1.f, 1.f, 1.f, 1.f)));
			}
			if checkSetting(settings::teamWeaponName, settings::enemyWeaponName) {
				if(settings::PlayerWeapontype ==0)
				texts.push_back(Text(GetGunName(player), 1, 9, D3DXCOLOR(0.f, 1.f, 0.f, 1.f)));
				else
				texts.push_back(Text(GetGunType(player), 1, 9, D3DXCOLOR(0.f, 1.f, 0.f, 1.f)));
			}
			int middle[3] = { ofootLocation.y,ofootLocation.y, ofootLocation.x - ofootLocation.y };
			int Top[3] = { oheadLocation.y,oheadLocation.y, oheadLocation.x - oheadLocation.y };
			for (auto text : texts)
			{
				int fontsize = text.size;
				float offset = (text.text.length() * fontsize) / 5;
				switch (text.side)
				{
				case 0:
					DrawString(text.text.c_str(), text.size, oheadLocation.x - offset, Top[1] - (heightoffset / 4) - fontsize, text.color.r, text.color.g, text.color.b);
					Top[1] -= fontsize;
					break;
				case 1:
					DrawString(text.text.c_str(), text.size, ofootLocation.x - offset, middle[1] + fontsize, text.color.r, text.color.g, text.color.b);
					middle[1] += fontsize;
					break;
				case 2:
					DrawString(text.text.c_str(), text.size, oheadLocation.x + (heightoffset / 4) + fontsize, Top[1] - fontsize, text.color.r, text.color.g, text.color.b);
					Top[1] += fontsize;
					break;
				}
			}

		}
	}
	if ((Inputs::keydown(VK_LBUTTON) || settings::autolock) && settings::aimbot)
	{

		D3DXVECTOR3 BONE = D3DXVECTOR3();
		std::vector<int> HitBoxesToScan{};
		switch (settings::aimbothitbox)
		{
		case 0:
			HitBoxesToScan.push_back(BoneId::head);
			break;
		case 1:
			HitBoxesToScan.push_back(BoneId::neck);
			break;
		case 2:
			HitBoxesToScan.push_back(BoneId::chest);
			break;
		default:
			break;
		}
		for (auto hitbox : HitBoxesToScan)
		{
			if (hitbox != -1)
			{
				if (gm.ClosestCrosshairEnemy.GetEntityBonePosition(hitbox, BONE)) {

					D3DXVECTOR3 Hitbox = CalcSoldierFuturePos(D3DXVECTOR3(BONE.x, BONE.y, BONE.z));
					if (GetCrossDistance(Hitbox.x, Hitbox.y, S_width / 2, S_height / 2) <= aimfov * 8)
					{
						auto roundPos = D3DXVECTOR2((float)round(Hitbox.x), (float)round(Hitbox.y));
						AimAtPosV2(roundPos.x, roundPos.y, aimspeed, false);
						if (settings::aimbotdrawhitbox)
							DrawCircle(roundPos.x, roundPos.y, 3, 3, 1.f, 0.f, 0.f, 1.f, true);

					}
				}
			}
		}
	}
	if (settings::aimbotdrawfov)
		DrawCircle(S_width / 2, S_height / 2, aimfov * 8, 1, aimcolor.r, aimcolor.g, aimcolor.b, aimcolor.a, false);

}
int main()
{
	const char* filename = "./APEX_BaseAddress.ini";
	std::ifstream infile(filename, std::fstream::in);
	DWORD_PTR a;
	infile >> std::hex >> a;
	base = a;
	std::cout << "Apex Legends ESP by Zakaria" << std::endl;
	std::cout << "Load Config" << std::endl;
	ReadSettings();
	std::cout << "Initializing Overlay" << std::endl;
	DirectOverlaySetup(drawLoop, FindWindow(NULL, "Apex Legends"));
	std::cout << std::endl << std::endl;
	std::cout << "Base Address = " << std::hex << base << std::endl;

	getchar();
}
```

`apex/apex.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{1E2333FA-3780-492A-91F5-E583C3B32B63}</ProjectGuid>
    <RootNamespace>apex</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x64;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>HighestAvailable</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="DirectOverlay.h" />
    <ClInclude Include="Includes.h" />
    <ClInclude Include="kRpm.h" />
    <ClInclude Include="Menu.h" />
    <ClInclude Include="Offsets.h" />
    <ClInclude Include="Render.h" />
    <ClInclude Include="SDK.h" />
    <ClInclude Include="Settings.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Render.cpp" />
    <ClCompile Include="Source.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`apex/apex.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DirectOverlay.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kRpm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Menu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Settings.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SDK.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Render.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Render.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`apex/apex.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`x64/Release/APEX_BaseAddress.ini`:

```ini
0x7ff624440000
```

`x64/Release/Settings.ini`:

```ini
[Config]
Active = 1
AutoLock = 0
AimKnocket =0
HitBox = 1
AimSpeed = 20
Fov = 12
aimlock = 0.9
AimSpot = 1
AimSpotDis = 20
AimSpotFov = 16
AimSpotSpeed = 20
DrawFov = 1
DrawHitBox = 0
TeamBox = 0
TeamDistance = 0
TeamSnaplines = 0
TeamHealth = 0
ShieldHealth = 0
TeamFilledbox = 0
TeamKnocked = 0
EnemyBoxes = 1
EnemyDistance = 1
EnemySnaplines = 1
EnemyHealth = 1
EnemyShieldHealth = 1
EnemyFilledbox = 0
EnemyKnocked = 1
CrosshairEnable = 1
CrosshairStyle = 3
Size = 7.0
Stroke = 4.0
BoxType = 1
HealthbarType = 1
PlayersDis = 250
MenuX = 10.0
MenuY = 400.0

```