Project Path: arc_gmh5225_Ponce_92h9ngrl

Source Tree:

```txt
arc_gmh5225_Ponce_92h9ngrl
├── AUTHORS
├── CMakeLists.txt
├── LICENSE
├── README.md
├── docs
│   ├── README.md
│   ├── SUMMARY.md
│   ├── examples
│   │   ├── negate-and-inject.md
│   │   ├── negate-inject-and-restore.md
│   │   ├── symbolic-engine.md
│   │   └── taint-engine.md
│   ├── misc
│   │   ├── building.md
│   │   ├── debugging.md
│   │   ├── faq.md
│   │   ├── ponce-limitations.md
│   │   └── port.md
│   └── usage
│       ├── blacklist.md
│       ├── enable-disable.md
│       ├── shortcuts.md
│       ├── solve-conditions.md
│       ├── symbolic-and-taint-engines.md
│       └── symbolize-taint-data.md
├── examples
│   ├── crackme_hash.cpp
│   ├── crackme_xor.cpp
│   ├── fread_SAGE.cpp
│   └── long_time_to_solve.cpp
├── media
│   ├── cmake_tainting_fread.gif
│   ├── crackmexor_negate_and_inject.gif
│   ├── manual_symbolize_and_solve_crackme_hash.gif
│   └── x64_fread_test_negate_restore_inject.gif
└── src
    ├── actions.cpp
    ├── actions.hpp
    ├── blacklist.cpp
    ├── blacklist.hpp
    ├── callbacks.cpp
    ├── callbacks.hpp
    ├── context.cpp
    ├── context.hpp
    ├── formConfiguration.cpp
    ├── formConfiguration.hpp
    ├── formTaintSymbolizeInput.cpp
    ├── formTaintSymbolizeInput.hpp
    ├── globals.cpp
    ├── globals.hpp
    ├── main.cpp
    ├── ponce_hexrays.cpp
    ├── ponce_hexrays.hpp
    ├── runtime_status.hpp
    ├── snapshot.cpp
    ├── snapshot.hpp
    ├── solver.cpp
    ├── solver.hpp
    ├── symVarTable.cpp
    ├── symVarTable.hpp
    ├── trigger.cpp
    ├── trigger.hpp
    ├── triton_logic.cpp
    ├── triton_logic.hpp
    ├── utils.cpp
    └── utils.hpp

```

`AUTHORS`:

```
Ponce was written and designed by the following authors:
  Alberto García Illera
  Francisco Oca 

For third party depedencies licenses, see LICENSE.

Triton, Z3 and Capstone are copyrights of their respective owners.

```

`CMakeLists.txt`:

```txt
  
cmake_minimum_required(VERSION 3.15.0)
# MSVC runtime library flags are selected by an abstraction
# https://cmake.org/cmake/help/latest/policy/CMP0091.html
cmake_policy(SET CMP0091 NEW) 
cmake_policy(SET CMP0067 NEW)

option(BUILD_EXAMPLES "Build examples" ON)
option(BUILD_HEXRAYS_SUPPORT "Use the Hex-Rays SDK to provide Ponce feedback on the pseudocode" ON)

set(IDA_INSTALLED_DIR "" CACHE PATH "Path to directory where IDA is installed. If set, triton plugin will be moved there after building")

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set (PROJECT_NAME Ponce)
project(${PROJECT_NAME})


if (NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
	message(FATAL_ERROR "IDA plugins >7.0 can't be built as 32 bits modules")
endif()

file(GLOB PONCE_SOURCE_FILES
    src/*.cpp
)
file(GLOB PONCE_HEADER_FILES
    src/*.hpp
)

add_library(${PROJECT_NAME} SHARED ${PONCE_SOURCE_FILES} ${PONCE_HEADER_FILES})
add_library(${PROJECT_NAME}64 SHARED ${PONCE_SOURCE_FILES} ${PONCE_HEADER_FILES})

#                       #
# Look for dependencies #
#                       # 

# Look for IDA SDK 
set(IDASDK_ROOT_DIR "" CACHE PATH "Path to directory idasdk7X where you extracted idasdk7X.zip")

if(NOT IDASDK_ROOT_DIR)
	message(FATAL_ERROR "You should set IDASDK_ROOT_DIR to the IDA SDK path")
endif()

set(IDA_INCLUDE_DIR ${IDASDK_ROOT_DIR}/include)

# IDA SDK libs.
if(WIN32)
	set(idasdk_ea32 "${IDASDK_ROOT_DIR}/lib/x64_win_vc_32/ida.lib")
	set(idasdk_ea64 "${IDASDK_ROOT_DIR}/lib/x64_win_vc_64/ida.lib")
elseif(APPLE)
	set(idasdk_ea32 "${IDASDK_ROOT_DIR}/lib/x64_mac_gcc_32/libida.dylib")
	set(idasdk_ea64 "${IDASDK_ROOT_DIR}/lib/x64_mac_gcc_64/libida64.dylib")
elseif(UNIX) # APPLE is also UNIX, so it MUST be before this elseif().
	set(idasdk_ea32 "${IDASDK_ROOT_DIR}/lib/x64_linux_gcc_32/libida.so")
	set(idasdk_ea64 "${IDASDK_ROOT_DIR}/lib/x64_linux_gcc_64/libida64.so")
	set(CMAKE_POSITION_INDEPENDENT_CODE OFF)
else()
	message(FATAL_ERROR "Unsupported system type: ${CMAKE_SYSTEM_NAME}")
endif()

if(${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
	if (USE_CLANG)
		# IDA libs are built with clang from IDA 7.3
		SET(CMAKE_C_COMPILER /usr/bin/clang)
		SET(CMAKE_CXX_COMPILER /usr/bin/clang++)
		set(idasdk_ea32 "${IDASDK_ROOT_DIR}/lib/x64_mac_clang_32/libida.dylib")
		set(idasdk_ea64 "${IDASDK_ROOT_DIR}/lib/x64_mac_clang_64/libida64.dylib")
	else()
		SET(CMAKE_C_COMPILER /usr/bin/gcc)
		SET(CMAKE_CXX_COMPILER /usr/bin/g++)
	endif()
endif()

# Find Triton
find_package(triton CONFIG REQUIRED)

if(BUILD_EXAMPLES)
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)

	add_executable(crackme_hash examples/crackme_hash.cpp)
	add_executable(crackme_xor examples/crackme_xor.cpp)
	add_executable(fread_SAGE examples/fread_SAGE.cpp)
	add_executable(long_time_to_solve examples/long_time_to_solve.cpp)
	set_target_properties(crackme_hash
		PROPERTIES
		FOLDER "Examples")
	set_target_properties(crackme_xor
		PROPERTIES
		FOLDER "Examples")
	set_target_properties(fread_SAGE
		PROPERTIES
		FOLDER "Examples")
	set_target_properties(long_time_to_solve
		PROPERTIES
		FOLDER "Examples")
endif()

# Look for hexrays SDK to provide Ponce feedback in the pseudocode	
find_file(HEXRAYS_PATH hexrays.hpp PATHS ${IDA_INCLUDE_DIR} NO_DEFAULT_PATH)	
if(BUILD_HEXRAYS_SUPPORT)	
	if (NOT HEXRAYS_PATH)	
		message(FATAL_ERROR "You should add hexrays.hpp to ${IDA_INCLUDE_DIR}")	
	else()	
		target_compile_definitions(${PROJECT_NAME} PRIVATE BUILD_HEXRAYS_SUPPORT)	
		target_compile_definitions(${PROJECT_NAME}64 PRIVATE BUILD_HEXRAYS_SUPPORT)	
	endif()	
endif()

get_filename_component(a_dir ${IDASDK_ROOT_DIR} DIRECTORY)



# Now we create the projects (one for x86 and other for x64)
target_include_directories(${PROJECT_NAME} PRIVATE ${IDA_INCLUDE_DIR})
target_include_directories(${PROJECT_NAME}64 PRIVATE ${IDA_INCLUDE_DIR})

target_link_libraries(
    ${PROJECT_NAME}
	PRIVATE
    triton::triton
	${idasdk_ea32}
)

target_link_libraries(
    ${PROJECT_NAME}64
	PRIVATE
    triton::triton
	${idasdk_ea64}
)

target_compile_definitions(${PROJECT_NAME} PRIVATE __X64__ __IDP__)
target_compile_definitions(${PROJECT_NAME}64 PRIVATE __X64__ __IDP__ __EA64__)

if(WIN32)
	target_compile_definitions(${PROJECT_NAME} PRIVATE __NT__)
	target_compile_definitions(${PROJECT_NAME}64 PRIVATE __NT__)
	set(PLUGIN_EXTENSION dll)
	add_definitions(/MP)
	# If using the static library we should use the static runtime too
	set_property(TARGET ${PROJECT_NAME} PROPERTY MSVC_RUNTIME_LIBRARY "MultiThreaded")
	set_property(TARGET ${PROJECT_NAME}64 PROPERTY MSVC_RUNTIME_LIBRARY "MultiThreaded")
elseif (APPLE)
	set_target_properties(${PROJECT_NAME} PROPERTIES LINK_FLAGS_RELEASE -dead_strip)
	set_target_properties(${PROJECT_NAME}64 PROPERTIES LINK_FLAGS_RELEASE -dead_strip)
	target_compile_definitions(${PROJECT_NAME} PRIVATE __MAC__ USE_DANGEROUS_FUNCTIONS USE_STANDARD_FILE_FUNCTIONS)
	target_compile_definitions(${PROJECT_NAME}64 PRIVATE __MAC__ USE_DANGEROUS_FUNCTIONS USE_STANDARD_FILE_FUNCTIONS)
	# Prevent creating ponce binaries as libPonce.so but do Ponce.so
	SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES PREFIX "")
	SET_TARGET_PROPERTIES(${PROJECT_NAME}64 PROPERTIES PREFIX "")
	set(PLUGIN_EXTENSION dylib)
elseif (UNIX AND NOT APPLE)
	set_target_properties(${PROJECT_NAME} PROPERTIES COMPILE_FLAGS "-ffunction-sections -fdata-sections" )
	set_target_properties(${PROJECT_NAME}64 PROPERTIES COMPILE_FLAGS "-ffunction-sections -fdata-sections" )
	set_target_properties(${PROJECT_NAME} PROPERTIES LINK_FLAGS_RELEASE "-s -Wl,--gc-sections")
	set_target_properties(${PROJECT_NAME}64 PROPERTIES LINK_FLAGS_RELEASE "-s -Wl,--gc-sections")
	target_compile_definitions(${PROJECT_NAME} PRIVATE __LINUX__ USE_DANGEROUS_FUNCTIONS)
	target_compile_definitions(${PROJECT_NAME}64 PRIVATE __LINUX__ USE_DANGEROUS_FUNCTIONS)
	# Prevent creating ponce binaries as libPonce.so but do Ponce.so
	SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES PREFIX "")
	SET_TARGET_PROPERTIES(${PROJECT_NAME}64 PROPERTIES PREFIX "")
	set(PLUGIN_EXTENSION so)
endif()


# Clean as much symbols as we can in OSX and Linux
if(NOT WIN32)	
	if(EXISTS "/usr/bin/strip")	
		message(STATUS "[-] Symbols will be stripped using strip after build")
		# Strip binary for release builds
		if (CMAKE_BUILD_TYPE STREQUAL Release)
			add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
					COMMAND strip -S $<TARGET_FILE:${PROJECT_NAME}>
					COMMENT "Symbols stripped from ${PROJECT_NAME}")
			add_custom_command(TARGET ${PROJECT_NAME}64 POST_BUILD
					COMMAND strip -S $<TARGET_FILE:${PROJECT_NAME}64>
					COMMENT "Symbols stripped from ${PROJECT_NAME}64")
		endif ()
	endif()
endif()

if(IDA_INSTALLED_DIR)
	message(STATUS "[-] Ponce built plugin and pdb file will be moved to '${IDA_INSTALLED_DIR}/plugins/'. The build system should have permisions to write there or it will error.")
	add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
		COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:${PROJECT_NAME}> ${IDA_INSTALLED_DIR}/plugins/Ponce.${PLUGIN_EXTENSION}
		COMMENT "Created ${IDA_INSTALLED_DIR}/plugins/${PROJECT_NAME}.${PLUGIN_EXTENSION}"
	)
	
	add_custom_command(TARGET ${PROJECT_NAME}64 POST_BUILD
			COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:${PROJECT_NAME}64> ${IDA_INSTALLED_DIR}/plugins/Ponce64.${PLUGIN_EXTENSION}
			COMMENT "Created ${IDA_INSTALLED_DIR}/plugins/${PROJECT_NAME}64.${PLUGIN_EXTENSION}"
		)

	# Move symbols for debugging in Windows
	if(WIN32)
		add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
		COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_BINARY_DIR}/Debug/${PROJECT_NAME}.pdb ${IDA_INSTALLED_DIR}/plugins/Ponce.pdb
		COMMENT "Created ${IDA_INSTALLED_DIR}/plugins/${PROJECT_NAME}.${PLUGIN_EXTENSION}"
		)
		
		add_custom_command(TARGET ${PROJECT_NAME}64 POST_BUILD
			COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_BINARY_DIR}/Debug/${PROJECT_NAME}64.pdb ${IDA_INSTALLED_DIR}/plugins/Ponce64.pdb
			COMMENT "Created ${IDA_INSTALLED_DIR}/plugins/${PROJECT_NAME}64.${PLUGIN_EXTENSION}"
		)
	endif()
endif()

```

`LICENSE`:

```
BSD License
This is the software license for Ponce.
Ponce has been designed & implemented by:

* Alberto García Illera (@algillera)
* Francisco Oca         (@francisco_oca)

Copyright (c) 2016. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.
* Neither the name of the developers nor the names of its
  contributors may be used to endorse or promote products derived from this
  software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.



In addition, the following licenses apply to third party dependencies used within the Ponce software:

-------------- Triton -------------------
This is the software license for the Triton framework.
The Triton framework has been designed & implemented by:

* Jonathan Salwan (Quarkslab)
* Romain Thomas (Quarkslab)
* Florent Saudel (Bordeaux University)

See http://triton.quarkslab.com/about/ for further information.

Copyright (c) 2016. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.
* Neither the name of the developers nor the names of its
  contributors may be used to endorse or promote products derived from this
  software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

-------------- Z3 -------------------
Z3
Copyright (c) Microsoft Corporation
All rights reserved. 
MIT License
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

-------------- Capstone -------------------
This is the software license for Capstone disassembly framework.
Capstone has been designed & implemented by Nguyen Anh Quynh <aquynh@gmail.com>

See http://www.capstone-engine.org for further information.

Copyright (c) 2013, COSEINC.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.
* Neither the name of the developer(s) nor the names of its
  contributors may be used to endorse or promote products derived from this
  software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
<p align="center">
  <img src="https://cloud.githubusercontent.com/assets/5193128/18534105/f27da220-7a9c-11e6-8d2e-a940d94b404b.png">
</p>

<p align="center">
  <a href="https://github.com/illera88/Ponce/actions?query=workflow%3A%22Build+for+Windows%22"><img alt="Build for Windows" src="https://github.com/illera88/Ponce/workflows/Build%20for%20Windows/badge.svg"></a>
  <a href="https://github.com/illera88/Ponce/actions?query=workflow%3A%22Build+for+OSX%22"><img alt="Build for OSX" src="https://github.com/illera88/Ponce/workflows/Build%20for%20OSX/badge.svg"></a>
  <a href="https://github.com/illera88/Ponce/actions?query=workflow%3A%22Build+for+Linux%22"><img alt="Build for Linux" src="https://github.com/illera88/Ponce/workflows/Build%20for%20Linux/badge.svg"></a>
</p>

# Ponce

Ponce \(pronounced _\[ 'poN θe \]_ pon-they \) is an IDA Pro plugin that provides users the ability to perform taint analysis and symbolic execution over binaries in an easy and intuitive fashion. With Ponce you are one click away from getting all the power from cutting edge symbolic execution. Entirely written in C/C++.

### Why?

Symbolic execution is not a new concept in the security community. It has been around for many years but it is not until around 2015 that open source projects like [Triton](https://github.com/JonathanSalwan/Triton) and [Angr](http://angr.io/) have been created to address this need. Despite the availability of these projects, end users are often left to implement specific use cases themselves.

We addressed these needs by creating Ponce, an IDA plugin that implements symbolic execution and taint analysis within the most used disassembler/debugger for reverse engineers.

### Installation

Ponce works with both x86 and x64 binaries in any IDA version &gt;= 7.0. Installing the plugin is as simple as copying the appropiate files from the [latest builds](https://github.com/illera88/Ponce/releases/latest) to the `plugins\` folder in your IDA installation directory.

Make sure you use the Ponce binary compiled for your IDA version to avoid any incompatibilities.

### OS Support

Ponce works on Windows, Linux and OSX natively!

### Use cases

* **Exploit development**: Ponce can help you create an exploit in a far more efficient manner as the exploit developer may easily see what parts of memory and which registers you control, as well as possible addresses which can be leveraged as ROP gadgets.
* **Malware Analysis**: Another use of Ponce is related to malware code. Analyzing the commands a particular family of malware supports is easily determined by symbolizing a simple known command and negating all the conditions where the command is being checked. 
* **Protocol Reversing**: One of the most interesting Ponce uses is the possibility of recognizing required magic numbers, headers or even entire protocols for controlled user input. For instance, Ponce can help you to list all the accepted arguments for a given command line binary or extract the file format required for a specific file parser.
* **CTF**: Ponce speeds up the process of reverse engineer binaries during CTFs. As Ponce is totally integrated into IDA you don't need to worry about setup timing. It's ready to be used!

The plugin will automatically run, guiding you through the initial configuration the first time it is run. The configuration will be saved to a configuration file so you won't have to worry about the config window again.

### Use modes

* **Tainting engine**: This engine is used to determine at every step of the binary's execution which parts of memory and registers are controllable by the user input.
* **Symbolic engine**: This engine maintains a symbolic state of registers and part of memory at each step in a binary's execution path. 

### Examples

#### Negate and inject a condition

In the next gif we can see the use of automatic tainting and how we can negate a condition and inject it in memory while debugging:

* We select the symbolic engine and set the option to symbolize `argv`.
* We identify the condition that needs to be satisfied to win the crackMe.
* We negate an inject the solution everytime a byte of our input is checked against the key.
* Finally we get the key `elite` that has been injected in memory and therefore reach the `Win` code.

 The crackme source code can be found [here](https://github.com/illera88/Ponce/blob/master/examples/crackme_xor.cpp)

![crackmexor\_negate\_and\_inject](https://cloud.githubusercontent.com/assets/5193128/18558282/5dd1cbca-7b27-11e6-81d7-13044bfc0b59.gif)

#### Using the tainting engine to track user controlled input

In this example we can see the use of the tainting engine with cmake. We are:

* Passing a file as argument to cmake to have him parsing it.
* We select we want to use the tainting engine
* We taint the buffer that \`\`\`fread\(\)\`\`\`\` reads from the file.
* We resume the execution under the debugger control to see where the taint input is moved to.
* Ponce will rename the tainted functions. These are the functions that somehow the user has influence on, not the simply executed functions.

![cmake\_tainting\_fread](https://cloud.githubusercontent.com/assets/5193128/18558313/7aaa6d88-7b27-11e6-9c63-9870720d14e3.gif)

#### Use Negate, Inject & Restore

In the next example we are using the snapshot engine:

* Passing a file as argument.
* We select we want to use the symbolic engine.
* We taint the buffer that \`\`\`fread\(\)\`\`\`\` reads from the file.
* We create a snapshot in the function that parses the buffer read from the file.
* When a condition is evaluated we negate it, inject the solution in memory and restore the snapshot with it.
* The solution will be "valid" so we will satisfy the existent conditions.

![fread\_test\_negate\_restore\_inject](https://github.com/illera88/Ponce/tree/780e1992a935d310f5a956e6ece6b8f630a853a7/media/x64_fread_test_negate_restore_inject.gif?raw=true) The example source code can be found [here](https://github.com/illera88/Ponce/blob/master/examples/fread_SAGE.cpp)

### Usage

In this section we will list the different Ponce options as well as keyboard shortcuts:

* Access the configuration and taint/symbolic windows: Edit &gt; Ponce &gt; Show Config \(Ctl+Shift+P and Ctl+Alt+T\)

![2016-09-15 11\_39\_08-configuracion](https://cloud.githubusercontent.com/assets/5193128/18563366/44a8c698-7b3c-11e6-8802-efb3fe4a5a2d.png)

* Enable/Disable Ponce tracing \(Ctl+Shift+E\)

![2016-09-15 11\_31\_34-](https://cloud.githubusercontent.com/assets/5193128/18563294/fd2cf992-7b3b-11e6-911f-c91c76804b5a.png)

* Symbolize/taint a register \(Ctl+Shift+R\)

![2016-09-15 11\_32\_32-](https://cloud.githubusercontent.com/assets/5193128/18563447/7e4db840-7b3c-11e6-813b-868bdae515bc.png)

* Symbolize/taint memory. Can be done from the IDA View or the Hex View \(Ctl+Shift+M\)

![2016-09-15 11\_32\_52-ida - testproject idb testproject exe c\_\_users\_default default-pc\_documents\_vi](https://cloud.githubusercontent.com/assets/5193128/18563458/88c5bb7e-7b3c-11e6-8b4e-f4a694cad5a8.png)![2016-09-15 11\_33\_10-taint \_ symbolize memory range](https://cloud.githubusercontent.com/assets/5193128/18563460/8adbb8f0-7b3c-11e6-886f-02441bff63a4.png)

![2016-09-15 12\_09\_11-inicio](https://cloud.githubusercontent.com/assets/5193128/18563642/45860a7a-7b3d-11e6-9f95-e7aed529cc85.png)

* Solve formula \(Ctl+Shift+S\)

![2016-09-15 11\_35\_11-](https://cloud.githubusercontent.com/assets/5193128/18563556/e093f0c8-7b3c-11e6-9b37-b3b2c7111d57.png)

* Negate & Inject \(Ctl+Shift+N\)

![2016-09-15 11\_34\_44-](https://cloud.githubusercontent.com/assets/5193128/18563423/6db81160-7b3c-11e6-94a2-698ff334c024.png)

* Negate, Inject & Restore Snaphot \(Ctl+Shift+I\)

![2016-09-15 11\_47\_19-](https://cloud.githubusercontent.com/assets/5193128/18563350/34e0fd20-7b3c-11e6-8040-7e5899fc200f.png)

* Create Execution Snapshot \(Ctl+Shift+C\)

![2016-09-15 11\_37\_40-](https://cloud.githubusercontent.com/assets/5193128/18563529/cfc599c2-7b3c-11e6-84e1-5dd5c7b27537.png)

* Restore Execution Snapshot \(Ctl+Shift+S\)

![2016-09-15 11\_38\_10-](https://cloud.githubusercontent.com/assets/5193128/18563411/63cfeb50-7b3c-11e6-8f56-255bb27bc8f2.png)

* Delete Execution Snapshot \(Ctl+Shift+D\)

![2016-09-15 11\_38\_23-](https://cloud.githubusercontent.com/assets/5193128/18563385/53df1d42-7b3c-11e6-8c2f-f1bd16369f79.png)

* Execute Native \(Ctl+Shift+F9\)

![2016-09-15 12\_07\_10-](https://cloud.githubusercontent.com/assets/5193128/18563579/fc95339a-7b3c-11e6-9947-971e0510eba4.png)

### Triton

Ponce relies on the [Triton framework](https://github.com/JonathanSalwan/Triton) to provide semantics, taint analysis and symbolic execution. Triton is an awesome Open Source project sponsored by Quarkslab and maintained mainly by [Jonathan Salwan](http://shell-storm.org/) with a rich library. We would like to thank and endorse Jonathan's work with Triton. You rock! :\)

### Building

Since Ponce v0.3 we have moved the building compilation process to use `CMake`. Doing this we unify the way that configuration and building happens for Linux, Windows and OSX. We now support providing feedback on the pseudocode about symbolic or taint instructions. For this feature to work you need to add `hexrays.hpp` to your IDA SDK include folder. `hexrays.hpp` can be found on `plugins/hexrays_sdk/` on your IDA installation path. If you have not purchased the hex-rays decompiler you can still build Pnce by using `-DBUILD_HEXRAYS_SUPPORT=OFF`. We use Github actions as our CI environment. Check the [action files](https://github.com/illera88/Ponce/tree/master/.github/workflows) if you want to understand how the building process happens.

### FAQ

#### Why the name of Ponce?

Juan Ponce de León \(1474 – July 1521\) was a Spanish explorer and conquistador. He discovered Florida in the United States. The IDA plugin will help you discover, explore and hopefully conquer the different paths in a binary.

#### Can Ponce be used to analyze Windows, OS X and Linux binaries?

Yes, you can natively use Ponce in IDA for Windows or remotely attach to a Linux or OS X box and use it. In the next Ponce version we will natively support Ponce for Linux and OS X IDA versions.

#### How many instructions per second can handle Ponce?

In our tests we reach to process 3000 instructions per second. We plan to use the PIN tracer IDA offers to increase the speed.

#### Something is not working!

Open an [issue](https://github.com/illera88/Ponce/issues), we will solve it ASAP ;\)

#### I love your project! Can I collaborate?

Sure! Please do pull requests and work in the opened issues. We will pay you in beers for help ;\)

### Limitations

Concolic execution and Ponce have some problems:

* Symbolic memory load/write: When the index used to read a memory value is symbolic like in `x = aray[symbolic_index]` some problems arise that could lead on the loose of track of the tainted/symbolized user controled input. 
* Triton doesn't work very well with [floating point instructions](https://github.com/illera88/Ponce/issues/59).
* Concolic execution only analyzed the executed instructions. That means that symbolic tracking is lost in cases like the following:

  ```c
  int check(char myinput)  // Input is symbolic/tainted
  {
  int flag = 0;
  if (myinput == 'A')  //This condition is symbolic/tainted
    flag = 1
  else
    flag =- 1;
  return flag; // flag is not symbolic/tainted!
  }
  ```

### Authors

* Alberto Garcia Illera \([@algillera](https://twitter.com/algillera)\) agarciaillera@gmail.com
* Francisco Oca \([@francisco\_oca](https://twitter.com/francisco_oca)\) francisco.oca.gonzalez@gmail.com


```

`docs/README.md`:

```md
---
description: IDA 2016 plugin contest winner! Symbolic Execution just one-click away!
---

# Ponce

![](https://cloud.githubusercontent.com/assets/5193128/18534105/f27da220-7a9c-11e6-8d2e-a940d94b404b.png)

[![Build for Windows](https://github.com/illera88/Ponce/workflows/Build%20for%20Windows/badge.svg)](https://github.com/illera88/Ponce/actions?query=workflow%3A%22Build+for+Windows%22) [![Build for OSX](https://github.com/illera88/Ponce/workflows/Build%20for%20OSX/badge.svg)](https://github.com/illera88/Ponce/actions?query=workflow%3A%22Build+for+OSX%22) [![Build for Linux](https://github.com/illera88/Ponce/workflows/Build%20for%20Linux/badge.svg)](https://github.com/illera88/Ponce/actions?query=workflow%3A%22Build+for+Linux%22)

## Ponce

Ponce \(pronounced _\[ 'poN θe \]_ pon-they \) is an IDA Pro plugin that provides users the ability to perform taint analysis and symbolic execution over binaries in an easy and intuitive fashion. With Ponce you are one click away from getting all the power from cutting edge symbolic execution. Entirely written in C/C++.

For a quick overview of how Ponce works checkout the examples on the left panel, we have some animated gifs so you can see what Ponce is capable of!

### Why?

Symbolic execution is not a new concept in the security community. It has been around for many years but it is not until around 2015 that open source projects like [Triton](https://github.com/JonathanSalwan/Triton) and [Angr](http://angr.io/) have been created to address this need. Despite the availability of these projects, end users are often left to implement specific use cases themselves.

We addressed these needs by creating Ponce, an IDA plugin that implements symbolic execution and taint analysis within the most used disassembler/debugger for reverse engineers.

### Use cases

* **Exploit development**: Ponce can help you create an exploit in a far more efficient manner as the exploit developer may easily see what parts of memory and which registers you control, as well as possible addresses which can be leveraged as ROP gadgets.
* **Malware Analysis**: Another use of Ponce is related to malware code. Analyzing the commands a particular family of malware supports is easily determined by symbolizing a simple known command and negating all the conditions where the command is being checked. 
* **Protocol Reversing**: One of the most interesting Ponce uses is the possibility of recognizing required magic numbers, headers or even entire protocols for controlled user input. For instance, Ponce can help you to list all the accepted arguments for a given command line binary or extract the file format required for a specific file parser.
* **CTF**: Ponce speeds up the process of reverse engineer binaries during CTFs. As Ponce is totally integrated into IDA you don't need to worry about setup timing. It's ready to be used!

The plugin will automatically run, guiding you through the initial configuration the first time it is run. The configuration will be saved to a configuration file so you won't have to worry about the config window again.

### Installation

Ponce works with both x86 and x64 binaries in any IDA version &gt;= 7.0 for Windows, Linux and MacOs. Installing the plugin is as simple as copying the appropiate files from the [latest builds](https://github.com/illera88/Ponce/tree/master/latest_builds) to the `plugins\` folder in your IDA installation directory.

Make sure you use the Ponce binary compiled for your IDA version to avoid any incompatibilities.

### How to use Ponce?

The examples section is a good way to see how Ponce works. If you want a more detailed information check out the Usage section, we explained there the different options.

Also make sure to review the [limitations](misc/ponce-limitations.md) before you start using Ponce.

### Triton

Ponce relies on the [Triton framework](https://github.com/JonathanSalwan/Triton) to provide semantics, taint analysis and symbolic execution. Triton is an awesome Open Source project sponsored by Quarkslab and maintained mainly by [Jonathan Salwan](http://shell-storm.org/) with a rich library. We would like to thank and endorse Jonathan's work with Triton. You rock! :)

### Authors

* Alberto Garcia Illera ([@algillera](https://twitter.com/algillera)) agarciaillera@gmail.com
* Francisco Oca ([@francisco\_oca](https://twitter.com/francisco_oca)) francisco.oca.gonzalez@gmail.com
```

`docs/SUMMARY.md`:

```md
# Summary

## USAGE

* [Symbolic and Taint engines](usage/symbolic-and-taint-engines.md)
* [Enable/Disable Ponce](usage/enable-disable.md)
* [Symbolize/Taint data](usage/symbolize-taint-data.md)
* [Solve conditions](usage/solve-conditions.md)
* [Blacklisting library functions](usage/blacklist.md)
* [Shortcuts](usage/shortcuts.md)

## EXAMPLES

* [Symbolic engine](examples/symbolic-engine.md)
* [Taint engine](examples/taint-engine.md)
* [Negate & Inject](examples/negate-and-inject.md)
* [Negate, Inject & Restore](examples/negate-inject-and-restore.md)

## MISC

* [Ponce limitations](misc/ponce-limitations.md)
* [Building](misc/building.md)
* [FAQ](misc/faq.md)
* [Debugging](misc/debugging.md)
* [Port to IDA version](misc/port.md)


```

`docs/examples/negate-and-inject.md`:

```md
# Negate & Inject

In the next gif we can see the use of automatic tainting and how we can negate a condition and inject it in memory while debugging:

* We select the symbolic engine and set the option to symbolize `argv`.
* We identify the condition that needs to be satisfied to win the crackMe.
* We negate an inject the solution everytime a byte of our input is checked against the key.
* Finally we get the key `elite` that has been injected in memory and therefore reach the `Win` code.

 The crackme source code can be found [here](https://github.com/illera88/Ponce/blob/master/examples/crackme_xor.cpp)

![crackmexor\_negate\_and\_inject](https://cloud.githubusercontent.com/assets/5193128/18558282/5dd1cbca-7b27-11e6-81d7-13044bfc0b59.gif)


```

`docs/examples/negate-inject-and-restore.md`:

```md
# Negate, Inject & Restore

In the next example we are using the snapshot engine:

* Passing a file as argument.
* We select we want to use the symbolic engine.
* We taint the buffer that `fread()`reads from the file.
* We create a snapshot in the function that parses the buffer read from the file.
* When a condition is evaluated we negate it, inject the solution in memory and restore the snapshot with it.
* The solution will be "valid" so we will satisfy the existent conditions.

![x64\_fread\_test\_negate\_restore\_inject.gif](https://github.com/illera88/Ponce/blob/780e1992a935d310f5a956e6ece6b8f630a853a7/media/x64_fread_test_negate_restore_inject.gif?raw=true)


```

`docs/examples/symbolic-engine.md`:

```md
# Symbolic engine

#### Use symbolic execution to solve a crackMe

Here we can see the use of the symbolic engine and how we can solve constrains:

* Passing simple `aaaaa` as argument.
* We first select the symbolic engine.
* We convert to symbolic the memory pointed by argv\[1\] \(`aaaaa`\)
* Identify the symbolic condition that make us win and solve it.
* Test the solution.

 The crackme source code can be found [here](https://github.com/illera88/Ponce/blob/master/examples/crackme_hash.cpp)

![manual\_symbolize\_and\_solve\_crackme\_hash2](https://cloud.githubusercontent.com/assets/5193128/18558235/32561cb2-7b27-11e6-846f-9fde03e88df5.gif)

#### 




```

`docs/examples/taint-engine.md`:

```md
# Taint engine

The taint engine is specially useful when analyzing complex binaries in order to reduce the ammount of code that the analyst needs to focus on.

In the following example we analyze the program cmake. The goal is to figure out which instructions are parsing the user input, the input file. In order to do that we use the taint engine following the next steps:

* We pass a file as argument to cmake.
* We configure Ponce to use the taint engine.
* We taint the buffer that `fread()` reads from the file.
* We resume the execution under the debugger control to see where the taint input is moved to.
* Ponce will rename the tainted functions. These are the functions that somehow the user has influence on, not simply the executed functions.

![cmake\_tainting\_fread](https://cloud.githubusercontent.com/assets/5193128/18558313/7aaa6d88-7b27-11e6-9c63-9870720d14e3.gif)


```

`docs/misc/building.md`:

```md
# Building

Since Ponce v0.3 we have moved the building compilation process to use `CMake`. Doing this we unify the way that configuration and building happens for Linux, Windows and OSX. 

We now support providing feedback on the pseudocode about symbolic or taint instructions. For this feature to work you need to add `hexrays.hpp` to your IDA SDK include folder. `hexrays.hpp` can be found on `plugins/hexrays_sdk/` on your IDA installation path. 

If you have not purchased the hex-rays decompiler you can still build Ponce by using `-DBUILD_HEXRAYS_SUPPORT=OFF`. 

We use Github actions as our CI environment. Check the [action files](https://github.com/illera88/Ponce/tree/master/.github/workflows) if you want to understand how the building process happens.
```

`docs/misc/debugging.md`:

```md
# How to debug Ponce under Windows
If you want to debug Ponce and being able to step into functions and put breakpoints you should do the following:

- Make sure you set the `IDA_INSTALLED_DIR` parameter when building with CMake.
- Secondly you should open the IDA binary under Visual Studio. Do File -> Open -> Project and select the `C:\Program Files\IDA Pro 7.5\ida64.exe` binary.
- In the properties of the project you can set the arguments to the binary you IDA to run
- Now right click on the solution and go to Add -> Exixting Project and select the `Ponce64` project.
- Remember to compile Ponce on Debug so the breakpoints get hit
```

`docs/misc/faq.md`:

```md
# FAQ

**Why the name of Ponce?**

Juan Ponce de León \(1474 – July 1521\) was a Spanish explorer and conquistador. He discovered Florida in the United States. The IDA plugin will help you discover, explore and hopefully conquer the different paths in a binary.

**Can Ponce be used to analyze Windows, OSX and Linux binaries?**

Yes. Ponce is multi-platform and can be used in Windows, OSX and Linux.

**What platforms are supported?**
Ponce relies heavily on Triton, and support the same platforms Triton does: 
* x86
* x86-64
* Arm
* Arm64

**How many instructions per second can handle Ponce?**

In our tests we reach to process 3000 instructions per second. We plan to use the PIN tracer IDA offers to increase the speed.


**Something is not working!**

Open an [issue](https://github.com/illera88/Ponce/issues), we will solve it ASAP ;\)

**I love your project! Can I collaborate?**

Sure! Please do pull requests and work in the opened issues. We will pay you in beers for help ;\)


```

`docs/misc/ponce-limitations.md`:

```md
# Ponce limitations

Ponce and Triton, the framework that Ponce relies on, have some limitations due to the nature of concolic execution. It is important to understand these limitations before you start using Ponce.


## Symbolic index while doing a memory load or write

When the index used to read a memory value is symbolic, like in:
```
x = aray[symbolic_index]
``` 
Some problems arise that could lead to the loose of track of the tainted/symbolized user controled input. 

This is a common problem with symbolic/concolic execution, there are some mitigations but it's not trivial to solve it. 

One simple example where this happens:
```c
#include<stdio.h>

char * alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; 

int toUpper(char *userinput) {
  for (int i=0; i < strlen(userinput); i++){
    // We loose here the symbolic tracking, when using a symbolic index to access non symbolic data, alphabet 
    userinput[i] = alphabet[userinput[i] - 'a'];
  }
}

int main(){
  char * userinput = malloc(10);
  memcpy(userinput, "aaaaaaaaa", 10); 
  // Let's image aaaaaaaaa is the userinput that is symbolic
  toUpper(userinput);
  // After the execution of the function userinput is not symbolic anymore
  return 0;
}
```

## Concolic execution only analyzed the executed instructions
It's obvious but sometimes the implications are not so easy to spot.

This means that symbolic tracking is lost in cases like the following:

```c
int check(char myinput)  // Input is symbolic/tainted
{
int flag = 0;
if (myinput == 'A')  //This condition is symbolic/tainted
  flag = 1
else
  flag =- 1;
return flag; // flag is not symbolic/tainted!
}
```

Concolic execution only see one of the branches of the condition, so it doesn't have a way to figure out that the flag value depends on the result of the symbolic condition.


## Triton, thereforce Ponce, doesn't work very well with floating instructions
As mentioned in this ticket:
https://github.com/illera88/Ponce/issues/59
```

`docs/misc/port.md`:

```md
# Port Ponce to newer IDA version (for maintaners)

Ponce supports any IDA version >= 7.0. If a new version of IDA pops up this are the steps to update Ponce to work with it:

1) Use your `ida.key` to request the newest IDA version on [this](https://www.hex-rays.com/updida/) site
2) In the email HexRays sends there will be a user and password and a link to download the SDK. Download it.
3) We need to add the content of `C:\Program Files\IDA Pro 7.X\plugins\hexrays_sdk\include` into the `include` path of the downlaoded SDK zip from the prevoius step. To obtain the files to add (should be one called `hexrays.hpp` and maybe others) you have to install IDA (remember it needs to be bundled with the decompiler for this file to be present)
4) Zip up all the IDA versions SDKs in a file called `IDA_SDKs.zip` and upload it to a site that support direct download (i.e. bublup.com).
5) Use the direct link to [update the secret](https://github.com/illera88/Ponce/settings/secrets/actions) `DOWNLOAD_LINK_IDA_SDK` in Github.
6) Update the action files for Windows, Linux and OSX in these two places:
    - [Here](https://github.com/illera88/Ponce/blob/master/.github/workflows/ci-windows.yml#L76-L80)
    - [Here](https://github.com/illera88/Ponce/blob/master/.github/workflows/ci-windows.yml#L142-L150)
7) Check that the IDA APIs have not change and Ponce compiles.
8) The CI will automatically create the Ponce plugin for you on every platform and every version 
```

`docs/usage/blacklist.md`:

```md
# Blacklisting library functions

Symbolic execution consumes a lot of resources, so limiting the scope of what functions are symbolic executed and which ones not helps to increase the speed of the analysis and decrease the amount of resources consumed.

Many functions from libc or kernel32 don't modify the user input, so we can disable the taint/symbolic engine during the execution of those functions.

One example is the function `printf`. It is usually a pretty complex and big function, that doesn't modify the input. You can see a list of all the functions that by default are blacklisted [here](https://github.com/illera88/Ponce/blob/master/src/blacklist.cpp#L31).

```

`docs/usage/enable-disable.md`:

```md
# Enable/Disable Ponce

Ponce doesn't do anything, is disabled, until you symbolize or taint some data. In this way Ponce doesn't have a impact in the program you are debugging until you decide to use Ponce to symbolically analize the instructions.

Once Ponce is enabled is going to execute instructions step by step, even if you continue the execution, analyze it with Triton and visualize the result.

But you can manually change this behaviour. Maybe you want to enable Ponce at the beginning of your program, just to get the symbolic instructions associated with some instructions.

ToDo: Add image

You can also disable Ponce at any given point. 

This is useful when you know that there is a are with a lot of instructions that don't interact with your input data. In that case you can disable Ponce until all those instructions have been executed and then Enable it again to analyze the instructions that interact with the symbolic/tainted data.

Ponce internally Disables and Enables itself when some library functions are called, like `printf`. More information in [Blacklisting library functions](usage/blacklist.md).
```

`docs/usage/shortcuts.md`:

```md

### Shortcuts

In this section we will list the different keyboard shortcuts:

* Access the configuration and taint/symbolic windows: Edit &gt; Ponce &gt; Show Config \(Ctl+Shift+P and Ctl+Alt+T\)

![2016-09-15 11\_39\_08-configuracion](https://cloud.githubusercontent.com/assets/5193128/18563366/44a8c698-7b3c-11e6-8802-efb3fe4a5a2d.png)

* Enable/Disable Ponce tracing \(Ctl+Shift+E\)

![2016-09-15 11\_31\_34-](https://cloud.githubusercontent.com/assets/5193128/18563294/fd2cf992-7b3b-11e6-911f-c91c76804b5a.png)

* Symbolize/taint a register \(Ctl+Shift+R\)

![2016-09-15 11\_32\_32-](https://cloud.githubusercontent.com/assets/5193128/18563447/7e4db840-7b3c-11e6-813b-868bdae515bc.png)

* Symbolize/taint memory. Can be done from the IDA View or the Hex View \(Ctl+Shift+M\)

![2016-09-15 11\_32\_52-ida - testproject idb testproject exe c\_\_users\_default default-pc\_documents\_vi](https://cloud.githubusercontent.com/assets/5193128/18563458/88c5bb7e-7b3c-11e6-8b4e-f4a694cad5a8.png)![2016-09-15 11\_33\_10-taint \_ symbolize memory range](https://cloud.githubusercontent.com/assets/5193128/18563460/8adbb8f0-7b3c-11e6-886f-02441bff63a4.png)

![2016-09-15 12\_09\_11-inicio](https://cloud.githubusercontent.com/assets/5193128/18563642/45860a7a-7b3d-11e6-9f95-e7aed529cc85.png)

* Solve formula \(Ctl+Shift+S\)

![2016-09-15 11\_35\_11-](https://cloud.githubusercontent.com/assets/5193128/18563556/e093f0c8-7b3c-11e6-9b37-b3b2c7111d57.png)

* Negate & Inject \(Ctl+Shift+N\)

![2016-09-15 11\_34\_44-](https://cloud.githubusercontent.com/assets/5193128/18563423/6db81160-7b3c-11e6-94a2-698ff334c024.png)

* Negate, Inject & Restore Snaphot \(Ctl+Shift+I\)

![2016-09-15 11\_47\_19-](https://cloud.githubusercontent.com/assets/5193128/18563350/34e0fd20-7b3c-11e6-8040-7e5899fc200f.png)

* Create Execution Snapshot \(Ctl+Shift+C\)

![2016-09-15 11\_37\_40-](https://cloud.githubusercontent.com/assets/5193128/18563529/cfc599c2-7b3c-11e6-84e1-5dd5c7b27537.png)

* Restore Execution Snapshot \(Ctl+Shift+S\)

![2016-09-15 11\_38\_10-](https://cloud.githubusercontent.com/assets/5193128/18563411/63cfeb50-7b3c-11e6-8f56-255bb27bc8f2.png)

* Delete Execution Snapshot \(Ctl+Shift+D\)

![2016-09-15 11\_38\_23-](https://cloud.githubusercontent.com/assets/5193128/18563385/53df1d42-7b3c-11e6-8c2f-f1bd16369f79.png)

* Execute Native \(Ctl+Shift+F9\)

![2016-09-15 12\_07\_10-](https://cloud.githubusercontent.com/assets/5193128/18563579/fc95339a-7b3c-11e6-9947-971e0510eba4.png)
```

`docs/usage/solve-conditions.md`:

```md
ToDo.
```

`docs/usage/symbolic-and-taint-engines.md`:

```md
### Symbolic and Taint engines

Ponce has two different engines:

* **Taint engine**: This engine is used to determine at every step of the binary's execution which parts of memory and registers are controllable by the user input.    
    
    This engine is more useful when you just want to see how user controlled data moves through a program.

    For example during exploit development you can use the taint engine to narrow down which functions of the binary are parsing the user controlled data. 
    
    The taint engine is slighly faster and lightweight than the symbolic one.

* **Symbolic engine**: This engine maintains a symbolic state of registers and part of memory at each step in a binary's execution path. And allows a user to get a solution for a specific condition.

    This engine is useful when there is a non straigh forward condition to solve in order to reach an area of code we are interested in.

    One example is CTF challenges that do some complex calculations and checks for a specific result.

    

```

`docs/usage/symbolize-taint-data.md`:

```md
# Symbolize/Taint data

Typically, the first step in Ponce is to Symbolize or Taint, depending of the engine you are using, a user input you want to analyze, for example an input file.

For now on we are going to use the symbolic engine. But the same steps would apply for the taint engine.

You can symbolize two things, memory or registers.

In order to symbolize memory you can do it from the Dissassembly view or directly from the hexdump. 

The advantage of doing it from the dissasembly view is that you can jump directly to the address using the Ponce context menu over an address.

The first time you symbolize an item Ponce enables the symbolic engine.
```

`examples/crackme_hash.cpp`:

```cpp
#include <stdio.h>
#include <stdlib.h>

const char *serial = "\x31\x3e\x3d\x26\x31";

int check(char *ptr)
{
	int i;
	int hash = 0xABCD;

	for (i = 0; ptr[i]; i++)
		hash += ptr[i] ^ serial[i % 5];

	return hash;
}

int main(int ac, char **av)
{
	int ret;

	if (ac != 2)
		return -1;

	ret = check(av[1]);
	if (ret == 0xad6d)
		printf("Win\n");
	else
		printf("fail\n");

	return 0;
}
```

`examples/crackme_xor.cpp`:

```cpp
#include <stdio.h>
#include <stdlib.h>

const char *serial = "\x31\x3e\x3d\x26\x31";

int check(char *ptr)
{
	int i = 0;

	while (i < 5){
		if (((ptr[i] - 1) ^ 0x55) != serial[i])
			return 1;
		i++;
	}
	return 0;
}

int main(int ac, char **av)
{
	int ret;

	if (ac != 2)
		return -1;

	ret = check(av[1]);
	if (ret == 0)
		printf("Win\n");
	else
		printf("fail\n");

	return 0;
}

```

`examples/fread_SAGE.cpp`:

```cpp
// SAGE_fread.cpp : Defines the entry point for the console application.
//
#include <stdio.h>

bool reading_input_from_file(char *buffer)
{
	FILE *f = fopen("input.txt", "rb");
	if (f == NULL)
	{
		printf("input.txt not found!\n");
		return 0;
	}
	if (fread(buffer, 1, 4, f) != 4)
	{
		printf("file too small!\n");
		fclose(f);
		return 0;
	}
	fclose(f);
	return 1;
}

void check(const char *buf)
{
	int n = 0;
	if (buf[0] == 'b') n++;
	if (buf[1] == 'a') n++;
	if (buf[2] == 'd') n++;
	if (buf[3] == '!') n++;
	if (n == 4)
	{
		printf("Win!\n");
	}
	else
	{
		printf("Fail\n");
	}
}

int main(int argc, char* argv[])
{
	char buffer[256];
	if (reading_input_from_file(buffer))
		check(buffer);
	return 0;
}


```

`examples/long_time_to_solve.cpp`:

```cpp
/* Run with 32 a's as first argument
*/
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
    if (argc != 2)
        return -1;
    int len = strlen(argv[1]);
    int sum = 0;

    for (int i = 0; i < len; i++)
    {
        sum += argv[1][i];
    }
    //For example 32 a's
    if (sum == 97 * 32)
        printf("You Won!!!\n");
    else
        printf("You Failed :( :(\n");
    return 0;
}

```

`src/actions.cpp`:

```cpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#include <thread>

//IDA
#include <idp.hpp>
#include <dbg.hpp>
#include <loader.hpp>
#include <kernwin.hpp>
#include <hexrays.hpp>

//Ponce
#include "globals.hpp"
#include "utils.hpp"
#include "callbacks.hpp"
#include "formConfiguration.hpp"
#include "formTaintSymbolizeInput.hpp"
#include "actions.hpp"
#include "symVarTable.hpp"
#include "blacklist.hpp"
#include "context.hpp"
#include "solver.hpp"
#include "triton_logic.hpp"

//Triton
#include "triton/api.hpp"
#include "triton/x86Specifications.hpp"

int taint_symbolize_register(const qstring& selected, action_activation_ctx_t* action_activation_ctx) {
    auto reg_id_to_symbolize = str_to_register(selected);

    if (reg_id_to_symbolize != triton::arch::register_e::ID_REG_INVALID) {
        auto register_to_symbolize = api.getRegister(reg_id_to_symbolize);
        /*When the user symbolize something for the first time we should enable step_tracing*/
        start_tainting_or_symbolic_analysis();

        msg("[+] %s register %s\n", cmdOptions.use_tainting_engine ? "Tainting" : "Symbolizing", selected.c_str());
        
        ea_t pc;
        get_ip_val(&pc);
        char comment[256];
        qsnprintf(comment, 256, "Reg %s at address: " MEM_FORMAT, selected.c_str(), pc);

        // Before symbolizing register we should set his concrete value
        needConcreteRegisterValue_cb(api, register_to_symbolize);

        if (cmdOptions.use_tainting_engine) {
            api.taintRegister(register_to_symbolize);
        }
        else{ // Symbolize register            
            api.symbolizeRegister(register_to_symbolize, std::string(comment));
        }

        tritonize(pc);
        return 0;
    }
    return 0;
}


struct ah_taint_symbolize_register_t : public action_handler_t
{
    /*Event called when the user taint a register*/
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        // Get the address range selected, or return false if there was no selection
        qstring selected;
        if (ctx->widget_type == BWN_DISASM) {      
            uint32 flags;
            get_highlight(&selected, get_current_viewer(), &flags);
        }
#if IDA_SDK_VERSION >= 740
        else if (ctx->widget_type == BWN_CPUREGS) {
            selected = ctx->regname;            
        }
#endif

        taint_symbolize_register(selected, ctx);

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* action_update_ctx)
    {
        char label[50] = { 0 };
        bool success;
        action_state_t action_to_take = AST_DISABLE;
        qsnprintf(label, sizeof(label), "%s register", cmdOptions.use_tainting_engine ? "Taint" : "Symbolize");
        // Default
        if (action_update_ctx->widget_type == BWN_DISASM) {
            qstring selected;
            uint32 flags;
            if (get_highlight(&selected, get_current_viewer(), &flags)) {
                if (str_to_register(selected) != triton::arch::register_e::ID_REG_INVALID) {
                    qsnprintf(label, sizeof(label), "%s %s register", cmdOptions.use_tainting_engine ? "Taint" : "Symbolize", qstrupr((char*)selected.c_str()));
                    action_to_take = is_debugger_on() ? AST_ENABLE : AST_DISABLE;
                }
            }                
        }
#if IDA_SDK_VERSION >= 740
        else if (action_update_ctx->widget_type == BWN_CPUREGS) {
            auto reg_name = action_update_ctx->regname;
            if (str_to_register(reg_name) != triton::arch::register_e::ID_REG_INVALID) {
                qsnprintf(label, sizeof(label), "%s %s register", cmdOptions.use_tainting_engine ? "Taint" : "Symbolize", reg_name);
                action_to_take = is_debugger_on() ? AST_ENABLE : AST_DISABLE;
            }
        }
#endif
        success = update_action_label(action_IDA_taint_symbolize_register.name, label);
        success = update_action_tooltip(action_IDA_taint_symbolize_register.name, cmdOptions.use_tainting_engine ? COMMENT_TAINT_REG : COMMENT_SYMB_REG);

        return action_to_take;
    }
};
static ah_taint_symbolize_register_t ah_taint_symbolize_register;


action_desc_t action_IDA_taint_symbolize_register = ACTION_DESC_LITERAL(
    "Ponce:taint_symbolize_register", // The action name. This acts like an ID and must be unique
    "nothing", //The action text.
    &ah_taint_symbolize_register, //The action handler.
    "Ctrl+Shift+R", //Optional: the action shortcut
    "Taint the selected register", //Optional: the action tooltip (available in menus/toolbar)
    50); //Optional: the action icon (shows when in menus/toolbars)

struct ah_taint_symbolize_memory_t : public action_handler_t
{
    /*Event called when the user symbolize a memory*/
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        ea_t selection_starts = 0;
        ea_t selection_ends = 0;
        ea_t current_ea = 0;
        sval_t size = 1;
        //We ask to the user for the memory and the size
        if (ctx->widget_type == BWN_DISASM) {
            qstring selected;
            uint32 flags;
            /* Try to get register if selected*/
            if (get_highlight(&selected, get_current_viewer(), &flags)) {
                if (str_to_register(selected) != triton::arch::register_e::ID_REG_INVALID) {
                    regval_t reg;
                    auto sucess = get_reg_val(selected.c_str(), &reg);
                    if (sucess && is_mapped(reg.ival)) {
                        current_ea = reg.ival;                        
                    }
                }
            }
            if (current_ea == 0) {
                if (ctx->cur_flags & ACF_HAS_SELECTION) { // Only if there has been a valid selection
                //We get the selection bounds from the action activation context
                    auto selection_starts = ctx->cur_sel.from.at->toea();
                    auto selection_ends = ctx->cur_sel.to.at->toea();
                    size = selection_ends - selection_starts + 1;
                    current_ea = selection_starts;
                }
                else
                    current_ea = get_screen_ea() != -1 ? get_screen_ea() : 0;
            }                
        }
#if IDA_SDK_VERSION >= 730
        else if (ctx->widget_type == BWN_STKVIEW) {
            if(is_mapped(ctx->cur_value))
                current_ea = ctx->cur_value;
        }
#endif
        else if (ctx->widget_type == BWN_DUMP) {
            if (ctx->cur_flags & ACF_HAS_SELECTION){ // Only if there has been a valid selection
                //We get the selection bounds from the action activation context
                auto selection_starts = ctx->cur_sel.from.at->toea();
                auto selection_ends = ctx->cur_sel.to.at->toea();
                size = selection_ends - selection_starts + 1;
                current_ea = selection_starts;
            }
        }
       
#if IDA_SDK_VERSION >= 740
        else if (ctx->widget_type == BWN_CPUREGS) {
            auto reg_name = ctx->regname;
            uint64 reg_value;
            get_reg_val(reg_name, &reg_value);
            current_ea = reg_value;
        }
#endif
        auto success = jumpto(current_ea, -1, UIJMP_IDAVIEW);

        if (!prompt_window_taint_symbolize(current_ea, abs(size), &selection_starts, &selection_ends))
            return 0;

        /* When the user taints something for the first time we should enable step_tracing*/
        start_tainting_or_symbolic_analysis();

        auto selection_length = selection_ends - selection_starts;
        msg("[+] %s memory from " MEM_FORMAT " to " MEM_FORMAT ". Total: %d bytes\n", cmdOptions.use_tainting_engine ? "Tainting" : "Symbolizing",  selection_starts, selection_ends, (int)selection_length);

        // Before symbolizing the memory we should set its concrete value
        for (unsigned int i = 0; i < selection_length; i++) {
            needConcreteMemoryValue_cb(api, triton::arch::MemoryAccess(selection_starts + i, 1));
        }

        if (cmdOptions.use_tainting_engine) {
            for (unsigned int i = 0; i < selection_length; i++) {
                auto taintVar = api.taintMemory(triton::arch::MemoryAccess(selection_starts + i, 1));
                if (taintVar) {
                    ponce_set_cmt(selection_starts + i, "Tainted memory", true);
                }
            }
        }
        else{ // Symbolizing all the selected memory
            for (unsigned int i = 0; i < selection_length; i++) {
                auto symVar = api.symbolizeMemory(triton::arch::MemoryAccess(selection_starts + i, 1));
                auto var_name = symVar->getName();
                ponce_set_cmt(selection_starts + i, var_name.c_str(), true);
            }
        }

        tritonize(current_instruction());

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* action_update_ctx_t)
    {
        char label[50] = { 0 };
        bool success;
        action_state_t action_to_take = AST_DISABLE;
        qsnprintf(label, sizeof(label), "%s memory", cmdOptions.use_tainting_engine ? "Taint" : "Symbolize");
        if (action_update_ctx_t->widget_type == BWN_DISASM) {
            qstring selected;
            uint32 flags;
            /* Try to get register if selected*/
            if (get_highlight(&selected, get_current_viewer(), &flags)) {
                if (str_to_register(selected) != triton::arch::register_e::ID_REG_INVALID) {
                    regval_t reg;
                    //invalidate_dbg_state(DBGINV_REGS);
                    auto sucess = get_reg_val(selected.c_str(), &reg);
                    if (sucess && is_mapped(reg.ival)) {
                        qsnprintf(label, sizeof(label), "%s memory at %s " MEM_FORMAT, cmdOptions.use_tainting_engine ? "Taint" : "Symbolize", qstrupr((char*)selected.c_str()), reg.ival);
                    }
                }
            }
            action_to_take = is_debugger_on() ? AST_ENABLE : AST_DISABLE;
        }
        else if (action_update_ctx_t->widget_type == BWN_DUMP) {
            action_to_take = is_debugger_on() ? AST_ENABLE : AST_DISABLE;    
        }
#if IDA_SDK_VERSION >= 730
        else if (action_update_ctx_t->widget_type == BWN_STKVIEW) {
            if (is_mapped(action_update_ctx_t->cur_value)) {
                qsnprintf(label, sizeof(label), "%s memory at " MEM_FORMAT, cmdOptions.use_tainting_engine ? "Taint" : "Symbolize", action_update_ctx_t->cur_value);
                action_to_take = is_debugger_on() ? AST_ENABLE : AST_DISABLE;
            }
            else
                action_to_take = AST_DISABLE;
        }
#endif
#if IDA_SDK_VERSION >= 740
        else if (action_update_ctx_t->widget_type == BWN_CPUREGS) {
            auto reg_name = action_update_ctx_t->regname;
            uint64 reg_value;  
            get_reg_val(reg_name, &reg_value);

            if (!is_mapped(reg_value)) {
                action_to_take = AST_DISABLE;
            }
            else {
                qsnprintf(label, sizeof(label), "%s memory at %s " MEM_FORMAT, cmdOptions.use_tainting_engine ? "Taint" : "Symbolize", reg_name, reg_value);    
                action_to_take = is_debugger_on() ? AST_ENABLE : AST_DISABLE;
            }
        }
#endif
        else {
            return AST_DISABLE;
        }

        success = update_action_label(action_IDA_taint_symbolize_memory.name, label);
        success = update_action_tooltip(action_IDA_taint_symbolize_memory.name, cmdOptions.use_tainting_engine ? COMMENT_TAINT_MEM : COMMENT_SYMB_MEM);
        return action_to_take;
        
    }
};
static ah_taint_symbolize_memory_t ah_taint_symbolize_memory;

action_desc_t action_IDA_taint_symbolize_memory = ACTION_DESC_LITERAL(
    "Ponce:taint_symbolize_memory", // The action name. This acts like an ID and must be unique
    "bla bla bla", //The action text.
    &ah_taint_symbolize_memory, //The action handler.
    "Ctrl+Shift+M", //Optional: the action shortcut
    "Symbolize the selected register", //Optional: the action tooltip (available in menus/toolbar)
    50); //Optional: the action icon (shows when in menus/toolbars)

struct ah_negate_and_inject_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* action_activation_ctx)
    {
        //This is only working from the disassembly windows
        if (action_activation_ctx->widget_type == BWN_DISASM) {
            // We get the symbolic condition index from the tooltip
            qstring tooltip;
            get_action_tooltip(&tooltip, action_activation_ctx->action);
            auto offset = tooltip.find("Index: ");
            assert(offset != -1);
            //We extract the symbolic condition index from the action name
            unsigned int symbolic_condition_index = atoi((tooltip.c_str() + offset + 7)); // skip "Index: "
            
            if (cmdOptions.showDebugInfo)
                msg("[+] Negating condition at " MEM_FORMAT "\n", action_activation_ctx->cur_ea);

            std::thread t(negate_inject_maybe_restore_solver, action_activation_ctx->cur_ea, symbolic_condition_index, false);
            t.detach();            
        }

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        //Only if process is being debugged
        if (is_debugger_on()) {
            //If we are in runtime and it is the last instruction we test if it is symbolize
            if (ponce_runtime_status.last_triton_instruction != NULL &&
                ponce_runtime_status.last_triton_instruction->getAddress() == ctx->cur_ea &&
                ponce_runtime_status.last_triton_instruction->isBranch() &&
                ponce_runtime_status.last_triton_instruction->isSymbolized()) {

                unsigned int path_constraint_index = 0;
                for (const auto& pc : api.getPathConstraints()) {
                    for (auto const& [taken, srcAddr, dstAddr, pc] : pc.getBranchConstraints()) {
                        if (ctx->cur_ea == srcAddr && !taken) {
                            char tooltip[256];
                            //We need the path constraint index during the action activate
                            qsnprintf(tooltip, 255, "Index: %u", path_constraint_index);
                            update_action_tooltip(ctx->action, tooltip);

                            char label[100] = { 0 };
                            qsnprintf(label, sizeof(label), "Negate and Inject to reach " MEM_FORMAT, dstAddr);
                            update_action_label(ctx->action, label);
                            return AST_ENABLE;
                        }
                    }
                    path_constraint_index++;
                }
            }
        }
        // Using the default value
        update_action_label(ctx->action, action_IDA_negate_and_inject.label);
        return AST_DISABLE;
    }
};
static ah_negate_and_inject_t ah_negate_and_inject;

action_desc_t action_IDA_negate_and_inject = ACTION_DESC_LITERAL(
    "Ponce:negate_and_inject", // The action name. This acts like an ID and must be unique
    "Negate & Inject", //The action text.
    &ah_negate_and_inject, //The action handler.
    "", //Optional: the action shortcut
    "Negate the current condition and inject the solution into memory", //Optional: the action tooltip (available in menus/toolbar)
    58); //Optional: the action icon (shows when in menus/toolbars)

struct ah_negate_inject_and_restore_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* action_activation_ctx)
    {
        //This is only working from the disassembly windows
        if (action_activation_ctx->widget_type == BWN_DISASM) {
            // We get the symbolic condition index from the tooltip
            qstring tooltip;
            get_action_tooltip(&tooltip, action_activation_ctx->action);
            auto offset = tooltip.find("Index: ");
            assert(offset != -1);
            //We extract the symbolic condition index from the action name
            unsigned int symbolic_condition_index = atoi((tooltip.c_str() + offset + 7)); // skip "Index: "

            if (cmdOptions.showDebugInfo)
                msg("[+] Negating condition at " MEM_FORMAT "\n", action_activation_ctx->cur_ea);

            std::thread t(negate_inject_maybe_restore_solver, action_activation_ctx->cur_ea, symbolic_condition_index, true);
            t.detach();
        }
        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        //Only if process is being debugged
        if (is_debugger_on() && snapshot.exists()) {
            //If we are in runtime and it is the last instruction we test if it is symbolize
            if (ponce_runtime_status.last_triton_instruction != NULL &&
                ponce_runtime_status.last_triton_instruction->getAddress() == ctx->cur_ea &&
                ponce_runtime_status.last_triton_instruction->isBranch() &&
                ponce_runtime_status.last_triton_instruction->isSymbolized()) {


                for (const auto& pc : api.getPathConstraints()) {
                    for (auto const& [taken, srcAddr, dstAddr, pc] : pc.getBranchConstraints()) {
                        if (ctx->cur_ea == srcAddr) {
                            char label[100] = { 0 };
                            qsnprintf(label, sizeof(label), "Negate, Inject to reach " MEM_FORMAT " & Restore snapshot", dstAddr);
                            update_action_label(ctx->action, label);
                            return AST_ENABLE;
                        }
                    }
                }
            }
        }
        // Using the default value
        update_action_label(ctx->action, action_IDA_negate_inject_and_restore.label);
        return AST_DISABLE;
    }
};
static ah_negate_inject_and_restore_t ah_negate_inject_and_restore;

action_desc_t action_IDA_negate_inject_and_restore = ACTION_DESC_LITERAL(
    "Ponce:negate_inject_restore", // The action name. This acts like an ID and must be unique
    "Negate, Inject & Restore snapshot", //The action text.
    &ah_negate_inject_and_restore, //The action handler.
    "Ctrl+Shift+I", //Optional: the action shortcut
    "Negates a condition, inject the solution and restore the snapshot", //Optional: the action tooltip (available in menus/toolbar)
    145); //Optional: the action icon (shows when in menus/toolbars)

struct ah_create_snapshot_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        ea_t xip;
        if (!get_ip_val(&xip)) {
            msg("Could not get the XIP value. This should never happen\n");
            return 0;
        }

        ponce_set_cmt(xip, "Snapshot taken here", false, true);
        ponce_set_item_color(xip, 0x00FFFF);

        snapshot.takeSnapshot();
        snapshot.setAddress(xip); // We will use this address later to delete the comment
        msg("Snapshot Taken\n");

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        //Only if process is being debugged and there is not previous snaphot
        if (is_debugger_on() && !snapshot.exists())
            return AST_ENABLE;
        else
            return AST_DISABLE;
    }
};
static ah_create_snapshot_t ah_create_snapshot;

static const action_desc_t action_IDA_createSnapshot = ACTION_DESC_LITERAL(
    "Ponce:create_snapshot",
    "Create Execution Snapshot",
    &ah_create_snapshot,
    "Ctrl+Shift+C",
    NULL,
    129);

struct ah_restore_snapshot_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        snapshot.restoreSnapshot();
        msg("Snapshot restored\n");

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        //Only if process is being debugged and there is an existent shapshot
        if (is_debugger_on() && snapshot.exists())
            return AST_ENABLE;
        else
            return AST_DISABLE;
    }
};
static ah_restore_snapshot_t ah_restore_snapshot;

static const action_desc_t action_IDA_restoreSnapshot = ACTION_DESC_LITERAL(
    "Ponce:restore_snapshot",
    "Restore Execution Snapshot",
    &ah_restore_snapshot,
    "Ctrl+Shift+S",
    NULL,
    128);

struct ah_delete_snapshot_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        snapshot.resetEngine();
        msg("[+] Snapshot removed\n");

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        //Only if there is an existent shapshot
        if (snapshot.exists())
            return AST_ENABLE;
        else
            return AST_DISABLE;
    }
};
static ah_delete_snapshot_t ah_delete_snapshot;

static const action_desc_t action_IDA_deleteSnapshot = ACTION_DESC_LITERAL(
    "Ponce:delete_snapshot",
    "Delete Execution Snapshot",
    &ah_delete_snapshot,
    "Ctrl+Shift+D",
    NULL,
    130);

struct ah_show_config_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        prompt_conf_window();

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        return AST_ENABLE_ALWAYS;
    }
};
static ah_show_config_t ah_show_config;

action_desc_t action_IDA_show_config = ACTION_DESC_LITERAL(
    "Ponce:show_config", // The action name. This acts like an ID and must be unique
    "Show config", //The action text.
    &ah_show_config, //The action handler.
    "Ctrl+Shift+P", //Optional: the action shortcut
    "Show the Ponce configuration", //Optional: the action tooltip (available in menus/toolbar)
    156); //Optional: the action icon (shows when in menus/toolbars)


/* The following two actions are going to be present in the formTaintWindow*/
struct ah_show_symbolicVarsWindow_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {       
        //So we don't reopen twice the same window
        if (ponce_table_chooser != nullptr) {
            //let's update it and change to it
            ponce_table_chooser->fill_entryList();
            
            auto form = find_widget(ponce_table_chooser->title);
            if (!form) {
                msg("[!!] Could not find %s widget\n", ponce_table_chooser->title);
                return 0;
            }
            refresh_chooser(ponce_table_chooser->title);                      
            activate_widget(form, true);
        }
        else{
            ponce_table_chooser = new ponce_table_chooser_t();
            ponce_table_chooser->choose();
        }
        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        return AST_ENABLE;
    }
};
static ah_show_symbolicVarsWindow_t ah_show_symbolicVars_Window;

action_desc_t action_IDA_show_expressionsWindow = ACTION_DESC_LITERAL(
    "Ponce:show_SymbolicVarsWindows", // The action name. This acts like an ID and must be unique
    "Show symbolic variables", //The action text.
    &ah_show_symbolicVars_Window, //The action handler.
    "Ctrl+Shift+Z", //Optional: the action shortcut
    "Show all the symbolic variables", //Optional: the action tooltip (available in menus/toolbar)
    157); //Optional: the action icon (shows when in menus/toolbars)


struct ah_action_chooser_add_constrain_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        int upper_limit_int, lower_limit_int;
        bool upper_set = false, lower_set = false;
        int res = ask_constrain(ctx->chooser_selection, &upper_limit_int, &lower_limit_int);

        // Let's clean the previous constrains if they exist
        for (const auto& index : ctx->chooser_selection) {
            auto list_item = ponce_table_chooser->table_item_list.at(index);
            if (ponce_table_chooser->constrains.count(list_item.id) > 0) {
                ponce_table_chooser->constrains.erase(list_item.id);
            }
        }

        if (res == -1) // user did not set any contrain
            return 0;
        else if (res == 2) { // user set both limits
            upper_set = true;
            lower_set = true;
        }
        else if (res == 1) {
            lower_set = true;
        }
        else if (res == 0) {
            upper_set = true;
        }


        auto ast = api.getAstContext();
        for (const auto& index : ctx->chooser_selection) {
            triton::ast::SharedAbstractNode ge, le;
            auto list_item = ponce_table_chooser->table_item_list.at(index);
            auto SymVar = ast->getVariableNode(list_item.var_name);
            if (upper_set) {
                ge = ast->bvsge(SymVar, ast->bv(lower_limit_int, SymVar->getBitvectorSize()));
                ponce_table_chooser->constrains[list_item.id].push_back(std::make_tuple(ge, list_item.var_name + " >= "+std::to_string(lower_limit_int)));
            }
            if (lower_set) {
                le = ast->bvsle(SymVar, ast->bv(upper_limit_int, SymVar->getBitvectorSize()));
                ponce_table_chooser->constrains[list_item.id].push_back(std::make_tuple(le, list_item.var_name + " <= " + std::to_string(upper_limit_int)));
            }
        }
        refresh_chooser(ponce_table_chooser->title);

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        update_action_label(ctx->action, "Set constraint to symbolic variable");

        if (!ponce_table_chooser || 
            ctx->chooser_selection.empty() ||
            cmdOptions.use_tainting_engine)
            return AST_DISABLE;

        if (ctx->chooser_selection.size() == 1) {
            char label[100] = { 0 };
            auto selection_row = ponce_table_chooser->table_item_list.at(ctx->chooser_selection[0]);
            qsnprintf(label, sizeof(label), "Set constraint to %s", selection_row.var_name.c_str());
            update_action_label(ctx->action, label);
        }

        else if (ctx->chooser_selection.size() > 1) {
            char label[100] = { 0 };
            qsnprintf(label, sizeof(label), "Set constraint to %d symbolic variables", ctx->chooser_selection.size());
            update_action_label(ctx->action, label);
        }
        return AST_ENABLE;
    }
};
static ah_action_chooser_add_constrain_t ah_action_chooser_add_constrain;

action_desc_t action_chooser_add_constrain = ACTION_DESC_LITERAL(
    "Ponce:action_chooser_add_constrain", // The action name. This acts like an ID and must be unique
    "Set constraint to symbolic variable", //The action text.
    &ah_action_chooser_add_constrain, //The action handler.
    "Alt+Shift+5", //Optional: the action shortcut
    "Set a constraint to a symbolic variable", //Optional: the action tooltip (available in menus/toolbar)
    111); //Optional: the action icon (shows when in menus/toolbars)


struct ah_action_chooser_comment_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        qstring response;
        if (ask_str(&response, 3, "New comment")) {
            for (const auto& index : ctx->chooser_selection) {             
                auto list_item = ponce_table_chooser->table_item_list.at(index);
                api.getSymbolicVariable(list_item.id)->setComment(std::string(response.c_str()));
                msg("[+] Comment %s set to %s\n", response.c_str(), list_item.var_name.c_str());
            }
            refresh_chooser(ponce_table_chooser->title);
        }
        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        update_action_label(ctx->action, "Set comment to symbolic variable");

        if (!ponce_table_chooser ||
            ctx->chooser_selection.empty() ||
            cmdOptions.use_tainting_engine)
            return AST_DISABLE;

        if (ctx->chooser_selection.size() == 1) {
            char label[100] = { 0 };
            auto selection_row = ponce_table_chooser->table_item_list.at(ctx->chooser_selection[0]);
            qsnprintf(label, sizeof(label), "Set comment to %s", selection_row.var_name.c_str());
            update_action_label(ctx->action, label);
        }

        else if(ctx->chooser_selection.size() > 1){
            char label[100] = { 0 };
            qsnprintf(label, sizeof(label), "Set comment to %d symbolic variables", ctx->chooser_selection.size());
            update_action_label(ctx->action, label);
        }
        return AST_ENABLE;
    }
};
static ah_action_chooser_comment_t ah_action_chooser_comment;

action_desc_t action_chooser_comment = ACTION_DESC_LITERAL(
    "Ponce:action_chooser_comment", // The action name. This acts like an ID and must be unique
    "Set a comment for variable", //The action text.
    &ah_action_chooser_comment, //The action handler.
    "Alt+Shift+4", //Optional: the action shortcut
    "Set comments to variable", //Optional: the action tooltip (available in menus/toolbar)
    111); //Optional: the action icon (shows when in menus/toolbars)


////////////////////////////


struct ah_unload_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        term();

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {       
        return AST_ENABLE_ALWAYS;
    }
};
static ah_unload_t ah_unload;

action_desc_t action_IDA_unload = ACTION_DESC_LITERAL(
    "Ponce:unload", // The action name. This acts like an ID and must be unique
    "Unload plugin", //The action text.
    &ah_unload, //The action handler.
    "Ctrl+Shift+U", //Optional: the action shortcut
    "Unload the plugin", //Optional: the action tooltip (available in menus/toolbar)
    138); //Optional: the action icon (shows when in menus/toolbars)


struct ah_clean_comments_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        delete_ponce_comments();

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        return AST_ENABLE_ALWAYS;
    }
};
static ah_clean_comments_t ah_clean;

action_desc_t action_IDA_clean = ACTION_DESC_LITERAL(
    "Ponce:clean", // The action name. This acts like an ID and must be unique
    "Clean comments & colours", //The action text.
    &ah_clean, //The action handler.
    "Ctrl+Shift+U", //Optional: the action shortcut
    "Clean all the comments and colours created by Ponce", //Optional: the action tooltip (available in menus/toolbar)
    65); //Optional: the action icon (shows when in menus/toolbars)


struct ah_enable_disable_tracing_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        if (ponce_runtime_status.runtimeTrigger.getState()) {
            // Ponce was already running (disable tracing)
            if (ask_for_execute_native()) {
                //Deleting previous snapshot
                snapshot.resetEngine();
                //Disabling step tracing...
                disable_step_trace();
                ponce_runtime_status.runtimeTrigger.disable();
                if (cmdOptions.showDebugInfo)
                    msg("[+] Disabling step tracing\n");
            }
        }
        else {
            // Ponce was not running (enable tracing)
            start_tainting_or_symbolic_analysis();
            tritonize(current_instruction());
            if (cmdOptions.showDebugInfo)
                msg("[+] Enabling step tracing\n");
        }

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        //Only if process is being debugged
        if (is_debugger_on()) {
            //We are using this event to change the text of the action
            if (ponce_runtime_status.runtimeTrigger.getState()) {
                update_action_label(ctx->action, "Disable ponce tracing");
                update_action_icon(ctx->action, 62);
            }
            else {
                update_action_label(ctx->action, "Enable ponce tracing");
                update_action_icon(ctx->action, 61);
            }
            return AST_ENABLE;
        }
        return AST_DISABLE;
    }
};
static ah_enable_disable_tracing_t ah_enable_disable_tracing;

//We need to define this struct before the action handler because we are using it inside the handler
action_desc_t action_IDA_enable_disable_tracing = ACTION_DESC_LITERAL(
    "Ponce:enable_disable_tracing",
    "Enable ponce tracing", //The action text.
    &ah_enable_disable_tracing, //The action handler.
    "Ctrl+Shift+E", //Optional: the action shortcut
    "Enable or Disable the ponce tracing", //Optional: the action tooltip (available in menus/toolbar)
    61); //Optional: the action icon (shows when in menus/toolbars)


struct ah_solve_formula_sub_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        // We get the symbolic condition index from the tooltip
        qstring tooltip;
        get_action_tooltip(&tooltip, ctx->action);
        auto offset = tooltip.find("Index: ");
        assert(offset != -1);
        //We extract the solved index from the action name
        unsigned int path_constraint_index = atoi((tooltip.c_str() + offset + 7)); // skip "Index: "
        if (cmdOptions.showDebugInfo)
            msg("[+] Solving condition at address " MEM_FORMAT " with symbolic condition index %d\n", ctx->cur_ea, path_constraint_index);
        
        std::thread t(solve_formula, ctx->cur_ea, path_constraint_index);
        t.detach();
        
        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        // The solve menus are added dynamically, this event is never called for them
        // We have still an menu action for solve that is always disabled to show the user that the option is there.
        return AST_DISABLE;
    }
};
ah_solve_formula_sub_t ah_solve_formula_sub;

action_desc_t action_IDA_solve_formula_sub = ACTION_DESC_LITERAL(
    "Ponce:solve_formula_sub", // The action name. This acts like an ID and must be unique
    "Solve formula", //The action text.
    &ah_solve_formula_sub, //The action handler.
    "", //Optional: the action shortcutaction_IDA_solve_formula_sub
    "This solves a specific condition and shows the result in the output window", //Optional: the action tooltip (available in menus/toolbar)
    13); //Optional: the action icon (shows when in menus/toolbars)

struct ah_solve_formula_choose_index_sub_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        static const char formTaintSymbolizeInput[] =
            "STARTITEM 1\n"
            "Select hit # to solve formula for\n\n"
            "<#The hit#Hit   \t:D2:16:16>\n"
            "\n"
            ;

        sval_t path_constraint_index = 0;
        if (ask_form(formTaintSymbolizeInput,
            &path_constraint_index
        ) > 0)
        {
            if (cmdOptions.showDebugInfo)
                msg("[+] Solving condition at address " MEM_FORMAT " with symbolic condition index %d\n", ctx->cur_ea, path_constraint_index);
            
            std::thread t(solve_formula, ctx->cur_ea, path_constraint_index);
            t.detach();
        }

        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        // The solve menus are added dynamically, this event is never called for them
        // We have still an menu action for solve that is always disabled to show the user that the option is there.
        return AST_DISABLE;
    }
};
ah_solve_formula_choose_index_sub_t ah_solve_formula_choose_index_sub;

action_desc_t action_IDA_solve_formula_choose_index_sub = ACTION_DESC_LITERAL(
    "Ponce:solve_formula_choose_index_sub", // The action name. This acts like an ID and must be unique
    "Hit N, choose index to solve formula", //The action text.
    &ah_solve_formula_choose_index_sub, //The action handler.
    "", //Optional: the action shortcut
    "Choose an arbitrary index to solve formula", //Optional: the action tooltip (available in menus/toolbar)
    13); //Optional: the action icon (shows when in menus/toolbars)



struct ah_ponce_banner_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        update_action_label(ctx->action, cmdOptions.use_tainting_engine ? "Ponce Plugin (Taint mode)" : "Ponce Plugin (Symbolic mode)");
        return AST_ENABLE;
    }
};
static ah_ponce_banner_t ah_ponce_banner;

//We need to define this struct before the action handler because we are using it inside the handler
action_desc_t action_IDA_ponce_banner = ACTION_DESC_LITERAL(
    "Ponce:banner",
    "Ponce Plugin", //The action text.
    &ah_ponce_banner, //The action handler.
    NULL, //Optional: the action shortcut
    "Use settings below while debugging", //Optional: the action tooltip (available in menus/toolbar)
    0); //Optional: the action icon (shows when in menus/toolbars)


struct ah_run_until_symbolic_t : public action_handler_t
{
    virtual int idaapi activate(action_activation_ctx_t* ctx)
    {
        ponce_runtime_status.run_and_break_on_symbolic_branch = true;
        request_continue_process();
        run_requests(); 
        
        // Reset tracer timing counter since user was using IDA and not just tracing
        ponce_runtime_status.tracing_start_time = GetTimeMs64();
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t* ctx)
    {
        if (is_debugger_on() && 
            ponce_runtime_status.runtimeTrigger.getState()/*and there is something symbolic*/) {
            return AST_ENABLE;
        }
        return AST_DISABLE;
    }
};
static ah_run_until_symbolic_t ah_run_until_symbolic;

//We need to define this struct before the action handler because we are using it inside the handler
action_desc_t action_IDA_run_until_symbolic = ACTION_DESC_LITERAL(
    "Ponce:run_until_symbolic_branch",
    "Run until symbolic condition", //The action text.
    &ah_run_until_symbolic, //The action handler.
    "Ctrl+Shift+F9", //Optional: the action shortcut
    "Continue running and stop on next symbolic condition", //Optional: the action tooltip (available in menus/toolbar)
    72); //Optional: the action icon (shows when in menus/toolbars)


/*This list defined all the actions for the plugin*/
struct IDA_actions action_list[] =
{
    { &action_IDA_ponce_banner, {0}, "" },

    { &action_IDA_enable_disable_tracing, { BWN_DISASM, __END__ }, "" },

    { &action_IDA_run_until_symbolic, { BWN_DISASM, __END__ }, "" },

    { &action_IDA_taint_symbolize_register, {0}, "Symbolic or taint/"},
    { &action_IDA_taint_symbolize_memory, {0}, "Symbolic or taint/" },

    { &action_IDA_negate_and_inject, { BWN_DISASM, __END__ }, "SMT Solver/" },
    { &action_IDA_negate_inject_and_restore, { BWN_DISASM, __END__ }, "SMT Solver/" },
    // Solve formula is handled separatly to be more user friendly
    // But still we want to register it in advance so it is always disable, so we define no views
    { &action_IDA_solve_formula_sub, { __END__ }, "SMT Solver/" },

    { &action_IDA_createSnapshot, { BWN_DISASM, __END__ }, "Snapshot/"},
    { &action_IDA_restoreSnapshot, { BWN_DISASM, __END__ }, "Snapshot/" },
    { &action_IDA_deleteSnapshot, { BWN_DISASM, __END__ }, "Snapshot/" },

    { &action_chooser_comment, { BWN_CHOOSER, __END__ }, "" },
    { &action_chooser_add_constrain, { BWN_CHOOSER, __END__ }, "" },

    { NULL, __END__, __END__ }
};

```

`src/actions.hpp`:

```hpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#pragma once

#define __END__ -1

/* Depending on the IDA version the SDK allows or not using some of the fetures we have*/
#if IDA_SDK_VERSION < 730
const int ponce_banner_views[] = { BWN_DISASM, BWN_DUMP, BWN_CHOOSER, __END__ };
const int ponce_taint_symbolize_mem_views[] = { BWN_DISASM, BWN_DUMP, __END__ };
const int ponce_taint_symbolize_reg_views[] = { BWN_DISASM, BWN_DUMP, __END__ };
#elif IDA_SDK_VERSION == 730
const int ponce_banner_views[] = { BWN_DISASM, BWN_DUMP, BWN_STKVIEW, BWN_CHOOSER, __END__ };
const int ponce_taint_symbolize_mem_views[] = { BWN_DISASM, BWN_DUMP, BWN_STKVIEW, __END__ };
const int ponce_taint_symbolize_reg_views[] = { BWN_DISASM, BWN_DUMP, BWN_STKVIEW, __END__ };
#elif IDA_SDK_VERSION >= 740
const int ponce_banner_views[] = { BWN_DISASM, BWN_CPUREGS, BWN_DUMP, BWN_STKVIEW, BWN_CHOOSER, __END__ };
const int ponce_taint_symbolize_mem_views[] = { BWN_DISASM, BWN_CPUREGS, BWN_DUMP, BWN_STKVIEW, __END__ };
const int ponce_taint_symbolize_reg_views[] = { BWN_DISASM, BWN_CPUREGS, BWN_DUMP, BWN_STKVIEW, __END__ };
#endif

struct IDA_actions {
    const action_desc_t* action_decs;
    int view_type[10]; // This are the posible views
    char const* menu_path; // this is where the item will be conteined in
};
extern struct IDA_actions action_list[];


extern action_desc_t action_IDA_show_config;
extern action_desc_t action_IDA_show_expressionsWindow;
extern action_desc_t action_IDA_clean;
extern action_desc_t action_IDA_unload;
extern action_desc_t action_IDA_solve_formula_sub;
extern action_desc_t action_IDA_negate_and_inject;
extern action_desc_t action_IDA_negate_inject_and_restore;
extern action_desc_t action_IDA_taint_symbolize_register;
extern action_desc_t action_IDA_taint_symbolize_memory;
extern action_desc_t action_IDA_ponce_banner;
extern action_desc_t action_IDA_solve_formula_choose_index_sub;


#define SYMBOLIC "Symbolic/"
#define symbolize_REG "Symbolize Register"
#define symbolize_MEM "Symbolize Memory"
#define TAINT "Taint/"
#define TAINT_REG "Taint Register"
#define TAINT_MEM "Taint Memory"
#define COMMENT_TAINT_REG "Make the selected register tainted"
#define COMMENT_SYMB_REG "Make the selected register symbolic"
#define COMMENT_TAINT_MEM "Make the selected memory tainted"
#define COMMENT_SYMB_MEM "Make the selected memory symbolic"
```

`src/blacklist.cpp`:

```cpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#include <iostream>
#include <fstream>

// Ponce
#include "blacklist.hpp"
#include "globals.hpp"
#include "callbacks.hpp"
#include "utils.hpp"
#include "triton_logic.hpp"

// IDA
#include <ida.hpp>
#include <dbg.hpp>
#include <loader.hpp>
#include <intel.hpp>
#include <bytes.hpp>

std::list<breakpoint_pending_action> breakpoint_pending_actions;

std::vector<std::string> builtin_black_functions = {
    "printf",
    "puts",
    "putc",
    "sleep",
    "recv",
    "recvfrom",
    "send",
    "closesocket",
    "exit",
    "abort",
    "malloc",
    "calloc",
    "realloc",
    "free",
    "calloc_crt",
    "realloc_crt",

    //cstdio
    "clearerr",
    "fclose",
    "feof",
    "ferror",
    "fflush",
    "fgetc",
    "fgetpos",
    "fgets",
    "fopen",
    "fprintf",
    "fputc",
    "fputs",
    "fread",
    "freopen",
    "fscanf",
    "fseek",
    "fsetpos",
    "ftell",
    "fwrite",
    "getc",
    "getchar",
    "gets",
    "perror",
    "printf",
    "putc",
    "putchar",
    "puts",
    "remove",
    "rename",
    "rewind",
    "scanf",
    "setbuf",
    "setvbuf",
    "snprintf",
    "sprintf",
    "sscanf",
    "tmpfile",
    "tmpnam",
    "ungetc",
    "vfprintf",
    "vfscanf",
    "vprintf",
    "vscanf",
    "vsnprintf",
    "vsprintf",
    "vsscanf",

    //Windows
    "Sleep",
    "HeapAlloc",
    "HeapFree",
    "HeapRealloc",
    "CreateThread",
    "NtTerminateProcess",
    "ExitThread",
    "TerminateThread",
    "ExitProcess",

    "EnterCriticalSection",
    "LeaveCriticalSection",
    "SendMessage",
    "WSAGetLastError",
    "WaitForSingleObject",
    "CloseHandle",
};

//Helper to concretize and untaint volatile registers
void concretizeAndUntaintVolatileRegisters()
{
    //ToDo: check how different compilers behave regarding volatile registers
#if defined(__i386) || defined(_M_IX86)
    char const* volatile_regs[] = { "eax", "ecx", "edx" };
#elif defined(__x86_64__) || defined(_M_X64)
    char const* volatile_regs[] = { "rax", "rcx", "rdx", "r8", "r8", "r10", "r11", "xmm6", "xmm7", "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15" };
#endif

    for (const auto& [reg_id, reg] : api.getAllRegisters())
    {
        for (auto i = 0; i < sizeof(volatile_regs) / sizeof(char*); i++) {
            if (strcmp(reg.getName().c_str(), volatile_regs[i]) == 0) {
                api.concretizeRegister(reg);
                api.untaintRegister(reg);
            }
        }
    }
}

//Helper to concretize and untaint all registers
void concretizeAndUntaintAllRegisters()
{
    api.concretizeAllRegister();
    //We untaint all the registers
    auto regs = api.getAllRegisters();
    for (auto it = regs.begin(); it != regs.end(); it++)
    {
        api.untaintRegister(it->second);
    }
}

/* We use this function to enable the trigger after a blacklisted function.
We are also concretizing all the registers. The idea is after call a external function
you couldn't assume any register has been unchanged, so we concretize all of them.*/
void enableTrigger_and_concretize_registers(ea_t main_address)
{
    ponce_runtime_status.runtimeTrigger.enable();
    concretizeAndUntaintVolatileRegisters();
}

void readBlacklistfile(char* path) {
    std::ifstream file(path);
    std::string str;
    blacklkistedUserFunctions = new std::vector<std::string>();
    while (std::getline(file, str)) {
        if (cmdOptions.showDebugInfo)
            msg("[+] Adding %s to the blacklist funtion list\n", str.c_str());
        blacklkistedUserFunctions->push_back(str);
    }
}


bool should_blacklist(ea_t pc, thid_t tid) {
    insn_t cmd;
    decode_insn(&cmd, pc);

    // We do this to blacklist API that does not change the tainted input
    if (cmd.itype == NN_call || cmd.itype == NN_callfi || cmd.itype == NN_callni)
    {
        //qstring callee = get_callee_name(pc);
        qstring callee;
        auto callee_lenght = get_func_name(&callee, pc);
        std::vector<std::string>* to_use_blacklist;

        //Let's check if the user provided any blacklist file or we sholuld use the built in one
        if (blacklkistedUserFunctions != nullptr) {
            to_use_blacklist = blacklkistedUserFunctions;
        }
        else {//We need to use the built in one
            to_use_blacklist = &builtin_black_functions;
        }

        for (const auto& blacklisted_function : *to_use_blacklist) {
            if (strcmp(callee.c_str(), blacklisted_function.c_str()) == 0)
            {
                //We are in a call to a blacklisted function.
                /*We should set a BP in the next instruction right after the
                blacklisted callback to enable tracing again*/
                ea_t next_ea = next_head(pc, BADADDR);
                add_bpt(next_ea, 1, BPT_EXEC);
                //We set a comment so the user know why there is a new bp there
                ponce_set_cmt(next_ea, "Temporal bp set by ponce for blacklisting\n", false);

                breakpoint_pending_action bpa;
                bpa.address = next_ea;
                bpa.ignore_breakpoint = false;
                bpa.callback = enableTrigger_and_concretize_registers; // We will enable back the trigger when this bp get's reached

                //We add the action to the list
                breakpoint_pending_actions.push_back(bpa);

                //Disabling step tracing...
                disable_step_trace();

                //We want to tritonize the call, so the memory write for the ret address in the stack will be restore by the snapshot
                tritonize(pc, tid);
                ponce_runtime_status.runtimeTrigger.disable();

                return true;
            }
        }
    }
    return false;
}
```

`src/blacklist.hpp`:

```hpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#pragma once
#include <vector>
#include <string>
#include <list>

#include <ida.hpp>
#include <idd.hpp>

//This struct is used to define a pending action when a breakpoint is triggered
typedef struct
{
    //The address where the breakpoint was set
    ea_t address;
    //If we found a previous breakpoint in the same address we should ignore it
    bool ignore_breakpoint;
    //This is the callback will be executed when this breakpoint is reached
    void(*callback)(ea_t);
} breakpoint_pending_action;

extern std::list<breakpoint_pending_action> breakpoint_pending_actions;


bool should_blacklist(ea_t pc, thid_t tid = 0);
```

`src/callbacks.cpp`:

```cpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#include <list>
#include <locale> 
#include <fstream>

// Ponce
#include "callbacks.hpp"
#include "globals.hpp"
#include "context.hpp"
#include "utils.hpp"
#include "blacklist.hpp"
#include "actions.hpp"
#include "triton_logic.hpp"

//IDA
#include <ida.hpp>
#include <dbg.hpp>
#include <loader.hpp>
#include <intel.hpp>
#include <bytes.hpp>

//Triton
#include "triton/api.hpp"
#include "triton/x86Specifications.hpp"

ssize_t idaapi tracer_callback(void* user_data, int notification_code, va_list va)
{
    //if (cmdOptions.showExtraDebugInfo)
    //    msg("[+] Notification code: %d str: %s\n", notification_code, notification_code_to_string(notification_code).c_str());
    switch (notification_code)
    {
    case dbg_process_start:
    case dbg_process_attach:
    {
        if (cmdOptions.showDebugInfo)
            msg("[+] Starting the debugged process. Reseting all the engines.\n");
        triton_restart_engines();        
        break;
    }
    case dbg_step_into:
    case dbg_step_over:
    {
        ponce_runtime_status.tracing_start_time = 0;
        break;
    }
    case dbg_trace:
    {
        //We only want to analyze the thread being analyzed
        if (ponce_runtime_status.analyzed_thread != get_current_thread())
            break;
        //If the trigger is disbaled then the user is manually stepping with the ponce tracing disabled
        if (!ponce_runtime_status.runtimeTrigger.getState())
            break;

        thid_t tid = va_arg(va, thid_t);
        ea_t pc = va_arg(va, ea_t);
        //Sometimes the cmd structure doesn't correspond with the traced instruction
        //With this we are filling cmd with the instruction at the address specified

        if (should_blacklist(pc, tid)) {
            // We have blacklisted this call so we should not keep going 
            return 0;
        }

        //If the instruciton is not a blacklisted call we analyze the instruction
        //We don't want to reanalize instructions. p.e. if we put a bp we receive two events, the bp and this one
        if (ponce_runtime_status.last_triton_instruction == NULL || (ponce_runtime_status.last_triton_instruction != NULL && ponce_runtime_status.last_triton_instruction->getAddress() != pc))
            tritonize(pc, tid);

        ponce_runtime_status.current_trace_counter++;
        ponce_runtime_status.total_number_traced_ins++;
        //Every 1000 traced instructions we show with debug that info in the output
        if (cmdOptions.showDebugInfo && ponce_runtime_status.total_number_traced_ins % 1000 == 0)
            msg("Instructions traced: %d Symbolic instructions: %d Symbolic conditions: %d Time: %lld secs\n", ponce_runtime_status.total_number_traced_ins, ponce_runtime_status.total_number_symbolic_ins, ponce_runtime_status.total_number_symbolic_conditions, GetTimeMs64() - ponce_runtime_status.tracing_start_time);
        //msg("[+] Instructions traced: %d\n", ponce_runtime_status.total_number_traced_ins);

        //This is the wow64 switching, we need to skip it. https://forum.hex-rays.com/viewtopic.php?f=8&t=4070
        if (ponce_runtime_status.last_triton_instruction->getDisassembly().find("call dword ptr fs:[0xc0]") != -1) {
            if (cmdOptions.showExtraDebugInfo)
                msg("[+] Wow64 switching! Requesting a step_over\n");
            //And now we need to stop the tracing, do step over and reenable the tracing...
            //disable_step_trace();
            suspend_process();
            //We don't want to do a real step over (it would reset the timer)
            ponce_runtime_status.ignore_wow64_switching_step = true;
            request_step_over();
            request_continue_process();
            run_requests();
            break;
        }

        //Check if the limit instructions limit was reached
        if (cmdOptions.limitInstructionsTracingMode && ponce_runtime_status.current_trace_counter >= cmdOptions.limitInstructionsTracingMode) {
            int answer = ask_yn(1, "[?] %u instructions has been traced. Do you want to execute %u more?", ponce_runtime_status.total_number_traced_ins, (unsigned int)cmdOptions.limitInstructionsTracingMode);
            if (answer == 0 || answer == -1)  { //No or Cancel
                // stop the trace mode and suspend the process
                disable_step_trace();
                suspend_process();
                msg("[!] Process suspended (Traced %d instructions)\n", ponce_runtime_status.total_number_traced_ins);
            }
            else {
                ponce_runtime_status.current_trace_counter = 0;
            }
        }

        //Check if the time limit for tracing was reached
        if (cmdOptions.limitTime != 0) {
            //This is the first time we start the tracer
            if (ponce_runtime_status.tracing_start_time == 0) {
                ponce_runtime_status.tracing_start_time = GetTimeMs64();
            }
            else if ((GetTimeMs64() - ponce_runtime_status.tracing_start_time) / 1000 >= cmdOptions.limitTime) {
                int answer = ask_yn(1, "[?] the tracing was working for %u seconds(%u inst traced!). Do you want to execute it %u more?", (unsigned int)((GetTimeMs64() - ponce_runtime_status.tracing_start_time) / 1000), ponce_runtime_status.total_number_traced_ins, (unsigned int)cmdOptions.limitTime);
                if (answer == 0 || answer == -1) { //No or Cancel
                    // stop the trace mode and suspend the process
                    disable_step_trace();
                    suspend_process();
                    msg("[!] Process suspended (Traced %d instructions)\n", ponce_runtime_status.total_number_traced_ins);
                }
                else {
                    ponce_runtime_status.tracing_start_time = GetTimeMs64();
                }
            }
        }
        break;
    }
    case dbg_bpt:
    {
        //We only want to analyze the thread being analyzed
        if (ponce_runtime_status.analyzed_thread != get_current_thread())
            break;
        msg("BP Instructions traced: %d Symbolic instructions: %d Symbolic conditions: %d Time: %lld secs\n", ponce_runtime_status.total_number_traced_ins, ponce_runtime_status.total_number_symbolic_ins, ponce_runtime_status.total_number_symbolic_conditions, GetTimeMs64() - ponce_runtime_status.tracing_start_time);

        thid_t tid = va_arg(va, thid_t);
        ea_t pc = va_arg(va, ea_t);
        int* warn = va_arg(va, int*);
        //This variable defines if a breakpoint is a user-defined breakpoint or not
        bool user_bp = true;
        //We look if there is a pending action for this breakpoint
        for (auto it = breakpoint_pending_actions.begin(); it != breakpoint_pending_actions.end(); ++it) {
            breakpoint_pending_action bpa = *it;
            //If we find a pendign action we execute the callback
            if (pc == bpa.address) {
                bpa.callback(pc);
                tritonize(pc, tid);

                //The pending breakpoints are used for enable the tracing so we consider this instruction tracing too
                ponce_runtime_status.current_trace_counter++;
                ponce_runtime_status.total_number_traced_ins++;
                //If there is a user-defined bp in the same address we should respect it and dont continue the exec
                if (!bpa.ignore_breakpoint) {
                    //If it's a breakpoint the plugin set not a user-defined bp
                    user_bp = false;
                    //If not this is the bp we set to taint the arguments, we should rmeove it and continue the execution
                    del_bpt(pc);
                    enable_step_trace(true);
                    //We dont want to skip library funcions or debug segments
                    set_step_trace_options(0);
                    continue_process();
                    //We delete the comment
                    ponce_set_cmt(pc, "", false);
                    breakpoint_pending_actions.erase(it);
                }
                break;
            }
        }
        //If it is a user break point we enable again the step tracing if it was enabled previously...
        //The idea is if the user uses Execute native til next bp, and IDA reachs the next bp we reenable the tracing
        if (user_bp) {
            ponce_runtime_status.tracing_start_time = 0;
            //request_suspend_process();
            //run_requests();
            //disable_step_trace();
            //request_enable_step_trace();
            //If the trigger is disabled then the user is manually stepping with the ponce tracing disabled
            //if (ponce_runtime_status.runtimeTrigger.getState())
            //enable_step_trace(ponce_runtime_status.runtimeTrigger.getState());
        }
        break;
    }
    case dbg_process_exit:
    {
        if (cmdOptions.showDebugInfo)
            msg("[!] Process_exiting...\n");
        //Do we want to unhook this event? I don't think so we want to be hooked for future sessions
        //unhook_from_notification_point(HT_DBG, tracer_callback, NULL);
        ponce_runtime_status.runtimeTrigger.disable();
        enable_step_trace(false);
        //Removing snapshot if it exists
        if (snapshot.exists())
            snapshot.resetEngine();
        break;
    }
    }
    return 0;
}

/*  Mode 0: Only one posible formula to be solved ("Solve formula to take " MEM_FORMAT)
    Mode 1: Multiple posible formulas to be solved ("Hit %u, taken -> " MEM_FORMAT)
    Mode 2: Chose arbitrary path_constraint_index to solve formula ("Choose index to solve formula" MEM_FORMAT)
*/
bool attach_action_solve(triton::uint64 dstAddr, unsigned int path_constraint_index, TWidget* form, TPopupMenu* popup_handle, int mode) {
    action_desc_t action;
    
    char label[256];
    char tooltip[256];
    char name[256];
    char popup_name[] = "SMT Solver/Solve formula (Multiple hits)/";

    if (mode == 0) {
        action = action_IDA_solve_formula_sub;       
        qsnprintf(label, sizeof(label), "Solve formula to take " MEM_FORMAT, dstAddr);
        //We need the path constraint index during the action activate
        qsnprintf(tooltip, 255, "%s. Index: %u", action_IDA_solve_formula_sub.tooltip, path_constraint_index);
        qsnprintf(popup_name, sizeof(popup_name), "SMT Solver/Solve formula");

        action.name = "Ponce:solve_formula_one_branch";
        action.label = label;
        action.tooltip = tooltip;
    }
    else if (mode == 1) {
        action = action_IDA_solve_formula_sub;
        qsnprintf(name, 255, "[%u]Ponce:solve_formula_sub", path_constraint_index);      
        qsnprintf(label, 255, "Hit %u, taken -> " MEM_FORMAT, path_constraint_index, dstAddr);
        //We need the path constraint index during the action activate
        qsnprintf(tooltip, 255, "%s. Index: %u", action_IDA_solve_formula_sub.tooltip, path_constraint_index);

        action.name = name;
        action.label = label;
        action.tooltip = tooltip;
    }
    else if(mode == 2){
        action = action_IDA_solve_formula_choose_index_sub;  
    }

    bool success = register_action(action);
    //If the submenu is already registered, we should unregister it and re-register it
    if (!success) {
        unregister_action(action.name);
        success = register_action(action);
    }
    assert(success);
    success = attach_action_to_popup(form, popup_handle, action.name, popup_name, SETMENU_INS);
    assert(success);
    return success;
}

//---------------------------------------------------------------------------
// Callback for ui notifications
ssize_t idaapi ui_callback(void* ud, int notification_code, va_list va)
{
    switch (notification_code)
    {
        // Called when IDA is preparing a context menu for a view
        // Here dynamic context-depending user menu items can be added.
    case ui_populating_widget_popup:
    {
        TWidget* form = va_arg(va, TWidget*);
        TPopupMenu* popup_handle = va_arg(va, TPopupMenu*);
        int view_type = get_widget_type(form);
        bool success;

        // Set the name for the action depending if using tainting or symbolic engine
        if (cmdOptions.use_tainting_engine) {
            action_list[3].menu_path = TAINT;
            action_list[4].menu_path = TAINT;
        }
        else {
            action_list[3].menu_path = SYMBOLIC;
            action_list[4].menu_path = SYMBOLIC;
        }

        //Adding a separator
        success = attach_action_to_popup(form, popup_handle, "", SETMENU_INS);

        /*Iterate over all the actions*/
        for (int i = 0;; i++) {
            if (action_list[i].action_decs == NULL)
                break;

            if (cmdOptions.use_tainting_engine && strcmp(action_list[i].menu_path, "SMT Solver/") == 0) {
                /* Do not populate SMT Solver options if we use the tainting engine*/
                continue;
            }

            /*Iterate over the view types of every action*/
            for (int j = 0;; j++) {
                if (action_list[i].view_type[j] == __END__) {
                    break;
                }
                if (action_list[i].view_type[j] == view_type) {  
                    success = attach_action_to_popup(form, popup_handle, action_list[i].action_decs->name, action_list[i].menu_path, SETMENU_INS);
                    //msg("name: %s menu path: %s success: %s\n", action_list[i].action_decs->name, action_list[i].menu_path, success ? "true" : "false");
                }
            }
        }   

        //Adding a separator
        success = attach_action_to_popup(form, popup_handle, "", SETMENU_INS);

        ea_t cur_ea = get_screen_ea();

        /* Here we fill the posible SMT branches to solve if there is multiple*/
        if (view_type == BWN_DISASM) {
            //&& !(is_debugger_on() && !ponce_runtime_status.runtimeTrigger.getState())) { // Don't let solve formulas if user is debugging natively 

            for (const auto& pc : api.getPathConstraints()) {
                auto temp = pc.getBranchConstraints();
            }
            /* For the selected address(cur_ea), let's count how many branches we can reach (how many non taken addresses are in reach)*/
            int non_taken_branches_n = std::count_if(api.getPathConstraints().begin(), api.getPathConstraints().end(), [cur_ea](const auto& pc) {
                for (auto const& [taken, srcAddr, dstAddr, pc] : pc.getBranchConstraints()) {
                    if (cur_ea == srcAddr && !taken) return true;
                }
                return false;
                });


            if (non_taken_branches_n == 0) {
                // Disabled menu (so the user knows it's an option in some cases), already registered, we just need to attach it to the popup
                attach_action_to_popup(form, popup_handle, action_IDA_solve_formula_sub.name, "SMT Solver/Solve formula", SETMENU_INS);
            }
            else if (non_taken_branches_n == 1) {
                // There is only one non taken branch, no need to add submenus
                // But we need to modify the Solve Formula menu with more info and the path constraint index
                // The tooltip is not updated on the update event, we need to unregister the Solve formula submenu and add a new one
                unsigned int path_constraint_index = 0;
                for (const auto& pc : api.getPathConstraints()) {
                    for (auto const& [taken, srcAddr, dstAddr, pc] : pc.getBranchConstraints()) {
                        if (cur_ea == srcAddr && !taken) { // get the non taken branch for the path constraint the user clicked on          
                            // Using the solve formula as template
                            attach_action_solve(dstAddr, path_constraint_index, form, popup_handle, 0);
                            break;
                        }
                    }
                    path_constraint_index++;
                }
            }
            else {
                // There are more than one non taken branches, we add submenus
                // Fix https://github.com/illera88/Ponce/issues/116
                if (non_taken_branches_n <= 5) {
                    unsigned int path_constraint_index = 0;
                    for (const auto& pc : api.getPathConstraints()) {
                        for (auto const& [taken, srcAddr, dstAddr, pc] : pc.getBranchConstraints()) {
                            if (cur_ea == srcAddr && taken) { // get the taken branch for the path constraint the user clicked on          
                                // Using the solve formula as template (If not we modify the name of the main solve formula menu)
                                attach_action_solve(dstAddr, path_constraint_index, form, popup_handle, 1);    
                                break;
                            }
                        }
                        path_constraint_index++;
                    }
                }
                else {
                    /*  If there are more than 5 posible solutions to solve we are gonna use in this order
                        - The first two
                        - An option to select an arbitrary hit
                        - The last two*/
                    unsigned int path_constraint_index = 0;
                    unsigned int count = 0;
                    // Show the first two
                    for (const auto& pc : api.getPathConstraints()) {
                        for (auto const& [taken, srcAddr, dstAddr, pc] : pc.getBranchConstraints()) {
                            if (cur_ea == srcAddr && taken) { // get the taken branch for the path constraint the user clicked on          
                                if (count == 2) // Only adding the first two
                                    break;
                                // Using the solve formula as template (If not we modify the name of the main solve formula menu)
                                attach_action_solve(dstAddr, path_constraint_index, form, popup_handle, 1);
                                count++;
                                break;
                            }
                        }
                        path_constraint_index++;
                    }

                    // Option to select an arbitrary hit
                    attach_action_solve(NULL, 0, form, popup_handle, 2);

                    path_constraint_index = non_taken_branches_n;
                    count = 0;
                    struct pair_address_index {
                        unsigned int index;
                        triton::uint64 dstAddr;
                    };
                    struct pair_address_index holder[2] = {0};
                    // Show the last two
                    for (auto rit = std::rbegin(api.getPathConstraints()); rit != std::rend(api.getPathConstraints()); ++rit) {
                        for (auto const& [taken, srcAddr, dstAddr, pc] : rit->getBranchConstraints()) {
                            if (cur_ea == srcAddr && taken) { // get the taken branch for the path constraint the user clicked on          
                                if (count == 2) // Only adding the first two
                                    break;
                                // Using the solve formula as template (If not we modify the name of the main solve formula menu)
                                // Keep in holder the last two items so we add them ad the en in asc order
                                holder[count] = { path_constraint_index, dstAddr };
                                count++;
                                break;
                            }
                        }
                        path_constraint_index--;
                    }
                    attach_action_solve(holder[1].dstAddr, holder[1].index, form, popup_handle, 1);
                    attach_action_solve(holder[0].dstAddr, holder[0].index, form, popup_handle, 1);
                }
            }
        }

        break;
    }
    case dbg_process_exit:
    {
        unhook_from_notification_point(HT_DBG, ui_callback, NULL);
        break;
    }
    }
    return 0;
}



```

`src/callbacks.hpp`:

```hpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#pragma once

#include <idp.hpp>

ssize_t idaapi tracer_callback(void* /*user_data*/, int notification_code, va_list va);
ssize_t idaapi ui_callback(void* /*ud*/, int notification_code, va_list va);

```

`src/context.cpp`:

```cpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#include <cstring>
#include <stdexcept>

//Triton
#include <triton/cpuSize.hpp>
#include <triton/coreUtils.hpp>
#include <triton/x86Specifications.hpp>
#include <triton/api.hpp>

#include "context.hpp"
#include "globals.hpp"

//IDA
#include <dbg.hpp>
#include <pro.h>
#include <bytes.hpp>
//Ponce
#include "globals.hpp"

/* Get a memory value from IDA debugger*/
triton::uint512 IDA_getCurrentMemoryValue(ea_t addr, triton::uint32 size)
{
    if (size > triton::size::max_supported) {
        warning("[!] getCurrentMemoryValue() error, size can't be larger than %u bytes (%u)\n", triton::size::max_supported, triton::size::max_supported * 8);
        return -1;
    }
    triton::uint8 buffer[64] = { 0 };
    //This is the way to force IDA to read the value from the debugger
    //More info here: https://www.hex-rays.com/products/ida/support/sdkdoc/dbg_8hpp.html#ac67a564945a2c1721691aa2f657a908c
    invalidate_dbgmem_contents(addr, size);
    get_bytes(&buffer, size, addr, GMB_READALL, NULL);

    triton::uint512 value = 0;
    switch (size) {
    case triton::size::byte:    value = *(reinterpret_cast<triton::uint8*>(buffer));  break;
    case triton::size::word:    value = *(reinterpret_cast<triton::uint16*>(buffer)); break;
    case triton::size::dword:   value = *(reinterpret_cast<triton::uint32*>(buffer)); break;
    case triton::size::qword:   value = *(reinterpret_cast<triton::uint64*>(buffer)); break;
    case triton::size::dqword:  value = triton::utils::cast<triton::uint128>(reinterpret_cast<triton::uint8*>(buffer)); break;
    case triton::size::qqword:  value = triton::utils::cast<triton::uint256>(reinterpret_cast<triton::uint8*>(buffer)); break;
    case triton::size::dqqword: value = triton::utils::cast<triton::uint512>(reinterpret_cast<triton::uint8*>(buffer)); break;
    }

    return value;
    return triton::utils::cast<triton::uint512>(buffer);
}

/*This callback is called when triton is processing a instruction and it needs a memory value to build the expressions*/
void needConcreteMemoryValue_cb(triton::API& api, const triton::arch::MemoryAccess& mem)
{
    bool had_it = false;
    auto IDA_memValue = IDA_getCurrentMemoryValue((ea_t)mem.getAddress(), mem.getSize());

    if (api.isConcreteMemoryValueDefined(mem)) {
        auto triton_memValue = api.getConcreteMemoryValue(mem, false);
        if ((IDA_memValue != triton_memValue)) {
            api.setConcreteMemoryValue(mem, IDA_memValue);
            had_it = false;
        }
        had_it = true;
    }
    else {
        api.setConcreteMemoryValue(mem, IDA_memValue);
    }

    if (cmdOptions.showExtraDebugInfo) {
        char ascii_value[5] = { 0 };
        if (std::isprint(static_cast<unsigned char>(IDA_memValue)))
            qsnprintf(ascii_value, sizeof(ascii_value), "(%c)", static_cast<char>(IDA_memValue));
        std::stringstream stream;
        stream << std::nouppercase << std::hex << IDA_memValue;
        msg("[+] Triton asking IDA for %s syncronized memory address: " MEM_FORMAT " Size: %u. Value: 0x%s %s\n", 
            had_it ? "already" : "not", 
            (ea_t)mem.getAddress(), 
            mem.getSize(), 
            stream.str().c_str(),
            std::isprint(static_cast<unsigned char>(IDA_memValue)) ? ascii_value : "");
    }
}

/* Get a reg value from IDA debugger*/
triton::uint512 IDA_getCurrentRegisterValue(const triton::arch::Register& reg)
{
    regval_t reg_value;
    triton::uint512 value = 0;
    auto reg_name = reg.getName();
    assert(!reg_name.empty());
    //We need to invalidate the registers. If not IDA uses the last value when program was stopped
    invalidate_dbg_state(DBGINV_REGS);
    get_reg_val(reg_name.c_str(), &reg_value);
    value = reg_value.ival;
    /* Sync with the libTriton */
    triton::arch::Register syncReg;
    if (reg.getId() >= api.registers.x86_af.getId() && reg.getId() <= api.registers.x86_zf.getId())
        syncReg = api.registers.x86_eflags;
    else if (reg.getId() >= api.registers.x86_sse_ie.getId() && reg.getId() <= api.registers.x86_sse_fz.getId())
        syncReg = api.registers.x86_mxcsr;
    else
        syncReg = api.getRegister(reg.getParent());

    return value;
}

/*This callback is called when triton is processing a instruction and it needs a regiter to build the expressions*/
void needConcreteRegisterValue_cb(triton::API& api, const triton::arch::Register& reg)
{
    bool had_it = true;
    auto IDA_regValue = IDA_getCurrentRegisterValue(reg);
    auto triton_regValue = api.getConcreteRegisterValue(reg, false);

    if (IDA_regValue != triton_regValue) {
        api.setConcreteRegisterValue(reg, IDA_regValue);
        had_it = false;
    }
 
    if (cmdOptions.showExtraDebugInfo) {
        char ascii_value[5] = { 0 };
        if (std::isprint(static_cast<unsigned char>(IDA_regValue)))
            qsnprintf(ascii_value, sizeof(ascii_value), "(%c)", static_cast<char>(IDA_regValue));
        
        std::stringstream stream;
        stream << std::nouppercase << std::hex << IDA_regValue;
        msg("[+] Triton asking IDA for %s syncronized register: %s. IDA returns value: 0x%s %s\n",
            had_it ? "already" : "not",
            reg.getName().c_str(),
            stream.str().c_str(),
            std::isprint(static_cast<unsigned char>(IDA_regValue)) ? ascii_value : "");
    }
}





```

`src/context.hpp`:

```hpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#pragma once
//Triton
#include <triton/api.hpp>
//IDA
#include <pro.h> 

void needConcreteMemoryValue_cb(triton::API& api, const triton::arch::MemoryAccess& mem);
void needConcreteRegisterValue_cb(triton::API& api, const triton::arch::Register& reg);
triton::uint512 IDA_getCurrentMemoryValue(ea_t addr, triton::uint32 size);
triton::uint512 IDA_getCurrentRegisterValue(const triton::arch::Register& reg);
```

`src/formConfiguration.cpp`:

```cpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

//IDA
#include <pro.h>
#include <idp.hpp>
#include <loader.hpp>
#include <kernwin.hpp>

//Ponce
#include "formConfiguration.hpp"
#include "globals.hpp"
#include "utils.hpp"

//--------------------------------------------------------------------------
//This function is used to activate or deactivate other items in the form while using it
int idaapi modcb(int fid, form_actions_t& fa)
{
    ushort isActivated = 0;
    switch (fid)
    {
    case -1: // called at the begining
        fa.get_checkbox_value(3, &isActivated); // get symbolic engine value
        fa.enable_field(8, isActivated ? 1 : 0);
        fa.enable_field(9, isActivated ? 1 : 0);
        fa.enable_field(12, isActivated ? 1 : 0);
        fa.enable_field(13, isActivated ? 1 : 0);
        fa.enable_field(14, !isActivated ? 1 : 0); // TAINT_THROUGH_POINTERS only when tainting engine
        break;
    case -2:
        break;
    case 3:
    case 4:
        fa.get_checkbox_value(3, &isActivated); // get symbolic engine value
        fa.enable_field(8, isActivated ? 1 : 0);
        fa.enable_field(9, isActivated ? 1 : 0);
        fa.enable_field(12, isActivated ? 1 : 0);
        fa.enable_field(13, isActivated ? 1 : 0);
        fa.enable_field(14, !isActivated ? 1 : 0); // TAINT_THROUGH_POINTERS only when tainting engine
        break;
    case 5:
        fa.get_checkbox_value(5, &isActivated);
        if (!isActivated)
            fa.set_checkbox_value(6, &isActivated);
        break;
    case 6:
        // if extra verbosity set then regular verbosity set too
        fa.get_checkbox_value(6, &isActivated);
        if(isActivated)
            fa.set_checkbox_value(5, &isActivated);
        break;
    default:
        break;
    }
    return 1;
}

/*IDA windows style is a FUMADA!!
If you want to create a new checkbox you should:
- add it to the form variable that its in formChoser.hpp
- Create the global variable in cmdOptions
- if you want to inizialize it to something do it in the first if of the function (if (!cmdOptions.already_configured))
- in the else you should add the correspondant item in the chkgroup where you are adding the item
- if AskUsingForm_c success (user clicks accept) set the value of your item from his correspondent chkgroupX
- add it to the msg at the end of the function for debug purposes*/
void prompt_conf_window(void) {
    /*We should create as many ushort variables as groups of checkboxes we have in the form window*/
    ushort chkgroup1, chkgroup2, chkgroup3;
    ushort symbolic_or_taint_engine = 0;

    if (!cmdOptions.already_configured) {
        //Here we can initialize the checkboxes by group. use 1 | 2 .. to select multiple 
        chkgroup1 = 1;
        chkgroup2 = 0;
        chkgroup3 = 1 | 2;

        cmdOptions.blacklist_path[0] = '\0'; // Will use this to check if the user set some path for the blacklist
    }
    else {
        /*By default all the variables are set to false. If the user wants to change the configuration
        after using the plugin we should set the variables to the previously set configuration. If we
        don't do this the variables will be always initialized to  the previous lines
        NOTE: Parenthesis are mandatory or it won't work!*/
        chkgroup1 = (cmdOptions.showDebugInfo ? 1 : 0) | (cmdOptions.showExtraDebugInfo ? 2 : 0);
        chkgroup2 = (cmdOptions.CONCRETIZE_UNDEFINED_REGISTERS ? 1 : 0) | (cmdOptions.CONSTANT_FOLDING ? 2 : 0) | (cmdOptions.SYMBOLIZE_INDEX_ROTATION ? 4 : 0) | (cmdOptions.AST_OPTIMIZATIONS ? 8 : 0) | (cmdOptions.TAINT_THROUGH_POINTERS ? 16 : 0);
        chkgroup3 = (cmdOptions.addCommentsControlledOperands ? 1 : 0) | (cmdOptions.RenameTaintedFunctionNames ? 2 : 0) | (cmdOptions.addCommentsSymbolicExpresions ? 4 : 0);

        symbolic_or_taint_engine = cmdOptions.use_symbolic_engine ? 0 : 1;
    }
    if (ask_form(form,
        modcb,
        &symbolic_or_taint_engine,
        &chkgroup1,
        &chkgroup2,
        &chkgroup3,
        &cmdOptions.limitTime,
        &cmdOptions.limitInstructionsTracingMode,
        &cmdOptions.solver_timeout,
        &cmdOptions.color_tainted,
        &cmdOptions.color_executed_instruction,
        &cmdOptions.color_tainted_condition,
        &cmdOptions.blacklist_path
    ) > 0)
    {
        /*First we set the flag that indicates that the user already provided a configuration
        so we should't use the default values anymore but the ones that the user provided previously*/
        cmdOptions.already_configured = true;

        // Get the user selection for the exclusive checkboxes
        switch (symbolic_or_taint_engine) {
        case 0: // Symbolic engine
            cmdOptions.use_symbolic_engine = true;
            cmdOptions.use_tainting_engine = false;
            break;
        case 1: // Tainting engine
            cmdOptions.use_tainting_engine = true;
            cmdOptions.use_symbolic_engine = false;
            break;
        }

        /*Now that the user pressed accept we need to transform the chkgroups to actual booleans for cmdOptions*/
        cmdOptions.showDebugInfo = chkgroup1 & 1 ? 1 : 0;
        cmdOptions.showExtraDebugInfo = chkgroup1 & 2 ? 1 : 0;
        //
        cmdOptions.CONCRETIZE_UNDEFINED_REGISTERS = chkgroup2 & 1 ? 1 : 0;
        cmdOptions.CONSTANT_FOLDING = chkgroup2 & 2 ? 1 : 0;
        cmdOptions.SYMBOLIZE_INDEX_ROTATION = chkgroup2 & 4 ? 1 : 0;
        cmdOptions.AST_OPTIMIZATIONS = chkgroup2 & 8 ? 1 : 0;
        cmdOptions.TAINT_THROUGH_POINTERS = chkgroup2 & 16 ? 1 : 0;
        
        // Make sure that modes are correctly set since some engines
        // can't have some modes activated
        if (cmdOptions.use_symbolic_engine) {
            cmdOptions.TAINT_THROUGH_POINTERS = false;
        }
        else {
            cmdOptions.CONCRETIZE_UNDEFINED_REGISTERS = false;
            cmdOptions.CONSTANT_FOLDING = false;
            cmdOptions.SYMBOLIZE_INDEX_ROTATION = false;
            cmdOptions.AST_OPTIMIZATIONS = false;
        }

        cmdOptions.addCommentsControlledOperands = chkgroup3 & 1 ? 1 : 0;
        cmdOptions.RenameTaintedFunctionNames = chkgroup3 & 2 ? 1 : 0;
        cmdOptions.addCommentsSymbolicExpresions = chkgroup3 & 4 ? 1 : 0;

        if (cmdOptions.blacklist_path[0] != '\0') {
            //Means that the user set a path for custom blacklisted functions
            if (blacklkistedUserFunctions != NULL) {
                //Check if we had a previous custom blacklist and if so we delete it
                blacklkistedUserFunctions->clear();
                delete blacklkistedUserFunctions;
                blacklkistedUserFunctions = NULL;
            }
            readBlacklistfile(cmdOptions.blacklist_path);
        }

        save_options(&cmdOptions);
        if (cmdOptions.showDebugInfo) {
            msg("\n"
                "limitTime: %lld\n"
                "limitInstructionsTracingMode: %lld\n"
                "solver_timeout: %lld\n"
                "use_symbolic_engine: %s\n"
                "showDebugInfo: %s\n"
                "showExtraDebugInfo: %s\n"
                "CONCRETIZE_UNDEFINED_REGISTERS: %s\n"
                "CONSTANT_FOLDING: %s\n"
                "SYMBOLIZE_INDEX_ROTATION: %s\n"
                "AST_OPTIMIZATIONS: %s\n"
                "TAINT_THROUGH_POINTERS: %s\n"
                "addCommentsControlledOperands: %s\n"
                "RenameTaintedFunctionNames: %s\n"
                "addCommentssymbolizexpresions: %s\n"
                "color_tainted: %x\n"
                "color_executed_instruction: %x\n"
                "color_tainted_condition: %x\n",
                cmdOptions.limitTime,
                cmdOptions.limitInstructionsTracingMode,
                cmdOptions.solver_timeout,
                cmdOptions.use_symbolic_engine ? "symbolic engine enabled" : "tainting engine enabled",
                cmdOptions.showDebugInfo ? "true" : "false",
                cmdOptions.showExtraDebugInfo ? "true" : "false",
                cmdOptions.CONCRETIZE_UNDEFINED_REGISTERS ? "true" : "false",
                cmdOptions.CONSTANT_FOLDING ? "true" : "false",
                cmdOptions.SYMBOLIZE_INDEX_ROTATION ? "true" : "false",
                cmdOptions.AST_OPTIMIZATIONS ? "true" : "false",
                cmdOptions.TAINT_THROUGH_POINTERS ? "true" : "false",
                cmdOptions.addCommentsControlledOperands ? "true" : "false",
                cmdOptions.RenameTaintedFunctionNames ? "true" : "false",
                cmdOptions.addCommentsSymbolicExpresions ? "true" : "false",
                cmdOptions.color_tainted,
                cmdOptions.color_executed_instruction,
                cmdOptions.color_tainted_condition
            );
        }
    }
}
```

`src/formConfiguration.hpp`:

```hpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#pragma once
//IDA
#include <ida.hpp>
#include "globals.hpp"

int idaapi modcb(int fid, form_actions_t& fa);
void idaapi btn_cb(TWidget* [], int);
void prompt_conf_window(void);

static const char form[] =
"STARTITEM 0\n"
"Ponce Configuration\n\n"
"%/"

// Choser between using only the tainting engine or the symbolic one
"<#It will let you perform symbolic execution and track user controlled input#Select engine to use#Symbolic Engine:R3>\n"
"<#It allow you to track user controlled input#Taint Engine:R4>>\n"
//
"<#Show debug info#Verbosity#Show Ponce debug info:C5>\n"
"<#Max debug verbosity#Show EXTRA Ponce debug info:C6>>\n"
//
"<#Concretize every registers tagged as undefined#Optimizations#CONCRETIZE_UNDEFINED_REGISTERS:C8>\n"
"<#Perform a constant folding optimization of sub ASTs which do not contain symbolic variables#CONSTANT_FOLDING:C9>\n"
"<#Symbolize index rotation for bvrol and bvror. This mode increases the complexity of solving#SYMBOLIZE_INDEX_ROTATION:C12>\n"
"<#Classical arithmetic optimisations to reduce the depth of the trees#AST_OPTIMIZATIONS:C13>\n"
"<#Spread the taint if an index pointer is already tainted#TAINT_THROUGH_POINTERS:C14>>\n"
//
"<#Add comments to controlled operands#IDA View expand info#Add comments with controlled operands:C15>\n"
"<#This helps to track the tainted functions in large programms#Add prefix to tainted function names:C16>\n"
"<#Will add a comment for every instruction with his symbolic expression. Will pollute the IDA view.#Add comments with symbolic expresions:C17>>\n"
"\n"
"Ponce will heads up you after:\n"
"<#Time in seconds#Seconds running               :D1:12:12>\n"
"<#Number of the instructions executed during tracing before ask to the user#Instructions executed         :D2:12:12>\n"
"\n"
"<#Time in seconds#Solver timeout               :D23:12:12>\n"
"\n"
"<#-1 is default colour#Color Tainted Instruction     :K19:::>\n"
"<#-1 is default colour#Color Executed Instruction    :K20:::>\n"
"<#-1 is default colour#Color Tainted Condition       :K21:::>\n"
"\n"
"<#Ponce will blacklist some functions that do not modify the passed parameters. You can select a file with the functions you want to blacklist#Function blacklist file path:f22::18:>\n"

"\n"
;

```

`src/formTaintSymbolizeInput.cpp`:

```cpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

//IDA
#include <pro.h>
#include <idp.hpp>
#include <loader.hpp>
#include <kernwin.hpp>

//Triton
#include <triton/api.hpp>

//Ponce
#include "formTaintSymbolizeInput.hpp"
#include "globals.hpp"
#include "utils.hpp"

/*Function to show a dialog to the user asking for an address and a size to taint/symbolize.
It returns a MemoryAccess with the memory address and the size indicated. the caller need to free this object*/
bool prompt_window_taint_symbolize(ea_t address, sval_t size, ea_t *selection_start, ea_t *selection_end)
{
	char format[125] = { 0 };
	if (ask_form(formTaintSymbolizeInput,
		NULL,
		&address,
		&size
		) > 0)
	{
		*selection_start = address;
		*selection_end = address + size;
		return true;
	}
	return false;
}
```

`src/formTaintSymbolizeInput.hpp`:

```hpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#pragma once
//Triton
#include <triton/api.hpp>

//IDA
#include <ida.hpp>

bool prompt_window_taint_symbolize(ea_t address, sval_t size, ea_t* selection_start, ea_t* selection_end);

static const char formTaintSymbolizeInput[] =
"STARTITEM 1\n"
"Symbolize/Taint memory range\n\n"
"%/"
"<#The memory address in hex#Address\t:M1:16:16>\n"
"<#The size#Size   \t:D2:16:16>\n"
"\n"
;
```

`src/globals.cpp`:

```cpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

/*This file containts all the global variables used around the plugin code*/
#include <map>
//Ponce
#include "globals.hpp"
#include "trigger.hpp"
//Triton
#include <triton/api.hpp>

#include <ida.hpp>
//A variable to store if the plugin has hooked the ui and debugger events
bool hooked = false;

//This struct stores all the global variables used for the current state of the Ponce plugin during execution
//The idea is restore this sctruct when we restore the snapshot
runtime_status_t ponce_runtime_status;

//Options
struct cmdOptionStruct cmdOptions;

//Snapshot object, defined in the snapshot.cpp
Snapshot snapshot = Snapshot();

//Used to point to the vector of blacklisted user functions
std::vector<std::string>* blacklkistedUserFunctions = nullptr;

triton::API api;

std::map<ea_t, struct instruction_info> ponce_comments;



```

`src/globals.hpp`:

```hpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#pragma once
//Ponce
#include "trigger.hpp"
#include "snapshot.hpp"
#include "runtime_status.hpp"
#include "symVarTable.hpp"

//IDA
#include <kernwin.hpp>

//Triton
#include <triton/api.hpp>

#define strtol_m strtoll

#include <inttypes.h>

//stdcall does not exist in Linux so lets define it to nothing
#if defined(__LINUX__) || defined(__MAC__)
#define __stdcall
#endif

#define __END__ -1

//All the options:
#define SNAPSHOT_DESCRIPTION "Before use the script"
//It enables the instruction tracing the first time a register/memory is tainted
#define ENABLE_STEP_INTO_WHEN_TAINTING true

#define RENAME_TAINTED_FUNCTIONS_PREFIX "T_"
#define RENAME_TAINTED_FUNCTIONS_PATTERN RENAME_TAINTED_FUNCTIONS_PREFIX"%03d_"
#define RENAME_TAINTED_FUNCTIONS_PATTERN_LEN 6 

extern Snapshot snapshot;

//All the global variables:
extern bool hooked;

//User controlled options
struct cmdOptionStruct {
    uint64 limitInstructionsTracingMode = 10000;
    uint64 limitTime = 60; //seconds

    //all this variables should be false and initialized in prompt_conf_window in utils.cpp
    bool already_configured = false; // We use this variable to know if the user already configured anything or if this is the first configuration promt

    //Only one out of the two will be selected
    bool  use_tainting_engine = false;
    bool  use_symbolic_engine = false;

    bgcolor_t color_tainted = 0x99FFCE;
    bgcolor_t color_tainted_condition = 0x00b377;
    bgcolor_t color_executed_instruction = 0xe6e6e6;

    bool showDebugInfo = false;
    bool showExtraDebugInfo = false;

    unsigned int solver_timeout = 10; // default 10 seconds

    bool AST_OPTIMIZATIONS = false;
    bool CONCRETIZE_UNDEFINED_REGISTERS = false;
    bool CONSTANT_FOLDING = false;
    bool SYMBOLIZE_INDEX_ROTATION = false;
    bool TAINT_THROUGH_POINTERS = false;

    bool addCommentsControlledOperands = false;
    bool RenameTaintedFunctionNames = false;
    bool addCommentsSymbolicExpresions = false;

    char blacklist_path[QMAXPATH];
};
extern struct cmdOptionStruct cmdOptions;

extern std::vector<std::string>* blacklkistedUserFunctions;

extern void idaapi term(void);

extern triton::API api;

struct instruction_info {
    std::string comment;
    std::string snapshot_comment;
    bgcolor_t color = DEFCOLOR;

};
extern std::map<ea_t, struct instruction_info> ponce_comments;
/* For backwards compatibility with IDA SDKs < 7.3 */
#if IDA_SDK_VERSION < 730
#define inf_get_min_ea()        inf.min_ea
#define inf_is_64bit()          inf.is_64bit()
#define inf_is_32bit()          inf.is_32bit()
#define WOPN_DP_TAB             WOPN_TAB
#endif

#ifdef __EA64__
#define MEM_FORMAT "%#" PRIx64
#define REG_XIP api.registers.x86_rip
#else
#define MEM_FORMAT "%#" PRIx32
#define REG_XIP api.registers.x86_eip
#endif // __EA64__


```

`src/main.cpp`:

```cpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

//IDA
#include <idp.hpp>
#include <dbg.hpp>
#include <loader.hpp>
#include <kernwin.hpp>

//Triton
#include <triton/api.hpp>

//Ponce
#include "callbacks.hpp"
#include "actions.hpp"
#include "globals.hpp"
#include "trigger.hpp"
#include "context.hpp"
#include "utils.hpp"
#include "formConfiguration.hpp"
#include "triton_logic.hpp"
#include "actions.hpp"

#ifdef BUILD_HEXRAYS_SUPPORT
#include "ponce_hexrays.hpp"

#if IDA_SDK_VERSION < 760
// Hex-Rays API pointer
hexdsp_t* hexdsp = NULL;
#endif
#endif

bool idaapi run(size_t)
{
    /*We shouldn't prompt for it if the user has a saved configuration*/
    if (!load_options(&cmdOptions)) {
        prompt_conf_window();
    }

    if (!hooked) {
        //Registering action for the Ponce config
        register_action(action_IDA_show_config);
        attach_action_to_menu("Edit/Ponce/", action_IDA_show_config.name, SETMENU_APP);
        //Registering action for the Ponce taint window
        register_action(action_IDA_show_expressionsWindow);
        attach_action_to_menu("Edit/Ponce/", action_IDA_show_expressionsWindow.name, SETMENU_APP);
        //Registering action for the unload action
        register_action(action_IDA_unload);
        attach_action_to_menu("Edit/Ponce/", action_IDA_unload.name, SETMENU_APP);
        register_action(action_IDA_clean);
        attach_action_to_menu("Edit/Ponce/", action_IDA_clean.name, SETMENU_APP);

        //Some actions needs to use the api and the api need to have the architecture set
        if (!ponce_set_triton_architecture()) {
            return false;
        }

        // Set the name for the action depending if using tainting or symbolic engine
        if (cmdOptions.use_tainting_engine) {
            action_list[3].menu_path = TAINT;
            action_IDA_taint_symbolize_register.label = TAINT_REG;
            action_IDA_taint_symbolize_register.tooltip = COMMENT_TAINT_REG;

            action_list[4].menu_path = TAINT;
            action_IDA_taint_symbolize_memory.label = TAINT_MEM;
            action_IDA_taint_symbolize_memory.tooltip = COMMENT_TAINT_MEM;
        }
        else {
            action_list[3].menu_path = SYMBOLIC;
            action_IDA_taint_symbolize_register.label = symbolize_REG;
            action_IDA_taint_symbolize_register.tooltip = COMMENT_SYMB_REG;

            action_list[4].menu_path = SYMBOLIC;
            action_IDA_taint_symbolize_memory.tooltip = COMMENT_SYMB_MEM;
            action_IDA_taint_symbolize_memory.label = symbolize_MEM;     
        }

        /* Init the IDA actions depending on the IDA SDK version we build with*/
        std::copy(std::begin(ponce_banner_views), std::end(ponce_banner_views), std::begin(action_list[0].view_type));
        std::copy(std::begin(ponce_taint_symbolize_reg_views), std::end(ponce_taint_symbolize_reg_views), std::begin(action_list[3].view_type));
        std::copy(std::begin(ponce_taint_symbolize_mem_views), std::end(ponce_taint_symbolize_mem_views), std::begin(action_list[4].view_type));

        //Loop to register all the actions used in the menus
        for (int i = 0;; i++) {
            if (action_list[i].action_decs == NULL) {
                break;
            }
            //Here we register all the actions
            if (!register_action(*action_list[i].action_decs)) {
                warning("[!] Failed to register %s actions. Exiting Ponce plugin\n", action_list[i].action_decs->name);
                return false;
            }
        }

        // This is Ponce logo. I put it here so it's only loaded once
        unsigned char ponce_icon[] = "\x89\x50\x4E\x47\x0D\x0A\x1A\x0A\x00\x00\x00\x0D\x49\x48\x44\x52\x00\x00\x00\x20\x00\x00\x00\x20\x08\x06\x00\x00\x00\x73\x7A\x7A\xF4\x00\x00\x00\x01\x73\x52\x47\x42\x00\xAE\xCE\x1C\xE9\x00\x00\x00\x04\x67\x41\x4D\x41\x00\x00\xB1\x8F\x0B\xFC\x61\x05\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0E\xC4\x00\x00\x0E\xC4\x01\x95\x2B\x0E\x1B\x00\x00\x0C\xC4\x49\x44\x41\x54\x58\x47\x45\x97\x77\x54\x94\x69\x9A\xC5\x6B\xF7\x9C\xDD\xB3\x33\x67\x66\xDA\x2C\x92\xA1\x08\x05\x14\x59\x42\x21\x85\x04\x11\x49\x22\x2A\x51\x25\x08\x88\x0D\x8A\x28\x60\x00\xEC\x56\x51\x14\x23\x88\x82\xA0\x24\xC5\x00\x82\x80\x18\xDA\x00\x54\x51\x44\xC1\xD0\x3D\x1D\xB4\x1D\xDB\x9E\x99\xD3\xDB\x7B\xBA\x7B\x66\xCE\x9E\x8D\x67\xFE\xF9\xED\x53\x65\xDB\xFB\xC7\x3D\xDF\x57\x1F\x1F\x75\xEF\x7B\x9F\xE7\xBD\xEF\x53\x8A\x3A\xDD\xD7\xD4\x8D\x7C\xCD\xE9\xA1\xAF\x38\x33\xFC\x92\xDA\x91\x57\x72\xFF\xA5\x3C\x7B\xC5\xF9\xC9\x3F\x73\x4A\xFF\x86\xFD\x1D\x83\xEC\xD9\xB7\x8F\xAA\x82\x4D\xB4\xEC\xDB\x42\xAB\xA0\xAD\x3C\x9F\x96\xBD\x79\x9C\x2B\xC9\xA6\x66\x5B\x1A\x95\x39\xEB\x29\xCB\x4C\x64\x67\xC6\x3A\x2A\x2E\xF6\xD2\x30\xFE\x2D\xF5\xC3\x5F\x71\x4E\x27\xDF\xA3\xFF\xDA\x74\xAD\x1F\x79\xF9\xCB\x67\xE3\xFD\x59\x81\xC2\x48\x58\x27\x0F\x6B\xE5\xE5\x3A\xA3\x00\x11\x72\x61\xF2\x4F\x9C\xD6\xBD\xA6\xB2\xED\x36\xFB\x76\x97\x71\xFC\xC3\x54\x5A\xCB\xB2\xB8\x5C\x91\x6F\x22\x37\x12\x1B\x05\xBC\x17\xD2\x54\x96\x43\xED\x8E\x8D\x1C\xD8\x92\xC4\xB6\xA4\x28\x0A\xD2\x13\x38\x7E\x7B\x9A\x73\xFA\xD7\xD4\x3D\xFE\x82\xB3\xC3\x5F\x9A\xC4\x18\x51\x27\x8B\x3B\x6B\xBC\x17\x9E\x73\x46\x01\x46\x15\x26\xC8\x1F\xCE\x89\x1B\x17\xC6\xDF\x52\x5C\x7F\x83\xBC\x82\x02\x8A\x92\x57\x72\x7C\x4B\x22\x2D\xBB\x73\x68\xFD\x99\xF0\x3D\xE9\x7B\x21\xEF\x90\x2B\x22\x32\x39\x5B\xB4\x91\xC3\xF9\x29\x94\xA7\x47\x51\xB2\xAF\x82\x46\x71\xF0\x82\xE1\x1B\x9A\x26\xBE\xE5\xC2\x84\xF1\xFA\x96\xA6\xF1\x37\x72\x2F\xD0\xBD\xA4\x41\xF7\x25\x8A\xF7\xD6\x34\x18\xDE\x88\xBA\x2F\x88\xD9\x90\x8B\xD9\xA2\x85\xC4\x2F\xF7\x67\xB7\x58\x7A\xA2\x30\x9D\xA6\xD2\x6C\x93\xF5\xEF\x09\x2F\xED\x31\x22\x97\x36\x79\xD6\x21\xAE\xB4\x95\xE7\xD2\xB2\x27\x8B\x3A\x71\xA1\xA6\x20\x95\xED\xC9\xAB\xC8\x4C\x8C\xE2\x60\xCB\x4D\x8E\xB4\xDE\xE4\x70\xD3\x55\x8E\xB6\x76\x51\x71\xAE\x9D\x9D\x27\x9B\x39\xD8\x3E\xC0\xB9\xA1\xCF\x68\x99\xFA\x46\x04\x0C\x7F\x41\xE3\xE8\x2B\x6A\xFA\x27\xF0\x5F\x1E\xC1\xC2\x79\x73\xB0\xB6\xB6\xC1\xD5\xCD\x85\x1D\xE9\xF1\xD4\x6E\x4F\xA7\x71\x57\x26\xAD\x42\xFC\xCE\x81\x3C\xDA\x85\xB0\xAD\x3C\x87\x46\xA9\xFF\x89\xC2\x0D\x7C\x9C\xB3\x8E\xA2\xB4\x18\xB2\xE2\xC3\x49\x5A\x11\x44\x8C\x36\x80\x10\x3F\x6F\xB4\xBE\x1E\x84\xFB\x79\x10\xE6\xA7\x46\xEB\xE3\x46\x84\xAF\x2B\x81\xEE\x4E\x78\xB9\x3A\xE3\x17\x18\xC4\x8E\x93\x4D\x28\xEA\x1F\x3E\x17\x25\x6F\x49\x2A\x28\xC1\xCA\x6C\x3E\x16\x96\x96\x2C\x5C\xB4\x08\x17\x95\x23\x9B\x65\x15\xC6\xFA\x9F\x28\x4C\xA5\xAE\x78\xA3\x08\x31\xAE\x72\x13\xFB\x73\x12\xD9\x91\xB6\x8A\xDC\x35\x2B\x48\x89\xD2\x12\xAD\xF5\x43\xE3\xED\x8E\xD2\xDE\x0E\x4B\x2B\x2B\x59\x80\x35\xFE\x9E\xAE\xC4\x89\x8B\x61\x41\x4B\xD1\x88\x90\xE8\xE0\xA5\x04\xCA\x3B\x4E\x0E\xF6\xD8\xD9\x2B\xF9\xE0\xD7\xBF\x22\x3E\x6B\x2B\x8A\x06\xC3\xD7\xB4\x4E\xFF\x91\x8C\x9D\x15\x78\xAA\xEC\x59\x62\x66\xC6\xDC\xB9\x73\xB1\x92\x2F\x5A\x2E\xFF\xBC\x2B\x63\x0D\xE5\xD2\xE1\x25\x1B\xE2\xD9\x2A\x0D\xB6\x29\x36\x94\xF5\x11\x1A\x22\x35\x3E\xF8\xA8\x5D\x71\x72\x54\xCA\xBB\xD6\x38\x3B\x3A\xA0\x5D\xEA\x4E\xAC\x76\x29\x41\x42\xE8\xEF\xE3\x81\x8F\xA7\x1B\x3E\xEE\x6E\x78\xAA\x5D\x50\x3A\x38\x60\x2E\xEF\x2D\x59\xB2\x84\x79\xBF\xFB\x0D\xDA\xA8\x78\xCE\x3F\x7A\x8A\xA2\xB4\xA2\x92\xF3\xA3\x5F\xB1\xE5\xE3\xE3\xA8\x1D\x6D\x31\x33\x5B\xC2\x9C\x39\x73\x58\xB0\x60\x01\xF6\x4A\x3B\xD6\xAE\x0C\x21\x3B\x61\x85\x89\x38\x69\x65\x10\x11\x81\xDE\x78\xB8\x38\x61\x6B\x6B\x8B\xA3\x83\x12\xB5\x88\xF0\x70\x17\xB8\x09\x5C\x9C\xB1\xB7\xB5\x61\xF1\x12\x73\xEC\xEC\x6C\x70\x76\xB2\x47\xE5\xA4\xC4\xC1\xDE\x1E\x2B\x8B\x25\x2C\x5A\x30\x0F\x27\x95\x8A\x84\x8C\x2D\xD4\x7F\xF2\x84\xD6\xF1\x57\x28\xF6\xAD\x74\x61\x7F\xE5\x3E\x0A\x8E\x9C\x41\xED\xEC\x28\x0A\xCD\xF8\xC0\x28\x60\xE1\x22\xFC\xBD\x3D\x48\x8D\x0E\x25\x79\x65\x30\xA1\xFE\x5E\xB8\x38\x39\xE0\x2A\xEF\xA8\x1C\xED\x71\x50\x2A\xB1\x17\xCB\xCD\xCC\x2D\x04\xE6\xB8\xC8\xF3\xD8\xD0\x40\x4A\xB3\xD6\xD1\x71\xA8\x90\xD9\xCE\xA3\x18\xDA\x0F\xB3\x23\x7B\x35\x96\x36\xB6\x04\x48\x7F\xE5\x94\x1F\xA4\x76\x70\x94\xCB\x33\x7F\xA0\xD5\xF0\x39\x17\x75\x2F\x44\x40\xE2\x32\xAA\x37\xC7\x92\x97\xB6\x06\x57\x95\x13\x8B\x16\x2F\xC6\xC2\x7C\x89\xE9\xCB\xF2\xD6\x46\x4A\xED\xFC\xF1\x16\x0B\x7D\xA5\xA6\x4A\x5B\x6B\xDC\xE4\x1D\x07\x7B\x5B\xCC\x45\xA8\x9D\x08\xD8\x95\xB5\x9A\xBE\x33\x65\x7C\xDE\x73\x9A\xBF\xEA\x5B\xF9\xFB\x74\x17\x7F\x7F\x72\x93\xFF\x9C\xE8\xE2\x7F\x27\xBB\xE9\x39\x55\x4A\x55\xCB\x55\x3A\xA6\x5F\x73\x75\xF6\x0D\xAD\x63\x9F\xD3\x3C\xF2\x9C\x4B\xFA\x4F\xB9\x34\xFA\x19\x8A\xB8\x20\x6F\x76\xC9\x7E\x2F\xDD\x9C\x84\x9B\x94\xC0\xD3\x4D\x45\xD6\x6A\xE9\x66\x69\x2E\x3F\x2F\x35\x4B\x85\x38\xC0\x5B\x2D\x2B\xB6\x63\x91\x99\xF9\xBB\x15\x4B\x9F\x58\xDB\xDA\x71\x74\x77\x2E\x3F\x8E\x5C\xE2\xBF\xA7\x3A\xF9\xF7\xF1\xCB\xFC\x75\xB4\x83\x7F\x1B\x6A\xE5\x87\xE1\xCB\xFC\x4D\x7F\x85\xFF\x9A\xB8\x4A\xE7\xE1\x02\x4A\x8E\x1C\xA3\x63\xF2\x25\xCD\x43\xB3\xA6\x55\xB7\xEA\x9F\xD3\xA6\x97\xAB\xEE\x39\x8A\x98\x60\x1F\xE2\xFC\x5D\xA4\x8B\xD5\x44\x87\xF8\x89\xE5\xC1\xF8\x7B\xB9\xE2\x25\xAB\x0E\xD3\xF8\x8A\x00\x37\x53\xBD\x17\x2E\x32\xC3\xC3\xD9\x8A\x08\x3F\x3B\x1C\xA4\x04\x47\x64\x47\xFC\x20\xE4\x7F\x1B\x6D\xE3\xF5\x60\x3D\x2F\x07\xEA\x98\xBD\x7E\x9C\x9F\x74\x6D\xBC\xBD\xDB\x48\x7F\x5D\x19\x39\xA9\xB1\xAC\x8E\xD4\x50\x56\x52\xC0\xC5\x91\x67\xB4\xEB\x9F\x0A\xF1\x53\xDA\x47\xE5\x5E\xD0\x21\x50\x94\x94\xED\x22\x37\x7B\x13\xAB\x43\x7C\x09\x0E\xF0\x96\xC6\x92\xC6\x71\x76\x62\x79\xA0\x2F\x7E\xB2\x6D\x6C\x64\x4B\x59\x59\x5A\xB0\xC4\xC2\x92\xA4\x50\x47\x92\x42\xEC\xA4\xBB\x5D\x19\xBE\xB8\x9F\x4F\xBB\x6A\x28\xCD\x5D\xCB\x52\x79\x4F\x25\xFD\x61\x27\xCD\x76\xF7\xFC\x7E\xBE\x7F\xD8\xCC\x0E\xD9\xAA\xAE\x6E\x6E\xE4\xAD\x8B\x24\x3F\x2F\x53\x04\x3C\xA5\xC3\xF0\xDC\x84\xCB\x63\x2F\x7E\x81\xE2\x78\xC7\x0D\xB2\x32\xD2\x25\x1C\x9C\x70\x17\xFB\x97\x6B\xFC\x58\xA1\xF5\xC7\x41\x3A\xDC\xB8\x15\x9D\x1C\xAC\xB1\xB1\xB1\xC4\xDE\xCE\x9A\x60\x1F\x47\xC9\x07\xB9\xCA\x4E\x68\xAB\xDA\x46\x51\x66\x3C\x51\x2B\x82\x09\x09\x09\x20\x34\xD8\x8F\xD8\x88\x65\xAC\x08\x0B\xE2\xF5\x9D\x7A\x76\xE7\x26\xE3\xEB\x17\xC8\xFA\xC4\x04\xD6\xAF\x4F\x14\xE2\xFF\x17\x70\xE5\x67\x72\xE3\x55\xB1\x26\x71\x8D\x58\xAB\x24\x7C\x99\x2F\x51\x21\x12\x1C\x62\xBB\xB7\x5A\x85\xA3\x10\xAA\x55\x76\xB8\x3B\x5B\xBF\xAB\xB9\x38\xE1\xA6\xB2\xC5\xD5\xC5\x96\xEC\x94\x18\x9A\xAA\x77\x52\x55\x92\xC5\xCE\x9C\x64\x52\xD7\xC7\xA3\x09\x0A\xA2\xB7\xBE\x92\x4C\xF9\xDB\x09\x89\xE9\xBB\x8D\x15\x5C\xAC\xA9\x60\x57\x6E\x3A\x25\x5B\x33\x69\x1B\x9A\xE4\xAA\x88\xE8\x14\x5C\x1B\x7B\x66\x82\xF1\xB3\xC2\x58\xFB\xB0\x65\x01\xD2\xF5\x41\xAC\x92\xCE\xD7\xF8\x7A\x9A\xA2\x38\xD8\xDB\x1E\x27\x7B\x4B\x11\xE5\x63\x2A\x8D\xAD\x9D\x92\xA0\x40\x1F\x42\x24\xF5\xCE\x56\xE6\x33\x70\xBE\x9C\x03\x72\xF8\x6C\xCD\x4C\xE1\x64\x4D\x35\x9B\xD2\x53\xE9\xAD\x2D\xE7\xEC\xFE\x7C\x12\xE3\x56\xA2\x6B\x3F\x42\xCF\x99\x52\xEE\xD4\x16\xF3\x71\x69\x0E\xCD\xF7\x46\xE8\x9A\xFA\xCC\x44\x7A\x7D\xFC\xF9\x2F\x50\x68\xC5\xCE\x48\xC9\xEE\xE8\x50\x8D\xD4\xDD\xC7\x94\x5A\x8E\x0E\x12\xA9\x16\x16\xA6\xCE\x2F\xCA\x5A\xCB\xA9\x8A\x3C\x62\xC2\xB5\x04\x06\x06\x90\x9E\x12\xCF\x58\x7B\x15\xD3\x57\xAA\xD0\xB7\x1D\xA4\xAF\x76\x0F\xCF\xBA\x4E\xD2\x7E\xA4\x98\xE1\x96\xC3\xCC\x5C\x3F\xC6\x9A\x98\x08\x06\xCE\x55\x30\x75\xE3\x04\x23\x2D\x07\x38\x5A\xBE\x85\x0B\xB7\x1F\xD2\x3D\xF5\x29\xD7\x46\x67\xB8\x6E\x98\xE5\xC6\xD8\x53\xBA\xC6\xA5\x09\x3D\xE5\x60\x08\xF6\xF3\x42\xEB\xEF\x69\xEA\x01\x95\x44\xAB\xBB\xA3\xB9\xE4\xBA\xA5\xA4\x9B\x92\xED\x22\x60\x67\xF6\x1A\xB2\x52\xE3\x08\x08\xF0\xC3\xD7\xC7\x9B\x07\x4D\x07\xF8\x7E\xE8\x12\xFF\xFA\xA8\x99\xBF\x8C\xB4\xF3\xC3\x50\x1B\x6F\x06\x1B\x64\x47\x74\x32\x7B\xAD\x9A\x8C\x94\x38\xAA\x4B\x72\x4D\xB9\x70\x4B\x5C\x38\xBB\xFF\x43\xDA\xEE\x3E\xA2\x7B\xE2\x39\xD7\x74\xD3\x5C\x17\x11\x37\x44\x44\x97\x88\x50\xB8\x8B\x00\x6F\x89\x52\x3B\x3B\x5B\xE6\xCD\x9D\xC3\xFC\x79\xF3\x89\x88\x8E\xC6\x5D\x2D\xA9\x27\x0D\x98\x20\xF1\x1B\x1B\xA9\x25\x4D\xBA\x39\x2E\x26\x1C\x47\x95\x0B\x15\xDB\x36\xF2\xED\xBD\x06\x53\x06\x7C\xFF\xF8\x12\x3F\xE9\x2F\xF3\xDD\xE3\x16\xFE\xFC\xA0\x99\xE9\xCE\x6A\x8A\x73\x93\x4C\x22\xBE\x7B\x78\x89\xD1\xD6\x43\x9C\xAC\xFC\x90\xCB\x8F\x0C\x26\x01\x46\xE2\x6E\x59\xF9\x7B\x28\xAC\xCC\xCD\x30\x5F\xBC\x90\xC5\x92\x80\x01\xC1\x21\x94\x1D\x3D\xCD\x55\xFD\x13\xB2\xF3\xF3\xB0\xB7\x5A\x28\x2E\x48\xC4\x46\x85\xB1\x29\x25\x96\x84\xD8\x70\x3C\xBD\xBC\x49\x88\x5F\x49\xC3\xC7\xF9\xB2\x0D\x4F\xF0\xA3\xAE\x45\xF2\xA0\x4D\x4A\x72\x84\xD7\xB7\xEB\xA8\x96\x7C\xC8\xDF\xB4\x96\xC6\x83\x1F\xF2\xAA\xBF\x8E\x9F\x86\x9A\x68\x3B\xB9\x87\x8E\xC7\x93\xDC\x14\xC2\xAE\x51\x11\x20\x0D\xD8\x2D\xAB\xEF\x91\xAB\x62\xC3\xD6\x6D\xE4\x95\xEE\x93\xA1\xA1\x8D\x2B\xC3\x93\xF4\x4E\x7F\xCE\xB1\x86\x26\x34\xD2\x0F\x5E\xAE\x36\x12\x48\xF6\xA8\x5D\xE4\x50\x8A\xD1\xA2\x0D\xF2\xC1\xC3\xD3\x1D\xB5\xBB\x9A\x75\x72\x40\x55\x09\x59\x6F\xED\x5E\x06\xCF\xEE\x41\x77\xE9\x00\x53\x97\xAB\xE8\x3E\x59\xC2\x47\xC5\xD9\xEC\x93\x39\xA1\x54\x4E\xD1\x2B\x87\xC4\xFE\xC6\x1A\x6E\x48\x00\xF5\x88\xF5\x3D\xD2\x84\xBD\x46\x88\x80\x5B\xE3\x52\x82\x3E\x21\xEC\x17\xF4\x4E\xBC\xA0\xF3\xD1\x38\x37\x86\x9F\xD0\x78\xA3\x8F\x20\x1F\x3B\xBC\xDC\xAC\x25\xF7\xCD\xE5\x6A\x85\xB9\x85\xB9\xA4\xA5\x92\x15\xC1\x5E\x04\xF8\xFB\xE1\xE7\xE7\x4B\x8C\x34\x5B\x5A\x4A\x02\x97\x8F\x14\x99\xAC\x7F\xD8\xB4\x5F\x82\xA8\x9C\x63\xC5\x49\x6C\x88\xF3\x25\x73\x5D\x38\xBB\xD3\x34\xD4\xD4\x7C\x44\xFF\xCC\x17\xF4\x8D\xCD\x30\x20\xC4\xEF\xD1\x2F\x50\x5C\x13\xD2\xAB\x82\x6B\x8F\x85\x7C\x64\x92\xEB\xC3\x13\x74\xE9\xA7\x38\xDE\xD8\x44\x4C\xA4\x3F\x2B\x23\x03\x65\xEF\x3B\x31\x57\x7A\xC3\x43\x9C\xC8\x88\x72\x66\xDD\x4A\x1F\x34\x1A\x0D\xE1\xA1\x5A\xA2\xA2\x23\xE8\xAD\xDB\xCD\x84\xEC\x8C\x43\xDB\x92\xC9\x8C\x51\x11\x13\xA2\x22\x37\x29\x82\x03\xDB\x37\xB1\x76\xD5\x32\x7C\xBC\x1C\x68\xE9\xBD\xCB\x9D\xA9\x67\xF4\x8D\x4E\x30\x30\x3E\x25\x30\x5E\x27\x51\x74\xEB\xA7\xE9\xD6\x4D\xBD\xC3\x88\x40\xCA\x70\x43\xC4\xF4\xE8\x66\xE8\x1E\x1A\xA3\xBE\xF3\x2A\xB6\x36\x36\xCC\x9F\x3F\x9F\x25\x72\x10\x69\x97\x2A\x29\x8C\x73\x61\x5D\x94\x06\xFF\x40\x09\xAE\xD0\x60\xAE\x89\xED\xCD\x07\x0A\xD8\x93\xEC\x4E\x72\x98\x03\x07\x4B\xB6\xD0\x79\xBC\x8C\x43\xC5\x9B\xA9\x2C\xCA\x21\x5C\xE3\x4A\x55\xED\x69\x06\xA7\x9E\x70\x6B\x74\x94\xFE\xF1\x71\x6E\x4F\x4C\x32\x30\x31\x21\x25\x18\x9B\xA4\xDF\x30\xC9\x2D\x59\xF5\x2D\xFD\x18\xBD\x3A\x83\x09\xDD\x23\x06\xAE\xF4\xF5\x50\x98\x9F\xC6\xBC\xF9\x0B\x24\x8E\xAD\xB1\x94\x71\xCD\x41\x69\xC3\x72\x3F\x07\x8A\x13\x9C\x24\xB2\xDD\x88\x91\x06\xAD\x96\x71\x2D\x31\xC2\x9D\x8D\x51\x6E\xA4\xC4\x86\xF0\x3F\x72\x1C\x3F\xBD\x79\x46\xC8\x33\x88\x8F\x0A\x62\x43\x6A\xBC\xF4\x55\x1D\x57\x06\x6F\x9B\x56\x3E\x28\xE4\x83\x13\x53\xDC\x11\x28\xFA\x0D\x63\xA6\x87\xFD\x63\xE3\x52\xA3\x31\xFA\xE4\x73\x8F\x4E\xC7\x9D\x27\xB3\x14\x16\x17\x11\xA5\xF5\xC0\x5A\x1C\x30\x92\xAB\x64\x9A\xF1\xF6\x72\xC7\x41\xA2\x3B\x39\xD4\x8E\xDD\x89\x4E\x6C\x49\xF4\x65\xDB\x7A\x3F\x36\xAE\x52\xE3\x25\x56\x27\xAD\x0E\x61\x50\x42\xA8\xF9\xA3\x6C\x3E\xCE\x8F\x91\xF1\xCD\x85\x42\x99\x94\x6F\x1B\xC6\x19\x10\xDC\x11\xDB\x8D\xC4\x46\x0C\x1A\x4B\xD0\xAB\x17\x4B\x84\xBC\x5F\xFE\x78\x7B\x4C\xEA\x22\xD7\x5B\xF2\xAC\xF3\xDE\x7D\xD6\x27\x84\xCB\x19\x21\x93\x6D\xC8\x52\x71\x40\x46\x30\x39\x25\xA3\x65\xC5\x39\x9B\x8C\x53\x8E\x15\x61\xFE\xF6\xE4\xC7\xDB\x53\xBA\xD6\x91\xC2\x78\x27\x56\x87\x39\x91\x19\xAD\x22\x2F\xC1\x5D\xCA\xE1\x46\x4D\xA6\x27\xA7\xB2\x7D\x28\x5C\xA3\xA6\x43\xDC\xBC\x3F\x3D\x6B\xE2\x30\x12\x9B\x04\x88\xFB\x8A\x5B\xBA\x51\x13\xA1\xF1\xDA\xA7\x37\x98\x70\x57\x6A\x75\xAE\xF3\x1A\xF5\x87\xF3\xB9\x71\xBE\x84\x8C\xB5\xA1\xEC\x92\x1F\x1C\xC1\x32\xA4\xAA\x5C\x5D\x68\x39\xB6\xD3\x94\x90\x16\x32\x21\x69\x65\x3E\xD8\xB8\x42\xC9\xE6\x68\x41\x8C\x08\x88\x71\x23\x5D\xC6\xBC\x8D\xD1\x2E\x64\xC4\xA8\xC9\x58\xA5\x22\x25\xDC\x8A\x8A\xF2\x6D\x3C\x78\xF2\x8C\x41\x71\xF8\x9E\x34\xE1\x3D\x11\x70\xCF\xE8\x80\x49\x80\xA0\x77\x44\x4F\xF7\xA3\x21\x13\x1E\xCE\x3C\x23\x31\x6D\x3D\x21\x1A\x67\x7E\x3F\xD4\xC8\x27\x1D\x7B\xF9\xA8\x28\x81\xEA\xBD\x99\x64\x6E\x58\xC7\xF6\xBC\x14\xEE\x34\x54\x92\x91\x1C\xC3\x32\xAD\x0C\xAA\x72\x8E\x38\x39\xD9\x11\xE0\x65\x23\x3B\x40\xC9\xEA\xE5\x2A\x52\x57\xC9\x84\x1C\xA6\x26\x72\x55\x24\xDE\x32\x3F\x44\xAF\x5C\xC6\xDD\x89\x71\xEE\x8E\x8B\x80\xC9\x09\xEE\xFF\x0C\x45\xEF\x90\x8E\x9E\xA1\x11\x7A\x1E\x0F\x73\x6B\x58\xCF\xE3\xA7\x2F\x28\xDB\x5F\xC9\x6F\x7F\xA3\xE0\x57\xFF\xA2\x20\x54\x44\x4C\x0D\x9E\x64\xAA\xEF\x88\x4C\x41\x09\x34\x1F\x2B\xA0\xA1\xA6\x98\x6B\xB5\x15\x34\x1C\xDC\x4E\x9E\xA4\x5E\xE7\x89\x5D\x5C\x3B\xBE\x93\x9D\x12\xC1\x39\xA9\x31\xD2\x0B\xAE\xB8\xB9\x2A\x71\x71\xB0\x60\xCD\xDA\x38\xB6\x6E\x2F\x22\x6D\x63\x1A\xBA\x99\x59\xEE\x8B\xDB\x9F\x8C\x1A\x78\x20\x65\x7F\x20\x6E\x28\xFA\x47\x46\x18\x94\x87\x03\xD2\x78\x57\xFA\xFB\x38\x5C\x73\x02\x2B\xEB\xF9\xCC\xF9\x40\xC1\xE2\x85\xFF\x6C\x12\xB1\x54\x56\x76\xFB\xF2\x21\xFE\x38\x73\x95\xD9\x4F\x6A\x99\xB9\x7F\x96\xC7\x37\x6B\xB8\x79\xA9\x8A\x0B\x27\x4A\x68\xA9\x2E\xE6\x85\x9C\x88\xDF\xCB\xE1\xD4\x7B\x76\x2F\x99\x1B\x57\x13\xB8\xD4\x19\x5F\x0F\x67\x34\xCB\x34\x5C\xEF\xEF\xE5\xC1\xA8\x8E\x47\x63\xA3\x3C\x32\xC8\x22\xE5\xFA\x78\x5C\xEE\xC7\xF4\x28\x06\x86\x86\x68\x6C\x6D\x23\x76\x75\x82\xCC\xF8\x6A\x94\x8B\x2D\xF0\x97\x5F\x2E\x36\xE6\xBF\x63\xDE\xBC\x7F\x14\x11\xFF\x24\xBF\x13\xFE\x41\x0E\xAB\xDF\xD2\x78\x6A\x37\x7F\xF9\xC6\xC0\x7F\x7C\x37\xCB\x8F\x7F\x30\xF0\xA7\xDF\x3F\xE0\xED\xF3\x41\xA6\xEE\x5F\x60\xEC\x76\x03\x93\x3D\x75\x34\x4B\x2A\xE6\x65\xA7\x70\xAB\xFD\x38\x47\xF7\xA4\x73\xE2\xCC\x29\x0C\x4F\x9F\x88\x80\x11\x13\x1E\x1A\x74\x26\x72\x93\x80\x71\x3D\xFF\x07\xBC\x56\x64\x24\x3B\xC4\x6A\x82\x00\x00\x00\x00\x49\x45\x4E\x44\xAE\x42\x60\x82";
        auto custom_ponce_icon = load_custom_icon(ponce_icon, sizeof(ponce_icon), "png");
        update_action_icon(action_IDA_ponce_banner.name, custom_ponce_icon);

        if (!hook_to_notification_point(HT_UI, ui_callback, NULL)) {
            warning("[!] Could not hook ui callback");
            return false;
        }
        if (!hook_to_notification_point(HT_DBG, tracer_callback, NULL)) {
            warning("[!] Could not hook tracer callback");
            return false;
        }

        msg("[+] Ponce plugin running!\n");
        hooked = true;
    }
    return true;
}

//--------------------------------------------------------------------------
#if IDA_SDK_VERSION >= 760
plugmod_t* idaapi init(void)
#elif IDA_SDK_VERSION == 750
size_t idaapi init(void)
#else
int idaapi init(void)
#endif
{
    char version[8];
    //We do some checks with the versions...
    if (get_kernel_version(version, sizeof(version))) {
#if IDA_SDK_VERSION == 770
        if (strcmp(version, "7.7") != 0) {
#elif IDA_SDK_VERSION == 760
        if (strcmp(version, "7.6") != 0) {
#elif IDA_SDK_VERSION == 750
        if (strcmp(version, "7.5") != 0) {
#elif IDA_SDK_VERSION == 740
        if (strcmp(version, "7.4") != 0) {
#elif IDA_SDK_VERSION == 730
        if (strcmp(version, "7.3") != 0) {
#elif IDA_SDK_VERSION == 720
        if (strcmp(version, "7.2") != 0) {
#elif IDA_SDK_VERSION == 710
        if (strcmp(version, "7.1") != 0) {
#elif IDA_SDK_VERSION == 700
        if (strcmp(version, "7.00") != 0) {
#elif IDA_SDK_VERSION < 700
#error "Ponce does not support IDA < 7.0"
#endif
            warning("[!] This Ponce plugin was built for IDA %d, you are using: %s\n", IDA_SDK_VERSION, version);
        }
    }
    else {
        error("Can't detect the IDA version you are running");
    }

    if (int(version[0]) < 7) {
        warning("[!] Ponce plugin can't run with IDA version < 7. Please use a newer IDA version");
        return PLUGIN_SKIP;
    }

#ifdef BUILD_HEXRAYS_SUPPORT
    /* try to use hexrays if possible*/
    if (init_hexrays_plugin()) {
        install_hexrays_callback(ponce_hexrays_callback, NULL);
        msg("[+] Hex-rays version %s has been detected, Ponce will use it to provide more info\n", get_hexrays_version());
        hexrays_present = true;
    }
#endif

    // Start Ponce when IDA starts
    if(run(0))
        return PLUGIN_KEEP;
    else
        return PLUGIN_SKIP;
}

//--------------------------------------------------------------------------
void idaapi term(void)
{
    // remove snapshot if exists
    snapshot.resetEngine();
    // We want to delete Ponce comments and colours before terminating
    delete_ponce_comments();
#ifdef BUILD_HEXRAYS_SUPPORT
    remove_hexrays_callback(ponce_hexrays_callback, NULL);
#endif
    // Unhook notifications
    unhook_from_notification_point(HT_UI, ui_callback, NULL);
    unhook_from_notification_point(HT_DBG, tracer_callback, NULL);
    // Unregister and detach menus
    unregister_action(action_IDA_show_config.name);
    detach_action_from_menu("Edit/Ponce/", action_IDA_show_config.name);
    unregister_action(action_IDA_show_expressionsWindow.name);
    detach_action_from_menu("Edit/Ponce/", action_IDA_show_expressionsWindow.name);
    unregister_action(action_IDA_unload.name);
    detach_action_from_menu("Edit/Ponce/", action_IDA_unload.name);
    unregister_action(action_IDA_clean.name);
    detach_action_from_menu("Edit/Ponce/", action_IDA_clean.name);
    detach_action_from_menu("Edit/Ponce/", "");
    hooked = false;
}

//--------------------------------------------------------------------------
//
//      PLUGIN DESCRIPTION BLOCK
//
//--------------------------------------------------------------------------
plugin_t PLUGIN =
{
    IDP_INTERFACE_VERSION,
    0,                    // plugin flags
    init,                 // initialize
    term,                 // terminate. this pointer may be NULL.
    run,                  // invoke plugin
    "Ponce, a concolic execution plugin for IDA", // long comment about the plugin
    "", // multiline help about the plugin
    "Ponce", // the preferred short name of the plugin
    "" // the preferred hotkey to run the plugin
};


```

`src/ponce_hexrays.cpp`:

```cpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#ifdef BUILD_HEXRAYS_SUPPORT
#include "ponce_hexrays.hpp"
#include "globals.hpp"

#include <hexrays.hpp>

bool hexrays_present = false;

/* Returns the pseudocode line corresponding to an address or -1 if fail*/
int get_compile_coord_by_ea(cfunc_t* cfunc, ea_t addr) {
    int y = -1;
#if IDA_SDK_VERSION >= 720
    if (citem_t* item = cfunc->body.find_closest_addr(addr)) {
        if (cfunc->find_item_coords(item, nullptr, &y)) {
            //found
        }
        else
            y = -1;
    }
#else
    std::map<ea_t, int> lnmap;
    int i = 0;
    y = -1;

    for (const auto& line : cfunc->get_pseudocode()) {
        auto pitem = ctree_item_t();
        auto ret = cfunc->get_line_item(line.line.c_str(), 0, true, nullptr, &pitem, nullptr);
        if (ret && pitem.it) {
            lnmap[pitem.it->ea] = i;
        }
        i++;
    }
    ea_t closest_ea = BADADDR;
    for (const auto& [ea, line] : lnmap) {
        if (closest_ea == BADADDR || abs(int(closest_ea - addr)) > abs(int(ea - addr))) {
            closest_ea = ea;
            y = lnmap[ea];
        }
    }
#endif
    return y;

}

#if IDA_SDK_VERSION == 700
int idaapi ponce_hexrays_callback(void*, hexrays_event_t event, va_list va)
#else
ssize_t idaapi ponce_hexrays_callback(void*, hexrays_event_t event, va_list va)
#endif
{
    int y = -1;
    
    switch (event)
    {
    case hxe_func_printed:
    {
        cfunc_t* cfunc = va_arg(va, cfunc_t*);
        ctree_maturity_t mat = va_argi(va, ctree_maturity_t);
#if IDA_SDK_VERSION == 700
        func_t* func = get_func(cfunc->entry_ea);
#else
        func_t* func = cfunc->mba->get_curfunc();
#endif
        std::list<int> already_commented_lines;
        for (const auto& [address, insinfo] : ponce_comments) {
            if (func_contains(func, address)) {
                y = get_compile_coord_by_ea(cfunc, address);
                if (y == -1)
                    continue;
                if (!insinfo.comment.empty()) { //comment
                    if (std::find(already_commented_lines.begin(), already_commented_lines.end(), y) != already_commented_lines.end()) {
                        // We have already commented this line. Don't do it again
                        continue;
                    }
                    cfunc->sv[y].line.cat_sprnt("\t\t\t" COLSTR("// %s", SCOLOR_NUMBER), insinfo.comment.c_str());
                    already_commented_lines.push_back(y);
                }
                if (!insinfo.snapshot_comment.empty()) { //extra comment
                    if (std::find(already_commented_lines.begin(), already_commented_lines.end(), y) != already_commented_lines.end()) {
                        // We have already commented this line. Don't do it again
                        continue;
                    }
                    cfunc->sv[y].line += "\t\t\t/*";
                    cfunc->sv[y].line += insinfo.comment.c_str();
                    cfunc->sv[y].line += "*/";
                    already_commented_lines.push_back(y);
                }
                if (insinfo.color != DEFCOLOR && insinfo.color != cmdOptions.color_executed_instruction) { //color
                    cfunc->sv[y].bgcolor = insinfo.color;
                }
            }
        }       
        break;
    }
    default:
        break;
    }

    return 0;
}
#endif
```

`src/ponce_hexrays.hpp`:

```hpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#pragma once

#ifdef BUILD_HEXRAYS_SUPPORT
#include <hexrays.hpp>
#if IDA_SDK_VERSION == 700
int idaapi ponce_hexrays_callback(void*, hexrays_event_t event, va_list va);
#else
ssize_t idaapi ponce_hexrays_callback(void*, hexrays_event_t event, va_list va);
#endif
#endif

extern bool hexrays_present;
```

`src/runtime_status.hpp`:

```hpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#pragma once
//Ponce
#include "trigger.hpp"
//Triton
#include <triton/api.hpp>
//IDA
#include <pro.h> 
#include <idd.hpp>

//This struct stores all the global variables used for the current state of the Ponce plugin during execution
//The idea is restore this sctruct when we restore the snapshot
typedef struct runtime_status_t
{
    //This variable stores the number of instructions executed during the tracing
    unsigned int total_number_traced_ins;
    //This variable is use to have statistics
    unsigned int total_number_symbolic_ins;
    //This variable is use to have statistics
    unsigned int total_number_symbolic_conditions;
    //This variable is used to count how many instructions were executed after the user was asked
    unsigned int current_trace_counter;
    //This index is used when we are renaming the tainted funcitons, to know the index
    unsigned int tainted_functions_index;
    //Trigger to enable/disable triton
    Trigger runtimeTrigger;
    //This is the last instruction executed by triton, we need to reference to reanalize if the user taint a register
    triton::arch::Instruction* last_triton_instruction;
    //This variable is used to know how much time the tracing was working, and stop if this time is bigger than the user defined value
    std::uint64_t tracing_start_time = 0;
    thid_t analyzed_thread;
    //Flag used to skip the step over done to deal with wow64 switching
    bool ignore_wow64_switching_step = false;
    // Set when user uses run & break on symbolic
    bool run_and_break_on_symbolic_branch = false;
} runtime_status_t;

extern runtime_status_t ponce_runtime_status;
```

`src/snapshot.cpp`:

```cpp
//! \file
/*
**  Copyright (C) - Triton
**
**  This program is under the terms of the BSD License.
*/

#include <iostream>

#include "snapshot.hpp"
#include "globals.hpp"
#include "utils.hpp"

#include "dbg.hpp"

Snapshot::Snapshot() {
    this->locked = true;
    this->snapshotTaintEngine = nullptr;
    this->snapshotSymEngine = nullptr;
    this->mustBeRestore = false;
    this->snapshotTaken = false;
}


Snapshot::~Snapshot() {
}

/* Check if the snapshot has been taken */
bool Snapshot::exists(void) {
    return this->snapshotTaken;
}

/* Add the modification byte. */
void Snapshot::addModification(ea_t mem, char byte) {
    if (this->locked == false && this->memory.find(mem) == this->memory.end())
        this->memory[mem] = byte;
}


/* Enable the snapshot engine. */
void Snapshot::takeSnapshot() {
    this->snapshotTaken = true;

    /* 1 - Unlock the engine */
    this->locked = false;

    /* 2 - Save current symbolic engine state */
    this->snapshotSymEngine = new triton::engines::symbolic::SymbolicEngine(*api.getSymbolicEngine());

    /* 3 - Save current taint engine state */
    this->snapshotTaintEngine = new triton::engines::taint::TaintEngine(*api.getTaintEngine());

    /* 4 - Save current set of nodes */
    this->astCtx = new triton::ast::AstContext(*api.getAstContext());
    //this->nodesList = api.getAllocatedAstNodes();

    /* 5 - Save the Triton CPU state. It depens on the analyzed binary*/   
    switch (api.getArchitecture()) {
    case triton::arch::ARCH_X86_64:
        this->cpu_x8664 = new triton::arch::x86::x8664Cpu(*dynamic_cast<triton::arch::x86::x8664Cpu*>(api.getCpuInstance()));
        break;
    case triton::arch::ARCH_X86:
        this->cpu_x86 = new triton::arch::x86::x86Cpu(*reinterpret_cast<triton::arch::x86::x86Cpu*>(api.getCpuInstance()));
        break;
    case triton::arch::ARCH_AARCH64:
        this->cpu_AArch64 = new triton::arch::arm::aarch64::AArch64Cpu(*reinterpret_cast<triton::arch::arm::aarch64::AArch64Cpu*>(api.getCpuInstance()));
        break;
    case triton::arch::ARCH_ARM32:
        this->cpu_Arm32 = new triton::arch::arm::arm32::Arm32Cpu(*reinterpret_cast<triton::arch::arm::arm32::Arm32Cpu*>(api.getCpuInstance()));
        break;
    default:
        throw triton::exceptions::Architecture("Architecture not supported.");
        break;
    }

    /* 6 - Save IDA registers context */
    auto regs = api.getAllRegisters();
    for (auto it = regs.begin(); it != regs.end(); it++)
    {
        const triton::arch::Register reg = (*it).second;
        uint64 ival;
        if (get_reg_val(reg.getName().c_str(), &ival)) {
            this->IDAContext[reg.getName()] = ival;
        }
    }

    //We also saved the ponce status
    this->saved_ponce_runtime_status = ponce_runtime_status;
}

void Snapshot::setAddress(ea_t address) {
    this->address = address;
}


/* Restore the snapshot. */
void Snapshot::restoreSnapshot() {

    /* 1 - Restore all memory modification. */
    for (auto i = this->memory.begin(); i != this->memory.end(); ++i) {
        put_bytes(i->first, &i->second, 1);
    }
    this->memory.clear();

    /* 2 - Restore current symbolic engine state */
    *api.getSymbolicEngine() = *this->snapshotSymEngine;

    /* 3 - Restore current taint engine state */
    *api.getTaintEngine() = *this->snapshotTaintEngine;

    /* 4 - Restore current AST context */
    *api.getAstContext() = *this->astCtx;

    /* 5 - Restore the Triton CPU state */
    switch (api.getArchitecture()) {
    case triton::arch::ARCH_X86_64:
        *reinterpret_cast<triton::arch::x86::x8664Cpu*>(api.getCpuInstance()) = *this->cpu_x8664;
        break;
    case triton::arch::ARCH_X86:
        *reinterpret_cast<triton::arch::x86::x86Cpu*>(api.getCpuInstance()) = *this->cpu_x86;
        break;
    case triton::arch::ARCH_AARCH64:
        *reinterpret_cast<triton::arch::arm::aarch64::AArch64Cpu*>(api.getCpuInstance()) = *this->cpu_AArch64;
        break;
    case triton::arch::ARCH_ARM32:
        *reinterpret_cast<triton::arch::arm::arm32::Arm32Cpu*>(api.getCpuInstance()) = *this->cpu_Arm32;
        break;
    default:
        throw triton::exceptions::Architecture("Architecture not supported.");
        break;
    }

    this->mustBeRestore = false;

    /* 6 - Restore IDA registers context
    Suposedly XIP should be set at the same time and execution redirected*/
    typedef std::map<std::string, triton::uint512>::iterator it_type;
    for (it_type iterator = this->IDAContext.begin(); iterator != this->IDAContext.end(); iterator++) {
        if (!set_reg_val(iterator->first.c_str(), static_cast<uint64>(iterator->second)))
            msg("[!] ERROR restoring register %s\n", iterator->first.c_str());
    }

    /* 7 - Restore the Ponce status */
    ponce_runtime_status = this->saved_ponce_runtime_status;

    /* 8 - We need to set to NULL the last instruction. We are deleting the last instructions in the Tritonize callback.
    So after restore a snapshot if last_instruction is not NULL is double freeing the same instruction */
    ponce_runtime_status.last_triton_instruction = nullptr;
}

/* Disable the snapshot engine. */
void Snapshot::disableSnapshot(void) {
    this->locked = true;
}


/* Reset the snapshot engine.
* Clear all backups for a new snapshot. */
void Snapshot::resetEngine(void) {
    if (!this->snapshotTaken)
        return;

    this->memory.clear();

    //ToDo: We should delete this when this issue is fixed: https://github.com/JonathanSalwan/Triton/issues/385
    delete this->snapshotSymEngine;
    this->snapshotSymEngine = nullptr;

    delete this->snapshotTaintEngine;
    this->snapshotTaintEngine = nullptr;

    this->snapshotTaken = false;

    //We delete the comment and color that we created
    ponce_set_cmt(this->address, "", false);
    del_item_color(this->address);
    this->address = 0;
}


/* Check if the snapshot engine is locked. */
bool Snapshot::isLocked(void) {
    return this->locked;
}


/* Check if we must restore the snapshot */
bool Snapshot::mustBeRestored(void) {
    return this->mustBeRestore;
}


/* Check if we must restore the snapshot */
void Snapshot::setRestore(bool flag) {
    this->mustBeRestore = flag;
}

```

`src/snapshot.hpp`:

```hpp
//! \file
/*
**  Copyright (C) - Triton
**
**  This program is under the terms of the LGPLv3 License.
*/

#pragma once

//IDA
#include <pro.h>

#include <map>
#include <set>

/* libTriton */
#include <triton/api.hpp>
#include <triton/ast.hpp>
#include <triton/symbolicEngine.hpp>
#include <triton/taintEngine.hpp>
#include <triton/x8664Cpu.hpp>
#include <triton/x86Cpu.hpp>
#include <triton/arm32Cpu.hpp>
#include <triton/aarch64Cpu.hpp>

// Ponce
#include "runtime_status.hpp"

//! \class Snapshot
//! \brief the snapshot class.
class Snapshot {

private:
    //! I/O memory monitoring for snapshot.
    std::map<ea_t, char> memory;

    //! Status of the snapshot engine.
    bool locked;

    //! Status of the snapshot engine.
    bool snapshotTaken;

    //! Flag which defines if we must restore the snapshot.
    bool mustBeRestore;

    //! AST node state.
    std::set<triton::ast::AbstractNode*> nodesList;

    //! Variables node state.
    std::map<std::string, triton::ast::AbstractNode*> variablesMap;

    //! Snapshot of the symbolic engine.
    triton::engines::symbolic::SymbolicEngine* snapshotSymEngine;

    //! Snapshot of the taint engine.
    triton::engines::taint::TaintEngine* snapshotTaintEngine;

    //! AST Context
    triton::ast::AstContext* astCtx;

    //! Snapshot of triton CPU.
    triton::arch::x86::x8664Cpu* cpu_x8664;
    triton::arch::x86::x86Cpu* cpu_x86;
    triton::arch::arm::aarch64::AArch64Cpu * cpu_AArch64;
    triton::arch::arm::arm32::Arm32Cpu* cpu_Arm32;

#if defined(__x86_64__) || defined(_M_X64)
    
#endif
#if defined(__i386) || defined(_M_IX86)
    triton::arch::x86::x86Cpu* cpu;
#endif

    //! Snapshot of Pin context.
    std::map<std::string, triton::uint512> IDAContext;

    //! Snapshot of the ponce plugin status
    struct runtime_status_t saved_ponce_runtime_status;

    //! address where the snapshot was taken
    ea_t address;

public:
    //! Constructor.
    Snapshot();

    //! Destructor.
    ~Snapshot();

    //! Returns true if the snapshot engine is disabled.
    bool isLocked(void);

    //! Returns true if we must restore the context.
    bool mustBeRestored(void);

    //! Adds a memory modifiction.
    void addModification(ea_t address, char byte);

    //! Disables the snapshot engine.
    void disableSnapshot(void);

    //! Resets the snapshot engine.
    void resetEngine(void);

    //! Restores a snapshot.
    void restoreSnapshot();

    //! Sets the restore flag.
    void setRestore(bool flag);

    //! Takes a snapshot.
    void takeSnapshot();

    //! Tells if a snapshot has been taken
    bool exists(void);

    //! Setter for the address where the snaphsot was taken
    void setAddress(ea_t address);
};


```

`src/solver.cpp`:

```cpp

#include "solver.hpp"
#include "globals.hpp"

#include <dbg.hpp>


/* This function return a vector of Inputs. A vector is necesary since switch conditions may have multiple branch constraints*/
std::vector<Input> solve_formula(ea_t pc, size_t path_constraint_index)
{
    auto pathConstrains = api.getPathConstraints();
    std::vector<Input> solutions;
    
    if (path_constraint_index > pathConstrains.size() - 1) {
        msg("Error. Requested path constraint index %u is larger than PathConstraints vector size (%lu)\n", path_constraint_index, pathConstrains.size());
        return solutions;
    }

    // Double check that the condition at the path constraint index is at the address the user selected
    assert(std::get<1>(pathConstrains[path_constraint_index].getBranchConstraints()[0]) == pc);

    auto ast = api.getAstContext();
    // We are going to store here the constraints for the previous conditions
    // We can not initializate this to null, so we do it to a true condition (based on code_coverage_crackme_xor.py from the triton project)
    auto previousConstraints = ast->equal(ast->bvtrue(), ast->bvtrue());

    // Add user define constraints (borrar en reejecuccion, poner mensaje if not sat, 
    if (ponce_table_chooser){
        for (const auto& [id, constrain] : ponce_table_chooser->constrains) {
            for (const auto& [abstract_node_constrain, str_constrain] : constrain) {
                previousConstraints = ast->land(previousConstraints, abstract_node_constrain);
            }
        }
    }  

    // First we iterate through the previous path constrains to add the predicates of the taken path
    unsigned int j;
    for (j = 0; j < path_constraint_index; j++)
    {
        if (cmdOptions.showExtraDebugInfo)
            msg("[+] Keeping condition %d\n", j);

        // We add to the previous constraints the predicate for the taken branch 
        auto predicate = pathConstrains[j].getTakenPredicate();
        previousConstraints = ast->land(previousConstraints, predicate);
    }

    // Then we use the predicate for the non taken path so we "solve" that condition.
    // We try to solve every non taken branch (more than one is possible under certain situations
    for (auto const& [taken, srcAddr, dstAddr, constraint] : pathConstrains[path_constraint_index].getBranchConstraints()) {
        if (!taken) {
            // We concatenate the previous constraints for the taken path plus the non taken constrain of the user selected condition
            triton::ast::SharedAbstractNode final_expr = ast->land(previousConstraints, constraint);
            if (cmdOptions.showExtraDebugInfo) {  
                std::stringstream ss;
                ss << "(set-logic QF_AUFBV)" << std::endl;
                api.liftToSMT(ss, api.newSymbolicExpression(final_expr), true);
                msg("[+] Formula:\n%s\n\n", ss.str().c_str());
            }

            //Time to solve
            api.setSolverTimeout(cmdOptions.solver_timeout * 1000);
            triton::engines::solver::status_e solver_status;
            auto model = api.getModel(final_expr, &solver_status);
            
            if (solver_status == triton::engines::solver::status_e::TIMEOUT) {
                msg("[!] Solver timed out after %d seconds\n", cmdOptions.solver_timeout);
            }
            else if (solver_status == triton::engines::solver::status_e::UNSAT) {
                msg("[!] That formula cannnot be solved (UNSAT)\n");
            }

            else if (solver_status == triton::engines::solver::status_e::SAT) {
                Input newinput;
                //Clone object 
                newinput.path_constraint_index = path_constraint_index;
                newinput.dstAddr = dstAddr;
                newinput.srcAddr = srcAddr;

                // model is an std::unordered_map. Lets sort it out so results make more sense when printed
                std::map<triton::usize, triton::engines::solver::SolverModel> ordered_model(model.begin(), model.end());

                msg("[+] Solution found! Values:\n");
                for (const auto& [symId, model] : ordered_model) {
                    triton::engines::symbolic::SharedSymbolicVariable  symbVar = api.getSymbolicVariable(symId);
                    std::string  symbVarComment = symbVar->getComment();
                    triton::uint512 model_value = model.getValue();
                    if (symbVar->getType() == triton::engines::symbolic::variable_e::MEMORY_VARIABLE) {
                        auto mem = triton::arch::MemoryAccess(symbVar->getOrigin(), symbVar->getSize() / 8);
                        newinput.memOperand.push_back(mem);
                        api.setConcreteMemoryValue(mem, model_value);
                    }
                    else if (symbVar->getType() == triton::engines::symbolic::variable_e::REGISTER_VARIABLE) {
                        auto reg = triton::arch::Register(*api.getCpuInstance(), (triton::arch::register_e)symbVar->getOrigin());
                        newinput.regOperand.push_back(reg);
                        api.setConcreteRegisterValue(reg, model_value);
                    }
                    switch (symbVar->getSize())
                    {
                    case 8:
                        msg(" - %s%s: %#02x %s\n", 
                            model.getVariable()->getName().c_str(), 
                            !symbVarComment.empty()? (" ("+symbVarComment+")").c_str():"",
                            static_cast<uchar>(model_value),
                            isprint(static_cast<uchar>(model_value)) ? ("(" + std::string(1, static_cast<uchar>(model_value)) + ")").c_str()  : "");
                        break;
                    case 16:
                        msg(" - %s%s: %#04x (%c%c)\n", 
                            !symbVarComment.empty() ? (" (" + symbVarComment + ")").c_str() : "",
                            symbVarComment.c_str(), 
                            static_cast<ushort>(model_value),
                            static_cast<uchar>(model_value) == 0 ? ' ' : static_cast<uchar>(model_value),
                            (unsigned char)(static_cast<ushort>(model_value) >> 8) == 0 ? ' ' : (unsigned char)(static_cast<ushort>(model_value) >> 8));
                        break;
                    case 32:
                        msg(" - %s%s: %#08x\n", 
                            !symbVarComment.empty() ? (" (" + symbVarComment + ")").c_str() : "",
                            symbVarComment.c_str(), 
                            static_cast<uint32>(model_value));
                        break;
                    case 64:
                        msg(" - %s%s: %#16llx\n", 
                            model.getVariable()->getName().c_str(), 
                            !symbVarComment.empty() ? (" (" + symbVarComment + ")").c_str() : "",
                            static_cast<uint64>(model_value));
                        break;
                    default:
                        msg("[!] Unsupported size for the symbolic variable: %s (%s)\n", model.getVariable()->getName().c_str(), symbVarComment.c_str()); // what about 128 - 512 registers? 
                    }
                }
                solutions.push_back(newinput);
            }
            else {
                msg("[!] You should not see this. If so report a bug :(\n");
            }
        }
    }
    return solutions;
}



/*This function identify the type of condition jmp and negate the flags to negate the jmp.
Probably it is possible to do this with the solver, adding more variable to the formula to
identify the flag of the conditions and get the values. But for now we are doing it in this way.*/
void negate_flag_condition(triton::arch::Instruction* triton_instruction)
{
    switch (triton_instruction->getType())
    {
    case triton::arch::x86::ID_INS_JA:
    {
        uint64 cf;
        get_reg_val("CF", &cf);
        uint64 zf;
        get_reg_val("ZF", &zf);
        if (cf == 0 && zf == 0)
        {
            cf = 1;
            zf = 1;
        }
        else
        {
            cf = 0;
            zf = 0;
        }
        set_reg_val("ZF", zf);
        set_reg_val("CF", cf);
        break;
    }
    case triton::arch::x86::ID_INS_JAE:
    {
        uint64 cf;
        get_reg_val("CF", &cf);
        uint64 zf;
        get_reg_val("ZF", &zf);
        if (cf == 0 || zf == 0)
        {
            cf = 1;
            zf = 1;
        }
        else
        {
            cf = 0;
            zf = 0;
        }
        set_reg_val("ZF", zf);
        set_reg_val("CF", cf);
        break;
    }
    case triton::arch::x86::ID_INS_JB:
    {
        uint64 cf;
        get_reg_val("CF", &cf);
        cf = !cf;
        set_reg_val("CF", cf);
        break;
    }
    case triton::arch::x86::ID_INS_JBE:
    {
        uint64 cf;
        get_reg_val("CF", &cf);
        uint64 zf;
        get_reg_val("ZF", &zf);
        if (cf == 1 || zf == 1)
        {
            cf = 0;
            zf = 0;
        }
        else
        {
            cf = 1;
            zf = 1;
        }
        set_reg_val("ZF", zf);
        set_reg_val("CF", cf);
        break;
    }
    /*	ToDo: Check this one
        case triton::arch::x86::ID_INS_JCXZ:
        {
        break;
        }*/
    case triton::arch::x86::ID_INS_JE:
    case triton::arch::x86::ID_INS_JNE:
    {
        uint64 zf;
        auto old_value = get_reg_val("ZF", &zf);
        zf = !zf;
        set_reg_val("ZF", zf);
        break;
    }
    //case triton::arch::x86::ID_INS_JRCXZ:
    //case triton::arch::x86::ID_INS_JECXZ:
    case triton::arch::x86::ID_INS_JG:
    {
        uint64 sf;
        get_reg_val("SF", &sf);
        uint64 of;
        get_reg_val("OF", &of);
        uint64 zf;
        get_reg_val("ZF", &zf);
        if (sf == of && zf == 0)
        {
            sf = !of;
            zf = 1;
        }
        else
        {
            sf = of;
            zf = 0;
        }
        set_reg_val("SF", sf);
        set_reg_val("OF", of);
        set_reg_val("ZF", zf);
        break;
    }
    case triton::arch::x86::ID_INS_JGE:
    {
        uint64 sf;
        get_reg_val("SF", &sf);
        uint64 of;
        get_reg_val("OF", &of);
        uint64 zf;
        get_reg_val("ZF", &zf);
        if (sf == of || zf == 1)
        {
            sf = !of;
            zf = 0;
        }
        else
        {
            sf = of;
            zf = 1;
        }
        set_reg_val("SF", sf);
        set_reg_val("OF", of);
        set_reg_val("ZF", zf);
        break;
    }
    case triton::arch::x86::ID_INS_JL:
    {
        uint64 sf;
        get_reg_val("SF", &sf);
        uint64 of;
        get_reg_val("OF", &of);
        if (sf == of)
        {
            sf = !of;
        }
        else
        {
            sf = of;
        }
        set_reg_val("SF", sf);
        set_reg_val("OF", of);
        break;
    }
    case triton::arch::x86::ID_INS_JLE:
    {
        uint64 sf;
        get_reg_val("SF", &sf);
        uint64 of;
        get_reg_val("OF", &of);
        uint64 zf;
        get_reg_val("ZF", &zf);
        if (sf != of || zf == 1)
        {
            sf = of;
            zf = 0;
        }
        else
        {
            sf = !of;
            zf = 1;
        }
        set_reg_val("SF", sf);
        set_reg_val("OF", of);
        set_reg_val("ZF", zf);
        break;
    }
    case triton::arch::x86::ID_INS_JNO:
    case triton::arch::x86::ID_INS_JO:
    {
        uint64 of;
        get_reg_val("OF", &of);
        of = !of;
        set_reg_val("OF", of);
        break;
    }
    case triton::arch::x86::ID_INS_JNP:
    case triton::arch::x86::ID_INS_JP:
    {
        uint64 pf;
        get_reg_val("PF", &pf);
        pf = !pf;
        set_reg_val("PF", pf);
        break;
    }
    case triton::arch::x86::ID_INS_JNS:
    case triton::arch::x86::ID_INS_JS:
    {
        uint64 sf;
        get_reg_val("SF", &sf);
        sf = !sf;
        set_reg_val("SF", sf);
        break;
    }
    default:
        msg("[!] We cannot negate %s instruction\n", triton_instruction->getDisassembly().c_str());
    }
}


/*We set the memory to the results we got and do the analysis from there*/
void set_SMT_solution(const Input& solution) {
    /*To set the memory types*/
    for (const auto& mem : solution.memOperand){
        auto concreteValue = api.getConcreteMemoryValue(mem, false);
        put_bytes((ea_t)mem.getAddress(), &concreteValue, mem.getSize());
        api.setConcreteMemoryValue(mem, concreteValue);

        if (cmdOptions.showExtraDebugInfo){
            char ascii_value[5] = { 0 };
            if(std::isprint(static_cast<unsigned char>(concreteValue)))
                qsnprintf(ascii_value, sizeof(ascii_value), "(%c)", static_cast<char>(concreteValue));
            std::stringstream stream;
            stream << std::hex << concreteValue;
            msg("[+] Memory " MEM_FORMAT " set with value 0x%s %s\n", 
                mem.getAddress(), 
                stream.str().c_str(), 
                std::isprint(static_cast<unsigned char>(concreteValue))? ascii_value :"");
        }
    }

    /*To set the register types*/
    for (const auto& reg : solution.regOperand) {
        auto concreteRegValue = api.getConcreteRegisterValue(reg, false);
        set_reg_val(reg.getName().c_str(), static_cast<uint64>(concreteRegValue));
        api.setConcreteRegisterValue(reg, concreteRegValue);

        if (cmdOptions.showExtraDebugInfo) {
            char ascii_value[5] = { 0 };
            if (std::isprint(static_cast<unsigned char>(concreteRegValue)))
                qsnprintf(ascii_value, sizeof(ascii_value), "(%c)", static_cast<char>(concreteRegValue));
            std::stringstream stream;
            stream << std::hex << concreteRegValue;

            msg("[+] Registers %s set with value 0x%s %s\n", 
                reg.getName().c_str(), 
                stream.str().c_str(),
                std::isprint(static_cast<unsigned char>(concreteRegValue)) ? ascii_value : "");
        }
    }

    if (cmdOptions.showDebugInfo)
        msg("[+] Memory/Registers set with the SMT results\n");
}


void negate_inject_maybe_restore_solver(ea_t pc, int path_constraint_index, bool restore) {
    auto solutions = solve_formula(pc, path_constraint_index);

    Input* chosen_solution = nullptr;
    if (solutions.size() > 0) {
        if (solutions.size() == 1) {
            chosen_solution = &solutions[0];
            triton::ast::SharedAbstractNode new_constraint;
            for (auto& [taken, srcAddr, dstAddr, constraint] : api.getPathConstraints().back().getBranchConstraints()) {
                // Let's look for the constraint we have force to take wich is the a priori not taken one
                if (!taken) {
                    new_constraint = constraint;
                    break;
                }
            }
            // Once found we first pop the last path constraint
            api.popPathConstraint();
            // And replace it for the found previously
            api.pushPathConstraint(new_constraint);
        }
        else {
            // ToDo: what do we do if we are in a switch case and get several solutions? Just using the first one? Ask the user?
            for (const auto& solution : solutions) {
                // ask the user where he wants to go in popup or even better in the contextual menu
                // chosen_solution = &solutions[0];
                //We need to modify the last path constrain from api.getPathConstraints()
                for (auto& [taken, srcAddr, dstAddr, constraint] : api.getPathConstraints().back().getBranchConstraints()) {
                    if (!taken) {

                    }
                }
            }
        }
        // We negate necesary flags to go over the other branch
        negate_flag_condition(ponce_runtime_status.last_triton_instruction);
        if (restore)
            snapshot.restoreSnapshot();
        set_SMT_solution(*chosen_solution);
    }
}
```

`src/solver.hpp`:

```hpp
#pragma once

#include <vector>

#include <triton/api.hpp>

#include <ida.hpp>

class Input
{
public:
    int path_constraint_index;

    // Memory or register operands involved on the Input
    std::vector <triton::arch::MemoryAccess> memOperand;
    std::vector <triton::arch::Register> regOperand;

    triton::uint64 srcAddr, dstAddr;

    //! Constructor.
    Input() : path_constraint_index(0), srcAddr(0), dstAddr(0)
    {
    }

    //! Destructor.
    ~Input()
    {
    }
};


std::vector<Input> solve_formula(ea_t pc, size_t path_constraint_index);
void negate_inject_maybe_restore_solver(ea_t pc, int path_constraint_index, bool restore);

```

`src/symVarTable.cpp`:

```cpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

//C++
#include <string>
#include <sstream>

//Triton
#include <triton/api.hpp>

//IDA
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <bytes.hpp>
#include <kernwin.hpp>

//Ponce
#include "symVarTable.hpp"
#include "globals.hpp"

struct ponce_table_chooser_t* ponce_table_chooser = nullptr;

void ponce_table_chooser_t::fill_entryList() {
    //We clear the list
    table_item_list.clear();

    for (const auto& [SymVarId, SymVar] : api.getSymbolicVariables()) {
        list_item_t list_entry;

        list_entry.id = SymVarId;
        if (SymVar->getType() == triton::engines::symbolic::variable_e::MEMORY_VARIABLE) {
            list_entry.address = SymVar->getOrigin();
            list_entry.value = api.getConcreteMemoryValue(list_entry.address, false);
        }
        else if (SymVar->getType() == triton::engines::symbolic::variable_e::REGISTER_VARIABLE) {
            list_entry.register_name = api.getRegister((triton::arch::register_e)SymVar->getOrigin()).getName();
            list_entry.value = api.getConcreteRegisterValue(api.getRegister((triton::arch::register_e)SymVar->getOrigin()), false);
        }

        list_entry.var_name = SymVar->getName();
        list_entry.comment = SymVar->getComment();       

        // fill the constrains
        for (const auto& [id, constrain] : constrains) {
            if (list_entry.id == id){
                for (const auto& [abstract_node_constrain, str_constrain] : constrain) {
                    list_entry.constrains += list_entry.constrains.empty() ? str_constrain : " ; " +str_constrain;
                }
            }
        }
        // Finally, let's push it to the vector table
        table_item_list.push_back(list_entry);
    }
}


const int ponce_table_chooser_t::widths_[] = { 
    CHCOL_DEC | 8,
    12,
    10,
    7,
    16,
    16,
    25
};

// column headers
 const char* ponce_table_chooser_t::header_[] =
{
    "SymVarId",
    "Var Name",
    "Address", // Only for memory
    "Reg Name", // Only for registry 
    "Concrete Value",
    "Comment",
    "Constrains"
};

ponce_table_chooser_t::ponce_table_chooser_t()
    : chooser_multi_t(CH_CAN_REFRESH, qnumber(widths_), widths_, header_, "Ponce Symbolic Variables") {
    CASSERT(qnumber(widths_) == qnumber(header_));

    //Fill the list with Triton info
    fill_entryList();
}

// function that generates the list line
void idaapi ponce_table_chooser_t::get_row(qstrvec_t* cols_, int*, chooser_item_attrs_t*,
    size_t n) const {
    qstrvec_t& cols = *cols_;

    list_item_t li = table_item_list.at(n);

    cols[0].sprnt("%lu", li.id);
    cols[1].sprnt("%s", li.var_name.c_str());
    if(!li.register_name.empty()){
        // its a register entry
        cols[3].sprnt("%s", li.register_name.c_str());
    }
    else{    
        // Its a memory entry
        cols[2].sprnt(MEM_FORMAT, li.address);
    }

    cols[4].sprnt("%s", triton::utils::toString(li.value).c_str()); // Concrete value

    if(!li.comment.empty())
        cols[5].sprnt("%s", li.comment.c_str());

    if (!li.constrains.empty())
        cols[6].sprnt("%s", li.constrains.c_str());

}


//This function is used to activate or deactivate other items in the form while using it
int idaapi check_params_cb(int fid, form_actions_t& fa)
{
    ushort isActivated = 0;
    switch (fid)
    {
    case -1: // called at the begining
        fa.get_checkbox_value(3, &isActivated); // get symbolic engine value

        break;
    case -2:
        break;

    case 3:
    {
        fa.get_checkbox_value(fid, &isActivated);
        if (isActivated) {
            fa.enable_field(1, 1);
            fa.enable_field(2, 1);
        }
        break;
    }
    case 4:
    {
        fa.get_checkbox_value(fid, &isActivated);
        if (isActivated){
            qstring lower("0x20");
            qstring upper("0x7e");
            fa.set_string_value(1, &lower);
            fa.set_string_value(2, &upper);
            fa.enable_field(1, 0);
            fa.enable_field(2, 0);
        }       
        break;
    }
    case 5:
    {
        fa.get_checkbox_value(fid, &isActivated);
        if (isActivated) {
            qstring lower("0x30");
            qstring upper("0x39");
            fa.set_string_value(1, &lower);
            fa.set_string_value(2, &upper);
            fa.enable_field(1, 0);
            fa.enable_field(2, 0);
        }
        break;
    }
    case 6:
    {
        fa.get_checkbox_value(fid, &isActivated);
        if (isActivated) {
            qstring lower("0x41");
            qstring upper("0x5a");
            fa.set_string_value(1, &lower);
            fa.set_string_value(2, &upper);
            fa.enable_field(1, 0);
            fa.enable_field(2, 0);
        }
        break;
    }
    case 7:
    {
        fa.get_checkbox_value(fid, &isActivated);
        if (isActivated) {
            qstring lower("0x61");
            qstring upper("0x7a");
            fa.set_string_value(1, &lower);
            fa.set_string_value(2, &upper);
            fa.enable_field(1, 0);
            fa.enable_field(2, 0);
        }
        break;
    }
    default:
        break;
    }

    // Let's deactivate all the check

    return 1;
}

int ask_constrain(sizevec_t& choser_selection, int* upper_limit_int, int* lower_limit_int) {
    qstring upper_limit = "None";
    qstring lower_limit = "None";

    bool lower_set = false, upper_set = false;
    ushort chkgroup1 = 0;
    if (ask_form(constrain_form,
        check_params_cb, // the call to this function can be omitted. It's only usefull if a checkbox activate or dissable other elements of the form
        &lower_limit,
        &upper_limit,
        &chkgroup1
    ) > 0)
    {
        if (upper_limit != "None" && !upper_limit.empty()) {
            try {
                int base = 10;
                char* ptr = (char*)upper_limit.c_str();
                if (upper_limit.substr(0, 2) == "0x") {
                    // its hex
                    base = 16;
                    ptr += 2;
                }
                *upper_limit_int = std::stoi(ptr, 0, base);
                upper_set = true;
            }
            catch (...) {}
        }
        if (lower_limit != "None" && !lower_limit.empty()) {
            try{
                int base = 10;
                char* ptr = (char*)lower_limit.c_str();
                if (lower_limit.substr(0, 2) == "0x") {
                    // its hex
                    base = 16;
                    ptr += 2;
                }
                *lower_limit_int = std::stoi(ptr, 0, base);
                lower_set = true;
            }
            catch (...) {}
        }

        if (lower_set && upper_set)
            return 2;
        else if (lower_set)
            return 1;
        else if (upper_set)
            return 0;
    }
    return -1;
}
```

`src/symVarTable.hpp`:

```hpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#pragma once

#include <vector>
#include "kernwin.hpp"


extern struct ponce_table_chooser_t* ponce_table_chooser;

// column widths
struct ponce_table_chooser_t : public chooser_multi_t
{
protected:
    static const int widths_[];
    static const char* header_[];
    typedef struct s
    {
        triton::usize id = 0;
        triton::uint64 address = 0;
        std::string register_name;
        triton::uint512 value = 0;
        std::string comment;
        std::string var_name;
        std::string constrains;
        
    }list_item_t;
   
    TWidget* widget;
    
public:

    std::map<triton::usize, std::vector<std::tuple<triton::ast::SharedAbstractNode, std::string>>> constrains;

    virtual ~ponce_table_chooser_t() {
        if (!table_item_list.empty()) {
            table_item_list.clear();
        }
    }
    // function that returns number of lines in the list
    virtual size_t idaapi get_count() const { return table_item_list.size(); }

    // function that generates the list line
    virtual void idaapi get_row(qstrvec_t* cols, int* icon_,
        chooser_item_attrs_t* attrs,
        size_t n) const;

    // function that is called when the user wants to refresh the chooser
    virtual cbres_t idaapi refresh(sizevec_t* sel) {
        fill_entryList();
        //return adjust_last_item(n);  // try to preserve the cursor
        return ALL_CHANGED;
    }


    // function that is called when the user wants to close the chooser
    virtual void idaapi closed() {
        table_item_list.clear();
        constrains.clear();
        ponce_table_chooser = nullptr;
    }

public:
    std::vector<list_item_t> table_item_list;

    ponce_table_chooser_t();
    void fill_entryList();
};




static const char constrain_form[]=
"STARTITEM 0\n"
"Add constrain to symbolic variable(s)\n\n"
"%/"
"Set limits:\n"
"<#Lower bound restriction#Lower bound:q1:16:16>\n"
"<#Upper bound restriction#Upper bound:q2:16:16>\n"

"<#Common constraints#Custom:R3>\n"
"<#ASCII only:R4>\n"
"<#Numeric only:R5>\n"
"<#Uppercase letters only:R6>\n"
"<#Lowercase letters only:R7>>\n"

"\n"
;


int ask_constrain(sizevec_t& choser_selection, int* upper_limit_int, int* lower_limit_int);

```

`src/trigger.cpp`:

```cpp
//! \file
/*
**  Copyright (C) - Triton
**
**  This program is under the terms of the BSD License.
*/

#include "trigger.hpp"

Trigger::Trigger()
    : state(false) {
}

void Trigger::toggle() {
    this->state = !this->state;
}

bool Trigger::getState() {
    return this->state;
}

void Trigger::enable(void) {
    this->state = true;
}

void Trigger::disable(void) {
    this->state = false;
}

void Trigger::update(bool flag) {
    this->state = flag;
}


```

`src/trigger.hpp`:

```hpp
//! \file
/*
**  Copyright (C) - Triton
**
**  This program is under the terms of the BSD License.
*/

#pragma once

//! \class Trigger Enable and disable the Pin's InsertCalls.
class Trigger {
protected:
    bool state;

public:
    //! Constructor.
    Trigger();

    //! Switchs the trigger.
    void toggle();

    //! Returns true if the switch is ON, false otherwise.
    bool getState();

    //! Sets the state to true
    void enable(void);

    //! Sets the state to false
    void disable(void);

    //! Sets the state to flag
    void update(bool flag);


};
```

`src/triton_logic.cpp`:

```cpp

#include "triton_logic.hpp"
#include "globals.hpp"
#include "utils.hpp"
#include "context.hpp"
#include "blacklist.hpp"

#include <ida.hpp>
#include <dbg.hpp>
#include <auto.hpp>

/*This function will create and fill the Triton object for every instruction
    Returns:
    0 instruction tritonized
    1 trigger is not activated
    2 other error*/
int tritonize(ea_t pc, thid_t threadID)
{
    /*Check that the runtime Trigger is on just in case*/
    if (!ponce_runtime_status.runtimeTrigger.getState())
        return 1;

    threadID = threadID ? threadID : get_current_thread();

    if (pc == 0) {
        msg("[!] Some error at tritonize since pc is 0\n");
        return 2;
    }

    // Show analized instruction in IDA UI
    show_addr(pc);

    //We delete the last_instruction
    if (ponce_runtime_status.last_triton_instruction != nullptr) {
        delete ponce_runtime_status.last_triton_instruction;
        ponce_runtime_status.last_triton_instruction = nullptr;
    }

    triton::arch::Instruction* tritonInst = new triton::arch::Instruction();
    ponce_runtime_status.last_triton_instruction = tritonInst;

    /*This will fill the 'cmd' (to get the instruction size) which is a insn_t structure https://www.hex-rays.com/products/ida/support/sdkdoc/classinsn__t.html */
    if (!can_decode(pc)) {
        msg("[!] Some error decoding instruction at " MEM_FORMAT "\n", pc);
    }

    unsigned char opcodes[15];
    ssize_t item_size = 0x0;

    insn_t ins;
    decode_insn(&ins, pc);
    item_size = ins.size;
    assert(item_size < sizeof(opcodes));
    get_bytes(&opcodes, item_size, pc, GMB_READALL, NULL);

    /* Setup Triton information */
    tritonInst->clear(); // ToDo: I think this is not necesary
    tritonInst->setOpcode((triton::uint8*)opcodes, item_size);
    tritonInst->setAddress(pc);
    tritonInst->setThreadId(threadID);

    try {
        if (!api.processing(*tritonInst)) {
            msg("[!] Instruction at " MEM_FORMAT " not supported by Triton: %s (Thread id: %d)\n", pc, tritonInst->getDisassembly().c_str(), threadID);
            return 2;
        }
    }
    catch (const triton::exceptions::Exception& e) {
        msg("[!] Instruction at " MEM_FORMAT " not supported by Triton: %s (Thread id: %d)\n", pc, tritonInst->getDisassembly().c_str(), threadID);
        return 2;
    }

    if (cmdOptions.showExtraDebugInfo) {
        msg("[+] Triton at " MEM_FORMAT " : %s (Thread id: %d)\n", pc, tritonInst->getDisassembly().c_str(), threadID);
    }

    /*In the case that the snapshot engine is in use we should track every memory write access*/
    if (snapshot.exists())  {
        for (const auto& [memory_access, node]: tritonInst->getStoreAccess()){
            auto addr = memory_access.getAddress();
            //This is the way to force IDA to read the value from the debugger
            //More info here: https://www.hex-rays.com/products/ida/support/sdkdoc/dbg_8hpp.html#ac67a564945a2c1721691aa2f657a908c
            invalidate_dbgmem_contents((ea_t)addr, memory_access.getSize()); //ToDo: Do I have to call this for every byte in memory I want to read?
            for (unsigned int i = 0; i < memory_access.getSize(); i++) {
                triton::uint128 value = 0;
                //We get the memory readed
                get_bytes(&value, 1, (ea_t)addr + i, GMB_READALL, NULL);

                //We add a meomory modification to the snapshot engine
                snapshot.addModification((ea_t)addr + i, static_cast<char>(value));
            }
        }
    }

    /* Don't write nothing on symbolic/tainted branch instructions instructions because I'll do it later*/
    if (cmdOptions.addCommentsControlledOperands && !tritonInst->isBranch()){
        comment_controlled_operands(tritonInst, pc);
    }

    if (cmdOptions.addCommentsSymbolicExpresions)
        add_symbolic_expressions(tritonInst, pc);

    //We only paint the executed instructions if they don't have a previous color
    if (get_item_color(pc) == DEFCOLOR && cmdOptions.color_executed_instruction != DEFCOLOR) {
        ponce_set_item_color(pc, cmdOptions.color_executed_instruction);
    }
    

    //ToDo: The isSymbolized is missidentifying like "user-controlled" some instructions: https://github.com/JonathanSalwan/Triton/issues/383
    if (tritonInst->isTainted() || tritonInst->isSymbolized()) {
        ponce_runtime_status.total_number_symbolic_ins++;

        if (cmdOptions.showDebugInfo) {
            msg("[!] Instruction %s at " MEM_FORMAT " \n", tritonInst->isTainted() ? "tainted" : "symbolized", pc);
        }
        if (cmdOptions.RenameTaintedFunctionNames)
            rename_tainted_function(pc);
        // Check if it is a conditional jump
        // We only color with a different color the symbolic conditions, to show the user he could do additional actions like solve
        if (tritonInst->isBranch()) {
            if (tritonInst->isTainted())
                ponce_set_cmt(pc, "Tainted branch!", false, false);
            else
                ponce_set_cmt(pc, "Symbolic branch, make your choice!", false, false);

            ponce_runtime_status.total_number_symbolic_conditions++;
            if (cmdOptions.color_tainted_condition != DEFCOLOR)
                ponce_set_item_color(pc, cmdOptions.color_tainted_condition);
        }
        else  {
            //It paints every tainted/symbolic instruction
            if (cmdOptions.color_tainted != DEFCOLOR)
                ponce_set_item_color(pc, cmdOptions.color_tainted);
        }
    }

    if (tritonInst->isBranch() && tritonInst->isSymbolized()) {
        ea_t addr1 = (ea_t)tritonInst->getNextAddress();
        ea_t addr2 = (ea_t)tritonInst->operands[0].getImmediate().getValue();
        if (cmdOptions.showDebugInfo) {
            msg("[+] Branch symbolized detected at " MEM_FORMAT ": " MEM_FORMAT " or " MEM_FORMAT ", Taken:%s\n", pc, addr1, addr2, tritonInst->isConditionTaken() ? "Yes" : "No");
        }

        if (ponce_runtime_status.run_and_break_on_symbolic_branch) {
            suspend_process();
            ponce_runtime_status.run_and_break_on_symbolic_branch = false;
        }
    }

    return 0;
}

bool ponce_set_triton_architecture() {
    if (ph.id == PLFM_386) {
        if (ph.use64())
            api.setArchitecture(triton::arch::ARCH_X86_64);
        else if (ph.use32())
            api.setArchitecture(triton::arch::ARCH_X86);
        else {
            msg("[e] Wrong architecture\n");
            return false;
        }
    }
    else if (ph.id == PLFM_ARM) {
        if (ph.use64())
            api.setArchitecture(triton::arch::ARCH_AARCH64);
        else if (ph.use32())
            api.setArchitecture(triton::arch::ARCH_ARM32);
        else {
            msg("[e] Wrong architecture\n");
            return false;
        }
    }
    else {
        msg("[e] Architecture not supported by Ponce\n");
        return false;
    }
    return true;
}

/*This functions is called every time a new debugger session starts*/
void triton_restart_engines()
{
    if (cmdOptions.showDebugInfo)
        msg("[+] Restarting triton engines...\n");
    //We need to set the architecture for Triton
    ponce_set_triton_architecture();
    //We reset everything at the beginning
    api.reset();
    // Memory access callback
    api.addCallback(triton::callbacks::callback_e::GET_CONCRETE_MEMORY_VALUE, needConcreteMemoryValue_cb);
    // Register access callback
    api.addCallback(triton::callbacks::callback_e::GET_CONCRETE_REGISTER_VALUE, needConcreteRegisterValue_cb);

    if (ponce_runtime_status.last_triton_instruction) {
        delete ponce_runtime_status.last_triton_instruction;
        ponce_runtime_status.last_triton_instruction = nullptr;
    }

    api.setMode(triton::modes::ONLY_ON_SYMBOLIZED, true);
    
    // These modes cannot be configured by the user. They are allways on
    api.setMode(triton::modes::ALIGNED_MEMORY, true);
    // We don't want to track non symbolic path constraints
    api.setMode(triton::modes::PC_TRACKING_SYMBOLIC, true);
    // Only keep expressions (AST) that contain at least a symbolic variable
    api.setMode(triton::modes::ONLY_ON_SYMBOLIZED, true);


    // Set the optimizations selected by user
    api.setMode(triton::modes::AST_OPTIMIZATIONS, cmdOptions.AST_OPTIMIZATIONS);
    api.setMode(triton::modes::CONCRETIZE_UNDEFINED_REGISTERS, cmdOptions.CONCRETIZE_UNDEFINED_REGISTERS);
    api.setMode(triton::modes::CONSTANT_FOLDING, cmdOptions.CONSTANT_FOLDING);
    api.setMode(triton::modes::SYMBOLIZE_INDEX_ROTATION, cmdOptions.SYMBOLIZE_INDEX_ROTATION);
    api.setMode(triton::modes::TAINT_THROUGH_POINTERS, cmdOptions.TAINT_THROUGH_POINTERS);

    ponce_runtime_status.runtimeTrigger.disable();
    ponce_runtime_status.tainted_functions_index = 0;
    //Reset instruction counter
    ponce_runtime_status.total_number_traced_ins = 0;
    ponce_runtime_status.total_number_symbolic_ins = 0;
    ponce_runtime_status.total_number_symbolic_conditions = 0;
    ponce_runtime_status.current_trace_counter = 0;
    breakpoint_pending_actions.clear();
    clear_requests_queue();

}


/*This function is call the first time we are tainting something to enable the trigger, the flags and the tracing*/
void start_tainting_or_symbolic_analysis()
{
    if (!ponce_runtime_status.runtimeTrigger.getState())
    {
        //triton_restart_engines();
        // Delete previous Ponce comments
        if (ponce_runtime_status.last_triton_instruction == nullptr){
            /* We don't want to delete the comments in case we are re-enabling 
            an current Ponce tracing like when the user just disables Ponce
            to prevent instrumenting a function but he's gonna reenabling in after it*/
            delete_ponce_comments();
        }
        ponce_runtime_status.runtimeTrigger.enable();
        ponce_runtime_status.analyzed_thread = get_current_thread();
        enable_step_trace(true);
        set_step_trace_options(0);
        ponce_runtime_status.tracing_start_time = 0;
    }
}
```

`src/triton_logic.hpp`:

```hpp
#pragma once

#include <dbg.hpp>

int tritonize(ea_t pc, thid_t threadID = 0);
void triton_restart_engines();
void start_tainting_or_symbolic_analysis();
bool ponce_set_triton_architecture();
```

`src/utils.cpp`:

```cpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

//C++
#include <stdio.h>
#include <string>
#include <iostream>
#include <fstream>
//Used in GetTimeMs64
#ifdef _WIN32
#include <Windows.h>
#else
#include <sys/time.h>
#include <ctime>
#endif


//Triton
#include <triton/api.hpp>
#include <triton/x86Specifications.hpp>

//IDA
#include <idp.hpp>
#include <loader.hpp>
#include <dbg.hpp>
#include <name.hpp>
#include <bytes.hpp>

//Ponce
#include "utils.hpp"
#include "globals.hpp"
#include "context.hpp"
#include "blacklist.hpp"
#include "callbacks.hpp"





/*This functions gets a string and return the triton register assign or nullptr
This is using the triton current architecture so it is more generic.*/
const triton::arch::register_e str_to_register(const qstring& register_name)
{
    for (const auto& [key, value] : api.getAllRegisters())
        if (stricmp(value.getName().c_str(), register_name.c_str()) == 0)
            return key;

    return triton::arch::register_e::ID_REG_INVALID;
}


/*This function is a helper to find a function having its name.
It is likely IDA SDK has another API to do this but I can't find it.
Source: http://www.openrce.org/reference_library/files/ida/idapw.pdf */
ea_t find_function(char const* function_name)
{
    // get_func_qty() returns the number of functions in file(s) loaded.
    for (unsigned int f = 0; f < get_func_qty(); f++) {
        // getn_func() returns a func_t struct for the function number supplied
        func_t* curFunc = getn_func(f);
        qstring funcName;
        ssize_t size_read = 0;
        // get_func_name2 gets the name of a function and stored it in funcName
        size_read = get_func_name(&funcName, curFunc->start_ea);
        if (size_read > 0) { // if found
            if (strcmp(funcName.c_str(), function_name) == 0) {
                return curFunc->start_ea;
            }
            //We need to ignore our prefix when the function is tainted
            //If the function name starts with our prefix, fix for #51
            if (strstr(funcName.c_str(), RENAME_TAINTED_FUNCTIONS_PREFIX) == funcName.c_str() && funcName.size() > RENAME_TAINTED_FUNCTIONS_PATTERN_LEN) {
                //Then we ignore the prefix and compare the rest of the function name
                if (strcmp(funcName.c_str() + RENAME_TAINTED_FUNCTIONS_PATTERN_LEN, function_name) == 0) {
                    return curFunc->start_ea;
                }
            }
        }
    }
    return -1;
}

//This function return the real value of the argument.
ea_t get_args(int argument_number, bool skip_ret)
{
#if !defined(__EA64__)
    ea_t memprogram = get_args_pointer(argument_number, skip_ret);
    //We first get the pointer and then we dereference it
    ea_t value = 0;
    value = read_regSize_from_ida(memprogram);
    return value;

#else
    int skip_ret_index = skip_ret ? 1 : 0;
    //Not converted to IDA we should use get_reg_val
#ifdef __NT__ // note the underscore: without it, it's not msdn official!
    // On Windows - function parameters are passed in using RCX, RDX, R8, R9 for ints / ptrs and xmm0 - 3 for float types.
    switch (argument_number)
    {
    case 0: return static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_rcx));
    case 1: return static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_rdx));
    case 2: return static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_r8));
    case 3: return static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_r9));
    default:
        ea_t esp = static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_rsp));
        ea_t arg = esp + (argument_number - 4 + skip_ret_index) * 8;
        return get_qword(arg);
    }
#elif __LINUX__ || __MAC__ // IDA macros https://www.hex-rays.com/products/ida/support/sdkdoc/pro_8h.html
    //On Linux - parameters are passed in RDI, RSI, RDX, RCX, R8, R9 for ints / ptrs and xmm0 - 7 for float types.
    switch (argument_number)
    {
    case 0: return static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_rdi));
    case 1: return static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_rsi));
    case 2: return static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_rdx));
    case 3: return static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_rcx));
    case 4: return static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_r8));
    case 5: return static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_r9));
    default:
        ea_t esp = static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_rsp));
        ea_t arg = esp + (argument_number - 6 + skip_ret_index) * 8;
        return get_qword(arg);
    }
#endif
#endif
}

// Return the argument at the "argument_number" position. It is independant of the architecture and the OS.
// We suppossed the function is using the default call convention, stdcall or cdelc in x86, no fastcall and fastcall in x64
ea_t get_args_pointer(int argument_number, bool skip_ret)
{
    int skip_ret_index = skip_ret ? 1 : 0;
#if !defined(__EA64__)
    regval_t esp_value;
    invalidate_dbg_state(DBGINV_REGS);
    get_reg_val("esp", &esp_value);
    ea_t arg = (ea_t)esp_value.ival + (argument_number + skip_ret_index) * 4;
    return arg;
#else
    //Not converted to IDA we should use get_reg_val
#ifdef __NT__ // note the underscore: without it, it's not msdn official!
    // On Windows - function parameters are passed in using RCX, RDX, R8, R9 for ints / ptrs and xmm0 - 3 for float types.
    switch (argument_number)
    {
    case 0:
    case 1:
    case 2:
    case 3: error("[!] In Windows 64 bits you can't get a pointer to the four first\n arguments since they are registers");
    default:
        ea_t esp = static_cast<ea_t>(IDA_getCurrentRegisterValue(api.registers.x86_rsp));
        ea_t arg = esp + (argument_number - 4 + skip_ret_index) * 8;
        return arg;
    }
#elif __LINUX__ || __MAC__ // IDA macros https://www.hex-rays.com/products/ida/support/sdkdoc/pro_8h.html
    //On Linux - parameters are passed in RDI, RSI, RDX, RCX, R8, R9 for ints / ptrs and xmm0 - 7 for float types.
    switch (argument_number)
    {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:error("[!] In Linux/OsX 64 bits you can't get a pointer to the five first\n arguments since they are registers");
    default:
        ea_t esp = (ea_t)IDA_getCurrentRegisterValue(api.registers.x86_rsp);
        ea_t arg = esp + (argument_number - 6 + skip_ret_index) * 8;
        return arg;
    }
#endif
#endif
}

//Use templates??
short read_unicode_char_from_ida(ea_t address)
{
    short value;
    //This is the way to force IDA to read the value from the debugger
    //More info here: https://www.hex-rays.com/products/ida/support/sdkdoc/dbg_8hpp.html#ac67a564945a2c1721691aa2f657a908c
    invalidate_dbgmem_contents(address, sizeof(value));
    ssize_t bytes_read = get_bytes(&value, sizeof(value), address, GMB_READALL, NULL);
    if (bytes_read == 0 || bytes_read == -1) {
        msg("[!] Error reading memory from " MEM_FORMAT "\n", address);
    }
    return value;
}

//Use templates??
char read_char_from_ida(ea_t address)
{
    char value;
    //This is the way to force IDA to read the value from the debugger
    //More info here: https://www.hex-rays.com/products/ida/support/sdkdoc/dbg_8hpp.html#ac67a564945a2c1721691aa2f657a908c
    invalidate_dbgmem_contents(address, sizeof(value));
    ssize_t bytes_read = get_bytes(&value, sizeof(value), address, GMB_READALL, NULL);
    if (bytes_read == 0 || bytes_read == -1) {
        msg("[!] Error reading memory from " MEM_FORMAT "\n", address);
    }
    return value;
}

ea_t read_regSize_from_ida(ea_t address)
{
    ea_t value;
    //This is the way to force IDA to read the value from the debugger
    //More info here: https://www.hex-rays.com/products/ida/support/sdkdoc/dbg_8hpp.html#ac67a564945a2c1721691aa2f657a908c
    invalidate_dbgmem_contents(address, sizeof(value));
    ssize_t bytes_read = get_bytes(&value, sizeof(value), address, GMB_READALL, NULL);
    if (bytes_read == 0 || bytes_read == -1) {
        msg("[!] Error reading memory from " MEM_FORMAT "\n", address);
    }

    return value;
}

/*This function renames a tainted function with the prefix RENAME_TAINTED_FUNCTIONS_PATTERN, by default "T%03d_"*/
void rename_tainted_function(ea_t address)
{
    qstring func_name;
    ssize_t size = 0x0;
    //First we get the current function name
    size = get_func_name(&func_name, address);

    if (size > 0) {
        //If the function isn't already renamed
        if (strstr(func_name.c_str(), RENAME_TAINTED_FUNCTIONS_PREFIX) != func_name.c_str()) {
            char new_func_name[MAXSTR];
            //This is a bit tricky, the prefix contains the format string, so if the user modified it and removes the format string isn't going to work
            qsnprintf(new_func_name, sizeof(new_func_name), RENAME_TAINTED_FUNCTIONS_PATTERN"%s", ponce_runtime_status.tainted_functions_index, func_name.c_str());
            //We need the start of the function we can have that info with our function find_function
            set_name(find_function(func_name.c_str()), new_func_name);
            if (cmdOptions.showDebugInfo)
                msg("[+] Renaming function %s -> %s\n", func_name.c_str(), new_func_name);
            ponce_runtime_status.tainted_functions_index += 1;
        }
    }
}

void add_symbolic_expressions(triton::arch::Instruction* tritonInst, ea_t address)
{
    std::ostringstream oss;
    for (const auto& expr : tritonInst->symbolicExpressions) {       
        oss << expr << "\n";
    }

    ponce_set_cmt(address, oss.str().c_str(), false);
}

std::string notification_code_to_string(int notification_code)
{
    switch (notification_code)
    {
    case 0:
        return std::string("dbg_null");
    case 1:
        return std::string("dbg_process_start");
    case 2:
        return std::string("dbg_process_exit");
    case 3:
        return std::string("dbg_process_attach");
    case 4:
        return std::string("dbg_process_detach");
    case 5:
        return std::string("dbg_thread_start");
    case 6:
        return std::string("dbg_thread_exit");
    case 7:
        return std::string("dbg_library_load");
    case 8:
        return std::string("dbg_library_unload");
    case 9:
        return std::string("dbg_information");
    case 10:
        return std::string("dbg_exception");
    case 11:
        return std::string("dbg_suspend_process");
    case 12:
        return std::string("dbg_bpt");
    case 13:
        return std::string("dbg_trace");
    case 14:
        return std::string("dbg_request_error");
    case 15:
        return std::string("dbg_step_into");
    case 16:
        return std::string("dbg_step_over");
    case 17:
        return std::string("dbg_run_to");
    case 18:
        return std::string("dbg_step_until_ret");
    case 19:
        return std::string("dbg_bpt_changed");
    case 20:
        return std::string("dbg_last");
    default:
        return std::string("Not defined");
    }
}

/*This function loads the options from the config file.
It returns true if it reads the config false, if there is any error.*/
bool load_options(struct cmdOptionStruct* cmdOptions)
{
    std::ifstream config_file;
    config_file.open("Ponce.cfg", std::ios::in | std::ios::binary);
    if (!config_file.is_open())
    {
        msg("[i] Config file %s not found\n", "Ponce.cfg");
        return false;
    }
    auto begin = config_file.tellg();
    config_file.seekg(0, std::ios::end);
    auto end = config_file.tellg();
    config_file.seekg(0, std::ios::beg);
    if ((end - begin) != sizeof(struct cmdOptionStruct))
        return false;
    config_file.read((char*)cmdOptions, sizeof(struct cmdOptionStruct));
    config_file.close();

    //Check if we need to reload the custom blacklisted functions
    if (cmdOptions->blacklist_path[0] != '\0') {
        //Means that the user set a path for custom blacklisted functions
        if (blacklkistedUserFunctions != NULL) {
            //Check if we had a previous custom blacklist and if so we delete it
            blacklkistedUserFunctions->clear();
            delete blacklkistedUserFunctions;
            blacklkistedUserFunctions = NULL;
        }
        readBlacklistfile(cmdOptions->blacklist_path);
    }

    return true;
}

/*This function loads the options from the config file.
It returns true if it reads the config and false if there is any error.*/
bool save_options(struct cmdOptionStruct* cmdOptions)
{
    std::ofstream config_file;
    config_file.open("Ponce.cfg", std::ios::out | std::ios::binary);
    if (!config_file.is_open())
    {
        msg("[!] Error opening config file %s\n", "Ponce.cfg");
        return false;
    }
    config_file.write((char*)cmdOptions, sizeof(struct cmdOptionStruct));
    config_file.close();
    return true;
}




/*Ask to the user if he really want to execute native code even if he has a snapshot.
Returns true if the user say yes.*/
bool ask_for_execute_native()
{
    //Is there any snapshot?
    if (!snapshot.exists())
        return true;
    //If so we should say to the user that he cannot execute native code and expect the snapshot to work
    int answer = ask_yn(1, "[?] If you execute native code (without tracing) Ponce cannot trace all the memory modifications so the execution snapshot will be deleted. Do you still want to do it? (Y/n):");
    if (answer == 1) //Yes
        return true;
    else // No or Cancel
        return false;
}

/*This function deletes the prefixes and sufixes that IDA adds*/
qstring clean_function_name(qstring name) {
    if (name.substr(0, 7) == "__imp__")
        return clean_function_name(name.substr(7));
    else if (name.substr(0, 4) == "imp_")
        return clean_function_name(name.substr(4));
    else if (name.substr(0, 3) == "cs:" || name.substr(0, 3) == "ds:")
        return clean_function_name(name.substr(3));
    else if (name.substr(0, 2) == "j_")
        return clean_function_name(name.substr(2));
    else if (name.substr(0, 1) == "_" || name.substr(0, 1) == "@" || name.substr(0, 1) == "?")
        return clean_function_name(name.substr(1));
    else if (name.find('@', 0) != -1)
        return clean_function_name(name.substr(0, name.find('@', 0)));
    else if (name.at(name.length() - 2) == '_' && isdigit(name.at(name.length() - 1))) //name_1
        return clean_function_name(name.substr(0, name.length() - 2));
    return name;
}

qstring get_callee_name(ea_t address) {
    qstring name;
    char buf[100] = { 0 };
    static const char* nname = "$ vmm functions";
    netnode n(nname);
    auto fun = n.altval(address) - 1;
    if (fun == -1) {
        qstring buf_op;
        if (is_code(get_flags(address)))
            print_operand(&buf_op, address, 0);
        qstring buf_tag;
        tag_remove(&buf_tag, buf_op);
        name = clean_function_name(buf_tag);
    }
    else {
        get_ea_name(&name, fun); // 00C5101A call    edi ; __imp__malloc style

        if (name.empty()) {
            qstring buf_op;
            if (is_code(get_flags(address)))
                print_operand(&buf_op, address, 0);
            qstring buf_tag;
            tag_remove(&buf_tag, buf_op);
            name = clean_function_name(buf_tag);
        }
        else {
            name = clean_function_name(name);
        }
    }
    return name;
}

std::uint64_t GetTimeMs64(void)
{
#ifdef _WIN32
    /* Windows */
    FILETIME ft;
    LARGE_INTEGER li;

    /* Get the amount of 100 nano seconds intervals elapsed since January 1, 1601 (UTC) and copy it
    * to a LARGE_INTEGER structure. */
    GetSystemTimeAsFileTime(&ft);
    li.LowPart = ft.dwLowDateTime;
    li.HighPart = ft.dwHighDateTime;

    std::uint64_t ret = li.QuadPart;
    ret -= 116444736000000000LL; /* Convert from file time to UNIX epoch time. */
    ret /= 10000; /* From 100 nano seconds (10^-7) to 1 millisecond (10^-3) intervals */

    return ret;
#else
    /* Linux */
    struct timeval tv;

    gettimeofday(&tv, NULL);

    triton::uint64 ret = tv.tv_usec;
    /* Convert from micro seconds (10^-6) to milliseconds (10^-3) */
    ret /= 1000;

    /* Adds the seconds (10^0) after converting them to milliseconds (10^-3) */
    ret += (tv.tv_sec * 1000);

    return ret;
#endif
}

/* Gets current instruction. Only possible if */
ea_t current_instruction()
{
    if (!is_debugger_on()) {
        return 0;
    }
    ea_t xip = 0;
    if (!get_ip_val(&xip)) {
        msg("[-] Could not get the XIP value. This should never happen\n");
        return 0;
    }
    return xip;
}

/* This function deletes all the comments and colour made by Ponce Plugin everytime that the Ponce
engine is restarted with another run. We do this to prevent polluting the IDA UI*/
void delete_ponce_comments() {
    unsigned int count_comments = 0;
    unsigned int count_colors = 0;
    ea_t snapshot_address = 0;
    for (auto& [address, insinfo]: ponce_comments) {      
        if (!insinfo.comment.empty()) { //comment
            set_cmt(address, "", false);
            count_comments++;
        }
        if (!insinfo.snapshot_comment.empty()) { //extra comment
            if (snapshot.exists())
                snapshot_address = address;
            set_cmt(address, "", false);
        }
        if (insinfo.color != DEFCOLOR) { //color
            del_item_color(address);
            count_colors++;
        }
    }
    ponce_comments.clear();
    msg("[+] Deleted %u comments and %u colored addresses\n", count_comments, count_colors);

    // If snapshot exists lets put it back
    if (snapshot_address) {
        ponce_set_cmt(snapshot_address, "Snapshot taken here", false, true);
    }
}

void ponce_set_item_color(ea_t ea, bgcolor_t color) {
    //if it is a new color we add it to ponce_comments
    if (ponce_comments.count(ea) > 0) {
        ponce_comments[ea].color = color;
    }
    else {
        struct instruction_info insinfo;
        insinfo.color = color;
        ponce_comments[ea] = insinfo;
    }
    set_item_color(ea, color);
}

/* Wrapper to keep track of added comments so we can delete them after*/
bool ponce_set_cmt(ea_t ea, const char* comm, bool rptble, bool snapshot) {
    qstring buf;
    qstring new_comment;
    if (get_cmt(&buf, ea, rptble) != -1) {
        auto first_space = strchr(buf.c_str(), ' ');
        // there is a previous comment. Let's try to get the hit count
        if (first_space){
            try {
                auto n_hit = std::stoi(std::string(buf.c_str(), first_space - buf.c_str()));
                new_comment.sprnt("%d hits. %s", ++n_hit, comm);
                //return set_cmt(ea, new_comment.c_str(), rptble);
            }
            catch (...) {}
        }
        if(new_comment.empty()){
            new_comment.sprnt("%d hits. %s", 2, comm);
            //return set_cmt(ea, new_comment.c_str(), rptble);     
        }
    }
    else { //its a new comment
        new_comment = comm;
    }

    auto new_line_pos = new_comment.find('\n');
    /* Lets only get the text about Symbolic/Taint instruction not the memory or
        registers involved since thats not relevant info for the pseudocode*/
    std::string pseudocode_comment;
    if (new_line_pos != std::string::npos) 
        pseudocode_comment = std::string(new_comment.c_str(), new_line_pos);
    else
        pseudocode_comment = std::string(new_comment.c_str());

    //if it is a new comment we add it to ponce_comments
    if (ponce_comments.count(ea) > 0) {
        if (snapshot)
            ponce_comments[ea].snapshot_comment = pseudocode_comment;
        else
            ponce_comments[ea].comment = pseudocode_comment;
    }
    else  {
        struct instruction_info insinfo;
        if (snapshot)
            insinfo.snapshot_comment = pseudocode_comment;
        else
            insinfo.comment = pseudocode_comment;

        ponce_comments[ea] = insinfo;
    }
    return set_cmt(ea, new_comment.c_str(), rptble);
}

/*This function gets the tainted operands for an instruction and add a comment to that instruction with this info*/
void comment_controlled_operands(triton::arch::Instruction* tritonInst, ea_t pc)
{
    std::stringstream comment;
    std::stringstream regs_controlled;
    std::stringstream mems_controlled;
    std::stringstream coso;

    if ((cmdOptions.use_symbolic_engine && !tritonInst->isSymbolized()) || (cmdOptions.use_tainting_engine && !tritonInst->isTainted())) {
        return;
    }

    if (cmdOptions.use_tainting_engine)
        comment << "Tainted instruction";
    else
        comment << "Symbolic instruction";

    /*Here we check all the registers and memory read to know which are tainted*/
    auto regs = tritonInst->getReadRegisters();
    for (const auto& [reg, expr] : tritonInst->getReadRegisters()) {
        if ((cmdOptions.use_tainting_engine && api.isRegisterTainted(reg)) ||
            (cmdOptions.use_symbolic_engine && api.isRegisterSymbolized(reg))) {
            regs_controlled << std::uppercase << reg.getName() << " ";
        }
    }
    if (regs_controlled.str().size() > 0) {
        comment << "\nRegister: " << regs_controlled.str();
    }

    for (const auto& [mem, expr] : tritonInst->getLoadAccess()) {
        if ((cmdOptions.use_tainting_engine && api.isMemoryTainted(mem)) ||
            (cmdOptions.use_symbolic_engine && api.isMemorySymbolized(mem)))
            mems_controlled << "0x" << std::hex << mem.getAddress() << " ";
    }

    if (mems_controlled.str().size() > 0) {
        comment << "\nMemory: " << mems_controlled.str();
    }

    //We set the comment
    if (comment.str().size() > 0) {
        ponce_set_cmt(pc, comment.str().c_str(), false);
    }
}

```

`src/utils.hpp`:

```hpp
//! \file
/*
**  Copyright (c) 2020 - Ponce
**  Authors:
**         Alberto Garcia Illera        agarciaillera@gmail.com
**         Francisco Oca                francisco.oca.gonzalez@gmail.com
**
**  This program is under the terms of the BSD License.
*/

#pragma once
#include <string>
//Triton
#include <triton/api.hpp>
//Ponce
#include "globals.hpp"

const triton::arch::register_e str_to_register(const qstring& register_name);
ea_t find_function(char const* function_name);
ea_t get_args(int argument_number, bool skip_ret);
ea_t get_args_pointer(int argument_number, bool skip_ret);
char read_char_from_ida(ea_t address);
ea_t read_regSize_from_ida(ea_t address);
void rename_tainted_function(ea_t address);
void add_symbolic_expressions(triton::arch::Instruction* tritonInst, ea_t address);
std::string notification_code_to_string(int notification_code);
bool load_options(struct cmdOptionStruct* cmdOptions);
bool save_options(struct cmdOptionStruct* cmdOptions);
bool ask_for_execute_native();
qstring get_callee_name(ea_t address);
void concretizeAndUntaintAllRegisters();
void enableTrigger_and_concretize_registers(ea_t main_address);
void readBlacklistfile(char* path);
std::uint64_t GetTimeMs64(void);
void concretizeAndUntaintVolatileRegisters();
short read_unicode_char_from_ida(ea_t address);
ea_t current_instruction();
void delete_ponce_comments();
bool ponce_set_cmt(ea_t ea, const char* comm, bool rptble, bool snapshot = false);
void ponce_set_item_color(ea_t ea, bgcolor_t color);
void comment_controlled_operands(triton::arch::Instruction* tritonInst, ea_t pc);
```