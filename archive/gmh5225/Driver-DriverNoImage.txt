Project Path: arc_gmh5225_Driver-DriverNoImage_qiv1c2wg

Source Tree:

```txt
arc_gmh5225_Driver-DriverNoImage_qiv1c2wg
├── DriverNoImage.inf
├── DriverNoImage.vcxproj
├── DriverNoImage.vcxproj.filters
├── DriverNoImage.vcxproj.user
├── README.md
├── driver.c
├── inlineHook.c
├── inlineHook.h
├── patch.c
├── patch.h
├── patchFun.c
├── patchFun.h
├── replaceData.c
├── replaceData.h
├── shellcode.asm
└── shellcode.c

```

`DriverNoImage.inf`:

```inf
;
; DriverNoImage.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=DriverNoImage.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
DriverNoImage_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
driverBe.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%DriverNoImage.DeviceDesc%=DriverNoImage_Device, Root\DriverNoImage ; TODO: edit hw-id

[DriverNoImage_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
driverBe.sys

;-------------- Service installation
[DriverNoImage_Device.NT.Services]
AddService = DriverNoImage,%SPSVCINST_ASSOCSERVICE%, DriverNoImage_Service_Inst

; -------------- DriverNoImage driver install sections
[DriverNoImage_Service_Inst]
DisplayName    = %DriverNoImage.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\driverBe.sys

;
;--- DriverNoImage_Device Coinstaller installation ------
;

[DriverNoImage_Device.NT.CoInstallers]
AddReg=DriverNoImage_Device_CoInstaller_AddReg
CopyFiles=DriverNoImage_Device_CoInstaller_CopyFiles

[DriverNoImage_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[DriverNoImage_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[DriverNoImage_Device.NT.Wdf]
KmdfService =  DriverNoImage, DriverNoImage_wdfsect
[DriverNoImage_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "DriverNoImage Installation Disk"
DriverNoImage.DeviceDesc = "DriverNoImage Device"
DriverNoImage.SVCDESC = "DriverNoImage Service"

```

`DriverNoImage.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0E6E4F4B-C152-4B8D-A7E8-2D5BCB7DB584}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>DriverNoImage</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.15063.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IntDir>$(SolutionDir)Temp\$(ProjectName)-$(PlatformName)-vc$(PlatformToolsetVersion)\$(Configuration)\</IntDir>
    <TargetName>driverBe</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IntDir>$(SolutionDir)Temp\$(ProjectName)-$(PlatformName)-vc$(PlatformToolsetVersion)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <IntDir>$(SolutionDir)Temp\$(ProjectName)-$(PlatformName)-vc$(PlatformToolsetVersion)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)bin\sys\</OutDir>
    <TargetName>$(TargetName.Replace(' ',''))</TargetName>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <EnableInf2cat>true</EnableInf2cat>
    <IntDir>$(SolutionDir)Temp\$(ProjectName)-$(PlatformName)-vc$(PlatformToolsetVersion)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)bin\sys\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Link>
      <AdditionalDependencies>$(DDK_LIB_PATH)\BufferOverflowK.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="DriverNoImage.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.c" />
    <ClCompile Include="patch.c" />
    <ClCompile Include="inlineHook.c" />
    <ClCompile Include="patchFun.c" />
    <ClCompile Include="replaceData.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="inlineHook.h" />
    <ClInclude Include="patchFun.h" />
    <ClInclude Include="replaceData.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="shellcode.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DriverNoImage.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="DriverNoImage.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="inlineHook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="patch.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="patchFun.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="replaceData.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="inlineHook.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="patchFun.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="replaceData.h">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="shellcode.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`DriverNoImage.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DbgengKernelMachineName>VM-WIN10</DbgengKernelMachineName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DbgengKernelMachineName>VM-WIN10</DbgengKernelMachineName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DbgengKernelMachineName>VM-WIN10</DbgengKernelMachineName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DbgengKernelMachineName>VM-WIN10</DbgengKernelMachineName>
    <SignMode>Off</SignMode>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DbgengKernelMachineName>VM-WIN10</DbgengKernelMachineName>
    <RemoveDriver>True</RemoveDriver>
    <InstallMode>None</InstallMode>
    <HardwareIdString />
    <CommandLine />
    <ScriptPath>C:\Program Files (x86)\Windows Kits\10\Testing\Tests\Utilities\DefaultDriverPackageInstallationTask.dll</ScriptPath>
    <DbgengRemoteMachineName>VM-WIN10</DbgengRemoteMachineName>
    <DeployFiles />
    <ScriptName>Microsoft.DriverKit.DefaultDriverPackageInstallationClass.PerformDefaultDriverPackageInstallation</ScriptName>
    <ScriptDeviceQuery />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DbgengKernelMachineName>VM-WIN10</DbgengKernelMachineName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DbgengKernelMachineName>VM-WIN10</DbgengKernelMachineName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DbgengKernelMachineName>VM-WIN10</DbgengKernelMachineName>
  </PropertyGroup>
</Project>
```

`README.md`:

```md
# DriverNoImage
以shellcode注入其它驱动执行，躲避驱动签名检测，曾pubg项目中使用，，，当然现在，，，


shellcode asm文件通过编译后再通过IDA工具拷贝出来填入ASM文件中
有部分测试代码在里面需要做适当修改

```

`driver.c`:

```c
#include <ntdef.h>
#include <ntifs.h>
#include "patch.h"



VOID Unload(PDRIVER_OBJECT  pDriverObject)
{
	//UnHookLuDashi();
	//DbgPrint("DriverNoImage Unload.\n");
	char printStr[] = { 68,114,105,118,101,114,32,85,110,108,111,97,100,46,92,110,0 };
	DbgPrint(printStr);
	UnHookNTFS();
}



NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT  pDriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	//HideDriver(pDriverObject);
	//"Driver entry.\n"
	char printStr[] = { 68,114,105,118,101,114,32,101,110,116,114,121,46,92,110,0 };
	DbgPrint(printStr);
	NTSTATUS status = STATUS_SUCCESS;
	pDriverObject->DriverUnload = Unload;
	HookNTFS();
	return status;
/*
	HookLuDashi();
#if DEBUG_TEST
	return STATUS_SUCCESS;
#else
	return STATUS_NOT_FOUND;
#endif*/
	
}
```

`inlineHook.c`:

```c
#include "inlineHook.h"


#define kmalloc(_s) ExAllocatePoolWithTag(NonPagedPool, _s, 'SYSW')  

#define kfree(_p) ExFreePool(_p)  



KIRQL WPOFFx64()
{
	KIRQL irql = KeRaiseIrqlToDpcLevel();
	UINT64 cr0 = __readcr0();
	cr0 &= 0xfffffffffffeffff;
	__writecr0(cr0);
	_disable();
	return irql;

}

void WPONx64(KIRQL irql)
{
	UINT64 cr0 = __readcr0();
	cr0 |= 0x10000;
	_enable();
	__writecr0(cr0);
	KeLowerIrql(irql);
}

ULONG GetPatchSize(PUCHAR Address)
{
	return 15;
}

  
void HookKernelApi(IN void* ApiAddress, IN void* Proxy_ApiAddress, OUT void* *Original_ApiAddress, OUT ULONG *PatchSize)
{

	KIRQL irql;
	UINT64 tmpv;
	PVOID head_n_byte, ori_func;
	UCHAR jmp_code[] = "\xFF\x25\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";
	UCHAR jmp_code_orifunc[] = "\xFF\x25\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";

	//How many bytes shoule be patch  
	*PatchSize = GetPatchSize((PUCHAR)ApiAddress);

	//step 1: Read current data  
	head_n_byte = kmalloc(*PatchSize);

	irql = WPOFFx64();
	memcpy(head_n_byte, ApiAddress, *PatchSize);
	WPONx64(irql);

	//step 2: Create ori function  
	ori_func = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, 0);
	//ori_func = kmalloc(*PatchSize + 14);    //原始机器码+跳转机器码  
	RtlFillMemory(ori_func, *PatchSize + 14, 0x90);
	tmpv = (ULONG64)ApiAddress + *PatchSize;    //跳转到没被打补丁的那个字节  
	memcpy(jmp_code_orifunc + 6, &tmpv, 8);
	memcpy((PUCHAR)ori_func, head_n_byte, *PatchSize);
	kfree(head_n_byte);
	memcpy((PUCHAR)ori_func + *PatchSize, jmp_code_orifunc, 14);
	*Original_ApiAddress = ori_func;
	//step 3: fill jmp code  
	tmpv = (UINT64)Proxy_ApiAddress;
	memcpy(jmp_code + 6, &tmpv, 8);

	//step 4: Fill NOP and hook  
	irql = WPOFFx64();
	RtlFillMemory(ApiAddress, *PatchSize, 0x90);
	memcpy(ApiAddress, jmp_code, 14);
	WPONx64(irql);

	return;
}


void UnhookKernelApi(IN void* ApiAddress, IN void* OriCode, IN ULONG PatchSize)
{
	KIRQL irql;
	irql = WPOFFx64();
	memcpy(ApiAddress, OriCode, PatchSize);
	WPONx64(irql);
	//后续还要释放申请的内存等
	//kfree(OriCode);
	ExFreePoolWithTag(OriCode, 0);
}
```

`inlineHook.h`:

```h
#include <ntddk.h>

KIRQL WPOFFx64();
void WPONx64(KIRQL irql);


//传入：待HOOK函数地址，代理函数地址，接收原始函数地址的指针，接收补丁长度的指针；返回：原来头N字节的数据
void HookKernelApi(IN void* ApiAddress, IN void* Proxy_ApiAddress, OUT void* *Original_ApiAddress, OUT ULONG *PatchSize);

//传入：被HOOK函数地址，原始数据，补丁长度  
void UnhookKernelApi(IN void* ApiAddress, IN void* OriCode, IN ULONG PatchSize);
```

`patch.c`:

```c
#include <ntdef.h>
#include <ntifs.h>

#include "inlineHook.h"
#include "patchFun.h"
#include "replaceData.h"

extern NTSTATUS FASTCALL _myIrpDispath(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp);

NTKERNELAPI NTSTATUS ObReferenceObjectByName(
	IN PUNICODE_STRING ObjectName,
	IN ULONG Attributes,
	IN PACCESS_STATE PassedAccessState OPTIONAL,
	IN ACCESS_MASK DesiredAccess OPTIONAL,
	IN POBJECT_TYPE ObjectType,
	IN KPROCESSOR_MODE AccessMode,
	IN OUT PVOID ParseContext OPTIONAL,
	OUT PVOID *Object
);
extern POBJECT_TYPE* IoDriverObjectType;

//////////////////////////////////////////////////////////////////////////







void* g_luOldAddr = NULL;
void* g_originalAddr = NULL;
ULONG g_patchSize = NULL;
PVOID g_myIrpAddrNew;




void HookLuDashi()
{
	
	NTSTATUS result;
	UNICODE_STRING DestinationString;
	//\Driver\driverMain
	//加了最后一位随机 a-z
	wchar_t linkPath[] = { 92,68,114,105,118,101,114,92,100,117,109,112,95,100,117,109,112,108,100,115,0,0 };
	PDRIVER_OBJECT pDriver = NULL;
	for (int i = 0; i < 26; i++)
	{
		linkPath[20] = 97 + i;
		RtlInitUnicodeString(&DestinationString, linkPath/*L"\\Driver\\ComputerZ"*/);

		
		result = ObReferenceObjectByName(&DestinationString,
			OBJ_CASE_INSENSITIVE, NULL, NULL,
			*IoDriverObjectType, KernelMode, NULL, (PVOID)&pDriver);
		if (NT_SUCCESS(result))
			break;
		pDriver = NULL;
	}
	

	//"pDriver:%p result:%lx IoDeviceObjectType:%p\n"
	char printStr[] = { 112,68,114,105,118,101,114,58,37,112,32,114,101,115,117,108,116,58,37,108,120,32,73,111,68,101,118,105,99,101,79,98,106,101,99,116,84,121,112,101,58,37,112,92,110,0 };
	DbgPrint(printStr, pDriver, result, IoDriverObjectType);

	if (NT_SUCCESS(result))
	{
		KIRQL oldIrql;
		g_luOldAddr = pDriver->MajorFunction[IRP_MJ_DEVICE_CONTROL];

		KIRQL irql = WPOFFx64();
		__int32 hookFlag = *(__int32*)g_luOldAddr;
		WPONx64(irql);

		if (hookFlag != 0x25FF)
		{
			InitFunTable();
			//HOOK开始
			g_myIrpAddrNew = CopyMyFun(_myIrpDispath, NULL);
			HookKernelApi(g_luOldAddr, g_myIrpAddrNew, &g_originalAddr, &g_patchSize);
		}
		else
		{
			//"Driver had run...\n"
			char printStr[] = { 68,114,105,118,101,114,32,104,97,100,32,114,117,110,46,46,46,92,110,0 };
			DbgPrint(printStr);
		}
			
		
		ObfDereferenceObject(pDriver);
	}




/*
	PDEVICE_OBJECT DeviceObject = NULL;
	PIRP Irp = NULL;
	myIrpDispath(DeviceObject, Irp);
	DoMemBase(NULL);
	DoMemRead(NULL);
	DoMemWrite(NULL);
	DoMemAlloc(NULL);
	DoMemProtect(NULL);
	EncryptDecryptBuf(NULL, NULL, NULL);*/
	
}

void UnHookLuDashi()
{
	if (g_originalAddr)
	{
		UnhookKernelApi(g_luOldAddr, g_originalAddr, g_patchSize);
		ExFreePoolWithTag(g_myIrpAddrNew, 0);
	}
}


NTSTATUS FASTCALL myIrpDispathTest(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp)
{
	//DbgPrint("myIrpDispath ENTRY!");
	NTSTATUS NtStatus = STATUS_SUCCESS;

	PIO_STACK_LOCATION pIoStackIrp = NULL;
	pIoStackIrp = /*((IoGetCurrentIrpStackLocation_)FLAG_IoGetCurrentIrpStackLocation)*/Irp->Tail.Overlay.CurrentStackLocation;
	if (pIoStackIrp && pIoStackIrp->MajorFunction == IRP_MJ_CREATE)
	{
		ULONG loControlCodes = pIoStackIrp->Parameters.DeviceIoControl.IoControlCode;//I/O控制代码
		DbgPrint("myIrpDispath ENTRY!");
		if (loControlCodes == -1)
		{
			Irp->IoStatus.Information = 0;
			Irp->IoStatus.Status = STATUS_SUCCESS;
			MyStruct* myData = (MyStruct*)FLAG_MYSTRUCT;
			IofCompleteRequest(Irp, IO_NO_INCREMENT);
			return NtStatus;
		}
	}

/*
	((IofCompleteRequest_)FLAG_IofCompleteRequest)(Irp, IO_NO_INCREMENT);
	return NtStatus;*/
	
	PDRIVER_DISPATCH oldEnter = (ULONG64)g_luOldAddr + 0xF;
	NTSTATUS status  =  oldEnter(DeviceObject, Irp);
	return status;
}

void HookNTFS()
{
	NTSTATUS result;
	UNICODE_STRING DestinationString;

	PDRIVER_OBJECT pDriver = NULL;

	RtlInitUnicodeString(&DestinationString, L"\\FileSystem\\Ntfs");


	result = ObReferenceObjectByName(&DestinationString,
		OBJ_CASE_INSENSITIVE, NULL, NULL,
		*IoDriverObjectType, KernelMode, NULL, (PVOID)&pDriver);


	DbgPrint("pDriver:%p result:%lx IoDeviceObjectType:%p\n", pDriver, result, IoDriverObjectType);

	if (NT_SUCCESS(result))
	{
		KIRQL oldIrql;
		g_luOldAddr = pDriver->MajorFunction[IRP_MJ_CREATE];

		KIRQL irql = WPOFFx64();
		__int32 hookFlag = *(__int32*)g_luOldAddr;
		WPONx64(irql);

		if (hookFlag != 0x25FF)
		{
			//HOOK开始
			HookKernelApi(g_luOldAddr, myIrpDispathTest, &g_originalAddr, &g_patchSize);
		}
		else
		{
			//"Driver had run...\n"
			char printStr[] = { 68,114,105,118,101,114,32,104,97,100,32,114,117,110,46,46,46,92,110,0 };
			DbgPrint(printStr);
		}


		ObfDereferenceObject(pDriver);
	}

}

void UnHookNTFS()
{
	if (g_originalAddr)
	{
		UnhookKernelApi(g_luOldAddr, g_originalAddr, g_patchSize);
	}
}
```

`patch.h`:

```h
void HookLuDashi();
void UnHookLuDashi();

void HookNTFS();
void UnHookNTFS();
```

`patchFun.c`:

```c
#include "patchFun.h"
#include "replaceData.h"


#define DIRECTORY_TABLE_BASE    0x028 


extern void* g_luOldAddr;

//////////////////////////////////////////////////////////////////////////


#define DEVICE_MY_INDEX 0x860
#define IRQ_CODE_MEM_BASE CTL_CODE(FILE_DEVICE_UNKNOWN,DEVICE_MY_INDEX,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IRQ_CODE_MEM_READ CTL_CODE(FILE_DEVICE_UNKNOWN,DEVICE_MY_INDEX + 1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IRQ_CODE_MEM_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,DEVICE_MY_INDEX + 2,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IRQ_CODE_MEM_ALLOC CTL_CODE(FILE_DEVICE_UNKNOWN,DEVICE_MY_INDEX + 3,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IRQ_CODE_MEM_PROTECT CTL_CODE(FILE_DEVICE_UNKNOWN,DEVICE_MY_INDEX + 4,METHOD_BUFFERED,FILE_ANY_ACCESS)



BOOLEAN KernelMemCopy(PVOID dst, PVOID src, SIZE_T lenth, SIZE_T memsetlen)
{
	BOOLEAN Ret = FALSE;

	//////////////////////////////////////////////////////////////////////////
	KIRQL irql;
	KIRQL curreirql;

	if (dst)
	{
		curreirql = KeGetCurrentIrql();
		if (curreirql < DISPATCH_LEVEL)
		{
			irql = KeRaiseIrqlToDpcLevel();
		}
		UINT64 cr0 = __readcr0();
		cr0 &= 0xfffffffffffeffff;
		__writecr0(cr0);
		_disable();
		memset(dst, 0x90, memsetlen);
		memcpy(dst, src, lenth);
		cr0 = __readcr0();
		cr0 |= 0x10000;
		_enable();
		__writecr0(cr0);
		if (curreirql < DISPATCH_LEVEL)
		{
			KeLowerIrql(irql);
		}
		Ret = TRUE;
	}
	return Ret;
}


NTSTATUS DoMemBase(pMemStruct objData)
{
	PEPROCESS targetProcess;
	PVOID value = 0;
	NTSTATUS ntStatus = ((PsLookupProcessByProcessId_)FLAG_PsLookupProcessByProcessId)((HANDLE)objData->m_pid, &targetProcess);

	if (ntStatus != STATUS_SUCCESS || !targetProcess)
		return STATUS_FATAL_APP_EXIT;
	__try
	{
		((KeAttachProcess_)FLAG_KeAttachProcess)((PKPROCESS)targetProcess);
		value = ((PsGetProcessSectionBaseAddress_)FLAG_PsGetProcessSectionBaseAddress)(targetProcess);
		((KeDetachProcess_)FLAG_KeDetachProcess)();
		((ObfDereferenceObject_)FLAG_ObfDereferenceObject)(targetProcess);

		memcpy(objData->m_buffer, &value, sizeof(__int64));
	}
	__except (GetExceptionCode())
	{
		((ObfDereferenceObject_)FLAG_ObfDereferenceObject)(targetProcess);
		return STATUS_FATAL_APP_EXIT;
	}
	return STATUS_SUCCESS;
}

NTSTATUS DoMemRead(pMemStruct objData)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	
	IN PVOID BaseAddress = objData->m_addr;
	IN UINT32 BufferSize = objData->m_size;
	OUT PVOID Buffer = objData->m_buffer;

	PEPROCESS TargetProcess;
	PEPROCESS CurrentProcess;
	{
		if (((PCHAR)BaseAddress + BufferSize < (PCHAR)BaseAddress) ||
			((PCHAR)Buffer + BufferSize < (PCHAR)Buffer) ||
			((PVOID)((PCHAR)BaseAddress + BufferSize) > FLAG_MM_HIGHEST_USER_ADDRESS) ||
			((PVOID)((PCHAR)Buffer + BufferSize) > FLAG_MM_HIGHEST_USER_ADDRESS))
		{
			return STATUS_FATAL_APP_EXIT;
		}
		else
		{
			ntStatus = ((PsLookupProcessByProcessId_)FLAG_PsLookupProcessByProcessId)((HANDLE)objData->m_pid, &TargetProcess);
			if (NT_SUCCESS(ntStatus))
			{
				ntStatus = ((PsLookupProcessByProcessId_)FLAG_PsLookupProcessByProcessId)((HANDLE)objData->m_userPid, &CurrentProcess);
				if (NT_SUCCESS(ntStatus))
				{
					ULONG transferred;
					((MmCopyVirtualMemory_)FLAG_MmCopyVirtualMemory)(TargetProcess, BaseAddress, CurrentProcess, Buffer, BufferSize, KernelMode, &transferred);
					((ObfDereferenceObject_)FLAG_ObfDereferenceObject)(TargetProcess);
					((ObfDereferenceObject_)FLAG_ObfDereferenceObject)(CurrentProcess);
				}
				else
					((ObfDereferenceObject_)FLAG_ObfDereferenceObject)(TargetProcess);
			}
		}
	}
	return STATUS_SUCCESS;
}

NTSTATUS DoMemWrite(pMemStruct objData)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;


	IN PVOID BaseAddress = objData->m_addr;
	IN UINT32 BufferSize = objData->m_size;
	OUT PVOID Buffer = objData->m_buffer;

	PEPROCESS TargetProcess;
	PEPROCESS CurrentProcess;
	{
		if (((PCHAR)BaseAddress + BufferSize < (PCHAR)BaseAddress) ||
			((PCHAR)Buffer + BufferSize < (PCHAR)Buffer) ||
			((PVOID)((PCHAR)BaseAddress + BufferSize) > FLAG_MM_HIGHEST_USER_ADDRESS) ||
			((PVOID)((PCHAR)Buffer + BufferSize) > FLAG_MM_HIGHEST_USER_ADDRESS))
		{
			return STATUS_FATAL_APP_EXIT;
		}
		else
		{
			ntStatus = ((PsLookupProcessByProcessId_)FLAG_PsLookupProcessByProcessId)((HANDLE)objData->m_pid, &TargetProcess);
			if (NT_SUCCESS(ntStatus))
			{
				ntStatus = ((PsLookupProcessByProcessId_)FLAG_PsLookupProcessByProcessId)((HANDLE)objData->m_userPid, &CurrentProcess);
				if (NT_SUCCESS(ntStatus))
				{
					ULONG transferred;
					((MmCopyVirtualMemory_)FLAG_MmCopyVirtualMemory)(CurrentProcess, Buffer, TargetProcess, BaseAddress, BufferSize, KernelMode, &transferred);
					((ObfDereferenceObject_)FLAG_ObfDereferenceObject)(TargetProcess);
					((ObfDereferenceObject_)FLAG_ObfDereferenceObject)(CurrentProcess);
				}
				else
					((ObfDereferenceObject_)FLAG_ObfDereferenceObject)(TargetProcess);
			}
		}
	}
	return STATUS_SUCCESS;
}

NTSTATUS DoMemAlloc(pMemStruct objData)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	PEPROCESS TargetProcess;
	ntStatus = ((PsLookupProcessByProcessId_)FLAG_PsLookupProcessByProcessId)((HANDLE)objData->m_pid, &TargetProcess);
	ULONG nSize = objData->m_size;
	if (NT_SUCCESS(ntStatus))
	{
		//PVOID DriverBuffer = ExAllocatePoolWithTag(NonPagedPool, objData->m_size, 'Sys');

		//在目标进程申请内存
		((KeAttachProcess_)FLAG_KeAttachProcess)(TargetProcess);
		void* newAddr = NULL;
		if (!NT_SUCCESS(((ZwAllocateVirtualMemory_)FLAG_ZwAllocateVirtualMemory)(-1, (PVOID*)&newAddr, 0, &nSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)))
			ntStatus = STATUS_FATAL_APP_EXIT;
		else
			ntStatus = STATUS_SUCCESS;
		//*(ULONG64*)DriverBuffer = (ULONG64)newAddr;
		((KeDetachProcess_)FLAG_KeDetachProcess)();
		
		((ObfDereferenceObject_)FLAG_ObfDereferenceObject)(TargetProcess);

		memcpy(objData->m_buffer, &newAddr, sizeof(__int64));
/*
		if (NT_SUCCESS(ntStatus))
		{
			ntStatus = PsLookupProcessByProcessId((HANDLE)objData->m_userPid, &TargetProcess);
			KeStackAttachProcess(TargetProcess, &apc_state);
			memcpy(objData->m_buffer, &newAddr, sizeof(ULONG64));
			KeUnstackDetachProcess(&apc_state);
			ObfDereferenceObject(TargetProcess);
		}*/
		//ExFreePool(DriverBuffer);
	}
	return STATUS_SUCCESS;
}

NTSTATUS DoMemProtect(pMemStruct objData)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	IN UINT32 BufferSize = objData->m_size;
	OUT PVOID Buffer = objData->m_buffer;

	PEPROCESS TargetProcess;
	ntStatus = ((PsLookupProcessByProcessId_)FLAG_PsLookupProcessByProcessId)((HANDLE)objData->m_pid, &TargetProcess);
	if (NT_SUCCESS(ntStatus))
	{
		((KeAttachProcess_)FLAG_KeAttachProcess)(TargetProcess);
		//在目标进程申请内存
		ULONG64 newAddr = 0;
		if (!NT_SUCCESS(((ZwProtectVirtualMemory_)FLAG_ZwProtectVirtualMemory)(-1, (PVOID*)&newAddr, 0, &objData->m_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)))
			ntStatus = STATUS_FATAL_APP_EXIT;
		else
			ntStatus = STATUS_SUCCESS;
		objData->m_buffer = newAddr;
		((KeDetachProcess_)FLAG_KeDetachProcess)();
		((ObfDereferenceObject_)FLAG_ObfDereferenceObject)(TargetProcess);
	}
	return STATUS_SUCCESS;
}



NTSTATUS FASTCALL myIrpDispath(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp)
{
	//DbgPrint("myIrpDispath ENTRY!");
	NTSTATUS NtStatus = STATUS_SUCCESS;

	PIO_STACK_LOCATION pIoStackIrp = NULL;
	pIoStackIrp = /*((IoGetCurrentIrpStackLocation_)FLAG_IoGetCurrentIrpStackLocation)*/Irp->Tail.Overlay.CurrentStackLocation;
	if (pIoStackIrp && pIoStackIrp->MajorFunction == IRP_MJ_DEVICE_CONTROL)
	{
		ULONG loControlCodes = pIoStackIrp->Parameters.DeviceIoControl.IoControlCode;//I/O控制代码
		if (loControlCodes >= IRQ_CODE_MEM_BASE)
		{
			Irp->IoStatus.Information = 0;
			Irp->IoStatus.Status = STATUS_SUCCESS;
			MyStruct* myData = (MyStruct*)FLAG_MYSTRUCT;
			switch (loControlCodes)
			{
			case IRQ_CODE_MEM_BASE:
			{
				ULONG64 FunAddr = myData->_DoMemBaseAddr;
				ULONG FunSize = myData->_DoMemBaseSize;
				INT FunKey = myData->_DoMemBaseKey;
				((EncryptDecryptBuf_)FLAG_EncryptDecryptBuf)(FunAddr, FunSize, FunKey);
#if DEBUG_TEST
				NtStatus = DoMemBase((pMemStruct)Irp->AssociatedIrp.SystemBuffer);
#else
				NtStatus = ((DoMemFun_)FunAddr)((pMemStruct)Irp->AssociatedIrp.SystemBuffer);
#endif
				myData->_DoMemBaseKey = (FunKey + 1) % 90 + 1;
				((EncryptDecryptBuf_)FLAG_EncryptDecryptBuf)(FunAddr, FunSize, myData->_DoMemBaseKey);
			}
			break;
			case IRQ_CODE_MEM_READ:
			{
				ULONG64 FunAddr = myData->_DoMemReadAddr;
				ULONG FunSize = myData->_DoMemReadSize;
				INT FunKey = myData->_DoMemReadKey;
				((EncryptDecryptBuf_)FLAG_EncryptDecryptBuf)(FunAddr, FunSize, FunKey);
#if DEBUG_TEST
				NtStatus = DoMemRead((pMemStruct)Irp->AssociatedIrp.SystemBuffer);
#else
				NtStatus = ((DoMemFun_)FunAddr)((pMemStruct)Irp->AssociatedIrp.SystemBuffer);
#endif
				myData->_DoMemReadKey = (FunKey + 1) % 91 + 3;
				((EncryptDecryptBuf_)FLAG_EncryptDecryptBuf)(FunAddr, FunSize, myData->_DoMemReadKey);
			}
			break;
			case IRQ_CODE_MEM_WRITE:
			{
				ULONG64 FunAddr = myData->_DoMemWriteAddr;
				ULONG FunSize = myData->_DoMemWriteSize;
				INT FunKey = myData->_DoMemWriteKey;
				((EncryptDecryptBuf_)FLAG_EncryptDecryptBuf)(FunAddr, FunSize, FunKey);
#if DEBUG_TEST
				NtStatus = DoMemWrite((pMemStruct)Irp->AssociatedIrp.SystemBuffer);
#else
				NtStatus = ((DoMemFun_)FunAddr)((pMemStruct)Irp->AssociatedIrp.SystemBuffer);
#endif
				myData->_DoMemWriteKey = (FunKey + 1) % 92 + 5;
				((EncryptDecryptBuf_)FLAG_EncryptDecryptBuf)(FunAddr, FunSize, myData->_DoMemWriteKey);
			}
			break;
			case IRQ_CODE_MEM_ALLOC:
			{
				ULONG64 FunAddr = myData->_DoMemAllocAddr;
				ULONG FunSize = myData->_DoMemAllocSize;
				INT FunKey = myData->_DoMemAllocKey;
				((EncryptDecryptBuf_)FLAG_EncryptDecryptBuf)(FunAddr, FunSize, FunKey);
#if DEBUG_TEST
				NtStatus = DoMemAlloc((pMemStruct)Irp->AssociatedIrp.SystemBuffer);
#else
				NtStatus = ((DoMemFun_)FunAddr)((pMemStruct)Irp->AssociatedIrp.SystemBuffer);
#endif
				myData->_DoMemAllocKey = (FunKey + 1) % 93 + 7;
				((EncryptDecryptBuf_)FLAG_EncryptDecryptBuf)(FunAddr, FunSize, myData->_DoMemAllocKey);
			}
			break;
			case IRQ_CODE_MEM_PROTECT:
			{
				ULONG64 FunAddr = myData->_DoMemProtectAddr;
				ULONG FunSize = myData->_DoMemProtectSize;
				INT FunKey = myData->_DoMemProtectKey;
				((EncryptDecryptBuf_)FLAG_EncryptDecryptBuf)(FunAddr, FunSize, FunKey);
#if DEBUG_TEST
				NtStatus = DoMemProtect((pMemStruct)Irp->AssociatedIrp.SystemBuffer);
#else
				NtStatus = ((DoMemFun_)FunAddr)((pMemStruct)Irp->AssociatedIrp.SystemBuffer);
#endif
				myData->_DoMemProtectKey = (FunKey + 1) % 94 + 9;
				((EncryptDecryptBuf_)FLAG_EncryptDecryptBuf)(FunAddr, FunSize, myData->_DoMemProtectKey);
			}
			break;
			}
			((IofCompleteRequest_)FLAG_IofCompleteRequest)(Irp, IO_NO_INCREMENT);
			return NtStatus;
		}
	}
	
	((IofCompleteRequest_)FLAG_IofCompleteRequest)(Irp, IO_NO_INCREMENT);
	return NtStatus;
/*
	PDRIVER_DISPATCH oldEnter = (ULONG64)g_luOldAddr + 0xF;
	NTSTATUS status  =  oldEnter(DeviceObject, Irp);
	return status;*/
}



```

`patchFun.h`:

```h
#ifndef PATCH_FUN_H_
#define PATCH_FUN_H_

#include <ntdef.h>
#include <ntifs.h>

#define CACHE_LINE  8  
#define CACHE_ALIGN __declspec(align(CACHE_LINE))  

typedef struct CACHE_ALIGN memStruct
{
	__int64    m_userPid;
	__int64    m_pid;
	__int64    m_addr;
	__int64    m_buffer;
	__int64    m_size;
} MemStruct, *pMemStruct;

typedef void (*EncryptDecryptBuf_)(char* buf, int size, char key);
typedef NTSTATUS(*DoMemFun_)(pMemStruct objData);
typedef PIO_STACK_LOCATION(*IoGetCurrentIrpStackLocation_)(_In_ PIRP Irp);
typedef VOID(FASTCALL *IofCompleteRequest_)(_In_ PIRP Irp, _In_ CCHAR PriorityBoost);
typedef NTSTATUS(*PsLookupProcessByProcessId_)(_In_ HANDLE ProcessId, _Outptr_ PEPROCESS *Process);
typedef VOID(*KeAttachProcess_)(_Inout_ PRKPROCESS Process);


typedef PVOID(*PsGetProcessSectionBaseAddress_)(__in PEPROCESS Process);
typedef VOID(*KeDetachProcess_)(VOID);
typedef LONG_PTR(*FASTCALL ObfDereferenceObject_)(_In_ PVOID Object);
typedef NTSTATUS(*MmCopyVirtualMemory_)(IN PEPROCESS FromProcess,IN CONST VOID *FromAddress,IN PEPROCESS ToProcess,OUT PVOID ToAddress,IN SIZE_T BufferSize,IN KPROCESSOR_MODE PreviousMode,OUT PSIZE_T NumberOfBytesCopied);
typedef NTSTATUS(*ZwAllocateVirtualMemory_)(_In_ HANDLE ProcessHandle,_Inout_ PVOID *BaseAddress,_In_ ULONG_PTR ZeroBits,_Inout_ PSIZE_T RegionSize,_In_ ULONG AllocationType,_In_ ULONG Protect);
typedef NTSTATUS(__stdcall *ZwProtectVirtualMemory_)(HANDLE ProcessHandle, PVOID *BaseAddress, PULONG ProtectSize, ULONG NewProtect, PULONG OldProtect);

typedef VOID(*KeStackAttachProcess_)(_Inout_ PRKPROCESS PROCESS, _Out_ PRKAPC_STATE ApcState);
typedef VOID(*KeUnstackDetachProcess_)(_In_ PRKAPC_STATE ApcState);

BOOLEAN KernelMemCopy(PVOID dst, PVOID src, SIZE_T lenth, SIZE_T memsetlen);
ULONG64 CalcWdkoptimizationCodeSize(UCHAR *adr);
NTSTATUS DoMemBase(pMemStruct objData);
NTSTATUS DoMemRead(pMemStruct objData);
NTSTATUS DoMemWrite(pMemStruct objData);
NTSTATUS DoMemAlloc(pMemStruct objData);
NTSTATUS DoMemProtect(pMemStruct objData);

NTSTATUS FASTCALL myIrpDispath(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp);

#endif
```

`replaceData.c`:

```c
#include "replaceData.h"
#include <ntdef.h>
#include <ntifs.h>

#include "inlineHook.h"


NTSTATUS _DoMemBase(pMemStruct objData);
NTSTATUS _DoMemRead(pMemStruct objData);
NTSTATUS _DoMemWrite(pMemStruct objData);
NTSTATUS _DoMemAlloc(pMemStruct objData);
NTSTATUS _DoMemProtect(pMemStruct objData);
void _EncryptDecryptBuf(char* buf, int size, int key);
typedef struct _Fun_Index
{
	PVOID funTableFlag;
	PVOID funAddr;
}Fun_Index, *pFun_Index;


typedef struct _Fun_Table
{
	int count;
	Fun_Index funIndex[100];
}Fun_Table,*pFun_Table;


Fun_Table g_funTable;

MyStruct* g_myStruct = NULL;
ZwProtectVirtualMemory_ g_ZwProtectVirtualMemory = NULL;
ULONG64 CalcWdkoptimizationCodeSize(UCHAR *adr) {
	UCHAR *orgi = adr;
	// C3 CC CC CC CC
	//ffff880`0307c3db c3              ret
	//	fffff880`0307c3dc cc              int     3
	//	fffff880`0307c3dd cc              int     3
	//fffff880`0307c3de cc              int     3
	//fffff880`0307c3df cc              int     3

/*
	while (adr[0] != 0XC3 && adr[1] != 0xCC && adr[2] != 0xCC && adr[3] != 0xCC && adr[4] != 0xCC)
	{
		adr++;
	}*/

	while (adr < orgi + 0x1000)
	{
		if (adr[0] == 0XC3 && adr[1] == 0xCC && adr[2] == 0xCC && adr[3] == 0xCC && adr[4] == 0xCC)
		{
			UCHAR a = adr[0];
			UCHAR b = adr[1];
			UCHAR c = adr[2];
			UCHAR d = adr[3];
			break;
		}
			
		adr++;
	}



	return ((adr - orgi) + 4 + 4);
}

PVOID CopyMyFun(ULONG64 funAddr, OUT ULONG* size)
{
	PVOID myIrpAddrNew = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, 0);
	RtlFillMemory(myIrpAddrNew, PAGE_SIZE, 0);
	KIRQL irql = WPOFFx64();
	ULONG64 funSize = CalcWdkoptimizationCodeSize((UCHAR*)funAddr);

	WPONx64(irql);
	if(size > NULL)
		*size = funSize;
	memcpy((PVOID)myIrpAddrNew, (PVOID)funAddr, funSize);
	int iiii = memcmp((PVOID)myIrpAddrNew, (PVOID)funAddr, funSize);
	ReplaceFun(myIrpAddrNew);
	return myIrpAddrNew;
}

void EncryptDecryptBuf(char* buf, int size, char key)
{
	for (int i = 0; i < size; i++)
	{
		buf[i] = buf[i] ^ key;
	}
}

void dealMyFun(ULONG64 srcFunAddr, INT key, OUT ULONG64* addr, OUT ULONG* size)
{
	*addr = CopyMyFun(srcFunAddr, size);
	//*(int*)(*addr + *size) = key;
	EncryptDecryptBuf((char*)*addr, *size, key);
}

void InitFunTable()
{
	UNICODE_STRING DestinationString;

	g_funTable.count = 0;

	//////////////////////////////////////////////////////////////////////////

	//狼由API
	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1? FLAG_IoGetCurrentIrpStackLocation : FLAG_IoGetCurrentIrpStackLocation_;
	g_funTable.funIndex[g_funTable.count].funAddr = IoGetCurrentIrpStackLocation;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_IofCompleteRequest : FLAG_IofCompleteRequest_;
	g_funTable.funIndex[g_funTable.count].funAddr = IofCompleteRequest;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_PsLookupProcessByProcessId : FLAG_PsLookupProcessByProcessId_;
	g_funTable.funIndex[g_funTable.count].funAddr = PsLookupProcessByProcessId;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_KeAttachProcess : FLAG_KeAttachProcess_;
	g_funTable.funIndex[g_funTable.count].funAddr = KeAttachProcess;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_PsGetProcessSectionBaseAddress : FLAG_PsGetProcessSectionBaseAddress_;
	g_funTable.funIndex[g_funTable.count].funAddr = PsGetProcessSectionBaseAddress;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_KeDetachProcess : FLAG_KeDetachProcess_;
	g_funTable.funIndex[g_funTable.count].funAddr = KeDetachProcess;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_ObfDereferenceObject : FLAG_ObfDereferenceObject_;
	g_funTable.funIndex[g_funTable.count].funAddr = ObfDereferenceObject;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_MmCopyVirtualMemory : FLAG_MmCopyVirtualMemory_;
	g_funTable.funIndex[g_funTable.count].funAddr = MmCopyVirtualMemory;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_ZwAllocateVirtualMemory : FLAG_ZwAllocateVirtualMemory_;
	g_funTable.funIndex[g_funTable.count].funAddr = ZwAllocateVirtualMemory;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_ZwProtectVirtualMemory : FLAG_ZwProtectVirtualMemory_;
	RtlInitUnicodeString(&DestinationString, L"ZwProtectVirtualMemory");
	g_funTable.funIndex[g_funTable.count].funAddr = (ZwProtectVirtualMemory_)MmGetSystemRoutineAddress(&DestinationString);
	g_ZwProtectVirtualMemory = g_funTable.funIndex[g_funTable.count].funAddr;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_KeStackAttachProcess : FLAG_KeStackAttachProcess_;
	g_funTable.funIndex[g_funTable.count].funAddr = KeStackAttachProcess;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_KeUnstackDetachProcess : FLAG_KeUnstackDetachProcess_;
	g_funTable.funIndex[g_funTable.count].funAddr = KeUnstackDetachProcess;
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_MM_HIGHEST_USER_ADDRESS : FLAG_MM_HIGHEST_USER_ADDRESS_;
	g_funTable.funIndex[g_funTable.count].funAddr = &MM_HIGHEST_USER_ADDRESS;
	g_funTable.count++;

	//孔嬬痕方

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_EncryptDecryptBuf : FLAG_EncryptDecryptBuf_;
	g_funTable.funIndex[g_funTable.count].funAddr = CopyMyFun(_EncryptDecryptBuf, NULL);
	g_funTable.count++;

	//坪何痕方

	g_funTable.funIndex[g_funTable.count].funTableFlag = DEBUG_TEST < 1 ? FLAG_MYSTRUCT : FLAG_MYSTRUCT_;
	g_funTable.funIndex[g_funTable.count].funAddr = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, 0);
	g_funTable.count++;
	
	g_funTable.funIndex[g_funTable.count].funTableFlag = 0x68888000c9e8f0cc;
	g_funTable.funIndex[g_funTable.count].funAddr = g_funTable.funIndex[g_funTable.count - 1].funAddr;
	g_funTable.count++;

	//蝕兵野割方象
	g_myStruct = (MyStruct*)(g_funTable.funIndex[g_funTable.count-1].funAddr);

	g_myStruct->_DoMemBaseKey = 1;
	dealMyFun(_DoMemBase, g_myStruct->_DoMemBaseKey, &g_myStruct->_DoMemBaseAddr, &g_myStruct->_DoMemBaseSize);
	g_myStruct->_DoMemReadKey = 1;
	dealMyFun(_DoMemRead, g_myStruct->_DoMemReadKey, &g_myStruct->_DoMemReadAddr, &g_myStruct->_DoMemReadSize);
	g_myStruct->_DoMemWriteKey = 1;
	dealMyFun(_DoMemWrite, g_myStruct->_DoMemWriteKey, &g_myStruct->_DoMemWriteAddr, &g_myStruct->_DoMemWriteSize);
	g_myStruct->_DoMemAllocKey = 1;
	dealMyFun(_DoMemAlloc, g_myStruct->_DoMemAllocKey, &g_myStruct->_DoMemAllocAddr, &g_myStruct->_DoMemAllocSize);
	g_myStruct->_DoMemProtectKey = 1;
	dealMyFun(_DoMemProtect, g_myStruct->_DoMemProtectKey, &g_myStruct->_DoMemProtectAddr, &g_myStruct->_DoMemProtectSize);
	//////////////////////////////////////////////////////////////////////////

/*
	ULONG  size = 0;
	g_funTable.funIndex[g_funTable.count].funTableFlag = FLAG_DoMemBase;
	g_funTable.funIndex[g_funTable.count].funAddr = CopyMyFun((ULONG64)_DoMemBase, &size);
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = FLAG_DoMemRead;
	g_funTable.funIndex[g_funTable.count].funAddr = CopyMyFun((ULONG64)_DoMemRead, &size);
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = FLAG_DoMemWrite;
	g_funTable.funIndex[g_funTable.count].funAddr = CopyMyFun(_DoMemWrite, &size);
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = FLAG_DoMemAlloc;
	g_funTable.funIndex[g_funTable.count].funAddr = CopyMyFun((ULONG64)_DoMemAlloc, &size);
	g_funTable.count++;

	g_funTable.funIndex[g_funTable.count].funTableFlag = FLAG_DoMemProtect;
	g_funTable.funIndex[g_funTable.count].funAddr = CopyMyFun((ULONG64)_DoMemProtect, &size);
	g_funTable.count++;*/

}


BOOLEAN ReplaceFun(UCHAR *Original)
{
	UCHAR* indexStart = Original;
	for (int i = 0; i < 0x1000 - 8; i++)
	{
		if (*(int*)(indexStart) == 0xCCCC)
			break;
		else
		{
			ULONG64 CL = *(ULONG64*)indexStart;
			//DbgPrint("CL:%llx\n", CL);
			for (int j = 0; j < g_funTable.count; j++)
			{
				ULONG64 UL = g_funTable.funIndex[j].funTableFlag;
				
				
				if (g_funTable.funIndex[j].funTableFlag == *(ULONG64*)indexStart)
				//if(indexStart[0] == UL[0] && indexStart[1] == UL[1] && indexStart[2] == UL[2] && indexStart[3] == UL[3] && indexStart[4] == UL[4])
				{
					*(ULONG64*)indexStart = g_funTable.funIndex[j].funAddr;
					break;
				}
			}
		}
		indexStart = indexStart + 1;
	}

	return TRUE;
}
```

`replaceData.h`:

```h
#include <ntdef.h>
#include <ntifs.h>
#include "patchFun.h"


//系统函数申明
NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(__in PEPROCESS Process);
NTKERNELAPI NTSTATUS MmCopyVirtualMemory(
	IN PEPROCESS FromProcess,
	IN CONST VOID *FromAddress,
	IN PEPROCESS ToProcess,
	OUT PVOID ToAddress,
	IN SIZE_T BufferSize,
	IN KPROCESSOR_MODE PreviousMode,
	OUT PSIZE_T NumberOfBytesCopied
);

//////////////////////////////////////////////////////////////////////////
typedef struct _MyStruct
{
	__int32 _DoMemBaseKey;
	__int64 _DoMemBaseAddr;
	__int32   _DoMemBaseSize;

	__int32     _DoMemReadKey;
	__int64 _DoMemReadAddr;
	__int32   _DoMemReadSize;

	__int32     _DoMemWriteKey;
	__int64 _DoMemWriteAddr;
	__int32   _DoMemWriteSize;

	__int32     _DoMemAllocKey;
	__int64 _DoMemAllocAddr;
	__int32   _DoMemAllocSize;

	__int32     _DoMemProtectKey;
	__int64 _DoMemProtectAddr;
	__int32   _DoMemProtectSize;

}MyStruct, *pMyStruct;

extern MyStruct* g_myStruct;
extern ZwProtectVirtualMemory_ g_ZwProtectVirtualMemory;


#define DEBUG_TEST 0

#if DEBUG_TEST

//辅助功能函数
#define FLAG_EncryptDecryptBuf                   EncryptDecryptBuf

//自定义函数和结构
#define FLAG_MYSTRUCT                            g_myStruct
#define FLAG_DoMemBase                           DoMemBase
#define FLAG_DoMemRead                           DoMemRead
#define FLAG_DoMemWrite                          DoMemWrite
#define FLAG_DoMemAlloc                          DoMemAlloc
#define FLAG_DoMemProtect                        DoMemProtect


//系统API
#define FLAG_IoGetCurrentIrpStackLocation        IoGetCurrentIrpStackLocation    //抛弃不使用，inline函数不可翻译使用
#define FLAG_IofCompleteRequest                  IofCompleteRequest
#define FLAG_PsLookupProcessByProcessId          PsLookupProcessByProcessId
#define FLAG_KeAttachProcess                     KeAttachProcess
#define FLAG_PsGetProcessSectionBaseAddress      PsGetProcessSectionBaseAddress
#define FLAG_KeDetachProcess                     KeDetachProcess
#define FLAG_ObfDereferenceObject                ObfDereferenceObject
#define FLAG_MmCopyVirtualMemory                 MmCopyVirtualMemory
#define FLAG_ZwAllocateVirtualMemory             ZwAllocateVirtualMemory
#define FLAG_ZwProtectVirtualMemory              g_ZwProtectVirtualMemory
#define FLAG_KeStackAttachProcess                KeStackAttachProcess
#define FLAG_KeUnstackDetachProcess              KeUnstackDetachProcess
#define FLAG_MM_HIGHEST_USER_ADDRESS             MM_HIGHEST_USER_ADDRESS

#else

//辅助功能函数
#define FLAG_EncryptDecryptBuf                   0x68888000c9e8f000

//自定义函数和结构
#define FLAG_MYSTRUCT                            0x88888000c9e8f000
#define FLAG_DoMemBase                           0x88888010c9e8f000
#define FLAG_DoMemRead                           0x88888020c9e8f000
#define FLAG_DoMemWrite                          0x88888030c9e8f000
#define FLAG_DoMemAlloc                          0x88888040c9e8f000
#define FLAG_DoMemProtect                        0x88888050c9e8f000


//系统API
#define FLAG_IoGetCurrentIrpStackLocation        0x78888010c9e8f000    //抛弃不使用，inline函数不可翻译使用
#define FLAG_IofCompleteRequest                  0x78888020c9e8f000
#define FLAG_PsLookupProcessByProcessId          0x78888030c9e8f000
#define FLAG_KeAttachProcess                     0x78888040c9e8f000
#define FLAG_PsGetProcessSectionBaseAddress      0x78888050c9e8f000
#define FLAG_KeDetachProcess                     0x78888060c9e8f000
#define FLAG_ObfDereferenceObject                0x78888070c9e8f000
#define FLAG_MmCopyVirtualMemory                 0x78888080c9e8f000
#define FLAG_ZwAllocateVirtualMemory             0x78888090c9e8f000
#define FLAG_ZwProtectVirtualMemory              0x788880a0c9e8f000
#define FLAG_KeStackAttachProcess                0x788880b0c9e8f000
#define FLAG_KeUnstackDetachProcess              0x788880c0c9e8f000
#define FLAG_MM_HIGHEST_USER_ADDRESS             0x788880d0c9e8f000

#endif


//////////////////////////////////////////////////////////////////////////
//调试使用符号，需要同步更新同上，只是名字不同，标志相同
//辅助功能函数
#define FLAG_EncryptDecryptBuf_                   0x68888000c9e8f000

//自定义函数和结构
#define FLAG_MYSTRUCT_                             0x88888000c9e8f000
#define FLAG_DoMemBase_                            0x88888010c9e8f000
#define FLAG_DoMemRead_                            0x88888020c9e8f000
#define FLAG_DoMemWrite_                           0x88888030c9e8f000
#define FLAG_DoMemAlloc_                           0x88888040c9e8f000
#define FLAG_DoMemProtect_                         0x88888050c9e8f000


//系统API
#define FLAG_IoGetCurrentIrpStackLocation_         0x78888010c9e8f000    //抛弃不使用，inline函数不可翻译使用
#define FLAG_IofCompleteRequest_                   0x78888020c9e8f000
#define FLAG_PsLookupProcessByProcessId_           0x78888030c9e8f000
#define FLAG_KeAttachProcess_                      0x78888040c9e8f000
#define FLAG_PsGetProcessSectionBaseAddress_       0x78888050c9e8f000
#define FLAG_KeDetachProcess_                      0x78888060c9e8f000
#define FLAG_ObfDereferenceObject_                 0x78888070c9e8f000
#define FLAG_MmCopyVirtualMemory_                  0x78888080c9e8f000
#define FLAG_ZwAllocateVirtualMemory_              0x78888090c9e8f000
#define FLAG_ZwProtectVirtualMemory_               0x788880a0c9e8f000
#define FLAG_KeStackAttachProcess_                 0x788880b0c9e8f000
#define FLAG_KeUnstackDetachProcess_               0x788880c0c9e8f000
#define FLAG_MM_HIGHEST_USER_ADDRESS_              0x788880d0c9e8f000

void InitFunTable();
BOOLEAN ReplaceFun(UCHAR *Original);
PVOID CopyMyFun(ULONG64 funAddr, OUT ULONG* size);
void EncryptDecryptBuf(char* buf, int size, char key);
```

`shellcode.asm`:

```asm

.CODE

 _DoMemAlloc      proc                ; CODE XREF: HookLuDashi+11C↑p
                                         ; DATA XREF: .pdata:0000000140006054↓o
                 mov     [rsp+8], rcx
                 sub     rsp, 58h
                 mov     dword ptr [rsp+30h], 0
                 lea     rdx, [rsp+38h]
                 mov     rax, [rsp+60h]
                 mov     rcx, [rax+8]
                 mov     rax, 78888030C9E8F000h
                 call    rax
                 mov     [rsp+30h], eax
                 mov     rax, [rsp+60h]
                 mov     eax, [rax+20h]
                 mov     [rsp+34h], eax
                 cmp     dword ptr [rsp+30h], 0
                 jl      loc_140001F34
                 mov     rcx, [rsp+38h]
                 mov     rax, 78888040C9E8F000h
                 call    rax
                 mov     qword ptr [rsp+40h], 0
                 mov     dword ptr [rsp+28h], 40h
                 mov     dword ptr [rsp+20h], 3000h
                 lea     r9, [rsp+34h]
                 xor     r8d, r8d
                 lea     rdx, [rsp+40h]
                 mov     rcx, 0FFFFFFFFFFFFFFFFh
                 mov     rax, 78888090C9E8F000h
                 call    rax
                 test    eax, eax
                 jge     short loc_140001EFE
                 mov     dword ptr [rsp+30h], 40000015h
                 jmp     short loc_140001F06
 ; ---------------------------------------------------------------------------

 loc_140001EFE:                          ; CODE XREF: DoMemAlloc+92↑j
                 mov     dword ptr [rsp+30h], 0

 loc_140001F06:                          ; CODE XREF: DoMemAlloc+9C↑j
                 mov     rax, 78888060C9E8F000h
                 call    rax
                 mov     rcx, [rsp+38h]
                 mov     rax, 78888070C9E8F000h
                 call    rax
                 mov     rax, [rsp+60h]
                 mov     rax, [rax+18h]
                 mov     rcx, [rsp+40h]
                 mov     [rax], rcx

 loc_140001F34:                          ; CODE XREF: DoMemAlloc+40↑j
                 xor     eax, eax
                 add     rsp, 58h
                 ret
 _DoMemAlloc      endp

 ; ---------------------------------------------------------------------------
int 3
int 3
int 3
int 3

 ; =============== S U B R O U T I N E =======================================


 _DoMemBase       proc                ; CODE XREF: HookLuDashi+107↑p
                                         ; DATA XREF: .pdata:0000000140006060↓o

 ; FUNCTION CHUNK AT .text:00000001400036F0 SIZE 00000022 BYTES

 ; __unwind { // __C_specific_handler_0
                 mov     [rsp+8], rcx
                 sub     rsp, 48h
                 mov     qword ptr [rsp+30h], 0
                 lea     rdx, [rsp+28h]
                 mov     rax, [rsp+50h]
                 mov     rcx, [rax+8]
                 mov     rax, 78888030C9E8F000h
                 call    rax
                 mov     [rsp+20h], eax
                 cmp     dword ptr [rsp+20h], 0
                 jnz     short loc_140001F7F
                 cmp     qword ptr [rsp+28h], 0
                 jnz     short loc_140001F86

 loc_140001F7F:                          ; CODE XREF: DoMemBase+35↑j
                 mov     eax, 40000015h
                 jmp     short loc_140001FF7
 ; ---------------------------------------------------------------------------

 loc_140001F86:                          ; CODE XREF: DoMemBase+3D↑j
 ;   __try { // __except at 140001FDD
                 mov     rcx, [rsp+28h]
                 mov     rax, 78888040C9E8F000h
                 call    rax
                 mov     rcx, [rsp+28h]
                 mov     rax, 78888050C9E8F000h
                 call    rax
                 mov     [rsp+30h], rax
                 mov     rax, 78888060C9E8F000h
                 call    rax
                 mov     rcx, [rsp+28h]
                 mov     rax, 78888070C9E8F000h
                 call    rax
                 mov     rax, [rsp+50h]
                 mov     rax, [rax+18h]
                 mov     rcx, [rsp+30h]
                 mov     [rax], rcx
                 jmp     short loc_140001FF5
 ;   } // starts at 140001F86
 ; ---------------------------------------------------------------------------
 ;   __except(DoMemBase$filt$0) // owned by 140001F86
                 mov     rcx, [rsp+28h]
                 mov     rax, 78888070C9E8F000h
                 call    rax
                 mov     eax, 40000015h
                 jmp     short loc_140001FF7
 ; ---------------------------------------------------------------------------

 loc_140001FF5:                          ; CODE XREF: DoMemBase+9B↑j
                 xor     eax, eax

 loc_140001FF7:                          ; CODE XREF: DoMemBase+44↑j
                                         ; DoMemBase+B3↑j
                 add     rsp, 48h
                 ret
 ; } // starts at 140001F40
 _DoMemBase       endp

 ; ---------------------------------------------------------------------------
int 3
int 3
int 3
int 3
 ; =============== S U B R O U T I N E =======================================


 _DoMemProtect    proc                ; CODE XREF: HookLuDashi+123↑p
                                         ; DATA XREF: .pdata:000000014000606C↓o

                 mov     [rsp+8], rcx
                 sub     rsp, 58h
                 mov     dword ptr [rsp+30h], 0
                 mov     rax, [rsp+60h]
                 mov     eax, [rax+20h]
                 mov     [rsp+34h], eax
                 mov     rax, [rsp+60h]
                 mov     rax, [rax+18h]
                 mov     [rsp+48h], rax
                 lea     rdx, [rsp+40h]
                 mov     rax, [rsp+60h]
                 mov     rcx, [rax+8]
                 mov     rax, 78888030C9E8F000h
                 call    rax
                 mov     [rsp+30h], eax
                 cmp     dword ptr [rsp+30h], 0
                 jl      loc_1400020E7
                 mov     rcx, [rsp+40h]
                 mov     rax, 78888040C9E8F000h
                 call    rax
                 mov     qword ptr [rsp+38h], 0
                 mov     rax, [rsp+60h]
                 add     rax, 20h
                 mov     dword ptr [rsp+28h], 40h
                 mov     qword ptr [rsp+20h], 3000h
                 mov     r9d, eax
                 xor     r8d, r8d
                 lea     rdx, [rsp+38h]
                 mov     rcx, 0FFFFFFFFFFFFFFFFh
                 mov     rax, 788880A0C9E8F000h
                 call    rax
                 test    eax, eax
                 jge     short loc_1400020B4
                 mov     dword ptr [rsp+30h], 40000015h
                 jmp     short loc_1400020BC
 ; ---------------------------------------------------------------------------

 loc_1400020B4:                          ; CODE XREF: DoMemProtect+A8↑j
                 mov     dword ptr [rsp+30h], 0

 loc_1400020BC:                          ; CODE XREF: DoMemProtect+B2↑j
                 mov     rax, [rsp+60h]
                 mov     rcx, [rsp+38h]
                 mov     [rax+18h], rcx
                 mov     rax, 78888060C9E8F000h
                 call    rax
                 mov     rcx, [rsp+40h]
                 mov     rax, 78888070C9E8F000h
                 call    rax

 loc_1400020E7:                          ; CODE XREF: DoMemProtect+4E↑j
                 xor     eax, eax
                 add     rsp, 58h
                 ret
 _DoMemProtect    endp

 ; ---------------------------------------------------------------------------
 algn_1400020EE:                         ; DATA XREF: .pdata:000000014000606C↓o
                 align 10h

 ; =============== S U B R O U T I N E =======================================


 _DoMemRead       proc                ; CODE XREF: HookLuDashi+10E↑p
                                         ; DATA XREF: .pdata:0000000140006078↓o

                 mov     [rsp+8], rcx
                 sub     rsp, 78h
                 mov     dword ptr [rsp+44h], 0
                 mov     rax, [rsp+80h]
                 mov     rax, [rax+10h]
                 mov     [rsp+58h], rax
                 mov     rax, [rsp+80h]
                 mov     eax, [rax+20h]
                 mov     [rsp+40h], eax
                 mov     rax, [rsp+80h]
                 mov     rax, [rax+18h]
                 mov     [rsp+50h], rax
                 mov     eax, [rsp+40h]
                 mov     rcx, [rsp+58h]
                 add     rcx, rax
                 mov     rax, rcx
                 cmp     rax, [rsp+58h]
                 jb      short loc_14000219A
                 mov     eax, [rsp+40h]
                 mov     rcx, [rsp+50h]
                 add     rcx, rax
                 mov     rax, rcx
                 cmp     rax, [rsp+50h]
                 jb      short loc_14000219A
                 mov     eax, [rsp+40h]
                 mov     rcx, [rsp+58h]
                 add     rcx, rax
                 mov     rax, rcx
                 mov     rcx, 788880D0C9E8F000h
                 cmp     rax, rcx
                 ja      short loc_14000219A
                 mov     eax, [rsp+40h]
                 mov     rcx, [rsp+50h]
                 add     rcx, rax
                 mov     rax, rcx
                 mov     rcx, 788880D0C9E8F000h
                 cmp     rax, rcx
                 jbe     short loc_1400021A9

 loc_14000219A:                          ; CODE XREF: DoMemRead+56↑j
                                         ; DoMemRead+6C↑j ...
                 mov     eax, 40000015h
                 jmp     loc_14000226B
 ; ---------------------------------------------------------------------------
                 jmp     loc_140002269
 ; ---------------------------------------------------------------------------

 loc_1400021A9:                          ; CODE XREF: DoMemRead+A8↑j
                 lea     rdx, [rsp+60h]
                 mov     rax, [rsp+80h]
                 mov     rcx, [rax+8]
                 mov     rax, 78888030C9E8F000h
                 call    rax
                 mov     [rsp+44h], eax
                 cmp     dword ptr [rsp+44h], 0
                 jl      loc_140002269
                 lea     rdx, [rsp+68h]
                 mov     rax, [rsp+80h]
                 mov     rcx, [rax]
                 mov     rax, 78888030C9E8F000h
                 call    rax
                 mov     [rsp+44h], eax
                 cmp     dword ptr [rsp+44h], 0
                 jl      short loc_140002258
                 mov     eax, [rsp+40h]
                 lea     rcx, [rsp+48h]
                 mov     [rsp+30h], rcx
                 mov     byte ptr [rsp+28h], 0
                 mov     [rsp+20h], rax
                 mov     r9, [rsp+50h]
                 mov     r8, [rsp+68h]
                 mov     rdx, [rsp+58h]
                 mov     rcx, [rsp+60h]
                 mov     rax, 78888080C9E8F000h
                 call    rax
                 mov     rcx, [rsp+60h]
                 mov     rax, 78888070C9E8F000h
                 call    rax
                 mov     rcx, [rsp+68h]
                 mov     rax, 78888070C9E8F000h
                 call    rax
                 jmp     short loc_140002269
 ; ---------------------------------------------------------------------------

 loc_140002258:                          ; CODE XREF: DoMemRead+10A↑j
                 mov     rcx, [rsp+60h]
                 mov     rax, 78888070C9E8F000h
                 call    rax

 loc_140002269:                          ; CODE XREF: DoMemRead+B4↑j
                                         ; DoMemRead+DF↑j ...
                 xor     eax, eax

 loc_14000226B:                          ; CODE XREF: DoMemRead+AF↑j
                 add     rsp, 78h
                 ret
 _DoMemRead       endp


int 3
int 3
int 3
int 3

 ; =============== S U B R O U T I N E =======================================


 _DoMemWrite      proc                ; CODE XREF: HookLuDashi+115↑p
                                         ; DATA XREF: .pdata:0000000140006078↓o ...

                 mov     [rsp+8], rcx
                 sub     rsp, 78h
                 mov     dword ptr [rsp+44h], 0
                 mov     rax, [rsp+80h]
                 mov     rax, [rax+10h]
                 mov     [rsp+50h], rax
                 mov     rax, [rsp+80h]
                 mov     eax, [rax+20h]
                 mov     [rsp+40h], eax
                 mov     rax, [rsp+80h]
                 mov     rax, [rax+18h]
                 mov     [rsp+58h], rax
                 mov     eax, [rsp+40h]
                 mov     rcx, [rsp+50h]
                 add     rcx, rax
                 mov     rax, rcx
                 cmp     rax, [rsp+50h]
                 jb      short loc_14000231A
                 mov     eax, [rsp+40h]
                 mov     rcx, [rsp+58h]
                 add     rcx, rax
                 mov     rax, rcx
                 cmp     rax, [rsp+58h]
                 jb      short loc_14000231A
                 mov     eax, [rsp+40h]
                 mov     rcx, [rsp+50h]
                 add     rcx, rax
                 mov     rax, rcx
                 mov     rcx, 788880D0C9E8F000h
                 cmp     rax, rcx
                 ja      short loc_14000231A
                 mov     eax, [rsp+40h]
                 mov     rcx, [rsp+58h]
                 add     rcx, rax
                 mov     rax, rcx
                 mov     rcx, 788880D0C9E8F000h
                 cmp     rax, rcx
                 jbe     short loc_140002329

 loc_14000231A:                          ; CODE XREF: DoMemWrite+56↑j
                                         ; DoMemWrite+6C↑j ...
                 mov     eax, 40000015h
                 jmp     loc_1400023EB
 ; ---------------------------------------------------------------------------
                 jmp     loc_1400023E9
 ; ---------------------------------------------------------------------------

 loc_140002329:                          ; CODE XREF: DoMemWrite+A8↑j
                 lea     rdx, [rsp+60h]
                 mov     rax, [rsp+80h]
                 mov     rcx, [rax+8]
                 mov     rax, 78888030C9E8F000h
                 call    rax
                 mov     [rsp+44h], eax
                 cmp     dword ptr [rsp+44h], 0
                 jl      loc_1400023E9
                 lea     rdx, [rsp+68h]
                 mov     rax, [rsp+80h]
                 mov     rcx, [rax]
                 mov     rax, 78888030C9E8F000h
                 call    rax
                 mov     [rsp+44h], eax
                 cmp     dword ptr [rsp+44h], 0
                 jl      short loc_1400023D8
                 mov     eax, [rsp+40h]
                 lea     rcx, [rsp+48h]
                 mov     [rsp+30h], rcx
                 mov     byte ptr [rsp+28h], 0
                 mov     [rsp+20h], rax
                 mov     r9, [rsp+50h]
                 mov     r8, [rsp+60h]
                 mov     rdx, [rsp+58h]
                 mov     rcx, [rsp+68h]
                 mov     rax, 78888080C9E8F000h
                 call    rax
                 mov     rcx, [rsp+60h]
                 mov     rax, 78888070C9E8F000h
                 call    rax
                 mov     rcx, [rsp+68h]
                 mov     rax, 78888070C9E8F000h
                 call    rax
                 jmp     short loc_1400023E9
 ; ---------------------------------------------------------------------------

 loc_1400023D8:                          ; CODE XREF: DoMemWrite+10A↑j
                 mov     rcx, [rsp+60h]
                 mov     rax, 78888070C9E8F000h
                 call    rax

 loc_1400023E9:                          ; CODE XREF: DoMemWrite+B4↑j
                                         ; DoMemWrite+DF↑j ...
                 xor     eax, eax

 loc_1400023EB:                          ; CODE XREF: DoMemWrite+AF↑j
                 add     rsp, 78h
                 ret
 _DoMemWrite      endp


int 3
int 3
int 3
int 3

 ; =============== S U B R O U T I N E =======================================


 _myIrpDispath    proc                ; CODE XREF: HookLuDashi+100↑p
                                         ; DATA XREF: HookLuDashi+C6↑o ...
                 mov     [rsp+10h], rdx
                 mov     [rsp+8], rcx
                 sub     rsp, 98h
                 mov     dword ptr [rsp+28h], 0
                 mov     qword ptr [rsp+60h], 0
                 mov     rax, [rsp+0A8h]
                 mov     rax, [rax+0B8h]
                 mov     [rsp+60h], rax
                 cmp     qword ptr [rsp+60h], 0
                 jz      loc_1400027F9
                 mov     rax, [rsp+60h]
                 movzx   eax, byte ptr [rax]
                 cmp     eax, 0Eh
                 jnz     loc_1400027F9
                 mov     rax, [rsp+60h]
                 mov     eax, [rax+18h]
                 mov     [rsp+30h], eax
                 cmp     dword ptr [rsp+30h], 222180h
                 jb      loc_1400027F9
                 mov     rax, [rsp+0A8h]
                 mov     qword ptr [rax+38h], 0
                 mov     rax, [rsp+0A8h]
                 mov     dword ptr [rax+30h], 0
                 mov     rax, 88888000C9E8F000h
                 mov     [rsp+20h], rax
                 mov     eax, [rsp+30h]
                 mov     [rsp+2Ch], eax
                 cmp     dword ptr [rsp+2Ch], 222180h
                 jz      short loc_1400024EA
                 cmp     dword ptr [rsp+2Ch], 222184h
                 jz      loc_14000257A
                 cmp     dword ptr [rsp+2Ch], 222188h
                 jz      loc_14000260E
                 cmp     dword ptr [rsp+2Ch], 22218Ch
                 jz      loc_1400026A2
                 cmp     dword ptr [rsp+2Ch], 222190h
                 jz      loc_140002742
                 jmp     loc_1400027DD
 ; ---------------------------------------------------------------------------

 loc_1400024EA:                          ; CODE XREF: myIrpDispath+AB↑j
                 mov     rax, [rsp+20h]
                 mov     rax, [rax+8]
                 mov     [rsp+68h], rax
                 mov     rax, [rsp+20h]
                 mov     eax, [rax+10h]
                 mov     [rsp+38h], eax
                 mov     rax, [rsp+20h]
                 mov     eax, [rax]
                 mov     [rsp+34h], eax
                 movzx   r8d, byte ptr [rsp+34h]
                 mov     edx, [rsp+38h]
                 mov     rcx, [rsp+68h]
                 mov     rax, 68888000C9E8F000h
                 call    rax
                 mov     rax, [rsp+0A8h]
                 mov     rcx, [rax+18h]
                 call    qword ptr [rsp+68h]
                 mov     [rsp+28h], eax
                 mov     eax, [rsp+34h]
                 inc     eax
                 cdq
                 mov     ecx, 5Ah
                 idiv    ecx
                 mov     eax, edx
                 inc     eax
                 mov     rcx, [rsp+20h]
                 mov     [rcx], eax
                 mov     rax, [rsp+20h]
                 movzx   r8d, byte ptr [rax]
                 mov     edx, [rsp+38h]
                 mov     rcx, [rsp+68h]
                 mov     rax, 68888000C9E8F000h
                 call    rax
                 jmp     loc_1400027DD
 ; ---------------------------------------------------------------------------

 loc_14000257A:                          ; CODE XREF: myIrpDispath+B5↑j
                 mov     rax, [rsp+20h]
                 mov     rax, [rax+18h]
                 mov     [rsp+70h], rax
                 mov     rax, [rsp+20h]
                 mov     eax, [rax+20h]
                 mov     [rsp+40h], eax
                 mov     rax, [rsp+20h]
                 mov     eax, [rax+14h]
                 mov     [rsp+3Ch], eax
                 movzx   r8d, byte ptr [rsp+3Ch]
                 mov     edx, [rsp+40h]
                 mov     rcx, [rsp+70h]
                 mov     rax, 68888000C9E8F000h
                 call    rax
                 mov     rax, [rsp+0A8h]
                 mov     rcx, [rax+18h]
                 call    qword ptr [rsp+70h]
                 mov     [rsp+28h], eax
                 mov     eax, [rsp+3Ch]
                 inc     eax
                 cdq
                 mov     ecx, 5Bh
                 idiv    ecx
                 mov     eax, edx
                 add     eax, 3
                 mov     rcx, [rsp+20h]
                 mov     [rcx+14h], eax
                 mov     rax, [rsp+20h]
                 movzx   r8d, byte ptr [rax+14h]
                 mov     edx, [rsp+40h]
                 mov     rcx, [rsp+70h]
                 mov     rax, 68888000C9E8F000h
                 call    rax
                 jmp     loc_1400027DD
 ; ---------------------------------------------------------------------------

 loc_14000260E:                          ; CODE XREF: myIrpDispath+C3↑j
                 mov     rax, [rsp+20h]
                 mov     rax, [rax+28h]
                 mov     [rsp+78h], rax
                 mov     rax, [rsp+20h]
                 mov     eax, [rax+30h]
                 mov     [rsp+48h], eax
                 mov     rax, [rsp+20h]
                 mov     eax, [rax+24h]
                 mov     [rsp+44h], eax
                 movzx   r8d, byte ptr [rsp+44h]
                 mov     edx, [rsp+48h]
                 mov     rcx, [rsp+78h]
                 mov     rax, 68888000C9E8F000h
                 call    rax
                 mov     rax, [rsp+0A8h]
                 mov     rcx, [rax+18h]
                 call    qword ptr [rsp+78h]
                 mov     [rsp+28h], eax
                 mov     eax, [rsp+44h]
                 inc     eax
                 cdq
                 mov     ecx, 5Ch
                 idiv    ecx
                 mov     eax, edx
                 add     eax, 5
                 mov     rcx, [rsp+20h]
                 mov     [rcx+24h], eax
                 mov     rax, [rsp+20h]
                 movzx   r8d, byte ptr [rax+24h]
                 mov     edx, [rsp+48h]
                 mov     rcx, [rsp+78h]
                 mov     rax, 68888000C9E8F000h
                 call    rax
                 jmp     loc_1400027DD
 ; ---------------------------------------------------------------------------

 loc_1400026A2:                          ; CODE XREF: myIrpDispath+D1↑j
                 mov     rax, [rsp+20h]
                 mov     rax, [rax+38h]
                 mov     [rsp+80h], rax
                 mov     rax, [rsp+20h]
                 mov     eax, [rax+40h]
                 mov     [rsp+50h], eax
                 mov     rax, [rsp+20h]
                 mov     eax, [rax+34h]
                 mov     [rsp+4Ch], eax
                 movzx   r8d, byte ptr [rsp+4Ch]
                 mov     edx, [rsp+50h]
                 mov     rcx, [rsp+80h]
                 mov     rax, 68888000C9E8F000h
                 call    rax
                 mov     rax, [rsp+0A8h]
                 mov     rcx, [rax+18h]
                 call    qword ptr [rsp+80h]
                 mov     [rsp+28h], eax
                 mov     eax, [rsp+4Ch]
                 inc     eax
                 cdq
                 mov     ecx, 5Dh
                 idiv    ecx
                 mov     eax, edx
                 add     eax, 7
                 mov     rcx, [rsp+20h]
                 mov     [rcx+34h], eax
                 mov     rax, [rsp+20h]
                 movzx   r8d, byte ptr [rax+34h]
                 mov     edx, [rsp+50h]
                 mov     rcx, [rsp+80h]
                 mov     rax, 68888000C9E8F000h
                 call    rax
                 jmp     loc_1400027DD
 ; ---------------------------------------------------------------------------

 loc_140002742:                          ; CODE XREF: myIrpDispath+DF↑j
                 mov     rax, [rsp+20h]
                 mov     rax, [rax+48h]
                 mov     [rsp+88h], rax
                 mov     rax, [rsp+20h]
                 mov     eax, [rax+50h]
                 mov     [rsp+58h], eax
                 mov     rax, [rsp+20h]
                 mov     eax, [rax+44h]
                 mov     [rsp+54h], eax
                 movzx   r8d, byte ptr [rsp+54h]
                 mov     edx, [rsp+58h]
                 mov     rcx, [rsp+88h]
                 mov     rax, 68888000C9E8F000h
                 call    rax
                 mov     rax, [rsp+0A8h]
                 mov     rcx, [rax+18h]
                 call    qword ptr [rsp+88h]
                 mov     [rsp+28h], eax
                 mov     eax, [rsp+54h]
                 inc     eax
                 cdq
                 mov     ecx, 5Eh
                 idiv    ecx
                 mov     eax, edx
                 add     eax, 9
                 mov     rcx, [rsp+20h]
                 mov     [rcx+44h], eax
                 mov     rax, [rsp+20h]
                 movzx   r8d, byte ptr [rax+44h]
                 mov     edx, [rsp+58h]
                 mov     rcx, [rsp+88h]
                 mov     rax, 68888000C9E8F000h
                 call    rax

 loc_1400027DD:                          ; CODE XREF: myIrpDispath+E5↑j
                                         ; myIrpDispath+175↑j ...
                 xor     edx, edx
                 mov     rcx, [rsp+0A8h]
                 mov     rax, 78888020C9E8F000h
                 call    rax
                 mov     eax, [rsp+28h]
                 jmp     short loc_140002813
 ; ---------------------------------------------------------------------------

 loc_1400027F9:                          ; CODE XREF: myIrpDispath+3C↑j
                                         ; myIrpDispath+4D↑j ...
                 xor     edx, edx
                 mov     rcx, [rsp+0A8h]
                 mov     rax, 78888020C9E8F000h
                 call    rax
                 mov     eax, [rsp+28h]

 loc_140002813:                          ; CODE XREF: myIrpDispath+3F7↑j
                 add     rsp, 98h
                 ret
 _myIrpDispath    endp

int 3
int 3
int 3
int 3


 _EncryptDecryptBuf1 proc              ; CODE XREF: HookLuDashi+12F↑p
                                         ; dealMyFun+43↓p
                                         ; DATA XREF: ...
                 mov     [rsp+18h], r8b
                 mov     [rsp+10h], edx
                 mov     [rsp+8], rcx
                 sub     rsp, 18h
                 mov     dword ptr [rsp], 0
                 jmp     short loc_140002943
 ; ---------------------------------------------------------------------------

 loc_14000293B:                          ; CODE XREF: EncryptDecryptBuf+4C↓j
                 mov     eax, [rsp]
                 inc     eax
                 mov     [rsp], eax

 loc_140002943:                          ; CODE XREF: EncryptDecryptBuf+19↑j
                 mov     eax, [rsp+28h]
                 cmp     [rsp], eax
                 jge     short loc_14000296E
                 movsxd  rax, dword ptr [rsp]
                 mov     rcx, [rsp+20h]
                 movsx   eax, byte ptr [rcx+rax]
                 movsx   ecx, byte ptr [rsp+30h]
                 xor     eax, ecx
                 movsxd  rcx, dword ptr [rsp]
                 mov     rdx, [rsp+20h]
                 mov     [rdx+rcx], al
                 jmp     short loc_14000293B
 ; ---------------------------------------------------------------------------

 loc_14000296E:                          ; CODE XREF: EncryptDecryptBuf+2A↑j
                 add     rsp, 18h
                 ret
 _EncryptDecryptBuf1 endp

 _EncryptDecryptBuf proc              ; CODE XREF: HookLuDashi+D4↑p
                 movsxd  rax, edx
                 test    edx, edx
                 jle     short locret_140001DB3

 loc_140001DA7:                          ; CODE XREF: EncryptDecryptBuf+11↓j
                 xor     [rcx], r8b
                 inc     rcx
                 sub     rax, 1
                 jnz     short loc_140001DA7

 locret_140001DB3:                       ; CODE XREF: EncryptDecryptBuf+5↑j
                 ret
 _EncryptDecryptBuf endp

int 3
int 3
int 3
int 3


END
```

`shellcode.c`:

```c
#include <ntddk.h>
#include <ntifs.h>

extern PVOID OrgiDispatch;

extern PVOID DriverDisPath;

INT CalcShellcodeSize(UCHAR* adr)
{
	UCHAR *orgi = adr;
	while (*adr != 0xC3)
	{
		adr++;
	}
	return adr - orgi;
}

BOOLEAN replacedata(ULONG64 *Original, ULONG64 Now)
{
	while (*Original != Now)
	{
		Original = Original + 8;
	}
	if (Original)
	{
		*Original = Now;
	}
}

INT CalcWdkoptimizationCodeSize(UCHAR *adr) {
	UCHAR *orgi = adr;
	// C3 CC CC CC CC
	//ffff880`0307c3db c3              ret
	//	fffff880`0307c3dc cc              int     3
	//	fffff880`0307c3dd cc              int     3
	//fffff880`0307c3de cc              int     3
	//fffff880`0307c3df cc              int     3

	while (adr[0] != 0XC3 && adr[1] != 0xCC && adr[2] != 0xCC && adr[3] != 0xCC && adr[4] != 0xCC)
	{
		adr++;
	}
	return (adr - orgi) + 3;

}



BOOLEAN replacedata(UCHAR *Original, ULONG64 Orig, ULONG64 Now)
{
	UCHAR *UL = &Orig;
	INT Count = 0x1000;
	INT NowCount = 0;
	while (NowCount <= Count)
	{
		NowCount++;
		if (Original[0] == UL[0] && Original[1] == UL[1] && Original[2] == UL[2] && Original[3] == UL[3] && Original[4] == UL[4])
		{
			break;
		}
		Original++;
	}
	if (Original)
	{
		*(ULONG64*)Original = Now;
		return TRUE;
	}
	return FALSE;
}


NTKERNELAPI
NTSTATUS
ObReferenceObjectByName(
	IN PUNICODE_STRING ObjectName,
	IN ULONG Attributes,
	IN PACCESS_STATE PassedAccessState OPTIONAL,
	IN ACCESS_MASK DesiredAccess OPTIONAL,
	IN POBJECT_TYPE ObjectType,
	IN KPROCESSOR_MODE AccessMode,
	IN OUT PVOID ParseContext OPTIONAL,
	OUT PVOID *Object
);
extern POBJECT_TYPE* IoDriverObjectType;

typedef NTSTATUS (*MmCopyVirtualMemoryx)(IN ULONG FromProcess, IN CONST VOID *FromAddress, IN ULONG ToProcess, OUT PVOID ToAddress, IN SIZE_T BufferSize, IN KPROCESSOR_MODE PreviousMode, OUT PSIZE_T NumberOfBytesCopied);

PDRIVER_DISPATCH gfn_OrigReadCompleteRoutine;
PDRIVER_OBJECT g_FilterDriverObject = NULL;
void startTask()
{
	NTSTATUS Status;
	UNICODE_STRING DestinationString;
	RtlInitUnicodeString(&DestinationString, L"\\Driver\\ComputerZ");

	
	Status = ObReferenceObjectByName(&DestinationString,
		OBJ_CASE_INSENSITIVE, NULL, NULL,
		*IoDriverObjectType, KernelMode, NULL, (PVOID)&g_FilterDriverObject);

	//result = IoGetDeviceObjectPointer( &DestinationString, FILE_ALL_ACCESS, &FileObject, &pDriver);
	DbgPrint("hookLudashiFsk pDriver:%p result:%lx IoDeviceObjectType:%p\n", g_FilterDriverObject, Status, IoDriverObjectType);

	if (NT_SUCCESS(Status))
	{
		UNICODE_STRING routineName;
		RtlInitUnicodeString(&routineName, L"MmCopyVirtualMemory");
		MmCopyVirtualMemoryx MmCopyVirtualMemoryRoutine = (MmCopyVirtualMemoryx)MmGetSystemRoutineAddress(&routineName);

		//计算原函数并且填充
		PVOID Orgi = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, 0);
		SIZE_T codesize = CalcShellcodeSize(&OrgiDispatch);
		memcpy(Orgi, &OrgiDispatch, codesize); //计算大小且复制Orgishellcode
		gfn_OrigReadCompleteRoutine = g_FilterDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL];
		gfn_OrigReadCompleteRoutine = (ULONG64)gfn_OrigReadCompleteRoutine + 0x18;
		replacedata(Orgi, 0x98888800c9e8f000, gfn_OrigReadCompleteRoutine);

		//////////////////////////////////////////////////////////////////////////
		///填充功能函数
		PVOID read = ExAllocatePoolWithTag(NonPagedPool, 0x1000, 0);
		codesize = CalcShellcodeSize(&write);
		memcpy(read, &Write, codesize);
		replacedata(read, 0x788777009e8f000, &PsLookupProcessByProcessId);
		replacedata(read, 0x688777009e8f000, &PsLookupProcessByProcessId);
		replacedata(read, 0x588777009e8f000, &MmCopyVirtualMemoryRoutine);
		replacedata(read, 0x488777009e8f000, &ObfDereferenceObject);
		replacedata(read, 0x388777009e8f000, &ObfDereferenceObject);
		replacedata(read, 0x288777009e8f000, &ObfDereferenceObject);

		//计算ShellCodeFunc 填充 Read Write 修正
		PVOID driverdis = ExAllocatePoolWithTag(NonPagedPool, 0x1000, 0);
		codesize = CalcShellcodeSize(&DriverDisPath);
		memcpy(driverdis, &DriverDisPath, codesize);

		replacedata(driverdis, 0x78888800c9e8f000, read);//read
		replacedata(driverdis, 0x68888800c9e8f000, write);//write
		replacedata(driverdis, 0x88888800c9e8f000, Orgi);//orig dis

		DbgPrint("shellcode:%p\n", driverdis);

		//Hook Com..z
		memcpy(jmp_code + 6, &driverdis, 8);;
		PDRIVER_DISPATCH Adr = g_FilterDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL];
		KernelMemCopy(Adr, jmp_code, 14, 0x18);

		ObDereferenceObject(g_FilterDriverObject);     //清除引用计数
	}
}

void stopTask()
{
	mem_protect_close();
	memcpy((PVOID)lpHookInfo->fnOrigAddress, lpHookInfo->origCode, HOOK_INST_LEN);
	mem_protect_open();
}
```