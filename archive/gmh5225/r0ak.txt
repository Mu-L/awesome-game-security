Project Path: arc_gmh5225_r0ak_7bmmvv7_

Source Tree:

```txt
arc_gmh5225_r0ak_7bmmvv7_
├── README.md
├── nt.h
├── r0ak-archdiag.png
├── r0ak-demo.png
├── r0ak.c
├── r0ak.h
├── r0ak.sln
├── r0ak.vcxproj
├── r0aketw.c
├── r0akexec.c
├── r0akmem.c
├── r0akrd.c
├── r0akrun.c
├── r0aksym.c
├── r0akutil.c
└── r0akwr.c

```

`README.md`:

```md
# r0ak![Downloads](https://img.shields.io/github/downloads/atom/atom/total.svg)

r0ak is a Windows command-line utility that enables you to easily read, write, and execute kernel-mode code (with some limitations) from the command prompt, without requiring anything else other than Administrator privileges.

## Quick Peek

```
r0ak v1.0.0 -- Ring 0 Army Knife
http://www.github.com/ionescu007/r0ak
Copyright (c) 2018 Alex Ionescu [@aionescu]
http://www.windows-internals.com

USAGE: r0ak.exe
       [--execute <Address | module.ext!function> <Argument>]
       [--write   <Address | module.ext!function> <Value>]
       [--read    <Address | module.ext!function> <Size>]
```

![Screenshot](r0ak-demo.png)

## Introduction

### Motivation

The Windows kernel is a rich environment in which hundreds of drivers execute on a typical system, and where thousands of variables containing global state are present. For advanced troubleshooting, IT experts will typically use tools such as the Windows Debugger (WinDbg), SysInternals Tools, or write their own. Unfortunately, usage of these tools is getting increasingly hard, and they are themselves limited by their own access to Windows APIs and exposed features.

Some of today's challenges include:

* Windows 8 and later support Secure Boot, which prevents kernel debugging (including local debugging) and loading of test-signed driver code. This restricts troubleshooting tools to those that have a signed kernel-mode driver.
* Even on systems without Secure Boot enabled, enabling local debugging or changing boot options which ease debugging capabilities will often trigger BitLocker's recovery mode.
* Windows 10 Anniversary Update and later include much stricter driver signature requirements, which now enforce Microsoft EV Attestation Signing. This restricts the freedom of software developers as generic "read-write-everything" drivers are frowned upon.
* Windows 10 Spring Update now includes customer-facing options for enabling HyperVisor Code Integrity (HVCI) which further restricts allowable drivers and blacklists multiple 3rd party drivers that had "read-write-everything" capabilities due to poorly written interfaces and security risks.
* Technologies like Supervisor Mode Execution Prevention (SMEP), Kernel Control Flow Guard (KCFG) and HVCI with Second Level Address Translation (SLAT) are making traditional Ring 0 execution 'tricks' obsoleted, so a new approach is needed.

In such an environment, it was clear that a simple tool which can be used as an emergency band-aid/hotfix and to quickly troubleshoot kernel/system-level issues which may be apparent by analyzing kernel state might be valuable for the community.

### How it Works

#### Basic Architecture

![Diagram](r0ak-archdiag.png)

r0ak works by redirecting the execution flow of the window manager's trusted font validation checks when attempting to load a new font, by replacing the trusted font table's comparator routine with an alternate function which schedules an executive work item (`WORK_QUEUE_ITEM`) stored in the input node. Then, the trusted font table's right child (which serves as the root node) is overwritten with a named pipe's write buffer (`NP_DATA_ENTRY`) in which a custom work item is stored. This item's underlying worker function and its parameter are what will eventually be executed by a dedicated `ExpWorkerThread` at `PASSIVE_LEVEL` once a font load is attempted and the comparator routine executes, receiving the name pipe-backed parent node as its input. A real-time Event Tracing for Windows (ETW) trace event is used to receive an asynchronous notification that the work item has finished executing, which makes it safe to tear down the structures, free the kernel-mode buffers, and restore normal operation.

#### Supported Commands

When using the `--execute` option, this function and parameter are supplied by the user.

When using `--write`, a custom gadget is used to modify arbitrary 32-bit values anywhere in kernel memory.

When using `--read`, the write gadget is used to modify the system's HSTI buffer pointer and size (__**N.B.: This is destructive behavior in terms of any other applications that will request the HSTI data. As this is optional Windows behavior, and this tool is meant for emergency debugging/experimentation, this loss of data was considered acceptable**__). Then, the HSTI Query API is used to copy back into the tool's user-mode address space, and a hex dump is shown.

Because only built-in, Microsoft-signed, Windows functionality is used, and all called functions are part of the KCFG bitmap, there is no violation of any security checks, and no debugging flags are required, or usage of 3rd party poorly-written drivers.

### FAQ

#### Is this a bug/vulnerability in Windows?

No. Since this tool -- and the underlying technique -- require a SYSTEM-level privileged token, which can only be obtained by a user running under the Administrator account, no security boundaries are being bypassed in order to achieve the effect. The behavior and utility of the tool is only possible due to the elevated/privileged security context of the Administrator account on Windows, and is understood to be a by-design behavior.

#### Was Microsoft notified about this behavior?

Of course! It's important to always file security issues with Microsoft even when no violation of privileged boundaries seems to have occurred -- their teams of researchers and developers might find novel vectors and ways to reach certain code paths which an external researcher may not have thought of.

As such, in November 2014, a security case was filed with the Microsoft Security Research Centre (MSRC) which responded:
"*[…] doesn't fall into the scope of a security issue we would address via our traditional Security Bulletin vehicle. It […] pre-supposes admin privileges -- a place where architecturally, we do not currently define a defensible security boundary. As such, we won't be pursuing this to fix.*"

Furthermore, in April 2015 at the Infiltrate conference, a talk titled *Insection : AWEsomely Exploiting Shared Memory Objects* was presented detailing this issue, including to Microsoft developers in attendance, which agreed this was currently out of scope of Windows's architectural security boundaries. This is because there are literally dozens -- if not more -- of other ways an Administrator can read/write/execute Ring 0 memory. This tool merely allows an easy commodification of one such vector, for purposes of debugging and troubleshooting system issues.

#### Can't this be packaged up as part of end-to-end attack/exploit kit?

Packaging this code up as a library would require carefully removing all interactive command-line parsing and standard output, at which point, without major rewrites, the 'kit' would:

* Require the target machine to be running Windows 10 Anniversary Update x64 or later
* Have already elevated privileges to SYSTEM
* Require an active Internet connection with a proxy/firewall allowing access to Microsoft's Symbol Server
* Require the Windows SDK/WDK installed on the target machine
* Require a sensible _NT_SYMBOL_PATH environment variable to have been configured on the target machine, and for about 15MB of symbol data to be downloaded and cached as PDB files somewhere on the disk

Attackers interested in using this particular approach -- versus very many others more cross-compatible, no-SYSTEM-right-requiring techniques -- likely already adapted their own code based on the Proof-of-Concept from April 2015 -- more than 3 years ago.

## Usage

### Requirements

Due to the usage of the Windows Symbol Engine, you must have either the Windows Software Development Kit (SDK) or Windows Driver Kit (WDK) installed with the Debugging Tools for Windows. The tool will lookup your installation path automatically, and leverage the `DbgHelp.dll` and `SymSrv.dll` that are present in that directory. As these files are not re-distributable, they cannot be included with the release of the tool.

Alternatively, if you obtain these libraries on your own, you can modify the source-code to use them.

Usage of symbols requires an Internet connection, unless you have pre-cached them locally. Additionally, you should setup the `_NT_SYMBOL_PATH` variable pointing to an appropriate symbol server and cached location.

It is assumed that an IT Expert or other troubleshooter which apparently has a need to read/write/execute kernel memory (and has knowledge of the appropriate kernel variables to access) is already more than intimately familiar with the above setup requirements. Please do not file issues asking what the SDK is or how to set an environment variable.

### Use Cases

* Some driver leaked kernel pool? Why not call `ntoskrnl.exe!ExFreePool` and pass in the kernel address that's leaking? What about an object reference? Go call `ntoskrnl.exe!ObfDereferenceObject` and have that cleaned up.

* Want to dump the kernel DbgPrint log? Why not dump the internal circular buffer at `ntoskrnl.exe!KdPrintCircularBuffer`

* Wondering how big the kernel stacks are on your machine? Try looking at `ntoskrnl.exe!KeKernelStackSize`

* Want to dump the system call table to look for hooks? Go print out `ntoskrnl.exe!KiServiceTable`

These are only a few examples -- all Ring 0 addresses are accepted, either by `module!symbol` syntax or directly passing the kernel pointer if known. The Windows Symbol Engine is used to look these up.

### Limitations

The tool requires certain kernel variables and functions that are only known to exist in modern versions of Windows 10, and was only meant to work on 64-bit systems. These limitations are due to the fact that on older systems (or x86 systems), these stricter security requirements don't exist, and as such, more traditional approaches can be used instead. This is a personal tool which I am making available, and I had no need for these older systems, where I could use a simple driver instead. That being said, this repository accepts pull requests, if anyone is interested in porting it.

Secondly, due to the use cases and my own needs, the following restrictions apply:
* Reads -- Limited to 4 GB of data at a time
* Writes -- Limited to 32-bits of data at a time
* Executes -- Limited to functions which only take 1 scalar parameter

Obviously, these limitations could be fixed by programmatically choosing a different approach, but they fit the needs of a command line tool and my use cases. Again, pull requests are accepted if others wish to contribute their own additions.

Note that all execution (including execution of the `--read` and `--write` commands) occurs in the context of a System Worker Thread at `PASSIVE_LEVEL`. Therefore, user-mode addresses should not be passed in as parameters/arguments.

## Contributing

Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.

## License
```
Copyright 2018 Alex Ionescu. All rights reserved. 

Redistribution and use in source and binary forms, with or without modification, are permitted provided
that the following conditions are met: 
1. Redistributions of source code must retain the above copyright notice, this list of conditions and
   the following disclaimer. 
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions
   and the following disclaimer in the documentation and/or other materials provided with the 
   distribution. 

THIS SOFTWARE IS PROVIDED BY ALEX IONESCU ``AS IS'' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ALEX IONESCU
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those of the authors and
should not be interpreted as representing official policies, either expressed or implied, of Alex Ionescu.

```

`nt.h`:

```h
/*++

Copyright (c) Alex Ionescu.  All rights reserved.

Module Name:

    nt.h

Abstract:

    This header defines internal NT data structures and routines used by r0ak

Author:

    Alex Ionescu (@aionescu) 21-Jul-2018 - First public version

Environment:

    User mode only.

--*/

#include <winternl.h>

NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege (
    _In_ ULONG Privilege,
    _In_ BOOLEAN NewValue,
    _In_ BOOLEAN ForThread,
    _Out_ PBOOLEAN OldValue
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection (
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

typedef struct _WORK_QUEUE_ITEM
{
    LIST_ENTRY List;
    PVOID WorkerRoutine;
    PVOID Parameter;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

typedef struct _RTL_BALANCED_LINKS
{
    struct _RTL_BALANCED_LINKS *Parent;
    struct _RTL_BALANCED_LINKS *LeftChild;
    struct _RTL_BALANCED_LINKS *RightChild;
    CHAR Balance;
    UCHAR Reserved[3];
} RTL_BALANCED_LINKS;
typedef RTL_BALANCED_LINKS *PRTL_BALANCED_LINKS;

typedef struct _RTL_AVL_TABLE
{
    RTL_BALANCED_LINKS BalancedRoot;
    PVOID OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    ULONG DepthOfTree;
    PRTL_BALANCED_LINKS RestartKey;
    ULONG DeleteCount;
    PVOID CompareRoutine;
    PVOID AllocateRoutine;
    PVOID FreeRoutine;
    PVOID TableContext;
} RTL_AVL_TABLE;
typedef RTL_AVL_TABLE *PRTL_AVL_TABLE;

typedef struct tagXSGLOBALS
{
    PVOID NetworkFontsTableLock;
    PRTL_AVL_TABLE NetworkFontsTable;
    PVOID TrustedFontsTableLock;
    PRTL_AVL_TABLE TrustedFontsTable;
} XSGLOBALS, *PXSGLOBALS;

#pragma warning(push)
#pragma warning(disable:4214)
#pragma warning(disable:4201)
typedef struct _SYSTEM_BIGPOOL_ENTRY
{
    union
    {
        PVOID VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };
    ULONGLONG SizeInBytes;
    union
    {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;
#pragma warning(pop)

typedef struct _SYSTEM_BIGPOOL_INFORMATION
{
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;

#define SE_DEBUG_PRIVILEGE 20
#define SystemBigPoolInformation (SYSTEM_INFORMATION_CLASS)66
#define SystemHardwareSecurityTestInterfaceResultsInformation (SYSTEM_INFORMATION_CLASS)166
#define PERF_WORKER_THREAD 0x48000000
#define EVENT_TRACE_GROUP_THREAD 0x0500
#define PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM_END (EVENT_TRACE_GROUP_THREAD | 0x41)


```

`r0ak.c`:

```c
/*++

Copyright (c) Alex Ionescu.  All rights reserved.

Module Name:

    r0ak.c

Abstract:

    This module implements the main command line interface for r0ak

Author:

    Alex Ionescu (@aionescu) 21-Jul-2018 - First public version

Environment:

    User mode only.

--*/

#include "r0ak.h"

_Success_(return != 0)
BOOL
CmdParseInputParameters (
    _In_ PCHAR Arguments[],
    _Out_ PVOID* Function,
    _Out_ PULONG_PTR FunctionArgument
    )
{
    PVOID functionPointer;
    PCHAR moduleName, functionName, pBang, functionNameAndModule;

    //
    // Check if the user passed in a module!function instead
    //
    functionPointer = (PVOID)strtoull(Arguments[2], NULL, 0);
    if (functionPointer == NULL)
    {
        //
        // Separate out the module name from the symbol name
        //
        functionNameAndModule = Arguments[2];
        pBang = strchr(functionNameAndModule, '!');
        if (pBang == NULL)
        {
            printf("[-] Malformed symbol string: %s\n",
                   Arguments[2]);
            return FALSE;
        }

        //
        // Now get the remaining function name
        //
        functionName = pBang + 1;
        *pBang = ANSI_NULL;
        moduleName = functionNameAndModule;

        //
        // Get the symbol requested
        //
        functionPointer = SymLookup(moduleName, functionName);
        if (functionPointer == NULL)
        {
            printf("[-] Could not find symbol!\n");
            return FALSE;
        }
    }

    //
    // Return the data back
    //
    *Function = functionPointer;
    *FunctionArgument = strtoull(Arguments[3], NULL, 0);
    return TRUE;
}

INT
main (
    _In_ INT ArgumentCount,
    _In_ PCHAR Arguments[]
    )
{
    PKERNEL_EXECUTE kernelExecute;
    BOOL b;
    ULONG_PTR kernelValue;
    PVOID kernelPointer;
    INT errValue;

    //
    // Print header
    //
    printf("r0ak v1.0.0 -- Ring 0 Army Knife\n");
    printf("http://www.github.com/ionescu007/r0ak\n");
    printf("Copyright (c) 2018 Alex Ionescu [@aionescu]\n");
    printf("http://www.windows-internals.com\n\n");
    kernelExecute = NULL;
    errValue = -1;

    //
    // We need four arguments
    //
    if (ArgumentCount != 4)
    {
        printf("USAGE: r0ak.exe\n"
               "       [--execute <Address | module!function> <Argument>]\n"
               "       [--write   <Address | module!function> <Value>]\n"
               "       [--read    <Address | module!function> <Size>]\n");
        goto Cleanup;
    }

    //
    // Initialize symbol engine
    //
    b = SymSetup();
    if (b == FALSE)
    {
        printf("[-] Failed to initialize Symbol Engine\n");
        goto Cleanup;
    }

    //
    // Initialize our execution engine
    //
    b = KernelExecuteSetup(&kernelExecute, g_TrampolineFunction);
    if (b == FALSE)
    {
        printf("[-] Failed to setup Ring 0 execution engine\n");
        goto Cleanup;
    }

    //
    // Caller wants to execute their own routine
    //
    if (strstr(Arguments[1], "--execute"))
    {
        //
        // Get the initial inputs
        //
        b = CmdParseInputParameters(Arguments, &kernelPointer, &kernelValue);
        if (b == FALSE)
        {
            goto Cleanup;
        }

        //
        // Execute it
        //
        b = CmdExecuteKernel(kernelExecute, kernelPointer, kernelValue);
        if (b == FALSE)
        {
            printf("[-] Failed to execute function\n");
            goto Cleanup;
        }

        //
        // It's now safe to exit/cleanup state
        //
        printf("[+] Function executed successfuly!\n");
        errValue = 0;
    }
    else if (strstr(Arguments[1], "--write"))
    {
        //
        // Get the initial inputs
        //
        b = CmdParseInputParameters(Arguments, &kernelPointer, &kernelValue);
        if (b == FALSE)
        {
            goto Cleanup;
        }

        //
        // Only 32-bit values can be written
        //
        if (kernelValue > ULONG_MAX)
        {
            printf("[-] Invalid 64-bit value, r0ak only supports 32-bit\n");
            goto Cleanup;
        }

        //
        // Write it!
        //
        b = CmdWriteKernel(kernelExecute, kernelPointer, (ULONG)kernelValue);
        if (b == FALSE)
        {
            printf("[-] Failed to write variable\n");
            goto Cleanup;
        }

        //
        // It's now safe to exit/cleanup state
        //
        printf("[+] Write executed successfuly!\n");
        errValue = 0;
    }
    else if (strstr(Arguments[1], "--read"))
    {
        //
        // Get the initial inputs
        //
        b = CmdParseInputParameters(Arguments, &kernelPointer, &kernelValue);
        if (b == FALSE)
        {
            goto Cleanup;
        }

        //
        // Only 4GB of data can be read
        //
        if (kernelValue > ULONG_MAX)
        {
            printf("[-] Invalid size, r0ak can only read up to 4GB of data\n");
            goto Cleanup;
        }


        //
        // Write it!
        //
        b = CmdReadKernel(kernelExecute, kernelPointer, (ULONG)kernelValue);
        if (b == FALSE)
        {
            printf("[-] Failed to read variable\n");
            goto Cleanup;
        }

        //
        // It's now safe to exit/cleanup state
        //
        printf("[+] Read executed successfuly!\n");
        errValue = 0;
    }

Cleanup:
    //
    // Teardown the execution engine if we initialized it
    //
    if (kernelExecute != NULL)
    {
        KernelExecuteTeardown(kernelExecute);
    }
    return errValue;
}

```

`r0ak.h`:

```h
/*++

Copyright (c) Alex Ionescu.  All rights reserved.

Module Name:

    r0ak.h

Abstract:

    This header defines the main routines and structures for r0ak 

Author:

    Alex Ionescu (@aionescu) 21-Jul-2018 - First public version

Environment:

    User mode only.

--*/

#define UNICODE
#include <initguid.h>
#include <windows.h>
#include <tlhelp32.h>
#include <Psapi.h>
#include <DbgHelp.h>
#include <stdlib.h>
#include <stdio.h>
#include <winternl.h>
#include <evntcons.h>
#include <Evntrace.h>
#include "nt.h"

//
// Symbols provided by the symbol engine
//
extern PVOID g_XmFunction;
extern PVOID g_HstiBufferSize;
extern PVOID g_HstiBufferPointer;
extern PVOID g_TrampolineFunction;

//
// Opaque to callers
//
typedef struct _KERNEL_ALLOC *PKERNEL_ALLOC;
typedef struct _KERNEL_EXECUTE *PKERNEL_EXECUTE;
typedef struct _ETW_DATA *PETW_DATA;

//
// Symbol Routines
//
_Success_(return != 0)
PVOID
SymLookup (
    _In_ PCHAR ModuleName,
    _In_ PCHAR SymbolName
    );

_Success_(return != 0)
BOOL
SymSetup (
    VOID
    );

//
// Utility Routines
//
VOID
DumpHex (
    _In_ LPCVOID Data,
    _In_ SIZE_T Size
    );

_Success_(return != 0)
ULONG_PTR
GetDriverBaseAddr (
    _In_ PCCH BaseName
    );

_Success_(return != 0)
BOOL
ElevateToSystem (
    VOID
    );

//
// Kernel Memory Routines
//
_Success_(return != 0)
PVOID
KernelAlloc (
    _Outptr_ PKERNEL_ALLOC* KernelAlloc,
    _In_ ULONG Size
    );

_Success_(return != 0)
PVOID
KernelWrite (
    _In_ PKERNEL_ALLOC KernelAlloc
    );

VOID
KernelFree (
    _In_ PKERNEL_ALLOC KernelAlloc
    );

//
// Kernel Execution Routines
//
_Success_(return != 0)
BOOL
KernelExecuteRun (
    _In_ PKERNEL_EXECUTE KernelExecute
    );

_Success_(return != 0)
BOOL
KernelExecuteSetup (
    _Outptr_ PKERNEL_EXECUTE* KernelExecute,
    _In_ PVOID TrampolineFunction
    );

_Success_(return != 0)
BOOL
KernelExecuteSetCallback (
    _In_ PKERNEL_EXECUTE KernelExecute,
    _In_ PVOID WorkFunction,
    _In_ PVOID WorkParameter
    );

VOID
KernelExecuteTeardown (
    _In_ PKERNEL_EXECUTE KernelExecute
    );

//
// Kernel Read Routine
//
_Success_(return != 0)
BOOL
CmdReadKernel (
    _In_ PKERNEL_EXECUTE KernelExecute,
    _In_ PVOID KernelAddress,
    _In_ ULONG ValueSize
    );

//
// Kernel Write Routine
//
_Success_(return != 0)
BOOL
CmdWriteKernel (
    _In_ PKERNEL_EXECUTE KernelExecute,
    _In_ PVOID KernelAddress,
    _In_ ULONG KernelValue
    );

//
// Kernel Run Routine
//
_Success_(return != 0)
BOOL
CmdExecuteKernel (
    _In_ PKERNEL_EXECUTE KernelExecute,
    _In_ PVOID FunctionPointer,
    _In_ ULONG_PTR FunctionParameter
    );

//
// ETW Routines
//
_Success_(return != 0)
BOOL
EtwStartSession (
    _Outptr_ PETW_DATA* EtwData,
    _In_ PVOID WorkerRoutine
    );

_Success_(return != 0)
BOOL
EtwParseSession (
    _In_ PETW_DATA EtwData
    );


```

`r0ak.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "r0ak", "r0ak.vcxproj", "{689FD196-F8F9-45B2-8F9E-ACA4767776A2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{689FD196-F8F9-45B2-8F9E-ACA4767776A2}.Release|x64.ActiveCfg = Release|x64
		{689FD196-F8F9-45B2-8F9E-ACA4767776A2}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`r0ak.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="r0aketw.c" />
    <ClCompile Include="r0akexec.c" />
    <ClCompile Include="r0akmem.c" />
    <ClCompile Include="r0ak.c">
      <PrecompiledHeader>Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="r0akrd.c" />
    <ClCompile Include="r0akrun.c" />
    <ClCompile Include="r0aksym.c" />
    <ClCompile Include="r0akutil.c" />
    <ClCompile Include="r0akwr.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="r0ak.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{689FD196-F8F9-45B2-8F9E-ACA4767776A2}</ProjectGuid>
    <TemplateGuid>{504102d4-2172-473c-8adf-cd96e308f257}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Release</Configuration>
    <ProjectName>r0ak</ProjectName>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ItemDefinitionGroup>
    <Link>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>r0ak.h</PrecompiledHeaderFile>
      <Optimization>Full</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`r0aketw.c`:

```c
/*++

Copyright (c) Alex Ionescu.  All rights reserved.

Module Name:

    r0aketw.c

Abstract:

    This module implements the ETW tracing support routines for r0ak

Author:

    Alex Ionescu (@aionescu) 21-Jul-2018 - First public version

Environment:

    User mode only.

--*/
#include "r0ak.h"

//
// Tracks tracing data between calls
//
typedef struct _ETW_DATA
{
    TRACEHANDLE SessionHandle;
    TRACEHANDLE ParserHandle;
    PEVENT_TRACE_PROPERTIES Properties;
    PVOID WorkItemRoutine;
} ETW_DATA, *PETW_DATA;

DEFINE_GUID(g_EtwTraceGuid,
            0x53636210,
            0xbe24,
            0x1264,
            0xc6, 0xa5, 0xf0, 0x9c, 0x59, 0x88, 0x1e, 0xbd);
WCHAR g_EtwTraceName[] = L"r0ak-etw";

VOID
EtpEtwEventCallback(
    _In_ PEVENT_RECORD EventRecord
    )
{
    PETW_DATA etwData;

    //
    // Look for an "end of work item execution event"
    //
    if (EventRecord->EventHeader.EventDescriptor.Opcode ==
        (PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM_END & 0xFF))
    {
        //
        // Grab our context and check if the work routine matches ours
        //
        etwData = (PETW_DATA)EventRecord->UserContext;
        if (*(PVOID*)EventRecord->UserData == etwData->WorkItemRoutine)
        {
            //
            // Stop the trace -- this callback will run a few more times
            //
            printf("[+] Kernel finished executing work item at               0x%.16p\n",
                   etwData->WorkItemRoutine);
            ControlTrace(etwData->SessionHandle,
                         NULL,
                         etwData->Properties,
                         EVENT_TRACE_CONTROL_STOP);
        }
    }
}

_Success_(return != 0)
BOOL
EtwParseSession (
    _In_ PETW_DATA EtwData
    )
{
    ULONG errorCode;

    //
    // Process the trace until the right work item is found
    //
    errorCode = ProcessTrace(&EtwData->ParserHandle, 1, NULL, NULL);
    if (errorCode != ERROR_SUCCESS)
    {
        printf("[-] Failed to process trace: %lX\n", errorCode);
        ControlTrace(EtwData->SessionHandle,
                     NULL,
                     EtwData->Properties,
                     EVENT_TRACE_CONTROL_STOP);
    }

    //
    // All done -- cleanup
    //
    CloseTrace(EtwData->ParserHandle);
    HeapFree(GetProcessHeap(), 0, EtwData->Properties);
    HeapFree(GetProcessHeap(), 0, EtwData);
    return errorCode == ERROR_SUCCESS;
}

_Success_(return != 0)
BOOL
EtwStartSession (
    _Outptr_ PETW_DATA* EtwData,
    _In_ PVOID WorkItemRoutine
    )
{
    ULONG errorCode;
    ULONG traceFlags[8] = { 0 };
    EVENT_TRACE_LOGFILEW logFile = { 0 };
    ULONG bufferSize;

    //
    // Initialize context
    //
    *EtwData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(**EtwData));
    if (*EtwData == NULL)
    {
        printf("[-] Out of memory allocating ETW state\n");
        return FALSE;
    }

    //
    // Allocate memory for our session descriptor
    //
    bufferSize = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(g_EtwTraceName);
    (*EtwData)->Properties = HeapAlloc(GetProcessHeap(),
                                       HEAP_ZERO_MEMORY,
                                       bufferSize);
    if ((*EtwData)->Properties == NULL)
    {
        printf("[-] Failed to allocate memory for the ETW trace\n");
        HeapFree(GetProcessHeap(), 0, *EtwData);
        return FALSE;
    }

    //
    // Create a real-time session using the system logger, tracing nothing
    //
    (*EtwData)->Properties->Wnode.BufferSize = bufferSize;
    (*EtwData)->Properties->Wnode.Guid = g_EtwTraceGuid;
    (*EtwData)->Properties->Wnode.ClientContext = 1;
    (*EtwData)->Properties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    (*EtwData)->Properties->MinimumBuffers = 1;
    (*EtwData)->Properties->LogFileMode = EVENT_TRACE_REAL_TIME_MODE |
                                          EVENT_TRACE_SYSTEM_LOGGER_MODE;
    (*EtwData)->Properties->FlushTimer = 1;
    (*EtwData)->Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    errorCode = StartTrace(&(*EtwData)->SessionHandle,
                           g_EtwTraceName,
                           (*EtwData)->Properties);
    if (errorCode != ERROR_SUCCESS)
    {
        printf("[-] Failed to create the event trace session: %lX\n", 
               errorCode);
        HeapFree(GetProcessHeap(), 0, (*EtwData)->Properties);
        HeapFree(GetProcessHeap(), 0, *EtwData);
        return FALSE;
    }

    //
    // Open a consumer handle to it
    //
    logFile.LoggerName = g_EtwTraceName;
    logFile.ProcessTraceMode = PROCESS_TRACE_MODE_REAL_TIME |
                               PROCESS_TRACE_MODE_EVENT_RECORD;
    logFile.EventRecordCallback = EtpEtwEventCallback;
    logFile.Context = *EtwData;
    (*EtwData)->ParserHandle = OpenTrace(&logFile);
    if ((*EtwData)->ParserHandle == INVALID_PROCESSTRACE_HANDLE)
    {
        printf("[-] Failed open a consumer handle for the trace session: %lX\n",
               GetLastError());
        ControlTrace((*EtwData)->SessionHandle,
                     NULL,
                     (*EtwData)->Properties,
                     EVENT_TRACE_CONTROL_STOP);
        HeapFree(GetProcessHeap(), 0, (*EtwData)->Properties);
        HeapFree(GetProcessHeap(), 0, *EtwData);
        return FALSE;
    }

    //
    // Trace worker thread events
    //
    traceFlags[2] = PERF_WORKER_THREAD;
    errorCode = TraceSetInformation((*EtwData)->SessionHandle,
                                    TraceSystemTraceEnableFlagsInfo,
                                    traceFlags,
                                    sizeof(traceFlags));
    if (errorCode != ERROR_SUCCESS)
    {
        printf("[-] Failed to set flags for event trace session: %lX\n",
               errorCode);
        ControlTrace((*EtwData)->SessionHandle,
                     NULL,
                     (*EtwData)->Properties,
                     EVENT_TRACE_CONTROL_STOP);
        CloseTrace((*EtwData)->ParserHandle);
        HeapFree(GetProcessHeap(), 0, (*EtwData)->Properties);
        HeapFree(GetProcessHeap(), 0, *EtwData);
        return FALSE;
    }

    //
    // Remember which work routine we'll be looking for
    //
    (*EtwData)->WorkItemRoutine = WorkItemRoutine;
    return TRUE;
}

```

`r0akexec.c`:

```c
/*++

Copyright (c) Alex Ionescu.  All rights reserved.

Module Name:

    r0akexec.c

Abstract:

    This module implements the kernel-mode execution engine for r0ak

Author:

    Alex Ionescu (@aionescu) 21-Jul-2018 - First public version

Environment:

    User mode only.

--*/

#include "r0ak.h"

typedef struct _CONTEXT_PAGE
{
    RTL_BALANCED_LINKS Header;
    UCHAR Reserved[0x50];
    WORK_QUEUE_ITEM WorkItem;
} CONTEXT_PAGE, *PCONTEXT_PAGE;

//
// Tracks execution state between calls
//
typedef struct _KERNEL_EXECUTE
{
    PXSGLOBALS Globals;
    PKERNEL_ALLOC TrampolineAllocation;
    PRTL_BALANCED_LINKS TrampolineParameter;
} KERNEL_EXECUTE, *PKERNEL_EXECUTE;

_Success_(return != 0)
BOOL
KernelExecuteRun (
    _In_ PKERNEL_EXECUTE KernelExecute
    )
{
    PRTL_AVL_TABLE realTable, fakeTable;
    BOOL b;

    //
    // Remember original pointer
    //
    realTable = KernelExecute->Globals->TrustedFontsTable;

    //
    // Remove arial, which is our target font
    //
    b = RemoveFontResourceExW(L"C:\\windows\\fonts\\arial.ttf", 0, NULL);
    if (b == 0)
    {
        printf("[-] Failed to remove font: %lx\n", GetLastError());
        return b;
    }

    //
    // Save the original trusted font file table and overwrite it with our own.
    //
    fakeTable = (PRTL_AVL_TABLE)((KernelExecute->Globals) + 1);
    fakeTable->BalancedRoot.RightChild = KernelExecute->TrampolineParameter;
    KernelExecute->Globals->TrustedFontsTable = fakeTable;

    //
    // Set our priority to 4, the theory being that this should force the work
    // item to execute even on a single-processor core
    //
    SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_BEGIN);

    //
    // Add a font -- Win32k.sys will check if it's in the trusted path,
    // triggering the AVL search. This will trigger the execute.
    //
    b = AddFontResourceExW(L"C:\\windows\\fonts\\arial.ttf", 0, NULL);
    if (b == 0)
    {
        printf("[-] Failed to add font: %lx\n", GetLastError());
    }

    //
    // Restore original pointer and thread priority
    //
    KernelExecute->Globals->TrustedFontsTable = realTable;
    SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_END);
    return b;
}

VOID
KernelExecuteTeardown (
    _In_ PKERNEL_EXECUTE KernelExecute
    )
{
    //
    // Free the trampoline context
    //
    KernelFree(KernelExecute->TrampolineAllocation);

    //
    // Unmap the globals
    //
    UnmapViewOfFile(KernelExecute->Globals);

    //
    // Free the context
    //
    HeapFree(GetProcessHeap(), 0, KernelExecute);
}

_Success_(return != 0)
BOOL
KernelExecuteSetup (
    _Outptr_ PKERNEL_EXECUTE* KernelExecute,
    _In_ PVOID TrampolineFunction
    )
{
    PRTL_AVL_TABLE fakeTable;
    BOOL b;
    NTSTATUS status;
    HANDLE hFile;
    UNICODE_STRING name;
    OBJECT_ATTRIBUTES objectAttributes;

    //
    // Callers can't pass NULL
    //
    if (KernelExecute == NULL)
    {
        return FALSE;
    }

    //
    // Initialize the context
    //
    *KernelExecute = HeapAlloc(GetProcessHeap(),
                               HEAP_ZERO_MEMORY,
                               sizeof(**KernelExecute));
    if (*KernelExecute == NULL)
    {
        printf("[-] Out of memory allocating execution tracker\n");
        return FALSE;
    }

    //
    // Get a SYSTEM token
    //
    b = ElevateToSystem();
    if (b == FALSE)
    {
        printf("[-] Failed to elevate to SYSTEM privileges\n");
        HeapFree(GetProcessHeap(), 0, *KernelExecute);
        return FALSE;
    }

    //
    // Open a handle to Win32k's cross-session globals section object
    //
    RtlInitUnicodeString(&name, L"\\Win32kCrossSessionGlobals");
    InitializeObjectAttributes(&objectAttributes,
                               &name,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    status = ZwOpenSection(&hFile, MAXIMUM_ALLOWED, &objectAttributes);

    //
    // We can drop impersonation now
    //
    b = RevertToSelf();
    if (b == FALSE)
    {
        //
        // Not much to do but trace
        //
        printf("[-] Failed to revert impersonation token: %lX\n",
               GetLastError());
    }

    //
    // Can't keep going if we couldn't get a handle to the section
    //
    if (!NT_SUCCESS(status))
    {
        printf("[-] Couldn't open handle to kernel execution block: %lx\n",
               status);
        CloseHandle(hFile);
        HeapFree(GetProcessHeap(), 0, *KernelExecute);
        return FALSE;
    }

    //
    // Map the section object in our address space
    //
    (*KernelExecute)->Globals = MapViewOfFile(hFile,
                                              FILE_MAP_ALL_ACCESS,
                                              0,
                                              0,
                                              sizeof((*KernelExecute)->Globals));
    CloseHandle(hFile);
    if ((*KernelExecute)->Globals == NULL)
    {
        printf("[-] Couldn't map kernel execution block: %lx\n",
               GetLastError());
        HeapFree(GetProcessHeap(), 0, *KernelExecute);
        return FALSE;
    }

    //
    // Setup the table
    //
    printf("[+] Mapped kernel execution block at                     0x%.16p\n",
           (*KernelExecute)->Globals);
    fakeTable = (PRTL_AVL_TABLE)((*KernelExecute)->Globals + 1);
    fakeTable->DepthOfTree = 1;
    fakeTable->NumberGenericTableElements = 1;
    fakeTable->CompareRoutine = TrampolineFunction;
    return TRUE;
}

_Success_(return != 0)
BOOL
KernelExecuteSetCallback (
    _In_ PKERNEL_EXECUTE KernelExecute,
    _In_ PVOID WorkFunction,
    _In_ PVOID WorkParameter
    )
{
    PCONTEXT_PAGE contextBuffer;
    PKERNEL_ALLOC kernelAlloc;

    //
    // Allocate the right child page that will be sent to the trampoline
    //
    contextBuffer = KernelAlloc(&kernelAlloc, sizeof(*contextBuffer));
    if (contextBuffer == NULL)
    {
        printf("[-] Failed to allocate memory for WORK_QUEUE_ITEM\n");
        return FALSE;
    }

    //
    // Fill out the worker and its parameter
    //
    contextBuffer->WorkItem.WorkerRoutine = WorkFunction;
    contextBuffer->WorkItem.Parameter = WorkParameter;

    //
    // Write into the buffer
    //
    contextBuffer = (PCONTEXT_PAGE)KernelWrite(kernelAlloc);
    if (contextBuffer == NULL)
    {
        KernelFree(kernelAlloc);
        printf("[-] Failed to find kernel memory for WORK_QUEUE_ITEM\n");
        return FALSE;
    }

    //
    // Return the balanced links with the appropriate work item
    //
    KernelExecute->TrampolineAllocation = kernelAlloc;
    KernelExecute->TrampolineParameter = &contextBuffer->Header;
    return TRUE;
}

```

`r0akmem.c`:

```c
/*++

Copyright (c) Alex Ionescu.  All rights reserved.

Module Name:

    r0akmem.c

Abstract:

    This module implements kernel memory allocation and mapping for r0ak

Author:

    Alex Ionescu (@aionescu) 21-Jul-2018 - First public version

Environment:

    User mode only.

--*/

#include "r0ak.h"

//
// Internal definitions
//
#define POOL_TAG_FIXED_BUFFER       (32 * 1024 * 1024)
#define PAGE_SIZE                   4096
#define NPFS_DATA_ENTRY_SIZE        0x30
#define NPFS_DATA_ENTRY_POOL_TAG    'rFpN'

//
// Tracks allocation state between calls
//
typedef struct _KERNEL_ALLOC
{
    HANDLE Pipes[2];
    PVOID UserBase;
    PVOID KernelBase;
    ULONG MagicSize;
} KERNEL_ALLOC, *PKERNEL_ALLOC;

_Success_(return != 0)
PVOID
GetKernelAddress (
    _In_ ULONG Size
    )
{
    NTSTATUS status;
    PSYSTEM_BIGPOOL_INFORMATION bigPoolInfo;
    PSYSTEM_BIGPOOL_ENTRY entry;
    ULONG resultLength;
    ULONG_PTR resultAddress;
    ULONG i;

    //
    // Allocate a large 32MB buffer to store pool tags in
    //
    bigPoolInfo = VirtualAlloc(NULL,
                               POOL_TAG_FIXED_BUFFER,
                               MEM_COMMIT | MEM_RESERVE,
                               PAGE_READWRITE);
    if (!bigPoolInfo)
    {
        printf("[-] No memory for pool buffer\n");
        return NULL;
    }

    //
    // Dump all pool tags
    //
    status = NtQuerySystemInformation(SystemBigPoolInformation,
                                      bigPoolInfo,
                                      POOL_TAG_FIXED_BUFFER,
                                      &resultLength);
    if (!NT_SUCCESS(status))
    {
        printf("[-] Failed to dump pool allocations: %lx\n", status);
        return NULL;
    }

    //
    // Scroll through them all
    //
    for (resultAddress = 0, i = 0; i < bigPoolInfo->Count; i++)
    {
        //
        // Check for the desired allocation
        //
        entry = &bigPoolInfo->AllocatedInfo[i];
        if (entry->TagUlong == NPFS_DATA_ENTRY_POOL_TAG)
        {
            //
            // With the Heap-Backed Pool in RS5/19H1, sizes are precise, while
            // the large pool allocator uses page-aligned pages
            //
            if ((entry->SizeInBytes == (Size + PAGE_SIZE)) ||
                (entry->SizeInBytes == (Size + NPFS_DATA_ENTRY_SIZE)))
            {
                //
                // Mask out the nonpaged pool bit
                //
                resultAddress = (ULONG_PTR)entry->VirtualAddress & ~1;
                break;
            }
        }
    }

    //
    // Weird..
    //
    if (resultAddress == 0)
    {
        printf("[-] Kernel buffer not found!\n");
        return NULL;
    }

    //
    // Free the buffer
    //
    VirtualFree(bigPoolInfo, 0, MEM_RELEASE);
    return (PVOID)(resultAddress + NPFS_DATA_ENTRY_SIZE);
}

_Success_(return != 0)
PVOID
KernelAlloc (
    _Outptr_ PKERNEL_ALLOC* KernelAlloc,
    _In_ ULONG Size
    )
{
    BOOL b;

    //
    // Catch bad callers
    //
    if (KernelAlloc == NULL)
    {
        return NULL;
    }

    //
    // Only support < 2KB allocations
    //
    *KernelAlloc = NULL;
    if (Size > 2048)
    {
        return NULL;
    }

    //
    // Allocate our tracker structure
    //
    *KernelAlloc = HeapAlloc(GetProcessHeap(),
                             HEAP_ZERO_MEMORY,
                             sizeof(**KernelAlloc));
    if (*KernelAlloc == NULL)
    {
        return NULL;
    }

    //
    // Compute a magic size to get something in big pool that should be unique
    // This will use at most ~5MB of non-paged pool
    //
    (*KernelAlloc)->MagicSize = 0;
    while ((*KernelAlloc)->MagicSize == 0)
    {
        (*KernelAlloc)->MagicSize = (((__rdtsc() & 0xFF000000) >> 24) * 0x5000);
    }

    //
    // Allocate the right child page that will be sent to the trampoline
    //
    (*KernelAlloc)->UserBase = VirtualAlloc(NULL,
                                            (*KernelAlloc)->MagicSize,
                                            MEM_COMMIT | MEM_RESERVE,
                                            PAGE_READWRITE);
    if ((*KernelAlloc)->UserBase == NULL)
    {
        printf("[-] Failed to allocate user-mode memory for kernel buffer\n");
        return NULL;
    }

    //
    // Allocate a pipe to hold on to the buffer
    //
    b = CreatePipe(&(*KernelAlloc)->Pipes[0],
                   &(*KernelAlloc)->Pipes[1],
                   NULL,
                   (*KernelAlloc)->MagicSize);
    if (!b)
    {
        printf("[-] Failed creating the pipe: %lx\n",
               GetLastError());
        return NULL;
    }

    //
    // Return the allocated user-mode base
    //
    return (*KernelAlloc)->UserBase;
}

_Success_(return != 0)
PVOID
KernelWrite (
    _In_ PKERNEL_ALLOC KernelAlloc
    )
{
    BOOL b;

    //
    // Write into the buffer
    //
    b = WriteFile(KernelAlloc->Pipes[1],
                  KernelAlloc->UserBase,
                  KernelAlloc->MagicSize,
                  NULL,
                  NULL);
    if (!b)
    {
        printf("[-] Failed writing kernel buffer: %lx\n",
               GetLastError());
        return NULL;
    }

    //
    // Compute the kernel address and return it
    //
    KernelAlloc->KernelBase = GetKernelAddress(KernelAlloc->MagicSize);
    return KernelAlloc->KernelBase;
}

VOID
KernelFree (
    _In_ PKERNEL_ALLOC KernelAlloc
    )
{
    //
    // Free the UM side of the allocation
    //
    VirtualFree(KernelAlloc->UserBase, 0, MEM_RELEASE);

    //
    // Close the pipes, which will free the kernel side
    //
    CloseHandle(KernelAlloc->Pipes[0]);
    CloseHandle(KernelAlloc->Pipes[1]);

    //
    // Free the structure
    //
    HeapFree(GetProcessHeap(), 0, KernelAlloc);
}


```

`r0akrd.c`:

```c
/*++

Copyright (c) Alex Ionescu.  All rights reserved.

Module Name:

    r0akrd.c

Abstract:

    This module implements read capabilities for r0ak

Author:

    Alex Ionescu (@aionescu) 21-Jul-2018 - First public version

Environment:

    User mode only.

--*/

#include "r0ak.h"

_Success_(return != 0)
BOOL
CmdReadKernel (
    _In_ PKERNEL_EXECUTE KernelExecute,
    _In_ PVOID KernelAddress,
    _In_ ULONG ValueSize
    )
{
    BOOL b;
    NTSTATUS status;
    PVOID userData;

    //
    // First, set the size that the user wants
    //
    printf("[+] Setting size to                                      0x%.16lX\n",
           ValueSize);
    b = CmdWriteKernel(KernelExecute, g_HstiBufferSize, ValueSize);
    if (b == FALSE)
    {
        printf("[-] Fail to set size\n");
        return b;
    }

    //
    // Then, set the pointer -- our write is 32-bits so we do it in 2 steps
    //
    printf("[+] Setting pointer to                                   0x%.16p\n",
           KernelAddress);
    b = CmdWriteKernel(KernelExecute,
                        g_HstiBufferPointer,
                        (ULONG_PTR)KernelAddress & 0xFFFFFFFF);
    if (b == FALSE)
    {
        printf("[-] Fail to set lower pointer bits\n");
        return b;
    }
    b = CmdWriteKernel(KernelExecute,
                        (PVOID)((ULONG_PTR)g_HstiBufferPointer + 4),
                        (ULONG_PTR)KernelAddress >> 32);
    if (b == FALSE)
    {
        printf("[-] Fail to set lower pointer bits\n");
        return b;
    }

    //
    // Allocate a buffer for the data in user space
    //
    userData = VirtualAlloc(NULL,
                            ValueSize,
                            MEM_COMMIT | MEM_RESERVE,
                            PAGE_READWRITE);
    if (userData == NULL)
    {
        printf("[-] Failed to allocate user mode buffer\n");
        return FALSE;
    }

    //
    // Now do the read by abusing the HSTI buffers
    //
    status = NtQuerySystemInformation(
        SystemHardwareSecurityTestInterfaceResultsInformation,
        userData,
        ValueSize,
        NULL);
    if (!NT_SUCCESS(status))
    {
        printf("[-] Failed to read kernel data\n");
    }
    else
    {
        DumpHex(userData, ValueSize);
    }

    //
    // Free the buffer and exit
    //
    VirtualFree(userData, 0, MEM_RELEASE);
    return NT_SUCCESS(status);
}


```

`r0akrun.c`:

```c
/*++

Copyright (c) Alex Ionescu.  All rights reserved.

Module Name:

    r0akrun.c

Abstract:

    This module implements run capabilities for r0ak

Author:

    Alex Ionescu (@aionescu) 21-Jul-2018 - First public version

Environment:

    User mode only.

--*/

#include "r0ak.h"

_Success_(return != 0)
BOOL
CmdExecuteKernel (
    _In_ PKERNEL_EXECUTE KernelExecute,
    _In_ PVOID FunctionPointer,
    _In_ ULONG_PTR FunctionParameter
    )
{
    PETW_DATA etwData;
    BOOL b;

    //
    // Initialize a work item for the caller-supplied function and argument
    //
    printf("[+] Calling function pointer 0x%p\n", FunctionPointer);
    b = KernelExecuteSetCallback(KernelExecute,
                                 FunctionPointer,
                                 (PVOID)FunctionParameter);
    if (b == FALSE)
    {
        printf("[-] Failed to initialize work item trampoline\n");
        return b;
    }

    //
    // Begin ETW tracing to look for the work item executing
    //
    etwData = NULL;
    b = EtwStartSession(&etwData, FunctionPointer);
    if (b == FALSE)
    {
        printf("[-] Failed to start ETW trace\n");
        return b;
    }

    //
    // Execute it!
    //
    b = KernelExecuteRun(KernelExecute);
    if (b == FALSE)
    {
        printf("[-] Failed to execute work item\n");
        return b;
    }

    //
    // Wait for execution to finish
    //
    b = EtwParseSession(etwData);
    if (b == FALSE)
    {
        //
        // We have no idea if execution finished -- block forever
        //
        printf("[-] Failed to parse ETW trace\n");
        Sleep(INFINITE);
    }
    return b;
}

```

`r0aksym.c`:

```c
/*++

Copyright (c) Alex Ionescu.  All rights reserved.

Module Name:

    r0aksym.c

Abstract:

    This module implements the symbol engine interface and parsing for r0ak

Author:

    Alex Ionescu (@aionescu) 21-Jul-2018 - First public version

Environment:

    User mode only.

--*/

#include "r0ak.h"

typedef DWORD64
(*tSymLoadModuleEx)(
    _In_ HANDLE hProcess,
    _In_opt_ HANDLE hFile,
    _In_opt_ PCSTR ImageName,
    _In_opt_ PCSTR ModuleName,
    _In_ DWORD64 BaseOfDll,
    _In_ DWORD DllSize,
    _In_opt_ PMODLOAD_DATA Data,
    _In_opt_ DWORD Flags
    );

typedef BOOL
(*tSymInitializeW)(
    _In_ HANDLE hProcess,
    _In_opt_ PCWSTR UserSearchPath,
    _In_ BOOL fInvadeProcess
    );

typedef DWORD
(*tSymSetOptions)(
    _In_ DWORD   SymOptions
    );

typedef BOOL
(*tSymGetSymFromName64)(
    _In_ HANDLE hProcess,
    _In_ PCSTR Name,
    _Inout_ PIMAGEHLP_SYMBOL64 Symbol
    );

typedef BOOL
(*tSymUnloadModule64)(
    _In_ HANDLE hProcess,
    _In_ DWORD64 BaseOfDll
    );

PVOID g_XmFunction;
PVOID g_HstiBufferSize;
PVOID g_HstiBufferPointer;
PVOID g_TrampolineFunction;

tSymLoadModuleEx pSymLoadModuleEx;
tSymInitializeW pSymInitializeW;
tSymSetOptions pSymSetOptions;
tSymUnloadModule64 pSymUnloadModule64;
tSymGetSymFromName64 pSymGetSymFromName64;

_Success_(return != 0)
PVOID
SymLookup (
    _In_ PCHAR ModuleName,
    _In_ PCHAR SymbolName
    )
{
    ULONG_PTR offset;
    ULONG_PTR kernelBase;
    ULONG_PTR imageBase;
    BOOL b;
    PIMAGEHLP_SYMBOL64 symbol;
    ULONG_PTR realKernelBase;
    CHAR symName[MAX_PATH];

    //
    // Get the base address of the kernel image in kernel-mode
    //
    realKernelBase = GetDriverBaseAddr(ModuleName);
    if (realKernelBase == 0)
    {
        printf("[-] Couldn't find base address for %s\n", ModuleName);
        return NULL;
    }

    //
    // Load the kernel image in user-mode
    //
    kernelBase = (ULONG_PTR)LoadLibraryExA(ModuleName,
                                           NULL,
                                           DONT_RESOLVE_DLL_REFERENCES);
    if (kernelBase == 0)
    { 
        printf("[-] Couldn't map %s!\n", ModuleName);
        return NULL;
    }

    //
    // Allocate space for a symbol buffer
    //
    symbol = HeapAlloc(GetProcessHeap(),
                       HEAP_ZERO_MEMORY,
                       sizeof(*symbol) + 2);
    if (symbol == NULL)
    {
        printf("[-] Not enough memory to allocate IMAGEHLP_SYMBOL64\n");
        FreeLibrary((HMODULE)kernelBase);
        return NULL;
    }

    //
    // Attach symbols to our module
    //
    imageBase = pSymLoadModuleEx(GetCurrentProcess(),
                                 NULL,
                                 ModuleName,
                                 ModuleName,
                                 kernelBase,
                                 0,
                                 NULL,
                                 0);
    if (imageBase != kernelBase)
    {
        HeapFree(GetProcessHeap(), 0, symbol);
        FreeLibrary((HMODULE)kernelBase);
        printf("[-] Couldn't load symbols for %s\n", ModuleName);
        return NULL;
    }

    //
    // Build the symbol name
    //
    strcpy_s(symName, MAX_PATH, ModuleName);
    strcat_s(symName, MAX_PATH, "!");
    strcat_s(symName, MAX_PATH, SymbolName);

    //
    // Look it up
    //
    symbol->SizeOfStruct = sizeof(*symbol);
    symbol->MaxNameLength = 1;
    b = pSymGetSymFromName64(GetCurrentProcess(), symName, symbol);
    if (b == FALSE)
    {
        printf("[-] Couldn't find %s symbol\n", symName);
        FreeLibrary((HMODULE)kernelBase);
        pSymUnloadModule64(GetCurrentProcess(), imageBase);
        HeapFree(GetProcessHeap(), 0, symbol);
        return NULL;
    }
    
    //
    // Compute the offset based on the mapped address
    //
    offset = symbol->Address - kernelBase;
    FreeLibrary((HMODULE)kernelBase);
    pSymUnloadModule64(GetCurrentProcess(), imageBase);
    HeapFree(GetProcessHeap(), 0, symbol);

    //
    // Compute the final location based on the real kernel base
    //
    return (PVOID)(realKernelBase + offset);
}

_Success_(return != 0)
BOOL
SymSetup (
    VOID
    )
{
    HMODULE hMod;
    HKEY rootKey;
    DWORD dwError;
    WCHAR rootPath[MAX_PATH];
    ULONG pathSize;
    ULONG type;
    BOOL b;

    //
    // Open the Kits key
    //
    dwError = RegOpenKey(HKEY_LOCAL_MACHINE,
                         L"Software\\Microsoft\\Windows Kits\\Installed Roots",
                         &rootKey);
    if (dwError != ERROR_SUCCESS)
    {
        printf("[-] No Windows SDK or WDK installed: %lx\n", dwError);
        return FALSE;
    }

    //
    // Check where a kit was installed
    //
    pathSize = sizeof(rootPath);
    type = REG_SZ;
    dwError = RegQueryValueEx(rootKey,
                              L"KitsRoot10",
                              NULL,
                              &type,
                              (LPBYTE)rootPath,
                              &pathSize);
    if (dwError != ERROR_SUCCESS)
    {
        printf("[-] Win 10 SDK/WDK not found, falling back to 8.1: %lx\n",
               dwError);
        dwError = RegQueryValueEx(rootKey,
                                  L"KitsRoot81",
                                  NULL,
                                  &type,
                                  (LPBYTE)rootPath,
                                  &pathSize);
        if (dwError != ERROR_SUCCESS)
        {
            printf("[-] Win 8.1 SDK/WDK not found, falling back to 8: %lx\n",
                   dwError);
            dwError = RegQueryValueEx(rootKey,
                                      L"KitsRoot8",
                                      NULL,
                                      &type,
                                      (LPBYTE)rootPath,
                                      &pathSize);
            if (dwError != ERROR_SUCCESS)
            {
                printf("[-] Win 8 SDK/WDK not found %lx\n", dwError);
                return FALSE;
            }
        }
    }

    //
    // Now try to load the correct debug help library
    //
    wcscat_s(rootPath, _ARRAYSIZE(rootPath), L"debuggers\\x64\\dbghelp.dll");
    hMod = LoadLibrary(rootPath);
    if (hMod == NULL)
    {
        printf("[-] Failed to load Debugging Tools Dbghelp.dll: %lx\n",
               GetLastError());
        return FALSE;
    }

    //
    // Get the APIs that we need
    //
    pSymSetOptions = (tSymSetOptions)GetProcAddress(hMod,
                                                    "SymSetOptions");
    if (pSymSetOptions == NULL)
    {
        printf("[-] Failed to find SymSetOptions\n");
        return FALSE;
    }
    pSymInitializeW = (tSymInitializeW)GetProcAddress(hMod,
                                                      "SymInitializeW");
    if (pSymInitializeW == NULL)
    {
        printf("[-] Failed to find SymInitializeW\n");
        return FALSE;
    }
    pSymLoadModuleEx = (tSymLoadModuleEx)GetProcAddress(hMod,
                                                        "SymLoadModuleEx");
    if (pSymLoadModuleEx == NULL)
    {
        printf("[-] Failed to find SymLoadModuleEx\n");
        return FALSE;
    }
    pSymGetSymFromName64 = (tSymGetSymFromName64)GetProcAddress(hMod,
                                                                "SymGetSymFromName64");
    if (pSymGetSymFromName64 == NULL)
    {
        printf("[-] Failed to find SymGetSymFromName64\n");
        return FALSE;
    }
    pSymUnloadModule64 = (tSymUnloadModule64)GetProcAddress(hMod,
                                                            "SymUnloadModule64");
    if (pSymUnloadModule64 == NULL)
    {
        printf("[-] Failed to find SymUnloadModule64\n");
        return FALSE;
    }

    //
    // Initialize the engine
    //
    pSymSetOptions(SYMOPT_DEFERRED_LOADS);
    b = pSymInitializeW(GetCurrentProcess(), NULL, TRUE);
    if (b == FALSE)
    {
        printf("[-] Failed to initialize symbol engine: %lx\n",
               GetLastError());
        return b;
    }

    //
    // Initialize our gadgets
    //
    g_XmFunction = SymLookup("hal.dll", "XmMovOp");
    if (g_XmFunction == NULL)
    {
        printf("[-] Failed to find hal!XmMovOp\n");
        return FALSE;
    }
    g_HstiBufferSize = SymLookup("ntoskrnl.exe", "SepHSTIResultsSize");
    if (g_HstiBufferSize == NULL)
    {
        printf("[-] Failed to find nt!SepHSTIResultsSize\n");
        return FALSE;
    }
    g_HstiBufferPointer = SymLookup("ntoskrnl.exe", "SepHSTIResultsBuffer");
    if (g_HstiBufferPointer == NULL)
    {
        printf("[-] Failed to find nt!SepHSTIResultsBuffer\n");
        return FALSE;
    }
    g_TrampolineFunction = SymLookup("ntoskrnl.exe", "PopFanIrpComplete");
    if (g_TrampolineFunction == NULL)
    {
        printf("[-] Failed to find nt!PopFanIrpComplete\n");
        return FALSE;
    }
    return TRUE;
}

```

`r0akutil.c`:

```c
/*++

Copyright (c) Alex Ionescu.  All rights reserved.

Module Name:

    r0akutil.c

Abstract:

    This module implements utility functions for r0ak

Author:

    Alex Ionescu (@aionescu) 21-Jul-2018 - First public version

Environment:

    User mode only.

--*/

#include "r0ak.h"

VOID
DumpHex (
    _In_ LPCVOID Data,
    _In_ SIZE_T Size
    )
{
    CHAR ascii[17];
    SIZE_T i, j;

    //
    // Parse each byte in the stream
    //
    ascii[16] = ANSI_NULL;
    for (i = 0; i < Size; ++i)
    {
        //
        // Every new line, print a TAB
        //
        if ((i % 16) == 0)
        {
            printf("\t");
        }

        //
        // Print the hex representation of the data
        //
        printf("%02X", ((PUCHAR)Data)[i]);

        //
        // And as long as this isn't the middle dash, print a space
        //
        if ((i + 1) % 16 != 8)
        {
            printf(" ");
        }
        else
        {
            printf("-");
        }

        //
        // Is this a printable character? If not, use a '.' to represent it
        //
        if (isprint(((PUCHAR)Data)[i]))
        {
            ascii[i % 16] = ((PUCHAR)Data)[i];
        }
        else
        {
            ascii[i % 16] = '.';
        }

        //
        // Is this end of the line? If so, print it out
        //
        if (((i + 1) % 16) == 0)
        {
            printf(" %s\n", ascii);
        }

        if ((i + 1) == Size)
        {
            //
            // We've reached the end of the buffer, keep printing spaces
            // until we get to the end of the line
            //
            ascii[(i + 1) % 16] = ANSI_NULL;
            for (j = ((i + 1) % 16); j < 16; j++)
            {
                printf("   ");
            }

            printf(" %s\n", ascii);
        }
    }
}

_Success_(return != 0)
ULONG_PTR
GetDriverBaseAddr (
    _In_ PCCH BaseName
    )
{
    LPVOID BaseAddresses[1024];
    DWORD cbNeeded;
    CHAR FileName[MAX_PATH];

    //
    // Enumerate all the device drivers
    //
    if (!EnumDeviceDrivers(BaseAddresses, sizeof(BaseAddresses), &cbNeeded))
    {
        printf("[-] Failed to enumerate driver base addresses: %lx\n",
               GetLastError());
        return 0;
    }

    //
    // Go through each one
    //
    for (int i = 0; i < (cbNeeded / sizeof(LPVOID)); i++)
    {
        //
        // Get its name
        //
        if (!GetDeviceDriverBaseNameA(BaseAddresses[i],
                                      FileName,
                                      sizeof(FileName)))
        {
            printf("[-] Failed to get driver name: %lx\n",
                   GetLastError());
            return 0;
        }

        //
        // Compare it
        //
        if (!_stricmp(FileName, BaseName))
        {
            return (ULONG_PTR)BaseAddresses[i];
        }
    }
    return 0;
}

_Success_(return != 0)
BOOL
ElevateToSystem (
    VOID
    )
{
    HANDLE hProcess;
    HANDLE hToken, hNewtoken;
    HANDLE hSnapshot;
    DWORD logonPid;
    BOOL b;
    PROCESSENTRY32W processEntry;
    BOOLEAN old;
    NTSTATUS status;

    //
    // Create toolhelp snaapshot
    //
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == NULL)
    {
        printf("[-] Failed to initialize toolhelp snapshot: %lx\n",
               GetLastError());
        return FALSE;
    }

    //
    // Scan process list
    //
    logonPid = 0;
    processEntry.dwSize = sizeof(processEntry);
    Process32First(hSnapshot, &processEntry);
    do
    {
        //
        // Look for winlogon
        //
        if (wcsstr(processEntry.szExeFile, L"winlogon.exe") != NULL)
        {
            //
            // Found it
            //
            logonPid = processEntry.th32ProcessID;
            break;
        }
    } while (Process32Next(hSnapshot, &processEntry) != 0);

    //
    // Fail it not found
    //
    if (logonPid == 0)
    {
        printf("[-] Couldn't find Winlogon.exe\n");
        return FALSE;
    }

    //
    // Enable debug privileges, so that we may open the processes we need
    //
    status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE, TRUE, FALSE, &old);
    if (!NT_SUCCESS(status))
    {
        printf("[-] Failed to get SE_DEBUG_PRIVILEGE: %lx\n",
               status);
        return FALSE;
    }

    //
    // Open handle to it
    //
    hProcess = OpenProcess(MAXIMUM_ALLOWED, FALSE, logonPid);
    if (hProcess == NULL)
    {
        printf("[-] Failed to open handle to Winlogon: %lx\n",
               GetLastError());
        return FALSE;
    }

    //
    // Open winlogon's token
    //
    b = OpenProcessToken(hProcess, MAXIMUM_ALLOWED, &hToken);
    if (b == 0)
    {
        printf("[-] Failed to open Winlogon Token: %lx\n",
               GetLastError());
        return b;
    }

    //
    // Make an impersonation token copy out of it
    //
    b = DuplicateToken(hToken, SecurityImpersonation, &hNewtoken);
    if (b == 0)
    {
        printf("[-] Failed to duplicate Winlogon Token: %lx\n",
               GetLastError());
        return b;
    }

    //
    // And assign it as our thread token
    //
    b = SetThreadToken(NULL, hNewtoken);
    if (b == 0)
    {
        printf("[-] Failed to impersonate Winlogon Token: %lx\n",
               GetLastError());
        return b;
    }

    //
    // Close the handle to wininit, its token, and our copy
    //
    CloseHandle(hProcess);
    CloseHandle(hToken);
    CloseHandle(hNewtoken);
    return TRUE;
}

```

`r0akwr.c`:

```c
/*++

Copyright (c) Alex Ionescu.  All rights reserved.

Module Name:

    r0akwr.c

Abstract:

    This module implements write capabilities for r0ak

Author:

    Alex Ionescu (@aionescu) 21-Jul-2018 - First public version

Environment:

    User mode only.

--*/

#include "r0ak.h"

typedef enum _XM_OPERATION_DATATYPE
{
    BYTE_DATA = 0,
    WORD_DATA = 1,
    LONG_DATA = 3
} XM_OPERATION_DATATYPE;

typedef struct _XM_CONTEXT
{
    UCHAR Reserved[0x58];
    PVOID DestinationPointer;
    PVOID SourcePointer;
    ULONG DestinationValue;
    ULONG SourceValue;
    ULONG CurrentOpcode;
    ULONG DataSegment;
    ULONG DataType;
} XM_CONTEXT, *PXM_CONTEXT;

_Success_(return != 0)
BOOL
CmdWriteKernel (
    _In_ PKERNEL_EXECUTE KernelExecute,
    _In_ PVOID KernelAddress,
    _In_ ULONG KernelValue
    )
{
    PKERNEL_ALLOC kernelAlloc;
    PXM_CONTEXT xmContext;
    BOOL b;
    PETW_DATA etwData;

    //
    // Trace operation
    //
    printf("[+] Writing 0x%.8lX to                                0x%.16p\n",
           KernelValue, KernelAddress);

    //
    // Allocate an XM_CONTEXT to drive the HAL x64 emulator
    //
    kernelAlloc = NULL;
    xmContext = KernelAlloc(&kernelAlloc, sizeof(*xmContext));
    if (xmContext == NULL)
    {
        printf("[-] Failed to allocate memory for XM_CONTEXT\n");
        return FALSE;
    }

    //
    // Fill it out
    //
    xmContext->SourceValue = KernelValue;
    xmContext->DataType = LONG_DATA;
    xmContext->DestinationPointer = KernelAddress;

    //
    // Make a kernel copy of it
    //
    xmContext = KernelWrite(kernelAlloc);
    if (xmContext == NULL)
    {
        printf("[-] Failed to find kernel memory for XM_CONTEXT\n");
        KernelFree(kernelAlloc);
        return FALSE;
    }

    //
    // Setup the work item
    //
    b = KernelExecuteSetCallback(KernelExecute,
                                 g_XmFunction,
                                 xmContext->Reserved);
    if (b == FALSE)
    {
        printf("[-] Failed to initialize work item!\n");
        KernelFree(kernelAlloc);
        return b;
    }

    //
    // Begin ETW tracing to look for the work item executing
    //
    etwData = NULL;
    b = EtwStartSession(&etwData, g_XmFunction);
    if (b == FALSE)
    {
        printf("[-] Failed to start ETW trace\n");
        KernelFree(kernelAlloc);
        return b;
    }

    //
    // Run it!
    //
    b = KernelExecuteRun(KernelExecute);
    if (b == FALSE)
    {
        printf("[-] Failed to execute kernel function!\n");
    }
    else
    {
        //
        // Wait for execution to finish
        //
        b = EtwParseSession(etwData);
        if (b == FALSE)
        {
            //
            // We have no idea if execution finished -- block forever
            //
            printf("[-] Failed to parse ETW trace\n");
            Sleep(INFINITE);
            return b;
        }
    }

    //
    // Free the allocation since this path either failed or completed execution
    //
    KernelFree(kernelAlloc);
    return b;
}

```