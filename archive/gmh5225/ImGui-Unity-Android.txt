Project Path: arc_gmh5225_ImGui-Unity-Android_tfkgrnx7

Source Tree:

```txt
arc_gmh5225_ImGui-Unity-Android_tfkgrnx7
├── app
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       ├── androidTest
│       │   └── java
│       │       └── id
│       │           └── akn
│       │               └── imguiunitytouch
│       │                   └── ExampleInstrumentedTest.java
│       ├── main
│       │   ├── AndroidManifest.xml
│       │   ├── cpp
│       │   │   ├── CMakeLists.txt
│       │   │   ├── LIBS
│       │   │   │   ├── And64InlineHook
│       │   │   │   ├── BNM
│       │   │   │   ├── Dobby
│       │   │   │   ├── KittyMemory
│       │   │   │   │   ├── KittyArm64.cpp
│       │   │   │   │   ├── KittyArm64.h
│       │   │   │   │   ├── KittyMemory.cpp
│       │   │   │   │   ├── KittyMemory.h
│       │   │   │   │   ├── KittyScanner.cpp
│       │   │   │   │   ├── KittyScanner.h
│       │   │   │   │   ├── KittyUtils.cpp
│       │   │   │   │   ├── KittyUtils.h
│       │   │   │   │   ├── MemoryBackup.cpp
│       │   │   │   │   ├── MemoryBackup.h
│       │   │   │   │   ├── MemoryPatch.cpp
│       │   │   │   │   └── MemoryPatch.h
│       │   │   │   ├── Substrate
│       │   │   │   │   ├── Buffer.hpp
│       │   │   │   │   ├── CydiaSubstrate.h
│       │   │   │   │   ├── SubstrateARM.hpp
│       │   │   │   │   ├── SubstrateDebug.cpp
│       │   │   │   │   ├── SubstrateDebug.hpp
│       │   │   │   │   ├── SubstrateHook.cpp
│       │   │   │   │   ├── SubstrateHook.h
│       │   │   │   │   ├── SubstrateLog.hpp
│       │   │   │   │   ├── SubstratePosixMemory.cpp
│       │   │   │   │   ├── SubstrateX86.hpp
│       │   │   │   │   ├── SymbolFinder.cpp
│       │   │   │   │   ├── SymbolFinder.h
│       │   │   │   │   ├── hde64.c
│       │   │   │   │   ├── hde64.h
│       │   │   │   │   └── table64.h
│       │   │   │   └── imgui
│       │   │   ├── MENU.hpp
│       │   │   ├── Misc
│       │   │   │   ├── ImGuiUtils.h
│       │   │   │   ├── JNIHooks.h
│       │   │   │   ├── JNIUtils.hpp
│       │   │   │   ├── Utils.h
│       │   │   │   ├── log.h
│       │   │   │   └── obfuscate.h
│       │   │   └── native-lib.cpp
│       │   ├── java
│       │   │   └── id
│       │   │       └── akn
│       │   │           └── imguiunitytouch
│       │   │               └── MainActivity.java
│       │   └── res
│       │       ├── drawable
│       │       │   └── ic_launcher_background.xml
│       │       ├── drawable-v24
│       │       │   └── ic_launcher_foreground.xml
│       │       ├── layout
│       │       │   └── activity_main.xml
│       │       ├── mipmap-anydpi-v26
│       │       │   ├── ic_launcher.xml
│       │       │   └── ic_launcher_round.xml
│       │       ├── mipmap-hdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-mdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xxhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── mipmap-xxxhdpi
│       │       │   ├── ic_launcher.webp
│       │       │   └── ic_launcher_round.webp
│       │       ├── values
│       │       │   ├── colors.xml
│       │       │   └── strings.xml
│       │       └── xml
│       │           ├── backup_rules.xml
│       │           └── data_extraction_rules.xml
│       └── test
│           └── java
│               └── id
│                   └── akn
│                       └── imguiunitytouch
│                           └── ExampleUnitTest.java
├── build.gradle
├── build_so.ps1
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
└── settings.gradle

```

`app/build.gradle`:

```gradle
plugins {
    id 'com.android.application'
}

android {
    compileSdk 32

    defaultConfig {
        applicationId "id.akn.imguiunitytouch"
        minSdk 21
        targetSdk 32
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        externalNativeBuild {
            ndk {
                abiFilters 'armeabi-v7a', 'arm64-v8a'
            }
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    externalNativeBuild {
        cmake {
            path file('src/main/cpp/CMakeLists.txt')
            version '3.18.1'
        }
    }
    buildFeatures {
        viewBinding true
        prefab true
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'io.github.vvb2060.ndk:curl:7.85.1'
}
```

`app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

`app/src/androidTest/java/id/akn/imguiunitytouch/ExampleInstrumentedTest.java`:

```java
package id.akn.imguiunitytouch;

import android.content.Context;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import static org.junit.Assert.*;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Test
    public void useAppContext() {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
        assertEquals("id.akn.imguiunitytouch", appContext.getPackageName());
    }
}
```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="id.akn.imguiunitytouch">

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        tools:targetApi="31">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

`app/src/main/cpp/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.18.1)

project("ModMenu")

set(CMAKE_CXX_FLAGS "-O3 -w -s -Wno-error=format-security -fvisibility=hidden -Werror -std=c++17 -Wno-error=c++11-narrowing -fpermissive -Wall -fexceptions")
set(CMAKE_C_FLAGS "-O3 -w -s -Wno-error=format-security -fvisibility=hidden -fpermissive -fexceptions")

set(DOBBY_DIR ${CMAKE_SOURCE_DIR}/LIBS/Dobby)

# Dobby Options
option(DOBBY_GENERATE_SHARED "Build shared library" ON)
option(DOBBY_DEBUG "Enable debug logging" OFF)
option(NearBranch "Enable near branch trampoline" ON)
option(FullFloatingPointRegisterPack "Save and pack all floating-point registers" OFF)
option(Plugin.SymbolResolver "Enable symbol resolver" ON)
option(Plugin.ImportTableReplace "Enable import table replace " ON)
option(Plugin.Android.BionicLinkerUtil "Enable android bionic linker util" ON)
option(BUILD_EXAMPLE "Build example" OFF)
option(BUILD_TEST "Build test" OFF)

include_directories(
        LIBS/imgui LIBS/imgui/backends LIBS/KittyMemory
        LIBS/BNM LIBS/Substrate LIBS/And64InlineHook
        Misc
)

add_library(
        ModMenu

        SHARED

        native-lib.cpp

        # ImGui
        LIBS/imgui/imgui.cpp
        LIBS/imgui/imgui_draw.cpp
        LIBS/imgui/imgui_tables.cpp
        LIBS/imgui/imgui_widgets.cpp
        LIBS/imgui/backends/imgui_impl_android.cpp
        LIBS/imgui/backends/imgui_impl_opengl3.cpp

        # KittyMemory
        LIBS/KittyMemory/KittyArm64.cpp
        LIBS/KittyMemory/KittyMemory.cpp
        LIBS/KittyMemory/KittyScanner.cpp
        LIBS/KittyMemory/MemoryBackup.cpp
        LIBS/KittyMemory/KittyUtils.cpp
        LIBS/KittyMemory/MemoryPatch.cpp

        # ByNameModding
        LIBS/BNM/ByNameModding/BNM.cpp

        # Substrate
        LIBS/Substrate/hde64.c
        LIBS/Substrate/SubstrateDebug.cpp
        LIBS/Substrate/SubstrateHook.cpp
        LIBS/Substrate/SubstratePosixMemory.cpp
        LIBS/Substrate/SymbolFinder.cpp

        LIBS/And64InlineHook/And64InlineHook.cpp
)

target_include_directories(ModMenu PRIVATE
        ${ANDROID_NDK}/sources/android/native_app_glue)

if(NOT TARGET dobby)
    macro(SET_OPTION option value)
        set(${option} ${value} CACHE INTERNAL "" FORCE)
    endmacro()
    SET_OPTION(DOBBY_DEBUG OFF)
    SET_OPTION(DOBBY_GENERATE_SHARED OFF)
    add_subdirectory(${DOBBY_DIR} dobby)
    get_property(DOBBY_INCLUDE_DIRECTORIES
            TARGET dobby
            PROPERTY INCLUDE_DIRECTORIES)
    include_directories(
            .
            ${DOBBY_INCLUDE_DIRECTORIES}
            $<TARGET_PROPERTY:dobby,INCLUDE_DIRECTORIES>
    )
endif()

target_link_libraries(
        ${PROJECT_NAME}
        log
        dobby
        android
        EGL
        GLESv1_CM
        GLESv2
        GLESv3
)
```

`app/src/main/cpp/LIBS/KittyMemory/KittyArm64.cpp`:

```cpp
#include "KittyArm64.h"

// refs to
// https://github.com/CAS-Atlantic/AArch64-Encoding
// https://github.com/bminor/binutils-gdb
// https://github.com/capstone-engine/capstone
// https://github.com/qemu/QEMU
// https://reverseengineering.stackexchange.com/questions/15418/getting-function-address-by-reading-adrp-and-add-instruction-values
// https://stackoverflow.com/questions/41906688/what-are-the-semantics-of-adrp-and-adrl-instructions-in-arm-assembly

namespace KittyArm64
{

	int32_t bit_from(uint32_t insn, int pos)
	{
		return ((1 << pos) & insn) >> pos;
	}

	int32_t bits_from(uint32_t insn, int pos, int l)
	{
		return (insn >> pos) & ((1 << l) - 1);
	}

	bool is_insn_adr(uint32_t insn)
	{
		return (insn & 0x9F000000) == 0x10000000;
	}

	bool is_insn_adrp(uint32_t insn)
	{
		return (insn & 0x9F000000) == 0x90000000;
	}

	// decode adr/adrp
	bool decode_adr_imm(uint32_t insn, int64_t *imm)
	{
		if (is_insn_adr(insn) || is_insn_adrp(insn))
		{
			// 21-bit imm encoded in adrp.
			int64_t imm_val = bits_from(insn, 5, 19) << 2; // immhi
			imm_val |= bits_from(insn, 29, 2);			   // immlo

			if (is_insn_adrp(insn))
			{
				// Retrieve msb of 21-bit-signed imm for sign extension.
				uint64_t msbt = (imm_val >> 20) & 1;
				
				// Real value is imm multiplied by 4k. Value now has 33-bit information.
				imm_val <<= 12;

				// Sign extend to 64-bit by repeating msbt 31 (64-33) times and merge it
				// with value.
				*imm = ((((uint64_t)(1) << 32) - msbt) << 33) | imm_val;
			}
			else // adr
			{
				// Sign-extend the 21-bit immediate.
				if (imm_val & (1 << (21 - 1)))
					imm_val |= ~((1LL << 21) - 1);

				*imm = imm_val;
			}

			return true;
		}

		return false;
	}

	/*
	 *  31 30 29 28         23 22 21         10 9   5 4   0
	 * +--+--+--+-------------+--+-------------+-----+-----+
	 * |sf|op| S| 1 0 0 0 1 0 |sh|    imm12    |  Rn | Rd  |
	 * +--+--+--+-------------+--+-------------+-----+-----+
	 *
	 *    sf: 0 -> 32bit, 1 -> 64bit
	 *    op: 0 -> add  , 1 -> sub
	 *     S: 1 -> set flags
	 *    sh: 1 -> LSL imm by 12
	 */

	int32_t decode_addsub_imm(uint32_t insn)
	{
		int32_t imm12 = bits_from(insn, 10, 12);

		bool shift = bit_from(insn, 22) == 1;

		if (shift)
		{
			imm12 <<= 12;
		}

		return imm12;
	}

	bool is_insn_ld(uint32_t insn)
	{
		// L bit
		return bit_from(insn, 22) == 1;
	}

	bool is_insn_ldst(uint32_t insn)
	{
		return (insn & 0x0a000000) == 0x08000000;
	}

	bool is_insn_ldst_uimm(uint32_t insn)
	{
		return (insn & 0x3b000000) == 0x39000000;
	}

	// decode Load/store unsigned immediate
	bool decode_ldrstr_uimm(uint32_t insn, int32_t *imm12)
	{
		if (is_insn_ldst_uimm(insn))
		{
			*imm12 = bits_from(insn, 10, 12);
			// shift with scale value
			*imm12 <<= bits_from(insn, 30, 2); // size bits

			return true;
		}

		return false;
	}

}
```

`app/src/main/cpp/LIBS/KittyMemory/KittyArm64.h`:

```h
#pragma once

#include <cstdio>
#include <cstdint>
#include <string>

namespace KittyArm64
{

	int32_t bit_from(uint32_t insn, int pos);

	int32_t bits_from(uint32_t insn, int pos, int l);

	bool is_insn_adr(uint32_t insn);

	bool is_insn_adrp(uint32_t insn);

	bool decode_adr_imm(uint32_t insn, int64_t *imm);

	int32_t decode_addsub_imm(uint32_t insn);

	bool is_insn_ld(uint32_t insn);

	bool is_insn_ldst(uint32_t insn);

	bool is_insn_ldst_uimm(uint32_t insn);

	bool decode_ldrstr_uimm(uint32_t insn, int32_t *offset);

}
```

`app/src/main/cpp/LIBS/KittyMemory/KittyMemory.cpp`:

```cpp
//
//  KittyMemory.cpp
//
//  Created by MJ (Ruit) on 1/1/19.
//

#include "KittyMemory.h"
#include <map>
#include <android/log.h>

namespace KittyMemory {

    int setAddressProtection(void *address, size_t length, int protection) {
        uintptr_t pageStart = _PAGE_START_OF_(address);
        uintptr_t pageLen = _PAGE_LEN_OF_(address, length);
        int ret = mprotect(reinterpret_cast<void *>(pageStart), pageLen, protection);
        KITTY_LOGI("mprotect(%p, %zu, %d) = %d", address, length, protection, ret);
        return ret;
    }

    bool memWrite(void *address, const void *buffer, size_t len) {
        KITTY_LOGI("memWrite(%p, %p, %zu)", address, buffer, len);

        if (!address) {
            KITTY_LOGE("memWrite err address (%p) is null", address);
            return false;
        }

        if (!buffer) {
            KITTY_LOGE("memWrite err buffer (%p) is null", buffer);
            return false;
        }

        if (len < 1 || len > INT_MAX) {
            KITTY_LOGE("memWrite err invalid len (%zu) < 1 || > INT_MAX", len);
            return false;
        }

        ProcMap addressMap = getAddressMap(address);
        if (!addressMap.isValid()) {
            KITTY_LOGE("memWrite err couldn't find address (%p) in any map", address);
            return false;
        }

        if (addressMap.protection & PROT_WRITE) {
            memcpy(address, buffer, len);
            return true;
        }

        if (setAddressProtection(address, len, addressMap.protection | PROT_WRITE) != 0) {
            KITTY_LOGE("memWrite err couldn't add write perm to address (%p, len: %zu, prot: %d)",
                            address, len, addressMap.protection);
            return false;
        }

        memcpy(address, buffer, len);

        if (setAddressProtection(address, len, addressMap.protection) != 0) {
            KITTY_LOGE("memWrite err couldn't revert protection of address (%p, len: %zu, prot: %d)",
                            address, len, addressMap.protection);
            return false;
        }

        return true;
    }

    bool memRead(void *address, const void *buffer, size_t len) {
        KITTY_LOGI("memRead(%p, %p, %zu)", address, buffer, len);

        if (!address) {
            KITTY_LOGE("memRead err address (%p) is null", address);
            return false;
        }

        if (!buffer) {
            KITTY_LOGE("memRead err buffer (%p) is null", buffer);
            return false;
        }

        if (len < 1 || len > INT_MAX) {
            KITTY_LOGE("memRead err invalid len (%zu) < 1 || > INT_MAX", len);
            return false;
        }

        memcpy(address, buffer, len);

        return true;
    }

    std::string read2HexStr(const void *address, size_t len) {
        std::string temp(len, ' ');
        if (!memRead(&temp[0], address, len)) return "";

        std::string ret(len * 2, ' ');
        for (int i = 0; i < len; i++) {
            sprintf(&ret[i * 2], "%02X", (unsigned char) temp[i]);
        }
        return ret;
    }

    std::vector<ProcMap> getAllMaps() {
        std::vector<ProcMap> retMaps;
        char line[512] = {0};

        FILE *fp = fopen("/proc/self/maps", "r");
        if (fp) {
            while (fgets(line, sizeof(line), fp)) {
                ProcMap map;

                char perms[5] = {0}, dev[11] = {0}, pathname[256] = {0};
                // parse a line in maps file
                // (format) startAddress-endAddress perms offset dev inode pathname
                sscanf(line, "%llx-%llx %s %llx %s %lu %s",
                       &map.startAddress, &map.endAddress,
                       perms, &map.offset, dev, &map.inode, pathname);

                map.length = map.endAddress - map.startAddress;
                map.dev = dev;
                map.pathname = pathname;

                if (perms[0] == 'r')
                {
                    map.protection |= PROT_READ;
                    map.readable = true;
                }
                if (perms[1] == 'w')
                {
                    map.protection |= PROT_WRITE;
                    map.writeable = true;
                }
                if (perms[2] == 'x')
                {
                    map.protection |= PROT_EXEC;
                    map.executable = true;
                }

                map.is_private = (perms[3] == 'p');
                map.is_shared = (perms[3] == 's');

                map.is_rx = (strncmp(perms, "r-x", 3) == 0);
                map.is_rw = (strncmp(perms, "rw-", 3) == 0);
                map.is_ro = (strncmp(perms, "r--", 3) == 0);

                retMaps.push_back(map);
            }
            fclose(fp);
        }

        if (retMaps.empty()) {
            KITTY_LOGE("getAllMaps err couldn't find any map");
        }
        return retMaps;
    }

    std::vector<ProcMap> getMapsByName(const std::string &name) {
        if (name.empty()) return {};

        KITTY_LOGI("getMapsByName(%s)", name.c_str());

        std::vector<ProcMap> retMaps;
        char line[512] = {0};

        FILE *fp = fopen("/proc/self/maps", "r");
        if (fp) {
            while (fgets(line, sizeof(line), fp)) {
                if (strstr(line, name.c_str())) {
                    ProcMap map;

                    char perms[5] = {0}, dev[11] = {0}, pathname[256] = {0};
                    // parse a line in maps file
                    // (format) startAddress-endAddress perms offset dev inode pathname
                    sscanf(line, "%llx-%llx %s %llx %s %lu %s",
                           &map.startAddress, &map.endAddress,
                           perms, &map.offset, dev, &map.inode, pathname);

                    map.length = map.endAddress - map.startAddress;
                    map.dev = dev;
                    map.pathname = pathname;

                    if (perms[0] == 'r')
                    {
                        map.protection |= PROT_READ;
                        map.readable = true;
                    }
                    if (perms[1] == 'w')
                    {
                        map.protection |= PROT_WRITE;
                        map.writeable = true;
                    }
                    if (perms[2] == 'x')
                    {
                        map.protection |= PROT_EXEC;
                        map.executable = true;
                    }

                    map.is_private = (perms[3] == 'p');
                    map.is_shared = (perms[3] == 's');

                    map.is_rx = (strncmp(perms, "r-x", 3) == 0);
                    map.is_rw = (strncmp(perms, "rw-", 3) == 0);
                    map.is_ro = (strncmp(perms, "r--", 3) == 0);

                    retMaps.push_back(map);
                    // KITTY_LOGI("getMapsByName [%llx-%llx %s %llx %s %lu %s]",
                    // map.startAddress, map.endAddress, perms, map.offset,
                    // map.dev.empty() ? "null" : map.dev.c_str(),
                    // map.inode, map.pathname.empty() ? "null" : map.pathname.c_str());
                }
            }
            fclose(fp);
        }

        if (retMaps.empty()) {
            KITTY_LOGE("getMapsByName err couldn't find any map with name (%s)", name.c_str());
        }
        return retMaps;
    }

    ProcMap getAddressMap(const void *address) {
        KITTY_LOGI("getAddressMap(%p)", address);

        if (!address) return {};

        ProcMap map;
        char line[512] = {0};
        unsigned long long startAddress = 0, endAddress = 0;

        FILE *fp = fopen("/proc/self/maps", "r");
        if (fp) {
            while (fgets(line, sizeof(line), fp)) {
                sscanf(line, "%llx-%llx", &startAddress, &endAddress);
                if ((uintptr_t)address >= startAddress && (uintptr_t)address <= endAddress) {

                    char perms[5] = {0}, dev[11] = {0}, pathname[256] = {0};
                    // parse a line in maps file
                    // (format) startAddress-endAddress perms offset dev inode pathname
                    sscanf(line, "%*llx-%*llx %s %llx %s %lu %s",
                           perms, &map.offset, dev, &map.inode, pathname);

                    map.startAddress = startAddress;
                    map.endAddress = endAddress;
                    map.length = map.endAddress - map.startAddress;
                    map.dev = dev;
                    map.pathname = pathname;

                    if (perms[0] == 'r')
                    {
                        map.protection |= PROT_READ;
                        map.readable = true;
                    }
                    if (perms[1] == 'w')
                    {
                        map.protection |= PROT_WRITE;
                        map.writeable = true;
                    }
                    if (perms[2] == 'x')
                    {
                        map.protection |= PROT_EXEC;
                        map.executable = true;
                    }

                    map.is_private = (perms[3] == 'p');
                    map.is_shared = (perms[3] == 's');

                    map.is_rx = (strncmp(perms, "r-x", 3) == 0);
                    map.is_rw = (strncmp(perms, "rw-", 3) == 0);
                    map.is_ro = (strncmp(perms, "r--", 3) == 0);

                    // KITTY_LOGI("Address (%p) map = (%llx-%llx %s %llx %s %lu %s)", address,
                    // map.startAddress, map.endAddress, perms[0] == 0 ? "null" : perms,
                    // map.offset, map.dev.empty() ? "null" : map.dev.c_str(),
                    // map.inode, map.pathname.empty() ? "null" : map.pathname.c_str());

                    break;
                }
            }
            fclose(fp);
        }

        if (!map.isValid()) {
            KITTY_LOGE("getAddressMap err couldn't find any map with address (%p)",
                       address);
        }
        return map;
    }

    ProcMap getLibraryBaseMap(const std::vector<ProcMap>& maps) {
        if(maps.empty()) return {};

        ProcMap retMap = maps[0];
        if(retMap.is_rx && retMap.is_private) return retMap;
        // find the first map with r-xp, sometimes r--p map is found first.
        for (auto &curr_map: maps) {
            if(retMap.isValid() && curr_map.is_rx && retMap.is_private) {
                retMap = curr_map;
                break;
            }
        }
        return retMap;
    }

    ProcMap getLibraryBaseMap(const std::string& name) {
        return getLibraryBaseMap(getMapsByName(name));
    }

}
```

`app/src/main/cpp/LIBS/KittyMemory/KittyMemory.h`:

```h
//
//  KittyMemory.hpp
//
//  Created by MJ (Ruit) on 1/1/19.
//

#pragma once

#include <stdio.h>
#include <string>
#include <unistd.h>
#include <sys/mman.h>
#include <vector>

#define _SYS_PAGE_SIZE_ (sysconf(_SC_PAGE_SIZE))

#define _PAGE_START_OF_(x) ((uintptr_t)x & ~(uintptr_t)(_SYS_PAGE_SIZE_ - 1))
#define _PAGE_END_OF_(x, len) (_PAGE_START_OF_((uintptr_t)x + len - 1))
#define _PAGE_LEN_OF_(x, len) (_PAGE_END_OF_(x, len) - _PAGE_START_OF_(x) + _SYS_PAGE_SIZE_)
#define _PAGE_OFFSET_OF_(x) ((uintptr_t)x - _PAGE_START_OF_(x))

#define EMPTY_VEC_OFFSET std::vector<int>()

#ifdef kITTYMEMORY_DEBUG
#include <android/log.h>
#define KITTY_LOGI(...) ((void)__android_log_print(4, "KittyMemory", __VA_ARGS__))
#define KITTY_LOGE(...) ((void)__android_log_print(6, "KittyMemory", __VA_ARGS__))
#else
#define KITTY_LOGI(...)
#define KITTY_LOGE(...)
#endif

namespace KittyMemory
{

    class ProcMap {
    public:
        unsigned long long startAddress;
        unsigned long long endAddress;
        size_t length;
        int protection;
        bool readable, writeable, executable, is_private, is_shared, is_ro, is_rw, is_rx;
        unsigned long long offset;
        std::string dev;
        unsigned long inode;
        std::string pathname;

        ProcMap() : startAddress(0), endAddress(0), length(0), protection(0),
                    is_private(false), is_shared(false),
                    readable(false), writeable(false), executable(false),
                    is_ro(false), is_rw(false), is_rx(false),
                    offset(0), inode(0) {}

        inline bool isValid() const { return (length > 0); }
        inline bool isUnknown() const { return pathname.empty(); }
    };

    /*
     * mprotect wrapper
     */
    int setAddressProtection(void *address, size_t length, int protection);

    /*
     * Writes buffer content to an address
     */
    bool memWrite(void *address, const void *buffer, size_t len);

    /*
     * Reads an address content into a buffer
     */
    bool memRead(void *buffer, const void *address, size_t len);

    /*
     * Reads an address content and returns hex string
     */
    std::string read2HexStr(const void *address, size_t len);

    /*
     * Gets info of all maps in self process
     */
    std::vector<ProcMap> getAllMaps();

    /*
     * Gets info of all maps which contain "name" in self process
     */
    std::vector<ProcMap> getMapsByName(const std::string& name);

    /*
     * Gets map info of an address in self process
     */
    ProcMap getAddressMap(const void *address);

    /*
     * Gets first r-xp map of a library
     */
    ProcMap getLibraryBaseMap(const std::vector<ProcMap>& maps);
    ProcMap getLibraryBaseMap(const std::string& name);
}

```

`app/src/main/cpp/LIBS/KittyMemory/KittyScanner.cpp`:

```cpp
#include "KittyScanner.h"

#include "KittyMemory.h"
#include "KittyUtils.h"

using KittyMemory::ProcMap;

// refs
// https://github.com/learn-more/findpattern-bench

namespace KittyScanner
{

    bool compare(const char *data, const char *pattern, const char *mask)
    {
        for (; *mask; ++mask, ++data, ++pattern)
        {
            if (*mask == 'x' && *data != *pattern)
                return false;
        }
        return !*mask;
    }

    uintptr_t find(const uintptr_t start, uintptr_t end,
                   const char *pattern, const char *mask)
    {
        if (start >= end)
            return 0;

        const size_t mask_size = strlen(mask);
        const size_t size = end - start;

        for (size_t i = 0; i < size; ++i)
        {
            const uintptr_t current_end = start + i + mask_size;
            if (current_end > end)
                break;

            if (!compare(reinterpret_cast<const char *>(start + i), pattern, mask))
                continue;

            return start + i;
        }
        return 0;
    }

    std::vector<uintptr_t> findBytesAll(const KittyMemory::ProcMap &map,
                                        const char *pattern, const char *mask)
    {
        std::vector<uintptr_t> list;

        if (!map.isValid())
            return list;

        uintptr_t curr_search_address = map.startAddress;
        size_t size = strlen(mask);
        do {
            if (!list.empty()) curr_search_address = list.back() + size;
            
            uintptr_t found = find(curr_search_address, map.endAddress, pattern, mask);
            if (!found) break;

            list.push_back(found);
        } while (true);

        return list;
    }

    uintptr_t findBytesFirst(const KittyMemory::ProcMap &map, const char *pattern, const char *mask)
    {
        if (!map.isValid() || !pattern || !mask || map.length < strlen(mask))
            return 0;

        return find(map.startAddress, map.endAddress, pattern, mask);
    }


    std::vector<uintptr_t> findHexAll(const KittyMemory::ProcMap& map, std::string hex, const char *mask)
	{
        std::vector<uintptr_t> list;
        
        if (!map.isValid() || !mask || !KittyUtils::validateHexString(hex)) return list;

        size_t size = strlen(mask);
        if((hex.length() / 2) != size) return list;
        
        std::vector<char> pattern(size);
        KittyUtils::fromHex(hex, &pattern[0]);

        list = findBytesAll(map, pattern.data(), mask);
        return list;
    }

    uintptr_t findHexFirst(const KittyMemory::ProcMap& map, std::string hex, const char *mask)
	{        
        if (!map.isValid() || !mask || !KittyUtils::validateHexString(hex)) return 0;

        size_t size = strlen(mask);
        if((hex.length() / 2) != size) return 0;
        
        std::vector<char> pattern(size);
        KittyUtils::fromHex(hex, &pattern[0]);

        return findBytesFirst(map, pattern.data(), mask);
    }


    std::vector<uintptr_t> findDataAll(const KittyMemory::ProcMap &map, const void *data, size_t size)
    {
        std::vector<uintptr_t> list;

        if (!map.isValid())
            return list;

        std::string mask(size, 'x');
        uintptr_t curr_search_address = map.startAddress;
        do {
            if (!list.empty()) curr_search_address = list.back() + size;

            uintptr_t found = find(curr_search_address, map.endAddress, (const char *)data, mask.c_str());
            if (!found) break;

            list.push_back(found);
        } while (true);

        return list;
    }

    uintptr_t findDataFirst(const KittyMemory::ProcMap &map, const void *data, size_t size)
    {
        if (!map.isValid())
            return 0;

        std::string mask(size, 'x');

        return find(map.startAddress, map.endAddress, (const char *)data, mask.c_str());
    }

    RegisterNativeFn findRegisterNativeFn(const std::vector<KittyMemory::ProcMap> &maps, const std::string &name)
    {
        uintptr_t string_loc = 0, string_xref = 0, fn_loc = 0;
        RegisterNativeFn fn = { nullptr, nullptr, nullptr };

        if (name.empty() || maps.empty())
            return fn;
        
        for (auto &it : maps)  {
            if (it.is_rx) {
                string_loc = KittyScanner::findDataFirst(it, name.data(), name.length());
                if (string_loc) break;
            }
        }

        if (!string_loc) {
            KITTY_LOGE("couldn't find string (%s) in selected maps", name.c_str());
            return fn;
        }

        KITTY_LOGI("string (%s) at %p", name.c_str(), (void*)string_loc);

        for (auto &it : maps) {
            if (it.is_rw) {
                string_xref = KittyScanner::findDataFirst(it, &string_loc, sizeof(uintptr_t));
                if (!string_xref) continue;

                KITTY_LOGI("string at (%p) referenced at %p", (void *)string_loc, (void *)string_xref);
                
                fn_loc = string_xref;
            }
        }

        if(!fn_loc) return fn;

        memcpy(&fn, (void *)fn_loc, sizeof(RegisterNativeFn));
        return fn;
    }

}
```

`app/src/main/cpp/LIBS/KittyMemory/KittyScanner.h`:

```h
#pragma once

#include <string>
#include <cstdint>
#include <vector>

#include "KittyMemory.h"

namespace KittyScanner
{
    class RegisterNativeFn
    {
    public:
        char *name;
        char *signature;
        void *fnPtr;
        inline bool isValid() const { return name != nullptr && signature != nullptr && fnPtr != nullptr; }
    };

    bool compare(const char *data, const char *pattern, const char *mask);

    uintptr_t find(const uintptr_t start, const size_t end, const char *pattern, const char *mask);

    // scan for direct bytes and return first result
    std::vector<uintptr_t> findBytesAll(const KittyMemory::ProcMap& map, const char *pattern, const char *mask);
    // scan for direct bytes and return all result
    uintptr_t findBytesFirst(const KittyMemory::ProcMap& map, const char *pattern, const char *mask);

    // scan for hex bytes and return first result
    std::vector<uintptr_t> findHexAll(const KittyMemory::ProcMap& map, std::string hex, const char *mask);
    // scan for hex bytes and return all result
    uintptr_t findHexFirst(const KittyMemory::ProcMap& map, std::string hex, const char *mask);

    // scan for data and return first result
    std::vector<uintptr_t> findDataAll(const KittyMemory::ProcMap &map, const void *data, size_t size);
    // scan for data and return all result
    uintptr_t findDataFirst(const KittyMemory::ProcMap &map, const void *data, size_t size);

    // search for string "name" references to find the JNINativeMethod array
    RegisterNativeFn findRegisterNativeFn(const std::vector<KittyMemory::ProcMap> &maps, const std::string &name);

}
```

`app/src/main/cpp/LIBS/KittyMemory/KittyUtils.cpp`:

```cpp
#include "KittyUtils.h"

#include <sstream>
#include <iomanip>

static void xtrim(std::string &hex) {
    if (hex.compare(0, 2, "0x") == 0) {
        hex.erase(0, 2);
    }

    // https://www.techiedelight.com/remove-whitespaces-string-cpp/
    hex.erase(std::remove_if(hex.begin(), hex.end(), [](char c) {
                  return (c == ' ' || c == '\n' || c == '\r' ||
                          c == '\t' || c == '\v' || c == '\f');
              }),
              hex.end());
}

namespace KittyUtils {

    bool validateHexString(std::string &xstr) {
        if (xstr.length() < 2) return false;
        xtrim(xstr); // first remove spaces
        if (xstr.length() % 2 != 0) return false;
        for (size_t i = 0; i < xstr.length(); i++) {
            if (!std::isxdigit((unsigned char) xstr[i])) {
                return false;
            }
        }
        return true;
    }

    // https://tweex.net/post/c-anything-tofrom-a-hex-string/

    // ------------------------------------------------------------------
    /*!
        Convert a block of data to a hex string
    */
    void toHex(
            void *const data,        //!< Data to convert
            const size_t dataLength, //!< Length of the data to convert
            std::string &dest        //!< Destination string
    ) {
        unsigned char *byteData = reinterpret_cast<unsigned char *>(data);
        std::stringstream hexStringStream;

        hexStringStream << std::hex << std::setfill('0');
        for (size_t index = 0; index < dataLength; ++index)
            hexStringStream << std::setw(2) << static_cast<int>(byteData[index]);
        dest = hexStringStream.str();
    }

    // ------------------------------------------------------------------
    /*!
        Convert a hex string to a block of data
    */
    void fromHex(
            const std::string &in, //!< Input hex string
            void *const data       //!< Data store
    ) {
        size_t length = in.length();
        unsigned char *byteData = reinterpret_cast<unsigned char *>(data);

        std::stringstream hexStringStream;
        hexStringStream >> std::hex;
        for (size_t strIndex = 0, dataIndex = 0; strIndex < length; ++dataIndex) {
            // Read out and convert the string two characters at a time
            const char tmpStr[3] = {in[strIndex++], in[strIndex++], 0};

            // Reset and fill the string stream
            hexStringStream.clear();
            hexStringStream.str(tmpStr);

            // Do the conversion
            int tmpValue = 0;
            hexStringStream >> tmpValue;
            byteData[dataIndex] = static_cast<unsigned char>(tmpValue);
        }
    }
}
```

`app/src/main/cpp/LIBS/KittyMemory/KittyUtils.h`:

```h
#pragma once

#include <string>
#include <algorithm>

namespace KittyUtils {

    bool validateHexString(std::string &xstr);
    void toHex(void *const data, const size_t dataLength, std::string &dest);
    void fromHex(const std::string &in, void *const data);

}
```

`app/src/main/cpp/LIBS/KittyMemory/MemoryBackup.cpp`:

```cpp
//
//  MemoryBackup.cpp
//
//  Created by MJ (Ruit) on 4/19/20.
//

#include "MemoryBackup.h"


MemoryBackup::MemoryBackup()
{
  _address = 0;
  _size = 0;
  _orig_code.clear();
}

MemoryBackup::MemoryBackup(const ProcMap &map, uintptr_t address, size_t backup_size)
{
  _address = 0;
  _size = 0;
  _orig_code.clear();

  if (!map.isValid() || address == 0 || backup_size < 1)
    return;

  _address = map.startAddress+address;
  if (_address == 0)
    return;

  _size = backup_size;

  _orig_code.resize(backup_size);

  // backup current content
  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), backup_size);
}

MemoryBackup::MemoryBackup(uintptr_t absolute_address, size_t backup_size)
{
  _address = 0;
  _size = 0;
  _orig_code.clear();

  if (absolute_address == 0 || backup_size < 1)
    return;

  _address = absolute_address;

  _size = backup_size;

  _orig_code.resize(backup_size);

  // backup current content
  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), backup_size);
}

MemoryBackup::~MemoryBackup()
{
  // clean up
  _orig_code.clear();
}

bool MemoryBackup::isValid() const
{
  return (_address != 0 && _size > 0 && _orig_code.size() == _size);
}

size_t MemoryBackup::get_BackupSize() const
{
  return _size;
}

uintptr_t MemoryBackup::get_TargetAddress() const
{
  return _address;
}

bool MemoryBackup::Restore()
{
  if (!isValid()) return false;
  
  return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_orig_code[0], _size);
}

std::string MemoryBackup::get_CurrBytes()
{
  if (!isValid()) return "";
  
  return KittyMemory::read2HexStr(reinterpret_cast<const void *>(_address), _size);
}

std::string MemoryBackup::get_OrigBytes()
{
  if (!isValid()) return "";
  
  return KittyMemory::read2HexStr(_orig_code.data(), _orig_code.size());
}

```

`app/src/main/cpp/LIBS/KittyMemory/MemoryBackup.h`:

```h
//
//  MemoryBackup.h
//
//  Created by MJ (Ruit) on 4/19/20.
//

#pragma once

#include <vector>

#include "KittyMemory.h"

using KittyMemory::ProcMap;

class MemoryBackup
{
private:
    uintptr_t _address;
    size_t _size;

    std::vector<uint8_t> _orig_code;

public:
    MemoryBackup();

    /*
     * expects library name and relative address
     */
    MemoryBackup(const ProcMap &map, uintptr_t address, size_t backup_size);

    /*
     * expects absolute address
     */
    MemoryBackup(uintptr_t absolute_address, size_t backup_size);

    ~MemoryBackup();

    /*
     * Validate patch
     */
    bool isValid() const;

    size_t get_BackupSize() const;

    /*
     * Returns pointer to the target address
     */
    uintptr_t get_TargetAddress() const;

    /*
     * Restores backup code
     */
    bool Restore();

    /*
     * Returns current target address bytes as hex string
     */
    std::string get_CurrBytes();

    std::string get_OrigBytes();
};

```

`app/src/main/cpp/LIBS/KittyMemory/MemoryPatch.cpp`:

```cpp
//
//  MemoryPatch.cpp
//
//  Created by MJ (Ruit) on 1/1/19.
//

#include "MemoryPatch.h"
#include "KittyUtils.h"

MemoryPatch::MemoryPatch()
{
  _address = 0;
  _size = 0;
  _orig_code.clear();
  _patch_code.clear();
}

MemoryPatch::MemoryPatch(const ProcMap &map, uintptr_t address,
                         const void *patch_code, size_t patch_size)
{
  _address = 0;
  _size = 0;
  _orig_code.clear();
  _patch_code.clear();

  if (!map.isValid() || address == 0 || !patch_code || patch_size < 1)
    return;

  _address = map.startAddress+address;
  if (_address == 0)
    return;

  _size = patch_size;

  _orig_code.resize(patch_size);
  _patch_code.resize(patch_size);

  // initialize patch & backup current content
  KittyMemory::memRead(&_patch_code[0], patch_code, patch_size);
  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), patch_size);
}

MemoryPatch::MemoryPatch(uintptr_t absolute_address,
                         const void *patch_code, size_t patch_size)
{
  _address = 0;
  _size = 0;
  _orig_code.clear();
  _patch_code.clear();

  if (absolute_address == 0 || !patch_code || patch_size < 1)
    return;

  _address = absolute_address;
  _size = patch_size;

  _orig_code.resize(patch_size);
  _patch_code.resize(patch_size);

  // initialize patch & backup current content
  KittyMemory::memRead(&_patch_code[0], patch_code, patch_size);
  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), patch_size);
}

MemoryPatch::~MemoryPatch()
{
  // clean up
  _orig_code.clear();
  _patch_code.clear();
}

MemoryPatch MemoryPatch::createWithHex(const ProcMap &map, uintptr_t address,
                                       std::string hex)
{
  MemoryPatch patch;

  if (!map.isValid() || address == 0 || !KittyUtils::validateHexString(hex))
    return patch;

  patch._address = map.startAddress+address;
  if (patch._address == 0)
    return patch;

  patch._size = hex.length() / 2;

  patch._orig_code.resize(patch._size);
  patch._patch_code.resize(patch._size);

  // initialize patch
  KittyUtils::fromHex(hex, &patch._patch_code[0]);

  // backup current content
  KittyMemory::memRead(&patch._orig_code[0], reinterpret_cast<const void *>(patch._address), patch._size);
  return patch;
}

MemoryPatch MemoryPatch::createWithHex(uintptr_t absolute_address, std::string hex)
{
  MemoryPatch patch;

  if (absolute_address == 0 || !KittyUtils::validateHexString(hex))
    return patch;

  patch._address = absolute_address;
  patch._size = hex.length() / 2;

  patch._orig_code.resize(patch._size);
  patch._patch_code.resize(patch._size);

  // initialize patch
  KittyUtils::fromHex(hex, &patch._patch_code[0]);

  // backup current content
  KittyMemory::memRead(&patch._orig_code[0], reinterpret_cast<const void *>(patch._address), patch._size);
  return patch;
}

bool MemoryPatch::isValid() const
{
  return (_address != 0 && _size > 0 && _orig_code.size() == _size && _patch_code.size() == _size);
}

size_t MemoryPatch::get_PatchSize() const
{
  return _size;
}

uintptr_t MemoryPatch::get_TargetAddress() const
{
  return _address;
}

bool MemoryPatch::Restore()
{
  if (!isValid()) return false;
  return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_orig_code[0], _size);
}

bool MemoryPatch::Modify()
{
  if (!isValid()) return false;
  return (KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_patch_code[0], _size));
}

std::string MemoryPatch::get_CurrBytes()
{
  if (!isValid()) return "";
  
  return KittyMemory::read2HexStr(reinterpret_cast<const void *>(_address), _size);
}

std::string MemoryPatch::get_OrigBytes()
{
  if (!isValid()) return "";
  
  return KittyMemory::read2HexStr(_orig_code.data(), _orig_code.size());
}

std::string MemoryPatch::get_PatchBytes()
{
  if (!isValid()) return "";
  
  return KittyMemory::read2HexStr(_patch_code.data(), _patch_code.size());
}

```

`app/src/main/cpp/LIBS/KittyMemory/MemoryPatch.h`:

```h
//
//  MemoryPatch.h
//
//  Created by MJ (Ruit) on 1/1/19.
//

#pragma once

#include <vector>

#include "KittyMemory.h"

using KittyMemory::ProcMap;

class MemoryPatch
{
private:
    uintptr_t _address;
    size_t _size;

    std::vector<uint8_t> _orig_code;
    std::vector<uint8_t> _patch_code;

public:
    MemoryPatch();

    /*
     * expects library name and relative address
     */
    MemoryPatch(const ProcMap &map, uintptr_t address,
                const void *patch_code, size_t patch_size);

    /*
     * expects absolute address
     */
    MemoryPatch(uintptr_t absolute_address,
                const void *patch_code, size_t patch_size);

    ~MemoryPatch();

    /*
     * compatible hex format (0xffff & ffff & ff ff)
     */
    static MemoryPatch createWithHex(const ProcMap &map, uintptr_t address, std::string hex);
    static MemoryPatch createWithHex(uintptr_t absolute_address, std::string hex);

    /*
     * Validate patch
     */
    bool isValid() const;

    size_t get_PatchSize() const;

    /*
     * Returns pointer to the target address
     */
    uintptr_t get_TargetAddress() const;

    /*
     * Restores patch to original value
     */
    bool Restore();

    /*
     * Applies patch modifications to target address
     */
    bool Modify();

    /*
     * Returns current patch target address bytes as hex string
     */
    std::string get_CurrBytes();

    std::string get_OrigBytes();
    
    std::string get_PatchBytes();
};

```

`app/src/main/cpp/LIBS/Substrate/Buffer.hpp`:

```hpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_BUFFER_HPP
#define SUBSTRATE_BUFFER_HPP

#include <string.h>

template <typename Type_>
_disused static _finline void MSWrite(uint8_t *&buffer, Type_ value) {
    *reinterpret_cast<Type_ *>(buffer) = value;
    buffer += sizeof(Type_);
}

_disused static _finline void MSWrite(uint8_t *&buffer, uint8_t *data, size_t size) {
    memcpy(buffer, data, size);
    buffer += size;
}

#endif//SUBSTRATE_BUFFER_HPP

```

`app/src/main/cpp/LIBS/Substrate/CydiaSubstrate.h`:

```h
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_H_
#define SUBSTRATE_H_

#ifdef __APPLE__
#ifdef __cplusplus
extern "C" {
#endif
#include <mach-o/nlist.h>
#ifdef __cplusplus
}
#endif

#include <objc/runtime.h>
#include <objc/message.h>
#endif

#include <dlfcn.h>
#include <stdlib.h>

#define _finline \
    inline __attribute__((__always_inline__))
#define _disused \
    __attribute__((__unused__))

#define _extern \
    extern "C" __attribute__((__visibility__("default")))

#ifdef __cplusplus
#define _default(value) = value
#else
#define _default(value)
#endif

#ifdef __cplusplus
extern "C" {
#endif

bool MSHookProcess(pid_t pid, const char *library);

typedef const void *MSImageRef;

MSImageRef MSGetImageByName(const char *file);
void *MSFindSymbol(MSImageRef image, const char *name);

void MSHookFunction(void *symbol, void *replace, void **result);

#ifdef __APPLE__
#ifdef __arm__
__attribute__((__deprecated__))
IMP MSHookMessage(Class _class, SEL sel, IMP imp, const char *prefix _default(NULL));
#endif
void MSHookMessageEx(Class _class, SEL sel, IMP imp, IMP *result);
#endif

#ifdef SubstrateInternal
typedef void *SubstrateAllocatorRef;
typedef struct __SubstrateProcess *SubstrateProcessRef;
typedef struct __SubstrateMemory *SubstrateMemoryRef;

SubstrateProcessRef SubstrateProcessCreate(SubstrateAllocatorRef allocator, pid_t pid);
void SubstrateProcessRelease(SubstrateProcessRef process);

SubstrateMemoryRef SubstrateMemoryCreate(SubstrateAllocatorRef allocator, SubstrateProcessRef process, void *data, size_t size);
void SubstrateMemoryRelease(SubstrateMemoryRef memory);
#endif

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

#ifdef SubstrateInternal
struct SubstrateHookMemory {
    SubstrateMemoryRef handle_;

    SubstrateHookMemory(SubstrateProcessRef process, void *data, size_t size) :
        handle_(SubstrateMemoryCreate(NULL, NULL, data, size))
    {
    }

    ~SubstrateHookMemory() {
        if (handle_ != NULL)
            SubstrateMemoryRelease(handle_);
    }
};
#endif


template<typename Type_>
static inline void MSHookFunction(Type_ *symbol, Type_ *replace, Type_ **result) {
    MSHookFunction(
            reinterpret_cast<void *>(symbol),
            reinterpret_cast<void *>(replace),
            reinterpret_cast<void **>(result)
    );
}

template<typename Type_>
static inline void MSHookFunction(Type_ *symbol, Type_ *replace) {
    return MSHookFunction(symbol, replace, reinterpret_cast<Type_ **>(NULL));
}

template<typename Type_>
static inline void MSHookSymbol(Type_ *&value, const char *name, MSImageRef image = NULL) {
    value = reinterpret_cast<Type_ *>(MSFindSymbol(image, name));
}

template<typename Type_>
static inline void MSHookFunction(const char *name, Type_ *replace, Type_ **result = NULL) {
    Type_ *symbol;
    MSHookSymbol(symbol, name);
    return MSHookFunction(symbol, replace, result);
}

#endif

#define MSHook(type, name, args...) \
    _disused static type (*_ ## name)(args); \
    static type $ ## name(args)

#ifdef __cplusplus
#define MSHake(name) \
    &$ ## name, &_ ## name
#else
#define MSHake(name) \
    &$ ## name, (void **) &_ ## name
#endif


#endif//SUBSTRATE_H_

```

`app/src/main/cpp/LIBS/Substrate/SubstrateARM.hpp`:

```hpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_ARM_HPP
#define SUBSTRATE_ARM_HPP

enum A$r {
    A$r0, A$r1, A$r2, A$r3,
    A$r4, A$r5, A$r6, A$r7,
    A$r8, A$r9, A$r10, A$r11,
    A$r12, A$r13, A$r14, A$r15,
    A$sp = A$r13,
    A$lr = A$r14,
    A$pc = A$r15
};

enum A$c {
    A$eq, A$ne, A$cs, A$cc,
    A$mi, A$pl, A$vs, A$vc,
    A$hi, A$ls, A$ge, A$lt,
    A$gt, A$le, A$al,
    A$hs = A$cs,
    A$lo = A$cc
};

#define A$mrs_rm_cpsr(rd) /* mrs rd, cpsr */ \
    (0xe10f0000 | ((rd) << 12))
#define A$msr_cpsr_f_rm(rm) /* msr cpsr_f, rm */ \
    (0xe128f000 | (rm))
#define A$ldr_rd_$rn_im$(rd, rn, im) /* ldr rd, [rn, #im] */ \
    (0xe5100000 | ((im) < 0 ? 0 : 1 << 23) | ((rn) << 16) | ((rd) << 12) | abs((int)(im)))
#define A$str_rd_$rn_im$(rd, rn, im) /* sr rd, [rn, #im] */ \
    (0xe5000000 | ((im) < 0 ? 0 : 1 << 23) | ((rn) << 16) | ((rd) << 12) | abs(im))
#define A$sub_rd_rn_$im(rd, rn, im) /* sub, rd, rn, #im */ \
    (0xe2400000 | ((rn) << 16) | ((rd) << 12) | (im & 0xff))
#define A$blx_rm(rm) /* blx rm */ \
    (0xe12fff30 | (rm))
#define A$mov_rd_rm(rd, rm) /* mov rd, rm */ \
    (0xe1a00000 | ((rd) << 12) | (rm))
#define A$ldmia_sp$_$rs$(rs) /* ldmia sp!, {rs} */ \
    (0xe8b00000 | (A$sp << 16) | (rs))
#define A$stmdb_sp$_$rs$(rs) /* stmdb sp!, {rs} */ \
    (0xe9200000 | (A$sp << 16) | (rs))
#define A$stmia_sp$_$r0$  0xe8ad0001 /* stmia sp!, {r0}   */
#define A$bx_r0           0xe12fff10 /* bx r0             */

#endif//SUBSTRATE_ARM_HPP

```

`app/src/main/cpp/LIBS/Substrate/SubstrateDebug.cpp`:

```cpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#include "SubstrateHook.h"
#include "SubstrateDebug.hpp"

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <obfuscate.h>

_extern bool MSDebug;
bool MSDebug = false;

static char _MSHexChar(uint8_t value) {
    return value < 0x20 || value >= 0x80 ? '.' : value;
}

#define HexWidth_ 16
#define HexDepth_ 4

void MSLogHexEx(const void *vdata, size_t size, size_t stride, const char *mark) {
    const uint8_t *data((const uint8_t *) vdata);

    size_t i(0), j;

    char d[256];
    size_t b(0);
    d[0] = '\0';

    while (i != size) {
        if (i % HexWidth_ == 0) {
            if (mark != NULL)
                b += sprintf(d + b, AY_OBFUSCATE("\n[%s] "), mark);
            b += sprintf(d + b, AY_OBFUSCATE("0x%.3zx:"), i);
        }

        b += sprintf(d + b, " ");

        for (size_t q(0); q != stride; ++q)
            b += sprintf(d + b, AY_OBFUSCATE("%.2x"), data[i + stride - q - 1]);

        i += stride;

        for (size_t q(1); q != stride; ++q)
            b += sprintf(d + b, " ");

        if (i % HexDepth_ == 0)
            b += sprintf(d + b, " ");

        if (i % HexWidth_ == 0) {
            b += sprintf(d + b, " ");
            for (j = i - HexWidth_; j != i; ++j)
                b += sprintf(d + b, "%c", _MSHexChar(data[j]));

            lprintf("%s", d);
            b = 0;
            d[0] = '\0';
        }
    }

    if (i % HexWidth_ != 0) {
        for (j = i % HexWidth_; j != HexWidth_; ++j)
            b += sprintf(d + b, "   ");
        for (j = 0; j != (HexWidth_ - i % HexWidth_ + HexDepth_ - 1) / HexDepth_; ++j)
            b += sprintf(d + b, " ");
        b += sprintf(d + b, " ");
        for (j = i / HexWidth_ * HexWidth_; j != i; ++j)
            b += sprintf(d + b, AY_OBFUSCATE("%c"), _MSHexChar(data[j]));

       // lprintf("%s", d);
        b = 0;
        d[0] = '\0';
    }
}

void MSLogHex(const void *vdata, size_t size, const char *mark) {
    return MSLogHexEx(vdata, size, 1, mark);
}

```

`app/src/main/cpp/LIBS/Substrate/SubstrateDebug.hpp`:

```hpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_DEBUG_HPP
#define SUBSTRATE_DEBUG_HPP

#include "SubstrateLog.hpp"
#define lprintf(format, ...) \
    MSLog(MSLogLevelNotice, format, ## __VA_ARGS__)

extern "C" bool MSDebug;
void MSLogHexEx(const void *vdata, size_t size, size_t stride, const char *mark = 0);
void MSLogHex(const void *vdata, size_t size, const char *mark = 0);

#endif//SUBSTRATE_DEBUG_HPP

```

`app/src/main/cpp/LIBS/Substrate/SubstrateHook.cpp`:

```cpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#define SubstrateInternal

#include "CydiaSubstrate.h"

#include <sys/mman.h>

#define _trace() do { \
    MSLog(MSLogLevelNotice, "_trace(%u)", __LINE__); \
} while (false)

#if defined(__i386__) || defined(__x86_64__)

#include "hde64.h"

#endif

#include "SubstrateDebug.hpp"

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <obfuscate.h>

#ifdef __arm__
/* WebCore (ARM) PC-Relative:
X    1  ldr r*,[pc,r*] !=
     2 fldd d*,[pc,#*]
X    5  str r*,[pc,r*] !=
     8 flds s*,[pc,#*]
   400  ldr r*,[pc,r*] ==
   515  add r*, pc,r*  ==
X 4790  ldr r*,[pc,#*]    */

// x=0; while IFS= read -r line; do if [[ ${#line} -ne 0 && $line == +([^\;]): ]]; then x=2; elif [[ $line == ' +'* && $x -ne 0 ]]; then ((--x)); echo "$x${line}"; fi; done <WebCore.asm >WebCore.pc
// grep pc WebCore.pc | cut -c 40- | sed -Ee 's/^ldr *(ip|r[0-9]*),\[pc,\#0x[0-9a-f]*\].*/ ldr r*,[pc,#*]/;s/^add *r[0-9]*,pc,r[0-9]*.*/ add r*, pc,r*/;s/^(st|ld)r *r([0-9]*),\[pc,r([0-9]*)\].*/ \1r r\2,[pc,r\3]/;s/^fld(s|d) *(s|d)[0-9]*,\[pc,#0x[0-9a-f]*].*/fld\1 \2*,[pc,#*]/' | sort | uniq -c | sort -n

#include "SubstrateARM.hpp"

#define T$Label(l, r) \
    (((r) - (l)) * 2 - 4 + ((l) % 2 == 0 ? 0 : 2))

#define T$pop_$r0$ 0xbc01 // pop {r0}
#define T$b(im) /* b im */ \
    (0xde00 | (im & 0xff))
#define T$blx(rm) /* blx rm */ \
    (0x4780 | (rm << 3))
#define T$bx(rm) /* bx rm */ \
    (0x4700 | (rm << 3))
#define T$nop /* nop */ \
    (0x46c0)

#define T$add_rd_rm(rd, rm) /* add rd, rm */ \
    (0x4400 | (((rd) & 0x8) >> 3 << 7) | (((rm) & 0x8) >> 3 << 6) | (((rm) & 0x7) << 3) | ((rd) & 0x7))
#define T$push_r(r) /* push r... */ \
    (0xb400 | (((r) & (1 << A$lr)) >> A$lr << 8) | ((r) & 0xff))
#define T$pop_r(r) /* pop r... */ \
    (0xbc00 | (((r) & (1 << A$pc)) >> A$pc << 8) | ((r) & 0xff))
#define T$mov_rd_rm(rd, rm) /* mov rd, rm */ \
    (0x4600 | (((rd) & 0x8) >> 3 << 7) | (((rm) & 0x8) >> 3 << 6) | (((rm) & 0x7) << 3) | ((rd) & 0x7))
#define T$ldr_rd_$rn_im_4$(rd, rn, im) /* ldr rd, [rn, #im * 4] */ \
    (0x6800 | (((im) & 0x1f) << 6) | ((rn) << 3) | (rd))
#define T$ldr_rd_$pc_im_4$(rd, im) /* ldr rd, [PC, #im * 4] */ \
    (0x4800 | ((rd) << 8) | ((im) & 0xff))
#define T$cmp_rn_$im(rn, im) /* cmp rn, #im */ \
    (0x2000 | ((rn) << 8) | ((im) & 0xff))
#define T$it$_cd(cd, ms) /* it<ms>, cd */ \
    (0xbf00 | ((cd) << 4) | (ms))
#define T$cbz$_rn_$im(op,rn,im) /* cb<op>z rn, #im */ \
    (0xb100 | ((op) << 11) | (((im) & 0x40) >> 6 << 9) | (((im) & 0x3e) >> 1 << 3) | (rn))
#define T$b$_$im(cond,im) /* b<cond> #im */ \
    (cond == A$al ? 0xe000 | (((im) >> 1) & 0x7ff) : 0xd000 | ((cond) << 8) | (((im) >> 1) & 0xff))

#define T1$ldr_rt_$rn_im$(rt, rn, im) /* ldr rt, [rn, #im] */ \
    (0xf850 | ((im < 0 ? 0 : 1) << 7) | (rn))
#define T2$ldr_rt_$rn_im$(rt, rn, im) /* ldr rt, [rn, #im] */ \
    (((rt) << 12) | abs((int)(im)))

#define T1$mrs_rd_apsr(rd) /* mrs rd, apsr */ \
    (0xf3ef)
#define T2$mrs_rd_apsr(rd) /* mrs rd, apsr */ \
    (0x8000 | ((rd) << 8))

#define T1$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \
    (0xf380 | (rn))
#define T2$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \
    (0x8c00)
#define T$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \
    (T2$msr_apsr_nzcvqg_rn(rn) << 16 | T1$msr_apsr_nzcvqg_rn(rn))

static inline bool A$pcrel$r(uint32_t ic) {
    return (ic & 0x0c000000) == 0x04000000 && (ic & 0xf0000000) != 0xf0000000 && (ic & 0x000f0000) == 0x000f0000;
}

static inline bool T$32bit$i(uint16_t ic) {
    return ((ic & 0xe000) == 0xe000 && (ic & 0x1800) != 0x0000);
}

static inline bool T$pcrel$cbz(uint16_t ic) {
    return (ic & 0xf500) == 0xb100;
}

static inline bool T$pcrel$b(uint16_t ic) {
    return (ic & 0xf000) == 0xd000 && (ic & 0x0e00) != 0x0e00;
}

static inline bool T2$pcrel$b(uint16_t *ic) {
    return (ic[0] & 0xf800) == 0xf000 && (((ic[1] & 0xd000) == 0x9000 || (ic[1] & 0xd000) == 0x8000) && (ic[0] & 0x0380) != 0x0380);
}

static inline bool T$pcrel$bl(uint16_t *ic) {
    return (ic[0] & 0xf800) == 0xf000 && ((ic[1] & 0xd000) == 0xd000 || (ic[1] & 0xd001) == 0xc000);
}

static inline bool T$pcrel$ldr(uint16_t ic) {
    return (ic & 0xf800) == 0x4800;
}

static inline bool T$pcrel$add(uint16_t ic) {
    return (ic & 0xff78) == 0x4478;
}

static inline bool T$pcrel$ldrw(uint16_t ic) {
    return (ic & 0xff7f) == 0xf85f;
}

static size_t MSGetInstructionWidthThumb(void *start) {
    uint16_t *thumb(reinterpret_cast<uint16_t *>(start));
    return T$32bit$i(thumb[0]) ? 4 : 2;
}

static size_t MSGetInstructionWidthARM(void *start) {
    return 4;
}

extern "C" size_t MSGetInstructionWidth(void *start) {
    if ((reinterpret_cast<uintptr_t>(start) & 0x1) == 0)
        return MSGetInstructionWidthARM(start);
    else
        return MSGetInstructionWidthThumb(reinterpret_cast<void *>(reinterpret_cast<uintptr_t>(start) & ~0x1));
}

static size_t SubstrateHookFunctionThumb(SubstrateProcessRef process, void *symbol, void *replace, void **result) {
    if (symbol == NULL)
        return 0;
printf(AY_OBFUSCATE("SubstrateHookFunctionThumb\n"));
    uint16_t *area(reinterpret_cast<uint16_t *>(symbol));

    unsigned align((reinterpret_cast<uintptr_t>(area) & 0x2) == 0 ? 0 : 1);
    uint16_t *thumb(area + align);

    uint32_t *arm(reinterpret_cast<uint32_t *>(thumb + 2));
    uint16_t *trail(reinterpret_cast<uint16_t *>(arm + 2));

    if (
        (align == 0 || area[0] == T$nop) &&
        thumb[0] == T$bx(A$pc) &&
        thumb[1] == T$nop &&
        arm[0] == A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8)
    ) {
        if (result != NULL)
            *result = reinterpret_cast<void *>(arm[1]);

        SubstrateHookMemory code(process, arm + 1, sizeof(uint32_t) * 1);

        arm[1] = reinterpret_cast<uint32_t>(replace);

        return sizeof(arm[0]);
    }

    size_t required((trail - area) * sizeof(uint16_t));

    size_t used(0);
    while (used < required)
        used += MSGetInstructionWidthThumb(reinterpret_cast<uint8_t *>(area) + used);
    used = (used + sizeof(uint16_t) - 1) / sizeof(uint16_t) * sizeof(uint16_t);

    size_t blank((used - required) / sizeof(uint16_t));

    uint16_t backup[used / sizeof(uint16_t)];
    memcpy(backup, area, used);

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", area);
        MSLogHexEx(area, used + sizeof(uint16_t), 2, name);
    }

    if (result != NULL) {

    size_t length(used);
    for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset)
        if (T$pcrel$ldr(backup[offset]))
            length += 3 * sizeof(uint16_t);
        else if (T$pcrel$b(backup[offset]))
            length += 6 * sizeof(uint16_t);
        else if (T2$pcrel$b(backup + offset)) {
            length += 5 * sizeof(uint16_t);
            ++offset;
        } else if (T$pcrel$bl(backup + offset)) {
            length += 5 * sizeof(uint16_t);
            ++offset;
        } else if (T$pcrel$cbz(backup[offset])) {
            length += 16 * sizeof(uint16_t);
        } else if (T$pcrel$ldrw(backup[offset])) {
            length += 4 * sizeof(uint16_t);
            ++offset;
        } else if (T$pcrel$add(backup[offset]))
            length += 6 * sizeof(uint16_t);
        else if (T$32bit$i(backup[offset]))
            ++offset;

    unsigned pad((length & 0x2) == 0 ? 0 : 1);
    length += (pad + 2) * sizeof(uint16_t) + 2 * sizeof(uint32_t);

    uint16_t *buffer(reinterpret_cast<uint16_t *>(mmap(
        NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0
    )));

    if (buffer == MAP_FAILED) {
        MSLog(MSLogLevelError, "MS:Error:mmap() = %d", errno);
        *result = NULL;
        return 0;
    }

    if (false) fail: {
        munmap(buffer, length);
        *result = NULL;
        return 0;
    }

    size_t start(pad), end(length / sizeof(uint16_t));
    uint32_t *trailer(reinterpret_cast<uint32_t *>(buffer + end));
    for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset) {
        if (T$pcrel$ldr(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 8;
                    uint16_t rd : 3;
                    uint16_t : 5;
                };
            } bits = {backup[offset+0]};

            buffer[start+0] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start+0, end-2) / 4);
            buffer[start+1] = T$ldr_rd_$rn_im_4$(bits.rd, bits.rd, 0);

            // XXX: this code "works", but is "wrong": the mechanism is more complex than this
            *--trailer = ((reinterpret_cast<uint32_t>(area + offset) + 4) & ~0x2) + bits.immediate * 4;

            start += 2;
            end -= 2;
        } else if (T$pcrel$b(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t imm8 : 8;
                    uint16_t cond : 4;
                    uint16_t /*1101*/ : 4;
                };
            } bits = {backup[offset+0]};

            intptr_t jump(bits.imm8 << 1);
            jump |= 1;
            jump <<= 23;
            jump >>= 23;

            buffer[start+0] = T$b$_$im(bits.cond, (end-6 - (start+0)) * 2 - 4);

            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;
            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
            *--trailer = T$nop << 16 | T$bx(A$pc);

            start += 1;
            end -= 6;
        } else if (T2$pcrel$b(backup + offset)) {
            union {
                uint16_t value;

                struct {
                    uint16_t imm6 : 6;
                    uint16_t cond : 4;
                    uint16_t s : 1;
                    uint16_t : 5;
                };
            } bits = {backup[offset+0]};

            union {
                uint16_t value;

                struct {
                    uint16_t imm11 : 11;
                    uint16_t j2 : 1;
                    uint16_t a : 1;
                    uint16_t j1 : 1;
                    uint16_t : 2;
                };
            } exts = {backup[offset+1]};

            intptr_t jump(1);
            jump |= exts.imm11 << 1;
            jump |= bits.imm6 << 12;

            if (exts.a) {
                jump |= bits.s << 24;
                jump |= (~(bits.s ^ exts.j1) & 0x1) << 23;
                jump |= (~(bits.s ^ exts.j2) & 0x1) << 22;
                jump |= bits.cond << 18;
                jump <<= 7;
                jump >>= 7;
            } else {
                jump |= bits.s << 20;
                jump |= exts.j2 << 19;
                jump |= exts.j1 << 18;
                jump <<= 11;
                jump >>= 11;
            }

            buffer[start+0] = T$b$_$im(exts.a ? A$al : bits.cond, (end-6 - (start+0)) * 2 - 4);

            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;
            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
            *--trailer = T$nop << 16 | T$bx(A$pc);

            ++offset;
            start += 1;
            end -= 6;
        } else if (T$pcrel$bl(backup + offset)) {
            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 10;
                    uint16_t s : 1;
                    uint16_t : 5;
                };
            } bits = {backup[offset+0]};

            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 11;
                    uint16_t j2 : 1;
                    uint16_t x : 1;
                    uint16_t j1 : 1;
                    uint16_t : 2;
                };
            } exts = {backup[offset+1]};

            int32_t jump(0);
            jump |= bits.s << 24;
            jump |= (~(bits.s ^ exts.j1) & 0x1) << 23;
            jump |= (~(bits.s ^ exts.j2) & 0x1) << 22;
            jump |= bits.immediate << 12;
            jump |= exts.immediate << 1;
            jump |= exts.x;
            jump <<= 7;
            jump >>= 7;

            buffer[start+0] = T$push_r(1 << A$r7);
            buffer[start+1] = T$ldr_rd_$pc_im_4$(A$r7, ((end-2 - (start+1)) * 2 - 4 + 2) / 4);
            buffer[start+2] = T$mov_rd_rm(A$lr, A$r7);
            buffer[start+3] = T$pop_r(1 << A$r7);
            buffer[start+4] = T$blx(A$lr);

            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;

            ++offset;
            start += 5;
            end -= 2;
        } else if (T$pcrel$cbz(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t rn : 3;
                    uint16_t immediate : 5;
                    uint16_t : 1;
                    uint16_t i : 1;
                    uint16_t : 1;
                    uint16_t op : 1;
                    uint16_t : 4;
                };
            } bits = {backup[offset+0]};

            intptr_t jump(1);
            jump |= bits.i << 6;
            jump |= bits.immediate << 1;

            //jump <<= 24;
            //jump >>= 24;

            unsigned rn(bits.rn);
            unsigned rt(rn == A$r7 ? A$r6 : A$r7);

            buffer[start+0] = T$push_r(1 << rt);
            buffer[start+1] = T1$mrs_rd_apsr(rt);
            buffer[start+2] = T2$mrs_rd_apsr(rt);
            buffer[start+3] = T$cbz$_rn_$im(bits.op, rn, (end-10 - (start+3)) * 2 - 4);
            buffer[start+4] = T1$msr_apsr_nzcvqg_rn(rt);
            buffer[start+5] = T2$msr_apsr_nzcvqg_rn(rt);
            buffer[start+6] = T$pop_r(1 << rt);

            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;
            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
            *--trailer = T$nop << 16 | T$bx(A$pc);
            *--trailer = T$nop << 16 | T$pop_r(1 << rt);
            *--trailer = T$msr_apsr_nzcvqg_rn(rt);

#if 0
            if ((start & 0x1) == 0)
                buffer[start++] = T$nop;
            buffer[start++] = T$bx(A$pc);
            buffer[start++] = T$nop;

            uint32_t *arm(reinterpret_cast<uint32_t *>(buffer + start));
            arm[0] = A$add(A$lr, A$pc, 1);
            arm[1] = A$ldr_rd_$rn_im$(A$pc, A$pc, (trailer - arm) * sizeof(uint32_t) - 8);
#endif

            start += 7;
            end -= 10;
        } else if (T$pcrel$ldrw(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t : 7;
                    uint16_t u : 1;
                    uint16_t : 8;
                };
            } bits = {backup[offset+0]};

            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 12;
                    uint16_t rt : 4;
                };
            } exts = {backup[offset+1]};

            buffer[start+0] = T1$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start+0, end-2));
            buffer[start+1] = T2$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start+0, end-2));

            buffer[start+2] = T1$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);
            buffer[start+3] = T2$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);

            // XXX: this code "works", but is "wrong": the mechanism is more complex than this
            *--trailer = ((reinterpret_cast<uint32_t>(area + offset) + 4) & ~0x2) + (bits.u == 0 ? -exts.immediate : exts.immediate);

            ++offset;
            start += 4;
            end -= 2;
        } else if (T$pcrel$add(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t rd : 3;
                    uint16_t rm : 3;
                    uint16_t h2 : 1;
                    uint16_t h1 : 1;
                    uint16_t : 8;
                };
            } bits = {backup[offset+0]};

            if (bits.h1) {
                MSLog(MSLogLevelError, "MS:Error:pcrel(%u):add (rd > r7)", offset);
                goto fail;
            }

            unsigned rt(bits.rd == A$r7 ? A$r6 : A$r7);

            buffer[start+0] = T$push_r(1 << rt);
            buffer[start+1] = T$mov_rd_rm(rt, (bits.h1 << 3) | bits.rd);
            buffer[start+2] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start+2, end-2) / 4);
            buffer[start+3] = T$add_rd_rm((bits.h1 << 3) | bits.rd, rt);
            buffer[start+4] = T$pop_r(1 << rt);
            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4;

            start += 5;
            end -= 2;
        } else if (T$32bit$i(backup[offset])) {
            buffer[start++] = backup[offset];
            buffer[start++] = backup[++offset];
        } else {
            buffer[start++] = backup[offset];
        }
    }

    buffer[start++] = T$bx(A$pc);
    buffer[start++] = T$nop;

    uint32_t *transfer = reinterpret_cast<uint32_t *>(buffer + start);
    transfer[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
    transfer[1] = reinterpret_cast<uint32_t>(area + used / sizeof(uint16_t)) + 1;

    if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {
        MSLog(MSLogLevelError, "MS:Error:mprotect():%d", errno);
        return 0;
    }

    *result = reinterpret_cast<uint8_t *>(buffer + pad) + 1;

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", *result);
        MSLogHexEx(buffer, length, 2, name);
    }

    }

    {
        SubstrateHookMemory code(process, area, used);

        if (align != 0)
            area[0] = T$nop;

        thumb[0] = T$bx(A$pc);
        thumb[1] = T$nop;

        arm[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
        arm[1] = reinterpret_cast<uint32_t>(replace);

        for (unsigned offset(0); offset != blank; ++offset)
            trail[offset] = T$nop;
    }

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", area);
        MSLogHexEx(area, used + sizeof(uint16_t), 2, name);
    }

    return used;
}

static size_t SubstrateHookFunctionARM(SubstrateProcessRef process, void *symbol, void *replace, void **result) {
    if (symbol == NULL)
        return 0;
    printf(AY_OBFUSCATE("SubstrateHookFunctionARM\n"));
    uint32_t *area(reinterpret_cast<uint32_t *>(symbol));
    uint32_t *arm(area);

    const size_t used(8);

    uint32_t backup[used / sizeof(uint32_t)] = {arm[0], arm[1]};

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", area);
        MSLogHexEx(area, used + sizeof(uint32_t), 4, name);
    }

    if (result != NULL) {

    if (backup[0] == A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8)) {
        *result = reinterpret_cast<void *>(backup[1]);

        return sizeof(backup[0]);
    }

    size_t length(used);
    for (unsigned offset(0); offset != used / sizeof(uint32_t); ++offset)
        if (A$pcrel$r(backup[offset])) {
            if ((backup[offset] & 0x02000000) == 0 || (backup[offset] & 0x0000f000 >> 12) != (backup[offset] & 0x0000000f))
                length += 2 * sizeof(uint32_t);
            else
                length += 4 * sizeof(uint32_t);
        }

    length += 2 * sizeof(uint32_t);

    uint32_t *buffer(reinterpret_cast<uint32_t *>(mmap(
        NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0
    )));

    if (buffer == MAP_FAILED) {
        MSLog(MSLogLevelError, "MS:Error:mmap() = %d", errno);
        *result = NULL;
        return 0;
    }

    if (false) fail: {
        munmap(buffer, length);
        *result = NULL;
        return 0;
    }

    size_t start(0), end(length / sizeof(uint32_t));
    uint32_t *trailer(reinterpret_cast<uint32_t *>(buffer + end));
    for (unsigned offset(0); offset != used / sizeof(uint32_t); ++offset)
        if (A$pcrel$r(backup[offset])) {
            union {
                uint32_t value;

                struct {
                    uint32_t rm : 4;
                    uint32_t : 1;
                    uint32_t shift : 2;
                    uint32_t shiftamount : 5;
                    uint32_t rd : 4;
                    uint32_t rn : 4;
                    uint32_t l : 1;
                    uint32_t w : 1;
                    uint32_t b : 1;
                    uint32_t u : 1;
                    uint32_t p : 1;
                    uint32_t mode : 1;
                    uint32_t type : 2;
                    uint32_t cond : 4;
                };
            } bits = {backup[offset+0]}, copy(bits);

            bool guard;
            if (bits.mode == 0 || bits.rd != bits.rm) {
                copy.rn = bits.rd;
                guard = false;
            } else {
                copy.rn = bits.rm != A$r0 ? A$r0 : A$r1;
                guard = true;
            }

            if (guard)
                buffer[start++] = A$stmdb_sp$_$rs$((1 << copy.rn));

            buffer[start+0] = A$ldr_rd_$rn_im$(copy.rn, A$pc, (end-1 - (start+0)) * 4 - 8);
            buffer[start+1] = copy.value;

            start += 2;

            if (guard)
                buffer[start++] = A$ldmia_sp$_$rs$((1 << copy.rn));

            *--trailer = reinterpret_cast<uint32_t>(area + offset) + 8;
            end -= 1;
        } else
            buffer[start++] = backup[offset];

    buffer[start+0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
    buffer[start+1] = reinterpret_cast<uint32_t>(area + used / sizeof(uint32_t));

    if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {
        MSLog(MSLogLevelError, AY_OBFUSCATE("MS:Error:mprotect():%d"), errno);
        goto fail;
    }

    *result = buffer;

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", *result);
        MSLogHexEx(buffer, length, 4, name);
    }

    }

    {
        SubstrateHookMemory code(process, symbol, used);

        arm[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
        arm[1] = reinterpret_cast<uint32_t>(replace);
    }

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", area);
        MSLogHexEx(area, used + sizeof(uint32_t), 4, name);
    }

    return used;
}

static size_t SubstrateHookFunction(SubstrateProcessRef process, void *symbol, void *replace, void **result) {
    if (MSDebug)
        MSLog(MSLogLevelNotice, "SubstrateHookFunction(%p, %p, %p, %p)\n", process, symbol, replace, result);
    if ((reinterpret_cast<uintptr_t>(symbol) & 0x1) == 0)
        return SubstrateHookFunctionARM(process, symbol, replace, result);
    else
        return SubstrateHookFunctionThumb(process, reinterpret_cast<void *>(reinterpret_cast<uintptr_t>(symbol) & ~0x1), replace, result);
}
#endif

#if defined(__i386__) || defined(__x86_64__)

#include "SubstrateX86.hpp"

static size_t MSGetInstructionWidthIntel(void *start) {
    hde64s decode;
    return hde64_disasm(start, &decode);
}

static void
SubstrateHookFunction(SubstrateProcessRef process, void *symbol, void *replace, void **result) {
    if (MSDebug)
     MSLog(MSLogLevelNotice, AY_OBFUSCATE("MSHookFunction(%p, %p, %p)\n"), symbol, replace, result);
    if (symbol == NULL)
        return;

    uintptr_t source(reinterpret_cast<uintptr_t>(symbol));
    uintptr_t target(reinterpret_cast<uintptr_t>(replace));

    uint8_t *area(reinterpret_cast<uint8_t *>(symbol));

    size_t required(MSSizeOfJump(target, source));

    if (MSDebug) {
        char name[16];
        sprintf(name, AY_OBFUSCATE("%p"), area);
        MSLogHex(area, 32, name);
    }

    size_t used(0);
    while (used < required) {
        size_t width(MSGetInstructionWidthIntel(area + used));
        if (width == 0) {
            //MSLog(MSLogLevelError, "MS:Error:MSGetInstructionWidthIntel(%p) == 0", area + used);
            return;
        }

        used += width;
    }

    size_t blank(used - required);

    if (MSDebug) {
        char name[16];
        sprintf(name, AY_OBFUSCATE("%p"), area);
        MSLogHex(area, used + sizeof(uint16_t), name);
    }

    uint8_t backup[used];
    memcpy(backup, area, used);

    if (result != NULL) {

        if (backup[0] == 0xe9) {
            *result = reinterpret_cast<void *>(source + 5 +
                                               *reinterpret_cast<uint32_t *>(backup + 1));
            return;
        }

        if (!ia32 && backup[0] == 0xff && backup[1] == 0x25) {
            *result = *reinterpret_cast<void **>(source + 6 +
                                                 *reinterpret_cast<uint32_t *>(backup + 2));
            return;
        }

        size_t length(used + MSSizeOfJump(source + used));

        for (size_t offset(0), width; offset != used; offset += width) {
            hde64s decode;
            hde64_disasm(backup + offset, &decode);
            width = decode.len;
            //_assert(width != 0 && offset + width <= used);

#ifdef __LP64__
            if ((decode.modrm & 0xc7) == 0x05) {
                if (decode.opcode == 0x8b) {
                    void *destiny(area + offset + width + int32_t(decode.disp.disp32));
                    uint8_t reg(decode.rex_r << 3 | decode.modrm_reg);
                    length -= decode.len;
                    length += MSSizeOfPushPointer(destiny);
                    length += MSSizeOfPop(reg);
                    length += MSSizeOfMove64();
                } else {
                    MSLog(MSLogLevelError, "MS:Error: Unknown RIP-Relative (%.2x %.2x)", decode.opcode, decode.opcode2);
                    continue;
                }
            } else
#endif

            if (backup[offset] == 0xe8) {
                int32_t relative(*reinterpret_cast<int32_t *>(backup + offset + 1));
                void *destiny(area + offset + decode.len + relative);

                if (relative == 0) {
                    length -= decode.len;
                    length += MSSizeOfPushPointer(destiny);
                } else {
                    length += MSSizeOfSkip();
                    length += MSSizeOfJump(destiny);
                }
            } else if (backup[offset] == 0xeb) {
                length -= decode.len;
                length += MSSizeOfJump(area + offset + decode.len +
                                       *reinterpret_cast<int8_t *>(backup + offset + 1));
            } else if (backup[offset] == 0xe9) {
                length -= decode.len;
                length += MSSizeOfJump(area + offset + decode.len +
                                       *reinterpret_cast<int32_t *>(backup + offset + 1));
            } else if (
                    backup[offset] == 0xe3 ||
                    (backup[offset] & 0xf0) == 0x70
                // XXX: opcode2 & 0xf0 is 0x80?
                    ) {
                length += decode.len;
                length += MSSizeOfJump(area + offset + decode.len +
                                       *reinterpret_cast<int8_t *>(backup + offset + 1));
            }
        }

        uint8_t *buffer(reinterpret_cast<uint8_t *>(mmap(
                NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0
        )));

        if (buffer == MAP_FAILED) {
            MSLog(MSLogLevelError, AY_OBFUSCATE("MS:Error:mmap() = %d"), errno);
            *result = NULL;
            return;
        }

        if (false)
            fail:
            {
                munmap(buffer, length);
                *result = NULL;
                return;
            }

        {
            uint8_t *current(buffer);

            for (size_t offset(0), width; offset != used; offset += width) {
                hde64s decode;
                hde64_disasm(backup + offset, &decode);
                width = decode.len;
                //_assert(width != 0 && offset + width <= used);

#ifdef __LP64__
                if ((decode.modrm & 0xc7) == 0x05) {
                    if (decode.opcode == 0x8b) {
                        void *destiny(area + offset + width + int32_t(decode.disp.disp32));
                        uint8_t reg(decode.rex_r << 3 | decode.modrm_reg);
                        MSPushPointer(current, destiny);
                        MSWritePop(current, reg);
                        MSWriteMove64(current, reg, reg);
                    } else {
                        MSLog(MSLogLevelError, "MS:Error: Unknown RIP-Relative (%.2x %.2x)", decode.opcode, decode.opcode2);
                        goto copy;
                    }
                } else
#endif

                if (backup[offset] == 0xe8) {
                    int32_t relative(*reinterpret_cast<int32_t *>(backup + offset + 1));
                    if (relative == 0)
                        MSPushPointer(current, area + offset + decode.len);
                    else {
                        MSWrite<uint8_t>(current, 0xe8);
                        MSWrite<int32_t>(current, MSSizeOfSkip());
                        void *destiny(area + offset + decode.len + relative);
                        MSWriteSkip(current, MSSizeOfJump(destiny, current + MSSizeOfSkip()));
                        MSWriteJump(current, destiny);
                    }
                } else if (backup[offset] == 0xeb)
                    MSWriteJump(current, area + offset + decode.len +
                                         *reinterpret_cast<int8_t *>(backup + offset + 1));
                else if (backup[offset] == 0xe9)
                    MSWriteJump(current, area + offset + decode.len +
                                         *reinterpret_cast<int32_t *>(backup + offset + 1));
                else if (
                        backup[offset] == 0xe3 ||
                        (backup[offset] & 0xf0) == 0x70
                        ) {
                    MSWrite<uint8_t>(current, backup[offset]);
                    MSWrite<uint8_t>(current, 2);
                    MSWrite<uint8_t>(current, 0xeb);
                    void *destiny(area + offset + decode.len +
                                  *reinterpret_cast<int8_t *>(backup + offset + 1));
                    MSWrite<uint8_t>(current, MSSizeOfJump(destiny, current + 1));
                    MSWriteJump(current, destiny);
                } else
#ifdef __LP64__
                    copy:
#endif
                {
                    MSWrite(current, backup + offset, width);
                }
            }

            MSWriteJump(current, area + used);
        }

        if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {
            MSLog(MSLogLevelError, AY_OBFUSCATE("MS:Error:mprotect():%d"), errno);
            goto fail;
        }

        *result = buffer;

        if (MSDebug) {
            char name[16];
            sprintf(name, AY_OBFUSCATE("%p"), *result);
            MSLogHex(buffer, length, name);
        }

    }

    {
        SubstrateHookMemory code(process, area, used);
        uint8_t *current(area);
        MSWriteJump(current, target);
        for (unsigned offset(0); offset != blank; ++offset)
            MSWrite<uint8_t>(current, 0x90);
    }

    if (MSDebug) {
        char name[16];
        sprintf(name, AY_OBFUSCATE("%p"), area);
        MSLogHex(area, used + sizeof(uint16_t), name);
    }
}

#endif

void MSHookFunction(void *symbol, void *replace, void **result) {
#if defined(__i386__) || defined(__arm__)
    SubstrateHookFunction(NULL, symbol, replace, result);
#endif
}

#if defined(__APPLE__) && defined(__arm__)
_extern void _Z14MSHookFunctionPvS_PS_(void *symbol, void *replace, void **result) {
    return MSHookFunction(symbol, replace, result);
}
#endif

```

`app/src/main/cpp/LIBS/Substrate/SubstrateHook.h`:

```h
#ifndef __SUBSTRATEHOOK_H__
#define __SUBSTRATEHOOK_H__


#include <stdlib.h>

#define _extern extern "C" __attribute__((__visibility__("hidden")))

#ifdef __cplusplus
extern "C" {
#endif

void MSHookFunction(void *symbol, void *replace, void **result);

#ifdef __cplusplus
}
#endif

#endif

```

`app/src/main/cpp/LIBS/Substrate/SubstrateLog.hpp`:

```hpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_LOG_HPP
#define SUBSTRATE_LOG_HPP

#if 0
#include <android/log.h>

#define MSLog(level, format, ...) ((void)__android_log_print(level, "NNNN", format, __VA_ARGS__))

#define MSLogLevelNotice ANDROID_LOG_INFO
#define MSLogLevelWarning ANDROID_LOG_WARN
#define MSLogLevelError ANDROID_LOG_ERROR

#else

#define MSLog(level, format, ...) printf(format, __VA_ARGS__)

#endif

#endif//SUBSTRATE_LOG_HPP

```

`app/src/main/cpp/LIBS/Substrate/SubstratePosixMemory.cpp`:

```cpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#define SubstrateInternal
#include "CydiaSubstrate.h"
#include "SubstrateLog.hpp"

#include <sys/mman.h>

#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <obfuscate.h>

extern "C" void __clear_cache (void *beg, void *end);

struct __SubstrateMemory {
    void *address_;
    size_t width_;

    __SubstrateMemory(void *address, size_t width) :
        address_(address),
        width_(width)
    {
    }
};

extern "C" SubstrateMemoryRef SubstrateMemoryCreate(SubstrateAllocatorRef allocator, SubstrateProcessRef process, void *data, size_t size) {
    if (allocator != NULL) {
        MSLog(MSLogLevelError, AY_OBFUSCATE("MS:Error:allocator != %d"), 0);
        return NULL;
    }

    if (size == 0)
        return NULL;

    int page(getpagesize());

    uintptr_t base(reinterpret_cast<uintptr_t>(data) / page * page);
    size_t width(((reinterpret_cast<uintptr_t>(data) + size - 1) / page + 1) * page - base);
    void *address(reinterpret_cast<void *>(base));

    if (mprotect(address, width, PROT_READ | PROT_WRITE | PROT_EXEC) == -1) {
        MSLog(MSLogLevelError, AY_OBFUSCATE("MS:Error:mprotect() = %d"), errno);
        return NULL;
    }

    return new __SubstrateMemory(address, width);
}

extern "C" void SubstrateMemoryRelease(SubstrateMemoryRef memory) {
    if (mprotect(memory->address_, memory->width_, PROT_READ | PROT_WRITE | PROT_EXEC) == -1)
        MSLog(MSLogLevelError,  AY_OBFUSCATE("MS:Error:mprotect() = %d"), errno);

    __clear_cache(reinterpret_cast<char *>(memory->address_), reinterpret_cast<char *>(memory->address_) + memory->width_);

    delete memory;
}

```

`app/src/main/cpp/LIBS/Substrate/SubstrateX86.hpp`:

```hpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_X86_HPP
#define SUBSTRATE_X86_HPP

#include "Buffer.hpp"

#ifdef __LP64__
static const bool ia32 = false;
#else
static const bool ia32 = true;
#endif

enum I$r {
    I$rax, I$rcx, I$rdx, I$rbx,
    I$rsp, I$rbp, I$rsi, I$rdi,
    I$r8, I$r9, I$r10, I$r11,
    I$r12, I$r13, I$r14, I$r15,
};

_disused static bool MSIs32BitOffset(uintptr_t target, uintptr_t source) {
    intptr_t offset(target - source);
    return int32_t(offset) == offset;
}

_disused static size_t MSSizeOfSkip() {
    return 5;
}

_disused static size_t MSSizeOfPushPointer(uintptr_t target) {
    return uint64_t(target) >> 32 == 0 ? 5 : 13;
}

_disused static size_t MSSizeOfPushPointer(void *target) {
    return MSSizeOfPushPointer(reinterpret_cast<uintptr_t>(target));
}

_disused static size_t MSSizeOfJump(bool blind, uintptr_t target, uintptr_t source = 0) {
    if (ia32 || !blind && MSIs32BitOffset(target, source + 5))
        return MSSizeOfSkip();
    else
        return MSSizeOfPushPointer(target) + 1;
}

_disused static size_t MSSizeOfJump(uintptr_t target, uintptr_t source) {
    return MSSizeOfJump(false, target, source);
}

_disused static size_t MSSizeOfJump(uintptr_t target) {
    return MSSizeOfJump(true, target);
}

_disused static size_t MSSizeOfJump(void *target, void *source) {
    return MSSizeOfJump(reinterpret_cast<uintptr_t>(target), reinterpret_cast<uintptr_t>(source));
}

_disused static size_t MSSizeOfJump(void *target) {
    return MSSizeOfJump(reinterpret_cast<uintptr_t>(target));
}

_disused static void MSWriteSkip(uint8_t *&current, ssize_t size) {
    MSWrite<uint8_t>(current, 0xe9);
    MSWrite<uint32_t>(current, size);
}

_disused static void MSPushPointer(uint8_t *&current, uintptr_t target) {
    MSWrite<uint8_t>(current, 0x68);
    MSWrite<uint32_t>(current, target);

    if (uint32_t high = uint64_t(target) >> 32) {
        MSWrite<uint8_t>(current, 0xc7);
        MSWrite<uint8_t>(current, 0x44);
        MSWrite<uint8_t>(current, 0x24);
        MSWrite<uint8_t>(current, 0x04);
        MSWrite<uint32_t>(current, high);
    }
}

_disused static void MSPushPointer(uint8_t *&current, void *target) {
    return MSPushPointer(current, reinterpret_cast<uintptr_t>(target));
}

_disused static void MSWriteCall(uint8_t *&current, I$r target) {
    if (target >> 3 != 0)
        MSWrite<uint8_t>(current, 0x40 | (target & 0x08) >> 3);
    MSWrite<uint8_t>(current, 0xff);
    MSWrite<uint8_t>(current, 0xd0 | target & 0x07);
}

_disused static void MSWriteCall(uint8_t *&current, uintptr_t target) {
    uintptr_t source(reinterpret_cast<uintptr_t>(current));

    if (ia32 || MSIs32BitOffset(target, source + 5)) {
        MSWrite<uint8_t>(current, 0xe8);
        MSWrite<uint32_t>(current, target - (source + 5));
    } else {
        MSPushPointer(current, target);

        MSWrite<uint8_t>(current, 0x83);
        MSWrite<uint8_t>(current, 0xc4);
        MSWrite<uint8_t>(current, 0x08);

        MSWrite<uint8_t>(current, 0x67);
        MSWrite<uint8_t>(current, 0xff);
        MSWrite<uint8_t>(current, 0x54);
        MSWrite<uint8_t>(current, 0x24);
        MSWrite<uint8_t>(current, 0xf8);
    }
}

template <typename Type_>
_disused static void MSWriteCall(uint8_t *&current, Type_ *target) {
    return MSWriteCall(current, reinterpret_cast<uintptr_t>(target));
}

_disused static void MSWriteJump(uint8_t *&current, uintptr_t target) {
    uintptr_t source(reinterpret_cast<uintptr_t>(current));

    if (ia32 || MSIs32BitOffset(target, source + 5))
        MSWriteSkip(current, target - (source + 5));
    else {
        MSPushPointer(current, target);
        MSWrite<uint8_t>(current, 0xc3);
    }
}

_disused static void MSWriteJump(uint8_t *&current, void *target) {
    return MSWriteJump(current, reinterpret_cast<uintptr_t>(target));
}

_disused static void MSWriteJump(uint8_t *&current, I$r target) {
    if (target >> 3 != 0)
        MSWrite<uint8_t>(current, 0x40 | (target & 0x08) >> 3);
    MSWrite<uint8_t>(current, 0xff);
    MSWrite<uint8_t>(current, 0xe0 | target & 0x07);
}

_disused static void MSWritePop(uint8_t *&current, uint8_t target) {
    if (target >> 3 != 0)
        MSWrite<uint8_t>(current, 0x40 | (target & 0x08) >> 3);
    MSWrite<uint8_t>(current, 0x58 | target & 0x07);
}

_disused static size_t MSSizeOfPop(uint8_t target) {
    return target >> 3 != 0 ? 2 : 1;
}

_disused static void MSWritePush(uint8_t *&current, I$r target) {
    if (target >> 3 != 0)
        MSWrite<uint8_t>(current, 0x40 | (target & 0x08) >> 3);
    MSWrite<uint8_t>(current, 0x50 | target & 0x07);
}

_disused static void MSWriteAdd(uint8_t *&current, I$r target, uint8_t source) {
    MSWrite<uint8_t>(current, 0x83);
    MSWrite<uint8_t>(current, 0xc4 | target & 0x07);
    MSWrite<uint8_t>(current, source);
}

_disused static void MSWriteSet64(uint8_t *&current, I$r target, uintptr_t source) {
    MSWrite<uint8_t>(current, 0x48 | (target & 0x08) >> 3 << 2);
    MSWrite<uint8_t>(current, 0xb8 | target & 0x7);
    MSWrite<uint64_t>(current, source);
}

template <typename Type_>
_disused static void MSWriteSet64(uint8_t *&current, I$r target, Type_ *source) {
    return MSWriteSet64(current, target, reinterpret_cast<uintptr_t>(source));
}

_disused static void MSWriteMove64(uint8_t *&current, uint8_t source, uint8_t target) {
    MSWrite<uint8_t>(current, 0x48 | (target & 0x08) >> 3 << 2 | (source & 0x08) >> 3);
    MSWrite<uint8_t>(current, 0x8b);
    MSWrite<uint8_t>(current, (target & 0x07) << 3 | source & 0x07);
}

_disused static size_t MSSizeOfMove64() {
    return 3;
}

#endif//SUBSTRATE_X86_HPP

```

`app/src/main/cpp/LIBS/Substrate/SymbolFinder.cpp`:

```cpp
#include <stdio.h>
#include <elf.h>
#include <android/log.h>
#include <malloc.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <cstring>
#include <obfuscate.h>
#include "SymbolFinder.h"

#define TAG "MSHook"
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,  TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)
/* memory map for libraries */
#define MAX_NAME_LEN 256
#define MEMORY_ONLY  "[memory]"
struct mm {
    char name[MAX_NAME_LEN];
    unsigned long start, end;
};

typedef struct symtab *symtab_t;
struct symlist {
    Elf32_Sym *sym; /* symbols */
    char *str; /* symbol strings */
    unsigned num; /* number of symbols */
};
struct symtab {
    struct symlist *st; /* "static" symbols */
    struct symlist *dyn; /* dynamic symbols */
};

static void *xmalloc(size_t size) {
    void *p;
    p = malloc(size);
    if (!p) {
        printf(AY_OBFUSCATE("Out of memory\n"));
        exit(1);
    }
    return p;
}

static int my_pread(int fd, void *buf, size_t count, off_t offset) {
    lseek(fd, offset, SEEK_SET);
    return read(fd, buf, count);
}

static struct symlist *get_syms(int fd, Elf32_Shdr *symh, Elf32_Shdr *strh) {
    struct symlist *sl, *ret;
    int rv;

    ret = NULL;
    sl = (struct symlist *) xmalloc(sizeof(struct symlist));
    sl->str = NULL;
    sl->sym = NULL;

    /* sanity */
    if (symh->sh_size % sizeof(Elf32_Sym)) {
        //printf("elf_error\n");
        goto out;
    }

    /* symbol table */
    sl->num = symh->sh_size / sizeof(Elf32_Sym);
    sl->sym = (Elf32_Sym *) xmalloc(symh->sh_size);
    rv = my_pread(fd, sl->sym, symh->sh_size, symh->sh_offset);
    if (0 > rv) {
        //perror("read");
        goto out;
    }
    if (rv != symh->sh_size) {
        //printf("elf error\n");
        goto out;
    }

    /* string table */
    sl->str = (char *) xmalloc(strh->sh_size);
    rv = my_pread(fd, sl->str, strh->sh_size, strh->sh_offset);
    if (0 > rv) {
        //perror("read");
        goto out;
    }
    if (rv != strh->sh_size) {
        //printf("elf error");
        goto out;
    }

    ret = sl;
    out:
    return ret;
}

static int do_load(int fd, symtab_t symtab) {
    int rv;
    size_t size;
    Elf32_Ehdr ehdr;
    Elf32_Shdr *shdr = NULL, *p;
    Elf32_Shdr *dynsymh, *dynstrh;
    Elf32_Shdr *symh, *strh;
    char *shstrtab = NULL;
    int i;
    int ret = -1;

    /* elf header */
    rv = read(fd, &ehdr, sizeof(ehdr));
    if (0 > rv) {
        LOGD(AY_OBFUSCATE("read\n"));
        goto out;
    }
    if (rv != sizeof(ehdr)) {
        LOGD(AY_OBFUSCATE("elf error 1\n"));
        goto out;
    }
    if (strncmp((const char *) ELFMAG, (const char *) ehdr.e_ident, SELFMAG)) { /* sanity */
        LOGD(AY_OBFUSCATE("not an elf\n"));
        goto out;
    }
    if (sizeof(Elf32_Shdr) != ehdr.e_shentsize) { /* sanity */
        LOGD(AY_OBFUSCATE("elf error 2\n"));
        goto out;
    }

    /* section header table */
    size = ehdr.e_shentsize * ehdr.e_shnum;
    shdr = (Elf32_Shdr *) xmalloc(size);
    rv = my_pread(fd, shdr, size, ehdr.e_shoff);
    if (0 > rv) {
        LOGD(AY_OBFUSCATE("read\n"));
        goto out;
    }
    if (rv != size) {
        LOGD(AY_OBFUSCATE("elf error 3 %d %d\n"), rv, size);
        goto out;
    }

    /* section header string table */
    size = shdr[ehdr.e_shstrndx].sh_size;
    shstrtab = (char *) xmalloc(size);
    rv = my_pread(fd, shstrtab, size, shdr[ehdr.e_shstrndx].sh_offset);
    if (0 > rv) {
        LOGD(AY_OBFUSCATE("read\n"));
        goto out;
    }
    if (rv != size) {
        LOGD(AY_OBFUSCATE("elf error 4 %d %d\n"), rv, size);
        goto out;
    }

    /* symbol table headers */
    symh = dynsymh = NULL;
    strh = dynstrh = NULL;
    for (i = 0, p = shdr; i < ehdr.e_shnum; i++, p++)
        if (SHT_SYMTAB == p->sh_type) {
            if (symh) {
                LOGD(AY_OBFUSCATE("too many symbol tables\n"));
                goto out;
            }
            symh = p;
        } else if (SHT_DYNSYM == p->sh_type) {
            if (dynsymh) {
                LOGD(AY_OBFUSCATE("too many symbol tables\n"));
                goto out;
            }
            dynsymh = p;
        } else if (SHT_STRTAB == p->sh_type
                   && !strncmp(shstrtab + p->sh_name, AY_OBFUSCATE(".strtab"), 7)) {
            if (strh) {
                LOGD(AY_OBFUSCATE("too many string tables\n"));
                goto out;
            }
            strh = p;
        } else if (SHT_STRTAB == p->sh_type
                   && !strncmp(shstrtab + p->sh_name, AY_OBFUSCATE(".dynstr"), 7)) {
            if (dynstrh) {
                LOGD(AY_OBFUSCATE("too many string tables\n"));
                goto out;
            }
            dynstrh = p;
        }
    /* sanity checks */
    if ((!dynsymh && dynstrh) || (dynsymh && !dynstrh)) {
        LOGD(AY_OBFUSCATE("bad dynamic symbol table\n"));
        goto out;
    }
    if ((!symh && strh) || (symh && !strh)) {
        LOGD(AY_OBFUSCATE("bad symbol table\n"));
        goto out;
    }
    if (!dynsymh && !symh) {
        LOGD(AY_OBFUSCATE("no symbol table\n"));
        goto out;
    }

    /* symbol tables */
    if (dynsymh)
        symtab->dyn = get_syms(fd, dynsymh, dynstrh);
    if (symh)
        symtab->st = get_syms(fd, symh, strh);
    ret = 0;
    out:
    free(shstrtab);
    free(shdr);
    return ret;
}

static symtab_t load_symtab(char *filename) {
    int fd;
    symtab_t symtab;

    symtab = (symtab_t) xmalloc(sizeof(*symtab));
    memset(symtab, 0, sizeof(*symtab));

    fd = open(filename, O_RDONLY);
    if (0 > fd) {
        LOGE(AY_OBFUSCATE("%s open\n"), __func__);
        return NULL;
    }
    if (0 > do_load(fd, symtab)) {
        LOGE(AY_OBFUSCATE("Error ELF parsing %s\n"), filename);
        free(symtab);
        symtab = NULL;
    }
    close(fd);
    return symtab;
}

static int load_memmap(pid_t pid, struct mm *mm, int *nmmp) {
    size_t buf_size = 0x40000;
    char *p_buf = (char *) malloc(buf_size); // increase this if needed for larger "maps"
    char name[MAX_NAME_LEN] = {0};
    char *p;
    unsigned long start, end;
    struct mm *m;
    int nmm = 0;
    int fd, rv;
    int i;

    sprintf(p_buf, AY_OBFUSCATE("/proc/%d/maps"), pid);
    fd = open(p_buf, O_RDONLY);
    if (0 > fd) {
        LOGE(AY_OBFUSCATE("Can't open %s for reading\n"), p_buf);
        free(p_buf);
        return -1;
    }

    /* Zero to ensure data is null terminated */
    memset(p_buf, 0, buf_size);

    p = p_buf;
    while (1) {
        rv = read(fd, p, buf_size - (p - p_buf));
        if (0 > rv) {
            LOGE(AY_OBFUSCATE("%s read"), __FUNCTION__);
            free(p_buf);
            return -1;
        }
        if (0 == rv)
            break;
        p += rv;
        if (p - p_buf >= buf_size) {
            LOGE(AY_OBFUSCATE("Too many memory mapping\n"));
            free(p_buf);
            return -1;
        }
    }
    close(fd);

    p = strtok(p_buf, "\n");
    m = mm;
    while (p) {
        /* parse current map line */
        rv = sscanf(p, AY_OBFUSCATE("%08lx-%08lx %*s %*s %*s %*s %s\n"), &start, &end, name);

        p = strtok(NULL, "\n");

        if (rv == 2) {
            m = &mm[nmm++];
            m->start = start;
            m->end = end;
            memcpy(m->name, MEMORY_ONLY, sizeof(MEMORY_ONLY));
            continue;
        }

        /* search backward for other mapping with same name */
        for (i = nmm - 1; i >= 0; i--) {
            m = &mm[i];
            if (!strcmp(m->name, name))
                break;
        }

        if (i >= 0) {
            if (start < m->start)
                m->start = start;
            if (end > m->end)
                m->end = end;
        } else {
            /* new entry */
            m = &mm[nmm++];
            m->start = start;
            m->end = end;
            memcpy(m->name, name, strlen(name));
        }
    }

    *nmmp = nmm;
    free(p_buf);
    return 0;
}

/* Find libc in MM, storing no more than LEN-1 chars of
 its name in NAME and set START to its starting
 address.  If libc cannot be found return -1 and
 leave NAME and START untouched.  Otherwise return 0
 and null-terminated NAME. */
static int find_libname(const char *libn, char *name, int len, unsigned long *start,
                        struct mm *mm, int nmm) {
    int i;
    struct mm *m;
    char *p;
    for (i = 0, m = mm; i < nmm; i++, m++) {
        if (!strcmp(m->name, MEMORY_ONLY))
            continue;
        p = strrchr(m->name, '/');
        if (!p)
            continue;
        p++;
        if (strncmp(libn, p, strlen(libn)))
            continue;
        p += strlen(libn);

        /* here comes our crude test -> 'libc.so' or 'libc-[0-9]' */
        if (!strncmp(AY_OBFUSCATE("so"), p, 2) || 1) // || (p[0] == '-' && isdigit(p[1])))
            break;
    }
    if (i >= nmm)
        /* not found */
        return -1;

    *start = m->start;
    strncpy(name, m->name, len);
    if (strlen(m->name) >= len)
        name[len - 1] = '\0';

    mprotect((void *) m->start, m->end - m->start,
             PROT_READ | PROT_WRITE | PROT_EXEC);
    return 0;
}

static int lookup2(struct symlist *sl, unsigned char type, char *name,
                   unsigned long *val) {
    Elf32_Sym *p;
    int len;
    int i;

    len = strlen(name);
    for (i = 0, p = sl->sym; i < sl->num; i++, p++) {
        //LOGD("name: %s %x\n", sl->str+p->st_name, p->st_value)
        if (!strncmp(sl->str + p->st_name, name, len)
            && *(sl->str + p->st_name + len) == 0
            && ELF32_ST_TYPE(p->st_info) == type) {
            //if (p->st_value != 0) {
            *val = p->st_value;
            return 0;
            //}
        }
    }
    return -1;
}

static int lookup_sym(symtab_t s, unsigned char type, char *name,
                      unsigned long *val) {
    if (s->dyn && !lookup2(s->dyn, type, name, val))
        return 0;
    if (s->st && !lookup2(s->st, type, name, val))
        return 0;
    return -1;
}

static int lookup_func_sym(symtab_t s, char *name, unsigned long *val) {
    return lookup_sym(s, STT_FUNC, name, val);
}

int find_name(pid_t pid, const char *name, const char *libn,
              unsigned long *addr) {
    struct mm mm[1000] = {0};
    unsigned long libcaddr;
    int nmm;
    char libc[1024] = {0};
    symtab_t s;

    if (0 > load_memmap(pid, mm, &nmm)) {
        LOGD(AY_OBFUSCATE("cannot read memory map\n"));
        return -1;
    }
    if (0
        > find_libname((char *) libn, (char *) libc, sizeof(libc),
                       &libcaddr, mm, nmm)) {
        LOGD(AY_OBFUSCATE("cannot find lib: %s\n"), libn);
        return -1;
    }
    //LOGD("lib: >%s<\n", libc)
    s = load_symtab(libc);
    if (!s) {
        LOGD(AY_OBFUSCATE("cannot read symbol table\n"));
        return -1;
    }
    if (0 > lookup_func_sym(s, (char *) name, addr)) {
        LOGD(AY_OBFUSCATE("cannot find function: %s\n"), name);
        return -1;
    }
    *addr += libcaddr;
    return 0;
}

int find_libbase(pid_t pid, const char *libn, unsigned long *addr) {
    struct mm mm[1000] = {0};
    unsigned long libcaddr;
    int nmm;
    char libc[1024] = {0};
    symtab_t s;

    if (0 > load_memmap(pid, mm, &nmm)) {
        LOGD(AY_OBFUSCATE("cannot read memory map\n"));
        return -1;
    }
    if (0 > find_libname(libn, libc, sizeof(libc), &libcaddr, mm, nmm)) {
        LOGD(AY_OBFUSCATE("cannot find lib\n"));
        return -1;
    }
    *addr = libcaddr;
    return 0;
}

```

`app/src/main/cpp/LIBS/Substrate/SymbolFinder.h`:

```h
#ifndef SYMBOL_FINDER
#define SYMBOL_FINDER

#include <unistd.h>

extern int find_name(pid_t pid, const char *name,const  char *libn, unsigned long *addr);
extern int find_libbase(pid_t pid, const char *libn, unsigned long *addr);
#endif
```

`app/src/main/cpp/LIBS/Substrate/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include <stdint.h>
#include <string.h>

#include "hde64.h"
#include "table64.h"

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    memset(hs,0,sizeof(hde64s));
    char *tmp=(char*)hs;

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

```

`app/src/main/cpp/LIBS/Substrate/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include <stdint.h>

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b; 
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`app/src/main/cpp/LIBS/Substrate/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`app/src/main/cpp/MENU.hpp`:

```hpp
//
// Created by Askan on 10/22/2022.
//

#ifndef IMGUI_UNITY_TOUCH_MENU_HPP
#define IMGUI_UNITY_TOUCH_MENU_HPP

#include <EGL/egl.h>
#include <GLES2/gl2.h>
#include <GLES2/gl2ext.h>
#include <GLES2/gl2platform.h>
#include <imgui.h>
#include <imgui_impl_android.h>
#include <imgui_impl_opengl3.h>
#include <unistd.h>
#include "Misc/log.h"

namespace MENU {
    int (*GlWidth)();
    int (*GlHeight)();

    bool clearMouse = true, setup = false, dark;

    bool open = true, updatePos;
    static ImVec2 iconPos;
    static ImVec2 mainPos;
    static float clickDuration;

    ImGuiWindowFlags wFlags =
            ImGuiWindowFlags_NoResize |
            ImGuiWindowFlags_NoSavedSettings;

    void Init();
    void SetStyle(bool bStyleDark_, float alpha_);
    void Menu(const char *windowName, bool *open);

    void Init() {
        LOGI(OFC("IMGUI: Setup ...\n H:%i W:%i"), GlHeight(), GlWidth());
        if (!GlHeight && !GlWidth) {
            sleep(2);
            Init();
        }

        IMGUI_CHECKVERSION();

        ImGui::CreateContext();
        ImGuiIO &io = ImGui::GetIO();

        io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;
        io.ConfigFlags |= ImGuiConfigFlags_IsTouchScreen;

        io.IniFilename = NULL;
        io.KeyMap[ImGuiKey_UpArrow] = 19;
        io.KeyMap[ImGuiKey_DownArrow] = 20;
        io.KeyMap[ImGuiKey_LeftArrow] = 21;
        io.KeyMap[ImGuiKey_RightArrow] = 22;
        io.KeyMap[ImGuiKey_Enter] = 66;
        io.KeyMap[ImGuiKey_Backspace] = 67;
        io.KeyMap[ImGuiKey_PageUp] = 92;
        io.KeyMap[ImGuiKey_PageDown] = 93;
        io.KeyMap[ImGuiKey_Escape] = 111;
        io.KeyMap[ImGuiKey_Delete] = 112;
        io.KeyMap[ImGuiKey_Home] = 122;
        io.KeyMap[ImGuiKey_End] = 123;
        io.KeyMap[ImGuiKey_Insert] = 124;
        io.KeyMap[ImGuiKey_UpArrow] = 19;
        io.KeyMap[ImGuiKey_DownArrow] = 20;
        io.KeyMap[ImGuiKey_LeftArrow] = 21;
        io.KeyMap[ImGuiKey_RightArrow] = 22;
        io.KeyMap[ImGuiKey_Enter] = 66;
        io.KeyMap[ImGuiKey_Backspace] = 67;
        io.KeyMap[ImGuiKey_PageUp] = 92;
        io.KeyMap[ImGuiKey_PageDown] = 93;
        io.KeyMap[ImGuiKey_Escape] = 111;
        io.KeyMap[ImGuiKey_Delete] = 112;
        io.KeyMap[ImGuiKey_Home] = 122;
        io.KeyMap[ImGuiKey_End] = 123;
        io.KeyMap[ImGuiKey_Insert] = 124;

        SetStyle(true, 0.8f);

        ImGui_ImplOpenGL3_Init(OFC("#version 300 es"));
        ImGui_ImplAndroid_Init(nullptr);
        ImFontConfig font_cfg;
        font_cfg.SizePixels = 24.0f;
        io.Fonts->AddFontDefault(&font_cfg);

        ImGui::GetStyle().ScaleAllSizes(3.0f);
        setup = true;
    }
    void SetStyle(bool bStyleDark_, float alpha_) {
        LOGI(OFC("IMGUI: Set Style ...\n dark: %i alpha: %.2f"), bStyleDark_, alpha_);

        ImGuiStyle &style = ImGui::GetStyle();

        // light style from Pacôme Danhiez (user itamago) https://github.com/ocornut/imgui/pull/511#issuecomment-175719267
        style.Alpha = 1.0f;
        style.FrameRounding = 3.0f;
        style.WindowRounding = 5.0f;
        style.FrameRounding = 2.3f;
        style.ScrollbarRounding = 5.0f;
        style.ChildRounding = 4.0f;

        style.Colors[ImGuiCol_Text] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(0.94f, 0.94f, 0.94f, 0.94f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(1.00f, 1.00f, 1.00f, 0.94f);
        style.Colors[ImGuiCol_Border] = ImVec4(0.00f, 0.00f, 0.00f, 0.39f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(1.00f, 1.00f, 1.00f, 0.10f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(1.00f, 1.00f, 1.00f, 0.94f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.69f, 0.69f, 0.69f, 1.00f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.59f, 0.59f, 0.59f, 1.00f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
        style.Colors[ImGuiCol_Button] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
        style.Colors[ImGuiCol_Header] = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(1.00f, 1.00f, 1.00f, 0.50f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);

        if (bStyleDark_) {
            for (int i = 0; i <= ImGuiCol_COUNT; i++) {
                ImVec4 &col = style.Colors[i];
                float H, S, V;
                ImGui::ColorConvertRGBtoHSV(col.x, col.y, col.z, H, S, V);

                if (S < 0.1f) {
                    V = 1.0f - V;
                }
                ImGui::ColorConvertHSVtoRGB(H, S, V, col.x, col.y, col.z);
                if (col.w < 1.00f) {
                    col.w *= alpha_;
                }
            }
        } else {
            for (int i = 0; i <= ImGuiCol_COUNT; i++) {
                ImVec4 &col = style.Colors[i];
                if (col.w < 1.00f) {
                    col.x *= alpha_;
                    col.y *= alpha_;
                    col.z *= alpha_;
                    col.w *= alpha_;
                }
            }
        }
    }
    void TextCenter(ImColor color, const char* text, ...)
    {
        float windowWidth = ImGui::GetWindowSize().x;
        float textWidth = ImGui::CalcTextSize(text).x;
        va_list args;
        va_start(args, text);

        ImGui::SetCursorPosX((windowWidth - textWidth) * 0.5f);
        ImGui::TextColoredV(color, text, args);

        va_end(args);
    }

    float fov;
    void Menu(const char *windowName, bool isVertical = false) {
        ImGuiIO &io = ImGui::GetIO();
        if (open) {
            isVertical ? ImGui::SetNextWindowSize(ImVec2(io.DisplaySize.x / 1.25f, io.DisplaySize.y / 2.5f), ImGuiCond_Always) : ImGui::SetNextWindowSize(ImVec2(io.DisplaySize.x / 2.5f, io.DisplaySize.y / 1.15f), ImGuiCond_Always);
            ImGui::GetStyle().WindowPadding = ImVec2(0.8f,0.8f);
            if (updatePos) {
                ImGui::SetNextWindowPos(iconPos);
                updatePos = false;
            }

            ImGui::Begin(windowName, nullptr, wFlags);
            TextCenter(ImColor(255,255,0), OFC("Mod By Askan"));

            ImGui::SliderFloat(OFC("FOV"), &fov, 20.0f, 200.0f, OFC("%.3f"), 0);
            if (ImGui::Button(OFC("Set FOV"), ImVec2(ImGui::GetContentRegionAvail().x - 1.0f, ImGui::GetContentRegionAvail().y / 6.0f))) {
                LOGI(OFC("SCREEN: \n W: %i H: %i"), MENU::GlWidth(), MENU::GlHeight());
            }


            if (ImGui::Button(OFC("Close"), ImVec2(ImGui::GetContentRegionAvail().x/4.0f, 50.0f))) {
                mainPos = ImGui::GetMousePos();
                open = false;
                updatePos = true;
            }
            ImGui::End();
        } else {
            float size = isVertical ? io.DisplaySize.y / 12.5f : io.DisplaySize.x / 12.5f;
            ImGui::SetNextWindowSize(ImVec2(size, size), ImGuiCond_Always);
            ImGui::GetStyle().WindowPadding = ImVec2(0.0f,0.0f);
            if (updatePos) {
                ImGui::SetNextWindowPos(mainPos);
                updatePos = false;
            }

            int m_downCount = IM_ARRAYSIZE(io.MouseDown);

            ImGui::Begin(OFC("Mod Icon"), nullptr,
                         ImGuiWindowFlags_NoTitleBar |
                         ImGuiWindowFlags_NoResize |
                         ImGuiWindowFlags_NoSavedSettings);

            if (ImGui::Button(OFC("Mod"), ImGui::GetContentRegionAvail())) {
                if (clickDuration > 0.3f) goto skip;

                iconPos = ImGui::GetWindowPos();
                open = true;
                updatePos = true;

                skip:;
            }
            if (ImGui::IsItemActive()) {
                for (int i = 0; i < m_downCount; i++) {
                    if (ImGui::IsMouseDown(i))  {
                        if  (io.MouseDownDuration[i] > 0.3f)
                                ImGui::SetWindowPos(
                                        ImVec2(ImGui::GetMousePos().x - ImGui::GetWindowSize().x / 2,
                                               ImGui::GetMousePos().y - ImGui::GetWindowSize().y / 2), 0);

                        clickDuration = io.MouseDownDuration[i];
                    }
                }
            }

            ImGui::End();
        }
    }
}


#endif //IMGUI_UNITY_TOUCH_MENU_HPP

```

`app/src/main/cpp/Misc/ImGuiUtils.h`:

```h
#ifndef IMGUI_UNITY_TOUCH_IMGUIUTILS_H
#define IMGUI_UNITY_TOUCH_IMGUIUTILS_H

IMGUI_IMPL_API int32_t  ImGui_Android_HandleInputEvent(int x, int y, int type);
IMGUI_IMPL_API void     ImGui_AndroidNewFrame(int window_width, int window_height);

static double g_Time = 0.0;

int32_t ImGui_Android_HandleInputEvent(int x, int y, int type = 0)
{
    ImGuiIO& io = ImGui::GetIO();

    switch (type)
    {
        case 0:
            io.MouseDown[0] = true;
            break;
        case 1:
            io.MouseDown[0] = false;
            break;
        default:
            break;
    }
    io.MousePos = ImVec2((float)x, (float)y);
    return 0;
}

void ImGui_AndroidNewFrame(int window_width, int window_height)
{
    ImGuiIO& io = ImGui::GetIO();

    // Setup display size (every frame to accommodate for window resizing)
    int display_width = window_width;
    int display_height = window_height;

    io.DisplaySize = ImVec2((float)window_width, (float)window_height);
    if (window_width > 0 && window_height > 0)
        io.DisplayFramebufferScale = ImVec2((float)display_width / window_width, (float)display_height / window_height);

    // Setup time step
    struct timespec currentTimeSpec{};
    clock_gettime(CLOCK_MONOTONIC, &currentTimeSpec);
    double current_time = (double)(currentTimeSpec.tv_sec) + (currentTimeSpec.tv_nsec / 1000000000.0);
    io.DeltaTime = g_Time > 0.0 ? (float)(current_time - g_Time) : (float)(1.0f / 60.0f);
    g_Time = current_time;
}

#endif
```

`app/src/main/cpp/Misc/JNIHooks.h`:

```h
//
// Created by Admin on 10/25/2022.
//

#ifndef IMGUI_UNITY_TOUCH_JNIHOOKS_H
#define IMGUI_UNITY_TOUCH_JNIHOOKS_H
#include "ImGuiUtils.h"

jmethodID MotionEvent_getX;
jmethodID MotionEvent_getY;
jmethodID MotionEvent_getAction;
jmethodID KeyEvent_getUnicodeChar;
jmethodID KeyEvent_getMetaState;
jmethodID KeyEvent_getAction;
jmethodID KeyEvent_getKeyCode;
jboolean (*old_nativeInjectEvent)(JNIEnv *, jobject, jobject);
jboolean nativeInjectEvent(JNIEnv *env, jobject thiz, jobject inputEvent)
{
    if (MENU::setup)
    {
        jclass MotionEventCls = env->FindClass(OFC("android/view/MotionEvent"));
        jclass KeyEventCls = env->FindClass(OFC("android/view/KeyEvent"));
        if (env->IsInstanceOf(inputEvent, MotionEventCls))
        {
            if (!MotionEvent_getX)
                MotionEvent_getX = env->GetMethodID(MotionEventCls, OFC("getX"),
                                                    OFC("()F"));
            if (!MotionEvent_getY)
                MotionEvent_getY = env->GetMethodID(MotionEventCls, OFC("getY"),
                                                    OFC("()F"));
            if (!MotionEvent_getAction)
                MotionEvent_getAction = env->GetMethodID(MotionEventCls, OFC("getAction"),
                                                         OFC("()I"));
            ImGuiIO &io = ImGui::GetIO();
            auto x = env->CallFloatMethod(inputEvent, MotionEvent_getX);
            auto y = env->CallFloatMethod(inputEvent, MotionEvent_getY);
            auto action = env->CallIntMethod(inputEvent,
                                             MotionEvent_getAction);
//            LOGD("X:%f\nY:%f\nAction:%i", x, y, action);

            ImGui_Android_HandleInputEvent(x,y,action);

            if (io.WantCaptureMouse)
                return true;
        } else if (env->IsInstanceOf(inputEvent, KeyEventCls))
        {
            if (!KeyEvent_getAction)
                KeyEvent_getAction = env->GetMethodID(KeyEventCls, OFC("getAction"),
                                                      OFC("()I"));
            if (env->CallIntMethod(inputEvent, KeyEvent_getAction) == 0)
            {
                if (!KeyEvent_getKeyCode)
                    KeyEvent_getKeyCode = env->GetMethodID(KeyEventCls, OFC("getKeyCode"),
                                                           OFC("()I"));
                if (!KeyEvent_getUnicodeChar)
                    KeyEvent_getUnicodeChar = env->GetMethodID(KeyEventCls,
                                                               OFC("getUnicodeChar"),
                                                               OFC("(I)I"));
                if (!KeyEvent_getMetaState)
                    KeyEvent_getMetaState = env->GetMethodID(KeyEventCls, OFC("getMetaState"),
                                                             OFC("()I"));
                ImGuiIO &io = ImGui::GetIO();
                int KeyCode = env->CallIntMethod(inputEvent, KeyEvent_getKeyCode);
                switch (KeyCode)
                {
                    case 19:
                        io.KeysDown[io.KeyMap[ImGuiKey_UpArrow]] = true;
                        break;
                    case 20:
                        io.KeysDown[io.KeyMap[ImGuiKey_DownArrow]] = true;
                        break;
                    case 21:
                        io.KeysDown[io.KeyMap[ImGuiKey_LeftArrow]] = true;
                        break;
                    case 22:
                        io.KeysDown[io.KeyMap[ImGuiKey_RightArrow]] = true;
                        break;
                    case 61:
                        io.KeysDown[io.KeyMap[ImGuiKey_Tab]] = true;
                        break;
                    case 66:
                        io.KeysDown[io.KeyMap[ImGuiKey_Enter]] = true;
                        break;
                    case 67:
                        io.KeysDown[io.KeyMap[ImGuiKey_Backspace]] = true;;
                        break;
                    case 92:
                        io.KeysDown[io.KeyMap[ImGuiKey_PageUp]] = true;
                        break;
                    case 93:
                        io.KeysDown[io.KeyMap[ImGuiKey_PageDown]] = true;
                        break;
                    case 111:
                        io.KeysDown[io.KeyMap[ImGuiKey_Escape]] = true;
                        break;
                    case 112:
                        io.KeysDown[io.KeyMap[ImGuiKey_Delete]] = true;
                        break;
                    case 122:
                        io.KeysDown[io.KeyMap[ImGuiKey_Home]] = true;
                        break;
                    case 123:
                        io.KeysDown[io.KeyMap[ImGuiKey_End]] = true;
                        break;
                    case 124:
                        io.KeysDown[io.KeyMap[ImGuiKey_Insert]] = true;
                        break;
                    default:
                        io.AddInputCharacter(env->CallIntMethod(inputEvent, KeyEvent_getUnicodeChar,
                                                                env->CallIntMethod(inputEvent,
                                                                                   KeyEvent_getMetaState)));
                        break;
                }
            }
        }
    }
    return old_nativeInjectEvent(env, thiz, inputEvent);
}
jint (*orig_RegisterNatives)(JNIEnv*, jclass, const JNINativeMethod*, jint);
jint hook_RegisterNatives(JNIEnv* env, jclass klazz, const JNINativeMethod* methods, jint methodcount)
{
    for (int i = 0; i < methodcount; ++i)
    {
        auto method = methods[i];
        if (strcmp(method.name, OFC("nativeInjectEvent")) == 0)
        {
            DobbyHook((void *) method.fnPtr, (dobby_dummy_func_t) nativeInjectEvent,
                 (dobby_dummy_func_t *) &old_nativeInjectEvent);
        }
    }
    return orig_RegisterNatives(env, klazz, methods, methodcount);
}

#endif //IMGUI_UNITY_TOUCH_JNIHOOKS_H

```

`app/src/main/cpp/Misc/JNIUtils.hpp`:

```hpp
//
// Created by Admin on 10/22/2022.
//

#ifndef IMGUI_UNITY_TOUCH_JNIUTILS_HPP
#define IMGUI_UNITY_TOUCH_JNIUTILS_HPP
#include <jni.h>
#include "log.h"

JavaVM *jvm;
jclass cls_UnityPlayer;
jfieldID fid_CurrUnityPlayer;
JNIEnv* getEnv() {
    JNIEnv *env;
    int status = jvm->GetEnv((void**)&env, JNI_VERSION_1_6);
    if(status < 0) {
        status = jvm->AttachCurrentThread(&env, NULL);
        if(status < 0) {
            LOGE(OFC("Error Getting JNI"), 1);
            return nullptr;
        }
    }
    return env;
}
jobject getGlobalContext(JNIEnv *env)
{
    jclass activityThread = env->FindClass(OFC("android/app/ActivityThread"));
    jmethodID currentActivityThread = env->GetStaticMethodID(activityThread, OFC("currentActivityThread"), OFC("()Landroid/app/ActivityThread;"));
    jobject at = env->CallStaticObjectMethod(activityThread, currentActivityThread);
    jmethodID getApplication = env->GetMethodID(activityThread, OFC("getApplication"), OFC("()Landroid/app/Application;"));
    jobject context = env->CallObjectMethod(at, getApplication);
    return context;
}
void displayKeyboard(bool pShow) {
    JNIEnv *env = getEnv();
    jclass ctx = env->FindClass(OFC("android/content/Context"));
    jfieldID fid = env->GetStaticFieldID(ctx, OFC("INPUT_METHOD_SERVICE"), OFC("Ljava/lang/String;"));
    jmethodID mid = env->GetMethodID(ctx, OFC("getSystemService"), OFC("(Ljava/lang/String;)Ljava/lang/Object;"));
    jobject context = env->GetStaticObjectField(cls_UnityPlayer, fid_CurrUnityPlayer);
    jobject InputManObj = env->CallObjectMethod(context, mid, (jstring) env->GetStaticObjectField(ctx, fid));
    jclass ClassInputMethodManager = env->FindClass(OFC("android/view/inputmethod/InputMethodManager"));
    jmethodID toggleSoftInputId = env->GetMethodID(ClassInputMethodManager, OFC("toggleSoftInput"), OFC("(II)V"));
    if (pShow) {
        env->CallVoidMethod(InputManObj, toggleSoftInputId, 2, 0);
    } else {
        env->CallVoidMethod(InputManObj, toggleSoftInputId, 0, 0);
    }
}

#endif //IMGUI_UNITY_TOUCH_JNIUTILS_HPP

```

`app/src/main/cpp/Misc/Utils.h`:

```h
//
// Created by Admin on 10/23/2022.
//

#ifndef IMGUI_UNITY_TOUCH_UTILS_H
#define IMGUI_UNITY_TOUCH_UTILS_H

#include <cstdio>
#include <string>
#include <dobby.h>
#include "obfuscate.h"

#define OFC(data) AY_OBFUSCATE_KEY(data, AY_OBFUSCATE_DEFAULT_KEY)

typedef uint64_t DWORD;

static DWORD address;
bool libLoaded;

DWORD findLibrary(const char *library) {
    char filename[0xFF] = {0},
            buffer[1024] = {0};
    FILE *fp = NULL;
    DWORD _address = 0;

    sprintf(filename, OFC("/proc/self/maps"));

    fp = fopen(filename, ("rt"));
    if (fp == NULL) {
        perror(("fopen"));
        goto done;
    }

    while (fgets(buffer, sizeof(buffer), fp)) {
        if (strstr(buffer, library)) {
            address = (DWORD) strtoul(buffer, NULL, 16);
            goto done;
        }
    }

    done:

    if (fp) {
        fclose(fp);
    }

    return _address;
}

DWORD getAbsoluteAddress(const char *libraryName, DWORD relativeAddress) {
    address = findLibrary(libraryName);
    if (address == 0)
        return 0;
    return (reinterpret_cast<DWORD>(address + relativeAddress));
}

bool isLibraryLoaded(const char *libName) {
    char line[512] = {0};
    FILE *fp = fopen(OFC("/proc/self/maps"), OFC("rt"));
    if (fp != NULL) {
        while (fgets(line, sizeof(line), fp)) {
            std::string a = line;
            if (strstr(line, libName)) {
                libLoaded = true;
                return true;
            }
        }
        fclose(fp);
    }
    return false;
}

uintptr_t string2Offset(const char *c) {
    int base = 16;
    // See if this function catches all possibilities.
    // If it doesn't, the function would have to be amended
    // whenever you add a combination of architecture and
    // compiler that is not yet addressed.
    static_assert(sizeof(uintptr_t) == sizeof(unsigned long)
                  || sizeof(uintptr_t) == sizeof(unsigned long long),
                  "Please add string to handle conversion for this architecture.");

    return strtoul(c, nullptr, base);
}

#endif //IMGUI_UNITY_TOUCH_UTILS_H

```

`app/src/main/cpp/Misc/log.h`:

```h
//
// Created by Admin on 10/23/2022.
//

#ifndef IMGUI_UNITY_TOUCH_LOG_H
#define IMGUI_UNITY_TOUCH_LOG_H
#include <android/log.h>
#include "Utils.h"

#define LOG_TAG OFC("ModMenu")

#define LOGD(...) ((void)__android_log_print(3, LOG_TAG, __VA_ARGS__))
#define LOGE(...) ((void)__android_log_print(6, LOG_TAG, __VA_ARGS__))
#define LOGI(...) ((void)__android_log_print(4,  LOG_TAG, __VA_ARGS__))
#define LOGW(...) ((void)__android_log_print(5,  LOG_TAG, __VA_ARGS__))


#endif //IMGUI_UNITY_TOUCH_LOG_H

```

`app/src/main/cpp/Misc/obfuscate.h`:

```h
//
// Created by Admin on 10/23/2022.
//

#ifndef IMGUI_UNITY_TOUCH_OBFUSCATE_H
#define IMGUI_UNITY_TOUCH_OBFUSCATE_H

/* --------------------------------- ABOUT -------------------------------------
Original Author: Adam Yaxley
Website: https://github.com/adamyaxley
License: See end of file
Obfuscate
Guaranteed compile-time string literal obfuscation library for C++14
Usage:
Pass string literals into the AY_OBFUSCATE macro to obfuscate them at compile
time. AY_OBFUSCATE returns a reference to an ay::obfuscated_data object with the
following traits:
	- Guaranteed obfuscation of string
	The passed string is encrypted with a simple XOR cipher at compile-time to
	prevent it being viewable in the binary image
	- Global lifetime
	The actual instantiation of the ay::obfuscated_data takes place inside a
	lambda as a function level static
	- Implicitly convertable to a char*
	This means that you can pass it directly into functions that would normally
	take a char* or a const char*
Example:
const char* obfuscated_string = AY_OBFUSCATE("Hello World");
std::cout << obfuscated_string << std::endl;
----------------------------------------------------------------------------- */

// Workaround for __LINE__ not being constexpr when /ZI (Edit and Continue) is enabled in Visual Studio
// See: https://developercommunity.visualstudio.com/t/-line-cannot-be-used-as-an-argument-for-constexpr/195665
#ifdef _MSC_VER
#define AY_CAT(X,Y) AY_CAT2(X,Y)
	#define AY_CAT2(X,Y) X##Y
	#define AY_LINE int(AY_CAT(__LINE__,U))
#else
#define AY_LINE __LINE__
#endif

#ifndef AY_OBFUSCATE_DEFAULT_KEY
// The default 64 bit key to obfuscate strings with.
// This can be user specified by defining AY_OBFUSCATE_DEFAULT_KEY before
// including obfuscate.h
#define AY_OBFUSCATE_DEFAULT_KEY ay::generate_key(AY_LINE)
#endif

namespace ay
{
    using size_type = unsigned long long;
    using key_type = unsigned long long;

    // Generate a pseudo-random key that spans all 8 bytes
    constexpr key_type generate_key(key_type seed)
{
    // Use the MurmurHash3 64-bit finalizer to hash our seed
    key_type key = seed;
    key ^= (key >> 33);
    key *= 0xff51afd7ed558ccd;
    key ^= (key >> 33);
    key *= 0xc4ceb9fe1a85ec53;
    key ^= (key >> 33);

    // Make sure that a bit in each byte is set
    key |= 0x0101010101010101ull;

    return key;
}

// Obfuscates or deobfuscates data with key
constexpr void cipher(char* data, size_type size, key_type key)
{
    // Obfuscate with a simple XOR cipher based on key
    for (size_type i = 0; i < size; i++)
    {
        data[i] ^= char(key >> ((i % 8) * 8));
    }
}

// Obfuscates a string at compile time
template <size_type N, key_type KEY>
class obfuscator
{
public:
    // Obfuscates the string 'data' on construction
    constexpr obfuscator(const char* data)
    {
        // Copy data
        for (size_type i = 0; i < N; i++)
        {
            m_data[i] = data[i];
        }

        // On construction each of the characters in the string is
        // obfuscated with an XOR cipher based on key
        cipher(m_data, N, KEY);
    }

    constexpr const char* data() const
    {
        return &m_data[0];
    }

    constexpr size_type size() const
    {
        return N;
    }

    constexpr key_type key() const
    {
        return KEY;
    }

private:

    char m_data[N]{};
};

// Handles decryption and re-encryption of an encrypted string at runtime
template <size_type N, key_type KEY>
class obfuscated_data
{
public:
    obfuscated_data(const obfuscator<N, KEY>& obfuscator)
    {
        // Copy obfuscated data
        for (size_type i = 0; i < N; i++)
        {
            m_data[i] = obfuscator.data()[i];
        }
    }

    ~obfuscated_data()
    {
        // Zero m_data to remove it from memory
        for (size_type i = 0; i < N; i++)
        {
            m_data[i] = 0;
        }
    }

    // Returns a pointer to the plain text string, decrypting it if
    // necessary
    operator char*()
    {
        decrypt();
        return m_data;
    }

    // Manually decrypt the string
    void decrypt()
    {
        if (m_encrypted)
        {
            cipher(m_data, N, KEY);
            m_encrypted = false;
        }
    }

    // Manually re-encrypt the string
    void encrypt()
    {
        if (!m_encrypted)
        {
            cipher(m_data, N, KEY);
            m_encrypted = true;
        }
    }

    // Returns true if this string is currently encrypted, false otherwise.
    bool is_encrypted() const
    {
        return m_encrypted;
    }

private:

    // Local storage for the string. Call is_encrypted() to check whether or
    // not the string is currently obfuscated.
    char m_data[N];

    // Whether data is currently encrypted
    bool m_encrypted{ true };
};

// This function exists purely to extract the number of elements 'N' in the
// array 'data'
template <size_type N, key_type KEY = AY_OBFUSCATE_DEFAULT_KEY>
constexpr auto make_obfuscator(const char(&data)[N])
{
    return obfuscator<N, KEY>(data);
}
}

// Obfuscates the string 'data' at compile-time and returns a reference to a
// ay::obfuscated_data object with global lifetime that has functions for
// decrypting the string and is also implicitly convertable to a char*
#define AY_OBFUSCATE(data) AY_OBFUSCATE_KEY(data, AY_OBFUSCATE_DEFAULT_KEY)

// Obfuscates the string 'data' with 'key' at compile-time and returns a
// reference to a ay::obfuscated_data object with global lifetime that has
// functions for decrypting the string and is also implicitly convertable to a
// char*
#define AY_OBFUSCATE_KEY(data, key) \
	[]() -> ay::obfuscated_data<sizeof(data)/sizeof(data[0]), key>& { \
		static_assert(sizeof(decltype(key)) == sizeof(ay::key_type), "key must be a 64 bit unsigned integer"); \
		static_assert((key) >= (1ull << 56), "key must span all 8 bytes"); \
		constexpr auto n = sizeof(data)/sizeof(data[0]); \
		constexpr auto obfuscator = ay::make_obfuscator<n, key>(data); \
		thread_local auto obfuscated_data = ay::obfuscated_data<n, key>(obfuscator); \
		return obfuscated_data; \
	}()

/* -------------------------------- LICENSE ------------------------------------
Public Domain (http://www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
----------------------------------------------------------------------------- */


#endif //IMGUI_UNITY_TOUCH_OBFUSCATE_H

```

`app/src/main/cpp/native-lib.cpp`:

```cpp
#include "MENU.hpp"
#include "Misc/log.h"
#include "Misc/JNIUtils.hpp"
#include "Misc/JNIHooks.h"

#include <ByNameModding/BNM.hpp>
#include <dobby.h>

#include <dlfcn.h>
#include <jni.h>
#include <unistd.h>

#define targetLib OFC("libil2cpp.so")

// Hook eglSwapBuffers for rendering ImGui
EGLBoolean (*old_eglSwapBuffers)(EGLDisplay dpy, EGLSurface surface);
EGLBoolean hook_eglSwapBuffers(EGLDisplay dpy, EGLSurface surface) {
    if (!MENU::setup) {
        MENU::Init();
    }

    ImGuiIO &io = ImGui::GetIO();

    // Start the Dear ImGui frame
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_AndroidNewFrame(MENU::GlWidth(), MENU::GlHeight());
    ImGui::NewFrame();

    // Render ImGui windows here.
    MENU::Menu("Mod Menu", true);

    // Rendering
    ImGui::EndFrame();
    ImGui::Render();
    glViewport(0, 0, (int)ImGui::GetIO().DisplaySize.x, (int)ImGui::GetIO().DisplaySize.y);
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

    io.KeysDown[io.KeyMap[ImGuiKey_UpArrow]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_DownArrow]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_LeftArrow]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_RightArrow]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_Tab]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_Enter]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_Backspace]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_PageUp]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_PageDown]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_Escape]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_Delete]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_Home]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_End]] = false;
    io.KeysDown[io.KeyMap[ImGuiKey_Insert]] = false;

    if (MENU::clearMouse) {
        io.MousePos = ImVec2(-1, -1);
        MENU::clearMouse = false;
    }

    return old_eglSwapBuffers(dpy, surface);
}

void hack_thread() {
    LOGI(OFC("Hack Thread Started"));
    sleep(3);
    do {
        sleep(1);
    } while (!isLibraryLoaded(targetLib));
    BNM::AttachIl2Cpp();

    InitResolveFunc(MENU::GlHeight, std::string(OFC("UnityEngine.Screen::get_height")));
    InitResolveFunc(MENU::GlWidth, std::string(OFC("UnityEngine.Screen::get_width")));

    address = findLibrary(targetLib);

    // Get eglHandle ptr
    auto eglHandle = dlopen(OFC("libunity.so"), RTLD_LAZY);
    if (!eglHandle) {
        LOGE(OFC("Failed to get eglHandle address: %s"), dlerror());
        BNM::DetachIl2Cpp();
        pthread_exit(nullptr);
    }
    dlerror();    /* Clear any existing error */
    // Get eglSwapBuffers ptr
    auto eglSwapBuffers = dlsym(eglHandle, OFC("eglSwapBuffers"));
    if (!eglSwapBuffers) {
        LOGE(OFC("Failed to get eglSwapBuffers address: %s"), dlerror());
        BNM::DetachIl2Cpp();
        pthread_exit(nullptr);
    }

//    auto eglSwapBuffersAddress = (uintptr_t)dlsym(RTLD_NEXT, "eglSwapBuffers");

    // Hook eglSwapBuffer
    LOGI(OFC("eglSwapBuffer Address: %p"), eglSwapBuffers);
    DobbyHook(eglSwapBuffers, (dobby_dummy_func_t) hook_eglSwapBuffers,
              (dobby_dummy_func_t *) &old_eglSwapBuffers);


    dlclose(eglHandle);
    BNM::DetachIl2Cpp();
    pthread_exit(nullptr);
}

#include <thread>
[[maybe_unused]] __attribute__((constructor))
void lib_main() { std::thread(hack_thread).detach(); }

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void * reserved)
{
    JNIEnv *env;
    vm->GetEnv((void **) &env, JNI_VERSION_1_6);

    BNM::HardBypass(env);

    cls_UnityPlayer = env->FindClass(OFC("com/unity3d/player/UnityPlayer"));
    fid_CurrUnityPlayer = env->GetStaticFieldID(cls_UnityPlayer,
                                                            OFC("currentActivity"),
                                                            OFC("Landroid/app/Activity;"));

    DobbyHook((void*)env->functions->RegisterNatives,
              (dobby_dummy_func_t)hook_RegisterNatives,
              (dobby_dummy_func_t *)&orig_RegisterNatives);

    return JNI_VERSION_1_6;
}

```

`app/src/main/java/id/akn/imguiunitytouch/MainActivity.java`:

```java
package id.akn.imguiunitytouch;

import android.app.Activity;
import android.os.Bundle;
import android.widget.Toast;
import java.util.Objects;

public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (!Objects.equals(this.getPackageName(), "id.akn.imguiunitytouch")) {
            System.loadLibrary("ModMenu");
        }

        Toast.makeText(this, "ImGui Unity Touch by Askan", Toast.LENGTH_LONG).show();
    }
}
```

`app/src/main/res/drawable-v24/ic_launcher_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>
```

`app/src/main/res/drawable/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#3DDC84"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>

```

`app/src/main/res/layout/activity_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity">

</LinearLayout>
```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
</resources>
```

`app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name">ImGui Unity Touch</string>
</resources>
```

`app/src/main/res/xml/backup_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older that API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>
```

`app/src/main/res/xml/data_extraction_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>
```

`app/src/test/java/id/akn/imguiunitytouch/ExampleUnitTest.java`:

```java
package id.akn.imguiunitytouch;

import org.junit.Test;

import static org.junit.Assert.*;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() {
        assertEquals(4, 2 + 2);
    }
}
```

`build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id 'com.android.application' version '7.2.2' apply false
    id 'com.android.library' version '7.2.2' apply false
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
```

`build_so.ps1`:

```ps1
cmake -Happ\src\main\cpp -Btmp -DANDROID_ABI=armeabi-v7a -DANDROID_PLATFORM=android-21 -DANDROID_NDK=D:\Android\Sdks\Sdk-win64\ndk\21.4.7075529 -DCMAKE_TOOLCHAIN_FILE=D:\Android\Sdks\Sdk-win64\ndk\21.4.7075529\build\cmake\android.toolchain.cmake -G Ninja -DCMAKE_MAKE_PROGRAM=D:\Android\Sdks\Sdk-win64\cmake\3.18.1\bin\ninja.exe -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_SYSTEM_NAME=Android -DCMAKE_SYSTEM_VERSION=21 -DANDROID_STL=c++_static
```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app"s APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true
```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Sat Oct 22 20:06:51 ICT 2022
distributionBase=GRADLE_USER_HOME
distributionUrl=https\://services.gradle.org/distributions/gradle-7.3.3-bin.zip
distributionPath=wrapper/dists
zipStorePath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME

```

`gradlew`:

```
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`settings.gradle`:

```gradle
pluginManagement {
    repositories {
        gradlePluginPortal()
        google()
        mavenCentral()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}
rootProject.name = "ImGui Unity Touch"
include ':app'

```