Project Path: arc_gmh5225_HWID-SteamSpywareTerminator_fja1xyih

Source Tree:

```txt
arc_gmh5225_HWID-SteamSpywareTerminator_fja1xyih
├── README.md
├── SteamSpywareTerminator
│   ├── SteamSpywareTerminator.vcxproj
│   ├── SteamSpywareTerminator.vcxproj.filters
│   ├── dllmain.cpp
│   └── includes.h
└── SteamSpywareTerminator.sln

```

`README.md`:

```md
<div align="center">
  <h1>SteamSpywareTerminator</h1> (fuck you, burtonJ)
</div>

Work in progress (currently only logs thread initialization) library that once injected into steam, aims at blocking CSteamEngine::CFillMachineInfoThread which is a hidden thread that collects encrypted information regarding your hard drives, network adapters and optical peripherals with the lame purpose of blocking all your alternate accounts and make you lose thousands of money (and I don't really want to pay a dime more for burtonJ's salary)

## Reverse Engineering

You can find the instruction by looking up this string in IDA and xref:

<img src="https://i.imgur.com/kWk9Vi6.png">

You can't just terminate or return the thread, but interesting possibilities open up. That function is part of the only function (besides constructor, initiator and terminator/deconstructor) of a virtual table that inherits CScheduledFunction<CSteamEngine>.

'MachineGuid' is collected from registry and SHA1'd, possibly with a "BB3" constant? I know fuck nothing about encryption

<img src="https://i.imgur.com/G2W6vc1.png">

Other device registry information is then collected

<img src="https://i.imgur.com/diWvpFz.png">

At the same time, CIMV2 WMIC queries to retrieve network adapters are ran

<img src="https://i.imgur.com/WvnjhbH.png">

This time the above data is encrypted with the constant "FF2"? An interesting approach without blocking the entire thread could be changing these constants to alter the results of the digest. If Steam would fall back to not encrypting these strings they could be against GDPR as they are collecting information that can be classified as "personal data"

More queries follow up, the amount of data they collect is creepy.

"SELECT * FROM Win32_DiskPartition", they check BootPartitions, DeviceID, DiskIndex, again "SELECT * FROM Win32_DiskDrive", more stuff, then once AGAIN "SELECT * FROM Win32_PhysicalMedia", they check serials and manufacturer.

Encrypted again, "3B3" constant (?)

Finally, the second argument of the callee is encrypted (if not NULL) with the "333" constant (?)

```

`SteamSpywareTerminator.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31613.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SteamSpywareTerminator", "SteamSpywareTerminator\SteamSpywareTerminator.vcxproj", "{12BB0BE6-D873-46A7-ADB4-BB302A7CF3CD}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{12BB0BE6-D873-46A7-ADB4-BB302A7CF3CD}.Debug|x64.ActiveCfg = Debug|x64
		{12BB0BE6-D873-46A7-ADB4-BB302A7CF3CD}.Debug|x64.Build.0 = Debug|x64
		{12BB0BE6-D873-46A7-ADB4-BB302A7CF3CD}.Debug|x86.ActiveCfg = Debug|Win32
		{12BB0BE6-D873-46A7-ADB4-BB302A7CF3CD}.Debug|x86.Build.0 = Debug|Win32
		{12BB0BE6-D873-46A7-ADB4-BB302A7CF3CD}.Release|x64.ActiveCfg = Release|x64
		{12BB0BE6-D873-46A7-ADB4-BB302A7CF3CD}.Release|x64.Build.0 = Release|x64
		{12BB0BE6-D873-46A7-ADB4-BB302A7CF3CD}.Release|x86.ActiveCfg = Release|Win32
		{12BB0BE6-D873-46A7-ADB4-BB302A7CF3CD}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4611BB6C-1251-4820-8CE5-4559C11A5278}
	EndGlobalSection
EndGlobal

```

`SteamSpywareTerminator/SteamSpywareTerminator.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{12bb0be6-d873-46a7-adb4-bb302a7cf3cd}</ProjectGuid>
    <RootNamespace>SteamSpywareTerminator</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Users\19v\Downloads\MinHook_133_lib\include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Users\19v\Downloads\MinHook_133_lib\lib;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;STEAMSPYWARETERMINATOR_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;STEAMSPYWARETERMINATOR_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;STEAMSPYWARETERMINATOR_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;STEAMSPYWARETERMINATOR_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h" />
    <ClInclude Include="tier0thread.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SteamSpywareTerminator/SteamSpywareTerminator.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="File di origine">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="File di intestazione">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="File di risorse">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>File di origine</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="tier0thread.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`SteamSpywareTerminator/dllmain.cpp`:

```cpp
// dllmain.cpp : Definisce il punto di ingresso per l'applicazione DLL.
#include "includes.h"

extern "C" { __declspec(dllimport) void Init(); }

void __fastcall ThreadInit_hk(void* This, void* _EDX) // ecx actually but im just c+ping old code
{
    char* name = ((char*)(This) + 0x10);
    printf("[!] THREAD started... ID  %i which translates to: %s\n", This, name);
    if (name[15] == 'F' && name[19] == 'M') //CThread::SetName((CThread *)(v1 + 2912), "MachineIDInfoThread"); CSteamEngine::CFillMachineInfoThread
    {
        printf("RED ALERT RED ALERT BURTONJ TRACKING US, HANGING STEAM");
        TerminateThread(*((HANDLE*)This + 1), 0);
    }
}

void Init() {
    if (steamClient && tier0) {
        AllocConsole();
        SetConsoleTitleA("mmmm stean");
        freopen_s((FILE**)stdin, "conin$", "r", stdin);
        freopen_s((FILE**)stdout, "conout$", "w", stdout);
        std::cout << "steanSpywareTerminator build " __DATE__ << " " << __TIME__ << std::endl;

        if (MH_Initialize() != MH_OK)
        {
            std::cout << "[-] Failed to initialize hook management!" << std::endl;
        }

        std::cout << "logging all STEAN threads.........." << std::endl;

        if (MH_CreateHook(GetProcAddress(tier0, "?Init@CThread@@MAE_NXZ"), &ThreadInit_hk, reinterpret_cast<LPVOID*>(oThreadInit)) != MH_OK)
        {
            std::cout << "Failed to hook tier0->CThread::Init..." << std::endl;
        }
        printf("[+] tier0_s.dll->CThread::Init hooked...");

        DWORD OldProtection;

        VirtualProtect((LPVOID)(steamClient + 0x8AACF), sizeof(unsigned char), PAGE_EXECUTE_READWRITE, &OldProtection);
        *(unsigned char*)(steamClient + 0x8AACF) = 'a';
        VirtualProtect((LPVOID)(steamClient + 0x8AACF), sizeof(unsigned char), OldProtection, &OldProtection);

        if (MH_EnableHook(MH_ALL_HOOKS) != MH_OK)
        {
            std::cout << "Fatal Error!" << std::endl;
        }
    }
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hModule);
        CreateThread(0,0,(LPTHREAD_START_ROUTINE)Init,0,0,0);
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

`SteamSpywareTerminator/includes.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <string>
#include "MinHook.h"

#if defined _M_X64
#pragma comment(lib, "libMinHook.x64.lib")
#elif defined _M_IX86
#pragma comment(lib, "libMinHook-x86-v141-mtd.lib")
#endif

//38C8D964		?Init@CThread@@MAE_NXZ	tier0_s
//38C8D88C		?Terminate@CThread@@QAE_NH@Z	tier0_s
//38C8D944		?GetName@CThread@@QAEPBDXZ	tier0_s
//FillInMachineIDInfo()

HMODULE steamClient = GetModuleHandle("steamclient.dll");
HMODULE tier0 = GetModuleHandle("tier0_s.dll");

typedef void(__thiscall* cThreadInit)(void*);
static cThreadInit oThreadInit;
void __fastcall ThreadInit_hk(void* This, void* _EDX);

typedef const char* (__thiscall* cThreadGetNameFn)(void);
cThreadGetNameFn cThreadGetName = (cThreadGetNameFn)GetProcAddress(tier0, "?GetName@CThread@@QAEPBDXZ");
```