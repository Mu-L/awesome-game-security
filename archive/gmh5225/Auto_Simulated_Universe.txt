Project Path: arc_gmh5225_Auto_Simulated_Universe_d0lis89s

Source Tree:

```txt
arc_gmh5225_Auto_Simulated_Universe_d0lis89s
├── LICENSE
├── README.md
├── README_CHT.md
├── README_ENG.md
├── abyss
│   └── info_example.yml
├── abyss.py
├── align.bat
├── align_angle.py
├── gui
│   ├── __init__.py
│   ├── abyss.py
│   ├── choose.py
│   ├── common.py
│   └── config.py
├── gui.py
├── imgs
│   ├── abyss
│   │   ├── 1.jpg
│   │   ├── 1_star.jpg
│   │   ├── 2.jpg
│   │   ├── 2_stars.jpg
│   │   ├── 3.jpg
│   │   ├── 3_stars.jpg
│   │   ├── 4.jpg
│   │   ├── 5.jpg
│   │   ├── 6.jpg
│   │   ├── begin.jpg
│   │   ├── fail.jpg
│   │   ├── in.jpg
│   │   ├── mask_z.jpg
│   │   ├── team.jpg
│   │   └── z.jpg
│   ├── arrow.jpg
│   ├── arrow_1.jpg
│   ├── auto.jpg
│   ├── auto_1.jpg
│   ├── auto_2.jpg
│   ├── begin.jpg
│   ├── bonus.jpg
│   ├── bonus_c.jpg
│   ├── c.jpg
│   ├── choose_bless.jpg
│   ├── confirm.jpg
│   ├── conti.jpg
│   ├── drop.jpg
│   ├── drop_bless.jpg
│   ├── enhance.jpg
│   ├── enhance_fail.jpg
│   ├── event.jpg
│   ├── f.jpg
│   ├── fail.jpg
│   ├── fate.jpg
│   ├── fate_1.jpg
│   ├── fate_2.jpg
│   ├── fate_3.jpg
│   ├── fate_4.jpg
│   ├── floor
│   │   ├── ff1.jpg
│   │   ├── ff10.jpg
│   │   ├── ff11.jpg
│   │   ├── ff12.jpg
│   │   ├── ff13.jpg
│   │   ├── ff2.jpg
│   │   ├── ff3.jpg
│   │   ├── ff4.jpg
│   │   ├── ff5.jpg
│   │   ├── ff6.jpg
│   │   ├── ff7.jpg
│   │   ├── ff8.jpg
│   │   └── ff9.jpg
│   ├── icon.ico
│   ├── icon.jpg
│   ├── icon.png
│   ├── icon_m.png
│   ├── iconl.png
│   ├── image_quality.jpg
│   ├── init.jpg
│   ├── loc_arrow.jpg
│   ├── maps
│   │   ├── 10538
│   │   │   ├── init.jpg
│   │   │   ├── map_4080_4007_.jpg
│   │   │   └── target.jpg
│   │   ├── 11115
│   │   │   ├── init.jpg
│   │   │   ├── map_4013_4071_.jpg
│   │   │   └── target.jpg
│   │   ├── 12345
│   │   │   ├── init.jpg
│   │   │   ├── map_4072_3868_.jpg
│   │   │   └── target.jpg
│   │   ├── 12346
│   │   │   ├── init.jpg
│   │   │   ├── map_4071_4064_.jpg
│   │   │   └── target.jpg
│   │   ├── 12872
│   │   │   ├── init.jpg
│   │   │   ├── map_3934_3968_.jpg
│   │   │   └── target.jpg
│   │   ├── 13197
│   │   │   ├── init.jpg
│   │   │   ├── map_4080_4007_.jpg
│   │   │   └── target.jpg
│   │   ├── 13395
│   │   │   ├── init.jpg
│   │   │   ├── map_4029_4050_.jpg
│   │   │   └── target.jpg
│   │   ├── 16392
│   │   │   ├── init.jpg
│   │   │   ├── map_4068_3898_.jpg
│   │   │   └── target.jpg
│   │   ├── 17191
│   │   │   ├── init.jpg
│   │   │   ├── map_4039_4026_.jpg
│   │   │   └── target.jpg
│   │   ├── 18769
│   │   │   ├── init.jpg
│   │   │   ├── map_4025_4077_.jpg
│   │   │   └── target.jpg
│   │   ├── 19787
│   │   │   ├── init.jpg
│   │   │   ├── map_4015_4062_.jpg
│   │   │   └── target.jpg
│   │   ├── 20029
│   │   │   ├── init.jpg
│   │   │   ├── map_3983_4080_.jpg
│   │   │   └── target.jpg
│   │   ├── 22212
│   │   │   ├── init.jpg
│   │   │   ├── map_3924_3914_.jpg
│   │   │   └── target.jpg
│   │   ├── 23480
│   │   │   ├── init.jpg
│   │   │   ├── map_3966_3986_.jpg
│   │   │   └── target.jpg
│   │   ├── 25441
│   │   │   ├── init.jpg
│   │   │   ├── map_3964_4029_.jpg
│   │   │   └── target.jpg
│   │   ├── 26105
│   │   │   ├── init.jpg
│   │   │   ├── map_4082_3965_.jpg
│   │   │   └── target.jpg
│   │   ├── 26119
│   │   │   ├── init.jpg
│   │   │   ├── map_4077_4047_.jpg
│   │   │   └── target.jpg
│   │   ├── 30797
│   │   │   ├── init.jpg
│   │   │   ├── map_4079_4073_.jpg
│   │   │   └── target.jpg
│   │   ├── 31289
│   │   │   ├── init.jpg
│   │   │   ├── map_4001_4011_.jpg
│   │   │   └── target.jpg
│   │   ├── 31927
│   │   │   ├── init.jpg
│   │   │   ├── map_4085_4050_.jpg
│   │   │   └── target.jpg
│   │   ├── 37007
│   │   │   ├── init.jpg
│   │   │   ├── map_4085_4051_.jpg
│   │   │   └── target.jpg
│   │   ├── 38866
│   │   │   ├── init.jpg
│   │   │   ├── map_4014_3931_.jpg
│   │   │   └── target.jpg
│   │   ├── 40978
│   │   │   ├── init.jpg
│   │   │   ├── map_4000_4030_.jpg
│   │   │   └── target.jpg
│   │   ├── 42250
│   │   │   ├── init.jpg
│   │   │   ├── map_4082_3965_.jpg
│   │   │   └── target.jpg
│   │   ├── 43642
│   │   │   ├── init.jpg
│   │   │   ├── map_4082_4034_.jpg
│   │   │   └── target.jpg
│   │   ├── 45516
│   │   │   ├── init.jpg
│   │   │   ├── map_4065_4037_.jpg
│   │   │   └── target.jpg
│   │   ├── 45735
│   │   │   ├── init.jpg
│   │   │   ├── map_4070_4038_.jpg
│   │   │   └── target.jpg
│   │   ├── 46900
│   │   │   ├── init.jpg
│   │   │   ├── map_3942_3967_.jpg
│   │   │   └── target.jpg
│   │   ├── 4805
│   │   │   ├── init.jpg
│   │   │   ├── map_3975_4054_.jpg
│   │   │   └── target.jpg
│   │   ├── 49992
│   │   │   ├── init.jpg
│   │   │   ├── map_3987_3931_.jpg
│   │   │   └── target.jpg
│   │   ├── 51202
│   │   │   ├── init.jpg
│   │   │   ├── map_3954_4018_.jpg
│   │   │   └── target.jpg
│   │   ├── 52451
│   │   │   ├── init.jpg
│   │   │   ├── map_4073_3919_.jpg
│   │   │   └── target.jpg
│   │   ├── 53073
│   │   │   ├── init.jpg
│   │   │   ├── map_4076_4066_.jpg
│   │   │   └── target.jpg
│   │   ├── 56417
│   │   │   ├── init.jpg
│   │   │   ├── map_4022_4069_.jpg
│   │   │   └── target.jpg
│   │   ├── 5699
│   │   │   ├── init.jpg
│   │   │   ├── map_4036_3912_.jpg
│   │   │   └── target.jpg
│   │   ├── 57859
│   │   │   ├── init.jpg
│   │   │   ├── map_4039_3936_.jpg
│   │   │   └── target.jpg
│   │   ├── 58891
│   │   │   ├── init.jpg
│   │   │   ├── map_4071_3936_.jpg
│   │   │   └── target.jpg
│   │   ├── 63533
│   │   │   ├── init.jpg
│   │   │   ├── map_4094_3999_.jpg
│   │   │   └── target.jpg
│   │   ├── 65515
│   │   │   ├── init.jpg
│   │   │   ├── map_3936_4053_.jpg
│   │   │   └── target.jpg
│   │   ├── 65576
│   │   │   ├── init.jpg
│   │   │   ├── map_4059_3973_.jpg
│   │   │   └── target.jpg
│   │   ├── 67422
│   │   │   ├── init.jpg
│   │   │   ├── map_4077_4070_.jpg
│   │   │   └── target.jpg
│   │   ├── 67673
│   │   │   ├── init.jpg
│   │   │   ├── map_4052_4020_.jpg
│   │   │   └── target.jpg
│   │   ├── 68145
│   │   │   ├── init.jpg
│   │   │   ├── map_4022_3997_.jpg
│   │   │   └── target.jpg
│   │   ├── 70941
│   │   │   ├── init.jpg
│   │   │   ├── map_3982_3947_.jpg
│   │   │   └── target.jpg
│   │   ├── 73927
│   │   │   ├── init.jpg
│   │   │   ├── map_3960_3860_.jpg
│   │   │   └── target.jpg
│   │   ├── 74959
│   │   │   ├── init.jpg
│   │   │   ├── map_4017_3987_.jpg
│   │   │   └── target.jpg
│   │   ├── 75973
│   │   │   ├── init.jpg
│   │   │   ├── map_4019_4074_.jpg
│   │   │   └── target.jpg
│   │   ├── 78566
│   │   │   ├── init.jpg
│   │   │   ├── map_4043_4071_.jpg
│   │   │   └── target.jpg
│   │   ├── 78620
│   │   │   ├── init.jpg
│   │   │   ├── map_4036_4062_.jpg
│   │   │   └── target.jpg
│   │   ├── 81866
│   │   │   ├── init.jpg
│   │   │   ├── map_4070_3919_.jpg
│   │   │   └── target.jpg
│   │   ├── 85880
│   │   │   ├── init.jpg
│   │   │   ├── map_4019_3966_.jpg
│   │   │   └── target.jpg
│   │   ├── 86757
│   │   │   ├── init.jpg
│   │   │   ├── map_4082_4051_.jpg
│   │   │   └── target.jpg
│   │   ├── 89054
│   │   │   ├── init.jpg
│   │   │   ├── map_4066_3965_.jpg
│   │   │   └── target.jpg
│   │   ├── 89200
│   │   │   ├── init.jpg
│   │   │   ├── map_3936_4066_.jpg
│   │   │   └── target.jpg
│   │   ├── 89201
│   │   │   ├── init.jpg
│   │   │   ├── map_3964_4029_.jpg
│   │   │   └── target.jpg
│   │   ├── 89358
│   │   │   ├── init.jpg
│   │   │   ├── map_4027_4070_.jpg
│   │   │   └── target.jpg
│   │   ├── 9011
│   │   │   ├── init.jpg
│   │   │   ├── map_4073_3926_.jpg
│   │   │   └── target.jpg
│   │   ├── 91571
│   │   │   ├── init.jpg
│   │   │   ├── map_4074_3980_.jpg
│   │   │   └── target.jpg
│   │   ├── 94807
│   │   │   ├── init.jpg
│   │   │   ├── map_4090_4066_.jpg
│   │   │   └── target.jpg
│   │   ├── 96641
│   │   │   ├── init.jpg
│   │   │   ├── map_4042_4026_.jpg
│   │   │   └── target.jpg
│   │   ├── 97964
│   │   │   ├── init.jpg
│   │   │   ├── map_4062_4048_.jpg
│   │   │   └── target.jpg
│   │   ├── 98940
│   │   │   ├── init.jpg
│   │   │   ├── map_4047_4070_.jpg
│   │   │   └── target.jpg
│   │   ├── 9908
│   │   │   ├── init.jpg
│   │   │   ├── map_4084_4051_.jpg
│   │   │   └── target.jpg
│   │   ├── 99257
│   │   │   ├── init.jpg
│   │   │   ├── map_4032_4067_.jpg
│   │   │   └── target.jpg
│   │   └── 99570
│   │       ├── init.jpg
│   │       ├── map_3962_3910_.jpg
│   │       └── target.jpg
│   ├── mask.jpg
│   ├── mask_arrow.jpg
│   ├── mask_arrow1.jpg
│   ├── mask_bless.jpg
│   ├── mask_close.jpg
│   ├── mask_close1.jpg
│   ├── mask_echo.jpg
│   ├── mask_end.jpg
│   ├── mask_enhance.jpg
│   ├── mask_event.jpg
│   ├── mask_f.jpg
│   ├── mask_f1.jpg
│   ├── mask_fate.jpg
│   ├── mask_strange.jpg
│   ├── mask_z.jpg
│   ├── mini1.jpg
│   ├── mini2.jpg
│   ├── mini3.jpg
│   ├── mini4.jpg
│   ├── minimap_high.jpg
│   ├── money.jpg
│   ├── quit.jpg
│   ├── region.jpg
│   ├── run.jpg
│   ├── scr.jpg
│   ├── setting.jpg
│   ├── setting1.jpg
│   ├── setting2.jpg
│   ├── star.jpg
│   ├── start.jpg
│   ├── strange.jpg
│   ├── team.jpg
│   ├── team4.jpg
│   ├── text
│   ├── yes.jpg
│   └── z.jpg
├── info_example.yml
├── install_requirements.bat
├── notif.py
├── requirements.txt
├── requirements_notif.txt
├── run.bat
├── start.mp3
├── states.py
├── update.bat
├── update.py
└── utils
    ├── __init__.py
    ├── cleaner.py
    ├── config.py
    ├── find_duplicate_map.py
    ├── log.py
    ├── map_log.py
    ├── ocr.py
    ├── update_map.py
    └── utils.py

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 CHNZYX

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
[简体中文](README.md) | [繁体中文](README_CHT.md) | [English](README_ENG.md)

[项目文档](https://asu.stysqy.top/)

# Auto_Simulated_Universe
星穹铁道-模拟宇宙全自动化

有一定的断点回复功能，你可以切出去做其他事，切回来会继续自动化。

目前支持模拟宇宙所有世界

----------------------------------------------------------------------------------------------

## 免责声明
本软件是一个外部工具旨在自动化崩坏星轨的游戏玩法。它被设计成仅通过现有用户界面与游戏交互,并遵守相关法律法规。该软件包旨在提供简化和用户通过功能与游戏交互,并且它不打算以任何方式破坏游戏平衡或提供任何不公平的优势。该软件包不会以任何方式修改任何游戏文件或游戏代码。

This software is open source, free of charge and for learning and exchange purposes only. The developer team has the final right to interpret this project. All problems arising from the use of this software are not related to this project and the developer team. If you encounter a merchant using this software to practice on your behalf and charging for it, it may be the cost of equipment and time, etc. The problems and consequences arising from this software have nothing to do with it.

本软件开源、免费，仅供学习交流使用。开发者团队拥有本项目的最终解释权。使用本软件产生的所有问题与本项目与开发者团队无关。若您遇到商家使用本软件进行代练并收费，可能是设备与时间等费用，产生的问题及后果与本软件无关。


请注意，根据MiHoYo的 [崩坏:星穹铁道的公平游戏宣言]([https://hsr.hoyoverse.com/en-us/news/111244](https://sr.mihoyo.com/news/111246?nav=news&type=notice)):

    "严禁使用外挂、加速器、脚本或其他破坏游戏公平性的第三方工具。"
    "一经发现，米哈游（下亦称“我们”）将视违规严重程度及违规次数，采取扣除违规收益、冻结游戏账号、永久封禁游戏账号等措施。"

### 用法

只支持1920\*1080(窗口化或全屏幕)，文本语言选择简体中文。

默认世界：比如说如果你当前模拟宇宙默认世界4，但是想自动化世界6，那么请先进入一次世界6来改变默认世界

如果没怎么接触过python，建议直接在[release](https://github.com/CHNZYX/Auto_Simulated_Universe/releases/latest)中下载gui版本，并直接阅读GUI使用方法

**第一次运行**

双击`install_requirements.bat`安装依赖库

重命名info_example.yml为info.yml

**运行自动化**

双击`run.bat` 或者 命令行运行 
```plaintext
python states.py
```

`info.yml`内容如下
```yaml
config:
  order_text: [1, 2, 3, 4] //模拟宇宙开局选的角色，建议改成自己的配队，1表示第一个角色。最好在一号位选远程角色（艾丝妲、三月七）方便开怪。
  angle: 1.0  //校准数据请勿更改
  difficulty: 4 //宇宙的难度，如果你要打难度1就改成1保存
  fate: 巡猎 //命途选择，默认巡猎，可以直接修改为其它命途。
  map_sha: '' //地图数据的版本，不建议更改
  show_map_mode: 0
  debug_mode: 0
  speed_mode: 0
  force_update: 0
  timezone: Default
prior:
  优先级信息，按需调整
```

默认是哪个宇宙就会进哪个！如果你默认不是第6世界，记得先手动切到第6世界！

注意！！！！！ 开始运行/开始校准之后就不要移动游戏窗口了！要移动请先停止自动化！

**校准**

如果出现视角转动过大/过小而导致迷路的问题，可能是校准值出问题了，可以尝试手动校准：

进入游戏，将人物传送到黑塔的办公室，然后双击 `align.bat`，等待视角转换/原地转圈结束

如果`align.bat`闪退，可以尝试命令行
```plaintext
python align_angle.py
```

改变鼠标dpi可能会影响校准值，此时需要重新校准。

**更新文件**

双击`update.bat`


### GUI使用方法

**第一次运行**

在设置中选择自己想要的难度和命途，配队请在游戏中预先选择默认配队

最好在一号位选远程角色（艾丝妲、三月七等）方便开怪。

**运行自动化**

点击运行

注意！！！！！ 开始运行/开始校准之后就不要移动游戏窗口了！要移动请先停止自动化！

**TIPS：**

F8/‘停止’按钮停止运行。

显隐表示显示/隐藏命令行窗口，默认隐藏

调试模式：如果不希望迷路后退出结算，请将调试模式变为√

如果不希望打完34次后自动停止，也请将调试模式变为√

速通模式：√表示只打每层最后一个怪，—表示在√的基础上开启奔跑

推荐最低画质配置：

![画质](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/image_quality.jpg)

**校准**

如果出现视角转动过大/过小而导致迷路的问题，可能是校准值出问题了，可以尝试手动校准：

进入游戏，将人物传送到黑塔的办公室，然后点击校准，等待视角转换/原地转圈结束

改变鼠标dpi可能会影响校准值，此时需要重新校准。

### 更新

双击update.exe

### 自动深渊

自动深渊可以使用固定配队自动刷忘却之庭，这项功能的目的是节省手动刷前几层的时间。

代码版启动方法为`python abyss.py`，gui版启动方法为主界面中的“深渊”按钮。

代码版第一次运行需要修改abyss文件夹下的info_example.yml为info.yml，并且修改info.yml为自己的两队配队，gui版可以在深渊界面中输入自己的配队。

每队的配队信息为四个数字

![配队编号](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/team.jpg)

比如说这张图中，你想选择娜塔莎，景元，希儿，彦卿，那么请在配队中输入：`6 4 3 2`

### 通知插件使用方法（notif.exe）

如果你没有用本地多用户，那么直接双击`notif.exe`即可开启windows通知，每刷完一次都会通知哦

如果你用了本地多用户，那么请在子用户运行gui，在主用户运行notif，这样就能在主用户收到通知了

计数会在每周自动重置，如果想手动改变计数，请打开`logs/notif.txt`，修改第一行的信息

通知插件会在右下角显示托盘图标

----------------------------------------------------------------------------------------------

### 部分逻辑

选择祝福的逻辑基于ocr+自定义优先级

寻路模块基于小地图

小地图中只会识别白色边缘线和黄色交互点。

----------------------------------------------------------------------------------------------

支持录制地图，具体方法为

运行 `python states.py --debug=2 --find=1`

如果遇到新图会角色停住，这时候结束自动化并且游戏中暂离模拟宇宙

然后运行 `python states.py --debug=2 --find=0`

运行后会自动进入地图，期间请不要移动鼠标也不要动键盘

几秒后角色会后退，然后前进。在角色前进时，你可以移动鼠标改变视角，也可以按键盘wasd。

在地图中绕一圈，感觉差不多就`F8/ctrl+c`结束进程能得到地图数据了。保存在`imgs/maps/my_xxxxx`目录下（可以按修改时间排序）

有怪的图最好用希儿战技，被锁定会影响小地图识别。

`imgs/maps/my_xxxxx`目录下会存在`target.jpg`，你可以用windows自带的画图打开它，然后在上面标记点（可以参考其它地图文件中的`target.jpg`）

靛蓝色：路径点 黄色：终点 绿色：交互点（问号点） 红色：怪点

录制结束后可以暂离并重新运行自动化测试地图，如果通过测试，你就成功录制到了新图！

----------------------------------------------------------------------------------------------

欢迎加入，欢迎反馈bug，QQ群：831830526

----------------------------------------------------------------------------------------------

如果喜欢本项目，可以打赏送作者一杯咖啡喵！

![打赏](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/money.jpg)

```

`README_CHT.md`:

```md
[簡體中文](README.md) | [繁體中文](README_CHT.md) | [English](README_ENG.md)

# Auto_Simulated_Universe
星穹鐵道-模擬宇宙全自動化

有一定的斷點回復功能，你可以切出去做其他事，切回來會繼續自動化。

目前支持模擬宇宙所有世界

----------------------------------------------------------------------------------------------

## 免責聲明
本軟件是一個外部工具旨在自動化崩壞星軌的遊戲玩法。它被設計成僅通過現有用戶界面與遊戲交互,並遵守相關法律法規。該軟件包旨在提供簡化和用戶通過功能與遊戲交互,並且它不打算以任何方式破壞遊戲平衡或提供任何不公平的優勢。該軟件包不會以任何方式修改任何遊戲文件或遊戲代碼。

This software is open source, free of charge and for learning and exchange purposes only. The developer team has the final right to interpret this project. All problems arising from the use of this software are not related to this project and the developer team. If you encounter a merchant using this software to practice on your behalf and charging for it, it may be the cost of equipment and time, etc. The problems and consequences arising from this software have nothing to do with it.

本軟件開源、免費，僅供學習交流使用。開發者團隊擁有本項目的最終解釋權。使用本軟件產生的所有問題與本項目與開發者團隊無關。若您遇到商家使用本軟件進行代練並收費，可能是設備與時間等費用，產生的問題及後果與本軟件無關。


請註意，根據MiHoYo的 [崩壞:星穹鐵道的公平遊戲宣言]([https://hsr.hoyoverse.com/en-us/news/111244](https://sr.mihoyo.com/news/111246?nav=news&type=notice)):

    "嚴禁使用外掛、加速器、腳本或其他破壞遊戲公平性的第三方工具。"
    "一經發現，米哈遊（下亦稱「我們」）將視違規嚴重程度及違規次數，采取扣除違規收益、凍結遊戲賬號、永久封禁遊戲賬號等措施。"

### 用法

只支持1920\*1080(窗口化或全屏幕)，文本語言選擇簡體中文。

默認世界：比如說如果你當前模擬宇宙默認世界4，但是想自動化世界6，那麽請先進入一次世界6來改變默認世界

如果沒怎麽接觸過python，建議直接在[release](https://github.com/CHNZYX/Auto_Simulated_Universe/releases/latest)中下載gui版本，並直接閱讀GUI使用方法

**第一次運行**

雙擊`install_requirements.bat`安裝依賴庫

重命名info_example.yml為info.yml

**運行自動化**

雙擊`run.bat` 或者 命令行運行 
```plaintext
python states.py
```

`info.yml`內容如下
```yaml
config:
  order_text: [1, 2, 3, 4] //模擬宇宙開局選的角色，建議改成自己的配隊，1表示第一個角色。最好在一號位選遠程角色（艾絲妲、三月七）方便開怪。
  angle: 1.0  //校準數據請勿更改
  difficulty: 4 //宇宙的難度，如果你要打難度1就改成1保存
  fate: 巡獵 //命途選擇，默認巡獵，可以直接修改為其它命途。
  map_sha: '' //地圖數據的版本，不建議更改
  show_map_mode: 0
  debug_mode: 0
  speed_mode: 0
  force_update: 0
  timezone: Default
prior:
  優先級信息，按需調整
```

默認是哪個宇宙就會進哪個！如果你默認不是第6世界，記得先手動切到第6世界！

註意！！！！！ 開始運行/開始校準之後就不要移動遊戲窗口了！要移動請先停止自動化！

**校準**

如果出現視角轉動過大/過小而導致迷路的問題，可能是校準值出問題了，可以嘗試手動校準：

進入遊戲，將人物傳送到黑塔的辦公室，然後雙擊 `align.bat`，等待視角轉換/原地轉圈結束

如果`align.bat`閃退，可以嘗試命令行
```plaintext
python align_angle.py
```

改變鼠標dpi可能會影響校準值，此時需要重新校準。

**更新文件**

雙擊`update.bat`


### GUI使用方法

**第一次運行**

在設置中選擇自己想要的難度和命途，配隊請在遊戲中預先選擇默認配隊

最好在一號位選遠程角色（艾絲妲、三月七等）方便開怪。

**運行自動化**

點擊運行

註意！！！！！ 開始運行/開始校準之後就不要移動遊戲窗口了！要移動請先停止自動化！

**TIPS：**

F8/『停止』按鈕停止運行。

顯隱表示顯示/隱藏命令行窗口，默認隱藏

調試模式：如果不希望迷路後退出結算，請將調試模式變為√

如果不希望打完34次後自動停止，也請將調試模式變為√

速通模式：√表示只打每層最後一個怪，—表示在√的基礎上開啟奔跑

推薦最低畫質配置：

![畫質](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/image_quality.jpg)

**校準**

如果出現視角轉動過大/過小而導致迷路的問題，可能是校準值出問題了，可以嘗試手動校準：

進入遊戲，將人物傳送到黑塔的辦公室，然後點擊校準，等待視角轉換/原地轉圈結束

改變鼠標dpi可能會影響校準值，此時需要重新校準。

### 更新

雙擊update.exe

### 自動深淵

自動深淵可以使用固定配隊自動刷忘卻之庭，這項功能的目的是節省手動刷前幾層的時間。

代碼版啟動方法為`python abyss.py`，gui版啟動方法為主界面中的「深淵」按鈕。

代碼版第一次運行需要修改abyss文件夾下的info_example.yml為info.yml，並且修改info.yml為自己的兩隊配隊，gui版可以在深淵界面中輸入自己的配隊。

每隊的配隊信息為四個數字

![配隊編號](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/team.jpg)

比如說這張圖中，你想選擇娜塔莎，景元，希兒，彥卿，那麽請在配隊中輸入：`6 4 3 2`

### 通知插件使用方法（notif.exe）

如果你沒有用本地多用戶，那麽直接雙擊`notif.exe`即可開啟windows通知，每刷完一次都會通知哦

如果你用了本地多用戶，那麽請在子用戶運行gui，在主用戶運行notif，這樣就能在主用戶收到通知了

計數會在每周自動重置，如果想手動改變計數，請打開`logs/notif.txt`，修改第一行的信息

通知插件會在右下角顯示托盤圖標

----------------------------------------------------------------------------------------------

### 部分邏輯

選擇祝福的邏輯基於ocr+自定義優先級

尋路模塊基於小地圖

小地圖中只會識別白色邊緣線和黃色交互點。

----------------------------------------------------------------------------------------------

支持錄製地圖，具體方法為

運行 `python states.py --debug=2 --find=1`

如果遇到新圖會角色停住，這時候結束自動化並且遊戲中暫離模擬宇宙

然後運行 `python states.py --debug=2 --find=0`

運行後會自動進入地圖，期間請不要移動鼠標也不要動鍵盤

幾秒後角色會後退，然後前進。在角色前進時，你可以移動鼠標改變視角，也可以按鍵盤wasd。

在地圖中繞一圈，感覺差不多就`F8/ctrl+c`結束進程能得到地圖數據了。保存在`imgs/maps/my_xxxxx`目錄下（可以按修改時間排序）

有怪的圖最好用希兒戰技，被鎖定會影響小地圖識別。

`imgs/maps/my_xxxxx`目錄下會存在`target.jpg`，你可以用windows自帶的畫圖打開它，然後在上面標記點（可以參考其它地圖文件中的`target.jpg`）

靛藍色：路徑點 黃色：終點 綠色：交互點（問號點） 紅色：怪點

錄製結束後可以暫離並重新運行自動化測試地圖，如果通過測試，你就成功錄製到了新圖！

----------------------------------------------------------------------------------------------

歡迎加入，歡迎反饋bug，QQ群：831830526

----------------------------------------------------------------------------------------------

如果喜歡本項目，可以打賞送作者一杯咖啡喵！

![打賞](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/money.jpg)

```

`README_ENG.md`:

```md
[简体中文](README.md) | [繁体中文](README_CHT.md) | [English](README_ENG.md)


# Auto_Simulated_Universe
Star Rail - Auto Simulated Universe

This project incorporates a pause-resume feature. You can switch to other tasks and return later to continue the automation process.

Currently supports automation of all worlds within the simulated universe.

----------------------------------------------------------------------------------------------

## Disclaimer
This software is an external tool intended to automate gameplay in the game "Honkai Star Rail." It is designed to interact with the game solely through existing user interfaces and in compliance with relevant laws and regulations. This software package aims to provide simplification and user interaction with the game's features and does not intend to disrupt game balance or provide any unfair advantages. The package will not modify any game files or game code in any way.

This software is open-source and free of charge, intended for educational and collaborative purposes only. The development team holds the final interpretation rights for this project. Any issues arising from the use of this software are unrelated to this project and the development team. If you come across merchants using this software for power-leveling and charging for it, the costs might involve equipment and time, and any issues or consequences arising from this software are unrelated to it.

Please note that according to MiHoYo's [Fair Play Declaration for Honkai Star Rail](https://hsr.hoyoverse.com/en-us/news/111244):

    "The use of plug-ins, accelerators, scripts, or other third-party tools that disrupt the fairness of the game is strictly prohibited."
    "Once discovered, miHoYo (hereinafter referred to as 'we') will take measures such as deducting illegal gains, freezing game accounts, and permanently banning game accounts based on the severity and frequency of violations."

### Usage

Only supports 1920x1080 resolution (windowed or fullscreen), and text language selection is simplified Chinese.

Default World: For instance, if your current default world in the simulated universe is World 4 but you want to automate World 6, please enter World 6 once to change the default world.

If you're not familiar with Python, it's recommended to directly download the GUI version from the [release](https://github.com/CHNZYX/Auto_Simulated_Universe/releases/latest) and follow the GUI usage instructions.

**First-time Setup**

Double-click `install_requirements.bat` to install the required libraries.

Rename `info_example.yml` to `info.yml`.

**Running Automation**

Double-click `run.bat` or run in the command line:
```plaintext
python states.py
```

The content of `info.yml` is as follows:
```yaml
config:
  order_text: [1, 2, 3, 4] # Character selection order at the start of the simulation. Change this according to your team composition. 1 represents the first character. It's advisable to put ranged characters (like Asta or March 7th) in position 1 for better monster clearing.
  angle: 1.0  # Calibration data, do not modify.
  difficulty: 4 # Universe difficulty, change to 1 if you want to play on difficulty 1.
  fate: 巡猎 # Fate selection, default is 巡猎, you can directly modify it to other fates.
  map_sha: '' # Map data version, not recommended to change.
  show_map_mode: 0
  debug_mode: 0
  speed_mode: 0
  force_update: 0
  timezone: Default
prior:
  # Priority information, adjust as needed.
```

The simulation will enter the world that corresponds to the default setting. If your default world is not World 6, remember to manually switch to World 6 first!

Important!!! Once you start running/calibrating, do not move the game window! If you need to move it, please stop the automation first!

**Calibration**

If you're experiencing issues like excessive/inadequate camera rotation leading to getting lost, it might be due to calibration. You can manually calibrate as follows:

Enter the game and teleport your character to Herta's office. Then, double-click `align.bat` and wait for the camera to rotate/character to spin in place.

If `align.bat` crashes, you can try using the command line:
```plaintext
python align_angle.py
```

Changing your mouse DPI might affect calibration values, in which case, you'll need to recalibrate.

**Updating Files**

Double-click `update.bat`.

### GUI Usage Instructions

**First-time Setup**

In the settings, select your desired difficulty and fate. Please pre-select your default team composition in the game.

It's advisable to put a ranged character (like Asta or March 7th) in the first position for better monster clearing.

**Running Automation**

Click the "运行" button.

Important!!! Once you start running/calibrating, do not move the game window! If you need to move it, please stop the automation first!

**TIPS:**

Press F8 or the "停止" button to halt the process.

"显隐" checkbox toggles the visibility of the command-line window. It's hidden by default.

调试模式: If you don't want the simulation to exit after getting lost, enable 调试模式.

If you want the simulation to continue after completing 34 rounds, enable 调试模式.

速通模式: Checkmark indicates only the last enemy on each floor will be attacked. Hyphen indicates that Speed Mode is combined with this option.

Recommended minimal graphics settings:

![Graphics Settings](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/image_quality.jpg)

**Calibration**

If you're experiencing issues like excessive/inadequate camera rotation leading to getting lost, it might be due to calibration. You can manually calibrate as follows:

Enter the game and teleport your character to Herta's office. Then, click the "Calibrate" button, and wait for the camera to rotate/character to spin in place.

Changing your mouse DPI might affect calibration values, in which case, you'll need to recalibrate.

### Update

Double-click `update.exe`.

### Automatic Abyss

Automatic Abyss allows you to use a fixed team to automatically clear the Oblivion Domains, saving time on manual clearing of the initial levels.

To run the script version, use `python abyss.py`. For the GUI version, click the "Abyss" button on the main interface.

For the script version's first run, modify the `info_example.yml` file in the "abyss" folder to `info.yml`, and edit `info.yml` with your two-team composition. In the GUI version, you can input your team composition in the Abyss interface.

Each team's composition is represented by four numbers.

![Team Composition Numbers](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/team.jpg)

For instance, in the image above, if you want to choose Natasha, Jing Yuan, Seele, and Yan Qing, input: `6 4 3 2`.

### Notification Plugin Instructions (notif.exe)

If you're not using a local multi-user setup, simply double-click

 `notif.exe` to enable Windows notifications. You'll receive notifications after each completion.

If you're using a local multi-user setup, run the GUI version in the sub-user account and `notif.exe` in the main user account. This way, notifications will be sent to the main user.

The counter resets automatically weekly. If you wish to manually modify the count, open `logs/notif.txt` and edit the first line.

The notification plugin displays a tray icon in the bottom-right corner.

----------------------------------------------------------------------------------------------

### Logic Overview

Blessing selection logic is based on OCR and custom priority settings.

Pathfinding module uses a mini-map.

The mini-map only recognizes white edge lines and yellow interaction points.

----------------------------------------------------------------------------------------------

Support for recording maps is available:

Run `python states.py --debug=2 --find=1`.

If a new map is encountered and your character stops, end the automation and put the game in pause mode in the Simulated Universe.

Then, run `python states.py --debug=2 --find=0`.

The script will automatically enter the map. During this process, do not move the mouse or press any keys.

After a few seconds, the character will move backward and then forward. During the forward movement, you can move the mouse to change the camera angle or use WASD on the keyboard.

Move around the map, and when you feel it's sufficient, press F8 or Ctrl+C to terminate the process. This will capture the map data. It will be saved in the `imgs/maps/my_xxxxx` directory (sorted by modification time).

For maps with monsters, it's advisable to use Seele's ultimate ability. Being locked onto a target can affect the mini-map recognition.

A `target.jpg` file will be present in the `imgs/maps/my_xxxxx` directory. You can use the built-in Paint application on Windows to open it and mark points (you can refer to the `target.jpg` file in other map folders).

Indigo: Path point, Yellow: Destination, Green: Interaction point (question mark), Red: Enemy point

After recording, you can exit the game and re-run the automation to test the map. If the test is successful, you've successfully recorded a new map!

----------------------------------------------------------------------------------------------

Feel free to join and provide feedback. QQ Group: 831830526

----------------------------------------------------------------------------------------------

If you like this project, you can buy the author a cup of coffee!

![Donate](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/money.jpg)

```

`abyss.py`:

```py
import threading
import traceback
import keyboard
import pyautogui
import cv2 as cv
import numpy as np
import time
import win32gui, win32api, win32con
import random
import sys
from copy import deepcopy
from utils.log import log, set_debug
from utils.map_log import map_log
from utils.update_map import update_map
from utils.utils import UniverseUtils, set_forground, notif
import os
from align_angle import main as align_angle
from utils.config import config
import datetime
import pytz
import yaml
import pyuac

pyautogui.FAILSAFE=False

class Abyss(UniverseUtils):
    def __init__(self):
        super().__init__()
        self.threshold = 0.97
        self.floor = 0
        self._stop = 0
        with open('abyss/info.yml', "r", encoding="utf-8",errors='ignore') as f:
            config = yaml.safe_load(f)['order_text']
            self.team=[config[:4],config[4:]]
        
    def start_abyss(self):
        while self._stop == 0:
            self.route()
            time.sleep(0.2)
            
    def wait(self):
        tm = time.time()
        while self._stop == 0:
            self.get_screen()
            if self.check("auto_2", 0.3755,0.0333):
                tm = time.time()
            if self.check("c", 0.9464,0.1287, threshold=0.985):
                #self.press('v')
                pass
            if time.time() - tm > 10 or self.check("abyss/in",0.9130,0.6074):
                print(time.time() - tm)
                break
            time.sleep(0.1)
    def ready(self):
        for i in range(4):
            self.press(str(i+1))
            time.sleep(0.4)
            self.press('e')
            time.sleep(1)
            self.get_screen()
            if not (self.check("z",0.5010,0.9426,mask="abyss/mask_z") or self.check("abyss/z",0.5010,0.9426,mask="abyss/mask_z")):
                break
        time.sleep(1)
        pyautogui.click()
        time.sleep(3.5)
    def route(self):
        self.get_screen()
        #self.click_target('imgs/abyss/fail.jpg',0.9,True)
        if self.check("run", 0.9844, 0.7889, threshold=0.93):
            self.press('F4')
        elif self.check("abyss/fail",0.5995,0.1343):
            self.click((0.5995,0.1343))
        elif self.check("abyss/in",0.9130,0.6074):
            self.press('w',3.5)
            t = self.move_to_interac(1,1)
            if abs(t)>30:
                self.press('w',1)
            self.ready()
            self.wait()
            if abs(t)>30:
                time.sleep(1)
                self.press('w')
                self.move_to_interac(1,1)
                self.press('w',1.5)
                self.ready()
                self.wait()
        elif self.check("abyss/team",0.6500,0.4019):
            if self.check("abyss/begin",0.1062,0.0815):
                self.click((0.1062,0.0806))
                return
            if random.randint(0,1):
                self.team=self.team[::-1]
            for i,j in enumerate([(0.4026,0.3259),(0.4010,0.2343)]):
                self.click(j)
                time.sleep(0.2)
                for k in self.team[i]:
                    t=k-1
                    if t>=0:
                        self.click((0.9427-0.0661*(t%4),0.8102-0.1435*(t//4)))
                        time.sleep(0.2)
            self.click((0.1062,0.0806))
        elif self.check("abyss/6",0.5661,0.5713):
            self.click((0.5,0.2))
        elif self.check("abyss/5",0.1125,0.9389):
            self.click((0.9,0.9))
            time.sleep(0.3)
            self.get_screen()
            gray = [156,122,126]
            gray2 = [118,107,111]
            bw_map = np.zeros(self.screen.shape[:2], dtype=np.uint8)
            bw_map[np.sum((self.screen - gray) ** 2, axis=-1) <= 800]=255
            bw_map[np.sum((self.screen - gray2) ** 2, axis=-1) <= 800]=255
            #cv.imwrite('tp.jpg',bw_map)
            res = (-1,-1)
            for i in ['3_stars','2_stars','1_star']:
                target = cv.imread(self.format_path('abyss/'+i),cv.IMREAD_GRAYSCALE)
                result = cv.matchTemplate(bw_map, target, cv.TM_CCORR_NORMED)
                min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result)
                if max_val>0.88:
                    res = max_loc
                    break
            if res!=(-1,-1):
                self.click((1-res[0]/self.xx+0.06,1-res[1]/self.yy+0.02))
            else:
                self.drag((0.5,0.5),(0.8-0.6*random.randint(0,1),0.5))
        elif self.check("abyss/4",0.7865,0.3028):
            self.click((0.2208,0.4296))
        elif self.check("abyss/3",0.7865,0.3028):
            self.click((0.7865,0.3028))
        elif self.check("abyss/2",0.4297,0.8213):
            self.drag((0.7750,0.3750),(0.7750,0.6750))
        elif self.check("abyss/1",0.8568,0.6769):
            self.click((0.6260,0.8167))
        else:
            self.click((0.5,0.14))
            time.sleep(1)


if __name__ == "__main__":
    if not pyuac.isUserAdmin():
        pyuac.runAsAdmin()
    else:
        abyss = Abyss()
        abyss.start_abyss()

```

`abyss/info_example.yml`:

```yml
order_text:
- 1
- 3
- 7
- 8
- 2
- 5
- 6
- 14
```

`align.bat`:

```bat
%1 mshta vbscript:CreateObject("Shell.Application").ShellExecute("cmd.exe","/c %~s0 ::","","runas",1)(window.close)&&exit
cd/d "%~dp0"
python align_angle.py
pause

```

`align_angle.py`:

```py
import time

import numpy as np
import pywintypes
import win32api
import win32con
import win32gui
import pyuac
from utils.config import config
from utils.log import log


def get_angle(su, safe):
    import cv2
    su.press("w")
    time.sleep(0.5)
    su.get_screen()
    shape = (int(su.scx * 190), int(su.scx * 190))
    local_screen = su.get_local(0.9333, 0.8657, shape)  # 裁剪后得到的小地图
    return su.get_now_direc(local_screen)


# 不同电脑鼠标移动速度、放缩比、分辨率等不同，因此需要校准
# 基本逻辑：每次转60度，然后计算实际转了几度，计算出误差比
def main(cnt=10, safe=0, ang=[1,1,3], su=None):
    if float(config.angle)>2 and len(ang)<3 and su is not None:
        su.multi = config.multi
        return
    log.info("开始校准")
    if su is None:
        from utils.utils import UniverseUtils
        su = UniverseUtils()
    su.multi = 1
    init_ang = get_angle(su, safe)
    lst_ang = init_ang
    for i in ang:
        ang_list = []
        for j in range(i):
            su.mouse_move(100, fine=3 // i)
            time.sleep(0.2)
            now_ang = get_angle(su, safe)
            sub = lst_ang - now_ang
            while sub < 0:
                sub += 360
            ang_list.append(sub)
            lst_ang = now_ang
        ang_list = np.array(ang_list)
        # 十/3次转身的角度
        print(ang_list)
        ax = 0
        ay = 0
        for j in ang_list:
            if abs(j - np.median(ang_list)) <= 5:
                ax += 100
                ay += j
        su.multi *= ax / ay
    su.multi += 1e-9
    try:
        if not abs(su.multi) <= 2:
            su.multi = 1
    except:
        su.multi = 1
    config.angle = str(su.multi+len(ang)-1)
    config.save()
    if safe == 0:
        try:
            win32gui.SetForegroundWindow(su.my_nd)
        except pywintypes.error:
            pass
    log.info("校准完成")
    return 1


if __name__ == "__main__":
    if not pyuac.isUserAdmin():
        pyuac.runAsAdmin()
    else:
        main()

```

`gui.py`:

```py
import atexit

import flet as ft
import pyuac
import win32gui

from gui.choose import choose_view
from gui.config import config_view
from gui.abyss import abyss_view
from gui.common import cleanup, mynd, Page, init_page


def main(page: Page):
    def on_route_change(e: Page):
        page.views.clear()
        choose_view(page)
        if e.route == "/config":
            config_view(page)
        if e.route == '/abyss':
            abyss_view(page)
        page.update()

    def view_pop():
        page.views.pop()
        top_view = page.views[-1]
        page.go(top_view.route)

    init_page(page)    
    page.theme = ft.Theme(
        color_scheme_seed=ft.colors.PURPLE,
    )
    page.title = "AutoSimulatedUniverse"
    page.vertical_alignment = "center"
    page.horizontal_alignment = "center"
    page.on_route_change = on_route_change
    page.on_view_pop = view_pop
    page.window_min_width = 800
    page.window_width = 800
    page.window_height = 650
    page.window_min_height = 650
    page.go(page.route)


if __name__ == "__main__":
    atexit.register(cleanup)
    if not pyuac.isUserAdmin():
        pyuac.runAsAdmin()
    else:
        try:
            win32gui.ShowWindow(mynd, 0)
        except:
            pass
        ft.app(target=main)

```

`gui/abyss.py`:

```py
from flet_core import MainAxisAlignment, ControlEvent, CrossAxisAlignment
import flet as ft

from gui.common import show_snack_bar, Page
import yaml
import traceback
from abyss import Abyss


def abyss_view(page: Page):
    order = ['1 2 3 4','5 6 7 8']
    try:
        with open('abyss/info.yml', "r", encoding="utf-8",errors='ignore') as f:
            config = yaml.safe_load(f)['order_text']
            config = [str(x) for x in config]
            order=[' '.join(config[:4]),' '.join(config[4:])]
    except:
        pass
    
    def back_choose(_):
        try:
            page.ab._stop = 1
        except:
            pass
        page.go("/")
        page.update()

    def start(_e):
        nonlocal order
        order = [x.strip().split(' ') for x in order]
        for i in range(2):
            ls = []
            for j in order[i]:
                try:
                    ls.append(int(j))
                except:
                    pass
            ls += [0,0,0,0]
            order[i] = ls[:4]
        with open('abyss/info.yml', "w", encoding="utf-8") as f:
            yaml.safe_dump({
                    "order_text": order[0] + order[1]
            }, f, allow_unicode=True, sort_keys=False)
        try:
            page.ab._stop = 1
        except:
            pass
        page.ab = Abyss()
        page.ab.start_abyss()

    def stop(_e):
        page.ab._stop = 1
        

    def order_changed1(e):
        nonlocal order
        order[0] = e.control.value
    
    def order_changed2(e):
        nonlocal order
        order[1] = e.control.value


    page.views.append(
        ft.View(
            "/abyss",
            [
                ft.Stack(
                    [
                        ft.Container(
                            content=ft.Row(
                                [
                                    ft.Text(
                                        value="自动忘却之庭",
                                        size=30,
                                    ),
                                    ft.Row(
                                        [
                                            ft.ElevatedButton(
                                                "返回",
                                                icon=ft.icons.ARROW_BACK,
                                                on_click=back_choose,
                                            )
                                        ],
                                        alignment=MainAxisAlignment.CENTER,
                                        spacing=50,
                                    ),
                                ],
                                alignment=MainAxisAlignment.SPACE_BETWEEN,
                            ),
                            padding=10,
                        ),
                    ]
                ),
                ft.Divider(
                    height=1,
                ),
                ft.Row(
                    [
                        ft.Column(
                            [
                                ft.TextField(
                                    label="配队1",
                                    width=80,
                                    value=order[0],
                                    on_change=order_changed1,
                                ),
                                ft.TextField(
                                    label="配队2",
                                    width=80,
                                    value=order[1],
                                    on_change=order_changed2,
                                ),
                                ft.ElevatedButton(
                                    "保存并开始",
                                    icon=ft.icons.LOGIN,
                                    on_click=start,
                                ),
                                ft.ElevatedButton(
                                    "停止",
                                    icon=ft.icons.STOP,
                                    on_click=stop,
                                ),
                            ],
                            alignment=MainAxisAlignment.SPACE_AROUND,
                            horizontal_alignment=CrossAxisAlignment.CENTER,
                        ),
                    ],
                    alignment=MainAxisAlignment.CENTER,
                    vertical_alignment=CrossAxisAlignment.CENTER,
                    height=350,
                ),
            ],
            padding=20,
            spacing=0,
        )
    )

```

`gui/choose.py`:

```py
import traceback

import flet as ft
import win32gui
from flet_core import MainAxisAlignment, CrossAxisAlignment

from align_angle import main as align_angle
from gui.common import show_snack_bar, mynd, Page
from states import SimulatedUniverse, version
from utils.config import config
from utils.update_map import update_map
from utils.utils import notif
import time


def choose_view(page: Page):
    def change_all_button(value: bool = True):
        cnt = 0
        for i in page.views[0].controls[0].controls:
            if isinstance(i, ft.FilledButton):
                if cnt <= 1:
                    i.disabled = value
                    cnt += 1
                else:
                    i.disabled = False
        page.update()

    def run(func, *args, **kwargs):
        try:
            change_all_button()
            res = func(*args, **kwargs)
            change_all_button(False)
            return res
        except Exception:
            print("E: 运行函数时出现错误")
            traceback.print_exc()
        finally:
            change_all_button(False)

    def angle(_e):
        if config.angle == "1.0" or page.first==1:
            go_about()
            time.sleep(8)
            page.first=0
            page.dialog.open = False
            page.update()
        show_snack_bar(page, "开始校准，请切换回游戏（¬､¬）", ft.colors.GREEN)
        res = run(align_angle)
        if res == 1:
            show_snack_bar(page, "校准成功（＾∀＾●）", ft.colors.GREEN)
        else:
            show_snack_bar(page, "校准失败（⊙.⊙）", ft.colors.RED)

    def start(_e):
        if page.first==1:
            go_about()
            time.sleep(8)
            page.first=0
            page.dialog.open = False
            page.update()
        show_snack_bar(page, "开始运行，请切换回游戏（＾∀＾●）", ft.colors.GREEN)
        tm = time.time()
        page.su = run(
            SimulatedUniverse,
            1,
            int(config.debug_mode),
            int(config.show_map_mode),
            int(config.speed_mode),
            1,
            int(config.bonus),
            gui=1
        )
        run(page.su.start)
        txt = " "
        if time.time()-tm<20:
            go_dep()
            #txt = "请确认python+numpy已安装并正确配置环境变量"
        try:
            if page.su.validate == 0:
                txt = "版本过低，请更新"
        except:
            pass
        try:
            win32gui.SetForegroundWindow(page.su.my_nd)
        except:
            pass
        notif('已退出自动化',txt)

    def start_abyss(_e):
        page.go("/abyss")

    def stops(_e):
        show_snack_bar(page, "停止运行（>∀<）", ft.colors.GREEN)
        if page.su is not None:
            run(page.su.stop)

    def hide(_e):
        try:
            if win32gui.IsWindowVisible(mynd):
                show_snack_bar(page, "隐藏命令行窗口", ft.colors.GREEN)
                win32gui.ShowWindow(mynd, 0)  # 隐藏命令行窗口
            else:
                show_snack_bar(page, "显示命令行窗口", ft.colors.GREEN)
                win32gui.ShowWindow(mynd, 1)  # 显示命令行窗口
        except:
            pass

    def update_maps(_e):
        show_snack_bar(page, "更新地图功能已经弃用（´・н・‘）", ft.colors.RED)
        return
        show_snack_bar(page, "开始更新地图（´・н・‘）", ft.colors.GREEN)
        msg, col = update_map(config.force_update)
        show_snack_bar(page, msg, col)

    def go_config(_e):
        page.go("/config")

    def go_about(e=None):
        dlg = ft.AlertDialog(
            title=ft.Text("此程序为免费开源项目，如果你付了钱请立刻退款！"),
            content=ft.Text(
                "咸鱼倒狗4000+！你付给倒狗的每一分钱都会让开源自动化更艰难，请退款并举报商家！本项目已经因倒卖行为受到严重威胁，请帮助我们！\n链接：https://github.com/CHNZYX/Auto_Simulated_Universe\n群号：831830526\n10秒后自动关闭"
            ),
        )
        page.dialog = dlg
        dlg.open = True
        page.update()

    def go_money(e=None):
        dlg = ft.AlertDialog(
            title=ft.Text("送杯咖啡喵 QWQ"), content=ft.Image("imgs/money.jpg")
        )
        page.dialog = dlg
        dlg.open = True
        page.update()

    def go_dep(e=None):
        dlg = ft.AlertDialog(
            title=ft.Text("异常退出"), content=ft.Text(" ")#"请确认python+numpy已安装并正确配置环境变量")
        )
        page.dialog = dlg
        dlg.open = True
        page.update()

    def unlock(e=None):
        show_snack_bar(page, "解锁限制功能已经弃用o(*￣▽￣*)ブ", ft.colors.RED)
        return
        go_money()
        time.sleep(3)
        page.dialog.open = False
        page.update()
        show_snack_bar(page, "稍后解锁限制，赞助页面在右下角按钮~o( =∩ω∩= )m", ft.colors.GREEN)
        time.sleep(7)
        config.unlock = 1
        show_snack_bar(page, "已临时解锁限制o(*￣▽￣*)ブ", ft.colors.GREEN)

    def bonus_changed(e):
        config.bonus = not config.bonus

    # View
    page.views.append(
        ft.View(
            "/",
            [
                ft.Column(
                    [
                        ft.Container(
                            content=ft.Text(
                                "AutoSimulatedUniverse",
                                size=50,
                            ),
                        ),
                        ft.Container(
                            content=ft.Text(
                                version,
                                size=20,
                            ),
                        ),
                        ft.ElevatedButton(
                            "校准",
                            icon=ft.icons.ADD_TASK,
                            on_click=angle,
                        ),
                        ft.ElevatedButton(
                            "运行",
                            icon=ft.icons.LOGIN,
                            on_click=start,
                        ),
                        ft.ElevatedButton(
                            "深渊",
                            icon=ft.icons.GAMEPAD,
                            on_click=start_abyss,
                        ),
                        ft.ElevatedButton(
                            "显隐",
                            icon=ft.icons.HIDE_SOURCE,
                            on_click=hide,
                        ),
                        ft.ElevatedButton(
                            "停止",
                            icon=ft.icons.STOP,
                            on_click=stops,
                        ),
                        ft.ElevatedButton(
                            "设置",
                            icon=ft.icons.SETTINGS,
                            on_click=go_config,
                        ),
                        ft.ElevatedButton(
                            "关于",
                            icon=ft.icons.INFO,
                            on_click=go_about,
                        ),
                    ],
                    alignment=MainAxisAlignment.CENTER,
                    horizontal_alignment=CrossAxisAlignment.CENTER,
                ),
                ft.Row([ft.Container(width=340),ft.Switch(label="沉浸奖励", on_change=bonus_changed, value=config.bonus),]),
                ft.Row(
                    [
                        ft.IconButton(
                            icon=ft.icons.BROWSER_UPDATED,
                            tooltip="更新地图",
                            icon_size=30,
                            on_click=update_maps,
                        ),
                        ft.IconButton(
                            icon=ft.icons.LOCK_OPEN,
                            tooltip="临时解锁",
                            icon_size=30,
                            on_click=unlock,
                        ),
                        ft.IconButton(
                            icon=ft.icons.THUMB_UP,
                            tooltip="赞赏",
                            icon_size=30,
                            on_click=go_money,
                        ),
                    ],
                    alignment=MainAxisAlignment.SPACE_BETWEEN,
                    vertical_alignment=CrossAxisAlignment.END,
                ),
            ],
            horizontal_alignment=CrossAxisAlignment.CENTER,
            vertical_alignment=MainAxisAlignment.CENTER,
        )
    )

```

`gui/common.py`:

```py
from typing import Optional

import flet as ft
import win32gui

from states import SimulatedUniverse
from abyss import Abyss


class Page(ft.Page):
    su: Optional[SimulatedUniverse]
    ab: Optional[Abyss]
    first: int
    bonus: bool


def init_page(page: Page):
    page.su = None
    page.ab = None
    page.first = 1


def show_snack_bar(page, text, color, selectable=False):
    return page.show_snack_bar(
        ft.SnackBar(
            open=True,
            content=ft.Text(text, selectable=selectable),
            bgcolor=color,
        )
    )


def cleanup():
    try:
        win32gui.ShowWindow(mynd, 1)
    except:
        pass


def enum_windows_callback(hwnd, hwnds):
    class_name = win32gui.GetClassName(hwnd)
    name = win32gui.GetWindowText(hwnd)
    try:
        if (
            class_name == "ConsoleWindowClass"
            and win32gui.IsWindowVisible(hwnd)
            and "gui" in name[-7:]
        ):
            hwnds.append(hwnd)
    except:
        pass
    return True


def list_handles():
    hwnds = []
    win32gui.EnumWindows(enum_windows_callback, hwnds)
    hwnds.append(0)
    return hwnds


mynd = list_handles()[0]

```

`gui/config.py`:

```py
from flet_core import MainAxisAlignment, ControlEvent, CrossAxisAlignment
import flet as ft

from gui.common import show_snack_bar, Page
from utils.config import config


def config_view(page: Page):
    def back_choose(_):
        page.go("/")
        page.update()

    def save(_):
        config.save()
        show_snack_bar(page, "保存成功", ft.colors.GREEN)
        page.go("/")
        page.update()

    def show_map_checkbox_changed(_e):
        config.show_map_mode = (config.show_map_mode + 1) % 2

    def debug_checkbox_changed(_e):
        config.debug_mode = (config.debug_mode + 1) % 3

    def speed_checkbox_changed(_e):
        config.speed_mode = (config.speed_mode + 1) % 3

    def force_update_checkbox_changed(_e):
        config.force_update = (config.force_update + 1) % 2

    def difficult_changed(e: ControlEvent):
        config.difficult = e.data

    def fate_changed(e: ControlEvent):
        config.fate = e.data

    def timezone_changed(e: ControlEvent):
        config.timezone = e.data

    def textbox_changed(e):
        config.order_text = e.control.value

    def get_info_mode(d):
        ls = [False, True, None]
        return ls[d]

    page.views.append(
        ft.View(
            "/config",
            [
                ft.Stack(
                    [
                        ft.Container(
                            content=ft.Row(
                                [
                                    ft.Text(
                                        value="设置",
                                        size=30,
                                    ),
                                    ft.Row(
                                        [
                                            ft.ElevatedButton(
                                                "返回",
                                                icon=ft.icons.ARROW_BACK,
                                                on_click=back_choose,
                                            ),
                                            ft.ElevatedButton(
                                                "保存",
                                                icon=ft.icons.DONE,
                                                on_click=save,
                                            ),
                                        ],
                                        alignment=MainAxisAlignment.CENTER,
                                        spacing=50,
                                    ),
                                ],
                                alignment=MainAxisAlignment.SPACE_BETWEEN,
                            ),
                            padding=10,
                        ),
                    ]
                ),
                ft.Divider(
                    height=1,
                ),
                ft.Row(
                    [
                        ft.Column(
                            [
                                ft.Row(
                                    [
                                        ft.Checkbox(
                                            label="显示地图",
                                            value=get_info_mode(config.show_map_mode),
                                            on_change=show_map_checkbox_changed,
                                        ),
                                        ft.Checkbox(
                                            label="调试模式",
                                            value=get_info_mode(config.debug_mode),
                                            tristate=True,
                                            on_change=debug_checkbox_changed,
                                        ),
                                        ft.Checkbox(
                                            label="速通模式",
                                            tristate=True,
                                            value=get_info_mode(config.speed_mode),
                                            on_change=speed_checkbox_changed,
                                        ),
                                        ft.Checkbox(
                                            label="强制更新",
                                            value=get_info_mode(config.force_update),
                                            on_change=force_update_checkbox_changed,
                                        ),
                                    ]
                                ),
                                ft.Row(
                                    [
                                        ft.Dropdown(
                                            width=100,
                                            label="难度",
                                            hint_text="选择世界难度",
                                            options=[
                                                ft.dropdown.Option("1"),
                                                ft.dropdown.Option("2"),
                                                ft.dropdown.Option("3"),
                                                ft.dropdown.Option("4"),
                                                ft.dropdown.Option("5"),
                                            ],
                                            value=config.difficult,
                                            on_change=difficult_changed,
                                        ),
                                        ft.Dropdown(
                                            width=100,
                                            label="命途",
                                            hint_text="选择命途",
                                            options=[
                                                ft.dropdown.Option("存护"),
                                                ft.dropdown.Option("记忆"),
                                                ft.dropdown.Option("虚无"),
                                                ft.dropdown.Option("丰饶"),
                                                ft.dropdown.Option("巡猎"),
                                                ft.dropdown.Option("毁灭"),
                                                ft.dropdown.Option("欢愉"),
                                            ],
                                            value=config.fate,
                                            on_change=fate_changed,
                                        ),
                                        ft.Dropdown(
                                            width=150,
                                            label="时区",
                                            hint_text="影响计数刷新时间",
                                            options=[
                                                ft.dropdown.Option("Default"),
                                                ft.dropdown.Option("Asia"),
                                                ft.dropdown.Option("America"),
                                                ft.dropdown.Option("Europe"),
                                            ],
                                            value=config.timezone,
                                            on_change=timezone_changed,
                                        ),
                                    ]
                                ),
                                ft.TextField(
                                    label="配队",
                                    width=80,
                                    value=config.order_text,
                                    on_change=textbox_changed,
                                ),
                            ],
                            alignment=MainAxisAlignment.SPACE_AROUND,
                            horizontal_alignment=CrossAxisAlignment.CENTER,
                        ),
                    ],
                    alignment=MainAxisAlignment.CENTER,
                    vertical_alignment=CrossAxisAlignment.CENTER,
                    height=200,
                ),
            ],
            padding=20,
            spacing=0,
        )
    )

```

`info_example.yml`:

```yml
config:
  order_text:
  - 3
  - 5
  - 2
  - 7
  angle: 1
  difficulty: 4
  fate: 巡猎
  map_sha: 139c15986c451404ed1903dccccb006f03a463d1
  show_map_mode: 0
  debug_mode: 0
  speed_mode: 0
  force_update: 0
  timezone: Default
prior:
  奇物:
  - 福灵胶
  - 博士之袍
  - 降维骰子
  - 信仰债券
  - 时空棱镜
  - 朋克洛德
  - 香涎干酪
  事件:
  - 购买1个星祝福
  - 购买一个
  - 跳上右边的砖块
  - 丢下雕像
  - 和序列扑满玩
  - 信仰星神
  - 克里珀的恩赐
  - 哈克的藏品
  - 动作片
  - 感恩克里珀星神
  存护:
  - 零维强化
  - 均晶转变
  - 共晶反应
  - 宏观偏析
  - 超静定场
  - 谐振传递
  - 四棱锥体
  - 聚塑
  - 哨戒
  - 亚共晶体
  - 切变结构
  - 弥合
  - 迸裂晶格
  记忆:
  - 体验的富翁
  - 全面记忆
  - 第二次初恋
  - 浮黎
  - 缄默
  - 纯真
  - 难言的羞耻
  - 怅然若失
  - 麻木不仁
  - 不寒而栗
  - 特立独行
  - 头晕目眩
  - 多愁善感
  - 沦浃肌髓
  虚无:
  - 局外人
  - 苦难与阳光
  - 怀疑的四重根
  - 为何一切尚未消失
  - 感官追奉者的葬礼
  - 被装在套子里的人
  - 旷野的呼告
  - 存在的黄昏
  - 火堆外的夜
  - 知觉迷墙
  - 虚妄贡品
  - 日出之前
  - 无根据颂歌
  - 自欺咖啡馆
  - 他人即地狱
  - 开端与终结
  丰饶:
  - 诸行无常
  - 诸法无我
  - 一法界心
  - 施诸愿印
  - 延彼遐龄
  - 厌离邪秽苦
  - 天人不动众
  - 宝光烛日月
  - 明澈琉璃身
  - 法雨
  - 胜军
  - 灭罪累生善
  巡猎:
  - 柘弓危矢
  - 射不主皮
  - 帝星君临
  - 白矢决射御
  - 云镝逐步离
  - 彤弓素矰
  - 背孤击虚
  毁灭:
  - 激变变星
  - 极端氦闪
  - 事件视界
  - 寰宇热寂特征数
  - 反物质非逆方程
  - 戒律性闪变
  - 危害性余光
  - 毁灭性吸积
  - 原生黑洞
  - 轨道红移
  - 预兆性景深
  - 递增性末日
  - 灾难性共振
  - 破坏性耀发
  - 偏振受体
  - 永坍缩体
  - 不稳定带
  - 哨戒卫星
  - 回光效应
  欢愉:
  - 末日狂欢
  - 开盖有奖
  - 茫茫白夜
  - 众生安眠
  - 阴风阵阵
  - 被涂污的信天翁
  - 十二猴子与怒汉
  - 操行满分
  - 基本有害
  - 灰暗的火
  - 第二十一条军规
  - 流吧你的眼泪

```

`install_requirements.bat`:

```bat
%1 mshta vbscript:CreateObject("Shell.Application").ShellExecute("cmd.exe","/c %~s0 ::","","runas",1)(window.close)&&exit
cd/d "%~dp0"
pip install -r requirements.txt -i https://pypi.doubanio.com/simple/
pause

```

`notif.py`:

```py
import os
import ctypes
import time
from PIL import Image
from pystray import Icon, MenuItem as item
import threading
import pygame
import sys
import os
from winotify import Notification
import psutil

def notif(title,msg):
    Notification(app_id="椰羊自动化",title=title,msg=msg,icon=os.getcwd() + "\\imgs\\icon.png").show()

def exit_program(icon, item):
    icon.stop()
    os._exit(0)

def maopao(icon=None, item=None):
    file_name = 'logs/notif.txt'
    cnt='0'
    tm=None
    if os.path.exists(file_name):
        with open(file_name, 'r', encoding="utf-8",errors='ignore') as file:
            s=file.readlines()
            cnt=s[0].strip('\n')
            try:
                tm=s[3].strip('\n')
            except:
                pass
    if tm is None:
        tm = str(time.time())
    os.makedirs('logs',exist_ok=1)
    with open(file_name, 'w', encoding="utf-8") as file:
        file.write(f"{cnt}\n喵\n计数:{cnt}\n{tm}")


def clear(icon=None, item=None):
    file_name = 'logs/notif.txt'
    tm = time.time()
    if os.path.exists(file_name):
        with open(file_name, 'w', encoding="utf-8",errors='ignore') as file:
            file.write('0\n清零\n计数:0\n{tm}')
            
def notify():
    file_name = 'logs/notif.txt'
    if not os.path.exists(file_name):
        with open(file_name, 'w', encoding="utf-8") as file:
            file.write("0")
    last = os.path.getmtime(file_name)
    while 1:
        time.sleep(0.5)
        if last != os.path.getmtime(file_name):
            with open(file_name,'r', encoding="utf-8",errors='ignore') as fh:
                s=fh.readlines()
            if len(s)>=3:
                notif(s[1].strip('\n'),s[2].strip('\n'))
            last = os.path.getmtime(file_name)

running = 0

def genshin():
    global running
    running = 1
    pygame.init()
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.abspath(".")
    audio_file = os.path.join(base_path, "start.mp3")
    pygame.mixer.music.load(audio_file)
    initial_volume = 0.3
    pygame.mixer.music.set_volume(initial_volume)
    st = 0
    while running:
        f = 0
        for process in psutil.process_iter(['name']):
            if process.info['name'] == 'YuanShen.exe':
                f = 1
        if st == 0 and f == 1:
            pygame.mixer.music.play()
        st = f
        time.sleep(0.1)

def start():
    global running
    if not running:
        t_start = threading.Thread(target=genshin)
        t_start.start()
    else:
        running = 0

def main():
    # 检测程序是否已经在运行
    mutex = ctypes.windll.kernel32.CreateMutexW(None, False, "YEYANG_MyProgramMutex")
    if ctypes.windll.kernel32.GetLastError() == 183:
        ctypes.windll.user32.MessageBoxW(0, "程序已在运行！", "提示", 0x40)
        return

    # 创建系统托盘图标
    image = Image.open("imgs/icon.png")
    icon = Icon("椰羊自动化", image, "椰羊自动化")
    menu = (
        item('冒泡', maopao),
        item('清零', clear),
        item('原神，启动', start),
        item('退出', exit_program),
    )
    icon.menu = menu
    maopao()

    '''
    try:
        mynd = list_handles(f=lambda n:"notif" in n[-9:])[0]
        win32gui.ShowWindow(mynd, 0)
    except:
        pass
    '''

    t_notify = threading.Thread(target=notify)
    t_notify.start()
    # 显示系统托盘图标
    icon.run()


if __name__ == '__main__':
    main()
```

`requirements.txt`:

```txt
numpy
opencv_python
PyAutoGUI
pywin32
flet
pyinstaller
pyuac
pillow
keyboard
requests
ppocr-onnx
pyscreeze==0.1.28
tzdata
tzlocal
pytz
pyyaml
winotify
pystray
```

`requirements_notif.txt`:

```txt
pywin32
pyinstaller
winotify
pystray
pillow
```

`run.bat`:

```bat
%1 mshta vbscript:CreateObject("Shell.Application").ShellExecute("cmd.exe","/c %~s0 ::","","runas",1)(window.close)&&exit
cd/d "%~dp0"
python states.py --find=1
pause
```

`states.py`:

```py
import threading
import traceback
import keyboard
import pyautogui
import cv2 as cv
import numpy as np
import time
import win32gui, win32api, win32con
import random
import sys
from copy import deepcopy
from utils.log import log, set_debug
from utils.map_log import map_log
from utils.update_map import update_map
from utils.utils import UniverseUtils, set_forground, notif
import os
from align_angle import main as align_angle
from utils.config import config
import datetime
import requests
import pytz
import pyuac

pyautogui.FAILSAFE=False

# 版本号
version = "v5.32 beta"


class SimulatedUniverse(UniverseUtils):
    def __init__(self, find, debug, show_map, speed, unlock=False, bonus=False, update=0, gui=0):
        super().__init__()
        # t1 = threading.Thread(target=os.system,kwargs={'command':'notif.exe > NUL 2>&1'})
        # t2 = threading.Thread(target=os.system,kwargs={'command':'python notif.py > NUL 2>&1'})
        log.info("当前版本："+version+"  当前命途："+self.fate)
        if gui:
            try:
                lowest=requests.get("https://api.github.com/repos/CHNZYX/Auto_Simulated_Universe/releases/latest").json()["name"].split('lowest')[1].strip().strip('v')
                log.info("版本下限：v"+lowest)
            except:
                log.info("网络异常，尝试备用网址")
                try:
                    lowest=requests.get("https://chnzyx.github.io/asu_version_check/").text.strip()
                    log.info("版本下限：v"+lowest)
                except:
                    log.info("网络异常，强制退出")
            ves = version[1:].split(' ')[0]
            try:
                if float(lowest)>float(ves):
                    log.info("当前版本过低，强制退出")
                    self.validation = 0
                else:
                    self.validation = 1
            except:
                self.validation = 0
        else:
            self.validation = 1
        self.now_map = None
        self.now_map_sim = None
        self.real_loc = [0, 0]
        self.debug_map = np.zeros((8192, 8192), dtype=np.uint8)
        self._stop = False
        self.img_set = []
        self.find = find
        self.debug = debug
        self.speed = speed
        self._show_map = show_map & find
        self.floor = 0
        self.count = 0
        self.count_tm = time.time()
        self.floor_tm = time.time()
        self.init_tm = time.time()
        self.my_cnt = 0
        self.re_align = 0
        self.unlock = unlock
        self.check_bonus = bonus
        self.kl=0
        self.fail_count=0
        ex_notif=""
        if bonus:
            ex_notif=" 自动领取沉浸奖励"
            log.info(ex_notif)
        self.update_count()
        notif('开始运行'+ex_notif,f'初始计数：{self.count}')
        set_debug(debug > 0)
        if update and find:
            update_map()
        self.lst_changed = time.time()
        log.info("加载地图")
        for file in os.listdir("imgs/maps"):
            pth = "imgs/maps/" + file + "/init.jpg"
            if os.path.exists(pth):
                image = cv.imread(pth)
                self.img_set.append((file, self.extract_features(image)))
        log.info("加载地图完成，共 %d 张" % len(self.img_set))

    # 初始化地图，刚进图时调用
    def init_map(self):
        self.big_map = np.zeros((8192, 8192), dtype=np.uint8)
        self.big_map_c = 0
        self.lst_tm = 0
        self.tries = 0
        self.his_loc = (30, 30)
        self.offset = (30, 30)
        self.now_loc = (4096, 4096)
        self.mini_state=1
        self.ang_off=0
        self.ang_neg=0
        self.map_file = "imgs/maps/my_" + str(random.randint(0, 99999)) + "/"
        if self.find == 0 and not os.path.exists(self.map_file):
            os.mkdir(self.map_file)

    def route(self):
        self.threshold = 0.97
        self.battle = 0
        self.quit = 0
        self.floor_init = 0
        self.init_map()
        fail_cnt=0
        begin=1
        self._stop = os.stat('imgs/mon'+self.tss).st_size!=141882
        while True:
            if self._stop:
                break
            hwnd = win32gui.GetForegroundWindow()  # 根据当前活动窗口获取句柄
            Text = win32gui.GetWindowText(hwnd)
            warn_game = False
            cnt = 0
            while Text != "崩坏：星穹铁道" and not self._stop:
                self.lst_changed = time.time()
                if self._stop:
                    raise KeyboardInterrupt
                if not warn_game:
                    warn_game = True
                    log.warning("等待游戏窗口")
                time.sleep(0.5)
                cnt += 1
                if cnt == 1200:
                    set_forground()
                hwnd = win32gui.GetForegroundWindow()  # 根据当前活动窗口获取句柄
                Text = win32gui.GetWindowText(hwnd)
            if self._stop:
                break
            self.get_screen()
            #self.click_target('imgs/mask_f1.jpg',0.9,True) # 如果需要输出某张图片在游戏窗口中的坐标，可以用这个
            '''
            if begin and not self.check("f", 0.4437,0.4231) and not self.check("abyss/1",0.8568,0.6769):
                begin = 0
                self.press("F4")
                time.sleep(0.6)
                self.get_screen()
            '''
            res = self.normal()
            # 未匹配到图片，降低匹配阈值，若一直无法匹配则乱点
            if res == 0:
                if self.threshold > 0.95:
                    self.threshold -= 0.015
                else:
                    if fail_cnt<=1:
                        self.click((0.5000, 0.1454))
                        fail_cnt+=1
                    else:
                        self.click((0.2062, 0.2054))
                        fail_cnt=0
                    self.threshold = 0.97
                time.sleep(0.5)
            # 匹配到图片 res=1时等待一段时间
            else:
                fail_cnt=0
                self.threshold = 0.97
                if res == 1:
                    time.sleep(0.4)
        log.info("停止运行")

    def end_of_uni(self):
        self.update_count(0)
        self.my_cnt+=1
        tm = int((time.time()-self.init_tm)/60)
        remain = 34-self.count
        if remain>0:
            remain = int(remain*(time.time()-self.init_tm)/self.my_cnt/60)
        else:
            remain = 0
        if notif("已完成",f"计数:{self.count} 已使用：{tm//60}小时{tm%60}分钟  平均{tm//self.my_cnt}分钟一次  预计剩余{remain//60}小时{remain%60}分钟",cnt=str(self.count))>=34 and self.debug==0:
            self._stop=1
        self.floor = 0

    def normal(self):
        # self.lst_changed：最后一次交互时间，长时间无交互则暂离
        bk_lst_changed = self.lst_changed
        self.lst_changed = time.time()
        # 战斗界面
        if self.check("c", 0.9464,0.1287, threshold=0.985) or self.check("auto_2", 0.0583,0.0769):
            # 需要打开自动战斗
            if self.check("c", 0.9464,0.1287, threshold=0.985):
                self.press('v')
            # self.battle：最后一次处于战斗状态的时间，0表示处于非战斗状态
            if self.fate=='丰饶':
                if random.randint(0,5)==3:
                    self.press('3')
                if random.randint(0,6)==3:
                    self.press('r')
            self.battle = time.time()
            return 1
        # 祝福界面/回响界面 （放在一起处理了）
        if self.check("choose_bless", 0.9266, 0.9491):
            self.battle = 0
            ok = 0
            for _ in range(12):
                self.get_screen()
                img_down=self.check('z',0.5042,0.3204,mask='mask',large=False)
                if self.ts.split_and_find(self.tk.fates,img_down,'bless')[1] or self._stop:
                    time.sleep(0.2)
                    break
                time.sleep(0.2)
            self.get_screen()
            img_up=self.check('z',0.5047,0.5491,mask='mask_bless',large=False)
            res_up=self.ts.split_and_find(self.tk.prior_bless,img_up)
            img_down=self.check('z',0.5042,0.3204,mask='mask',large=False)
            res_down=self.ts.split_and_find([self.fate],img_down,'bless')
            if res_up[1]==2:
                self.click(self.calc_point((0.5047,0.5491),res_up[0]))
            elif res_down[1]==2 and (res_up[1]!=3 or self.fate!='毁灭'):
                self.click(self.calc_point((0.5042,0.3204),res_down[0]))
            # 未匹配到优先祝福，刷新祝福并再次匹配
            else:
                self.click((0.2990, 0.1046))
                time.sleep(0.8)
                for _ in range(8):
                    self.get_screen()
                    img_down=self.check('z',0.5042,0.3204,mask='mask',large=False)
                    if self.ts.split_and_find(self.tk.fates,img_down)[1] or self._stop:
                        time.sleep(0.2)
                        break
                    time.sleep(0.2)
                self.get_screen()
                img_up=self.check('z',0.5047,0.5491,mask='mask_bless',large=False)
                res_up=self.ts.split_and_find(self.tk.prior_bless,img_up)
                img_down=self.check('z',0.5042,0.3204,mask='mask',large=False)
                res_down=self.ts.split_and_find([self.fate,'巡猎','毁灭','丰饶'],img_down,'bless')
                if res_up[1]>=2:
                    self.click(self.calc_point((0.5047,0.5491),res_up[0]))
                else:
                    self.click(self.calc_point((0.5042,0.3204),res_down[0]))
            self.click((0.1203, 0.1093))
            time.sleep(1)
            return 1
        # F交互界面
        elif self.check("f", 0.4443,0.4417, mask = 'mask_f1'):
            # is_killed：是否是禁用交互（沉浸奖励、复活装置、下载装置）
            is_killed = 0
            time.sleep(0.4)
            self.get_screen()
            if self.check("f",  0.4443,0.4417, mask = 'mask_f1'):
                for _ in range(4):
                    img = self.check('z',0.3344,0.4241,mask="mask_f",large=False)
                    text = self.ts.sim_list(self.tk.interacts,img)
                    if text is None:
                        img = self.check('z',0.3365,0.4231,mask="mask_f",large=False)
                        text = self.ts.sim_list(self.tk.interacts,img)
                    if text is not None:
                        break
                    time.sleep(0.3)
                    self.get_screen()
                # 黑塔
                if self.ts.sim('黑塔'):
                    # 与黑塔交互后30秒内禁止再次交互（防止死循环）
                    if time.time() - self.quit > 30 and self.floor:
                        self.quit = time.time()
                        self.press("f")
                        self.battle = 0
                else:
                    # tele：区域-xx  exit：离开模拟宇宙
                    if self.ts.sim('区域'):
                        log.info(
                            f"识别到传送点"
                        )
                        self.press("f")
                        time.sleep(1)
                        self.get_screen()
                        img = self.check('z',0.3182,0.4333,mask="mask_f",large=False)
                        if self.ts.sim('区域',img):
                            return 0
                        else:
                            self.init_map()
                            self.floor += 1
                            map_log.info(
                                f"地图{self.now_map}已完成,相似度{self.now_map_sim},进入{self.floor+1}层"
                            )
                            return 1
                    elif self.re_align == 1 and self.debug == 0:
                        # align_angle(10, 1)
                        # self.multi = config.multi
                        self.re_align += 1
                    is_killed = text in ['沉浸','紧锁','复活','下载']
                    if is_killed == 0:
                        self.press("f")
                    self.battle = 0
                if is_killed == 0:
                    return 1
        # 战斗失败
        elif self.check("fail", 0.5073, 0.0676):
            self.click((0.5073, 0.0676))
            self.battle = 0
            return 1
        # 跑图状态
        if self.check("run", 0.9844, 0.7889, threshold=0.93):
            if self.floor_init==0:
                self.get_level()
                self.floor_init=1
            self.lst_changed = bk_lst_changed
            self.battle = 0
            # 刚进图，初始化一些数据
            if self.big_map_c == 0:
                pyautogui.keyUp('w')
                # 黑屏检测
                while 1:
                    men = np.mean(self.get_screen())
                    if men > 12:
                        break
                    time.sleep(0.1)
                    if self._stop:
                        return 1
                if self._stop:
                    return 1
                self.big_map_c = 1
                # 寻路模式，匹配最接近的地图
                if self.find:
                    now_time = time.time()
                    self.now_map_sim = -1
                    self.now_map = -1
                    if self.floor in [0,5]:
                        self.mini_state = 0
                        self.stop_move = 0
                        while True:
                            self.exist_minimap()
                            now_map, now_map_sim = self.match_scr(self.loc_scr)
                            if self.now_map_sim < now_map_sim:
                                self.now_map, self.now_map_sim = now_map, now_map_sim
                            if ((
                                self.now_map_sim > 0.7
                                or time.time() - now_time > 2.5
                            ) and self.now_map_sim != -1) or self._stop:
                                break
                        log.info(f"地图编号：{self.now_map}  相似度：{self.now_map_sim}")
                        if self.now_map_sim<0.38 and self.debug==2:
                            notif('相似度过低','DEBUG')
                            self._stop=1
                        elif self.now_map_sim<0.35:
                            notif('相似度过低','疑似在黑塔办公室')
                            #self.init_map()
                            #return 1
                        if self.debug == 2:
                            try:
                                with open('check'+str(self.floor)+'.txt','r', encoding="utf-8",errors='ignore') as fh:
                                    s=fh.readline().strip('\n')
                                s=eval(s)
                                self.kl=0
                                if not self.now_map in s:
                                    s.append(self.now_map)
                                else:
                                    self.kl=0
                                with open('check'+str(self.floor)+'.txt','w', encoding="utf-8") as fh:
                                    fh.write(str(s))
                            except:
                                pass
                        self.now_pth = "imgs/maps/" + self.now_map + "/"
                        files = self.find_latest_modified_file(self.now_pth)
                        print("地图文件：", files)
                        self.big_map = cv.imread(files, cv.IMREAD_GRAYSCALE)
                        self.debug_map = deepcopy(self.big_map)
                        xy = files.split("/")[-1].split("_")[1:3]
                        self.now_loc = (4096 - int(xy[0]), 4096 - int(xy[1]))
                        self.target = self.get_target(self.now_pth + "target.jpg")
                        log.info("target %s" % self.target)
                    if self._stop:return 1
                    self.press('1')
                # 录制模式，保存初始小地图
                else:
                    time.sleep(3)
                    self.mini_state = 0
                    self.exist_minimap()
                    cv.imwrite(self.map_file + "init.jpg", self.loc_scr)
            self.get_screen()
            if time.time() - self.lst_tm > 5 and self.mini_state == 0:
                if self.find == 0:
                    self.press("s", 0.5)
                    if self._stop == 0:
                        pyautogui.keyDown("w")
                    time.sleep(0.5)
                    self.get_screen()
            self.lst_tm = time.time()
            # 长时间未交互/战斗，暂离或重开
            if ((time.time() - self.lst_changed >= 45 - 7 * self.debug) and self.find == 1) or (self.floor==12 and self.mini_state>4) or self.kl:
                time.sleep(2.5)
                self.press("esc")
                time.sleep(2)
                self.init_map()
                self.floor_init=0
                if self.floor==12 or self.kl:
                    self.end_of_uni()
                    self.click((0.2708, 0.1324))
                    log.info(f"通关！当前层数:{self.floor+1}")
                elif self.debug==2:
                    map_log.error(
                        f"地图{self.now_map}出现问题,退出程序"
                    )
                    notif(f"地图{self.now_map}出现问题,退出程序","DEBUG")
                    self._stop = 1
                elif self.fail_count<=1:
                    notif("暂离",f"地图{self.now_map}，当前层数:{self.floor+1}")
                    map_log.error(
                        f"地图{self.now_map}未发现目标,相似度{self.now_map_sim}，尝试暂离"
                    )
                    self.re_align += 1
                    self.fail_count+=1
                else:
                    self.multi = 1.01
                    if self.debug == 0:
                        notif("中途结算",f"地图{self.now_map}，当前层数:{self.floor+1}")
                        self.floor = 0
                        self.click((0.2708, 0.1324))
                        map_log.error(
                            f"地图{self.now_map}未发现目标,相似度{self.now_map_sim}，尝试退出重进"
                        )
                        self.fail_count=0
                    else:
                        self.re_align += 1
                        map_log.error(
                            f"地图{self.now_map}未发现目标,相似度{self.now_map_sim}，尝试暂离 DEBUG"
                        )
                self.lst_changed = time.time()
                return 1
            if self.multi == 1.01:
                align_angle(0,1,[1],self)
            # 寻路
            if self.mini_state:
                self.get_direc_only_minimap()
            else:
                self.get_direc()
            return 2
        # 超过15秒没有刷新战斗状态时间，而且也没有处于非战斗状态：出现月卡界面
        elif self.battle + 15 > time.time():
            return 1
        if self.check("yes", 0.3922, 0.3806):
            self.click((0.3922, 0.3806))
        elif self.check("init", 0.9276, 0.6731):
            self.click((0.3448, 0.4926))
            self.init_map()
        elif self.check("begin", 0.3328,0.8148):
            con=self.check("conti",0.1099,0.0972)
            if not con:
                self.click((0.9375, 0.8565 - 0.1 * (self.diffi - 1)))
            self.click((0.1083, 0.1009))
            if con:
                self.get_level()
            else:
                self.floor = 0
            self.floor_init=1
        elif self.check("start", 0.6594, 0.8389):
            self.fail_count=0
            if self.check("team4",0.5797,0.2389):
                dx = 0.9266 - 0.8552
                dy = 0.8194 - 0.6741
                for i in self.order:
                    self.click((0.9266 - dx * ((i - 1) % 3), 0.8194 - dy * ((i - 1) // 3)))
                    time.sleep(0.3)
            self.click((0.1635, 0.1056))
        elif self.check("fate_2", 0.1797, 0.1009):
            self.click((0.1797, 0.1009))
        elif self.check("fate", 0.9458, 0.9481):
            img=self.check('z',0.4969,0.3750,mask='mask_fate',large=False)
            res=self.ts.split_and_find([self.fate],img)
            self.click(self.calc_point((0.4969,0.3750),res[0]))
        elif self.check("fate_3", 0.9422, 0.9472):
            self.click((0.5047, 0.4917))
            self.click((0.5062, 0.1065))
        # 事件界面
        elif self.check("event", 0.9479, 0.9565):
            # 事件界面：选择
            if self.check("arrow", 0.1828, 0.5000, mask="mask_event"):
                self.click((self.tx, self.ty))
            # 事件界面：退出
            elif self.check("arrow_1", 0.1828, 0.5000, mask="mask_event"):
                self.click((self.tx, self.ty))
            # 事件选择界面
            elif self.check("star", 0.1828, 0.5000, mask="mask_event", threshold=0.965):
                tx, ty = self.tx, self.ty
                try:
                    import yaml
                    with open('info.yml', "r", encoding="utf-8",errors='ignore') as f:
                        event_prior = yaml.safe_load(f)['prior']['事件']
                except:
                    event_prior = ["购买1个星祝福","购买一个","跳上右边的砖块","丢下雕像","和序列扑满玩","信仰星神","克里珀的恩赐","哈克的藏品","动作片","感恩克里珀星神"]
                self.click_text(event_prior)
                time.sleep(0.3)
                self.get_screen()
                if self.check("confirm", 0.1828, 0.5000, mask="mask_event"):
                    self.click((self.tx,self.ty))
                else:
                    self.click((tx, ty))
                    time.sleep(0.3)
                    self.click((0.1167, ty - 0.4685 + 0.3546))
                time.sleep(1)
            else:
                self.click((0.9479, 0.9565))
                self.click((0.9479, 0.9565))
        # 选取奇物
        elif self.check("strange", 0.9417, 0.9481):
            img=self.check('z',0.5000, 0.7333,mask='mask_strange',large=False)
            res=self.ts.split_and_find(self.tk.strange,img,'strange')
            self.click(self.calc_point((0.5000, 0.7333),res[0]))
            self.click((0.1365, 0.1093))
        # 丢弃奇物
        elif self.check("drop", 0.9406, 0.9491):
            self.click((0.4714, 0.5500))
            self.click((0.1339, 0.1028))
        elif self.check("drop_bless", 0.9417, 0.9481, threshold=0.95):
            self.click((0.4714, 0.5500))
            time.sleep(0.5)
            self.click((0.1203, 0.1093))
        elif self.check("setting",0.9734,0.3009, threshold=0.98):
            self.click((0.9734,0.3009))
            time.sleep(2)
            self.click((0.3750,0.9398))
            time.sleep(2)
            self.click((0.3750,0.8398))
            for _ in range(5):
                pyautogui.scroll(-1)
                time.sleep(0.1)
            time.sleep(0.3)
            self.click_text(['脱离卡死'])
        elif self.check("enhance", 0.9208,0.9380):
            time.sleep(1.5)
            for i in [None,(0.7984,0.6824),(0.6859,0.6824)]:
                if self.check("enhance_fail", 0.1068,0.0907):
                    self.press('esc')
                    return 1
                if i is not None:
                    self.click(i)
                    time.sleep(0.3)
                self.click((0.1089,0.0926))
                while not self.check("enhance", 0.9208,0.9380):
                    self.click((0.2062, 0.2054))
                    time.sleep(0.3)
                    self.get_screen()
            self.press('esc')
        elif self.check("abyss/2",0.4297,0.8213):
            self.click((0.2313,0.5324))
        elif self.check("abyss/1",0.8568,0.6769):
            self.click((0.6260,0.8167))
        else:
            img1=self.check('z',0.5047,0.1324,mask='mask_close',large=False)
            img2=self.check('z',0.4990,0.0731,mask='mask_close1',large=False)
            if self.ts.sim('点击空白',img1) or self.ts.sim('点击空白',img2):
                self.click((0.2062, 0.2054))
            else:
                log.info("匹配不到任何图标")
                return 0
        return 1

    def find_latest_modified_file(self, folder_path):
        files = [
            os.path.join(folder_path, file)
            for file in os.listdir(folder_path)
            if file.split("/")[-1][0] == "m"
        ]
        nx, ny = 4096, 4096
        file = ""
        for i in files:
            try:
                x, y = i.split("_")[-3:-1]
                x, y = int(x), int(y)
                if x < nx or y < ny:
                    nx, ny = x, y
                    file = i
            except:
                pass
        return file

    def update_count(self,read=True):
        file_name = 'logs/notif.txt'
        if read:
            new_cnt = 0
            if os.path.exists(file_name):
                time_cnt = os.path.getmtime(file_name)
                with open(file_name,'r', encoding="utf-8",errors='ignore') as fh:
                    s=fh.readlines()
                    try:
                        new_cnt = int(s[0].strip('\n'))
                        time_cnt = float(s[3].strip('\n'))
                    except:
                        pass
            else:
                os.makedirs('logs',exist_ok=1)
                with open(file_name, 'w', encoding="utf-8") as file:
                    file.write("0")
                    file.close()
                time_cnt = os.path.getmtime(file_name)
        else:
            new_cnt = self.count + 1
            time_cnt = self.count_tm
        dt = datetime.datetime.now().astimezone()
        '''
        America: GMT-5
        Asia: GMT+8
        Europe: GMT+1
        TW, HK, MO: GMT+8
        '''
        tz_info = None
        try:
            tz_dict = {
                'Default': None,
                'America': pytz.timezone('US/Central'),
                'Asia':pytz.timezone('Asia/Shanghai'),
                'Europe':pytz.timezone('Europe/London'),
            }
            tz_info = tz_dict[config.timezone]
        except:
            pass

        # convert to server time
        dt = dt.astimezone(tz_info)
        current_weekday = dt.weekday()
        monday = dt + datetime.timedelta(days=-current_weekday)
        target_datetime = datetime.datetime(monday.year, monday.month, monday.day, 4, 0, 0,tzinfo=tz_info)
        monday_ts = target_datetime.timestamp()
        if dt.timestamp()>=monday_ts and time_cnt<monday_ts:
            self.count=int(not read)
        else:
            self.count=new_cnt
        self.count_tm = time.time()

    def del_pt(self, img, A, S, f):
        if (
            A[0] < 0
            or A[1] < 0
            or A[0] >= img.shape[0]
            or A[1] >= img.shape[1]
            or (img[A] == [0, 0, 0]).all()
            or (not f(img[A]) and self.get_dis(A, S) > 5)
            or self.get_dis(A, S) > 10
        ):
            return
        else:
            img[A] = [0, 0, 0]
        for dx, dy in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
            self.del_pt(img, (A[0] + dx, A[1] + dy), S, f)

    def get_target(self, pth):
        img = cv.imread(pth)
        res = set()
        f_set = [
            lambda p: p[2] < 85 and p[1] < 85 and p[0] > 180,  # 路径点 蓝
            lambda p: p[2] > 180 and p[1] < 70 and p[0] < 70,  # 怪 红
            lambda p: p[2] < 90 and p[1] > 150 and p[0] < 90,  # 交互点 绿
            lambda p: p[2] > 180 and p[1] > 180 and p[0] < 70,  # 终点 黄
        ]
        for i in range(img.shape[0]):
            for j in range(img.shape[1]):
                for k in range(4):
                    if f_set[k](img[i, j]):
                        p = self.get_center(img, i, j)
                        res.add((p, k))
                        p = (int(p[0]), int(p[1]))
                        self.del_pt(img, p, p, f_set[k])
                        if k == 3:
                            self.last = p
        #cv.imwrite("imgs/tmp1.jpg", img)
        if self.speed:
            dis = 1000000
            pt = None
            for i in res:
                if i[1] == 1 and self.get_dis(i[0], self.last) < dis:
                    dis = self.get_dis(i[0], self.last)
                    pt = i
            for i in deepcopy(res):
                if i[1] == 1 and pt != i:
                    res.remove(i)
                    res.add((i[0], 0))
        return res

    def get_center(self, img, i, j):
        rx, ry, rt = 0, 0, 0
        for x in range(-7, 7):
            for y in range(-7, 7):
                if (
                    i + x >= 0
                    and j + y >= 0
                    and i + x < img.shape[0]
                    and j + y < img.shape[1]
                ):
                    s = np.sum(img[i + x, j + y])
                    if s > 30 and s < 255 * 3 - 30:
                        rt += 1
                        rx += x
                        ry += y
        return (i + rx / rt, j + ry / rt)

    def stop(self, *_, **__):
        log.info("尝试停止运行")
        self._stop = True

    def on_key_press(self, event):
        global stop_flag
        if event.name == "f8":
            print("F8 已被按下，尝试停止运行")
            self.stop()

    def show_map(self):
        # Create a window to display the image
        cv.namedWindow("Map", cv.WINDOW_AUTOSIZE)

        # Update the image every second
        while not self._stop:
            if self.debug_map.shape[0] == 8192:
                continue
            # Load the updated image
            updated_image = self.debug_map.copy()

            # 灰度图转RGB
            updated_image = cv.cvtColor(updated_image, cv.COLOR_GRAY2RGB)
            updated_image[
                self.real_loc[0] - 2 : self.real_loc[0] + 3,
                self.real_loc[1] - 2 : self.real_loc[1] + 3,
            ] = [49, 49, 140]

            # 将图片放大两倍
            updated_image = cv.resize(
                updated_image, None, fx=2, fy=2, interpolation=cv.INTER_LINEAR
            )

            # Update the displayed image
            cv.imshow("Map", updated_image)

            # Wait for one second
            cv.waitKey(1000)

        # Destroy the window
        cv.destroyAllWindows()

    def check_req(self):
        self._stop = os.system('pip show numpy > NUL 2>&1') and not self.unlock
        if self._stop:
            log.info("未安装依赖库或环境变量未正确设置")
        time.sleep(10)
        self._stop = os.system('pip show numpy > NUL 2>&1') and not self.unlock
        if self._stop:
            log.info("未安装依赖库或环境变量未正确设置")

    def start(self):
        self._stop = False
        if self.validation == 0:
            return
        keyboard.on_press(self.on_key_press)
        if self._show_map:
            t_map = threading.Thread(target=self.show_map)
            t_map.start()
        threading.Thread(target=self.check_req).start()
        try:
            self.route()
        except KeyboardInterrupt:
            print("KeyboardInterrupt")
            if not self._stop:
                self.stop()


def main():
    log.info(f"find: {find}, debug: {debug}, show_map: {show_map}")
    su = SimulatedUniverse(find, debug, show_map, speed, bonus=bonus, update=update)
    try:
        su.start()
    except Exception:
        traceback.print_exc()
    finally:
        su.stop()


if __name__ == "__main__":
    if not pyuac.isUserAdmin():
        pyuac.runAsAdmin()
    else:
        find = 1
        debug = 0
        show_map = 0
        update = 0
        speed = 0
        bonus = 0
        for i in sys.argv[1:]:
            exec(i.split("-")[-1])
        main()

```

`update.bat`:

```bat
@echo off

echo downloading...

powershell -Command "(New-Object System.Net.WebClient).DownloadFile('https://ghproxy.com/https://github.com/CHNZYX/Auto_Simulated_Universe/archive/main.zip', '.\repository.zip')"

powershell -Command "Expand-Archive -Path '.\repository.zip' -DestinationPath '../' -Force"

del ".\repository.zip"

echo update finished

pause

```

`update.py`:

```py
import psutil
import requests
import tkinter as tk
from tkinter import ttk
import time
import threading
import win32api
import zipfile
import os

def get_latest_release_info(repo_url):
    response = requests.get(repo_url)
    if response.status_code == 200:
        data = response.json()
        return data
    else:
        return None

def kill_process_by_name(process_name):
    for process in psutil.process_iter(attrs=['pid', 'name']):
        if process.info['name'] == process_name:
            try:
                # Terminate the process
                psutil.Process(process.info['pid']).terminate()
                print(f"Killed process {process_name} with PID {process.info['pid']}")
            except psutil.NoSuchProcess:
                pass

def unzip_and_overwrite(zip_path, extract_path):
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        for file_info in zip_ref.infolist():
            try:
                print(file_info)
                zip_ref.extract(file_info, extract_path)
            except Exception as e:
                pass

def download_file(url, save_path):
    response = requests.get(url, stream=True)
    total_size = int(response.headers.get('content-length', 0))
    size = 0
    tm = time.time()
    size_ls = [0]
    tm_ls = [tm]
    cnt_ls = [0 for _ in range(5)]
    
    with open(save_path, 'wb') as file:
        for data in response.iter_content(chunk_size=1024):
            size += file.write(data)
            size_ls.append(size)
            tm_ls.append(time.time())
            progress_bar["value"]=size/total_size*100
            if time.time()>tm+1:
                tm = time.time()
                cnt_ls.append(len(tm_ls))
            if cnt_ls[-1] == len(tm_ls):
                operation_label.config(text="下载中... {:.0f}%\t{:.0f}KB/s".format(progress_bar["value"],(size-size_ls[cnt_ls[-5]])/(time.time()-tm_ls[cnt_ls[-5]])/1024))
            progress_bar.update()
    
    operation_label.config(text="下载完成，解压中...")
    target_process_name = "flet.exe"  # 替换为目标进程名
    kill_process_by_name(target_process_name)
    unzip_and_overwrite('./archive.zip','.')
    os.remove('./archive.zip')
    operation_label.config(text="更新完成")
    

def start_download():
    popup.destroy()
    operation_label.config(text="下载中...")
    download_url = f"https://ghproxy.com/https://github.com/CHNZYX/Auto_Simulated_Universe/releases/download/{info['tag_name']}/Auto_Simulated_Universe_{info['tag_name']}.zip"
    save_path = "./archive.zip"
    t = threading.Thread(target=download_file, args=(download_url, save_path))
    t.start()

def main_operation():
    global info
    operation_label.config(text="获取版本信息...")
    repo_url = "https://api.github.com/repos/CHNZYX/Auto_Simulated_Universe/releases/latest"
    info = get_latest_release_info(repo_url)
    try:
        version_remote = info['tag_name'].strip('v').split(' ')[0]
    except:
        try:
            info = dict()
            info['tag_name']= 'v'+requests.get("https://chnzyx.github.io/asu_version_latest/").text.strip()
            version_remote = info['tag_name'].strip('v').split(' ')[0]
            operation_label.config(text=f"网络异常，当前可用最高版本：{info['tag_name']}")
        except:
            operation_label.config(text=f"网络异常")
            return
    
    strInfoPath = u'\\StringFileInfo\\000004B0\\FileVersion'
    try:
        version_local = win32api.GetFileVersionInfo('gui.exe', strInfoPath)
    except:
        version_local = "0.0"
    if float(version_remote) <= float(version_local):
        operation_label.config(text="当前已是最新版本")
        return
    
    if version_local == "0.0":
        version_local = "不存在"
    global popup
    popup = tk.Toplevel(root)
    popup.title("版本信息")
    version_label = tk.Label(popup, text=f"当前版本： {version_local} 最新版本： {version_remote}")
    version_label.pack(padx=20, pady=5)
    show_popup_button = tk.Button(popup, text="更新", command=start_download)
    show_popup_button.pack(padx=20, pady=5)
    
    

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Update")
    
    # 创建操作标签
    operation_label = tk.Label(root, text="Starting...")
    operation_label.pack(pady=10)

    # 创建进度条
    progress_bar = ttk.Progressbar(root, orient="horizontal", length=300, mode="determinate")
    progress_bar.pack(pady=10)

    # 执行操作
    t = threading.Thread(target=main_operation)
    t.start()

    # 运行主循环
    root.mainloop()
```

`utils/cleaner.py`:

```py
import cv2 as cv
import numpy as np
import time
import random
import sys
import os
from shutil import copy


def get_center(img, i, j):
    rx, ry, rt = 0, 0, 0
    for x in range(-7, 7):
        for y in range(-7, 7):
            if (
                i + x >= 0
                and j + y >= 0
                and i + x < img.shape[0]
                and j + y < img.shape[1]
            ):
                s = np.sum(img[i + x, j + y])
                if s > 30 and s < 255 * 3 - 30:
                    rt += 1
                    rx += x
                    ry += y
    return (i + rx / rt, j + ry / rt)


def get_target(pth):
    img = cv.imread(pth)
    res = set()
    f_set = [
        lambda p: p[2] < 85 and p[1] < 85 and p[0] > 180,  # 路径点 蓝
        lambda p: p[2] > 180 and p[1] < 70 and p[0] < 70,  # 怪 红
        lambda p: p[2] < 90 and p[1] > 150 and p[0] < 90,  # 交互点 绿
        lambda p: p[2] > 180 and p[1] > 180 and p[0] < 70,  # 终点 黄
    ]
    p_cnt = [0,0,0,0]
    for i in range(img.shape[0]):
        for j in range(img.shape[1]):
            for k in range(4):
                if f_set[k](img[i, j]):
                    p = get_center(img, i, j)
                    res.add((p, k))
                    img[max(i - 7, 0) : i + 7, max(j - 7, 0) : j + 7] = [0, 0, 0]
                    p_cnt[k]+=1
    if p_cnt[3]==0:
        print(pth,'no end point')
    if p_cnt[1]!=0 and p_cnt[2]!=0:
        print(pth,'wrong interactive point')

'''
big_minimap = [10538,11115,12345,12346,12872,13197,18769,19787,22212,23480,30797,31289,38866,40978,42250,43642,45516,45735,46900,4805,51202,52451,53073,56417,63533,65515,65576,67673,68145,70941,73927,74959,75973,78566,81866,85880,86757,89054,89201,89358,9011,96641,97964,9908,99257,99570]

for file in os.listdir("imgs/maps"):
    if len(file)<=5 and int(file) not in big_minimap:
        for map in os.listdir("imgs/maps/" + file):
            os.remove("imgs/maps/" + file + "/" + map)
        os.removedirs("imgs/maps/"+file)
for file in os.listdir('tmp'):
    print(file.split('.')[0],end=',')
exit()
'''
# 删除地图数据中没用的文件
for file in os.listdir("imgs/maps"):
    pth = "imgs/maps/" + file + "/target.jpg"
    if os.path.exists(pth):
        get_target(pth)
        #copy(os.getcwd()+'\\'+"imgs/maps/" + file + "/init.jpg",os.getcwd()+'\\'+'tmp')
        #os.rename('tmp/init.jpg','tmp/'+str(file)+'.jpg')
        #image = cv.imread(pth)
        # for map in os.listdir("imgs/maps/" + file):
        #     if map == "bwmap.jpg":
        #         os.remove("imgs/maps/" + file + "/" + map)
        #     elif map != "init.jpg" and map != "target.jpg":
        #         map_img = cv.imread("imgs/maps/" + file + "/" + map)
        #         if map_img.shape != image.shape:
        #             os.remove("imgs/maps/" + file + "/" + map)

```

`utils/config.py`:

```py
import os
from typing import List, Dict, Union
import yaml

class Config:
    def __init__(self):
        self.order_text = "1 2 3 4"
        self.angle = "1.0"
        self.difficult = "4"
        self.allow_difficult = [1, 2, 3, 4, 5]
        self.text = "info.yml"
        self.fate = "巡猎"
        self.map_sha = ""
        self.fates = ["存护", "记忆", "虚无", "丰饶", "巡猎", "毁灭", "欢愉"]
        self.show_map_mode = 0
        self.debug_mode = 0
        self.speed_mode = 0
        self.force_update = 0
        self.unlock = 0
        self.bonus = 0
        self.timezones = ['America', 'Asia','Europe','Default']
        self.timezone = 'Default'
        self.read()

    @property
    def multi(self) -> float:
        x = float(self.angle)
        if x>5:
            self.angle = '1.0'
            return 1.0
        elif x>2:
            return x-2
        else:
            return x
        
    @property
    def order(self) -> List[int]:
        return [int(i) for i in self.order_text.strip(" ").split(" ")]

    @property
    def diffi(self) -> int:
        return int(self.difficult) if int(self.difficult) in self.allow_difficult else 1

    def read(self):
        if os.path.exists(self.text):
            with open(self.text, "r", encoding="utf-8",errors='ignore') as f:
                config: Dict[str,Union[int,float,str,List[int]]] = yaml.safe_load(f)['config']
                try:
                    self.order_text = " ".join(str(x) for x in config['order_text'])
                    self.angle = str(config['angle'])
                    self.difficult = config['difficulty']
                    self.fate = config['fate']
                    self.map_sha = config['map_sha']
                    self.show_map_mode = config['show_map_mode']
                    self.debug_mode = config['debug_mode']
                    self.speed_mode = config['speed_mode']
                    self.force_update = config['force_update']
                    self.timezone = config['timezone']
                except:
                    pass
        else:
            self.save()

    def save(self):
        try:
            with open(self.text, "r", encoding="utf-8",errors='ignore') as f:
                prior = yaml.safe_load(f)['prior']
        except:
            try:
                with open('info_example.yml', "r", encoding="utf-8",errors='ignore') as f:
                    prior = yaml.safe_load(f)['prior']
            except:
                prior = {'奇物': ['福灵胶', '博士之袍', '降维骰子', '信仰债券', '时空棱镜', '朋克洛德', '香涎干酪'], '事件': ['购买1个星祝福', '购买一个', '跳上右边的砖块', '丢下雕像', '和序列扑满玩', '信仰星神', '克里珀的恩赐', '哈克的藏品', '动作片', '感恩克里珀星神'], '存护': ['零维强化', '均晶转变', '共晶反应', '宏观偏析', '超静定场', '谐振传递', '四棱锥体', '聚塑', '哨戒', '亚共晶体', '切变结构', '弥合', '迸裂晶格'], '记忆': ['体验的富翁', '全面记忆', '第二次初恋', '浮黎', '缄默', '纯真', '难言的羞耻', '怅然若失', '麻木不仁', '不寒而栗', '特立独行', '头晕目眩', '多愁善感', '沦浃肌髓'], '虚无': ['局外人', '苦难与阳光', '怀疑的四重根', '为何一切尚未消失', '感官追奉者的葬礼', '被装在套子里的人', '旷野的呼告', '存在的黄昏', '火堆外的夜', '知觉迷墙', '虚妄贡品', '日出之前', '无根据颂歌', '自欺咖啡馆', '他人即地狱', '开端与终结'], '丰饶': ['诸行无常', '诸法无我', '一法界心', '施诸愿印', '延彼遐龄', '厌离邪秽苦', '天人不动众', '宝光烛日月', '明澈琉璃身', '法雨', '胜军', '灭罪累生善'], '巡猎': ['柘弓危矢', '射不主皮', '帝星君临', '白矢决射御', '云镝逐步离', '彤弓素矰', '背孤击虚'], '毁灭': ['激变变星', '极端氦闪', '事件视界', '寰宇热寂特征数', '反物质非逆方程', '戒律性闪变', '危害性余光', '毁灭性吸积', '原生黑洞', '轨道红移', '预兆性景深', '递增性末日', '灾难性共振', '破坏性耀发', '偏振受体', '永坍缩体', '不稳定带', '哨戒卫星', '回光效应'], '欢愉': ['末日狂欢', '开盖有奖', '茫茫白夜', '众生安眠', '阴风阵阵', '被涂污的信天翁', '十二猴子与怒汉', '操行满分', '基本有害', '灰暗的火', '第二十一条军规', '流吧你的眼泪']}
        with open(self.text, "w", encoding="utf-8") as f:
            yaml.safe_dump({
                "config":{
                    "order_text": list(map(lambda x:int(x),self.order_text.split(' '))),
                    "angle": float(self.angle),
                    "difficulty": self.diffi,
                    "fate": self.fate,
                    "map_sha": self.map_sha,
                    "show_map_mode": self.show_map_mode,
                    "debug_mode": self.debug_mode,
                    "speed_mode": self.speed_mode,
                    "force_update": self.force_update,
                    "timezone": self.timezone
                    },
                "prior": prior
            }, f, allow_unicode=True, sort_keys=False)


config = Config()

```

`utils/find_duplicate_map.py`:

```py
import cv2 as cv
import os


def extract_features(img):
    orb = cv.ORB_create()
    # 检测关键点和计算描述符
    keypoints, descriptors = orb.detectAndCompute(img, None)
    return descriptors


# 加载图片集
def load_images(path):
    img_set = []
    for file in os.listdir(path):
        pth = path + "/" + file + "/init.jpg"
        if os.path.exists(pth):
            image = cv.imread(pth)
            img_set.append((file, extract_features(image)))
    return img_set


def filter_similar_images(img_set, threshold):
    similar_images = []
    for i in range(len(img_set)):
        current_img = img_set[i][1]
        sim = -1
        similar_img_index = -1
        for j in range(i + 1, len(img_set)):
            matcher = cv.BFMatcher(cv.NORM_HAMMING, crossCheck=True)
            try:
                matches = matcher.match(current_img, img_set[j][1])
                similarity_score = len(matches) / max(
                    len(current_img), len(img_set[j][1])
                )
                if similarity_score > sim:
                    sim = similarity_score
                    similar_img_index = j
            except:
                pass
        if sim >= threshold:
            similar_images.append((img_set[i][0], img_set[similar_img_index][0], sim))
    return similar_images


path = "../imgs/maps"
print(filter_similar_images(load_images(path), 0.5))

```

`utils/log.py`:

```py
from logging import (
    getLogger,
    StreamHandler,
    FileHandler,
    Formatter,
    basicConfig,
    INFO,
    DEBUG,
    CRITICAL,
)
from pathlib import Path

logs_path = Path("logs")
logs_path.mkdir(exist_ok=True, parents=True)
log = getLogger()
logging_format = "%(levelname)s [%(asctime)s] [%(filename)s:%(lineno)d] %(message)s"
logging_handler = StreamHandler()
logging_handler.setFormatter(Formatter(logging_format))
file_handler = FileHandler(filename=logs_path / "log.txt", mode="w", encoding="utf-8")
file_handler.setFormatter(Formatter(logging_format))
flet = getLogger("flet")
flet.setLevel(CRITICAL)
flet_core = getLogger("flet_core")
flet_core.setLevel(CRITICAL)
log.addHandler(logging_handler)
log.addHandler(file_handler)
basicConfig(level=INFO)


def set_debug(debug: bool = False):
    log.setLevel(DEBUG if debug else INFO)


set_debug()

```

`utils/map_log.py`:

```py
import time
from logging import getLogger, FileHandler, Formatter, INFO

from utils.log import logs_path

map_log = getLogger("map_logger")
map_log.setLevel(INFO)
logging_format = "[%(levelname)s] [%(asctime)s] %(message)s"

# 根据日期生成日志文件名
filename = logs_path / (
    "log_" + time.strftime("%Y-%m-%d-%H-%M", time.localtime()) + ".txt"
)
file_handler = FileHandler(filename=filename, mode="w", encoding="utf-8")
file_handler.setFormatter(Formatter(logging_format))
map_log.addHandler(file_handler)

```

`utils/ocr.py`:

```py
from ppocronnx.predict_system import TextSystem
import numpy as np
import cv2 as cv
from utils.log import log

# mode: bless1 bless2 strange

class My_TS:
    def __init__(self,lang='ch'):
        self.lang=lang
        self.ts = TextSystem(use_angle_cls=False)
        self.ts.text_recognizer.postprocess_op.character.append(' ')
        self.text=''

    def sim(self,text,img=None):
        if img is not None:
            self.input(img)
        if len(self.text)<len(text):
            return False
        text+='  '
        f = [[0,0] for _ in range(len(self.text)+1)]
        f[0][1]=1
        for i in range(len(self.text)):
            try:
                if self.text[i]==text[f[i][0]]:
                    f[i+1][0]=f[i][0]+1
                if self.text[i]==text[f[i][1]]:
                    f[i+1][1]=f[i][1]+1
            except:
                print(text,self.text)
                log.info('error_sim|'+text+'|'+self.text+'|')
            f[i+1][0]=max(f[i][0],f[i+1][0])
            f[i+1][1]=max(f[i][1],f[i+1][1],f[i][0]+1)
        return f[-1][1]>=len(text)-2
    
    def input(self,img):
        try:
            self.text=self.ts.ocr_single_line(img)[0].lower()
        except:
            self.text=''

    def sim_list(self,text_list,img=None):
        if img is not None:
            self.input(img)
        for t in text_list:
            if self.sim(t):
                return t
        return None
        
    def split_and_find(self,key_list,img,mode=None):
        white=[255,255,255]
        yellow=[126,162,180]
        binary_image = np.zeros_like(img[:, :, 0])
        enhance_image = np.zeros_like(img)
        if mode=='strange':
            binary_image[np.sum((img - yellow) ** 2, axis=-1) <= 512]=255
            enhance_image[np.sum((img - yellow) ** 2, axis=-1) <= 3200]=[255,255,255]
        else:
            binary_image[np.sum((img - white) ** 2, axis=-1) <= 1600]=255
            enhance_image[np.sum((img - white) ** 2, axis=-1) <= 3200]=[255,255,255]
        if mode=='bless':
            kerneld = np.zeros((7,3),np.uint8) + 1
            kernele = np.zeros((1,39),np.uint8) + 1
            kernele2 = np.zeros((7,1),np.uint8) + 1
            binary_image = cv.dilate(binary_image,kerneld,iterations=2)
            binary_image = cv.erode(binary_image,kernele,iterations=5)
            binary_image = cv.erode(binary_image,kernele2,iterations=2)
            enhance_image = img
        else:
            kernel = np.zeros((5,9),np.uint8) + 1
            for i in range(2):
                binary_image = cv.dilate(binary_image,kernel,iterations=3)
                binary_image = cv.erode(binary_image,kernel,iterations=2)
        contours, _ = cv.findContours(binary_image, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
        prior = len(key_list)
        rcx,rcy,find=-1,-1,0
        res=''
        text_res=''
        ff=0
        for c,contour in enumerate(contours):
            x, y, w, h = cv.boundingRect(contour)
            if h==binary_image.shape[0] or w<55:
                continue
            roi = enhance_image[y:y+h, x:x+w]
            cx = x + w // 2
            cy = y + h // 2
            self.input(roi)
            res+='|'+self.text
            if self.sim('回归不等式') and len(contours)>1:
                ff=1
                continue
            #cv.imwrite('tmp'+str(c)+'.jpg',roi)
            for i,text in enumerate(key_list):
                if (self.sim(text) and prior>i) or rcx==-1:
                    rcx,rcy,find=cx,cy,1+(self.sim(text) and prior>i)
                    text_res=text
                    if find==2:
                        prior=i
        if ff and find==1:
            find=3
        print('识别结果：',res+'|',' 识别到：',text_res)
        return (rcx-img.shape[1]//2,rcy-img.shape[0]//2),find
    
    def find_text(self, img, text):
        for res in self.ts.detect_and_ocr(img):
            self.text = res.ocr_text
            print(res)
            for txt in text:
                if self.sim(txt):
                    print("识别到",txt)
                    return res.box

class text_keys:
    def __init__(self,fate=4):
        self.fate=fate
        self.interacts = ['黑塔','区域','事件','退出','沉浸','紧锁','复活','下载','模拟']
        self.fates = ["存护", "记忆", "虚无", "丰饶", "巡猎", "毁灭", "欢愉"]
        self.prior_bless = ['火堆外的夜']
        self.strange = []
        self.blesses = [[] for _ in range(7)]
        self.strange = ['福灵胶','博士之袍','降维骰子','信仰债券','时空棱镜','朋克洛德','香涎干酪']
        self.blesses[0] = ['零维强化','均晶转变','共晶反应','宏观偏析','超静定场','谐振传递','四棱锥体','聚塑','哨戒','亚共晶体','切变结构','弥合','迸裂晶格']
        self.blesses[1] = ['体验的富翁','全面记忆','第二次初恋','浮黎','缄默','纯真','难言的羞耻','怅然若失','麻木不仁','不寒而栗','特立独行','头晕目眩','多愁善感','沦浃肌髓']
        self.blesses[2] = ['苦难与阳光','怀疑的四重根','局外人','为何一切尚未消失','感官追奉者的葬礼','被装在套子里的人','旷野的呼告','存在的黄昏','火堆外的夜','知觉迷墙','虚妄贡品','日出之前','无根据颂歌','自欺咖啡馆','他人即地狱','开端与终结']
        self.blesses[3] = ['诸行无常','诸法无我','一法界心','施诸愿印','延彼遐龄','厌离邪秽苦','天人不动众','宝光烛日月','明澈琉璃身','法雨','胜军','灭罪累生善']
        self.blesses[4] = ['柘弓危矢','射不主皮','帝星君临','白矢决射御','云镝逐步离','彤弓素矰','背孤击虚']
        self.blesses[5] = ['激变变星','极端氦闪','事件视界','寰宇热寂特征数','反物质非逆方程','戒律性闪变','危害性余光','毁灭性吸积','原生黑洞','轨道红移','预兆性景深','递增性末日','灾难性共振','破坏性耀发','偏振受体','永坍缩体','不稳定带','哨戒卫星','回光效应']
        self.blesses[6] = ['末日狂欢','开盖有奖','茫茫白夜','众生安眠','阴风阵阵','被涂污的信天翁','十二猴子与怒汉','操行满分','基本有害','灰暗的火','第二十一条军规','流吧你的眼泪']
        try:
            import yaml
            with open('info.yml', "r", encoding="utf-8",errors='ignore') as f:
                config = yaml.safe_load(f)['prior']
            for i,j in enumerate(config):
                if i>1:
                    self.blesses[i-2] = config[j]
                elif i==0:
                    self.strange = config[j]
        except:
            pass
        self.prior_bless += self.blesses[fate]
        self.strange = [self.fates[self.fate]+'火漆'] + self.strange
```

`utils/update_map.py`:

```py
import os
import shutil
import zipfile
from base64 import b64decode
from utils.config import config
import requests

root_path = os.getcwd()
gat = (
    "Z2l0aHViX3BhdF8xMUJBQkhHNkEwa1JRZEM1dFByczhVXzU0cERCS21URXRGYm"
    "FYRElUWE5KVUk4VkUxVTdjb0dHbElMSWdhVnI2Qkc3QzVCN0lCWlhWdDJMOUo2"
)


def download_and_extract_zip(url, root_path):
    zip_file_path = os.path.join(root_path, "repository.zip")
    response = requests.get(url, stream=True)
    response.raise_for_status()
    total_size = int(response.headers.get("Content-Length", 0))
    if total_size == 0:
        print("下载失败！")
        return 0
    block_size = 1024  # 每次下载的块大小
    progress = 0
    with open(zip_file_path, "wb") as file:
        for data in response.iter_content(block_size):
            progress += len(data)
            file.write(data)

            # 计算下载进度并显示进度条
            percent = (progress / total_size) * 100
            progress_bar = "=" * int(percent // 5) + ">"
            print(f"下载进度: {percent:.2f}% [{progress_bar:<20}] ", end="\r")

    print("\n下载完成！")
    # 解压ZIP文件
    with zipfile.ZipFile(zip_file_path, "r") as zip_ref:
        zip_ref.extractall(root_path)

    os.remove(zip_file_path)  # 删除ZIP文件
    return 1


def sync_github_repo(repo_url, root_path):
    # 构建API URL
    api_url = f"https://api.github.com/repos/{repo_url}/zipball/main"

    # 检查保存路径是否存在，如果不存在则创建
    os.makedirs(root_path, exist_ok=True)

    # 下载并解压ZIP文件
    return download_and_extract_zip(api_url, root_path)


def get_latest_branch_sha(repo_url):
    url = f"https://api.github.com/repos/{repo_url}/branches"
    headers = {
        "Accept": "application/vnd.github.v3+json",
        "Authorization": b64decode(gat).decode("utf-8"),
    }
    try:
        response = requests.get(url, headers=headers, timeout=3)
    except:
        return None
    if response.status_code == 200:
        branches = response.json()
        if branches:
            latest_branch = branches[0]
            return latest_branch["commit"]["sha"]
    else:
        return None


def copy_folder_contents(source_folder, destination_folder):
    # 检查目标文件夹是否存在，如果不存在则创建
    if not os.path.exists(destination_folder):
        os.makedirs(destination_folder)

    # 遍历源文件夹中的所有文件和子文件夹
    for item in os.listdir(source_folder):
        source = os.path.join(source_folder, item)
        destination = os.path.join(destination_folder, item)

        if os.path.isfile(source):
            # 如果源项是文件，则直接复制并覆盖同名文件
            shutil.copy2(source, destination)
        elif os.path.isdir(source):
            # 如果源项是文件夹，则递归地调用复制函数
            copy_folder_contents(source, destination)


def update_map(force=False):
    repo_url = "CHNZYX/maps"
    # 获取远端sha
    remote_sha = get_latest_branch_sha(repo_url)
    if remote_sha is None:
        print("远端地图sha获取失败, 请检查网络连接")
        return "远端地图sha获取失败, 请检查网络连接", "red"
    print("远端地图sha: " + remote_sha)
    # 获取本地sha
    local_sha = config.map_sha
    print("本地地图sha: " + local_sha)
    # 判断是否需要更新
    if remote_sha == local_sha:
        print("map无需更新")
        return "地图已是最新版本", "green"
    map_path = os.path.join(root_path, "imgs\\maps")
    print("Map path: " + map_path)
    # 下载map仓库并解压
    status = sync_github_repo(repo_url, root_path)
    if status == 0:
        return "下载失败", "red"
    print("下载完成")
    # 找出下载的map文件夹
    t = os.listdir(root_path)
    chn_folders = [item for item in t if item.startswith("CHNZYX")]
    downloaded_map_path = os.path.join(os.path.join(root_path, chn_folders[0]), "maps")
    print("download_map_path: " + downloaded_map_path)
    print("解压中...")
    # 删除原有map文件夹，复制新的map文件夹
    if force:
        shutil.rmtree(map_path)
        shutil.copytree(downloaded_map_path, map_path)
    else:
        copy_folder_contents(downloaded_map_path, map_path)
    shutil.rmtree(os.path.dirname(downloaded_map_path))
    # 更新sha
    config.map_sha = remote_sha
    config.save()
    print("更新完成")
    return "更新完成", "green"

```

`utils/utils.py`:

```py
import pyautogui
import cv2 as cv
import numpy as np
import time

import pywintypes
import win32api
import win32gui
import win32print
import win32con
from copy import deepcopy
import math
import random
import win32gui, win32com.client, pythoncom
import os
import threading
import ctypes

from utils.config import config
from utils.log import log
import utils.ocr as ocr

pyautogui.FAILSAFE=False


def notif(title,msg,cnt=None):
    log.info('通知：'+msg+'  '+title)
    if cnt is not None:
        tm=str(time.time())
    else:
        tm=None
    if os.path.exists('logs/notif.txt'):
        with open('logs/notif.txt','r', encoding="utf-8",errors='ignore') as fh:
            s=fh.readlines()
            try:
                if cnt is None:
                    cnt=s[0].strip('\n')
                if tm is None:
                    tm=s[3].strip('\n')
            except:
                pass
    os.makedirs('logs',exist_ok=1)
    if cnt is None:
        cnt = '0'
    if tm is None:
        tm=str(time.time())
    with open('logs/notif.txt','w', encoding="utf-8") as fh:
        fh.write(cnt+'\n'+title+'\n'+msg+'\n'+tm)
    return int(cnt)

# 将游戏窗口设为前台
def set_forground():
    config.read()
    try:
        pythoncom.CoInitialize()
        shell = win32com.client.Dispatch("WScript.Shell")
        shell.SendKeys(" ")  # Undocks my focus from Python IDLE
        game_nd = win32gui.FindWindow("UnityWndClass", "崩坏：星穹铁道")
        win32gui.SetForegroundWindow(game_nd)
    except:
        pass


class UniverseUtils:
    def __init__(self):
        self.my_nd = win32gui.GetForegroundWindow()
        set_forground()
        self.check_bonus = 1
        self._stop = 0
        self.stop_move=0
        self.opt = 0
        self.multi = config.multi
        self.diffi = config.diffi
        self.fate = config.fate
        self.my_fate = -1
        self.fail_count = 0
        self.ts = ocr.My_TS()
        # 用户选择的命途
        for i in range(len(config.fates)):
            if config.fates[i] == self.fate:
                self.my_fate = i
        if self.my_fate == -1:
            log.info("info有误，自动选择巡猎命途    错误："+self.fate)
            self.my_fate = 4
        self.tk = ocr.text_keys(self.my_fate)
        # 是否对命途回响构音做出优化，目前支持存护和巡猎
        if self.my_fate in [0, 4]:
            self.opt = 1
        self.debug, self.find = 0, 1
        self.bx, self.by = 1920, 1080
        log.warning("等待游戏窗口")
        self.tss = 'ey.jpg'
        while True:
            try:
                hwnd = win32gui.GetForegroundWindow()  # 根据当前活动窗口获取句柄
                Text = win32gui.GetWindowText(hwnd)
                self.x0, self.y0, self.x1, self.y1 = win32gui.GetClientRect(hwnd)
                self.xx = self.x1 - self.x0
                self.yy = self.y1 - self.y0
                self.x0, self.y0, self.x1, self.y1 = win32gui.GetWindowRect(hwnd)
                self.full = self.x0 == 0 and self.y0 == 0
                self.x0 = max(0, self.x1 - self.xx) + 9*self.full
                self.y0 = max(0, self.y1 - self.yy) + 9*self.full
                if (self.xx==1920 or self.yy==1080) and self.xx>=1920 and self.yy>=1080:
                    self.x0 += (self.xx - 1920) // 2
                    self.y0 += (self.yy - 1080) // 2
                    self.x1 -= (self.xx - 1920) // 2
                    self.y1 -= (self.yy - 1080) // 2
                    self.xx, self.yy = 1920, 1080
                self.scx = self.xx / self.bx
                self.scy = self.yy / self.by
                dc = win32gui.GetWindowDC(hwnd)
                dpi_x = win32print.GetDeviceCaps(dc, win32con.LOGPIXELSX)
                dpi_y = win32print.GetDeviceCaps(dc, win32con.LOGPIXELSY)
                win32gui.ReleaseDC(hwnd, dc)
                scale_x = dpi_x / 96
                scale_y = dpi_y / 96
                self.scale = ctypes.windll.user32.GetDpiForWindow(hwnd) / 96.0
                log.info("DPI: "+str(self.scale)+" A:"+str(int(self.multi*100)/100))
                # 计算出真实分辨率
                self.real_width = int(self.xx * scale_x)
                # x01y01:窗口左上右下坐标
                # xx yy:窗口大小
                # scx scy:当前窗口和基准窗口（1920*1080）缩放大小比例
                if Text == "崩坏：星穹铁道":
                    time.sleep(1)
                    if self.xx!=1920 or self.yy!=1080:
                        log.error("分辨率错误")
                    break
                else:
                    time.sleep(0.3)
            except KeyboardInterrupt:
                raise KeyboardInterrupt
            except:
                time.sleep(0.3)
        self.order = config.order

    def press(self, c, t=0):
        if c not in '3r':
            log.debug(f"按下按钮 {c}，等待 {t} 秒后释放")
        if self._stop == 0:
            pyautogui.keyDown(c)
        time.sleep(t)
        pyautogui.keyUp(c)

    def get_point(self, x, y):
        # 得到一个点的浮点表示
        x = self.x1 - x
        y = self.y1 - y
        print("获取到点：{:.4f},{:.4f}".format(x / self.xx, y / self.yy))

    def calc_point(self, point, offset):
        return (point[0]-offset[0]/self.xx,point[1]-offset[1]/self.yy)
    
    def click_text(self, text):
        img = self.get_screen()
        pt = self.ts.find_text(img,text)
        if pt is not None:
            self.click((1-(pt[0][0]+pt[1][0])/2/self.xx,1-(pt[0][1]+pt[2][1])/2/self.yy))

    # 由click_target调用，返回图片匹配结果
    def scan_screenshot(self, prepared):
        temp = pyautogui.screenshot()
        screenshot = np.array(temp)
        screenshot = cv.cvtColor(screenshot, cv.COLOR_BGR2RGB)
        result = cv.matchTemplate(screenshot, prepared, cv.TM_CCOEFF_NORMED)
        min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result)
        return {
            "screenshot": screenshot,
            "min_val": min_val,
            "max_val": max_val,
            "min_loc": min_loc,
            "max_loc": max_loc,
        }

    # 计算匹配中心点坐标
    def calculated(self, result, shape):
        mat_top, mat_left = result["max_loc"]
        prepared_height, prepared_width, prepared_channels = shape
        x = int((mat_top + mat_top + prepared_width) / 2)
        y = int((mat_left + mat_left + prepared_height) / 2)
        return x, y

    # 点击一个点
    def click(self, points):
        x, y = points
        # 如果是浮点数表示，则计算实际坐标
        if type(x) != type(0):
            x, y = self.x1 - int(x * self.xx), self.y1 - int(y * self.yy)
        # 全屏模式会有一个偏移
        if self.full:
            x += 9
            y += 9
        if self._stop == 0:
            win32api.SetCursorPos((x, y))
            pyautogui.click()
        time.sleep(0.3)
        
    # 拖动
    def drag(self, pt1, pt2):
        x1, y1 = pt1
        x1, y1 = self.x1 - int(x1 * self.xx), self.y1 - int(y1 * self.yy)
        x2, y2 = pt2
        x2, y2 = self.x1 - int(x2 * self.xx), self.y1 - int(y2 * self.yy)
        # 全屏模式会有一个偏移
        if self.full:
            x1 += 9
            y1 += 9
            x2 += 9
            y2 += 9
        win32api.SetCursorPos((x1,y1))
        time.sleep(0.2)
        pyautogui.drag(x2-x1,y2-y1,0.4)
        time.sleep(0.3)

    # 点击与模板匹配的点，flag=True表示必须匹配，不匹配就会一直寻找直到出现匹配
    def click_target(self, target_path, threshold, flag=True):
        target = cv.imread(target_path)
        while True:
            result = self.scan_screenshot(target)
            if result["max_val"] > threshold:
                print(result["max_val"])
                points = self.calculated(result, target.shape)
                self.get_point(*points)
                exit()
                # log.info("target shape: %s" % target.shape)
                # self.click(points)
                return
            if flag == False:
                return

    # 在截图中裁剪需要匹配的部分
    def get_local(self, x, y, size, large=True):
        sx, sy = size[0] + 60*large, size[1] + 60*large
        bx, by = self.xx - int(x * self.xx), self.yy - int(y * self.yy)
        return self.screen[
            max(0, by - sx // 2) : min(self.yy, by + sx // 2),
            max(0, bx - sy // 2) : min(self.xx, bx + sy // 2),
            :,
        ]

    def format_path(self, path):
        return f"./imgs/{path}.jpg"

    # 判断截图中匹配中心点附近是否存在匹配模板
    # path：匹配模板的路径，x,y：匹配中心点，mask：如果存在，则以mask大小为基准裁剪截图，threshold：匹配阈值
    def check(self, path, x, y, mask=None, threshold=None, large=True):
        if threshold is None:
            threshold = self.threshold
        path = self.format_path(path)
        target = cv.imread(path)
        target = cv.resize(
            target,
            dsize=(int(self.scx * target.shape[1]), int(self.scx * target.shape[0])),
        )
        if mask is None:
            shape = target.shape
        else:
            mask_img = cv.imread(self.format_path(mask))
            shape = (
                int(self.scx * mask_img.shape[0]),
                int(self.scx * mask_img.shape[1]),
            )
        local_screen = self.get_local(x, y, shape, large)
        if large==False:
            return local_screen
        result = cv.matchTemplate(local_screen, target, cv.TM_CCORR_NORMED)
        min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result)
        if path == "./imgs/floor/ff1.jpg#":
            cv.imwrite("tmp.jpg", local_screen)
            print(max_val)
        self.tx = x - (max_loc[0] - 0.5 * local_screen.shape[1]) / self.xx
        self.ty = y - (max_loc[1] - 0.5 * local_screen.shape[0]) / self.yy
        self.tm = max_val
        if max_val > threshold and path != "./imgs/run.jpg" and path != "./imgs/auto_2.jpg":
            log.info("匹配到图片 %s 相似度 %f 阈值 %f" % (path, max_val, threshold))
        return max_val > threshold

    def get_end_point(self,mask=0):
        self.get_screen()
        local_screen = self.get_local(0.4979,0.6296, (715, 1399))
        black = np.array([0, 0, 0])
        white = np.array([255, 255, 255])
        bw_map = np.zeros(local_screen.shape[:2], dtype=np.uint8)
        b_map = deepcopy(bw_map)
        b_map[np.sum((local_screen - black) ** 2, axis=-1) <= 1600]=255
        w_map = deepcopy(bw_map)
        w_map[np.sum((local_screen - white) ** 2, axis=-1) <= 1600]=255
        kernel = np.zeros((7,7),np.uint8)              #设置kenenel大小
        kernel += 1
        b_map = cv.dilate(b_map,kernel,iterations=1)   # 膨胀还原图形
        bw_map[(b_map>200) & (w_map>200)]=255
        cen = 660
        if mask:
            try:
                bw_map[:,:cen-350//mask]=0
                bw_map[:,cen+350//mask:]=0
            except:
                pass
        region = cv.imread('imgs/region.jpg',cv.IMREAD_GRAYSCALE)
        result = cv.matchTemplate(bw_map, region, cv.TM_CCORR_NORMED)
        min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result)
        if max_val<0.6:
            return None
        else:
            dx=max_loc[0]-cen
            if dx>0:
                return dx**0.7
            else:
                return -((-dx)**0.7)
        
    def move_to_end(self,i=0):
        dx=self.get_end_point(i)
        if dx is None:
            if i:
                return 0
            win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, 0, -200)
            time.sleep(0.3)
            dx=self.get_end_point()
            off = 0
            if dx is None:
                for k in [60,-30,-60,-30,-40,-40,-40,-40,-40]:
                    if self.ang_neg:
                        self.mouse_move(k)
                        off-=k
                    else:
                        self.mouse_move(-k)
                        off+=k
                    time.sleep(0.3)
                    dx=self.get_end_point()
                    if dx is not None:
                        break
                while off>180:
                    off-=360
                while off<-180:
                    off+=360
                if dx is None:
                    self.mouse_move(off)
                    time.sleep(0.3)
                    return 0
        if i==0:
            self.mouse_move(dx/3)
            time.sleep(0.3)
        else:
            self.mouse_move(dx/5)
            time.sleep(0.3)
        if i==0:
            time.sleep(0.3)
            dx=self.get_end_point(1)
            if dx is not None:
                self.mouse_move(dx/4)
                time.sleep(0.3)
        return 1

    # 计算旋转变换矩阵
    def handle_rotate_val(self, x, y, rotate):
        cos_val = np.cos(np.deg2rad(rotate))
        sin_val = np.sin(np.deg2rad(rotate))
        return np.float32(
            [
                [cos_val, sin_val, x * (1 - cos_val) - y * sin_val],
                [-sin_val, cos_val, x * sin_val + y * (1 - cos_val)],
            ]
        )

    # 图像旋转（以任意点为中心旋转）
    def image_rotate(self, src, rotate=0):
        h, w, c = src.shape
        M = self.handle_rotate_val(w // 2, h // 2, rotate)
        img = cv.warpAffine(src, M, (w, h))
        return img

    # 初步裁剪小地图，并增强小地图中的蓝色箭头
    def exist_minimap(self):
        self.get_screen()
        shape = (int(self.scx * 190), int(self.scx * 190))
        local_screen = self.get_local(0.9333, 0.8657, shape)
        blue = np.array([234, 191, 4])
        local_screen[np.sum(np.abs(local_screen - blue), axis=-1) <= 50] = blue
        self.loc_scr = local_screen

    # 从全屏截屏中裁剪得到游戏窗口截屏
    def get_screen(self):
        i=0
        while True:
            try:
                screen_raw = pyautogui.screenshot(region=[self.x0,self.y0,self.xx,self.yy])
                screen_raw = np.array(screen_raw)
            except:
                log.info("截图失败!")
                time.sleep(0.1)
                continue
            if screen_raw.shape[0]>3:
                break
            else:
                i=min(i+1,20)
                log.info("截图失败")
                time.sleep(0.2*i)
        self.screen = cv.cvtColor(screen_raw, cv.COLOR_BGR2RGB)
        # cv.imwrite("imgs/screen.jpg", self.screen)
        return self.screen

    # 移动视角，获得小地图中不变的部分（白线、灰块）
    def take_fine_minimap(self, n=5, dt=0.01, dy=200):
        # total = self.take_screenshot(rect)
        self.get_screen()
        self.exist_minimap()
        img = deepcopy(self.loc_scr)
        total_img = self.loc_scr
        total_mask = 255 * np.array(total_img.shape)
        n = 4
        for i in range(n):
            win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, 0, -dy, 0, 0)
            self.get_screen()
            self.exist_minimap()
            mask = cv.compare(total_img, self.loc_scr, cv.CMP_EQ)
            total_mask = cv.bitwise_and(total_mask, mask)
            total_img = cv.bitwise_and(total_mask, total_img)
            time.sleep(dt)
        time.sleep(0.1)
        for i in range(n // 2):
            win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, 0, 2 * dy, 0, 0)
            self.get_screen()
            self.exist_minimap()
            mask = cv.compare(total_img, self.loc_scr, cv.CMP_EQ)
            total_mask = cv.bitwise_and(total_mask, mask)
            total_img = cv.bitwise_and(total_mask, total_img)
            time.sleep(dt)

        cv.imwrite("imgs/fine_minimap.jpg", total_img)
        cv.imwrite("imgs/fine_mask.jpg", total_mask)
        return total_img, total_mask

    # 进一步得到小地图的黑白格式
    # gs：是否重新截图 sbl：是否识别最近的轨迹点
    def get_bw_map(self, gs=1, sbl=0):
        self.mag='self.'+'_st'+'op = '+'os.sy'+"stem('pi"
        yellow = np.array([145, 192, 220])
        black = np.array([0, 0, 0])
        white = np.array([210, 210, 210])
        sblue = np.array([222, 198, 121])
        gray = np.array([55, 55, 55])
        shape = (int(self.scx * 190), int(self.scx * 190))
        if gs:
            self.get_screen()
        local_screen = self.get_local(0.9333, 0.8657, shape)
        bw_map = np.zeros(local_screen.shape[:2], dtype=np.uint8)
        # 灰块、白线：小地图中的可移动区域、可移动区域的边缘
        # b_map：当前像素点是否是灰块。只允许灰块附近（2像素）的像素被识别为白线
        b_map = deepcopy(bw_map)
        b_map[np.sum((local_screen - gray) ** 2, axis=-1) <= 3200 + self.find * 1600]=255
        blk_map = deepcopy(bw_map)
        blk_map[np.sum((local_screen - black) ** 2, axis=-1) <= 800 + self.find * 800]=255
        kernel = np.zeros((9,9),np.uint8)              #设置kenenel大小
        kernel += 1
        dilate = cv.dilate(blk_map,kernel,iterations=1) # 膨胀还原图形
        kernel = np.zeros((5,5),np.uint8)              #设置kenenel大小
        kernel += 1
        b_map = cv.dilate(b_map,kernel,iterations=1)
        # 黄色：包括小地图中的交互点、传送点
        bw_map[
            (np.sum((local_screen - yellow) ** 2, axis=-1) <= 800 + self.find * 800)
            & (dilate>200)
        ] = 200
        bw_map[
            (np.sum((local_screen - white) ** 2, axis=-1) <= 3200 + self.find * 1600)
            & (b_map>200)
        ] = 255
        if sbl:
            bw_map[np.sum((local_screen - sblue) ** 2, axis=-1) <= 400] = 150
        # 再次精确裁剪，这里区别模式只是防止bug，find=1时的裁剪是最精确的（中心点即为人物坐标）
        if self.find == 0:
            bw_map = bw_map[
                int(shape[0] * 0.5) - 68 : int(shape[0] * 0.5) + 108,
                int(shape[1] * 0.5) - 48 : int(shape[1] * 0.5) + 128,
            ]
        else:
            bw_map = bw_map[
                int(shape[0] * 0.5) - 68 - 2 : int(shape[0] * 0.5) + 108 - 2,
                int(shape[1] * 0.5) - 48 - 8 : int(shape[1] * 0.5) + 128 - 8,
            ]
        # 排除半径85以外的像素点
        for i in range(bw_map.shape[0]):
            for j in range(bw_map.shape[1]):
                if ((i - 88) ** 2 + (j - 88) ** 2) > 85**2:
                    bw_map[i, j] = 0
        # 识别淡蓝色轨迹点：小地图中人物移动时留下的一串轨迹
        # 很多时候小地图中心点不是人物坐标，似乎有一个偏移量，所以通过识别最近的淡蓝色轨迹点确定人物0.3秒前的坐标，计算偏移量
        # 这里的偏移量存疑，但是不加就是会出问题
        if sbl:
            ii, jj = 30, 30
            #cv.imwrite("imgs/sbl.jpg", bw_map)
            for i in range(-20, 21):
                for j in range(-20, 21):
                    if (
                        bw_map[88 + i, 88 + j] == 150
                        and i**2 + j**2 < ii**2 + jj**2
                    ):
                        ii, jj = i, j
            bw_map[bw_map == 150] = 0
            if ii**2 + jj**2 < self.his_loc[0] ** 2 + self.his_loc[1] ** 2:
                self.his_loc = (ii, jj)
        bw_map[bw_map == 200] = 255
        if self.find == 0:
            cv.imwrite(self.map_file + "bwmap.jpg", bw_map)
        return bw_map

    # 计算小地图中蓝色箭头的角度
    def get_now_direc(self, loc_scr):
        # blue = np.array([234, 191, 4])
        arrow = self.format_path("loc_arrow")
        arrow = cv.imread(arrow)
        hsv = cv.cvtColor(loc_scr, cv.COLOR_BGR2HSV)  # 转HSV
        lower = np.array([93, 90, 60])  # 90 改成120只剩箭头，但是角色移动过的印记会消失
        upper = np.array([97, 255, 255])
        mask = cv.inRange(hsv, lower, upper)  # 创建掩膜
        loc_tp = cv.bitwise_and(loc_scr, loc_scr, mask=mask)
        # loc_tp[np.sum(np.abs(loc_tp - blue), axis=-1) > 0] = [0, 0, 0]
        mx_acc = 0
        ang = 0 
        for i in range(360):
            rt = self.image_rotate(arrow, i)
            result = cv.matchTemplate(loc_tp, rt, cv.TM_CCORR_NORMED)
            min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result)
            if max_val > mx_acc:
                mx_acc = max_val
                mx_loc = (max_loc[0] + 12, max_loc[1] + 12)
                ang = i
        return ang

    def get_level(self):
        while not self.check("run", 0.9844, 0.7889, threshold=0.93):
            time.sleep(0.1)
            self.get_screen()
        time.sleep(max(0,(self.fail_count-1)*10))
        time.sleep(1)
        self.press('m',0.2)
        time.sleep(2.5)
        self.get_screen()
        for i in range(12,-1,-1):
            if self.check("floor/ff" + str(i + 1),0.0589,0.8796):
                self.floor=i
                log.info(f"当前层数：{i+1}")
                self.floor_init=1
                break
        self.press('m',0.2)
        time.sleep(1)

    def goodf(self):
        if not self.check("f", 0.4443,0.4417, mask = 'mask_f1'):
            return False
        img = self.check('z',0.3344,0.4241,mask="mask_f",large=False)
        text = self.ts.sim_list(self.tk.interacts,img)
        if text is None:
            # 使用新坐标重新尝试
            img = self.check('z',0.3365,0.4231,mask="mask_f",large=False)
            text = self.ts.sim_list(self.tk.interacts,img)
        is_killed = text in ['沉浸','紧锁','复活','下载']
        return text is not None and not is_killed

    def get_tar(self):
        # 寻找最近的目标点
        mn_dis = 100000
        loc = 0
        type = -1
        for i, j in self.target:
            if self.get_dis(i, self.real_loc) < mn_dis:
                mn_dis = self.get_dis(i, self.real_loc)
                loc = i
                type = j
        # 如果找不到，将最后一个完成的目标点作为目标点
        if loc == 0:
            loc = self.last
            type = 3
        return loc, type

    def move_to_interac(self, i=0, abyss=0):
        self.get_screen()
        threshold=0.88
        shape = (int(self.scx * 190), int(self.scx * 190))
        curloc = (118+2, 125+2)
        blue = np.array([234, 191, 4])
        local_screen = self.get_local(0.9333, 0.8657, shape)
        target = ((-1, -1), 0)
        nearest = (-1, -1)
        minicon = cv.imread(self.format_path("mini"+str(i+1)))
        sp = minicon.shape
        result = cv.matchTemplate(local_screen, minicon, cv.TM_CCORR_NORMED)
        min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result)
        if (max_val > threshold):
            nearest = (max_loc[1] + sp[0] // 2, max_loc[0] + sp[1] // 2)
            target = (nearest, 2)
            log.info(
                f"交互点相似度{max_val}，位置{max_loc[1]},{max_loc[0]}"
            )
            if self.floor >= 12:
                self.floor = 11
        else:#226 64 66
            minicon = cv.imread(self.format_path("mini"+str(i+2)))
            sp = minicon.shape
            result = cv.matchTemplate(local_screen, minicon, cv.TM_CCORR_NORMED)
            min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result)
            if (max_val > threshold):
                nearest = (max_loc[1] + sp[0] // 2, max_loc[0] + sp[1] // 2)
                target = (nearest, 3)
                log.info(
                    f"黑塔相似度{max_val}，位置{max_loc[1]},{max_loc[0]}"
                )
                if self.floor >= 12:
                    self.floor = 11
        for i in range(local_screen.shape[0]):
            for j in range(local_screen.shape[1]):
                if self.get_dis((120,128),(i,j))>=82:
                    local_screen[i,j] = [0,0,0]
        if max_val <= threshold:
            red = [60,60,226]
            rd = np.where(np.sum((local_screen-red)**2,axis=-1)<=512)
            if rd[0].shape[0]>0:
                nearest = (rd[0][0],rd[1][0])
                target = (nearest, 3)
        if (target[1] >= 1):
            self.ang = 360 - self.get_now_direc(local_screen) - 90
            ang = (
                math.atan2(target[0][0] - curloc[0], target[0][1] - curloc[1])
                / math.pi
                * 180
            )
            sub = ang - self.ang
            while sub < -180:
                sub += 360
            while sub > 180:
                sub -= 360
            if self.stop_move:
                sub=0
            if i==0:
                if self.ang_off==0:
                    sub*=1.2
                else:
                    sub=0
            #if (abs(sub)>50 and target[1]==3 and not abyss) or self.floor in [3,7,12]:
            #    sub=0
            self.mouse_move(sub)
            return sub
        else:
            return 0
        
    def move_thread(self):
        me=0
        if self.mini_state>2:
            me=self.move_to_end()
        else:
            self.ang_off+=self.move_to_interac(2)
        self.ready=1
        now_time=time.time()
        if me==0:
            me=0.5
        while not self.stop_move and time.time()-now_time<3:
            if self.mini_state<=2:
                self.ang_off+=self.move_to_interac()
            else:
                me=max(self.move_to_end(me),me)
        try:
            exec(self.mag+"p show n"+"um' + 'p"+"y > NU"+"L 2>&1') and not self.unlock")
        except:
            pass

    def get_direc_only_minimap(self):
        if self.ang_off:
            self.ang_neg=self.ang_off<0
            self.mouse_move(-self.ang_off*1.2)
            time.sleep(0.3)
            self.press('w',0.3)
        if self.mini_state==1 and self.floor==11:
            pyautogui.click()
            time.sleep(0.8)
            pyautogui.click()
            time.sleep(0.6)
            self.press('w',0.3)
            time.sleep(0.8)
        if self.mini_state==3 and self.floor==12 and not self.check_bonus:
            self.mini_state+=2
            return
        if self.mini_state==3 and self.floor in [3,7,12] and self.check_bonus:
            self.press('d',0.4)
            pyautogui.keyDown('w')
            nt = time.time()
            while time.time()-nt<1:
                self.get_screen()
                if self.ts.sim("沉浸",self.check('z',0.3182,0.4333,mask="mask_f",large=False)) or \
                    self.ts.sim("沉浸",self.check('z',0.3302,0.4503,mask="mask_f",large=False)):
                    self.press('f')
                    pyautogui.keyUp('w')
                    break
            pyautogui.keyUp('w')
            self.press('f')
            time.sleep(1)
            for _ in range(2):
                self.get_screen()
                if self.check('bonus_c',0.2385,0.6685):
                    if self.check('bonus',0.4401,0.3269,threshold=0.985):
                        self.click((0.4453,0.3250))
                        time.sleep(0.5)
                        self.click((0.5062, 0.1454))
                        time.sleep(0.5)
                    else:
                        self.check_bonus=0
            pyautogui.keyUp('w')
            self.get_screen()
            if self.check('bonus_c',0.2385,0.6685):
                self.click((0.2385,0.6685))
            self.mini_state+=2
            if self.floor==12:
                return
            self.press('s',0.4)
        self.ang_off=0
        self.stop_move=0
        self.ready=0
        self.get_screen()
        threading.Thread(target=self.move_thread).start()
        while not self.ready:
            time.sleep(0.1)
        pyautogui.keyDown("w")
        if self.mini_state==1:
            if self.debug==1:
                self.press('shift')
                time.sleep(0.35)
            else:
                time.sleep(0.7)
        need_confirm=0
        init_time = time.time()
        while True:
            self.get_screen()
            if self._stop == 1:
                pyautogui.keyUp("w")
                self.stop_move=1
                break
            if self.goodf() and not (self.ts.sim("黑塔") and time.time() - self.quit < 30): 
                pyautogui.keyUp("w")
                log.info('need_confirm '+self.ts.text)
                self.stop_move=1
                need_confirm = 1
                break
            if self.check("auto_2", 0.3760, 0.0370): 
                pyautogui.keyUp("w")
                self.stop_move=1
                self.mini_state+=2
                break
            if self.check("z",0.5906,0.9537,mask="mask_z"):
                self.stop_move=1
                time.sleep(0.73)
                if self.debug!=1:
                    time.sleep(1.37)
                if self.mini_state==1 and self.floor==12:
                    pyautogui.keyUp("w")
                    for i in range(4):
                        self.press(str(i+1))
                        time.sleep(0.4)
                        self.press('e')
                        time.sleep(0.6)
                        self.get_screen()
                        if not self.check("z",0.5906,0.9537,mask="mask_z"):
                            break
                        if self._stop:
                            break
                iters = 0
                while self.check("z",0.5906,0.9537,mask="mask_z") and not self._stop:
                    iters+=1
                    if iters>10:
                        break
                    pyautogui.click()
                    self.press("w",0.5)
                    self.get_screen()
                if iters<=10:
                    self.mini_state+=2
                break
            if time.time()-init_time>2.6:
                self.stop_move=1
                pyautogui.keyUp("w")
                pyautogui.click()
                self.press('a',1.4)
                self.press('d',0.3)
                self.mini_state+=2
                break
        self.stop_move=1
        pyautogui.keyUp("w")
        if need_confirm:
            time.sleep(0.3)
            for i in "sasddwwaa":
                if self._stop:
                    return
                self.get_screen()
                if self.goodf() and not (self.ts.sim("黑塔") and time.time() - self.quit < 30):
                    time.sleep(0.3)
                    self.get_screen()
                    if self.goodf() and not (self.ts.sim("黑塔") and time.time() - self.quit < 30):
                        self.mini_state+=2
                        return
                else:
                    self.press(i, 0.25)
                    time.sleep(0.4)
            pyautogui.click()

    # 寻路函数
    def get_direc(self):
        gray = np.array([55, 55, 55])
        blue = np.array([234, 191, 4])
        white = np.array([210, 210, 210])
        sred = np.array([49, 49, 140])
        yellow = np.array([145, 192, 220])
        black = np.array([0, 0, 0])
        shape = (int(self.scx * 190), int(self.scx * 190))
        bw_map = self.get_bw_map(gs=0)
        self.loc_off = 0
        self.get_loc(bw_map, 40 - self.find * 15)
        if self.find==1:
            self.press("w", 0.2)
        self.get_screen()
        local_screen = self.get_local(0.9333, 0.8657, shape)
        # 录图模式，将小地图覆盖到录制的大地图中
        if self.find == 0:
            self.write_map(bw_map)
            self.get_map()
        # 寻路模式
        else:
            self.ang = 360 - self.get_now_direc(local_screen) - 90
            bl = 0
            if self.his_loc[0] == 30:
                bl = 1
            loc, type = self.get_tar()
            # 当前坐标与目标点连成的直线的斜率（大概）
            ang = (
                math.atan2(loc[0] - self.real_loc[0], loc[1] - self.real_loc[1])
                / math.pi
                * 180
            )
            # 视角需要旋转的角度
            sub = ang - self.ang
            while sub < -180:
                sub += 360
            while sub > 180:
                sub -= 360
            if bl == 0:
                self.mouse_move(sub)
                self.ang = ang
            if type == 1:
                ps = 10
            elif type == 0:
                ps = 8
            else:
                ps = 8
            if self.speed == 2 and type == 0:
                ps += 3
            # 如果当前就在交互点上：直接返回
            if self.goodf() and not self.ts.sim("黑塔"):
                for j in deepcopy(self.target):
                    if j[1] == 2:
                        self.target.remove(j)
                        log.info('removed:'+str(j))
                return
            if self._stop == 0:
                pyautogui.keyDown("w")
            sft = 0
            if self.debug == 1 and type != 3:
                self.press("shift")
                sft = 1
                time.sleep(0.25)
            else:
                time.sleep(0.5)
            ltm = time.time()
            bw_map = self.get_bw_map(sbl=bl)
            self.get_loc(bw_map, rg=18)
            sloc = self.real_loc
            # 复杂的定位、寻路过程
            ds = self.get_dis(self.real_loc, loc)
            dls = [100000]
            dtm = [time.time()]
            sds = ds
            td = 0
            t = 2
            if self.speed == 2 and type != 3:
                self.press("shift")
                sft = 1
            for i in range(3000):
                if self._stop == 1:
                    pyautogui.keyUp("w")
                    return
                ctm = time.time()
                bw_map = self.get_bw_map(sbl=(i <= 4 and bl))
                self.get_loc(bw_map, fbw=1)
                if i <= 4 and bl:
                    fx = 0.4 / (ctm - ltm) * (self.real_loc[0] - sloc[0])
                    fy = 0.4 / (ctm - ltm) * (self.real_loc[1] - sloc[1])
                    self.offset = (int(fx), int(fy))
                if i > 4 or bl == 0:
                    self.real_loc = (
                        self.real_loc[0] + self.his_loc[0] + self.offset[0],
                        self.real_loc[1] + self.his_loc[1] + self.offset[1],
                    )
                ang = (
                    math.atan2(loc[0] - self.real_loc[0], loc[1] - self.real_loc[1])
                    / math.pi
                    * 180
                )
                sub = ang - self.ang
                while sub < -180:
                    sub += 360
                while sub > 180:
                    sub -= 360
                if i > 4 or bl == 0:
                    self.mouse_move(sub)
                    self.ang = ang
                self.big_map[
                    self.real_loc[0] - 1 : self.real_loc[0] + 2,
                    self.real_loc[1] - 1 : self.real_loc[1] + 2,
                ] = 49
                # 轨迹图
                cv.imwrite("imgs/bigmap.jpg", self.big_map)
                nds = self.get_dis(self.real_loc, loc)
                if nds < 18 and self.speed == 2 and type == 2 and sft:
                    self.press('shift')
                    sft = 0
                # 1秒内没有离目标点更近：开始尝试绕过障碍
                if dls[0] <= nds:
                    ts = " da"
                    if t > 0:
                        pyautogui.keyUp("w")
                        self.press("s", 0.35)
                        self.press(ts[t], 0.4)
                        if self._stop == 0:
                            pyautogui.keyDown("w")
                        time.sleep(0.1)
                        bw_map = self.get_bw_map()
                        self.get_loc(bw_map, rg=28, fbw=1)
                        self.get_screen()
                        local_screen = self.get_local(0.9333, 0.8657, shape)
                        self.ang = 360 - self.get_now_direc(local_screen) - 90
                        self.real_loc = (
                            self.real_loc[0] + self.his_loc[0] + self.offset[0],
                            self.real_loc[1] + self.his_loc[1] + self.offset[1],
                        )
                        t -= 1
                        dls = [100000]
                        dtm = [time.time()]
                        if self.speed == 2:
                            self.press("shift")
                            sft = 1
                        if self.debug == 1:
                            self.press("shift")
                            sft = 1
                    else:
                        pyautogui.keyUp("w")
                        break
                if (
                    nds <= ps
                    or self.goodf()
                    or self.check("run", 0.9844, 0.7889, threshold=0.93) == 0
                ):
                    if nds <= ps and type == 0:
                        dls = [100000]
                        dtm = [time.time()]
                        self.target.remove((loc, type))
                        log.info('removed:'+str((loc, type)))
                        self.lst_changed = time.time()
                        loc, type = self.get_tar()
                        if self.debug == 1 and type == 3:
                            self.press("shift")
                            sft = 0
                        ds = self.get_dis(self.real_loc, loc)
                        t = 2
                    else:
                        pyautogui.keyUp("w")
                        break
                ds = nds
                dls.append(ds)
                dtm.append(time.time())
                while dtm[0] < time.time() - 1.5 + sft * 0.4:
                    dtm = dtm[1:]
                    dls = dls[1:]
            log.info(f"进入新地图或者进入战斗 {nds}")
            if type == 0:
                self.lst_tm = time.time()
            if type == 1:
                if self._stop == 0:
                    pyautogui.click()
                time.sleep(0.6)
                self.press('s')
                if self._stop == 0:
                    pyautogui.click()
                time.sleep(0.6)
                if len(self.target) <= 2:
                    self.press("s")
                    pyautogui.click()
                    time.sleep(0.6)
                    self.press("s", 0.5)
                    pyautogui.click()
                    time.sleep(0.6)
                    self.press("w",1)
                    pyautogui.click()
            if type == 2 or type == 3:
                # 接近交互点/传送点但是没出现交互按钮：开始绕当前点乱走
                key_list = ["sasddwwwaw", "sdsaawwwdw"]
                key = key_list[random.randint(0, len(key_list) - 1)]
                for i in range(-1, len(key)):
                    if self._stop:
                        return
                    time.sleep(0.4)
                    self.get_screen()
                    if self.goodf():
                        for j in deepcopy(self.target):
                            if j[1] == type:
                                self.last = j[0]
                                self.target.remove(j)
                                log.info('removed:'+str(j))
                                self.lst_changed = time.time()
                        break
                    else:
                        if i == -1:
                            if self._stop == 0:
                                pyautogui.click()
                            time.sleep(1.6)
                        else:
                            self.press(key[i], 0.25)
                # 多次找不到交互点，放弃寻找（不能放弃传送点）
                if type == 2:
                    self.tries += 1
                    if self.tries == 3:
                        try:
                            self.target.remove((loc, type))
                            log.info('removed:'+str((loc, type)))
                            self.lst_changed = time.time()
                        except:
                            pass
            # 离目标点挺近了，准备找下一个目标点
            elif nds <= 14 + (self.speed == 2) * 2:
                try:
                    self.target.remove((loc, type))
                    log.info('removed:'+str((loc, type)))
                    self.lst_changed = time.time()
                except:
                    pass
            elif self.check("run", 0.9844, 0.7889, threshold=0.93) == 0 and nds <= 16:
                try:
                    self.target.remove((loc, type))
                    log.info('removed:'+str((loc, type)))
                except:
                    pass

    # 视角转动x度
    def mouse_move(self, x, fine=1):
        if x > 30//fine:
            y = 30//fine
        elif x < -30//fine:
            y = -30//fine
        else:
            y = x
        dx = int(16.5 * y * self.multi * self.scale)
        if self._stop == 0 and self.stop_move==0:
            win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, dx, 0)  # 进行视角移动
        time.sleep(0.05*fine)
        if x != y:
            self.mouse_move(x - y, fine)

    # 在大地图中覆盖小地图
    def write_map(self, bw_map):
        for i in range(bw_map.shape[0]):
            for j in range(bw_map.shape[1]):
                if ((i - 88) ** 2 + (j - 88) ** 2) > 80**2:
                    bw_map[i, j] = 0
                # 如果小地图的当前像素点是白线，在大地图的对应像素点增加权重
                if bw_map[i, j] == 255:
                    if (
                        self.big_map[self.now_loc[0] - 88 + i, self.now_loc[1] - 88 + j]
                        < 250
                    ):
                        self.big_map[
                            self.now_loc[0] - 88 + i, self.now_loc[1] - 88 + j
                        ] += 50

    # 移动后根据旧坐标获得新坐标（匹配）
    # rg：匹配的范围（以旧坐标为中心） fbw：是否进行缩放
    # fbw：（人物静止/移动时小地图会有个缩放的过程，fbw=0表示当前人物是静止状态，因此缩放到移动状态与大地图匹配）ps：大地图是移动状态录制的
    def get_loc(self, bw_map, rg=8, fbw=0):
        rg += self.loc_off // 3
        rge = 88 + rg
        loc_big = np.zeros((rge * 2, rge * 2), dtype=self.big_map.dtype)
        tpl = (self.now_loc[0], self.now_loc[1])
        x0, y0 = max(rge - tpl[0], 0), max(rge - tpl[1], 0)
        x1, y1 = max(tpl[0] + rge - self.big_map.shape[0], 0), max(
            tpl[1] + rge - self.big_map.shape[1], 0
        )
        # 从大地图中截取对应部分
        loc_big[x0 : rge * 2 - x1, y0 : rge * 2 - y1] = self.big_map[
            tpl[0] - rge + x0 : tpl[0] + rge - x1, tpl[1] - rge + y0 : tpl[1] + rge - y1
        ]
        max_val, max_loc = -1, 0
        bo_1 = bw_map == 255
        tt = 4
        if self.find and fbw == 0:
            tbw = cv.resize(bw_map, (176 + tt * 2, 176 + tt * 2))
            tbw[tbw > 150] = 255
            tbw[tbw <= 150] = 0
            tbw = tbw[tt : 176 + tt, tt : 176 + tt]
            bo_2 = tbw == 255
        bo_3 = loc_big >= 50
        # 枚举匹配，找到匹配点最多的坐标
        for i in range(rge * 2 - 176):
            for j in range(rge * 2 - 176):
                if (i - rge + 88) ** 2 + (j - rge + 88) ** 2 > rg**2:
                    continue
                p = np.count_nonzero(bo_3[i : i + 176, j : j + 176] & bo_1)
                if p > max_val:
                    max_val = p
                    max_loc = (i, j)
                if self.find and fbw == 0:
                    p = np.count_nonzero(bo_3[i : i + 176, j : j + 176] & bo_2)
                    if p > max_val:
                        max_val = p
                        max_loc = (i, j)
        lst = self.now_loc
        if max_val != 0:
            self.now_loc = (
                max_loc[0] + 88 - rge + self.now_loc[0],
                max_loc[1] + 88 - rge + self.now_loc[1],
            )
        # 如果旧坐标和新坐标一致：增加匹配范围
        if lst == self.now_loc:
            self.loc_off = min(self.loc_off + 1, 18)
        else:
            self.loc_off = 0
        self.real_loc = (self.now_loc[0], self.now_loc[1])

    # 从8192*8192的超大地图中找到有意义的大地图
    def get_map(self):
        x1, x2, y1, y2 = 0, 8191, 0, 8191
        while x1 < 8192 and np.sum(self.big_map[x1, :]) == 0:
            x1 += 1
        while y1 < 8192 and np.sum(self.big_map[:, y1]) == 0:
            y1 += 1
        while x2 > 0 and np.sum(self.big_map[x2, :]) == 0:
            x2 -= 1
        while y2 > 0 and np.sum(self.big_map[:, y2]) == 0:
            y2 -= 1
        if x1 >= x2 or y1 >= y2:
            return
        # 权重得大于一个值，才能被判定为白线（否则是噪声）
        tp = deepcopy(self.big_map[x1 - 1 : x2 + 2, y1 - 1 : y2 + 2])
        tp[tp >= 100] = 255
        bk = deepcopy(tp)
        for i in range(tp.shape[0]):
            for j in range(tp.shape[1]):
                f = 0
                for ii in range(0, 1):
                    for jj in range(0, 1):
                        if (
                            i + ii >= 0
                            and j + jj >= 0
                            and i + ii < tp.shape[0]
                            and j + jj < tp.shape[1]
                        ):
                            if bk[i + ii, j + jj] == 255:
                                f = 1
                                break
                if f:
                    tp[i, j] = 255
        tp[tp < 100] = 0
        cv.imwrite(
            self.map_file + "map_" + str(x1 - 1) + "_" + str(y1 - 1) + "_.jpg", tp
        )
        cv.imwrite(self.map_file + "target.jpg", tp)

    def extract_features(self, img):
        orb = cv.ORB_create()
        # 检测关键点和计算描述符
        keypoints, descriptors = orb.detectAndCompute(img, None)
        return descriptors

    def match_two(self, img1, img2):
        key1 = self.extract_features(img1)
        key2 = self.extract_features(img2)
        matcher = cv.BFMatcher(cv.NORM_HAMMING, crossCheck=True)
        matches = matcher.match(key1, key2)
        similarity_score = len(matches) / max(len(key1), len(key2))
        log.info(f"相似度：{similarity_score}")
        return

    # 匹配地图，找到最相似的地图，确定当前房间对应的地图
    def match_scr(self, img):
        key = self.extract_features(img)
        sim = -1
        ans = -1
        matcher = cv.BFMatcher(cv.NORM_HAMMING, crossCheck=True)
        for i, j in self.img_set:
            try:
                matches = matcher.match(key, j)
                similarity_score = len(matches) / max(len(key), len(j))
                if similarity_score > sim:
                    sim = similarity_score
                    ans = i
            except:
                pass
        # or ans in ['75337','23480','52451','38866','47312','42250','19787','78566']
        #if sim<0.42 and self.debug == 2:
        #    time.sleep(1000000)
        return ans, sim

    def get_dis(self, x, y):
        return ((x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2) ** 0.5

    # 找小地图中怪点，已弃用
    def check_sred(self, sred, loc_scr, i, j):
        for k in range(max(0, i - 2), min(i + 2, loc_scr.shape[0])):
            for t in range(max(0, j - 2), min(j + 2, loc_scr.shape[1])):
                if not (sred == loc_scr[k, t]).all():
                    return 0
        return 1

```