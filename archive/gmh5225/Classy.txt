Project Path: arc_gmh5225_Classy_6spmrmwf

Source Tree:

```txt
arc_gmh5225_Classy_6spmrmwf
├── README.md
├── classy
│   ├── __init__.py
│   ├── aboutwindow.py
│   ├── choose_struct_dialog.py
│   ├── database.py
│   ├── database_entries.py
│   ├── gui.py
│   ├── itanium_mangler.py
│   ├── menumgr.py
│   ├── plugin.py
│   ├── signature_dialog.py
│   ├── typedef_dialog.py
│   ├── uiaction.py
│   └── util.py
└── classy_plugin.py

```

`README.md`:

```md
#### Classy

This repo actually wasn't meant to be public but oh well.
If you use this plugin at this point I cannot guarantee for anything. Bugs might and probably are everywhere. Also the database layout itself is subject to change and no way of automatically upgrading it to newer versions might be provided.

Classy allows easily managing classes in IDA Pro. Vtables can be generated by selecting a range, functions can be assigned to classes, their signatures can be easily editing and mangled, IDA structs can be assigned, C headers can be generated, probably more :)

Credits to Ninji aka Treeki for the core idea and many code snippets from the plugin he created.

![](https://i.imgur.com/OsRuyn3.png)

Video:

[![In action demonstration](https://img.youtube.com/vi/-gUfn6eQRAM/0.jpg)](https://www.youtube.com/watch?v=-gUfn6eQRAM)
```

`classy/__init__.py`:

```py
#from __future__ import absolute_import

```

`classy/aboutwindow.py`:

```py
from PyQt5 import QtWidgets, QtCore


class AboutWindow(QtWidgets.QDialog):
   def __init__(self):
      super(AboutWindow, self).__init__()

      self.setFixedSize(260, 120)
      self.setWindowTitle('About Classy')

      layout = QtWidgets.QVBoxLayout(self)
      aboutLabel = QtWidgets.QLabel('Classy\n\nRicBent, Treeki', self)
      aboutLabel.setAlignment(QtCore.Qt.AlignCenter)
      layout.addWidget(aboutLabel)

      self.show()

```

`classy/choose_struct_dialog.py`:

```py
import idaapi
import ida_kernwin
import idc
from PyQt5 import QtWidgets, QtCore

import classy.util as util
import classy.itanium_mangler as itanium_mangler


class ChooseStructDialog(QtWidgets.QDialog):
    def __init__(self, inital_new_name='', title='Select a struct', has_none_btn=False):
        super(ChooseStructDialog, self).__init__()

        self.struct_id = idc.BADADDR

        self.setWindowTitle(title)

        layout = QtWidgets.QHBoxLayout(self)

        self.new_name_w = QtWidgets.QLineEdit()
        self.new_name_w.setText(inital_new_name)
        self.new_name_w.setMinimumWidth(200)
        layout.addWidget(self.new_name_w)

        new_btn = QtWidgets.QPushButton('New')
        new_btn.clicked.connect(self.handle_new)
        layout.addWidget(new_btn)

        existing_btn = QtWidgets.QPushButton('Existing')
        existing_btn.clicked.connect(self.handle_existing)
        layout.addWidget(existing_btn)

        if has_none_btn:
            none_btn = QtWidgets.QPushButton('None')
            none_btn.clicked.connect(self.handle_none)
            layout.addWidget(none_btn)

        cancel_btn = QtWidgets.QPushButton('Cancel')
        cancel_btn.clicked.connect(self.reject)
        layout.addWidget(cancel_btn)


    def handle_new(self):
        new_name = self.new_name_w.text().encode('ascii', 'replace').strip().decode()

        if not itanium_mangler.check_identifier(new_name):
            ida_kernwin.warning('The name "%s" is invalid' % new_name)
            return

        struct_id = idc.get_struc_id(new_name)
        if struct_id != idc.BADADDR:
            if util.ask_yes_no('The struct "%s" already exists. Do you want to select it anyways?' % new_name):
                self.struct_id = struct_id
                self.accept()
                return
            return

        self.struct_id = idaapi.add_struc(idc.BADADDR, new_name, False)
        if self. struct_id == idc.BADADDR:
            ida_kernwin.warning('Creating struct with the name "%s" failed' % new_name)
            return

        self.accept()


    def handle_existing(self):
        struct = idaapi.choose_struc('Select an existing struct')
        if struct is None:
            return
        self.struct_id = struct.id
        self.accept()


    def handle_none(self):
        self.struct_id = idc.BADADDR
        self.accept()

```

`classy/database.py`:

```py
import _pickle as cPickle
import idaapi
import os
from datetime import datetime

from classy.util import log
from PyQt5 import QtCore


class ClassyDatabase(object):

    CURRENT_VERSION = 1

    NON_DICT_ATTRIBUTES = ['data', 'path', 'autosave_path', 'is_open', 'autosave_timer']

    NONE_DEFAULTS = []
    HASH_DEFAULTS = ['classes_by_name', 'classes_by_struct_id', 'known_methods', 'typedefs']
    LIST_DEFAULTS = ['root_classes', 'pure_virtual_vals', 'deleted_virtual_vals']
    DEFAULTS = {'autosave_interval': 60}


    def __init__(self):
        self.data = {}
        self.is_open = False

        idb_path = idaapi.get_path(idaapi.PATH_TYPE_IDB)
        self.path = os.path.splitext(idb_path)[0] + '.cdb'
        self.autosave_path = os.path.splitext(idb_path)[0] + '.autosave.cdb'

        self.autosave_timer = QtCore.QTimer()
        self.autosave_timer.timeout.connect(self.autosave)


    def is_created(self):
        if self.is_open:
            return True
        return os.path.isfile(self.path)


    def delete(self):
        if self.is_open:
            return

        try:
            os.remove(self.path)
        except:
            pass


    def open(self):
        try:
            dbfile = open(self.path, 'rb')
            self.data = cPickle.load(dbfile)

            if not hasattr(self, 'version'):
                raise Exception('Database is corrupt!')

            if self.version != self.CURRENT_VERSION:
                raise Exception('Version Mismatch! File: %s, Plugin: %s' % (self.version, self.CURRENT_VERSION))

        except IOError:
            pass

        if not hasattr(self, 'version'):
            self.initialize()

        self.is_open = True
        self.autosave_timer.start(self.autosave_interval * 1000)



    def close(self):
        self.autosave_timer.stop()
        self.data = {}
        self.is_open = False


    def __getattr__(self, key):
        try:
            return self.data[key]
        except KeyError:
            try:
                default = self.default_for(key)
                setattr(self, key, default)
                return getattr(self, key)
            except KeyError:
                raise AttributeError('Classy database has no attribute %s' % key)


    def __setattr__(self, key, value):
        if key in self.NON_DICT_ATTRIBUTES:
            object.__setattr__(self, key, value)
        else:
            self.data[key] = value


    def save(self):
        self.save_as(self.path)
        try:
            os.remove(self.autosave_path)
        except FileNotFoundError:
            pass


    def save_as(self, path):
        if not self.is_open:
            return
        cPickle.dump(self.data, open(path, 'wb'))


    def autosave(self):
        self.save_as(self.autosave_path)
        log('Classy database autosaved')


    def initialize(self):
        self.version = self.CURRENT_VERSION


    def clear(self):
        self.data = {}
        self.initialize()


    def set_autosave_interval(self, interval):
        self.autosave_interval = interval
        self.autosave_timer.stop()
        if self.is_open:
            self.autosave_timer.start(self.autosave_interval * 1000)


    def generate_symbols(self):
        contents = []
        contents.append('/*\n * Classy exported symbols')
        contents.append(datetime.now().strftime(' * %x %X'))
        contents.append(' */\n\n')

        if len(self.classes_by_name) > 0:
            contents.append('/*\n * Classes\n */\n\n')
            for c_name in self.classes_by_name:
                contents.append(self.classes_by_name[c_name].generate_symbols())
                contents.append('')

        return '\n'.join(contents)


    @staticmethod
    def default_for(key):
        if key in ClassyDatabase.NONE_DEFAULTS:
            return None
        if key in ClassyDatabase.HASH_DEFAULTS:
            return {}
        if key in ClassyDatabase.LIST_DEFAULTS:
            return []
        return ClassyDatabase.DEFAULTS[key]



db = None


def create_instance():
    global db

    if db is not None:
        raise ValueError('Classy database instance is already created!')

    db = ClassyDatabase()
    return db


def destroy_instance():
    global db

    if db is None:
        raise ValueError('Classy database instance is not created!')

    db = None


def get():
    global db

    if db is None:
        raise ValueError('Classy database instance is not created!')

    return db

```

`classy/database_entries.py`:

```py
import idaapi
import idc
import ida_bytes

import classy.database as database
import classy.itanium_mangler as itanium_mangler


class Class(object):
    def __init__(self, name, base):

        self.name = name

        self.base = base
        self.derived = []

        self.struct_id = idc.BADADDR

        if self.base is not None:
            self.base.derived.append(self)

        self.methods = []

        self.vtable_start = None
        self.vtable_end = None
        self.vmethods = []
        self.reset_vtable()

        db = database.get()
        db.classes_by_name[name] = self
        if self.base is None:
            db.root_classes.append(self)


    def unlink(self, delete_orphaned_struct=False):
        if len(self.derived) > 0:
            raise ValueError('Cannot unlink classes with derived classes')

        for m in self.methods:
            m.unlink()

        for vm in self.vmethods:
            if vm.owner == self:
                vm.unlink()

        self.unlink_struct(delete_orphaned_struct)

        if self.base is not None:
            self.base.derived.remove(self)

        db = database.get()
        del db.classes_by_name[self.name]
        if self.base is None:
            db.root_classes.remove(self)


    def safe_name(self):
        return Class.s_safe_name(self.name)


    @staticmethod
    def s_safe_name(name):
        return name.replace('::', '_')


    def rename(self, new_name):
        old_name = self.name

        db = database.get()
        del db.classes_by_name[old_name]
        db.classes_by_name[new_name] = self

        self.name = new_name

        # Try to rename the struct
        if self.struct_id != idc.BADADDR:
            struct_name = idc.get_struc_name(self.struct_id)
            if struct_name == Class.s_safe_name(old_name):
                idc.set_struc_name(self.struct_id, self.safe_name())

        # Rename ctors and dtors
        for vm in self.vmethods:
            if vm.name == old_name:
                vm.name = new_name
            if vm.name == '~' + old_name:
                vm.name = '~' + new_name
        for m in self.methods:
            if m.name == old_name:
                m.name = new_name
            if m.name == '~' + old_name:
                m.name = '~' + new_name

        self.refresh()


    def refresh(self):
        for m in self.methods:
            m.refresh()
        for m in self.vmethods:
            m.refresh()
        self.refresh_struct_comment()


    def set_vtable_range(self, start, end):
        if self.is_vtable_locked():
            raise ValueError('VTable cannot be modified because the class has derived classes')
        if start % 4 or end % 4:
            raise ValueError('VTable start and end must be 4 byte aligned')
        if start >= end:
            raise ValueError('Vtable end must be after the start')
        if self.base:
            new_len = (end - start) // 4
            if new_len < len(self.base.vmethods):
                raise ValueError('VTable is smaller than base VTable')
        # Todo: More sanity checks: Don't overwrite any other vtable

        self.reset_vtable()
        self.vtable_start = start
        self.vtable_end = end
        self.init_vtable()


    def is_vtable_locked(self):
        return len(self.derived) > 0


    def can_be_derived(self):
        if self.base is None:
            return True
        return len(self.vmethods) >= len(self.base.vmethods)    # vtable inited?


    def vtable_start_idx(self):
        if self.base is None:
            return 0
        return len(self.base.vmethods)


    def reset_vtable(self):
        if self.is_vtable_locked():
            return
        self.vtable_start = None
        self.vtable_end = None
        idx = self.vtable_start_idx()
        for vm in self.vmethods[idx:]:
            vm.unlink()
        self.vmethods = []


    def init_vtable(self):
        my_start_idx = self.vtable_start_idx()

        # Fix: support 64bit work
        if idc.__EA64__:
            pointer_size = idaapi.DEF_ADDRSIZE
            pfn_make_ptr = lambda x: ida_bytes.create_data(x, idc.FF_QWORD, 8, idaapi.BADADDR) #MakeQword
            pfn_get_ptr_value = ida_bytes.get_qword
        else:
            pointer_size = idaapi.DEF_ADDRSIZE
            pfn_make_ptr =  lambda x: ida_bytes.create_data(x, idc.FF_DWORD, 4, idaapi.BADADDR) #ida_bytes.MakeDword
            pfn_get_ptr_value = ida_bytes.get_dword

        for idx, ea in enumerate(range(self.vtable_start, self.vtable_end, pointer_size)):
            pfn_make_ptr(ea)
            idc.op_plain_offset(ea, 0, 0)
            dst = pfn_get_ptr_value(ea)

            if idx < my_start_idx:
                base_method = self.base.vmethods[idx]
                if base_method.is_dst_equal(dst):                   # Method from base class
                    self.vmethods.append(self.base.vmethods[idx])
                elif Method.s_is_pure_virtual_dst(dst):             # New pure virtual override
                    opvm = PureVirtualOverrideMethod(self, base_method, idx)
                    opvm.refresh()
                    self.vmethods.append(opvm)
                elif Method.s_is_deleted_virtual_dst(dst):          # New deleted override
                    dom = DeletedOverrideMethod(self, base_method, idx)
                    dom.refresh()
                    self.vmethods.append(dom)
                else:                                               # New override
                    om = OverrideMethod(dst, self, base_method, idx)
                    om.refresh()
                    self.vmethods.append(om)
            elif Method.s_is_pure_virtual_dst(dst):                 # New pure virtual
                pvm = PureVirtualMethod(self, 'vf%X' % (idx*4), idx)
                pvm.refresh()
                self.vmethods.append(pvm)
            elif Method.s_is_deleted_virtual_dst(dst):              # New deleted virtual
                pvm = DeletedVirtualMethod(self, 'vf%X' % (idx*4), idx)
                pvm.refresh()
                self.vmethods.append(pvm)
            else:                                                   # New virtual
                vm = VirtualMethod(dst, self, 'vf%X' % (idx*4), idx)
                vm.refresh()
                self.vmethods.append(vm)


    def get_vtable_index_ea(self, idx):
        if idx > len(self.vmethods):
            raise ValueError('get_vtable_index_ea for out of range index')
        return self.vtable_start + (idx*4)


    def iter_vtable(self):
        ea = self.vtable_start
        end = self.vtable_end

        while ea <= end:
            yield (ea, idc.get_wide_dword(ea))
            ea += 4


    def set_struct_id(self, new_struct_id, delete_orphaned=False):
        db = database.get()

        if self.struct_id == new_struct_id:
            return

        if new_struct_id in db.classes_by_struct_id:
            raise ValueError('The struct is already assigned to the class %s' % db.classes_by_struct_id[new_struct_id]).name

        self.unlink_struct(delete_orphaned)

        self.struct_id = new_struct_id
        if self.struct_id != idc.BADADDR:
            db.classes_by_struct_id[self.struct_id] = self

        self.refresh()


    def unlink_struct(self, delete_orphaned=False):
        if self.struct_id == idc.BADADDR:
            return

        del database.get().classes_by_struct_id[self.struct_id]

        if delete_orphaned:
            idc.del_struc(self.struct_id)
        else:
            struct_name = idc.get_struc_name(self.struct_id)
            idc.set_struc_cmt(self.struct_id, 'Orphaned from %s' % self.name, False)
            idc.set_struc_name(self.struct_id, '%s_orphaned' % struct_name)

        self.struct_id = idc.BADADDR


    def refresh_struct_comment(self):
        if self.struct_id == idc.BADADDR:
            return

        idc.set_struc_cmt(self.struct_id, 'Linked to %s' % self.name, False)


    def generate_cpp_definition(self):
        contents = []
        contents.append('class %s%s\n{\npublic:' % (self.name, '' if self.base is None else (' : public %s' % self.base.name)))

        seen_dtor = False

        # Overrides
        for idx in range(self.vtable_start_idx()):
            vm = self.vmethods[idx]
            if vm.owner == self and type(vm) == OverrideMethod:
                if vm.name == '~' + self.name:
                    if seen_dtor:
                        continue
                    seen_dtor = True
                    contents.append('    virtual %s;' % vm.get_signature(include_owner=False))
                else:
                    contents.append('    %s override;' % vm.get_signature(include_owner=False))

        if self.vtable_start_idx() > 0:
            contents.append('')

        # New virtuals
        for idx in range(self.vtable_start_idx(), len(self.vmethods)):
            vm = self.vmethods[idx]
            if type(vm) == VirtualMethod:   # If this isn't the case something is very wrong
                if vm.name == '~' + self.name:
                    if seen_dtor:
                        continue
                    seen_dtor = True
                contents.append('    virtual %s;' % vm.get_signature(include_owner=False))

        if (len(self.vmethods) - self.vtable_start_idx()) > 0:
            contents.append('')

        # Methods
        for m in self.methods:
            if m.name == '~' + self.name:
                if seen_dtor:
                    continue
                seen_dtor = True
            contents.append('    %s;' % m.get_signature(include_owner=False))

        # Todo: Replace this ugly temp code
        if self.struct_id != idc.BADADDR:
            struct = idaapi.get_struc(self.struct_id)
            raw_txt = idc.GetLocalType(struct.ordinal, idc.PRTYPE_1LINE)
            l_idx = raw_txt.find('{')
            r_idx = raw_txt.find('}')
            segs = raw_txt[l_idx+1:r_idx].split(';')
            if len(segs):
                contents.append('')
            for s in segs:
                contents.append('    %s;' % s)

        contents.append('};\n')

        return '\n'.join(contents)


    def generate_symbols(self):
        contents = ['/* %s */\n' % self.name]

        if len(self.vmethods):
            contents.append('/* virtual functions */')
            for vm in self.vmethods:
                if vm.owner == self and not vm.is_pure_virtual():
                    contents.append('%s = 0x%X;' % (vm.get_mangled(), vm.ea))
            contents.append('')

        if len(self.methods):
            contents.append('/* functions */')
            for m in self.methods:
                contents.append('%s = 0x%X;' % (m.get_mangled(), m.ea))
            contents.append('')

        return '\n'.join(contents)


    @staticmethod
    def s_name_is_valid(name):

        segs = name.split('::')

        if len(segs) == 0:
            return False

        for seg in segs:
            if len(seg) < 1:
                return False

            if seg[0].isdigit():
                return False

            for c in seg:
                if not c.isalnum() and c != '_':
                    return False

        return True


    @staticmethod
    def s_create():
        db = database.get()

        name = idaapi.ask_str('', idaapi.HIST_IDENT,'Enter a class name')

        if name is None:
            return None

        if name in database.get().classes_by_name:
            idaapi.warning('That name is already used.')
            return None

        if not Class.s_name_is_valid(name):
            idaapi.warning('The class name "%s" is invalid.' % name)
            return None

        base_class = None
        base_name = idaapi.ask_str('', idaapi.HIST_IDENT,'Enter a base class name (leave empty for none)')
        if base_name is None:
            return None
        if base_name:
            if base_name not in db.classes_by_name:
                idaapi.warning('The class "%s" is not in the database.' % base_name)
                return None
            else:
                base_class = db.classes_by_name[base_name]
                if not base_class.can_be_derived():
                    idaapi.warning('The class %s cannot be derived because the VTable is not setup correctly' % base_class.name)
                    return None

        return Class(name, base_class)

        '''
        safe_name = name.replace('::', '_')
    
        struct = idaapi.get_struc_id(safe_name)
        if struct != idaapi.BADADDR:
            if struct in database.get().classes_by_struct.keys():
                idaapi.warning('The struct "%s" is already associated with a struct!' % safe_name)
                return
    
            if not util.ask_yes_no('The struct "%s" already exists. Continue?' % safe_name, True):
                return
    
        else:
            struct = idaapi.add_struc(idaapi.BADADDR, safe_name, 0)
            if struct == idaapi.BADADDR:
                idaapi.warning('Creating struct "%s" for class "%s" failed!' % (safe_name, name))
                return
        '''


class Method(object):
    def __init__(self, ea, owner, name):
        self.ea = ea
        self.owner = owner
        self.name = name
        self.args = ''
        self.return_type = 'void'
        self.is_const = False
        self.ctor_type = 1
        self.dtor_type = 1

        if ea != idc.BADADDR:
            database.get().known_methods[ea] = self


    def type_name(self):
        return 'regular'


    def refresh(self):
        if self.ea != idc.BADADDR:
            mangled = self.get_mangled()
            idc.set_name(self.ea, mangled, idc.SN_CHECK)
        self.refresh_comments()


    def unlink(self):
        if self.owner and self in self.owner.methods:
            self.owner.methods.remove(self)

        self.owner = None

        if self.ea != idc.BADADDR:
            del database.get().known_methods[self.ea]
            idc.set_name(self.ea, '', idc.SN_CHECK)
            idc.set_func_cmt(self.ea, '', False)


    def is_dst_equal(self, dst):
        return dst == self.ea


    def set_signature(self, name, args, return_type='void', is_const=False, ctor_type=1, dtor_type=1):
        signature = Method.s_make_signature(self.owner, name, args, is_const, return_type)
        itanium_mangler.mangle_function(signature, database.get().typedefs, ctor_type, dtor_type)    # throws excption when invalid
        self.name = name
        self.args = args
        self.return_type = return_type
        self.is_const = is_const
        self.ctor_type = ctor_type
        self.dtor_type = dtor_type
        self.refresh()


    @staticmethod
    def s_make_signature(owner, name, args='', is_const=False, return_type=''):
        signature = ('%s::' % owner.name) if owner is not None else ''
        signature += name
        signature += '('
        signature += args
        signature += ')'
        if is_const:
            signature += ' const'
        if return_type:
            signature = return_type + ' ' + signature
        return signature


    def get_signature(self, include_return_type=True, include_owner=True):
        return Method.s_make_signature(self.owner if include_owner else None, self.name, self.args, self.is_const, self.return_type if include_return_type else '')


    def get_mangled(self):
        return itanium_mangler.mangle_function(self.get_signature(), database.get().typedefs, self.ctor_type, self.dtor_type)  # throws excption when invalid


    def copy_signature(self, other):
        if (other.owner is not None) and (other.name == '~' + other.owner.name):
            if self.owner is None:
                raise ValueError('Cannot copy dtor to non-owned function')
            self.name = '~' + self.owner.name
        else:
            self.name = other.name
        self.args = other.args
        self.return_type = other.return_type
        self.is_const = other.is_const
        self.ctor_type = other.ctor_type
        self.dtor_type = other.dtor_type


    def get_mangled(self):
        demangled = self.get_signature(False)
        return itanium_mangler.mangle_function(demangled, database.get().typedefs, self.ctor_type, self.dtor_type)


    def get_comment(self):
        return ''


    def refresh_comments(self):
        if self.ea == idc.BADADDR:
            return

        comment = self.get_comment()
        if comment:
            idc.set_func_cmt(self.ea, comment, False)


    @staticmethod
    def s_is_pure_virtual_dst(dst):
        return dst in database.get().pure_virtual_vals


    @staticmethod
    def s_is_deleted_virtual_dst(dst):
        return dst in database.get().deleted_virtual_vals



class VirtualMethod(Method):
    def __init__(self, ea, owner, name, vtable_idx):
        super(VirtualMethod, self).__init__(ea, owner, name)
        self.vtable_idx = vtable_idx
        self.overrides = []


    def is_override(self):
        return False


    def is_pure_virtual(self):
        return False


    def type_name(self):
        return 'virtual'


    def refresh(self):
        Method.refresh(self)


    def refresh_comments(self):
        Method.refresh_comments(self)
        idc.set_cmt(self.owner.get_vtable_index_ea(self.vtable_idx), self.get_vtable_comment(), 0) 


    def unlink(self):
        if len(self.overrides) > 0:
            raise ValueError('Cannot unlink method with overrides')
        for i, vm in enumerate(self.owner.vmethods):
            if vm == self:
                self.owner.vmethods[i] = None
        Method.unlink(self)


    def set_signature(self, name, args, return_type='void', is_const=False, ctor_type=1, dtor_type=1):
        Method.set_signature(self, name, args, return_type, is_const, ctor_type, dtor_type)
        for o in self.overrides:
            o.propagate_signature()


    def get_comment(self):
        lines = []

        if len(self.overrides) > 0:
            lines.append('Overridden by:')
            for o in self.overrides:
                if not o.is_pure_virtual():
                    lines.append('  - 0x%X : %s' % (o.ea, o.owner.name))
                else:
                    lines.append('  - pure virtual : %s' % o.owner.name)
        else:
            lines.append('Overridden by: None')

        return "\n".join(lines)


    def get_vtable_comment(self):
        return ''


    def add_override(self, override):
        if override in self.overrides:
            return
        self.overrides.append(override)
        self.refresh_comments()


    def remove_override(self, override):
        if override not in self.overrides:
            return
        self.overrides.remove(override)
        self.refresh_comments()



class PureVirtualMethod(VirtualMethod):
    def __init__(self, owner, name, vtable_idx):
        super(PureVirtualMethod, self).__init__(idc.BADADDR, owner, name, vtable_idx)


    def is_pure_virtual(self):
        return True


    def type_name(self):
        return 'pure virtual'


    def is_dst_equal(self, dst):
        return Method.s_is_pure_virtual_dst(dst)


    def get_comment(self):
        return ''


    def get_vtable_comment(self):
        return self.get_signature()



class DeletedVirtualMethod(PureVirtualMethod):
    def __init__(self, owner, name, vtable_idx):
        super(DeletedVirtualMethod, self).__init__(owner, name, vtable_idx)


    def type_name(self):
        return 'deleted virtual'


    def is_dst_equal(self, dst):
        return Method.s_is_deleted_virtual_dst(dst)



class OverrideMethod(VirtualMethod):
    def __init__(self, ea, owner, base, vtable_idx):
        if not base.owner.can_be_derived():
            raise ValueError('Overriding function of class without inited VTable')
        super(OverrideMethod, self).__init__(ea, owner, base.name, vtable_idx)
        self.base = base
        self.base.add_override(self)
        self.copy_signature(base)


    def is_override(self):
        return True


    def type_name(self):
        return 'override'


    def unlink(self):
        self.base.remove_override(self)
        VirtualMethod.unlink(self)


    def set_signature(self, name, args, return_type='void', is_const=False, ctor_type=1, dtor_type=1):
        root_method = self.get_root_method()

        if name == '~' + self.owner.name:
            root_name = '~' + root_method.owner.name
        else:
            root_name = name

        root_method.set_signature(root_name, args, return_type, is_const, ctor_type, dtor_type)


    def propagate_signature(self):
        self.copy_signature(self.base)
        self.refresh()
        for o in self.overrides:
            o.propagate_signature()


    def get_root_method(self):
        method = self
        while method.is_override():
            method = method.base
        return method


    def get_comment(self):
        if self.base.is_pure_virtual():
            override_cmt = 'pure virtual'
        else:
            override_cmt = '0x%X' % self.base.ea
        return 'Overrides: %s : %s\n\n%s' % (self.base.owner.name, override_cmt, VirtualMethod.get_comment(self))



class PureVirtualOverrideMethod(OverrideMethod):
    def __init__(self, owner, base, vtable_idx):
        super(PureVirtualOverrideMethod, self).__init__(idc.BADADDR, owner, base, vtable_idx)


    def is_pure_virtual(self):
        return True


    def type_name(self):
        return 'pure virtual override'


    def is_dst_equal(self, dst):
        return Method.s_is_pure_virtual_dst(dst)


    def get_comment(self):
        return ''


    def get_vtable_comment(self):
        return self.get_signature()



class DeletedOverrideMethod(PureVirtualOverrideMethod):
    def __init__(self, owner, base, vtable_idx):
        super(DeletedOverrideMethod, self).__init__(owner, base, vtable_idx)


    def type_name(self):
        return 'deleted override'


    def is_dst_equal(self, dst):
        return Method.s_is_deleted_virtual_dst(dst)



class NullMethod(Method):
    def __init__(self, owner):
        super(NullMethod, self).__init__(idc.BADADDR, owner, 'NullMethod')


    def type_name(self):
        return 'null'


    def refresh(self):
        pass


    def unlink(self):
        pass



def refresh_all():
    db = database.get()

    for c in db.classes_by_name.values():
        c.refresh()

```

`classy/gui.py`:

```py
from PyQt5 import QtWidgets, QtCore
import sip
import idaapi
import idc

import classy.util as util
import classy.database as database
import classy.database_entries as database_entries
from classy.signature_dialog import SignatureDialog
from classy.choose_struct_dialog import ChooseStructDialog


class ClassyGui(idaapi.PluginForm):

    def __init__(self, plugin):
        idaapi.PluginForm.__init__(self)
        self.plugin = plugin
        self.parent = None
        self.items_by_class = {}


    def show(self):
        idaapi.PluginForm.Show(self, 'Classy')


    def OnCreate(self, form):
        self.parent = self.FormToPyQtWidget(form)

        layout = QtWidgets.QVBoxLayout()

        # Setup left side
        left_widget = QtWidgets.QWidget()
        left_layout = QtWidgets.QVBoxLayout(left_widget)

        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        layout.addWidget(splitter)

        self.class_tree = QtWidgets.QTreeWidget()
        self.class_tree.header().hide()
        self.class_tree.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.class_tree.customContextMenuRequested.connect(self.handle_class_tree_context_menu)
        self.class_tree.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.class_tree.itemSelectionChanged.connect(self.handle_class_tree_selection_change)
        left_layout.addWidget(self.class_tree)

        button_layout = QtWidgets.QHBoxLayout()

        add_button = QtWidgets.QPushButton('Add')
        add_button.clicked.connect(self.add_class)
        button_layout.addWidget(add_button)

        remove_button = QtWidgets.QPushButton('Remove')
        remove_button.clicked.connect(self.remove_class)
        button_layout.addWidget(remove_button)

        left_layout.addLayout(button_layout)

        splitter.addWidget(left_widget)

        # Setup right side
        self.class_edit = ClassWidget(self)
        splitter.addWidget(self.class_edit)

        splitter.setSizes([100, 100000])

        self.parent.setLayout(layout)

        self.update_fields()


    def update_fields(self):
        self.reload_tree()
        self.class_edit.update_fields()


    def reload_tree(self):
        db = database.get()

        self.items_by_class = {}
        self.class_tree.clear()
        for c in db.root_classes:
            self.add_child_class_item(self.class_tree, c)


    def add_child_class_item(self, parent, c):
        if parent is None:
            parent = self.class_tree

        item = QtWidgets.QTreeWidgetItem(parent, [c.name])
        item.setData(0, QtCore.Qt.UserRole, c)
        self.items_by_class[c] = item
        for d in c.derived:
            self.add_child_class_item(item, d)
        return item


    def add_class(self):
        c = database_entries.Class.s_create()
        if c is None:
            return

        if c.base is not None:
            parent_item = self.items_by_class[c.base]
        else:
            parent_item = None

        item = self.add_child_class_item(parent_item, c)

        self.class_tree.clearSelection()
        self.class_tree.scrollToItem(item)
        item.setSelected(True)


    def remove_class(self):
        item = self.class_tree.selectedItems()[0] if len(self.class_tree.selectedItems()) else None
        if item is None:
            return

        c = item.data(0, QtCore.Qt.UserRole)
        if type(c) != database_entries.Class:
            return

        if not util.ask_yes_no('Do you really want to remove the class "%s"? All methods and new virtual methods will be unlinked' % c.name, False):
            return

        try:
            c.unlink()
            del self.items_by_class[c]
            sip.delete(item)
            idaapi.refresh_idaview_anyway()
        except ValueError as e:
            idaapi.warning(str(e))


    def update_class(self, c):
        try:
            item = self.items_by_class[c]
        except KeyError:
            return

        item.setText(0, c.name)


    def generate_class_header_to_file(self):
        item = self.class_tree.selectedItems()[0] if len(self.class_tree.selectedItems()) else None
        if item is None:
            return

        c = item.data(0, QtCore.Qt.UserRole)
        if type(c) != database_entries.Class:
            return

        path = QtWidgets.QFileDialog.getSaveFileName(None,
                                                     'Export class definition', c.name + '.h',
                                                     'C++ Header file (*.h);;All Files (*)')
        if not path[0]:
            return

        f = open(path[0], 'w')
        f.write(c.generate_cpp_definition())
        f.close()

    def generate_class_header_to_clipboard(self):
        item = self.class_tree.selectedItems()[0] if len(self.class_tree.selectedItems()) else None
        if item is None:
            return

        c = item.data(0, QtCore.Qt.UserRole)
        if type(c) != database_entries.Class:
            return

        QtWidgets.QApplication.clipboard().setText(c.generate_cpp_definition())


    def handle_class_tree_selection_change(self):
        item = self.class_tree.selectedItems()[0] if len(self.class_tree.selectedItems()) else None
        if item is None:
            self.class_edit.set_edit_class(None)
        else:
            c = item.data(0, QtCore.Qt.UserRole)
            if type(c) == database_entries.Class:
                self.class_edit.set_edit_class(c)
            else:
                self.class_edit.set_edit_class(None)


    def handle_class_tree_context_menu(self, point):
        item = self.class_tree.itemAt(point)

        menu = QtWidgets.QMenu()
        menu.addAction('Add', self.add_class)

        if item is not None:
            menu.addAction('Remove', self.remove_class)
            menu.addAction('Generate C++ Header (File)', self.generate_class_header_to_file)
            menu.addAction('Generate C++ Header (Clipboard)', self.generate_class_header_to_clipboard)

        menu.exec_(self.class_tree.mapToGlobal(point))



class ClassWidget(QtWidgets.QWidget):
    def __init__(self, parent_gui):
        QtWidgets.QWidget.__init__(self)

        self.parent_gui = parent_gui

        self.edit_class = None

        layout = QtWidgets.QGridLayout(self)

        self.name = QtWidgets.QLabel()
        layout.addWidget(self.name, 0, 0)

        self.set_name = QtWidgets.QPushButton('Set')
        self.set_name.setMaximumWidth(50)
        self.set_name.clicked.connect(self.handle_set_name)
        layout.addWidget(self.set_name, 0, 1)

        self.base_class = QtWidgets.QLabel()
        layout.addWidget(self.base_class, 1, 0, 1, 2)

        self.derived_classes = QtWidgets.QLabel()
        self.derived_classes.setWordWrap(True)
        layout.addWidget(self.derived_classes, 2, 0, 1, 2)

        self.struct = util.ClickableQLabel()
        self.struct.doubleClicked.connect(self.handle_struct_double_clicked)
        layout.addWidget(self.struct, 3, 0)

        self.set_struct = QtWidgets.QPushButton('Set')
        self.set_struct.setMaximumWidth(50)
        self.set_struct.clicked.connect(self.handle_set_struct)
        layout.addWidget(self.set_struct, 3, 1)

        self.vtable_range = QtWidgets.QLabel()
        layout.addWidget(self.vtable_range, 4, 0)

        self.set_vtable_range = QtWidgets.QPushButton('Set')
        self.set_vtable_range.setMaximumWidth(50)
        self.set_vtable_range.clicked.connect(self.handle_set_vtable_range)
        layout.addWidget(self.set_vtable_range, 4, 1)

        self.vtable = util.EnterPressQTableWidget()
        self.vtable.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.vtable.setColumnCount(4)
        self.vtable.setHorizontalHeaderLabels(['ID', 'Address', 'Function', 'Type'])
        vtable_header = self.vtable.horizontalHeader()
        vtable_header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        self.vtable.verticalHeader().hide()
        self.vtable.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.vtable.cellDoubleClicked.connect(self.handle_vtable_interaction)
        self.vtable.cellEnterPressed.connect(self.handle_vtable_interaction)
        layout.addWidget(self.vtable, 5, 0, 1, 2)

        self.methods = util.EnterPressQTableWidget()
        self.methods.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.methods.setColumnCount(2)
        self.methods.setHorizontalHeaderLabels(['Address', 'Function'])
        methods_header = self.methods.horizontalHeader()
        methods_header.setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.methods.verticalHeader().hide()
        self.methods.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        # self.methods.setSortingEnabled(True) Todo
        self.methods.cellDoubleClicked.connect(self.handle_methods_interaction)
        self.methods.cellEnterPressed.connect(self.handle_methods_interaction)
        layout.addWidget(self.methods, 6, 0, 1, 2)

        method_btn_layout = QtWidgets.QHBoxLayout()

        self.add_method_btn = QtWidgets.QPushButton('Add')
        self.add_method_btn.setMaximumWidth(50)
        self.add_method_btn.clicked.connect(self.handle_add_method)
        method_btn_layout.addWidget(self.add_method_btn)

        self.remove_method_btn = QtWidgets.QPushButton('Remove')
        self.remove_method_btn.setMaximumWidth(50)
        self.remove_method_btn.clicked.connect(self.handle_remove_method)
        method_btn_layout.addWidget(self.remove_method_btn)

        method_btn_layout.addItem(QtWidgets.QSpacerItem(0, 0, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum))

        layout.addLayout(method_btn_layout, 7, 0, 1, 2)

        self.update_fields()


    def set_edit_class(self, edit_class):
        self.edit_class = edit_class
        self.update_fields()


    def update_fields(self):
        if self.edit_class is None:
            self.setDisabled(True)
            self.name.setText('Name: -')
            self.base_class.setText('Base class: -')
            self.derived_classes.setText('Derived classes: -')
            self.struct.setText('Struct: -')
            self.vtable_range.setText('VTable: -')
            self.vtable.setRowCount(0)
            self.methods.setRowCount(0)

        else:
            self.setEnabled(True)
            self.name.setText('Name: %s' % self.edit_class.name)
            self.base_class.setText('Base class: %s' % (self.edit_class.base.name if self.edit_class.base is not None else 'None'))

            derived_classes_txts = []
            for dc in self.edit_class.derived:
                derived_classes_txts.append(dc.name)
            derived_classes_txt = ', '.join(derived_classes_txts)
            if not derived_classes_txt:
                derived_classes_txt = 'None'
            self.derived_classes.setText('Derived classes: %s' % derived_classes_txt)

            if self.edit_class.struct_id == idc.BADADDR:
                struct_txt = 'Not set'
            else:
                struct_txt = '%s (%d)' % (idc.get_struc_name(self.edit_class.struct_id), idc.get_struc_idx(self.edit_class.struct_id))
            self.struct.setText('Struct: %s' % struct_txt)

            if self.edit_class.vtable_start is None or self.edit_class.vtable_end is None:
                vtable_range_txt = 'Not set'
            else:
                vtable_range_txt = '0x%X - 0x%X' % (self.edit_class.vtable_start, self.edit_class.vtable_end)
            self.vtable_range.setText('VTable: %s' % vtable_range_txt)

            self.vtable.setRowCount(len(self.edit_class.vmethods))
            for idx, vm in enumerate(self.edit_class.vmethods):
                self.vtable.setItem(idx, 0, QtWidgets.QTableWidgetItem(str(idx)))
                self.vtable.setItem(idx, 1, QtWidgets.QTableWidgetItem(("0x%X" % vm.ea) if vm.ea != idc.BADADDR else '-'))
                self.vtable.setItem(idx, 2, QtWidgets.QTableWidgetItem(vm.get_signature()))
                self.vtable.setItem(idx, 3, QtWidgets.QTableWidgetItem(vm.type_name()))

            # This way of doing won't work when allowing sorting
            self.methods.setRowCount(len(self.edit_class.methods))
            for idx, m in enumerate(self.edit_class.methods):
                address_item = QtWidgets.QTableWidgetItem(m.ea)
                address_item.setData(QtCore.Qt.DisplayRole, "0x%X" % m.ea)
                address_item.setData(QtCore.Qt.UserRole, m)
                self.methods.setItem(idx, 0, address_item)
                self.methods.setItem(idx, 1, QtWidgets.QTableWidgetItem(m.get_signature()))


    def handle_set_struct(self):
        if self.edit_class is None:
            return

        default_struct_name = idc.get_struc_name(self.edit_class.struct_id)    \
                              if self.edit_class.struct_id != idc.BADADDR else \
                              self.edit_class.name

        dlg = ChooseStructDialog(default_struct_name, has_none_btn=True)
        if dlg.exec_() != QtWidgets.QDialog.Accepted:
            return

        if dlg.struct_id == self.edit_class.struct_id:
            return

        db = database.get()
        if dlg.struct_id in db.classes_by_struct_id:
            idaapi.warning('The struct "%s" is already linked to the class "%s"' %
                           (idc.get_struc_name(dlg.struct_id), b.classes_by_struct_id[dlg.struct_id]))
            return

        delete_orphaned = False
        if self.edit_class.struct_id != idc.BADADDR:
            delete_orphaned = util.ask_yes_no('Do you want to delete the orphaned class', False)

        self.edit_class.set_struct_id(dlg.struct_id, delete_orphaned)
        self.update_fields()


    def handle_struct_double_clicked(self):
        if self.edit_class is None:
            return

        if self.edit_class.struct_id == idc.BADADDR:
            return

        idaapi.open_structs_window(self.edit_class.struct_id)


    def handle_set_name(self):
        if self.edit_class is None:
            return

        new_name = idaapi.ask_str(self.edit_class.name, idaapi.HIST_IDENT,'Enter a class name')
        if new_name is None or new_name == self.edit_class.name:
            return

        if new_name in database.get().classes_by_name:
            idaapi.warning('That name is already used.')
            return

        if not database_entries.Class.s_name_is_valid(new_name):
            idaapi.warning('The class name "%s" is invalid.' % new_name)
            return

        self.edit_class.rename(new_name)
        self.update_fields()
        self.parent_gui.update_class(self.edit_class)


    def handle_set_vtable_range(self):
        if self.edit_class is None:
            return

        p0 = idaapi.twinpos_t()
        p1 = idaapi.twinpos_t()
        view = idaapi.get_current_viewer()

        success = idaapi.read_selection(view, p0, p1)

        if not success:
            idaapi.warning('Please, select region in ida dissasembler')

        ea0 = p0.place(view).ea
        ea1 = p1.place(view).ea

        # Check selection
        if ea0 == idc.BADADDR or ea1 == idc.BADADDR:
            return

        if ea0 > ea1:
            return

        if ea0 != idc.get_screen_ea() and ea1 != idc.get_screen_ea():
            return

        # Warning for large ranges
        if (ea1 - ea0) > 0x1000:
            if not util.ask_yes_no('Warning: The VTable range is longer than 0x1000 bytes. Continue?', False):
                return

        try:
            self.edit_class.set_vtable_range(ea0, ea1)
            self.update_fields()
        except ValueError as e:
            idaapi.warning(str(e))


    def handle_vtable_interaction(self, row, column):
        if self.edit_class is None:
            return

        vm = self.edit_class.vmethods[row]

        if column == 0:         # Go to vtable offset
            idc.jumpto(self.edit_class.vtable_start + row*4)
        elif column == 1:       # Go to address
            idc.jumpto(vm.ea)
        elif column == 2:       # Edit signature
            dlg = SignatureDialog(vm.return_type, vm.owner.name, vm.name, vm.args, vm.is_const, vm.ctor_type, vm.dtor_type, fixed_owner_type=True)
            if dlg.exec_() != QtWidgets.QDialog.Accepted:
                return
            vm.set_signature(dlg.name, dlg.args, dlg.return_type, dlg.is_const, dlg.ctor_type, dlg.dtor_type)
            self.vtable.setItem(row, 2, QtWidgets.QTableWidgetItem(vm.get_signature()))
            idaapi.refresh_idaview_anyway()


    def handle_add_method(self):
        db = database.get()

        if self.edit_class is None:
            return

        sel_ea = idc.get_screen_ea()

        if sel_ea == idc.BADADDR:
            return

        existing_method = None
        if sel_ea in db.known_methods:
            existing_method = db.known_methods[sel_ea]
            if type(existing_method) != database_entries.Method:
                idaapi.warning("Cannot unlink function that is in a VTable")
                return

        name = idc.get_name(sel_ea, 0)
        if name.startswith('_Z'):       # Ignore already mangled names
            name = ''
        if not name:
            name = 'sub_%X' % sel_ea

        dlg = SignatureDialog(name=name, owner_type=self.edit_class.name, fixed_owner_type=True)
        if dlg.exec_() != QtWidgets.QDialog.Accepted:
            return

        if existing_method is not None:
            existing_method.unlink()

        method = database_entries.Method(sel_ea, self.edit_class, dlg.name)
        method.set_signature(dlg.name, dlg.args, dlg.return_type, dlg.is_const, dlg.ctor_type, dlg.dtor_type)
        self.edit_class.methods.append(method)
        method.refresh()

        self.update_fields()


    def handle_remove_method(self):
        db = database.get()

        if self.edit_class is None:
            return

        row_item = self.methods.item(self.methods.currentRow(), 0)
        if row_item is None:
            return

        m = row_item.data(QtCore.Qt.UserRole)
        if type(m) != database_entries.Method or m not in self.edit_class.methods:
            return

        m.unlink()

        self.update_fields()



    def handle_methods_interaction(self, row, column):
        if self.edit_class is None:
            return

        m = self.methods.item(row, 0).data(QtCore.Qt.UserRole)
        if type(m) != database_entries.Method or m not in self.edit_class.methods:
            return

        elif column == 0:       # Go to address
            idc.jumpto(m.ea)
        elif column == 1:       # Edit signature
            dlg = SignatureDialog(m.return_type, m.owner.name, m.name, m.args, m.is_const, m.ctor_type, m.dtor_type, fixed_owner_type=True)
            if dlg.exec_() != QtWidgets.QDialog.Accepted:
                return
            m.set_signature(dlg.name, dlg.args, dlg.return_type, dlg.is_const, dlg.ctor_type, dlg.dtor_type)
            self.methods.setItem(row, 1, QtWidgets.QTableWidgetItem(m.get_signature()))
            idaapi.refresh_idaview_anyway()


```

`classy/itanium_mangler.py`:

```py
# If you want to stay sane, better close this file ;)

PREFIX = '_Z'

DECORS = {
    '*': 'P',
    '&': 'R',
    'const': 'K'
}

MULTI_SEGMENT_TYPES = [
    ['signed', 'char'],
    ['unsigned', 'char'],
    ['signed', 'short'],
    ['unsigned', 'short'],
    ['signed', 'int'],
    ['unsigned', 'int'],
    ['signed', 'long'],
    ['unsigned', 'long'],
    ['long', 'long'],
    ['signed', 'long', 'long'],
    ['unsigned', 'long', 'long'],
]
MULTI_SEGMENT_TYPES.sort(key=len, reverse=True)

BUILTIN_TYPES = {
    'void': 'v',
    'wchar_t': 'w',
    'bool': 'b',
    'char': 'c',
    'signed_char': 'a',
    'unsigned_char': 'h',
    'short': 's',
    'signed_short': 's',
    'unsigned_short': 't',
    'int': 'i',
    'signed_int': 'i',
    'unsigned_int': 'j',
    'long': 'l',
    'signed_long': 'l',
    'unsigned_long': 'm',
    'long_long': 'x',
    'signed_long_long': 'x',
    'unsigned_long_long': 'y',
    'float': 'f',
    'double': 'd',
}

CTOR_TYPES = [
    '',
    '',
    ''
]


def encode_seqid(seqid):
    alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'

    if seqid == 0:
        return 'S_'

    seqid -= 1
    base36 = ''

    while seqid:
        seqid, i = divmod(seqid, 36)
        base36 = alphabet[i] + base36

    return 'S' + (base36 or '0') + '_'


def check_identifier(ident):

    if len(ident) == 0:
        return False

    for c in ident:
        if not c.isalnum() and not c == '_':
            return False

    if ident[0].isdigit():
        return False

    return True


def brace_split(txt, char=' ', remove_empty=True):

    braces = {
        '(': ')',
        '<': '>'
    }

    brace_stack = []

    segs = []
    curr_seg = ''

    for c in txt:
        if len(brace_stack):
            if c == brace_stack[-1]:
                brace_stack.pop()

        if c in braces.keys():
            brace_stack.append(braces[c])

        if not len(brace_stack) and c == char:
            if not remove_empty or curr_seg:
                segs.append(curr_seg)
                curr_seg = ''
        else:
            curr_seg += c

    if curr_seg or (not remove_empty and len(segs)):
        segs.append(curr_seg)

    if len(brace_stack):
        raise ValueError('Mismatched braces')

    return segs


def len_encode(ident):
    return "%u%s" % (len(ident), ident)


def apply_typedefs(segs, typedefs):
    idx = 0
    while idx < len(segs):
        s = segs[idx]
        if s in typedefs:
            del segs[idx]
            new_segs = typedefs[s].split()
            while len(new_segs):
                segs.insert(idx, new_segs.pop(0))
                idx += 1
        else:
            idx += 1


def fix_multi_seg_types(segs):
    for l in range(len(segs)):
        for mst in MULTI_SEGMENT_TYPES:
            r = l + len(mst)
            if mst == segs[l:r]:
                del segs[l:r]
                segs.insert(l, '_'.join(mst))
                break


def mangle_type(txt, pre_and_postfix=True):

    if txt in BUILTIN_TYPES.keys():
        return BUILTIN_TYPES[txt]

    segs = txt.split('::')

    if len(segs) == 1:
        return len_encode(segs[0])

    ret = 'N' if pre_and_postfix else ''
    for s in segs:
        ret += len_encode(s)
    if pre_and_postfix:
        ret += 'E'

    return ret


def add_to_subs(subs, sub):
    if sub in subs:
        raise ValueError('Substitution "%s" is already registered' % sub)
    subs[sub] = encode_seqid(len(subs))


# Oh boy, this hurts... This is literally the WORST function I ever wrote in my life. CLEAN IT UP
# Todo: Allow templates
def mangle_decorated_type(txt_decors, type_txt, subs=None):
    if subs is None:
        subs = {}

    type_segs = type_txt.split('::')
    if not len(type_segs):
        raise ValueError('Type is empty')

    decors = []
    for d in txt_decors:
        try:
            decors.append(DECORS[d])
        except KeyError:
            raise ValueError('Invalid decor "%s"' % d)
    decors.reverse()


    if type_segs[-1] in BUILTIN_TYPES:
        if len(type_segs) > 1:
            raise ValueError('Builtin type may not be namespaced!')
        ret = BUILTIN_TYPES[type_segs[-1]]

        for i in range(len(decors) + 1):
            curr_mangled_nosubs = ''.join(decors[i:]) + ret
            # print('Testing for ' + curr_mangled_nosubs)

            start_backtrack = False

            if i == len(decors):        # No substitutions found
                start_backtrack = True
            if curr_mangled_nosubs in subs:
                # print('Found ' + curr_mangled_nosubs + ' as ' + subs[curr_mangled_nosubs])
                ret = subs[curr_mangled_nosubs]
                start_backtrack = True

            if start_backtrack:
                while i:
                    # print('Backtracking ' + decors[i - 1])
                    ret = decors[i - 1] + ret
                    curr_mangled_nosubs = decors[i - 1] + curr_mangled_nosubs
                    add_to_subs(subs, curr_mangled_nosubs)
                    # print(subs)
                    i -= 1
                break

        return ret


    type_mangled_stripped = mangle_type(type_txt, False)

    if type_mangled_stripped in subs:
        for i in range(len(decors) + 1):
            # print('Testing for decors ' + ''.join(decors[i:]))
            curr_mangled = ''.join(decors[i:]) + type_mangled_stripped
            if curr_mangled in subs:
                # print('Found ' + curr_mangled + ' as ' + subs[curr_mangled])
                ret = subs[curr_mangled]
                while i:
                    ret = decors[i-1] + ret
                    curr_mangled = decors[i-1] + curr_mangled
                    add_to_subs(subs, curr_mangled)
                    # print(subs)
                    i -= 1
                break
        return ret


    curr_mangled = ''
    curr_mangled_nosubs = ''

    # New found names are added to substitution from the left
    for i in reversed(range(len(type_segs) + 1)):
        curr_mangled_nosubs = ''.join(len_encode(ts) for ts in type_segs[:i])
        # print('Testing for names ' + '::'.join(type_segs[:i]) + ' (' + curr_mangled_nosubs + ')')

        if not curr_mangled_nosubs or curr_mangled_nosubs in subs:
            if curr_mangled_nosubs:
                # print('Found ' + curr_mangled_nosubs + ' as ' + subs[curr_mangled_nosubs])
                curr_mangled = subs[curr_mangled_nosubs]
            else:
                curr_mangled = ''
                # print('Did not find any substitution')
            while i < len(type_segs):
                curr_mangled += len_encode(type_segs[i])
                curr_mangled_nosubs += len_encode(type_segs[i])
                add_to_subs(subs, curr_mangled_nosubs)
                # print(subs)
                i += 1
            break

    if len(type_segs) == 1:
        ret = curr_mangled
    else:
        ret = 'N' + curr_mangled + 'E'

    for d in reversed(decors):
        ret = d + ret
        curr_mangled = d + curr_mangled
        curr_mangled_nosubs = d + curr_mangled_nosubs
        add_to_subs(subs, curr_mangled_nosubs)
        # print(subs)


    return ret


# Cleans up raw txt argument: Removes the label, parses decors
def mangle_argument(txt, typedefs=None, subs=None):
    if typedefs is None:
        typedefs = {}

    if subs is None:
        subs = {}

    if '(' in txt:
        raise NotImplementedError('Function pointers are not supported')
    if '<' in txt:
        raise NotImplementedError('Templates are not supported')
    if '&&' in txt:
        raise NotImplementedError('r-value reference are not supported')

    # Prepare text for space splitting
    txt = txt.replace('&', ' & ')
    txt = txt.replace('*', ' * ')

    segs = brace_split(txt)

    apply_typedefs(segs, typedefs)

    # Fix multi segment types for easier parsing
    fix_multi_seg_types(segs)

    # Check for pre-const: Belongs to first * or &, const without * or & is omitted
    if len(segs) != 0 and segs[0] == 'const':
        idx = -1
        for i in range(1, len(segs)):
            x = segs[i]
            if x == 'const':
                raise ValueError('Multiple const')
            if x in ['*', '&']:
                idx = i
                break

        if idx != -1:
            segs.insert(idx, 'const')
        del segs[0]

    # Current segment layout: type, decors, optional label

    # Filter out label
    if len(segs) >= 2:
        if not segs[-1] in DECORS.keys():   # Already no label?
            if not check_identifier(segs[-1]):
                raise ValueError('Invalid identifier "%s"' % segs[-1])
            if segs[-1] in BUILTIN_TYPES:
                raise ValueError('Invalid identifier "%s"' % segs[-1])
            del segs[-1]

    # Check decors
    decors = segs[1:]

    if len(decors) and decors[-1] == 'const':
        del decors[-1]

    if not len(segs):
        raise ValueError('No argument type')

    return mangle_decorated_type(decors, segs[0], subs)


# Mangles the entire text inside argument braces.
def mangle_arguments(txt, typedefs=None, subs=None):
    if typedefs is None:
        typedefs = {}

    if subs is None:
        subs = {}

    args = brace_split(txt, ',', False)

    args = [a.strip() for a in args]

    # Detect void arguments
    if not len(args) or (len(args) == 1 and (not args[0] or args[0] == 'void')):
        return 'v'

    ret = ''
    for a in args:
        ret += mangle_argument(a, typedefs, subs)
    return ret


# Basically the main function of all this
def mangle_function(txt, typedefs=None, ctor_type=None, dtor_type=None):
    if typedefs is None:
        typedefs = {}

    left_brace_idx = txt.find('(')
    right_brace_idx = txt.rfind(')')

    if left_brace_idx < 0 or right_brace_idx < 0 or left_brace_idx > right_brace_idx:
        raise ValueError('Finding argument braces failed')

    # Check identifier
    pre_brace_segs = txt[:left_brace_idx].split()

    if len(pre_brace_segs) < 1:
        raise ValueError('No function identifier found')

    identifier = pre_brace_segs[-1]

    # Arguments
    arguments = txt[left_brace_idx+1:right_brace_idx]

    # Decors
    post_brace_segs = txt[right_brace_idx + 1:].split()


    subs = {}

    ret = PREFIX

    identifier_segs = identifier.split('::')
    is_cdtor = False

    # Check for ctors and dtors
    if len(identifier_segs) >= 2:
        if identifier_segs[-1] == identifier_segs[-2]:              # ctor
            if ctor_type not in [1, 2, 3]:
                raise ValueError('No or invalid ctor type given')
            identifier_segs[-1] = 'C%u' % ctor_type
            is_cdtor = True
        elif identifier_segs[-1] == ('~' + identifier_segs[-2]):    # dtor
            if dtor_type not in [0, 1, 2]:
                raise ValueError('No or invalid dtor type given')
            identifier_segs[-1] = 'D%u' % dtor_type
            is_cdtor = True

    for s in identifier_segs:
        if not check_identifier(s):
            raise ValueError('Invalid identifier "%s"' % s)

    mangled_type = ''.join(len_encode(ts) for ts in identifier_segs[:len(identifier_segs)-1])
    mangled_type += identifier_segs[-1] if is_cdtor else len_encode(identifier_segs[-1])

    if 'const' in post_brace_segs:
        if len(identifier_segs) < 2:
            raise ValueError('Function outside struct/class may not be const')
        mangled_type = 'K' + mangled_type
    if len(identifier_segs) > 1:
        mangled_type = 'N' + mangled_type + 'E'
    ret += mangled_type

    for i in range(1, len(identifier_segs)):
        add_to_subs(subs, ''.join(len_encode(ts) for ts in identifier_segs[:i]))

    ret += mangle_arguments(arguments, typedefs, subs)

    return ret

```

`classy/menumgr.py`:

```py
import re

from classy.uiaction import UiAction
from classy.util import show_about, main_menu


class MenuState:
    NULL = 0
    DATABASE_CLOSED = 1
    DATABASE_OPENED = 2


class MenuMgr:
    def __init__(self, plugin):
        self.state = MenuState.NULL
        self.actions = []
        
        self.parent_menu = main_menu()
        self.menu = self.parent_menu.addMenu('Classy')

        # Global actions
        self.about_action = self.create_menu_item('About', show_about)

        # Database closed actions
        self.action_create_open = self.create_menu_item("Create/open database", plugin.create_open_database)

        # Database opened actions
        self.action_show_gui = self.create_menu_item("Show GUI", plugin.show_gui)
        self.action_save = self.create_menu_item("Save Database", plugin.save)
        self.action_save_as = self.create_menu_item("Save Database As...", plugin.save_as)
        self.action_export_all_symbols = self.create_menu_item("Export all Symbols...", plugin.export_all_symbols)
        self.action_edit_typedefs = self.create_menu_item("Edit Typedefs...", plugin.edit_typedefs)
        self.action_set_pure_virtuals = self.create_menu_item("Set pure virtual values...", plugin.edit_pure_virtual_vals)
        self.action_set_deleted_virtuals = self.create_menu_item("Set deleted virtual values...", plugin.edit_deleted_virtual_vals)
        self.action_set_autosave_interval = self.create_menu_item("Set autosave interval...", plugin.set_autosave_interval)
        self.action_refresh_all = self.create_menu_item("Refresh all", plugin.refresh_all)
        self.action_clear_database = self.create_menu_item("Clear Database", plugin.clear_database)


    def cleanup(self):
        for a in self.actions:
            a.unregister()
        self.parent_menu.removeAction(self.menu.menuAction())


    def set_state(self, state):
        if state == self.state:
            return

        self.state = state

        for a in self.actions:
            a.detach()

        if self.state == MenuState.DATABASE_CLOSED:
            self.action_create_open.attach()

        if self.state == MenuState.DATABASE_OPENED:
            self.action_show_gui.attach()
            self.action_save.attach()
            self.action_save_as.attach()
            self.action_export_all_symbols.attach()
            self.action_edit_typedefs.attach()
            self.action_set_pure_virtuals.attach()
            self.action_set_deleted_virtuals.attach()
            self.action_set_autosave_interval.attach()
            self.action_refresh_all.attach()
            self.action_clear_database.attach()

        self.about_action.attach()


    def create_menu_item(self, name, callback, shortcut="", tooltip=""):
        id = 'Classy:' + re.sub('[^A-Za-z0-9]+', '_', name)
        action = UiAction(id, name, tooltip, 'Classy', callback, shortcut)
        action.register()
        self.actions.append(action)
        return action

```

`classy/plugin.py`:

```py
import os
import re
import idaapi

from PyQt5 import QtWidgets, QtCore

from classy.util import *
from classy.gui import *
from classy.menumgr import MenuMgr, MenuState
from classy.typedef_dialog import TypedefDialog

import classy.database as database


class ClassyPlugin(idaapi.plugin_t):
    flags = idaapi.PLUGIN_PROC
    comment = ""

    help = "Uh, maybe later"
    wanted_name = "Classy"
    wanted_hotkey = ""

    version = 'v0.0.2'


    def init(self):
        self.menumgr = MenuMgr(self)
        self.gui = ClassyGui(self)

        db = database.create_instance()
        if db.is_created():
            try:
                db.open()
            except Exception as e:
                idaapi.warning('Loading Classy database failed: %s' % str(e))

        if db.is_open:
            self.menumgr.set_state(MenuState.DATABASE_OPENED)
        else:
            self.menumgr.set_state(MenuState.DATABASE_CLOSED)


        log('Loaded')

        return idaapi.PLUGIN_KEEP


    def run(self, arg):
        show_about()


    def term(self):
        try:
            db = database.get()

            if db.is_open and ask_yes_no('Do you want to save the classy database?', True):
                db.save()
            db.close()

            database.destroy_instance()

        except ValueError:      # Database instance might not be created
            pass

        self.menumgr.cleanup()

        log('Unloaded')


    def save(self):
        database.get().save()


    def save_as(self):
        db = database.get()

        path = QtWidgets.QFileDialog.getSaveFileName(None,
                                                     'Export Classy database', '',
                                                     'Classy database (*.cdb)')
        if not path[0]:
            return

        # Check for user idiocy
        if os.path.normpath(path[0]) == os.path.normpath(db.path):
            idaapi.warning('You cannot overwrite the currently active Classy database.')
            return

        db.save_as(path[0])


    def show_gui(self):
        self.gui.show()


    def create_open_database(self):
        db = database.get()

        try:
            db.open()
        except Exception as e:
            idaapi.warning('Creating/opening Classy database failed: %s' % str(e))

        if db.is_open:
            self.menumgr.set_state(MenuState.DATABASE_OPENED)
        else:
            self.menumgr.set_state(MenuState.DATABASE_CLOSED)


    def export_all_symbols(self):
        path = QtWidgets.QFileDialog.getSaveFileName(None,
                                                     'Export all symbols', '',
                                                     'Linker script (*.ld);;All files (*)')
        if not path[0]:
            return

        f = open(path[0], 'w')
        f.write(database.get().generate_symbols())
        f.close()



    def clear_database(self):
        if ask_yes_no('Are you really sure that you want to clear the Classy databse?\n', False):
            database.get().clear()
            self.gui.update_fields()
            idaapi.refresh_idaview_anyway()


    def edit_typedefs(self):
        dlg = TypedefDialog()
        dlg.exec_()


    def edit_pure_virtual_vals(self):
        db = database.get()

        txt = idaapi.ask_str(', '.join([('0x%X' % x) for x in db.pure_virtual_vals]), idaapi.HIST_IDENT,"Enter pure virtual values")
        if txt is None or not txt.strip():
            return

        new_pure_virtual_vals = []

        for s in txt.split(','):
            try:
                new_pure_virtual_vals.append(int(s, 0))
            except ValueError:
                idaapi.warning('Parsing "%s" failed. Pure virtual values were not modified.' % s)
                return

        db.pure_virtual_vals = new_pure_virtual_vals


    def edit_deleted_virtual_vals(self):
        db = database.get()

        txt = idaapi.ask_str(', '.join([('0x%X' % x) for x in db.deleted_virtual_vals]), idaapi.HIST_IDENT,"Enter deleted virtual values")
        if txt is None or not txt.strip():
            return

        new_deleted_virtual_vals = []

        for s in txt.split(','):
            try:
                new_deleted_virtual_vals.append(int(s, 0))
            except ValueError:
                idaapi.warning('Parsing "%s" failed. Deleted virtual values were not modified.' % s)
                return

        db.deleted_virtual_vals = new_deleted_virtual_vals


    def refresh_all(self):
        database_entries.refresh_all()
        idaapi.refresh_idaview_anyway()


    def set_autosave_interval(self):
        db = database.get()

        new_interval, ok_pressed = QtWidgets.QInputDialog.getInt(None, 'Set autosave interval', 'Autosave interval [seconds]:', db.autosave_interval, 10)
        if ok_pressed:
            db.set_autosave_interval(new_interval)

```

`classy/signature_dialog.py`:

```py
import idaapi
import idc
from PyQt5 import QtWidgets, QtCore

import classy.database as database
import classy.itanium_mangler as itanium_mangler


class SignatureDialog(QtWidgets.QDialog):
    def __init__(self, return_type = 'void', owner_type='', name='', args='', is_const=False, ctor_type=1, dtor_type=1,
                 fixed_return_type=False, fixed_owner_type=False, fixed_name=False, fixed_args=False,
                 fixed_is_const=False, fixed_ctor_type=False, fixed_dtor_type=False):
        super(SignatureDialog, self).__init__()

        self.return_type = return_type
        self.owner_type = owner_type
        self.name = name
        self.args = args
        self.is_const = is_const
        self.ctor_type = ctor_type
        self.dtor_type = dtor_type

        self.setWindowTitle('Set function signature')

        layout = QtWidgets.QGridLayout(self)

        self.signature_w = QtWidgets.QLabel()
        self.signature_w.setMinimumWidth(220)
        layout.addWidget(self.signature_w, 0, 0, 1, 2)

        layout.addWidget(QtWidgets.QLabel('Return type'), 1, 0)
        self.return_type_w = QtWidgets.QLineEdit()
        self.return_type_w.setText(self.return_type)
        self.return_type_w.setDisabled(fixed_return_type)
        self.return_type_w.textChanged.connect(self.update_signature)
        layout.addWidget(self.return_type_w, 1, 1)

        layout.addWidget(QtWidgets.QLabel('Owner type'), 2, 0)
        self.owner_type_w = QtWidgets.QLineEdit()
        self.owner_type_w.setText(self.owner_type)
        self.owner_type_w.setDisabled(fixed_owner_type)
        self.owner_type_w.textChanged.connect(self.update_signature)
        layout.addWidget(self.owner_type_w, 2, 1)

        layout.addWidget(QtWidgets.QLabel('Name'), 3, 0)
        self.name_w = QtWidgets.QLineEdit()
        self.name_w.setText(self.name)
        self.name_w.setDisabled(fixed_name)
        self.name_w.textChanged.connect(self.update_signature)
        layout.addWidget(self.name_w, 3, 1)

        layout.addWidget(QtWidgets.QLabel('Arguments'), 4, 0)
        self.args_w = QtWidgets.QLineEdit()
        self.args_w.setText(self.args)
        self.args_w.setDisabled(fixed_args)
        self.args_w.textChanged.connect(self.update_signature)
        layout.addWidget(self.args_w, 4, 1)

        layout.addWidget(QtWidgets.QLabel('Const'), 5, 0)
        self.is_const_w = QtWidgets.QCheckBox()
        self.is_const_w.setChecked(self.is_const)
        self.is_const_w.setDisabled(fixed_is_const)
        self.is_const_w.stateChanged.connect(self.update_signature)
        layout.addWidget(self.is_const_w, 5, 1)

        layout.addWidget(QtWidgets.QLabel('Ctor'), 6, 0)
        self.ctor_type_w = QtWidgets.QComboBox()
        self.ctor_type_w.addItem("C1: complete")
        self.ctor_type_w.addItem("C2: base")
        self.ctor_type_w.addItem("C3: complete allocating")
        self.ctor_type_w.setCurrentIndex(ctor_type-1)
        self.ctor_type_w.setDisabled(fixed_ctor_type)
        self.ctor_type_w.currentIndexChanged.connect(self.update_signature)
        layout.addWidget(self.ctor_type_w, 6, 1)

        layout.addWidget(QtWidgets.QLabel('Dtor'), 7, 0)
        self.dtor_type_w = QtWidgets.QComboBox()
        self.dtor_type_w.addItem("D0: deleting")
        self.dtor_type_w.addItem("D1: complete")
        self.dtor_type_w.addItem("D2: base")
        self.dtor_type_w.setCurrentIndex(dtor_type)
        self.dtor_type_w.setDisabled(fixed_dtor_type)
        self.dtor_type_w.currentIndexChanged.connect(self.update_signature)
        layout.addWidget(self.dtor_type_w, 7, 1)

        layout.addWidget(QtWidgets.QLabel('Status'), 8, 0)
        self.status_w = QtWidgets.QLabel()
        layout.addWidget(self.status_w, 8, 1)

        layout.addWidget(QtWidgets.QLabel('Mangled'), 9, 0)
        self.mangled_w = QtWidgets.QLabel()
        layout.addWidget(self.mangled_w, 9, 1)

        self.buttonBox = QtWidgets.QDialogButtonBox()
        self.buttonBox.addButton("OK", QtWidgets.QDialogButtonBox.AcceptRole)
        self.buttonBox.addButton("Cancel", QtWidgets.QDialogButtonBox.RejectRole)
        layout.addWidget(self.buttonBox, 10, 0, 1, 2)
        self.buttonBox.accepted.connect(self.handle_ok)
        self.buttonBox.rejected.connect(self.reject)

        self.signature = None
        self.is_signature_valid = False
        self.mangled = None
        self.status = ''
        self.update_signature()

    def update_signature(self):
        self.return_type = self.return_type_w.text().encode('ascii', 'replace').strip().decode() or 'void'
        self.owner_type = self.owner_type_w.text().encode('ascii', 'replace').strip().decode()
        self.name = self.name_w.text().encode('ascii', 'replace').strip().decode()
        self.args = self.args_w.text().encode('ascii', 'replace').strip().decode()
        self.is_const = self.is_const_w.isChecked()
        self.ctor_type = self.ctor_type_w.currentIndex() + 1
        self.dtor_type = self.dtor_type_w.currentIndex()

        # ctors and dtors shouldn't have a return type, dtors shouldn't have args
        if self.owner_type:
            owner_last_type = self.owner_type.split('::')[-1]
            if self.name == owner_last_type:
                self.return_type = ''
            elif self.name == '~' + owner_last_type:
                self.return_type = ''
                self.args = ''

        signature_segs = []
        if self.return_type:
            signature_segs.append(self.return_type)
            signature_segs.append(' ')
        if self.owner_type:
            signature_segs.append(self.owner_type)
            signature_segs.append('::')
        signature_segs.append(self.name)
        signature_segs.append('(')
        signature_segs.append(self.args)
        signature_segs.append(')')
        if self.is_const:
            signature_segs.append(' const')
        self.signature = ''.join(signature_segs)
        self.signature_w.setText(self.signature)

        self.is_signature_valid = False
        self.mangled = None
        try:
            if not self.name or (' ' in self.name):
                raise ValueError('Name is invalid')
            self.mangled = itanium_mangler.mangle_function(self.signature, database.get().typedefs, self.ctor_type, self.dtor_type)
            self.is_signature_valid = True
            self.status = ''
            self.status_w.setText('Valid')
        except (ValueError, NotImplementedError) as e:
            self.status = str(e)
            self.status_w.setText('Invalid: ' + self.status)
        self.mangled_w.setText(str(self.mangled))

    def handle_ok(self):
        if not self.is_signature_valid:
            idaapi.warning("The signature is not valid: " + self.status)
        else:
            self.accept()

```

`classy/typedef_dialog.py`:

```py
import idaapi
import idc
from PyQt5 import QtWidgets, QtCore

import classy.database as database
import classy.itanium_mangler as itanium_mangler


# Todo: Move some code to database_entries

class TypedefDialog(QtWidgets.QDialog):
    def __init__(self):
        super(TypedefDialog, self).__init__()

        self.setWindowTitle('Classy Typedefs')

        layout = QtWidgets.QVBoxLayout(self)

        self.list = QtWidgets.QListWidget()
        layout.addWidget(self.list)

        button_layout = QtWidgets.QHBoxLayout(self)
        layout.addLayout(button_layout)

        button_layout.addItem(QtWidgets.QSpacerItem(0, 0, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum))

        add_btn = QtWidgets.QPushButton('Add')
        add_btn.clicked.connect(self.handle_add)
        button_layout.addWidget(add_btn)

        edit_btn = QtWidgets.QPushButton('Edit')
        edit_btn.clicked.connect(self.handle_edit)
        button_layout.addWidget(edit_btn)

        remove_btn = QtWidgets.QPushButton('Remove')
        remove_btn.clicked.connect(self.handle_remove)
        button_layout.addWidget(remove_btn)

        self.update_list()


    def update_list(self):
        db = database.get()

        self.list.clear()
        for t in db.typedefs:
            item = QtWidgets.QListWidgetItem('typedef %s %s;' % (db.typedefs[t], t))
            item.setData(QtCore.Qt.UserRole, t)
            self.list.addItem(item)


    def handle_add(self):
        t = idaapi.ask_str('', idaapi.HIST_IDENT,'Enter typedef name')
        if t is None:
            return

        if t in database.get().typedefs:
            idaapi.warning('That name is already used.')
            return

        if not itanium_mangler.check_identifier(t):
            idaapi.warning('That name is invalid.')
            return

        # Todo: prevent overwriting builtins

        self.try_set_typedef(t)


    def handle_edit(self):
        item = self.list.currentItem()
        if item is None:
            return

        t = item.data(QtCore.Qt.UserRole)
        self.try_set_typedef(t)


    def handle_remove(self):
        item = self.list.currentItem()
        if item is None:
            return

        t = item.data(QtCore.Qt.UserRole)
        del database.get().typedefs[t]

        self.update_list()


    def try_set_typedef(self, t):
        val = idaapi.ask_str('', idaapi.HIST_IDENT,'Enter typedef value')
        if val is None:
            return

        val_segs = val.split()
        itanium_mangler.fix_multi_seg_types(val_segs)
        if len(val_segs) != 1 or (
                val_segs[0] not in itanium_mangler.BUILTIN_TYPES and not itanium_mangler.check_identifier(val_segs[0])):
            idaapi.warning('That value is invalid.')
            return

        database.get().typedefs[t] = val.strip()
        self.update_list()

```

`classy/uiaction.py`:

```py
import idaapi


class UiAction(idaapi.action_handler_t):

    def __init__(self, id, name, tooltip, menu_path, callback, shortcut):
        idaapi.action_handler_t.__init__(self)
        self.id = id
        self.name = name
        self.tooltip = tooltip
        self.menu_path = menu_path
        self.callback = callback
        self.shortcut = shortcut


    def register(self):
        action_desc = idaapi.action_desc_t(self.id, self.name, self, self.shortcut, self.tooltip)
        if not idaapi.register_action(action_desc):
            return False
        if not idaapi.attach_action_to_menu(self.menu_path, self.id, 0):
            return False
        return True


    def unregister(self):
        self.detach()
        idaapi.unregister_action(self.id)


    def attach(self):
        return idaapi.attach_action_to_menu(self.menu_path, self.id, 0)


    def detach(self):
        idaapi.detach_action_from_menu(self.menu_path, self.id)


    def activate(self, ctx):
        self.callback()
        return 1


    def update(self, ctx):
        return idaapi.AST_ENABLE_FOR_IDB

```

`classy/util.py`:

```py
import idaapi
from PyQt5 import QtWidgets, QtCore
from classy.aboutwindow import AboutWindow


def ask_yes_no(text, yes_is_default = True):
    ret = QtWidgets.QMessageBox.question(None, "Classy", text,
                                         QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                                         defaultButton=(QtWidgets.QMessageBox.Yes
                                                        if yes_is_default else
                                                        QtWidgets.QMessageBox.No))

    return ret == QtWidgets.QMessageBox.Yes


def log(msg):
    idaapi.msg("[ClassyDX] %s\n" % str(msg))


def show_about():
    AboutWindow().exec_()



class ClickableQLabel(QtWidgets.QLabel):
    clicked = QtCore.pyqtSignal()
    doubleClicked = QtCore.pyqtSignal()

    def __init__(self, parent=None):
        QtWidgets.QLabel.__init__(self, parent)

    def mousePressEvent(self, ev):
        self.clicked.emit()

    def mouseDoubleClickEvent(self, ev):
        self.doubleClicked.emit()



class EnterPressQTableWidget(QtWidgets.QTableWidget):
    cellEnterPressed = QtCore.pyqtSignal(int, int)

    def __init__(self, parent=None):
        super(EnterPressQTableWidget, self).__init__(parent)

    def keyPressEvent(self, event):
        if event.key() in [QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter]:
            row = self.currentRow()
            column = self.currentColumn()
            if row >= 0 and column >= 0:
                self.cellEnterPressed.emit(row, column)
                return
        super(EnterPressQTableWidget, self).keyPressEvent(event)


def main_window():
    tform = idaapi.get_current_widget()

    if not tform:
        tform = idaapi.find_widget('Output window')

    widget = idaapi.PluginForm.FormToPyQtWidget(tform)
    window = widget.window()
    return window

def main_menu():
    win = main_window()
    return win.findChild(QtWidgets.QMenuBar)

```

`classy_plugin.py`:

```py
#from __future__ import absolute_import, division, print_function
from __future__ import division, print_function


def PLUGIN_ENTRY():
    from classy.plugin import ClassyPlugin
    return ClassyPlugin()

```