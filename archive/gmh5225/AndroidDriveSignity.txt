Project Path: arc_gmh5225_AndroidDriveSignity_9nph5h6n

Source Tree:

```txt
arc_gmh5225_AndroidDriveSignity_9nph5h6n
├── AndroidDriveSignity.py
├── LICENSE
└── README.md

```

`AndroidDriveSignity.py`:

```py
import os
import argparse

# Dictionary to hold symbol addresses and names
symbols_dict = {}

def parse_kallsyms(file_path):
    # Parse the kallsyms file to populate the symbols dictionary
    global symbols_dict
    with open(file_path, 'r') as file:
        for line in file:
            parts = line.strip().split(' ')
            if len(parts) == 3:
                address, symbol_type, symbol_name = parts
                symbols_dict[address] = symbol_name

def check_original_instruction(kernel_data, patch_offset):
    # Check if the original instruction at the given offset is PACIASP
    return kernel_data[patch_offset:patch_offset + 4] == bytearray.fromhex("3F 23 03 D5")

def prepare_patch_data(original_patch_data_hex, has_paciasp):
    # Prepare the patch data, adding PACIASP and AUTIASP instructions if necessary
    if has_paciasp:
        return bytearray.fromhex("3F 23 03 D5") + bytearray.fromhex(original_patch_data_hex)[:4] + bytearray.fromhex("BF 23 03 D5") + bytearray.fromhex(original_patch_data_hex)[4:]
    else:
        return bytearray.fromhex(original_patch_data_hex)

def patch_symbol(kernel_data, symbol_name, base_address, original_patch_data_hex):
    # Patch the symbol in the kernel data with the given patch data
    symbol_address = None
    for address, name in symbols_dict.items():
        if name == symbol_name:
            symbol_address = int(address, 16)
            break

    if symbol_address is None:
        print(f"Error: {symbol_name} symbol not found.")
        return False

    relative_address = symbol_address - base_address
    patch_offset = relative_address

    # Check if the original instruction is PACIASP and prepare the patch data accordingly
    has_paciasp = check_original_instruction(kernel_data, patch_offset)
    if has_paciasp:
        print(f"Symbol {symbol_name} Offset 0x{patch_offset:X} has PACIASP enabled.")
    else:
        print(f"Symbol {symbol_name} Offset 0x{patch_offset:X} has PACIASP disabled.")
    patch_data = prepare_patch_data(original_patch_data_hex, has_paciasp)

    kernel_data[patch_offset:patch_offset + len(patch_data)] = patch_data
    return True

def patch_kernel_file(kernel_file_path, kallsyms_file_path, output_file_path):
    # Main function to patch the kernel file based on the provided kallsyms file
    parse_kallsyms(kallsyms_file_path)

    base_address = int(list(symbols_dict.keys())[0], 16)

    with open(kernel_file_path, 'rb') as kernel_file:
        kernel_data = bytearray(kernel_file.read())

    # Apply patches to specified symbols
    patch_symbol(kernel_data, "check_modinfo", base_address, "00 00 80 52 C0 03 5F D6")
    patch_symbol(kernel_data, "check_version", base_address, "20 00 80 52 C0 03 5F D6")
    # The GKI kernel may not have this function
    patch_symbol(kernel_data, "module_sig_check", base_address, "00 00 80 52 C0 03 5F D6")

    # Save the patched kernel data to the output file
    with open(output_file_path, 'wb') as output_file:
        output_file.write(kernel_data)

    print(f"Kernel file patched and saved to {output_file_path}")

if __name__ == "__main__":
    # Command line argument parsing
    parser = argparse.ArgumentParser(description="Patch kernel file with provided symbol modifications.")
    parser.add_argument("kernel_file_path", type=str, help="Path to the binary kernel file.")
    parser.add_argument("kallsyms_file_path", type=str, help="Path to the kallsyms symbol file.")
    parser.add_argument("output_file_path", type=str, help="Path where the patched kernel file will be saved.")

    args = parser.parse_args()

    # Execute the patching process with provided arguments
    patch_kernel_file(args.kernel_file_path, args.kallsyms_file_path, args.output_file_path)

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 gmh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# `AndroidDriveSignity`

AndroidDriveSignity is a Python script designed for patching Android kernel``(ARMv8.3)`` files, enabling the loading of drivers without being subject to various verification checks, specifically signature verifications. This tool aims to facilitate the development and testing process by allowing developers to bypass the kernel's built-in security measures that prevent unofficial or modified drivers from being loaded.

### Features

- **Targeted Symbol Patching:** Modifies specific symbols within the kernel (`check_modinfo`, `check_version`, and `module_sig_check`) to circumvent driver signature verification mechanisms.
- **Intelligent Patching:** Dynamically adjusts patching based on the presence of the PACIASP instruction, ensuring compatibility across different kernel configurations.
- **User-Friendly CLI:** Provides a straightforward command-line interface for specifying the kernel binary, the kallsyms symbol table, and the output file paths.

### Requirements

- Rooted Android devices``(ARMv8.3)`` with [Magisk](https://github.com/topjohnwu/Magisk) or [KernelSU](https://github.com/tiann/KernelSU)
- Python 3.x
- ADB

### Usage

1. **Prepare the Necessary Files:** Ensure you have the kernel binary file (`kernel_file_path`), the kallsyms symbol table file (`kallsyms_file_path`), and a destination for the patched kernel (`output_file_path`).

2. **Execute AndroidDriveSignity:** Navigate to the script's directory in your terminal or command prompt and run:

   ```bash
   python AndroidDriveSignity.py <kernel_file_path> <kallsyms_file_path> <output_file_path>

### How to get your kallsyms?
```
adb shell
su
echo 0 > /proc/sys/kernel/kptr_restrict
exit
exit
adb shell su -c "cat /proc/kallsyms > /data/local/tmp/kallsyms"
adb pull /data/local/tmp/kallsyms
```

### How to extract your kernel file?
If there are two partitions, prioritize trying "boot_a":
```
adb shell su -c "dd if=$(readlink /dev/block/by-name/boot_a) of=/data/local/tmp/boot.img"
```
If there is only one partition, then it is "boot.img":
```
adb shell su -c "dd if=$(readlink /dev/block/by-name/boot) of=/data/local/tmp/boot.img"
```
Then, pull the boot image to your local machine:
```
adb pull /data/local/tmp/boot.img
```

Finally, use [magiskboot](https://github.com/svoboda18/magiskboot/releases) to extract the kernel file from boot.img.
```
magiskboot --unpack boot.img
```
You will obtain two files: one is the ``kernel``(your kernel file), and the other is ``ramdisk.cpio``.

### Testing on android12-5.10
```
python AndroidDriveSignity.py kernel kallsyms new-kernel
move/mv new-kernel kernel
magiskboot --repack boot.img
adb reboot bootloader
fastboot flash boot new-boot.img
fastboot reboot
adb push demo.ko /data/local/tmp
adb shell su -c insmod /data/local/tmp/demo.ko
adb shell su -c "lsmod |grep demo"
adb shell su -c rmmod /data/local/tmp/demo.ko
```
You can obtain an example of the Android driver [here](https://github.com/gmh5225/android-kernel-driver-template/releases)

## Credits
- ``Linux``
- ``Android``
- Some anonymous people


```