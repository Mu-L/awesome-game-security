Project Path: arc_gmh5225_MapleStoryDetectionSampleGenerator_zos7lpvv

Source Tree:

```txt
arc_gmh5225_MapleStoryDetectionSampleGenerator_zos7lpvv
├── LICENSE
├── MapRender.Invoker
│   ├── MapRender.Invoker.csproj
│   ├── MapRender.cs
│   ├── MapRenderInvoker.cs
│   ├── ObjectClass.cs
│   ├── ScreenShotData.cs
│   └── TargetItem.cs
├── MapleStory.Common
│   ├── Exceptions
│   │   └── WzImgNotFoundException.cs
│   ├── MapleStory.Common.csproj
│   ├── MapleStoryPathHelper.cs
│   └── WzTreeSearcher.cs
├── MapleStory.MachineLearningSampleGenerator
│   ├── MapleStory.MachineLearningSampleGenerator.csproj
│   ├── OutputFormat.cs
│   └── Program.cs
├── MapleStory.Sampler
│   ├── CocoWriter.cs
│   ├── DarknetWriter.cs
│   ├── IDatasetWriter.cs
│   ├── MapleStory.Sampler.csproj
│   ├── PostProcessor
│   │   ├── IPostProcessor.cs
│   │   └── PlayerProcessor.cs
│   ├── Sample.cs
│   ├── Sampler.cs
│   ├── TfExample.cs
│   ├── TfRecordWriter.cs
│   └── protobuf
│       ├── Example.cs
│       ├── Feature.cs
│       ├── README.md
│       ├── example.proto
│       └── feature.proto
├── MapleStoryDetectionSampleGenerator.sln
├── README.md
├── Tools
│   └── protogen
│       ├── .gitignore
│       ├── System.Collections.Immutable.dll
│       ├── System.Private.ServiceModel.dll
│       ├── System.Security.Cryptography.Pkcs.dll
│       ├── System.Security.Cryptography.Xml.dll
│       ├── System.Security.Permissions.dll
│       ├── System.ServiceModel.Primitives.dll
│       ├── System.ServiceModel.dll
│       ├── protobuf-net.Core.dll
│       ├── protobuf-net.Core.xml
│       ├── protobuf-net.Reflection.dll
│       ├── protobuf-net.Reflection.xml
│       ├── protobuf-net.dll
│       ├── protobuf-net.xml
│       ├── protogen.deps.json
│       ├── protogen.dll
│       ├── protogen.exe
│       ├── protogen.runtimeconfig.dev.json
│       ├── protogen.runtimeconfig.json
│       ├── protogen.xml
│       └── runtimes
│           └── win
│               └── lib
│                   └── netcoreapp2.1
│                       └── System.Security.Cryptography.Pkcs.dll
├── WzComparerR2
└── pictures
    ├── chart_yolov4-custom.png
    └── result.png

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Charles Cao

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`MapRender.Invoker/MapRender.Invoker.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net5.0-windows</TargetFramework>
    <PlatformTarget>x64</PlatformTarget>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Crc32C.NET" Version="1.0.5" />
    <PackageReference Include="protobuf-net" Version="3.0.101" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\MapleStory.Common\MapleStory.Common.csproj" />
    <ProjectReference Include="..\WzComparerR2\WzComparerR2.Avatar\WzComparerR2.Avatar.csproj" />
    <ProjectReference Include="..\WzComparerR2\WzComparerR2.Common\WzComparerR2.Common.csproj" />
    <ProjectReference Include="..\WzComparerR2\WzComparerR2.MapRender\WzComparerR2.MapRender.csproj" />
    <ProjectReference Include="..\WzComparerR2\WzComparerR2.PluginBase\WzComparerR2.PluginBase.csproj" />
    <ProjectReference Include="..\WzComparerR2\WzComparerR2.WzLib\WzComparerR2.WzLib.csproj" />
    <ProjectReference Include="..\WzComparerR2\WzComparerR2\WzComparerR2.csproj" />
  </ItemGroup>
  <ItemGroup>
    <Reference Include="DevComponents.DotNetBar2">
      <HintPath>..\WzComparerR2\References\DevComponents.DotNetBar2.dll</HintPath>
    </Reference>
    <Reference Include="EmptyKeys.UserInterface">
      <HintPath>..\WzComparerR2\References\EmptyKeys.UserInterface.dll</HintPath>
    </Reference>
    <Reference Include="EmptyKeys.UserInterface.Core">
      <HintPath>..\WzComparerR2\References\EmptyKeys.UserInterface.Core.dll</HintPath>
    </Reference>
    <Reference Include="MonoGame.Framework">
      <HintPath>..\WzComparerR2\References\MonoGame.Framework.dll</HintPath>
    </Reference>
  </ItemGroup>
</Project>
```

`MapRender.Invoker/MapRender.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using WzComparerR2.Animation;
using WzComparerR2.MapRender;
using WzComparerR2.MapRender.Patches;
using WzComparerR2.MapRender.Patches2;
using WzComparerR2.WzLib;

namespace MapRender.Invoker
{
    internal class MapRender : FrmMapRender2
    {
        private volatile Stream _screenShotStream;
        private volatile ScreenShotData _screenShotData;

        public MapRender(Wz_Image img) : base(img)
        {
        }

        public void ChangeResolution(int width, int height)
        {
            GraphicsDeviceManager deviceManager = this.GraphicsManager;
            deviceManager.PreferredBackBufferWidth = width;
            deviceManager.PreferredBackBufferHeight = height;
            WzComparerR2.Rendering.D2DFactory.Instance.ReleaseContext(deviceManager.GraphicsDevice);
            deviceManager.ApplyChanges();
            this.ui.Width = width;
            this.ui.Height = height;
            engine.Renderer.ResetNativeSize();
        }

        /// <summary>
        /// Take Screen, save image to stream, and return items info on the entire map.
        /// </summary>
        /// <param name="stream">Stream to save image</param>
        public ScreenShotData TakeScreenShot(Stream stream)
        {
            _screenShotStream = stream;
            while (_screenShotStream != null) ; //Wait next Draw(), yield to GetScreenShotMapData()
            var ret = _screenShotData;
            _screenShotData = null;
            return ret;
        }

        /// <summary>
        /// Switch to a new map
        /// </summary>
        /// <param name="imgId">Wz img id</param>
        public void SwitchToNewMap(int imgId)
        {
            MoveToPortal(imgId, null);
            while (!SceneRunning) ; // Wait until new map loaded
        }

        protected override void Draw(GameTime gameTime)
        {
            base.Draw(gameTime);
            if (_screenShotStream != null)
            {
                ScreenShotHelper(_screenShotStream, gameTime);
                _screenShotData = new ScreenShotData(new List<TargetItem>(), this.renderEnv.Camera.ClipRect);
                GetScreenShotMapData(mapData.Scene, ref _screenShotData);
                _screenShotStream = null;
            }
        }

        private void ScreenShotHelper(Stream destination, GameTime gameTime)
        {
            int width = GraphicsDevice.PresentationParameters.BackBufferWidth;
            int height = GraphicsDevice.PresentationParameters.BackBufferHeight;
            using RenderTarget2D target = new RenderTarget2D(GraphicsDevice, width, height, false,
                SurfaceFormat.Rgba64, DepthFormat.None);
            var oldTarget = GraphicsDevice.GetRenderTargets();
            GraphicsDevice.SetRenderTarget(target);
            GraphicsDevice.Clear(Color.Black);
            DrawScene(gameTime);
            DrawTooltipItems(gameTime);
            this.ui.Draw(gameTime.ElapsedGameTime.TotalMilliseconds);
            this.tooltip.Draw(gameTime, renderEnv);
            GraphicsDevice.SetRenderTargets(oldTarget);
            target.SaveAsPng(destination, width, height);

        }

        private void GetScreenShotMapData(SceneNode node, ref ScreenShotData screenShotData)
        {
            var itemsOnMap = screenShotData.Items;
            if (node is ContainerNode container)
            {
                foreach (var item in container.Slots)
                {
                    if (item is LifeItem life)
                    {
                        var rectangle = this.GetLifeBoundingBox(life);
                        if (rectangle.HasValue)
                        {
                            itemsOnMap.Add(new TargetItem(life, rectangle.Value, RenderObjectType.Mob) { Id = life.ID });
                        }
                    }
                }
            }
            else
            {
                for (int i = 0, total = node.Nodes.Count; i < total; ++i)
                {
                    GetScreenShotMapData(node.Nodes[i], ref screenShotData);
                }
            }
        }

    }
}

```

`MapRender.Invoker/MapRenderInvoker.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MapleStory.Common;
using Microsoft.Xna.Framework;
using WzComparerR2.Common;
using WzComparerR2.MapRender;
using WzComparerR2.PluginBase;
using WzComparerR2.WzLib;

namespace MapRender.Invoker
{
    public class MapRenderInvoker : MapRenderInvokerBase
    {
        private Wz_Image _currentMapImage;
        private StringLinker _stringLinker;
        private Thread _renderThread;
        private MapRender _mapRender;
        private Camera _camera;
        private volatile bool _isRunning;

        public bool IsRunning => _isRunning;

        public int ScreenWidth { private set; get; }

        public int ScreenHeight { private set; get; }

        public int WorldWidth => _camera.WorldRect.Width;

        public int WorldHeight => _camera.WorldRect.Height;

        public int WorldOriginX => _camera.WorldRect.X;

        public int WorldOriginY => _camera.WorldRect.Y;

        public int CurrentCameraX => (int)_camera.Center.X;

        public int CurrentCameraY => (int)_camera.Center.Y;

        public int CurrentMap { get; private set; }

        public MapRenderInvoker(string mapleStoryPath, Encoding encoding, bool disableImgCheck = false)
            : base(mapleStoryPath, encoding, disableImgCheck)
        {
            _isRunning = false;
            AddFindWzEventHandler();
        }

        /// <summary>
        /// Attach event handler to PlugManager, let it throw if reflection fail so we know there are changes in WzComparerR2
        /// </summary>
        /// <seealso cref="WzComparerR2.PluginBase.PluginManager.WzFileFinding"/>
        private void AddFindWzEventHandler()
        {
            EventInfo findWzEvent = typeof(PluginManager)
                .GetEvent("WzFileFinding", BindingFlags.Static | BindingFlags.NonPublic);
            MethodInfo findWzHandler =
                typeof(MapRenderInvoker).GetMethod("CharaSimLoader_WzFileFinding", BindingFlags.NonPublic | BindingFlags.Instance);
            Delegate findWzDelegate = Delegate.CreateDelegate(findWzEvent.EventHandlerType, this, findWzHandler);
            findWzEvent.AddMethod.Invoke(this, new[] { findWzDelegate });
        }

        ~MapRenderInvoker()
        {
            _renderThread?.Abort();
        }

        ///<inheritdoc/>
        public override void LoadMap(string imgText)
        {
            CurrentMap = int.Parse(imgText);
            imgText = imgText.EndsWith(".img") ? imgText : (imgText + ".img");
            _currentMapImage = WzTreeSearcher.SearchForMap(_wzStructure.WzNode, imgText);
            Exception ex;
            _currentMapImage.TryExtract(out ex);
            if (ex != null)
            {
                throw ex;
            }
            _stringLinker = new StringLinker();
            _stringLinker.Load(PluginManager.FindWz(Wz_Type.String).GetValueEx<Wz_File>(null));
        }

        /// <inheritdoc/>
        public override void Launch(int width, int height)
        {
            if (_currentMapImage == null)
            {
                throw new InvalidOperationException("MapRenderInvoker.LoadMap() must be called before Launch().");
            }

            _isRunning = false;
            _renderThread = new Thread(() =>
            {
                _mapRender = new MapRender(_currentMapImage) { StringLinker = _stringLinker };
                _mapRender.Window.Title = FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileName;
                try
                {
                    using (_mapRender)
                    {
                        _mapRender.RunOneFrame(); // Initialize
                        _mapRender.ChangeResolution(width, height);
                        _isRunning = true;
                        _camera = _mapRender.renderEnv.Camera;
                        _mapRender.Run();
                    }
                }
                finally
                {
                    _mapRender = null;
                }
            });
            ScreenHeight = height;
            ScreenWidth = width;
            _renderThread.SetApartmentState(ApartmentState.STA);
            _renderThread.IsBackground = true;
            _renderThread.Start();

            while (!_isRunning) ; // Wait until ready
        }

        public override void SwitchMap(string imgText)
        {
            CurrentMap = int.Parse(imgText);
            _mapRender.SwitchToNewMap(CurrentMap);
        }

        public void MoveCamera(int centerX, int centerY)
        {
            _camera.Center = new Vector2(centerX, centerY);
            _camera.AdjustToWorldRect();
        }

        public ScreenShotData TakeScreenShot(Stream stream)
        {
            return _mapRender.TakeScreenShot(stream);
        }

        #region COPIED_CODE

        /// <summary>
        /// !!!!!!!!!!!!COPIED CODE!!!!!!!!!!!!!!
        /// Version: git@github.com:Kagamia/WzComparerR2.git:f6ecfb18cae661f125a189e527feea1964f5bda8
        /// </summary>
        /// <see cref="WzComparerR2.MainForm.CharaSimLoader_WzFileFinding"/>
        private void CharaSimLoader_WzFileFinding(object sender, WzComparerR2.FindWzEventArgs e)
        {
            string[] fullPath = null;
            if (!string.IsNullOrEmpty(e.FullPath)) //用fullpath作为输入参数
            {
                fullPath = e.FullPath.Split('/', '\\');
                try
                {
                    e.WzType = (Wz_Type)Enum.Parse(typeof(Wz_Type), fullPath[0], true);
                }
                catch
                {
                    e.WzType = Wz_Type.Unknown;
                }
            }

            List<Wz_Node> preSearch = new List<Wz_Node>();
            if (e.WzType != Wz_Type.Unknown) //用wztype作为输入参数
            {
                IEnumerable<Wz_Structure> preSearchWz = e.WzFile?.WzStructure != null ?
                    Enumerable.Repeat(e.WzFile.WzStructure, 1) : new List<Wz_Structure>() { _wzStructure };
                foreach (var wzs in preSearchWz)
                {
                    Wz_File baseWz = null;
                    bool find = false;
                    foreach (Wz_File wz_f in wzs.wz_files)
                    {
                        if (wz_f.Type == e.WzType)
                        {
                            preSearch.Add(wz_f.Node);
                            find = true;
                            //e.WzFile = wz_f;
                        }
                        if (wz_f.Type == Wz_Type.Base)
                        {
                            baseWz = wz_f;
                        }
                    }

                    // detect data.wz
                    if (baseWz != null && !find)
                    {
                        string key = e.WzType.ToString();
                        foreach (Wz_Node node in baseWz.Node.Nodes)
                        {
                            if (node.Text == key && node.Nodes.Count > 0)
                            {
                                preSearch.Add(node);
                            }
                        }
                    }
                }
            }

            if (fullPath == null || fullPath.Length <= 1)
            {
                if (e.WzType != Wz_Type.Unknown && preSearch.Count > 0) //返回wzFile
                {
                    e.WzNode = preSearch[0];
                    e.WzFile = preSearch[0].Value as Wz_File;
                }
                return;
            }

            if (preSearch.Count <= 0)
            {
                return;
            }

            foreach (var wzFileNode in preSearch)
            {
                var searchNode = wzFileNode;
                for (int i = 1; i < fullPath.Length && searchNode != null; i++)
                {
                    searchNode = searchNode.Nodes[fullPath[i]];
                    var img = searchNode.GetValueEx<Wz_Image>(null);
                    if (img != null)
                    {
                        searchNode = img.TryExtract() ? img.Node : null;
                    }
                }

                if (searchNode != null)
                {
                    e.WzNode = searchNode;
                    e.WzFile = wzFileNode.Value as Wz_File;
                    return;
                }
            }
            //寻找失败
            e.WzNode = null;
        }
        #endregion
    }

    public abstract class MapRenderInvokerBase
    {

        protected readonly Wz_Structure _wzStructure;

        protected MapRenderInvokerBase(string mapleStoryPath, Encoding encoding, bool disableImgCheck = false)
        {
            // Static settings for Wz_Structure :(
            Wz_Structure.DefaultAutoDetectExtFiles = true;
            Wz_Structure.DefaultEncoding = encoding;
            Wz_Structure.DefaultImgCheckDisabled = disableImgCheck;
            // Then our constructor
            string baseWzPath = Path.Combine(mapleStoryPath, MapleStoryPathHelper.MapleStoryBaseWzName);
            if (!File.Exists(baseWzPath))
            {
                throw new ArgumentException($"Cannot find {MapleStoryPathHelper.MapleStoryBaseWzName} in given directory {mapleStoryPath}.");
            }
            _wzStructure = new Wz_Structure();
            _wzStructure.Load(baseWzPath, true);
        }

        /// <summary>
        /// Load specified Wz map img to this invoker.
        /// </summary>
        /// <param name="imgText">The map node search. E.g. "450007010" </param>
        /// <exception cref="MapleStory.Common.Exceptions.WzImgNotFoundException">If supplied img cannot be found.</exception>
        public abstract void LoadMap(string imgText);

        /// <summary>
        /// Lunch map render. Make sure we have loaded img.
        /// </summary>
        /// <param name="width">Width of resolution</param>
        /// <param name="height">Height of resolution</param>
        public abstract void Launch(int width, int height);

        /// <summary>
        /// Switch to a new map after <see cref="Launch"/>
        /// </summary>
        /// <param name="imgText">The map node search. E.g. "450007010" </param>
        public abstract void SwitchMap(string imgText);

    }
}

```

`MapRender.Invoker/ObjectClass.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MapRender.Invoker
{
    public enum ObjectClass
    {
        Mob = 1,
        Player,
        Npc,
        InMapPortal,
        CrossMapPortal,
        Foothold,
        LadderRope,
        Unknown
    }
}

```

`MapRender.Invoker/ScreenShotData.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MapRender.Invoker
{
    public class ScreenShotData
    {
        public List<TargetItem> Items { get; private set; }

        public Rectangle CameraRectangle { get; private set; }

        public ScreenShotData(List<TargetItem> items, Microsoft.Xna.Framework.Rectangle camRectangle)
        {
            Items = items;
            CameraRectangle = new Rectangle(camRectangle.X, camRectangle.Y, camRectangle.Width, camRectangle.Height);
        }
    }
}

```

`MapRender.Invoker/TargetItem.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using WzComparerR2.MapRender.Patches;
using WzComparerR2.MapRender.Patches2;

namespace MapRender.Invoker
{
    //Object detection interests item
    public class TargetItem : SceneItem
    {
        public int Id { get; set; }

        public int X { get; set; }

        public int Y { get; set; }

        public ObjectClass Type { get; set; }

        public int Width { get; set; }

        public int Height { get; set; }

        public TargetItem() { }

        public TargetItem(SceneItem item)
        {
            Name = item.Name;
            Index = item.Index;
            Tag = item.Tag;
        }

        public TargetItem(SceneItem item, Rectangle rectangle) : this(item)
        {
            X = rectangle.X;
            Y = rectangle.Y;
            Width = rectangle.Width;
            Height = rectangle.Height;
        }

        public TargetItem(SceneItem item, Rectangle rectangle, RenderObjectType type) : this(item, rectangle)
        {
            Type = RenderTypeToObjectClass(type);
        }

        public static ObjectClass RenderTypeToObjectClass(RenderObjectType type)
        {
            switch (type)
            {
                case RenderObjectType.Mob:
                    return ObjectClass.Mob;
                case RenderObjectType.Foothold:
                    return ObjectClass.Foothold;
                case RenderObjectType.Npc:
                    return ObjectClass.Npc;
                case RenderObjectType.LadderRope:
                    return ObjectClass.LadderRope;
                case RenderObjectType.Portal:
                    return ObjectClass.CrossMapPortal; //TODO: Classify portal
            }
            return ObjectClass.Unknown;
        }

    }
}

```

`MapleStory.Common/Exceptions/WzImgNotFoundException.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;

namespace MapleStory.Common.Exceptions
{
    /// <summary>
    /// Simple exception class indicating specified Wz Img cannot be found.
    /// </summary>
    public class WzImgNotFoundException : Exception
    {
        public WzImgNotFoundException()
        {
        }

        public WzImgNotFoundException(string message) : base(message)
        {
        }

        public WzImgNotFoundException(string message, Exception innerException) : base(message, innerException)
        {
        }

        protected WzImgNotFoundException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }
    }
}

```

`MapleStory.Common/MapleStory.Common.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net5.0-windows</TargetFramework>
    <PlatformTarget>x64</PlatformTarget>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Win32.Registry" Version="5.0.0" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\WzComparerR2\WzComparerR2.Common\WzComparerR2.Common.csproj" />
    <ProjectReference Include="..\WzComparerR2\WzComparerR2.WzLib\WzComparerR2.WzLib.csproj" />
  </ItemGroup>
</Project>
```

`MapleStory.Common/MapleStoryPathHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Win32;

namespace MapleStory.Common
{
    /// <summary>
    /// Helper class for finding MapleStory's path. 
    /// </summary>
    public static class MapleStoryPathHelper
    {
        private static readonly string REG_KEY_PATH =
            @"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\MapleStory"; // Tested for CMS

        private static readonly string REG_VALUE_NAME = @"UninstallString";

        public static readonly string MapleStoryExecutableName = @"MapleStory.exe";

        public static readonly string MapleStoryBaseWzName = @"Base.wz";

        private static readonly Lazy<string> _mapleStoryInstallDirectory = new Lazy<string>(() =>
        {
            try
            {
                RegistryKey key = Registry.LocalMachine.OpenSubKey(REG_KEY_PATH); // Possible null
                string uninstallPath = key.GetValue(REG_VALUE_NAME) as string; // Possible invalid cast
                return Path.GetDirectoryName(uninstallPath); // Possible corrupted path
            }
            catch (Exception ex) when (ex is NullReferenceException || ex is InvalidCastException || ex is ArgumentException)
            {
                return string.Empty;
            }
        });

        /// <summary>
        /// Indicate if MapleStory installed location was found.
        /// </summary>
        public static bool FoundMapleStoryInstalled => Directory.Exists(_mapleStoryInstallDirectory.Value);

        /// <summary>
        /// Get MapleStory installed folder based on registry, might fail if no elevate privilege, in which case it will return empty string.
        /// </summary>
        public static string MapleStoryInstallDirectory => _mapleStoryInstallDirectory.Value;

    }
}

```

`MapleStory.Common/WzTreeSearcher.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WzComparerR2.WzLib;
using MapleStory.Common.Exceptions;

namespace MapleStory.Common
{
    public static class WzTreeSearcher
    {
        /// <summary>
        /// Generic searching based on BFS traversal. This is tree-search (only search for children).
        /// </summary>
        /// <param name="root">Root of target tree. The origin of search.</param>
        /// <param name="determinator">Return true if the input node meet search criteria.</param>
        /// <returns>Null if not found, otherwise the target node.</returns>
        public static Wz_Node GenericBfsSearcher(Wz_Node root, Func<Wz_Node, bool> determinator)
        {
            Queue<Wz_Node> queue = new Queue<Wz_Node>();
            queue.Enqueue(root);
            while (queue.Count != 0)
            {
                Wz_Node currNode = queue.Dequeue();
                if (determinator(currNode))
                {
                    return currNode;
                }
                foreach (var child in currNode.Nodes)
                {
                    queue.Enqueue(child);
                }
            }
            return null;
        }

        /// <summary>
        /// Search for specified map Img starting from Base.wz root.
        /// </summary>
        /// <param name="root">The root of Base.wz.</param>
        /// <param name="imgText">The node text to search. E.g. "450007010.img" </param>
        /// <returns>The Wz img containing desired map.</returns>
        /// <exception cref="WzImgNotFoundException">If not found.</exception>
        public static Wz_Image SearchForMap(Wz_Node root, string imgText)
        {
            if (!imgText.Contains(".img"))
            {
                throw new ArgumentException("Supplied imgText is not legal.", nameof(imgText));
            }
            // Filter map nodes, and find string wz file.
            IEnumerable<Wz_Node> mapNodes = root.Nodes
                .Where(n => n.GetNodeWzFile().Type == Wz_Type.Map);
            // Do search on each map node
            foreach (var mapRoot in mapNodes)
            {
                Wz_Node result = GenericBfsSearcher(mapRoot, (node) => node.Text == imgText);
                if (result != null)
                {
                    return result.GetNodeWzImage();
                }
            }
            // Throw if not found.
            throw new WzImgNotFoundException(string.Format("Target Img {0} cannot be found.", imgText));
        }

    }
}

```

`MapleStory.MachineLearningSampleGenerator/MapleStory.MachineLearningSampleGenerator.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <TargetFramework>net5.0-windows</TargetFramework>
        <UseWindowsForms>true</UseWindowsForms>
        <PlatformTarget>x64</PlatformTarget>
        <OutputType>Exe</OutputType>
    </PropertyGroup>
    <ItemGroup>
        <PackageReference Include="CommandLineParser" Version="2.8.0" />
    </ItemGroup>
    <ItemGroup>
        <ProjectReference Include="..\MapleStory.Sampler\MapleStory.Sampler.csproj" />
    </ItemGroup>
    <Target Name="PreBuild" BeforeTargets="PreBuildEvent">
      <Exec Command="xcopy &quot;$(ProjectDir)..\WzComparerR2\WzComparerR2\bin\$(Configuration)\*&quot; &quot;$(TargetDir)&quot; /I /Y /S" />
    </Target>
</Project>
```

`MapleStory.MachineLearningSampleGenerator/OutputFormat.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MapleStory.MachineLearningSampleGenerator
{
    internal enum OutputFormat
    {
        TfRecord,
        Darknet,
        Coco
    }
}

```

`MapleStory.MachineLearningSampleGenerator/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using CommandLine;
using CommandLine.Text;
using MapleStory.Common;
using MapleStory.Sampler;
using MapleStory.Sampler.PostProcessor;
using MapRender.Invoker;

namespace MapleStory.MachineLearningSampleGenerator
{
    internal static class Program
    {
        [DllImport("kernel32.dll")]
        static extern bool SetDllDirectory(string path);

        [DllImport("kernel32")]
        static extern bool AllocConsole();

        [DllImport("kernel32.dll")]
        static extern bool AttachConsole(int dwProcessId);

        [DllImport("kernel32.dll")]
        static extern bool FreeConsole();

        [DllImport("kernel32.dll")]
        static extern IntPtr GetConsoleWindow();

        static Program()
        {
            AttachConsole(-1); // Try to attach to parent process's console
            if (GetConsoleWindow() == IntPtr.Zero)
            {
                AllocConsole();
            }

            Console.OutputEncoding = Encoding.UTF8; // Correctly show non-English characters
            string libPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Lib",
                Environment.Is64BitProcess ? "x64" : "x86");
            SetDllDirectory(libPath); // Add dll search path for WzComparerR2
        }

        private class Options
        {
            [Option('m', "map", Required = true, HelpText = "Space-separated Wz image ID of map(s) used for generating TFRecord.")]
            public IEnumerable<string> Maps { get; set; }

            [Option('x', "xStep", Required = true, HelpText = "Step in X.")]
            public int StepX { get; set; }

            [Option('y', "yStep", Required = true, HelpText = "Step in Y.")]
            public int StepY { get; set; }

            [Option('f', "format", Required = true, HelpText = "Output format, must be one of: [tfrecord, darknet, coco]")]
            public string Format { get; set; }

            [Option('o', "output", Required = false, Default = ".", HelpText = "Data set output location")]
            public string OutputPath { get; set; }

            [Option('w', "width", Required = false, Default = 1366, HelpText = "Width of sample image.")]
            public int RenderWidth { get; set; }

            [Option('h', "height", Required = false, Default = 768, HelpText = "Height of sample image.")]
            public int RenderHeight { get; set; }

            [Option('i', "interval", Required = false, Default = 0, HelpText = "Time interval in ms between each sample")]
            public int SampleInterval { get; set; }

            [Option('p', "path", Required = false, Default = "", HelpText = "MapleStory Installed Path")]
            public string MapleStoryPath { get; set; }

            [Option("post", Required = false, Default = "", HelpText = "Indicate whether to enable post-processing.")]
            public bool PostProcessingEnable { get; set; }

            [Option("players", Required = false, Default = "", HelpText = "Directory where the post-processing player images stored.")]
            public string PlayerImageDirectory { get; set; }

            [Option('e', "encoding", Required = false, HelpText = "Encoding used to decode Wz strings. Using system default if not specified.")]
            public string Encoding { get; set; } = "";
        }

        [STAThread]
        private static int Main(string[] args)
        {
            int ret = CommandLine.Parser.Default.ParseArguments<Options>(args).MapResult(RunAndReturn, OnParseError);
            Console.WriteLine("MapleStory_TFRecord_Preparer exited with code= {0}", ret);
            FreeConsole();
            return ret;
        }

        private static int OnParseError(IEnumerable<Error> errors)
        {
            foreach (var error in errors)
            {
                Console.Error.WriteLine(Enum.GetName(typeof(ErrorType), error.Tag));
            }
            return -1;
        }

        /// <summary>
        /// Main logic here
        /// </summary>
        private static int RunAndReturn(Options options)
        {
            // Print program info
            Console.WriteLine(HeadingInfo.Default);
            Console.WriteLine(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).LegalCopyright);
            // Check arguments
            PreRunTest(options);
            Console.WriteLine("MapleStory Location: {0}", options.MapleStoryPath);
            // Initialize render
            MapRenderInvoker renderInvoker = new MapRenderInvoker(options.MapleStoryPath,
                options.Encoding == string.Empty ? Encoding.Default : Encoding.GetEncoding(options.Encoding),
                false);
            Queue<string> maps = new Queue<string>(options.Maps);
            var first = maps.Dequeue();
            renderInvoker.LoadMap(first);
            renderInvoker.Launch(options.RenderWidth, options.RenderHeight);
            // Initialize sampler
            IDatasetWriter writer = GetDatasetWriter(options, first);
            Sampler.Sampler sampler = new Sampler.Sampler(renderInvoker);
            if (options.PostProcessingEnable && options.PlayerImageDirectory != "")
            {
                IPostProcessor postProcessor = new PlayerProcessor(options.PlayerImageDirectory);
                sampler.OnSampleCaptured += (s, e) => postProcessor.Process(s);
            }

            while (true)
            {
                sampler.SampleAll(options.StepX, options.StepY, writer, options.SampleInterval);
                if (maps.Count == 0)
                {
                    break;
                }
                renderInvoker.SwitchMap(maps.Dequeue());
            }
            writer.Finish();
            return 0;
        }


        /// <summary>
        /// Throw if condition not meet.
        /// </summary>
        private static void PreRunTest(Options options)
        {
            // Check resolution
            if (options.RenderHeight <= 0)
            {
                throw new ArgumentException("Render size cannot exceed screen size. Height illegal.",
                    nameof(options.RenderHeight));
            }
            if (options.RenderWidth <= 0)
            {
                throw new ArgumentException("Render size cannot exceed screen size. Width illegal.",
                    nameof(options.RenderWidth));
            }

            // Check format
            Enum.Parse(typeof(OutputFormat), options.Format, true);

            // Check file path
            if (options.MapleStoryPath == string.Empty)
            {
                if (MapleStoryPathHelper.FoundMapleStoryInstalled)
                {
                    options.MapleStoryPath = MapleStoryPathHelper.MapleStoryInstallDirectory;
                }
                else
                {
                    throw new ArgumentException("Cannot find MapleStory installed location. Please specify it in commandline or retry as Administrator.");
                }
            }
            else if (!Directory.Exists(options.MapleStoryPath))
            {
                throw new ArgumentException("Supplied MapleStory directory does not exist.");
            }

            // Check map id format
            foreach (var map in options.Maps)
            {
                string id = map.Replace(".img", string.Empty);
                if (!id.All(char.IsDigit))
                {
                    throw new ArgumentException("Supplied Map Id is not in correct format." +
                                                " --map parameter should be space-separated list of IDs. " +
                                                "E.g. --map 450007010 450007060");
                }
            }

            // Check encoding
            if ((options.Encoding != string.Empty) &&
                Encoding.GetEncodings()
                .Any(e => e.Name.Equals(options.Encoding, StringComparison.OrdinalIgnoreCase)))
            {
                throw new ArgumentException($"{options.Encoding} is not an available Encoding in your system.");
            }

            // Check output path
            if (!Directory.Exists(options.OutputPath))
            {
                throw new ArgumentException($"OutputPath {options.OutputPath} does not exist.");
            }

            // Check interval
            if (options.SampleInterval < 0)
            {
                throw new ArgumentException("SampleInterval cannot be negative!");
            }

            // Check for post-processing
            if (options.PostProcessingEnable)
            {
                if (options.PlayerImageDirectory != "")
                {
                    if (!Directory.Exists(options.PlayerImageDirectory))
                    {
                        throw new ArgumentException($"PlayerImageDirectory {options.PlayerImageDirectory} cannot be found!");
                    }
                }
            }
        }

        private static IDatasetWriter GetDatasetWriter(Options options, string map)
        {
            switch (Enum.Parse(typeof(OutputFormat), options.Format, true))
            {
                case OutputFormat.TfRecord:
                    return new TfRecordWriter(Path.Combine(options.OutputPath, map));
                case OutputFormat.Darknet:
                    return new DarknetWriter(options.OutputPath);
                case OutputFormat.Coco:
                    return new CocoWriter(options.OutputPath, $"MapleStory {map}.img Object Detection Samples");
                default:
                    throw new ArgumentOutOfRangeException(nameof(options), options, null);
            }
        }

    }
}

```

`MapleStory.Sampler/CocoWriter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using MapRender.Invoker;

namespace MapleStory.Sampler
{
    public class CocoWriter : IDatasetWriter
    {
        private const double DefaultTestingPortion = 0.05;
        private const string DefaultRootDirectory = "coco";
        private const string TrainingDirectory = "train2017";
        private const string ValidationDirectory = "val2017";
        private const string AnnotationDirectory = "annotations";
        private const string TrainingJson = "instances_train2017.json";
        private const string ValidationJson = "instances_val2017.json";

        public string RootPath { get; }

        public string AnnotationsPath { get; }

        private readonly string _trainingImagesPath;
        private readonly string _validationImagesPath;
        private readonly Random _random;
        private readonly List<ObjectClass> _occurrenceClasses;
        private readonly string _datasetName;
        private readonly List<CocoImage> _trainingImages;
        private readonly List<CocoImage> _validationImages;
        private readonly List<CocoCategory> _categories;
        private readonly List<CocoAnnotation> _trainingAnnotations;
        private readonly List<CocoAnnotation> _validationAnnotations;

        public CocoWriter(string path, string name)
        {
            if (!Directory.Exists(path))
            {
                Console.WriteLine($"Target path {path} does not exist. Creating one...");
                Directory.CreateDirectory(path);
            }
            RootPath = Path.Combine(path, DefaultRootDirectory);
            if (!Directory.Exists(RootPath))
            {
                Directory.CreateDirectory(RootPath);
            }
            CleanDirectory(RootPath);
            _trainingImagesPath = Path.Combine(RootPath, TrainingDirectory);
            Directory.CreateDirectory(_trainingImagesPath);
            _validationImagesPath = Path.Combine(RootPath, ValidationDirectory);
            Directory.CreateDirectory(_validationImagesPath);
            AnnotationsPath = Path.Combine(RootPath, AnnotationDirectory);
            Directory.CreateDirectory(AnnotationsPath);

            _random = new Random();
            _occurrenceClasses = new List<ObjectClass>();
            _datasetName = name;
            _trainingImages = new List<CocoImage>();
            _validationImages = new List<CocoImage>();
            _validationAnnotations = new List<CocoAnnotation>();
            _categories = new List<CocoCategory>();
            _trainingAnnotations = new List<CocoAnnotation>();
            _validationAnnotations = new List<CocoAnnotation>();
        }

        public void Write(Sample sample)
        {
            double rand = _random.NextDouble();
            List<CocoAnnotation> annotationsToAdd;
            List<CocoImage> imagesToAdd;
            string pathToWrite;
            if (rand < DefaultTestingPortion)
            {
                annotationsToAdd = _validationAnnotations;
                imagesToAdd = _validationImages;
                pathToWrite = _validationImagesPath;
            }
            else
            {
                annotationsToAdd = _trainingAnnotations;
                imagesToAdd = _trainingImages;
                pathToWrite = _trainingImagesPath;
            }
            // Write image
            string jpgFileName = sample.Guid + ".jpg";
            using FileStream imageStream = new FileStream(Path.Combine(pathToWrite, jpgFileName), FileMode.CreateNew);
            sample.ImageStream.WriteTo(imageStream);
            imageStream.Flush();
            CocoImage cocoImage = new CocoImage(jpgFileName, sample.Width, sample.Height);
            imagesToAdd.Add(cocoImage);

            // Write annotations
            GetAnnotationFromSample(sample, cocoImage.Id, ref annotationsToAdd);
        }

        public void Finish()
        {
            CocoLicense license = new CocoLicense();
            // Write training set
            CocoJson trainingJson = new CocoJson(new CocoInfo($"{_datasetName} - Training"),
                license,
                _trainingImages,
                _categories,
                _trainingAnnotations);
            using FileStream trainingStream =
                new FileStream(Path.Combine(AnnotationsPath, TrainingJson), FileMode.CreateNew);
            using Utf8JsonWriter trainingWriter = new Utf8JsonWriter(trainingStream);
            JsonSerializer.Serialize(trainingWriter, trainingJson);

            // Write validation set
            CocoJson validationJson = new CocoJson(new CocoInfo($"{_datasetName} - Training"),
                license,
                _validationImages,
                _categories,
                _validationAnnotations);
            using FileStream validationStream =
                new FileStream(Path.Combine(AnnotationsPath, ValidationJson), FileMode.CreateNew);
            using Utf8JsonWriter validationWriter = new Utf8JsonWriter(validationStream);
            JsonSerializer.Serialize(validationWriter, validationJson);

            // Flush buffer (if any)
            trainingWriter.Flush();
            trainingStream.Flush();
            validationWriter.Flush();
            validationStream.Flush();
        }

        private void GetAnnotationFromSample(Sample sample, int imageId, ref List<CocoAnnotation> dstList)
        {
            foreach (var sampleItem in sample.Items)
            {
                ObjectClass type = sampleItem.Type;
                if (!_occurrenceClasses.Contains(type))
                {
                    _occurrenceClasses.Add(type);
                    _categories.Add(new CocoCategory("element", type.ToString()));
                }
                int categoryId = _occurrenceClasses.IndexOf(type) + 1;
                CocoAnnotation toAdd = new CocoAnnotation(imageId, sampleItem.X, sampleItem.Y, sampleItem.Width,
                    sampleItem.Height, categoryId);
                dstList.Add(toAdd);
            }
        }

        private static void CleanDirectory(string path)
        {
            if (Directory.EnumerateFileSystemEntries(path).Any())
            {
                Console.WriteLine("Warning: Target RootPath Is Not Empty. Cleaning target path...");
                DirectoryInfo directory = new DirectoryInfo(path);
                foreach (var fileInfo in directory.GetFiles())
                {
                    fileInfo.Delete();
                }
                foreach (var directoryInfo in directory.GetDirectories())
                {
                    directoryInfo.Delete(true);
                }
            }
        }

        #region JsonDefinitions
        private class CocoInfo
        {
            [JsonPropertyName("description")]
            public string Description { get; }

            [JsonPropertyName("url")]
            public string Url { get; } = @"https://github.com/charlescao460/MapleStoryDetectionSampleGenerator";

            [JsonPropertyName("version")]
            public string Version { get; } = "1.0";

            [JsonPropertyName("year")]
            public int Year { get; } = DateTime.Today.Year;

            [JsonPropertyName("contributor")]
            public string Contributor { get; } = "CSR";

            [JsonPropertyName("date_created")]
            public string DateCreated = DateTime.Today.ToLongDateString();

            public CocoInfo(string description)
            {
                Description = description;
            }
        }

        private class CocoLicense
        {
            [JsonPropertyName("url")]
            public string Url { get; } = @"https://github.com/charlescao460/MapleStoryDetectionSampleGenerator/blob/master/LICENSE";

            [JsonPropertyName("id")]
            public int Id { get; } = 1;

            [JsonPropertyName("name")]
            public string Name { get; } = "MIT License";
        }

        private class CocoImage
        {
            [JsonPropertyName("license")]
            public int License { get; } = 1;

            [JsonPropertyName("file_name")]
            public string FileName { get; }

            [JsonPropertyName("coco_url")]
            public string CocoUrl { get; } = string.Empty;

            [JsonPropertyName("height")]
            public int Height { get; }

            [JsonPropertyName("width")]
            public int Width { get; }

            [JsonPropertyName("date_captured")]
            public string DateCaptured = $"{DateTime.Now:G}";

            [JsonPropertyName("flickr_url")]
            public string FlickrUrl { get; } = string.Empty;

            [JsonPropertyName("id")]
            public int Id { get; }

            private static int _count = 1;

            public CocoImage(string fileName, int width, int height)
            {
                FileName = fileName;
                Width = width;
                Height = height;
                Id = _count++;
            }
        }

        private class CocoCategory
        {
            [JsonPropertyName("supercategory")]
            public string SuperCategory { get; }

            [JsonPropertyName("id")]
            public int Id { get; }

            [JsonPropertyName("name")]
            public string Name { get; }

            private static int _count = 1;

            public CocoCategory(string superCategory, string name)
            {
                SuperCategory = superCategory;
                Name = name;
                Id = _count++;
            }
        }

        private class CocoAnnotation
        {
            [JsonPropertyName("segmentation")]
            public float[][] Segmentation { get; }

            [JsonPropertyName("area")]
            public float Area { get; }

            [JsonPropertyName("iscrowd")]
            public int IsCrowd { get; } = 0;

            [JsonPropertyName("image_id")]
            public int ImageId { get; }

            [JsonPropertyName("bbox")]
            public float[] Bbox { get; }

            [JsonPropertyName("category_id")]
            public int CategoryId { get; }

            [JsonPropertyName("id")]
            public int Id { get; }

            private static int _count = 1;

            public CocoAnnotation(int imageId, float x, float y, float width, float height, int categoryId)
            {
                Segmentation = new float[][]
                {
                    new float[] { x, y, x + width, y, x + width, y + height, x, y + height }
                };
                Area = width * height;
                ImageId = imageId;
                Bbox = new float[] { x, y, width, height };
                CategoryId = categoryId;
                Id = _count++;
            }
        }

        private class CocoJson
        {
            [JsonPropertyName("info")]
            public CocoInfo Info { get; }

            [JsonPropertyName("licenses")]
            public CocoLicense[] Licenses { get; }

            [JsonPropertyName("images")]
            public IList<CocoImage> Images { get; }

            [JsonPropertyName("categories")]
            public IList<CocoCategory> Categories { get; }

            [JsonPropertyName("annotations")]
            public IList<CocoAnnotation> Annotations { get; }

            public CocoJson(CocoInfo info, CocoLicense license, IList<CocoImage> images, IList<CocoCategory> categories,
                IList<CocoAnnotation> annotations)
            {
                Info = info;
                Licenses = new[] { license };
                Images = images;
                Categories = categories;
                Annotations = annotations;
            }
        }

        #endregion
    }
}

```

`MapleStory.Sampler/DarknetWriter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MapRender.Invoker;

namespace MapleStory.Sampler
{
    public class DarknetWriter : IDatasetWriter, IDisposable
    {
        private const double DefaultTestingPortion = 0.05;

        private const string DefaultRootDirectory = "data";
        private const string ClassNamesFile = "obj.names";
        private const string ObjectDataFile = "obj.data";
        private const string TrainingDataFile = "train.txt";
        private const string TestingDataFile = "test.txt";
        private const string ObjDirectory = "obj";

        private readonly List<ObjectClass> _occurrenceClasses;
        private bool _isFinished;
        private bool _disposed;
        private readonly StreamWriter _trainingDataListWriter;
        private readonly StreamWriter _testingDataListWriter;
        private readonly Random _random;

        public string RootPath { get; }

        public string ObjPath { get; }

        public DarknetWriter(string path)
        {
            if (!Directory.Exists(path))
            {
                Console.WriteLine($"Target path {path} does not exist. Creating one...");
                Directory.CreateDirectory(path);
            }
            RootPath = Path.Combine(path, DefaultRootDirectory);
            if (!Directory.Exists(RootPath))
            {
                Directory.CreateDirectory(RootPath);
            }
            CleanDirectory(RootPath);
            ObjPath = Path.Combine(RootPath, ObjDirectory);
            Directory.CreateDirectory(ObjPath);
            _occurrenceClasses = new List<ObjectClass>();
            _isFinished = false;
            _random = new Random();
            _trainingDataListWriter = new StreamWriter(new FileStream(Path.Combine(RootPath, TrainingDataFile), FileMode.CreateNew));
            _trainingDataListWriter.AutoFlush = true;
            _testingDataListWriter = new StreamWriter(new FileStream(Path.Combine(RootPath, TestingDataFile), FileMode.CreateNew));
            _testingDataListWriter.AutoFlush = true;
        }


        public void Write(Sample sample)
        {
            // Write training list
            string dataLine = $"{DefaultRootDirectory}/{ObjDirectory}/{sample.Guid + ".jpg"}";
            StreamWriter destination = _random.NextDouble() < DefaultTestingPortion
                ? _testingDataListWriter
                : _trainingDataListWriter;
            destination.WriteLine(dataLine);
            destination.Flush();

            // Write images
            using (FileStream imageStream =
                new FileStream(Path.Combine(ObjPath, sample.Guid + ".jpg"), FileMode.CreateNew))
            {
                sample.ImageStream.WriteTo(imageStream);
            }
            // Write labels
            using (FileStream lableStream =
                new FileStream(Path.Combine(ObjPath, sample.Guid + ".txt"), FileMode.CreateNew))
            {
                using (StreamWriter lableStreamWriter = new StreamWriter(lableStream))
                {
                    WriteItems(sample, lableStreamWriter);
                }
            }
        }

        public void Finish()
        {
            WriteObjData();
            WriteClassNames();
            _trainingDataListWriter.Flush();
            _testingDataListWriter.Flush();
            _isFinished = true;
        }

        /// <summary>
        /// Write to imageName.txt
        /// </summary>
        /// <seealso cref="https://github.com/AlexeyAB/darknet#how-to-train-with-multi-gpu"/>
        private void WriteItems(Sample sample, StreamWriter writer)
        {
            double width = sample.Width;
            double height = sample.Height;
            foreach (var sampleItem in sample.Items)
            {
                ObjectClass type = sampleItem.Type;
                if (!_occurrenceClasses.Contains(type))
                {
                    _occurrenceClasses.Add(type);
                }

                double xCenter = ((double)sampleItem.X + sampleItem.Width / 2.0) / width;
                double yCenter = ((double)sampleItem.Y + sampleItem.Height / 2.0) / height;
                double sampleWidth = sampleItem.Width / width;
                double sampleHeight = sampleItem.Height / height;
                double[] numbers = { xCenter, yCenter, sampleWidth, sampleHeight };
                if (numbers.Any(n => n < 0 || n > 1))
                {
                    throw new InvalidDataException("Size and coordinates must be positive number smaller than 1");
                }

                writer.Write(_occurrenceClasses.IndexOf(type)); // <object-class>
                writer.Write(' ');
                writer.Write(xCenter); // <x_center>
                writer.Write(' ');
                writer.Write(yCenter); // <y_center>
                writer.Write(' ');
                writer.Write(sampleWidth); // <width>
                writer.Write(' ');
                writer.Write(sampleHeight); // <height>
                writer.WriteLine();
            }
        }

        private static void CleanDirectory(string path)
        {
            if (Directory.EnumerateFileSystemEntries(path).Any())
            {
                Console.WriteLine("Warning: Target RootPath Is Not Empty. Cleaning target path...");
                DirectoryInfo directory = new DirectoryInfo(path);
                foreach (var fileInfo in directory.GetFiles())
                {
                    fileInfo.Delete();
                }
                foreach (var directoryInfo in directory.GetDirectories())
                {
                    directoryInfo.Delete(true);
                }
            }
        }

        private void WriteObjData()
        {
            using (FileStream file = new FileStream(Path.Combine(RootPath, ObjectDataFile), FileMode.CreateNew))
            {
                using (StreamWriter writer = new StreamWriter(file))
                {
                    writer.WriteLine($"classes={_occurrenceClasses.Count}");
                    writer.WriteLine($"train={DefaultRootDirectory}/{TrainingDataFile}");
                    writer.WriteLine($"valid={DefaultRootDirectory}/{TestingDataFile}");
                    writer.WriteLine($"names={DefaultRootDirectory}/{ClassNamesFile}");
                    writer.WriteLine(@"backup = backup/");
                }
            }
        }

        private void WriteClassNames()
        {
            using (FileStream file = new FileStream(Path.Combine(RootPath, ClassNamesFile), FileMode.CreateNew))
            {
                using (StreamWriter writer = new StreamWriter(file))
                {
                    foreach (var occurenceClass in _occurrenceClasses)
                    {
                        writer.WriteLine(Enum.GetName(typeof(ObjectClass), occurenceClass));
                    }
                }
            }
        }

        public void Dispose()
        {
            if (!_isFinished)
            {
                Finish();
            }
            _trainingDataListWriter.Dispose();
            _testingDataListWriter.Dispose();
            _disposed = true;
        }

        ~DarknetWriter()
        {
            if (!_disposed)
            {
                Dispose();
            }
        }

    }
}

```

`MapleStory.Sampler/IDatasetWriter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MapleStory.Sampler
{
    public interface IDatasetWriter
    {
        void Write(Sample sample);

        void Finish();
    }
}

```

`MapleStory.Sampler/MapleStory.Sampler.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net5.0-windows</TargetFramework>
    <PlatformTarget>x64</PlatformTarget>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="System.Drawing.Common" Version="5.0.2" />
    <PackageReference Include="System.Text.Json" Version="5.0.2" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\MapRender.Invoker\MapRender.Invoker.csproj" />
  </ItemGroup>
  <Target Name="PostBuild" AfterTargets="PostBuildEvent">
    <Exec Command="cd $(ProjectDir)protobuf&#xD;&#xA;$(ProjectDir)..\Tools\protogen\protogen.exe --csharp_out=.\  feature.proto&#xD;&#xA;$(ProjectDir)..\Tools\protogen\protogen.exe --csharp_out=.\  example.proto" />
  </Target>
</Project>
```

`MapleStory.Sampler/PostProcessor/IPostProcessor.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MapleStory.Sampler.PostProcessor
{
    /// <summary>
    /// Interface for post-processor of samples
    /// </summary>
    public interface IPostProcessor
    {
        /// <summary>
        /// Post-process the sample. Post-processing could be adding items, resizing, etc..
        /// </summary>
        /// <param name="sample"> Sample before processing. </param>
        /// <returns> Sample after processing. </returns>
        Sample Process(Sample sample);
    }
}

```

`MapleStory.Sampler/PostProcessor/PlayerProcessor.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MapRender.Invoker;

namespace MapleStory.Sampler.PostProcessor
{
    /// <summary>
    /// Post-processor by adding player images and coordinates.
    /// </summary>
    public class PlayerProcessor : IPostProcessor
    {
        private const double VerticalRange = 0.85;
        private const double HorizontalRange = 0.85;

        private IEnumerable<Image> _playerImages;
        private int _numImages;
        private Random _random;

        public PlayerProcessor(string directory)
        {
            if (!Directory.Exists(directory))
            {
                throw new FileNotFoundException($"{directory} is not a valid directory!");
            }
            _random = new Random();
            _playerImages = Directory.GetFiles(directory, "*.bmp").Select(Image.FromFile);
            _numImages = _playerImages.Count();
            if (_numImages == 0)
            {
                throw new FileNotFoundException($"{directory} does not contain any .bmp images!");
            }
        }

        public Sample Process(Sample sample)
        {
            int drawX = _random.Next((int)(sample.Width * (1 - HorizontalRange)), (int)(sample.Width * HorizontalRange));
            int drawY = _random.Next((int)(sample.Height * (1 - VerticalRange)), (int)(sample.Height * VerticalRange));
            Image player = GetNextPlayer();
            // Draw player & replace stream
            sample.ImageStream = DrawPlayer(sample.ImageStream, player, drawX, drawY, sample.Width, sample.Height);
            // Add coordinate information 
            sample.Items.Add(new TargetItem() { Height = player.Height, Width = player.Width, X = drawX, Y = drawY, Type = ObjectClass.Player });
            return sample;
        }

        private Image GetNextPlayer()
        {
            return _playerImages.ElementAt(_random.Next(0, _numImages));
        }

        private MemoryStream DrawPlayer(MemoryStream source, Image player, int x, int y, int width, int height)
        {
            Bitmap result = new Bitmap(source);
            Rectangle drawRegion = new Rectangle(x, y, player.Width, player.Height);
            if (_random.NextDouble() > 0.5)
            {
                player.RotateFlip(RotateFlipType.RotateNoneFlipX);
            }
            using (Graphics graphics = Graphics.FromImage(result))
            {
                graphics.DrawImageUnscaledAndClipped(player, drawRegion);
            }
            MemoryStream ret = new MemoryStream();
            result.Save(ret, ImageFormat.Png);
            return ret;
        }

    }
}

```

`MapleStory.Sampler/Sample.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MapRender.Invoker;

namespace MapleStory.Sampler
{
    public class Sample
    {
        public MemoryStream ImageStream { get; internal set; }

        public IList<TargetItem> Items { get; internal set; }

        public int Width { get; internal set; }

        public int Height { get; internal set; }

        public Guid Guid { get; private set; }

        public Sample(MemoryStream imageStream, IEnumerable<TargetItem> items, int width, int height)
        {
            ImageStream = imageStream;
            Items = new List<TargetItem>(items);
            Width = width;
            Height = height;
            Guid = Guid.NewGuid();
        }
    }
}

```

`MapleStory.Sampler/Sampler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MapRender.Invoker;
using Encoder = System.Drawing.Imaging.Encoder;

namespace MapleStory.Sampler
{
    public class Sampler
    {
        private const long JPEG_RATIO = 90L;
        private const double ITEM_PARTIAL_AREA_THRESHOLD = 0.70;
        private readonly MapRenderInvoker _renderInvoker;

        public delegate void SamplePostProcessor(Sample sample, EventArgs e);

        public event SamplePostProcessor OnSampleCaptured;

        public Sampler(MapRenderInvoker renderInvoker)
        {
            _renderInvoker = renderInvoker;
            if (!renderInvoker.IsRunning)
            {
                throw new ArgumentException("Sampler must have a lunched render!");
            }
        }

        public Sample SampleSingle()
        {
            MemoryStream stream = new MemoryStream();
            var screenShotData = _renderInvoker.TakeScreenShot(stream);
            var items = FilterTargetsInCamera(screenShotData);
            int width = screenShotData.CameraRectangle.Width;
            int height = screenShotData.CameraRectangle.Height;
            Sample ret = new Sample(stream, items, width, height);
            OnSampleCaptured?.Invoke(ret, null);
            ret.ImageStream = EncodeScreenShot(ret.ImageStream);
            return ret;
        }

        /// <summary>
        /// Sample all based on provided step
        /// </summary>
        /// <param name="xStep">step in X to sample</param>
        /// <param name="yStep">step in Y to sample</param>
        /// <param name="writer">Writer to save result</param>
        /// <param name="interval">Sampling time interval, in ms.</param>
        public void SampleAll(int xStep, int yStep, IDatasetWriter writer, int interval = 0)
        {
            xStep = Math.Abs(xStep);
            yStep = Math.Abs(yStep);
            int initX = _renderInvoker.WorldOriginX + _renderInvoker.ScreenWidth / 2;
            int initY = _renderInvoker.WorldOriginY + _renderInvoker.ScreenHeight / 2;
            int endX = _renderInvoker.WorldOriginX + _renderInvoker.WorldWidth - _renderInvoker.ScreenWidth / 2;
            int endY = _renderInvoker.WorldOriginY + _renderInvoker.WorldHeight - _renderInvoker.ScreenHeight / 2;

            int count = 0;
            int total = (int)(Math.Round((double)(endX - initX) / xStep, MidpointRounding.ToPositiveInfinity) *
                         Math.Round((double)(endY - initY) / yStep, MidpointRounding.ToPositiveInfinity));

            for (int x = initX; x < endX; x += xStep)
            {
                for (int y = initY; y < endY; y += yStep)
                {
                    Console.WriteLine($"Sampling at center x={x},y={y}....");
                    _renderInvoker.MoveCamera(x, y);
                    Sample sample = SampleSingle();
                    Console.WriteLine($"Writing {sample.Guid.ToString()} to dataset...");
                    writer.Write(sample);
                    count++;
                    Console.WriteLine($"Done writing. Progress: {count}/{total}, {(double)count / total * 100}%\n");
                    Thread.Sleep(interval);
                }
            }
            Console.WriteLine("############## All Samples Captured ##############");
            return;
        }

        private MemoryStream EncodeScreenShot(Stream screenShotStream)
        {
            using Bitmap source = new Bitmap(screenShotStream);
            using Bitmap result = new Bitmap(_renderInvoker.ScreenWidth, _renderInvoker.ScreenHeight);
            Rectangle rectangle = new Rectangle(Point.Empty, source.Size);
            using (Graphics graphics = Graphics.FromImage(result))
            {
                // Dark background, to back alpha channel.
                graphics.Clear(Color.Black);
                graphics.DrawImageUnscaledAndClipped(source, rectangle);
            }
            MemoryStream ret = new MemoryStream();
            ImageCodecInfo jpegCodecInfo = ImageCodecInfo.GetImageEncoders().First(i => i.MimeType == "image/jpeg");
            using (EncoderParameters parameters = new EncoderParameters(1))
            {
                EncoderParameter parameter = new EncoderParameter(Encoder.Quality, JPEG_RATIO);
                parameters.Param[0] = parameter;
                result.Save(ret, jpegCodecInfo, parameters);
            }

            return ret;
        }

        private static List<TargetItem> FilterTargetsInCamera(ScreenShotData data)
        {
            List<TargetItem> ret = new List<TargetItem>();
            List<TargetItem> source = data.Items;
            Rectangle camRectangle = data.CameraRectangle;
            int imgWidth = camRectangle.Width;
            int imgHeight = camRectangle.Height;
            source.ForEach(i =>
            {
                i.X -= camRectangle.X;
                i.Y -= camRectangle.Y;

                // Validation
                if (i.Height < 0 || i.Width < 0)
                {
                    throw new InvalidDataException("Items Height or Width is negative!!");
                }

                // Not show in screenshots at all
                if (i.X > imgWidth || i.Y > imgHeight)
                {
                    return;
                }
                int inCameraWidth = i.Width;
                int inCameraHeight = i.Height;
                double itemArea = i.Width * i.Height;

                // Partial in X - left
                if (i.X < 0)
                {
                    inCameraWidth = i.X + i.Width;
                    if (inCameraWidth < 0)
                    {
                        return;
                    }
                    i.X = 0;
                }

                // Partial in X - right
                if (i.X + i.Width > imgWidth)
                {
                    inCameraWidth = imgWidth - i.X;
                }

                // Partial in Y - up
                if (i.Y < 0)
                {
                    inCameraHeight = i.Y + i.Height;
                    if (inCameraHeight < 0)
                    {
                        return;
                    }
                    i.Y = 0;
                }

                // Partial in Y - bottom
                if (i.Y + i.Height > imgHeight)
                {
                    inCameraHeight = imgHeight - i.Y;
                }

                double inCameraArea = inCameraHeight * imgWidth;
                if (inCameraArea / itemArea >= ITEM_PARTIAL_AREA_THRESHOLD)
                {
                    i.Width = inCameraWidth;
                    i.Height = inCameraHeight;
                    ret.Add(i);
                }
            });
            return ret;
        }


    }
}

```

`MapleStory.Sampler/TfExample.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MapRender.Invoker;
using ProtoBuf;
using Tensorflow;

namespace MapleStory.Sampler
{
    public class TfExample
    {
        #region KEYS
        private const string KeyHeight = @"image/height";
        private const string KeyWidth = @"image/width";
        private const string KeyFileName = @"image/filename";
        private const string KeySourceId = @"image/source_id";
        private const string KeyEncoded = @"image/encoded";
        private const string KeyFormat = @"image/format";
        private const string KeyMinX = @"image/object/bbox/xmin";
        private const string KeyMaxX = @"image/object/bbox/xmax";
        private const string KeyMinY = @"image/object/bbox/ymin";
        private const string KeyMaxY = @"image/object/bbox/ymax";
        private const string KeyClassText = @"image/object/class/text";
        private const string KeyLabel = @"image/object/class/label";
        #endregion

        private const string JpegFormatString = @"jpeg";

        private Example _underlyingExample;
        private Features _features;
        private Dictionary<string, Feature> _featureMap;
        private List<float> _minXList;
        private List<float> _minYList;
        private List<float> _maxXList;
        private List<float> _maxYList;
        private List<byte[]> _classTextList;
        private List<long> _labelList;
        private float _sampleWidth;
        private float _sampleHeight;

        public Guid Guid { get; private set; }

        private TfExample(MemoryStream imageStream, int width, int height, int itemCount)
        {
            _underlyingExample = new Example();
            _underlyingExample.Features = new Features();
            _features = _underlyingExample.Features;
            _featureMap = _features.feature;
            _sampleHeight = height;
            _sampleWidth = width;
            Guid = Guid.NewGuid();

            _minXList = new List<float>(itemCount);
            _minYList = new List<float>(itemCount);
            _maxXList = new List<float>(itemCount);
            _maxYList = new List<float>(itemCount);
            _classTextList = new List<byte[]>(itemCount);
            _labelList = new List<long>(itemCount);

            _featureMap[KeyFormat] = NewBytesFeature(JpegFormatString);
            _featureMap[KeyHeight] = NewInt64Feature(height);
            _featureMap[KeyWidth] = NewInt64Feature(width);
            _featureMap[KeyEncoded] = NewBytesFeature(imageStream.ToArray());
            var guidString = Guid.ToString();
            _featureMap[KeyFileName] = NewBytesFeature(guidString);
            _featureMap[KeySourceId] = NewBytesFeature(guidString);
        }

        public static TfExample From(Sample sample)
        {
            TfExample ret = new TfExample(sample.ImageStream, sample.Width, sample.Height, sample.Items.Count());
            foreach (var item in sample.Items)
            {
                ret.AddItem(item);
            }
            return ret;
        }

        public MemoryStream SerializeToStream()
        {
            _featureMap[KeyMinX] = NewFloatListFeature(_minXList.ToArray());
            _featureMap[KeyMaxX] = NewFloatListFeature(_maxXList.ToArray());
            _featureMap[KeyMinY] = NewFloatListFeature(_minYList.ToArray());
            _featureMap[KeyMaxY] = NewFloatListFeature(_maxYList.ToArray());
            _featureMap[KeyClassText] = NewBytesListFeature(_classTextList);
            _featureMap[KeyLabel] = NewInt64ListFeature(_labelList.ToArray());

            MemoryStream ret = new MemoryStream();
            Serializer.Serialize(ret, _underlyingExample);
            return ret;
        }

        private void AddItem(TargetItem item)
        {
            float x = item.X;
            float y = item.Y;
            float x2 = x + item.Width;
            float y2 = y + item.Height;
            _minXList.Add(x / _sampleWidth);
            _maxXList.Add(x2 / _sampleWidth);

            _minYList.Add(y / _sampleHeight);
            _maxYList.Add(y2 / _sampleHeight);

            if (item.Type == MapRender.Invoker.ObjectClass.Unknown || !Enum.IsDefined(typeof(ObjectClass), item.Type))
            {
                throw new ArgumentException("TargetItem contains unknown type item!");
            }
            _classTextList.Add(Encoding.UTF8.GetBytes(Enum.GetName(typeof(ObjectClass), item.Type)));
            _labelList.Add((long)item.Type);
        }

        private static Feature NewBytesListFeature(IEnumerable<byte[]> value)
        {
            var bytesList = new BytesList();
            bytesList.Values.AddRange(value);
            return new Feature() { BytesList = bytesList };
        }

        private static Feature NewFloatListFeature(float[] value)
        {
            return new Feature() { FloatList = new FloatList() { Values = value } };
        }

        private static Feature NewInt64ListFeature(long[] value)
        {
            return new Feature() { Int64List = new Int64List() { Values = value } };
        }

        private static Feature NewInt64Feature(long value)
        {
            return new Feature() { Int64List = new Int64List() { Values = new[] { value } } };
        }

        private static Feature NewBytesFeature(byte[] value)
        {
            return new Feature() { BytesList = new BytesList() { Values = { value } } };
        }

        private static Feature NewBytesFeature(string text)
        {
            return NewBytesFeature(Encoding.UTF8.GetBytes(text));
        }
    }
}

```

`MapleStory.Sampler/TfRecordWriter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Crc32C;

namespace MapleStory.Sampler
{
    public class TfRecordWriter : IDisposable, IDatasetWriter
    {
        public const string TfRecordNameExtension = ".tfrecord";
        private const int BufferSize = 5120;
        private FileStream _fileStream;

        /// <summary>
        /// Create a TfRecordWriter, by creating an underlying <see cref="FileStream"/>
        /// </summary>
        /// <param name="path">If path does not end with ".tfrecord", it will be added.</param>
        public TfRecordWriter(string path)
        {
            if (!path.EndsWith(TfRecordNameExtension, StringComparison.InvariantCultureIgnoreCase))
            {
                path += TfRecordNameExtension;
            }
            _fileStream = new FileStream(path, FileMode.CreateNew);
        }

        ~TfRecordWriter()
        {
            this.Dispose();
        }

        void IDatasetWriter.Write(Sample sample)
        {
            Write(TfExample.From(sample));
        }

        public void Write(TfExample example)
        {
            Write(example.SerializeToStream());
        }

        public void Write(byte[] bytes)
        {
            Write(new MemoryStream(bytes));
        }

        /// <summary>
        /// Write a single record. 
        /// </summary>
        /// <param name="stream">Stream containing record in binary form</param>
        public void Write(Stream stream)
        {
            ulong length = (ulong)stream.Length;
            uint crcLength = Crc32CAlgorithm.Compute(BitConverter.GetBytes(length));
            uint maskLength = MaskCrc32(crcLength);
            _fileStream.Write(BitConverter.GetBytes(length), 0, 8); // uint64 length
            _fileStream.Write(BitConverter.GetBytes(maskLength), 0, 4); // uint32 masked_crc32_of_length
            stream.Seek(0, SeekOrigin.Begin); // Read from head

            byte[] buffer = new byte[BufferSize];
            int count = 0;
            int readSize = stream.Read(buffer, 0, buffer.Length);
            uint crcData = Crc32CAlgorithm.Compute(buffer, 0, readSize);
            for (bool firstRun = true; readSize > 0;
                count += readSize, readSize = stream.Read(buffer, 0, buffer.Length), firstRun = false)
            {
                if (!firstRun)
                {
                    crcData = Crc32CAlgorithm.Append(crcData, buffer, 0, readSize);
                }
                _fileStream.Write(buffer, 0, readSize); // byte data[length]
            }

            if (count != (int)length)
            {
                throw new Exception("Stream length does not equal to read length.");
            }

            uint maskCrcData = MaskCrc32(crcData);
            _fileStream.Write(BitConverter.GetBytes(maskCrcData), 0, 4); // uint32 masked_crc32_of_data
        }

        /// <summary>
        /// See <seealso cref="https://www.tensorflow.org/tutorials/load_data/tfrecord#tfexample"/>
        /// </summary>
        private uint MaskCrc32(uint crc)
        {
            return (uint)(((crc >> 15) | (crc << 17)) + 0xa282ead8UL);
        }

        public void Finish()
        {
            // Not needed for TfRecord.
            return;
        }

        public void Dispose()
        {
            _fileStream?.Dispose();
        }

    }
}

```

`MapleStory.Sampler/protobuf/Example.cs`:

```cs
// <auto-generated>
//   This file was generated by a tool; you should avoid making direct changes.
//   Consider using 'partial classes' to extend these types
//   Input: example.proto
// </auto-generated>

#region Designer generated code
#pragma warning disable CS0612, CS0618, CS1591, CS3021, IDE1006, RCS1036, RCS1057, RCS1085, RCS1192
namespace Tensorflow
{

    [global::ProtoBuf.ProtoContract()]
    public partial class Example : global::ProtoBuf.IExtensible
    {
        private global::ProtoBuf.IExtension __pbn__extensionData;
        global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)
            => global::ProtoBuf.Extensible.GetExtensionObject(ref __pbn__extensionData, createIfMissing);

        [global::ProtoBuf.ProtoMember(1, Name = @"features")]
        public Features Features { get; set; }

    }

    [global::ProtoBuf.ProtoContract()]
    public partial class SequenceExample : global::ProtoBuf.IExtensible
    {
        private global::ProtoBuf.IExtension __pbn__extensionData;
        global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)
            => global::ProtoBuf.Extensible.GetExtensionObject(ref __pbn__extensionData, createIfMissing);

        [global::ProtoBuf.ProtoMember(1, Name = @"context")]
        public Features Context { get; set; }

        [global::ProtoBuf.ProtoMember(2, Name = @"feature_lists")]
        public FeatureLists FeatureLists { get; set; }

    }

}

#pragma warning restore CS0612, CS0618, CS1591, CS3021, IDE1006, RCS1036, RCS1057, RCS1085, RCS1192
#endregion

```

`MapleStory.Sampler/protobuf/Feature.cs`:

```cs
// <auto-generated>
//   This file was generated by a tool; you should avoid making direct changes.
//   Consider using 'partial classes' to extend these types
//   Input: feature.proto
// </auto-generated>

#region Designer generated code
#pragma warning disable CS0612, CS0618, CS1591, CS3021, IDE1006, RCS1036, RCS1057, RCS1085, RCS1192
namespace Tensorflow
{

    [global::ProtoBuf.ProtoContract()]
    public partial class BytesList : global::ProtoBuf.IExtensible
    {
        private global::ProtoBuf.IExtension __pbn__extensionData;
        global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)
            => global::ProtoBuf.Extensible.GetExtensionObject(ref __pbn__extensionData, createIfMissing);

        [global::ProtoBuf.ProtoMember(1, Name = @"value")]
        public global::System.Collections.Generic.List<byte[]> Values { get; } = new global::System.Collections.Generic.List<byte[]>();

    }

    [global::ProtoBuf.ProtoContract()]
    public partial class FloatList : global::ProtoBuf.IExtensible
    {
        private global::ProtoBuf.IExtension __pbn__extensionData;
        global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)
            => global::ProtoBuf.Extensible.GetExtensionObject(ref __pbn__extensionData, createIfMissing);

        [global::ProtoBuf.ProtoMember(1, Name = @"value", IsPacked = true)]
        public float[] Values { get; set; }

    }

    [global::ProtoBuf.ProtoContract()]
    public partial class Int64List : global::ProtoBuf.IExtensible
    {
        private global::ProtoBuf.IExtension __pbn__extensionData;
        global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)
            => global::ProtoBuf.Extensible.GetExtensionObject(ref __pbn__extensionData, createIfMissing);

        [global::ProtoBuf.ProtoMember(1, Name = @"value", IsPacked = true)]
        public long[] Values { get; set; }

    }

    [global::ProtoBuf.ProtoContract()]
    public partial class Feature : global::ProtoBuf.IExtensible
    {
        private global::ProtoBuf.IExtension __pbn__extensionData;
        global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)
            => global::ProtoBuf.Extensible.GetExtensionObject(ref __pbn__extensionData, createIfMissing);

        [global::ProtoBuf.ProtoMember(1, Name = @"bytes_list")]
        public BytesList BytesList
        {
            get => __pbn__kind.Is(1) ? ((BytesList)__pbn__kind.Object) : default;
            set => __pbn__kind = new global::ProtoBuf.DiscriminatedUnionObject(1, value);
        }
        public bool ShouldSerializeBytesList() => __pbn__kind.Is(1);
        public void ResetBytesList() => global::ProtoBuf.DiscriminatedUnionObject.Reset(ref __pbn__kind, 1);

        private global::ProtoBuf.DiscriminatedUnionObject __pbn__kind;

        [global::ProtoBuf.ProtoMember(2, Name = @"float_list")]
        public FloatList FloatList
        {
            get => __pbn__kind.Is(2) ? ((FloatList)__pbn__kind.Object) : default;
            set => __pbn__kind = new global::ProtoBuf.DiscriminatedUnionObject(2, value);
        }
        public bool ShouldSerializeFloatList() => __pbn__kind.Is(2);
        public void ResetFloatList() => global::ProtoBuf.DiscriminatedUnionObject.Reset(ref __pbn__kind, 2);

        [global::ProtoBuf.ProtoMember(3, Name = @"int64_list")]
        public Int64List Int64List
        {
            get => __pbn__kind.Is(3) ? ((Int64List)__pbn__kind.Object) : default;
            set => __pbn__kind = new global::ProtoBuf.DiscriminatedUnionObject(3, value);
        }
        public bool ShouldSerializeInt64List() => __pbn__kind.Is(3);
        public void ResetInt64List() => global::ProtoBuf.DiscriminatedUnionObject.Reset(ref __pbn__kind, 3);

    }

    [global::ProtoBuf.ProtoContract()]
    public partial class Features : global::ProtoBuf.IExtensible
    {
        private global::ProtoBuf.IExtension __pbn__extensionData;
        global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)
            => global::ProtoBuf.Extensible.GetExtensionObject(ref __pbn__extensionData, createIfMissing);

        [global::ProtoBuf.ProtoMember(1)]
        [global::ProtoBuf.ProtoMap]
        public global::System.Collections.Generic.Dictionary<string, Feature> feature { get; } = new global::System.Collections.Generic.Dictionary<string, Feature>();

    }

    [global::ProtoBuf.ProtoContract()]
    public partial class FeatureList : global::ProtoBuf.IExtensible
    {
        private global::ProtoBuf.IExtension __pbn__extensionData;
        global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)
            => global::ProtoBuf.Extensible.GetExtensionObject(ref __pbn__extensionData, createIfMissing);

        [global::ProtoBuf.ProtoMember(1, Name = @"feature")]
        public global::System.Collections.Generic.List<Feature> Features { get; } = new global::System.Collections.Generic.List<Feature>();

    }

    [global::ProtoBuf.ProtoContract()]
    public partial class FeatureLists : global::ProtoBuf.IExtensible
    {
        private global::ProtoBuf.IExtension __pbn__extensionData;
        global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)
            => global::ProtoBuf.Extensible.GetExtensionObject(ref __pbn__extensionData, createIfMissing);

        [global::ProtoBuf.ProtoMember(1)]
        [global::ProtoBuf.ProtoMap]
        public global::System.Collections.Generic.Dictionary<string, FeatureList> feature_list { get; } = new global::System.Collections.Generic.Dictionary<string, FeatureList>();

    }

}

#pragma warning restore CS0612, CS0618, CS1591, CS3021, IDE1006, RCS1036, RCS1057, RCS1085, RCS1192
#endregion

```

`MapleStory.Sampler/protobuf/README.md`:

```md
# NOTE
Files in this folder are copied from https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/example
```

`MapleStory.Sampler/protobuf/example.proto`:

```proto
// Protocol messages for describing input data Examples for machine learning
// model training or inference.
syntax = "proto3";

package tensorflow;

import "feature.proto";

option cc_enable_arenas = true;
option java_outer_classname = "ExampleProtos";
option java_multiple_files = true;
option java_package = "org.tensorflow.example";
option go_package = "github.com/tensorflow/tensorflow/tensorflow/go/core/example/example_protos_go_proto";

// LINT.IfChange
// An Example is a mostly-normalized data format for storing data for
// training and inference.  It contains a key-value store (features); where
// each key (string) maps to a Feature message (which is oneof packed BytesList,
// FloatList, or Int64List).  This flexible and compact format allows the
// storage of large amounts of typed data, but requires that the data shape
// and use be determined by the configuration files and parsers that are used to
// read and write this format.  That is, the Example is mostly *not* a
// self-describing format.  In TensorFlow, Examples are read in row-major
// format, so any configuration that describes data with rank-2 or above
// should keep this in mind.  For example, to store an M x N matrix of Bytes,
// the BytesList must contain M*N bytes, with M rows of N contiguous values
// each.  That is, the BytesList value must store the matrix as:
//     .... row 0 .... .... row 1 .... // ...........  // ... row M-1 ....
//
// An Example for a movie recommendation application:
//   features {
//     feature {
//       key: "age"
//       value { float_list {
//         value: 29.0
//       }}
//     }
//     feature {
//       key: "movie"
//       value { bytes_list {
//         value: "The Shawshank Redemption"
//         value: "Fight Club"
//       }}
//     }
//     feature {
//       key: "movie_ratings"
//       value { float_list {
//         value: 9.0
//         value: 9.7
//       }}
//     }
//     feature {
//       key: "suggestion"
//       value { bytes_list {
//         value: "Inception"
//       }}
//     }
//     # Note that this feature exists to be used as a label in training.
//     # E.g., if training a logistic regression model to predict purchase
//     # probability in our learning tool we would set the label feature to
//     # "suggestion_purchased".
//     feature {
//       key: "suggestion_purchased"
//       value { float_list {
//         value: 1.0
//       }}
//     }
//     # Similar to "suggestion_purchased" above this feature exists to be used
//     # as a label in training.
//     # E.g., if training a linear regression model to predict purchase
//     # price in our learning tool we would set the label feature to
//     # "purchase_price".
//     feature {
//       key: "purchase_price"
//       value { float_list {
//         value: 9.99
//       }}
//     }
//  }
//
// A conformant Example data set obeys the following conventions:
//   - If a Feature K exists in one example with data type T, it must be of
//       type T in all other examples when present. It may be omitted.
//   - The number of instances of Feature K list data may vary across examples,
//       depending on the requirements of the model.
//   - If a Feature K doesn't exist in an example, a K-specific default will be
//       used, if configured.
//   - If a Feature K exists in an example but contains no items, the intent
//       is considered to be an empty tensor and no default will be used.

message Example {
  Features features = 1;
}

// A SequenceExample is an Example representing one or more sequences, and
// some context.  The context contains features which apply to the entire
// example. The feature_lists contain a key, value map where each key is
// associated with a repeated set of Features (a FeatureList).
// A FeatureList thus represents the values of a feature identified by its key
// over time / frames.
//
// Below is a SequenceExample for a movie recommendation application recording a
// sequence of ratings by a user. The time-independent features ("locale",
// "age", "favorites") describing the user are part of the context. The sequence
// of movies the user rated are part of the feature_lists. For each movie in the
// sequence we have information on its name and actors and the user's rating.
// This information is recorded in three separate feature_list(s).
// In the example below there are only two movies. All three feature_list(s),
// namely "movie_ratings", "movie_names", and "actors" have a feature value for
// both movies. Note, that "actors" is itself a bytes_list with multiple
// strings per movie.
//
// context: {
//   feature: {
//     key  : "locale"
//     value: {
//       bytes_list: {
//         value: [ "pt_BR" ]
//       }
//     }
//   }
//   feature: {
//     key  : "age"
//     value: {
//       float_list: {
//         value: [ 19.0 ]
//       }
//     }
//   }
//   feature: {
//     key  : "favorites"
//     value: {
//       bytes_list: {
//         value: [ "Majesty Rose", "Savannah Outen", "One Direction" ]
//       }
//     }
//   }
// }
// feature_lists: {
//   feature_list: {
//     key  : "movie_ratings"
//     value: {
//       feature: {
//         float_list: {
//           value: [ 4.5 ]
//         }
//       }
//       feature: {
//         float_list: {
//           value: [ 5.0 ]
//         }
//       }
//     }
//   }
//   feature_list: {
//     key  : "movie_names"
//     value: {
//       feature: {
//         bytes_list: {
//           value: [ "The Shawshank Redemption" ]
//         }
//       }
//       feature: {
//         bytes_list: {
//           value: [ "Fight Club" ]
//         }
//       }
//     }
//   }
//   feature_list: {
//     key  : "actors"
//     value: {
//       feature: {
//         bytes_list: {
//           value: [ "Tim Robbins", "Morgan Freeman" ]
//         }
//       }
//       feature: {
//         bytes_list: {
//           value: [ "Brad Pitt", "Edward Norton", "Helena Bonham Carter" ]
//         }
//       }
//     }
//   }
// }
//
// A conformant SequenceExample data set obeys the following conventions:
//
// Context:
//   - All conformant context features K must obey the same conventions as
//     a conformant Example's features (see above).
// Feature lists:
//   - A FeatureList L may be missing in an example; it is up to the
//     parser configuration to determine if this is allowed or considered
//     an empty list (zero length).
//   - If a FeatureList L exists, it may be empty (zero length).
//   - If a FeatureList L is non-empty, all features within the FeatureList
//     must have the same data type T. Even across SequenceExamples, the type T
//     of the FeatureList identified by the same key must be the same. An entry
//     without any values may serve as an empty feature.
//   - If a FeatureList L is non-empty, it is up to the parser configuration
//     to determine if all features within the FeatureList must
//     have the same size.  The same holds for this FeatureList across multiple
//     examples.
//   - For sequence modeling, e.g.:
//        http://colah.github.io/posts/2015-08-Understanding-LSTMs/
//        https://github.com/tensorflow/nmt
//     the feature lists represent a sequence of frames.
//     In this scenario, all FeatureLists in a SequenceExample have the same
//     number of Feature messages, so that the ith element in each FeatureList
//     is part of the ith frame (or time step).
// Examples of conformant and non-conformant examples' FeatureLists:
//
// Conformant FeatureLists:
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { feature: { float_list: { value: [ 4.5 ] } }
//               feature: { float_list: { value: [ 5.0 ] } } }
//    } }
//
// Non-conformant FeatureLists (mismatched types):
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { feature: { float_list: { value: [ 4.5 ] } }
//               feature: { int64_list: { value: [ 5 ] } } }
//    } }
//
// Conditionally conformant FeatureLists, the parser configuration determines
// if the feature sizes must match:
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { feature: { float_list: { value: [ 4.5 ] } }
//               feature: { float_list: { value: [ 5.0, 6.0 ] } } }
//    } }
//
// Conformant pair of SequenceExample
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { feature: { float_list: { value: [ 4.5 ] } }
//               feature: { float_list: { value: [ 5.0 ] } } }
//    } }
// and:
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { feature: { float_list: { value: [ 4.5 ] } }
//               feature: { float_list: { value: [ 5.0 ] } }
//               feature: { float_list: { value: [ 2.0 ] } } }
//    } }
//
// Conformant pair of SequenceExample
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { feature: { float_list: { value: [ 4.5 ] } }
//               feature: { float_list: { value: [ 5.0 ] } } }
//    } }
// and:
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { }
//    } }
//
// Conditionally conformant pair of SequenceExample, the parser configuration
// determines if the second feature_lists is consistent (zero-length) or
// invalid (missing "movie_ratings"):
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { feature: { float_list: { value: [ 4.5 ] } }
//               feature: { float_list: { value: [ 5.0 ] } } }
//    } }
// and:
//    feature_lists: { }
//
// Non-conformant pair of SequenceExample (mismatched types)
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { feature: { float_list: { value: [ 4.5 ] } }
//               feature: { float_list: { value: [ 5.0 ] } } }
//    } }
// and:
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { feature: { int64_list: { value: [ 4 ] } }
//               feature: { int64_list: { value: [ 5 ] } }
//               feature: { int64_list: { value: [ 2 ] } } }
//    } }
//
// Conditionally conformant pair of SequenceExample; the parser configuration
// determines if the feature sizes must match:
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { feature: { float_list: { value: [ 4.5 ] } }
//               feature: { float_list: { value: [ 5.0 ] } } }
//    } }
// and:
//    feature_lists: { feature_list: {
//      key: "movie_ratings"
//      value: { feature: { float_list: { value: [ 4.0 ] } }
//               feature: { float_list: { value: [ 5.0, 3.0 ] } }
//    } }

message SequenceExample {
  Features context = 1;
  FeatureLists feature_lists = 2;
}
// LINT.ThenChange(
//     https://www.tensorflow.org/code/tensorflow/python/training/training.py)

```

`MapleStory.Sampler/protobuf/feature.proto`:

```proto
// Protocol messages for describing features for machine learning model
// training or inference.
//
// There are three base Feature types:
//   - bytes
//   - float
//   - int64
//
// A Feature contains Lists which may hold zero or more values.  These
// lists are the base values BytesList, FloatList, Int64List.
//
// Features are organized into categories by name.  The Features message
// contains the mapping from name to Feature.
//
// Example Features for a movie recommendation application:
//   feature {
//     key: "age"
//     value { float_list {
//       value: 29.0
//     }}
//   }
//   feature {
//     key: "movie"
//     value { bytes_list {
//       value: "The Shawshank Redemption"
//       value: "Fight Club"
//     }}
//   }
//   feature {
//     key: "movie_ratings"
//     value { float_list {
//       value: 9.0
//       value: 9.7
//     }}
//   }
//   feature {
//     key: "suggestion"
//     value { bytes_list {
//       value: "Inception"
//     }}
//   }
//   feature {
//     key: "suggestion_purchased"
//     value { int64_list {
//       value: 1
//     }}
//   }
//   feature {
//     key: "purchase_price"
//     value { float_list {
//       value: 9.99
//     }}
//   }
//

syntax = "proto3";

package tensorflow;

option cc_enable_arenas = true;
option java_outer_classname = "FeatureProtos";
option java_multiple_files = true;
option java_package = "org.tensorflow.example";
option go_package = "github.com/tensorflow/tensorflow/tensorflow/go/core/example/example_protos_go_proto";

// LINT.IfChange
// Containers to hold repeated fundamental values.
message BytesList {
  repeated bytes value = 1;
}
message FloatList {
  repeated float value = 1 [packed = true];
}
message Int64List {
  repeated int64 value = 1 [packed = true];
}

// Containers for non-sequential data.
message Feature {
  // Each feature can be exactly one kind.
  oneof kind {
    BytesList bytes_list = 1;
    FloatList float_list = 2;
    Int64List int64_list = 3;
  }
}

message Features {
  // Map from feature name to feature.
  map<string, Feature> feature = 1;
}

// Containers for sequential data.
//
// A FeatureList contains lists of Features.  These may hold zero or more
// Feature values.
//
// FeatureLists are organized into categories by name.  The FeatureLists message
// contains the mapping from name to FeatureList.
//
message FeatureList {
  repeated Feature feature = 1;
}

message FeatureLists {
  // Map from feature name to feature list.
  map<string, FeatureList> feature_list = 1;
}
// LINT.ThenChange(
//     https://www.tensorflow.org/code/tensorflow/python/training/training.py)

```

`MapleStoryDetectionSampleGenerator.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31112.23
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MapleStory.Common", "MapleStory.Common\MapleStory.Common.csproj", "{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "CharaSimResource", "WzComparerR2\CharaSimResource\CharaSimResource.csproj", "{54797F38-A12C-4202-92A4-1A3DDCE914B7}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WzComparerR2", "WzComparerR2\WzComparerR2\WzComparerR2.csproj", "{5E883BE2-2009-4517-8026-4B90DEB83884}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WzComparerR2.Avatar", "WzComparerR2\WzComparerR2.Avatar\WzComparerR2.Avatar.csproj", "{A0753218-2C58-4E4A-9017-A435D2E5F639}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WzComparerR2.Common", "WzComparerR2\WzComparerR2.Common\WzComparerR2.Common.csproj", "{818060BC-404C-470A-94B3-5160716C5247}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WzComparerR2.PluginBase", "WzComparerR2\WzComparerR2.PluginBase\WzComparerR2.PluginBase.csproj", "{FA74A2FD-0250-4182-845D-DD98D829B525}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WzComparerR2.WzLib", "WzComparerR2\WzComparerR2.WzLib\WzComparerR2.WzLib.csproj", "{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WzComparerR2.MapRender", "WzComparerR2\WzComparerR2.MapRender\WzComparerR2.MapRender.csproj", "{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MapRender.Invoker", "MapRender.Invoker\MapRender.Invoker.csproj", "{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MapleStory.Sampler", "MapleStory.Sampler\MapleStory.Sampler.csproj", "{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MapleStory.MachineLearningSampleGenerator", "MapleStory.MachineLearningSampleGenerator\MapleStory.MachineLearningSampleGenerator.csproj", "{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Debug|x64.ActiveCfg = Debug|Any CPU
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Debug|x64.Build.0 = Debug|Any CPU
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Debug|x86.ActiveCfg = Debug|Any CPU
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Debug|x86.Build.0 = Debug|Any CPU
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Release|Any CPU.Build.0 = Release|Any CPU
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Release|x64.ActiveCfg = Release|Any CPU
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Release|x64.Build.0 = Release|Any CPU
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Release|x86.ActiveCfg = Release|Any CPU
		{43F1F84E-0B40-4AAD-9BC9-B6100CAB1D4C}.Release|x86.Build.0 = Release|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Debug|x64.ActiveCfg = Debug|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Debug|x64.Build.0 = Debug|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Debug|x86.ActiveCfg = Debug|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Debug|x86.Build.0 = Debug|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Release|Any CPU.Build.0 = Release|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Release|x64.ActiveCfg = Release|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Release|x64.Build.0 = Release|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Release|x86.ActiveCfg = Release|Any CPU
		{54797F38-A12C-4202-92A4-1A3DDCE914B7}.Release|x86.Build.0 = Release|Any CPU
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Debug|x64.ActiveCfg = Debug|x64
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Debug|x64.Build.0 = Debug|x64
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Debug|x86.ActiveCfg = Debug|x86
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Debug|x86.Build.0 = Debug|x86
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Release|Any CPU.Build.0 = Release|Any CPU
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Release|x64.ActiveCfg = Release|x64
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Release|x64.Build.0 = Release|x64
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Release|x86.ActiveCfg = Release|x86
		{5E883BE2-2009-4517-8026-4B90DEB83884}.Release|x86.Build.0 = Release|x86
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Debug|x64.ActiveCfg = Debug|Any CPU
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Debug|x64.Build.0 = Debug|Any CPU
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Debug|x86.ActiveCfg = Debug|Any CPU
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Debug|x86.Build.0 = Debug|Any CPU
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Release|Any CPU.Build.0 = Release|Any CPU
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Release|x64.ActiveCfg = Release|Any CPU
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Release|x64.Build.0 = Release|Any CPU
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Release|x86.ActiveCfg = Release|Any CPU
		{A0753218-2C58-4E4A-9017-A435D2E5F639}.Release|x86.Build.0 = Release|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Debug|x64.ActiveCfg = Debug|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Debug|x64.Build.0 = Debug|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Debug|x86.ActiveCfg = Debug|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Debug|x86.Build.0 = Debug|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Release|Any CPU.Build.0 = Release|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Release|x64.ActiveCfg = Release|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Release|x64.Build.0 = Release|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Release|x86.ActiveCfg = Release|Any CPU
		{818060BC-404C-470A-94B3-5160716C5247}.Release|x86.Build.0 = Release|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Debug|x64.ActiveCfg = Debug|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Debug|x64.Build.0 = Debug|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Debug|x86.ActiveCfg = Debug|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Debug|x86.Build.0 = Debug|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Release|Any CPU.Build.0 = Release|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Release|x64.ActiveCfg = Release|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Release|x64.Build.0 = Release|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Release|x86.ActiveCfg = Release|Any CPU
		{FA74A2FD-0250-4182-845D-DD98D829B525}.Release|x86.Build.0 = Release|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Debug|x64.ActiveCfg = Debug|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Debug|x64.Build.0 = Debug|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Debug|x86.ActiveCfg = Debug|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Debug|x86.Build.0 = Debug|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Release|Any CPU.Build.0 = Release|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Release|x64.ActiveCfg = Release|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Release|x64.Build.0 = Release|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Release|x86.ActiveCfg = Release|Any CPU
		{0E9801FD-44A2-4AF8-AE91-D6E74BAD56B2}.Release|x86.Build.0 = Release|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Debug|x64.ActiveCfg = Debug|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Debug|x64.Build.0 = Debug|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Debug|x86.ActiveCfg = Debug|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Debug|x86.Build.0 = Debug|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Release|Any CPU.Build.0 = Release|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Release|x64.ActiveCfg = Release|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Release|x64.Build.0 = Release|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Release|x86.ActiveCfg = Release|Any CPU
		{11E362E4-B8FB-4BD4-B0D3-BA078D5FB002}.Release|x86.Build.0 = Release|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Debug|x64.ActiveCfg = Debug|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Debug|x64.Build.0 = Debug|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Debug|x86.Build.0 = Debug|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Release|Any CPU.Build.0 = Release|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Release|x64.ActiveCfg = Release|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Release|x64.Build.0 = Release|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Release|x86.ActiveCfg = Release|Any CPU
		{C28EA64C-2C4C-40CE-8FF9-EF74E50CEA5B}.Release|x86.Build.0 = Release|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Debug|x64.ActiveCfg = Debug|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Debug|x64.Build.0 = Debug|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Debug|x86.ActiveCfg = Debug|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Debug|x86.Build.0 = Debug|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Release|Any CPU.Build.0 = Release|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Release|x64.ActiveCfg = Release|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Release|x64.Build.0 = Release|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Release|x86.ActiveCfg = Release|Any CPU
		{6B6E65DC-B238-4925-A4FC-6C1DEC2920F5}.Release|x86.Build.0 = Release|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Debug|x64.ActiveCfg = Debug|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Debug|x64.Build.0 = Debug|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Debug|x86.ActiveCfg = Debug|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Debug|x86.Build.0 = Debug|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Release|Any CPU.Build.0 = Release|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Release|x64.ActiveCfg = Release|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Release|x64.Build.0 = Release|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Release|x86.ActiveCfg = Release|Any CPU
		{5DD2E446-DCD0-4104-A3F2-EDB6941A0B34}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {58DAE377-DCA8-48A9-88E3-A8C9AE2197DB}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
# MapleStoryDetectionSampleGenerator
Generate Machine Learning Samples Object Detection In MapleStory
![](https://github.com/charlescao460/MapleStoryDetectionSampleGenerator/blob/master/pictures/result.png)



# Performance
This generator can generate arbitrarily many annotated samples. All bounding boxes are precisely annotated based on rendering coordinates.

With [YOLOv4](https://github.com/AlexeyAB/darknet/blob/master/cfg/yolov4-custom.cfg) and ~5000 samples, it can achieve 99.8%mAP in test set.


![](https://github.com/charlescao460/MapleStoryDetectionSampleGenerator/blob/master/pictures/chart_yolov4-custom.png)

# Requirement
* Visual Studio 2019 v16.8 or above with .NET workload installed
* .NET 5.0 SDK (5.0.0 or above)

# Build
1. Clone this repository with submodules by </br> `git clone --recursive git@github.com:charlescao460/MapleStoryDetectionSampleGenerator.git`. </br>Note that `--recursive` is necessary.
2. Build `WzComparerR2/WzComparerR2.sln` (submodule MUST be built first)
3. Build `MapleStoryDetectionSampleGenerator.sln`
4. Run `MapleStory.MachineLearningSampleGenerator\bin\Release\net5.0-windows\WzComparerR2.exe`. Running `WzComparerR2.exe` will generate `Setting.config`, which is required for our MapRender.

# Run
(Assuming assemblies are built with `Release` configuration. `Debug` configuration is similar)
1. Cd into executable directory: `cd MapleStory.MachineLearningSampleGenerator\bin\Release\net5.0-windows`
2. Use `WzComparerR2.exe` to find the desired map you want to sample. Assuming `993134200.img` is the map you want in Limina.
3. Prepare your player PNGs in a directory. </br>Since WzComparerR2 does not have Avatar supported inside MapRender, we have to draw player images in our post-processing steps. Player images should be transparent PNGs with only the player's appearance. You can get these PNGs by Photoshop or save from WzComparerR2's Avatar plugin. Assuming `.\players` is the directory containing all images
4. Run ```.\MapleStory.MachineLearningSampleGenerator.exe -m 993134200 -x 5 -y 5 -f coco -o ".\output" --post --players ".\players"```</br>
This means run the sampler in map 993134200.img with every 5 pixels in X and every 5 pixels in Y, outputing COCO format, and drawing players in post processor. </br>
You can run `.\MapleStory.MachineLearningSampleGenerator.exe --help` for usage hint. Also you can take a look of the entrypoint [Program.cs](https://github.com/charlescao460/MapleStoryDetectionSampleGenerator/blob/master/MapleStory.MachineLearningSampleGenerator/Program.cs)

# Note
* Since NPCs look like players, including them without annotation could result a negative effect on our model. If you want to hide all NPCs from generated samples, simply change [WzComparerR2.MapRender/MapData.cs](https://github.com/Kagamia/WzComparerR2/blob/master/WzComparerR2.MapRender/MapData.cs) to prevent any NPC data loaded into map render. 

# Output Formats
## Tensorflow TFRecord
According to Tensorflow [official document](https://www.tensorflow.org/tutorials/load_data/tfrecord#tfrecords_format_details), the output .tfrecord contains multiple [tf.train.Example](https://www.tensorflow.org/api_docs/python/tf/train/Example) in single file. With each example store in the following formats:

```
uint64 length
uint32 masked_crc32_of_length
byte   data[length]
uint32 masked_crc32_of_data
```
And
```
masked_crc = ((crc >> 15) | (crc << 17)) + 0xa282ead8ul
```
Each `tf.train.Example` is generated by [protobuf-net](https://github.com/protobuf-net/protobuf-net) according to Tensorflow [example.proto](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/example/example.proto)

## Darknet
Output directory structure:
```
data/
|---obj/
|   |---1.jpg
|   |---1.txt
|   |---......
|---obj.data
|---obj.names
|---test.txt
|---train.txt
```
`obj.data` contains 
```
classes=2
train=data/train.txt
valid=data/test.txt
names=data/obj.names
backup = backup/
```
And `obj.names` contains the class name for object. `test.txt` and `train.txt` contains samples for testing/training with ratio of 5:95 (5% of images in `obj/` are used for testing).

## COCO
Output directory structure:
```
coco/
|---train2017/
|   |---1.jpg
|   |---2.jpg
|   |---......
|---val2017/
|   |---1000.jpg
|   |---1001.jpg
|   |---......
|---annotations/
|   |---instances_train2017.json
|   |---instances_val2017.json
```
The COCO json is defined as following:
```json
{
  "info": {
    "description": "MapleStory 993134100.img Object Detection Samples - Training",
    "url": "https://github.com/charlescao460/MapleStoryDetectionSampleGenerator",
    "version": "1.0",
    "year": 2021,
    "contributor": "CSR"
  },
  "licenses": [
    {
      "url": "https://github.com/charlescao460/MapleStoryDetectionSampleGenerator/blob/master/LICENSE",
      "id": 1,
      "name": "MIT License"
    }
  ],
  "images": [
    {
      "license": 1,
      "file_name": "30a892e1-7f3d-4c65-bdd1-9d28f1ae5187.jpg",
      "coco_url": "",
      "height": 768,
      "width": 1366,
      "flickr_url": "",
      "id": 1
    },
    ...],
  "categories": [
    {
      "supercategory": "element",
      "id": 1,
      "name": "Mob"
    },
    {
      "supercategory": "element",
      "id": 2,
      "name": "Player"
    }
  ],
  "annotations": [
    {
      "segmentation": [
        [
          524,
          429,
          664,
          429,
          664,
          578,
          524,
          578
        ]
      ],
      "area": 20860,
      "iscrowd": 0,
      "image_id": 1,
      "bbox": [
        524,
        429,
        140,
        149
      ],
      "category_id": 1,
      "id": 1
    },
    ...]
```
Note that `segmentation` covers the area as the same as `bbox` does. No segmentation or masked implemented .

```

`Tools/protogen/.gitignore`:

```
!/*
!/**/*
```

`Tools/protogen/protobuf-net.Core.xml`:

```xml
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>protobuf-net.Core</name>
    </assembly>
    <members>
        <member name="T:ProtoBuf.BclHelpers">
            <summary>
            Provides support for common .NET types that do not have a direct representation
            in protobuf, using the definitions from bcl.proto
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.GetUninitializedObject(System.Type)">
            <summary>
            Creates a new instance of the specified type, bypassing the constructor.
            </summary>
            <param name="type">The type to create</param>
            <returns>The new instance</returns>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteTimeSpan(System.TimeSpan,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a TimeSpan to a protobuf stream using protobuf-net's own representation, bcl.TimeSpan
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteTimeSpan(ProtoBuf.ProtoWriter.State@,System.TimeSpan)">
            <summary>
            Writes a TimeSpan to a protobuf stream using protobuf-net's own representation, bcl.TimeSpan
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadTimeSpan(ProtoBuf.ProtoReader)">
            <summary>
            Parses a TimeSpan from a protobuf stream using protobuf-net's own representation, bcl.TimeSpan
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadTimeSpan(ProtoBuf.ProtoReader.State@)">
            <summary>
            Parses a TimeSpan from a protobuf stream using protobuf-net's own representation, bcl.TimeSpan
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDuration(ProtoBuf.ProtoReader)">
            <summary>
            Parses a TimeSpan from a protobuf stream using the standardized format, google.protobuf.Duration
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDuration(ProtoBuf.ProtoReader.State@)">
            <summary>
            Parses a TimeSpan from a protobuf stream using the standardized format, google.protobuf.Duration
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDuration(System.TimeSpan,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a TimeSpan to a protobuf stream using the standardized format, google.protobuf.Duration
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDuration(ProtoBuf.ProtoWriter.State@,System.TimeSpan)">
            <summary>
            Writes a TimeSpan to a protobuf stream using the standardized format, google.protobuf.Duration
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadTimestamp(ProtoBuf.ProtoReader)">
            <summary>
            Parses a DateTime from a protobuf stream using the standardized format, google.protobuf.Timestamp
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadTimestamp(ProtoBuf.ProtoReader.State@)">
            <summary>
            Parses a DateTime from a protobuf stream using the standardized format, google.protobuf.Timestamp
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteTimestamp(System.DateTime,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a DateTime to a protobuf stream using the standardized format, google.protobuf.Timestamp
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteTimestamp(ProtoBuf.ProtoWriter.State@,System.DateTime)">
            <summary>
            Writes a DateTime to a protobuf stream using the standardized format, google.protobuf.Timestamp
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDateTime(ProtoBuf.ProtoReader)">
            <summary>
            Parses a DateTime from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDateTime(ProtoBuf.ProtoReader.State@)">
            <summary>
            Parses a DateTime from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDateTime(System.DateTime,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a DateTime to a protobuf stream, excluding the <c>Kind</c>
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDateTime(ProtoBuf.ProtoWriter.State@,System.DateTime)">
            <summary>
            Writes a DateTime to a protobuf stream, excluding the <c>Kind</c>
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDateTimeWithKind(System.DateTime,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a DateTime to a protobuf stream, including the <c>Kind</c>
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDateTimeWithKind(ProtoBuf.ProtoWriter.State@,System.DateTime)">
            <summary>
            Writes a DateTime to a protobuf stream, including the <c>Kind</c>
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDecimal(ProtoBuf.ProtoReader)">
            <summary>
            Parses a decimal from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDecimal(ProtoBuf.ProtoReader.State@)">
            <summary>
            Parses a decimal from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDecimalString(ProtoBuf.ProtoReader.State@)">
            <summary>
            Parses a decimal from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDecimal(System.Decimal,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a decimal to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDecimal(ProtoBuf.ProtoWriter.State@,System.Decimal)">
            <summary>
            Writes a decimal to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDecimalString(ProtoBuf.ProtoWriter.State@,System.Decimal)">
            <summary>
            Writes a decimal to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteGuid(System.Guid,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a Guid to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteGuid(ProtoBuf.ProtoWriter.State@,System.Guid)">
            <summary>
            Writes a Guid to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteGuidBytes(ProtoBuf.ProtoWriter.State@,System.Guid)">
            <summary>
            Writes a Guid to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteGuidString(ProtoBuf.ProtoWriter.State@,System.Guid)">
            <summary>
            Writes a Guid to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadGuid(ProtoBuf.ProtoReader)">
            <summary>
            Parses a Guid from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadGuid(ProtoBuf.ProtoReader.State@)">
            <summary>
            Parses a Guid from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadGuidBytes(ProtoBuf.ProtoReader.State@)">
            <summary>
            Parses a Guid from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadGuidString(ProtoBuf.ProtoReader.State@)">
            <summary>
            Parses a Guid from a protobuf stream
            </summary>
        </member>
        <member name="T:ProtoBuf.BufferExtension">
            <summary>
            Provides a simple buffer-based implementation of an <see cref="T:ProtoBuf.IExtension">extension</see> object.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoBeforeSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before serialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoAfterSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after serialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoBeforeDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before deserialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoAfterDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after deserialization.</summary>
        </member>
        <member name="T:ProtoBuf.CompatibilityLevel">
            <summary>
            Defines the compatibility level / conventions to use when encoding common
            types into protobuf. When starting a new green-field project the highest
            available level can be safely applied, but note that changing the
            compatibility level changes the encoding. For this reason, it should not
            be casually changed on brown-field projects, unless you are also knowingly
            breaking the encoding requirements of pre-existing data. If not specified,
            the oldest (lowest number) is assumed, for safety.
            </summary>
        </member>
        <member name="F:ProtoBuf.CompatibilityLevel.NotSpecified">
            <summary>
            Functionally identical to <see cref="F:ProtoBuf.CompatibilityLevel.Level200"/>
            </summary>
        </member>
        <member name="F:ProtoBuf.CompatibilityLevel.Level200">
            <summary>
            Uses bcl.proto for <see cref="T:System.DateTime"/>, <see cref="T:System.TimeSpan"/>, <see cref="T:System.Guid"/> and <see cref="T:System.Decimal"/>, for compatibility
            with all versions of protobuf-net, at the expense of being inconvenient for use with other protobuf implementations.
            </summary>
        </member>
        <member name="F:ProtoBuf.CompatibilityLevel.Level240">
            <summary>
            Like <see cref="F:ProtoBuf.CompatibilityLevel.Level200"/>, but uses '.google.protobuf.Timestamp' for <see cref="T:System.DateTime"/> and '.google.protobuf.Duration' for <see cref="T:System.TimeSpan"/>.
            This is functionally identical to a <see cref="F:ProtoBuf.CompatibilityLevel.Level200"/> configuration that specifies <see cref="F:ProtoBuf.DataFormat.WellKnown"/>.
            </summary>
        </member>
        <member name="F:ProtoBuf.CompatibilityLevel.Level300">
            <summary>
            Like <see cref="F:ProtoBuf.CompatibilityLevel.Level240"/>, but uses 'string' for <see cref="T:System.Guid"/> (big-endian hyphenated UUID format; a shorter 'bytes' variant is also available via <see cref="F:ProtoBuf.DataFormat.FixedSize"/>)
            and <see cref="T:System.Decimal"/> (invariant "general" format).
            </summary>
        </member>
        <member name="T:ProtoBuf.CompatibilityLevelAttribute">
            <summary>
            Defines the compatibiltiy level to use for an element
            </summary>
        </member>
        <member name="P:ProtoBuf.CompatibilityLevelAttribute.Level">
            <summary>
            The compatibiltiy level to use for this element
            </summary>
        </member>
        <member name="M:ProtoBuf.CompatibilityLevelAttribute.#ctor(ProtoBuf.CompatibilityLevel)">
            <summary>
            Create a new CompatibilityLevelAttribute instance
            </summary>
        </member>
        <member name="T:ProtoBuf.DataFormat">
            <summary>
            Sub-format to use when serializing/deserializing data
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.Default">
            <summary>
            Uses the default encoding for the data-type.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.ZigZag">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that zigzag variant encoding will be used. This means that values
            with small magnitude (regardless of sign) take a small amount
            of space to encode.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.TwosComplement">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that two's-complement variant encoding will be used.
            This means that any -ve number will take 10 bytes (even for 32-bit),
            so should only be used for compatibility.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.FixedSize">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that a fixed amount of space will be used.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.Group">
            <summary>
            When applied to a sub-message, indicates that the value should be treated
            as group-delimited.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.WellKnown">
            <summary>
            When applied to members of types such as DateTime or TimeSpan, specifies
            that the "well known" standardized representation should be use; DateTime uses Timestamp,
            TimeSpan uses Duration.
            </summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnionObject">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnionObject.Object">
            <summary>The value typed as Object</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnionObject.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnionObject.#ctor(System.Int32,System.Object)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnionObject.Reset(ProtoBuf.DiscriminatedUnionObject@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="P:ProtoBuf.DiscriminatedUnionObject.Discriminator">
            <summary>The discriminator value</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion64">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.Int64">
            <summary>The value typed as Int64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.UInt64">
            <summary>The value typed as UInt64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.Double">
            <summary>The value typed as Double</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.DateTime">
            <summary>The value typed as DateTime</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64.TimeSpan">
            <summary>The value typed as TimeSpan</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Int64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.UInt64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Double)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Nullable{System.DateTime})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.#ctor(System.Int32,System.Nullable{System.TimeSpan})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64.Reset(ProtoBuf.DiscriminatedUnion64@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="P:ProtoBuf.DiscriminatedUnion64.Discriminator">
            <summary>The discriminator value</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion128Object">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Int64">
            <summary>The value typed as Int64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.UInt64">
            <summary>The value typed as UInt64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Double">
            <summary>The value typed as Double</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.DateTime">
            <summary>The value typed as DateTime</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.TimeSpan">
            <summary>The value typed as TimeSpan</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Guid">
            <summary>The value typed as Guid</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128Object.Object">
            <summary>The value typed as Object</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Int64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.UInt64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Double)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Object)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Nullable{System.DateTime})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Nullable{System.TimeSpan})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.#ctor(System.Int32,System.Nullable{System.Guid})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128Object.Reset(ProtoBuf.DiscriminatedUnion128Object@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="P:ProtoBuf.DiscriminatedUnion128Object.Discriminator">
            <summary>The discriminator value</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion128">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Int64">
            <summary>The value typed as Int64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.UInt64">
            <summary>The value typed as UInt64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Double">
            <summary>The value typed as Double</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.DateTime">
            <summary>The value typed as DateTime</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.TimeSpan">
            <summary>The value typed as TimeSpan</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion128.Guid">
            <summary>The value typed as Guid</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Int64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.UInt64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Double)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Nullable{System.DateTime})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Nullable{System.TimeSpan})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.#ctor(System.Int32,System.Nullable{System.Guid})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion128.Reset(ProtoBuf.DiscriminatedUnion128@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="P:ProtoBuf.DiscriminatedUnion128.Discriminator">
            <summary>The discriminator value</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion64Object">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Int64">
            <summary>The value typed as Int64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.UInt64">
            <summary>The value typed as UInt64</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Double">
            <summary>The value typed as Double</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.DateTime">
            <summary>The value typed as DateTime</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.TimeSpan">
            <summary>The value typed as TimeSpan</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion64Object.Object">
            <summary>The value typed as Object</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Int64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.UInt64)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Double)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Object)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Nullable{System.DateTime})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.#ctor(System.Int32,System.Nullable{System.TimeSpan})">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion64Object.Reset(ProtoBuf.DiscriminatedUnion64Object@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="P:ProtoBuf.DiscriminatedUnion64Object.Discriminator">
            <summary>The discriminator value</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion32">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32.Reset(ProtoBuf.DiscriminatedUnion32@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="P:ProtoBuf.DiscriminatedUnion32.Discriminator">
            <summary>The discriminator value</summary>
        </member>
        <member name="T:ProtoBuf.DiscriminatedUnion32Object">
            <summary>Represent multiple types as a union; this is used as part of OneOf -
            note that it is the caller's responsbility to only read/write the value as the same type</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32Object.Int32">
            <summary>The value typed as Int32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32Object.UInt32">
            <summary>The value typed as UInt32</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32Object.Boolean">
            <summary>The value typed as Boolean</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32Object.Single">
            <summary>The value typed as Single</summary>
        </member>
        <member name="F:ProtoBuf.DiscriminatedUnion32Object.Object">
            <summary>The value typed as Object</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.Is(System.Int32)">
            <summary>Indicates whether the specified discriminator is assigned</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.#ctor(System.Int32,System.Int32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.#ctor(System.Int32,System.UInt32)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.#ctor(System.Int32,System.Single)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.#ctor(System.Int32,System.Boolean)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.#ctor(System.Int32,System.Object)">
            <summary>Create a new discriminated union value</summary>
        </member>
        <member name="M:ProtoBuf.DiscriminatedUnion32Object.Reset(ProtoBuf.DiscriminatedUnion32Object@,System.Int32)">
            <summary>Reset a value if the specified discriminator is assigned</summary>
        </member>
        <member name="P:ProtoBuf.DiscriminatedUnion32Object.Discriminator">
            <summary>The discriminator value</summary>
        </member>
        <member name="T:ProtoBuf.Extensible">
            <summary>
            Simple base class for supporting unexpected fields allowing
            for loss-less round-tips/merge, even if the data is not understod.
            The additional fields are (by default) stored in-memory in a buffer.
            </summary>
            <remarks>As an example of an alternative implementation, you might
            choose to use the file system (temporary files) as the back-end, tracking
            only the paths [such an object would ideally be IDisposable and use
            a finalizer to ensure that the files are removed].</remarks>
            <seealso cref="T:ProtoBuf.IExtensible"/>
        </member>
        <member name="M:ProtoBuf.Extensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:ProtoBuf.Extensible.GetExtensionObject(ProtoBuf.IExtension@,System.Boolean)">
            <summary>
            Provides a simple, default implementation for <see cref="T:ProtoBuf.IExtension">extension</see> support,
            optionally creating it if it does not already exist. Designed to be called by
            classes implementing <see cref="T:ProtoBuf.IExtensible"/>.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <param name="extensionObject">The extension field to check (and possibly update).</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The type of the value to append.</typeparam>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.Meta.TypeModel,ProtoBuf.IExtensible,System.Int32,``0,ProtoBuf.DataFormat)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="model">The model to use for serialization.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.Meta.TypeModel,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="model">The type model to use for deserialization.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.Meta.TypeModel,ProtoBuf.IExtensible,System.Int32,``0@,ProtoBuf.DataFormat,System.Boolean)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="model">The type model to use for deserialization.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.Meta.TypeModel,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="model">The type model to use for deserialization.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Object@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <param name="type">The data-type of the field.</param>
            <param name="model">The model to use for configuration.</param>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <param name="model">The model to use for configuration.</param>
            <param name="type">The data-type of the field.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue(ProtoBuf.Meta.TypeModel,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Object)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <param name="model">The model to use for configuration.</param>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="T:ProtoBuf.ExtensibleUtil">
            <summary>
            This class acts as an internal wrapper allowing us to do a dynamic
            methodinfo invoke; an't put into Serializer as don't want on public
            API; can't put into Serializer&lt;T&gt; since we need to invoke
            across classes
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues``1(ProtoBuf.Meta.TypeModel,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
        </member>
        <member name="T:ProtoBuf.Helpers">
            <summary>
            Not all frameworks are created equal (fx1.1 vs fx2.0,
            micro-framework, compact-framework,
            silverlight, etc). This class simply wraps up a few things that would
            otherwise make the real code unnecessarily messy, providing fallback
            implementations if necessary.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoTypeCode">
            <summary>
            Intended to be a direct map to regular TypeCode, but:
            - with missing types
            - existing on WinRT
            </summary>
        </member>
        <member name="T:ProtoBuf.IExtensible">
            <summary>
            Indicates that the implementing type has support for protocol-buffer
            <see cref="T:ProtoBuf.IExtension">extensions</see>.
            </summary>
            <remarks>Can be implemented by deriving from Extensible.</remarks>
        </member>
        <member name="M:ProtoBuf.IExtensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="T:ProtoBuf.IExtension">
            <summary>
            Provides addition capability for supporting unexpected fields during
            protocol-buffer serialization/deserialization. This allows for loss-less
            round-trip/merge, even when the data is not fully understood.
            </summary>
        </member>
        <member name="M:ProtoBuf.IExtension.BeginAppend">
            <summary>
            Requests a stream into which any unexpected fields can be persisted.
            </summary>
            <returns>A new stream suitable for storing data.</returns>
        </member>
        <member name="M:ProtoBuf.IExtension.EndAppend(System.IO.Stream,System.Boolean)">
            <summary>
            Indicates that all unexpected fields have now been stored. The
            implementing class is responsible for closing the stream. If
            "commit" is not true the data may be discarded.
            </summary>
            <param name="stream">The stream originally obtained by BeginAppend.</param>
            <param name="commit">True if the append operation completed successfully.</param>
        </member>
        <member name="M:ProtoBuf.IExtension.BeginQuery">
            <summary>
            Requests a stream of the unexpected fields previously stored.
            </summary>
            <returns>A prepared stream of the unexpected fields.</returns>
        </member>
        <member name="M:ProtoBuf.IExtension.EndQuery(System.IO.Stream)">
            <summary>
            Indicates that all unexpected fields have now been read. The
            implementing class is responsible for closing the stream.
            </summary>
            <param name="stream">The stream originally obtained by BeginQuery.</param>
        </member>
        <member name="M:ProtoBuf.IExtension.GetLength">
            <summary>
            Requests the length of the raw binary stream; this is used
            when serializing sub-entities to indicate the expected size.
            </summary>
            <returns>The length of the binary stream representing unexpected data.</returns>
        </member>
        <member name="T:ProtoBuf.IExtensionResettable">
            <summary>
            Provides the ability to remove all existing extension data
            </summary>
        </member>
        <member name="M:ProtoBuf.IExtensionResettable.Reset">
            <summary>
            Remove all existing extension data
            </summary>
        </member>
        <member name="T:ProtoBuf.ImplicitFields">
            <summary>
            Specifies the method used to infer field tags for members of the type
            under consideration. Tags are deduced using the invariant alphabetic
            sequence of the members' names; this makes implicit field tags very brittle,
            and susceptible to changes such as field names (normally an isolated
            change).
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.None">
            <summary>
            No members are serialized implicitly; all members require a suitable
            attribute such as [ProtoMember]. This is the recmomended mode for
            most scenarios.
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.AllPublic">
            <summary>
            Public properties and fields are eligible for implicit serialization;
            this treats the public API as a contract. Ordering beings from ImplicitFirstTag.
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.AllFields">
            <summary>
            Public and non-public fields are eligible for implicit serialization;
            this acts as a state/implementation serializer. Ordering beings from ImplicitFirstTag.
            </summary>
        </member>
        <member name="T:ProtoBuf.Internal.PrimaryTypeProvider.DecimalAccessor">
            <summary>
            Provides access to the inner fields of a decimal.
            Similar to decimal.GetBits(), but faster and avoids the int[] allocation
            </summary>
        </member>
        <member name="T:ProtoBuf.Internal.PrimaryTypeProvider.GuidAccessor">
            <summary>
            Provides access to the inner fields of a Guid.
            Similar to Guid.ToByteArray(), but faster and avoids the byte[] allocation
            </summary>
        </member>
        <member name="M:ProtoBuf.Internal.ReferenceValueChecker.ProtoBuf#Internal#IValueChecker{System#Object}#HasNonTrivialValue(System.Object)">
            <summary>
            Indicates whether a value is non-null and needs serialization (non-zero, not an empty string, etc)
            </summary>
        </member>
        <member name="M:ProtoBuf.Internal.ReferenceValueChecker.ProtoBuf#Internal#IValueChecker{System#Object}#IsNull(System.Object)">
            <summary>
            Indicates whether a value is null
            </summary>
        </member>
        <member name="T:ProtoBuf.IProtoInput`1">
            <summary>
            Represents the ability to deserialize values from an input of type <typeparamref name="TInput"/>
            </summary>
        </member>
        <member name="M:ProtoBuf.IProtoInput`1.Deserialize``1(`0,``0,System.Object)">
            <summary>
            Deserialize a value from the input
            </summary>
        </member>
        <member name="T:ProtoBuf.IProtoOutput`1">
            <summary>
            Represents the ability to serialize values to an output of type <typeparamref name="TOutput"/>
            </summary>
        </member>
        <member name="M:ProtoBuf.IProtoOutput`1.Serialize``1(`0,``0,System.Object)">
            <summary>
            Serialize the provided value
            </summary>
        </member>
        <member name="T:ProtoBuf.IMeasuredProtoOutput`1">
            <summary>
            Represents the ability to serialize values to an output of type <typeparamref name="TOutput"/>
            with pre-computation of the length
            </summary>
        </member>
        <member name="M:ProtoBuf.IMeasuredProtoOutput`1.Measure``1(``0,System.Object)">
            <summary>
            Measure the length of a value in advance of serialization
            </summary>
        </member>
        <member name="M:ProtoBuf.IMeasuredProtoOutput`1.Serialize``1(ProtoBuf.MeasureState{``0},`0)">
            <summary>
            Serialize the previously measured value
            </summary>
        </member>
        <member name="T:ProtoBuf.ISerializationContext">
            <summary>
            Represents common state during a serialization operation; this instance should not be stored - it may be reused later with different meaning
            </summary>
        </member>
        <member name="P:ProtoBuf.ISerializationContext.Model">
            <summary>
            The type-model that represents the operation
            </summary>
        </member>
        <member name="P:ProtoBuf.ISerializationContext.UserState">
            <summary>
            Addition information about this serialization operation.
            </summary>
        </member>
        <member name="T:ProtoBuf.MeasureState`1">
            <summary>
            Represents the outcome of computing the length of an object; since this may have required computing lengths
            for multiple objects, some metadata is retained so that a subsequent serialize operation using
            this instance can re-use the previously calculated lengths. If the object state changes between the
            measure and serialize operations, the behavior is undefined.
            </summary>
        </member>
        <member name="M:ProtoBuf.MeasureState`1.Dispose">
            <summary>
            Releases all resources associated with this value
            </summary>
        </member>
        <member name="P:ProtoBuf.MeasureState`1.Length">
            <summary>
            Gets the calculated length of this serialize operation, in bytes
            </summary>
        </member>
        <member name="M:ProtoBuf.MeasureState`1.LengthOnly">
            <summary>
            Returns the calculated length, disposing the value as a side-effect
            </summary>
        </member>
        <member name="M:ProtoBuf.MeasureState`1.Serialize(System.IO.Stream)">
            <summary>
            Perform the calculated serialization operation against the provided target stream. If the object state changes between the
            measure and serialize operations, the behavior is undefined.
            </summary>
        </member>
        <member name="M:ProtoBuf.MeasureState`1.Serialize(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Perform the calculated serialization operation against the provided target writer. If the object state changes between the
            measure and serialize operations, the behavior is undefined.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.ProtoSyntax">
            <summary>
            Indiate the variant of the protobuf .proto DSL syntax to use
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.ProtoSyntax.Default">
            <summary>
            Use the global default
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.ProtoSyntax.Proto2">
            <summary>
            https://developers.google.com/protocol-buffers/docs/proto
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.ProtoSyntax.Proto3">
            <summary>
            https://developers.google.com/protocol-buffers/docs/proto3
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeFormatEventArgs">
            <summary>
            Event arguments needed to perform type-formatting functions; this could be resolving a Type to a string suitable for serialization, or could
            be requesting a Type from a string. If no changes are made, a default implementation will be used (from the assembly-qualified names).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.Type">
            <summary>
            The type involved in this map; if this is initially null, a Type is expected to be provided for the string in FormattedName.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.FormattedName">
            <summary>
            The formatted-name involved in this map; if this is initially null, a formatted-name is expected from the type in Type.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeFormatEventHandler">
            <summary>
            Delegate type used to perform type-formatting functions; the sender originates as the type-model.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeModel">
            <summary>
            Provides protobuf serialization support for a number of types
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetSerializer``2">
            <summary>
            Gets a cached serializer for a type, as offered by a given provider
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeModel.TypeModelOptions">
            <summary>
            Specifies optional behaviors associated with a type model
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.TypeModelOptions.None">
            <summary>
            No additional options
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.TypeModelOptions.InternStrings">
            <summary>
            Should the deserializer attempt to avoid duplicate copies of the same string?
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.TypeModelOptions.IncludeDateTimeKind">
            <summary>
            Should the <c>Kind</c> be included on date/time values?
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.TypeModelOptions.SkipZeroLengthPackedArrays">
            <summary>
            Should zero-length packed arrays be serialized? (this is the v2 behavior, but skipping them is more efficient)
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.TypeModelOptions.AllowPackedEncodingAtRoot">
            <summary>
            Should root-values allow "packed" encoding? (v2 does not support this)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeModel.Options">
            <summary>
            Specifies optional behaviors associated with this model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.MapType(System.Type)">
            <summary>
            Resolve a System.Type to the compiler-specific type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.MapType(System.Type,System.Boolean)">
            <summary>
            Resolve a System.Type to the compiler-specific type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.IsKnownType``1(ProtoBuf.CompatibilityLevel)">
            <summary>
            Indicates whether a type is known to the model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.TrySerializeAuxiliaryType(ProtoBuf.ProtoWriter.State@,System.Type,ProtoBuf.DataFormat,System.Int32,System.Object,System.Boolean,System.Object)">
            <summary>
            This is the more "complete" version of Serialize, which handles single instances of mapped types.
            The value is written as a complete field, including field-header and (for sub-objects) a
            length-prefix
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IEnumerable sequences of any type handled by TrySerializeAuxiliaryType
             
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object,ProtoBuf.SerializationContext)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.Buffers.IBufferWriter{System.Byte},System.Object,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied writer.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="userState">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize``1(System.IO.Stream,``0,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="userState">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize``1(System.Buffers.IBufferWriter{System.Byte},``0,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied writer.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="userState">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Measure``1(``0,System.Object,System.Int64)">
            <summary>
            Calculates the length of a protocol-buffer payload for an item
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(ProtoBuf.ProtoWriter,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied writer.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination writer to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.TypeResolver)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.TypeResolver,System.Int32@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <param name="bytesRead">Returns the number of bytes consumed by this operation (includes length-prefix overheads and any skipped data).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.TypeResolver,System.Int64@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <param name="bytesRead">Returns the number of bytes consumed by this operation (includes length-prefix overheads and any skipped data).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.TypeResolver)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Meta.TypeModel.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
            <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.TypeResolver,ProtoBuf.SerializationContext)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Meta.TypeModel.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
            <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
            <returns>The sequence of deserialized objects.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Meta.TypeModel.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Meta.TypeModel.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="type">The type being serialized.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="type">The type being serialized.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize``1(System.IO.Stream,``0,System.Object)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <typeparam name="T">The type (including inheritance) to consider.</typeparam>
            <param name="userState">Additional information about this serialization operation.</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize``1(System.ReadOnlyMemory{System.Byte},``0,System.Object)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <typeparam name="T">The type (including inheritance) to consider.</typeparam>
            <param name="userState">Additional information about this serialization operation.</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize``1(System.Buffers.ReadOnlySequence{System.Byte},``0,System.Object)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <typeparam name="T">The type (including inheritance) to consider.</typeparam>
            <param name="userState">Additional information about this serialization operation.</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int64)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume (or -1 to read to the end of the stream).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int64,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume (or -1 to read to the end of the stream).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.ReadOnlyMemory{System.Byte},System.Type,System.Object,System.Object)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary payload  to apply to the instance.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="userState">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.Buffers.ReadOnlySequence{System.Byte},System.Type,System.Object,System.Object)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary payload  to apply to the instance.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="userState">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(ProtoBuf.ProtoReader,System.Object,System.Type)">
            <summary>
            Applies a protocol-buffer reader to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The reader to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.TryDeserializeAuxiliaryType(ProtoBuf.ProtoReader.State@,ProtoBuf.DataFormat,System.Int32,System.Type,System.Object@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Object)">
            <summary>
            <para>
            This is the more "complete" version of Deserialize, which handles single instances of mapped types.
            The value is read as a complete field, including field-header and (for sub-objects) a
            length-prefix..kmc  
            </para>
            <para>
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IList sets of any type handled by TryDeserializeAuxiliaryType
            </para>
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Create">
            <summary>
            Creates a new runtime model, to which the caller
            can add support for a range of types. A model
            can be used "as is", or can be compiled for
            optimal performance.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CreateForAssembly``1">
            <summary>
            Create a model that serializes all types from an
            assembly specified by type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CreateForAssembly(System.Type)">
            <summary>
            Create a model that serializes all types from an
            assembly specified by type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CreateForAssembly(System.Reflection.Assembly)">
            <summary>
            Create a model that serializes all types from an assembly
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.IsDefined(System.Type)">
            <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.IsDefined(System.Type,ProtoBuf.CompatibilityLevel)">
            <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetSerializer``1">
            <summary>
            Get a typed serializer for <typeparamref name="T"/>
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetInbuiltSerializer``1(ProtoBuf.CompatibilityLevel,ProtoBuf.DataFormat)">
            <summary>
            Gets the inbuilt serializer relevant to a specific <see cref="T:ProtoBuf.CompatibilityLevel"/> (and <see cref="T:ProtoBuf.DataFormat"/>).
            Returns null if there is no defined inbuilt serializer.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(ProtoBuf.Internal.ObjectScope,ProtoBuf.ProtoReader.State@,System.Type,System.Object)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="state">Reader state</param>
            <param name="scope">The style of serialization to adopt</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="T:ProtoBuf.Meta.TypeModel.CallbackType">
            <summary>
            Indicates the type of callback to be used
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.BeforeSerialize">
            <summary>
            Invoked before an object is serialized
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.AfterSerialize">
            <summary>
            Invoked after an object is serialized
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.BeforeDeserialize">
            <summary>
            Invoked before an object is deserialized (or when a new instance is created)
            </summary>            
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.AfterDeserialize">
            <summary>
            Invoked after an object is deserialized
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeepClone``1(``0,System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeepClone(System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedSubtype(System.Type,System.Type)">
            <summary>
            Indicates that while an inheritance tree exists, the exact type encountered was not
            specified in that hierarchy and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedSubtype``1(``0)">
            <summary>
            Indicates that while an inheritance tree exists, the exact type encountered was not
            specified in that hierarchy and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedSubtype``2(``0)">
            <summary>
            Indicates that while an inheritance tree exists, the exact type encountered was not
            specified in that hierarchy and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.IsSubType``1(``0)">
            <summary>
            Returns whether the object provided is a subtype of the expected type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedType(System.Type,ProtoBuf.Meta.TypeModel)">
            <summary>
            Indicates that the given type was not expected, and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowCannotCreateInstance(System.Type,System.Exception)">
            <summary>
            Indicates that the given type cannot be constructed; it may still be possible to 
            deserialize into existing instances.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerializeContractType(System.Type)">
            <summary>
            Returns true if the type supplied is either a recognised contract type,
            or a *list* of a recognised contract type. 
            </summary>
            <remarks>Note that primitives always return false, even though the engine
            will, if forced, try to serialize such</remarks>
            <returns>True if this type is recognised as a serializable entity, else false</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerialize(System.Type)">
            <summary>
            Returns true if the type supplied is a basic type with inbuilt handling,
            a recognised contract type, or a *list* of a basic / contract type. 
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerializeBasicType(System.Type)">
            <summary>
            Returns true if the type supplied is a basic type with inbuilt handling,
            or a *list* of a basic type with inbuilt handling
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetSchema(System.Type)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetSchema(System.Type,ProtoBuf.Meta.ProtoSyntax)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
            <returns>The .proto definition as a string</returns>
            <param name="syntax">The .proto syntax to use for the operation</param>
        </member>
        <member name="E:ProtoBuf.Meta.TypeModel.DynamicTypeFormatting">
            <summary>
            Used to provide custom services for writing and parsing type names when using dynamic types. Both parsing and formatting
            are provided on a single API as it is essential that both are mapped identically at all times.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CreateFormatter(System.Type)">
            <summary>
            Creates a new IFormatter that uses protocol-buffer [de]serialization.
            </summary>
            <returns>A new IFormatter to be used during [de]serialization.</returns>
            <param name="type">The type of object to be [de]deserialized by the formatter.</param>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.ListItemTag">
            <summary>
            The field number that is used as a default when serializing/deserializing a list of objects.
            The data is treated as repeated message with field number 1.
            </summary>
        </member>
        <member name="T:ProtoBuf.PrefixStyle">
            <summary>
            Specifies the type of prefix that should be applied to messages.
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.None">
            <summary>
            No length prefix is applied to the data; the data is terminated only be the end of the stream.
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Base128">
            <summary>
            A base-128 ("varint", the default prefix format in protobuf) length prefix is applied to the data (efficient for short messages).
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Fixed32">
            <summary>
            A fixed-length (little-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Fixed32BigEndian">
            <summary>
            A fixed-length (big-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoContractAttribute">
            <summary>
            Indicates that a type is defined for protocol-buffer serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.Name">
            <summary>
            Gets or sets the defined name of the type.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFirstTag">
            <summary>
            Gets or sets the fist offset to use with implicit field tags;
            only uesd if ImplicitFields is set.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.UseProtoMembersOnly">
            <summary>
            If specified, alternative contract markers (such as markers for XmlSerailizer or DataContractSerializer) are ignored.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.IgnoreListHandling">
            <summary>
            If specified, do NOT treat this type as a list, even if it looks like one.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFields">
            <summary>
            Gets or sets the mechanism used to automatically infer field tags
            for members. This option should be used in advanced scenarios only.
            Please review the important notes against the ImplicitFields enumeration.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromName">
            <summary>
            Enables/disables automatic tag generation based on the existing name / order
            of the defined members. This option is not used for members marked
            with ProtoMemberAttribute, as intended to provide compatibility with
            WCF serialization. WARNING: when adding new fields you must take
            care to increase the Order for new elements, otherwise data corruption
            may occur.
            </summary>
            <remarks>If not explicitly specified, the default is assumed from Serializer.GlobalOptions.InferTagFromName.</remarks>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromNameHasValue">
            <summary>
            Has a InferTagFromName value been explicitly set? if not, the default from the type-model is assumed.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.DataMemberOffset">
            <summary>
            Specifies an offset to apply to [DataMember(Order=...)] markers;
            this is useful when working with mex-generated classes that have
            a different origin (usually 1 vs 0) than the original data-contract.
            
            This value is added to the Order of each member.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.SkipConstructor">
            <summary>
            If true, the constructor for the type is bypassed during deserialization, meaning any field initializers
            or other initialization code is skipped.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.AsReferenceDefault">
            <summary>
            Should this type be treated as a reference by default? Please also see the implications of this,
            as recorded on ProtoMemberAttribute.AsReference
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.IsGroup">
            <summary>
            Indicates whether this type should always be treated as a "group" (rather than a string-prefixed sub-message)
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.EnumPassthru">
            <summary>
            Applies only to enums (not to DTO classes themselves); gets or sets a value indicating that an enum should be treated directly as an int/short/etc, rather
            than enforcing .proto enum rules. This is useful *in particul* for [Flags] enums.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.Surrogate">
            <summary>
            Defines a surrogate type used for serialization/deserialization purpose.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.Serializer">
            <summary>
            Defines a serializer to use for this type; the serializer must implement ISerializer-T for this type
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoConverterAttribute">
            <summary>
            Indicates that a static member should be considered the same as though
            were an implicit / explicit conversion operator; in particular, this
            is useful for conversions that operator syntax does not allow, such as
            to/from interface types.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoEnumAttribute">
            <summary>
            Used to define protocol-buffer specific behavior for
            enumerated values.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoEnumAttribute.Value">
            <summary>
            Gets or sets the specific value to use for this enum during serialization.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoEnumAttribute.HasValue">
            <summary>
            Indicates whether this instance has a customised value mapping
            </summary>
            <returns>true if a specific value is set</returns>
        </member>
        <member name="P:ProtoBuf.ProtoEnumAttribute.Name">
            <summary>
            Gets or sets the defined name of the enum, as used in .proto
            (this name is not used during serialization).
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoException">
            <summary>
            Indicates an error during serialization/deserialization of a proto stream.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.String)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.String,System.Exception)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoPartialIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields. This allows
            ProtoIgnoreAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoPartialIgnoreAttribute.#ctor(System.String)">
            <summary>
            Creates a new ProtoPartialIgnoreAttribute instance.
            </summary>
            <param name="memberName">Specifies the member to be ignored.</param>
        </member>
        <member name="P:ProtoBuf.ProtoPartialIgnoreAttribute.MemberName">
            <summary>
            The name of the member to be ignored.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoIncludeAttribute">
            <summary>
            Indicates the known-types to support for an individual
            message. This serializes each level in the hierarchy as
            a nested message to retain wire-compatibility with
            other protocol-buffer implementations.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.Type)">
            <summary>
             Creates a new instance of the ProtoIncludeAttribute.
             </summary>
             <param name="tag">The unique index (within the type) that will identify this data.</param>
             <param name="knownType">The additional type to serialize/deserialize.</param>
        </member>
        <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new instance of the ProtoIncludeAttribute.
            </summary>
            <param name="tag">The unique index (within the type) that will identify this data.</param>
            <param name="knownTypeName">The additional type to serialize/deserialize.</param>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.Tag">
            <summary>
            Gets the unique index (within the type) that will identify this data.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownTypeName">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownType">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.DataFormat">
            <summary>
            Specifies whether the inherited type's sub-message should be
            written with a length-prefix (default), or with group markers.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoMapAttribute">
            <summary>
            Controls the formatting of elements in a dictionary, and indicates that
            "map" rules should be used: duplicates *replace* earlier values, rather
            than throwing an exception
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMapAttribute.KeyFormat">
            <summary>
            Describes the data-format used to store the key
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMapAttribute.ValueFormat">
            <summary>
            Describes the data-format used to store the value
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMapAttribute.DisableMap">
            <summary>
            Disables "map" handling; dictionaries will use ".Add(key,value)" instead of  "[key] = value",
            which means duplicate keys will cause an exception (instead of retaining the final value); if
            a proto schema is emitted, it will be produced using "repeated" instead of "map"
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag. A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(System.Object)">
            <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(ProtoBuf.ProtoMemberAttribute)">
            <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.#ctor(System.Int32)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Name">
            <summary>
            Gets or sets the original name defined in the .proto; not used
            during serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.DataFormat">
            <summary>
            Gets or sets the data-format to be used when encoding this value.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Tag">
            <summary>
            Gets the unique tag used to identify this member within the type.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.IsRequired">
            <summary>
            Gets or sets a value indicating whether this member is mandatory.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.IsPacked">
            <summary>
            Gets a value indicating whether this member is packed.
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.OverwriteList">
            <summary>
            Indicates whether this field should *replace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Options">
            <summary>
            Gets or sets a value indicating whether this member is packed (lists/arrays).
            </summary>
        </member>
        <member name="T:ProtoBuf.MemberSerializationOptions">
            <summary>
            Additional (optional) settings that control serialization of members
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.None">
            <summary>
            Default; no additional options
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.Packed">
            <summary>
            Indicates that repeated elements should use packed (length-prefixed) encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.Required">
            <summary>
            Indicates that the given item is required
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.AsReference">
            <summary>
            Enables full object-tracking/full-graph support
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.OverwriteList">
            <summary>
            Indicates whether this field should *replace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.AsReferenceHasValue">
            <summary>
            Determines whether the types AsReferenceDefault value is used, or whether this member's AsReference should be used
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoPartialMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag and MemberName. This allows ProtoMemberAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoPartialMemberAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
            <param name="memberName">Specifies the member to be serialized.</param>
        </member>
        <member name="P:ProtoBuf.ProtoPartialMemberAttribute.MemberName">
            <summary>
            The name of the member to be serialized.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoReader">
            <summary>
            A stateful reader, used to read a protobuf stream. Typical usage would be (sequentially) to call
            ReadFieldHeader and (after matching the field) an appropriate Read* method.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.FieldNumber">
            <summary>
            Gets the number of the field being processed.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.WireType">
            <summary>
            Indicates the underlying proto serialization format on the wire.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.InternStrings">
            <summary>
            Gets / sets a flag indicating whether strings should be checked for repetition; if
            true, any repeated UTF-8 byte sequence will result in the same String instance, rather
            than a second instance of the same string. Disabled by default. Note that this uses
            a <i>custom</i> interner - the system-wide string interner is not used.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Init(ProtoBuf.Meta.TypeModel,System.Object)">
            <summary>
            Initialize the reader
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.UserState">
            <summary>
            Addition information about this deserialization operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Context">
            <summary>
            Addition information about this deserialization operation.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Dispose">
            <summary>
            Releases resources used by the reader, but importantly <b>does not</b> Dispose the 
            underlying stream; in many typical use-cases the stream is used for different
            processes, so it is assumed that the consumer will Dispose their stream separately.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Position">
            <summary>
            Returns the position of the current reader (note that this is not necessarily the same as the position
            in the underlying stream, if multiple readers are used on the same stream)
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.LongPosition">
            <summary>
            Returns the position of the current reader (note that this is not necessarily the same as the position
            in the underlying stream, if multiple readers are used on the same stream)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt16">
            <summary>
            Reads a signed 16-bit integer from the stream: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt16">
            <summary>
            Reads an unsigned 16-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadByte">
            <summary>
            Reads an unsigned 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadSByte">
            <summary>
            Reads a signed 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt32">
            <summary>
            Reads an unsigned 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt32">
            <summary>
            Reads a signed 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt64">
            <summary>
            Reads a signed 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadString">
            <summary>
            Reads a string from the stream (using UTF8); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ThrowEnumException(System.Type,System.Int32)">
            <summary>
            Throws an exception indication that the given value cannot be mapped to an enum.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadDouble">
            <summary>
            Reads a double-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadObject(System.Object,System.Type,ProtoBuf.ProtoReader)">
            <summary>
            Reads (merges) a sub-message from the stream, internally calling StartSubItem and EndSubItem, and (in between)
            parsing the message in accordance with the model associated with the reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoReader)">
            <summary>
            Makes the end of consuming a nested message in the stream; the stream must be either at the correct EndGroup
            marker, or all fields of the sub-message must have been consumed (in either case, this means ReadFieldHeader
            should return zero)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.StartSubItem(ProtoBuf.ProtoReader)">
            <summary>
            Begins consuming a nested message in the stream; supported wire-types: StartGroup, String
            </summary>
            <remarks>The token returned must be help and used when callining EndSubItem</remarks>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadFieldHeader">
            <summary>
            Reads a field header from the stream, setting the wire-type and retuning the field number. If no
            more fields are available, then 0 is returned. This methods respects sub-messages.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.TryReadFieldHeader(System.Int32)">
            <summary>
            Looks ahead to see whether the next field in the stream is what we expect
            (typically; what we've just finished reading - for example ot read successive list items)
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Model">
            <summary>
            Get the TypeModel associated with this reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Hint(ProtoBuf.WireType)">
            <summary>
            Compares the streams current wire-type to the hinted wire-type, updating the reader if necessary; for example,
            a Variant may be updated to SignedVariant. If the hinted wire-type is unrelated then no change is made.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Assert(ProtoBuf.WireType)">
            <summary>
            Verifies that the stream's current wire-type is as expected, or a specialized sub-type (for example,
            SignedVariant) - in which case the current wire-type is updated. Otherwise an exception is thrown.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.SkipField">
            <summary>
            Discards the data for the current field.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt64">
            <summary>
            Reads an unsigned 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadSingle">
            <summary>
            Reads a single-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadBoolean">
            <summary>
            Reads a boolean value from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.AppendBytes(System.Byte[],ProtoBuf.ProtoReader)">
            <summary>
            Reads a byte-sequence from the stream, appending them to an existing byte-sequence (which can be null); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadLittleEndianInt32(System.IO.Stream)">
            <summary>
            Reads a little-endian encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBigEndianInt32(System.IO.Stream)">
            <summary>
            Reads a big-endian encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadVarintInt32(System.IO.Stream)">
            <summary>
            Reads a varint encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBytes(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a string (of a given lenth, in bytes) directly from the source into a pre-existing buffer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBytes(System.IO.Stream,System.Int32)">
            <summary>
            Reads a given number of bytes directly from the source. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadString(System.IO.Stream,System.Int32)">
            <summary>
            Reads a string (of a given lenth, in bytes) directly from the source. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLongLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.TryReadUInt64Varint(System.IO.Stream,System.UInt64@)">
            <summary>Read a varint if possible</summary>
            <returns>The number of bytes consumed; 0 if no data available</returns>
        </member>
        <member name="M:ProtoBuf.ProtoReader.AppendExtensionData(ProtoBuf.IExtensible)">
            <summary>
            Copies the current field into the instance as extension data
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.HasSubValue(ProtoBuf.WireType,ProtoBuf.ProtoReader)">
            <summary>
            Indicates whether the reader still has data remaining in the current sub-item,
            additionally setting the wire-type for the next field if there is more data.
            This is used when decoding packed data.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadType">
            <summary>
            Reads a Type from the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Merge(ProtoBuf.ProtoReader,System.Object,System.Object)">
            <summary>
            Merge two objects using the details from the current reader; this is used to change the type
            of objects when an inheritance relationship is discovered later than usual during deserilazation.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoReader.State">
            <summary>
            Holds state used by the deserializer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.Create(System.Buffers.ReadOnlySequence{System.Byte},ProtoBuf.Meta.TypeModel,System.Object)">
            <summary>
            Creates a new reader against a multi-segment buffer
            </summary>
            <param name="source">The source buffer</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="userState">Additional context about this serialization operation</param>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.Create(System.ReadOnlyMemory{System.Byte},ProtoBuf.Meta.TypeModel,System.Object)">
            <summary>
            Creates a new reader against a multi-segment buffer
            </summary>
            <param name="source">The source buffer</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="userState">Additional context about this serialization operation</param>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.Dispose">
            <summary>
            Release any resources associated with this instance
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadUInt16">
            <summary>
            Reads an unsigned 16-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadInt16">
            <summary>
            Reads a signed 16-bit integer from the stream: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.GetPosition">
            <summary>
            Returns the position of the current reader (note that this is not necessarily the same as the position
            in the underlying stream, if multiple readers are used on the same stream)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadByte">
            <summary>
            Reads an unsigned 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadSByte">
            <summary>
            Reads a signed 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadUInt32">
            <summary>
            Reads an unsigned 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadInt32">
            <summary>
            Reads a signed 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadInt64">
            <summary>
            Reads a signed 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadDouble">
            <summary>
            Reads a double-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadSingle">
            <summary>
            Reads a single-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadBoolean">
            <summary>
            Reads a boolean value from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadUInt64">
            <summary>
            Reads an unsigned 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.AppendBytes(System.Byte[])">
            <summary>
            Reads a byte-sequence from the stream, appending them to an existing byte-sequence (which can be null); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.AppendBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Reads a byte-sequence from the stream, appending them to an existing byte-sequence; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.AppendBytes(System.Memory{System.Byte})">
            <summary>
            Reads a byte-sequence from the stream, appending them to an existing byte-sequence; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.AppendBytes(System.ArraySegment{System.Byte})">
            <summary>
            Reads a byte-sequence from the stream, appending them to an existing byte-sequence; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.AppendBytes``1(``0,ProtoBuf.Serializers.IMemoryConverter{``0,System.Byte})">
            <summary>
            Reads a byte-sequence from the stream, appending them to an existing byte-sequence (which can be null); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadBytes(System.Span{System.Byte})">
            <summary>
            Tries to read a string-like type directly into a span; if successful, the span
            returned indicates the available amount of data; if unsuccessful, an exception
            is thrown; this should only be used when there is confidence that the length
            is bounded.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.StartSubItem">
            <summary>
            Begins consuming a nested message in the stream; supported wire-types: StartGroup, String
            </summary>
            <remarks>The token returned must be help and used when callining EndSubItem</remarks>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.EndSubItem(ProtoBuf.SubItemToken)">
            <summary>
            Makes the end of consuming a nested message in the stream; the stream must be either at the correct EndGroup
            marker, or all fields of the sub-message must have been consumed (in either case, this means ReadFieldHeader
            should return zero)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadObject(System.Object,System.Type)">
            <summary>
            Reads (merges) a sub-message from the stream, internally calling StartSubItem and EndSubItem, and (in between)
            parsing the message in accordance with the model associated with the reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadString(ProtoBuf.StringMap)">
            <summary>
            Reads a string from the stream (using UTF8); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.Assert(ProtoBuf.WireType)">
            <summary>
            Verifies that the stream's current wire-type is as expected, or a specialized sub-type (for example,
            SignedVariant) - in which case the current wire-type is updated. Otherwise an exception is thrown.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.SkipField">
            <summary>
            Discards the data for the current field.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadFieldHeader">
            <summary>
            Reads a field header from the stream, setting the wire-type and retuning the field number. If no
            more fields are available, then 0 is returned. This methods respects sub-messages.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.TryReadFieldHeader(System.Int32)">
            <summary>
            Looks ahead to see whether the next field in the stream is what we expect
            (typically; what we've just finished reading - for example ot read successive list items)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.Hint(ProtoBuf.WireType)">
            <summary>
            Compares the streams current wire-type to the hinted wire-type, updating the reader if necessary; for example,
            a Variant may be updated to SignedVariant. If the hinted wire-type is unrelated then no change is made.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ThrowEnumException(System.Type,System.Int32)">
            <summary>
            Throws an exception indication that the given value cannot be mapped to an enum.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.AppendExtensionData(ProtoBuf.IExtensible)">
            <summary>
            Copies the current field into the instance as extension data
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.State.WireType">
            <summary>
            Indicates the underlying proto serialization format on the wire.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.State.InternStrings">
            <summary>
            Gets / sets a flag indicating whether strings should be checked for repetition; if
            true, any repeated UTF-8 byte sequence will result in the same String instance, rather
            than a second instance of the same string. Disabled by default. Note that this uses
            a <i>custom</i> interner - the system-wide string interner is not used.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.State.FieldNumber">
            <summary>
            Gets the number of the field being processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadType">
            <summary>
            Reads a Type from the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadMessage``1(``0)">
            <summary>
            Reads a sub-item from the input reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadMessage``1(ProtoBuf.Serializers.SerializerFeatures,``0,ProtoBuf.Serializers.ISerializer{``0})">
            <summary>
            Reads a sub-item from the input reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadMessage``2(ProtoBuf.Serializers.SerializerFeatures,``1,``0@)">
            <summary>
            Reads a sub-item from the input reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadAny``1(``0)">
            <summary>
            Reads a value or sub-item from the input reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadAny``1(ProtoBuf.Serializers.SerializerFeatures,``0,ProtoBuf.Serializers.ISerializer{``0})">
            <summary>
            Reads a value or sub-item from the input reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.ReadBaseType``2(``1,ProtoBuf.Serializers.ISubTypeSerializer{``0})">
            <summary>
            Reads a sub-item from the input reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.DeserializeRoot``1(``0,ProtoBuf.Serializers.ISerializer{``0})">
            <summary>
            Deserialize an instance of the provided type
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.State.Context">
            <summary>
            Gets the serialization context associated with this instance;
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.HasSubValue(ProtoBuf.WireType)">
            <summary>
            Indicates whether the reader still has data remaining in the current sub-item,
            additionally setting the wire-type for the next field if there is more data.
            This is used when decoding packed data.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.CreateInstance``1(ProtoBuf.Serializers.ISerializer{``0})">
            <summary>
            Create an instance of the provided type, respecting any custom factory rules
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.State.Create(System.IO.Stream,ProtoBuf.Meta.TypeModel,System.Object,System.Int64)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="userState">Additional context about this serialization operation</param>
            <param name="length">The number of bytes to read, or -1 to read until the end of the stream</param>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DefaultState">
            <summary>
            Get the default state associated with this reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Create(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext,System.Int64)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
            <param name="length">The number of bytes to read, or -1 to read until the end of the stream</param>
        </member>
        <member name="M:ProtoBuf.ProtoReader.StreamProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext,System.Int32)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
            <param name="length">The number of bytes to read, or -1 to read until the end of the stream</param>
        </member>
        <member name="M:ProtoBuf.ProtoReader.StreamProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext,System.Int64)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
            <param name="length">The number of bytes to read, or -1 to read until the end of the stream</param>
        </member>
        <member name="M:ProtoBuf.ProtoReader.StreamProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
        </member>
        <member name="T:ProtoBuf.ProtoReservedAttribute">
            <summary>
            Indicates a reserved field or range
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReservedAttribute.From">
            <summary>
            The start of a numeric field range
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReservedAttribute.To">
            <summary>
            The end of a numeric field range
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReservedAttribute.Name">
            <summary>
            A named field reservation
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReservedAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new instance of a single number field reservation
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReservedAttribute.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a new instance of a range number field reservation
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReservedAttribute.Comment">
            <summary>
            Records a comment explaining this reservation
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReservedAttribute.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of a named field reservation
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoWriter">
            <summary>
            <para>Represents an output stream for writing protobuf data.</para>
            <para>
            Why is the API backwards (static methods with writer arguments)?
            See: http://marcgravell.blogspot.com/2010/03/last-will-be-first-and-first-will-be.html
            </para>
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoWriter.State">
            <summary>
            Writer state
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.Create(System.Buffers.IBufferWriter{System.Byte},ProtoBuf.Meta.TypeModel,System.Object)">
            <summary>
            Create a new ProtoWriter that tagets a buffer writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.Flush">
            <summary>
            Writes any uncommitted data to the output
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteString(System.Int32,System.String,ProtoBuf.StringMap)">
            <summary>
            Writes a string to the stream
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteString(System.String,ProtoBuf.StringMap)">
            <summary>
            Writes a string to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteType(System.Type)">
            <summary>
            Writes a Type to the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteFieldHeader(System.Int32,ProtoBuf.WireType)">
            <summary>
            Writes a field-header, indicating the format of the next data we plan to write.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteInt32Varint(System.Int32,System.Int32)">
            <summary>
            Writes a signed 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteInt32(System.Int32)">
            <summary>
            Writes a signed 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteSByte(System.SByte)">
            <summary>
            Writes a signed 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteInt16(System.Int16)">
            <summary>
            Writes a signed 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteUInt16(System.UInt16)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteByte(System.Byte)">
            <summary>
            Writes an unsigned 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteBoolean(System.Boolean)">
            <summary>
            Writes a boolean to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteUInt32(System.UInt32)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteDouble(System.Double)">
            <summary>
            Writes a double-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteSingle(System.Single)">
            <summary>
            Writes a single-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteInt64(System.Int64)">
            <summary>
            Writes a signed 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteUInt64(System.UInt64)">
            <summary>
            Writes an unsigned 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteMessage``1(ProtoBuf.Serializers.SerializerFeatures,``0,ProtoBuf.Serializers.ISerializer{``0})">
            <summary>
            Writes a sub-item to the writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteMessage``1(System.Int32,ProtoBuf.Serializers.SerializerFeatures,``0,ProtoBuf.Serializers.ISerializer{``0})">
            <summary>
            Writes a sub-item to the writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteGroup``1(System.Int32,ProtoBuf.Serializers.SerializerFeatures,``0,ProtoBuf.Serializers.ISerializer{``0})">
            <summary>
            Writes a sub-item to the writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteAny``1(System.Int32,``0,ProtoBuf.Serializers.ISerializer{``0})">
            <summary>
            Writes a value or sub-item to the writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteAny``1(System.Int32,ProtoBuf.Serializers.SerializerFeatures,``0,ProtoBuf.Serializers.ISerializer{``0})">
            <summary>
            Writes a value or sub-item to the writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteSubType``1(``0,ProtoBuf.Serializers.ISubTypeSerializer{``0})">
            <summary>
            Writes a sub-type to the input writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteSubType``1(System.Int32,``0,ProtoBuf.Serializers.ISubTypeSerializer{``0})">
            <summary>
            Writes a sub-type to the input writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteBaseType``1(``0,ProtoBuf.Serializers.ISubTypeSerializer{``0})">
            <summary>
            Writes a base-type to the input writer
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoWriter.State.Context">
            <summary>
            The serialization context associated with this instance
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteBytes(System.Buffers.ReadOnlySequence{System.Byte})">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteBytes(System.ArraySegment{System.Byte})">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteBytes(System.Byte[])">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteBytes``1(``0,ProtoBuf.Serializers.IMemoryConverter{``0,System.Byte})">
            <summary>
            Writes a binary chunk to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WriteBytes(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Writes a binary chunk to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.SerializeRoot``1(``0,ProtoBuf.Serializers.ISerializer{``0})">
            <summary>
            Writes an object to the input writer as a root value; if the
            object is determined to be a scalar, it is written as though it were
            part of a message with field-number 1
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.Abandon">
            <summary>
            Abandon any pending unflushed data
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.WritePackedPrefix(System.Int32,ProtoBuf.WireType)">
            <summary>
            Used for packed encoding; writes the length prefix using fixed sizes rather than using
            buffering. Only valid for fixed-32 and fixed-64 encoding.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.StartSubItem(System.Object)">
            <summary>
            Indicates the start of a nested record.
            </summary>
            <param name="instance">The instance to write.</param>
            <returns>A token representing the state of the stream; this token is given to EndSubItem.</returns>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.Dispose">
            <summary>
            Releases any resources associated with this instance
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.Close">
            <summary>
            Flushes data to the underlying stream, and releases any resources. The underlying stream is *not* disposed
            by this operation.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.EndSubItem(ProtoBuf.SubItemToken)">
            <summary>
            Indicates the end of a nested record.
            </summary>
            <param name="token">The token obtained from StartubItem.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.AppendExtensionData(ProtoBuf.IExtensible)">
            <summary>
            Copies any extension data stored for the instance to the underlying stream
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.SetPackedField(System.Int32)">
            <summary>
            Used for packed encoding; indicates that the next field should be skipped rather than
            a field header written. Note that the field number must match, else an exception is thrown
            when the attempt is made to write the (incorrect) field. The wire-type is taken from the
            subsequent call to WriteFieldHeader. Only primitive types can be packed.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.ClearPackedField(System.Int32)">
            <summary>
            Used for packed encoding; explicitly reset the packed field marker; this is not required
            if using StartSubItem/EndSubItem
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.ThrowEnumException(System.Object)">
            <summary>
            Throws an exception indicating that the given enum cannot be mapped to a serialized value.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.State.Create(System.IO.Stream,ProtoBuf.Meta.TypeModel,System.Object)">
            <summary>
            Creates a new writer against a stream
            </summary>
            <param name="dest">The destination stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to serialize sub-objects</param>
            <param name="userState">Additional context about this serialization operation</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteFieldHeader(System.Int32,ProtoBuf.WireType,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a field-header, indicating the format of the next data we plan to write.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],ProtoBuf.ProtoWriter)">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],System.Int32,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.StartSubItem(System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Indicates the start of a nested record.
            </summary>
            <param name="instance">The instance to write.</param>
            <param name="writer">The destination.</param>
            <returns>A token representing the state of the stream; this token is given to EndSubItem.</returns>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoWriter)">
            <summary>
            Indicates the end of a nested record.
            </summary>
            <param name="token">The token obtained from StartubItem.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Init(ProtoBuf.Meta.TypeModel,System.Object,System.Boolean)">
            <summary>
            Creates a new writer against a stream
            </summary>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to serialize sub-objects</param>
            <param name="userState">Additional context about this serialization operation</param>
            <param name="impactCount">Whether this initialization should impact usage counters (to check for double-usage)</param>
        </member>
        <member name="P:ProtoBuf.ProtoWriter.Context">
            <summary>
            Addition information about this serialization operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoWriter.UserState">
            <summary>
            Addition information about this serialization operation.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteMessage``1(ProtoBuf.ProtoWriter.State@,``0,ProtoBuf.Serializers.ISerializer{``0},ProtoBuf.PrefixStyle,System.Boolean)">
            <summary>
            Writes a sub-item to the input writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteSubType``1(ProtoBuf.ProtoWriter.State@,``0,ProtoBuf.Serializers.ISubTypeSerializer{``0})">
            <summary>
            Writes a sub-item to the input writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Abandon">
            <summary>
            Abandon any pending unflushed data
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Close">
            <summary>
            Flushes data to the underlying stream, and releases any resources. The underlying stream is *not* disposed
            by this operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoWriter.Model">
            <summary>
            Get the TypeModel associated with this writer
            </summary>
        </member>
        <member name="F:ProtoBuf.ProtoWriter.UTF8">
            <summary>
            The encoding used by the writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteString(System.String,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a string to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.TryFlush(ProtoBuf.ProtoWriter.State@)">
            <summary>
            Writes any buffered data (if possible) to the underlying stream.
            </summary>
            <param name="state">Wwriter state</param>
            <remarks>It is not always possible to fully flush, since some sequences
            may require values to be back-filled into the byte-stream.</remarks>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt64(System.UInt64,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt64(System.Int64,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt32(System.UInt32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt16(System.Int16,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt16(System.UInt16,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteByte(System.Byte,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteSByte(System.SByte,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt32(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteDouble(System.Double,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a double-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteSingle(System.Single,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a single-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.ThrowEnumException(ProtoBuf.ProtoWriter,System.Object)">
            <summary>
            Throws an exception indicating that the given enum cannot be mapped to a serialized value.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBoolean(System.Boolean,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a boolean to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.AppendExtensionData(ProtoBuf.IExtensible,ProtoBuf.ProtoWriter)">
            <summary>
            Copies any extension data stored for the instance to the underlying stream
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.SetPackedField(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Used for packed encoding; indicates that the next field should be skipped rather than
            a field header written. Note that the field number must match, else an exception is thrown
            when the attempt is made to write the (incorrect) field. The wire-type is taken from the
            subsequent call to WriteFieldHeader. Only primitive types can be packed.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.ClearPackedField(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Used for packed encoding; explicitly reset the packed field marker; this is not required
            if using StartSubItem/EndSubItem
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WritePackedPrefix(System.Int32,ProtoBuf.WireType,ProtoBuf.ProtoWriter)">
            <summary>
            Used for packed encoding; writes the length prefix using fixed sizes rather than using
            buffering. Only valid for fixed-32 and fixed-64 encoding.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteType(System.Type,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a Type to the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.DefaultState">
            <summary>
            Gets the default state associated with this writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Create(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
            <summary>
            Creates a new writer against a stream
            </summary>
            <param name="dest">The destination stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to serialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
        </member>
        <member name="T:ProtoBuf.SerializationContext">
            <summary>
            Additional information about a serialization operation
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.Context">
            <summary>
            Gets or sets a user-defined object containing additional information about this serialization/deserialization operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.Default">
            <summary>
            A default SerializationContext, with minimal information.
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.State">
            <summary>
            Gets or sets the source or destination of the transmitted data.
            </summary>
        </member>
        <member name="M:ProtoBuf.SerializationContext.op_Implicit(ProtoBuf.SerializationContext)~System.Runtime.Serialization.StreamingContext">
            <summary>
            Convert a SerializationContext to a StreamingContext
            </summary>
        </member>
        <member name="M:ProtoBuf.SerializationContext.op_Implicit(System.Runtime.Serialization.StreamingContext)~ProtoBuf.SerializationContext">
            <summary>
            Convert a StreamingContext to a SerializationContext
            </summary>
        </member>
        <member name="M:ProtoBuf.SerializationContext.AsStreamingContext(ProtoBuf.ISerializationContext)">
            <summary>
            Create a StreamingContext from a serialization context
            </summary>
        </member>
        <member name="M:ProtoBuf.SerializationContext.AsSerializationContext(ProtoBuf.ISerializationContext)">
            <summary>
            Creates a frozen SerializationContext from a serialization context
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.EnumSerializer">
            <summary>
            Provides utility methods for creating enum serializers
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.EnumSerializer.CreateSByte``1">
            <summary>
            Create an enum serializer for the provided type, which much be a matching enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.EnumSerializer.CreateInt16``1">
            <summary>
            Create an enum serializer for the provided type, which much be a matching enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.EnumSerializer.CreateInt32``1">
            <summary>
            Create an enum serializer for the provided type, which much be a matching enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.EnumSerializer.CreateInt64``1">
            <summary>
            Create an enum serializer for the provided type, which much be a matching enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.EnumSerializer.CreateByte``1">
            <summary>
            Create an enum serializer for the provided type, which much be a matching enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.EnumSerializer.CreateUInt16``1">
            <summary>
            Create an enum serializer for the provided type, which much be a matching enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.EnumSerializer.CreateUInt32``1">
            <summary>
            Create an enum serializer for the provided type, which much be a matching enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.EnumSerializer.CreateUInt64``1">
            <summary>
            Create an enum serializer for the provided type, which much be a matching enum
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.EnumSerializer`1">
            <summary>
            Base type for enum serializers
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.EnumSerializer`1.Read(ProtoBuf.ProtoReader.State@,`0)">
            <summary>
            Deserialize an enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.EnumSerializer`1.Write(ProtoBuf.ProtoWriter.State@,`0)">
            <summary>
            Serialize an enum
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.IMemoryConverter`2">
            <summary>
            Provides an abstract way of referring to simple range-based
            data types as Memory<typeparamref name="TElement"/>.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IMemoryConverter`2.NonNull(`0@)">
            <summary>
            Provides a non-null value from the provided storage.
            For many value-types, this will simply return the input value. For
            reference-types, the input should be null-coalesced against an
            empty value such as Array.Empty<typeparamref name="TStorage"/>().
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IMemoryConverter`2.GetLength(`0@)">
            <summary>
            Get the length (in terms of element count) of the provided storage.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IMemoryConverter`2.GetMemory(`0@)">
            <summary>
            Access a Memory<typeparamref name="TElement"/> that is the underlying
            data held by this storage.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IMemoryConverter`2.Expand(ProtoBuf.ISerializationContext,`0@,System.Int32)">
            <summary>
            Resizes (typically: allocates and copies) the provided storage by
            the requested additional capacity, returning a memory to *just
            the additional portion*). The implementor is responsible for
            ensuring that the old values are copied if necessary.
            The implementor may choose to recycle the old storage, if
            appropriate.
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.DefaultMemoryConverter`1">
            <summary>
            Provides a memory converter implementation for many common storage kinds.
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.DefaultMemoryConverter`1.Instance">
            <summary>
            Provides the singleton instance for element type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.SerializerFeatures">
            <summary>
            Indicates capabilities and behaviors of a serializer
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.WireTypeVarint">
            <summary>
            Base-128 variable-length encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.WireTypeFixed64">
            <summary>
            Fixed-length 8-byte encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.WireTypeString">
            <summary>
            Length-variant-prefixed encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.WireTypeStartGroup">
            <summary>
            Indicates the start of a group
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.WireTypeFixed32">
            <summary>
            Fixed-length 4-byte encoding
            </summary>10
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.WireTypeSignedVarint">
            <summary>
            Denotes a varint that should be interpreted using
            zig-zag semantics (so -ve numbers aren't a significant overhead)
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.WireTypeSpecified">
            <summary>
            Indicates that the wire-type has been explicitly specified
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.CategoryRepeated">
            <summary>
            Indicates that this data should be treated like a list/array
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.CategoryScalar">
            <summary>
            Scalars are simple types such as integers, not messages; when written as
            a root message, a field-one wrapper is added
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.CategoryMessage">
            <summary>
            Indicates a type that is a message
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.CategoryMessageWrappedAtRoot">
            <summary>
            Indicates a type that is both "message" and "scalar"; *at the root only* it will be a message wrapped like a scalar; otherwise, it is
            treated as a message; see: DateTime/TimeSpan
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.OptionPackedDisabled">
            <summary>
            Explicitly disables packed encoding; normally, packed encoding is
            used by default when appropriate
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.OptionClearCollection">
            <summary>
            List-like values should clear any existing contents before adding new
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.OptionFailOnDuplicateKey">
            <summary>
            Maps should use dictionary Add rather than overwrite; this means that duplicate keys will cause failure
            </summary>
        </member>
        <member name="F:ProtoBuf.Serializers.SerializerFeatures.OptionSkipRecursionCheck">
            <summary>
            Disable recursion checking
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.ISerializer`1">
            <summary>
            Abstract API capable of serializing/deserializing messages or values
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.ISerializer`1.Read(ProtoBuf.ProtoReader.State@,`0)">
            <summary>
            Deserialize an instance from the supplied writer
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.ISerializer`1.Write(ProtoBuf.ProtoWriter.State@,`0)">
            <summary>
            Serialize an instance to the supplied writer
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.ISerializer`1.Features">
            <summary>
            Indicates the features (including the default wire-type) for this type/serializer
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.ISerializerProxy`1">
            <summary>
            Provides indirect access to a serializer for a given type
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.ISerializerProxy`1.Serializer">
            <summary>
            Gets the actual serializer for the type
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.IMeasuringSerializer`1">
            <summary>
            Abstract API capable of measuring values without writing them
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IMeasuringSerializer`1.Measure(ProtoBuf.ISerializationContext,ProtoBuf.WireType,`0)">
            <summary>
            Measure the given value, reporting the required length for the payload (not including the field-header)
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.IRepeatedSerializer`1">
            <summary>
            Abstract API capable of serializing/deserializing a sequence of messages or values
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IRepeatedSerializer`1.WriteRepeated(ProtoBuf.ProtoWriter.State@,System.Int32,ProtoBuf.Serializers.SerializerFeatures,`0)">
            <summary>
            Serialize a sequence of values to the supplied writer
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IRepeatedSerializer`1.ReadRepeated(ProtoBuf.ProtoReader.State@,ProtoBuf.Serializers.SerializerFeatures,`0)">
            <summary>
            Deserializes a sequence of values from the supplied reader
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.ISubTypeSerializer`1">
            <summary>
            Abstract API capable of serializing/deserializing objects as part of a type hierarchy
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.ISubTypeSerializer`1.WriteSubType(ProtoBuf.ProtoWriter.State@,`0)">
            <summary>
            Serialize an instance to the supplied writer
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.ISubTypeSerializer`1.ReadSubType(ProtoBuf.ProtoReader.State@,ProtoBuf.Serializers.SubTypeState{`0})">
            <summary>
            Deserialize an instance from the supplied writer
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.SubTypeState`1">
            <summary>
            Represents the state of an inheritance deserialization operation
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.SubTypeState`1.Create``1(ProtoBuf.ISerializationContext,``0)">
            <summary>
            Create a new value, using the provided concrete type if a new instance is required
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.SubTypeState`1.Value">
            <summary>
            Gets or sets the current instance represented
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.SubTypeState`1.CreateIfNeeded">
            <summary>
            Ensures that the instance has a value
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.SubTypeState`1.HasValue">
            <summary>
            Indicates whether an instance currently exists
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.SubTypeState`1.ReadSubType``1(ProtoBuf.ProtoReader.State@,ProtoBuf.Serializers.ISubTypeSerializer{``0})">
            <summary>
            Parse the input as a sub-type of the instance
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.SubTypeState`1.OnBeforeDeserialize(System.Action{`0,ProtoBuf.ISerializationContext})">
            <summary>
            Specifies a serialization callback to be used when the item is constructed; if the item already exists, the callback is executed immediately
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.IFactory`1">
            <summary>
            Abstract API capable of serializing/deserializing complex objects with inheritance
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IFactory`1.Create(ProtoBuf.ISerializationContext)">
            <summary>
            Create a new instance of the type
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.MapSerializer">
            <summary>
            Provides utility methods for creating serializers for repeated data
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer.CreateConcurrentDictionary``3">
            <summary>Create a map serializer that operates on concurrent dictionaries</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer.CreateDictionary``2">
            <summary>Create a map serializer that operates on dictionaries</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer.CreateDictionary``3">
            <summary>Create a map serializer that operates on dictionaries</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer.CreateImmutableDictionary``2">
            <summary>Create a map serializer that operates on immutable dictionaries</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer.CreateImmutableSortedDictionary``2">
            <summary>Create a map serializer that operates on immutable dictionaries</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer.CreateIImmutableDictionary``2">
            <summary>Create a map serializer that operates on immutable dictionaries</summary>
        </member>
        <member name="T:ProtoBuf.Serializers.MapSerializer`3">
            <summary>
            Base class for dictionary-like collection serializers
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer`3.WriteMap(ProtoBuf.ProtoWriter.State@,System.Int32,ProtoBuf.Serializers.SerializerFeatures,`0,ProtoBuf.Serializers.SerializerFeatures,ProtoBuf.Serializers.SerializerFeatures,ProtoBuf.Serializers.ISerializer{`1},ProtoBuf.Serializers.ISerializer{`2})">
            <summary>
            Deserializes a sequence of values from the supplied reader
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer`3.Initialize(`0,ProtoBuf.ISerializationContext)">
            <summary>Ensure that the collection is not nil, if required</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer`3.Clear(`0,ProtoBuf.ISerializationContext)">
            <summary>Remove any existing contents from the collection</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer`3.AddRange(`0,System.ArraySegment{System.Collections.Generic.KeyValuePair{`1,`2}}@,ProtoBuf.ISerializationContext)">
            <summary>Add new contents to the collection</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer`3.SetValues(`0,System.ArraySegment{System.Collections.Generic.KeyValuePair{`1,`2}}@,ProtoBuf.ISerializationContext)">
            <summary>Update the new contents intoto the collection, overwriting existing values</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.MapSerializer`3.ReadMap(ProtoBuf.ProtoReader.State@,ProtoBuf.Serializers.SerializerFeatures,`0,ProtoBuf.Serializers.SerializerFeatures,ProtoBuf.Serializers.SerializerFeatures,ProtoBuf.Serializers.ISerializer{`1},ProtoBuf.Serializers.ISerializer{`2})">
            <summary>
            Deserializes a sequence of values from the supplied reader
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializers.RepeatedSerializer">
            <summary>
            Provides utility methods for creating serializers for repeated data
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateConcurrentBag``2">
            <summary>Create a serializer that operates on immutable sets</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateConcurrentStack``2">
            <summary>Create a serializer that operates on immutable sets</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateConcurrentQueue``2">
            <summary>Create a serializer that operates on immutable sets</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateIProducerConsumerCollection``2">
            <summary>Create a serializer that operates on immutable sets</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateNestedDataNotSupported``2">
            <summary>Create a serializer that indicates that a scenario is not supported</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateNotSupported``2">
            <summary>Create a serializer that indicates that a scenario is not supported</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateList``1">
            <summary>Create a serializer that operates on lists</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateList``2">
            <summary>Create a serializer that operates on lists</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateEnumerable``2">
            <summary>Create a serializer that operates on most common collections</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateEnumerable``3">
            <summary>Create a serializer that operates on most common collections</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateVector``1">
            <summary>Create a serializer that operates on lists</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateQueue``2">
            <summary>Create a serializer that operates on lists</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateStack``2">
            <summary>Create a serializer that operates on lists</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.ReverseInPlace``1(System.ArraySegment{``0}@)">
            <summary>Reverses a range of values</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateImmutableArray``1">
            <summary>Create a serializer that operates on immutable arrays</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateImmutableList``1">
            <summary>Create a serializer that operates on immutable lists</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateImmutableIList``1">
            <summary>Create a serializer that operates on immutable lists</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateImmutableQueue``1">
            <summary>Create a serializer that operates on immutable queues</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateImmutableIQueue``1">
            <summary>Create a serializer that operates on immutable queues</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateImmutableStack``1">
            <summary>Create a serializer that operates on immutable stacks</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateImmutableIStack``1">
            <summary>Create a serializer that operates on immutable stacks</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateImmutableHashSet``1">
            <summary>Create a serializer that operates on immutable sets</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateImmutableSortedSet``1">
            <summary>Create a serializer that operates on immutable sets</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer.CreateImmutableISet``1">
            <summary>Create a serializer that operates on immutable sets</summary>
        </member>
        <member name="T:ProtoBuf.Serializers.RepeatedSerializer`2">
            <summary>
            Base class for simple collection serializers
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer`2.WriteRepeated(ProtoBuf.ProtoWriter.State@,System.Int32,ProtoBuf.Serializers.SerializerFeatures,`0,ProtoBuf.Serializers.ISerializer{`1})">
            <summary>
            Serialize a sequence of values to the supplied writer
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer`2.TryGetCount(`0)">
            <summary>If possible to do so *cheaply*, return the count of the items in the collection</summary>
            <remarks>TryGetCountDefault can be used as a reasonable fallback</remarks>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer`2.TryGetCountDefault(`0)">
            <summary>Applies a range of common strategies for cheaply counting collections</summary>
            <remarks>This involves multiple tests and exception handling; if your collection is known to be reliable, you should prefer an exposed .Count or similar</remarks>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer`2.ReadRepeated(ProtoBuf.ProtoReader.State@,ProtoBuf.Serializers.SerializerFeatures,`0,ProtoBuf.Serializers.ISerializer{`1})">
            <summary>
            Deserializes a sequence of values from the supplied reader
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer`2.Initialize(`0,ProtoBuf.ISerializationContext)">
            <summary>Ensure that the collection is not nil, if required</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer`2.Clear(`0,ProtoBuf.ISerializationContext)">
            <summary>Remove any existing contents from the collection</summary>
        </member>
        <member name="M:ProtoBuf.Serializers.RepeatedSerializer`2.AddRange(`0,System.ArraySegment{`1}@,ProtoBuf.ISerializationContext)">
            <summary>Add new contents to the collection</summary>
        </member>
        <member name="T:ProtoBuf.Serializers.SerializerCache">
            <summary>
            Provides access to cached serializers
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.SerializerCache.Get``2">
            <summary>
            Gets a cached serializer instance for a type, in the context of a given provider
            </summary>
        </member>
        <member name="T:ProtoBuf.StringMap">
            <summary>
            Not yet implemented
            </summary>
        </member>
        <member name="T:ProtoBuf.SubItemToken">
            <summary>
            Used to hold particulars relating to nested objects. This is opaque to the caller - simply
            give back the token you are given at the end of an object.
            </summary>
        </member>
        <member name="M:ProtoBuf.SubItemToken.ToString">
            <summary>
            See object.ToString()
            </summary>
        </member>
        <member name="M:ProtoBuf.SubItemToken.GetHashCode">
            <summary>
            See object.GetHashCode()
            </summary>
        </member>
        <member name="M:ProtoBuf.SubItemToken.Equals(System.Object)">
            <summary>
            See object.Equals()
            </summary>
        </member>
        <member name="T:ProtoBuf.TypeResolver">
            <summary>
            Maps a field-number to a type
            </summary>
        </member>
        <member name="T:ProtoBuf.WellKnownTypes.Duration">
            <summary>
            A Duration represents a signed, fixed-length span of time represented
            as a count of seconds and fractions of seconds at nanosecond
            resolution. It is independent of any calendar and concepts like "day"
            or "month". It is related to Timestamp in that the difference between
            two Timestamp values is a Duration and it can be added or subtracted
            from a Timestamp. 
            </summary>
        </member>
        <member name="P:ProtoBuf.WellKnownTypes.Duration.Seconds">
            <summary>
            Signed seconds of the span of time.
            </summary>
        </member>
        <member name="P:ProtoBuf.WellKnownTypes.Duration.Nanoseconds">
            <summary>
            Signed fractions of a second at nanosecond resolution of the span of time.
            </summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Duration.#ctor(System.Int64,System.Int32)">
            <summary>Creates a new Duration with the supplied values</summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Duration.#ctor(System.TimeSpan)">
            <summary>Converts a TimeSpan to a Duration</summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Duration.AsTimeSpan">
            <summary>Converts a Duration to a TimeSpan</summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Duration.op_Implicit(ProtoBuf.WellKnownTypes.Duration)~System.TimeSpan">
            <summary>Converts a Duration to a TimeSpan</summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Duration.op_Implicit(System.TimeSpan)~ProtoBuf.WellKnownTypes.Duration">
            <summary>Converts a TimeSpan to a Duration</summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Duration.Normalize">
            <summary>
            Applies .proto rules to ensure that this value is in the expected ranges
            </summary>
        </member>
        <member name="T:ProtoBuf.WellKnownTypes.Empty">
            <summary>
            A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs
            </summary>
        </member>
        <member name="T:ProtoBuf.WellKnownTypes.Timestamp">
            <summary>
             A Timestamp represents a point in time independent of any time zone or local
            calendar, encoded as a count of seconds and fractions of seconds at
            nanosecond resolution. The count is relative to an epoch at UTC midnight on
            January 1, 1970, in the proleptic Gregorian calendar which extends the
            Gregorian calendar backwards to year one.
            </summary>
        </member>
        <member name="P:ProtoBuf.WellKnownTypes.Timestamp.Seconds">
            <summary>
            Represents seconds of UTC time since Unix epoch
            </summary>
        </member>
        <member name="P:ProtoBuf.WellKnownTypes.Timestamp.Nanoseconds">
            <summary>
            Non-negative fractions of a second at nanosecond resolution.
            </summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Timestamp.#ctor(System.Int64,System.Int32)">
            <summary>Creates a new Duration with the supplied values</summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Timestamp.#ctor(System.DateTime)">
            <summary>Converts a DateTime to a Timestamp</summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Timestamp.Normalize">
            <summary>
            Applies .proto rules to ensure that this value is in the expected ranges
            </summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Timestamp.AsDateTime">
            <summary>Converts a Timestamp to a DateTime</summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Timestamp.op_Implicit(ProtoBuf.WellKnownTypes.Timestamp)~System.DateTime">
            <summary>Converts a Timestamp to a DateTime</summary>
        </member>
        <member name="M:ProtoBuf.WellKnownTypes.Timestamp.op_Implicit(System.DateTime)~ProtoBuf.WellKnownTypes.Timestamp">
            <summary>Converts a DateTime to a Timestamp</summary>
        </member>
        <member name="F:ProtoBuf.WellKnownTypes.Timestamp.TimestampEpoch">
            <summary>
            The default value for dates that are following google.protobuf.Timestamp semantics
            </summary>
        </member>
        <member name="T:ProtoBuf.WireType">
            <summary>
            Indicates the encoding used to represent an individual value in a protobuf stream
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.None">
            <summary>
            Represents an error condition
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Variant">
            <summary>
            Base-128 variable-length encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Varint">
            <summary>
            Base-128 variable-length encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Fixed64">
            <summary>
            Fixed-length 8-byte encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.String">
            <summary>
            Length-variant-prefixed encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.StartGroup">
            <summary>
            Indicates the start of a group
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.EndGroup">
            <summary>
            Indicates the end of a group
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Fixed32">
            <summary>
            Fixed-length 4-byte encoding
            </summary>10
        </member>
        <member name="F:ProtoBuf.WireType.SignedVariant">
            <summary>
            This is not a formal wire-type in the "protocol buffers" spec, but
            denotes a varint that should be interpreted using
            zig-zag semantics (so -ve numbers aren't a significant overhead)
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.SignedVarint">
            <summary>
            This is not a formal wire-type in the "protocol buffers" spec, but
            denotes a varint that should be interpreted using
            zig-zag semantics (so -ve numbers aren't a significant overhead)
            </summary>
        </member>
    </members>
</doc>

```

`Tools/protogen/protobuf-net.Reflection.xml`:

```xml
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>protobuf-net.Reflection</name>
    </assembly>
    <members>
        <member name="T:ProtoBuf.Reflection.CodeGenerator">
            <summary>
            Abstract root for a general purpose code-generator
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CodeGenerator.Name">
            <summary>
            The logical name of this code generator
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CodeGenerator.ToString">
            <summary>
            Get a string representation of the instance
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CodeGenerator.Generate(Google.Protobuf.Reflection.FileDescriptorSet,ProtoBuf.Reflection.NameNormalizer)">
            <summary>
            Execute the code generator against a FileDescriptorSet, yielding a sequence of files
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CodeGenerator.Generate(Google.Protobuf.Reflection.FileDescriptorSet,ProtoBuf.Reflection.NameNormalizer,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Execute the code generator against a FileDescriptorSet, yielding a sequence of files
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CodeGenerator.Compile(ProtoBuf.Reflection.CodeFile)">
            <summary>
            Eexecute this code generator against a code file
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CodeGenerator.Compile(ProtoBuf.Reflection.CodeFile[])">
            <summary>
            Eexecute this code generator against a set of code file
            </summary>
        </member>
        <member name="T:ProtoBuf.Reflection.CommonCodeGenerator">
            <summary>
            Abstract base class for a code generator that uses a visitor pattern
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GetAccess(Google.Protobuf.Reflection.FileDescriptorProto)">
            <summary>
            Obtain the access of an item, accounting for the model's hierarchy
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GetLanguageVersion(Google.Protobuf.Reflection.FileDescriptorProto)">
            <summary>
            Get the language version for this language from a schema
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GetAccess(Google.Protobuf.Reflection.DescriptorProto)">
            <summary>
            Obtain the access of an item, accounting for the model's hierarchy
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GetAccess(Google.Protobuf.Reflection.FieldDescriptorProto)">
            <summary>
            Obtain the access of an item, accounting for the model's hierarchy
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GetAccess(Google.Protobuf.Reflection.EnumDescriptorProto)">
            <summary>
            Obtain the access of an item, accounting for the model's hierarchy
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GetAccess(Google.Protobuf.Reflection.ServiceDescriptorProto)">
            <summary>
            Obtain the access of an item, accounting for the model's hierarchy
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GetAccess(ProtoBuf.Reflection.Access)">
            <summary>
            Get the textual name of a given access level
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.Indent">
            <summary>
            The indentation used by this code generator
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.DefaultFileExtension">
            <summary>
            The file extension of the files generatred by this generator
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.IsCaseSensitive">
            <summary>
            Should case-sensitivity be used when computing conflicts?
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.Escape(System.String)">
            <summary>
            Handle keyword escaping in the language of this code generator
            </summary>
            <param name="identifier"></param>
            <returns></returns>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.Generate(Google.Protobuf.Reflection.FileDescriptorSet,ProtoBuf.Reflection.NameNormalizer,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Execute the code generator against a FileDescriptorSet, yielding a sequence of files
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteFile(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto)">
            <summary>
            Emits the code for a file in a descriptor-set
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteExtension(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto)">
            <summary>
            Emit code representing an extension field
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteExtensionsHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            Emit code preceeding a set of extension fields
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteExtensionsFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            Emit code following a set of extension fields
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteExtensionsHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Emit code preceeding a set of extension fields
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteExtensionsFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Emit code following a set of extension fields
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteService(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.ServiceDescriptorProto)">
            <summary>
            Emit code representing a service
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteServiceFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.ServiceDescriptorProto,System.Object@)">
            <summary>
            Emit code following a set of service methods
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteServiceMethod(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.MethodDescriptorProto,System.Object@)">
            <summary>
            Emit code representing a service method
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteServiceHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.ServiceDescriptorProto,System.Object@)">
            <summary>
            Emit code preceeding a set of service methods
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.ShouldOmitMessage(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Check whether a particular message should be suppressed - for example because it represents a map
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteMessage(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto)">
            <summary>
            Emit code representing a message type
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteConstructorFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Emit code terminating a constructor, if one is required
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteInitField(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto,System.Object@,ProtoBuf.Reflection.CommonCodeGenerator.OneOfStub[])">
            <summary>
            Emit code initializing field values inside a constructor, if one is required
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteContructorHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Emit code beginning a constructor, if one is required
            </summary>
            <returns>true if a constructor is required</returns>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteField(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto,System.Object@,ProtoBuf.Reflection.CommonCodeGenerator.OneOfStub[])">
            <summary>
            Emit code representing a message field
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.TrackFieldPresence(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto,ProtoBuf.Reflection.CommonCodeGenerator.OneOfStub[],ProtoBuf.Reflection.CommonCodeGenerator.OneOfStub@)">
            <summary>
            Indicates whether field presence tracking is suggested for this field
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteMessageFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Emit code following a set of message fields
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteMessageHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Emit code preceeding a set of message fields
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteEnum(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.EnumDescriptorProto)">
            <summary>
            Emit code representing an enum type
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteOneOf(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,ProtoBuf.Reflection.CommonCodeGenerator.OneOfStub)">
            <summary>
            Emit code representing 'oneof' elements as an enum discriminator
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteEnumHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.EnumDescriptorProto,System.Object@)">
            <summary>
            Emit code preceeding a set of enum values
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteEnumValue(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.EnumValueDescriptorProto,System.Object@)">
            <summary>
            Emit code representing an enum value
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteEnumFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.EnumDescriptorProto,System.Object@)">
            <summary>
            Emit code following a set of enum values
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteFileHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            Emit code at the start of a file
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteFileFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            Emit code at the end of a file
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteOneOfEnumHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.OneofDescriptorProto,System.Object@)">
            <summary>
            Emit the start of an enum declaration for 'oneof' groups, including the 0/None element
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteOneOfEnumValue(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto,System.Object@)">
            <summary>
            Emit a field-based entry for a 'oneof' groups's enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteOneOfEnumFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.OneofDescriptorProto,System.Object@)">
            <summary>
            Emit the end of an enum declaration for 'oneof' groups
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.WriteOneOfDiscriminator(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.OneofDescriptorProto,System.Object@)">
            <summary>
            Emit  the discriminator accessor for 'oneof' groups
            </summary>
        </member>
        <member name="F:ProtoBuf.Reflection.CommonCodeGenerator.OneOfEnumSuffixEnum">
            <summary>
            Convention-based suffix for 'oneof' enums
            </summary>
        </member>
        <member name="F:ProtoBuf.Reflection.CommonCodeGenerator.OneOfEnumSuffixDiscriminator">
            <summary>
            Convention-based suffix for 'oneof' discriminators
            </summary>
        </member>
        <member name="T:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext">
            <summary>
            Represents the state of a code-generation invocation
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.File">
            <summary>
            The file being processed
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.IndentToken">
            <summary>
            The token to use for indentation
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.IndentLevel">
            <summary>
            The current indent level
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.NameNormalizer">
            <summary>
            The mechanism to use for name normalization
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.Output">
            <summary>
            The output for this code generation
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.Syntax">
            <summary>
            The effective syntax of this code-generation cycle, defaulting to "proto2" if not explicity specified
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.OneOfEnums">
            <summary>
            Whether to emit enums and discriminators for oneof groups
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.#ctor(ProtoBuf.Reflection.CommonCodeGenerator,Google.Protobuf.Reflection.FileDescriptorProto,ProtoBuf.Reflection.NameNormalizer,System.IO.TextWriter,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Create a new GeneratorContext instance
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.EmitListSetters">
            <summary>
            Whether lists should be written with getters
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.EmitServices">
            <summary>
            Whether services should be emitted
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.IsEnabled(System.String)">
            <summary>
            Whether a custom option is enabled
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.GetCustomOption(System.String)">
            <summary>
            Gets the value of an OPTION/VALUE pair provided to the system
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.EmitRequiredDefaults">
            <summary>
            Should default value initializers be emitted even for required values?
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.LanguageVersion">
            <summary>
            The specified language version (null if not specified)
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.WriteLine">
            <summary>
            Ends the current line
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.WriteLine(System.String)">
            <summary>
            Appends a value and ends the current line
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.Write(System.String)">
            <summary>
            Appends a value to the current line
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.Indent">
            <summary>
            Increases the indentation level
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.Outdent">
            <summary>
            Decreases the indentation level
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext.TryFind``1(System.String)">
            <summary>
            Try to find a descriptor of the type specified by T with the given full name
            </summary>
        </member>
        <member name="T:ProtoBuf.Reflection.CommonCodeGenerator.OneOfStub">
            <summary>
            Represents the union summary of a one-of declaration
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.OneOfStub.OneOf">
            <summary>
            The underlying descriptor
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CommonCodeGenerator.OneOfStub.Index">
            <summary>
            The effective index of this stub
            </summary>
        </member>
        <member name="T:ProtoBuf.Reflection.CSharpCodeGenerator">
            <summary>
            A code generator that writes C#
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CSharpCodeGenerator.Default">
            <summary>
            Reusable code-generator instance
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.#ctor">
            <summary>
            Create a new CSharpCodeGenerator instance
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CSharpCodeGenerator.Name">
            <summary>
            Returns the language name
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CSharpCodeGenerator.DefaultFileExtension">
            <summary>
            Returns the default file extension
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.Escape(System.String)">
            <summary>
            Escapes language keywords
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.GetLanguageVersion(Google.Protobuf.Reflection.FileDescriptorProto)">
            <summary>
            Get the language version for this language from a schema
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteFileHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            Start a file
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteFileFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            End a file
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteEnumHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.EnumDescriptorProto,System.Object@)">
            <summary>
            Start an enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteEnumFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.EnumDescriptorProto,System.Object@)">
            <summary>
            End an enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteEnumValue(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.EnumValueDescriptorProto,System.Object@)">
            <summary>
            Write an enum value
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteMessageFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            End a message
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteMessageHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Start a message
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.GetAccess(ProtoBuf.Reflection.Access)">
            <summary>
            Get the language specific keyword representing an access level
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteContructorHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Emit code beginning a constructor, if one is required
            </summary>
            <returns>true if a constructor is required</returns>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteConstructorFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Emit code terminating a constructor, if one is required
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteInitField(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto,System.Object@,ProtoBuf.Reflection.CommonCodeGenerator.OneOfStub[])">
            <summary>
            Emit code initializing field values inside a constructor, if one is required
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteField(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto,System.Object@,ProtoBuf.Reflection.CommonCodeGenerator.OneOfStub[])">
            <summary>
            Write a field
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteExtensionsHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            Starts an extensions block
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteExtensionsFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            Ends an extgensions block
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteExtensionsHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Starts an extensions block
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteExtensionsFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Ends an extensions block
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteExtension(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto)">
            <summary>
            Write an extension
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteOneOfEnumHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.OneofDescriptorProto,System.Object@)">
            <summary>
            Emit the start of an enum declaration for 'oneof' groups, including the 0/None element
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteOneOfEnumFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.OneofDescriptorProto,System.Object@)">
            <summary>
            Emit the end of an enum declaration for 'oneof' groups
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteOneOfEnumValue(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto,System.Object@)">
            <summary>
            Emit a field-based entry for a 'oneof' groups's enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteOneOfDiscriminator(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.OneofDescriptorProto,System.Object@)">
            <summary>
            Emit  the discriminator accessor for 'oneof' groups
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.UseArray(Google.Protobuf.Reflection.FieldDescriptorProto)">
            <summary>
            Indicate which types will commonly use arrays
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.MakeRelativeName(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,System.String)">
            <summary>
            Obtain a relative name from a type name
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteServiceHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.ServiceDescriptorProto,System.Object@)">
            <summary>
            Emit code preceeding a set of service methods
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteServiceFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.ServiceDescriptorProto,System.Object@)">
            <summary>
            Emit code following a set of service methods
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CSharpCodeGenerator.WriteServiceMethod(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.MethodDescriptorProto,System.Object@)">
            <summary>
            Emit code representing a service method
            </summary>
        </member>
        <member name="T:ProtoBuf.Reflection.Internal.ErrorCode">
            <summary>
            Registry of known errors / warnings
            </summary>
        </member>
        <member name="T:ProtoBuf.Reflection.NameNormalizer">
            <summary>
            Provides general purpose name suggestions
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.NullNormalizer.Pluralize(System.String)">
            <summary>
            Suggest a name with idiomatic pluralization
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.DefaultNormalizer.Pluralize(System.String)">
            <summary>
            Suggest a name with idiomatic pluralization
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.NoPluralNormalizer.Pluralize(System.String)">
            <summary>
            Suggest a name with idiomatic pluralization
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.AutoCapitalize(System.String)">
            <summary>
            Suggest a name with idiomatic name capitalization
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.AutoPluralize(System.String)">
            <summary>
            Suggest a name with idiomatic pluralization
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.NameNormalizer.Default">
            <summary>
            Name normalizer with default protobuf-net behaviour, using .NET idioms
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.NameNormalizer.Null">
            <summary>
            Name normalizer that passes through all identifiers without any changes
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.NameNormalizer.NoPlural">
            <summary>
            Name normalizer with default protobuf-net behaviour, using .NET idioms, without pluralization
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.GetName(System.String)">
            <summary>
            Suggest a normalized identifier
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.Pluralize(System.String)">
            <summary>
            Suggest a name with idiomatic pluralization
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.GetName(Google.Protobuf.Reflection.FileDescriptorProto)">
            <summary>
            Suggest a normalized identifier
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.GetName(Google.Protobuf.Reflection.OneofDescriptorProto)">
            <summary>
            Suggest a normalized identifier
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.GetName(Google.Protobuf.Reflection.DescriptorProto)">
            <summary>
            Suggest a normalized identifier
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.GetName(Google.Protobuf.Reflection.EnumDescriptorProto)">
            <summary>
            Suggest a normalized identifier
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.GetName(Google.Protobuf.Reflection.EnumValueDescriptorProto)">
            <summary>
            Suggest a normalized identifier
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.GetName(Google.Protobuf.Reflection.FieldDescriptorProto)">
            <summary>
            Suggest a normalized identifier
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.GetName(Google.Protobuf.Reflection.ServiceDescriptorProto)">
            <summary>
            Suggest a normalized identifier
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.GetName(Google.Protobuf.Reflection.MethodDescriptorProto)">
            <summary>
            Suggest a normalized identifier
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.BuildConflicts(Google.Protobuf.Reflection.DescriptorProto,System.Boolean)">
            <summary>
            Obtain a set of all names defined for a message
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.NameNormalizer.GetName(Google.Protobuf.Reflection.DescriptorProto,System.String,System.String,System.Boolean)">
            <summary>
            Get the preferred name for an element
            </summary>
        </member>
        <member name="T:ProtoBuf.Reflection.CodeFile">
            <summary>
            Describes a generated file
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.CodeFile.ToString">
            <summary>
            Get a string representation of this instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:ProtoBuf.Reflection.CodeFile.#ctor(System.String,System.String)">
            <summary>
            Create a new CodeFile instance
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CodeFile.Name">
            <summary>
            The name (including path if necessary) of this file
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CodeFile.Text">
            <summary>
            The contents of this file
            </summary>
        </member>
        <member name="T:ProtoBuf.Reflection.CompilerResult">
            <summary>
            Represents the overall result of a compilation process
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CompilerResult.Errors">
            <summary>
            The errors from this execution
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.CompilerResult.Files">
            <summary>
            The output files from this execution
            </summary>
        </member>
        <member name="T:ProtoBuf.Reflection.Error">
            <summary>
            Describes an error that occurred during processing
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.Error.Parse(System.String,System.String)">
            <summary>
            Parse an error from a PROTOC error message
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.Error.ToString">
            <summary>
            Get a text representation of this instance
            </summary>
            <returns></returns>
        </member>
        <member name="P:ProtoBuf.Reflection.Error.ErrorNumber">
            <summary>
            The error code defined for this scenario
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.Error.IsWarning">
            <summary>
            True if this instance represents a non-fatal warning
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.Error.IsError">
            <summary>
            True if this instance represents a fatal error
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.Error.File">
            <summary>
            The file in which this error was identified
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.Error.Text">
            <summary>
            The source text relating to this error
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.Error.Message">
            <summary>
            The error message
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.Error.LineContents">
            <summary>
            The entire line contents in the source in which this error was located
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.Error.LineNumber">
            <summary>
            The line number in which this error was located
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.Error.ColumnNumber">
            <summary>
            The column number in which this error was located
            </summary>
        </member>
        <member name="T:ProtoBuf.Reflection.VBCodeGenerator">
            <summary>
            A code generator that writes VB
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.VBCodeGenerator.Default">
            <summary>
            Reusable code-generator instance
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.VBCodeGenerator.IsCaseSensitive">
            <summary>
            Should case-sensitivity be used when computing conflicts?
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.#ctor">
            <summary>
            Create a new VBCodeGenerator instance
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.VBCodeGenerator.Name">
            <summary>
            Returns the language name
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.GetLanguageVersion(Google.Protobuf.Reflection.FileDescriptorProto)">
            <summary>
            Get the language version for this language from a schema
            </summary>
        </member>
        <member name="P:ProtoBuf.Reflection.VBCodeGenerator.DefaultFileExtension">
            <summary>
            Returns the default file extension
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.Escape(System.String)">
            <summary>
            Escapes language keywords
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteFileHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            Start a file
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteFileFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            End a file
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteEnumHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.EnumDescriptorProto,System.Object@)">
            <summary>
            Start an enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteEnumFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.EnumDescriptorProto,System.Object@)">
            <summary>
            End an enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteEnumValue(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.EnumValueDescriptorProto,System.Object@)">
            <summary>
            Write an enum value
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteOneOfDiscriminator(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.OneofDescriptorProto,System.Object@)">
            <summary>
            Emit  the discriminator accessor for 'oneof' groups
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteOneOfEnumFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.OneofDescriptorProto,System.Object@)">
            <summary>
            Emit the end of an enum declaration for 'oneof' groups
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteOneOfEnumHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.OneofDescriptorProto,System.Object@)">
            <summary>
            Emit the start of an enum declaration for 'oneof' groups, including the 0/None element
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteOneOfEnumValue(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto,System.Object@)">
            <summary>
            Emit a field-based entry for a 'oneof' groups's enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteMessageFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            End a message
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteMessageHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Start a message
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.GetAccess(ProtoBuf.Reflection.Access)">
            <summary>
            Get the language specific keyword representing an access level
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteField(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto,System.Object@,ProtoBuf.Reflection.CommonCodeGenerator.OneOfStub[])">
            <summary>
            Write a field
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteExtensionsHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            Starts an extgensions block
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteExtensionsFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FileDescriptorProto,System.Object@)">
            <summary>
            Ends an extgensions block
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteExtensionsHeader(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Starts an extensions block
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteExtensionsFooter(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.DescriptorProto,System.Object@)">
            <summary>
            Ends an extensions block
            </summary>
        </member>
        <member name="M:ProtoBuf.Reflection.VBCodeGenerator.WriteExtension(ProtoBuf.Reflection.CommonCodeGenerator.GeneratorContext,Google.Protobuf.Reflection.FieldDescriptorProto)">
            <summary>
            Write an extension
            </summary>
        </member>
        <member name="P:Google.Protobuf.Reflection.FileDescriptorSet.AllowNameOnlyImport">
            <summary>
            When processing Foo/Bar/Some.proto, should Foo/Bar be treated as an implicit import location?
            </summary>
        </member>
        <member name="P:Google.Protobuf.Reflection.FileDescriptorSet.DefaultPackage">
            <summary>
            Default package to use when none is specified; can use #FILE# and #DIR# tokens
            </summary>
        </member>
    </members>
</doc>

```

`Tools/protogen/protobuf-net.xml`:

```xml
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>protobuf-net</name>
    </assembly>
    <members>
        <member name="M:ProtoBuf.Compiler.CompilerContext.LoadNullRef">
            <summary>
            Pushes a null reference onto the stack. Note that this should only
            be used to return a null (or set a variable to null); for null-tests
            use BranchIfTrue / BranchIfFalse.
            </summary>
        </member>
        <member name="M:ProtoBuf.Compiler.CompilerContext.UsingBlock.#ctor(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>
            <para>
            Creates a new "using" block (equivalent) around a variable;
            the variable must exist, and note that (unlike in C#) it is
            the variables *final* value that gets disposed. If you need
            *original* disposal, copy your variable first.
            </para>
            <para>
            It is the callers responsibility to ensure that the variable's
            scope fully-encapsulates the "using"; if not, the variable
            may be re-used (and thus re-assigned) unexpectedly.
            </para>
            </summary>
        </member>
        <member name="P:ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ExpectedType">
            <summary>
            The type that this serializer is intended to work for.
            </summary>
        </member>
        <member name="M:ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.Write(ProtoBuf.ProtoWriter.State@,System.Object)">
            <summary>
            Perform the steps necessary to serialize this data.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="state">Writer state</param>
        </member>
        <member name="M:ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.Read(ProtoBuf.ProtoReader.State@,System.Object)">
            <summary>
            Perform the steps necessary to deserialize this data.
            </summary>
            <param name="value">The current value, if appropriate.</param>
            <param name="state">Reader state</param>
            <returns>The updated / replacement value.</returns>
        </member>
        <member name="P:ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue">
            <summary>
            Indicates whether a Read operation <em>replaces</em> the existing value, or
            <em>extends</em> the value. If false, the "value" parameter to Read is
            discarded, and should be passed in as null.
            </summary>
        </member>
        <member name="P:ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue">
            <summary>
            Now all Read operations return a value (although most do); if false no
            value should be expected.
            </summary>
        </member>
        <member name="M:ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>Emit the IL necessary to perform the given actions
            to serialize this data.
            </summary>
            <param name="ctx">Details and utilities for the method being generated.</param>
            <param name="valueFrom">The source of the data to work against;
            If the value is only needed once, then LoadValue is sufficient. If
            the value is needed multiple times, then note that a "null"
            means "the top of the stack", in which case you should create your
            own copy - GetLocalWithValue.</param>
        </member>
        <member name="M:ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>
            Emit the IL necessary to perform the given actions to deserialize this data.
            </summary>
            <param name="ctx">Details and utilities for the method being generated.</param>
            <param name="entity">For nested values, the instance holding the values; note
            that this is not always provided - a null means not supplied. Since this is always
            a variable or argument, it is not necessary to consume this value.</param>
        </member>
        <member name="T:ProtoBuf.Meta.AutoCompileTypeModel">
            <summary>
            A type model that performs per-assembly auto-compilation
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.AutoCompileTypeModel.CreateForAssembly``1">
            <summary>
            Create a model that serializes all types from an
            assembly specified by type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.AutoCompileTypeModel.CreateForAssembly(System.Type)">
            <summary>
            Create a model that serializes all types from an
            assembly specified by type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.AutoCompileTypeModel.CreateForAssembly(System.Reflection.Assembly)">
            <summary>
            Create a model that serializes all types from an assembly
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.AutoCompileTypeModel.CreateForAssembly(System.Reflection.Assembly,ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions)">
            <summary>
            Create a model that serializes all types from an assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.AutoCompileTypeModel.Instance">
            <summary>
            Gets the instance of this serializer
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.AutoCompileTypeModel.GetSchema(System.Type,ProtoBuf.Meta.ProtoSyntax)">
            <summary>See TypeModel.GetSchema</summary>
        </member>
        <member name="M:ProtoBuf.Meta.AutoCompileTypeModel.GetSerializer``1">
            <summary>See TypeModel.GetSerializer</summary>
        </member>
        <member name="T:ProtoBuf.Meta.CallbackSet">
            <summary>
            Represents the set of serialization callbacks to be used when serializing/deserializing a type.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.BeforeSerialize">
            <summary>Called before serializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.BeforeDeserialize">
            <summary>Called before deserializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.AfterSerialize">
            <summary>Called after serializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.AfterDeserialize">
            <summary>Called after deserializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.NonTrivial">
            <summary>
            True if any callback is set, else False
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.EnumMember">
            <summary>
            Describes a named constant integer, i.e. an enum value
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.EnumMember.Name">
            <summary>
            Gets the declared name of this enum member
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.EnumMember.Value">
            <summary>
            Gets the value of this enum member
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.EnumMember.#ctor(System.Object,System.String)">
            <summary>
            Create a new named enum value; the value can be of the expected
            enum type, or an appropriate boxed enum value
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.EnumMember.WithName(System.String)">
            <summary>
            Creates a copy of this definition with a different name
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.EnumMember.WithValue(System.Object)">
            <summary>
            Creates a copy of this definition with a different value
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.EnumMember.Normalize(System.Type)">
            <summary>
            Converts the declared value in accordance with the provided type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.EnumMember.Equals``1(``0)">
            <summary>Compare a member to an enum value</summary>
        </member>
        <member name="M:ProtoBuf.Meta.EnumMember.ToString">
            <summary>See object.ToString</summary>
        </member>
        <member name="M:ProtoBuf.Meta.EnumMember.GetHashCode">
            <summary>See object.GetHashCode</summary>
        </member>
        <member name="M:ProtoBuf.Meta.EnumMember.Equals(System.Object)">
            <summary>See object.Equals</summary>
        </member>
        <member name="M:ProtoBuf.Meta.EnumMember.Equals(ProtoBuf.Meta.EnumMember)">
            <summary>Compare two enum-member definitions</summary>
        </member>
        <member name="M:ProtoBuf.Meta.EnumMember.Create``1(``0)">
            <summary>
            Create an EnumMember instance from an enum value
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.MetaType">
            <summary>
            Represents a type at runtime for use with protobuf, allowing the field mappings (etc) to be defined
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.ToString">
            <summary>
            Get the name of the type being represented
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.BaseType">
            <summary>
            Gets the base-type for this type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.CompatibilityLevel">
            <summary>
            Gets or sets the <see cref="P:ProtoBuf.Meta.MetaType.CompatibilityLevel"/> for this instance
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.IncludeSerializerMethod">
            <summary>
            When used to compile a model, should public serialization/deserialzation methods
            be included for this type?
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.AsReferenceDefault">
            <summary>
            Should this type be treated as a reference by default?
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddSubType(System.Int32,System.Type)">
            <summary>
            Adds a known sub-type to the inheritance model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddSubType(System.Int32,System.Type,ProtoBuf.DataFormat)">
            <summary>
            Adds a known sub-type to the inheritance model
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.HasCallbacks">
            <summary>
            Indicates whether the current type has defined callbacks 
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.HasSubtypes">
            <summary>
            Indicates whether the current type has defined subtypes
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Callbacks">
            <summary>
            Returns the set of callbacks defined for this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
            <param name="beforeSerialize">The method (or null) called before serialization begins.</param>
            <param name="afterSerialize">The method (or null) called when serialization is complete.</param>
            <param name="beforeDeserialize">The method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
            <param name="afterDeserialize">The method (or null) called when deserialization is complete.</param>
            <returns>The set of callbacks.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.String,System.String,System.String,System.String)">
            <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
            <param name="beforeSerialize">The name of the method (or null) called before serialization begins.</param>
            <param name="afterSerialize">The name of the method (or null) called when serialization is complete.</param>
            <param name="beforeDeserialize">The name of the method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
            <param name="afterDeserialize">The name of the method (or null) called when deserialization is complete.</param>
            <returns>The set of callbacks.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.GetSchemaTypeName">
            <summary>
            Returns the public Type name of this Type used in serialization
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Name">
            <summary>
            Gets or sets the name of this contract.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetFactory(System.Reflection.MethodInfo)">
            <summary>
            Designate a factory-method to use to create instances of this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetFactory(System.String)">
            <summary>
            Designate a factory-method to use to create instances of this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.ThrowIfFrozen">
            <summary>
            Throws an exception if the type has been made immutable
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Type">
            <summary>
            The runtime type that the meta-type represents
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>        
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String)">
            <summary>
            Adds a member (by name) to the MetaType, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.UseConstructor">
            <summary>
            Gets or sets whether the type should use a parameterless constructor (the default),
            or whether the type should skip the constructor completely. This option is not supported
            on compact-framework.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.ConstructType">
            <summary>
            The concrete type to create when a new instance of this type is needed; this may be useful when dealing
            with dynamic proxies, or with interface-based APIs
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.String)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>     
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetSurrogate(System.Type)">
            <summary>
            Performs serialization of this type via a surrogate; all
            other serialization options are ignored and handled
            by the surrogate's configuration.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.String[])">
            <summary>
            Adds a set of members (by name) to the MetaType
            </summary>     
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Object)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>        
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Type,System.Type)">
            <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String,System.Type,System.Type)">
            <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Item(System.Int32)">
            <summary>
            Returns the ValueMember that matchs a given field number, or null if not found
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Item(System.Reflection.MemberInfo)">
            <summary>
            Returns the ValueMember that matchs a given member (property/field), or null if not found
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.GetFields">
            <summary>
            Returns the ValueMember instances associated with this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.GetEnumValues">
            <summary>
            Returns the EnumMember instances associated with this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetEnumValues(ProtoBuf.Meta.EnumMember[])">
            <summary>
            Add a new defined name/value pair for an enum
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.GetSubtypes">
            <summary>
            Returns the SubType instances associated with this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.CompileInPlace">
            <summary>
            Compiles the serializer for this type; this is *not* a full
            standalone compile, but can significantly boost performance
            while allowing additional types to be added.
            </summary>
            <remarks>An in-place compile can access non-public types / members</remarks>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.EnumPassthru">
            <summary>
            Gets or sets a value indicating that an enum should be treated directly as an int/short/etc, rather
            than enforcing .proto enum rules. This is useful *in particul* for [Flags] enums.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.IgnoreListHandling">
            <summary>
            Gets or sets a value indicating that this type should NOT be treated as a list, even if it has
            familiar list-like characteristics (enumerable, add, etc)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.SerializerType">
            <summary>
            Specify a custom serializer for this type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.IsGroup">
            <summary>
            Indicates whether this type should always be treated as a "group" (rather than a string-prefixed sub-message)
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.ApplyFieldOffset(System.Int32)">
            <summary>
            Apply a shift to all fields (and sub-types) on this type
            </summary>
            <param name="offset">The change in field number to apply</param>
            <remarks>The resultant field numbers must still all be considered valid</remarks>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddReservation(System.Int32,System.String)">
            <summary>
            Adds a single number field reservation
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddReservation(System.Int32,System.Int32,System.String)">
            <summary>
            Adds range number field reservation
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddReservation(System.String,System.String)">
            <summary>
            Adds a named field reservation
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel">
            <summary>
            Provides protobuf serialization support for a number of types that can be defined at runtime
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Initialize">
            <summary>
            Ensures that RuntimeTypeModel has been initialized, in advance of using methods on <see cref="T:ProtoBuf.Serializer"/>.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Options">
            <summary>
            Specifies optional behaviors associated with this model
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault">
            <summary>
            Global default that
            enables/disables automatic tag generation based on the existing name / order
            of the defined members. See <seealso cref="P:ProtoBuf.ProtoContractAttribute.InferTagFromName"/>
            for usage and <b>important warning</b> / explanation.
            You must set the global default before attempting to serialize/deserialize any
            impacted type.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoAddProtoContractTypesOnly">
            <summary>
            Global default that determines whether types are considered serializable
            if they have [DataContract] / [XmlType]. With this enabled, <b>ONLY</b>
            types marked as [ProtoContract] are added automatically.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.UseImplicitZeroDefaults">
            <summary>
            <para>
            Global switch that enables or disables the implicit
            handling of "zero defaults"; meanning: if no other default is specified,
            it assumes bools always default to false, integers to zero, etc.
            </para>
            <para>
            If this is disabled, no such assumptions are made and only *explicit*
            default values are processed. This is enabled by default to 
            preserve similar logic to v1.
            </para>
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AllowParseableTypes">
            <summary>
            Global switch that determines whether types with a <c>.ToString()</c> and a <c>Parse(string)</c>
            should be serialized as strings.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.IncludeDateTimeKind">
            <summary>
            Global switch that determines whether DateTime serialization should include the <c>Kind</c> of the date/time.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.SkipZeroLengthPackedArrays">
            <summary>
            Should zero-length packed arrays be serialized? (this is the v2 behavior, but skipping them is more efficient)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AllowPackedEncodingAtRoot">
            <summary>
            Should root-values allow "packed" encoding? (v2 does not support this)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.InternStrings">
            <summary>
            Global switch that determines whether a single instance of the same string should be used during deserialization.
            </summary>
            <remarks>Note this does not use the global .NET string interner</remarks>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Default">
            <summary>
            The default model, used to support ProtoBuf.Serializer
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetTypes">
            <summary>
            Returns a sequence of the Type instances that can be
            processed by this model.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.DefaultCompatibilityLevel">
            <summary>
            Gets or sets the default <see cref="T:ProtoBuf.CompatibilityLevel"/> for this model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetSchema(System.Type,ProtoBuf.Meta.ProtoSyntax)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
            <returns>The .proto definition as a string</returns>
            <param name="syntax">The .proto syntax to use</param>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Item(System.Type)">
            <summary>
            Obtains the MetaType associated with a given Type for the current model,
            allowing additional configuration.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Add``1(System.Boolean,ProtoBuf.CompatibilityLevel)">
            <summary>
            Like the non-generic Add(Type); for convenience
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Add(System.Type,System.Boolean)">
            <summary>
            Adds support for an additional type in this model, optionally
            applying inbuilt patterns. If the type is already known to the
            model, the existing type is returned **without** applying
            any additional behaviour.
            </summary>
            <remarks>Inbuilt patterns include:
            [ProtoContract]/[ProtoMember(n)]
            [DataContract]/[DataMember(Order=n)]
            [XmlType]/[XmlElement(Order=n)]
            [On{Des|S}erializ{ing|ed}]
            ShouldSerialize*/*Specified
            </remarks>
            <param name="type">The type to be supported</param>
            <param name="applyDefaultBehaviour">Whether to apply the inbuilt configuration patterns (via attributes etc), or
            just add the type with no additional configuration (the type must then be manually configured).</param>
            <returns>The MetaType representing this type, allowing
            further configuration.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Add(System.Type,System.Boolean,ProtoBuf.CompatibilityLevel)">
            <summary>
            Adds support for an additional type in this model, optionally
            applying inbuilt patterns. If the type is already known to the
            model, the existing type is returned **without** applying
            any additional behaviour.
            </summary>
            <remarks>Inbuilt patterns include:
            [ProtoContract]/[ProtoMember(n)]
            [DataContract]/[DataMember(Order=n)]
            [XmlType]/[XmlElement(Order=n)]
            [On{Des|S}erializ{ing|ed}]
            ShouldSerialize*/*Specified
            </remarks>
            <param name="type">The type to be supported</param>
            <param name="applyDefaultBehaviour">Whether to apply the inbuilt configuration patterns (via attributes etc), or
            just add the type with no additional configuration (the type must then be manually configured).</param>
            <param name="compatibilityLevel">The <see cref="T:ProtoBuf.CompatibilityLevel"/> to assume for this type; this should usually be omitted</param>
            <returns>The MetaType representing this type, allowing
            further configuration.</returns>
        </member>
        <member name="E:ProtoBuf.Meta.RuntimeTypeModel.BeforeApplyDefaultBehaviour">
            <summary>
            Raised before a type is auto-configured; this allows the auto-configuration to be electively suppressed
            </summary>
            <remarks>This callback should be fast and not involve complex external calls, as it may block the model</remarks>
        </member>
        <member name="E:ProtoBuf.Meta.RuntimeTypeModel.AfterApplyDefaultBehaviour">
            <summary>
            Raised after a type is auto-configured; this allows additional external customizations
            </summary>
            <remarks>This callback should be fast and not involve complex external calls, as it may block the model</remarks>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoCompile">
            <summary>
            Should serializers be compiled on demand? It may be useful
            to disable this for debugging purposes.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoAddMissingTypes">
            <summary>
            Should support for unexpected types be added automatically?
            If false, an exception is thrown when unexpected types
            are encountered.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.ThrowIfFrozen">
            <summary>
            Verifies that the model is still open to changes; if not, an exception is thrown
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Freeze">
            <summary>
            Prevents further changes to this model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetSerializer``1">
            <summary>Resolve a service relative to T</summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.IsKnownType``1(ProtoBuf.CompatibilityLevel)">
            <summary>Indicates whether a type is known to the model</summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.ToString">
            <summary>
            See Object.ToString
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CompileInPlace">
            <summary>
            Compiles the serializers individually; this is *not* a full
            standalone compile, but can significantly boost performance
            while allowing additional types to be added.
            </summary>
            <remarks>An in-place compile can access non-public types / members</remarks>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions">
            <summary>
            Represents configuration options for compiling a model to 
            a standalone assembly.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.SetFrameworkOptions(ProtoBuf.Meta.MetaType)">
            <summary>
            Import framework options from an existing type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TargetFrameworkName">
            <summary>
            The TargetFrameworkAttribute FrameworkName value to burn into the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TargetFrameworkDisplayName">
            <summary>
            The TargetFrameworkAttribute FrameworkDisplayName value to burn into the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TypeName">
            <summary>
            The name of the TypeModel class to create
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.OutputPath">
            <summary>
            The path for the new dll
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.ImageRuntimeVersion">
            <summary>
            The runtime version for the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.MetaDataVersion">
            <summary>
            The runtime version for the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.Accessibility">
            <summary>
            The acecssibility of the generated serializer
            </summary>
        </member>
        <member name="E:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.IncludeType">
            <summary>
            Implements a filter for use when generating models from assemblies
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel.Accessibility">
            <summary>
            Type accessibility
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.RuntimeTypeModel.Accessibility.Public">
            <summary>
            Available to all callers
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.RuntimeTypeModel.Accessibility.Internal">
            <summary>
            Available to all callers in the same assembly, or assemblies specified via [InternalsVisibleTo(...)]
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile(ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions)">
            <summary>
            Fully compiles the current model into a static-compiled serialization dll
            (the serialization dll still requires protobuf-net for support services).
            </summary>
            <remarks>A full compilation is restricted to accessing public types / members</remarks>
            <returns>An instance of the newly created compiled type-model</returns>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.MetadataTimeoutMilliseconds">
            <summary>
            The amount of time to wait if there are concurrent metadata access operations
            </summary>
        </member>
        <member name="E:ProtoBuf.Meta.RuntimeTypeModel.LockContended">
            <summary>
            If a lock-contention is detected, this event signals the *owner* of the lock responsible for the blockage, indicating
            what caused the problem; this is only raised if the lock-owning code successfully completes.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.SetDefaultFactory(System.Reflection.MethodInfo)">
            <summary>
            Designate a factory-method to use to create instances of any type; note that this only affect types seen by the serializer *after* setting the factory.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Create(System.String)">
            <summary>
            Creates a new runtime model, to which the caller
            can add support for a range of types. A model
            can be used "as is", or can be compiled for
            optimal performance.
            </summary>
            <param name="name">The logical name of this model</param>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CreateForAssembly``1">
            <summary>
            Create a model that serializes all types from an
            assembly specified by type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CreateForAssembly(System.Type)">
            <summary>
            Create a model that serializes all types from an
            assembly specified by type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CreateForAssembly(System.Reflection.Assembly)">
            <summary>
            Create a model that serializes all types from an assembly
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.MakeDefault">
            <summary>
            Promotes this model instance to be the default model; the default model is used by <see cref="T:ProtoBuf.Serializer"/> and <see cref="T:ProtoBuf.Serializer.NonGeneric"/>.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.LockContentedEventArgs">
            <summary>
            Contains the stack-trace of the owning code when a lock-contention scenario is detected
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.LockContentedEventArgs.OwnerStackTrace">
            <summary>
            The stack-trace of the code that owned the lock when a lock-contention scenario occurred
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.LockContentedEventHandler">
            <summary>
            Event-type that is raised when a lock-contention scenario is detected
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.SubType">
            <summary>
            Represents an inherited type in a type hierarchy.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.SubType.FieldNumber">
            <summary>
            The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.SubType.DerivedType">
            <summary>
            The sub-type to be considered.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.SubType.#ctor(System.Int32,ProtoBuf.Meta.MetaType,ProtoBuf.DataFormat)">
            <summary>
            Creates a new SubType instance.
            </summary>
            <param name="fieldNumber">The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.</param>
            <param name="derivedType">The sub-type to be considered.</param>
            <param name="format">Specific encoding style to use; in particular, Grouped can be used to avoid buffering, but is not the default.</param>
        </member>
        <member name="T:ProtoBuf.Meta.TypeAddedEventArgs">
            <summary>
            Event data associated with new types being added to a model
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeAddedEventArgs.ApplyDefaultBehaviour">
            <summary>
            Whether or not to apply the default mapping behavior
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeAddedEventArgs.MetaType">
            <summary>
            The configuration of the type being added
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeAddedEventArgs.Type">
            <summary>
            The type that was added to the model
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeAddedEventArgs.Model">
            <summary>
            The model that is being changed
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.ValueMember">
            <summary>
            Represents a member (property/field) that is mapped to a protobuf field
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.FieldNumber">
            <summary>
            The number that identifies this member in a protobuf stream
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.Member">
            <summary>
            Gets the member (field/property) which this member relates to.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.BackingMember">
            <summary>
            Gets the backing member (field/property) which this member relates to
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.ItemType">
            <summary>
            Within a list / array / etc, the type of object for each item in the list (especially useful with ArrayList)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.MemberType">
            <summary>
            The underlying type of the member
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DefaultType">
            <summary>
            For abstract types (IList etc), the type of concrete object to create (if required)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.ParentType">
            <summary>
            The type the defines the member
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DefaultValue">
            <summary>
            The default value of the item (members with this value will not be serialized)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.CompatibilityLevel">
            <summary>
            Gets or sets the <see cref="P:ProtoBuf.Meta.ValueMember.CompatibilityLevel"/> of this member; by default this is inherited from
            the type; when <see cref="F:ProtoBuf.CompatibilityLevel.Level200"/> is used with <see cref="F:ProtoBuf.DataFormat.WellKnown"/>,
            the member is considered <see cref="F:ProtoBuf.CompatibilityLevel.Level240"/>.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Type,System.Int32,System.Reflection.MemberInfo,System.Type,System.Type,System.Type,ProtoBuf.DataFormat,System.Object)">
            <summary>
            Creates a new ValueMember instance
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Int32,System.Type,System.Type,System.Type,ProtoBuf.DataFormat)">
            <summary>
            Creates a new ValueMember instance
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DataFormat">
            <summary>
            Specifies the rules used to process the field; this is used to determine the most appropriate
            wite-type, but also to describe subtypes <i>within</i> that wire-type (such as SignedVariant)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsStrict">
            <summary>
            Indicates whether this field should follow strict encoding rules; this means (for example) that if a "fixed32"
            is encountered when "variant" is defined, then it will fail (throw an exception) when parsing. Note that
            when serializing the defined type is always used.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsPacked">
            <summary>
            Indicates whether this field should use packed encoding (which can save lots of space for repeated primitive values).
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.OverwriteList">
            <summary>
            Indicates whether this field should *replace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsRequired">
            <summary>
            Indicates whether this field is mandatory.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsMap">
            <summary>
            Indicates that the member should be treated as a protobuf Map
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.MapKeyFormat">
            <summary>
            Specifies the data-format that should be used for the key, when IsMap is enabled
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.MapValueFormat">
            <summary>
            Specifies the data-format that should be used for the value, when IsMap is enabled
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.SetSpecified(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Specifies methods for working with optional data members.
            </summary>
            <param name="getSpecified">Provides a method (null for none) to query whether this member should
            be serialized; it must be of the form "bool {Method}()". The member is only serialized if the
            method returns true.</param>
            <param name="setSpecified">Provides a method (null for none) to indicate that a member was
            deserialized; it must be of the form "void {Method}(bool)", and will be called with "true"
            when data is found.</param>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.Name">
            <summary>
            Gets the logical name for this member in the schema (this is not critical for binary serialization, but may be used
            when inferring a schema).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.SupportNull">
            <summary>
            Should lists have extended support for null values? Note this makes the serialization less efficient.
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer">
            <summary>
            Provides protocol-buffer serialization capability for concrete, attributed types. This
            is a *default* model, but custom serializer models are also supported.
            </summary>
            <remarks>
            Protocol-buffer serialization is a compact binary format, designed to take
            advantage of sparse data and knowledge of specific data types; it is also
            extensible, allowing a type to be deserialized / merged even if some data is
            not recognised.
            </remarks>
        </member>
        <member name="M:ProtoBuf.Serializer.GetProto``1">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <typeparam name="T">The type to generate a .proto definition for</typeparam>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.GetProto``1(ProtoBuf.Meta.ProtoSyntax)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <typeparam name="T">The type to generate a .proto definition for</typeparam>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeepClone``1(``0,ProtoBuf.SerializationContext)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.DeepClone``1(``0,System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.Measure``1(``0,System.Object,System.Int64)">
            <summary>
            Calculates the length of a protocol-buffer payload for an item
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.IO.Stream,``0)">
            <summary>
            Applies a protocol-buffer stream to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.ChangeType``2(``0)">
            <summary>
            Serializes a given instance and deserializes it as a different type;
            this can be used to translate between wire-compatible objects (where
            two .NET types represent the same data), or to promote/demote a type
            through an inheritance hierarchy.
            </summary>
            <remarks>No assumption of compatibility is made between the types.</remarks>
            <typeparam name="TFrom">The type of the object being copied.</typeparam>
            <typeparam name="TTo">The type of the new object to be created.</typeparam>
            <param name="instance">The existing instance to use as a template.</param>
            <returns>A new instane of type TNewType, with the data from TOldType.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Xml.XmlReader,``0)">
            <summary>
            Applies a protocol-buffer from an XmlReader to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="reader">The XmlReader containing the data to apply to the instance (cannot be null).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Runtime.Serialization.SerializationInfo,``0)">
            <summary>
            Applies a protocol-buffer from a SerializationInfo to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="info">The SerializationInfo containing the data to apply to the instance (cannot be null).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,``0)">
            <summary>
            Applies a protocol-buffer from a SerializationInfo to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="info">The SerializationInfo containing the data to apply to the instance (cannot be null).</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.PrepareSerializer``1">
            <summary>
            Precompiles the serializer for a given type.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.CreateFormatter``1">
            <summary>
            Creates a new IFormatter that uses protocol-buffer [de]serialization.
            </summary>
            <typeparam name="T">The type of object to be [de]deserialized by the formatter.</typeparam>
            <returns>A new IFormatter to be used during [de]serialization.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignored for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="fieldNumber">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="fieldNumber">The expected tag of the item (only used with base-128 prefix style).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.MergeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
            <summary>
            Applies a protocol-buffer stream to an existing instance, using length-prefixed
            data - useful with network IO.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="source">The stream containing the data to investigate for a length.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.Byte[],System.Int32,System.Int32,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="buffer">The buffer containing the data to investigate for a length.</param>
            <param name="index">The offset of the first byte to read from the buffer.</param>
            <param name="count">The number of bytes to read from the buffer.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="F:ProtoBuf.Serializer.ListItemTag">
            <summary>
            The field number that is used as a default when serializing/deserializing a list of objects.
            The data is treated as repeated message with field number 1.
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.NonGeneric">
            <summary>
            Provides non-generic access to the default serializer.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.DeepClone(System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Deserialize(System.Type,System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <param name="type">The type to be created.</param>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Merge(System.IO.Stream,System.Object)">
            <summary>Applies a protocol-buffer stream to an existing instance.</summary>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.SerializeWithLengthPrefix(System.IO.Stream,System.Object,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.TryDeserializeWithLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,ProtoBuf.TypeResolver,System.Object@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.CanSerialize(System.Type)">
            <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.PrepareSerializer(System.Type)">
            <summary>
            Precompiles the serializer for a given type.
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.GlobalOptions">
            <summary>
            Global switches that change the behavior of protobuf-net
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializer.GlobalOptions.InferTagFromName">
            <summary>
            <see cref="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault"/>
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializer.GlobalOptions.DefaultSyntax">
            <summary>
            Gets or sets the default .proto syntax to be used
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.FlushPool">
            <summary>
            Releases any internal buffers that have been reserved for efficiency; this does not affect any serialization
            operations; simply: it can be used (optionally) to release the buffers for garbage collection (at the expense
            of having to re-allocate a new buffer for the next operation, rather than re-use prior buffers).
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.TypeResolver">
            <summary>
            Maps a field-number to a type
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.Deserialize``1(System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Deserialize``1(System.IO.Stream,``0,ProtoBuf.SerializationContext,System.Int64)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Deserialize``1(System.IO.Stream,``0,System.Object,System.Int64)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Deserialize(System.Type,System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <param name="type">The type to be created.</param>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Deserialize``1(System.ReadOnlyMemory{System.Byte},``0,System.Object)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.Deserialize``1(System.Buffers.ReadOnlySequence{System.Byte},``0,System.Object)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.IO.Stream,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.IO.Stream,``0,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="userState">Additional state for this serialization operation</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Buffers.IBufferWriter{System.Byte},``0,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied writer.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="userState">Additional serialization context</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Runtime.Serialization.SerializationInfo,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied SerializationInfo.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="info">The destination SerializationInfo to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied SerializationInfo.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="info">The destination SerializationInfo to write to.</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Xml.XmlWriter,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied XmlWriter.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="writer">The destination XmlWriter to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="T:ProtoBuf.ServiceModel.ProtoBehaviorAttribute">
            <summary>
            Uses protocol buffer serialization on the specified operation; note that this
            must be enabled on both the client and server.
            </summary>
        </member>
        <member name="T:ProtoBuf.ServiceModel.ProtoEndpointBehavior">
            <summary>
            Behavior to swap out DatatContractSerilaizer with the XmlProtoSerializer for a given endpoint.
             <example>
            Add the following to the server and client app.config in the system.serviceModel section:
             <behaviors>
               <endpointBehaviors>
                 <behavior name="ProtoBufBehaviorConfig">
                   <ProtoBufSerialization/>
                 </behavior>
               </endpointBehaviors>
             </behaviors>
             <extensions>
               <behaviorExtensions>
                 <add name="ProtoBufSerialization" type="ProtoBuf.ServiceModel.ProtoBehaviorExtension, protobuf-net, Version=1.0.0.255, Culture=neutral, PublicKeyToken=257b51d87d2e4d67"/>
               </behaviorExtensions>
             </extensions>
            
            Configure your endpoints to have a behaviorConfiguration as follows:
            
             <service name="TK.Framework.Samples.ServiceModel.Contract.SampleService">
               <endpoint address="http://myhost:9003/SampleService" binding="basicHttpBinding" behaviorConfiguration="ProtoBufBehaviorConfig"
                bindingConfiguration="basicHttpBindingConfig" name="basicHttpProtoBuf" contract="ISampleServiceContract" />
             </service>
             <client>
                 <endpoint address="http://myhost:9003/SampleService" binding="basicHttpBinding"
                     bindingConfiguration="basicHttpBindingConfig" contract="ISampleServiceContract"
                     name="BasicHttpProtoBufEndpoint" behaviorConfiguration="ProtoBufBehaviorConfig"/>
              </client>
            </example>
            </summary>
        </member>
        <member name="T:ProtoBuf.ServiceModel.ProtoOperationBehavior">
            <summary>
            Describes a WCF operation behaviour that can perform protobuf serialization
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.ProtoOperationBehavior.#ctor(System.ServiceModel.Description.OperationDescription)">
            <summary>
            Create a new ProtoOperationBehavior instance
            </summary>
        </member>
        <member name="P:ProtoBuf.ServiceModel.ProtoOperationBehavior.Model">
            <summary>
            The type-model that should be used with this behaviour
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.ProtoOperationBehavior.CreateSerializer(System.Type,System.Xml.XmlDictionaryString,System.Xml.XmlDictionaryString,System.Collections.Generic.IList{System.Type})">
            <summary>
            Creates a protobuf serializer if possible (falling back to the default WCF serializer)
            </summary>
        </member>
        <member name="T:ProtoBuf.ServiceModel.XmlProtoSerializer">
            <summary>
            An xml object serializer that can embed protobuf data in a base-64 hunk (looking like a byte[])
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.TryCreate(ProtoBuf.Meta.TypeModel,System.Type)">
            <summary>
            Attempt to create a new serializer for the given model and type
            </summary>
            <returns>A new serializer instance if the type is recognised by the model; null otherwise</returns>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.#ctor(ProtoBuf.Meta.TypeModel,System.Type)">
            <summary>
            Creates a new serializer for the given model and type
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteEndObject(System.Xml.XmlDictionaryWriter)">
            <summary>
            Ends an object in the output
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteStartObject(System.Xml.XmlDictionaryWriter,System.Object)">
            <summary>
            Begins an object in the output
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteObjectContent(System.Xml.XmlDictionaryWriter,System.Object)">
            <summary>
            Writes the body of an object in the output
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.IsStartObject(System.Xml.XmlDictionaryReader)">
            <summary>
            Indicates whether this is the start of an object we are prepared to handle
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.ReadObject(System.Xml.XmlDictionaryReader,System.Boolean)">
            <summary>
            Reads the body of an object
            </summary>
        </member>
    </members>
</doc>

```

`Tools/protogen/protogen.deps.json`:

```json
{
  "runtimeTarget": {
    "name": ".NETCoreApp,Version=v3.0",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETCoreApp,Version=v3.0": {
      "protogen/3.0.14": {
        "dependencies": {
          "Microsoft.SourceLink.GitHub": "1.0.0",
          "Nerdbank.GitVersioning": "3.1.91",
          "System.Collections.Immutable": "1.7.1",
          "protobuf-net": "1.0.0",
          "protobuf-net.Reflection": "1.0.0"
        },
        "runtime": {
          "protogen.dll": {}
        }
      },
      "Microsoft.Build.Tasks.Git/1.0.0": {},
      "Microsoft.NETCore.Platforms/2.0.0": {},
      "Microsoft.SourceLink.Common/1.0.0": {},
      "Microsoft.SourceLink.GitHub/1.0.0": {
        "dependencies": {
          "Microsoft.Build.Tasks.Git": "1.0.0",
          "Microsoft.SourceLink.Common": "1.0.0"
        }
      },
      "Nerdbank.GitVersioning/3.1.91": {},
      "System.Collections.Immutable/1.7.1": {
        "runtime": {
          "lib/netstandard2.0/System.Collections.Immutable.dll": {
            "assemblyVersion": "1.2.5.0",
            "fileVersion": "4.700.20.21406"
          }
        }
      },
      "System.Private.ServiceModel/4.7.0": {
        "dependencies": {
          "System.Reflection.DispatchProxy": "4.5.0",
          "System.Security.Cryptography.Xml": "4.5.0",
          "System.Security.Principal.Windows": "4.5.0"
        },
        "runtime": {
          "lib/netstandard2.0/System.Private.ServiceModel.dll": {
            "assemblyVersion": "4.7.0.0",
            "fileVersion": "4.700.19.56502"
          }
        }
      },
      "System.Reflection.DispatchProxy/4.5.0": {},
      "System.Reflection.Emit/4.7.0": {},
      "System.Reflection.Emit.Lightweight/4.7.0": {},
      "System.Security.AccessControl/4.5.0": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "2.0.0",
          "System.Security.Principal.Windows": "4.5.0"
        }
      },
      "System.Security.Cryptography.Cng/4.5.0": {},
      "System.Security.Cryptography.Pkcs/4.5.0": {
        "dependencies": {
          "System.Security.Cryptography.Cng": "4.5.0"
        },
        "runtime": {
          "lib/netcoreapp2.1/System.Security.Cryptography.Pkcs.dll": {
            "assemblyVersion": "4.0.3.0",
            "fileVersion": "4.6.26515.6"
          }
        },
        "runtimeTargets": {
          "runtimes/win/lib/netcoreapp2.1/System.Security.Cryptography.Pkcs.dll": {
            "rid": "win",
            "assetType": "runtime",
            "assemblyVersion": "4.0.3.0",
            "fileVersion": "4.6.26515.6"
          }
        }
      },
      "System.Security.Cryptography.Xml/4.5.0": {
        "dependencies": {
          "System.Security.Cryptography.Pkcs": "4.5.0",
          "System.Security.Permissions": "4.5.0"
        },
        "runtime": {
          "lib/netstandard2.0/System.Security.Cryptography.Xml.dll": {
            "assemblyVersion": "4.0.1.0",
            "fileVersion": "4.6.26515.6"
          }
        }
      },
      "System.Security.Permissions/4.5.0": {
        "dependencies": {
          "System.Security.AccessControl": "4.5.0"
        },
        "runtime": {
          "lib/netstandard2.0/System.Security.Permissions.dll": {
            "assemblyVersion": "4.0.1.0",
            "fileVersion": "4.6.26515.6"
          }
        }
      },
      "System.Security.Principal.Windows/4.5.0": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "2.0.0"
        }
      },
      "System.ServiceModel.Primitives/4.7.0": {
        "dependencies": {
          "System.Private.ServiceModel": "4.7.0"
        },
        "runtime": {
          "lib/netcoreapp2.1/System.ServiceModel.Primitives.dll": {
            "assemblyVersion": "4.7.0.0",
            "fileVersion": "4.700.19.56502"
          },
          "lib/netcoreapp2.1/System.ServiceModel.dll": {
            "assemblyVersion": "4.0.0.0",
            "fileVersion": "4.700.19.56502"
          }
        }
      },
      "protobuf-net/1.0.0": {
        "dependencies": {
          "System.Reflection.Emit": "4.7.0",
          "System.Reflection.Emit.Lightweight": "4.7.0",
          "System.ServiceModel.Primitives": "4.7.0",
          "protobuf-net.Core": "1.0.0"
        },
        "runtime": {
          "protobuf-net.dll": {}
        }
      },
      "protobuf-net.Core/1.0.0": {
        "runtime": {
          "protobuf-net.Core.dll": {}
        }
      },
      "protobuf-net.Reflection/1.0.0": {
        "dependencies": {
          "protobuf-net.Core": "1.0.0"
        },
        "runtime": {
          "protobuf-net.Reflection.dll": {}
        }
      }
    }
  },
  "libraries": {
    "protogen/3.0.14": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Microsoft.Build.Tasks.Git/1.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-z2fpmmt+1Jfl+ZnBki9nSP08S1/tbEOxFdsK1rSR+LBehIJz1Xv9/6qOOoGNqlwnAGGVGis1Oj6S8Kt9COEYlQ==",
      "path": "microsoft.build.tasks.git/1.0.0",
      "hashPath": "microsoft.build.tasks.git.1.0.0.nupkg.sha512"
    },
    "Microsoft.NETCore.Platforms/2.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-VdLJOCXhZaEMY7Hm2GKiULmn7IEPFE4XC5LPSfBVCUIA8YLZVh846gtfBJalsPQF2PlzdD7ecX7DZEulJ402ZQ==",
      "path": "microsoft.netcore.platforms/2.0.0",
      "hashPath": "microsoft.netcore.platforms.2.0.0.nupkg.sha512"
    },
    "Microsoft.SourceLink.Common/1.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-G8DuQY8/DK5NN+3jm5wcMcd9QYD90UV7MiLmdljSJixi3U/vNaeBKmmXUqI4DJCOeWizIUEh4ALhSt58mR+5eg==",
      "path": "microsoft.sourcelink.common/1.0.0",
      "hashPath": "microsoft.sourcelink.common.1.0.0.nupkg.sha512"
    },
    "Microsoft.SourceLink.GitHub/1.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-aZyGyGg2nFSxix+xMkPmlmZSsnGQ3w+mIG23LTxJZHN+GPwTQ5FpPgDo7RMOq+Kcf5D4hFWfXkGhoGstawX13Q==",
      "path": "microsoft.sourcelink.github/1.0.0",
      "hashPath": "microsoft.sourcelink.github.1.0.0.nupkg.sha512"
    },
    "Nerdbank.GitVersioning/3.1.91": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-eQI9TrHjxDtM4eUtl8zCAT5DGtQgZ6mpRd/qkHBEWUeLK/cn1wXnTdJ/6ffs5tlFDP1mEmGHc//wUzFdfr4Eiw==",
      "path": "nerdbank.gitversioning/3.1.91",
      "hashPath": "nerdbank.gitversioning.3.1.91.nupkg.sha512"
    },
    "System.Collections.Immutable/1.7.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-B43Zsz5EfMwyEbnObwRxW5u85fzJma3lrDeGcSAV1qkhSRTNY5uXAByTn9h9ddNdhM+4/YoLc/CI43umjwIl9Q==",
      "path": "system.collections.immutable/1.7.1",
      "hashPath": "system.collections.immutable.1.7.1.nupkg.sha512"
    },
    "System.Private.ServiceModel/4.7.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-BItrYCkoTV3VzVPsrew+uc34fmLb+3ncgspa7vbO3vkfY9JQCea4u34pHE+Bcv1Iy16MgRs3n2jKVRCDg0rPfg==",
      "path": "system.private.servicemodel/4.7.0",
      "hashPath": "system.private.servicemodel.4.7.0.nupkg.sha512"
    },
    "System.Reflection.DispatchProxy/4.5.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-+UW1hq11TNSeb+16rIk8hRQ02o339NFyzMc4ma/FqmxBzM30l1c2IherBB4ld1MNcenS48fz8tbt50OW4rVULA==",
      "path": "system.reflection.dispatchproxy/4.5.0",
      "hashPath": "system.reflection.dispatchproxy.4.5.0.nupkg.sha512"
    },
    "System.Reflection.Emit/4.7.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-VR4kk8XLKebQ4MZuKuIni/7oh+QGFmZW3qORd1GvBq/8026OpW501SzT/oypwiQl4TvT8ErnReh/NzY9u+C6wQ==",
      "path": "system.reflection.emit/4.7.0",
      "hashPath": "system.reflection.emit.4.7.0.nupkg.sha512"
    },
    "System.Reflection.Emit.Lightweight/4.7.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-a4OLB4IITxAXJeV74MDx49Oq2+PsF6Sml54XAFv+2RyWwtDBcabzoxiiJRhdhx+gaohLh4hEGCLQyBozXoQPqA==",
      "path": "system.reflection.emit.lightweight/4.7.0",
      "hashPath": "system.reflection.emit.lightweight.4.7.0.nupkg.sha512"
    },
    "System.Security.AccessControl/4.5.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-vW8Eoq0TMyz5vAG/6ce483x/CP83fgm4SJe5P8Tb1tZaobcvPrbMEL7rhH1DRdrYbbb6F0vq3OlzmK0Pkwks5A==",
      "path": "system.security.accesscontrol/4.5.0",
      "hashPath": "system.security.accesscontrol.4.5.0.nupkg.sha512"
    },
    "System.Security.Cryptography.Cng/4.5.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-WG3r7EyjUe9CMPFSs6bty5doUqT+q9pbI80hlNzo2SkPkZ4VTuZkGWjpp77JB8+uaL4DFPRdBsAY+DX3dBK92A==",
      "path": "system.security.cryptography.cng/4.5.0",
      "hashPath": "system.security.cryptography.cng.4.5.0.nupkg.sha512"
    },
    "System.Security.Cryptography.Pkcs/4.5.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-TGQX51gxpY3K3I6LJlE2LAftVlIMqJf0cBGhz68Y89jjk3LJCB6SrwiD+YN1fkqemBvWGs+GjyMJukl6d6goyQ==",
      "path": "system.security.cryptography.pkcs/4.5.0",
      "hashPath": "system.security.cryptography.pkcs.4.5.0.nupkg.sha512"
    },
    "System.Security.Cryptography.Xml/4.5.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-i2Jn6rGXR63J0zIklImGRkDIJL4b1NfPSEbIVHBlqoIb12lfXIigCbDRpDmIEzwSo/v1U5y/rYJdzZYSyCWxvg==",
      "path": "system.security.cryptography.xml/4.5.0",
      "hashPath": "system.security.cryptography.xml.4.5.0.nupkg.sha512"
    },
    "System.Security.Permissions/4.5.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-9gdyuARhUR7H+p5CjyUB/zPk7/Xut3wUSP8NJQB6iZr8L3XUXTMdoLeVAg9N4rqF8oIpE7MpdqHdDHQ7XgJe0g==",
      "path": "system.security.permissions/4.5.0",
      "hashPath": "system.security.permissions.4.5.0.nupkg.sha512"
    },
    "System.Security.Principal.Windows/4.5.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-U77HfRXlZlOeIXd//Yoj6Jnk8AXlbeisf1oq1os+hxOGVnuG+lGSfGqTwTZBoORFF6j/0q7HXIl8cqwQ9aUGqQ==",
      "path": "system.security.principal.windows/4.5.0",
      "hashPath": "system.security.principal.windows.4.5.0.nupkg.sha512"
    },
    "System.ServiceModel.Primitives/4.7.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-YUXIMO4kL1v6dUVptJGixAx/8Ai5trQzVn3gbk0mpwxh77kGAs+MyBRoHN/5ZoxtwNn4E1dq3N4rJCAgAUaiJA==",
      "path": "system.servicemodel.primitives/4.7.0",
      "hashPath": "system.servicemodel.primitives.4.7.0.nupkg.sha512"
    },
    "protobuf-net/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "protobuf-net.Core/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "protobuf-net.Reflection/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    }
  }
}
```

`Tools/protogen/protogen.runtimeconfig.dev.json`:

```json
{
  "runtimeOptions": {
    "additionalProbingPaths": [
      "C:\\Users\\CSR\\.dotnet\\store\\|arch|\\|tfm|",
      "C:\\Users\\CSR\\.nuget\\packages",
      "C:\\Program Files\\dotnet\\sdk\\NuGetFallbackFolder"
    ]
  }
}
```

`Tools/protogen/protogen.runtimeconfig.json`:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.NETCore.App",
      "version": "3.0.0"
    }
  }
}
```

`Tools/protogen/protogen.xml`:

```xml
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>protogen</name>
    </assembly>
    <members>
    </members>
</doc>

```