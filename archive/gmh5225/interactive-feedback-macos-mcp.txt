Project Path: arc_gmh5225_interactive-feedback-macos-mcp_11vlnd84

Source Tree:

```txt
arc_gmh5225_interactive-feedback-macos-mcp_11vlnd84
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ biome.json
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â””â”€â”€ src
    â””â”€â”€ mcp-server-macos.js

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 gmh5225.eth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Interactive Feedback MCP for macOS

A native macOS MCP server for collecting interactive user feedback with AppleScript dialogs and image support.

![image](https://github.com/user-attachments/assets/7d321b56-303c-4045-9ec5-de865c1c5b11)



![image](https://github.com/user-attachments/assets/a0652fa6-5ddb-48c5-a3cb-067a95748110)




## âœ¨ What's Different

This is a macOS-native reimplementation of the original [interactive-feedback-mcp](https://github.com/noopstudios/interactive-feedback-mcp) by FÃ¡bio Ferreira ([@fabiomlferreira](https://x.com/fabiomlferreira)) with the following enhancements:

- **Native macOS Dialogs**: Uses AppleScript instead of web UI
- **Image Support**: Built-in image picker and screenshot capture
- **Lightweight**: No web server dependencies (Express, CORS, etc.)
- **Better Integration**: Seamless macOS user experience

## ðŸ›  Installation

1. Clone and install:
   ```bash
   git clone https://github.com/gmh5225/interactive-feedback-macos-mcp.git
   cd interactive-feedback-macos-mcp
   npm install
   ```

2. Add to your Cursor MCP configuration:
   ```json
   {
     "mcpServers": {
       "interactive-feedback-macos-mcp": {
         "command": "node",
         "args": ["/path/to/interactive-feedback-macos-mcp/src/mcp-server-macos.js"],
         "autoApprove": ["collect_feedback", "pick_image", "get_image_info", "take_screenshot"]
       }
     }
   }
   ```

## ðŸ”§ Available Tools

- **`collect_feedback`**: Native dialog for user feedback with optional image attachment
- **`pick_image`**: macOS file picker for image selection
- **`get_image_info`**: Get image metadata and base64 content
- **`take_screenshot`**: Capture area or full screen screenshots

## ðŸ“ Usage

Add this to your AI assistant prompt for best results:

> Whenever you want to ask a question, always call the MCP `interactive-feedback-macos-mcp.collect_feedback`.
> Whenever you're about to complete a user request, call the MCP `interactive-feedback-macos-mcp.collect_feedback` instead of simply ending the process.

##  License

MIT License

## ðŸ™ Credits

Based on [interactive-feedback-mcp](https://github.com/noopstudios/interactive-feedback-mcp) by FÃ¡bio Ferreira ([@fabiomlferreira](https://x.com/fabiomlferreira)).

```

`biome.json`:

```json
{
	"$schema": "./node_modules/@biomejs/biome/configuration_schema.json",
	"formatter": {
		"enabled": true,
		"useEditorconfig": true
	},
	"linter": {
		"enabled": true,
		"rules": {
			"recommended": true,
			"suspicious": {
				"noExplicitAny": "off",
				"noArrayIndexKey": "off"
			},
			"complexity": {
				"noForEach": "off"
			},
			"correctness": {
				"useExhaustiveDependencies": "off",
				"noUnusedImports": "error",
				"noUnusedFunctionParameters": "warn"
			},
			"style": {
				"noUnusedTemplateLiteral": {
					"level": "error",
					"fix": "safe"
				},
				"noNonNullAssertion": "warn",
				"useBlockStatements": "warn"
			}
		}
	},
	"organizeImports": {
		"enabled": true
	},
	"files": {
		"ignore": ["./packages/database/prisma/zod/index.ts"]
	},
	"javascript": {
		"jsxRuntime": "reactClassic"
	},
	"css": {
		"formatter": {
			"enabled": false
		},
		"linter": {
			"enabled": false
		}
	},
	"vcs": {
		"enabled": true,
		"clientKind": "git",
		"defaultBranch": "main",
		"useIgnoreFile": true
	}
}

```

`package-lock.json`:

```json
{
	"name": "interactive-feedback-macos-mcp",
	"version": "1.0.2",
	"lockfileVersion": 3,
	"requires": true,
	"packages": {
		"": {
			"name": "interactive-feedback-macos-mcp",
			"version": "1.0.2",
			"license": "MIT",
			"dependencies": {
				"@modelcontextprotocol/sdk": "0.5.0",
				"image-size": "^1.0.2"
			},
			"bin": {
				"interactive-feedback-macos-mcp": "src/mcp-server-macos.js"
			},
			"devDependencies": {
				"@biomejs/biome": "1.9.4"
			}
		},
		"node_modules/@biomejs/biome": {
			"version": "1.9.4",
			"resolved": "https://registry.npmjs.org/@biomejs/biome/-/biome-1.9.4.tgz",
			"integrity": "sha512-1rkd7G70+o9KkTn5KLmDYXihGoTaIGO9PIIN2ZB7UJxFrWw04CZHPYiMRjYsaDvVV7hP1dYNRLxSANLaBFGpog==",
			"dev": true,
			"hasInstallScript": true,
			"license": "MIT OR Apache-2.0",
			"bin": {
				"biome": "bin/biome"
			},
			"engines": {
				"node": ">=14.21.3"
			},
			"funding": {
				"type": "opencollective",
				"url": "https://opencollective.com/biome"
			},
			"optionalDependencies": {
				"@biomejs/cli-darwin-arm64": "1.9.4",
				"@biomejs/cli-darwin-x64": "1.9.4",
				"@biomejs/cli-linux-arm64": "1.9.4",
				"@biomejs/cli-linux-arm64-musl": "1.9.4",
				"@biomejs/cli-linux-x64": "1.9.4",
				"@biomejs/cli-linux-x64-musl": "1.9.4",
				"@biomejs/cli-win32-arm64": "1.9.4",
				"@biomejs/cli-win32-x64": "1.9.4"
			}
		},
		"node_modules/@biomejs/cli-darwin-arm64": {
			"version": "1.9.4",
			"resolved": "https://registry.npmjs.org/@biomejs/cli-darwin-arm64/-/cli-darwin-arm64-1.9.4.tgz",
			"integrity": "sha512-bFBsPWrNvkdKrNCYeAp+xo2HecOGPAy9WyNyB/jKnnedgzl4W4Hb9ZMzYNbf8dMCGmUdSavlYHiR01QaYR58cw==",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=14.21.3"
			}
		},
		"node_modules/@biomejs/cli-darwin-x64": {
			"version": "1.9.4",
			"resolved": "https://registry.npmjs.org/@biomejs/cli-darwin-x64/-/cli-darwin-x64-1.9.4.tgz",
			"integrity": "sha512-ngYBh/+bEedqkSevPVhLP4QfVPCpb+4BBe2p7Xs32dBgs7rh9nY2AIYUL6BgLw1JVXV8GlpKmb/hNiuIxfPfZg==",
			"cpu": [
				"x64"
			],
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=14.21.3"
			}
		},
		"node_modules/@biomejs/cli-linux-arm64": {
			"version": "1.9.4",
			"resolved": "https://registry.npmjs.org/@biomejs/cli-linux-arm64/-/cli-linux-arm64-1.9.4.tgz",
			"integrity": "sha512-fJIW0+LYujdjUgJJuwesP4EjIBl/N/TcOX3IvIHJQNsAqvV2CHIogsmA94BPG6jZATS4Hi+xv4SkBBQSt1N4/g==",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"optional": true,
			"os": [
				"linux"
			],
			"engines": {
				"node": ">=14.21.3"
			}
		},
		"node_modules/@biomejs/cli-linux-arm64-musl": {
			"version": "1.9.4",
			"resolved": "https://registry.npmjs.org/@biomejs/cli-linux-arm64-musl/-/cli-linux-arm64-musl-1.9.4.tgz",
			"integrity": "sha512-v665Ct9WCRjGa8+kTr0CzApU0+XXtRgwmzIf1SeKSGAv+2scAlW6JR5PMFo6FzqqZ64Po79cKODKf3/AAmECqA==",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"optional": true,
			"os": [
				"linux"
			],
			"engines": {
				"node": ">=14.21.3"
			}
		},
		"node_modules/@biomejs/cli-linux-x64": {
			"version": "1.9.4",
			"resolved": "https://registry.npmjs.org/@biomejs/cli-linux-x64/-/cli-linux-x64-1.9.4.tgz",
			"integrity": "sha512-lRCJv/Vi3Vlwmbd6K+oQ0KhLHMAysN8lXoCI7XeHlxaajk06u7G+UsFSO01NAs5iYuWKmVZjmiOzJ0OJmGsMwg==",
			"cpu": [
				"x64"
			],
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"optional": true,
			"os": [
				"linux"
			],
			"engines": {
				"node": ">=14.21.3"
			}
		},
		"node_modules/@biomejs/cli-linux-x64-musl": {
			"version": "1.9.4",
			"resolved": "https://registry.npmjs.org/@biomejs/cli-linux-x64-musl/-/cli-linux-x64-musl-1.9.4.tgz",
			"integrity": "sha512-gEhi/jSBhZ2m6wjV530Yy8+fNqG8PAinM3oV7CyO+6c3CEh16Eizm21uHVsyVBEB6RIM8JHIl6AGYCv6Q6Q9Tg==",
			"cpu": [
				"x64"
			],
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"optional": true,
			"os": [
				"linux"
			],
			"engines": {
				"node": ">=14.21.3"
			}
		},
		"node_modules/@biomejs/cli-win32-arm64": {
			"version": "1.9.4",
			"resolved": "https://registry.npmjs.org/@biomejs/cli-win32-arm64/-/cli-win32-arm64-1.9.4.tgz",
			"integrity": "sha512-tlbhLk+WXZmgwoIKwHIHEBZUwxml7bRJgk0X2sPyNR3S93cdRq6XulAZRQJ17FYGGzWne0fgrXBKpl7l4M87Hg==",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"optional": true,
			"os": [
				"win32"
			],
			"engines": {
				"node": ">=14.21.3"
			}
		},
		"node_modules/@biomejs/cli-win32-x64": {
			"version": "1.9.4",
			"resolved": "https://registry.npmjs.org/@biomejs/cli-win32-x64/-/cli-win32-x64-1.9.4.tgz",
			"integrity": "sha512-8Y5wMhVIPaWe6jw2H+KlEm4wP/f7EW3810ZLmDlrEEy5KvBsb9ECEfu/kMWD484ijfQ8+nIi0giMgu9g1UAuuA==",
			"cpu": [
				"x64"
			],
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"optional": true,
			"os": [
				"win32"
			],
			"engines": {
				"node": ">=14.21.3"
			}
		},
		"node_modules/@modelcontextprotocol/sdk": {
			"version": "0.5.0",
			"resolved": "https://registry.npmjs.org/@modelcontextprotocol/sdk/-/sdk-0.5.0.tgz",
			"integrity": "sha512-RXgulUX6ewvxjAG0kOpLMEdXXWkzWgaoCGaA2CwNW7cQCIphjpJhjpHSiaPdVCnisjRF/0Cm9KWHUuIoeiAblQ==",
			"license": "MIT",
			"dependencies": {
				"content-type": "^1.0.5",
				"raw-body": "^3.0.0",
				"zod": "^3.23.8"
			}
		},
		"node_modules/bytes": {
			"version": "3.1.2",
			"resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
			"integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
			"license": "MIT",
			"engines": {
				"node": ">= 0.8"
			}
		},
		"node_modules/content-type": {
			"version": "1.0.5",
			"resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
			"integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
			"license": "MIT",
			"engines": {
				"node": ">= 0.6"
			}
		},
		"node_modules/depd": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
			"integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
			"license": "MIT",
			"engines": {
				"node": ">= 0.8"
			}
		},
		"node_modules/http-errors": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
			"integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
			"license": "MIT",
			"dependencies": {
				"depd": "2.0.0",
				"inherits": "2.0.4",
				"setprototypeof": "1.2.0",
				"statuses": "2.0.1",
				"toidentifier": "1.0.1"
			},
			"engines": {
				"node": ">= 0.8"
			}
		},
		"node_modules/iconv-lite": {
			"version": "0.6.3",
			"resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
			"integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
			"license": "MIT",
			"dependencies": {
				"safer-buffer": ">= 2.1.2 < 3.0.0"
			},
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/image-size": {
			"version": "1.2.1",
			"resolved": "https://registry.npmjs.org/image-size/-/image-size-1.2.1.tgz",
			"integrity": "sha512-rH+46sQJ2dlwfjfhCyNx5thzrv+dtmBIhPHk0zgRUukHzZ/kRueTJXoYYsclBaKcSMBWuGbOFXtioLpzTb5euw==",
			"license": "MIT",
			"dependencies": {
				"queue": "6.0.2"
			},
			"bin": {
				"image-size": "bin/image-size.js"
			},
			"engines": {
				"node": ">=16.x"
			}
		},
		"node_modules/inherits": {
			"version": "2.0.4",
			"resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
			"integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
			"license": "ISC"
		},
		"node_modules/queue": {
			"version": "6.0.2",
			"resolved": "https://registry.npmjs.org/queue/-/queue-6.0.2.tgz",
			"integrity": "sha512-iHZWu+q3IdFZFX36ro/lKBkSvfkztY5Y7HMiPlOUjhupPcG2JMfst2KKEpu5XndviX/3UhFbRngUPNKtgvtZiA==",
			"license": "MIT",
			"dependencies": {
				"inherits": "~2.0.3"
			}
		},
		"node_modules/raw-body": {
			"version": "3.0.0",
			"resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.0.tgz",
			"integrity": "sha512-RmkhL8CAyCRPXCE28MMH0z2PNWQBNk2Q09ZdxM9IOOXwxwZbN+qbWaatPkdkWIKL2ZVDImrN/pK5HTRz2PcS4g==",
			"license": "MIT",
			"dependencies": {
				"bytes": "3.1.2",
				"http-errors": "2.0.0",
				"iconv-lite": "0.6.3",
				"unpipe": "1.0.0"
			},
			"engines": {
				"node": ">= 0.8"
			}
		},
		"node_modules/safer-buffer": {
			"version": "2.1.2",
			"resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
			"integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
			"license": "MIT"
		},
		"node_modules/setprototypeof": {
			"version": "1.2.0",
			"resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
			"integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
			"license": "ISC"
		},
		"node_modules/statuses": {
			"version": "2.0.1",
			"resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
			"integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
			"license": "MIT",
			"engines": {
				"node": ">= 0.8"
			}
		},
		"node_modules/toidentifier": {
			"version": "1.0.1",
			"resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
			"integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
			"license": "MIT",
			"engines": {
				"node": ">=0.6"
			}
		},
		"node_modules/unpipe": {
			"version": "1.0.0",
			"resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
			"integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
			"license": "MIT",
			"engines": {
				"node": ">= 0.8"
			}
		},
		"node_modules/zod": {
			"version": "3.25.42",
			"resolved": "https://registry.npmjs.org/zod/-/zod-3.25.42.tgz",
			"integrity": "sha512-PcALTLskaucbeHc41tU/xfjfhcz8z0GdhhDcSgrCTmSazUuqnYqiXO63M0QUBVwpBlsLsNVn5qHSC5Dw3KZvaQ==",
			"license": "MIT",
			"funding": {
				"url": "https://github.com/sponsors/colinhacks"
			}
		}
	}
}

```

`package.json`:

```json
{
	"name": "interactive-feedback-macos-mcp",
	"version": "1.0.2",
	"description": "macOS MCP tool for collecting interactive user feedback with native dialogs and image support",
	"main": "src/mcp-server-macos.js",
	"scripts": {
		"start": "node src/mcp-server-macos.js",
		"format": "biome format . --write",
		"lint": "biome lint ."
	},
	"dependencies": {
		"@modelcontextprotocol/sdk": "0.5.0",
		"image-size": "^1.0.2"
	},
	"devDependencies": {
		"@biomejs/biome": "1.9.4"
	},
	"bin": {
		"interactive-feedback-macos-mcp": "./src/mcp-server-macos.js"
	},
	"keywords": ["mcp", "macos", "feedback", "interactive"],
	"author": "gmh5225",
	"license": "MIT"
}

```

`src/mcp-server-macos.js`:

```js
#!/usr/bin/env node

const path = require("path");
const fs = require("fs");
const { spawn, exec } = require("child_process");
const imageSize = require("image-size");
const { Server } = require("@modelcontextprotocol/sdk/server/index.js");
const {
	StdioServerTransport,
} = require("@modelcontextprotocol/sdk/server/stdio.js");
const {
	CallToolRequestSchema,
	ListToolsRequestSchema,
} = require("@modelcontextprotocol/sdk/types.js");

console.error(`[Native MCP] Starting server...`);
console.error(`[Native MCP] Node version: ${process.version}`);
console.error(`[Native MCP] Working directory: ${process.cwd()}`);

class NativeMCPServer {
	constructor() {
		this.requestId = 0;
	}

	// Display native dialog using AppleScript (supports pasting multi-line text)
	async showNativeDialog(title, message, defaultText = "") {
		return new Promise((resolve, reject) => {
			const script = `
        tell application "System Events"
          activate
          set userInput to text returned of (display dialog "${message}

Tips:
â€¢ You can paste multi-line text directly
â€¢ Line breaks will be preserved
â€¢ Supports Cmd+A to select all, Cmd+C to copy, Cmd+V to paste" default answer "${defaultText}" with title "${title}" buttons {"Cancel", "OK"} default button "OK")
          return userInput
        end tell
      `;

			exec(`osascript -e '${script}'`, (error, stdout, stderr) => {
				if (error) {
					if (error.code === 1) {
						// User clicked cancel
						resolve(null);
					} else {
						reject(new Error(`AppleScript error: ${error.message}`));
					}
				} else {
					// Ensure line breaks are properly handled
					const result = stdout.replace(/\r\n|\r/g, "\n").trim();
					resolve(result);
				}
			});
		});
	}

	// Use native file picker
	async showNativeFilePicker() {
		return new Promise((resolve, reject) => {
			const script = `
        tell application "System Events"
          activate
          set selectedFile to (choose file with prompt "Please select an image file" of type {"public.image"})
          return POSIX path of selectedFile
        end tell
      `;

			exec(`osascript -e '${script}'`, (error, stdout, stderr) => {
				if (error) {
					if (error.code === 1) {
						// User clicked cancel
						resolve(null);
					} else {
						reject(new Error(`AppleScript error: ${error.message}`));
					}
				} else {
					resolve(stdout.trim());
				}
			});
		});
	}

	async showNativeAlert(title, message) {
		return new Promise((resolve) => {
			const script = `
        tell application "System Events"
          activate
          display alert "${title}" message "${message}" buttons {"OK"} default button "OK"
        end tell
      `;

			exec(`osascript -e '${script}'`, (error, stdout, stderr) => {
				resolve(); // Always resolve, regardless of user action
			});
		});
	}

	// Screenshot functionality
	async showScreenshotDialog() {
		return new Promise((resolve, reject) => {
			const script = `
        tell application "System Events"
          activate
          set userChoice to button returned of (display dialog "Please choose screenshot type:" buttons {"Cancel", "Select Area", "Full Screen"} default button "Select Area")
          return userChoice
        end tell
      `;

			exec(`osascript -e '${script}'`, (error, stdout, stderr) => {
				if (error) {
					if (error.code === 1) {
						resolve(null); // User canceled
					} else {
						reject(new Error(`AppleScript error: ${error.message}`));
					}
				} else {
					resolve(stdout.trim());
				}
			});
		});
	}

	async takeScreenshot(type = "selection") {
		return new Promise((resolve, reject) => {
			// Generate temporary filename
			const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
			const filename = `screenshot-${timestamp}.png`;
			const filepath = path.join(require("os").tmpdir(), filename);

			let screencaptureCmd;
			if (type === "Full Screen") {
				// Full screen screenshot
				screencaptureCmd = `screencapture "${filepath}"`;
			} else {
				// Select area screenshot (default)
				screencaptureCmd = `screencapture -s "${filepath}"`;
			}

			console.error(`[Native MCP] Taking screenshot: ${screencaptureCmd}`);

			exec(screencaptureCmd, (error, stdout, stderr) => {
				if (error) {
					reject(new Error(`Screenshot failed: ${error.message}`));
				} else {
					// Check if file was created successfully
					if (fs.existsSync(filepath)) {
						resolve(filepath);
					} else {
						reject(new Error("Screenshot was cancelled by user"));
					}
				}
			});
		});
	}

	async handleCollectFeedback(args) {
		try {
			const workSummary = args.work_summary || "No work summary";

			// Collect user feedback (directly enter feedback collection, no longer show work summary popup)
			const feedback = await this.showNativeDialog(
				"Feedback Collection",
				`Please enter your feedback, suggestions, or comments:`,
				"",
			);

			if (feedback === null) {
				throw new Error("User cancelled feedback input");
			}

			// Ask if user wants to add an image
			const addImageScript = `
        tell application "System Events"
          activate
          set userChoice to button returned of (display dialog "Would you like to add an image?" buttons {"Skip", "Select Image", "Screenshot"} default button "Skip")
          return userChoice
        end tell
      `;

			return new Promise((resolve, reject) => {
				exec(
					`osascript -e '${addImageScript}'`,
					async (error, stdout, stderr) => {
						let imagePath = null;

						if (!error) {
							const choice = stdout.trim();

							if (choice === "Select Image") {
								try {
									imagePath = await this.showNativeFilePicker();
								} catch (imgError) {
									console.error(
										"[Native MCP] Image selection error:",
										imgError.message,
									);
								}
							} else if (choice === "Screenshot") {
								try {
									const screenshotType = await this.showScreenshotDialog();
									if (screenshotType && screenshotType !== "Cancel") {
										imagePath = await this.takeScreenshot(screenshotType);
									}
								} catch (screenshotError) {
									console.error(
										"[Native MCP] Screenshot error:",
										screenshotError.message,
									);
									await this.showNativeAlert(
										"Screenshot Failed",
										screenshotError.message,
									);
								}
							}
						}

						const result = {
							feedback: feedback,
							image_path: imagePath,
							timestamp: new Date().toISOString(),
							work_summary: workSummary,
						};

						resolve({
							content: [
								{
									type: "text",
									text: `User feedback collection completed:\n\n${JSON.stringify(result, null, 2)}`,
								},
							],
						});
					},
				);
			});
		} catch (error) {
			console.error(`[Native MCP] collect_feedback failed: ${error.message}`);
			throw new Error(`Collect feedback failed: ${error.message}`);
		}
	}

	async handlePickImage(args) {
		try {
			console.error(`[Native MCP] Handling pick_image with native file picker`);

			const selectedPath = await this.showNativeFilePicker();

			if (!selectedPath) {
				throw new Error("User cancelled image selection");
			}

			// Verify file exists and format
			if (!fs.existsSync(selectedPath)) {
				throw new Error(`Selected file does not exist: ${selectedPath}`);
			}

			const ext = path.extname(selectedPath).toLowerCase();
			const supportedFormats = [
				".jpg",
				".jpeg",
				".png",
				".gif",
				".bmp",
				".webp",
				".heic",
				".heif",
			];

			if (!supportedFormats.includes(ext)) {
				throw new Error(`Unsupported image format: ${ext}`);
			}

			// Read image information and content
			const dimensions = imageSize(selectedPath);
			const stats = fs.statSync(selectedPath);
			const imageBuffer = fs.readFileSync(selectedPath);
			const base64Image = imageBuffer.toString("base64");
			const mimeType = this.getMimeType(ext);

			const result = {
				selected_image_path: selectedPath,
				filename: path.basename(selectedPath),
				format: ext.substring(1),
				width: dimensions.width,
				height: dimensions.height,
				size_bytes: stats.size,
				size_kb: (stats.size / 1024).toFixed(2),
				timestamp: new Date().toISOString(),
			};

			return {
				content: [
					{
						type: "text",
						text: `Image selection completed:\n\n${JSON.stringify(result, null, 2)}`,
					},
					{
						type: "image",
						data: base64Image,
						mimeType: mimeType,
					},
				],
			};
		} catch (error) {
			console.error(`[Native MCP] pick_image failed: ${error.message}`);
			throw new Error(`Pick image failed: ${error.message}`);
		}
	}

	async handleGetImageInfo(args) {
		try {
			const { image_path } = args;

			if (!image_path) {
				throw new Error("image_path parameter is required");
			}

			if (!fs.existsSync(image_path)) {
				throw new Error(`File not found: ${image_path}`);
			}

			const dimensions = imageSize(image_path);
			const stats = fs.statSync(image_path);

			// Read image file and convert to base64
			const imageBuffer = fs.readFileSync(image_path);
			const base64Image = imageBuffer.toString("base64");
			const mimeType = this.getMimeType(path.extname(image_path).toLowerCase());

			const result = {
				filename: path.basename(image_path),
				format: path.extname(image_path).substring(1),
				width: dimensions.width,
				height: dimensions.height,
				size_bytes: stats.size,
				size_kb: (stats.size / 1024).toFixed(2),
				modified: stats.mtime.toISOString(),
				path: image_path,
			};

			return {
				content: [
					{
						type: "text",
						text: `Image information:\n\n${JSON.stringify(result, null, 2)}`,
					},
					{
						type: "image",
						data: base64Image,
						mimeType: mimeType,
					},
				],
			};
		} catch (error) {
			throw new Error(`Get image info failed: ${error.message}`);
		}
	}

	// Get MIME type based on file extension
	getMimeType(ext) {
		const mimeTypes = {
			".jpg": "image/jpeg",
			".jpeg": "image/jpeg",
			".png": "image/png",
			".gif": "image/gif",
			".bmp": "image/bmp",
			".webp": "image/webp",
			".heic": "image/heic",
			".heif": "image/heif",
		};
		return mimeTypes[ext] || "image/jpeg";
	}

	async handleTakeScreenshot(args) {
		try {
			console.error(`[Native MCP] Handling take_screenshot`);

			const screenshotType = await this.showScreenshotDialog();

			if (!screenshotType || screenshotType === "Cancel") {
				throw new Error("User cancelled screenshot");
			}

			const screenshotPath = await this.takeScreenshot(screenshotType);

			if (!screenshotPath) {
				throw new Error("Screenshot failed or was cancelled");
			}

			// Read screenshot information and content
			const dimensions = imageSize(screenshotPath);
			const stats = fs.statSync(screenshotPath);
			const imageBuffer = fs.readFileSync(screenshotPath);
			const base64Image = imageBuffer.toString("base64");
			const mimeType = "image/png"; // Screenshots are always PNG format

			const result = {
				screenshot_path: screenshotPath,
				filename: path.basename(screenshotPath),
				type: screenshotType,
				width: dimensions.width,
				height: dimensions.height,
				size_bytes: stats.size,
				size_kb: (stats.size / 1024).toFixed(2),
				timestamp: new Date().toISOString(),
			};

			// Delete temporary screenshot file before returning result
			try {
				if (fs.existsSync(screenshotPath)) {
					fs.unlinkSync(screenshotPath);
					console.error(
						`[Native MCP] Deleted temporary screenshot: ${screenshotPath}`,
					);
				}
			} catch (unlinkError) {
				console.error(
					`[Native MCP] Failed to delete temporary screenshot: ${unlinkError.message}`,
				);
			}

			return {
				content: [
					{
						type: "text",
						text: `Screenshot completed:\n\n${JSON.stringify(result, null, 2)}`,
					},
					{
						type: "image",
						data: base64Image,
						mimeType: mimeType,
					},
				],
			};
		} catch (error) {
			console.error(`[Native MCP] take_screenshot failed: ${error.message}`);
			throw new Error(`Take screenshot failed: ${error.message}`);
		}
	}
}

async function setupNativeMCPServer() {
	console.error(`[Native MCP] Setting up MCP server...`);

	const nativeServer = new NativeMCPServer();

	const server = new Server(
		{
			name: "interactive-feedback-macos-mcp",
			version: "1.0.2",
		},
		{
			capabilities: {
				tools: {},
			},
		},
	);

	// List available tools
	server.setRequestHandler(ListToolsRequestSchema, async () => {
		console.error(`[Native MCP] Listing tools`);
		return {
			tools: [
				{
					name: "collect_feedback",
					description:
						"Collects user feedback (text and/or images) via native macOS dialogs.",
					inputSchema: {
						type: "object",
						properties: {
							work_summary: {
								type: "string",
								description:
									"AI's summary of work completed. Displayed to the user.",
							},
						},
						required: [],
					},
				},
				{
					name: "pick_image",
					description:
						"Allows the user to select a single image via native macOS file picker.",
					inputSchema: {
						type: "object",
						properties: {
							random_string: {
								type: "string",
								description: "Dummy parameter for no-parameter tools",
							},
						},
						required: ["random_string"],
					},
				},
				{
					name: "get_image_info",
					description:
						"Retrieves information (dimensions, format, size) about a local image file.",
					inputSchema: {
						type: "object",
						properties: {
							image_path: {
								type: "string",
								description: "The absolute path to the local image file.",
							},
						},
						required: ["image_path"],
					},
				},
				{
					name: "take_screenshot",
					description:
						"Takes a screenshot of the screen and saves it to a file.",
					inputSchema: {
						type: "object",
						properties: {
							random_string: {
								type: "string",
								description: "Dummy parameter for no-parameter tools",
							},
						},
						required: ["random_string"],
					},
				},
			],
		};
	});

	// Handle tool calls
	server.setRequestHandler(CallToolRequestSchema, async (request) => {
		const { name, arguments: args } = request.params;

		console.error(
			`[Native MCP] Tool call: ${name} with args: ${JSON.stringify(args)}`,
		);

		try {
			switch (name) {
				case "collect_feedback":
					return await nativeServer.handleCollectFeedback(args);

				case "pick_image":
					return await nativeServer.handlePickImage(args);

				case "get_image_info":
					return await nativeServer.handleGetImageInfo(args);

				case "take_screenshot":
					return await nativeServer.handleTakeScreenshot(args);

				default:
					throw new Error(`Unknown tool: ${name}`);
			}
		} catch (error) {
			console.error(`[Native MCP] Tool ${name} failed: ${error.message}`);
			throw error;
		}
	});

	// Cleanup on exit
	const cleanup = () => {
		console.error("[Native MCP] Received exit signal, cleaning up...");
		process.exit(0);
	};

	process.on("SIGINT", cleanup);
	process.on("SIGTERM", cleanup);
	process.on("uncaughtException", (error) => {
		console.error("[Native MCP] Uncaught exception:", error);
		process.exit(1);
	});

	// Start the server
	try {
		const transport = new StdioServerTransport();
		await server.connect(transport);
		console.error(
			`[Native MCP] Server connected successfully. PID: ${process.pid}`,
		);
	} catch (error) {
		console.error(`[Native MCP] Failed to connect server: ${error.message}`);
		throw error;
	}
}

// Start the native MCP server
setupNativeMCPServer().catch((error) => {
	console.error("[Native MCP] Failed to start:", error);
	process.exit(1);
});

```