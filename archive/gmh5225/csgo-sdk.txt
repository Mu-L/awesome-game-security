Project Path: arc_gmh5225_csgo-sdk_7v3b1ca7

Source Tree:

```txt
arc_gmh5225_csgo-sdk_7v3b1ca7
├── README.md
├── core
│   ├── hooks
│   │   ├── hooks.cpp
│   │   └── hooks.hpp
│   ├── main.cpp
│   └── menu
│       ├── menu.cpp
│       ├── menu.hpp
│       └── zgui
│           ├── menu.cpp
│           ├── menu.hpp
│           ├── zgui.cpp
│           └── zgui.hpp
├── csgo-cheat.sln
├── csgo-cheat.vcxproj
├── csgo-cheat.vcxproj.user
├── dependencies
│   ├── common_includes.hpp
│   ├── interfaces
│   │   ├── cglobalvarsbase.hpp
│   │   ├── ibaseclientdll.hpp
│   │   ├── icliententitylist.hpp
│   │   ├── iclientmode.hpp
│   │   ├── iclientstate.hpp
│   │   ├── iconsole.hpp
│   │   ├── igameeventmanager.hpp
│   │   ├── iinput.hpp
│   │   ├── ilocalize.hpp
│   │   ├── imaterialsystem.hpp
│   │   ├── interfaces.cpp
│   │   ├── interfaces.hpp
│   │   ├── ipanel.hpp
│   │   ├── isurface.hpp
│   │   ├── ivdebugoverlay.hpp
│   │   ├── iveffects.hpp
│   │   ├── ivengineclient.hpp
│   │   ├── ivmodelinfo.hpp
│   │   └── ivmodelrender.hpp
│   └── utilities
│       ├── fnv.hpp
│       ├── hook.cpp
│       ├── hook.hpp
│       ├── netvars.cpp
│       ├── netvars.hpp
│       ├── render.cpp
│       ├── render.hpp
│       ├── utilities.cpp
│       └── utilities.hpp
└── source-sdk
    ├── classes
    │   ├── c_usercmd.hpp
    │   ├── client_class.hpp
    │   ├── collideable.hpp
    │   ├── convar.hpp
    │   ├── entities.hpp
    │   ├── gameevent.hpp
    │   ├── recv_props.hpp
    │   └── studio.hpp
    ├── math
    │   ├── vector2d.hpp
    │   ├── vector3d.cpp
    │   └── vector3d.hpp
    ├── misc
    │   └── color.hpp
    ├── sdk.hpp
    └── structs
        ├── dlight.hpp
        ├── materials.hpp
        ├── models.hpp
        ├── vertex_t.hpp
        └── weaponinfo.hpp

```

`README.md`:

```md
# sdk

___________________________________________
a clean sdk to start writing a cheat on
for csgo. this has everything you need for
a fully featured internal cheat.

___________________________________________
many of my close friends may know this as ayysense.
this was the initial sdk, without the menu, aimbot, esp, and everything else
that ayysense had.

credits to wzn, rifk/czapek, duxe.

apologies to rifk/czapek; i know that you didnt want this public, but at this point 
i know you don't care about it, and you no longer work on it. this is without the menu
that ayysense had, so it shouldn't be a big deal.

```

`core/hooks/hooks.cpp`:

```cpp
#pragma once
#include "..//menu/menu.hpp"
#include "../../dependencies/common_includes.hpp"
#include <algorithm>

std::unique_ptr<vmt_hook> hooks::client_hook;
std::unique_ptr<vmt_hook> hooks::clientmode_hook;
std::unique_ptr<vmt_hook> hooks::panel_hook;
std::unique_ptr<vmt_hook> hooks::renderview_hook;
WNDPROC hooks::wndproc_original = NULL;

void hooks::initialize( ) {
	client_hook = std::make_unique<vmt_hook>( );
	clientmode_hook = std::make_unique<vmt_hook>( );
	panel_hook = std::make_unique<vmt_hook>( );
	renderview_hook = std::make_unique<vmt_hook>( );

	client_hook->setup( interfaces::client );
	client_hook->hook_index( 37, reinterpret_cast< void* >( frame_stage_notify ) );

	clientmode_hook->setup( interfaces::clientmode );
	clientmode_hook->hook_index( 24, reinterpret_cast< void* >( create_move ) );

	panel_hook->setup( interfaces::panel );
	panel_hook->hook_index( 41, reinterpret_cast< void* >( paint_traverse ) );

	renderview_hook->setup( interfaces::render_view );
	renderview_hook->hook_index( 9, reinterpret_cast< void* >( scene_end ) );

	wndproc_original = reinterpret_cast< WNDPROC >( SetWindowLongPtrA( FindWindow( "Valve001", NULL ), GWL_WNDPROC, reinterpret_cast< LONG >( wndproc ) ) );

	interfaces::console->get_convar( "viewmodel_fov" )->callbacks.SetSize( 0 );
	interfaces::console->get_convar( "mat_postprocess_enable" )->set_value( 0 );
	interfaces::console->get_convar( "crosshair" )->set_value( 1 );

	render::setup_fonts( );

	zgui::functions.draw_line = render::line;
	zgui::functions.draw_rect = render::rect;
	zgui::functions.draw_filled_rect = render::filled_rect;
	zgui::functions.draw_text = render::text;
	zgui::functions.get_text_size = render::get_text_size;
	zgui::functions.get_frametime = render::get_frametime;
}

void hooks::shutdown( ) {
	client_hook->release( );
	clientmode_hook->release( );
	panel_hook->release( );
	renderview_hook->release( );

	SetWindowLongPtrA( FindWindow( "Valve001", NULL ), GWL_WNDPROC, reinterpret_cast< LONG >( wndproc_original ) );
}

bool __stdcall hooks::create_move( float frame_time, c_usercmd* user_cmd ) {
	static auto original_fn = reinterpret_cast< create_move_fn >( clientmode_hook->get_original( 24 ) )( interfaces::clientmode, frame_time, user_cmd );
	
	if ( !user_cmd || !user_cmd->command_number )
		return original_fn;

	if ( !interfaces::entity_list->get_client_entity( interfaces::engine->get_local_player( ) ) )
		return original_fn;

	return false;
}

void __stdcall hooks::frame_stage_notify( int frame_stage ) {
	reinterpret_cast< frame_stage_notify_fn >( client_hook->get_original( 37 ) )( interfaces::client, frame_stage );
}

void __stdcall hooks::paint_traverse( unsigned int panel, bool force_repaint, bool allow_force ) {
	std::string panel_name = interfaces::panel->get_panel_name( panel );

	reinterpret_cast< paint_traverse_fn >( panel_hook->get_original( 41 ) )( interfaces::panel, panel, force_repaint, allow_force );

	static unsigned int _panel = 0;
	static bool once = false;

	if ( !once ) {
		char* panel_char = ( char* )( interfaces::panel->get_panel_name( panel ) );
		if ( strstr( panel_char, "MatSystemTopPanel" ) ) {
			_panel = panel;
			once = true;
		}
	}
	else if ( _panel == panel ) {
		g_menu.render( );
	}
}

void __stdcall hooks::scene_end( ) {
	reinterpret_cast< scene_end_fn >( renderview_hook->get_original( 9 ) )( interfaces::render_view );
}

LRESULT __stdcall hooks::wndproc( HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam ) {
	return CallWindowProcA( wndproc_original, hwnd, message, wparam, lparam );
}

```

`core/hooks/hooks.hpp`:

```hpp
#pragma once

namespace hooks {
	extern std::unique_ptr<vmt_hook> client_hook;
	extern std::unique_ptr<vmt_hook> clientmode_hook;
	extern std::unique_ptr<vmt_hook> panel_hook;
	extern std::unique_ptr<vmt_hook> renderview_hook;
	extern WNDPROC wndproc_original;

	void initialize( );
	void shutdown( );

	using create_move_fn = bool( __thiscall* )( i_client_mode*, float, c_usercmd* );
	using frame_stage_notify_fn = void( __thiscall* )( i_base_client_dll*, int );
	using paint_traverse_fn = void( __thiscall* )( i_panel*, unsigned int, bool, bool );
	using scene_end_fn = void( __thiscall* )( void* );

	bool __stdcall create_move( float frame_time, c_usercmd* user_cmd );
	void __stdcall frame_stage_notify( int frame_stage );
	void __stdcall paint_traverse( unsigned int panel, bool force_repaint, bool allow_force );
	void __stdcall scene_end( );
	LRESULT __stdcall wndproc( HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam );
}
```

`core/main.cpp`:

```cpp
#include "../dependencies/common_includes.hpp"

unsigned long __stdcall initial_thread( void* reserved ) {

	AllocConsole( );
	SetConsoleTitleW( L"Counter-Strike: Global Offensive" );
	freopen_s( reinterpret_cast< FILE** >stdin, "CONIN$", "r", stdin );
	freopen_s( reinterpret_cast< FILE** >stdout, "CONOUT$", "w", stdout );

	interfaces::initialize( );

	g_netvar_mgr.initialize( interfaces::client->get_client_classes( ) );

	hooks::initialize( );

	while ( !GetAsyncKeyState( VK_END ) )
		std::this_thread::sleep_for( std::chrono::milliseconds( 50 ) );

	hooks::shutdown( );
	std::this_thread::sleep_for( std::chrono::milliseconds( 100 ) );

	FreeLibraryAndExitThread( reinterpret_cast< HMODULE >( reserved ), 0 );
	return 0ul;
}

bool __stdcall DllMain( void* instance, unsigned long reason_to_call, void* reserved ) {
	if ( reason_to_call == DLL_PROCESS_ATTACH ) {
		CreateThread( 0, 0, initial_thread, instance, 0, 0 );
	}

	return true;
}

```

`core/menu/menu.cpp`:

```cpp
#include "menu.hpp"

c_menu g_menu;

void c_menu::render( ) {
	static bool checkbox;
	static float sliderf;
	static int slideri, dropdown;

	zgui::poll_input( "Counter-Strike: Global Offensive" );

	if ( zgui::begin_window( "sdk for counter-strike: global offensive", { 500, 350 }, render::main_font ) ) {
		zgui::begin_groupbox( "Example groupbox", { 468, 311 } );
		{
			zgui::checkbox( "Example checkbox", checkbox );
			zgui::slider_float( "Example slider (float)", 0.0f, 100.0f, sliderf );
			zgui::slider_int( "Example slider (int)", 0, 100, slideri );
			zgui::combobox( "Example dropdown", { "aaaa", "bbbb", "cccc", "dddd" }, dropdown );
		}
		zgui::end_groupbox( );

		zgui::end_window( );
	}
}
```

`core/menu/menu.hpp`:

```hpp
#include "..//..//dependencies/common_includes.hpp"
#include "zgui/zgui.hpp"

class c_menu {
public:
	void render( );
};

extern c_menu g_menu;
```

`core/menu/zgui/menu.cpp`:

```cpp
#include <algorithm>
#include <iomanip>
#include <sstream>
#include <cctype>
#include <Windows.h>

#include "zgui.hpp"

// zgui by zxvnme (https://github.com/zxvnme)
// heres defines that are designed to be modified by your preferences.
// see zgui.hh for complete documentation.
// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Color definition. Can be changed at any time just simply by editing this struct.
static struct {
	zgui::color window_border_inner_fill{ 60, 60, 60, 255 };
	zgui::color window_border_fill{ 40, 40, 40, 255 };
	zgui::color window_border_color{ 10, 10, 10, 255 };
	zgui::color window_background{ 40, 40, 40, 255 };

	zgui::color control_outline{ 23, 23, 30, 255 };
	zgui::color control_active_or_clicked{ 108, 92, 231, 255 };
	zgui::color control_idle{ 62, 62, 72, 255 };

	zgui::color color_groupbox_bg{ 50, 50, 50, 255 };
	zgui::color color_text{ 203, 203, 203, 255 };
	zgui::color color_text_dimmer{ 99, 110, 114, 255 };
	zgui::color color_slider{ 108, 92, 231, 255 };
	zgui::color color_combo_bg{ 108, 92, 231, 255 };
} global_colors;

static struct {
	// Base position of first drawn control (px). DO NOT change if its necessary
	zgui::vec2 base_pos{ 16, 23 };
	// Spacing between items (px)
	int item_spacing = 16;
	// Key that will toggle menu visibility unless zgui_window_flags_always_open is set
	int menu_toggle_key = VK_INSERT;
} global_config;

// Window definitions.
static struct gui_context_t {
	zgui::gui_window_context_t window;
} context;

// "Proxy" functions stuff...
zgui::functions_t zgui::functions;

// Globals
static zgui::vec2 mouse_pos;
static zgui::vec2 previous_mouse_pos;

// Input handling stuff
static bool key_state[256];
static bool prev_key_state[256];

// Check for input polling.
static bool input_loop_started = false;

// Function for starting our input loop.
void zgui::poll_input(std::string_view window_name)
{
	if (window_name.empty())
		throw std::exception("No window from where input should be read from specified in function parameter.");

	for (int i = 0; i < 256; i++) {
		prev_key_state[i] = key_state[i];
		key_state[i] = GetAsyncKeyState(i);
	}

	POINT p_mouse_pos;
	GetCursorPos(&p_mouse_pos);
	ScreenToClient(FindWindow(nullptr, window_name.data()), &p_mouse_pos);
	previous_mouse_pos = mouse_pos;
	mouse_pos = vec2{ static_cast<float>(p_mouse_pos.x), static_cast<float>(p_mouse_pos.y) };

	if (!input_loop_started)
		input_loop_started = true;
}

// Function for starting our input loop.
void zgui::poll_input(HWND hwnd)
{
	if (!hwnd)
		throw std::exception("No window from where input should be read from specified in function parameter.");

	for (int i = 0; i < 256; i++) {
		prev_key_state[i] = key_state[i];
		key_state[i] = GetAsyncKeyState(i);
	}

	POINT p_mouse_pos;
	GetCursorPos(&p_mouse_pos);
	ScreenToClient(hwnd, &p_mouse_pos);
	previous_mouse_pos = mouse_pos;
	mouse_pos = vec2{ static_cast<float>(p_mouse_pos.x), static_cast<float>(p_mouse_pos.y) };

	if (!input_loop_started)
		input_loop_started = true;
}

// Input utilities.
constexpr bool key_pressed(const int key) noexcept
{
	return key_state[key] && !prev_key_state[key];
}

constexpr bool key_down(const int key) noexcept
{
	return key_state[key];
}

constexpr bool key_released(const int key) noexcept
{
	return !key_state[key] && prev_key_state[key];
}

// Check if mouse is hovered over specified region.
bool mouse_in_region(const int x, const int y, const int w, const int h) noexcept
{
	return mouse_pos.x > x && mouse_pos.y > y && mouse_pos.x < w + x && mouse_pos.y < h + y;
}

// Push cursor position to the stack
void zgui::push_cursor_pos(const vec2 pos) noexcept
{
	context.window.cursor_pos.push(pos);
}

// Pop cursor position from the stack
zgui::vec2 zgui::pop_cursor_pos() noexcept
{
	const vec2 pos = context.window.cursor_pos.top();
	context.window.cursor_pos.pop();
	return pos;
}

void zgui::push_font(const unsigned long font) noexcept
{
	context.window.fonts.push(font);
}

unsigned long zgui::pop_font()
{
	const unsigned long font = context.window.fonts.top();
	context.window.fonts.pop();
	return font;
}

// Hashing util
std::vector<std::string> split_str(const char* str, const char separator) noexcept
{
	std::vector<std::string> output;
	std::string substring;
	std::istringstream stream{ str };

	while (std::getline(stream, substring, separator))
		output.push_back(substring);

	return output;
}

static constexpr uint32_t hash(const char* str, const uint32_t value = 0x811c9dc5) noexcept
{
	return *str ? hash(str + 1, (value ^ *str) * 0x1000193ull) : value;
}

// Names for each of VKs
constexpr std::string_view keys_list[]{
"Error", "Left Mouse", "Right Mouse", "Break", "Middle Mouse", "Mouse 4", "Mouse 5",
"Error", "Backspace", "TAB", "Error", "Error", "Error", "ENTER", "Error", "Error", "SHIFT",
"CTRL", "ALT","PAUSE","CAPS LOCK", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error", "Error", "Error", "Error", "SPACEBAR","PG UP", "PG DOWN", "END", "HOME", "Left",
"Up", "Right", "Down", "Error", "Print", "Error", "Print Screen", "Insert","Delete", "Error", "0", "1",
"2", "3", "4", "5", "6", "7", "8", "9", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U",
"V", "W", "X","Y", "Z", "Left Windows", "Right Windows", "Error", "Error", "Error", "NUM 0", "NUM 1",
"NUM 2", "NUM 3", "NUM 4", "NUM 5", "NUM 6","NUM 7", "NUM 8", "NUM 9", "*", "+", "_", "-", ".", "/", "F1", "F2", "F3",
"F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12","F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21",
"F22", "F23", "F24", "Error", "Error", "Error", "Error", "Error","Error", "Error", "Error",
"NUM LOCK", "SCROLL LOCK", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error","Error", "Error", "Error", "Error", "Error", "LSHIFT", "RSHIFT", "LCONTROL",
"RCONTROL", "LMENU", "RMENU", "Error","Error", "Error","Error", "Error", "Error", "Error",
"Error", "Error", "Error", "Next Track", "Previous Track", "Stop", "Play/Pause", "Error", "Error",
"Error", "Error", "Error", "Error", ";", "+", ",", "-", ".", "/?", "~", "Error", "Error",
"Error", "Error","Error", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error","Error",
"Error", "Error", "Error", "Error", "Error", "Error", "[{", "\\|", "}]", "'\"", "Error",
"Error", "Error", "Error","Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error"
};

struct key_code_info {
	int vk;

	char regular;
	char shift;
};

static key_code_info special_characters[22] = {
	{ 48,  '0',  ')' },
	{ 49,  '1',  '!' },
	{ 50,  '2',  '@' },
	{ 51,  '3',  '#' },
	{ 52,  '4',  '$' },
	{ 53,  '5',  '%' },
	{ 54,  '6',  '^' },
	{ 55,  '7',  '&' },
	{ 56,  '8',  '*' },
	{ 57,  '9',  '(' },
	{ 32,  ' ',  ' ' },
	{ 192, '`',  '~' },
	{ 189, '-',  '_' },
	{ 187, '=',  '+' },
	{ 219, '[',  '{' },
	{ 220, '\\', '|' },
	{ 221, ']',  '}' },
	{ 186, ';',  ':' },
	{ 222, '\'', '"' },
	{ 188, ',',  '<' },
	{ 190, '.',  '>' },
	{ 191, '/',  '?' }
};

bool zgui::begin_window(std::string_view title, const vec2 default_size, const unsigned long font, const int flags)
{
	if (!input_loop_started)
		throw std::exception("Input loop didnt start or didnt start properly.");;

	if (!(flags & zgui_window_flags_always_open))
	{
		if (key_pressed(global_config.menu_toggle_key))
			context.window.opened = !context.window.opened;
	}
	else
		context.window.opened = true;

	if (const int prev_alpha = context.window.alpha; !(flags & zgui_window_flags_no_ontoggle_animation))
	{
		const int fade_factor = static_cast<int>(1.0f / 0.15f * functions.get_frametime() * 255);
		context.window.alpha = std::clamp(context.window.alpha + (context.window.opened ? fade_factor : -fade_factor), 0, 255);

		if (context.window.alpha != prev_alpha)
		{
			global_colors.window_border_inner_fill.a = context.window.alpha;
			global_colors.window_border_fill.a = context.window.alpha;
			global_colors.window_border_color.a = context.window.alpha;
			global_colors.window_background.a = context.window.alpha;

			global_colors.control_outline.a = context.window.alpha;
			global_colors.control_active_or_clicked.a = context.window.alpha;
			global_colors.control_idle.a = context.window.alpha;

			global_colors.color_groupbox_bg.a = context.window.alpha;
			global_colors.color_text.a = context.window.alpha;
			global_colors.color_text_dimmer.a = context.window.alpha;
			global_colors.color_slider.a = context.window.alpha;
		}
	}

	if (context.window.opened || context.window.alpha > 0)
	{
		if (!(flags & zgui_window_flags_no_move))
		{
			if ((flags & zgui_window_flags_no_border ? mouse_in_region(context.window.position.x + 9, context.window.position.y + 14, context.window.size.x - 18, 14)
				: mouse_in_region(context.window.position.x - 6, context.window.position.y - 10, context.window.size.x + 12, 16))
				&& key_pressed(VK_LBUTTON) && !context.window.dragging)
			{
				context.window.dragging = true;
			}
			else if (key_down(VK_LBUTTON) && context.window.dragging)
			{
				const vec2 mouse_delta{ mouse_pos.x - previous_mouse_pos.x, mouse_pos.y - previous_mouse_pos.y };
				const vec2 new_position{ context.window.position.x + mouse_delta.x, context.window.position.y + mouse_delta.y };

				context.window.position = new_position;
			}
			else if (!key_down(VK_LBUTTON) && context.window.dragging)
			{
				context.window.dragging = false;
			}
		}

		if (context.window.size.x < 1 && context.window.size.y < 1)
			context.window.size = default_size;

		if (!(flags & zgui_window_flags_no_border))
		{
			functions.draw_filled_rect(context.window.position.x - 6, context.window.position.y - 10, context.window.size.x + 12, context.window.size.y + 16, global_colors.window_border_inner_fill);
			functions.draw_filled_rect(context.window.position.x - 5, context.window.position.y - 9, context.window.size.x + 10, context.window.size.y + 14, global_colors.window_border_color);
			functions.draw_filled_rect(context.window.position.x - 4, context.window.position.y - 8, context.window.size.x + 8, context.window.size.y + 12, global_colors.window_border_fill);
			functions.draw_filled_rect(context.window.position.x, context.window.position.y + 7, context.window.size.x, context.window.size.y - 7, global_colors.window_border_color);
			functions.draw_filled_rect(context.window.position.x + 1, context.window.position.y + 8, context.window.size.x - 2, context.window.size.y - 9, global_colors.window_border_inner_fill);
			functions.draw_filled_rect(context.window.position.x + 8, context.window.position.y + 15, context.window.size.x - 16, context.window.size.y - 23, global_colors.window_border_color);
		}

		if (!(flags & zgui_window_flags_no_titlebar))
			functions.draw_text(context.window.position.x + context.window.size.x * 0.5, context.window.position.y + (context.window.size.y * 0.010) - 10, global_colors.color_text, font, true, title.data());

		functions.draw_filled_rect(context.window.position.x + 9, context.window.position.y + 16, context.window.size.x - 18, context.window.size.y - 25, global_colors.window_background);


		push_font(font);
		push_cursor_pos(global_config.base_pos);
	}

	return context.window.opened || context.window.alpha > 0;
}

void zgui::end_window() noexcept
{
	for (int i = context.window.render.size() - 1; i >= 0; i--)
	{
		switch (context.window.render[i].render_type)
		{
		case zgui_render_type::zgui_line:
			functions.draw_line(context.window.render[i].draw_position.x, context.window.render[i].draw_position.y, context.window.render[i].size.x, context.window.render[i].size.y, context.window.render[i].color);
			break;
		case zgui_render_type::zgui_rect:
			functions.draw_rect(context.window.render[i].draw_position.x, context.window.render[i].draw_position.y, context.window.render[i].size.x, context.window.render[i].size.y, context.window.render[i].color);
			break;
		case zgui_render_type::zgui_filled_rect:
			functions.draw_filled_rect(context.window.render[i].draw_position.x, context.window.render[i].draw_position.y, context.window.render[i].size.x, context.window.render[i].size.y, context.window.render[i].color);
			break;
		case zgui_render_type::zgui_text:
			functions.draw_text(context.window.render[i].draw_position.x, context.window.render[i].draw_position.y, context.window.render[i].color, context.window.render[i].font, false, context.window.render[i].text.c_str());
			break;
		}
	}

	context.window.render.clear();

	while (!context.window.cursor_pos.empty())
		context.window.cursor_pos.pop();

}

void zgui::begin_groupbox(std::string_view title, const vec2 size, const int flags) noexcept
{
	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	functions.draw_rect(draw_pos.x - 1, draw_pos.y - 1, size.x + 2, size.y + 2, global_colors.control_outline);
	functions.draw_filled_rect(draw_pos.x, draw_pos.y, size.x, size.y, global_colors.color_groupbox_bg);

	if (title.length() > 0)
	{
		if (!(flags & zgui_groupbox_flags_title_centered))
		{
			functions.draw_text(draw_pos.x + 4, draw_pos.y - 8, global_colors.color_text, font, false, title.data());
		}
		else
		{
			int text_wide, text_tall;
			functions.get_text_size(font, title.data(), text_wide, text_tall);
			functions.draw_text(draw_pos.x + size.x / 2 - text_wide / 2, draw_pos.y - 8, global_colors.color_text, font, false, title.data());
		}
	}

	context.window.next_cursor_pos = vec2{ cursor_pos.x, cursor_pos.y + size.y + 10 };

	push_cursor_pos(vec2{ cursor_pos.x + 8, cursor_pos.y + 14 });

	push_font(font);
}

void zgui::end_groupbox() noexcept
{
	push_cursor_pos(context.window.next_cursor_pos);
	context.window.next_cursor_pos = { };
}

void zgui::checkbox(const char* id, bool& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_height = 8;
	const int control_width = 8;

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	int text_wide, text_tall;
	functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

	const bool active = context.window.blocking == hash(id);

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width + 6 + text_wide, control_height); !active && hovered && key_pressed(VK_LBUTTON))
	{
		context.window.blocking = hash(id);
	}
	else if (active && !key_down(VK_LBUTTON))
	{
		context.window.blocking = 0;
		value = !value;
	}

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 14, draw_pos.y - 2 }, zgui_render_type::zgui_text, value ? global_colors.color_text : global_colors.color_text_dimmer, id_split[0], vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect,  value ? global_colors.control_active_or_clicked : global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline,"", { control_width, control_height } });

	push_cursor_pos(vec2{ cursor_pos.x + 14 + text_wide + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + global_config.item_spacing });

	push_font(font);
}

void zgui::toggle_button(const char* id, const vec2 size, bool& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	const bool active = context.window.blocking == hash(id);

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, size.x, size.y); !active && hovered && key_pressed(VK_LBUTTON))
	{
		context.window.blocking = hash(id);
	}
	else if (active && !key_down(VK_LBUTTON))
	{
		context.window.blocking = 0;
		value = !value;
	}

	int text_wide, text_tall;
	functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + size.x / 2 - text_wide / 2, draw_pos.y + size.y / 2 - text_tall / 2 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect,  value ? global_colors.control_active_or_clicked : global_colors.control_idle, "", size });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { size.x + 2, size.y + 2 } });

	push_cursor_pos(vec2{ cursor_pos.x + size.x + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + size.y / 2 + global_config.item_spacing });

	push_font(font);
}

bool zgui::button(const char* id, const vec2 size) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	const bool active = context.window.blocking == hash(id);

	bool result = false;
	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, size.x, size.y); !active && hovered && key_pressed(VK_LBUTTON))
	{
		context.window.blocking = hash(id);
	}
	else if (active && !key_down(VK_LBUTTON))
	{
		context.window.blocking = 0;
		result = hovered;
	}

	int text_wide, text_tall;
	functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + size.x / 2 - text_wide / 2, draw_pos.y + size.y / 2 - text_tall / 2 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect,  active ? global_colors.control_active_or_clicked : global_colors.control_idle, "", {size.x - 2, size.y - 2} });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", size });

	push_cursor_pos(vec2{ cursor_pos.x + size.x + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + size.y / 2 + global_config.item_spacing });

	push_font(font);

	return result;
}

void zgui::key_bind(const char* id, int& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 80;
	const int control_height = 20;

	value = std::clamp(value, 0, 255);

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	const bool active = context.window.blocking == hash(id);

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}
	else if (active)
	{
		for (int i = 0; i < 256; i++)
		{
			if (key_pressed(i))
			{
				if (keys_list[i] != "Error")
					value = i;

				context.window.blocking = 0;
			}
		}
	}

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + 4 }, zgui_render_type::zgui_text, global_colors.color_text, active ? "Press any key" : keys_list[value].data(), vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect,  active ? global_colors.control_active_or_clicked : global_colors.control_idle, "", { control_width, control_height } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline,"", { control_width + 2, control_height + 2 } });

	push_cursor_pos(vec2{ cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });

	push_font(font);
}

void zgui::text_input(const char* id, std::string& value, const int max_length, const int flags) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 80;
	const int control_height = 20;

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	const bool active = context.window.blocking == hash(id);
	const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height);

	if (hovered && key_pressed(VK_LBUTTON) && !active)
	{
		context.window.blocking = hash(id);
	}
	else if (active)
	{
		if (key_pressed(VK_ESCAPE) || key_pressed(VK_RETURN) || (!hovered && key_pressed(VK_LBUTTON)))
		{
			context.window.blocking = 0;
		}
		else if (key_pressed(VK_BACK) && !value.empty())
		{
			value.pop_back();
		}
		else if (value.length() < max_length)
		{
			for (int i = 32; i <= 222; i++)
			{
				if ((i > 32 && i < 48) || (i > 57 && i < 65) || (i > 90 && i < 186))
					continue;

				if (i > 57 && i <= 90)
				{
					if (key_pressed(i))
						value += key_down(VK_SHIFT) ? static_cast<char>(i) : static_cast<char>(i + 32);
				}
				else
				{
					if (key_pressed(i))
					{
						for (int j = 0; j < sizeof(special_characters); j++)
						{
							if (special_characters[j].vk == i)
								value += key_down(VK_SHIFT) ? special_characters[j].shift : special_characters[j].regular;
						}
					}
				}
			}
		}
	}

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + 4 }, zgui_render_type::zgui_text,  global_colors.color_text, flags & zgui_text_input_flags_password ? std::string(value.length(), '*').c_str() : value.c_str(), vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect,  active ? global_colors.control_active_or_clicked : global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline,"", { control_width, control_height } });

	push_cursor_pos(vec2{ cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });

	push_font(font);
}

void zgui::slider_int(const char* id, const int min, const int max, int& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int font = pop_font();

	const int control_width = 120;
	const int control_height = 10;

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	if (context.window.blocking == 0 && mouse_in_region(draw_pos.x - (control_height - 2), draw_pos.y, 8, 10) && key_pressed(VK_LBUTTON))
		value = std::clamp(value - 1, min, max);
	else if (context.window.blocking == 0 && mouse_in_region(draw_pos.x + control_width, draw_pos.y, 8, 10) && key_pressed(VK_LBUTTON))
		value = std::clamp(value + 1, min, max);

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}
	else if (key_down(VK_LBUTTON) && context.window.blocking == hash(id))
	{
		float value_unmapped = std::clamp(mouse_pos.x - draw_pos.x, 0.0f, static_cast<float>(control_width));
		int value_mapped = static_cast<int>(value_unmapped / control_width * (max - min) + min);

		value = value_mapped;
	}
	else if (!key_down(VK_LBUTTON) && context.window.blocking == hash(id))
	{
		context.window.blocking = 0;
	}

	const int dynamic_width = (static_cast<float>(value) - min) / (max - min) * control_width - 2;

	int text_wide, text_tall;
	std::string value_str = std::to_string(value);
	functions.get_text_size(font, value_str.c_str(), text_wide, text_tall);

	int text_x = dynamic_width - text_wide;

	if (text_x < 0)
		text_x = 0;

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x - (control_height - 2), draw_pos.y - 2 }, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "-", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + (control_width + 4), draw_pos.y - 2 }, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "+", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + text_x, draw_pos.y }, zgui_render_type::zgui_text, global_colors.color_text, value_str, vec2{0,0}, font });

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect, global_colors.color_slider, "", { static_cast<float>(dynamic_width), control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, global_colors.control_idle,"", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline,"", { control_width, control_height } });


	push_cursor_pos(vec2{ cursor_pos.x + control_width + 14 + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });

	push_font(font);
}

void zgui::slider_float(const char* id, const float min, const float max, float& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 120;
	const int control_height = 10;

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	if (context.window.blocking == 0 && mouse_in_region(draw_pos.x - (control_height - 2), draw_pos.y, 8, 10) && key_pressed(VK_LBUTTON))
		value = std::clamp(value - 1, min, max);
	else if (context.window.blocking == 0 && mouse_in_region(draw_pos.x + control_width, draw_pos.y, 8, 10) && key_pressed(VK_LBUTTON))
		value = std::clamp(value + 1, min, max);

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}
	else if (key_down(VK_LBUTTON) && context.window.blocking == hash(id))
	{
		float value_unmapped = std::clamp(mouse_pos.x - draw_pos.x, 0.0f, static_cast<float>(control_width));
		float value_mapped = static_cast<float>((value_unmapped / static_cast<float>(control_width)) * (max - min) + min);

		value = value_mapped;
	}
	else if (!key_down(VK_LBUTTON) && context.window.blocking == hash(id))
	{
		context.window.blocking = 0;
	}

	const float dynamic_width = (static_cast<float>(value) - min) / (max - min) * control_width - 2;

	int text_wide, text_tall;
	std::stringstream ss;
	ss << std::fixed << std::setprecision(2) << value;
	std::string value_str = ss.str();
	functions.get_text_size(font, value_str.c_str(), text_wide, text_tall);

	int text_x = dynamic_width - text_wide;

	if (text_x < 0)
		text_x = 0;

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x - (control_height - 2), draw_pos.y - 2 }, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "-", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + (control_width + 4), draw_pos.y - 2 }, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "+", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + text_x, draw_pos.y }, zgui_render_type::zgui_text, global_colors.color_text, value_str, vec2{0,0}, font });

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect, global_colors.color_slider, "", { dynamic_width,  control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ {draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, global_colors.control_idle,"", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline,"", { control_width, control_height } });


	push_cursor_pos(vec2{ cursor_pos.x + control_width + 14 + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });

	push_font(font);
}

void zgui::combobox(const char* id, std::vector<std::string>items, int& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 70;
	const int control_height = 20;

	value = std::clamp(value, 0, static_cast<int>(items.size()) - 1);

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;

		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + control_width - 10, draw_pos.y + 4 }, zgui_render_type::zgui_text, global_colors.color_text,  "+", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + 4 }, zgui_render_type::zgui_text, global_colors.color_text,  items.at(value), vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect, global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x,  draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { control_width,  control_height } });

	push_cursor_pos(vec2{ cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });


	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}
	else if (context.window.blocking == hash(id))
	{
		for (int i = 1; i <= items.size(); i++)
		{
			bool hovered = mouse_in_region(draw_pos.x, draw_pos.y + (control_height - 1) * i, control_width, control_height);

			if (hovered && key_pressed(VK_LBUTTON))
			{
				context.window.blocking = 0;
				value = i - 1;
			}

			if (!hovered && key_pressed(VK_LBUTTON))
			{
				context.window.blocking = 0;
			}

			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + (control_height - 1) * i + 4 }, zgui_render_type::zgui_text, global_colors.color_text, items.at(i - 1), vec2{0,0}, font });
			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + (19 * i) + 1 }, zgui_render_type::zgui_filled_rect, hovered ? global_colors.color_combo_bg : global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y + 19 * i }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { control_width, control_height } });
		}
	}

	push_font(font);
}

void zgui::multi_combobox(const char* id, std::vector<multi_select_item> items) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 100;
	const int control_height = 20;

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	std::string value_str;
	int text_wide, text_tall;

	for (auto& item_t : items) {
		if (*item_t.value) {
			if (value_str.length() > 0)
				value_str += ", ";

			value_str += item_t.name;
		}
	}

	functions.get_text_size(font, value_str.c_str(), text_wide, text_tall);
	if (text_wide > control_width - 18)
	{
		value_str.resize(control_width / 10);
		value_str += " ...";
	}
	if (!value_str.length())
		value_str += "None";

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + control_width - 10, draw_pos.y + 4 }, zgui_render_type::zgui_text, global_colors.color_text,  "+", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + 4 }, zgui_render_type::zgui_text, global_colors.color_text,  value_str, vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect, global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x,  draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { control_width,  control_height } });

	push_cursor_pos(vec2{ cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });


	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}
	else if (context.window.blocking == hash(id))
	{
		for (int i = 1; i <= items.size(); i++)
		{
			bool hovered = mouse_in_region(draw_pos.x, draw_pos.y + (control_height - 1) * i, control_width, control_height);

			if (hovered && key_pressed(VK_LBUTTON))
			{
				context.window.blocking = 0;
				*items[i - 1].value = !*items[i - 1].value;
			}
			if (!hovered && key_pressed(VK_LBUTTON))
			{
				context.window.blocking = 0;
			}

			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + (control_height - 1) * i + 4 }, zgui_render_type::zgui_text, global_colors.color_text, items[i - 1].name.data(), vec2{0,0}, font });
			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + (19 * i) + 1 }, zgui_render_type::zgui_filled_rect, hovered ? global_colors.color_combo_bg : global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y + 19 * i }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { control_width, control_height } });
		}
	}

	push_font(font);
}

void zgui::listbox(const char* id, std::vector<multi_select_item> items) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 100;
	const int control_height = 20;

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	for (int i = 1; i <= items.size(); i++)
	{
		const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y + (control_height - 1) * (i - 1), control_width, control_height);

		if (hovered && key_pressed(VK_LBUTTON))
		{
			context.window.blocking = 0;
			*items[i - 1].value = !*items[i - 1].value;
		}
		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + (control_height - 1) * (i - 1) + 4}, zgui_render_type::zgui_text, *items[i - 1].value || hovered ? global_colors.control_active_or_clicked : global_colors.color_text, items[i - 1].name.data(), vec2{0,0}, font });
	}


	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect, global_colors.control_idle, "", { control_width - 2, static_cast<float>(control_height * items.size() - 2) } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x,  draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { control_width, static_cast<float>(control_height * items.size()) } });

	push_cursor_pos(vec2{ cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) + control_height * (items.size() - 1) });

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}

	push_font(font);
}

bool zgui::clickable_text(const char* id) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	int text_width, text_tall;
	functions.get_text_size(font, id_split[0].c_str(), text_width, text_tall);

	const bool active = context.window.blocking == hash(id);
	const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, text_width, text_tall);

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y}, zgui_render_type::zgui_text, (hovered || context.window.blocking == hash(id)) ? global_colors.control_active_or_clicked : global_colors.color_text, id_split[0], vec2{0,0}, font });

	push_cursor_pos(vec2{ cursor_pos.x + text_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + text_tall / 2 + global_config.item_spacing });

	bool result = false;

	if (!active && hovered && key_pressed(VK_LBUTTON))
	{
		context.window.blocking = hash(id);
	}
	else if (active && !key_down(VK_LBUTTON))
	{
		context.window.blocking = 0;
		result = hovered;
	}

	push_font(font);

	return result;
}

void zgui::text(const char* text) noexcept
{
	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	int text_width, text_tall;
	functions.get_text_size(font, text, text_width, text_tall);

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_text, global_colors.color_text, text, vec2{0,0}, font });

	push_cursor_pos(vec2{ cursor_pos.x + text_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + text_tall / 2 + global_config.item_spacing });

	push_font(font);
}

void zgui::dummy() noexcept
{
	const vec2 cursor_pos = pop_cursor_pos();
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + global_config.item_spacing });
}

void zgui::next_column(const int pusher_x, const int pusher_y) noexcept
{
	const vec2 cursor_pos = pop_cursor_pos();
	vec2 new_cursor_pos{ cursor_pos.x + pusher_x, global_config.base_pos.y + pusher_y };

	if (context.window.next_cursor_pos.y != 0)
		new_cursor_pos.y += 14;

	push_cursor_pos(new_cursor_pos);
}

void zgui::same_line(const float x_axis) noexcept
{
	const vec2 cursor_pos = pop_cursor_pos();

	if (x_axis != -1)
		push_cursor_pos(vec2{ global_config.base_pos.x + x_axis, cursor_pos.x });
}

void zgui::backup_line() noexcept
{
	const vec2 cursor_pos = pop_cursor_pos();

	push_cursor_pos(vec2{ context.window.next_cursor_pos.x, cursor_pos.y });
}
```

`core/menu/zgui/menu.hpp`:

```hpp
#pragma once
#include "../../../dependencies/utilities/render.hpp"

#pragma once

#include <cstdint>
#include <stack>
#include <vector>
#include <string>
#include <string_view>
#include <type_traits>


#define ZGUI_API __declspec(dllexport)

// zgui by zxvnme (https://github.com/zxvnme) and all the community contributors
#define ZGUI_VER "1.4.8" // the number after second dot is snapshot version.
/* =============================[general]===============================
 *
 * zgui is an simple framework created to help people with GUI rendering during their game hacking (but not only) journey.
 * here is glance zgui feature presentation:
 *	- easy to use immediate mode rendering (all you need is to include zgui header and source files to your project).
 *	- simple and aesthetic design.
 *	- extensible code.
 *	... and function documentation in section below:
 *
 *    ================================[pseudo documentation]=====================================
 *
 *    get_functions()
 *      -- function that is used to get our wrapped ones.
 *
 *    begin_window(std::string_view title, vec2 default_size, unsigned long font, int flags);
 *    end_window();
 *      -- functions used to create and end window.
 *
 *    begin_groupbox(std::string_view name, vec2 size);
 *    end_groupbox();
 *      -- functions uses to create our groupbox with desired size and end it.
 *
 *    slider_int(std::string_view id, int min, int max, int* value);
 *    slider_float(std::string_view id, float min, float max, float* value);
 *      -- functions used to create sliders with value type described in function name.
 *
 *    combobox(std::string_view id, std::vector<std::string> items, int* value);
 *    multi_combobox(std::string id, std::vector<multi_select_item> items)
 *      -- functions used for creating combo boxes.
 *
 *    checkbox(std::string_view id, bool* value);
 *      -- function that creates checkbox.
 *
 *    toggle_button(std::string_view id, vec2 size, bool* value);
 *      -- function that creates toggle button.
 *
 *    button(std::string_view id, vec2 size);
 *      -- function that creates button.
 *
 *    key_bind(std::string_view id, int* value);
 *      -- function that creates key binder.
 *
 *    text_input(std::string_view id, std::string* value, int max_length = 18);
 *      -- functions that creates text input box.
 *
 *    clickable_text(std::string_view text);
 *      -- function that creates text that can be clicked and eventually perform an action.
 *
 *    text(std::string_view text);
 *      -- function that creates text.
 *
 *    dummy();
 *      -- function that pushes cursor_pos.x to make empty space between our controls.
 *
 *    same_line(float x_axis = -1);
 *    backup_line();
 *      -- functions used for inline controls positioning. NOTE: there can be only one item between these two functions called.
 *
 *    ================================[hashing controls names]================================
 *
 *    the '#' thing in control name is separator that splits our name to two elements; actual displayed name & the one that is "hidden"
 *
 *    bad example:
 *      zgui::button("button", { 120, 30 });
 *      zgui::button("button", { 120, 30 });
 *
 *    code above won't work correctly because of same name provided. (known consequence is clicking 2 buttons at once)
 *
 *    good example:
 *      zgui::button("button#button_1", { 120, 30 });
 *      zgui::button("button#button_2", { 120, 30 });
 *
 *    and now, code above works fine because unique id (used in window input blocking) is provided after '#'
 *
 *    ==================================[input handling]======================================
 *
 *    IMPORTANT NOTE: poll_input(); HAS to be called before everything. Otherwise zgui will throw an exception or won't work properly.
 *
 *    poll_input("type_your_window_name") is function used to start reading input from window we specify in function parameter (string_view)
 *
 *    bad example:
 *      zgui::poll_input("");
 *      ... not calling this before whole zgui :)
 *
 *    code above won't work correctly because window name string_view size is equal to 0.
 *
 *    good example:
 *      zgui::poll_input("zgui directx9 example");
 *      zgui::poll_input("Minecraft 1.8.9");
 *
 *    and now, code above will work fine if your window titles are "zgui directx9 example" or "Minecraft 1.8.9"
 *
 *    ================================================================================================
 *
 * ================================================================================================
*/

// For examples and function descriptions see zgui header file.
namespace zgui {

	// Multi selectable item.
	struct multi_select_item { std::string_view name; bool* value; };
	// Two dimensional vector.
	struct vec2 { float x, y; };
	// Color with 4 paremeters; red, green, blue and alpha.
	struct color { int r, g, b, a; };

	/// "Proxy" functions definitions.
	using line_t = std::add_pointer_t<void(int x, int y, int x2, int y2, color color) noexcept>;
	using rect_t = std::add_pointer_t<void(int x, int y, int x2, int y2, color color) noexcept>;
	using filled_rect_t = std::add_pointer_t<void(int x, int y, int x2, int y2, color color) noexcept>;
	using text_t = std::add_pointer_t<void(int x, int y, color color, int font, bool center, const char* text) noexcept>;
	using get_text_size_t = std::add_pointer_t<void(unsigned long font, const char* text, int& wide, int& tall) noexcept>;
	using get_frametime = std::add_pointer_t<float() noexcept>;
	///

	// "Proxy" functions stuff...
	struct functions_t
	{
		line_t draw_line;
		rect_t draw_rect;
		filled_rect_t draw_filled_rect;
		text_t draw_text;
		get_text_size_t get_text_size;
		get_frametime get_frametime;
	};
	extern functions_t functions;

	// Flags for window appereance and its behavior.
	// ex: (zgui_window_flags_no_border | zgui_window_flags_no_titlebar) will cause window to be borderless and without title bar.
	enum zgui_window_flags
	{
		zgui_window_flags_none = 0,
		zgui_window_flags_no_border = 1 << 0,
		zgui_window_flags_no_titlebar = 1 << 1,
		zgui_window_flags_no_ontoggle_animation = 1 << 2,
		zgui_window_flags_no_move = 1 << 3,
		zgui_window_flags_always_open = 1 << 4,
	};

	// Flags for text input appereance.
	// ex: (zgui_text_input_flags_password) will convert text input (ex: "abcdef") to "******".
	enum zgui_text_input_flags
	{
		zgui_text_input_flags_none = 0,
		zgui_text_input_flags_password = 1 << 0
	};

	// Flags for groupboxes appereance.
	// ex: (zgui_groupbox_flags_title_centered) will center align title of groupbox.
	enum zgui_groupbox_flags
	{
		zgui_groupbox_flags_none = 0,
		zgui_groupbox_flags_title_centered = 1 << 0,
	};

	enum class zgui_render_type
	{
		zgui_line = 1,
		zgui_rect,
		zgui_filled_rect,
		zgui_text
	};

	struct zgui_control_render_t
	{
		vec2 draw_position;
		zgui_render_type render_type;
		color color;
		std::string text;
		vec2 size;
		int font = 0;
	};

	struct gui_window_context_t
	{
		uint32_t blocking;
		std::stack<vec2> cursor_pos;
		std::stack<unsigned long> fonts;
		std::vector<zgui_control_render_t> render;
		vec2 position, size;
		vec2 next_cursor_pos;
		bool dragging;
		bool opened;
		int alpha;
	};

	// Start Input loop
	ZGUI_API void poll_input(std::string_view window_name);
	ZGUI_API void poll_input(HWND hwnd);

	// Push cursor position to the stack defined in window context
	ZGUI_API void push_cursor_pos(vec2 pos) noexcept;
	// Pop cursor position from the stack defined in window context
	ZGUI_API vec2 pop_cursor_pos() noexcept;

	// Push font to the stack defined in window context
	ZGUI_API void push_font(unsigned long font) noexcept;
	// Pop font from the stack defined in window context
	ZGUI_API unsigned long pop_font();

	ZGUI_API bool begin_window(std::string_view title, vec2 default_size, unsigned long font, int flags = 0);
	ZGUI_API void end_window() noexcept;

	ZGUI_API void begin_groupbox(std::string_view title, vec2 size, int flags = 0) noexcept;
	ZGUI_API void end_groupbox() noexcept;

	ZGUI_API void checkbox(const char* id, bool& value) noexcept;

	ZGUI_API void toggle_button(const char* id, vec2 size, bool& value) noexcept;

	ZGUI_API bool button(const char* id, vec2 size) noexcept;

	ZGUI_API void key_bind(const char* id, int& value) noexcept;

	ZGUI_API void text_input(const char* id, std::string& value, int max_length = 16, int flags = 0) noexcept;

	ZGUI_API void slider_int(const char* id, int min, int max, int& value) noexcept;

	ZGUI_API void slider_float(const char* id, float min, float max, float& value) noexcept;

	ZGUI_API void combobox(const char*, std::vector<std::string> items, int& value) noexcept;

	ZGUI_API void multi_combobox(const char* id, std::vector<multi_select_item> items) noexcept;

	ZGUI_API void listbox(const char* id, std::vector<multi_select_item> items) noexcept;

	ZGUI_API bool clickable_text(const char* id) noexcept;

	ZGUI_API void text(const char* text) noexcept;

	ZGUI_API void dummy() noexcept;

	ZGUI_API void next_column(int pusher_x = 174, int pusher_y = 14) noexcept;

	ZGUI_API void same_line(float x_axis = -1) noexcept;

	ZGUI_API void backup_line() noexcept;
}
```

`core/menu/zgui/zgui.cpp`:

```cpp
#include <algorithm>
#include <iomanip>
#include <sstream>
#include <cctype>
#include <Windows.h>

#include "zgui.hpp"
// zgui by zxvnme (https://github.com/zxvnme)
// heres defines that are designed to be modified by your preferences.
// see zgui.hh for complete documentation.
// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Color definition. Can be changed at any time just simply by editing this struct.
static struct {
	color window_border_inner_fill{ 60, 60, 60, 255 };
	color window_border_fill{ 40, 40, 40, 255 };
	color window_border_color{ 10, 10, 10, 255 };
	color window_background{ 40, 40, 40, 255 };

	color control_outline{ 23, 23, 30, 255 };
	color control_active_or_clicked{ 108, 92, 231, 255 };
	color control_idle{ 62, 62, 72, 255 };

	color color_groupbox_bg{ 50, 50, 50, 255 };
	color color_text{ 203, 203, 203, 255 };
	color color_text_dimmer{ 99, 110, 114, 255 };
	color color_slider{ 108, 92, 231, 255 };
	color color_combo_bg{ 108, 92, 231, 255 };
} global_colors;

static struct {
	// Base position of first drawn control (px). DO NOT change if its necessary
	zgui::vec2 base_pos{ 16, 23 };
	// Spacing between items (px)
	int item_spacing = 16;
	// Key that will toggle menu visibility unless zgui_window_flags_always_open is set
	int menu_toggle_key = VK_INSERT;
} global_config;

// Window definitions.
static struct gui_context_t {
	zgui::gui_window_context_t window;
} context;

// "Proxy" functions stuff...
zgui::functions_t zgui::functions;

// Globals
static zgui::vec2 mouse_pos;
static zgui::vec2 previous_mouse_pos;

// Input handling stuff
static bool key_state[256];
static bool prev_key_state[256];

// Check for input polling.
static bool input_loop_started = false;

// Function for starting our input loop.
void zgui::poll_input(std::string_view window_name)
{
	if (window_name.empty())
		throw std::exception("No window from where input should be read from specified in function parameter.");

	for (int i = 0; i < 256; i++) {
		prev_key_state[i] = key_state[i];
		key_state[i] = GetAsyncKeyState(i);
	}

	POINT p_mouse_pos;
	GetCursorPos(&p_mouse_pos);
	ScreenToClient(FindWindow(nullptr, window_name.data()), &p_mouse_pos);
	previous_mouse_pos = mouse_pos;
	mouse_pos = vec2{ static_cast<float>(p_mouse_pos.x), static_cast<float>(p_mouse_pos.y) };

	if (!input_loop_started)
		input_loop_started = true;
}

// Function for starting our input loop.
void zgui::poll_input(HWND hwnd)
{
	if (!hwnd)
		throw std::exception("No window from where input should be read from specified in function parameter.");

	for (int i = 0; i < 256; i++) {
		prev_key_state[i] = key_state[i];
		key_state[i] = GetAsyncKeyState(i);
	}

	POINT p_mouse_pos;
	GetCursorPos(&p_mouse_pos);
	ScreenToClient(hwnd, &p_mouse_pos);
	previous_mouse_pos = mouse_pos;
	mouse_pos = vec2{ static_cast<float>(p_mouse_pos.x), static_cast<float>(p_mouse_pos.y) };

	if (!input_loop_started)
		input_loop_started = true;
}

// Input utilities.
constexpr bool key_pressed(const int key) noexcept
{
	return key_state[key] && !prev_key_state[key];
}

constexpr bool key_down(const int key) noexcept
{
	return key_state[key];
}

constexpr bool key_released(const int key) noexcept
{
	return !key_state[key] && prev_key_state[key];
}

// Check if mouse is hovered over specified region.
bool mouse_in_region(const int x, const int y, const int w, const int h) noexcept
{
	return mouse_pos.x > x && mouse_pos.y > y && mouse_pos.x < w + x && mouse_pos.y < h + y;
}

// Push cursor position to the stack
void zgui::push_cursor_pos(const vec2 pos) noexcept
{
	context.window.cursor_pos.push(pos);
}

// Pop cursor position from the stack
zgui::vec2 zgui::pop_cursor_pos() noexcept
{
	const vec2 pos = context.window.cursor_pos.top();
	context.window.cursor_pos.pop();
	return pos;
}

void zgui::push_font(const unsigned long font) noexcept
{
	context.window.fonts.push(font);
}

unsigned long zgui::pop_font()
{
	const unsigned long font = context.window.fonts.top();
	context.window.fonts.pop();
	return font;
}

// Hashing util
std::vector<std::string> split_str(const char* str, const char separator) noexcept
{
	std::vector<std::string> output;
	std::string substring;
	std::istringstream stream{ str };

	while (std::getline(stream, substring, separator))
		output.push_back(substring);

	return output;
}

static constexpr uint32_t hash(const char* str, const uint32_t value = 0x811c9dc5) noexcept
{
	return *str ? hash(str + 1, (value ^ *str) * 0x1000193ull) : value;
}

// Names for each of VKs
constexpr std::string_view keys_list[]{
"Error", "Left Mouse", "Right Mouse", "Break", "Middle Mouse", "Mouse 4", "Mouse 5",
"Error", "Backspace", "TAB", "Error", "Error", "Error", "ENTER", "Error", "Error", "SHIFT",
"CTRL", "ALT","PAUSE","CAPS LOCK", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error", "Error", "Error", "Error", "SPACEBAR","PG UP", "PG DOWN", "END", "HOME", "Left",
"Up", "Right", "Down", "Error", "Print", "Error", "Print Screen", "Insert","Delete", "Error", "0", "1",
"2", "3", "4", "5", "6", "7", "8", "9", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U",
"V", "W", "X","Y", "Z", "Left Windows", "Right Windows", "Error", "Error", "Error", "NUM 0", "NUM 1",
"NUM 2", "NUM 3", "NUM 4", "NUM 5", "NUM 6","NUM 7", "NUM 8", "NUM 9", "*", "+", "_", "-", ".", "/", "F1", "F2", "F3",
"F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12","F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21",
"F22", "F23", "F24", "Error", "Error", "Error", "Error", "Error","Error", "Error", "Error",
"NUM LOCK", "SCROLL LOCK", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error","Error", "Error", "Error", "Error", "Error", "LSHIFT", "RSHIFT", "LCONTROL",
"RCONTROL", "LMENU", "RMENU", "Error","Error", "Error","Error", "Error", "Error", "Error",
"Error", "Error", "Error", "Next Track", "Previous Track", "Stop", "Play/Pause", "Error", "Error",
"Error", "Error", "Error", "Error", ";", "+", ",", "-", ".", "/?", "~", "Error", "Error",
"Error", "Error","Error", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error","Error",
"Error", "Error", "Error", "Error", "Error", "Error", "[{", "\\|", "}]", "'\"", "Error",
"Error", "Error", "Error","Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
"Error", "Error"
};

struct key_code_info {
	int vk;

	char regular;
	char shift;
};

static key_code_info special_characters[22] = {
	{ 48,  '0',  ')' },
	{ 49,  '1',  '!' },
	{ 50,  '2',  '@' },
	{ 51,  '3',  '#' },
	{ 52,  '4',  '$' },
	{ 53,  '5',  '%' },
	{ 54,  '6',  '^' },
	{ 55,  '7',  '&' },
	{ 56,  '8',  '*' },
	{ 57,  '9',  '(' },
	{ 32,  ' ',  ' ' },
	{ 192, '`',  '~' },
	{ 189, '-',  '_' },
	{ 187, '=',  '+' },
	{ 219, '[',  '{' },
	{ 220, '\\', '|' },
	{ 221, ']',  '}' },
	{ 186, ';',  ':' },
	{ 222, '\'', '"' },
	{ 188, ',',  '<' },
	{ 190, '.',  '>' },
	{ 191, '/',  '?' }
};

bool zgui::begin_window(std::string_view title, const vec2 default_size, const unsigned long font, const int flags)
{
	if (!input_loop_started)
		throw std::exception("Input loop didnt start or didnt start properly.");;

	if (!(flags & zgui_window_flags_always_open))
	{
		if (key_pressed(global_config.menu_toggle_key))
			context.window.opened = !context.window.opened;
	}
	else
		context.window.opened = true;

	if (const int prev_alpha = context.window.alpha; !(flags & zgui_window_flags_no_ontoggle_animation))
	{
		const int fade_factor = static_cast<int>(1.0f / 0.15f * functions.get_frametime() * 255);
		context.window.alpha = std::clamp(context.window.alpha + (context.window.opened ? fade_factor : -fade_factor), 0, 255);

		if (context.window.alpha != prev_alpha)
		{
			global_colors.window_border_inner_fill.a = context.window.alpha;
			global_colors.window_border_fill.a = context.window.alpha;
			global_colors.window_border_color.a = context.window.alpha;
			global_colors.window_background.a = context.window.alpha;

			global_colors.control_outline.a = context.window.alpha;
			global_colors.control_active_or_clicked.a = context.window.alpha;
			global_colors.control_idle.a = context.window.alpha;

			global_colors.color_groupbox_bg.a = context.window.alpha;
			global_colors.color_text.a = context.window.alpha;
			global_colors.color_text_dimmer.a = context.window.alpha;
			global_colors.color_slider.a = context.window.alpha;
		}
	}

	if (context.window.opened || context.window.alpha > 0)
	{
		if (!(flags & zgui_window_flags_no_move))
		{
			if ((flags & zgui_window_flags_no_border ? mouse_in_region(context.window.position.x + 9, context.window.position.y + 14, context.window.size.x - 18, 14)
				: mouse_in_region(context.window.position.x - 6, context.window.position.y - 10, context.window.size.x + 12, 16))
				&& key_pressed(VK_LBUTTON) && !context.window.dragging)
			{
				context.window.dragging = true;
			}
			else if (key_down(VK_LBUTTON) && context.window.dragging)
			{
				const vec2 mouse_delta{ mouse_pos.x - previous_mouse_pos.x, mouse_pos.y - previous_mouse_pos.y };
				const vec2 new_position{ context.window.position.x + mouse_delta.x, context.window.position.y + mouse_delta.y };

				context.window.position = new_position;
			}
			else if (!key_down(VK_LBUTTON) && context.window.dragging)
			{
				context.window.dragging = false;
			}
		}

		if (context.window.size.x < 1 && context.window.size.y < 1)
			context.window.size = default_size;

		if (!(flags & zgui_window_flags_no_border))
		{
			functions.draw_filled_rect(context.window.position.x - 6, context.window.position.y - 10, context.window.size.x + 12, context.window.size.y + 16, global_colors.window_border_inner_fill);
			functions.draw_filled_rect(context.window.position.x - 5, context.window.position.y - 9, context.window.size.x + 10, context.window.size.y + 14, global_colors.window_border_color);
			functions.draw_filled_rect(context.window.position.x - 4, context.window.position.y - 8, context.window.size.x + 8, context.window.size.y + 12, global_colors.window_border_fill);
			functions.draw_filled_rect(context.window.position.x, context.window.position.y + 7, context.window.size.x, context.window.size.y - 7, global_colors.window_border_color);
			functions.draw_filled_rect(context.window.position.x + 1, context.window.position.y + 8, context.window.size.x - 2, context.window.size.y - 9, global_colors.window_border_inner_fill);
			functions.draw_filled_rect(context.window.position.x + 8, context.window.position.y + 15, context.window.size.x - 16, context.window.size.y - 23, global_colors.window_border_color);
		}

		if (!(flags & zgui_window_flags_no_titlebar))
			functions.draw_text(context.window.position.x + context.window.size.x * 0.5, context.window.position.y + (context.window.size.y * 0.010) - 10, global_colors.color_text, font, true, title.data());

		functions.draw_filled_rect(context.window.position.x + 9, context.window.position.y + 16, context.window.size.x - 18, context.window.size.y - 25, global_colors.window_background);


		push_font(font);
		push_cursor_pos(global_config.base_pos);
	}

	return context.window.opened || context.window.alpha > 0;
}

void zgui::end_window() noexcept
{
	for (int i = context.window.render.size() - 1; i >= 0; i--)
	{
		switch (context.window.render[i].render_type)
		{
		case zgui_render_type::zgui_line:
			functions.draw_line(context.window.render[i].draw_position.x, context.window.render[i].draw_position.y, context.window.render[i].size.x, context.window.render[i].size.y, context.window.render[i].color);
			break;
		case zgui_render_type::zgui_rect:
			functions.draw_rect(context.window.render[i].draw_position.x, context.window.render[i].draw_position.y, context.window.render[i].size.x, context.window.render[i].size.y, context.window.render[i].color);
			break;
		case zgui_render_type::zgui_filled_rect:
			functions.draw_filled_rect(context.window.render[i].draw_position.x, context.window.render[i].draw_position.y, context.window.render[i].size.x, context.window.render[i].size.y, context.window.render[i].color);
			break;
		case zgui_render_type::zgui_text:
			functions.draw_text(context.window.render[i].draw_position.x, context.window.render[i].draw_position.y, context.window.render[i].color, context.window.render[i].font, false, context.window.render[i].text.c_str());
			break;
		}
	}

	context.window.render.clear();

	while (!context.window.cursor_pos.empty())
		context.window.cursor_pos.pop();

}

void zgui::begin_groupbox(std::string_view title, const vec2 size, const int flags) noexcept
{
	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	functions.draw_rect(draw_pos.x - 1, draw_pos.y - 1, size.x + 2, size.y + 2, global_colors.control_outline);
	functions.draw_filled_rect(draw_pos.x, draw_pos.y, size.x, size.y, global_colors.color_groupbox_bg);

	if (title.length() > 0)
	{
		if (!(flags & zgui_groupbox_flags_title_centered))
		{
			functions.draw_text(draw_pos.x + 4, draw_pos.y - 8, global_colors.color_text, font, false, title.data());
		}
		else
		{
			int text_wide, text_tall;
			functions.get_text_size(font, title.data(), text_wide, text_tall);
			functions.draw_text(draw_pos.x + size.x / 2 - text_wide / 2, draw_pos.y - 8, global_colors.color_text, font, false, title.data());
		}
	}

	context.window.next_cursor_pos = vec2{ cursor_pos.x, cursor_pos.y + size.y + 10 };

	push_cursor_pos(vec2{ cursor_pos.x + 8, cursor_pos.y + 14 });

	push_font(font);
}

void zgui::end_groupbox() noexcept
{
	push_cursor_pos(context.window.next_cursor_pos);
	context.window.next_cursor_pos = { };
}

void zgui::checkbox(const char* id, bool& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_height = 8;
	const int control_width = 8;

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	int text_wide, text_tall;
	functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

	const bool active = context.window.blocking == hash(id);

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width + 6 + text_wide, control_height); !active && hovered && key_pressed(VK_LBUTTON))
	{
		context.window.blocking = hash(id);
	}
	else if (active && !key_down(VK_LBUTTON))
	{
		context.window.blocking = 0;
		value = !value;
	}

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 14, draw_pos.y - 2 }, zgui_render_type::zgui_text, value ? global_colors.color_text : global_colors.color_text_dimmer, id_split[0], vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect,  value ? global_colors.control_active_or_clicked : global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline,"", { control_width, control_height } });

	push_cursor_pos(vec2{ cursor_pos.x + 14 + text_wide + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + global_config.item_spacing });

	push_font(font);
}

void zgui::toggle_button(const char* id, const vec2 size, bool& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	const bool active = context.window.blocking == hash(id);

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, size.x, size.y); !active && hovered && key_pressed(VK_LBUTTON))
	{
		context.window.blocking = hash(id);
	}
	else if (active && !key_down(VK_LBUTTON))
	{
		context.window.blocking = 0;
		value = !value;
	}

	int text_wide, text_tall;
	functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + size.x / 2 - text_wide / 2, draw_pos.y + size.y / 2 - text_tall / 2 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect,  value ? global_colors.control_active_or_clicked : global_colors.control_idle, "", size });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { size.x + 2, size.y + 2 } });

	push_cursor_pos(vec2{ cursor_pos.x + size.x + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + size.y / 2 + global_config.item_spacing });

	push_font(font);
}

bool zgui::button(const char* id, const vec2 size) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	const bool active = context.window.blocking == hash(id);

	bool result = false;
	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, size.x, size.y); !active && hovered && key_pressed(VK_LBUTTON))
	{
		context.window.blocking = hash(id);
	}
	else if (active && !key_down(VK_LBUTTON))
	{
		context.window.blocking = 0;
		result = hovered;
	}

	int text_wide, text_tall;
	functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + size.x / 2 - text_wide / 2, draw_pos.y + size.y / 2 - text_tall / 2 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect,  active ? global_colors.control_active_or_clicked : global_colors.control_idle, "", {size.x - 2, size.y - 2} });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", size });

	push_cursor_pos(vec2{ cursor_pos.x + size.x + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + size.y / 2 + global_config.item_spacing });

	push_font(font);

	return result;
}

void zgui::key_bind(const char* id, int& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 80;
	const int control_height = 20;

	value = std::clamp(value, 0, 255);

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	const bool active = context.window.blocking == hash(id);

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}
	else if (active)
	{
		for (int i = 0; i < 256; i++)
		{
			if (key_pressed(i))
			{
				if (keys_list[i] != "Error")
					value = i;

				context.window.blocking = 0;
			}
		}
	}

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + 4 }, zgui_render_type::zgui_text, global_colors.color_text, active ? "Press any key" : keys_list[value].data(), vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect,  active ? global_colors.control_active_or_clicked : global_colors.control_idle, "", { control_width, control_height } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline,"", { control_width + 2, control_height + 2 } });

	push_cursor_pos(vec2{ cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });

	push_font(font);
}

void zgui::text_input(const char* id, std::string& value, const int max_length, const int flags) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 80;
	const int control_height = 20;

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	const bool active = context.window.blocking == hash(id);
	const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height);

	if (hovered && key_pressed(VK_LBUTTON) && !active)
	{
		context.window.blocking = hash(id);
	}
	else if (active)
	{
		if (key_pressed(VK_ESCAPE) || key_pressed(VK_RETURN) || (!hovered && key_pressed(VK_LBUTTON)))
		{
			context.window.blocking = 0;
		}
		else if (key_pressed(VK_BACK) && !value.empty())
		{
			value.pop_back();
		}
		else if (value.length() < max_length)
		{
			for (int i = 32; i <= 222; i++)
			{
				if ((i > 32 && i < 48) || (i > 57 && i < 65) || (i > 90 && i < 186))
					continue;

				if (i > 57 && i <= 90)
				{
					if (key_pressed(i))
						value += key_down(VK_SHIFT) ? static_cast<char>(i) : static_cast<char>(i + 32);
				}
				else
				{
					if (key_pressed(i))
					{
						for (int j = 0; j < sizeof(special_characters); j++)
						{
							if (special_characters[j].vk == i)
								value += key_down(VK_SHIFT) ? special_characters[j].shift : special_characters[j].regular;
						}
					}
				}
			}
		}
	}

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + 4 }, zgui_render_type::zgui_text,  global_colors.color_text, flags & zgui_text_input_flags_password ? std::string(value.length(), '*').c_str() : value.c_str(), vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect,  active ? global_colors.control_active_or_clicked : global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline,"", { control_width, control_height } });

	push_cursor_pos(vec2{ cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });

	push_font(font);
}

void zgui::slider_int(const char* id, const int min, const int max, int& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int font = pop_font();

	const int control_width = 120;
	const int control_height = 10;

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	if (context.window.blocking == 0 && mouse_in_region(draw_pos.x - (control_height - 2), draw_pos.y, 8, 10) && key_pressed(VK_LBUTTON))
		value = std::clamp(value - 1, min, max);
	else if (context.window.blocking == 0 && mouse_in_region(draw_pos.x + control_width, draw_pos.y, 8, 10) && key_pressed(VK_LBUTTON))
		value = std::clamp(value + 1, min, max);

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}
	else if (key_down(VK_LBUTTON) && context.window.blocking == hash(id))
	{
		float value_unmapped = std::clamp(mouse_pos.x - draw_pos.x, 0.0f, static_cast<float>(control_width));
		int value_mapped = static_cast<int>(value_unmapped / control_width * (max - min) + min);

		value = value_mapped;
	}
	else if (!key_down(VK_LBUTTON) && context.window.blocking == hash(id))
	{
		context.window.blocking = 0;
	}

	const int dynamic_width = (static_cast<float>(value) - min) / (max - min) * control_width - 2;

	int text_wide, text_tall;
	std::string value_str = std::to_string(value);
	functions.get_text_size(font, value_str.c_str(), text_wide, text_tall);

	int text_x = dynamic_width - text_wide;

	if (text_x < 0)
		text_x = 0;

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x - (control_height - 2), draw_pos.y - 2 }, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "-", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + (control_width + 4), draw_pos.y - 2 }, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "+", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + text_x, draw_pos.y }, zgui_render_type::zgui_text, global_colors.color_text, value_str, vec2{0,0}, font });

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect, global_colors.color_slider, "", { static_cast<float>(dynamic_width), control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, global_colors.control_idle,"", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline,"", { control_width, control_height } });


	push_cursor_pos(vec2{ cursor_pos.x + control_width + 14 + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });

	push_font(font);
}

void zgui::slider_float(const char* id, const float min, const float max, float& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 120;
	const int control_height = 10;

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	if (context.window.blocking == 0 && mouse_in_region(draw_pos.x - (control_height - 2), draw_pos.y, 8, 10) && key_pressed(VK_LBUTTON))
		value = std::clamp(value - 1, min, max);
	else if (context.window.blocking == 0 && mouse_in_region(draw_pos.x + control_width, draw_pos.y, 8, 10) && key_pressed(VK_LBUTTON))
		value = std::clamp(value + 1, min, max);

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}
	else if (key_down(VK_LBUTTON) && context.window.blocking == hash(id))
	{
		float value_unmapped = std::clamp(mouse_pos.x - draw_pos.x, 0.0f, static_cast<float>(control_width));
		float value_mapped = static_cast<float>((value_unmapped / static_cast<float>(control_width)) * (max - min) + min);

		value = value_mapped;
	}
	else if (!key_down(VK_LBUTTON) && context.window.blocking == hash(id))
	{
		context.window.blocking = 0;
	}

	const float dynamic_width = (static_cast<float>(value) - min) / (max - min) * control_width - 2;

	int text_wide, text_tall;
	std::stringstream ss;
	ss << std::fixed << std::setprecision(2) << value;
	std::string value_str = ss.str();
	functions.get_text_size(font, value_str.c_str(), text_wide, text_tall);

	int text_x = dynamic_width - text_wide;

	if (text_x < 0)
		text_x = 0;

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x - (control_height - 2), draw_pos.y - 2 }, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "-", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + (control_width + 4), draw_pos.y - 2 }, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "+", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + text_x, draw_pos.y }, zgui_render_type::zgui_text, global_colors.color_text, value_str, vec2{0,0}, font });

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect, global_colors.color_slider, "", { dynamic_width,  control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ {draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, global_colors.control_idle,"", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline,"", { control_width, control_height } });


	push_cursor_pos(vec2{ cursor_pos.x + control_width + 14 + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });

	push_font(font);
}

void zgui::combobox(const char* id, std::vector<std::string>items, int& value) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 70;
	const int control_height = 20;

	value = std::clamp(value, 0, static_cast<int>(items.size()) - 1);

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;

		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + control_width - 10, draw_pos.y + 4 }, zgui_render_type::zgui_text, global_colors.color_text,  "+", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + 4 }, zgui_render_type::zgui_text, global_colors.color_text,  items.at(value), vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect, global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x,  draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { control_width,  control_height } });

	push_cursor_pos(vec2{ cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });


	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}
	else if (context.window.blocking == hash(id))
	{
		for (int i = 1; i <= items.size(); i++)
		{
			bool hovered = mouse_in_region(draw_pos.x, draw_pos.y + (control_height - 1) * i, control_width, control_height);

			if (hovered && key_pressed(VK_LBUTTON))
			{
				context.window.blocking = 0;
				value = i - 1;
			}

			if (!hovered && key_pressed(VK_LBUTTON))
			{
				context.window.blocking = 0;
			}

			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + (control_height - 1) * i + 4 }, zgui_render_type::zgui_text, global_colors.color_text, items.at(i - 1), vec2{0,0}, font });
			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + (19 * i) + 1 }, zgui_render_type::zgui_filled_rect, hovered ? global_colors.color_combo_bg : global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y + 19 * i }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { control_width, control_height } });
		}
	}

	push_font(font);
}

void zgui::multi_combobox(const char* id, std::vector<multi_select_item> items) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 100;
	const int control_height = 20;

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x + 14, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	std::string value_str;
	int text_wide, text_tall;

	for (auto& item_t : items) {
		if (*item_t.value) {
			if (value_str.length() > 0)
				value_str += ", ";

			value_str += item_t.name;
		}
	}

	functions.get_text_size(font, value_str.c_str(), text_wide, text_tall);
	if (text_wide > control_width - 18)
	{
		value_str.resize(control_width / 10);
		value_str += " ...";
	}
	if (!value_str.length())
		value_str += "None";

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + control_width - 10, draw_pos.y + 4 }, zgui_render_type::zgui_text, global_colors.color_text,  "+", vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + 4 }, zgui_render_type::zgui_text, global_colors.color_text,  value_str, vec2{0,0}, font });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect, global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x,  draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { control_width,  control_height } });

	push_cursor_pos(vec2{ cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) });


	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}
	else if (context.window.blocking == hash(id))
	{
		for (int i = 1; i <= items.size(); i++)
		{
			bool hovered = mouse_in_region(draw_pos.x, draw_pos.y + (control_height - 1) * i, control_width, control_height);

			if (hovered && key_pressed(VK_LBUTTON))
			{
				context.window.blocking = 0;
				*items[i - 1].value = !*items[i - 1].value;
			}
			if (!hovered && key_pressed(VK_LBUTTON))
			{
				context.window.blocking = 0;
			}

			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + (control_height - 1) * i + 4 }, zgui_render_type::zgui_text, global_colors.color_text, items[i - 1].name.data(), vec2{0,0}, font });
			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + (19 * i) + 1 }, zgui_render_type::zgui_filled_rect, hovered ? global_colors.color_combo_bg : global_colors.control_idle, "", { control_width - 2, control_height - 2 } });
			context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y + 19 * i }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { control_width, control_height } });
		}
	}

	push_font(font);
}

void zgui::listbox(const char* id, std::vector<multi_select_item> items) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int control_width = 100;
	const int control_height = 20;

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	const bool inlined = id_split[0].empty();

	if (!inlined)
	{
		int text_wide, text_tall;
		functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y - 4 }, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0,0}, font });

		draw_pos.y += text_tall;
	}

	for (int i = 1; i <= items.size(); i++)
	{
		const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y + (control_height - 1) * (i - 1), control_width, control_height);

		if (hovered && key_pressed(VK_LBUTTON))
		{
			context.window.blocking = 0;
			*items[i - 1].value = !*items[i - 1].value;
		}
		context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 4, draw_pos.y + (control_height - 1) * (i - 1) + 4}, zgui_render_type::zgui_text, *items[i - 1].value || hovered ? global_colors.control_active_or_clicked : global_colors.color_text, items[i - 1].name.data(), vec2{0,0}, font });
	}


	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x + 1, draw_pos.y + 1 }, zgui_render_type::zgui_filled_rect, global_colors.control_idle, "", { control_width - 2, static_cast<float>(control_height * items.size() - 2) } });
	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x,  draw_pos.y }, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", { control_width, static_cast<float>(control_height * items.size()) } });

	push_cursor_pos(vec2{ cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) + control_height * (items.size() - 1) });

	if (const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && key_pressed(VK_LBUTTON) && context.window.blocking == 0)
	{
		context.window.blocking = hash(id);
	}

	push_font(font);
}

bool zgui::clickable_text(const char* id) noexcept
{
	std::vector<std::string> id_split = split_str(id, '#');

	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	int text_width, text_tall;
	functions.get_text_size(font, id_split[0].c_str(), text_width, text_tall);

	const bool active = context.window.blocking == hash(id);
	const bool hovered = mouse_in_region(draw_pos.x, draw_pos.y, text_width, text_tall);

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y}, zgui_render_type::zgui_text, (hovered || context.window.blocking == hash(id)) ? global_colors.control_active_or_clicked : global_colors.color_text, id_split[0], vec2{0,0}, font });

	push_cursor_pos(vec2{ cursor_pos.x + text_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + text_tall / 2 + global_config.item_spacing });

	bool result = false;

	if (!active && hovered && key_pressed(VK_LBUTTON))
	{
		context.window.blocking = hash(id);
	}
	else if (active && !key_down(VK_LBUTTON))
	{
		context.window.blocking = 0;
		result = hovered;
	}

	push_font(font);

	return result;
}

void zgui::text(const char* text) noexcept
{
	const int font = pop_font();

	const vec2 cursor_pos = pop_cursor_pos();
	const vec2 draw_pos{ context.window.position.x + cursor_pos.x, context.window.position.y + cursor_pos.y };

	int text_width, text_tall;
	functions.get_text_size(font, text, text_width, text_tall);

	context.window.render.emplace_back(zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui_render_type::zgui_text, global_colors.color_text, text, vec2{0,0}, font });

	push_cursor_pos(vec2{ cursor_pos.x + text_width + global_config.item_spacing, cursor_pos.y });
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + text_tall / 2 + global_config.item_spacing });

	push_font(font);
}

void zgui::dummy() noexcept
{
	const vec2 cursor_pos = pop_cursor_pos();
	push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + global_config.item_spacing });
}

void zgui::next_column(const int pusher_x, const int pusher_y) noexcept
{
	const vec2 cursor_pos = pop_cursor_pos();
	vec2 new_cursor_pos{ cursor_pos.x + pusher_x, global_config.base_pos.y + pusher_y };

	if (context.window.next_cursor_pos.y != 0)
		new_cursor_pos.y += 14;

	push_cursor_pos(new_cursor_pos);
}

void zgui::same_line(const float x_axis) noexcept
{
	const vec2 cursor_pos = pop_cursor_pos();

	if (x_axis != -1)
		push_cursor_pos(vec2{ global_config.base_pos.x + x_axis, cursor_pos.x });
}

void zgui::backup_line() noexcept
{
	const vec2 cursor_pos = pop_cursor_pos();

	push_cursor_pos(vec2{ context.window.next_cursor_pos.x, cursor_pos.y });
}
```

`core/menu/zgui/zgui.hpp`:

```hpp
#pragma once
#include "../../../dependencies/utilities/render.hpp"

#include <cstdint>
#include <stack>
#include <vector>
#include <string>
#include <string_view>
#include <type_traits>


#define ZGUI_API __declspec(dllexport)

// zgui by zxvnme (https://github.com/zxvnme) and all the community contributors
#define ZGUI_VER "1.4.8" // the number after second dot is snapshot version.
/* =============================[general]===============================
 *
 * zgui is an simple framework created to help people with GUI rendering during their game hacking (but not only) journey.
 * here is glance zgui feature presentation:
 *	- easy to use immediate mode rendering (all you need is to include zgui header and source files to your project).
 *	- simple and aesthetic design.
 *	- extensible code.
 *	... and function documentation in section below:
 *
 *    ================================[pseudo documentation]=====================================
 *
 *    get_functions()
 *      -- function that is used to get our wrapped ones.
 *
 *    begin_window(std::string_view title, vec2 default_size, unsigned long font, int flags);
 *    end_window();
 *      -- functions used to create and end window.
 *
 *    begin_groupbox(std::string_view name, vec2 size);
 *    end_groupbox();
 *      -- functions uses to create our groupbox with desired size and end it.
 *
 *    slider_int(std::string_view id, int min, int max, int* value);
 *    slider_float(std::string_view id, float min, float max, float* value);
 *      -- functions used to create sliders with value type described in function name.
 *
 *    combobox(std::string_view id, std::vector<std::string> items, int* value);
 *    multi_combobox(std::string id, std::vector<multi_select_item> items)
 *      -- functions used for creating combo boxes.
 *
 *    checkbox(std::string_view id, bool* value);
 *      -- function that creates checkbox.
 *
 *    toggle_button(std::string_view id, vec2 size, bool* value);
 *      -- function that creates toggle button.
 *
 *    button(std::string_view id, vec2 size);
 *      -- function that creates button.
 *
 *    key_bind(std::string_view id, int* value);
 *      -- function that creates key binder.
 *
 *    text_input(std::string_view id, std::string* value, int max_length = 18);
 *      -- functions that creates text input box.
 *
 *    clickable_text(std::string_view text);
 *      -- function that creates text that can be clicked and eventually perform an action.
 *
 *    text(std::string_view text);
 *      -- function that creates text.
 *
 *    dummy();
 *      -- function that pushes cursor_pos.x to make empty space between our controls.
 *
 *    same_line(float x_axis = -1);
 *    backup_line();
 *      -- functions used for inline controls positioning. NOTE: there can be only one item between these two functions called.
 *
 *    ================================[hashing controls names]================================
 *
 *    the '#' thing in control name is separator that splits our name to two elements; actual displayed name & the one that is "hidden"
 *
 *    bad example:
 *      zgui::button("button", { 120, 30 });
 *      zgui::button("button", { 120, 30 });
 *
 *    code above won't work correctly because of same name provided. (known consequence is clicking 2 buttons at once)
 *
 *    good example:
 *      zgui::button("button#button_1", { 120, 30 });
 *      zgui::button("button#button_2", { 120, 30 });
 *
 *    and now, code above works fine because unique id (used in window input blocking) is provided after '#'
 *
 *    ==================================[input handling]======================================
 *
 *    IMPORTANT NOTE: poll_input(); HAS to be called before everything. Otherwise zgui will throw an exception or won't work properly.
 *
 *    poll_input("type_your_window_name") is function used to start reading input from window we specify in function parameter (string_view)
 *
 *    bad example:
 *      zgui::poll_input("");
 *      ... not calling this before whole zgui :)
 *
 *    code above won't work correctly because window name string_view size is equal to 0.
 *
 *    good example:
 *      zgui::poll_input("zgui directx9 example");
 *      zgui::poll_input("Minecraft 1.8.9");
 *
 *    and now, code above will work fine if your window titles are "zgui directx9 example" or "Minecraft 1.8.9"
 *
 *    ================================================================================================
 *
 * ================================================================================================
*/

// For examples and function descriptions see zgui header file.
namespace zgui {

	// Multi selectable item.
	struct multi_select_item { std::string_view name; bool* value; };
	// Two dimensional vector.
	struct vec2 { float x, y; };

	/// "Proxy" functions definitions.
	
	using line_t = std::add_pointer_t<void(int x, int y, int x2, int y2, color color) noexcept>;
	using rect_t = std::add_pointer_t<void(int x, int y, int x2, int y2, color color) noexcept>;
	using filled_rect_t = std::add_pointer_t<void(int x, int y, int x2, int y2, color color) noexcept>;
	using text_t = std::add_pointer_t<void(int x, int y, color color, int font, bool center, std::string text) noexcept>;
	using get_text_size_t = std::add_pointer_t<void(unsigned long font, std::string text, int& wide, int& tall) noexcept>;
	using get_frametime = std::add_pointer_t<float() noexcept>;
	///

	// "Proxy" functions stuff...
	struct functions_t
	{
		line_t draw_line;
		rect_t draw_rect;
		filled_rect_t draw_filled_rect;
		text_t draw_text;
		get_text_size_t get_text_size;
		get_frametime get_frametime;
	};
	extern functions_t functions;

	// Flags for window appereance and its behavior.
	// ex: (zgui_window_flags_no_border | zgui_window_flags_no_titlebar) will cause window to be borderless and without title bar.
	enum zgui_window_flags
	{
		zgui_window_flags_none = 0,
		zgui_window_flags_no_border = 1 << 0,
		zgui_window_flags_no_titlebar = 1 << 1,
		zgui_window_flags_no_ontoggle_animation = 1 << 2,
		zgui_window_flags_no_move = 1 << 3,
		zgui_window_flags_always_open = 1 << 4,
	};

	// Flags for text input appereance.
	// ex: (zgui_text_input_flags_password) will convert text input (ex: "abcdef") to "******".
	enum zgui_text_input_flags
	{
		zgui_text_input_flags_none = 0,
		zgui_text_input_flags_password = 1 << 0
	};

	// Flags for groupboxes appereance.
	// ex: (zgui_groupbox_flags_title_centered) will center align title of groupbox.
	enum zgui_groupbox_flags
	{
		zgui_groupbox_flags_none = 0,
		zgui_groupbox_flags_title_centered = 1 << 0,
	};

	enum class zgui_render_type
	{
		zgui_line = 1,
		zgui_rect,
		zgui_filled_rect,
		zgui_text
	};

	struct zgui_control_render_t
	{
		vec2 draw_position;
		zgui_render_type render_type;
		color color;
		std::string text;
		vec2 size;
		int font = 0;
	};

	struct gui_window_context_t
	{
		uint32_t blocking;
		std::stack<vec2> cursor_pos;
		std::stack<unsigned long> fonts;
		std::vector<zgui_control_render_t> render;
		vec2 position, size;
		vec2 next_cursor_pos;
		bool dragging;
		bool opened;
		int alpha;
	};

	// Start Input loop
	ZGUI_API void poll_input(std::string_view window_name);
	ZGUI_API void poll_input(HWND hwnd);

	// Push cursor position to the stack defined in window context
	ZGUI_API void push_cursor_pos(vec2 pos) noexcept;
	// Pop cursor position from the stack defined in window context
	ZGUI_API vec2 pop_cursor_pos() noexcept;

	// Push font to the stack defined in window context
	ZGUI_API void push_font(unsigned long font) noexcept;
	// Pop font from the stack defined in window context
	ZGUI_API unsigned long pop_font();

	ZGUI_API bool begin_window(std::string_view title, vec2 default_size, unsigned long font, int flags = 0);
	ZGUI_API void end_window() noexcept;

	ZGUI_API void begin_groupbox(std::string_view title, vec2 size, int flags = 0) noexcept;
	ZGUI_API void end_groupbox() noexcept;

	ZGUI_API void checkbox(const char* id, bool& value) noexcept;

	ZGUI_API void toggle_button(const char* id, vec2 size, bool& value) noexcept;

	ZGUI_API bool button(const char* id, vec2 size) noexcept;

	ZGUI_API void key_bind(const char* id, int& value) noexcept;

	ZGUI_API void text_input(const char* id, std::string& value, int max_length = 16, int flags = 0) noexcept;

	ZGUI_API void slider_int(const char* id, int min, int max, int& value) noexcept;

	ZGUI_API void slider_float(const char* id, float min, float max, float& value) noexcept;

	ZGUI_API void combobox(const char*, std::vector<std::string> items, int& value) noexcept;

	ZGUI_API void multi_combobox(const char* id, std::vector<multi_select_item> items) noexcept;

	ZGUI_API void listbox(const char* id, std::vector<multi_select_item> items) noexcept;

	ZGUI_API bool clickable_text(const char* id) noexcept;

	ZGUI_API void text(const char* text) noexcept;

	ZGUI_API void dummy() noexcept;

	ZGUI_API void next_column(int pusher_x = 174, int pusher_y = 14) noexcept;

	ZGUI_API void same_line(float x_axis = -1) noexcept;

	ZGUI_API void backup_line() noexcept;
}
```

`csgo-cheat.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27703.2000
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "csgo-cheat", "csgo-cheat.vcxproj", "{AF041675-F00D-4A72-B40F-78D0C4BB72D9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AF041675-F00D-4A72-B40F-78D0C4BB72D9}.Debug|x64.ActiveCfg = Debug|x64
		{AF041675-F00D-4A72-B40F-78D0C4BB72D9}.Debug|x64.Build.0 = Debug|x64
		{AF041675-F00D-4A72-B40F-78D0C4BB72D9}.Debug|x86.ActiveCfg = Debug|Win32
		{AF041675-F00D-4A72-B40F-78D0C4BB72D9}.Debug|x86.Build.0 = Debug|Win32
		{AF041675-F00D-4A72-B40F-78D0C4BB72D9}.Release|x64.ActiveCfg = Release|x64
		{AF041675-F00D-4A72-B40F-78D0C4BB72D9}.Release|x64.Build.0 = Release|x64
		{AF041675-F00D-4A72-B40F-78D0C4BB72D9}.Release|x86.ActiveCfg = Release|Win32
		{AF041675-F00D-4A72-B40F-78D0C4BB72D9}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BB5EEA13-1F46-49E7-8ED1-B56C1ACFEF5D}
	EndGlobalSection
EndGlobal

```

`csgo-cheat.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{AF041675-F00D-4A72-B40F-78D0C4BB72D9}</ProjectGuid>
    <RootNamespace>ayysense</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>
    <ProjectName>csgo-cheat</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IncludePath>D:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>D:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
    <OutDir>.\output\debug\</OutDir>
    <IntDir>.\intermediates\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>.\output\debug\</OutDir>
    <IntDir>.\intermediates\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="core\hooks\hooks.cpp" />
    <ClCompile Include="core\menu\menu.cpp" />
    <ClCompile Include="core\menu\zgui\zgui.cpp" />
    <ClCompile Include="dependencies\interfaces\interfaces.cpp" />
    <ClCompile Include="dependencies\utilities\netvars.cpp" />
    <ClCompile Include="dependencies\utilities\render.cpp" />
    <ClCompile Include="dependencies\utilities\utilities.cpp" />
    <ClCompile Include="dependencies\utilities\hook.cpp" />
    <ClCompile Include="core\main.cpp" />
    <ClCompile Include="source-sdk\math\vector3d.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core\hooks\hooks.hpp" />
    <ClInclude Include="core\menu\menu.hpp" />
    <ClInclude Include="core\menu\zgui\zgui.hpp" />
    <ClInclude Include="dependencies\common_includes.hpp" />
    <ClInclude Include="dependencies\interfaces\cglobalvarsbase.hpp" />
    <ClInclude Include="dependencies\interfaces\iclientstate.hpp" />
    <ClInclude Include="dependencies\interfaces\iconsole.hpp" />
    <ClInclude Include="dependencies\interfaces\ibaseclientdll.hpp" />
    <ClInclude Include="dependencies\interfaces\icliententitylist.hpp" />
    <ClInclude Include="dependencies\interfaces\iclientmode.hpp" />
    <ClInclude Include="dependencies\interfaces\ienginetrace.hpp" />
    <ClInclude Include="dependencies\interfaces\igameeventmanager.hpp" />
    <ClInclude Include="dependencies\interfaces\iinput.hpp" />
    <ClInclude Include="dependencies\interfaces\ilocalize.hpp" />
    <ClInclude Include="dependencies\interfaces\imaterialsystem.hpp" />
    <ClInclude Include="dependencies\interfaces\interfaces.hpp" />
    <ClInclude Include="dependencies\interfaces\ipanel.hpp" />
    <ClInclude Include="dependencies\interfaces\isurface.hpp" />
    <ClInclude Include="dependencies\interfaces\ivdebugoverlay.hpp" />
    <ClInclude Include="dependencies\interfaces\iveffects.hpp" />
    <ClInclude Include="dependencies\interfaces\ivengineclient.hpp" />
    <ClInclude Include="dependencies\interfaces\ivmodelinfo.hpp" />
    <ClInclude Include="dependencies\interfaces\ivmodelrender.hpp" />
    <ClInclude Include="dependencies\utilities\fnv.hpp" />
    <ClInclude Include="dependencies\utilities\netvars.hpp" />
    <ClInclude Include="dependencies\utilities\render.hpp" />
    <ClInclude Include="dependencies\utilities\utilities.hpp" />
    <ClInclude Include="dependencies\utilities\hook.hpp" />
    <ClInclude Include="source-sdk\classes\client_class.hpp" />
    <ClInclude Include="source-sdk\classes\collideable.hpp" />
    <ClInclude Include="source-sdk\classes\convar.hpp" />
    <ClInclude Include="source-sdk\classes\c_usercmd.hpp" />
    <ClInclude Include="source-sdk\classes\entities.hpp" />
    <ClInclude Include="source-sdk\classes\gameevent.hpp" />
    <ClInclude Include="source-sdk\classes\recv_props.hpp" />
    <ClInclude Include="source-sdk\classes\studio.hpp" />
    <ClInclude Include="source-sdk\classes\trace.hpp" />
    <ClInclude Include="source-sdk\math\vector3d.hpp" />
    <ClInclude Include="source-sdk\misc\color.hpp" />
    <ClInclude Include="source-sdk\sdk.hpp" />
    <ClInclude Include="source-sdk\structs\dlight.hpp" />
    <ClInclude Include="source-sdk\structs\materials.hpp" />
    <ClInclude Include="source-sdk\structs\models.hpp" />
    <ClInclude Include="source-sdk\structs\weaponinfo.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`csgo-cheat.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`dependencies/common_includes.hpp`:

```hpp
#pragma once

#include <windows.h>
#include <iostream>
#include <cstdint>
#include <memory>
#include <vector>
#include <thread>
#include <chrono>
#include <array>
#include <fstream>
#include <istream>
#include <unordered_map>
#include <intrin.h>

#include <d3d9.h>
#include <d3dx9.h>
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")

#include "utilities/fnv.hpp"
#include "utilities/utilities.hpp"
#include "utilities/render.hpp"
#include "utilities/hook.hpp"
#include "interfaces/interfaces.hpp"
#include "utilities/netvars.hpp"

#include "../source-sdk/sdk.hpp"
#include "../core/hooks/hooks.hpp"
```

`dependencies/interfaces/cglobalvarsbase.hpp`:

```hpp
#pragma once

class c_global_vars_base {
public:
	float realtime;
	int frame_count;
	float absolute_frametime;
	float absolute_frame_start_time;
	float cur_time;
	float frame_time;
	int max_clients;
	int tick_count;
	float interval_per_tick;
	float interpolation_amount;
	int sim_ticks_this_frame;
	int network_protocol;
	void* p_save_data;
	bool is_client;
	bool is_remote_client;
	int timestamp_networking_base;
	int timestamp_randomize_window;
};
```

`dependencies/interfaces/ibaseclientdll.hpp`:

```hpp
#pragma once
#include "../../source-sdk/classes/client_class.hpp"

class i_base_client_dll {
public:
	client_class * get_client_classes( ) {
		using original_fn = client_class * ( __thiscall* )( i_base_client_dll* );
		return ( *( original_fn** ) this ) [ 8 ]( this );
	}
};
```

`dependencies/interfaces/icliententitylist.hpp`:

```hpp
#pragma once
#include <cstdint>

class i_client_entity_list {
public:
	void* get_client_entity( int index ) {
		using original_fn = void*( __thiscall* )( i_client_entity_list*, int );
		return ( *( original_fn** ) this ) [ 3 ]( this, index );
	}
	void* get_client_entity( uintptr_t handle ) {
		using original_fn = void*( __thiscall* )( i_client_entity_list*, uintptr_t );
		return ( *( original_fn** ) this ) [ 4 ]( this, handle );
	}
};
```

`dependencies/interfaces/iclientmode.hpp`:

```hpp
#pragma once

class i_client_mode {
	// todo
};
```

`dependencies/interfaces/iclientstate.hpp`:

```hpp
#pragma once

#pragma pack(push, 1)

class i_net_channel {
public:
	char pad_0000 [ 20 ];
	bool is_processing_messages;
	bool should_delete;
	char pad_0016 [ 2 ];
	int32_t out_sequence_nr;
	int32_t in_sequence_nr;
	int32_t out_sequence_nr_ack;
	int32_t out_reliable_state_count;
	int32_t in_reliable_state_count;
	int32_t choked_packets;
	char pad_0030 [ 1044 ];

	bool transmit( bool only_reliable ) {
		using fn = bool( __thiscall* )( void *, bool );
		return ( *( fn** ) this ) [ 49 ]( this, only_reliable );
	}
};

class i_client_state {
public:
	char pad_0000 [ 156 ];
	uint32_t net_channel;
	uint32_t challenge_count;
	double reconnect_time;
	int32_t retry_count;
	char pad_00A8 [ 88 ];
	int32_t signon_state_count;
	char pad_0104 [ 8 ];
	float next_cmd_time;
	int32_t server_count;
	uint32_t current_sequence;
	char pad_0118 [ 8 ];
	char pad_0120 [ 0x4C ];
	int32_t delta_tick;
	bool is_paused;
	char pad_0171 [ 3 ];
	int32_t view_entity;
	int32_t player_slot;
	char pad_017C [ 4 ];
	char level_name [ 260 ];
	char level_name_short [ 40 ];
	char pad_02AC [ 92 ];
	int32_t max_clients;
	char pad_030C [ 4083 ];
	uint32_t string_table_container;
	char pad_1303 [ 14737 ];
	float last_server_tick_time;
	bool is_in_simulation;
	char pad_4C99 [ 3 ];
	uint32_t old_tick_count;
	float tick_remainder;
	float frame_time;
	int32_t last_outgoing_command;
	int32_t choked_commands;
	int32_t last_command_ack;
	int32_t command_ack;
	int32_t sound_sequence;
	char pad_4CBC [ 80 ];
	vec3_t view_angles;

	void full_update( ) {
		delta_tick = -1;
	}
};

#pragma pack(pop)
```

`dependencies/interfaces/iconsole.hpp`:

```hpp
#pragma once
#include "../../source-sdk/classes/convar.hpp"
#include "../../source-sdk/misc/color.hpp"

class i_console {
public:
	convar * get_convar( const char* name ) {
		using original_fn = convar * ( __thiscall* )( i_console*, const char* );
		return ( *( original_fn** ) this ) [ 16 ]( this, name );
	}
};
```

`dependencies/interfaces/igameeventmanager.hpp`:

```hpp
#pragma once
#include "../../source-sdk/classes/gameevent.hpp"

class i_game_event_manager {
public:
	// to do
};
```

`dependencies/interfaces/iinput.hpp`:

```hpp
#pragma once
#include "../../source-sdk/classes/c_usercmd.hpp"

class i_input {
public:
	c_usercmd * get_user_cmd( int slot, int sequence_num ) {
		using original_fn = c_usercmd * ( __thiscall* )( void*, int, int );
		return ( *( original_fn** ) this )[ 8 ]( this, slot, sequence_num );
	}
};
```

`dependencies/interfaces/ilocalize.hpp`:

```hpp
#pragma once

class i_localize {
public:
	wchar_t* find( const char* token_name ) {
		using original_fn = wchar_t*( __thiscall* )( i_localize*, const char* );
		return ( *( original_fn** ) this ) [ 11 ]( this, token_name );
	}
};
```

`dependencies/interfaces/imaterialsystem.hpp`:

```hpp
#pragma once
#include "../../source-sdk/structs/materials.hpp"

class i_material_system {
public:
	i_material * find_material( char const* material_name, const char* group_name, bool complain = true, const char* complain_prefix = 0 ) {
		using original_fn = i_material * ( __thiscall* )( i_material_system*, char const*, const char*, bool, const char* );
		return ( *( original_fn** ) this ) [ 84 ]( this, material_name, group_name, complain, complain_prefix );
	}
	material_handle_t first_material( ) {
		using original_fn = material_handle_t( __thiscall* )( i_material_system* );
		return ( *( original_fn** ) this ) [ 86 ]( this );
	}
	material_handle_t next_material( material_handle_t handle ) {
		using original_fn = material_handle_t( __thiscall* )( i_material_system*, material_handle_t );
		return ( *( original_fn** ) this ) [ 87 ]( this, handle );
	}
	material_handle_t invalid_material_handle( ) {
		using original_fn = material_handle_t( __thiscall* )( i_material_system* );
		return ( *( original_fn** ) this ) [ 88 ]( this );
	}
	i_material* get_material( material_handle_t handle ) {
		using original_fn = i_material * ( __thiscall* )( i_material_system*, material_handle_t );
		return ( *( original_fn** ) this ) [ 89 ]( this, handle );
	}
	int	get_materials_count( ) {
		using original_fn = int( __thiscall* )( i_material_system* );
		return ( *( original_fn** ) this ) [ 90 ]( this );
	}
};
```

`dependencies/interfaces/interfaces.cpp`:

```cpp
#include "interfaces.hpp"
#include "../common_includes.hpp"

i_base_client_dll* interfaces::client = nullptr;
i_input* interfaces::input = nullptr;
i_client_entity_list* interfaces::entity_list = nullptr;
iv_engine_client* interfaces::engine = nullptr;
i_client_mode* interfaces::clientmode = nullptr;
i_client_state* interfaces::clientstate = nullptr;
i_panel* interfaces::panel = nullptr;
i_surface* interfaces::surface = nullptr;
c_global_vars_base* interfaces::globals = nullptr;
i_material_system* interfaces::material_system = nullptr;
iv_model_info* interfaces::model_info = nullptr;
iv_model_render* interfaces::model_render = nullptr;
void* interfaces::render_view = nullptr;
iv_effects* interfaces::effects = nullptr;
i_console* interfaces::console = nullptr;
i_localize* interfaces::localize = nullptr;
i_game_event_manager* interfaces::event_manager = nullptr;
iv_debug_overlay* interfaces::debug_overlay = nullptr;
IDirect3DDevice9* interfaces::directx = nullptr;

void interfaces::initialize( ) {
	client = reinterpret_cast< i_base_client_dll* >( utilities::game::capture_interface( "client_panorama.dll", "VClient018" ) );
	entity_list = reinterpret_cast< i_client_entity_list* >( utilities::game::capture_interface( "client_panorama.dll", "VClientEntityList003" ) );
	engine = reinterpret_cast< iv_engine_client* >( utilities::game::capture_interface( "engine.dll", "VEngineClient014" ) );
	panel = reinterpret_cast< i_panel* >( utilities::game::capture_interface( "vgui2.dll", "VGUI_Panel009" ) );
	surface = reinterpret_cast< i_surface* >( utilities::game::capture_interface( "vguimatsurface.dll", "VGUI_Surface031" ) );
	material_system = reinterpret_cast< i_material_system* >( utilities::game::capture_interface( "materialsystem.dll", "VMaterialSystem080" ) );
	model_info = reinterpret_cast< iv_model_info* >( utilities::game::capture_interface( "engine.dll", "VModelInfoClient004" ) );
	model_render = reinterpret_cast< iv_model_render* >( utilities::game::capture_interface( "engine.dll", "VEngineModel016" ) );
	render_view = reinterpret_cast< void* >( utilities::game::capture_interface( "engine.dll", "VEngineRenderView014" ) );
	console = reinterpret_cast< i_console* >( utilities::game::capture_interface( "vstdlib.dll", "VEngineCvar007" ) );
	localize = reinterpret_cast< i_localize* >( utilities::game::capture_interface( "localize.dll", "Localize_001" ) );
	event_manager = reinterpret_cast< i_game_event_manager* >( utilities::game::capture_interface( "engine.dll", "GAMEEVENTSMANAGER002" ) );
	debug_overlay = reinterpret_cast< iv_debug_overlay* >( utilities::game::capture_interface( "engine.dll", "VDebugOverlay004" ) );
	effects = reinterpret_cast< iv_effects* >( utilities::game::capture_interface( "engine.dll", "VEngineEffects001" ) );

	clientmode = **reinterpret_cast< i_client_mode*** >( ( *reinterpret_cast< uintptr_t** >( client ) ) [ 10 ] + 5 );
	clientstate = **( i_client_state*** ) ( utilities::pattern_scan( GetModuleHandleA( "engine.dll" ), "A1 ? ? ? ? 8B 80 ? ? ? ? C3" ) + 1 );
	globals = **reinterpret_cast< c_global_vars_base*** >( ( *reinterpret_cast< uintptr_t** >( client ) [ 0 ] + 27 ) );
	directx = **( IDirect3DDevice9*** ) ( utilities::pattern_scan( GetModuleHandleA( "shaderapidx9.dll" ), "A1 ? ? ? ? 50 8B 08 FF 51 0C" ) + 1 );
	input = *( i_input** ) ( utilities::pattern_scan( GetModuleHandleA( "client_panorama.dll" ), "B9 ? ? ? ? F3 0F 11 04 24 FF 50 10" ) + 1 );
}
```

`dependencies/interfaces/interfaces.hpp`:

```hpp
#pragma once
#include "ibaseclientdll.hpp"
#include "icliententitylist.hpp"
#include "ivengineclient.hpp"
#include "iclientmode.hpp"
#include "iclientstate.hpp"
#include "ipanel.hpp"
#include "isurface.hpp"
#include "cglobalvarsbase.hpp"
#include "imaterialsystem.hpp"
#include "ivmodelinfo.hpp"
#include "ivmodelrender.hpp"
#include "ivdebugoverlay.hpp"
#include "iconsole.hpp"
#include "ilocalize.hpp"
#include "igameeventmanager.hpp"
#include "iinput.hpp"
#include "iveffects.hpp"

#include <d3d9.h>
#include <d3dx9.h>
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")

namespace interfaces {
	extern i_base_client_dll* client;
	extern i_input* input;
	extern i_client_entity_list* entity_list;
	extern iv_engine_client* engine;
	extern i_client_mode* clientmode;
	extern i_client_state* clientstate;
	extern i_panel* panel;
	extern i_surface* surface;
	extern c_global_vars_base* globals;
	extern i_material_system* material_system;
	extern iv_model_info* model_info;
	extern iv_model_render* model_render;
	extern void* render_view;
	extern iv_effects* effects;
	extern iv_debug_overlay* debug_overlay;
	extern i_console* console;
	extern i_localize* localize;
	extern i_game_event_manager* event_manager;
	extern IDirect3DDevice9* directx;

	void initialize( );
}
```

`dependencies/interfaces/ipanel.hpp`:

```hpp
#pragma once

class i_panel {
public:
	const char* get_panel_name( unsigned int panel_id ) {
		using original_fn = const char*( __thiscall* )( i_panel*, unsigned int );
		return ( *( original_fn** ) this ) [ 36 ]( this, panel_id );
	}
};
```

`dependencies/interfaces/isurface.hpp`:

```hpp
#pragma once
#include "../../source-sdk/structs/vertex_t.hpp"

class i_surface {
public:
	void set_drawing_color( int r, int g, int b, int a = 255 ) {
		using original_fn = void( __thiscall* )( i_surface*, int, int, int, int );
		return ( *( original_fn** ) this )[ 15 ]( this, r, g, b, a );
	}
	void set_text_color( int r, int g, int b, int a = 255 ) {
		using original_fn = void( __thiscall* )( i_surface*, int, int, int, int );
		return ( *( original_fn** ) this )[ 25 ]( this, r, g, b, a );
	}
	void draw_polygon( int n, vertex_t *vertice, bool clip_vertices = true ) {
		using original_fn = void( __thiscall* )( i_surface*, int, vertex_t*, bool );
		return ( *( original_fn** ) this )[ 106 ]( this, n, vertice, clip_vertices );
	}
	void draw_filled_rectangle( int x, int y, int x1, int y1 ) {
		using original_fn = void( __thiscall* )( i_surface*, int, int, int, int );
		return ( *( original_fn** ) this )[ 16 ]( this, x, y, x + x1, y + y1 );
	}
	void set_texture( int id ) {
		using original_fn = void( __thiscall* )( i_surface*, int );
		return ( *( original_fn** ) this )[ 38 ]( this, id );
	}
	void set_texture_rgba( int id, const unsigned char *rgba, int wide, int tall ) {
		using original_fn = void( __thiscall* )( i_surface*, int, const unsigned char *, int, int, int, bool );
		return ( *( original_fn** ) this )[ 37 ]( this, id, rgba, wide, tall, 0, false );
	}
	int create_new_texture_id( bool procedural = false ) {
		using original_fn = int( __thiscall* )( i_surface*, bool );
		return ( *( original_fn** ) this )[ 43 ]( this, procedural );
	}
	void draw_outlined_rect( int x, int y, int x1, int y1 ) {
		using original_fn = void( __thiscall* )( i_surface*, int, int, int, int );
		return ( *( original_fn** ) this )[ 18 ]( this, x, y, x + x1, y+y1);
	}
	void draw_line( int x1, int y1, int x2, int y2 ) {
		using original_fn = void( __thiscall* )( i_surface*, int, int, int, int );
		return ( *( original_fn** ) this )[ 19 ]( this, x1, y1, x2, y2 );
	}
	void draw_text_font( unsigned long font ) {
		using original_fn = void( __thiscall* )( i_surface*, unsigned long );
		return ( *( original_fn** ) this )[ 23 ]( this, font );
	}
	void draw_text_pos( int x, int y ) {
		using original_fn = void( __thiscall* )( i_surface*, int, int );
		return ( *( original_fn** ) this )[ 26 ]( this, x, y );
	}
	void draw_render_text( const wchar_t* text, int textLen ) {
		using original_fn = void( __thiscall* )( i_surface*, const wchar_t*, int, int );
		return ( *( original_fn** ) this )[ 28 ]( this, text, textLen, 0 );
	}
	unsigned long font_create( ) {
		using original_fn = unsigned int( __thiscall* )( i_surface* );
		return ( *( original_fn** ) this )[ 71 ]( this );
	}
	void set_font_glyph( unsigned long font, const char* windowsFontName, int tall, int weight, int blur, int scanlines, int flags ) {
		using original_fn = void( __thiscall* )( i_surface*, unsigned long, const char*, int, int, int, int, int, int, int );
		return ( *( original_fn** ) this )[ 72 ]( this, font, windowsFontName, tall, weight, blur, scanlines, flags, 0, 0 );
	}
	void get_text_size( unsigned long font, const wchar_t* text, int& wide, int& tall ) {
		using original_fn = void( __thiscall* )( i_surface*, unsigned long, const wchar_t*, int&, int& );
		return ( *( original_fn** ) this )[ 79 ]( this, font, text, wide, tall );
	}
};
```

`dependencies/interfaces/ivdebugoverlay.hpp`:

```hpp
#pragma once
#include "../../source-sdk/math/vector3d.hpp"

class iv_debug_overlay {
public:
	bool world_to_screen( const vec3_t& in, vec3_t& out ) {
		using original_fn = int( __thiscall* )( iv_debug_overlay*, const vec3_t&, vec3_t& );
		int return_value = ( *( original_fn** ) this ) [ 13 ]( this, in, out );
		return static_cast< bool >( return_value != 1 );
	}
};
```

`dependencies/interfaces/iveffects.hpp`:

```hpp
#pragma once
#include "../../source-sdk/structs/dlight.hpp"

class iv_effects {
public:
	dlight_t * alloc( int key ) {
		using original_fn = dlight_t * ( __thiscall* )( void*, int );
		return ( *( original_fn** ) this ) [ 4 ]( this, key );
	}
};
```

`dependencies/interfaces/ivengineclient.hpp`:

```hpp
#pragma once
#include <cstdint>
#include "../../source-sdk/math/vector3d.hpp"

struct player_info_t {
	int64_t __pad0;
	union {
		int64_t xuid;
		struct {
			int xuidlow;
			int xuidhigh;
		};
	};
	char name [ 128 ];
	int userid;
	char guid [ 33 ];
	unsigned int friendsid;
	char friendsname [ 128 ];
	bool fakeplayer;
	bool ishltv;
	unsigned int customfiles [ 4 ];
	unsigned char filesdownloaded;
};

class iv_engine_client {
public:
	int get_local_player( ) {
		using original_fn = int( __thiscall* )( iv_engine_client* );
		return ( *( original_fn** ) this ) [ 12 ]( this );
	}
	int get_player_for_user_id( int user_id ) {
		using original_fn = int( __thiscall* )( iv_engine_client*, int );
		return ( *( original_fn** ) this ) [ 9 ]( this, user_id );
	}
	void get_player_info( int index, player_info_t* info ) {
		using original_fn = void( __thiscall* )( iv_engine_client*, int, player_info_t* );
		return ( *( original_fn** ) this ) [ 8 ]( this, index, info );
	}
	void get_screen_size( int& width, int& height ) {
		using original_fn = void( __thiscall* )( iv_engine_client*, int&, int& );
		return ( *( original_fn** ) this ) [ 5 ]( this, width, height );
	}
	void execute_cmd( const char* cmd ) {
		using original_fn = void( __thiscall* )( iv_engine_client*, const char* );
		return ( *( original_fn** ) this ) [ 108 ]( this, cmd ); // this always seems to crash whilst debugging, just feel free to continue.
	}
	void set_view_angles( vec3_t& angles ) {
		using original_fn = void( __thiscall* )( iv_engine_client*, vec3_t& );
		return ( *( original_fn** ) this ) [ 19 ]( this, angles );
	}
	vec3_t get_view_angles( ) {
		vec3_t temp;
		using original_fn = void( __thiscall* )( iv_engine_client*, vec3_t& );
		( *( original_fn** ) this ) [ 18 ]( this, temp );
		return temp;
	}
};
```

`dependencies/interfaces/ivmodelinfo.hpp`:

```hpp
#pragma once
#include "../../source-sdk/structs/models.hpp"
#include "../../source-sdk/classes/studio.hpp"

class iv_model_info {
public:
	model_t * get_model( int index ) {
		using original_fn = model_t * ( __thiscall* )( iv_model_info*, int );
		return ( *( original_fn** ) this ) [ 1 ]( this, index );
	}
	int get_model_index( const char* filename ) {
		using original_fn = int( __thiscall* )( iv_model_info*, const char* );
		return ( *( original_fn** ) this ) [ 2 ]( this, filename );
	}
	const char* get_model_name( const model_t* model ) {
		using original_fn = const char*( __thiscall* )( iv_model_info*, const model_t* );
		return ( *( original_fn** ) this ) [ 3 ]( this, model );
	}
	studio_hdr_t* get_studio_model( const model_t* model ) {
		using original_fn = studio_hdr_t * ( __thiscall* )( iv_model_info*, const model_t* );
		return ( *( original_fn** ) this ) [ 32 ]( this, model );
	}
};
```

`dependencies/interfaces/ivmodelrender.hpp`:

```hpp
#pragma once
#include "../../source-sdk/structs/materials.hpp"

class iv_model_render {
public:
	void override_material( i_material* material ) {
		using original_fn = void( __thiscall* )( iv_model_render*, i_material*, int, int );
		return ( *( original_fn** ) this ) [ 1 ]( this, material, 0, 0 );
	}
};
```

`dependencies/utilities/fnv.hpp`:

```hpp
#pragma once
#include <string>

class fnv_hash {
private:
	struct wrapper {
		wrapper( const char* str ) : str( str ) { }
		const char* str;
	};

	static const unsigned int prime = 16777619u;
	static const unsigned int basis = 2166136261u;

	template <unsigned int n>
	static constexpr unsigned int fnv_hash_const( const char( &str ) [ n ], unsigned int i = n ) {
		return i == 1 ? ( basis ^ str [ 0 ] ) * prime : ( fnv_hash_const( str, i - 1 ) ^ str [ i - 1 ] ) * prime;
	}
	static unsigned int hash( const char* str ) {
		const size_t length = strlen( str ) + 1;
		unsigned int hash = basis;

		for ( size_t i = 0; i < length; ++i ) {
			hash ^= *str++;
			hash *= prime;
		}

		return hash;
	}

	unsigned int hash_value;
public:
	fnv_hash( wrapper wrap ) : hash_value( hash( wrap.str ) ) { }

	template <unsigned int n>
	constexpr fnv_hash( const char( &str ) [ n ] ) : hash_value( fnv_hash_const( str ) ) { }

	constexpr operator unsigned int( ) const {
		return this->hash_value;
	}
};
```

`dependencies/utilities/hook.cpp`:

```cpp
#include "hook.hpp"
#include "../common_includes.hpp"

void prop_hook::setup( recv_prop* prop ) {
	this->prop = prop;
	this->original_fn = prop->proxy_fn;
}

void prop_hook::swap( recv_var_proxy_fn new_proxy ) {
	this->prop->proxy_fn = new_proxy;
}

void prop_hook::release( ) {
	this->prop->proxy_fn = this->original_fn;
}

recv_var_proxy_fn prop_hook::get_original( ) {
	return this->original_fn;
}

/*Okay this is a word from Oneshot. This code is not all mine but it wasnt functional until i changed some stuff, if
you wanna know what i changed then go and check the original code from exphck. This should be UD vmthooking
but it might not be that stable because .data area*/
auto table_is_hooked(void* table, const char* module_table_dst) -> const bool {
	// Because of this probable check you can make a VEH Hook by forcing the pointer to 0
	if (table == nullptr) // Not initialized or invalid table to check
		return false;

	const auto module_base = GetModuleHandleA(module_table_dst);

	// Get module end
	const auto dos_header = reinterpret_cast< PIMAGE_DOS_HEADER > (module_base);
	const auto nt_headers = reinterpret_cast< PIMAGE_NT_HEADERS > (reinterpret_cast< std::uint8_t* >(module_base) + dos_header->e_lfanew);

	const auto module_end = reinterpret_cast< std::uintptr_t >(module_base) + nt_headers->OptionalHeader.SizeOfImage - sizeof(std::uintptr_t);

	const auto table_dst = *reinterpret_cast< std::uintptr_t* >(table);

	// Check the destination of the table, if the destination of the table is outside the region of the module, it is because it has been changed(hooked)
	return (table_dst < reinterpret_cast< std::uintptr_t >(module_base) || table_dst > module_end);
}
uintptr_t* vmt_hook::search_free_data_page(const char* module_name, const std::size_t vmt_size) //Modified code from exphck https://www.unknowncheats.me/forum/2128832-post43.html
{
	auto check_data_section = [&] (LPCVOID address, const std::size_t vmt_size) {
		const DWORD DataProtection = (PAGE_EXECUTE_READWRITE | PAGE_READWRITE);
		MEMORY_BASIC_INFORMATION mbi = {0};

		if (VirtualQuery(address, &mbi, sizeof(mbi)) == sizeof(mbi) && mbi.AllocationBase && mbi.BaseAddress &&
			mbi.State == MEM_COMMIT && !(mbi.Protect & PAGE_GUARD) && mbi.Protect != PAGE_NOACCESS) {
			if ((mbi.Protect & DataProtection) && mbi.RegionSize >= vmt_size) {
				return ((mbi.Protect & DataProtection) && mbi.RegionSize >= vmt_size) ? true : false;
			}
		}
		return false;
	};

	auto module_addr = GetModuleHandleA(module_name);

	if (module_addr == nullptr)
		return nullptr;

	const auto dos_header = reinterpret_cast< PIMAGE_DOS_HEADER > (module_addr);
	const auto nt_headers = reinterpret_cast< PIMAGE_NT_HEADERS > (reinterpret_cast< std::uint8_t* >(module_addr) + dos_header->e_lfanew);

	const auto module_end = reinterpret_cast< std::uintptr_t >(module_addr) + nt_headers->OptionalHeader.SizeOfImage - sizeof(std::uintptr_t);

	for (auto current_address = module_end; current_address > (DWORD) module_addr; current_address -= sizeof(std::uintptr_t)) {
		if (*reinterpret_cast< std::uintptr_t* >(current_address) == 0 && check_data_section(reinterpret_cast< LPCVOID >(current_address), vmt_size)) {
			bool is_good_vmt = true;
			auto page_count = 0u;

			for (; page_count < vmt_size && is_good_vmt; page_count += sizeof(std::uintptr_t)) {
				if (*reinterpret_cast< std::uintptr_t* >(current_address + page_count) != 0)
					is_good_vmt = false;
			}

			if (is_good_vmt && page_count >= vmt_size)
				return (uintptr_t*) current_address;
		}
	}
	return nullptr;
}

vmt_hook::vmt_hook()
	: class_base(nullptr), vftbl_len(0), new_vftb1(nullptr), old_vftbl(nullptr) {
}
vmt_hook::vmt_hook(void* base)
	: class_base(base), vftbl_len(0), new_vftb1(nullptr), old_vftbl(nullptr) {
}
vmt_hook::~vmt_hook() {
	release();
	if (was_allocated)
		delete[] new_vftb1;
}

bool vmt_hook::setup(void* base, const char * module_name) {
	if (base != nullptr)
		class_base = base;

	if (class_base == nullptr)
		return false;

	old_vftbl = *(std::uintptr_t**)class_base;
	vftbl_len = estimate_vftbl_length(old_vftbl) * sizeof(std::uintptr_t);

	if (vftbl_len == 0)
		return false;


	if (module_name)// If provided a module name then we will find a place in that module				
	{
		new_vftb1 = search_free_data_page(module_name, vftbl_len + sizeof(std::uintptr_t));
		std::memset(new_vftb1, NULL, vftbl_len + sizeof(std::uintptr_t));
		std::memcpy(&new_vftb1[1], old_vftbl, vftbl_len);
		new_vftb1[0] = old_vftbl[-1];
		try {
			auto guard = detail::protect_guard {class_base, sizeof(std::uintptr_t), PAGE_READWRITE};

			*(std::uintptr_t**)class_base = &new_vftb1[1];
			was_allocated = false;
			if (table_is_hooked(base, module_name)) {
				Beep(500, 500);
			}
		} catch (...) {
			delete[] new_vftb1;
			return false;
		}
	} else // If not then we do regular vmthookinh
	{
		new_vftb1 = new std::uintptr_t[vftbl_len + 1]();
		std::memcpy(&new_vftb1[1], old_vftbl, vftbl_len);
		try {
			auto guard = detail::protect_guard {class_base, sizeof(std::uintptr_t), PAGE_READWRITE};
			new_vftb1[0] = old_vftbl[-1];
			*(std::uintptr_t**)class_base = &new_vftb1[1];
			was_allocated = true;
		} catch (...) {
			delete[] new_vftb1;
			return false;
		}
	}


	return true;
}

std::size_t vmt_hook::estimate_vftbl_length(std::uintptr_t* vftbl_start) {
	MEMORY_BASIC_INFORMATION memInfo = {NULL};
	int m_nSize = -1;
	do {
		m_nSize++;
		VirtualQuery(reinterpret_cast<LPCVOID>(vftbl_start[m_nSize]), &memInfo, sizeof(memInfo));

	} while (memInfo.Protect == PAGE_EXECUTE_READ || memInfo.Protect == PAGE_EXECUTE_READWRITE);

	return m_nSize;
}

void vmt_hook::hook_index( size_t fn_index, void* fn_pointer ) {
	assert(fn_index >= 0 && fn_index <= (int) vftbl_len);
	new_vftb1[fn_index + 1] = reinterpret_cast<std::uintptr_t>(fn_pointer);
}

void vmt_hook::release( ) {
	try {
		if (old_vftbl != nullptr) {
			auto guard = detail::protect_guard {class_base, sizeof(std::uintptr_t), PAGE_READWRITE};
			*(std::uintptr_t**)class_base = old_vftbl;
			old_vftbl = nullptr;
		}
	} catch (...) {
	}
}

void* vmt_hook::get_original( size_t fn_index ) {
	return reinterpret_cast< void* >(old_vftbl[fn_index]);
}
```

`dependencies/utilities/hook.hpp`:

```hpp
#pragma once
#include <cstdint>
#include "../../source-sdk/classes/client_class.hpp"
#define NOMINMAX
#include <Windows.h>
#include <assert.h>
#include <stdexcept>

namespace detail {
	class protect_guard {
	public:
		protect_guard(void* base, size_t len, std::uint32_t flags) {
			_base = base;
			_length = len;
			if (!VirtualProtect(base, len, flags, (PDWORD) &_old))
				throw std::runtime_error("failed to protect region.");
		}
		~protect_guard() {
			VirtualProtect(_base, _length, _old, (PDWORD) &_old);
		}

	private:
		void*         _base;
		size_t        _length;
		std::uint32_t _old;
	};
}

class prop_hook {
private:
	recv_var_proxy_fn original_fn;
	recv_prop* prop;

public:
	void setup( recv_prop* prop );
	void swap( recv_var_proxy_fn new_proxy );
	void release( );
	recv_var_proxy_fn get_original( );
};

class vmt_hook {
private:
	static inline std::size_t estimate_vftbl_length(std::uintptr_t* vftbl_start);

	void*           class_base;
	std::size_t     vftbl_len;
	std::uintptr_t* new_vftb1;
	std::uintptr_t* old_vftbl;
	LPCVOID         search_base = nullptr;
	bool was_allocated = false;

public:
	uintptr_t * search_free_data_page(const char * module_name, const std::size_t vmt_size);
	vmt_hook();
	vmt_hook(void* base);
	~vmt_hook();

	bool setup(void * base, const char * module_name = nullptr);

	void hook_index( size_t fn_index, void* fn_pointer );
	void release( );

	void* get_original( size_t fn_index );
};
```

`dependencies/utilities/netvars.cpp`:

```cpp
#include "netvars.hpp"
#include <sstream>
#include <iomanip>

netvar_manager g_netvar_mgr;

void netvar_manager::dump_table_recursive( recv_table* table ) {
	for ( auto i = 0; i < table->props_count; ++i ) {
		auto prop = &table->props [ i ];

		if ( !prop || isdigit( prop->prop_name [ 0 ] ) )
			continue;
		if ( strcmp( prop->prop_name, "baseclass" ) == 0 )
			continue;

		if ( prop->prop_type == send_prop_type::_data_table && prop->data_table != nullptr && prop->data_table->table_name [ 0 ] == 'D' ) {
			dump_table_recursive( prop->data_table );
		}

		std::string hash_string = table->table_name;
		hash_string.append( "->" );
		hash_string.append( prop->prop_name );

		netvars_map [ fnv_hash( hash_string.c_str( ) ) ] = prop;
	}
}

void netvar_manager::dump_table_to_file_recursive( recv_table* table, std::ofstream& file ) {
	for ( auto i = 0; i < table->props_count; ++i ) {
		auto prop = &table->props [ i ];

		if ( !prop || isdigit( prop->prop_name [ 0 ] ) )
			continue;
		if ( strcmp( prop->prop_name, "baseclass" ) == 0 )
			continue;

		if ( prop->prop_type == send_prop_type::_data_table && prop->data_table != nullptr && prop->data_table->table_name [ 0 ] == 'D' ) {
			dump_table_to_file_recursive( prop->data_table, file );
		}

		std::string hash_string = table->table_name;
		hash_string.append( " -> " );
		hash_string.append( prop->prop_name );

		auto hash = fnv_hash( hash_string.c_str( ) );

		hash_string.append( " (" );
		hash_string.append( std::to_string( unsigned int( hash ) ) );
		hash_string.append( ") [" );
		std::stringstream stream;
		stream << "0x"
			<< std::setfill( '0' ) << std::setw( sizeof( int ) * 2 )
			<< std::hex << prop->offset;
		hash_string.append( stream.str( ) );
		hash_string.append( "]" );

		file << hash_string << std::endl;
	}
}

void netvar_manager::initialize( client_class* client_data ) {
	for ( auto data = client_data; data; data = data->next_ptr ) {
		if ( data->recvtable_ptr ) {
			dump_table_recursive( data->recvtable_ptr );
		}
	}
}

void netvar_manager::dump_netvars( client_class* client_data ) {
	std::ofstream output( "netvars_dump.txt" );

	for ( auto data = client_data; data; data = data->next_ptr ) {
		if ( data->recvtable_ptr ) {
			dump_table_to_file_recursive( data->recvtable_ptr, output );
		}
	}
}

unsigned short netvar_manager::get_offset( unsigned int hash ) {
	if ( !netvars_map [ hash ] ) return 0;
	return netvars_map [ hash ]->offset;
}

recv_prop* netvar_manager::get_prop( unsigned int hash ) {
	return netvars_map [ hash ];
}
```

`dependencies/utilities/netvars.hpp`:

```hpp
#pragma once
#include "fnv.hpp"

#include "../../source-sdk/classes/recv_props.hpp"
#include "../../source-sdk/classes/client_class.hpp"

#include <string>
#include <vector>
#include <map>
#include <fstream>

class netvar_manager {
private:
	std::map<unsigned int, recv_prop*> netvars_map;
	void dump_table_recursive( recv_table* table );
	void dump_table_to_file_recursive( recv_table* table, std::ofstream& file );

public:
	void initialize( client_class* client_data );
	void dump_netvars( client_class* client_data );

	unsigned short get_offset( unsigned int hash );
	recv_prop* get_prop( unsigned int hash );
};

extern netvar_manager g_netvar_mgr;

#define offset_fn(type, var, offset) \
	type& var() { \
		return *(type*)(uintptr_t(this) + offset); \
	} \

#define netvar_fn(type, var, hash) \
	type& var() { \
		static auto _offset = g_netvar_mgr.get_offset(fnv_hash(hash)); \
		return *(type*)(uintptr_t(this) + _offset); \
	} \

#define netvar_ptr_fn(type, var, hash) \
	type* var() { \
		static auto _offset = g_netvar_mgr.get_offset(fnv_hash(hash)); \
		return (type*)(uintptr_t(this) + _offset); \
	} \

#define netvar_offset_fn(type, var, hash, offset) \
	type& var() { \
		static auto _offset = g_netvar_mgr.get_offset(fnv_hash(hash)); \
		return *(type*)(uintptr_t(this) + _offset + offset); \
	} \

#define netvar_original(type, var, offset) \
	type& var() { \
		return *(type*)(uintptr_t(this) + offset); \
	} \
```

`dependencies/utilities/render.cpp`:

```cpp
#include "render.hpp"

unsigned long render::main_font;

void render::setup_fonts() {
	main_font = interfaces::surface->font_create();

	interfaces::surface->set_font_glyph(main_font, "Tahoma", 12, 500, 0, 0, font_flags::fontflag_outline);
}

void render::line(int x, int y, int x2, int y2, color c) noexcept {
	interfaces::surface->set_drawing_color(c.r, c.g, c.b, c.a);
	interfaces::surface->draw_line(x, y, x2, y2);
}

void render::rect(int x, int y, int x2, int y2, color c) noexcept {
	interfaces::surface->set_drawing_color(c.r, c.g, c.b, c.a);
	interfaces::surface->draw_outlined_rect(x, y, x2, y2);
}

void render::filled_rect(int x, int y, int x2, int y2, color c) noexcept {
	interfaces::surface->set_drawing_color(c.r, c.g, c.b, c.a);
	interfaces::surface->draw_filled_rectangle(x, y, x2, y2);
}

void render::text(int x, int y, color color, int font, bool center, std::string str) noexcept {
	std::wstring text = std::wstring(str.begin(), str.end());
	const wchar_t* converted_text = text.c_str();

	int width, height;
	interfaces::surface->get_text_size(font, converted_text, width, height);

	interfaces::surface->set_text_color(color.r, color.g, color.b, color.a);
	interfaces::surface->draw_text_font(font);
	if (center)
		interfaces::surface->draw_text_pos(x - (width / 2), y);
	else
		interfaces::surface->draw_text_pos(x, y);

	interfaces::surface->draw_render_text(converted_text, wcslen(converted_text));
}

void render::get_text_size(unsigned long font, std::string str, int& width, int& height) noexcept {
	std::wstring text = std::wstring(str.begin(), str.end());
	const wchar_t* out = text.c_str();

	interfaces::surface->get_text_size(font, out, width, height);
}

float render::get_frametime() noexcept {
	return interfaces::globals->frame_time;
}
```

`dependencies/utilities/render.hpp`:

```hpp
#pragma once
#include <string>
#include "../interfaces/interfaces.hpp"
#include "..//..//source-sdk/misc/color.hpp"

namespace render {
	enum font_flags {
		fontflag_none,
		fontflag_italic = 0x001,
		fontflag_underline = 0x002,
		fontflag_strikeout = 0x004,
		fontflag_symbol = 0x008,
		fontflag_antialias = 0x010,
		fontflag_gaussianblur = 0x020,
		fontflag_rotary = 0x040,
		fontflag_dropshadow = 0x080,
		fontflag_additive = 0x100,
		fontflag_outline = 0x200,
		fontflag_custom = 0x400,
		fontflag_bitmap = 0x800,
	};

	extern unsigned long main_font;

	void setup_fonts();

	void line(int x, int y, int x2, int y2, color c) noexcept;
	void rect(int x, int y, int x2, int y2, color c) noexcept;
	void filled_rect(int x, int y, int x2, int y2, color c) noexcept;
	void text(int x, int y, color color, int font, bool center, std::string str) noexcept;
	void get_text_size(unsigned long font, std::string str, int& width, int& height) noexcept;
	float get_frametime() noexcept;
};
```

`dependencies/utilities/utilities.cpp`:

```cpp
#include "utilities.hpp"
#include "../common_includes.hpp"
#include <psapi.h>

std::uint8_t* utilities::pattern_scan( void* module, const char* signature ) {
	static auto pattern_to_byte = [ ] ( const char* pattern ) {
		auto bytes = std::vector<int> {};
		auto start = const_cast< char* >( pattern );
		auto end = const_cast< char* >( pattern ) + strlen( pattern );

		for ( auto current = start; current < end; ++current ) {
			if ( *current == '?' ) {
				++current;
				if ( *current == '?' )
					++current;
				bytes.push_back( -1 );
			}
			else {
				bytes.push_back( strtoul( current, &current, 16 ) );
			}
		}
		return bytes;
	};

	auto dos_headers = ( PIMAGE_DOS_HEADER ) module;
	auto nt_headers = ( PIMAGE_NT_HEADERS ) ( ( std::uint8_t* )module + dos_headers->e_lfanew );

	auto size_of_image = nt_headers->OptionalHeader.SizeOfImage;
	auto pattern_bytes = pattern_to_byte( signature );
	auto scan_bytes = reinterpret_cast< std::uint8_t* >( module );

	auto s = pattern_bytes.size( );
	auto d = pattern_bytes.data( );

	for ( auto i = 0ul; i < size_of_image - s; ++i ) {
		bool found = true;
		for ( auto j = 0ul; j < s; ++j ) {
			if (scan_bytes[ i + j ] != d [ j ] && d [ j ] != -1 ) {
				found = false;
				break;
			}
		}
		if ( found ) {
			return &scan_bytes[ i ];
		}
	}
	return nullptr;
}

void* utilities::game::capture_interface( const char* mod, const char* iface ) {
	using fn_capture_iface_t = void*( *)( const char*, int* );
	auto fn_addr = ( fn_capture_iface_t ) GetProcAddress( GetModuleHandleA( mod ), "CreateInterface" );

	auto iface_addr = fn_addr( iface, nullptr );
	printf( "found %s at 0x%p\n", iface, fn_addr( iface, nullptr ) );

	return iface_addr;
}

```

`dependencies/utilities/utilities.hpp`:

```hpp
#pragma once
#include <cstdint>
#include "../../source-sdk/math/vector3d.hpp"

#define M_PI 3.14159265358979323846

namespace utilities {
	namespace math {
		template <typename t> t clamp_value( t value, t min, t max ) {
			if ( value > max ) {
				return max;
			}
			if ( value < min ) {
				return min;
			}
			return value;
		}
	}
	namespace game {
		void* capture_interface( const char* mod, const char* iface );
	}
	std::uint8_t* pattern_scan( void* module, const char* signature );
}
```

`source-sdk/classes/c_usercmd.hpp`:

```hpp
#pragma once

enum cmd_buttons {
	in_attack = ( 1 << 0 ),
	in_jump = ( 1 << 1 ),
	in_duck = ( 1 << 2 ),
	in_forward = ( 1 << 3 ),
	in_back = ( 1 << 4 ),
	in_use = ( 1 << 5 ),
	in_cancel = ( 1 << 6 ),
	in_left = ( 1 << 7 ),
	in_right = ( 1 << 8 ),
	in_moveleft = ( 1 << 9 ),
	in_moveright = ( 1 << 10 ),
	in_attack2 = ( 1 << 11 ),
	in_run = ( 1 << 12 ),
	in_reload = ( 1 << 13 ),
	in_alt1 = ( 1 << 14 ),
	in_alt2 = ( 1 << 15 ),
	in_score = ( 1 << 16 ),
	in_speed = ( 1 << 17 ),
	in_walk = ( 1 << 18 ),
	in_zoom = ( 1 << 19 ),
	in_weapon1 = ( 1 << 20 ),
	in_weapon2 = ( 1 << 21 ),
	in_bullrush = ( 1 << 22 ),
	in_grenade1 = ( 1 << 23 ),
	in_grenade2 = ( 1 << 24 ),
	in_attack3 = ( 1 << 25 )
};

class c_usercmd {
public:
	c_usercmd( ) { };
	virtual ~c_usercmd( ) { };

	int command_number;
	int tick_count;
	vec3_t view_angles;
	vec3_t aim_direction;
	float forward_move;
	float side_move;
	float up_move;
	int buttons;
	unsigned char impulse;
	int weapon_select;
	int weapon_subtype;
	int random_seed;
	short mouse_dx;
	short mouse_dy;
	bool has_been_predicted;
	char pad_0x4c [ 0x18 ];
};
```

`source-sdk/classes/client_class.hpp`:

```hpp
#pragma once
#include "recv_props.hpp"

class client_class;
class i_client_networkable;

typedef i_client_networkable* ( *create_client_class_fn )( int ent_number, int serial_number );
typedef i_client_networkable* ( *create_event_fn )( );

enum class_ids {
	ctesttraceline = 196,
	cteworlddecal = 197,
	ctespritespray = 194,
	ctesprite = 193,
	ctesparks = 192,
	ctesmoke = 191,
	cteshowline = 189,
	cteprojecteddecal = 186,
	cfeplayerdecal = 61,
	cteplayerdecal = 185,
	ctephysicsprop = 182,
	cteparticlesystem = 181,
	ctemuzzleflash = 180,
	ctelargefunnel = 178,
	ctekillplayerattachments = 177,
	cteimpact = 176,
	cteglowsprite = 175,
	cteshattersurface = 188,
	ctefootprintdecal = 172,
	ctefizz = 171,
	cteexplosion = 169,
	cteenergysplash = 168,
	cteeffectdispatch = 167,
	ctedynamiclight = 166,
	ctedecal = 164,
	cteclientprojectile = 163,
	ctebubbletrail = 162,
	ctebubbles = 161,
	ctebspdecal = 160,
	ctebreakmodel = 159,
	ctebloodstream = 158,
	ctebloodsprite = 157,
	ctebeamspline = 156,
	ctebeamringpoint = 155,
	ctebeamring = 154,
	ctebeampoints = 153,
	ctebeamlaser = 152,
	ctebeamfollow = 151,
	ctebeaments = 150,
	ctebeamentpoint = 149,
	ctebasebeam = 148,
	ctearmorricochet = 147,
	ctemetalsparks = 179,
	csteamjet = 142,
	csmokestack = 135,
	dusttrail = 246,
	cfiretrail = 64,
	sporetrail = 252,
	sporeexplosion = 251,
	rockettrail = 249,
	smoketrail = 250,
	cpropvehicledriveable = 122,
	particlesmokegrenade = 248,
	cparticlefire = 100,
	movieexplosion = 247,
	ctegaussexplosion = 174,
	cenvquadraticbeam = 56,
	cembers = 46,
	cenvwind = 60,
	cprecipitation = 116,
	cprecipitationblocker = 117,
	cbasetempentity = 18,
	nextbotcombatcharacter = 0,
	ceconwearable = 45,
	cbaseattributableitem = 4,
	ceconentity = 44,
	cweaponxm1014 = 244,
	cweapontaser = 239,
	csmokegrenade = 133,
	cweaponsg552 = 236,
	csensorgrenade = 129,
	cweaponsawedoff = 232,
	cweaponnova = 228,
	cincendiarygrenade = 87,
	cmolotovgrenade = 97,
	cweaponm3 = 220,
	cknifegg = 94,
	cknife = 93,
	chegrenade = 84,
	cflashbang = 66,
	cweaponelite = 211,
	cdecoygrenade = 40,
	cdeagle = 39,
	cweaponusp = 243,
	cweaponm249 = 219,
	cweaponump45 = 242,
	cweapontmp = 241,
	cweapontec9 = 240,
	cweaponssg08 = 238,
	cweaponsg556 = 237,
	cweaponsg550 = 235,
	cweaponscout = 234,
	cweaponscar20 = 233,
	cscar17 = 127,
	cweaponp90 = 231,
	cweaponp250 = 230,
	cweaponp228 = 229,
	cweaponnegev = 227,
	cweaponmp9 = 226,
	cweaponmp7 = 225,
	cweaponmp5navy = 224,
	cweaponmag7 = 223,
	cweaponmac10 = 222,
	cweaponm4a1 = 221,
	cweaponhkp2000 = 218,
	cweaponglock = 217,
	cweapongalilar = 216,
	cweapongalil = 215,
	cweapong3sg1 = 214,
	cweaponfiveseven = 213,
	cweaponfamas = 212,
	cweaponbizon = 207,
	cweaponawp = 205,
	cweaponaug = 204,
	cak47 = 1,
	cweaponcsbasegun = 209,
	cweaponcsbase = 208,
	cc4 = 29,
	cweaponbaseitem = 206,
	cbasecsgrenade = 8,
	csmokegrenadeprojectile = 134,
	csensorgrenadeprojectile = 130,
	cmolotovprojectile = 98,
	citem_healthshot = 91,
	citemdogtags = 92,
	cdecoyprojectile = 41,
	cfirecrackerblast = 62,
	cinferno = 88,
	cchicken = 31,
	cfootstepcontrol = 68,
	ccsgamerulesproxy = 34,
	cweaponcubemap = 0,
	cweaponcycler = 210,
	cteplantbomb = 183,
	ctefirebullets = 170,
	cteradioicon = 187,
	cplantedc4 = 108,
	ccsteam = 38,
	ccsplayerresource = 36,
	ccsplayer = 35,
	ccsragdoll = 37,
	cteplayeranimevent = 184,
	chostage = 85,
	chostagecarriableprop = 86,
	cbasecsgrenadeprojectile = 9,
	chandletest = 83,
	cteamplayroundbasedrulesproxy = 146,
	cspritetrail = 140,
	cspriteoriented = 139,
	csprite = 138,
	cragdollpropattached = 125,
	cragdollprop = 124,
	cpredictedviewmodel = 118,
	cposecontroller = 114,
	cgamerulesproxy = 82,
	cinfoladderdismount = 89,
	cfuncladder = 74,
	ctefoundryhelpers = 173,
	cenvdetailcontroller = 52,
	cworld = 245,
	cwaterlodcontrol = 203,
	cwaterbullet = 202,
	cvotecontroller = 201,
	cvguiscreen = 200,
	cpropjeep = 121,
	cpropvehiclechoreogeneric = 0,
	ctriggersoundoperator = 199,
	cbasevphysicstrigger = 22,
	ctriggerplayermovement = 198,
	cbasetrigger = 20,
	ctest_proxytoggle_networkable = 195,
	ctesla = 190,
	cbaseteamobjectiveresource = 17,
	cteam = 145,
	csunlightshadowcontrol = 144,
	csun = 143,
	cparticleperformancemonitor = 101,
	cspotlightend = 137,
	cspatialentity = 136,
	cslideshowdisplay = 132,
	cshadowcontrol = 131,
	csceneentity = 128,
	cropekeyframe = 126,
	cragdollmanager = 123,
	cphysicspropmultiplayer = 106,
	cphysboxmultiplayer = 104,
	cpropdoorrotating = 120,
	cbasepropdoor = 16,
	cdynamicprop = 43,
	cprop_hallucination = 119,
	cpostprocesscontroller = 115,
	cpointworldtext = 113,
	cpointcommentarynode = 112,
	cpointcamera = 111,
	cplayerresource = 110,
	cplasma = 109,
	cphysmagnet = 107,
	cphysicsprop = 105,
	cstatueprop = 141,
	cphysbox = 103,
	cparticlesystem = 102,
	cmoviedisplay = 99,
	cmaterialmodifycontrol = 96,
	clightglow = 95,
	citemassaultsuituseable = 0,
	citem = 0,
	cinfooverlayaccessor = 90,
	cfunctracktrain = 81,
	cfuncsmokevolume = 80,
	cfuncrotating = 79,
	cfuncreflectiveglass = 78,
	cfuncoccluder = 77,
	cfuncmovelinear = 76,
	cfuncmonitor = 75,
	cfunc_lod = 70,
	ctedust = 165,
	cfunc_dust = 69,
	cfuncconveyor = 73,
	cfuncbrush = 72,
	cbreakablesurface = 28,
	cfuncareaportalwindow = 71,
	cfish = 65,
	cfiresmoke = 63,
	cenvtonemapcontroller = 59,
	cenvscreeneffect = 57,
	cenvscreenoverlay = 58,
	cenvprojectedtexture = 55,
	cenvparticlescript = 54,
	cfogcontroller = 67,
	cenvdofcontroller = 53,
	ccascadelight = 30,
	cenvambientlight = 51,
	centityparticletrail = 50,
	centityfreezing = 49,
	centityflame = 48,
	centitydissolve = 47,
	cdynamiclight = 42,
	ccolorcorrectionvolume = 33,
	ccolorcorrection = 32,
	cbreakableprop = 27,
	cbeamspotlight = 25,
	cbasebutton = 5,
	cbasetoggle = 19,
	cbaseplayer = 15,
	cbaseflex = 12,
	cbaseentity = 11,
	cbasedoor = 10,
	cbasecombatcharacter = 6,
	cbaseanimatingoverlay = 3,
	cbonefollower = 26,
	cbaseanimating = 2,
	cai_basenpc = 0,
	cbeam = 24,
	cbaseviewmodel = 21,
	cbaseparticleentity = 14,
	cbasegrenade = 13,
	cbasecombatweapon = 7,
	cbaseweaponworldmodel = 23
};

class client_class {
public:
	create_client_class_fn create_fn;
	create_event_fn create_event_fn;
	char* network_name;
	recv_table* recvtable_ptr;
	client_class* next_ptr;
	class_ids class_id;
};
```

`source-sdk/classes/collideable.hpp`:

```hpp
#pragma once

class collideable_t {
public:
	vec3_t & mins( ) {
		using original_fn = vec3_t & ( __thiscall* )( void* );
		return ( *( original_fn** ) this ) [ 1 ]( this );
	}
	vec3_t& maxs( ) {
		using original_fn = vec3_t & ( __thiscall* )( void* );
		return ( *( original_fn** ) this ) [ 2 ]( this );
	}
};
```

`source-sdk/classes/convar.hpp`:

```hpp
#pragma once
#include <vector>

class convar;
using fn_change_callback_t = void( *)( convar* var, const char* pOldValue, float flOldValue );

inline int UtlMemory_CalcNewAllocationCount( int nAllocationCount, int nGrowSize, int nNewSize, int nBytesItem ) {
	if ( nGrowSize )
		nAllocationCount = ( ( 1 + ( ( nNewSize - 1 ) / nGrowSize ) ) * nGrowSize );
	else {
		if ( !nAllocationCount )
			nAllocationCount = ( 31 + nBytesItem ) / nBytesItem;

		while ( nAllocationCount < nNewSize )
			nAllocationCount *= 2;
	}

	return nAllocationCount;
}

template< class T, class I = int >
class CUtlMemory {
public:
	T & operator[]( I i ) {
		return m_pMemory [ i ];
	}

	T* Base( ) {
		return m_pMemory;
	}

	int NumAllocated( ) const {
		return m_nAllocationCount;
	}

	bool IsExternallyAllocated( ) const {
		return m_nGrowSize < 0;
	}

protected:
	T * m_pMemory;
	int m_nAllocationCount;
	int m_nGrowSize;
};

template <class T>
inline T* Construct( T* pMemory ) {
	return ::new( pMemory ) T;
}

template <class T>
inline void Destruct( T* pMemory ) {
	pMemory->~T( );
}

template< class T, class A = CUtlMemory<T> >
class CUtlVector {
	typedef A CAllocator;
public:
	T & operator[]( int i ) {
		return m_Memory [ i ];
	}

	T& Element( int i ) {
		return m_Memory [ i ];
	}

	T* Base( ) {
		return m_Memory.Base( );
	}

	int Count( ) const {
		return m_Size;
	}

	void RemoveAll( ) {
		for ( int i = m_Size; --i >= 0; )
			Destruct( &Element( i ) );

		m_Size = 0;
	}

	int AddToTail( ) {
		return InsertBefore( m_Size );
	}

	void SetSize( int size ) {
		m_Size = size;
	}

	int InsertBefore( int elem ) {
		GrowVector( );
		ShiftElementsRight( elem );
		Construct( &Element( elem ) );

		return elem;
	}

protected:
	void GrowVector( int num = 1 ) {
		if ( m_Size + num > m_Memory.NumAllocated( ) )
			m_Memory.Grow( m_Size + num - m_Memory.NumAllocated( ) );

		m_Size += num;
		ResetDbgInfo( );
	}

	void ShiftElementsRight( int elem, int num = 1 ) {
		int numToMove = m_Size - elem - num;
		if ( ( numToMove > 0 ) && ( num > 0 ) )
			memmove( &Element( elem + num ), &Element( elem ), numToMove * sizeof( T ) );
	}

	CAllocator m_Memory;
	int m_Size;

	T* m_pElements;

	inline void ResetDbgInfo( ) {
		m_pElements = Base( );
	}
};

enum cvar_flags {
	fcvar_none = 0,
	fcvar_unregistered = ( 1 << 0 ),
	fcvar_developmentonly = ( 1 << 1 ),
	fcvar_gamedll = ( 1 << 2 ),
	fcvar_clientdll = ( 1 << 3 ),
	fcvar_hidden = ( 1 << 4 ),
	fcvar_protected = ( 1 << 5 ),
	fcvar_sponly = ( 1 << 6 ),
	fcvar_archive = ( 1 << 7 ),
	fcvar_notify = ( 1 << 8 ),
	fcvar_userinfo = ( 1 << 9 ),
	fcvar_printableonly = ( 1 << 10 ),
	fcvar_unlogged = ( 1 << 11 ),
	fcvar_never_as_string = ( 1 << 12 ),
	fcvar_replicated = ( 1 << 13 ),
	fcvar_cheat = ( 1 << 14 ),
	fcvar_ss = ( 1 << 15 ),
	fcvar_demo = ( 1 << 16 ),
	fcvar_dontrecord = ( 1 << 17 ),
	fcvar_ss_added = ( 1 << 18 ),
	fcvar_release = ( 1 << 19 ),
	fcvar_reload_materials = ( 1 << 20 ),
	fcvar_reload_textures = ( 1 << 21 ),
	fcvar_not_connected = ( 1 << 22 ),
	fcvar_material_system_thread = ( 1 << 23 ),
	fcvar_archive_xbox = ( 1 << 24 ),
	fcvar_accessible_from_threads = ( 1 << 25 ),
	fcvar_server_can_execute = ( 1 << 28 ),
	fcvar_server_cannot_query = ( 1 << 29 ),
	fcvar_clientcmd_can_execute = ( 1 << 30 ),
	fcvar_meme_dll = ( 1 << 31 ),
	fcvar_material_thread_mask = ( fcvar_reload_materials | fcvar_reload_textures | fcvar_material_system_thread )
};

class convar {
public:
	void set_value( const char* value ) {
		using original_fn = void( __thiscall* )( convar*, const char* );
		return ( *( original_fn** ) this ) [ 14 ]( this, value );
	}
	void set_value( float value ) {
		using original_fn = void( __thiscall* )( convar*, float );
		return ( *( original_fn** ) this ) [ 15 ]( this, value );
	}
	void set_value( int value ) {
		using original_fn = void( __thiscall* )( convar*, int );
		return ( *( original_fn** ) this ) [ 16 ]( this, value );
	}
	void set_value( bool value ) {
		using original_fn = void( __thiscall* )( convar*, int );
		return ( *( original_fn** ) this ) [ 16 ]( this, static_cast< int >( value ) );
	}

private:
	char pad_0x0000 [ 0x4 ];

public:
	convar * next;
	__int32 is_registered;
	char* name;
	char* help_string;
	__int32 flags;

private:
	char pad_0x0018 [ 0x4 ];

public:
	convar * parent;
	char* default_value;
	char* string;
	__int32 string_length;
	float float_value;
	__int32 numerical_value;
	__int32 has_min;
	float min;
	__int32 has_max;
	float max;
	CUtlVector<fn_change_callback_t> callbacks;
};
```

`source-sdk/classes/entities.hpp`:

```hpp
#pragma once
#include "collideable.hpp"

enum entity_flags {
	fl_onground = ( 1 << 0 ),
	fl_ducking = ( 1 << 1 ),
	fl_waterjump = ( 1 << 2 ),
	fl_ontrain = ( 1 << 3 ),
	fl_inrain = ( 1 << 4 ),
	fl_frozen = ( 1 << 5 ),
	fl_atcontrols = ( 1 << 6 ),
	fl_client = ( 1 << 7 ),
	fl_fakeclient = ( 1 << 8 ),
	fl_inwater = ( 1 << 9 ),
	fl_fly = ( 1 << 10 ),
	fl_swim = ( 1 << 11 ),
	fl_conveyor = ( 1 << 12 ),
	fl_npc = ( 1 << 13 ),
	fl_godmode = ( 1 << 14 ),
	fl_notarget = ( 1 << 15 ),
	fl_aimtarget = ( 1 << 16 ),
	fl_partialground = ( 1 << 17 ),
	fl_staticprop = ( 1 << 18 ),
	fl_graphed = ( 1 << 19 ),
	fl_grenade = ( 1 << 20 ),
	fl_stepmovement = ( 1 << 21 ),
	fl_donttouch = ( 1 << 22 ),
	fl_basevelocity = ( 1 << 23 ),
	fl_worldbrush = ( 1 << 24 ),
	fl_object = ( 1 << 25 ),
	fl_killme = ( 1 << 26 ),
	fl_onfire = ( 1 << 27 ),
	fl_dissolving = ( 1 << 28 ),
	fl_transragdoll = ( 1 << 29 ),
	fl_unblockable_by_player = ( 1 << 30 )
};

enum item_definition_indexes {
	item_none = 0,
	weapon_deagle = 1,
	weapon_duals = 2,
	weapon_five7 = 3,
	weapon_glock = 4,
	weapon_ak47 = 7,
	weapon_aug = 8,
	weapon_awp = 9,
	weapon_famas = 10,
	weapon_g3sg1 = 11,
	weapon_galil = 13,
	weapon_m249 = 14,
	weapon_m4a1 = 16,
	weapon_mac10 = 17,
	weapon_p90 = 19,
	weapon_ump45 = 24,
	weapon_xm1014 = 25,
	weapon_bizon = 26,
	weapon_mag7 = 27,
	weapon_negev = 28,
	weapon_sawedoff = 29,
	weapon_tec9 = 30,
	weapon_taser = 31,
	weapon_p2000 = 32,
	weapon_mp7 = 33,
	weapon_mp9 = 34,
	weapon_nova = 35,
	weapon_p250 = 36,
	weapon_scar20 = 38,
	weapon_sg553 = 39,
	weapon_scout = 40,
	weapon_knife_t = 42,
	weapon_flash = 43,
	weapon_he = 44,
	weapon_smoke = 45,
	weapon_molotov = 46,
	weapon_decoy = 47,
	weapon_inc = 48,
	weapon_c4 = 49,
	weapon_knife_ct = 59,
	weapon_m4a1s = 60,
	weapon_usps = 61,
	weapon_cz75 = 63,
	weapon_revolver = 64,
	weapon_knife_bayonet = 500,
	weapon_knife_flip = 505,
	weapon_knife_gut = 506,
	weapon_knife_karambit = 507,
	weapon_knife_m9bayonet = 508,
	weapon_knife_huntsman = 509,
	weapon_knife_falchion = 512,
	weapon_knife_bowie = 514,
	weapon_knife_butterfly = 515,
	weapon_knife_dagger = 516,
	weapon_max
};

class entity_t {
public:
	void* animating( ) {
		return reinterpret_cast< void* >( uintptr_t( this ) + 0x4 );
	}

	void* networkable( ) {
		return reinterpret_cast< void* >( uintptr_t( this ) + 0x8 );
	}

	collideable_t* collideable( ) {
		using original_fn = collideable_t * ( __thiscall* )( void* );
		return ( *( original_fn** ) this )[ 3 ]( this );
	}

	client_class* clientclass( ) {
		using original_fn = client_class * ( __thiscall* )( void* );
		return ( *( original_fn** ) networkable( ) )[ 2 ]( networkable( ) );
	}

	bool is_player( ) {
		using original_fn = bool( __thiscall* )( entity_t* );
		return ( *( original_fn** ) this )[ 152 ]( this );
	}

	bool is_weapon( ) {
		using original_fn = bool( __thiscall* )( entity_t* );
		return ( *( original_fn** ) this )[ 160 ]( this );
	}

	bool setup_bones( matrix_t* out, int max_bones, int mask, float time ) {
		using original_fn = bool( __thiscall* )( void*, matrix_t*, int, int, float );
		return ( *( original_fn** ) animating( ) )[ 13 ]( animating( ), out, max_bones, mask, time );
	}

	model_t* model( ) {
		using original_fn = model_t * ( __thiscall* )( void* );
		return ( *( original_fn** ) animating( ) )[ 8 ]( animating( ) );
	}

	void update( ) {
		using original_fn = void( __thiscall* )( entity_t* );
		( *( original_fn** ) this )[ 218 ]( this );
	}

	int draw_model( int flags, uint8_t alpha ) {
		using original_fn = int( __thiscall* )( void*, int, uint8_t );
		return ( *( original_fn** ) animating( ) )[ 9 ]( animating( ), flags, alpha );
	}

	void set_angles( vec3_t angles ) {
		using original_fn = void( __thiscall* )( void*, const vec3_t& );
		static original_fn set_angles_fn = ( original_fn ) ( ( DWORD ) utilities::pattern_scan( GetModuleHandleA( "client_panorama.dll" ), "55 8B EC 83 E4 F8 83 EC 64 53 56 57 8B F1" ) );
		set_angles_fn( this, angles );
	}

	void set_position( vec3_t position ) {
		using original_fn = void( __thiscall* )( void*, const vec3_t& );
		static original_fn set_position_fn = ( original_fn ) ( ( DWORD ) utilities::pattern_scan( GetModuleHandleA( "client_panorama.dll" ), "55 8B EC 83 E4 F8 51 53 56 57 8B F1 E8" ) );
		set_position_fn( this, position );
	}

	netvar_fn( int, flags, "DT_BasePlayer->m_fFlags" );
	netvar_fn( unsigned long, owner_handle, "DT_BaseEntity->m_hOwnerEntity" );
	offset_fn( bool, dormant, 0xE9 );
	netvar_fn( float, simulation_time, "DT_BaseEntity->m_flSimulationTime" );
	offset_fn( vec3_t, origin, 0x134 );
	offset_fn( vec3_t, view_offset, 0x104 );
	netvar_fn( int, team, "DT_BaseEntity->m_iTeamNum" );
	netvar_fn( bool, spotted, "DT_BaseEntity->m_bSpotted" );
};

class viewmodel_t : public entity_t {
public:
	netvar_ptr_fn( int, model_index, "DT_BaseViewModel->m_nModelIndex" );
	netvar_ptr_fn( int, viewmodel_index, "DT_BaseViewModel->m_nViewModelIndex" );
};

class weapon_t : public entity_t {
public:
	netvar_fn( float, next_primary_attack, "DT_BaseCombatWeapon->m_flNextPrimaryAttack" );
	netvar_fn( float, next_secondary_attack, "DT_BaseCombatWeapon->m_flNextSecondaryAttack" );
	netvar_fn( int, clip1_count, "DT_BaseCombatWeapon->m_iClip1" );
	netvar_fn( int, clip2_count, "DT_BaseCombatWeapon->m_iClip2" );
	netvar_fn( float, recoil_index, "DT_WeaponCSBase->m_flRecoilIndex" );

	float get_innacuracy( ) {
		using original_fn = float( __thiscall* )( void* );
		return ( *( original_fn** ) this )[ 479 ]( this );
	}

	float get_spread( ) {
		using original_fn = float( __thiscall* )( void* );
		return ( *( original_fn** ) this )[ 449 ]( this );
	}

	void update_accuracy_penalty( ) {
		using original_fn = void( __thiscall* )( void* );
		( *( original_fn** ) this )[ 480 ]( this );
	}

	weapon_info_t* get_weapon_data( ) {
		using original_fn = weapon_info_t * ( __thiscall* )( void* );
		static original_fn return_func = ( original_fn ) ( ( DWORD ) utilities::pattern_scan( GetModuleHandleA( "client_panorama.dll" ), "55 8B EC 81 EC ? ? ? ? 53 8B D9 56 57 8D 8B" ) );

		return return_func( this );

	}

	bool is_knife( ) {
		return clientclass( )->class_id == cknife || clientclass( )->class_id == cknifegg;
	}
};

class econ_view_item_t {
public:
	netvar_offset_fn( bool, is_initialized, "DT_ScriptCreatedItem->m_bInitialized", g_netvar_mgr.get_offset( fnv_hash( "DT_AttributeContainer->m_Item" ) ) + g_netvar_mgr.get_offset( fnv_hash( "DT_BaseAttributableItem->m_AttributeManager" ) ) );
	netvar_offset_fn( short, item_definition_index, "DT_ScriptCreatedItem->m_iItemDefinitionIndex", g_netvar_mgr.get_offset( fnv_hash( "DT_AttributeContainer->m_Item" ) ) + g_netvar_mgr.get_offset( fnv_hash( "DT_BaseAttributableItem->m_AttributeManager" ) ) );
	netvar_offset_fn( int, entity_level, "DT_ScriptCreatedItem->m_iEntityLevel", g_netvar_mgr.get_offset( fnv_hash( "DT_AttributeContainer->m_Item" ) ) + g_netvar_mgr.get_offset( fnv_hash( "DT_BaseAttributableItem->m_AttributeManager" ) ) );
	netvar_offset_fn( int, account_id, "DT_ScriptCreatedItem->m_iAccountID", g_netvar_mgr.get_offset( fnv_hash( "DT_AttributeContainer->m_Item" ) ) + g_netvar_mgr.get_offset( fnv_hash( "DT_BaseAttributableItem->m_AttributeManager" ) ) );
	netvar_offset_fn( int, item_id_low, "DT_ScriptCreatedItem->m_iItemIDLow", g_netvar_mgr.get_offset( fnv_hash( "DT_AttributeContainer->m_Item" ) ) + g_netvar_mgr.get_offset( fnv_hash( "DT_BaseAttributableItem->m_AttributeManager" ) ) );
	netvar_offset_fn( int, item_id_high, "DT_ScriptCreatedItem->m_iItemIDHigh", g_netvar_mgr.get_offset( fnv_hash( "DT_AttributeContainer->m_Item" ) ) + g_netvar_mgr.get_offset( fnv_hash( "DT_BaseAttributableItem->m_AttributeManager" ) ) );
	netvar_offset_fn( int, entity_quality, "DT_ScriptCreatedItem->m_iEntityQuality", g_netvar_mgr.get_offset( fnv_hash( "DT_AttributeContainer->m_Item" ) ) + g_netvar_mgr.get_offset( fnv_hash( "DT_BaseAttributableItem->m_AttributeManager" ) ) );
};

class attributable_item_t : public entity_t {
public:
	netvar_fn( unsigned long, original_owner_xuid, "DT_BaseAttributableItem->m_OriginalOwnerXuidLow" );
	netvar_fn( int, original_owner_xuid_low, "DT_BaseAttributableItem->m_OriginalOwnerXuidLow" );
	netvar_fn( int, original_owner_xuid_high, "DT_BaseAttributableItem->m_OriginalOwnerXuidHigh" );
	netvar_fn( int, fallback_stattrak, "DT_BaseAttributableItem->m_nFallbackStatTrak" );
	netvar_fn( int, fallback_paint_kit, "DT_BaseAttributableItem->m_nFallbackPaintKit" );
	netvar_fn( int, fallback_seed, "DT_BaseAttributableItem->m_nFallbackSeed" );
	netvar_fn( float, fallback_wear, "DT_BaseAttributableItem->m_flFallbackWear" );
	netvar_fn( unsigned long, world_model_handle, "DT_BaseCombatWeapon->m_hWeaponWorldModel" );

	econ_view_item_t& item( ) {
		return *( econ_view_item_t* ) this;
	}
};

class player_t : public entity_t {
public:
	netvar_fn( bool, has_defuser, "DT_CSPlayer->m_bHasDefuser" );
	netvar_fn( bool, has_gun_game_immunity, "DT_CSPlayer->m_bGunGameImmunity" );
	netvar_fn( int, shots_fired, "DT_CSPlayer->m_iShotsFired" );
	netvar_fn( vec3_t, eye_angles, "DT_CSPlayer->m_angEyeAngles[0]" );
	netvar_fn( int, armor, "DT_CSPlayer->m_ArmorValue" );
	netvar_fn( bool, has_helmet, "DT_CSPlayer->m_bHasHelmet" );
	netvar_fn( bool, is_scoped, "DT_CSPlayer->m_bIsScoped" );;
	netvar_fn( float, lower_body_yaw, "DT_CSPlayer->m_flLowerBodyYawTarget" );
	netvar_fn( float, flash_duration, "DT_CSPlayer->m_flFlashDuration" );
	netvar_fn( int, health, "DT_BasePlayer->m_iHealth" );
	netvar_fn( int, life_state, "DT_BasePlayer->m_lifeState" );
	netvar_fn( int, flags, "DT_BasePlayer->m_fFlags" );
	netvar_fn( int, tick_base, "DT_BasePlayer->m_nTickBase" );
	netvar_fn( vec3_t, punch_angle, "DT_BasePlayer->m_viewPunchAngle" );
	netvar_fn( vec3_t, aim_punch_angle, "DT_BasePlayer->m_aimPunchAngle" );
	netvar_fn( vec3_t, velocity, "DT_BasePlayer->m_vecVelocity[0]" );
	netvar_fn( float, max_speed, "DT_BasePlayer->m_flMaxspeed" );
	netvar_fn( unsigned long, observer_target, "DT_BasePlayer->m_hObserverTarget" );
	netvar_fn( unsigned long, active_weapon_handle, "DT_BaseCombatCharacter->m_hActiveWeapon" );

	weapon_t* active_weapon( void ) {
		uintptr_t handle = active_weapon_handle( );
		return ( weapon_t* ) interfaces::entity_list->get_client_entity( handle );
	}

	int* weapons( ) {
		return ( int* ) ( uintptr_t( this ) + 0x2DE8 );
	}
};
```

`source-sdk/classes/gameevent.hpp`:

```hpp
#pragma once

class game_event {
public:
	const char* get_name( ) {
		using original_fn = const char*( __thiscall* )( game_event* );
		return ( *( original_fn** ) this ) [ 1 ]( this );
	}
	int get_int( const char* name ) {
		using original_fn = int( __thiscall* )( game_event*, const char*, int );
		return ( *( original_fn** ) this ) [ 6 ]( this, name, 0 );
	}
};

class game_event_listener {
public:
	virtual ~game_event_listener( ) { }

	virtual void fire_game_event( game_event* event ) = 0;
	virtual int get_debug_id( ) = 0;

public:
	int debug_id;
};
```

`source-sdk/classes/recv_props.hpp`:

```hpp
#pragma once

class d_variant;
class recv_table;
class recv_prop;
class c_recv_proxy_data;

using recv_var_proxy_fn = void( *)( const c_recv_proxy_data* data, void* struct_ptr, void* out_ptr );
using array_length_recv_proxy_fn = void( *)( void* struct_ptr, int object_id, int current_array_length );
using data_table_recv_var_proxy_fn = void( *)( const recv_prop* prop, void** out_ptr, void* data_ptr, int object_id );

enum send_prop_type {
	_int = 0,
	_float,
	_vec,
	_vec_xy,
	_string,
	_array,
	_data_table,
	_int_64,
};
class d_variant {
public:
	union {
		float m_float;
		long m_int;
		char* m_string;
		void* m_data;
		float m_vector [ 3 ];
		__int64 m_int64;
	};
	send_prop_type type;
};
class c_recv_proxy_data {
public:
	const recv_prop* recv_prop;
	d_variant value;
	int element_index;
	int object_id;
};
class recv_prop {
public:
	char* prop_name;
	send_prop_type prop_type;
	int prop_flags;
	int buffer_size;
	int is_inside_of_array;
	const void* extra_data_ptr;
	recv_prop* array_prop;
	array_length_recv_proxy_fn array_length_proxy;
	recv_var_proxy_fn proxy_fn;
	data_table_recv_var_proxy_fn data_table_proxy_fn;
	recv_table* data_table;
	int offset;
	int element_stride;
	int elements_count;
	const char* parent_array_prop_name;
};
class recv_table {
public:
	recv_prop * props;
	int props_count;
	void* decoder_ptr;
	char* table_name;
	bool is_initialized;
	bool is_in_main_list;
};
```

`source-sdk/classes/studio.hpp`:

```hpp
#pragma once
#include <cstdint>

using quaternion = float [ 4 ];
using rad_euler = float [ 3 ];

enum bone_flags {
	bone_calculate_mask = 0x1f,
	bone_physically_simulated = 0x01,
	bone_physics_procedural = 0x02,
	bone_always_procedural = 0x04,
	bone_screen_align_sphere = 0x08,
	bone_screen_align_cylinder = 0x10,
	bone_used_mask = 0x0007ff00,
	bone_used_by_anything = 0x0007ff00,
	bone_used_by_hitbox = 0x00000100,
	bone_used_by_attachment = 0x00000200,
	bone_used_by_vertex_mask = 0x0003fc00,
	bone_used_by_vertex_lod0 = 0x00000400,
	bone_used_by_vertex_lod1 = 0x00000800,
	bone_used_by_vertex_lod2 = 0x00001000,
	bone_used_by_vertex_lod3 = 0x00002000,
	bone_used_by_vertex_lod4 = 0x00004000,
	bone_used_by_vertex_lod5 = 0x00008000,
	bone_used_by_vertex_lod6 = 0x00010000,
	bone_used_by_vertex_lod7 = 0x00020000,
	bone_used_by_bone_merge = 0x00040000,
	bone_type_mask = 0x00f00000,
	bone_fixed_alignment = 0x00100000,
	bone_has_saveframe_pos = 0x00200000,
	bone_has_saveframe_rot = 0x00400000
};

enum hitgroups {
	hitgroup_generic = 0,
	hitgroup_head = 1,
	hitgroup_chest = 2,
	hitgroup_stomach = 3,
	hitgroup_leftarm = 4,
	hitgroup_rightarm = 5,
	hitgroup_leftleg = 6,
	hitgroup_rightleg = 7,
	hitgroup_gear = 10
};

enum modtypes {
	mod_bad = 0,
	mod_brush,
	mod_sprite,
	mod_studio
};

enum hitboxes {
	hitbox_head,
	hitbox_neck,
	hitbox_lower_neck,
	hitbox_pelvis,
	hitbox_stomach,
	hitbox_lower_chest,
	hitbox_chest,
	hitbox_upper_chest,
	hitbox_right_thigh,
	hitbox_left_thigh,
	hitbox_right_calf,
	hitbox_left_calf,
	hitbox_right_foot,
	hitbox_left_foot,
	hitbox_right_hand,
	hitbox_left_hand,
	hitbox_right_upper_arm,
	hitbox_right_forearm,
	hitbox_left_upper_arm,
	hitbox_left_forearm,
	hitbox_max
};

struct studio_bone_t {
	int name_index;
	inline char *const name( void ) const {
		return ( ( char* ) this ) + name_index;
	}
	int parent;
	int bone_controller [ 6 ];

	vec3_t pos;
	quaternion quat;
	rad_euler rotation;

	vec3_t pos_scale;
	vec3_t rot_scale;

	matrix_t pose_to_bone;
	quaternion quat_alignement;
	int flags;
	int proc_type;
	int proc_index;
	mutable int physics_bone;

	inline void *procedure( ) const {
		if ( proc_index == 0 ) return NULL;
		else return( void * ) ( ( ( unsigned char* ) this ) + proc_index );
	};

	int surface_prop_idx;
	inline char *const surface_prop( void ) const {
		return ( ( char* ) this ) + surface_prop_idx;
	}
	inline int get_surface_prop( void ) const {
		return surf_prop_lookup;
	}

	int contents;
	int surf_prop_lookup;
	int unused [ 7 ];
};

struct studio_box_t {
	int bone;
	int group;
	vec3_t mins;
	vec3_t maxs;
	int name_index;
	int pad01 [ 3 ];
	float radius;
	int pad02 [ 4 ];
};

struct studio_hitbox_set_t {
	int name_index;
	int hitbox_count;
	int hitbox_index;

	inline char *const name( void ) const {
		return ( ( char* ) this ) + name_index;
	}
	inline studio_box_t *hitbox( int i ) const {
		return ( studio_box_t* ) ( ( ( unsigned char* ) this ) + hitbox_index ) + i;
	}
};

class studio_hdr_t {
public:
	int id;
	int version;
	long checksum;
	char name_char_array [ 64 ];
	int length;
	vec3_t eye_pos;
	vec3_t illium_pos;
	vec3_t hull_mins;
	vec3_t hull_maxs;
	vec3_t mins;
	vec3_t maxs;
	int flags;
	int bones_count;
	int bone_index;
	int bone_controllers_count;
	int bone_controller_index;
	int hitbox_sets_count;
	int hitbox_set_index;
	int local_anim_count;
	int local_anim_index;
	int local_seq_count;
	int local_seq_index;
	int activity_list_version;
	int events_indexed;
	int textures_count;
	int texture_index;

	studio_hitbox_set_t* hitbox_set( int i ) {
		if ( i > hitbox_sets_count ) return nullptr;
		return ( studio_hitbox_set_t* ) ( ( uint8_t* ) this + hitbox_set_index ) + i;
	}
	studio_bone_t* bone( int i ) {
		if ( i > bones_count ) return nullptr;
		return ( studio_bone_t* ) ( ( uint8_t* ) this + bone_index ) + i;
	}

};
```

`source-sdk/math/vector2d.hpp`:

```hpp
#pragma once

#include "vector3d.hpp"
class vec2_t {
public:
	float x, y;

	vec2_t() {
		x = 0; y = 0;
	};
	vec2_t(float X, float Y) {
		x = X; y = Y;
	};
	vec2_t(vec3_t vec) {
		x = vec.x; y = vec.y;
	}

	inline vec2_t operator*(const float n) const {
		return vec2_t(x*n, y*n);
	}
	inline vec2_t operator+(const vec2_t& v) const {
		return vec2_t(x + v.x, y + v.y);
	}
	inline vec2_t operator-(const vec2_t& v) const {
		return vec2_t(x - v.x, y - v.y);
	}
	inline void operator+=(const vec2_t& v) {
		x += v.x;
		y += v.y;
	}
	inline void operator-=(const vec2_t& v) {
		x -= v.x;
		y -= v.y;
	}

	bool operator==(const vec2_t& v) const {
		return (v.x == x && v.y == y);
	}
	bool operator!=(const vec2_t& v) const {
		return (v.x != x || v.y != y);
	}

	inline float length() {
		return sqrt((x * x) + (y * y));
	}
};

```

`source-sdk/math/vector3d.cpp`:

```cpp
#include "vector3d.hpp"
#include <cmath>

vec3_t::vec3_t( void ) {
	x = y = z = 0.0f;
}

vec3_t::vec3_t( float fx, float fy, float fz ) {
	x = fx;
	y = fy;
	z = fz;
}

vec3_t::~vec3_t( void ) {

};

void vec3_t::clamp( void ) {
	x = clip_number( x, -89.0f, 89.0f );
	y = clip_number( std::remainder( y, 360.0f ), -180.0f, 180.0f );
	z = clip_number( z, -50.0f, 50.0f );
}

void vec3_t::normalize( void ) {
	auto vec_normalize = [ & ] ( vec3_t& v ) {
		auto l = v.length( );

		if ( l != 0.0f ) {
			v.x /= l;
			v.y /= l;
			v.z /= l;
		}
		else {
			v.x = v.y = 0.0f; v.z = 1.0f;
		}

		return l;
	};

	vec_normalize( *this );
}

vec3_t vec3_t::normalized( void ) {
	vec3_t vec( *this );
	vec.normalize( );

	return vec;
}

float vec3_t::length( void ) {
	float root = 0.0f, sqsr = this->length_sqr( );

	__asm        sqrtss xmm0, sqsr
	__asm        movss root, xmm0

	return root;
}

float vec3_t::length_sqr( void ) {
	auto sqr = [ ] ( float n ) {
		return static_cast< float >( n * n );
	};

	return ( sqr( x ) + sqr( y ) + sqr( z ) );
}

float vec3_t::dot( const vec3_t other ) {
	return ( x * other.x + y * other.y + z * other.z );
}
```

`source-sdk/math/vector3d.hpp`:

```hpp
#pragma once
#include <limits>

template <typename T>
T clip_number( const T& n, const T& lower, const T& upper ) {
	if ( n < lower ) return lower;
	if ( n > upper ) return upper;
	return n;
}

class vec3_t {
public:
	vec3_t( );
	vec3_t( float, float, float );
	~vec3_t( );

	float x, y, z;

	vec3_t& operator+=( const vec3_t& v ) {
		x += v.x; y += v.y; z += v.z; return *this;
	}
	vec3_t& operator-=( const vec3_t& v ) {
		x -= v.x; y -= v.y; z -= v.z; return *this;
	}
	vec3_t& operator*=( float v ) {
		x *= v; y *= v; z *= v; return *this;
	}
	vec3_t operator+( const vec3_t& v ) {
		return vec3_t { x + v.x, y + v.y, z + v.z };
	}
	vec3_t operator-( const vec3_t& v ) {
		return vec3_t { x - v.x, y - v.y, z - v.z };
	}
	vec3_t operator*( float v ) const {
		return vec3_t { x * v, y * v, z * v };
	}

	float& operator[]( int i ) {
		return ( ( float* ) this ) [ i ];
	}
	float operator[]( int i ) const {
		return ( ( float* ) this ) [ i ];
	}

	void clamp( );
	vec3_t normalized( );
	void normalize( );
	float length( );
	float length_sqr( );
	float dot( const vec3_t other );
};
typedef float matrix_t [ 3 ] [ 4 ];
```

`source-sdk/misc/color.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <d3d9.h>

struct color {
	int a, r, g, b;
	color( ) = default;
	color( int r, int g, int b, int a = 255 ) {
		this->r = r;
		this->g = g;
		this->b = b;
		this->a = a;
	}
	color( uint32_t color ) {
		this->a = ( color >> 24 ) & 0xff;
		this->r = ( color >> 16 ) & 0xff;
		this->g = ( color >> 8 ) & 0xff;
		this->b = ( color & 0xff );
	}
	color from_uint( uint32_t uint ) {
		return color( uint );
	}
	D3DCOLOR from_color( color col ) {
		return D3DCOLOR_ARGB( col.a, col.r, col.g, col.b );
	}
};
```

`source-sdk/sdk.hpp`:

```hpp
#pragma once

#include "math/vector3d.hpp"
#include "misc/color.hpp"

#include "classes/c_usercmd.hpp"
#include "classes/recv_props.hpp"
#include "classes/client_class.hpp"
#include "classes/convar.hpp"
#include "classes/studio.hpp"
#include "classes/gameevent.hpp"
#include "structs/dlight.hpp"
#include "structs/weaponinfo.hpp"

#include "classes/entities.hpp"
```

`source-sdk/structs/dlight.hpp`:

```hpp
#pragma once

enum dlight_flags {
	dlight_no_world_illumination = 0x1,
	dlight_no_model_illumination = 0x2,
	dlight_add_displacement_alpha = 0x4,
	dlight_subtract_displacement_alpha = 0x8,
	dlight_displacement_mask = ( dlight_add_displacement_alpha | dlight_subtract_displacement_alpha ),
};

struct dlight_t {
	int flags;
	vec3_t origin;
	float radius;
	color color;
	float die_time;
	float decay;
	float min_light;
	int	key;
	int	style;
	vec3_t direction;
	float inner_angle;
	float outer_angle;
};
```

`source-sdk/structs/materials.hpp`:

```hpp
#pragma once

using material_handle_t = unsigned short;
class i_material {
public:
	const char* get_name( ) {
		using original_fn = const char*( __thiscall* )( i_material* );
		return ( *( original_fn** ) this ) [ 0 ]( this );
	}
	const char* get_group_name( ) {
		using original_fn = const char*( __thiscall* )( i_material* );
		return ( *( original_fn** ) this ) [ 1 ]( this );
	}
	void set_alpha( float alpha ) {
		using original_fn = void( __thiscall* )( i_material*, float );
		return ( *( original_fn** ) this ) [ 27 ]( this, alpha );
	}
	void set_alpha( int alpha ) {
		using original_fn = void( __thiscall* )( i_material*, float );
		return ( *( original_fn** ) this ) [ 27 ]( this, static_cast< float >( alpha ) / 255.f );
	}
	void set_color( float r, float g, float b ) {
		using original_fn = void( __thiscall* )( i_material*, float, float, float );
		return ( *( original_fn** ) this ) [ 28 ]( this, r, g, b );
	}

	void set_color( int r, int g, int b ) {
		using original_fn = void( __thiscall* )( i_material*, float, float, float );
		return ( *( original_fn** ) this ) [ 28 ]( this, r / 255.f, g / 255.f, b / 255.f );
	}
	void set_color( int color32 ) {
		int r1 = ( color32 >> 16 ) & 0xff;
		int g1 = ( color32 >> 8 ) & 0xff;
		int b1 = color32 & 0xff;
		i_material::set_color( r1, g1, b1 );
	}
	void set_flag( int flag, bool on ) {
		using original_fn = void( __thiscall* )( i_material*, int, bool );
		return ( *( original_fn** ) this ) [ 29 ]( this, flag, on );
	}
};
```

`source-sdk/structs/models.hpp`:

```hpp
#pragma once
#include "../math/vector3d.hpp"

struct model_t;

struct model_render_info_t {
	vec3_t origin;
	vec3_t angles;
	char pad [ 0x4 ]; // added this
	void *renderable; // this
	const void *model; // and this
	const matrix_t* model_to_world;
	const matrix_t* lighting_offset;
	const vec3_t* lighting_origin;
	int flags;
	int entity_index;
	int skin;
	int body;
	int hitboxset;
	unsigned short instance;

	model_render_info_t( ) {
		model_to_world = NULL;
		lighting_offset = NULL;
		lighting_origin = NULL;
	}
};
```

`source-sdk/structs/vertex_t.hpp`:

```hpp
#pragma once
#include "../math/vector2d.hpp"
struct vertex_t {
	vertex_t( ) {}
	vertex_t( const vec2_t &pos, const vec2_t &coord = vec2_t( 0, 0 ) ) {
		position = pos;
		tex_coord = coord;
	}
	void initialize( const vec2_t &pos, const vec2_t &coord = vec2_t( 0, 0 ) ) {
		position = pos;
		tex_coord = coord;
	}

	vec2_t	position;
	vec2_t	tex_coord;
};

```

`source-sdk/structs/weaponinfo.hpp`:

```hpp
#pragma once

class weapon_info_t {
public:
	virtual ~weapon_info_t( ) { };

	char _0x0000[20];
	__int32 max_clip;			//0x0014 
	char _0x0018[12];
	__int32 max_reserved_ammo;	//0x0024 
	char _0x0028[96];
	char* hud_name;				//0x0088 
	char* weapon_name;			//0x008C 
	char _0x0090[60];
	__int32 type;				//0x00CC 
	__int32 price;				//0x00D0 
	__int32 reward;				//0x00D4 
	char _0x00D8[20];
	BYTE full_auto;				//0x00EC 
	char _0x00ED[3];
	__int32 damage;				//0x00F0 
	float armor_ratio;			//0x00F4 
	__int32 bullets;			//0x00F8 
	float penetration;			//0x00FC 
	char _0x0100[8];
	float range;				//0x0108 
	float range_modifier;		//0x010C 
	char _0x0110[16];
	BYTE silencer;				//0x0120 
	char _0x0121[15];
	float max_speed;			//0x0130 
	float max_speed_alt;		//0x0134 
	char _0x0138[76];
	__int32 recoil_seed;		//0x0184 
	char _0x0188[32];
};
```