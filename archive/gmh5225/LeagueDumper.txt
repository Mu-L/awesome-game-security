Project Path: arc_gmh5225_LeagueDumper_ke8ucuau

Source Tree:

```txt
arc_gmh5225_LeagueDumper_ke8ucuau
├── Debug
│   ├── pd.ilk
│   └── pd.pdb
├── LICENSE
├── README.md
├── Release
│   ├── pd.iobj
│   ├── pd.ipdb
│   └── pd.pdb
├── pd
│   ├── DynArray.h
│   ├── ReadMe.txt
│   ├── close_watcher.cpp
│   ├── close_watcher.h
│   ├── dirent.h
│   ├── dump_process.cpp
│   ├── dump_process.h
│   ├── export_list.cpp
│   ├── export_list.h
│   ├── hash.cpp
│   ├── hash.h
│   ├── module_list.cpp
│   ├── module_list.h
│   ├── pd.cpp
│   ├── pd.vcproj
│   ├── pd.vcxproj
│   ├── pd.vcxproj.filters
│   ├── pd.vcxproj.user
│   ├── pe_exports.cpp
│   ├── pe_exports.h
│   ├── pe_hash_database.cpp
│   ├── pe_hash_database.h
│   ├── pe_header.cpp
│   ├── pe_header.h
│   ├── pe_imports.cpp
│   ├── pe_imports.h
│   ├── simple.cpp
│   ├── simple.h
│   ├── stdafx.cpp
│   ├── stdafx.h
│   ├── stream_wrapper.h
│   ├── targetver.h
│   ├── terminate_monitor_hook.cpp
│   ├── terminate_monitor_hook.h
│   ├── utils.h
│   └── work_queue.h
└── pd.sln

```

`LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2015 Geoff McDonald

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


```

`README.md`:

```md
Edited to fit League of Legends new Anti-Cheat system.


# Process Dump
Process Dump is a Windows reverse-engineering command-line tool to dump malware memory components back to disk for analysis. Often malware files are packed and obfuscated before they are executed in order to avoid AV scanners, however when these files are executed they will often unpack or inject a clean version of the malware code in memory. A common task for malware researchers when analyzing malware is to dump this unpacked code back from memory to disk for scanning with AV products or for analysis with static analysis tools such as IDA.

Process Dump works for Windows 32 and 64 bit operating systems and can dump memory components from specific processes or from all processes currently running. Process Dump supports creation and use of a clean-hash database, so that dumping of all the clean files such as kernel32.dll can be skipped. It's main features include:
* Dumps code from a specific process or all processes.
* Finds and dumps hidden modules that are not properly loaded in processes.
* Finds and dumps loose code chunks even if they aren't associated with a PE file. It builds a PE header and import table for the chunks.
* Reconstructs imports using an aggressive approach.
* Can run in close dump monitor mode ('-closemon'), where processes will be paused and dumped just before they terminate.
* Multi-threaded, so when you are dumping all running processes it will go pretty quickly.
* Can generate a clean hash database. Generate this before a machine is infected with malware so Process Dump will only dump the new malicious malware components.

I'm maintaining an official compiled release on my website here:
  http://split-code.com/processdump.html

# Installation
You can download the latest compiled release of Process Dump here:

This tool requires Microsoft Visual C++ Redistributable for Visual Studio 2015 to be installed to work:
* https://www.microsoft.com/en-ca/download/details.aspx?id=48145

# Compiling source code
This is designed for Visual Studio 2015 and works with the free Community edition. Just open the project file with VS2015 and compile, it should be that easy!


# Example Usage
Dump all modules and hidden code chunks from all processes on your system (ignoring known clean modules):
* pd64.exe -system

Run in terminate monitor mode. Until cancelled (CTRL-C), Process Dump will dump any process just before the termination:
* pd64.exe -closemon

Dump all modules and hidden code chunks from a specific process identifier:
* pd64.exe -pid 0x18A

Dump all modules and hidden code chunk by process name:
* pd64.exe -p .\*chrome.\*

Build clean-hash database. These hashes will be used to exclude modules from dumping with the above commands:
* pd64.exe -db gen

Dump code from a specific address in PID 0x1a3:
* pd64.exe -pid 0x1a3 -a 0xffb4000
 * Generates two files (32 and 64 bit) that can be loaded for analysis in IDA with generated PE headers and generated import table:
  * notepad_exe_x64_hidden_FFB40000.exe
  * notepad_exe_x86_hidden_FFB40000.exe


# Example sandbox usage
If you are running an automated sandbox or manual anti-malware research environment, I recommend running the following process with Process Dump, run all commands as Administrator:
* On your clean environment build the clean hash database:
 * pd64.exe -db gen
 * (or more quickly) pd64 -db genquick
* Begin the Process Dump terminate monitor. Leave this running in the background to dump all the intermediate processes used by the malware:
 * pd64.exe -closemon
* Run the malware file
* Watch the malware install (and pd64 dumping any process that tries to close)
* When you are ready to dump the running malware from memory, run the following command to dump all processes:
 * pd64.exe -system
* All the dumped components will be in the working directory of pd64.exe. You can change the output path using the '-o' flag,


Notes on the naming convention of dumped modules:
* 'hiddemodule' in the filename instead of the module name indicates the module was not properly registered in the process.
* 'codechunk' in the filename means that it is a reconstructed dump from a loose executable region. This can be for example injected code that did not have a PE header. Codechunks will be dumped twice, once with a reconstructed x86 and again with a reconstructed x64 header.

Example filenames of dumped files
* notepad_exe_PID2990_hiddenmodule_16B8ABB0000_x86.dll
* notepad_exe_PID3b5c_notepad.exe_7FF6E6630000_x64.exe
* notepad_exe_PID2c54_codechunk_17BD0000_x86.dll
* notepad_exe_PID2c54_codechunk_17BD0000_x64.dll


# Help Page
Process Dump v2.1
  Copyright ® 2017, Geoff McDonald
  http://www.split-code.com/

Process Dump (pd.exe) is a tool used to dump both 32 and 64 bit executable modules back to disk from memory within a process address space. This tool is able to find and dump hidden modules as well as loose executable code chunks, and it uses a clean hash database to exclude dumping of known clean files. This tool uses an aggressive import reconstruction approach that links all DWORD/QWORDs that point to an export in the process to the corresponding export function. Process dump can be used to dump all unknown code from memory ('-system' flag), dump specific processes, or run in a monitoring mode that dumps all processes just before they terminate.

Before first usage of this tool, when on the clean workstation the clean exclusing hash database can be generated by either:
* pd -db gen
* pd -db genquick

Example Usage:
* pd -system
* pd -pid 419
* pd -pid 0x1a3
* pd -pid 0x1a3 -a 0x401000 -o c:\dump\ -c c:\dump\test\clean.db
* pd -p chrome.exe
* pd -p "(?i).\*chrome.\*"
* pd -closemon

Options:

* -system
> Dumps all modules not matching the clean hash databas from all accessible processes into the working directory.

* -pid \<pid\>
> Dumps all modules not matching the clean hash database from the specified pid into the current working directory. Use a '0x' prefix to specify a hex PID.

* -closemon
> Runs in monitor mode. When any processes are terminating process dump will first dump the process.

* -p \<regex\>
> Dumps all modules not matching the clean hash database from the process name found to match the filter into specified pid into the current working directory.

* -g
> Forces generation of PE headers from scratch, ignoring existing headers.

* -o \<path\>
> Sets the default output root folder for dumped components.

* -v
> Verbose.

* -nh
> No header is printed in the output.

* -nr
> Disable recursion on hash database directory add or remove commands.

* -ni
> Disable import reconstruction.

* -nc
> Disable dumping of loose code regions.

* -nt
> Disable multithreading.

* -t \<thread count\>
> Sets the number of threads to use (default 16).

* -c \<filepath\>
> Full filepath to the clean hash database to use for this run.

* -db gen
> Automatically processes a few common folders as well as
all the currently running processes and adds the found module hashes to the clean hash database. It will add all files recursively in:
  %WINDIR%
  %HOMEPATH%
  C:\Program Files\
  C:\Program Files (x86)\
As well as all modules in all running processes

* -db genquick
> Adds the hashes from all modules in all processes to the clean hash database. Run this on a clean system.

* -db add \<dir\>
> Adds all the files in the specified directory recursively to the clean hash database.

* -db rem \<dir\>
> Removes all the files in the specified directory recursively from the clean hash database.

* -db clean
> Clears the clean hash database.

* -db ignore
> Ignores the clean hash database when dumping a process this time.  All modules will be dumped even if a match is found.



# Version history

## Version 2.1 (February 12th, 2017)
* Fixed a bug where the last section in some cases would instead be filled with zeros. Thanks to megastupidmonkey for reporting this issue.
* Fixed a bug where 64-bit base addresses would be truncated to a 32-bit address. It now properly keeps the full 64-bit module base address. Thanks to megastupidmonkey for reporting this issue.
* Addressed an issue where the processes dump close monitor would crash csrss.exe.
* Stopped Process Dump from hooking it's own process in close monitor mode. 

## Version 2.0 (September 18th, 2016)
* Added new flag '-closemon' which runs Process Dump in a monitoring
   mode. It will pause and dump any process just as it closes. This is designed
   to work well with malware analysis sandboxes, to be sure to dump
   malware from memory beofre the malicious process closes.
*  Upgraded Process Dump to be multi-threaded. Commands that dump or get
   hashes from multiple processes will run separate threads per operation.
   Default number of threads is 16, which speeds up the general Process
   Dump dumping processing significantly.
*  Upgraded Process Dump to dump unattached code chunks found in memory.
   These are identified as executable regions in memory which are not
   attached to a module and do not have a PE header. It also requires that
   the codechunk refer to at least 2 imports to be considered valid in
   order to reduce noise. When dumped, a PE header is recreated along with
   an import table. Code chunks are fully supported by the clean hash database.
*  Added flags to control the filepath to the clean hash database as well
   as the output folder for dumped files.
*  Fix to generating clean hash database from user path that was causing a
   crash.
*  Fix to the flag '-g' that forces generation of PE headers. Before even
   if this flag was set, system dumps (-system), would ignore this flag
   when dumping a process.
* Various performance improvements.
* Upgraded project to VS2015.

## Version 1.5 (November 21st, 2015)
* Fixed bug where very large memory regions would cause Process Dump to hang.
* Fixed bug where some modules at high addresses would not be found under 64-bit Windows.
* More debug information now outputted under Verbose mode.

## Version 1.4 (April 18th, 2015)
* Added new aggressive import reconstruction approach. Now patches up all DWORDs and QWORDs in the module to the corresponding export match.
* Added '-a (address to dump)' flag to dump a specific address. It will generate PE headers and build an import table for the address.
* Added '-ni' flag to skip new import reconstruction algorithm.
* Added '-g' flag to force generation of new PE header even if there exists one when dumping a module. This is good if the PE header is malformed for example.
* Various bug fixes.

## Version 1.3 (October 10th, 2013)
* Improved handling of PE headers with sections that specify invalid virtual sizes and addresses.
* Better module dumping methodology for dumping virtual sections down to disk sections.

## Version 1.1 (April 8th, 2013)
* Fixed a compatibility issue with Windows XP.
* Corrected bug where process dump would print it is dumping a module but not actually dump it.
* Implemented the '-pid ' dump flag.

## Version 1.0 (April 2nd, 2013)
* Initial release.

```

`pd.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.24720.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pd", "pd\pd.vcxproj", "{49B0E81A-D38E-426E-AB76-CC8463EC0003}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
		x64|Win32 = x64|Win32
		x64|x64 = x64|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.Debug|Win32.ActiveCfg = Debug|Win32
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.Debug|Win32.Build.0 = Debug|Win32
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.Debug|x64.ActiveCfg = Debug|x64
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.Debug|x64.Build.0 = Debug|x64
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.Release|Win32.ActiveCfg = Release|Win32
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.Release|Win32.Build.0 = Release|Win32
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.Release|x64.ActiveCfg = Release|x64
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.Release|x64.Build.0 = Release|x64
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.x64|Win32.ActiveCfg = Debug|Win32
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.x64|Win32.Build.0 = Debug|Win32
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.x64|x64.ActiveCfg = x64|x64
		{49B0E81A-D38E-426E-AB76-CC8463EC0003}.x64|x64.Build.0 = x64|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`pd/DynArray.h`:

```h
//////////////////////////////////////////////////////////////////////
// DynArray.h: interface&implementation for the DynArray class
//////////////////////////////////////////////////////////////////////
// From: http://www.anyexample.com/programming/cplusplus/cplusplus_dynamic_array_template_class.xml

#ifndef _AE_DYNARRAY_H_INCLUDED_
#define _AE_DYNARRAY_H_INCLUDED_

#include <cstdlib>

template<class el>
class DynArray
{
public:
    DynArray(); // constructor 
    DynArray(const DynArray &a); // copy constructor 
    ~DynArray(); // distructor 
    DynArray& operator = (const DynArray &a); // assignment operator 

    el& operator [] (unsigned int index); // get array item 
    void Add(const el &item); // Add item to the end of array 

    unsigned int GetSize(); // get size of array (elements)
    void SetSize(unsigned int newsize); // set size of array (elements)
    void Clear(); // clear array
    void Delete(unsigned int pos); // delete array item 
	void* getptr(); // get void* pointer to array data

    enum exception { MEMFAIL }; // exception enum 
	
private:
    el *array; // pointer for array's memory 
    unsigned int size; // size of array (elemets)
    unsigned int realsize; // actual size of allocated memory  

	const static int dyn_array_step = 128; // initial size of array memory (elements)
	const static int dyn_array_mult = 2; // multiplier (enlarge array memory 
										 // dyn_array_mult times  )
};

//////////////////////////////////////////////////////////////////////

template <class el>
DynArray<el>::DynArray()
{
    realsize = dyn_array_step; // First, allocate step 
							   // for dyn_array_step items
    size = 0;
    array = (el *)malloc(realsize*sizeof(el));

    if (array == NULL)
		throw MEMFAIL;
}


template <class el>
DynArray<el>::~DynArray()
{
    if (array)
    {
    	free(array);
    	array = NULL;
    }
}


template <class el>
DynArray<el>::DynArray(const DynArray &a)
{
    array = (el *)malloc(sizeof(el)*a.realsize);
    if (array == NULL)
		throw MEMFAIL;

    memcpy(array, a.array, sizeof(el)*a.realsize);
    realsize = a.realsize;
    size = a.size;
}


template <class el>
DynArray<el>& DynArray<el>::operator = (const DynArray &a)
{
    if (this == &a) // in case somebody tries assign array to itself 
		return *this;

	if (a.size == 0) // is other array is empty -- clear this array 
		Clear();

	SetSize(a.size); // set size 

    memcpy(array, a.array, sizeof(el)*a.size);

    return *this;
}

template <class el>
unsigned int DynArray<el>::GetSize()
{
    return size; // simply return size
}


template <class el>
void DynArray<el>::SetSize(unsigned int newsize)
{
    size = newsize;

	if (size != 0)
	{
		// change array memory size 
		// if new size is larger than current 
		// or new size is less then half of the current 
		if ((size > realsize) || (size < realsize/2))
		{
	    	realsize = size;
	    	array = (el *)realloc(array, sizeof(el)*size);

			if (array == NULL)
				throw MEMFAIL;
		}
	}
	else
		Clear();
}

template <class el>
void DynArray<el>::Delete(unsigned int pos)
{
	if (size == 1) // If array has only one element 
		Clear(); // than we clear it, since it will be deleted 
	else
	{
		// otherwise, shift array elements 
		for(unsigned int i=pos; i<size-1; i++) 
			array[i] = array[i+1];

		// decrease array size
		size--;
	}
}

template <class el>
void DynArray<el>::Clear() // clear array memory 
{
    size = 0; 
	array = (el *)realloc(array, sizeof(el)*dyn_array_step); 
				  // set initial memory size again 
	realsize = dyn_array_step;
}

template <class el>
void* DynArray<el>::getptr()
{
    return array; // return void* pointer 
}

template <class el>
el& DynArray<el>::operator [] (unsigned int index)
{
    return array[index]; // return array element 
}

template <class el>
void DynArray<el>::Add(const el &item)
{
    size++;

    if (size > realsize)
    {
		realsize *= dyn_array_mult;
		
		array = (el *)realloc(array, sizeof(el)*realsize);

		if (array == NULL)
			throw MEMFAIL;
    }

	array[size-1] = item;
}

#endif // ifndef _AE_DYNARRAY_H_INCLUDED_
```

`pd/ReadMe.txt`:

```txt
========================================================================
    CONSOLE APPLICATION : pd Project Overview
========================================================================

AppWizard has created this pd application for you.

This file contains a summary of what you will find in each of the files that
make up your pd application.


pd.vcproj
    This is the main project file for VC++ projects generated using an Application Wizard.
    It contains information about the version of Visual C++ that generated the file, and
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

pd.cpp
    This is the main application source file.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named pd.pch and a precompiled types file named StdAfx.obj.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

```

`pd/close_watcher.cpp`:

```cpp
#include "stdafx.h"
#include "close_watcher.h"


close_watcher::close_watcher(pe_hash_database* clean_db, PD_OPTIONS* options)
{
	_clean_db = clean_db;
	_options = options;
	_monitoring_thread = NULL;
	_monitor_request_stop = false;
}

bool close_watcher::start_monitor()
{
	// Create the main monitoring thread
	if (_monitoring_thread == NULL)
	{
		_monitor_request_stop = false;
		_monitoring_thread = new thread(&close_watcher::_monitor_dump_on_close, this);

		printf("Started monitoring for process closes.\r\n");
	}
	return true;
}

bool close_watcher::stop_monitor()
{
	if (_monitoring_thread != NULL)
	{
		// Cleanly exit the main thread
		_monitor_request_stop = true;
		_monitoring_thread->join();

		delete _monitoring_thread;
		_monitoring_thread = NULL;

		printf("Stopped monitoring for process closes.\r\n");
	}

	return true;
}


void close_watcher::_monitor_dump_on_close()
{
	// List of processes hooked
	unordered_set<DWORD> hooked_pids;
	unordered_map<DWORD, dump_process*> hooked_processes;

	// Create our threads that process the dumping of processes as they close
	thread** threads = new thread*[_options->NumberOfThreads];
	
	for (int i = 0; i < _options->NumberOfThreads; i++)
	{
		threads[i] = new thread(&close_watcher::_dump_process_worker_and_close, this);
	}

	// Hook all processes terminates
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	DWORD myPid = GetCurrentProcessId();

	while (!_monitor_request_stop)
	{
		// Keep hooking any new processes
		snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
		if (snapshot != INVALID_HANDLE_VALUE)
		{
			if (Process32First(snapshot, &entry) == TRUE)
			{
				while (Process32Next(snapshot, &entry) == TRUE)
				{
					if ( myPid != entry.th32ProcessID && hooked_pids.count(entry.th32ProcessID) == 0)
					{
						if (_wcsicmp(entry.szExeFile, L"csrss.exe") != 0) // TEMPORARY FIX TO ISSUE #10 CRASHING CSRSS.EXE
						{
							// Test code to only hook notepad.exe
							//if (_wcsicmp(entry.szExeFile, L"notepad.exe") == 0)
							//{
								// New process
								dump_process* dumper = new dump_process(entry.th32ProcessID, _clean_db, _options, true);
								if (dumper->monitor_close_start())
								{
									printf("...hooked close of: pid 0x%x,%S\r\n", entry.th32ProcessID, entry.szExeFile);
									hooked_processes.insert(std::pair<DWORD, dump_process*>(dumper->get_pid(), dumper));
									hooked_pids.insert(dumper->get_pid());
								}
								else
									delete dumper;
							//}
						}
					}
				}
			}
			CloseHandle(snapshot);
		}

		// Check if any processes are waiting to close
		for (unordered_map<DWORD, dump_process*>::iterator it = hooked_processes.begin(); it != hooked_processes.end(); )
		{
			if (it->second->monitor_close_is_waiting())
			{

				// Dump this process by adding it to the multi-threaded dumping queue
				char name[0x200];
				it->second->get_process_name(name, sizeof(name));
				printf("Process %s requesting to close, we are dumping it...\r\n", name);
				_work_queue.push(it->second); // Will be freed when it gets processed from work queue

				// Remove this process
				it = hooked_processes.erase(it);
			}
			else
			{
				it++;
			}
		}

		Sleep(10);
	}

	// Wait for the work queue to finish processing
	while (!_work_queue.empty())
	{
		printf("waiting for dump commands to be pulled from work queue...\r\n");
		Sleep(200);
	}

	// Wait for all worker threads to complete
	for (int i = 0; i < _options->NumberOfThreads; i++)
	{
		threads[i]->join(); // blocks until each thread is finished
		delete threads[i];
		threads[i] = NULL;
	}
	delete[]threads;

	// Clean up list of processes hooked
	for (unordered_map<DWORD, dump_process*>::iterator it = hooked_processes.begin(); it != hooked_processes.end(); ++it)
	{
		delete it->second; // cleans up the hook in the destructor
	}
}


void close_watcher::_dump_process_worker_and_close()
{
	// Dump this process
	unordered_set<unsigned __int64> new_hashes;
	while (!_monitor_request_stop || !_work_queue.empty())
	{
		// Process the hashes for this process
		dump_process* entry;
		if (_work_queue.pop(entry))
		{
			// Process this process

			// Dump this process
			entry->monitor_close_dump_and_resume();

			// We're done with the process
			delete entry;
		}

		Sleep(10);
	}
}


close_watcher::~close_watcher()
{
	stop_monitor();
}

```

`pd/close_watcher.h`:

```h
#pragma once
#include "work_queue.h"
#include <thread>
#include "pe_hash_database.h"
#include "dump_process.h"
#include "windows.h"

class close_watcher
{
	pe_hash_database* _clean_db;
	PD_OPTIONS* _options;

	Queue<dump_process*> _work_queue;

	thread* _monitoring_thread;
	bool _monitor_request_stop;

	void _monitor_dump_on_close();
	void _dump_process_worker_and_close();

public:
	close_watcher(pe_hash_database* clean_db, PD_OPTIONS* options);
	bool start_monitor();
	bool stop_monitor();
	~close_watcher();
};


```

`pd/dirent.h`:

```h
#pragma once

/*
* Dirent interface for Microsoft Visual Studio
* Version 1.21
*
* Copyright (C) 2006-2012 Toni Ronkko
* This file is part of dirent.  Dirent may be freely distributed
* under the MIT license.  For all details and documentation, see
* https://github.com/tronkko/dirent
*/
#ifndef DIRENT_H
#define DIRENT_H

/*
* Include windows.h without Windows Sockets 1.1 to prevent conflicts with
* Windows Sockets 2.0.
*/
#ifndef WIN32_LEAN_AND_MEAN
#   define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <wchar.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>

/* Indicates that d_type field is available in dirent structure */
#define _DIRENT_HAVE_D_TYPE

/* Indicates that d_namlen field is available in dirent structure */
#define _DIRENT_HAVE_D_NAMLEN

/* Entries missing from MSVC 6.0 */
#if !defined(FILE_ATTRIBUTE_DEVICE)
#   define FILE_ATTRIBUTE_DEVICE 0x40
#endif

/* File type and permission flags for stat(), general mask */
#if !defined(S_IFMT)
#   define S_IFMT _S_IFMT
#endif

/* Directory bit */
#if !defined(S_IFDIR)
#   define S_IFDIR _S_IFDIR
#endif

/* Character device bit */
#if !defined(S_IFCHR)
#   define S_IFCHR _S_IFCHR
#endif

/* Pipe bit */
#if !defined(S_IFFIFO)
#   define S_IFFIFO _S_IFFIFO
#endif

/* Regular file bit */
#if !defined(S_IFREG)
#   define S_IFREG _S_IFREG
#endif

/* Read permission */
#if !defined(S_IREAD)
#   define S_IREAD _S_IREAD
#endif

/* Write permission */
#if !defined(S_IWRITE)
#   define S_IWRITE _S_IWRITE
#endif

/* Execute permission */
#if !defined(S_IEXEC)
#   define S_IEXEC _S_IEXEC
#endif

/* Pipe */
#if !defined(S_IFIFO)
#   define S_IFIFO _S_IFIFO
#endif

/* Block device */
#if !defined(S_IFBLK)
#   define S_IFBLK 0
#endif

/* Link */
#if !defined(S_IFLNK)
#   define S_IFLNK 0
#endif

/* Socket */
#if !defined(S_IFSOCK)
#   define S_IFSOCK 0
#endif

/* Read user permission */
#if !defined(S_IRUSR)
#   define S_IRUSR S_IREAD
#endif

/* Write user permission */
#if !defined(S_IWUSR)
#   define S_IWUSR S_IWRITE
#endif

/* Execute user permission */
#if !defined(S_IXUSR)
#   define S_IXUSR 0
#endif

/* Read group permission */
#if !defined(S_IRGRP)
#   define S_IRGRP 0
#endif

/* Write group permission */
#if !defined(S_IWGRP)
#   define S_IWGRP 0
#endif

/* Execute group permission */
#if !defined(S_IXGRP)
#   define S_IXGRP 0
#endif

/* Read others permission */
#if !defined(S_IROTH)
#   define S_IROTH 0
#endif

/* Write others permission */
#if !defined(S_IWOTH)
#   define S_IWOTH 0
#endif

/* Execute others permission */
#if !defined(S_IXOTH)
#   define S_IXOTH 0
#endif

/* Maximum length of file name */
#if !defined(PATH_MAX)
#   define PATH_MAX MAX_PATH
#endif
#if !defined(FILENAME_MAX)
#   define FILENAME_MAX MAX_PATH
#endif
#if !defined(NAME_MAX)
#   define NAME_MAX FILENAME_MAX
#endif

/* File type flags for d_type */
#define DT_UNKNOWN 0
#define DT_REG S_IFREG
#define DT_DIR S_IFDIR
#define DT_FIFO S_IFIFO
#define DT_SOCK S_IFSOCK
#define DT_CHR S_IFCHR
#define DT_BLK S_IFBLK
#define DT_LNK S_IFLNK

/* Macros for converting between st_mode and d_type */
#define IFTODT(mode) ((mode) & S_IFMT)
#define DTTOIF(type) (type)

/*
* File type macros.  Note that block devices, sockets and links cannot be
* distinguished on Windows and the macros S_ISBLK, S_ISSOCK and S_ISLNK are
* only defined for compatibility.  These macros should always return false
* on Windows.
*/
#if !defined(S_ISFIFO)
#   define S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFIFO)
#endif
#if !defined(S_ISDIR)
#   define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
#endif
#if !defined(S_ISREG)
#   define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISLNK)
#   define S_ISLNK(mode) (((mode) & S_IFMT) == S_IFLNK)
#endif
#if !defined(S_ISSOCK)
#   define S_ISSOCK(mode) (((mode) & S_IFMT) == S_IFSOCK)
#endif
#if !defined(S_ISCHR)
#   define S_ISCHR(mode) (((mode) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISBLK)
#   define S_ISBLK(mode) (((mode) & S_IFMT) == S_IFBLK)
#endif

/* Return the exact length of d_namlen without zero terminator */
#define _D_EXACT_NAMLEN(p) ((p)->d_namlen)

/* Return number of bytes needed to store d_namlen */
#define _D_ALLOC_NAMLEN(p) (PATH_MAX)


#ifdef __cplusplus
extern "C" {
#endif


	/* Wide-character version */
	struct _wdirent {
		/* Always zero */
		long d_ino;

		/* Structure size */
		unsigned short d_reclen;

		/* Length of name without \0 */
		size_t d_namlen;

		/* File type */
		int d_type;

		/* File name */
		wchar_t d_name[PATH_MAX];
	};
	typedef struct _wdirent _wdirent;

	struct _WDIR {
		/* Current directory entry */
		struct _wdirent ent;

		/* Private file data */
		WIN32_FIND_DATAW data;

		/* True if data is valid */
		int cached;

		/* Win32 search handle */
		HANDLE handle;

		/* Initial directory name */
		wchar_t *patt;
	};
	typedef struct _WDIR _WDIR;

	static _WDIR *_wopendir(const wchar_t *dirname);
	static struct _wdirent *_wreaddir(_WDIR *dirp);
	static int _wclosedir(_WDIR *dirp);
	static void _wrewinddir(_WDIR* dirp);


	/* For compatibility with Symbian */
#define wdirent _wdirent
#define WDIR _WDIR
#define wopendir _wopendir
#define wreaddir _wreaddir
#define wclosedir _wclosedir
#define wrewinddir _wrewinddir


	/* Multi-byte character versions */
	struct dirent {
		/* Always zero */
		long d_ino;

		/* Structure size */
		unsigned short d_reclen;

		/* Length of name without \0 */
		size_t d_namlen;

		/* File type */
		int d_type;

		/* File name */
		char d_name[PATH_MAX];
	};
	typedef struct dirent dirent;

	struct DIR {
		struct dirent ent;
		struct _WDIR *wdirp;
	};
	typedef struct DIR DIR;

	static DIR *opendir(const char *dirname);
	static struct dirent *readdir(DIR *dirp);
	static int closedir(DIR *dirp);
	static void rewinddir(DIR* dirp);


	/* Internal utility functions */
	static WIN32_FIND_DATAW *dirent_first(_WDIR *dirp);
	static WIN32_FIND_DATAW *dirent_next(_WDIR *dirp);

	static int dirent_mbstowcs_s(
		size_t *pReturnValue,
		wchar_t *wcstr,
		size_t sizeInWords,
		const char *mbstr,
		size_t count);

	static int dirent_wcstombs_s(
		size_t *pReturnValue,
		char *mbstr,
		size_t sizeInBytes,
		const wchar_t *wcstr,
		size_t count);

	static void dirent_set_errno(int error);

	/*
	* Open directory stream DIRNAME for read and return a pointer to the
	* internal working area that is used to retrieve individual directory
	* entries.
	*/
	static _WDIR*
		_wopendir(
			const wchar_t *dirname)
	{
		_WDIR *dirp = NULL;
		int error;

		/* Must have directory name */
		if (dirname == NULL || dirname[0] == '\0') {
			dirent_set_errno(ENOENT);
			return NULL;
		}

		/* Allocate new _WDIR structure */
		dirp = (_WDIR*)malloc(sizeof(struct _WDIR));
		if (dirp != NULL) {
			DWORD n;

			/* Reset _WDIR structure */
			dirp->handle = INVALID_HANDLE_VALUE;
			dirp->patt = NULL;
			dirp->cached = 0;

			/* Compute the length of full path plus zero terminator
			*
			* Note that on WinRT there's no way to convert relative paths
			* into absolute paths, so just assume its an absolute path.
			*/
#       if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)
			n = wcslen(dirname);
#       else
			n = GetFullPathNameW(dirname, 0, NULL, NULL);
#       endif

			/* Allocate room for absolute directory name and search pattern */
			dirp->patt = (wchar_t*)malloc(sizeof(wchar_t) * n + 16);
			if (dirp->patt) {

				/*
				* Convert relative directory name to an absolute one.  This
				* allows rewinddir() to function correctly even when current
				* working directory is changed between opendir() and rewinddir().
				*
				* Note that on WinRT there's no way to convert relative paths
				* into absolute paths, so just assume its an absolute path.
				*/
#           if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)
				wcsncpy_s(dirp->patt, n + 1, dirname, n);
#           else
				n = GetFullPathNameW(dirname, n, dirp->patt, NULL);
#           endif
				if (n > 0) {
					wchar_t *p;

					/* Append search pattern \* to the directory name */
					p = dirp->patt + n;
					if (dirp->patt < p) {
						switch (p[-1]) {
						case '\\':
						case '/':
						case ':':
							/* Directory ends in path separator, e.g. c:\temp\ */
							/*NOP*/;
							break;

						default:
							/* Directory name doesn't end in path separator */
							*p++ = '\\';
						}
					}
					*p++ = '*';
					*p = '\0';

					/* Open directory stream and retrieve the first entry */
					if (dirent_first(dirp)) {
						/* Directory stream opened successfully */
						error = 0;
					}
					else {
						/* Cannot retrieve first entry */
						error = 1;
						dirent_set_errno(ENOENT);
					}

				}
				else {
					/* Cannot retrieve full path name */
					dirent_set_errno(ENOENT);
					error = 1;
				}

			}
			else {
				/* Cannot allocate memory for search pattern */
				error = 1;
			}

		}
		else {
			/* Cannot allocate _WDIR structure */
			error = 1;
		}

		/* Clean up in case of error */
		if (error  &&  dirp) {
			_wclosedir(dirp);
			dirp = NULL;
		}

		return dirp;
	}

	/*
	* Read next directory entry.  The directory entry is returned in dirent
	* structure in the d_name field.  Individual directory entries returned by
	* this function include regular files, sub-directories, pseudo-directories
	* "." and ".." as well as volume labels, hidden files and system files.
	*/
	static struct _wdirent*
		_wreaddir(
			_WDIR *dirp)
	{
		WIN32_FIND_DATAW *datap;
		struct _wdirent *entp;

		/* Read next directory entry */
		datap = dirent_next(dirp);
		if (datap) {
			size_t n;
			DWORD attr;

			/* Pointer to directory entry to return */
			entp = &dirp->ent;

			/*
			* Copy file name as wide-character string.  If the file name is too
			* long to fit in to the destination buffer, then truncate file name
			* to PATH_MAX characters and zero-terminate the buffer.
			*/
			n = 0;
			while (n + 1 < PATH_MAX  &&  datap->cFileName[n] != 0) {
				entp->d_name[n] = datap->cFileName[n];
				n++;
			}
			dirp->ent.d_name[n] = 0;

			/* Length of file name excluding zero terminator */
			entp->d_namlen = n;

			/* File type */
			attr = datap->dwFileAttributes;
			if ((attr & FILE_ATTRIBUTE_DEVICE) != 0) {
				entp->d_type = DT_CHR;
			}
			else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
				entp->d_type = DT_DIR;
			}
			else {
				entp->d_type = DT_REG;
			}

			/* Reset dummy fields */
			entp->d_ino = 0;
			entp->d_reclen = sizeof(struct _wdirent);

		}
		else {

			/* Last directory entry read */
			entp = NULL;

		}

		return entp;
	}

	/*
	* Close directory stream opened by opendir() function.  This invalidates the
	* DIR structure as well as any directory entry read previously by
	* _wreaddir().
	*/
	static int
		_wclosedir(
			_WDIR *dirp)
	{
		int ok;
		if (dirp) {

			/* Release search handle */
			if (dirp->handle != INVALID_HANDLE_VALUE) {
				FindClose(dirp->handle);
				dirp->handle = INVALID_HANDLE_VALUE;
			}

			/* Release search pattern */
			if (dirp->patt) {
				free(dirp->patt);
				dirp->patt = NULL;
			}

			/* Release directory structure */
			free(dirp);
			ok = /*success*/0;

		}
		else {
			/* Invalid directory stream */
			dirent_set_errno(EBADF);
			ok = /*failure*/-1;
		}
		return ok;
	}

	/*
	* Rewind directory stream such that _wreaddir() returns the very first
	* file name again.
	*/
	static void
		_wrewinddir(
			_WDIR* dirp)
	{
		if (dirp) {
			/* Release existing search handle */
			if (dirp->handle != INVALID_HANDLE_VALUE) {
				FindClose(dirp->handle);
			}

			/* Open new search handle */
			dirent_first(dirp);
		}
	}

	/* Get first directory entry (internal) */
	static WIN32_FIND_DATAW*
		dirent_first(
			_WDIR *dirp)
	{
		WIN32_FIND_DATAW *datap;

		/* Open directory and retrieve the first entry */
		dirp->handle = FindFirstFileExW(
			dirp->patt, FindExInfoStandard, &dirp->data,
			FindExSearchNameMatch, NULL, 0);
		if (dirp->handle != INVALID_HANDLE_VALUE) {

			/* a directory entry is now waiting in memory */
			datap = &dirp->data;
			dirp->cached = 1;

		}
		else {

			/* Failed to re-open directory: no directory entry in memory */
			dirp->cached = 0;
			datap = NULL;

		}
		return datap;
	}

	/* Get next directory entry (internal) */
	static WIN32_FIND_DATAW*
		dirent_next(
			_WDIR *dirp)
	{
		WIN32_FIND_DATAW *p;

		/* Get next directory entry */
		if (dirp->cached != 0) {

			/* A valid directory entry already in memory */
			p = &dirp->data;
			dirp->cached = 0;

		}
		else if (dirp->handle != INVALID_HANDLE_VALUE) {

			/* Get the next directory entry from stream */
			if (FindNextFileW(dirp->handle, &dirp->data) != FALSE) {
				/* Got a file */
				p = &dirp->data;
			}
			else {
				/* The very last entry has been processed or an error occured */
				FindClose(dirp->handle);
				dirp->handle = INVALID_HANDLE_VALUE;
				p = NULL;
			}

		}
		else {

			/* End of directory stream reached */
			p = NULL;

		}

		return p;
	}

	/*
	* Open directory stream using plain old C-string.
	*/
	static DIR*
		opendir(
			const char *dirname)
	{
		struct DIR *dirp;
		int error;

		/* Must have directory name */
		if (dirname == NULL || dirname[0] == '\0') {
			dirent_set_errno(ENOENT);
			return NULL;
		}

		/* Allocate memory for DIR structure */
		dirp = (DIR*)malloc(sizeof(struct DIR));
		if (dirp) {
			wchar_t wname[PATH_MAX];
			size_t n;

			/* Convert directory name to wide-character string */
			error = dirent_mbstowcs_s(&n, wname, PATH_MAX, dirname, PATH_MAX);
			if (!error) {

				/* Open directory stream using wide-character name */
				dirp->wdirp = _wopendir(wname);
				if (dirp->wdirp) {
					/* Directory stream opened */
					error = 0;
				}
				else {
					/* Failed to open directory stream */
					error = 1;
				}

			}
			else {
				/*
				* Cannot convert file name to wide-character string.  This
				* occurs if the string contains invalid multi-byte sequences or
				* the output buffer is too small to contain the resulting
				* string.
				*/
				error = 1;
			}

		}
		else {
			/* Cannot allocate DIR structure */
			error = 1;
		}

		/* Clean up in case of error */
		if (error  &&  dirp) {
			free(dirp);
			dirp = NULL;
		}

		return dirp;
	}

	/*
	* Read next directory entry.
	*
	* When working with text consoles, please note that file names returned by
	* readdir() are represented in the default ANSI code page while any output to
	* console is typically formatted on another code page.  Thus, non-ASCII
	* characters in file names will not usually display correctly on console.  The
	* problem can be fixed in two ways: (1) change the character set of console
	* to 1252 using chcp utility and use Lucida Console font, or (2) use
	* _cprintf function when writing to console.  The _cprinf() will re-encode
	* ANSI strings to the console code page so many non-ASCII characters will
	* display correcly.
	*/
	static struct dirent*
		readdir(
			DIR *dirp)
	{
		WIN32_FIND_DATAW *datap;
		struct dirent *entp;

		/* Read next directory entry */
		datap = dirent_next(dirp->wdirp);
		if (datap) {
			size_t n;
			int error;

			/* Attempt to convert file name to multi-byte string */
			error = dirent_wcstombs_s(
				&n, dirp->ent.d_name, PATH_MAX, datap->cFileName, PATH_MAX);

			/*
			* If the file name cannot be represented by a multi-byte string,
			* then attempt to use old 8+3 file name.  This allows traditional
			* Unix-code to access some file names despite of unicode
			* characters, although file names may seem unfamiliar to the user.
			*
			* Be ware that the code below cannot come up with a short file
			* name unless the file system provides one.  At least
			* VirtualBox shared folders fail to do this.
			*/
			if (error  &&  datap->cAlternateFileName[0] != '\0') {
				error = dirent_wcstombs_s(
					&n, dirp->ent.d_name, PATH_MAX,
					datap->cAlternateFileName, PATH_MAX);
			}

			if (!error) {
				DWORD attr;

				/* Initialize directory entry for return */
				entp = &dirp->ent;

				/* Length of file name excluding zero terminator */
				entp->d_namlen = n - 1;

				/* File attributes */
				attr = datap->dwFileAttributes;
				if ((attr & FILE_ATTRIBUTE_DEVICE) != 0) {
					entp->d_type = DT_CHR;
				}
				else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
					entp->d_type = DT_DIR;
				}
				else {
					entp->d_type = DT_REG;
				}

				/* Reset dummy fields */
				entp->d_ino = 0;
				entp->d_reclen = sizeof(struct dirent);

			}
			else {
				/*
				* Cannot convert file name to multi-byte string so construct
				* an errornous directory entry and return that.  Note that
				* we cannot return NULL as that would stop the processing
				* of directory entries completely.
				*/
				entp = &dirp->ent;
				entp->d_name[0] = '?';
				entp->d_name[1] = '\0';
				entp->d_namlen = 1;
				entp->d_type = DT_UNKNOWN;
				entp->d_ino = 0;
				entp->d_reclen = 0;
			}

		}
		else {
			/* No more directory entries */
			entp = NULL;
		}

		return entp;
	}

	/*
	* Close directory stream.
	*/
	static int
		closedir(
			DIR *dirp)
	{
		int ok;
		if (dirp) {

			/* Close wide-character directory stream */
			ok = _wclosedir(dirp->wdirp);
			dirp->wdirp = NULL;

			/* Release multi-byte character version */
			free(dirp);

		}
		else {

			/* Invalid directory stream */
			dirent_set_errno(EBADF);
			ok = /*failure*/-1;

		}
		return ok;
	}

	/*
	* Rewind directory stream to beginning.
	*/
	static void
		rewinddir(
			DIR* dirp)
	{
		/* Rewind wide-character string directory stream */
		_wrewinddir(dirp->wdirp);
	}

	/* Convert multi-byte string to wide character string */
	static int
		dirent_mbstowcs_s(
			size_t *pReturnValue,
			wchar_t *wcstr,
			size_t sizeInWords,
			const char *mbstr,
			size_t count)
	{
		int error;

#if defined(_MSC_VER)  &&  _MSC_VER >= 1400

		/* Microsoft Visual Studio 2005 or later */
		error = mbstowcs_s(pReturnValue, wcstr, sizeInWords, mbstr, count);

#else

		/* Older Visual Studio or non-Microsoft compiler */
		size_t n;

		/* Convert to wide-character string (or count characters) */
		n = mbstowcs(wcstr, mbstr, sizeInWords);
		if (!wcstr || n < count) {

			/* Zero-terminate output buffer */
			if (wcstr  &&  sizeInWords) {
				if (n >= sizeInWords) {
					n = sizeInWords - 1;
				}
				wcstr[n] = 0;
			}

			/* Length of resuting multi-byte string WITH zero terminator */
			if (pReturnValue) {
				*pReturnValue = n + 1;
			}

			/* Success */
			error = 0;

		}
		else {

			/* Could not convert string */
			error = 1;

		}

#endif

		return error;
	}

	/* Convert wide-character string to multi-byte string */
	static int
		dirent_wcstombs_s(
			size_t *pReturnValue,
			char *mbstr,
			size_t sizeInBytes, /* max size of mbstr */
			const wchar_t *wcstr,
			size_t count)
	{
		int error;

#if defined(_MSC_VER)  &&  _MSC_VER >= 1400

		/* Microsoft Visual Studio 2005 or later */
		error = wcstombs_s(pReturnValue, mbstr, sizeInBytes, wcstr, count);

#else

		/* Older Visual Studio or non-Microsoft compiler */
		size_t n;

		/* Convert to multi-byte string (or count the number of bytes needed) */
		n = wcstombs(mbstr, wcstr, sizeInBytes);
		if (!mbstr || n < count) {

			/* Zero-terminate output buffer */
			if (mbstr  &&  sizeInBytes) {
				if (n >= sizeInBytes) {
					n = sizeInBytes - 1;
				}
				mbstr[n] = '\0';
			}

			/* Length of resulting multi-bytes string WITH zero-terminator */
			if (pReturnValue) {
				*pReturnValue = n + 1;
			}

			/* Success */
			error = 0;

		}
		else {

			/* Cannot convert string */
			error = 1;

		}

#endif

		return error;
	}

	/* Set errno variable */
	static void
		dirent_set_errno(
			int error)
	{
#if defined(_MSC_VER)  &&  _MSC_VER >= 1400

		/* Microsoft Visual Studio 2005 and later */
		_set_errno(error);

#else

		/* Non-Microsoft compiler or older Microsoft compiler */
		errno = error;

#endif
	}


#ifdef __cplusplus
}
#endif
#endif /*DIRENT_H*/

```

`pd/dump_process.cpp`:

```cpp
#include "StdAfx.h"
#include "dump_process.h"




dump_process::dump_process(DWORD pid, pe_hash_database* db, PD_OPTIONS* options, bool quieter)
{
	_options = options;
	_opened = false;
	_pid = pid;
	_ph = NULL;
	_process_name = NULL;
	_export_list_built = false;
	_term_hook = NULL;
	_loaded_is64 = false;
	_is64 = false;
	_address_main_module = 0;
	_quieter = quieter && !options->Verbose;

	// Load the clean hash database
	_db_clean = db;

	// Dump this specified PID into the current directory PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION
	_ph = OpenProcess( PROCESS_ALL_ACCESS, false, pid);
	if (_ph == NULL)
	{
		// try opening with minimal permissions. This works for most actions (except terminate hooking)
		_ph = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, pid);
		if (_ph != NULL && _options->Verbose)
			fprintf(stderr, "WARNING: For PID 0x%x, we had to open handle with fewer permissions than expected. Dropped PROCESS_VM_WRITE and PROCESS_VM_OPERATION.\r\n", pid);
	}
	
	
	if( _ph != NULL )
	{
		typedef LONG(NTAPI *NtSuspendProcess)(IN HANDLE ProcessHandle);
		NtSuspendProcess pfnNtSuspendProcess = (NtSuspendProcess)GetProcAddress(
			GetModuleHandleA("ntdll"), "NtSuspendProcess");

		pfnNtSuspendProcess(_ph);

		// Try to load the main module name
		HANDLE hSnapshot=CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
		if(hSnapshot != INVALID_HANDLE_VALUE )
		{
			_opened = true;

			// Load the main module name
			MODULEENTRY32 tmpModule;
			tmpModule.dwSize = sizeof(MODULEENTRY32);
			if( Module32First(hSnapshot, &tmpModule) )
			{
				_process_name = new char[wcslen(tmpModule.szModule) + 1];
				sprintf( _process_name, "%S", tmpModule.szModule );

				// Replace all '.'s in filename with underscores
				int i = 0;
				while( _process_name[i] != 0 )
				{
					if( _process_name[i] == '.' )
						_process_name[i] = '_';
					i++;
				}
				
				_address_main_module = (unsigned __int64) tmpModule.modBaseAddr;
			}

			CloseHandle(hSnapshot);
		}
		else
		{
			if (!_quieter)
			{
				if (GetLastError() == 299)
					fprintf(stderr, "ERROR: Unable to snapshot process PID 0x%x. This can be as a result of the process being a 64 bit process and this tool is running as a 32 bit process, or the process may have not finished being created or already closed.\r\n", pid);
				else
					PrintLastError(L"dump_process CreateToolhelp32Snapshot");
			}

			_process_name = new char[strlen("unknown")+1];
			strcpy( _process_name, "unknown" );
		}
	}
	else
	{
		if (!_quieter)
		{
			fprintf(stderr, "Failed to open process with PID 0x%x:\r\n", pid);
			PrintLastError(L"\tdump_process");
		}
	}
}

bool dump_process::get_process_name(char* process_name, SIZE_T byte_length)
{
	if (_process_name != NULL)
	{
		if (strlen(_process_name) < byte_length)
		{
			strcpy_s(process_name, byte_length, _process_name);
			return true;
		}
	}
	if (byte_length > 0)
		_process_name[0] = 0;
	return false;
}

bool dump_process::is64()
{
	if (!_loaded_is64)
	{
		// Look at the main module to determine if it is 64 or 32 bit
		module_list* modules = new module_list(); // empty
		pe_header* main_module = new pe_header(_ph, (void*) _address_main_module, modules, _options);
		main_module->process_pe_header();
		_is64 = main_module->is_64();
		_loaded_is64 = true;
		delete main_module;
		delete modules;
	}

	if (_loaded_is64)
		return _is64;
	
	// Failed. Assume 64 bit.
	fprintf(stderr, "ERROR: For PID 0x%x, was unable to look at main module to determine 32 or 64 bit mode.\r\n", _pid);
	return true;
}

MBI_BASIC_INFO dump_process::get_mbi_info(unsigned __int64 address)
{
	_MEMORY_BASIC_INFORMATION64 mbi;
	MBI_BASIC_INFO result;
	result.base = 0;
	result.end = 0;
	result.protect = 0;
	result.valid = false;
	result.executable = false;

	// Load this heap information
	 __int64 blockSize = VirtualQueryEx(_ph, (LPCVOID)address, (PMEMORY_BASIC_INFORMATION)&mbi, sizeof(_MEMORY_BASIC_INFORMATION64));

	if (blockSize == sizeof(_MEMORY_BASIC_INFORMATION64))
	{
		result.base = mbi.BaseAddress;
		result.end = mbi.BaseAddress + mbi.RegionSize;
		result.protect = mbi.Protect;
		result.valid = mbi.State != MEM_FREE && !(mbi.Protect & (PAGE_NOACCESS | PAGE_GUARD));
		result.executable = (mbi.Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)) > 0;
	}
	else if (blockSize == sizeof(_MEMORY_BASIC_INFORMATION32))
	{
		_MEMORY_BASIC_INFORMATION32* mbi32 = (_MEMORY_BASIC_INFORMATION32*)&mbi;

		result.base = mbi32->BaseAddress;
		result.end = mbi32->BaseAddress + mbi32->RegionSize;
		result.protect = mbi32->Protect;
		result.valid = mbi32->State != MEM_FREE && !(mbi32->Protect & (PAGE_NOACCESS | PAGE_GUARD));
		result.executable = (mbi32->Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)) > 0;
	}

	return result;
}


int dump_process::get_all_hashes(unordered_set<unsigned __int64>* output_hashes)
{
	// Adds all the modules in the process to the output array
	if( _ph != NULL )
	{
		if( !_options->DumpChunks || build_export_list() ) // Only build export list if getting hashes for code chunks
		{
			// First build a list of the modules
			module_list* modules = new module_list( _pid );
			
			// Set the max address of the target process
			unsigned __int64 maxAddress = 0;
			maxAddress = 0xffffffffffffffff; // Not a problem for 32bit targets
			
			// Walk the process heaps
			__int64 address = 0;
			
			// First loop to build a list of executable heaps for later use in locating loose executable heaps not associated with any modules
			set<unsigned __int64> executable_heaps;
			if( _options->DumpChunks )
			{
				while (address < maxAddress)
				{
					MBI_BASIC_INFO mbi_info = get_mbi_info(address);
					
					// Check if this is a loose executable heap
					if( mbi_info.base > 0 && mbi_info.end > 0 && mbi_info.valid && mbi_info.executable)
					{
						executable_heaps.insert(mbi_info.base);
					}
					
					if( mbi_info.end + 1 <= address )
						break;
					address = mbi_info.end + 1;
				}
			}

			// Load all the PE files in the process
			address = 0;

			while (address < maxAddress)
			{
				// Load this heap information
				MBI_BASIC_INFO mbi_info = get_mbi_info(address);

				if (mbi_info.base > 0 && mbi_info.end > 0 && mbi_info.valid )
				{
					if( _options->Verbose )
						fprintf( stdout, "INFO: Scanning from region from 0x%llX to 0x%llX for MZ headers.\r\n", mbi_info.base, mbi_info.end );

					// This heap may have a PE file, check all page alignments for a "MZ".
					unsigned __int64 base = mbi_info.base - (mbi_info.base % PAGE_SIZE); // shouldn't be required.
					char output[2];
					SIZE_T out_read;
					int count = 0;
					while(mbi_info.base + 0x300 < mbi_info.end && count < 1000 ) // Skip the rest of the section if we have looped over 1000 pages.
					{
						DWORD oldProc;
						VirtualProtectEx(_ph, (LPVOID)((unsigned char*)base), 2, PAGE_EXECUTE_READ, &oldProc);

						if( ReadProcessMemory( _ph, (LPCVOID) ((unsigned char*) base), output, 2, &out_read) && out_read == 2 )
						{
							if( output[0] == 'M' && output[1] == 'Z' )
							{
								if( _options->Verbose )
									fprintf( stdout, "INFO: Found MZ header at %llX.\r\n", base );

								// Bingo, possible MZ file
								pe_header* header = new pe_header( _pid, (void*) base, modules, _options );

								header->process_pe_header();
								header->process_sections();

								if( header->somewhat_parsed() )
								{
									// Exclude all executable regions from this PE module
									unsigned __int64 end_address = header->get_virtual_size() + base;
									for (set<unsigned __int64>::iterator it=executable_heaps.begin(); it!=executable_heaps.end(); )
									{
										if( *it <= end_address && *it >= base )
										{
											// We've accounted for this executable heap, remove it from the loose heap list
											it = executable_heaps.erase(it);
										}
										else
										{
											it++;
										}
									}

									// Check hash
									unsigned __int64 hash = header->get_hash();
									if( hash != 0 && !_db_clean->contains(hash) && output_hashes->count( hash ) == 0 )
									{
										// Add this to the output hash array
										output_hashes->insert( hash );
									}
								}
								delete header;
							}
						}
						VirtualProtectEx(_ph, (LPVOID)((unsigned char*)base), 2, oldProc, &oldProc);
						base += PAGE_SIZE;
						count++;
					}
				}

				if (mbi_info.end + 1 <= address)
					break;
				address = mbi_info.end + 1;
			}

			
			if( _options->DumpChunks )
			{
				// One last loop to add the hashes from all stray executable heaps
				if( _options->Verbose )
					fprintf( stdout, "INFO: Looking at unattached executable heaps...\r\n" );
				
				int count_new_header_hashes = 0;
				for (set<unsigned __int64>::iterator it=executable_heaps.begin(); it!=executable_heaps.end(); it++)
				{
					// Unattached executable page. First check hash of crc32 of first 2kb of memory since import reconstruction hashing is
					// very expensive.
					unsigned __int64 chunk_header_hash = this->hash_codechunk_header(*it);

					if( _options->Verbose )
						fprintf( stdout, "INFO: Unattached heap start hash 0x%llX\r\n", chunk_header_hash );

					if( chunk_header_hash != 0 && !_db_clean->contains(chunk_header_hash) && output_hashes->count( chunk_header_hash ) == 0 )
					{
						if( _options->Verbose )
							fprintf( stdout, "INFO: Unattached heap start hash is new.\r\n" );
						
						if( count_new_header_hashes++ > CODECHUNK_NEW_HASH_LIMIT )
						{
							if( _options->Verbose )
								fprintf( stdout, "INFO: Too many unique loose code chunks. Stopped processing more chunks.\r\n" );
							break; // Too many new code chunks
						}

						// Add this header hash
						output_hashes->insert( chunk_header_hash );

						// Calculate the generic import reference hash as well
						pe_header* header = new pe_header( _pid, (void*) *it, modules, _options );
						header->build_pe_header( 0x1000, true, 1 ); // 64bit, only build it with the 1 executable section for performance reasons
						header->process_sections();

						// Get the import attributes of this header
						IMPORT_SUMMARY import_summary = header->get_imports_information(&this->_export_list);

						// Check hash
						if( import_summary.HASH_GENERIC != 0 && !_db_clean->contains(import_summary.HASH_GENERIC) && output_hashes->count( import_summary.HASH_GENERIC ) == 0 )
						{
							if( _options->Verbose )
								fprintf( stdout, "INFO: Adding hash from unattached heap at 0x%llX to process hash list: Hash=0x%llX\r\n", *it, import_summary.HASH_GENERIC );
							
							output_hashes->insert( import_summary.HASH_GENERIC );
						}
						delete header;
					}
				}
				if( _options->Verbose )
					fprintf( stdout, "INFO: Done looking at unattached executable heaps...\r\n" );
			}

			delete modules;
		}
	}
	else if( _options->Verbose )
		fprintf( stdout, "INFO: Null process handle %s.\r\n", this->_process_name );
	
	return false;
}

unsigned __int64 dump_process::hash_codechunk_header(__int64 base)
{
	char header_buffer[CODECHUNK_HEADER_HASH_SIZE];
	SIZE_T num_read = 0;

	DWORD oldProc;
	VirtualProtectEx(_ph, (LPVOID)(base), CODECHUNK_HEADER_HASH_SIZE, PAGE_EXECUTE_READ, &oldProc);

	BOOL success = ReadProcessMemory( _ph,
																(LPCVOID) (base),
																(void*)(header_buffer),
																CODECHUNK_HEADER_HASH_SIZE,
																&num_read);

	if( ( success || GetLastError() == ERROR_PARTIAL_COPY ) && num_read > 8 && num_read <= CODECHUNK_HEADER_HASH_SIZE )
	{
		// Hash the content
		return (unsigned __int64) crc32buf(header_buffer, num_read);
	}
	
	VirtualProtectEx(_ph, (LPVOID)(base), CODECHUNK_HEADER_HASH_SIZE, oldProc, &oldProc);

	// Default bad hash
	return 0;
}

bool dump_process::build_export_list()
{
	// Walk through each module, building the export list for this process. This will be used for import reconstruction
	// Returns: True if there are any modules to dump, False if there is nothing to dump.

	if( !_export_list_built )
	{
		if( !_quieter )
			printf( "... building import reconstruction table ...\r\n" );
		
		if (_ph != NULL)
		{
			// First build a list of the modules
			module_list* modules = new module_list(_pid);

			// Loop through each of these modules, grabbing their exports
			for (unordered_map<unsigned __int64, module*>::const_iterator item = modules->_modules.begin(); item != modules->_modules.end(); ++item)
			{
				pe_header* header = new pe_header(_pid, (void*) item->first, modules, _options);
				if (header->process_pe_header() && header->process_sections() && header->process_export_directory())
				{
					// Load it's exports
					this->_export_list.add_exports(header->get_exports());
				}

				// Cleanup
				delete header;
			}

			delete modules;
		}
		_export_list_built = true;
	}

	return true;
}

bool dump_process::build_export_list(export_list* result, char* library, module_list* modules)
{
	// Walk through each module, building the export list for this process. This will be used for import reconstruction
	// Returns: True if there are any modules to dump, False if there is nothing to dump.
	if (_ph != NULL)
	{
		// Loop through each of these modules, grabbing their exports
		for (unordered_map<unsigned __int64, module*>::const_iterator item = modules->_modules.begin(); item != modules->_modules.end(); ++item)
		{
			if (strcmpi(item->second->short_name, library) == 0)
			{
				pe_header* header = new pe_header(_pid, (void*)item->first, modules, _options);
				if (header->process_pe_header() && header->process_sections() && header->process_export_directory())
				{
					// Load its exports
					result->add_exports(header->get_exports());
				}

				// Cleanup
				delete header;
			}
		}
	}


	return true;
}

void dump_process::dump_header(pe_header* header, __int64 base, DWORD pid)
{
	if( header->process_sections() )
	{
		if( header->somewhat_parsed() )
		{
			if( header->process_import_directory() )
			{
				// Check hash
				unsigned __int64 hash = header->get_hash();
				if( hash != 0 && !_db_clean->contains(hash) )
				{
					if( _options->Verbose )
							printf(" preparing disk image for '%s' at %llX\r\n", header->get_name(), (__int64) base);
					if( header->process_disk_image(&this->_export_list) )
					{
						// Build the name that we will dump this image as
						char* extension = ( header->is_exe() ? "exe" :
														( header->is_dll() ? "dll" : 
														( header->is_sys() ? "sys" : "bin" ) ) );
						int length = MAX_PATH + FILENAME_MAX + 1;
						char* filename = new char[length];
						if( _options->output_path != NULL && strlen(_options->output_path) > 0 )
							sprintf(filename, "%s\\%s_PID%x_%s_%llX_%s.%s", _options->output_path, _process_name, pid, header->get_name(), (__int64)  base, (header->is_64() ? "x64": "x86"), extension );
						else
							sprintf(filename, "%s_PID%x_%s_%llX_%s.%s", _process_name, pid, header->get_name(), (__int64)  base, (header->is_64() ? "x64": "x86"), extension );
						
						// Dump the module
						printf(" dumping '%s' at %llX to file '%s'\r\n", extension, (__int64) base, filename);
						header->write_image(filename);
						
						delete[] filename;
					}
					else
					{
						if( _options->Verbose )
							printf("Failed to process disk image for module at %llX\r\n", base);
					}
				}
				else
				{
					if( _options->Verbose )
						printf("Null hash or the has is already in the clean hash database at %llX\r\n", base);
				}

			}
			else
			{
				if( _options->Verbose )
					printf("Failed to process import directory for module at %llX\r\n", base);
			}
		}
		else
		{
			if( _options->Verbose )
				printf("Module was not somehwat parsed for module at %llX\r\n", base);
		}
	}
	else
	{
		if( _options->Verbose )
			printf("Failed to process sections for module at %llX\r\n", base);
	}
}

void dump_process::dump_region(__int64 base)
{
	// Walk through the pages while dumping all MZ files that do not match our good hash database.
	printf( "\r\ndumping starting at %llX from process %s with pid 0x%x...\r\n", (__int64) base, this->_process_name, this->_pid );
	if( _ph != NULL )
	{
		// First build the export list for this process
		if( !_options->ImportRec || build_export_list() )
		{
			module_list* modules = new module_list( _pid );
			pe_header* header = new pe_header( _pid, (void*) base, modules, _options );
			
			if( _options->ForceGenHeader || !header->process_pe_header() )
			{
				if( _options->Verbose )
					printf( "Generating 32-bit PE header for module at %llX.\r\n", base );
				
				// Build the pe header as 32 and 64 bit since it could be either
				header->build_pe_header(0x1000ffff, true );
				dump_header(header, base, _pid);
				delete header;

				if( _options->Verbose )
					printf( "Generating 64-bit PE header for module at %llX.\r\n", base );
				header = new pe_header( _pid, (void*) base, modules, _options );
				header->build_pe_header(0x1000ffff, false ); 
				dump_header(header, base, _pid);
			}
			else
			{
				if( _options->Verbose )
					printf( "Using existing PE header for module at %llX.\r\n", base );
				dump_header(header, base, _pid);
			}



			delete modules;
			delete header;
		}
		else
		{
			printf("Failed to build export list.\r\n");
		}

	}
}


bool dump_process::monitor_close_start()
{
	if (!_opened || _address_main_module == 0)
		return false; // Not attached well to this process

	if (_term_hook == NULL)
	{
		// Add a hook on for when the process terminates so that we can dump it.
		if( _options->Verbose )
			printf("Hooking process terminate for process %s...\r\n", this->_process_name);
		_term_hook = new terminate_monitor_hook(_ph, _pid, this->is64(), this->_options );

		// Load the exports needed for the hooks
		module_list* modules = new module_list(_pid);
		export_list* exports = new export_list();
		build_export_list(exports, "kernel32.dll", modules);
		build_export_list(exports, "ntdll.dll", modules);
		bool result = _term_hook->hook_terminate(exports);

		// Cleanup
		delete exports;
		delete modules;

		return result;
	}

	return true; // Already started
}

bool dump_process::monitor_close_is_waiting()
{
	if (_term_hook != NULL)
	{
		return _term_hook->is_terminate_waiting();
	}

	return false; // not hooked
}

bool dump_process::monitor_close_stop()
{
	if (_term_hook != NULL)
	{
		delete _term_hook;
		return true;
	}
	return true; // not hooked
}


bool dump_process::monitor_close_dump_and_resume()
{
	if (_term_hook != NULL)
	{
		if (_term_hook->is_terminate_waiting())
		{
			// Dump the process
			dump_all();

			// Resume it so that it closes normally
			_term_hook->resume_terminate();

			return true;
		}

		return false; // was not waiting
	}
	return false; // not hooked
}

void dump_process::dump_all()
{
	// Walk through the pages while dumping all MZ files that do not match our good hash database.
	printf( "dumping process %s with pid 0x%x...\r\n", this->_process_name, this->_pid );
	if( _ph != NULL )
	{
		// First build the export list for this process
		if( build_export_list() )
		{
			// First build a list of the modules
			module_list* modules = new module_list( _pid );

			// Set the max address of the target process
			unsigned __int64 maxAddress = 0;
			maxAddress = 0xffffffffffffffff; // Not a problem for 32bit targets
			
			// Walk the process heaps
			__int64 address = 0;
			
			// First loop to build a list of executable heaps for later use in locating loose executable heaps not associated with any modules
			set<unsigned __int64> executable_heaps;
			if (_options->DumpChunks)
			{
				while (address < maxAddress)
				{
					MBI_BASIC_INFO mbi_info = get_mbi_info(address);

					// Check if this is a loose executable heap (this check causes it to fail.)
					if (mbi_info.base > 0 && mbi_info.end > 0 && mbi_info.valid && mbi_info.executable)
					{
						executable_heaps.insert(mbi_info.base);
					}

					if (mbi_info.end + 1 <= address)
						break;
					address = mbi_info.end + 1;
				}
			}

			// Load all the PE files in the process
			address = 0;
			while (address < maxAddress)
			{
				MBI_BASIC_INFO mbi_info = get_mbi_info(address);

				// Check if this is a loose executable heap
				if ( mbi_info.base > 0 && mbi_info.end > 0 && mbi_info.valid )
				{
					if (_options->Verbose)
						fprintf(stdout, "INFO: Scanning from region from 0x%llX to 0x%llX for MZ headers.\r\n", mbi_info.base, mbi_info.end);


					// This heap may have a PE file, check all page alignments for a "MZ".
					unsigned __int64 base = mbi_info.base - (mbi_info.base % PAGE_SIZE); // shouldn't be required.
					char output[2];
					SIZE_T out_read;
					int count = 0;
					while (base + 0x300 < mbi_info.end && count < 1000) // Skip the rest of the section if we have looped over 1000 pages.
					{
						DWORD oldProc;
						VirtualProtectEx(_ph, (LPVOID)((unsigned char*)base), 2, PAGE_EXECUTE_READ, &oldProc);

						if (ReadProcessMemory(_ph, (LPCVOID)((unsigned char*)base), output, 2, &out_read) && out_read == 2)
						{
							if (output[0] == 'M' && output[1] == 'Z')
							{
								// Bingo, possible MZ file
								pe_header* header = new pe_header(_pid, (void*)base, modules, _options);

								// Use the existing PE header for the dumping
								if (header->process_pe_header())
								{
									if (header->process_sections() && header->somewhat_parsed() && header->process_import_directory())
									{
										// Exclude all executable regions from this PE module
										unsigned __int64 end_address = header->get_virtual_size() + base;
										for (set<unsigned __int64>::iterator it = executable_heaps.begin(); it != executable_heaps.end(); )
										{
											if ( *it <= end_address && *it >= base)
											{
												// We've accounted for this executable heap, remove it from the loose heap list
												it = executable_heaps.erase(it);
											}
											else
											{
												it++;
											}
										}

										// Check hash
										unsigned __int64 hash = header->get_hash();
										if (hash != 0 && !_db_clean->contains(hash))
										{
											if (_options->ForceGenHeader)
											{
												// Use the existing PE header only to get the hash, then generate a PE header for the dumping.
												fprintf(stdout, "Dumping a module but ignoring existing PE Header for module at 0x%llX.\r\n", base);
												pe_header* header_dump = new pe_header(_pid, (void*)base, modules, _options);
												header_dump->build_pe_header(0x1000, true); // 64bit
												dump_header(header_dump, base, _pid);
												delete header_dump;

												header_dump = new pe_header(_pid, (void*)base, modules, _options);
												header_dump->build_pe_header(0x1000, false); // 32bit
												dump_header(header_dump, base, _pid);
												delete header_dump;
											}
											else if (header->process_disk_image(&this->_export_list))
											{
												// Build the name that we will dump this image as
												char* extension = (header->is_exe() ? "exe" :
													(header->is_dll() ? "dll" :
														(header->is_sys() ? "sys" : "bin")));
												int length = MAX_PATH + FILENAME_MAX + 1;
												char* filename = new char[length];
												if (_options->output_path != NULL && strlen(_options->output_path) > 0)
													sprintf(filename, "%s\\%s_PID%x_%s_%llX_%s.%s", _options->output_path, _process_name, _pid, header->get_name(), (__int64)base, (header->is_64() ? "x64" : "x86"), extension);
												else
													sprintf(filename, "%s_PID%x_%s_%llX_%s.%s", _process_name, _pid, header->get_name(), (__int64)base, (header->is_64() ? "x64" : "x86"), extension);

												// Dump the module
												printf(" dumping '%s' at %llX to file '%s'\r\n", extension, (__int64)base, filename);
												header->write_image(filename);

												delete[] filename;
											}
										}
									}
								}

								// Cleanup
								delete header;
							}
						}
						else
						{

						}

						VirtualProtectEx(_ph, (LPVOID)((unsigned char*)base), 2, oldProc, &oldProc);

						base += PAGE_SIZE;
						count++;
					}
				}

				if (mbi_info.end + 1 <= address)
					break;
				address = mbi_info.end + 1;
			}

			if( _options->DumpChunks )
			{
				// One last loop to add the hashes from all stray executable heaps
				if( _options->Verbose )
					fprintf( stdout, "INFO: Looking at unattached executable heaps...\r\n" );

				int count_new_header_hashes = 0;
				for (set<unsigned __int64>::iterator it=executable_heaps.begin(); it!=executable_heaps.end(); it++)
				{
					// Unattached executable page. First check hash of crc32 of first 2kb of memory since import reconstruction hashing is
					// very expensive.
					unsigned __int64 chunk_header_hash = this->hash_codechunk_header(*it);

					if( _options->Verbose )
						fprintf( stdout, "INFO: Unattached heap start hash 0x%llX\r\n", chunk_header_hash );

					if( chunk_header_hash != 0 && !_db_clean->contains(chunk_header_hash) )
					{
						if( _options->Verbose )
							fprintf( stdout, "INFO: Unattached heap start hash is new.\r\n" );
						
						if( count_new_header_hashes++ > CODECHUNK_NEW_HASH_LIMIT )
						{
							if( _options->Verbose )
								fprintf( stdout, "INFO: Too many unique loose code chunks. Stopped processing more chunks.\r\n" );
							break; // Too many new code chunks
						}
						
						// Calculate the generic import reference hash as well
						pe_header* header = new pe_header( _pid, (void*) *it, modules, _options );
						header->build_pe_header( 0x1000, true, 1 ); // 64bit, only build it with the 1 executable section for performance reasons
						header->process_sections();

						// Get the import attributes of this header
						IMPORT_SUMMARY import_summary = header->get_imports_information(&this->_export_list);

						// Check hash
						if( import_summary.HASH_GENERIC != 0 && !_db_clean->contains(import_summary.HASH_GENERIC) )
						{
							if( _options->Verbose )
								fprintf( stdout, "INFO: Unattached executable heap at 0x%llX found with %i imports matched.\r\n", *it, import_summary.COUNT_UNIQUE_IMPORT_ADDRESSES );
							
							if( header->somewhat_parsed() && import_summary.COUNT_UNIQUE_IMPORT_ADDRESSES >= 2 ) // Require at least 5 imports for dumping
							{
								fprintf( stdout, "Dumping unattached executable code chunk from 0x%llX.\r\n", *it );
								pe_header* header_dump = new pe_header( _pid, (void*) *it, modules, _options );
								header_dump->build_pe_header( 0x1000, true ); // 64bit
								header_dump->set_name("codechunk");
								dump_header(header_dump, *it, _pid);
								delete header_dump;
								
								header_dump = new pe_header( _pid, (void*) *it, modules, _options );
								header_dump->build_pe_header( 0x1000, false ); // 32bit
								header_dump->set_name("codechunk");
								dump_header(header_dump, *it, _pid);
								delete header_dump;
							}
						}
						delete header;
					}
				}
				if( _options->Verbose )
					fprintf( stdout, "INFO: Done looking at unattached executable heaps...\r\n" );
			}

			delete modules;
		}
	}
}



dump_process::~dump_process(void)
{
	if (_term_hook != NULL)
		delete _term_hook;
	if (_process_name != NULL)
		delete[] _process_name;
	if( _ph != NULL )
		CloseHandle( _ph );
}

```

`pd/dump_process.h`:

```h
#pragma once

// content
#include "pe_header.h"
#include "pe_hash_database.h"
#include "windows.h"
#include <tlhelp32.h>
#include "simple.h"
#include "module_list.h"
#include "DynArray.h"
#include "export_list.h"
#include "hash.h"
#include <set>
#include "terminate_monitor_hook.h"

#define PAGE_SIZE 0x1000
#define CODECHUNK_HEADER_HASH_SIZE 0x200 // First X bytes are CRC32'd of each loose code chunk. Only unique CRC32s are processed deeply.
#define CODECHUNK_NEW_HASH_LIMIT 500 // At most X code chunks processed deeply per process

using namespace std;
using namespace std::tr1;


struct MBI_BASIC_INFO
{
	__int64 base;
	__int64 end;
	DWORD protect;
	bool valid;
	bool executable;
};

class dump_process
{
	pe_hash_database* _db_clean;
	bool _opened;
	HANDLE _ph;
	DWORD _pid;
	char* _process_name;
	export_list _export_list;
	bool _export_list_built;
	PD_OPTIONS* _options;
	terminate_monitor_hook* _term_hook;

	unsigned __int64 _address_main_module = NULL;

	bool _loaded_is64;
	bool _is64;
	bool _quieter; // Suppress some of the error and warning messages

	MBI_BASIC_INFO get_mbi_info(unsigned __int64 address);

public:
	dump_process(DWORD pid, pe_hash_database* db, PD_OPTIONS* options, bool quieter);
	void dump_all();
	void dump_region(__int64 base);
	void dump_header(pe_header* header, __int64 base, DWORD pid);
	DWORD get_pid() { return _pid; };
	bool build_export_list();
	bool build_export_list(export_list* result, char* library, module_list* modules);
	int get_all_hashes(unordered_set<unsigned __int64>* output_hashes);
	unsigned __int64 hash_codechunk_header(__int64 base);
	bool is64();
	bool get_process_name(char* process_name, SIZE_T byte_length);

	// Functions for dumping processes as they close
	bool monitor_close_start(); // start terminate hooks
	bool monitor_close_is_waiting(); // check if the process has closed and is waiting dumping
	bool monitor_close_dump_and_resume(); // dumps the process if it is waiting dumping
	bool monitor_close_stop(); // stop terminate hooks

	~dump_process(void);
};
```

`pd/export_list.cpp`:

```cpp
#include "StdAfx.h"
#include "export_list.h"


export_entry::export_entry(char* library_name, char* name, WORD ord, unsigned __int64 rva, unsigned __int64 address, bool is64)
{
	// Copy the strings locally, knowing the function might not have a name but has to have a library name
	if (library_name != NULL)
	{
		this->library_name = new char[strlen(library_name) + 1];
		strcpy(this->library_name, library_name);
	}
	else
	{
		this->library_name = NULL;
	}

	if( name != NULL )
	{
		this->name = new char[strlen(name) + 1];
		strcpy( this->name, name );
	}
	else
	{
		this->name = NULL;
	}

	this->is64 = is64;
	this->ord = ord;
	this->rva = rva;
	this->address = address;
}

export_entry::export_entry(export_entry* other)
{
	// Copy the strings locally, knowing the function might not have a name but has to have a library name
	if (other->library_name != NULL)
	{
		this->library_name = new char[strlen(other->library_name) + 1];
		strcpy(this->library_name, other->library_name);
	}
	else
	{
		this->library_name = NULL;
	}
	
	if( other->name != NULL )
	{
		this->name = new char[strlen(other->name) + 1];
		strcpy( this->name, other->name );
	}
	else
	{
		this->name = NULL;
	}

	this->is64 = other->is64;
	this->ord = other->ord;
	this->rva = other->rva;
	this->address = other->address;
}

export_entry::~export_entry(void)
{
	if( library_name != NULL )
		delete [] library_name;
	if( name != NULL )
		delete [] name;
}

export_list::export_list()
{
	_min64 = _UI64_MAX;
	_max64 = UINT_MAX;
	_min32 = UINT_MAX;
	_max32 = 0;
	_bits32 = 0;
	_bits64 = 0;
}

bool export_list::contains(unsigned __int64 address)
{
	// Look up a 64-bit value
	if ( address <= UINT_MAX )
		return contains((unsigned __int32)address);
	
	if (address > _max64 || address < _min64 || (address & ~_bits64) > 0)
	{
		// We know there is no match by this quick filtering. This improves performance hugely.
		return false;
	}

	// Lookup the address
	unordered_set<unsigned __int64>::const_iterator got = _addresses.find(address);
	if (got != _addresses.end())
	{
		return true;
	}
	return false;
}

bool export_list::contains(unsigned __int32 address)
{
	// Look up a 32-bit value
	if (address > _max32 || address < _min32 || (address & ~_bits32) > 0)
	{
		// We know there is no match by this quick filtering. This improves performance hugely.
		return false;
	}

	// Lookup the address
	unordered_set<unsigned __int64>::const_iterator got = _addresses.find(address);
	if (got != _addresses.end())
	{
		return true;
	}
	return false;
}

unsigned __int64 export_list::find_export(char* library, char* name, bool is64)
{
	// Find the specified procedure in the corresponding library. Limit it to the specific 32-bit or 64-bit version of the library.
	for (unordered_map<unsigned __int64, export_entry*>::iterator it = _address_to_exports.begin(); it != _address_to_exports.end(); ++it)
	{
		//if( strcmp(it->second->library_name,"kernel32.dll") == 0 )
		//	printf("%s::%s\r\n", it->second->library_name, it->second->name);
		if (it->second->is64 == is64 && (library == NULL || strcmpi(library, it->second->library_name) == 0 ) && strcmpi(name, it->second->name) == 0)
		{
			// Found a match
			return it->second->address;
		}
	}

	// No match
	return NULL;
}

export_entry export_list::find(unsigned __int64 address)
{
	// Lookup the address
	unordered_map<unsigned __int64, export_entry*>::const_iterator got = _address_to_exports.find(address);
	if (got != _address_to_exports.end())
	{
		return got->second;
	}
	return NULL;
}

void export_list::add_export(unsigned __int64 address, export_entry* entry)
{
	// Register this export address for quick lookups later
	if (_address_to_exports.count(address) == 0)
	{
		_address_to_exports.insert(std::pair<unsigned __int64, export_entry*>(address, new export_entry(entry)));

		if (_addresses.count(address) == 0)
		{
			_addresses.insert(address);

			// Update our quick-lookup values
			if ( address > UINT_MAX )
			{
				// 64bit value
				if (address > _max64)
					_max64 = address;
				if (address < _min64)
					_min64 = address;
				_bits64 = _bits64 | address;
			}
			else
			{
				// 32bit value
				if (address > _max32)
					_max32 = address;
				if (address < _min32)
					_min32 = address;
				_bits32 = _bits32 | address;
			}
		}
	}
}

bool export_list::add_exports(export_list* other)
{
	// Merge the exports from the other list with the current export list
	for (unordered_map<unsigned __int64,export_entry*>::iterator it = other->_address_to_exports.begin();
        it != other->_address_to_exports.end(); ++it) 
	{
		add_export(it->first, it->second);
	}
	return true;
}


bool export_list::add_exports(unsigned char* image, SIZE_T image_size, unsigned __int64 image_base, IMAGE_EXPORT_DIRECTORY* export_directory, bool is64)
{
	if( export_directory->NumberOfFunctions > 0 && export_directory->AddressOfNameOrdinals != 0 )
	{
		char* library_name = (char*) ((__int64) export_directory->Name + image);
		if( !test_read(image, image_size, (unsigned char*) library_name, 0x1ff) || strlen(library_name) == 0 )
		{
			// Library name is invalid, no point in continuing to parse since we need this name to reconstruct any imports anyway
			//throw std::invalid_argument( printf("Invalid library export directory module name. Unable to add exports to table for import reconstruction. Library base 0x%llX.", (unsigned long long int) image_base ) );
			fprintf( stderr, "WARNING: Invalid library export directory module name. Unable to add exports to table for import reconstruction. Library base 0x%llX.\r\n",
											(unsigned long long int) image_base );
			return false;
		}
		
		// Parse the export directory
		for (int i = 0; i < export_directory->NumberOfNames; i++)
		{
			// Load the ordinal
			if( test_read(image, image_size, image + export_directory->AddressOfNameOrdinals + i*2, 2) )
			{
				DWORD ordinal_relative = *(WORD*)(export_directory->AddressOfNameOrdinals + i*2 + image);
				DWORD ordinal = export_directory->Base + ordinal_relative;
				
				// Load the name, there doesn't have to be one
				char* name = NULL;
				if (i < export_directory->NumberOfNames)
				{
					if( test_read(image, image_size, image + export_directory->AddressOfNames + i*4, 4) )
					{
						DWORD name_offset = *((DWORD*) (image + export_directory->AddressOfNames + i*4));
						
						if( test_read(image, image_size, image + name_offset, 0x4f) )
						{
							name = (char*) ( name_offset + image );
						}
					}
				}
				

				// Load the rva
				if( test_read(image, image_size, image + export_directory->AddressOfFunctions + ordinal_relative*4, 4) )
				{
					__int64 rva = *((DWORD*)(image + export_directory->AddressOfFunctions + ordinal_relative * 4));

					// Don't consider rva's of multiple of 0x1000 to prevent making mistakes in dump repairs
					if( rva % 0x1000 != 0 )
					{
						__int64 address = image_base + rva;
						
						// Add this export
						export_entry* new_entry = new export_entry( library_name, name, ordinal, rva, address, is64);
						add_export(address, new_entry);
						delete new_entry;
					}
				}
				
			}
		}
	}
	return true;
	
	
}

export_list::~export_list(void)
{
	// Clean up the export list
	for (unordered_map<unsigned __int64,export_entry*>::iterator it = _address_to_exports.begin();
        it != _address_to_exports.end(); ++it) 
	{
		delete it->second;
	}
	_address_to_exports.clear();
}

```

`pd/export_list.h`:

```h
#pragma once

#include "DynArray.h"
#include "windows.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdexcept>
#include <unordered_map>
#include <unordered_set>
#include "utils.h"
#include "limits.h"

using namespace std;
using namespace std::tr1;

class export_entry
{
public:
	char* library_name;
	char* name;
	WORD ord;
	bool is64;
	unsigned __int64 rva;
	unsigned __int64 address;

	export_entry(char* library_name, char* name, WORD ord, unsigned __int64 rva, unsigned __int64 address, bool is64);
	export_entry(export_entry* other);
	~export_entry(void);
};


class export_list
{
	unsigned __int64 _min64;
	unsigned __int64 _max64;
	unsigned __int32 _min32;
	unsigned __int32 _max32;
	unsigned __int32 _bits32;
	unsigned __int64 _bits64;

	unordered_map<unsigned __int64, export_entry*> _address_to_exports; // List of export addresses in this export list
	unordered_set<unsigned __int64> _addresses; // List of export addresses
public:
	

	export_list();
	
	bool add_exports(unsigned char* image, SIZE_T image_size, unsigned __int64 image_base, IMAGE_EXPORT_DIRECTORY* header_export_directory, bool is64);
	bool add_exports(export_list* other);
	void add_export(unsigned __int64 address, export_entry* entry);

	// Find export addresses in a process
	unsigned __int64 find_export(char* library, char* name, bool is64);

	// Functions to get quick filter values before doing a lookup
	bool contains(unsigned __int64 address);
	bool contains(unsigned __int32 address);
	export_entry find(unsigned __int64 address);
	unsigned __int64 get_min64() { return _min64; };
	unsigned __int64 get_max64() { return _max64; };
	unsigned __int32 get_min32() { return _min32; };
	unsigned __int32 get_max32() { return _max32; };
	unsigned __int32 get_nobits32() { return ~_bits32; };
	unsigned __int64 get_nobits64() { return ~_bits64; };

	~export_list(void);
};

```

`pd/hash.cpp`:

```cpp
#include "StdAfx.h"
#include "hash.h"

/* Crc - 32 BIT ANSI X3.66 CRC checksum files */


/**********************************************************************\
|* Demonstration program to compute the 32-bit CRC used as the frame  *|
|* check sequence in ADCCP (ANSI X3.66, also known as FIPS PUB 71     *|
|* and FED-STD-1003, the U.S. versions of CCITT's X.25 link-level     *|
|* protocol).  The 32-bit FCS was added via the Federal Register,     *|
|* 1 June 1982, p.23798.  I presume but don't know for certain that   *|
|* this polynomial is or will be included in CCITT V.41, which        *|
|* defines the 16-bit CRC (often called CRC-CCITT) polynomial.  FIPS  *|
|* PUB 78 says that the 32-bit FCS reduces otherwise undetected       *|
|* errors by a factor of 10^-5 over 16-bit FCS.                       *|
\**********************************************************************/

/* Need an unsigned type capable of holding 32 bits; */


/* Copyright (C) 1986 Gary S. Brown.  You may use this program, or
   code or tables extracted from it, as desired without restriction.*/

/* First, the polynomial itself and its table of feedback terms.  The  */
/* polynomial is                                                       */
/* X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0 */
/* Note that we take it "backwards" and put the highest-order term in  */
/* the lowest-order bit.  The X^32 term is "implied"; the LSB is the   */
/* X^31 term, etc.  The X^0 term (usually shown as "+1") results in    */
/* the MSB being 1.                                                    */

/* Note that the usual hardware shift register implementation, which   */
/* is what we're using (we're merely optimizing it by doing eight-bit  */
/* chunks at a time) shifts bits into the lowest-order term.  In our   */
/* implementation, that means shifting towards the right.  Why do we   */
/* do it this way?  Because the calculated CRC must be transmitted in  */
/* order from highest-order term to lowest-order term.  UARTs transmit */
/* characters in order from LSB to MSB.  By storing the CRC this way,  */
/* we hand it to the UART in the order low-byte to high-byte; the UART */
/* sends each low-bit to hight-bit; and the result is transmission bit */
/* by bit from highest- to lowest-order term without requiring any bit */
/* shuffling on our part.  Reception works similarly.                  */

/* The feedback terms table consists of 256, 32-bit entries.  Notes:   */
/*                                                                     */
/*  1. The table can be generated at runtime if desired; code to do so */
/*     is shown later.  It might not be obvious, but the feedback      */
/*     terms simply represent the results of eight shift/xor opera-    */
/*     tions for all combinations of data and CRC register values.     */
/*                                                                     */
/*  2. The CRC accumulation logic is the same for all CRC polynomials, */
/*     be they sixteen or thirty-two bits wide.  You simply choose the */
/*     appropriate table.  Alternatively, because the table can be     */
/*     generated at runtime, you can start by generating the table for */
/*     the polynomial in question and use exactly the same "updcrc",   */
/*     if your application needn't simultaneously handle two CRC       */
/*     polynomials.  (Note, however, that XMODEM is strange.)          */
/*                                                                     */
/*  3. For 16-bit CRCs, the table entries need be only 16 bits wide;   */
/*     of course, 32-bit entries work OK if the high 16 bits are zero. */
/*                                                                     */
/*  4. The values must be right-shifted by eight bits by the "updcrc"  */
/*     logic; the shift must be unsigned (bring in zeroes).  On some   */
/*     hardware you could probably optimize the shift in assembler by  */
/*     using byte-swap instructions.                                   */

static DWORD crc_32_tab[] = { /* CRC polynomial 0xedb88320 */
0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};



DWORD updateCRC32(unsigned char ch, DWORD crc)
{
      return UPDC32(ch, crc);
}

DWORD crc32buf(char *buf, size_t len)
{
      register DWORD oldcrc32;

      oldcrc32 = 0xFFFFFFFF;

      for ( ; len; --len, ++buf)
      {
            oldcrc32 = UPDC32(*buf, oldcrc32);
      }

      return ~oldcrc32;
      
}
```

`pd/hash.h`:

```h
#pragma once

#include "StdAfx.h"
#include "hash.h"
#include <stdio.h>
#include "windows.h"

/* Crc - 32 BIT ANSI X3.66 CRC checksum files */

#include <stdio.h>


/**********************************************************************\
|* Demonstration program to compute the 32-bit CRC used as the frame  *|
|* check sequence in ADCCP (ANSI X3.66, also known as FIPS PUB 71     *|
|* and FED-STD-1003, the U.S. versions of CCITT's X.25 link-level     *|
|* protocol).  The 32-bit FCS was added via the Federal Register,     *|
|* 1 June 1982, p.23798.  I presume but don't know for certain that   *|
|* this polynomial is or will be included in CCITT V.41, which        *|
|* defines the 16-bit CRC (often called CRC-CCITT) polynomial.  FIPS  *|
|* PUB 78 says that the 32-bit FCS reduces otherwise undetected       *|
|* errors by a factor of 10^-5 over 16-bit FCS.                       *|
\**********************************************************************/


/* Copyright (C) 1986 Gary S. Brown.  You may use this program, or
   code or tables extracted from it, as desired without restriction.*/

/* First, the polynomial itself and its table of feedback terms.  The  */
/* polynomial is                                                       */
/* X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0 */
/* Note that we take it "backwards" and put the highest-order term in  */
/* the lowest-order bit.  The X^32 term is "implied"; the LSB is the   */
/* X^31 term, etc.  The X^0 term (usually shown as "+1") results in    */
/* the MSB being 1.                                                    */

/* Note that the usual hardware shift register implementation, which   */
/* is what we're using (we're merely optimizing it by doing eight-bit  */
/* chunks at a time) shifts bits into the lowest-order term.  In our   */
/* implementation, that means shifting towards the right.  Why do we   */
/* do it this way?  Because the calculated CRC must be transmitted in  */
/* order from highest-order term to lowest-order term.  UARTs transmit */
/* characters in order from LSB to MSB.  By storing the CRC this way,  */
/* we hand it to the UART in the order low-byte to high-byte; the UART */
/* sends each low-bit to hight-bit; and the result is transmission bit */
/* by bit from highest- to lowest-order term without requiring any bit */
/* shuffling on our part.  Reception works similarly.                  */

/* The feedback terms table consists of 256, 32-bit entries.  Notes:   */
/*                                                                     */
/*  1. The table can be generated at runtime if desired; code to do so */
/*     is shown later.  It might not be obvious, but the feedback      */
/*     terms simply represent the results of eight shift/xor opera-    */
/*     tions for all combinations of data and CRC register values.     */
/*                                                                     */
/*  2. The CRC accumulation logic is the same for all CRC polynomials, */
/*     be they sixteen or thirty-two bits wide.  You simply choose the */
/*     appropriate table.  Alternatively, because the table can be     */
/*     generated at runtime, you can start by generating the table for */
/*     the polynomial in question and use exactly the same "updcrc",   */
/*     if your application needn't simultaneously handle two CRC       */
/*     polynomials.  (Note, however, that XMODEM is strange.)          */
/*                                                                     */
/*  3. For 16-bit CRCs, the table entries need be only 16 bits wide;   */
/*     of course, 32-bit entries work OK if the high 16 bits are zero. */
/*                                                                     */
/*  4. The values must be right-shifted by eight bits by the "updcrc"  */
/*     logic; the shift must be unsigned (bring in zeroes).  On some   */
/*     hardware you could probably optimize the shift in assembler by  */
/*     using byte-swap instructions.                                   */

DWORD updateCRC32(unsigned char ch, DWORD crc);
DWORD crc32buf(char *buf, size_t len);

#define UPDC32(b, c) (crc_32_tab[((int)c ^ b) & 0xff] ^ ((c >> 8) & 0x00FFFFFF))
```

`pd/module_list.cpp`:

```cpp
#include "StdAfx.h"
#include "module_list.h"


module_list::module_list()
{
	// Empty list
}

module_list::module_list( DWORD pid )
{
	#if defined(_WIN64)
	// List modules on a 64 bit machine. A 64 bit machine is assumed to be Windows Vista+
	HMODULE hMods[2048];
	DWORD cbNeeded;
    unsigned int i;
	HANDLE ph = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                            FALSE, pid );
	if( ph != NULL )
	{
		if( EnumProcessModulesEx(ph, hMods, sizeof(hMods), &cbNeeded, LIST_MODULES_ALL))
		{
			for ( i = 0; i < (cbNeeded / sizeof(HMODULE)); i++ )
			{
				// Query the module basic information
				MODULEINFO info;
				if( GetModuleInformation( ph, hMods[i], &info, sizeof(MODULEINFO) ) )
				{
					// Check if this base address is already occupied
					unordered_map<unsigned __int64, module*>::const_iterator item = _modules.find( (unsigned __int64) info.lpBaseOfDll );

					if( item == _modules.end() )
					{
						// Add this module
						_modules[(unsigned __int64) info.lpBaseOfDll ] = new module( ph, hMods[i], info );
					}
				}
				else
				{
					PrintLastError(L"module_list GetModuleInformation");
				}
			}
		}

		CloseHandle( ph );				
	}
	else
	{
		if( GetLastError() == 299 )
			fprintf(stderr, "ERROR: Unable to open process PID 0x%x since it is a 64 bit process and this tool is running as a 32 bit process.\r\n", pid);
		else
			PrintLastError(L"module_list OpenProcess");
	}
	#elif defined(_WIN32)

	HANDLE hSnapshot=CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
	if ( hSnapshot == INVALID_HANDLE_VALUE )
	{
		if( global_flag_verbose )
			printf ("WARNING: Could not gather process information for process pid 0x%X, error code (%d).\r\n", pid, GetLastError());
		return;
	}

	MODULEENTRY32 tmpModule;
	tmpModule.dwSize = sizeof(MODULEENTRY32);
	if( Module32First(hSnapshot, &tmpModule) )
	{
		// Add this first module to our array
		tmpModule.dwSize = sizeof(MODULEENTRY32);

		// Check if this base address is already occupied
		unordered_map<unsigned __int64, module*>::const_iterator item = _modules.find( (unsigned __int64) tmpModule.modBaseAddr );
		if( item == _modules.end() )
		{
			// Add this module
			_modules[(unsigned __int64) tmpModule.modBaseAddr ] = new module( tmpModule );
		}

		while(Module32Next(hSnapshot,&tmpModule))
		{
			// Add this module to our array
			unordered_map<unsigned __int64, module*>::const_iterator item = _modules.find( (unsigned __int64) tmpModule.modBaseAddr );
			if( item == _modules.end() )
			{
				// Add this module
				_modules[(unsigned __int64) tmpModule.modBaseAddr ] = new module( tmpModule );
			}

			tmpModule.dwSize = sizeof(MODULEENTRY32);
		}
	}

	CloseHandle(hSnapshot);

	#endif
}

module_list::~module_list(void)
{
	// Clean up the module list
	for ( unordered_map<unsigned __int64, module*>::const_iterator item = _modules.begin(); item != _modules.end(); ++item )
		delete item->second;
}

```

`pd/module_list.h`:

```h
#pragma once

#include <stdio.h>
#include "windows.h"
#include "simple.h"
#include <tlhelp32.h>
#include <unordered_map>
#include "Psapi.h"

using namespace std::tr1;


extern bool global_flag_verbose;

class module
{
	public:
	unsigned __int64 start;
	unsigned __int64 size;
	char* full_name;
	char* short_name;

	module( HANDLE ph, HMODULE mh, MODULEINFO info )
	{
		this->start = (unsigned __int64) info.lpBaseOfDll;
		this->size = (unsigned __int64) info.SizeOfImage;

		full_name = new char[260];
		short_name = new char[256];

		// Read in the short and long name
		GetModuleFileNameExA( ph, mh, full_name, 260 );
		GetModuleBaseNameA( ph, mh, short_name, 256 );
	}

	module( MODULEENTRY32 tmpModule )
	{
		this->start = (unsigned __int64) tmpModule.modBaseAddr;
		this->size = (unsigned __int64) tmpModule.modBaseSize;

		full_name = new char[260];
		short_name = new char[256];

		_snprintf( full_name, 259, "%S", tmpModule.szExePath );
		_snprintf( short_name, 255, "%S", tmpModule.szModule );
	}

	~module()
	{
		if( full_name != NULL )
			delete[] full_name;
		if( short_name != NULL )
			delete[] short_name;
	}
};

class module_list
{
	
	HANDLE _ph;

public:
	unordered_map <unsigned __int64, module*> _modules;
	module_list();
	module_list( DWORD pid );
	~module_list(void);
};

```

`pd/pd.cpp`:

```cpp
// pd.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "windows.h"
#include "pe_header.h"
#include <tlhelp32.h>
#include <cstdio>
#include "pe_hash_database.h"
#include "dump_process.h"
#include "simple.h"
#include "work_queue.h"
#include <thread>
#include "close_watcher.h"


BOOL is_win64()
{
	#if defined(_WIN64)
		return TRUE;  // 64-bit programs run only on Win64
	#elif defined(_WIN32)
		// 32-bit programs run on both 32-bit and 64-bit Windows
		// so must sniff
		BOOL f64 = FALSE;
		return IsWow64Process(GetCurrentProcess(), &f64) && f64;
	#else
		return FALSE; // Win64 does not support Win16
	#endif
}

bool is_elevated(HANDLE h_Process)
{
	HANDLE h_Token;
	TOKEN_ELEVATION t_TokenElevation;
    TOKEN_ELEVATION_TYPE e_ElevationType;
	DWORD dw_TokenLength;
	
	if( OpenProcessToken(h_Process, TOKEN_READ | TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES , &h_Token) )
	{
		if(GetTokenInformation(h_Token,TokenElevation,&t_TokenElevation,sizeof(t_TokenElevation),&dw_TokenLength))
		{
			if(t_TokenElevation.TokenIsElevated != 0)
			{
				if(GetTokenInformation(h_Token,TokenElevationType,&e_ElevationType,sizeof(e_ElevationType),&dw_TokenLength))
				{
					if(e_ElevationType == TokenElevationTypeFull || e_ElevationType == TokenElevationTypeDefault)
					{
						return true;
					}
				}
			}
		}
	}

    return false;
}


bool get_privileges(HANDLE h_Process)
{
	HANDLE h_Token;
	DWORD dw_TokenLength;
	if( OpenProcessToken(h_Process, TOKEN_READ | TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES , &h_Token) )
	{
		// Read the old token privileges
		TOKEN_PRIVILEGES* privilages = new TOKEN_PRIVILEGES[100];
		if( GetTokenInformation(h_Token, TokenPrivileges, privilages,sizeof(TOKEN_PRIVILEGES)*100,&dw_TokenLength) )
		{
			// Enable all privileges
			for( int i = 0; i < privilages->PrivilegeCount; i++ )
			{
				privilages->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
			}
			
			// Adjust the privilges
			if(AdjustTokenPrivileges( h_Token, false, privilages, sizeof(TOKEN_PRIVILEGES)*100, NULL, NULL  ))
			{
				delete[] privilages;
				return true;
			}
		}
		delete[] privilages;
	}
	return false;
}

bool ConsoleRequestingClose = false;
BOOL WINAPI ConsoleHandler(DWORD CEvent)
{
	char mesg[128];

	switch (CEvent)
	{
	case CTRL_C_EVENT:
	case CTRL_BREAK_EVENT:
		// Cancel the event and set closing flag
		printf("Close request received.\r\n");
		ConsoleRequestingClose = true;
		break;
	case CTRL_CLOSE_EVENT:
	case CTRL_LOGOFF_EVENT:
	case CTRL_SHUTDOWN_EVENT:
		// We need to cleanup before terminating since we can't cancel this event
		printf("Terminate request received.\r\n");
		ConsoleRequestingClose = true;
		Sleep(30000); // hackjob to make sure it cleans up
		break;
	}
	return TRUE;
}

void add_process_hashes( DWORD pid, pe_hash_database* db, PD_OPTIONS* options )
{
	// Build a list of the hashes from this process
	unordered_set<unsigned __int64> new_hashes;

	// Process this process
	dump_process* dumper = new dump_process( pid, db, options, true );
	dumper->get_all_hashes( &new_hashes );
	delete dumper;
	
	// Add all these hashes to the database
	db->add_hashes( new_hashes );
}

void add_process_hashes_worker(Queue<PROCESSENTRY32>* work_queue, pe_hash_database* db, PD_OPTIONS* options)
{
	// Gather hashes from the work queue process list
	while (!work_queue->empty())
	{
		// Process the hashes for this process
		PROCESSENTRY32 entry;
		if (work_queue->pop(entry))
		{
			add_process_hashes(entry.th32ProcessID, db, options);
		}
	}
}



void add_system_hashes( pe_hash_database* db, PD_OPTIONS* options )
{
	// Add clean hashes from all processes on the system right now

	// Build a list of the hashes from all processes
	options->ImportRec = false; // Force no import reconstruciton

	// Build the queue of work from the currently running processes
	Queue<PROCESSENTRY32> work_queue;
	int total_work_count = 0;

	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if( snapshot != INVALID_HANDLE_VALUE )
	{
		if (Process32First(snapshot, &entry) == TRUE)
		{
			while (Process32Next(snapshot, &entry) == TRUE)
			{
				printf("...adding process to work queue: pid 0x%x,%S\r\n", entry.th32ProcessID, entry.szExeFile);
				work_queue.push(entry);
				total_work_count++;
			}
		}
		CloseHandle(snapshot);
	}

	// Create threads processing the work queue
	thread** threads = new thread*[options->NumberOfThreads];
	for (int i = 0; i < options->NumberOfThreads; i++)
	{
		threads[i] = new thread(add_process_hashes_worker, &work_queue, db, options);
	}

	// Wait for queue depletion
	int count = 0;
	bool still_working = false;
	int running_count = 1;
	while (!work_queue.empty() || running_count > 0)
	{
		// Check threads state
		running_count = 0;
		for (int i = 0; i < options->NumberOfThreads; i++)
		{
			if( WaitForSingleObject(threads[i]->native_handle(), 1) == WAIT_TIMEOUT )
				running_count++;
		}

		if (count % 10 == 0)
		{
			// Print the status
			int waiting_count = work_queue.count();
			printf("Hash Queue -> Waiting: %i\tRunning: %i\tComplete: %i\r\n", waiting_count, running_count, total_work_count - (waiting_count + running_count));
		}

		// Wait
		Sleep(50);
		count++;
	}

	// Wait for thread completions
	for (int i = 0; i < options->NumberOfThreads; i++)
	{
		threads[i]->join(); // blocks until each thread is finished
	}

	// Cleanup
	printf("...cleaning up system memory hashes factory\r\n");
	for (int i = 0; i < options->NumberOfThreads; i++)
	{
		delete threads[i];
	}
	delete []threads;
}


void dump_process_worker(Queue<PROCESSENTRY32>* work_queue, pe_hash_database* db, PD_OPTIONS* options)
{
	// Gather hashes from the work queue process list
	unordered_set<unsigned __int64> new_hashes;
	while (!work_queue->empty())
	{
		// Process the hashes for this process
		PROCESSENTRY32 entry;
		if (work_queue->pop(entry))
		{
			// Process this process

			// Dump
			dump_process* dumper = new dump_process(entry.th32ProcessID, db, options, true);
			dumper->dump_all();

			// Exclude these hashes from the next dumps
			dumper->get_all_hashes(&new_hashes);
			db->add_hashes(new_hashes);
			new_hashes.clear();

			delete dumper;
		}
	}
}


void dump_system(pe_hash_database* db, PD_OPTIONS* options)
{
	// Dump modules from all running processes
	
	// Build the queue of work from the currently running processes
	Queue<PROCESSENTRY32> work_queue;
	unordered_set<DWORD> dumping_pids;

	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	int total_work_count = 0;

	if (snapshot != INVALID_HANDLE_VALUE)
	{
		if (Process32First(snapshot, &entry) == TRUE)
		{
			while (Process32Next(snapshot, &entry) == TRUE)
			{
				printf("...adding process to work queue: pid 0x%x,%S\r\n", entry.th32ProcessID, entry.szExeFile);
				work_queue.push(entry);
				dumping_pids.insert(entry.th32ProcessID);
				total_work_count++;
			}
		}
		CloseHandle(snapshot);
	}

	// Create threads processing the work queue
	thread** threads = new thread*[options->NumberOfThreads];
	for (int i = 0; i < options->NumberOfThreads; i++)
	{
		threads[i] = new thread(dump_process_worker, &work_queue, db, options);
	}

	// Wait for queue depletion
	int count = 0;
	bool still_working = false;
	int running_count = 1;
	bool added_new_processes = false;

	while (!work_queue.empty() || running_count > 0 || !added_new_processes)
	{
		// Check threads state
		running_count = 0;
		for (int i = 0; i < options->NumberOfThreads; i++)
		{
			if (WaitForSingleObject(threads[i]->native_handle(), 1) == WAIT_TIMEOUT)
				running_count++;
		}

		// Add any newly started processes at the very end
		if (!added_new_processes && work_queue.empty() && running_count )
		{
			printf("...adding new processes since we started this job\r\n");
			HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
			if (snapshot != INVALID_HANDLE_VALUE)
			{
				if (Process32First(snapshot, &entry) == TRUE)
				{
					while (Process32Next(snapshot, &entry) == TRUE)
					{
						if (dumping_pids.count(entry.th32ProcessID) == 0)
						{
							printf("...adding new process to work queue: pid 0x%x,%S\r\n", entry.th32ProcessID, entry.szExeFile);
							work_queue.push(entry);
							dumping_pids.insert(entry.th32ProcessID);
							total_work_count++;

							// Add a new worker thread if needed
							if (running_count < options->NumberOfThreads)
							{
								// Add a new worker thread
								for (int i = 0; i < options->NumberOfThreads; i++)
								{
									if (WaitForSingleObject(threads[i]->native_handle(), 1) != WAIT_TIMEOUT)
									{
										threads[i]->join(); // blocks until each thread is finished
										delete threads[i];
										threads[i] = new thread(dump_process_worker, &work_queue, db, options);
										break;
									}
								}
							}
						}
					}
				}
				CloseHandle(snapshot);
			}
			added_new_processes = true;
		}

		if (count % 10 == 0)
		{
			// Print the status
			int waiting_count = work_queue.count();
			printf("Dump Queue -> Waiting: %i\tRunning: %i\tComplete: %i\r\n", waiting_count, running_count, total_work_count - (waiting_count + running_count));
		}

		// Wait
		Sleep(50);
		count++;
	}

	// Wait for thread completions
	for (int i = 0; i < options->NumberOfThreads; i++)
	{
		threads[i]->join(); // blocks until each thread is finished
	}

	// Cleanup
	printf("...cleaning up system dump factory\r\n");
	for (int i = 0; i < options->NumberOfThreads; i++)
	{
		delete threads[i];
	}
	delete []threads;
}






bool global_flag_verbose = false;

int _tmain(int argc, _TCHAR* argv[])
{

	get_privileges( GetCurrentProcess() );

	// Process the flags	
	WCHAR* filter = NULL;
	char* processNameFilter = NULL;
	char* clean_database;
	string path = ExePath();
	clean_database = new char[ path.length() + strlen("clean.hashes") + 2 ];
	sprintf( clean_database, "%s\\%s", path.c_str() , "clean.hashes" );

	bool flagHelp = false;
	bool flagHeader = true;
	bool flagPidDump = false;
	bool flagProcessNameDump = false;
	bool flagSystemDump = false;
	bool flagAddressDump = false;
	bool flagDumpCloses = false;

	char* add_directory = NULL;
	bool flagDB_gen = false;
	bool flagDB_genQuick = false;
	bool flagDB_add = false;
	bool flagDB_clean = false;
	bool flagDB_ignore = false;
	bool flagDB_remove = false;
	bool flagRecursion = true;
	
	
	PD_OPTIONS options;
	options.ImportRec = true;
	options.ForceGenHeader = false;
	options.Verbose = false;
	options.EntryPointOverride = -1;
	options.ReconstructHeaderAsDll = false;
	options.DumpChunks = true;
	options.NumberOfThreads = 16; // Default 16 threads
	
	DWORD pid = -1;
	__int64 address = 0;

	if( argc <= 1 )
		flagHelp = true;

	for( int i = 1; i < argc; i++ )
	{
		if( lstrcmp(argv[i],L"--help") == 0 || lstrcmp(argv[i],L"-help") == 0 || lstrcmp(argv[i],L"-h") == 0 || lstrcmp(argv[i],L"--h") == 0)
			flagHelp = true;
		else if( lstrcmp(argv[i],L"-nh") == 0 )
			flagHeader = false;
		else if( lstrcmp(argv[i],L"-nr") == 0 )
			flagRecursion = false;
		else if( lstrcmp(argv[i],L"-ni") == 0 )
			options.ImportRec = false;
		else if( lstrcmp(argv[i],L"-nc") == 0 )
			options.DumpChunks = false;
		else if (lstrcmp(argv[i], L"-nt") == 0)
			options.NumberOfThreads = 1;
		else if (lstrcmp(argv[i], L"-closemon") == 0)
			flagDumpCloses = true;
		else if( lstrcmp(argv[i],L"-v") == 0 )
		{
			options.Verbose = true;
			global_flag_verbose = true;
		}
		else if( lstrcmp(argv[i],L"-g") == 0 )
			options.ForceGenHeader = true;
		else if( lstrcmp(argv[i],L"-pid") == 0 )
		{
			if( i + 1 < argc )
			{
				// Attempt to parse this second part
				filter = argv[i+1];

				// Check the prefix
				bool isHex = false;
				wchar_t* prefix = new wchar_t[3];
				memcpy(prefix, filter, 4);
				prefix[2] = 0;

				if( wcscmp(prefix, L"0x") == 0 )
				{
					filter = &filter[2];
					isHex = true;
				}
				delete[] prefix;
				
				// Extract the pid from the string
				if( (isHex && swscanf(filter, L"%x", &pid) > 0) ||
					(!isHex && swscanf(filter, L"%i", &pid) > 0))
				{
					// Successfully parsed the PID
					flagPidDump = true;
				}
				else
				{
					fprintf(stderr,"Failed to parse -pid argument. It must be followed by a number:\r\n\teg. 'pd -pid 0x10A'\r\n");
					exit(0);
				}

				// Skip next argument
				i++;
			}
			else
			{
				fprintf(stderr,"Failed to parse -pid argument. It must be followed by a number:\r\n\teg. 'pd -pid 0x10A'\r\n");
				exit(0);
			}
		}
		else if( lstrcmp(argv[i],L"-a") == 0 )
		{
			if( i + 1 < argc )
			{
				// Attempt to parse this second part
				filter = argv[i+1];

				// Check the prefix
				bool isHex = false;
				wchar_t* prefix = new wchar_t[3];
				memcpy(prefix, filter, 4);
				prefix[2] = 0;

				if( wcscmp(prefix, L"0x") == 0 )
				{
					filter = &filter[2];
					isHex = true;
				}
				delete[] prefix;
				
				// Extract the pid from the string
				if( (isHex && swscanf(filter, L"%llx", &address) > 0) ||
					(!isHex && swscanf(filter, L"%llu", &address) > 0))
				{
					// Successfully parsed the PID
					flagAddressDump = true;
				}
				else
				{
					fprintf(stderr,"Failed to parse -a address argument. It must be followed by a number:\r\n\teg. 'pd -a 0x401000 -pid 0x10A'\r\n");
					exit(0);
				}

				// Skip next argument
				i++;
			}
			else
			{
				fprintf(stderr,"Failed to parse -pid argument. It must be followed by a number:\r\n\teg. 'pd -pid 0x10A'\r\n");
				exit(0);
			}
		}
		else if( lstrcmp(argv[i],L"-p") == 0 )
		{
			if( i + 1 < argc )
			{
				// Extract the process name filter regex
				processNameFilter = new char[wcslen(argv[i+1]) + 1];
				sprintf( processNameFilter, "%S", argv[i+1] );
				
				flagProcessNameDump = true;
				
				// Skip next argument
				i++;
			}
			else
			{
				fprintf(stderr,"Failed to parse -p argument. It must be followed by a regex match statement:\r\n\teg. 'pd -p chrome.exe'\r\n");
				exit(0);
			}
		}
		else if( lstrcmp(argv[i],L"-t") == 0 )
		{
			if( i + 1 < argc )
			{
				// Extract the number of threads to use
				filter = argv[i+1];

				// Check the prefix
				bool isHex = false;
				wchar_t* prefix = new wchar_t[3];
				memcpy(prefix, filter, 4);
				prefix[2] = 0;

				if( wcscmp(prefix, L"0x") == 0 )
				{
					filter = &filter[2];
					isHex = true;
				}
				delete[] prefix;
				
				// Extract the number from the string
				if( (isHex && swscanf(filter, L"%x", &options.NumberOfThreads) > 0) ||
					(!isHex && swscanf(filter, L"%i", &options.NumberOfThreads) > 0))
				{
					// Successfully parsed the value
					if( options.NumberOfThreads < 1 )
					{
						fprintf(stderr,"Failed to parse -t argument. It must be followed by a number 1 or larger:\r\n\teg. 'pd -system -t 10'\r\n");
						exit(0);
					}
					printf("Set number of threads to %i.\r\n", options.NumberOfThreads);
				}
				else
				{
					fprintf(stderr,"Failed to parse -t argument. It must be followed by a number:\r\n\teg. 'pd -system -t 10'\r\n");
					exit(0);
				}
				
				// Skip next argument
				i++;
			}
			else
			{
				fprintf(stderr,"Failed to parse -t argument. It must be followed by a number:\r\n\teg. 'pd -system -t 10'\r\n");
				exit(0);
			}
		}
		else if( lstrcmp(argv[i],L"-c") == 0 )
		{
			if( i + 1 < argc )
			{
				// Extract the path to use as the clean file database
				clean_database = new char[wcslen(argv[i+1]) + 1];
				sprintf( clean_database, "%S", argv[i+1] );
				printf("Set clean database filepath to %s.\r\n", clean_database);
				
				// Skip next argument
				i++;
			}
			else
			{
				fprintf(stderr,"Failed to parse -c argument. It must be followed by a path to the clean file hash database to use.\r\n");
				exit(0);
			}
		}
		else if( lstrcmp(argv[i],L"-o") == 0 )
		{
			if( i + 1 < argc )
			{
				// Extract the default output path to use
				char* output_path = new char[wcslen(argv[i+1]) + 1];
				sprintf( output_path, "%S", argv[i+1] );
				options.set_output_path( output_path );
				printf("Set output path to %s.\r\n", output_path);
				delete [] output_path;
				
				// Skip next argument
				i++;
			}
			else
			{
				fprintf(stderr,"Failed to parse -c argument. It must be followed by a path to the clean file hash database to use.\r\n");
				exit(0);
			}
		}
		else if( lstrcmp(argv[i],L"-system") == 0 )
			flagSystemDump = true;
		else if( lstrcmp(argv[i],L"-db") == 0 )
		{
			// Process the db commands
			if(  i + 1 < argc )
			{
				// Process this db command
				// -db gen
				// -db genquick
				// -db add [directory]
				// -db clean
				// -db ignore
				if( lstrcmp(argv[i+1],L"gen") == 0 )
				{
					flagDB_gen = true;
				}else if( lstrcmp(argv[i+1],L"genquick") == 0 )
				{
					flagDB_genQuick = true;
				}else if( lstrcmp(argv[i+1],L"clean") == 0 )
				{
					flagDB_clean = true;
				}else if( lstrcmp(argv[i+1],L"ignore") == 0 )
				{
					flagDB_ignore = true;
				}else if( lstrcmp(argv[i+1],L"add") == 0 )
				{
					// Has yet another argument to specify the directory to add
					if(  i + 2 < argc )
					{
						// Extract the directory name to add
						add_directory = new char[wcslen(argv[i+2]) + 1];
						sprintf( add_directory, "%S", argv[i+2] );

						DIR* pdir = opendir( add_directory );
						if( pdir != NULL )
						{
							flagDB_add = true;
							closedir( pdir );
						}
						else
						{
							fprintf(stderr,"Failed to process '-db add' argument. The directory '%s' does not exist or is not accessible.\r\n", add_directory);
							exit(0);
						}
					}
					else
					{
						fprintf(stderr,"Failed to parse '-db add' argument. It must be followed by a directory to add:\r\n\teg. 'pd -db add C:\\Windows\\'\r\n");
						exit(0);
					}
					i+=1;
				}else if( lstrcmp(argv[i+1],L"remove") == 0 || lstrcmp(argv[i+1],L"rem") == 0 )
				{
					// Has yet another argument to specify the directory to remove
					if(  i + 2 < argc )
					{
						// Extract the directory name to remove
						add_directory = new char[wcslen(argv[i+2]) + 1];
						sprintf( add_directory, "%S", argv[i+2] );

						DIR* pdir = opendir( add_directory );
						if( pdir != NULL )
						{
							flagDB_remove = true;
							closedir( pdir );
						}
						else
						{
							fprintf(stderr,"Failed to process '-db remove' argument. The directory '%s' does not exist or is not accessible.\r\n", add_directory);
							exit(0);
						}
					}
					else
					{
						fprintf(stderr,"Failed to parse '-db remove' argument. It must be followed by a directory to remove:\r\n\teg. 'pd -db add C:\\Windows\\'\r\n");
						exit(0);
					}
					i+=1;
				}


				i+=1;
			}else{
				fprintf(stderr,"Failed to parse -db argument. It must be followed by a command:\r\n\teg. 'pd -db genquick'\r\n");
				exit(0);
			}
		}else{
			// This is an unassigned argument
			fprintf(stderr,"Failed to parse argument number %i, '%S'. Try 'pd --help' for usage instructions.\r\n", i, argv[i]);
			exit(0);
		}
	}

	if( flagHeader )
	{
		printf("Process Dump v2.1\r\n");
		printf("  Copyright © 2017, Geoff McDonald\r\n");
		printf("  http://www.split-code.com/\r\n");
		printf("  https://github.com/glmcdona/Process-Dump\r\n\r\n");
	}

	if( flagHelp )
	{
		// Print help page
		printf("Process Dump (pd.exe) is a tool used to dump both 32 and 64 bit executable modules back to disk from memory within a process address space. This tool is able to find and dump hidden modules as well as loose executable code chunks, and it uses a clean hash database to exclude dumping of known clean files. This tool uses an aggressive import reconstruction approach that links all DWORD/QWORDs that point to an export in the process to the corresponding export function. Process dump can be used to dump all unknown code from memory ('-system' flag), dump specific processes, or run in a monitoring mode that dumps all processes just before they terminate.\r\n\r\n");
		printf("Before first usage of this tool, when on the clean workstation the clean exclusing hash database can be generated by either:\r\n");
		printf("\tpd -db gen\r\n");
		printf("\tpd -db genquick\r\n\r\n");
		printf("Example Usage:\r\n");
		printf("\tpd -system\r\n");
		printf("\tpd -pid 419\r\n");
		printf("\tpd -pid 0x1a3\r\n");
		printf("\tpd -pid 0x1a3 -a 0x401000 -o c:\\dump\\ -c c:\\dump\\test\\clean.db\r\n");
		printf("\tpd -p chrome.exe\r\n");
		printf("\tpd -p \"(?i).*chrome.*\"\r\n");
		printf("\tpd -closemon\r\n\r\n");

		printf("Options:\r\n");
		printf("\t-system\t\tDumps all modules not matching the clean hash database\r\n\t\t\tfrom all accessible processes into the working\r\n\t\t\tdirectory.\r\n\r\n");
		printf("\t-pid <pid>\tDumps all modules not matching the clean hash database\r\n\t\t\tfrom the specified pid into the current working\r\n\t\t\tdirectory. Use a '0x' prefix to specify a hex PID.\r\n\r\n");
		printf("\t-closemon\t\tRuns in monitor mode. When any processes are terminating\r\n\t\t\tprocess dump will first dump the process.\r\n\r\n");
		printf("\t-p <regex>\tDumps all modules not matching the clean hash database\r\n\t\t\tfrom the process name found to match the filter into\r\n\t\t\tspecified pid into the current working directory.\r\n\r\n");
		printf("\t-g\t\tForces generation of PE headers from scratch, ignoring existing headers.\r\n\r\n");
		printf("\t-o <path>\tSets the default output root folder for dumped components.\r\n\r\n");
		//printf("\t-log\t\tRuns in log generation mode. No files are dumped, logfiles are generated for analysis. Specify a network path as the output and batch run to generate a report of multiple workstations.\r\n\r\n");
		//printf("\t-netcollect\t\tRuns in network sample collection mode. Specify a network path as the output, dumped files will be organized by hash.\r\n\r\n");
		printf("\t-v\t\tVerbose.\r\n\r\n");
		printf("\t-nh\t\tNo header is printed in the output.\r\n\r\n");
		printf("\t-nr\t\tDisable recursion on hash database directory add or\r\n\t\t\tremove commands.\r\n\r\n");
		printf("\t-ni\t\tDisable import reconstruction.\r\n\r\n");
		printf("\t-nc\t\tDisable dumping of loose code regions.\r\n\r\n");
		printf("\t-nt\t\tDisable multithreading.\r\n\r\n");
		printf("\t-t <thread count>\t\tSets the number of threads to use (default 16).\r\n\r\n");
		printf("\t-c <filepath>\t\tFull filepath to the clean hash database to use for this run.\r\n\r\n");
		printf("\t-db gen\t\tAutomatically processes a few common folders as well as\r\n\t\t\tall the currently running processes and adds the found\r\n\t\t\tmodule hashes to the clean hash database. It will add\r\n\t\t\tall files recursively in: \r\n\t\t\t\t%%WINDIR%% \r\n\t\t\t\t%%HOMEPATH%% \r\n\t\t\t\tC:\\Program Files\\ \r\n\t\t\t\tC:\\Program Files (x86)\\ \r\n\t\t\tAs well as all modules in all running processes \r\n\r\n");
		printf("\t-db genquick\tAdds the hashes from all modules in all processes to\r\n\t\t\tthe clean hash database. Run this on a clean system.\r\n\r\n");
		printf("\t-db add <dir>\tAdds all the files in the specified directory\r\n\t\t\trecursively to the clean hash database. \r\n\r\n");
		printf("\t-db rem <dir>\tRemoves all the files in the specified directory\r\n\t\t\trecursively from the clean hash database. \r\n\r\n");
		printf("\t-db clean\tClears the clean hash database.\r\n\r\n");
		printf("\t-db ignore\tIgnores the clean hash database when dumping a process\r\n\t\t\tthis time.  All modules will be dumped even if a match\r\n\t\t\tis found.\r\n\r\n");
	}
	
	// Sanity check on flags
	if( (int) flagPidDump + (int) flagProcessNameDump + (int) flagSystemDump +
		(int) flagDB_gen + (int) flagDB_genQuick + (int) flagDB_add + (int) flagDB_clean + (int) flagDumpCloses > 1 )
	{
		// Only one of these at a time
		fprintf(stderr,"Error. Only one process dump or hash database command should be issued per execution.\r\n");
		exit(0);
	}

	if( flagAddressDump && !flagPidDump )
	{
		// Only one of these at a time
		fprintf(stderr,"Error. Dumping a specific address only works with the -pid flag to specify the process.\r\n");
		exit(0);
	}


	// Warn if the process was not run as administrator
	HANDLE h_Process = GetCurrentProcess();
	if( !is_elevated(h_Process) )
	{
		printf("WARNING: This tool should be run with administrator rights for best results.\r\n\r\n");
	}

	// Request maximum thread token privileges
	if( !get_privileges(h_Process) )
	{
		printf("WARNING: Failed to adjust token privileges. This may result in not being able to access some processes due to insufficient privileges.\r\n\r\n");
	}

	// Warn if running in 32 bit mode on a 64 bit OS
	if( is_win64() && sizeof(void*) == 4 )
	{
		printf("WARNING: To properly access all processes on a 64 bit Windows version, the 64 bit version of this tool should be used. Currently Process Dump is running as a 32bit process under a 64bit operating system.\r\n\r\n");
	}

	

	pe_hash_database* db = new pe_hash_database(clean_database);


	if( flagDB_clean )
	{
		db->clear_database();
		printf("Cleared the clean hash database.\r\n");
		db->save();
	}else if( flagDB_add )
	{
		// Add the specified folder
		if( flagRecursion )
			printf("Adding all files in folder '%s' recursively to clean hash database...\r\n", add_directory);
		else
			printf("Adding all files in folder '%s' to clean hash database...\r\n", add_directory);

		int count_before = db->count();
		db->add_folder(add_directory, L"*", flagRecursion);
		printf("Added %i new hashes to the database. It now has %i hashes.\r\n", db->count() - count_before, db->count());
		db->save();
	}else if( flagDB_remove )
	{
		// Remove the specified folder
		if( flagRecursion )
			printf("Removing all files in folder '%s' recursively from the clean hash database...\r\n", add_directory);
		else
			printf("Removing all files in folder '%s' from the clean hash database...\r\n", add_directory);
		
		int count_before = db->count();
		db->remove_folder(add_directory, L"*", flagRecursion);
		printf("Removed %i hashes from the database. It now has %i hashes.\r\n", count_before - db->count(), db->count());
		db->save();
	}else if( flagDB_gen )
	{
		printf("Generating full clean database. This can take up to 30 minutes depending on the system.\r\n");

		// Add all the running processes to the clean hash database
		int count_before = db->count();
		printf("Adding modules from all running processes to clean hash database...\r\n");
		add_system_hashes( db, &options );
		printf("...added %i new hashes from running processes.\r\n", db->count() - count_before);
		db->save();

		// Add a bunch of folders to the database
		count_before = db->count();
		printf("Adding files in %%WINDIR%% to clean hash database...\r\n");
		db->add_folder("%WINDIR%", L"*", true);
		printf("...added %i new hashes from %%WINDIR%%.\r\n", db->count() - count_before);
		db->save();

		count_before = db->count();
		printf("Adding files in %%USERPROFILE%% to clean hash database...\r\n");
		db->add_folder("%USERPROFILE%", L"*", true);
		printf("...added %i new hashes from %%USERPROFILE%%.\r\n", db->count() - count_before);
		db->save();

		count_before = db->count();
		printf("Adding files in 'C:\\Program Files\\' to clean hash database...\r\n");
		db->add_folder("C:\\Program Files\\", L"*", true);
		printf("...added %i new hashes from 'C:\\Program Files\\'.\r\n", db->count() - count_before);
		db->save();

		count_before = db->count();
		printf("Adding files in C:\\Program Files (x86)\\ to clean hash database...\r\n");
		db->add_folder("C:\\Program Files (x86)\\", L"*", true);
		printf("...added %i new hashes from 'C:\\Program Files (x86)\\'.\r\n", db->count() - count_before);
		db->save();

		printf("\r\nFinished. The clean hash  database now has %i hashes.\r\n", db->count());
	}else if( flagDB_genQuick )
	{
		// Add all the running processes to the clean hash database
		int count_before = db->count();
		printf("Adding modules from all running processes to clean hash database...\r\n");
		add_system_hashes( db, &options );
		printf("...added %i new hashes from running processes.\r\n", db->count() - count_before);
		db->save();

		printf("\r\nFinished. The clean hash database now has %i hashes.\r\n", db->count());
	}

	// Clear the database if we set the flag to not use the database
	if( flagDB_ignore )
	{
		db->clear_database();
		printf("Ignoring the clean hash database for this execution.\r\n");
	}

	// Now process the dumping commands
	if( flagPidDump )
	{
		// Dump the specified PID
		dump_process* dumper = new dump_process( pid, db,  &options, false );

		if( flagAddressDump )
		{
			dumper->dump_region( address );
		}
		else
		{
			dumper->dump_all();
		}
		delete dumper;
	}
	else if( flagProcessNameDump )
	{
		// Dump the specified regex process name(s)

		// First gather the process matches
		DynArray<process_description*> matches;
		int count = process_find( processNameFilter, &matches );

		if( count > 1 )
		{
			// As the user if we should really dump all the found processes
			printf("\r\n\r\nPID\tProcess Name\r\n");
			for( int i = 0; i < count; i++ )
			{
				printf("0x%x\t%s\r\n", matches[i]->pid, matches[i]->process_name);
			}

			printf("\r\n\r\nAre you sure all of these processes should be dumped? (y/n): ");

			char* answer = new char[10];
			fgets( answer, 10, stdin );
			if( answer[0] != 'y' )
			{
				delete[] answer;
				exit(0);
			}
			delete[] answer;
		}

		// Loop through dumping the matching processes. Don't double-dump
		// modules with the same hash -- only dump them the first time
		// they are seen.
		unordered_set<unsigned __int64> new_hashes;
		for( int i = 0; i < count; i++ )
		{
			// Process this process
			dump_process* dumper = new dump_process( matches[i]->pid, db, &options, false );

			dumper->dump_all();

			// Exclude these hashes from the next dumps
			dumper->get_all_hashes( &new_hashes );
			db->add_hashes( new_hashes );
			new_hashes.clear();

			delete dumper;
		}
	}
	else if( flagSystemDump )
	{
		// Dump all processes running on the machine right now
		dump_system( db,  &options );
	}
	else if( flagPidDump )
	{
		// Dump the specified process
		dump_process* dumper = new dump_process( pid, db,  &options, false );
		dumper->dump_all();
		delete dumper;
	}
	else if (flagDumpCloses)
	{
		// Run in monitoring mode to dump all processes on close

		// Register the quit handler (CTRL-C to stop)
		if (SetConsoleCtrlHandler((PHANDLER_ROUTINE)ConsoleHandler, TRUE) == FALSE)
		{
			// unable to install handler... 
			// display message to the user
			printf("WARNING: Unable to install keyboard handler. This means that process dump will not be able to close or cleanup properly.\r\n");
		}

		// Start the hook monitor
		close_watcher* watcher = new close_watcher(db, &options);
		watcher->start_monitor();

		printf("------> Note: You may cleanly quit at any time by pressing CTRL-C. <------\r\n");

		// Wait until the user requests a close (by CTRL-C)
		while (!ConsoleRequestingClose)
		{
			Sleep(100);
		}
		
		// Cleanup properly
		printf("Cleaning up process terminate hooks cleanly...\r\n");
		watcher->stop_monitor();
		delete watcher;
	}

	printf("Finished running.\r\n");

	return 0;
}



```

`pd/pd.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9.00"
	Name="pd"
	ProjectGUID="{49B0E81A-D38E-426E-AB76-CC8463EC0003}"
	RootNamespace="pd"
	Keyword="Win32Proj"
	TargetFrameworkVersion="196613"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				DebugInformationFormat="4"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="Shlwapi.lib Kernel32.lib"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				SubSystem="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="Shlwapi.lib Kernel32.lib Psapi.lib"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				SubSystem="1"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="2"
				EnableIntrinsicFunctions="true"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
				RuntimeLibrary="2"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="Shlwapi.lib Kernel32.lib"
				LinkIncremental="1"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="2"
				EnableIntrinsicFunctions="true"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
				RuntimeLibrary="2"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="Shlwapi.lib Kernel32.lib Psapi.lib"
				LinkIncremental="1"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="x64|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				DebugInformationFormat="4"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				SubSystem="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="x64|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="Shlwapi.lib Kernel32.lib Psapi.lib"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				SubSystem="1"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath=".\dump_process.cpp"
				>
			</File>
			<File
				RelativePath=".\export_list.cpp"
				>
			</File>
			<File
				RelativePath=".\hash.cpp"
				>
			</File>
			<File
				RelativePath=".\module_list.cpp"
				>
			</File>
			<File
				RelativePath=".\pd.cpp"
				>
			</File>
			<File
				RelativePath=".\pe_exports.cpp"
				>
			</File>
			<File
				RelativePath=".\pe_hash_database.cpp"
				>
			</File>
			<File
				RelativePath=".\pe_header.cpp"
				>
			</File>
			<File
				RelativePath=".\pe_imports.cpp"
				>
			</File>
			<File
				RelativePath=".\simple.cpp"
				>
			</File>
			<File
				RelativePath=".\stdafx.cpp"
				>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Debug|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="x64|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="x64|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath=".\dump_process.h"
				>
			</File>
			<File
				RelativePath=".\DynArray.h"
				>
			</File>
			<File
				RelativePath=".\export_list.h"
				>
			</File>
			<File
				RelativePath=".\hash.h"
				>
			</File>
			<File
				RelativePath=".\module_list.h"
				>
			</File>
			<File
				RelativePath=".\pe_exports.h"
				>
			</File>
			<File
				RelativePath=".\pe_hash_database.h"
				>
			</File>
			<File
				RelativePath=".\pe_header.h"
				FileType="0"
				>
			</File>
			<File
				RelativePath=".\pe_imports.h"
				>
			</File>
			<File
				RelativePath=".\queue.h"
				>
			</File>
			<File
				RelativePath=".\simple.h"
				>
			</File>
			<File
				RelativePath=".\stdafx.h"
				>
			</File>
			<File
				RelativePath=".\stream_wrapper.h"
				DeploymentContent="true"
				FileType="1"
				>
			</File>
			<File
				RelativePath=".\targetver.h"
				>
			</File>
			<File
				RelativePath=".\utils.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`pd/pd.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="x64|Win32">
      <Configuration>x64</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="x64|x64">
      <Configuration>x64</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{49B0E81A-D38E-426E-AB76-CC8463EC0003}</ProjectGuid>
    <RootNamespace>pd</RootNamespace>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='x64|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='x64|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v140_xp</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='x64|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='x64|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>14.0.24730.2</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='x64|Win32'">
    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='x64|x64'">
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Shlwapi.lib;Kernel32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Shlwapi.lib;Kernel32.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Shlwapi.lib;Kernel32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Shlwapi.lib;Kernel32.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='x64|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='x64|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Shlwapi.lib;Kernel32.lib;Psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="close_watcher.cpp" />
    <ClCompile Include="dump_process.cpp" />
    <ClCompile Include="export_list.cpp" />
    <ClCompile Include="hash.cpp" />
    <ClCompile Include="module_list.cpp" />
    <ClCompile Include="pd.cpp" />
    <ClCompile Include="pe_exports.cpp" />
    <ClCompile Include="pe_hash_database.cpp" />
    <ClCompile Include="pe_header.cpp" />
    <ClCompile Include="pe_imports.cpp" />
    <ClCompile Include="simple.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='x64|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='x64|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="terminate_monitor_hook.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="close_watcher.h" />
    <ClInclude Include="dump_process.h" />
    <ClInclude Include="DynArray.h" />
    <ClInclude Include="export_list.h" />
    <ClInclude Include="hash.h" />
    <ClInclude Include="module_list.h" />
    <ClInclude Include="pd.h" />
    <ClInclude Include="pe_exports.h" />
    <ClInclude Include="pe_hash_database.h" />
    <ClInclude Include="pe_header.h">
      <FileType>CppCode</FileType>
    </ClInclude>
    <ClInclude Include="pe_imports.h" />
    <ClInclude Include="simple.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="stream_wrapper.h">
      <DeploymentContent>true</DeploymentContent>
      <FileType>CppClass</FileType>
    </ClInclude>
    <ClInclude Include="targetver.h" />
    <ClInclude Include="terminate_monitor_hook.h" />
    <ClInclude Include="utils.h" />
    <ClInclude Include="work_queue.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`pd/pd.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dump_process.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="export_list.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hash.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="module_list.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pd.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pe_exports.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pe_hash_database.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pe_header.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pe_imports.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="simple.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="terminate_monitor_hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="close_watcher.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dump_process.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DynArray.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="export_list.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hash.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="module_list.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pe_exports.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pe_hash_database.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pe_header.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pe_imports.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="simple.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stream_wrapper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="terminate_monitor_hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pd.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="close_watcher.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="work_queue.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`pd/pd.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>-pid 4656</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>-pid 4656</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`pd/pe_exports.cpp`:

```cpp
#include "StdAfx.h"
#include "pe_exports.h"

pe_exports::pe_exports(void)
{
}

pe_exports::~pe_exports(void)
{
}

```

`pd/pe_exports.h`:

```h
#pragma once

class pe_exports
{
public:
	pe_exports(void);
	~pe_exports(void);
};

```

`pd/pe_hash_database.cpp`:

```cpp
#include "StdAfx.h"
#include "pe_hash_database.h"

bool pe_hash_database::_is_mz(FILE* stream)
{
	char twochars[2];
	if( (fread( &twochars, 1, 2, stream) == 2) && twochars[0] == 'M' && twochars[1] == 'Z' )
	{
		fseek( stream, 0, SEEK_SET);
		return true;
	}
	fseek( stream, 0, SEEK_SET);
	return false;
}

pe_hash_database::pe_hash_database(char* clean_database_name)
{
	InitializeCriticalSectionAndSpinCount(&_lock, 0x00000400);
	EnterCriticalSection( &_lock );

	// Build the full database name
	_clean_database_path = new char[ strlen(clean_database_name) + 1 ];
	strcpy( _clean_database_path, clean_database_name );

	_clean_hashes.rehash(0x10000);

	// Open and read in the database of clean hashes if it exists.
	printf("Loading clean hash database from '%s'.\r\n", clean_database_name);
	FILE* fh = fopen( _clean_database_path, "rb" );
	unsigned __int64 hash;
	if( fh )
	{
		// Read in the database
		while( !feof( fh ) )
		{
			 if( fread( &hash, sizeof(unsigned __int64), 1, fh ) == 1 )
			 {
				_clean_hashes.insert( hash );
			 }
		}
		fclose(fh);

		printf("Loaded %i clean hashes from database.\r\n", _clean_hashes.size());
	}
	else
	{
		if( PathFileExistsA( _clean_database_path ) )
		{
			// Do not continue if the database exists, but we failed to open it. This is to protect
			// the contents of the database from being overwritten if we save the now empty database
			// successfully.
			PrintLastError(L"Failed to open existing hash database. Terminating.");
			exit(-1);
		}

		printf("Did not find an existing clean hash database, using an empty one.\r\n");
	}

	LeaveCriticalSection( &_lock );
}

int pe_hash_database::count()
{
	EnterCriticalSection( &_lock );
	int result = _clean_hashes.size();
	LeaveCriticalSection( &_lock );
	return result;
}

bool pe_hash_database::clear_database()
{
	EnterCriticalSection( &_lock );
	_clean_hashes.clear();
	LeaveCriticalSection( &_lock );
	return true;
}

bool pe_hash_database::add_hashes(unordered_set<unsigned __int64> hashes)
{
	EnterCriticalSection( &_lock );

	for (unordered_set<unsigned __int64>::iterator it=hashes.begin(); it!=hashes.end(); it++)
	{
		if( *it != 0 && _clean_hashes.count( *it ) == 0 )
		{
			_clean_hashes.insert( *it );
		}
	}

	LeaveCriticalSection( &_lock );
	
	return true;
}

	

bool pe_hash_database::add_folder( char* dir_name, WCHAR* filter, bool recursively )
{
	// Expand the environment names in the directory
	char dir_name_expanded[PATH_MAX + 1];
	if (ExpandEnvironmentStringsA(dir_name, dir_name_expanded, PATH_MAX) < PATH_MAX)
	{
		DWORD ftyp = GetFileAttributesA(dir_name_expanded);
		if (ftyp != INVALID_FILE_ATTRIBUTES && ftyp & FILE_ATTRIBUTE_DIRECTORY && !(ftyp & FILE_ATTRIBUTE_REPARSE_POINT))
		{
			DIR *dir;
			struct dirent *ent;
			dir = opendir(dir_name_expanded);
			if (dir != NULL)
			{
				/* print all the files and directories within directory */
				while ((ent = readdir(dir)) != NULL) {
					// Convert the path to wchar format
					wchar_t* result = new wchar_t[strlen(ent->d_name) + 1];

					if (result != NULL)
					{
						for (int i = 0; i < strlen(ent->d_name); i++)
							result[i] = ent->d_name[i];
						result[strlen(ent->d_name)] = 0;

						if ((ent->d_type & DT_DIR))
						{
							// Process this subdirectory if recursive flag is on
							if (recursively && wcscmp(result, L".") != 0 && wcscmp(result, L"..") != 0)
							{
								// Build the directory path
								char* directory = new char[strlen(dir_name_expanded) + strlen(ent->d_name) + 2];
								sprintf_s(directory, strlen(dir_name_expanded) + strlen(ent->d_name) + 2, "%s\\%s", dir_name_expanded, ent->d_name);

								add_folder(directory, filter, recursively);

								// Cleanup
								delete[] directory;
							}
						}
						else {
							// Check if this filename is a match to the specified pattern
							if (PathMatchSpec(result, filter))
							{
								// Process this file
								int length = wcslen(result) + strlen(dir_name_expanded) + 1;
								char* filename = new char[length + 1];
								filename[length] = 0;
								sprintf(filename, "%s\\%S", dir_name_expanded, result);

								// Processes the specified file
								FILE* fh = fopen(filename, "rb");
								if (fh != NULL)
								{
									if (_is_mz(fh))
									{
										fclose(fh);

										add_file(filename);
									}
									else
										fclose(fh);
								}
								else {
									// Error
									fprintf(stderr, "Error opening file %s: %s.\r\n", filename, strerror(errno));
								}
								delete[] filename;
							}
						}
						delete[] result;
					}
					else
					{
						fprintf(stderr, "Failed to allocate memory block of size %i for filename: %s.\r\n", ent->d_namlen + 1, strerror(errno));
					}
				}
				closedir(dir);
				return true;
			}
			else {
				fprintf(stderr, "Unable to open directory %s: %s.\r\n", dir_name_expanded, strerror(errno));
			}
		}
	}
	return false;
}


bool pe_hash_database::remove_folder( char* dir_name, WCHAR* filter, bool recursively )
{
	// Expand the environment names in the directory
	char* dir_name_expanded = new char[1000];
	ExpandEnvironmentStringsA( dir_name, dir_name_expanded, 1000 );


	DIR *dir;
	struct dirent *ent;
	dir = opendir (dir_name_expanded);
	if (dir != NULL)
	{
		/* print all the files and directories within directory */
		while ((ent = readdir (dir)) != NULL) {
			// Convert the path to wchar format
			wchar_t* result = new wchar_t[ent->d_namlen + 1];

			if( result != NULL )
			{
				for( int i = 0; i < ent->d_namlen; i++ )
					result[i] = ent->d_name[i];
				result[ent->d_namlen] = 0;

				if( (ent->d_type & DT_DIR) )
				{
					// Process this subdirectory if recursive flag is on
					if( recursively && wcscmp(result, L".") != 0 && wcscmp(result, L"..") != 0  )
					{
						// Build the directory path
						char* directory = new char[strlen(dir_name_expanded) + strlen(ent->d_name) + 2];
						sprintf(directory, "%s/%s", dir_name_expanded, ent->d_name);

						remove_folder( directory, filter, recursively );

						// Cleanup
						delete[] directory;
					}
				}else{
					// Check if this filename is a match to the specified pattern
					if( PathMatchSpec( result, filter ) )
					{
						// Process this file
						int length = wcslen(result) + strlen(dir_name_expanded) + 1;
						char* filename = new char[length + 1];
						filename[length] = 0;
						sprintf( filename, "%s\\%S", dir_name_expanded, result );

						// Processes the specified file
						FILE* fh = fopen( filename, "rb" );
						if( fh != NULL )
						{
							if( _is_mz( fh ) )
							{
								fclose(fh);

								remove_file(filename);
							}
							else
								fclose(fh);
						}else{
							// Error
							fprintf(stderr, "Error opening file %s: %s.\r\n", filename, strerror(errno));
						}
						delete[] filename;
					}
				}
				delete[] result;
			}
			else
			{
				fprintf(stderr, "Failed to allocate memory block of size %i for filename: %s.\r\n", ent->d_namlen + 1, strerror(errno));
			}
		}
		closedir (dir);
		return true;
	}else{
		fprintf(stderr, "Unable to open directory %s: %s.\r\n", dir_name_expanded, strerror(errno));
	}
	return false;
}


bool pe_hash_database::contains(unsigned __int64 hash)
{
	return _clean_hashes.count( hash ) != 0;
}

bool pe_hash_database::add_file(char* file)
{
	PD_OPTIONS options;
	options.ForceGenHeader = false;
	options.ImportRec = false;
	options.Verbose = false;
	pe_header* header = new pe_header(file, &options);
	unsigned __int64 hash = 0;
	header->process_pe_header();
	header->process_sections();
	
	if( header->somewhat_parsed() )
	{
		hash = header->get_hash();
	}
	else
	{
		printf("Failed to parse PE header for %s.\r\n", file);
		delete header;
		return false;
	}
	
	
	delete header;

	if( hash != 0 )
	{
		EnterCriticalSection( &_lock );
		if( _clean_hashes.count( hash ) == 0 )
		{
			_clean_hashes.insert( hash );
			printf("...new hash %s,0x%llX\r\n", file, hash);
		}
		LeaveCriticalSection( &_lock );
		
		return true;
	}

	printf("Failed to calculate hash for file %s.\r\n", file);
	return false;
}

bool pe_hash_database::remove_file(char* file)
{
	PD_OPTIONS options;
	options.ForceGenHeader = false;
	options.ImportRec = false;
	options.Verbose = false;
	pe_header* header = new pe_header(file, &options);
	header->process_pe_header();
	header->process_sections();
	
	unsigned __int64 hash = 0;
	if( header->somewhat_parsed() )
	{
		hash = header->get_hash();
	}
	delete header;

	if( hash != 0 )
	{
		EnterCriticalSection( &_lock );
		if( _clean_hashes.count( hash ) != 0 )
		{
			_clean_hashes.erase( hash );
			printf("...deleted hash %s,0x%llX\r\n", file, hash);
		}
		LeaveCriticalSection( &_lock );
		
		return true;
	}

	printf("Failed to add hash for file %s.\r\n", file);
	return false;
}

bool pe_hash_database::save()
{
	// Open and read in the database of clean hashes if it exists.
	FILE* fh = fopen( _clean_database_path, "wb" );
	unsigned __int64 hash;
	if( fh )
	{
		// Write the database
		EnterCriticalSection( &_lock );
		for (unordered_set<unsigned __int64>::const_iterator it = _clean_hashes.begin();
			it != _clean_hashes.end(); ++it) 
		{
			hash = *it;
			fwrite( &hash, sizeof(unsigned __int64), 1, fh );
		}
		fclose(fh);
		LeaveCriticalSection( &_lock );

		printf("Wrote to clean hash database. It now has a total of %i clean hashes.\r\n", _clean_hashes.size());

		return true;
	}
	else
	{
		PrintLastError(L"Failed to open existing hash database..");
	}

	return false;
}

pe_hash_database::~pe_hash_database(void)
{
	delete[] _clean_database_path;
	DeleteCriticalSection(&_lock);
}


```

`pd/pe_hash_database.h`:

```h
#pragma once


#include <unordered_set>
#include <iostream>
#include <stdio.h>
#include <io.h>
#include <sys/types.h>
#include "dirent.h"
#include "Shlwapi.h"
#include "pe_header.h"
#include "simple.h"
#include <windows.h>          // std::mutex






using namespace std;
using namespace std::tr1;

class pe_hash_database
{
	char* _clean_database_path;
	unordered_set<unsigned __int64> _clean_hashes;
	bool _is_mz(FILE* stream);
	CRITICAL_SECTION _lock;

public:
	pe_hash_database(char* clean_database_name);
	int count();
	bool clear_database();
	bool add_hashes(unordered_set<unsigned __int64> hashes);
	bool add_folder( char* dir_name, WCHAR* filter, bool recursively );
	bool remove_folder( char* dir_name, WCHAR* filter, bool recursively );
	bool contains(unsigned __int64 hash);
	bool add_file(char* file);
	bool remove_file(char* file);
	bool save();
	~pe_hash_database(void);
};
```

`pd/pe_header.cpp`:

```cpp
#include "StdAfx.h"
#include "pe_header.h"

pe_header::pe_header( char* filename, PD_OPTIONS* options )
{
	this->_options = options;
	this->_image_size = 0;
	this->_raw_header_size = 0;
	this->_disk_image_size = 0;
	this->_stream = (stream_wrapper*) new file_stream( filename );
	_original_base = 0;
	_unique_hash = 0;

	_name_filepath_long_size = 0;
	_name_filepath_long = NULL;
	_name_filepath_short_size = 0;
	_name_filepath_short = NULL;
	_name_original_exports_size = 0;
	_name_original_exports = NULL;
	_name_original_manifest_size = 0;
	_name_original_manifest = NULL;
	_name_symbols_path_size = 0;
	_name_symbols_path = NULL;
	_export_list = NULL;

	this->_parsed_dos = false;
	this->_parsed_pe_32 = false;
	this->_parsed_pe_64 = false;
	this->_parsed_sections = false;
	this->_image_size = 0;
	this->_disk_image_size = 0;
	this->_unique_hash = 0;

	if( _stream != NULL )
	{
		// Assign the disk filename for this file
		_name_filepath_long = new char[FILEPATH_SIZE];
		_name_filepath_long_size = _stream->get_long_name( _name_filepath_long, FILEPATH_SIZE );
		_name_filepath_short = new char[FILEPATH_SIZE];
		_name_filepath_short_size = _stream->get_short_name( _name_filepath_short, FILEPATH_SIZE );
	}

	if( _options->Verbose )
		fprintf( stdout, "INFO: Initialized header for module name %s.\r\n", this->get_name() );
}

export_list* pe_header::get_exports()
{
	if( (_parsed_pe_32 || _parsed_pe_64) && _export_list != NULL )
	{
		return this->_export_list;
	}
	return NULL;
}

pe_header::pe_header( DWORD pid, void* base, module_list* modules, PD_OPTIONS* options )
{
	this->_options = options;
	this->_image_size = 0;
	this->_raw_header_size = 0;
	this->_disk_image_size = 0;
	_unique_hash = 0;

	_header_export_directory = NULL;
	_header_import_descriptors = NULL;
	_name_filepath_long_size = 0;
	_name_filepath_long = NULL;
	_name_filepath_short_size = 0;
	_name_filepath_short = NULL;
	_name_original_exports_size = 0;
	_name_original_exports = NULL;
	_name_original_manifest_size = 0;
	_name_original_manifest = NULL;
	_name_symbols_path_size = 0;
	_name_symbols_path = NULL;
	_export_list = NULL;

	this->_parsed_dos = false;
	this->_parsed_pe_32 = false;
	this->_parsed_pe_64 = false;
	this->_parsed_sections = false;
	this->_image_size = 0;
	this->_disk_image_size = 0;
	this->_unique_hash = 0;

	this->_stream = (stream_wrapper*) new process_stream( pid, base, modules );
	_original_base = base;

	if( _stream != NULL )
	{
		// Assign the disk filename for this file
		_name_filepath_long = new char[FILEPATH_SIZE];
		_name_filepath_long_size = _stream->get_long_name( _name_filepath_long, FILEPATH_SIZE );
		_name_filepath_short = new char[FILEPATH_SIZE];
		_name_filepath_short_size = _stream->get_short_name( _name_filepath_short, FILEPATH_SIZE );
	}

	if( _options->Verbose )
		fprintf( stdout, "INFO: Initialized header for module name %s.\r\n", this->get_name() );
}

pe_header::pe_header( DWORD pid, module_list* modules, PD_OPTIONS* options )
{
	this->_options = options;
	this->_image_size = 0;
	this->_raw_header_size = 0;
	this->_disk_image_size = 0;
	_unique_hash = 0;

	_header_export_directory = NULL;
	_header_import_descriptors = NULL;
	_name_filepath_long_size = 0;
	_name_filepath_long = NULL;
	_name_filepath_short_size = 0;
	_name_filepath_short = NULL;
	_name_original_exports_size = 0;
	_name_original_exports = NULL;
	_name_original_manifest_size = 0;
	_name_original_manifest = NULL;
	_name_symbols_path_size = 0;
	_name_symbols_path = NULL;
	_export_list = NULL;

	this->_parsed_dos = false;
	this->_parsed_pe_32 = false;
	this->_parsed_pe_64 = false;
	this->_parsed_sections = false;
	this->_image_size = 0;
	this->_disk_image_size = 0;
	this->_unique_hash = 0;

	this->_stream = (stream_wrapper*) new process_stream( pid, modules );
	_original_base = ((process_stream*) _stream)->base;

	if( _options->Verbose )
		fprintf( stdout, "INFO: Initialized header for module name %s.\r\n", this->get_name() );
}

pe_header::pe_header( HANDLE ph, void* base, module_list* modules, PD_OPTIONS* options )
{
	this->_options = options;
	this->_image_size = 0;
	this->_raw_header_size = 0;
	this->_disk_image_size = 0;
	_unique_hash = 0;

	_name_filepath_long_size = 0;
	_name_filepath_long = NULL;
	_name_filepath_short_size = 0;
	_name_filepath_short = NULL;
	_name_original_exports_size = 0;
	_name_original_exports = NULL;
	_name_original_manifest_size = 0;
	_name_original_manifest = NULL;
	_name_symbols_path_size = 0;
	_name_symbols_path = NULL;
	_export_list = NULL;

	this->_parsed_dos = false;
	this->_parsed_pe_32 = false;
	this->_parsed_pe_64 = false;
	this->_parsed_sections = false;
	this->_image_size = 0;
	this->_disk_image_size = 0;
	this->_unique_hash = 0;

	this->_stream = (stream_wrapper*) new process_stream( ph, base );
	_original_base = base;

	if( _options->Verbose )
		fprintf( stdout, "INFO: Initialized header for module name %s.\r\n", this->get_name() );
}

void pe_header::print_report(FILE* stream)
{
	// Print the on-disk filepath if there is an associated file

	// Print the original filename specified by the exports table if it has one

	// Print the original filename specified by the manifest file if it has one

	// Print the symbols .pdb file path and name if found
	
	// Print the basic information

}

bool pe_header::somewhat_parsed()
{
	return _parsed_pe_32 || _parsed_pe_64;
}

bool pe_header::is_dll()
{
	if( this->_parsed_pe_32 )
		return (this->_header_pe32->FileHeader.Characteristics & IMAGE_FILE_DLL);
	if( this->_parsed_pe_64 )
		return (this->_header_pe64->FileHeader.Characteristics & IMAGE_FILE_DLL);
	return false;
}

bool pe_header::is_exe()
{
	if( this->_parsed_pe_32 )
		return !(this->_header_pe32->FileHeader.Characteristics & IMAGE_FILE_DLL) && !(this->_header_pe32->FileHeader.Characteristics & IMAGE_FILE_SYSTEM);
	if( this->_parsed_pe_64 )
		return !(this->_header_pe64->FileHeader.Characteristics & IMAGE_FILE_DLL) && !(this->_header_pe64->FileHeader.Characteristics & IMAGE_FILE_SYSTEM);
	return false;
}

bool pe_header::is_sys()
{
	if( this->_parsed_pe_32 )
		return this->_header_pe32->FileHeader.Characteristics & IMAGE_FILE_SYSTEM;
	if( this->_parsed_pe_64 )
		return this->_header_pe64->FileHeader.Characteristics & IMAGE_FILE_SYSTEM;
	return false;
}

bool pe_header::is_64()
{
	return this->_parsed_pe_64;
}

void pe_header::set_name(char* new_name)
{
	// Set name to sue for this module
	if( _name_filepath_short != NULL )
		delete _name_filepath_short;

	// Localize
	_name_filepath_short = new char[strlen(new_name) + 1];
	strcpy_s(_name_filepath_short, strlen(new_name) + 1, new_name);
	_name_filepath_short_size = strlen(_name_filepath_short);
}

char* pe_header::get_name()
{
	// Return the name of this module if available.
	if( this->_name_filepath_short_size > 0 && _name_filepath_short != NULL )
		return _name_filepath_short;
	return "hiddenmodule";
}

unsigned __int64 pe_header::get_virtual_size()
{
	if( this->_parsed_pe_32 || this->_parsed_pe_64 )
	{
		return _image_size;
	}
	return 0;
}

bool pe_header::process_hash( )
{
	// Build the hash of this library if has been loaded
	this->_unique_hash = 0;
	if( this->_parsed_pe_32 || this->_parsed_pe_64 )
	{
		// Hash the PE directory up until the end of the section definition, and hashes
		// this with the length of the import table, and number of modules in the import
		// table

		// First calculate begin hashing from the import table entries
		SIZE_T offset = 0;
		SIZE_T read_size = 0;
		if( _parsed_pe_32 )
		{
			offset = _header_pe32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;
			read_size = 4;
		}
		else
		{
			offset = _header_pe64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;
			read_size = 8;
		}

		unsigned __int64 last_dw = -1;

		// Hash the IAT overview (not the exact values, just the structure).
		bool more;
		do
		{
			more = false;
			if( _test_read( _image, _image_size, _image + offset, read_size ) )
			{
				unsigned __int64 new_dw;
				if( read_size == 4 )
					new_dw = *((DWORD*) (_image + (long) offset));
				if( read_size == 8 )
					new_dw = *((unsigned __int64*) (_image + (long) offset));

				if( new_dw == 0 && last_dw == 0 )
					break;
				if( new_dw == 0 )
				{
					// New module hash
					_unique_hash = _unique_hash ^ 0x8ADFA91F8ADFA91F;
					_unique_hash = _rotl64(_unique_hash, 0x13);
				}
				else
				{
					// New import in module hash
					_unique_hash = _unique_hash ^ 0x18F31A228FA9B17A;
					_unique_hash = _rotl64(_unique_hash, 0x17);
				}
				offset += read_size;
				last_dw = new_dw;
				more = true;
			}
		}while(more);
		
		/*
		// Hash this with the DOS header
		unsigned char* start = 0;
		SIZE_T length = 0;
		
		start = (unsigned char*) &_header_dos;
		length = sizeof(IMAGE_DOS_HEADER);
		for( unsigned char* i = start; i + 8 < start + length; i+= 4 )
		{
			// Hash with this segment
			_unique_hash = _unique_hash ^ *((unsigned __int32*)(i));
			_unique_hash = _rotl64(_unique_hash, 0x19);
		}
		*/


		// Hash this with some of the section information
		
		if( this->_parsed_sections )
		{
			for( int i = 0; i < this->_num_sections; i++ )
			{
				// Hash with this section description
				_unique_hash = _unique_hash ^ *((unsigned __int64*)(&_header_sections[i].Name));
				_unique_hash = _rotl64(_unique_hash, 0x21);
				_unique_hash = _unique_hash ^ _header_sections[i].SizeOfRawData;
				_unique_hash = _rotl64(_unique_hash, 0x13);
				_unique_hash = _unique_hash ^ _header_sections[i].Characteristics;
				_unique_hash = _rotl64(_unique_hash, 0x17);
			}
		}
		
		
		return true;
	}

	return false;
	
	return true;
}

bool pe_header::write_image( char* filename )
{
	// Writes the loaded and reconstructed memory image to a file
	if( _disk_image_size > 0 )
	{
		FILE* fh = fopen( filename, "wb" );
		if( fh != NULL )
		{
			// Write the image
			fwrite( _disk_image, 1, _disk_image_size, fh );
			fclose(fh);
		}
	}
	return false;
}

IMPORT_SUMMARY pe_header::get_imports_information( export_list* exports )
{
	return get_imports_information( exports, _image_size );
}

IMPORT_SUMMARY pe_header::get_imports_information( export_list* exports, __int64 size_limit )
{
	// Builds a structure of information about the imports declared by this PE object. This includes:
	//   # of different import addresses
	//	 # of code locations that imported
	//	 Generic import hash
	//   Specific import hash

	// Gets the number of distinct import addresses that are imported.
	unordered_set<unsigned __int64> import_addresses;

	if( _options->Verbose )
			printf( "INFO: Building import information.\r\n" );
	
	IMPORT_SUMMARY result;
	result.COUNT_UNIQUE_IMPORT_ADDRESSES = 0;
	result.COUNT_UNIQUE_IMPORT_LIBRARIES = 0;
	result.HASH_GENERIC = 0;
	result.HASH_SPECIFIC = 0;

	size_t hash_generic = 0x1a78ac10;
	size_t hash_specific = 0x1a78ac10;

	hash<string> hasher;
	
	if( this->_parsed_sections )
	{
		// Add matches to exports in this process
		unsigned __int32 cand32_last = 0;
		unsigned __int64 cand64_last = 0;
		for(__int64 offset = 0; offset < _image_size - 8 && offset < size_limit - 8; offset+=4 )
		{
			// Check if this 4-gram or 8-gram points to an export
			unsigned __int32 cand32 = *((__int32*)(_image + offset));

			if (cand32 != cand32_last)
			{
				if (exports->contains(cand32))
				{
					export_entry entry = exports->find(cand32);

					// Found an import reference
					unordered_set<unsigned __int64>::const_iterator gotImportAddress = import_addresses.find(cand32);

					if (gotImportAddress == import_addresses.end())
					{
						// Add this new import
						import_addresses.insert(cand32);
						result.COUNT_UNIQUE_IMPORT_ADDRESSES++;

						// Add this imported function hash
						if (entry.name != NULL)
						{
							hash_generic = hash_generic ^ hasher(string(entry.name));
							hash_specific = hash_specific ^ hasher(string(entry.name));
						}
						if (entry.library_name != NULL)
						{
							hash_generic = hash_generic ^ (hasher(string(entry.library_name)) << 1);
							hash_specific = hash_specific ^ (hasher(string(entry.library_name)) << 1);
						}
						hash_generic = _rotl(hash_generic, 0x05);
						hash_specific = hash_specific ^ offset;
						hash_specific = _rotl(hash_specific, 0x05);
					}
				}
			}
			cand32_last = cand32;
			
			unsigned __int64 cand64 = *((unsigned __int64*)(_image + offset));
			if (cand64 != cand64_last && cand64 > 0xffffffff)
			{
				if (exports->contains(cand64))
				{
					export_entry entry = exports->find(cand64);

					// Found an import reference
					unordered_set<unsigned __int64>::const_iterator gotImportAddress = import_addresses.find(cand64);

					if (gotImportAddress == import_addresses.end())
					{
						// Add this new import
						import_addresses.insert(cand64);
						result.COUNT_UNIQUE_IMPORT_ADDRESSES++;

						// Add this imported function hash
						if (entry.name != NULL)
						{
							hash_generic = hash_generic ^ hasher(string(entry.name));
							hash_specific = hash_specific ^ hasher(string(entry.name));
						}
						if (entry.library_name != NULL)
						{
							hash_generic = hash_generic ^ (hasher(string(entry.library_name)) << 1);
							hash_specific = hash_specific ^ (hasher(string(entry.library_name)) << 1);
						}
						hash_generic = _rotl(hash_generic, 0x05);
						hash_specific = hash_specific ^ offset;
						hash_specific = _rotl(hash_specific, 0x05);
					}
				}
			}
			cand64_last = cand64;
		}
	}
	
	result.HASH_GENERIC = hash_generic;
	result.HASH_SPECIFIC = hash_specific;

	if( _options->Verbose )
	{
		printf( "INFO: Finished building import information:\r\n" );
		printf( "INFO: Count Unique Import Addresses = %i\r\n", result.COUNT_UNIQUE_IMPORT_ADDRESSES );
		printf( "INFO: Count Unique Import Libraries = %i\r\n", result.COUNT_UNIQUE_IMPORT_LIBRARIES );
		printf( "INFO: Generic Hash = 0x%llX\r\n", result.HASH_GENERIC );
		printf( "INFO: Specific Hash = 0x%llX\r\n", result.HASH_SPECIFIC );
	}

	return result;
}

unsigned __int64 pe_header::get_hash()
{
	//return rand() + (rand() << 32);
	if( _unique_hash == 0 )
		process_hash();
	return _unique_hash;
}

bool pe_header::build_pe_header( __int64 size, bool amd64 )
{
	return build_pe_header( size, amd64, 99 ); // Build it with as many sections as we can.
}

bool pe_header::build_pe_header( __int64 size, bool amd64, int num_sections_limit )
{
	if( _stream != NULL )
	{
		_raw_header_size = 0x2000;
		_raw_header = new unsigned char[_raw_header_size];
		memset( _raw_header, 0, _raw_header_size );
		_original_base = (void*) ((__int64) _original_base -  (__int64) _raw_header_size);
		_stream->update_base(-(__int64) _raw_header_size);

		// Build the old dos header
		_header_dos = (IMAGE_DOS_HEADER*) _raw_header;
		_header_dos->e_magic=0x5a4d;
		_header_dos->e_cblp=0x0090;
		_header_dos->e_cp=0x0003;
		_header_dos->e_crlc=0x0000;
		_header_dos->e_cparhdr=0x0004;
		_header_dos->e_minalloc=0x0000;
		_header_dos->e_maxalloc=0xffff;
		_header_dos->e_ss=0x0000;
		_header_dos->e_sp=0x00b8;
		_header_dos->e_csum=0x0000;
		_header_dos->e_ip=0x0000;
		_header_dos->e_cs=0x0000;
		_header_dos->e_lfarlc=0x0040;
		_header_dos->e_ovno=0x0000;
		memset( &_header_dos->e_res, 0, sizeof(WORD)*4 );
		_header_dos->e_oemid=0x0000;
		_header_dos->e_oeminfo=0x0000;
		memset( &_header_dos->e_res2, 0, sizeof(WORD)*10 );
		_header_dos->e_lfanew=0x000000e0;

		this->_parsed_dos = true;

		unsigned char* base_pe = _header_dos->e_lfanew + _raw_header;
		
		if( !amd64 )
		{
			// Build intel 32 bit PE header
			_header_pe32 = (IMAGE_NT_HEADERS32*) base_pe;
			_header_pe32->Signature = 0x00004550;
			_header_pe32->FileHeader.Machine = IMAGE_FILE_MACHINE_I386;
			_header_pe32->FileHeader.NumberOfSections = 1;
			_header_pe32->FileHeader.NumberOfSymbols = 0;
			_header_pe32->FileHeader.PointerToSymbolTable = 0;
			_header_pe32->FileHeader.SizeOfOptionalHeader = sizeof(IMAGE_OPTIONAL_HEADER32);
			if( _options->ReconstructHeaderAsDll )
				_header_pe32->FileHeader.Characteristics = 0x0002; // Exe: 0x0002
			else
				_header_pe32->FileHeader.Characteristics = 0x2000; // Dll: 0x2000
			_header_pe32->OptionalHeader.Magic=0x10b;
			_header_pe32->OptionalHeader.MajorLinkerVersion=0x08;
			_header_pe32->OptionalHeader.MinorLinkerVersion=0x00;
			_header_pe32->OptionalHeader.SizeOfCode=0x00000000;
			_header_pe32->OptionalHeader.SizeOfInitializedData=0x00000000;
			_header_pe32->OptionalHeader.SizeOfUninitializedData=0x00000000;
			_header_pe32->OptionalHeader.AddressOfEntryPoint=0x2000; // Made up, start of first section
			_header_pe32->OptionalHeader.BaseOfCode=0x00002000;
			_header_pe32->OptionalHeader.ImageBase= (DWORD)_original_base; // Set to current address
			_header_pe32->OptionalHeader.SectionAlignment=0x00001000;
			_header_pe32->OptionalHeader.FileAlignment=0x000001000;
			_header_pe32->OptionalHeader.MajorOperatingSystemVersion=0x0004;
			_header_pe32->OptionalHeader.MinorOperatingSystemVersion=0x0000;
			_header_pe32->OptionalHeader.MajorImageVersion=0x0000;
			_header_pe32->OptionalHeader.MinorImageVersion=0x0000;
			_header_pe32->OptionalHeader.MajorSubsystemVersion=0x0005;
			_header_pe32->OptionalHeader.MinorSubsystemVersion=0x0002;
			_header_pe32->OptionalHeader.Win32VersionValue=0x00000000;
			_header_pe32->OptionalHeader.SizeOfImage=0x00006000;
			_header_pe32->OptionalHeader.SizeOfHeaders=0x00002000;
			_header_pe32->OptionalHeader.CheckSum=0x00000000;
			_header_pe32->OptionalHeader.Subsystem=0x0003;
			_header_pe32->OptionalHeader.DllCharacteristics=0x0000; // 0x2000
			_header_pe32->OptionalHeader.SizeOfStackReserve=0x0000000000100000;
			_header_pe32->OptionalHeader.SizeOfStackCommit=0x0000000000001000;
			_header_pe32->OptionalHeader.SizeOfHeapReserve=0x0000000000100000;
			_header_pe32->OptionalHeader.SizeOfHeapCommit=0x0000000000001000;
			_header_pe32->OptionalHeader.LoaderFlags=0x00000000;
			_header_pe32->OptionalHeader.NumberOfRvaAndSizes=0x00000010;
			memset( &_header_pe32->OptionalHeader.DataDirectory, 0, sizeof(IMAGE_DATA_DIRECTORY)*IMAGE_NUMBEROF_DIRECTORY_ENTRIES );

			_header_sections = (IMAGE_SECTION_HEADER*) (base_pe + sizeof(IMAGE_NT_HEADERS32));

			this->_parsed_pe_32 = true;
		}
		else
		{
			// Build intel 64 bit PE header
			_header_pe64 = (IMAGE_NT_HEADERS64*) base_pe;
			_header_pe64->Signature = 0x00004550;
			_header_pe64->FileHeader.Machine = IMAGE_FILE_MACHINE_AMD64;
			_header_pe64->FileHeader.NumberOfSections = 1;
			_header_pe64->FileHeader.NumberOfSymbols = 0;
			_header_pe64->FileHeader.PointerToSymbolTable = 0;
			_header_pe64->FileHeader.SizeOfOptionalHeader = sizeof(IMAGE_OPTIONAL_HEADER64);
			if( _options->ReconstructHeaderAsDll )
				_header_pe64->FileHeader.Characteristics = 0x0002; // Exe: 0x0002
			else
				_header_pe64->FileHeader.Characteristics = 0x2000; // Dll: 0x2000
			_header_pe64->OptionalHeader.Magic=0x020b;
			_header_pe64->OptionalHeader.MajorLinkerVersion=0x08;
			_header_pe64->OptionalHeader.MinorLinkerVersion=0x00;
			_header_pe64->OptionalHeader.SizeOfCode=0x00000000;
			_header_pe64->OptionalHeader.SizeOfInitializedData=0x00000000;
			_header_pe64->OptionalHeader.SizeOfUninitializedData=0x00000000;
			
			// Select the entry point
			_header_pe64->OptionalHeader.AddressOfEntryPoint=0x2000; // Made up, start of first section
			_header_pe64->OptionalHeader.BaseOfCode=0x00002000;
			_header_pe64->OptionalHeader.ImageBase= (__int64)_original_base; // Set to current address
			_header_pe64->OptionalHeader.SectionAlignment=0x00001000;
			_header_pe64->OptionalHeader.FileAlignment=0x000001000;
			_header_pe64->OptionalHeader.MajorOperatingSystemVersion=0x0004;
			_header_pe64->OptionalHeader.MinorOperatingSystemVersion=0x0000;
			_header_pe64->OptionalHeader.MajorImageVersion=0x0000;
			_header_pe64->OptionalHeader.MinorImageVersion=0x0000;
			_header_pe64->OptionalHeader.MajorSubsystemVersion=0x0005;
			_header_pe64->OptionalHeader.MinorSubsystemVersion=0x0002;
			_header_pe64->OptionalHeader.Win32VersionValue=0x00000000;
			_header_pe64->OptionalHeader.SizeOfImage=0x00006000;
			_header_pe64->OptionalHeader.SizeOfHeaders=0x00002000;
			_header_pe64->OptionalHeader.CheckSum=0x00000000;
			_header_pe64->OptionalHeader.Subsystem=0x0003;
			_header_pe64->OptionalHeader.DllCharacteristics=0x0000;
			_header_pe64->OptionalHeader.SizeOfStackReserve=0x0000000000100000;
			_header_pe64->OptionalHeader.SizeOfStackCommit=0x0000000000001000;
			_header_pe64->OptionalHeader.SizeOfHeapReserve=0x0000000000100000;
			_header_pe64->OptionalHeader.SizeOfHeapCommit=0x0000000000001000;
			_header_pe64->OptionalHeader.LoaderFlags=0x00000000;
			_header_pe64->OptionalHeader.NumberOfRvaAndSizes=0x00000010;
			memset( &_header_pe64->OptionalHeader.DataDirectory, 0, sizeof(IMAGE_DATA_DIRECTORY)*IMAGE_NUMBEROF_DIRECTORY_ENTRIES );

			_header_sections = (IMAGE_SECTION_HEADER*) (base_pe + sizeof(IMAGE_NT_HEADERS64));

			this->_parsed_pe_64 = true;
		}
		
		// Create the sections
		_num_sections = 0;
		__int64 image_size = _raw_header_size;
		while( _stream->estimate_section_size(image_size) != 0 && image_size >= size && _num_sections < 99 && _num_sections < num_sections_limit )
		{
			__int64 est_size = _stream->estimate_section_size(image_size);
			
			_header_sections[_num_sections].PointerToRawData = image_size;
			_header_sections[_num_sections].SizeOfRawData = est_size;
			_header_sections[_num_sections].VirtualAddress = image_size;
			_header_sections[_num_sections].Misc.PhysicalAddress = image_size;
			_header_sections[_num_sections].Misc.VirtualSize = est_size;
			_header_sections[_num_sections].Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE; //_stream->get_region_characteristics(offset);
			char name[9];
			sprintf_s( name, 9, "pd_rec%i", _num_sections);
			memcpy( &_header_sections[_num_sections].Name, name, 8 );
			_header_sections[_num_sections].NumberOfLinenumbers = 0;
			_header_sections[_num_sections].NumberOfRelocations = 0;
			_header_sections[_num_sections].PointerToLinenumbers = 0;
			
			if( _options->Verbose )
				printf("%s: size %x\r\n", name, image_size);

			_num_sections++;
			image_size += est_size;
		}

		// Update the number of sections and image size
		if( !amd64 )
		{
			_header_pe32->FileHeader.NumberOfSections = _num_sections;
			_header_pe32->OptionalHeader.SizeOfImage = image_size;
		}
		else
		{
			_header_pe64->FileHeader.NumberOfSections = _num_sections;
			_header_pe64->OptionalHeader.SizeOfImage = image_size;
		}

		return true;
	}
	return false;
}

bool pe_header::process_pe_header( )
{
	if( _options->Verbose )
		fprintf( stdout, "INFO: Loading PE header for %s.\r\n", this->get_name() );

	if( _stream != NULL )
	{
		// Request the block size of the first region
		_raw_header_size = _stream->block_size(0);
		_raw_header = new unsigned char[_raw_header_size];
		
		if( _raw_header_size >= 0x500 )
		{
			// Read in the PE header
			if( _stream->read(0, _raw_header_size, _raw_header, &_raw_header_size) && _raw_header_size >= 0x500 )
			{
				// Parse the PE header
				if( _raw_header_size > sizeof(IMAGE_DOS_HEADER) )
				{
					this->_header_dos = (IMAGE_DOS_HEADER*) _raw_header;
					
					if( _header_dos->e_magic == 0x5A4D )
					{
						// Successfully parsed dos header
						this->_parsed_dos = true;
						
						// Parse the PE header
						unsigned char* base_pe = _header_dos->e_lfanew + _raw_header;
						
						if( _test_read( _raw_header, _raw_header_size, base_pe, sizeof(IMAGE_NT_HEADERS64) ) )
						{
							// We are unsure if we need to process this as a 32bit or 64bit PE header, lets figure it out.
							// The first part is independent of the 32 or 64 bit definition.
							if( ((IMAGE_NT_HEADERS64*) base_pe)->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 )
							{
								// 32bit module
								this->_header_pe32 = ((IMAGE_NT_HEADERS32*) base_pe);

								if( _header_pe32->Signature == 0x4550 && _header_pe32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC )
								{
									this->_parsed_pe_32 = true;
									if( _options->Verbose )
										fprintf( stdout, "INFO: Loaded PE header for %s. Somewhat parsed: %d\r\n", this->get_name(), this->somewhat_parsed() );
									return true;
								}
							}
							else if( ((IMAGE_NT_HEADERS64*) base_pe)->FileHeader.Machine == IMAGE_FILE_MACHINE_IA64 ||
								((IMAGE_NT_HEADERS64*) base_pe)->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
							{
								// 64bit module
								this->_header_pe64 = ((IMAGE_NT_HEADERS64*) base_pe);

								if( _header_pe64->Signature == 0x4550 && _header_pe64->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC )
								{
									this->_parsed_pe_64 = true;
									if( _options->Verbose )
										fprintf( stdout, "INFO: Loaded PE header for %s. Somewhat parsed: %d\r\n", this->get_name(), this->somewhat_parsed() );
									return true;
								}
							}
							else
							{
								// error
							}
						}
					}
				}
			}
		}
	}
	else
	{
		if( _options->Verbose )
			fprintf( stderr, "INFO: Invalid stream.\r\n" );
	}
	
	if( _options->Verbose )
		fprintf( stdout, "INFO: Loaded PE header for %s. Somewhat parsed: %d\r\n", this->get_name(), this->somewhat_parsed() );

	return false;
}

bool pe_header::process_sections( )
{
	if( _options->Verbose )
		fprintf( stdout, "INFO: Loading sections for %s.\r\n", this->get_name() );

	if( this->_parsed_pe_32 )
	{
		// Attempt to parse the sections
		unsigned char* base_pe = _header_dos->e_lfanew + _raw_header;
		unsigned char* base_sections = base_pe + sizeof(*_header_pe32);
		if( _header_pe32->FileHeader.NumberOfSections > 0x100 )
		{
			char* location = new char[FILEPATH_SIZE + 1];
			_stream->get_location(location, FILEPATH_SIZE + 1);
			fprintf( stderr, "WARNING: module '%s' at %s. Extremely large number of sections of 0x%x changed to 0x100 as part of sanity check.\r\n",
				this->get_name(), location, _header_pe32->FileHeader.NumberOfSections );
			_header_pe32->FileHeader.NumberOfSections = 0x100;
			delete[] location;
		}
		
		if( _test_read( _raw_header, _raw_header_size, base_sections, sizeof(IMAGE_SECTION_HEADER) ) )
		{
			// Has room for at least 1 section.

			if( !_test_read( _raw_header, _raw_header_size, base_sections, _header_pe32->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER) ) )
			{
				// Parse the maximum number of sections possible
				char* location = new char[FILEPATH_SIZE + 1];
				_stream->get_location(location, FILEPATH_SIZE + 1);
				fprintf( stderr, "WARNING: module '%s' at %s. Number of sections being changed from 0x%x to 0x%x such that it will fit within the PE header buffer.\r\n",
					this->get_name(), location,
					_header_pe32->FileHeader.NumberOfSections,
					( (_raw_header + _raw_header_size - base_sections - 1) / sizeof(IMAGE_SECTION_HEADER) )
					);
				delete[] location;
				_header_pe32->FileHeader.NumberOfSections = ( (_raw_header + _raw_header_size - base_sections - 1) / sizeof(IMAGE_SECTION_HEADER) );
			}

			this->_parsed_sections = true;
			this->_num_sections = _header_pe32->FileHeader.NumberOfSections;
			this->_header_sections = (IMAGE_SECTION_HEADER*) base_sections;

			if( _options->Verbose )
			{
				for( int i = 0; i < this->_num_sections; i++ )
				{
					if( _test_read( _raw_header, _raw_header_size, this->_header_sections[i].Name, 0x40 ) )
						fprintf( stdout, "INFO: %s\t#%i\t%s\t0x%x\t0x%x\r\n", this->get_name(), i, this->_header_sections[i].Name, this->_header_sections[i].VirtualAddress, this->_header_sections[i].SizeOfRawData );
					else
						fprintf( stdout, "INFO: %s\t#%i\tINVALID ADDRESS\t0x%x\t0x%x\r\n", this->get_name(), i, this->_header_sections[i].VirtualAddress, this->_header_sections[i].SizeOfRawData );
				}
			}


			// Calculate the total size of the virtual image by inspecting the last section
			DWORD image_size = 0;
			if( this->_num_sections > 0 )
			{
				if( _header_sections[_num_sections - 1].Misc.VirtualSize > MAX_SECTION_SIZE )
				{
					// Smartly choose _header_pe32->OptionalHeader.SizeOfImage or last section plus max section size
					if( _header_pe32->OptionalHeader.SizeOfImage > _header_sections[_num_sections - 1].VirtualAddress &&
						  _header_pe32->OptionalHeader.SizeOfImage < _header_sections[_num_sections - 1].VirtualAddress + MAX_SECTION_SIZE )
					{
						// Use the _header_pe32->OptionalHeader.SizeOfImage, since it seems valid
						char* location = new char[FILEPATH_SIZE + 1];
						_stream->get_location(location, FILEPATH_SIZE + 1);
						fprintf( stderr, "WARNING: module '%s' at %s. Image size of last section appears incorrect, using image size specified by optional header instead since it appears valid. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
								this->get_name(), location);
						delete[] location;
						image_size = _header_pe32->OptionalHeader.SizeOfImage;
					}
					else
					{
						// Assume a really large last section since _header_pe32->OptionalHeader.SizeOfImage appears invalid. 
						char* location = new char[FILEPATH_SIZE + 1];
						_stream->get_location(location, FILEPATH_SIZE + 1);
						fprintf( stderr, "WARNING: module '%s' at %s. Image size of last section appears incorrect, using built-in max section size of 0x%x instead. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
							this->get_name(), location,
							MAX_SECTION_SIZE * (_num_sections+1));
						delete[] location;
						image_size = _header_sections[_num_sections - 1].VirtualAddress + MAX_SECTION_SIZE;
					}
				}
				else
					image_size = _header_sections[_num_sections - 1].VirtualAddress +
											 _header_sections[_num_sections - 1].Misc.VirtualSize;
			}
			if( _header_pe32->OptionalHeader.SizeOfImage > image_size )
				image_size = _header_pe32->OptionalHeader.SizeOfImage;
			
			// Perform a sanity check on the resulting image size
			if( image_size > MAX_SECTION_SIZE * (_num_sections+1)  )
			{
				char* location = new char[FILEPATH_SIZE + 1];
				_stream->get_location(location, FILEPATH_SIZE + 1);
				fprintf( stderr, "WARNING: module '%s' at %s. Large image size of 0x%x changed to 0x%x as part of sanity check. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
					this->get_name(), location,
					image_size, MAX_SECTION_SIZE * (_num_sections+1) );
				delete[] location;
				image_size = MAX_SECTION_SIZE * (_num_sections+1);
			}

			// Now lets build a proper image of this file with virtual alignment
			_image_size = image_size;
			_image = new unsigned char[_image_size];
			memset(_image, 0, _image_size);

			// Read in this full image
			if( _stream->file_alignment )
			{
				// Read in the full image from disk alignment
				
				// Read in the header
				SIZE_T num_read = 0;
				
				if( _test_read( _image, _image_size, _image, _header_pe32->OptionalHeader.SizeOfHeaders ) )
				{
					if( !_stream->read(0, _header_pe32->OptionalHeader.SizeOfHeaders, _image, &num_read ) && _options->Verbose )
					{
						char* location = new char[FILEPATH_SIZE + 1];
						_stream->get_location(location, FILEPATH_SIZE + 1);
						fprintf( stderr, "WARNING: module '%s' at %s. Failed to read in header of size 0x%x. Was only able to read 0x%x bytes from this region.\r\n",this->get_name(), location, _header_pe32->OptionalHeader.SizeOfHeaders, num_read);
						delete[] location;
					}
				}
				else
				{
					char* location = new char[FILEPATH_SIZE + 1];
					_stream->get_location(location, FILEPATH_SIZE + 1);
					fprintf( stderr, "WARNING: module '%s' at %s. Failed to read in header.", this->get_name(), location);
					delete[] location;
				}



				// Loop through reading the sections into their respective virtual sections
				if( this->_parsed_sections )
				{
					for( int i = 0; i < this->_num_sections; i++ )
					{
						// Test the destination is valid
						if( _test_read( _image, _image_size,
							_image + (SIZE_T) this->_header_sections[i].VirtualAddress, this->_header_sections[i].SizeOfRawData ) )
						{
							// Read in this section
							if( !_stream->read( this->_header_sections[i].PointerToRawData, this->_header_sections[i].SizeOfRawData,
								_image + (SIZE_T) this->_header_sections[i].VirtualAddress, &num_read ) && _options->Verbose )
							{
								char* location = new char[FILEPATH_SIZE + 1];
								_stream->get_location(location, FILEPATH_SIZE + 1);
								fprintf( stderr, "WARNING: module '%s' at %s. Failed to read in section %i of size 0x%x. Was only able to read 0x%x bytes from this region.\r\n", this->get_name(), location, i, this->_header_sections[i].SizeOfRawData, num_read);
								delete[] location;
							}
						}
					}
				}
			}
			else
			{
				// Read in the full image from virtual alignment
				SIZE_T num_read = 0;
				if( !_stream->read( 0, _image_size, _image, &num_read ) && _options->Verbose )
				{
					char* location = new char[FILEPATH_SIZE + 1];
					_stream->get_location(location, FILEPATH_SIZE + 1);
					fprintf( stderr, "WARNING: module '%s' at %s. Failed to read in image at 0x%llX of size 0x%x. Was only able to read 0x%x bytes from this region.\r\n",this->get_name(), location, this->_stream->get_address(), _image_size, num_read);
					delete[] location;
				}
			}

			if( _options->Verbose )
				fprintf( stdout, "INFO: Loaded sections for %s with result: %d. %i sections found.\r\n", this->get_name(), this->_parsed_sections, ( this->_parsed_sections ? this->_num_sections : 0 )  );

			return true;
		}
	}
	else if( this->_parsed_pe_64 )
	{
		// Attempt to parse the sections
		unsigned char* base_pe = _header_dos->e_lfanew + _raw_header;
		unsigned char* base_sections = base_pe + sizeof(*_header_pe64);
		if( _header_pe64->FileHeader.NumberOfSections > 0x100 )
		{
			char* location = new char[FILEPATH_SIZE + 1];
			_stream->get_location(location, FILEPATH_SIZE + 1);
			fprintf( stderr, "WARNING: module '%s' at %s. Extremely large number of sections of 0x%x changed to 0x100 as part of sanity check.\r\n",
				this->get_name(), location, _header_pe64->FileHeader.NumberOfSections );
			_header_pe64->FileHeader.NumberOfSections = 0x100;
			delete[] location;
		}
		
		if( _test_read( _raw_header, _raw_header_size, base_sections, sizeof(IMAGE_SECTION_HEADER) ) )
		{
			// Has room for at least 1 section.

			if( !_test_read( _raw_header, _raw_header_size, base_sections, _header_pe64->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER) ) )
			{
				// Parse the maximum number of sections possible
				char* location = new char[FILEPATH_SIZE + 1];
				_stream->get_location(location, FILEPATH_SIZE + 1);
				fprintf( stderr, "WARNING: module '%s' at %s. Number of sections being changed from 0x%x to 0x%x such that it will fit within the PE header buffer.\r\n",
					this->get_name(), location,
					_header_pe64->FileHeader.NumberOfSections,
					( (_raw_header + _raw_header_size - base_sections - 1) / sizeof(IMAGE_SECTION_HEADER) )
					);
				delete[] location;
				_header_pe64->FileHeader.NumberOfSections = ( (_raw_header + _raw_header_size - base_sections - 1) / sizeof(IMAGE_SECTION_HEADER) );
			}

			this->_parsed_sections = true;
			this->_num_sections = _header_pe64->FileHeader.NumberOfSections;
			this->_header_sections = (IMAGE_SECTION_HEADER*) base_sections;
	
			if( _options->Verbose )
			{
				for( int i = 0; i < this->_num_sections; i++ )
				{
					fprintf( stdout, "INFO: %s\t#%i\t%s\t0x%x\t0x%x\r\n", this->get_name(), i, this->_header_sections[i].Name, this->_header_sections[i].VirtualAddress, this->_header_sections[i].SizeOfRawData );
				}
			}

			// Calculate the total size of the virtual image by inspecting the last section
			DWORD image_size = 0;
			if( this->_num_sections > 0 )
			{
				if( _header_sections[_num_sections - 1].Misc.VirtualSize > MAX_SECTION_SIZE )
				{
					// Smartly choose _header_pe64->OptionalHeader.SizeOfImage or last section plus max section size
					if( _header_pe64->OptionalHeader.SizeOfImage > _header_sections[_num_sections - 1].VirtualAddress &&
						  _header_pe64->OptionalHeader.SizeOfImage < _header_sections[_num_sections - 1].VirtualAddress + MAX_SECTION_SIZE )
					{
						// Use the _header_pe64->OptionalHeader.SizeOfImage, since it seems valid
						char* location = new char[FILEPATH_SIZE + 1];
						_stream->get_location(location, FILEPATH_SIZE + 1);
						fprintf( stderr, "WARNING: module '%s' at %s. Image size of last section appears incorrect, using image size specified by optional header instead since it appears valid. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
								this->get_name(), location);
						delete[] location;
						image_size = _header_pe64->OptionalHeader.SizeOfImage;
					}
					else
					{
						// Assume a really large last section since _header_pe64->OptionalHeader.SizeOfImage appears invalid. 
						char* location = new char[FILEPATH_SIZE + 1];
						_stream->get_location(location, FILEPATH_SIZE + 1);
						fprintf( stderr, "WARNING: module '%s' at %s. Image size of last section appears incorrect, using built-in max section size of 0x%x instead. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
							this->get_name(), location,
							MAX_SECTION_SIZE * (_num_sections+1));
						delete[] location;
						image_size = _header_sections[_num_sections - 1].VirtualAddress + MAX_SECTION_SIZE;
					}
				}
				else
					image_size = _header_sections[_num_sections - 1].VirtualAddress +
											 _header_sections[_num_sections - 1].Misc.VirtualSize;
			}
			if( _header_pe64->OptionalHeader.SizeOfImage > image_size )
				image_size = _header_pe64->OptionalHeader.SizeOfImage;
			
			// Perform a sanity check on the resulting image size
			if( image_size > MAX_SECTION_SIZE * (_num_sections+1)  )
			{
				char* location = new char[FILEPATH_SIZE + 1];
				_stream->get_location(location, FILEPATH_SIZE + 1);
				fprintf( stderr, "WARNING: module '%s' at %s. Large image size of 0x%x changed to 0x%x as part of sanity check. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
					this->get_name(), location,
					image_size, MAX_SECTION_SIZE * (_num_sections+1) );
				delete[] location;
				image_size = MAX_SECTION_SIZE * (_num_sections+1);
			}

			// Now lets build a proper image of this file with virtual alignment
			_image_size = image_size;
			_image = new unsigned char[_image_size];
			memset(_image, 0, _image_size);

			// Read in this full image
			if( _stream->file_alignment )
			{
				// Read in the full image from disk alignment
				
				// Read in the header
				SIZE_T num_read = 0;
				
				if( _test_read( _image, _image_size, _image, _header_pe64->OptionalHeader.SizeOfHeaders ) )
				{
					if( !_stream->read(0, _header_pe64->OptionalHeader.SizeOfHeaders, _image, &num_read ) && _options->Verbose )
					{
						char* location = new char[FILEPATH_SIZE + 1];
						_stream->get_location(location, FILEPATH_SIZE + 1);
						fprintf( stderr, "WARNING: module '%s' at %s. Failed to read in header of size 0x%x. Was only able to read 0x%x bytes from this region.\r\n",this->get_name(), location, _header_pe64->OptionalHeader.SizeOfHeaders, num_read);
						delete[] location;
					}
				}
				else
				{
					char* location = new char[FILEPATH_SIZE + 1];
					_stream->get_location(location, FILEPATH_SIZE + 1);
					fprintf( stderr, "WARNING: module '%s' at %s. Failed to read in header.", this->get_name(), location);
					delete[] location;
				}



				// Loop through reading the sections into their respective virtual sections
				if( this->_parsed_sections )
				{
					for( int i = 0; i < this->_num_sections; i++ )
					{
						// Test the destination is valid
						if( _test_read( _image, _image_size,
							_image + (SIZE_T) this->_header_sections[i].VirtualAddress, this->_header_sections[i].SizeOfRawData ) )
						{
							// Read in this section
							if( !_stream->read( this->_header_sections[i].PointerToRawData, this->_header_sections[i].SizeOfRawData,
								_image + (SIZE_T) this->_header_sections[i].VirtualAddress, &num_read ) && _options->Verbose )
							{
								char* location = new char[FILEPATH_SIZE + 1];
								_stream->get_location(location, FILEPATH_SIZE + 1);
								fprintf( stderr, "WARNING: module '%s' at %s. Failed to read in section %i of size 0x%x. Was only able to read 0x%x bytes from this region.\r\n", this->get_name(), location, i, this->_header_sections[i].SizeOfRawData, num_read);
								delete[] location;
							}
						}
					}
				}
			}
			else
			{
				// Read in the full image from virtual alignment
				SIZE_T num_read = 0;
				if( !_stream->read( 0, _image_size, _image, &num_read ) && _options->Verbose )
				{
					char* location = new char[FILEPATH_SIZE + 1];
					_stream->get_location(location, FILEPATH_SIZE + 1);
					fprintf( stderr, "WARNING: module '%s' at %s. Failed to read in image at 0x%llX of size 0x%x. Was only able to read 0x%x bytes from this region.\r\n",this->get_name(), location, this->_stream->get_address(), _image_size, num_read);
					delete[] location;
				}
			}

			if( _options->Verbose )
				fprintf( stdout, "INFO: Loaded sections for %s with result: %d. %i sections found.\r\n", this->get_name(), this->_parsed_sections, ( this->_parsed_sections ? this->_num_sections : 0 )  );

			return true;
		}
	}

	if( _options->Verbose )
		fprintf( stdout, "INFO: Failed to load sections for %s.\r\n", this->get_name() );

	return false;
}

bool pe_header::process_disk_image( export_list* exports )
{
	if( this->_parsed_sections )
	{
		if( this->_parsed_pe_32 )
		{
			// Reconstruct PE imports aggressively using our knowledge of all the exports addresses in this process
			// Technique:
			//   1. 'exports' defines all valid export addresses in this process
			//   2. Find any binary that points to a valid export in this rpocess
			//   3. Add a new section for the new HintName Array and Import Address Table
			//   4. For each binary patch found above, add a HintName and ImportAddress point so the loads
			//      will recognize it correctly for analysis (IDA).
			unsigned char* larger_image;
			__int64 larger_image_size;
			if( _options->ImportRec )
			{
				// Start the with the original import descriptor list
				pe_imports* peimp = new pe_imports( _image, _image_size, _header_import_descriptors, false );
				
				// Add matches to exports in this process
				int count = 0;
				unsigned __int64 cand_last = 0;
				for(__int64 offset = 0; offset < _image_size - 8; offset+=4 )
				{
					// Check if this 4-gram or 8-gram points to an export
					unsigned __int64 cand = *((__int32*)(_image + offset));

					if ( cand_last != cand && exports->contains( cand ) )
					{
						export_entry entry = exports->find(cand);

						// Add this to be reconstructed as an import
						if (entry.name != NULL)
							peimp->add_fixup(entry.library_name, entry.name, offset, this->_parsed_pe_64);
						else
							peimp->add_fixup(entry.library_name, entry.ord, offset, this->_parsed_pe_64);
						count++;
					}
					else
					{
						cand_last = cand;
					}
				}
				if( _options->Verbose )
					printf( "INFO: Reconstructing %i imports.\r\n", count );
				
				// Increase the image size for a new section
				__int64 descriptor_size = 0;
				__int64 data_size = 0;
				peimp->get_table_size( descriptor_size, data_size );
				__int64 new_section_size = this->_section_align(data_size+descriptor_size, this->_header_pe32->OptionalHeader.SectionAlignment);
				
				
				// Increase the size of the last section
				_header_sections[_num_sections-1].Misc.VirtualSize = this->_section_align(_header_sections[_num_sections-1].Misc.VirtualSize, this->_header_pe32->OptionalHeader.SectionAlignment) + new_section_size;
				_header_sections[_num_sections-1].SizeOfRawData = _header_sections[_num_sections-1].Misc.VirtualSize;

				larger_image_size = this->_section_align((long long) this->_image_size, this->_header_pe32->OptionalHeader.SectionAlignment) + new_section_size;
				larger_image = new unsigned char[larger_image_size];
				memset(larger_image, 0, larger_image_size);
				memcpy(larger_image, _image, _image_size);

				if( _options->Verbose )
					printf( "INFO: Writing added import table.\r\n" );
				
				// Write to the new section
				peimp->build_table( larger_image + this->_section_align((long long) _image_size, this->_header_pe32->OptionalHeader.SectionAlignment), new_section_size, (__int64) _image_size, (__int64) 0, descriptor_size );
				
				if( _options->Verbose )
					printf( "INFO: Updating import data directory.\r\n" );

				// Update the PE header to refer to it
				_header_pe32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = this->_section_align((long long) _image_size, this->_header_pe32->OptionalHeader.SectionAlignment);
				_header_pe32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = descriptor_size;
				
				delete peimp;
			}
			else
			{
				larger_image_size = _image_size;
				larger_image = new unsigned char[larger_image_size];
				memset(larger_image, 0, larger_image_size);
				memcpy(larger_image, _image, _image_size);
			}
			
			if( _original_base != 0 )
			{
				// Adjust the preferred image base, this way the relocations doesn't have to be fixed
				_header_pe32->OptionalHeader.ImageBase = (DWORD) _original_base;
			}

			// Change the physical alignment to use the virtual alignment
			if( _options->Verbose )
					printf( "INFO: Adjusting file alignment to %x.\r\n", _header_pe32->OptionalHeader.SectionAlignment);
			_header_pe32->OptionalHeader.FileAlignment = _header_pe32->OptionalHeader.SectionAlignment;
			
			// Adjust the physical size of each section to use the virtual size
			_header_pe32->OptionalHeader.SizeOfHeaders = _section_align(_header_pe32->OptionalHeader.SizeOfHeaders, _header_pe32->OptionalHeader.FileAlignment);
			DWORD required_space = _section_align( _header_pe32->OptionalHeader.SizeOfHeaders, _header_pe32->OptionalHeader.SectionAlignment);
			
			for( int i = 0; i < _num_sections; i++ )
			{
				// Correct the VirtualSize of the section if it is too large
				if( this->_header_sections[i].Misc.VirtualSize > MAX_SECTION_SIZE  )
				{
					if( _options->Verbose )
						printf( "INFO: Calculating required space for section %i.\r\n", i);

					if( i + 1 < _num_sections &&
						this->_header_sections[i+1].VirtualAddress > this->_header_sections[i].VirtualAddress &&
						this->_header_sections[i+1].VirtualAddress < this->_header_sections[i].VirtualAddress + MAX_SECTION_SIZE )
					{
						// Calculate the virtual size manually
						char* location = new char[FILEPATH_SIZE + 1];
						_stream->get_location(location, FILEPATH_SIZE + 1);
						fprintf( stderr, "WARNING: module '%s' at %s. Large section size for section %i of 0x%x changed to 0x%x based on image size as part of sanity check. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
							this->get_name(), location, i, this->_header_sections[i].Misc.VirtualSize, this->_header_sections[i+1].VirtualAddress - this->_header_sections[i].VirtualAddress );
						delete[] location;
						this->_header_sections[i].Misc.VirtualSize = this->_header_sections[i+1].VirtualAddress - this->_header_sections[i].VirtualAddress;
					}
					else
					{
						// Use MAX_SECTION_SIZE
						char* location = new char[FILEPATH_SIZE + 1];
						_stream->get_location(location, FILEPATH_SIZE + 1);
						fprintf( stderr, "WARNING: module '%s' at %s. Large section size for section %i of 0x%x changed to 0x%x based on maximum section size as part of sanity check. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
							this->get_name(), location, i, this->_header_sections[i].Misc.VirtualSize, MAX_SECTION_SIZE );
						delete[] location;
						this->_header_sections[i].Misc.VirtualSize = MAX_SECTION_SIZE;
					}
				}
				
				// Truncate VirtualSize to fit inside image size
				if( this->_header_sections[i].Misc.VirtualSize + this->_header_sections[i].VirtualAddress > larger_image_size )
				{
					char* location = new char[FILEPATH_SIZE + 1];
					_stream->get_location(location, FILEPATH_SIZE + 1);
					DWORD new_size = larger_image_size - this->_header_sections[i].VirtualAddress;
					fprintf( stderr, "WARNING: module '%s' at %s. Large section size for section %i of 0x%x being truncated to 0x%x to fit within the image size. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
						this->get_name(), location, i, this->_header_sections[i].Misc.VirtualSize, new_size );
					delete[] location;
					this->_header_sections[i].Misc.VirtualSize = new_size;
				}
				
				// Adjust the physical size to be at least the same size as the virtual size
				if( this->_header_sections[i].Misc.VirtualSize > _header_sections[i].SizeOfRawData )
				{
					_header_sections[i].SizeOfRawData = this->_header_sections[i].Misc.VirtualSize;
				}
				
				// Update the pointer to raw data to be correct
				_header_sections[i].PointerToRawData = required_space;
				
				required_space = _section_align( required_space + _header_sections[i].SizeOfRawData, _header_pe32->OptionalHeader.FileAlignment );
			}
			
			// Set the size of image
			_header_pe32->OptionalHeader.SizeOfImage = required_space;
			
			if( _options->Verbose )
						printf( "INFO: Copying the corrected memory PE header into file PE header format.\r\n");

			// Copy over the modified PE header into the imaged version
			if( _test_read( larger_image, larger_image_size, larger_image, _header_pe32->OptionalHeader.SizeOfHeaders ) &&
				_test_read( _raw_header, _raw_header_size, _raw_header, _header_pe32->OptionalHeader.SizeOfHeaders ) )
			{
				memcpy( larger_image, _raw_header, _header_pe32->OptionalHeader.SizeOfHeaders );
			}
			else if( _test_read( larger_image, larger_image_size, larger_image, _raw_header_size ) &&
					 _test_read( _raw_header, _raw_header_size, _raw_header, _raw_header_size ) )
			{
				memcpy( larger_image, _raw_header, _raw_header_size );
			}
			
			if( _header_pe32->OptionalHeader.SectionAlignment >= _header_pe32->OptionalHeader.FileAlignment )
			{
				// Pack it down into a disk image of the file
				if( _options->Verbose )
						printf( "INFO: Packing down memory sections into the file.\r\n");

				// Allocate the necessary space for the physical image and initialize it to zero
				_disk_image_size = required_space;
				_disk_image = new unsigned char[_disk_image_size];
				memset(_disk_image, 0, _disk_image_size);
				
				// Copy the header
				if( _test_read( _disk_image, _disk_image_size, _disk_image, _section_align(_header_pe32->OptionalHeader.SizeOfHeaders, _header_pe32->OptionalHeader.FileAlignment) ) &&
					_test_read( larger_image, larger_image_size, larger_image, _section_align(_header_pe32->OptionalHeader.SizeOfHeaders, _header_pe32->OptionalHeader.FileAlignment) ) )
				{
					memcpy( _disk_image, larger_image, _header_pe32->OptionalHeader.SizeOfHeaders );
				}
				
				if( _parsed_sections )
				{
					// Copy the sections one-by-one
					for( int i = 0; i < _num_sections; i++ )
					{
						if( _options->Verbose )
							printf( "INFO: Packing down section %i.\r\n", i);

						// Copy this section if the source and destination are both within acceptable bounds
						if( _test_read( _disk_image, _disk_image_size,
							_disk_image + (SIZE_T) _header_sections[i].PointerToRawData, _header_sections[i].SizeOfRawData ) &&
							_test_read( larger_image, larger_image_size,
							larger_image + (SIZE_T) _header_sections[i].VirtualAddress, _header_sections[i].SizeOfRawData ))
						{
							memcpy( _disk_image + _header_sections[i].PointerToRawData, larger_image + _header_sections[i].VirtualAddress, _header_sections[i].SizeOfRawData );
						}
					}
				}

				delete [] larger_image;
				if( _options->Verbose )
					printf( "INFO: Done processing disk image.\r\n");

				return true;
			}
			delete [] larger_image;	
		}
		else if( this->_parsed_pe_64 )
		{
			// Reconstruct PE imports aggressively using our knowledge of all the exports addresses in this process
			// Technique:
			//   1. 'exports' defines all valid export addresses in this process
			//   2. Find any binary that points to a valid export in this rpocess
			//   3. Add a new section for the new HintName Array and Import Address Table
			//   4. For each binary patch found above, add a HintName and ImportAddress point so the loads
			//      will recognize it correctly for analysis (IDA).
			unsigned char* larger_image;
			__int64 larger_image_size;
			if( _options->ImportRec )
			{
				// Start the with the original import descriptor list
				pe_imports* peimp = new pe_imports( _image, _image_size, _header_import_descriptors, true );
				
				// Add matches to exports in this process
				int count = 0;
				unsigned __int64 cand_last = 0;
				for(__int64 offset = 0; offset < _image_size - 8; offset+=4 )
				{
					// Check if this 4-gram or 8-gram points to an export
					unsigned __int64 cand = *((unsigned __int64*)(_image + offset));

					if (cand_last != cand && exports->contains(cand))
					{
						export_entry entry = exports->find(cand);

						// Add this to be reconstructed as an import
						if (entry.name != NULL)
							peimp->add_fixup(entry.library_name, entry.name, offset, this->_parsed_pe_64);
						else
							peimp->add_fixup(entry.library_name, entry.ord, offset, this->_parsed_pe_64);
						count++;
					}
					else
					{
						cand_last = cand;
					}
				}
				if( _options->Verbose )
					printf( "INFO: Reconstructing %i imports.\r\n", count );
				
				// Increase the image size for a new section
				__int64 descriptor_size = 0;
				__int64 data_size = 0;
				peimp->get_table_size( descriptor_size, data_size );
				__int64 new_section_size = this->_section_align(data_size+descriptor_size, this->_header_pe64->OptionalHeader.SectionAlignment);
				
				
				// Increase the size of the last section
				_header_sections[_num_sections-1].Misc.VirtualSize = this->_section_align(_header_sections[_num_sections-1].Misc.VirtualSize, this->_header_pe64->OptionalHeader.SectionAlignment) + new_section_size;
				_header_sections[_num_sections-1].SizeOfRawData = _header_sections[_num_sections-1].Misc.VirtualSize;

				larger_image_size = this->_section_align((long long) this->_image_size, this->_header_pe64->OptionalHeader.SectionAlignment) + new_section_size;
				
				larger_image = new unsigned char[larger_image_size];
				memset(larger_image, 0, larger_image_size);
				memcpy(larger_image, _image, _image_size);

				if( _options->Verbose )
					printf( "INFO: Writing added import table.\r\n" );
				
				// Write to the new section
				peimp->build_table( larger_image + this->_section_align((long long) this->_image_size, this->_header_pe64->OptionalHeader.SectionAlignment), new_section_size, (__int64) _image_size, (__int64) 0, descriptor_size );
				
				if( _options->Verbose )
					printf( "INFO: Updating import data directory.\r\n" );

				// Update the PE header to refer to it
				_header_pe64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = this->_section_align((long long) this->_image_size, this->_header_pe64->OptionalHeader.SectionAlignment);
				_header_pe64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = descriptor_size;
				
				delete peimp;
			}
			else
			{
				larger_image_size = _image_size;
				larger_image = new unsigned char[larger_image_size];
				memset(larger_image, 0, larger_image_size);
				memcpy(larger_image, _image, _image_size);
			}
			
				

			if( _original_base != 0 )
			{
				// Adjust the preferred image base, this way the relocations doesn't have to be fixed
				_header_pe64->OptionalHeader.ImageBase = reinterpret_cast<__int64> (_original_base);
			}

			// Change the physical alignment to use the virtual alignment
			if( _options->Verbose )
					printf( "INFO: Adjusting file alignment to %x.\r\n", _header_pe64->OptionalHeader.SectionAlignment);
			_header_pe64->OptionalHeader.FileAlignment = _header_pe64->OptionalHeader.SectionAlignment;
			
			// Adjust the physical size of each section to use the virtual size
			_header_pe64->OptionalHeader.SizeOfHeaders = _section_align(_header_pe64->OptionalHeader.SizeOfHeaders, _header_pe64->OptionalHeader.FileAlignment);
			DWORD required_space = _section_align( _header_pe64->OptionalHeader.SizeOfHeaders, _header_pe64->OptionalHeader.SectionAlignment);
			
			for( int i = 0; i < _num_sections; i++ )
			{
				// Correct the VirtualSize of the section if it is too large
				if( this->_header_sections[i].Misc.VirtualSize > MAX_SECTION_SIZE  )
				{
					if( _options->Verbose )
						printf( "INFO: Calculating required space for section %i.\r\n", i);

					if( i + 1 < _num_sections &&
						this->_header_sections[i+1].VirtualAddress > this->_header_sections[i].VirtualAddress &&
						this->_header_sections[i+1].VirtualAddress < this->_header_sections[i].VirtualAddress + MAX_SECTION_SIZE )
					{
						// Calculate the virtual size manually
						char* location = new char[FILEPATH_SIZE + 1];
						_stream->get_location(location, FILEPATH_SIZE + 1);
						fprintf( stderr, "WARNING: module '%s' at %s. Large section size for section %i of 0x%x changed to 0x%x based on image virtual size as part of sanity check. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
							this->get_name(), location, i, this->_header_sections[i].Misc.VirtualSize, this->_header_sections[i+1].VirtualAddress - this->_header_sections[i].VirtualAddress );
						delete[] location;
						this->_header_sections[i].Misc.VirtualSize = this->_header_sections[i+1].VirtualAddress - this->_header_sections[i].VirtualAddress;
					}
					else
					{
						// Use MAX_SECTION_SIZE
						char* location = new char[FILEPATH_SIZE + 1];
						_stream->get_location(location, FILEPATH_SIZE + 1);
						fprintf( stderr, "WARNING: module '%s' at %s. Large section size for section %i of 0x%x changed to 0x%x based on maximum section size as part of sanity check. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
							this->get_name(), location, i, this->_header_sections[i].Misc.VirtualSize, MAX_SECTION_SIZE );
						delete[] location;
						this->_header_sections[i].Misc.VirtualSize = MAX_SECTION_SIZE;
					}
				}
				
				// Truncate VirtualSize to fit inside image size
				if( this->_header_sections[i].Misc.VirtualSize + this->_header_sections[i].VirtualAddress > larger_image_size )
				{
					char* location = new char[FILEPATH_SIZE + 1];
					_stream->get_location(location, FILEPATH_SIZE + 1);
					DWORD new_size = larger_image_size - this->_header_sections[i].VirtualAddress;
					fprintf( stderr, "WARNING: module '%s' at %s. Large section size for section %i of 0x%x being truncated to 0x%x to fit within the image size. This could be as a result of a custom code to load a library by means other than LoadLibrary().\r\n",
						this->get_name(), location, i, this->_header_sections[i].Misc.VirtualSize, new_size );
					delete[] location;
					this->_header_sections[i].Misc.VirtualSize = new_size;
				}
				
				// Adjust the physical size to be at least the same size as the virtual size
				if( this->_header_sections[i].Misc.VirtualSize > _header_sections[i].SizeOfRawData )
				{
					_header_sections[i].SizeOfRawData = this->_header_sections[i].Misc.VirtualSize;
				}
				
				// Update the pointer to raw data to be correct
				_header_sections[i].PointerToRawData = required_space;
				
				required_space = _section_align( required_space + _header_sections[i].SizeOfRawData, _header_pe64->OptionalHeader.FileAlignment );
			}
			
			// Set the size of image
			_header_pe64->OptionalHeader.SizeOfImage = required_space;
			
			if( _options->Verbose )
				printf( "INFO: Copying the corrected memory PE header into file PE header format.\r\n");

			// Copy over the modified PE header into the imaged version
			if( _test_read( larger_image, larger_image_size, larger_image, _header_pe64->OptionalHeader.SizeOfHeaders ) &&
				_test_read( _raw_header, _raw_header_size, _raw_header, _header_pe64->OptionalHeader.SizeOfHeaders ) )
			{
				memcpy( larger_image, _raw_header, _header_pe64->OptionalHeader.SizeOfHeaders );
			}
			else if( _test_read( larger_image, larger_image_size, larger_image, _raw_header_size ) &&
					 _test_read( _raw_header, _raw_header_size, _raw_header, _raw_header_size ) )
			{
				memcpy( larger_image, _raw_header, _raw_header_size );
			}
			
			if( _header_pe64->OptionalHeader.SectionAlignment >= _header_pe64->OptionalHeader.FileAlignment )
			{
				// Pack it down into a disk image of the file
				if( _options->Verbose )
						printf( "INFO: Packing down memory sections into the file.\r\n");

				// Allocate the necessary space for the physical image and initialize it to zero
				_disk_image_size = required_space;
				_disk_image = new unsigned char[_disk_image_size];
				memset(_disk_image, 0, _disk_image_size);
				
				// Copy the header
				if( _test_read( _disk_image, _disk_image_size, _disk_image, _section_align(_header_pe64->OptionalHeader.SizeOfHeaders, _header_pe64->OptionalHeader.FileAlignment) ) &&
					_test_read( larger_image, larger_image_size, larger_image, _section_align(_header_pe64->OptionalHeader.SizeOfHeaders, _header_pe64->OptionalHeader.FileAlignment) ) )
				{
					memcpy( _disk_image, larger_image, _header_pe64->OptionalHeader.SizeOfHeaders );
				}
				
				if( _parsed_sections )
				{
					// Copy the sections one-by-one
					for( int i = 0; i < _num_sections; i++ )
					{
						if( _options->Verbose )
							printf( "INFO: Packing down section %i.\r\n", i);

						// Copy this section if the source and destination are both within acceptable bounds
						if( _test_read( _disk_image, _disk_image_size,
							_disk_image + (SIZE_T) _header_sections[i].PointerToRawData, _header_sections[i].SizeOfRawData ) &&
							_test_read( larger_image, larger_image_size,
							larger_image + (SIZE_T) _header_sections[i].VirtualAddress, _header_sections[i].SizeOfRawData ))
						{
							memcpy( _disk_image + _header_sections[i].PointerToRawData, larger_image + _header_sections[i].VirtualAddress, _header_sections[i].SizeOfRawData );
						}
					}
				}

				delete [] larger_image;

				if( _options->Verbose )
					printf( "INFO: Done processing disk image.\r\n");

				return true;
			}
			delete [] larger_image;	
		}
	}
	return false;
}

bool pe_header::process_import_directory( )
{
	if( this->_parsed_pe_32 )
	{
		// Test case for import reconstruction - destroy it :)
		//_header_pe32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = 0;
		//_header_pe32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = 0;

		if( _header_pe32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != 0 )
		{
			unsigned char* base_imports = _image + _header_pe32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

			// Count the number of IMAGE_IMPORT_DESCRIPTORs
			_header_import_descriptors_count = 0;
			bool more;
			do
			{
				more = false;
				if( _test_read( _image,_image_size, base_imports + _header_import_descriptors_count * sizeof(IMAGE_IMPORT_DESCRIPTOR ),
					sizeof(IMAGE_IMPORT_DESCRIPTOR ) ) )
				{
					IMAGE_IMPORT_DESCRIPTOR* current = &((IMAGE_IMPORT_DESCRIPTOR*) base_imports)[_header_import_descriptors_count];
					if( current->Characteristics != 0 || current->FirstThunk != 0 || current->ForwarderChain != 0 || current->Name != 0 )
					{
						more = true;
						_header_import_descriptors_count++;
					}
				}
			}while(more);

			if( _options->Verbose )
				printf("Found %i import descriptors.\r\n", _header_import_descriptors_count);

			if( _header_import_descriptors_count > 0 )
			{
				// Load the IMAGE_IMPORT_DESCRIPTOR array
				_header_import_descriptors = (IMAGE_IMPORT_DESCRIPTOR*) base_imports;

				// Now process and fix the contents of each of these IMAGE_IMPORT_DESCRIPTORs. We assume the
				// OriginalFirstThunk HintName array is valid.
				// TODO: Upgrade this to assume OriginalFirstThunk array is invalid.
				for( int i = 0; i < _header_import_descriptors_count; i++ )
				{
					int num_iat_entries = 0;
					bool more;
					do{
						more = false;
						if( _test_read( _image, _image_size, _image + _header_import_descriptors[i].FirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32), sizeof(_IMAGE_THUNK_DATA32) ) &&
							_test_read( _image, _image_size, _image + _header_import_descriptors[i].OriginalFirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32), sizeof(_IMAGE_THUNK_DATA32) ) &&
							*((DWORD*)(_image + _header_import_descriptors[i].FirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32))) != 0 &&
							*((DWORD*)(_image + _header_import_descriptors[i].OriginalFirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32))) != 0)
						{
							memcpy( _image + _header_import_descriptors[i].FirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32),
								_image + _header_import_descriptors[i].OriginalFirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32), sizeof(_IMAGE_THUNK_DATA32) );

							more = true;
							num_iat_entries++;
						}
						// TODO: Parse the import table information

					}while(more);
					
					if( _options->Verbose )
							printf("Reconstructed %i thunk data entries.\r\n", num_iat_entries);
				}
			}
		}
		return true;
	}
	else if( this->_parsed_pe_64 )
	{
		// Test case for import reconstruction - destroy it :)
		//_header_pe64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = 0;
		//_header_pe64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = 0;

		if( _header_pe64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != 0 )
		{
			unsigned char* base_imports = _image + _header_pe64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

			// Count the number of IMAGE_IMPORT_DESCRIPTORs
			_header_import_descriptors_count = 0;
			bool more;
			do
			{
				more = false;
				if( _test_read( _image,_image_size, base_imports + _header_import_descriptors_count * sizeof(IMAGE_IMPORT_DESCRIPTOR ),
					sizeof(IMAGE_IMPORT_DESCRIPTOR ) ) )
				{
					IMAGE_IMPORT_DESCRIPTOR* current = &((IMAGE_IMPORT_DESCRIPTOR*) base_imports)[_header_import_descriptors_count];
					if( current->Characteristics != 0 || current->FirstThunk != 0 || current->ForwarderChain != 0 || current->Name != 0 )
					{
						more = true;
						_header_import_descriptors_count++;
					}
				}
			}while(more);

			if( _options->Verbose )
				printf("Found %i import descriptors.\r\n", _header_import_descriptors_count);

			if( _header_import_descriptors_count > 0 )
			{
				// Load the IMAGE_IMPORT_DESCRIPTOR array
				_header_import_descriptors = (IMAGE_IMPORT_DESCRIPTOR*) base_imports;

				// Now process and fix the contents of each of these IMAGE_IMPORT_DESCRIPTORs. We assume the
				// OriginalFirstThunk HintName array is valid.
				// TODO: Upgrade this to assume OriginalFirstThunk array is invalid.
				for( int i = 0; i < _header_import_descriptors_count; i++ )
				{
					int num_iat_entries = 0;
					bool more;
					do{
						more = false;
						if( _test_read( _image, _image_size, _image + _header_import_descriptors[i].FirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32), sizeof(_IMAGE_THUNK_DATA32) ) &&
							_test_read( _image, _image_size, _image + _header_import_descriptors[i].OriginalFirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32), sizeof(_IMAGE_THUNK_DATA32) ) &&
							*((DWORD*)(_image + _header_import_descriptors[i].FirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32))) != 0 &&
							*((DWORD*)(_image + _header_import_descriptors[i].OriginalFirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32))) != 0)
						{
							memcpy( _image + _header_import_descriptors[i].FirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32),
								_image + _header_import_descriptors[i].OriginalFirstThunk + num_iat_entries*sizeof(_IMAGE_THUNK_DATA32), sizeof(_IMAGE_THUNK_DATA32) );

							more = true;
							num_iat_entries++;
						}
						// TODO: Parse the import table information

					}while(more);
					
					if( _options->Verbose )
							printf("Reconstructed %i thunk data entries.\r\n", num_iat_entries);
				}
			}
		}
		return true;
	}

	return false;
}

bool pe_header::process_export_directory( )
{
	_header_import_descriptors_count = 0;

	if( (this->_parsed_pe_32 || this->_parsed_pe_64) && _image != NULL )
	{
		unsigned char* base_exports;
		if( _parsed_pe_32 )
			base_exports = _image + _header_pe32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
		else
			base_exports = _image + _header_pe64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
		
		if( _test_read( _image,_image_size, base_exports, sizeof(IMAGE_EXPORT_DIRECTORY ) ) )
		{
			_header_export_directory = ((IMAGE_EXPORT_DIRECTORY*) base_exports);
			
			// Parse this export directory
			_export_list = new export_list();
			_export_list->add_exports( _image, _image_size, (__int64) _original_base, _header_export_directory, this->_parsed_pe_64);
			
			return true;
		}
	}

	return false;
}

bool pe_header::_test_read( unsigned char* buffer, SIZE_T length, unsigned char* read_ptr, SIZE_T read_length )
{
	return read_ptr >= buffer && read_ptr + read_length <= buffer + length;
}

pe_header::~pe_header(void)
{
	if( this->_stream != NULL )
		delete this->_stream;
	if( this->_image_size != 0 )
		delete[] _image;
	if( this->_raw_header_size != 0 )
		delete[] _raw_header;
	if( this->_disk_image_size != 0 )
		delete[] _disk_image;
	if( this->_name_filepath_long != 0 )
		delete[] _name_filepath_long;
	if( this->_name_filepath_short != 0 )
		delete[] _name_filepath_short;
	if( this->_name_original_exports != 0 )
		delete[] _name_original_exports;
	if( this->_name_original_manifest != 0 )
		delete[] _name_original_manifest;
	if( this->_name_symbols_path != 0 )
		delete[] _name_symbols_path;
	if( this->_export_list != NULL )
		delete _export_list;
}


DWORD pe_header::_section_align( DWORD address, DWORD alignment)
{
	// Round the address up to the nearest section alignment
	if( alignment > 0 && address % alignment > 0 )
		return (address - (address % alignment)) + alignment;
	return address;
}

__int64 pe_header::_section_align( __int64 address, DWORD alignment)
{
	// Round the address up to the nearest section alignment
	if( address % alignment > 0 )
		return (address - (address % alignment)) + alignment;
	return address;
}
```

`pd/pe_header.h`:

```h
#pragma once

#include "stdafx.h"
#include <stdio.h>
#include "windows.h"
#include "stream_wrapper.h"
#include <stdlib.h>
#include "module_list.h"
#include "export_list.h"
#include <unordered_map>
#include <unordered_set>
#include "string.h"
#include "pe_imports.h"
#include <functional>

using namespace std;
using namespace std::tr1;


#define FILEPATH_SIZE 265

// 10MB
#define MAX_SECTION_SIZE (1024 * 1000) * 60

static bool static_zero_init = false;
static char static_zero [100];

enum ALIGNMENT
{
	PHYSICAL,
	VIRTUAL
};

struct IMPORT_SUMMARY
{
	size_t COUNT_UNIQUE_IMPORT_ADDRESSES;
	size_t COUNT_UNIQUE_IMPORT_LIBRARIES;
	unsigned __int64 HASH_GENERIC;
	unsigned __int64 HASH_SPECIFIC;
};

class pe_header
{
	
	unsigned __int64 _unique_hash;

	PD_OPTIONS* _options;

	stream_wrapper* _stream;
	void* _original_base;


	SIZE_T _raw_header_size;
	unsigned char* _raw_header;
	SIZE_T _image_size;
	unsigned char* _image;
	SIZE_T _disk_image_size;
	unsigned char* _disk_image;
	

	// Extracted current and original filename information about this module
	SIZE_T _name_filepath_short_size;
	char* _name_filepath_short;
	SIZE_T _name_filepath_long_size;
	char* _name_filepath_long;
	SIZE_T _name_original_exports_size;
	char* _name_original_exports;
	SIZE_T _name_original_manifest_size;
	char* _name_original_manifest;
	SIZE_T _name_symbols_path_size;
	char* _name_symbols_path;


	bool _parsed_dos;
	IMAGE_DOS_HEADER* _header_dos;

	bool _parsed_pe_32;
	IMAGE_NT_HEADERS32* _header_pe32;
	bool _parsed_pe_64;
	IMAGE_NT_HEADERS64* _header_pe64;
	int _correction_offset;

	// Import table
	int _header_import_descriptors_count;
	IMAGE_IMPORT_DESCRIPTOR* _header_import_descriptors;

	// Export table
	IMAGE_EXPORT_DIRECTORY* _header_export_directory;
	export_list* _export_list;
	
	bool _parsed_sections;
	int _num_sections;
	IMAGE_SECTION_HEADER* _header_sections;
	DWORD* _header_section_sizes;

	bool _test_read( unsigned char* buffer, SIZE_T length, unsigned char* read_ptr, SIZE_T read_length );
	
	
	
	
	DWORD _section_align( DWORD address, DWORD alignment);
	__int64 _section_align( __int64 address, DWORD alignment);

public:
	pe_header( char* filename, PD_OPTIONS* options );
	pe_header( DWORD pid, void* base, module_list* modules, PD_OPTIONS* options );
	pe_header( DWORD pid, module_list* modules, PD_OPTIONS* options );
	pe_header( HANDLE ph, void* base, module_list* modules, PD_OPTIONS* options );
	
	bool build_pe_header( __int64 size, bool amd64 );
	bool build_pe_header( __int64 size, bool amd64, int num_sections_limit );
	
	bool process_pe_header( );
	bool process_import_directory( );
	bool process_export_directory( );
	bool process_relocation_directory();
	bool process_sections( );
	bool process_disk_image( export_list* exports );
	bool process_hash( );

	bool somewhat_parsed();

	unsigned __int64 get_hash();

	IMPORT_SUMMARY get_imports_information( export_list* exports );
	IMPORT_SUMMARY get_imports_information( export_list* exports, __int64 size_limit );

	bool write_image( char* filename );

	export_list* get_exports();
	unsigned __int64 get_virtual_size();

	bool is_64();
	bool is_dll();
	bool is_exe();
	bool is_sys();
	char* get_name();
	void set_name(char* new_name);

	void print_report( FILE* stream );

	__int64 get_export_addresses();
	
	~pe_header(void);
};

```

`pd/pe_imports.cpp`:

```cpp
#include "StdAfx.h"
#include "pe_imports.h"

void pe_imports::add_fixup(char* library_name, int ordinal, __int64 rva, bool win64)
{
	this->_libraries.Add(new import_library(library_name, ordinal, rva, win64));
}

void pe_imports::add_fixup(char* library_name, char* proc_name, __int64 rva, bool win64)
{
	this->_libraries.Add(new import_library(library_name, proc_name, rva, win64));
}


void pe_imports::get_table_size(__int64 &descriptor_size, __int64 &extra_size)
{
	for( int i = 0; i < _libraries.GetSize(); i++ )
	{
		_libraries[i]->get_table_size( descriptor_size, extra_size );
	}
	descriptor_size += sizeof(IMAGE_IMPORT_DESCRIPTOR);
}

bool pe_imports::build_table(unsigned char* section, __int64 section_size, __int64 section_rva, __int64 descriptor_offset, __int64 extra_offset)
{
	// Build the import table in the new section
	bool retval = true;
	for( int i = 0; i < _libraries.GetSize(); i++ )
	{
		if( !_libraries[i]->build_table(section, section_size, section_rva, descriptor_offset, extra_offset) )
			retval = false;
	}

	// Write the final descriptor
	IMAGE_IMPORT_DESCRIPTOR blank_descrptor;
	memset( &blank_descrptor, 0, sizeof(IMAGE_IMPORT_DESCRIPTOR) );

	if( test_read( section, section_size, section + descriptor_offset , sizeof(IMAGE_IMPORT_DESCRIPTOR) ) )
		memcpy( section + descriptor_offset, &blank_descrptor, sizeof(IMAGE_IMPORT_DESCRIPTOR) );


	return retval;
}

pe_imports::pe_imports(unsigned char* image, __int64 image_size, IMAGE_IMPORT_DESCRIPTOR* imports, bool win64)
{
	_win64 = win64;

	// Process the import descriptor directory
	bool more;
	int i = 0;
	do
	{
		more = false;
		if( test_read( image, image_size, ((unsigned char*)imports) + i * sizeof(IMAGE_IMPORT_DESCRIPTOR ),
			sizeof(IMAGE_IMPORT_DESCRIPTOR ) ) )
		{
			IMAGE_IMPORT_DESCRIPTOR* current = &((IMAGE_IMPORT_DESCRIPTOR*) imports)[i];
			if( current->Characteristics != 0 || current->FirstThunk != 0 || current->ForwarderChain != 0 || current->Name != 0 )
			{
				this->add_descriptor(current);
				more = true;
				i++;
			}
		}
	}while(more);
}

void pe_imports::add_descriptor(IMAGE_IMPORT_DESCRIPTOR* descriptor)
{
	this->_libraries.Add( new import_library(descriptor, _win64) );
}

pe_imports::~pe_imports(void)
{
}

import_library::~import_library(void)
{
	delete _descriptor;

	if( _import_by_name != NULL )
		delete[] _import_by_name;

	if( _library_name != NULL )
		delete[] _library_name;

	if( _thunk_entry != NULL )
		delete _thunk_entry;
}

import_library::import_library(IMAGE_IMPORT_DESCRIPTOR* descriptor, bool win64)
{
	// Localize the descriptor, TODO: and the referenced data maybe
	_descriptor = new IMAGE_IMPORT_DESCRIPTOR(*descriptor);
	_import_by_name = NULL;
	_library_name = NULL;
	_thunk_entry = NULL;
}

import_library::import_library(char* library_name, int ordinal, __int64 rva, bool win64)
{
	// Create an import library to fixup a specific rva to the ordinal
	_descriptor = new IMAGE_IMPORT_DESCRIPTOR();
	_descriptor->OriginalFirstThunk = NULL; // Replace with rva to this->thunk_entry when outputting
	_descriptor->TimeDateStamp = -1;
	_descriptor->ForwarderChain = -1;
	_descriptor->Name = NULL; // Replace with rva to name upon writing
	_descriptor->FirstThunk = rva; // PE Loader with patchup address at rva to become the address of the import, awesome!
	_import_by_name = NULL;
	_thunk_entry = new IMAGE_THUNK_DATA64();

	_library_name = new char[strlen(library_name)+1];
	strcpy(_library_name, library_name);
	
	// Ordinal import
	if( win64 )
		_thunk_entry->u1.Ordinal = IMAGE_ORDINAL_FLAG64 | (ordinal & 0xffff);
	else
		_thunk_entry->u1.Ordinal = IMAGE_ORDINAL_FLAG32 | (ordinal & 0xffff);
}

import_library::import_library(char* library_name, char* proc_name, __int64 rva, bool win64)
{
	// Create an import library to fixup a specific rva to the ordinal
	_descriptor = new IMAGE_IMPORT_DESCRIPTOR();
	_descriptor->OriginalFirstThunk = NULL; // Replace with rva to this->thunk_entry when outputting
	_descriptor->TimeDateStamp = -1;
	_descriptor->ForwarderChain = -1;
	_descriptor->Name = NULL; // Replace with rva to name upon writing
	_descriptor->FirstThunk = rva; // PE Loader with patchup address at rva to become the address of the import, awesome!
	_thunk_entry = new IMAGE_THUNK_DATA64();

	_library_name = new char[strlen(library_name)+1];
	strcpy(_library_name, library_name);
	
	// Name import
	_thunk_entry->u1.AddressOfData = NULL; // Replace with rva to import_by_name
	
	_import_by_name = (IMAGE_IMPORT_BY_NAME*) new char[strlen(proc_name)+1+sizeof(WORD)]; // {DWORD, procedure name}
	_import_by_name->Hint = 0; // Not necessary
	_import_by_name_len = strlen(proc_name)+1+sizeof(WORD);
	strcpy((char*)(&_import_by_name->Name), proc_name);
}

void import_library::get_table_size(__int64 &descriptor_size, __int64 &extra_size)
{
	// Calculate the size required
	
	// Write the _import_by_name name if necessary
	if( _import_by_name != NULL )
	{
		extra_size += _import_by_name_len;
	}

	// Write the _thunk_entry IMAGE_THUNK_DATA64 struct, and update it
	if( _thunk_entry != NULL )
	{
		extra_size += 2 * sizeof(IMAGE_THUNK_DATA64);
	}

	// Patch up the library name
	if( _library_name != NULL )
	{
		extra_size += strlen(_library_name) + 1;
	}

	// Copy over the descriptor
	descriptor_size += sizeof(IMAGE_IMPORT_DESCRIPTOR);
}

bool import_library::build_table(unsigned char* section, __int64 section_size, __int64 section_rva, __int64 &descriptor_offset, __int64 &extra_offset)
{
	// Output this import table into the specified section blob
	
	// Write the _import_by_name name if necessary
	__int64 import_name_rva = 0;
	if( _import_by_name != NULL )
	{
		if( !test_read(section, section_size, extra_offset + section, _import_by_name_len ) )
			return false; // Not enough room
		
		memcpy(extra_offset + section, (char*)_import_by_name, _import_by_name_len);
		import_name_rva = extra_offset + section_rva;
		extra_offset += _import_by_name_len;
	}

	// Write the _thunk_entry IMAGE_THUNK_DATA64 struct, and update it
	__int64 thunk_entry_rva = 0;
	if( _thunk_entry != NULL )
	{
		if( !test_read(section, section_size, extra_offset + section, sizeof(IMAGE_THUNK_DATA64)*2 ) )
			return false;
		
		if( import_name_rva != NULL )
			_thunk_entry->u1.AddressOfData = import_name_rva;
		
		memcpy(extra_offset + section, (char*) _thunk_entry, sizeof(IMAGE_THUNK_DATA64));
		thunk_entry_rva = extra_offset + section_rva;
		
		// Copy a null _thunk_entry terminator. For a 32 bit module, we are wasting a DWORD for the 64 structure, but that's fine.
		memset(extra_offset + section + sizeof(IMAGE_THUNK_DATA64), 0, sizeof(IMAGE_THUNK_DATA64));
		
		extra_offset += 2*sizeof(IMAGE_THUNK_DATA64);
	}
	
	// Update and write the IMAGE_IMPORT_DESCRIPTOR
	if( _descriptor == NULL )
		return false;
	if( !test_read(section, section_size, descriptor_offset + section, sizeof(IMAGE_IMPORT_DESCRIPTOR)) )
		return false; // Not enough room

	if( thunk_entry_rva != NULL )
		_descriptor->OriginalFirstThunk = thunk_entry_rva; // Redirect this to our thunk rva
	
	// Patch up the library name
	if( _library_name != NULL )
	{
		if( !test_read(section, section_size, extra_offset + section, strlen(_library_name) + 1) )
			return false; // Not enough room

		strcpy((char*)(extra_offset + section), _library_name);
		_descriptor->Name = extra_offset + section_rva;
		
		extra_offset += strlen(_library_name) + 1;
	}

	// Copy over the descriptor
	memcpy(descriptor_offset + section, (unsigned char*)_descriptor, sizeof(IMAGE_IMPORT_DESCRIPTOR));
	descriptor_offset += sizeof(IMAGE_IMPORT_DESCRIPTOR);
	
	return true;
}
```

`pd/pe_imports.h`:

```h
#pragma once
#include "windows.h"
#include "DynArray.h"
#include "utils.h"

#define IMAGE_ORDINAL_FLAG64 0x8000000000000000ULL
#define IMAGE_ORDINAL_FLAG32 0x80000000

class import_library
{
	char* _library_name;
	
	IMAGE_IMPORT_DESCRIPTOR* _descriptor;
	IMAGE_THUNK_DATA64* _thunk_entry; // Use 64 bit definition for both 32 and 64 bit modules.
	IMAGE_IMPORT_BY_NAME* _import_by_name; // IMAGE_IMPORT_BY_NAME
	int _import_by_name_len;

public:
	import_library(IMAGE_IMPORT_DESCRIPTOR* descriptor, bool win64);
	import_library(char* library_name, int ordinal, __int64 rva, bool win64);
	import_library(char* library_name, char* proc_name, __int64 rva, bool win64);

	bool build_table(unsigned char* section, __int64 section_size, __int64 section_rva, __int64 &descriptor_offset, __int64 &extra_offset);
	void get_table_size(__int64 &descriptor_size, __int64 &extra_size);
	char* GetName();
	~import_library(void);
};

class pe_imports
{
	bool _win64;
	DynArray<import_library*> _libraries;
public:
	pe_imports(unsigned char* image, __int64 image_size, IMAGE_IMPORT_DESCRIPTOR* imports, bool win64);
	void add_descriptor(IMAGE_IMPORT_DESCRIPTOR* descriptor);
	bool build_table(unsigned char* section, __int64 section_size, __int64 section_rva, __int64 descriptor_offset, __int64 extra_offset);
	void get_table_size(__int64 &descriptor_size, __int64 &extra_size);

	void add_fixup(char* library_name, int ordinal, __int64 rva, bool win64);
	void add_fixup(char* library_name, char* proc_name, __int64 rva, bool win64);
	//char* build_table();
	~pe_imports(void);
};



```

`pd/simple.cpp`:

```cpp
#include "StdAfx.h"
#include "simple.h"


DWORD process_find(string match_regex, DynArray<process_description*>* result)
{
	PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if( snapshot != INVALID_HANDLE_VALUE )
	{
		if (Process32First(snapshot, &entry) == TRUE)
		{
			while (Process32Next(snapshot, &entry) == TRUE)
			{
				char* process_name = new char[wcslen(entry.szExeFile)+1];
				sprintf( process_name, "%S", entry.szExeFile );
			
				string name (process_name);
				try
				{
					regex reg (match_regex);
					if( regex_match( name, reg ) )
					{  
						// Record this as a matching process
						result->Add( new process_description( process_name, entry.th32ProcessID ) );
					}
				}
				catch( std::tr1::regex_error e )
				{
					fprintf( stderr, "ERROR: Invalid regex expression for matching process names." );
					return 0;
				}


			}
		}

		CloseHandle(snapshot);
	}
	return result->GetSize();
}

string ExePath() {
    char buffer[MAX_PATH];
    GetModuleFileNameA( NULL, buffer, MAX_PATH );
    string::size_type pos = string( buffer ).find_last_of( "\\/" );
    return string( buffer ).substr( 0, pos);
}

void PrintLastError(LPTSTR lpszFunction)
{
	// Retrieve the system error message for the last-error code
    LPVOID lpMsgBuf;
    LPVOID lpDisplayBuf;
    DWORD dw = GetLastError(); 

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dw,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) &lpMsgBuf,
        0, NULL );

    // Display the error message and exit the process
    lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT, 
        (lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR)); 
    StringCchPrintf((LPTSTR)lpDisplayBuf, 
        LocalSize(lpDisplayBuf) / sizeof(TCHAR),
        TEXT("%s failed with error %d: %s"), 
        lpszFunction, dw, lpMsgBuf); 

	fwprintf(stderr,(LPCTSTR) lpDisplayBuf );

    LocalFree(lpMsgBuf);
    LocalFree(lpDisplayBuf);
}
```

`pd/simple.h`:

```h
#pragma once

#include <windows.h>
#include <strsafe.h>
#include <string>
#include <iostream>
#include "windows.h"
#include <tlhelp32.h>
#include <Psapi.h>
#include <regex>
#include "DynArray.h"

using namespace std;
using namespace std::tr1;

class PD_OPTIONS
{
public:
	bool ImportRec;
	bool ForceGenHeader;
	bool Verbose;
	bool ReconstructHeaderAsDll;
	bool DumpChunks; // Dump loose code chunks
	int NumberOfThreads;

	__int64 EntryPointOverride;
	char* output_path;

	PD_OPTIONS()
	{
		output_path = new char[1];
		strcpy(output_path,"");
	}

	void set_output_path( char* path )
	{
		if( output_path != NULL )
			delete[] output_path;

		output_path = new char[strlen(path) + 1];
		strcpy_s( output_path, strlen(path) + 1, path);
	}

	~PD_OPTIONS()
	{
		if( output_path != NULL )
		{
			delete[] output_path;
		}
	}
};

class process_description
{
public:
	char* process_name;
	DWORD pid;

	process_description(char* name, DWORD pid)
	{
		process_name = new char[strlen(name)+1];
		strcpy( process_name, name );
		this->pid = pid;
	}
	
	~process_description()
	{
		delete[] process_name;
	}
};

DWORD process_find(string match_regex, DynArray<process_description*>* result);
string ExePath();
void PrintLastError(LPTSTR lpszFunction); 
```

`pd/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// pd.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`pd/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO: reference additional headers your program requires here

```

`pd/stream_wrapper.h`:

```h
#pragma once

#include <stdio.h>
#include "windows.h"
#include "simple.h"
#include <tlhelp32.h>
#include "module_list.h"


// A stream class that wraps reading from either a file or process memory offset.
class stream_wrapper
{
public:
	bool file_alignment;
	virtual SIZE_T block_size( long offset ) = 0;
	virtual bool read( long offset, SIZE_T size, unsigned char* output, SIZE_T* out_read ) = 0;
	virtual SIZE_T get_short_name( char* out_name, SIZE_T out_name_size ) = 0;
	virtual SIZE_T get_long_name( char* out_name, SIZE_T out_name_size ) = 0;
	virtual SIZE_T get_location( char* out_name, SIZE_T out_name_size ) = 0;
	virtual __int64 get_address() = 0;
	virtual __int64 estimate_section_size( long offset ) = 0;
	virtual DWORD get_region_characteristics( long offset ) = 0;
	virtual ~stream_wrapper() {}
	virtual void update_base( __int64 rva ) = 0;
};


class file_stream : stream_wrapper
{
	char* _filename;

	bool opened;
	FILE* fh;
public:

	file_stream(char* filename)
	{
		// Localize the filename
		_filename = new char[ strlen(filename) + 1 ];
		strcpy( _filename, filename );

		// Set the input stream as a file
		fh = fopen(filename, "rb");
		file_alignment = true;

		if( fh != NULL )
			opened = true;
		else
		{
			PrintLastError(L"Failed to open file.");
			opened = false;
		}
	}

	virtual void update_base( __int64 rva )
	{
			// nothing
	}

	virtual __int64 get_address( )
	{
		return 0;
	}

	virtual __int64 estimate_section_size( long offset )
	{
		return 0;
	}

	virtual SIZE_T get_location( char* out_name, SIZE_T out_name_size )
	{
		return get_long_name( out_name, out_name_size );
	}

	virtual SIZE_T get_long_name( char* out_name, SIZE_T out_name_size )
	{
		// Return the path of this file on disk
		SIZE_T length = strlen(_filename) + 1;
		if( length > out_name_size )
			length = out_name_size;
		memcpy( out_name, _filename, length );
		out_name[length-1] = 0;

		return length - 1;
	}

	virtual SIZE_T get_short_name( char* out_name, SIZE_T out_name_size )
	{
		char fname[_MAX_FNAME];
		char ext[_MAX_EXT];
		char short_name[_MAX_FNAME + _MAX_EXT + 1];
		_splitpath( _filename, NULL, NULL, fname, ext );
		sprintf( short_name, "%s.%s", fname, ext );

		SIZE_T length = strlen(short_name) + 1;
		if( length > out_name_size )
			length = out_name_size;
		memcpy( out_name, short_name, length );
		out_name[length-1] = 0;

		return length - 1;
	}


	virtual SIZE_T block_size( long offset )
	{
		if( opened )
		{
			if( !fseek( fh, 0, SEEK_END) )
				return ftell( fh ) - offset;
			else
				PrintLastError(L"Seek failed.");
		}
		return 0;
	}

	virtual DWORD get_region_characteristics( long offset )
	{
		return IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;
	}

	virtual bool read( long offset, SIZE_T size, unsigned char* output, SIZE_T* out_read )
	{
		*out_read = 0;

		if( opened )
		{
			if( !fseek( fh, offset, SEEK_SET) )
			{
				*out_read = fread( output, 1, size, fh );
				if( *out_read == size )
					return true;
			}
		}
		return false;
	}

	~file_stream(void)
	{
		if( opened )
			fclose( fh );
		if( _filename != NULL )
			delete[] _filename;
	}
};



class process_stream : stream_wrapper
{
	bool opened;
	HANDLE ph;

	char* _long_name;
	char* _short_name;
	
	void init( HANDLE ph, void* base, module_list* modules )
	{
		file_alignment = false;
		this->ph = ph;
		_long_name = NULL;
		_short_name = NULL;
		if( ph != NULL )
		{
			opened = true;
			this->base = base;

			// Copy this long and short name
			unordered_map<unsigned __int64, module*>::const_iterator item = modules->_modules.find( (unsigned __int64) base );
			if( item != modules->_modules.end() )
			{
				_long_name = new char[260];
				_short_name = new char[256];
				strcpy( _long_name, ((module*)item->second)->full_name );
				strcpy( _short_name, ((module*)item->second)->short_name );
			}
		}
		else
			opened = false;
	}

public:
	void* base;


	process_stream(HANDLE ph, void* base)
	{
		_long_name = NULL;
		_short_name = NULL;
		file_alignment = false;
		this->ph = ph;
		if( ph != NULL )
		{
			opened = true;
			this->base = base;
		}
		else
			opened = false;
	}

	process_stream(HANDLE ph, void* base, module_list* modules )
	{
		_long_name = NULL;
		_short_name = NULL;
		init( ph, base, modules );
	}

	process_stream(DWORD pid, module_list* modules)
	{
		_long_name = NULL;
		_short_name = NULL;

		// Try to open the specified process pid and use the main module as the base
		file_alignment = false;
		ph = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, pid);
		opened = false;
		
		if( ph != NULL )
		{
			HANDLE hSnapshot=CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
			if( hSnapshot != INVALID_HANDLE_VALUE )
			{
				MODULEENTRY32 tmpModule;
				tmpModule.dwSize = sizeof(MODULEENTRY32);
				if( Module32First(hSnapshot, &tmpModule) )
				{
					opened = true;
					this->base = tmpModule.modBaseAddr;
				}
				CloseHandle( hSnapshot );				

				init( ph, base, modules );
			}
			else
			{
				if( GetLastError() == 299 )
					fprintf(stderr, "ERROR: Unable to open process PID 0x%x since it is a 64 bit process and this tool is running as a 32 bit process.\r\n", pid);
				else
					PrintLastError(L"create_process_stream CreateToolhelp32Snapshot");
			}
		}
		else
		{
			fprintf(stderr, "Failed to open process with PID 0x%x:\r\n", pid );
			PrintLastError(L"\tcreate_process_stream");
		}
	}

	process_stream(DWORD pid, void* base, module_list* modules )
	{
		// Try to open the specified process pid
		_long_name = NULL;
		_short_name = NULL;
		file_alignment = false;
		opened = false;
		ph = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, pid);
		
		if( ph != NULL )
		{
			init( ph, base, modules );
		}
		else
		{
			fprintf(stderr, "Failed to open process with PID 0x%x:\r\n", pid );
			PrintLastError(L"\tcreate_process_stream");
		}
	}

	virtual SIZE_T get_location( char* out_name, SIZE_T out_name_size )
	{
		char* hex = new char[16 + 2 + 1]; // Max space required
		int hexLength = sprintf( hex, "0x%llX", (__int64) this->base );

		if( hexLength < out_name_size )
		{
			memcpy( out_name, hex, hexLength );
			out_name[hexLength] = 0;
			delete[] hex;
			return hexLength;
		}
		delete[] hex;
		return 0;
	}

	virtual SIZE_T get_short_name( char* out_name, SIZE_T out_name_size )
	{
		if( _short_name != NULL )
		{
			SIZE_T length = strlen( _short_name ) + 1;
			if( length > out_name_size )
				length = out_name_size;
			memcpy( out_name, _short_name, length );
			out_name[length-1] = 0;

			return length;
		}
		return 0;
	}

	virtual SIZE_T get_long_name( char* out_name, SIZE_T out_name_size )
	{
		if( _long_name != NULL )
		{
			SIZE_T length = strlen( _long_name ) + 1;
			if( length > out_name_size )
				length = out_name_size;
			memcpy( out_name, _long_name, length );
			out_name[length-1] = 0;

			return length;
		}

		return 0;
	}

	virtual SIZE_T block_size( long offset )
	{
		if( opened )
		{
			_MEMORY_BASIC_INFORMATION64 mbi;
			__int64 blockSize = VirtualQueryEx(ph, (LPCVOID) ((unsigned char*)base + (SIZE_T)offset), (PMEMORY_BASIC_INFORMATION) &mbi, sizeof(_MEMORY_BASIC_INFORMATION64));

			if( blockSize == sizeof(_MEMORY_BASIC_INFORMATION64) )
			{
				return mbi.RegionSize - offset;
			}
			else if(  blockSize == sizeof(_MEMORY_BASIC_INFORMATION32) )
			{
				_MEMORY_BASIC_INFORMATION32* mbi32 = (_MEMORY_BASIC_INFORMATION32*) &mbi;
				return mbi32->RegionSize - offset;
			}
			else if( blockSize == 0 )
			{
				PrintLastError(L"VirtualQueryEx query block size");
			}
		}
		return 0;
	}

	virtual DWORD get_region_characteristics( long offset )
	{
		DWORD characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;
		if( opened )
		{
			_MEMORY_BASIC_INFORMATION64 mbi;
			__int64 blockSize = VirtualQueryEx(ph, (LPCVOID) ((unsigned char*)base + (SIZE_T)offset), (_MEMORY_BASIC_INFORMATION*) &mbi, sizeof(_MEMORY_BASIC_INFORMATION64));

			if( blockSize == sizeof(_MEMORY_BASIC_INFORMATION64) )
			{
				if( mbi.State == MEM_COMMIT && !(mbi.Protect & (PAGE_NOACCESS | PAGE_GUARD)) )
				{
					if( mbi.AllocationProtect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE  ) )
						characteristics |= IMAGE_SCN_MEM_EXECUTE;
				}
			}
			else if(  blockSize == sizeof(_MEMORY_BASIC_INFORMATION32) )
			{
				_MEMORY_BASIC_INFORMATION32* mbi32 = (_MEMORY_BASIC_INFORMATION32*) &mbi;
				if( mbi32->State == MEM_COMMIT && !(mbi32->Protect & (PAGE_NOACCESS | PAGE_GUARD)) )
				{
					if( mbi32->AllocationProtect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE  ) )
						characteristics |= IMAGE_SCN_MEM_EXECUTE;
				}
			}
		}
		
		return characteristics;
	}

	virtual __int64 estimate_section_size( long offset )
	{
		// Estimate the section size according to the heap size and privilege level
		if( opened )
		{
			_MEMORY_BASIC_INFORMATION64 mbi;
			__int64 blockSize = VirtualQueryEx(ph, (LPCVOID) ((unsigned char*)base + (SIZE_T)offset), (_MEMORY_BASIC_INFORMATION*) &mbi, sizeof(_MEMORY_BASIC_INFORMATION64));

			if( blockSize == sizeof(_MEMORY_BASIC_INFORMATION64) )
			{
				if( mbi.State == MEM_COMMIT && !(mbi.Protect & (PAGE_NOACCESS | PAGE_GUARD)) )
				{
					// Good region
					return mbi.RegionSize;
				}
			}
			else if(  blockSize == sizeof(_MEMORY_BASIC_INFORMATION32) )
			{
				_MEMORY_BASIC_INFORMATION32* mbi32 = (_MEMORY_BASIC_INFORMATION32*) &mbi;
				if( mbi32->State == MEM_COMMIT && !(mbi32->Protect & (PAGE_NOACCESS | PAGE_GUARD)) )
				{
					return mbi32->RegionSize;
				}
			}
		}
		
		return 0; // Not valid
	}

	virtual void update_base( __int64 rva )
	{
		this->base = (void*) ((__int64)base + rva);
	}

	virtual __int64 get_address( )
	{
		return (__int64) this->base;
	}

	virtual bool read( long offset, SIZE_T size, unsigned char* output, SIZE_T* out_read )
	{
		// Reads in memory by region. Skips noaccess, guard, and failures leaving the corresponding
		// parts of the output buffer untouched.
		*out_read = 0;

		SIZE_T num_read = 0;

		__int64 already_read = 0;

		if( opened )
		{
			while( already_read < size )
			{
				_MEMORY_BASIC_INFORMATION64 mbi;
				__int64 blockSize = VirtualQueryEx(ph, (LPCVOID) ((unsigned char*)base + (SIZE_T)offset + (SIZE_T)already_read), (_MEMORY_BASIC_INFORMATION*) &mbi, sizeof(_MEMORY_BASIC_INFORMATION64));
				__int64 start_address = already_read + (__int64)base + offset;
				DWORD oldProc = 0;
				if( blockSize == sizeof(_MEMORY_BASIC_INFORMATION64) )
				{
					if (mbi.Protect & (PAGE_NOACCESS | PAGE_GUARD))
					{
						if (!VirtualProtectEx(ph, &mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READ, &oldProc)) {
							printf("Failed VirtualProtectEx");
						}
					}

					if( mbi.State == MEM_COMMIT )
					{
						// Read in this whole or part of this region
						bool success;
						if( start_address + size - already_read >= mbi.BaseAddress + mbi.RegionSize )
						{
							// Read in the whole region
							success = ReadProcessMemory( ph,
																(LPCVOID) (start_address),
																(void*)((__int64) output + already_read),
																mbi.RegionSize,
																&num_read);
							already_read += mbi.RegionSize;
							*out_read += num_read;
						}
						else
						{
							// Read in the partial region
							success = ReadProcessMemory( ph,
																	(LPCVOID) (start_address),
																	(void*)((__int64) output + already_read),
																	size - already_read,
																	&num_read);
								already_read += size - already_read;
								*out_read += num_read;
						}
					}
					else
					{
						// Guard or noaccess, skip this region
						already_read += mbi.RegionSize - (start_address - mbi.BaseAddress);
					}
				}
				else if(  blockSize == sizeof(_MEMORY_BASIC_INFORMATION32) )
				{
					_MEMORY_BASIC_INFORMATION32* mbi32 = (_MEMORY_BASIC_INFORMATION32*) &mbi;

					if (mbi.Protect & (PAGE_NOACCESS | PAGE_GUARD))
					{
						if(!VirtualProtectEx(ph, &mbi32->BaseAddress, mbi32->RegionSize, PAGE_EXECUTE_READ, &oldProc)) {
							printf("Failed VirtualProtectEx");
						}
					}

					if( mbi32->State == MEM_COMMIT )
					{
						// Read in this whole or part of this region
						bool success;

						if( start_address + size - already_read >= mbi32->BaseAddress + mbi32->RegionSize )
						{
							// Read in the whole region
							success = ReadProcessMemory( ph,
																(LPCVOID) (start_address),
																(void*)((__int64) output + already_read),
																mbi32->RegionSize,
																&num_read);
							already_read += mbi32->RegionSize;
							*out_read += num_read;
						}
						else
						{
							// Read in the partial region
							success = ReadProcessMemory( ph,
																	(LPCVOID) (start_address),
																	(void*)((__int64) output + already_read),
																	size - already_read,
																	&num_read);
								already_read += size - already_read;
								*out_read += num_read;
						}
					}
					else
					{
						// Guard or noaccess, skip this region
						already_read += mbi32->RegionSize - (start_address - mbi32->BaseAddress);
					}
				}
				else
				{
					// Failed to query MBI information, best we can do is skip 1 page?
					already_read += 0x1000;
				}
			}
		}

		if( *out_read != already_read )
			return false;
		return true;
	}

	~process_stream(void)
	{
		if( opened )
		{
			// Close the handle
			//CloseHandle( ph ); SHOULD NOT DO THIS. USED BY CREATOR.

			if( _long_name != NULL )
				delete[] _long_name;
			if( _short_name != NULL )
				delete[] _short_name;
		}
		
	}
};




```

`pd/targetver.h`:

```h
#pragma once

// The following macros define the minimum required platform.  The minimum required platform
// is the earliest version of Windows, Internet Explorer etc. that has the necessary features to run 
// your application.  The macros work by enabling all features available on platform versions up to and 
// including the version specified.

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef _WIN32_WINNT            // Specifies that the minimum required platform is Windows Vista.
#define _WIN32_WINNT 0x0600     // Change this to the appropriate value to target other versions of Windows.
#endif


```

`pd/terminate_monitor_hook.cpp`:

```cpp
#include "stdafx.h"
#include "terminate_monitor_hook.h"


bool terminate_monitor_hook::add_redirect(unsigned __int64 target_address)
{
	SIZE_T num_written = 0;
	unsigned char inject[0x20];

	if (!_is64)
	{
		// Redirect code that is the same for x86 and AMD64
		unsigned char data[] = {
			// call +0
			0xE8, 0x00, 0x00, 0x00, 0x00,

			// pop eax
			0x58,

			// add eax, 0x6
			0x83, 0xC0, 0x06,

			// jmp [eax]
			0xFF, 0x20,

			// <target>
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <target_address>
		};

		*(unsigned __int64*)(data + 11) = (unsigned __int64)(target_address);
		memcpy(inject, data, sizeof(data));
	}
	else
	{
		// 64-bit code
		unsigned char data[] = {
			// call +0
			0xE8, 0x00, 0x00, 0x00, 0x00,

			// pop rax
			0x58,

			// add rax, 0x7
			0x48, 0x83, 0xC0, 0x07,

			// jmp [rax]
			0xFF, 0x20,

			// <target>
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <target_address>
		};

		*(unsigned __int64*)(data + 12) = (unsigned __int64)(target_address);
		memcpy(inject, data, sizeof(data));
	}
	
	
	// Write the redirect
	bool success = WriteProcessMemory(_ph, (LPVOID)  _address_terminate, inject, sizeof(inject), &num_written);
	if (success && sizeof(inject) == num_written)
	{
		return true;
	}
	
	return false;
}

bool terminate_monitor_hook::unhock_terminate()
{
	if (_address_terminate != NULL && _original_hook_bytes != NULL)
	{
		// Write the original code back
		SIZE_T num_written = 0;
		bool success = WriteProcessMemory(_ph, (LPVOID) _address_terminate, _original_hook_bytes, sizeof(_original_hook_bytes), &num_written);

		// Handle any stuck threads that are waiting to terminate
		if (is_terminate_waiting())
		{
			resume_terminate();

			// no need to cleanup hook allocation since process is terminating
		}
		else
		{
			// Remove our hook allocation
			if (!_process_is_terminating && _hook_address != NULL)
				VirtualFreeEx(_ph, (LPVOID)_hook_address, 0, MEM_RELEASE);
		}

		_hook_address = NULL;
		_address_is_waiting = NULL;
		_address_thread_id = NULL;
	}
	
	return true;
}

unsigned __int64 terminate_monitor_hook::get_address(char * library, char * procedure_name)
{
	return 0;
}

bool terminate_monitor_hook::get_terminate_orig_code(unsigned char * out_buffer, int length)
{
	return false;
}

bool terminate_monitor_hook::hook_terminate(export_list* exports)
{
	// Allocate space in the remote process for the hook
	if (_hook_address == NULL)
	{
		_hook_address = (unsigned __int64)VirtualAllocEx(_ph, NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (_hook_address > 0)
		{
			// Lookup the function addresses in the target process
			_address_terminate = exports->find_export("ntdll.dll", "NtTerminateProcess", _is64);
			unsigned __int64 address_getthread = exports->find_export("kernel32.dll", "GetCurrentThread", _is64);
			unsigned __int64 address_getthreadid = exports->find_export("kernel32.dll", "GetCurrentThreadId", _is64);
			unsigned __int64 address_suspendthread = exports->find_export("kernel32.dll", "SuspendThread", _is64);

			if (_address_terminate == NULL || address_getthread == NULL || address_suspendthread == NULL || address_getthreadid == NULL)
			{
				if (_options->Verbose)
				{
					fprintf(stderr, "WARNING: Failed to find library exports used in hooking ZwTerminateProcess. PID: 0x%x, 64bit mode: %i\r\n", _pid, (int)_is64);
					fprintf(stderr, "WARNING: ntdll.dll::NtTerminateProcess = 0x%llX\r\n", _address_terminate);
					fprintf(stderr, "WARNING: kernel32.dll::GetCurrentThreadId = 0x%llX\r\n", address_getthreadid);
					fprintf(stderr, "WARNING: kernel32.dll::GetCurrentThread = 0x%llX\r\n", address_getthread);
					fprintf(stderr, "WARNING: kernel32.dll::SuspendThread = 0x%llX\r\n", address_suspendthread);
				}
			}
			else
			{
				// Found the addresses for our hook code

				// Modify the NtTerminateProcess region to add WRITE privileges
				//VirtualQueryEx( _ph, _address_terminate, )
				DWORD old_protection = 0;
				bool changed = VirtualProtectEx(_ph, (LPVOID) _address_terminate, 0x1000, PAGE_EXECUTE_READWRITE, &old_protection);

				if (changed)
				{
					// Read the original code
					SIZE_T num_read = 0;
					bool success = ReadProcessMemory(_ph, (LPCVOID)(_address_terminate), (void*)(_original_hook_bytes), sizeof(_original_hook_bytes), &num_read);

					if (num_read == sizeof(_original_hook_bytes) && success)
					{
						unsigned char* hook_code = NULL;
						int hook_code_length = 0;

						if (!_is64)
						{
							// Windows 10, wow64 version of ZwTerminateProcess
							// ntdll.dll -> ZwTerminateProcess()
							// B8 29 00 00 00          mov     eax, 29h; NtTerminateProcess
							// 33 C9                   xor     ecx, ecx
							// 8D 54 24 04             lea     edx, [esp + arg_0]
							// 64 FF 15 C0 00 00 00    call    large dword ptr fs : 0C0h
							// 83 C4 04                add     esp, 4
							// C2 08 00                retn    8

							// ------ Hook (x86/x64 independent code) -------
							//	is_waiting: (00)
							//		dq 0
							//	thread_id: (08)
							//		dq 0
							//	GetCurrentThread: (10)
							//		dq 0
							//	GetCurrentThreadId: (18)
							//		dq 0
							//	SuspendThread: (20)
							//		dq 0
							//	TerminateProcess: (28)
							//		dq 0
							//  _hook_original_code_length: (30)
							//		dq 0
							//	_hook_original_code: (38)
							//		dq 0
							//		dq 0
							//		dq 0
							//		dq 0
							//	hook:
							//		push ebx
							//		push ecx
							//		push esi
							//		push edi
							//		
							//		call 0
							//		pop ebx
							//		sub ebx, 0x5d  // 5 + 0x58 = 0x5d
							//
							//		push eax
							//		mov eax, [ebx+0x10] // GetCurrentThreadId
							//		call eax
							//		mov [ebx+0x08], eax // thread_id
							//		mov [ebx], 1	// is_waiting
							//		push eax
							//		mov eax, [ebx+0x18] // SuspendThread
							//		call eax
							//
							//		mov ecx, [ebx+0x28] // _hook_original_code_length
							//		mov esi, ebx
							//		add esi, 0x30 // _hook_original_code
							//		mov edi, [ebx+0x20] // TerminateProcess
							//		rep movsb
							//		
							//		mov eax, [ebx+0x20] // TerminateProcess
							//      pop edi
							//      pop esi
							//      pop ecx
							//      pop ebx
							//
							//		jmp eax

							unsigned char code[] = {
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <is_waiting>
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <thread_id>
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <GetCurrentThreadId>
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <GetCurrentThread>
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <SuspendThread>
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <TerminateProcess>
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // <_hook_original_code_length>
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <_hook_original_code>
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <_hook_original_code> + 8
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <_hook_original_code> + 16
								0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <_hook_original_code> + 24


								//		push ebx
								//		push ecx
								//		push esi
								//		push edi
								0x53, 0x51, 0x56, 0x57,

								//		call 0
								//		pop ebx
								//		sub ebx, 0x61  // 5 + 4 + 0x58 = 0x61
								0xE8, 0x00, 0x00, 0x00, 0x00,
								0x5B,
								0x83, 0xEB, 0x61,

								//		mov eax, [ebx+0x10] // GetCurrentThreadId
								//		call eax
								//		mov [ebx+0x08], eax // thread_id
								0x8B, 0x43, 0x10,
								0xFF, 0xD0,
								0x89, 0x43, 0x08,
								
								//		mov eax, [ebx+0x18] // GetCurrentThread
								//		call eax
								0x8B, 0x43, 0x18,
								0xFF, 0xD0,

								//		mov [ebx], 1	// is_waiting
								//		push eax
								//		mov eax, [ebx+0x20] // SuspendThread
								//		call eax
								0xC7, 0x03,	0x01, 0x00, 0x00, 0x00,
								0x50,
								0x8B, 0x43, 0x20,
								0xFF, 0xD0,

								//		mov ecx, [ebx+0x30] // _hook_original_code_length
								//		mov esi, ebx
								//		add esi, 0x38 // _hook_original_code
								//		mov edi, [ebx+0x28] // TerminateProcess
								//		cld
								//		rep movsb [edi], [esi]
								0x8B, 0x4B, 0x30,
								0x89, 0xDE,
								0x83, 0xC6, 0x38,
								0x8B, 0x7B, 0x28,
								0xFC,
								0xF3, 0xA4,

								//		mov eax, [ebx+0x28] // TerminateProcess
								0x8B, 0x43, 0x28,

								//      pop edi
								//      pop esi
								//      pop ecx
								//      pop ebx
								0x5F, 0x5E, 0x59, 0x5B,

								//0xCC,

								//		jmp eax
								0xFF, 0xE0

							};

							// Fill out the variables in the code
							//	is_waiting: (00)
							//		dq 0
							//	thread_id: (08)
							//		dq 0
							//	GetCurrentThreadId: (10)
							//		dq 0
							//	SuspendThread: (18)
							//		dq 0
							//	TerminateProcess: (20)
							//		dq 0
							//  _hook_original_code_length: (28)
							//		dq 0
							//	_hook_original_code: (30)
							//		dq 0
							//		dq 0
							hook_code = new unsigned char[sizeof(code)];
							hook_code_length = sizeof(code);
							*((unsigned __int64*)(code + 0x10)) = address_getthreadid; // GetCurrentThreadId
							*((unsigned __int64*)(code + 0x18)) = address_getthread; // GetCurrentThread
							*((unsigned __int64*)(code + 0x20)) = address_suspendthread; // SuspendThread
							*((unsigned __int64*)(code + 0x28)) = _address_terminate; // <address_terminate>
							*((unsigned __int64*)(code + 0x30)) = 32; // _hook_original_code_length
							memcpy(code + 0x38, _original_hook_bytes, 32); // _hook_original_code

							// Copy to use this code as our hook code
							memcpy(hook_code, code, sizeof(code));
						}
						else
						{
							// total size should be 0x47 (compiled code) + 0x58 (variables) = 0x9f
							unsigned char code64[] = {
								/*  00  */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <is_waiting>
								/*  08  */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <thread_id>
								/*  10  */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <GetCurrentThreadId>
								/*  18  */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <GetCurrentThread>
								/*  20  */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <SuspendThread>
								/*  28  */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <TerminateProcess>
								/*  30  */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // <_hook_original_code_length>
								/*  38  */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <_hook_original_code>
								/*  40  */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <_hook_original_code> + 8
								/*  48  */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <_hook_original_code> + 16
								/*  50  */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // <_hook_original_code> + 24


								//		push rbx
								//		push rcx
								//		push rsi
								//		push rdi
								0x53, 0x51, 0x56, 0x57,

								//		call +0
								//		pop rbx
								//		sub rbx, 0x61  // 5 + 4 + 0x58 = 0x61
								0xE8, 0x00, 0x00, 0x00, 0x00,
								0x5B,
								0x48, 0x83, 0xEB, 0x61,

								//		mov rax, [rbx+0x10] // GetCurrentThreadId
								//		sub rsp, 0x20
								//		call rax
								//		add rsp, 0x20
								//		mov [rbx+0x08], rax // thread_id
								0x48, 0x8B, 0x43, 0x10,
								0x48, 0x83, 0xEC, 0x20,
								0xFF, 0xD0,
								0x48, 0x83, 0xC4, 0x20,
								0x48, 0x89, 0x43, 0x08,

								//		mov rax, [rbx+0x18] // GetCurrentThread
								//		sub rsp, 0x20
								//		call rax
								//		add rsp, 0x20
								0x48, 0x8B, 0x43, 0x18,
								0x48, 0x83, 0xEC, 0x20,
								0xFF, 0xD0,
								0x48, 0x83, 0xC4, 0x20,

								//		mov QWORD [rbx], 1	// is_waiting
								// 4889C1  mov rcx, rax		; threadid
								//		mov rax, [rbx+0x20] // SuspendThread
								//      sub rsp, 0x20
								//		call rax
								//		add rsp, 0x20
								0x48, 0xC7, 0x03, 0x01, 0x00, 0x00, 0x00,
								0x48, 0x89, 0xC1,
								0x48, 0x8B, 0x43, 0x20,
								0x48, 0x83, 0xEC, 0x20,
								0xFF, 0xD0,
								0x48, 0x83, 0xC4, 0x20,

								//		mov rcx, [rbx+0x30] // _hook_original_code_length
								//		mov rsi, rbx
								//		add rsi, 0x38 // _hook_original_code
								//		mov rdi, [rbx+0x28] // TerminateProcess
								//		cld
								//		rep movsb [rdi], [rsi]
								0x48, 0x8B, 0x4B, 0x30,
								0x48, 0x89, 0xDE,
								0x48, 0x83, 0xC6, 0x38,
								0x48, 0x8B, 0x7B, 0x28,
								0xFC,
								0xF3, 0xA4,

								//		mov rax, [rbx+0x28] // TerminateProcess
								0x48, 0x8B, 0x43, 0x28,

								//      pop rdi
								//      pop rsi
								//      pop rcx
								//      pop rbx
								0x5F, 0x5E, 0x59, 0x5B,

								//0xCC,

								//		jmp rax
								0xFF, 0xE0

							};

							// Fill out the variables in the code
							//	is_waiting: (00)
							//		dq 0
							//	thread_id: (08)
							//		dq 0
							//	GetCurrentThreadId: (10)
							//		dq 0
							//	SuspendThread: (18)
							//		dq 0
							//	TerminateProcess: (20)
							//		dq 0
							//  _hook_original_code_length: (28)
							//		dq 0
							//	_hook_original_code: (30)
							//		dq 0
							//		dq 0
							hook_code = new unsigned char[sizeof(code64)];
							hook_code_length = sizeof(code64);
							*((unsigned __int64*)(code64 + 0x10)) = address_getthreadid; // GetCurrentThreadId
							*((unsigned __int64*)(code64 + 0x18)) = address_getthread; // GetCurrentThread
							*((unsigned __int64*)(code64 + 0x20)) = address_suspendthread; // SuspendThread
							*((unsigned __int64*)(code64 + 0x28)) = _address_terminate; // <address_terminate>
							*((unsigned __int64*)(code64 + 0x30)) = 32; // _hook_original_code_length
							memcpy(code64 + 0x38, _original_hook_bytes, 32); // _hook_original_code (_original_hook_bytes is not our hook!)

							// Copy to use this code as our hook code
							memcpy(hook_code, code64, sizeof(code64));
						}

						// Inject the hook code
						SIZE_T num_written = 0;
						bool success = WriteProcessMemory(_ph, (LPVOID)_hook_address, hook_code, hook_code_length, &num_written);
						if (hook_code != NULL)
							delete[]hook_code;

						if (success && num_written == hook_code_length)
						{
							// Set the variable addresses in the remote process
							_address_is_waiting = _hook_address;
							_address_thread_id = _hook_address + 8;

							// Redirect ZwTerminateProcess
							return add_redirect(_hook_address + 0x58);
						}
						else
						{
							PrintLastError(L"Failed to write NtTerminateProcess hook code.");
						}
					}
				}
			}
		}
		else
		{
			if( _options->Verbose )
				PrintLastError(L"Failed to allocate space for NtTerminateProcess hook.");
		}

		return false; // Failed to hook
	}
	return true; // Already hooked
}

bool terminate_monitor_hook::is_terminate_waiting()
{
	if (_hook_address != NULL && _address_is_waiting != NULL )
	{
		unsigned __int64 value = 0;
		SIZE_T num_read = 0;
		bool success = ReadProcessMemory(_ph, (LPCVOID) _address_is_waiting, &value, sizeof(value), &num_read);
		if (success && num_read == sizeof(value))
		{
			return value == 1;
		}
	}
	return false;
}

void terminate_monitor_hook::resume_terminate()
{
	if (is_terminate_waiting() && _address_thread_id != NULL)
	{
		DWORD tid = 0;
		if ( read_memory(_ph, _address_thread_id, &tid) && tid != 0 )
		{
			// Set it's state to no longer waiting to terminate
			write_memory(_ph, _address_is_waiting, (unsigned __int64)0);

			// Resume this thread in the target process
			HANDLE th = OpenThread(THREAD_SUSPEND_RESUME, false, tid);
			DWORD result = ResumeThread(th);

			_process_is_terminating = true;
		}
	}
}

terminate_monitor_hook::terminate_monitor_hook(HANDLE ph, DWORD pid, bool is64, PD_OPTIONS* options)
{
	_ph = ph;
	_pid = pid;
	_is64 = is64;
	_hook_address = NULL;
	_address_is_waiting = NULL;
	_address_thread_id = NULL;
	_address_terminate = NULL;
	_process_is_terminating = false;
	_options = options;
}


terminate_monitor_hook::~terminate_monitor_hook()
{
	// Remove our redirect from this process if it is in place
	unhock_terminate();
}

```

`pd/terminate_monitor_hook.h`:

```h
#pragma once

#include "windows.h"
#include "simple.h"
#include "export_list.h"
#include "utils.h"

class terminate_monitor_hook
{
	HANDLE _ph;
	DWORD _pid;
	bool _is64;
	unsigned __int64 _hook_address;
	unsigned __int64 _address_terminate;
	unsigned __int64 _address_is_waiting;
	unsigned __int64 _address_thread_id;
	unsigned char _original_hook_bytes[32];
	bool _process_is_terminating;
	PD_OPTIONS* _options;

	bool add_redirect(unsigned __int64 target_address);
	
	unsigned __int64 get_address(char* library, char* procedure_name);
	bool get_terminate_orig_code(unsigned char* out_buffer, int length);

public:
	bool hook_terminate(export_list* exports);
	bool unhock_terminate();

	bool is_terminate_waiting();
	void resume_terminate();

	terminate_monitor_hook(HANDLE ph, DWORD pid, bool is64, PD_OPTIONS* _options);
	~terminate_monitor_hook();
};


```

`pd/utils.h`:

```h
#pragma once

static bool test_read( unsigned char* buffer, SIZE_T length, unsigned char* read_ptr, SIZE_T read_length )
{
	return read_ptr >= buffer && read_ptr + read_length <= buffer + length;
};


static bool write_memory(HANDLE ph, unsigned __int64 address, unsigned __int64 value)
{
	SIZE_T num_written = 0;
	return WriteProcessMemory(ph, (LPVOID) address, &value, sizeof(value), &num_written) && num_written == sizeof(value);
};

static bool write_memory(HANDLE ph, unsigned __int64 address, unsigned __int32 value)
{
	SIZE_T num_written = 0;
	return WriteProcessMemory(ph, (LPVOID)address, &value, sizeof(value), &num_written) && num_written == sizeof(value);
};

static bool read_memory(HANDLE ph, unsigned __int64 address, unsigned __int64* value)
{
	SIZE_T num_read = 0;
	return ReadProcessMemory(ph, (LPVOID)address, value, sizeof(*value), &num_read) && num_read == sizeof(*value);
};

static bool read_memory(HANDLE ph, unsigned __int64 address, unsigned __int32* value)
{
	SIZE_T num_read = 0;
	return ReadProcessMemory(ph, (LPVOID)address, value, sizeof(*value), &num_read) && num_read == sizeof(*value);
};

static bool read_memory(HANDLE ph, unsigned __int64 address, void** value)
{
	SIZE_T num_read = 0;
	return ReadProcessMemory(ph, (LPVOID)address, value, sizeof(*value), &num_read) && num_read == sizeof(*value);
};

static bool read_memory(HANDLE ph, unsigned __int64 address, DWORD* value)
{
	SIZE_T num_read = 0;
	return ReadProcessMemory(ph, (LPVOID)address, value, sizeof(*value), &num_read) && num_read == sizeof(*value);
};
```

`pd/work_queue.h`:

```h
//
// Copyright (c) 2013 Juan Palacios juan.palacios.puyana@gmail.com
// Subject to the BSD 2-Clause License
// - see < http://opensource.org/licenses/BSD-2-Clause>

/*
Copyright (c) 2013, Juan Palacios <juan.palacios.puyana@gmail.com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met: 

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer. 
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#pragma once

#ifndef CONCURRENT_QUEUE_
#define CONCURRENT_QUEUE_

#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>

template <typename T>
class Queue
{
 public:

  T pop() 
  {
    std::unique_lock<std::mutex> mlock(mutex_);
    while (queue_.empty())
    {
      cond_.wait(mlock);
    }
    auto val = queue_.front();
    queue_.pop();
    return val;
  }

  bool pop(T& item)
  {
    std::unique_lock<std::mutex> mlock(mutex_);
	if (queue_.empty())
		return false;

    item = queue_.front();
    queue_.pop();
	return true;
  }

  bool empty()
  {
	  std::unique_lock<std::mutex> mlock(mutex_);
	  bool is_empty = queue_.empty();
	  mlock.unlock();
	  return is_empty;
  }

  int count()
  {
	  std::unique_lock<std::mutex> mlock(mutex_);
	  int count = queue_.size();
	  mlock.unlock();
	  return count;
  }

  void push(const T& item)
  {
    std::unique_lock<std::mutex> mlock(mutex_);
    queue_.push(item);
    mlock.unlock();
    cond_.notify_one();
  }
  Queue()=default;
  Queue(const Queue&) = delete;            // disable copying
  Queue& operator=(const Queue&) = delete; // disable assignment
  
 private:
  std::queue<T> queue_;
  std::mutex mutex_;
  std::condition_variable cond_;
};

#endif
```