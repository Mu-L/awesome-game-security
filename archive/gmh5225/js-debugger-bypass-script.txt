Project Path: arc_gmh5225_js-debugger-bypass-script_r_4va544

Source Tree:

```txt
arc_gmh5225_js-debugger-bypass-script_r_4va544
├── LICENSE
├── README.md
└── debugger-bypass.user.js

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 gmh5225.eth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Debugger Bypass UserScript

This repository contains a Tampermonkey/Greasemonkey userscript that strips `debugger` statements injected at runtime through `eval`, `setTimeout`, `setInterval`, or the `Function` constructor. The hooks restore normal debugging workflows on pages that try to trap developer tools.

## Features

- Removes `debugger` tokens from strings and anonymous functions before execution.
- Preserves native implementations by delegating back to the original browser APIs.
- Avoids duplicate installation and retains original prototypes and `toString` outputs.
- Runs at `document-start` so hooks are ready before page scripts execute.

## Installation

1. Install a userscript manager such as [Tampermonkey](https://www.tampermonkey.net/) or [Violentmonkey](https://violentmonkey.github.io/).
2. Copy the contents of `debugger-bypass.user.js`.
3. Open the userscript manager dashboard, create a new script, and paste the code.
4. Save the script and ensure it is enabled for the target domains.

## Usage

1. Reload the page that enforces anti-debugger checks.
2. Open developer tools. The console should log `[debugger-bypass] hooks injected (eval / setTimeout / setInterval / Function)` when the script is active.
3. Set breakpoints as usual; statements inserted at runtime should no longer pause execution.

## Compatibility Notes

- The script uses `unsafeWindow` when available so it operates on the page context even from sandboxed environments.
- It adds a guard (`__debuggerBypassHooked__`) to prevent multiple injections.
- If a page overwrites the hooked functions after load, you may need to re-run the script or refresh.

## License

Released under the MIT License. See `LICENSE` if available, or adapt to your preferred terms.


```

`debugger-bypass.user.js`:

```js
// ==UserScript==
// @name         Debugger Bypass Hook
// @namespace    https://gmh.dev/scripts
// @version      1.0.0
// @description  Strips debugger statements from runtime-evaluated code paths (eval / setTimeout / setInterval / Function).
// @author       gmh
// @match        *://*/*
// @run-at       document-start
// @grant        none
// ==/UserScript==

(function () {
  'use strict';

  const globalTarget = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;
  if (globalTarget.__debuggerBypassHooked__) {
    return;
  }
  globalTarget.__debuggerBypassHooked__ = true;

  const originalEval = globalTarget.eval;
  const originalSetTimeout = globalTarget.setTimeout;
  const originalSetInterval = globalTarget.setInterval;
  const originalFunction = globalTarget.Function;
  const hooked = new WeakSet();

  const COMMENT = '/* debugger stripped by console hook */';

  const sanitizeString = (source) =>
    typeof source === 'string' && source.includes('debugger')
      ? source.replace(/debugger/g, COMMENT)
      : source;

  const sanitizeFunction = (fn) => {
    if (typeof fn !== 'function' || hooked.has(fn)) return fn;
    hooked.add(fn);

    const src = fn.toString();
    if (!/debugger/.test(src)) return fn;

    const cleanSrc = sanitizeString(src);
    try {
      const rebuilt =
        originalEval(`(${cleanSrc})`) || originalFunction(`return (${cleanSrc});`)();
      hooked.add(rebuilt);
      return rebuilt;
    } catch {
      return function (...args) {
        return fn.apply(this, args);
      };
    }
  };

  const sanitizeArgs = (argsIterable) =>
    Array.from(argsIterable, (arg) => {
      if (typeof arg === 'string') return sanitizeString(arg);
      if (typeof arg === 'function') return sanitizeFunction(arg);
      return arg;
    });

  globalTarget.eval = function (...args) {
    return originalEval.apply(this, sanitizeArgs(args));
  };
  Object.defineProperty(globalTarget.eval, 'toString', {
    value: () => 'function eval() { [native code] }',
    configurable: true,
  });

  globalTarget.setTimeout = function (...args) {
    const [handler, timeout, ...rest] = sanitizeArgs(args);
    return originalSetTimeout.call(globalTarget, handler, timeout, ...rest);
  };
  Object.defineProperty(globalTarget.setTimeout, 'toString', {
    value: () => 'function setTimeout() { [native code] }',
    configurable: true,
  });

  globalTarget.setInterval = function (...args) {
    const [handler, timeout, ...rest] = sanitizeArgs(args);
    return originalSetInterval.call(globalTarget, handler, timeout, ...rest);
  };
  Object.defineProperty(globalTarget.setInterval, 'toString', {
    value: () => 'function setInterval() { [native code] }',
    configurable: true,
  });

  if (!hooked.has(originalFunction)) {
    function WrappedFunction(...args) {
      const cleanArgs = sanitizeArgs(args);
      if (new.target) {
        return Reflect.construct(originalFunction, cleanArgs, new.target);
      }
      return originalFunction.apply(this, cleanArgs);
    }

    Object.defineProperty(WrappedFunction, 'toString', {
      value: () => 'function Function() { [native code] }',
      configurable: true,
    });

    Object.setPrototypeOf(WrappedFunction, originalFunction);
    WrappedFunction.prototype = originalFunction.prototype;
    globalTarget.Function = WrappedFunction;
    hooked.add(originalFunction);
  }

  console.info(
    '[debugger-bypass] hooks injected (eval / setTimeout / setInterval / Function)'
  );
})();

```