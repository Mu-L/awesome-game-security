Project Path: arc_gmh5225_idawilli_aauhpc80

Source Tree:

```txt
arc_gmh5225_idawilli_aauhpc80
├── LICENSE
├── README.md
├── doc
│   └── idapython.rst
├── idawilli
│   ├── __init__.py
│   ├── dbg
│   │   └── __init__.py
│   └── lex_curline.py
├── plugins
│   ├── colors.py
│   ├── dynamic_hints
│   │   ├── dynamic_hints.py
│   │   └── readme.md
│   ├── hint_calls
│   │   ├── hint_calls.py
│   │   └── readme.md
│   └── tag_func.py
├── scripts
│   ├── add_segment
│   │   ├── add_segment.py
│   │   └── readme.md
│   ├── allocate_rwx_page.py
│   ├── color
│   │   └── color.py
│   ├── deob.py
│   ├── find_ptrs
│   │   ├── ida_find_ptrs.py
│   │   └── readme.md
│   ├── fix_ptr_ops
│   │   └── fix_ptr_operands.py
│   ├── go
│   │   ├── go_fixup_fptrs.py
│   │   ├── go_fixup_global_strings.py
│   │   └── go_fixup_inline_strings.py
│   ├── goto_file_offset.py
│   ├── goto_rva.py
│   ├── load_file_rwx.py
│   ├── load_map_file.py
│   ├── parse_uuid.py
│   ├── resolve_ptrs.py
│   ├── save_segment.py
│   ├── windb_symbols
│   │   └── apply_windbg_symbols.py
│   ├── write_file.py
│   └── yara_fn
│       ├── readme.md
│       └── yara_fn.py
├── setup.py
├── tests
│   ├── readme.md
│   └── test_all.py
└── themes
    ├── colors
    │   ├── adwaita-dark
    │   │   ├── adwaita-dark.clr
    │   │   ├── readme.md
    │   │   └── screenshot.png
    │   ├── readme.md
    │   └── willi
    │       ├── theme.css
    │       └── user.css
    └── skins
        ├── adwaita-dark
        │   ├── icons
        │   │   ├── expand.png
        │   │   └── spacer.png
        │   ├── manifest.xml
        │   ├── preview.png
        │   ├── readme.md
        │   └── stylesheet.qss
        ├── readme.md
        └── vscode-dark-wb
            ├── adwaita-dark.clr
            ├── icons
            │   ├── blank.png
            │   ├── close.png
            │   ├── drag.png
            │   ├── expand.png
            │   ├── float.png
            │   ├── fullscreen.png
            │   └── menu.png
            ├── manifest.json
            ├── preview.png
            ├── stylesheet.less
            ├── stylesheet.qss
            └── vscode-dark.clr

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# idawilli
IDA Pro configurations, scripts, and utilities


## components

### idawilli

a python module that contains utilities for working with the idapython scripting interface.


### plugins

ida pro plugins that you can install to your `%IDADIR%/plugins/` directory.
these typically provide some long-running functionality, such as interface hints.

### scripts

standalone ida pro scripts that can be run without installation.
these typically collect, format, and display some data.
usually these are not long-running.

### tests

unit tests that demonstrate that idawilli actually works as advertised.

### themes

ida pro configuration files that style the user interface.

```

`doc/idapython.rst`:

```rst
segments
--------

enumerate segments::

    Segment = namedtuple('Segment', ['start', 'end', 'name'])
    def enum_segments():
        for segstart in idautils.Segments():
            segend = idc.SegEnd(segstart)
            segname = idc.SegName(segstart)             
            yield Segment(segstart, segend, segname)

heads
-----

a `head` is a defined item in an idb.
for example, a defined byte, dword, instruction, etc. 

enumerate heads::

    for segment in enum_segments():
        for head in idautils.Heads(segment.start, segment.end):
            print(hex(head))

note that just because there is a byte value at an address does not mean there is a head there.
use ``idc.isHead(idc.getFlags(address))`` to test head-ness. for example, consider the following::

    0000 seg000		segment	byte public 'CODE' use32
    0000    assume cs:seg000
    0000    assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
    0000    db    ?	;  NOT HEAD
    0001    db    ?	;  NOT HEAD
    0002    db    ?	;  NOT HEAD
    0003    db  90h	;  NOT HEAD
    0004    dw 9090h;  HEAD
    0006    db 90h  ;  HEAD
    0007 ; ---------------------------------------------------------------------------
    0007    nop     ;  HEAD
    0007 ; ---------------------------------------------------------------------------

although there is a byte at address 0003, it has not been defined like the byte at 0006.

names and comments can be set an any address, not just heads. 
so in the above example, the byte at address 0003 may have a name and comment, but not be considered a head.
however, when fetching comments you need to be a bit careful: heads may span multiple bytes, and fetching comments from any address within the head fetches the head's comments.
given the above example, the following is true::

    idc.MakeComm(0x4, 'a comment')
    assert idc.Comm(0x4) == 'a comment'
    assert idc.Comm(0x5) == 'a comment'


text encoding
-------------

on different systems, IDA may use different codepages.
all IDAPython APIs accept and return the python type ``str`` for strings, and they do not accept the ``unicode`` type.

for compatibility across users, you should explicitly encode and decode to/from ASCII::

    idc.MakeName(0x0, u'foobar'.encode('ascii', errors='replace'))
    idc.Name(0x0).decode('ascii', errors='replace')


commenting
----------

create local comment::

    if not idc.MakeComm(va, ctext):
        logger.warning('failed to create local comment: 0x%x', va)

delete local comment::

    if not idc.MakeComm(va, ''):
        logger.warning('failed to delete local comment: 0x%x', va)

create repeatable comment::

    if not idc.MakeRptCmt(va, ctext):
        logger.warning('failed to create repeatable comment: 0x%x', va)
        
delete repeatable comment::

    if not idc.MakeRptCmt(va, ''):
        logger.warning('failed to delete repeatable comment: 0x%x', va)
        
create anterior comment::

    for i, line in enumerate(ctext.split('\n')):
        if not idc.ExtLinA(va, i, line):
            logger.warning('failed to create anterior line comment: 0x%x %d', va, i)
            
delete anterior comment::

    # deleting line 0 deletes all the rest, too
    if not idc.DelExtLnA(va, 0):
        logger.warning('failed to delete anterior comment: 0x%x', va)

create posterior comment::

    for i, line in enumerate(ctext.split('\n')):
        if not idc.ExtLinB(va, i, line):
            logger.warning('failed to create posterior line comment: 0x%x %d', va, i)

delete posterior comment::

    if not idc.DelExtLnB(va, 0):
        logger.warning('failed to delete anterior comment: 0x%x', va)
        
create function comment::

    if not idc.SetFunctionCmt(va, ctext, False):
        logger.warning('failed to create function local comment: 0x%x', va)

delete function comment::

    if not idc.SetFunctionCmt(va, '', False):
        logger.warning('failed to delete function local comment: 0x%x', va)
        
create repeatable function comment::

    if not idc.SetFunctionCmt(va, ctext, True):
        logger.warning('failed to create function repeatable comment: 0x%x', va)
        
delete repeatable function comment::

    if not idc.SetFunctionCmt(va, '', True):
        logger.warning('failed to delete function repeatablecomment: 0x%x', va)


types
--------------------------

inspect function prototype::

    tup = idaapi.get_named_type(None, 'CreateServiceA', idaapi.NTF_SYMM)
    if tup is not None:
        code, type_str, fields_str, cmt, field_cmts, sclass, value  = tup
        t1 = idaapi.tinfo_t()
        t1.deserialize(None, type_str, fields_str, cmt)
        print('Number of args: %d' % t1.get_nargs())
        print('Type of arg 0: %s' %t1.get_nth_arg(0)._print())
        print('Size of arg 0: %d' % t1.get_nth_arg(0).get_size())








```

`idawilli/__init__.py`:

```py
def align(value, alignment=0x1000):
    if value % alignment == 0:
        return value
    return value + (alignment - (value % alignment))
```

`idawilli/dbg/__init__.py`:

```py
import idc
import idaapi
import ida_idd
import ida_name
import ida_bytes
import ida_kernwin
import ida_dbg

# import types for the given macros
idaapi.import_type(idaapi.cvar.idati, 0, "MACRO_NULL")  # for NULL
idaapi.import_type(idaapi.cvar.idati, 0, "MACRO_PAGE")  # for PAGE_EXECUTE_READWRITE
idaapi.import_type(idaapi.cvar.idati, 0, "MACRO_MEM")   # for MEM_COMMIT

# shortcut to constants
c = ida_idd.Appcall.Consts


def allocate_rwx(size):
    # this is the explicit way to create an Appcall callable
    # see also: `Appcall.proto`
    VirtualAlloc = ida_idd.Appcall.typedobj("int __stdcall VirtualAlloc( int lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect);")
    VirtualAlloc.ea = ida_name.get_name_ea(0, "kernel32_VirtualAlloc")
    ptr = VirtualAlloc(c.NULL, int(size), c.MEM_COMMIT, c.PAGE_EXECUTE_READWRITE)
    if ptr == 0:
        print("VirtualAlloc failed: 0x%x" % GetLastError())
        raise ValueError("VirtualAlloc failed: 0x%x" % GetLastError())
    ida_dbg.refresh_debugger_memory()
    return ptr
    
    
def GetLastError():
    # this is the concise way to create an Appcall callable.
    # symbol name as found in the workspace and function prototype.
    return ida_idd.Appcall.proto("kernel32_GetLastError", "DWORD __stdcall GetLastError();")()
    
    
LoadLibraryA = ida_idd.Appcall.proto("kernel32_LoadLibraryA", "HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);")
GetProcAddress = ida_idd.Appcall.proto("kernel32_GetProcAddress", "FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);")


def get_winapi_decl(name):
    '''
    fetch the C function declaration for the given Windows API function.
    '''
    tup = idaapi.get_named_type(None, name, idaapi.NTF_SYMM)
    if tup is None:
        raise ValueError("failed to fetch type")
    code, type_str, fields_str, cmt, field_cmts, sclass, value = tup
    ti = idaapi.tinfo_t()
    ti.deserialize(None, type_str, fields_str, cmt)

    # the rendered declaration from IDA doesn't include the function name,
    # so insert the function name, naively.
    #
    # for example;
    #
    #    > DWORD (DWORD a, DWORD b)
    #    < DWORD foo(DWORD a, DWORD b);
    decl = str(ti).replace("(", " " + name + "(") + ";"

    return decl


def api(dll, proc):
    '''
    get a callable Windows API function.

    Python>idaapi.require("idawilli.dbg")
    Python>idawilli.dbg.api("kernel32.dll", "SetLastError")(0x31337)
    0x0L
    Python>idawilli.dbg.api("kernel32.dll", "GetLastError")()
    0x31337L
    '''
    hmod = LoadLibraryA(dll)
    pfunc = GetProcAddress(hmod, proc)
    decl = get_winapi_decl(proc)
    return ida_idd.Appcall.proto(pfunc.value, decl)


class _Module(object):
    ''' loaded DLL that supports calling procedures via Appcall '''

    def __init__(self, dll):
        super(_Module, self).__init__()
        self.dll = dll if dll.lower().endswith('.dll') else (dll + '.dll')
        self.hmod = LoadLibraryA(dll).value

    def __getattr__(self, proc):
        if proc == 'dll':
            return super(self, _Module).__getattr__(proc)
        elif proc == 'hmod':
            return super(self, _Module).__getattr__(proc)

        pfunc = GetProcAddress(self.hmod, proc).value
        return ida_idd.Appcall.proto(pfunc, get_winapi_decl(proc))


class _API(object):
    ''' fake object that creates a _Module on demand '''

    def __getattr__(self, dll):
        return _Module(dll)


'''
Python>idaapi.require("idawilli.dbg")
Python>idawilli.dbg.winapi.kernel32.SetLastError(0x31337)
0x0L
Python>idawilli.dbg.winapi.kernel32.GetLastError()
0x31337L
'''
winapi = _API()


def patch_bytes(ea, buf):
    for i, b in enumerate(buf):
        ida_bytes.patch_byte(ea + i, b)

```

`idawilli/lex_curline.py`:

```py
'''
split the line returned by `get_custom_viewer_curline` into symbols.
it pulls out the strings, color directives, and escaped characters.
this hex-rays blog post describes how ida uses the special color tags
to describe syntax highlighting:

    http://www.hexblog.com/?p=119

for example, here's a line that we see in IDA Pro:

    10056303 008 6A 52                   push    52h

and when we fetch it via `get_custom_viewer_curline`, this is what we get:

    00000000: 01 13 31 30 30 35 36 33  30 33 02 13 20 01 0C 30  ..10056303.. ..0
    00000010: 30 38 20 02 0C 01 14 36  41 20 35 32 20 02 14 20  08 ....6A 52 .. 
    00000020: 20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20                  
    00000030: 20 01 05 70 75 73 68 02  05 20 20 20 20 01 29 01   ..push..    .).
    00000040: 0C 35 32 68 02 0C 02 29                           .52h...)

note that at offset 0x0 are the bytes | 01 13 |, which is not ascii text.
instead, this indicate "start syntax highlighting using the COLOR_PREFIX theme".
this lexer decodes these bytes into an object you can inspect:

    > for s in lex(curline):
    >     print(str(s))

    < COLORON=COLOR_PREFIX
    < "10056303"
    < COLOROFF=COLOR_PREFIX
    < ...

when building a formatter that processes these symbols, inspect
each object's `.type` property to figure out what it is. then you
can fetch other relevant fields, such as `.color` for `ColorOnSymbol`.
'''
import idaapi


# inverse mapping of color value to name.
# ref: https://www.hex-rays.com/products/ida/support/sdkdoc/group___s_c_o_l_o_r__.html#ga6052470f86411b8b5ffdf4af4bbee225
INV_COLORS = {
    0x1: 'COLOR_DEFAULT',  #= 0x01,         // Default
    0x2: 'COLOR_REGCMT',   #= 0x02,         // Regular comment
    0x3: 'COLOR_RPTCMT',   #= 0x03,         // Repeatable comment (comment defined somewhere else)
    0x4: 'COLOR_AUTOCMT',  #= 0x04,         // Automatic comment
    0x5: 'COLOR_INSN',     #= 0x05,         // Instruction
    0x6: 'COLOR_DATNAME',  #= 0x06,         // Dummy Data Name
    0x7: 'COLOR_DNAME',    #= 0x07,         // Regular Data Name
    0x8: 'COLOR_DEMNAME',  #= 0x08,         // Demangled Name
    0x9: 'COLOR_SYMBOL',   #= 0x09,         // Punctuation
    0xa: 'COLOR_CHAR',     #= 0x0A,         // Char constant in instruction
    0xb: 'COLOR_STRING',   #= 0x0B,         // String constant in instruction
    0xc: 'COLOR_NUMBER',   #= 0x0C,         // Numeric constant in instruction
    0xd: 'COLOR_VOIDOP',   #= 0x0D,         // Void operand
    0xe: 'COLOR_CREF',     #= 0x0E,         // Code reference
    0xf: 'COLOR_DREF',     #= 0x0F,         // Data reference
    0x10: 'COLOR_CREFTAIL', #= 0x10,         // Code reference to tail byte
    0x11: 'COLOR_DREFTAIL', #= 0x11,         // Data reference to tail byte
    0x12: 'COLOR_ERROR',    #= 0x12,         // Error or problem
    0x13: 'COLOR_PREFIX',   #= 0x13,         // Line prefix
    0x14: 'COLOR_BINPREF',  #= 0x14,         // Binary line prefix bytes
    0x15: 'COLOR_EXTRA',    #= 0x15,         // Extra line
    0x16: 'COLOR_ALTOP',    #= 0x16,         // Alternative operand
    0x17: 'COLOR_HIDNAME',  #= 0x17,         // Hidden name
    0x18: 'COLOR_LIBNAME',  #= 0x18,         // Library function name
    0x19: 'COLOR_LOCNAME',  #= 0x19,         // Local variable name
    0x1A: 'COLOR_CODNAME',  #= 0x1A,         // Dummy code name
    0x1B: 'COLOR_ASMDIR',   #= 0x1B,         // Assembler directive
    0x1C: 'COLOR_MACRO',    #= 0x1C,         // Macro
    0x1D: 'COLOR_DSTR',     #= 0x1D,         // String constant in data directive
    0x1E: 'COLOR_DCHAR',    #= 0x1E,         // Char constant in data directive
    0x1F: 'COLOR_DNUM',     #= 0x1F,         // Numeric constant in data directive
    0x20: 'COLOR_KEYWORD',  #= 0x20,         // Keywords
    0x21: 'COLOR_REG',      #= 0x21,         // Register name
    0x22: 'COLOR_IMPNAME',  #= 0x22,         // Imported name
    0x23: 'COLOR_SEGNAME',  #= 0x23,         // Segment name
    0x24: 'COLOR_UNKNAME',  #= 0x24,         // Dummy unknown name
    0x25: 'COLOR_CNAME',    #= 0x25,         // Regular code name
    0x26: 'COLOR_UNAME',    #= 0x26,         // Regular unknown name
    0x27: 'COLOR_COLLAPSED',#= 0x27,         // Collapsed line

    #  // Fictive colors
    0x28: 'COLOR_ADDR',     #= 0x28, // hidden address marks
                            #        // The address is represented as 8digit
                            #        // hex number: 01234567
                            #        // It doesn't have COLOR_OFF pair
                            #        // NB: for 64-bit IDA, the address is 16digit

    0x29: 'COLOR_OPND1',    #= COLOR_ADDR+1, // Instruction operand 1
    0x2A: 'COLOR_OPND2',    #= COLOR_ADDR+2, // Instruction operand 2
    0x2B: 'COLOR_OPND3',    #= COLOR_ADDR+3, // Instruction operand 3
    0x2C: 'COLOR_OPND4',    #= COLOR_ADDR+4, // Instruction operand 4
    0x2D: 'COLOR_OPND5',    #= COLOR_ADDR+5, // Instruction operand 5
    0x2E: 'COLOR_OPND6',    #= COLOR_ADDR+6, // Instruction operand 6

    0x32: 'COLOR_UTF8',     #= COLOR_ADDR+10;// Following text is UTF-8 encoded
}


def get_color_name(color):
    return INV_COLORS[color]


class Symbol(object):
    def __init__(self, type):
        super(Symbol, self).__init__()
        self.type = type

    def __str__(self):
        raise NotImplementedError()


class StringSymbol(Symbol):
    def __init__(self, string):
        super(StringSymbol, self).__init__('string')
        self.string = string

    def __str__(self):
        return 'STRING=' + self.string


class ColorOnSymbol(Symbol):
    def __init__(self, color):
        super(ColorOnSymbol, self).__init__('coloron')
        self.color = ord(color)

    def __str__(self):
        return 'COLORON=' + get_color_name(self.color)


class ColorOffSymbol(Symbol):
    def __init__(self, color):
        super(ColorOffSymbol, self).__init__('coloroff')
        self.color = ord(color)

    def __str__(self):
        return 'COLOROFF=' + get_color_name(self.color)


class ColorInvSymbol(Symbol):
    def __init__(self):
        super(ColorInvSymbol, self).__init__('colorinv')

    def __str__(self):
        return 'COLORINV'


def lex(curline):
    '''
    split the line returned by `get_custom_viewer_curline` into symbols.
    it pulls out the strings, color directives, and escaped characters.

    Args:
      curline (str): a line returned by `idaapi.get_custom_viewer_curline`

    Returns:
      generator: generator of Symbol subclass instances
    '''

    offset = 0
    cur_word = []
    while offset < len(curline):

        c = curline[offset]

        if c == idaapi.COLOR_ON:
            if cur_word:
                yield StringSymbol(''.join(cur_word))
                cur_word = []

            offset += 1
            color = curline[offset]

            yield ColorOnSymbol(color)
            offset += 1

        elif c == idaapi.COLOR_OFF:
            if cur_word:
                yield StringSymbol(''.join(cur_word))
                cur_word = []

            offset += 1
            color = curline[offset]

            yield ColorOffSymbol(color)
            offset += 1

        elif c == idaapi.COLOR_ESC:
            if cur_word:
                yield StringSymbol(''.join(cur_word))
                cur_word = []

            offset += 1
            c = curline[offset]

            cur_word.append(c)
            offset += 1

        elif c == idaapi.COLOR_INV:
            if cur_word:
                yield StringSymbol(''.join(cur_word))
                cur_word = []

            yield ColorInvSymbol()
            offset += 1

        else:
            cur_word.append(c)
            offset += 1


```

`plugins/colors.py`:

```py
import ctypes
import functools

import idaapi
import ida_ua
import ida_funcs
import ida_frame
import ida_lines
import ida_idaapi


class ColorHooks(idaapi.IDP_Hooks):
    def ev_get_bg_color(self, color, ea):
        """
        Get item background color.
        Plugins can hook this callback to color disassembly lines dynamically

        ```c
        // background color in RGB
        typedef uint32 bgcolor_t;
        ```
        ref: https://hex-rays.com/products/ida/support/sdkdoc/pro_8h.html#a3df5040891132e50157aee66affdf1de

        args:
            color: (bgcolor_t *), out
            ea: (::ea_t)

        returns:
            retval 0: not implemented
            retval 1: color set
        """
        mnem = ida_ua.print_insn_mnem(ea)

        if mnem == "call":
            bgcolor = ctypes.cast(int(color), ctypes.POINTER(ctypes.c_int))
            bgcolor[0] = 0xDDDDDD
            return 1

        else:
            return 0

    def ev_out_mnem(self, ctx) -> int:
        """
        Generate instruction mnemonics.
        This callback should append the colored mnemonics to ctx.outbuf 
        Optional notification, if absent, out_mnem will be called.

        args:
            ctx: (outctx_t *)

        returns:
            retval 1: if appended the mnemonics
            retval 0: not implemented
        """
        mnem = ctx.insn.get_canon_mnem()
        if mnem == "call":
            # you can manipulate this, but note that it affects `ida_ua.print_insn_mnem` which is inconvenient for formatting.
            # also, you only have access to theme colors, like COLOR_PREFIX, not arbitrary control.
            ctx.out_custom_mnem("call")
            return 1

        else:
            return 0


def mainthread(function):
    """
    A function decorator to ensure the function executes on the main IDA thread.
    via: https://github.com/gaasedelen/lighthouse/blob/f4642e8b4b4347b11ccb25a79ec4f490c9ad901d/plugins/lighthouse/painting/ida_painter.py#L70
    """
    @functools.wraps(function)
    def wrapper(*args, **kwargs):
        ff = functools.partial(function, *args, **kwargs)
        return idaapi.execute_sync(ff, idaapi.MFF_NOWAIT | idaapi.MFF_WRITE)
    return wrapper


# the only way to install this is by instantiating an instance *from within a plugin*.
class CallPrefix(ida_lines.user_defined_prefix_t):
    def __init__(self):
        super().__init__(len(">>>"))

    def get_user_defined_prefix(self, ea, insn, lnnum, indent, line):
        mnem = insn.get_canon_mnem()

        if mnem == "call":
            return ">>>"

        #elif mnem == "push":
        #    return "-->"

        else:
            return "   "


class ColorsPlugin(ida_idaapi.plugin_t):
    flags = 0
    comment = "Colors"
    help = ""
    wanted_name = "Colors"
    wanted_hotkey = ""

    def __init__(self):
        self.prefix = None
        self.hooks = ColorHooks()

    def init(self):
        self.prefix = CallPrefix()
        self.hooks.hook()
        return ida_idaapi.PLUGIN_KEEP

    def run(self, arg):
        pass

    def term(self):
        self.prefix = None
        self.hooks.unhook()


def PLUGIN_ENTRY():
    return ColorsPlugin()

```

`plugins/dynamic_hints/dynamic_hints.py`:

```py
'''
example of:
  - providing custom UI hints with dynamic data from Python

in this silly example, we display UI hints with the current timestamp.
a more useful plugin might inspect the hovered line, and display some documentation.

Author: Willi Ballenthin <william.ballenthin@fireeye.com>
Licence: Apache 2.0
'''
import sys
import datetime

import idc
import idaapi
import idautils


class HintsHooks(idaapi.UI_Hooks):
    def get_custom_viewer_hint(self, view, place):
        curline = idaapi.get_custom_viewer_curline(view, True)
        _, x, y = idaapi.get_custom_viewer_place(view, True)
        ea = place.toea()

        return ('0x%08X: %s' % (place.toea(), datetime.datetime.now().isoformat(' ')), 1)

    def get_ea_hint(self, ea):
        return datetime.datetime.now().isoformat(' ')


class DynHints2Plugin(idaapi.plugin_t):
    flags = idaapi.PLUGIN_KEEP
    comment = "Display dynamically-generated hints (2)."

    help = "Display dynamically-generated hints (2)."
    wanted_name = "DynHints2"
    wanted_hotkey = "Ctrl-["


    def init(self):
        self.hooks = HintsHooks()
        return idaapi.PLUGIN_OK

    def run(self, arg):
        print('hints2: run')
        self.hooks.hook()

    def term(self):
        print('hints2: term')
        self.hooks.unhook()


def PLUGIN_ENTRY():
    return DynHints2Plugin()

```

`plugins/dynamic_hints/readme.md`:

```md
# dynamic_hints

an example plugin that demonstrates how to provide custom hints with dynamic data.

# installation

copy the python file to `%IDADIR%/plugins/`.

```

`plugins/hint_calls/hint_calls.py`:

```py
'''
IDA plugin to display the calls and strings referenced by a function as hints.

Installation: put this file in your %IDADIR%/plugins/ directory.
Author: Willi Ballenthin <william.ballenthin@fireeye.com>
Licence: Apache 2.0
'''
import logging

import idc
import idaapi
import idautils
import ida_xref
import ida_nalt
import ida_bytes
import ida_lines
import ida_kernwin
import re


logger = logging.getLogger(__name__)
DEFAULT_IMPORTANT_LINES_NUM = 5


###############################################################################
#### begin: idapython_lex_curline
# via: https://gist.github.com/williballenthin/466eb28679d30e212ffac57e4a9ceaa5
# note: inline here for simplicity


# inverse mapping of color value to name.
# ref: https://www.hex-rays.com/products/ida/support/sdkdoc/group___s_c_o_l_o_r__.html#ga6052470f86411b8b5ffdf4af4bbee225
INV_COLORS = {
    0x1: 'COLOR_DEFAULT',  #= 0x01,         // Default
    0x2: 'COLOR_REGCMT',   #= 0x02,         // Regular comment
    0x3: 'COLOR_RPTCMT',   #= 0x03,         // Repeatable comment (comment defined somewhere else)
    0x4: 'COLOR_AUTOCMT',  #= 0x04,         // Automatic comment
    0x5: 'COLOR_INSN',     #= 0x05,         // Instruction
    0x6: 'COLOR_DATNAME',  #= 0x06,         // Dummy Data Name
    0x7: 'COLOR_DNAME',    #= 0x07,         // Regular Data Name
    0x8: 'COLOR_DEMNAME',  #= 0x08,         // Demangled Name
    0x9: 'COLOR_SYMBOL',   #= 0x09,         // Punctuation
    0xa: 'COLOR_CHAR',     #= 0x0A,         // Char constant in instruction
    0xb: 'COLOR_STRING',   #= 0x0B,         // String constant in instruction
    0xc: 'COLOR_NUMBER',   #= 0x0C,         // Numeric constant in instruction
    0xd: 'COLOR_VOIDOP',   #= 0x0D,         // Void operand
    0xe: 'COLOR_CREF',     #= 0x0E,         // Code reference
    0xf: 'COLOR_DREF',     #= 0x0F,         // Data reference
    0x10: 'COLOR_CREFTAIL', #= 0x10,         // Code reference to tail byte
    0x11: 'COLOR_DREFTAIL', #= 0x11,         // Data reference to tail byte
    0x12: 'COLOR_ERROR',    #= 0x12,         // Error or problem
    0x13: 'COLOR_PREFIX',   #= 0x13,         // Line prefix
    0x14: 'COLOR_BINPREF',  #= 0x14,         // Binary line prefix bytes
    0x15: 'COLOR_EXTRA',    #= 0x15,         // Extra line
    0x16: 'COLOR_ALTOP',    #= 0x16,         // Alternative operand
    0x17: 'COLOR_HIDNAME',  #= 0x17,         // Hidden name
    0x18: 'COLOR_LIBNAME',  #= 0x18,         // Library function name
    0x19: 'COLOR_LOCNAME',  #= 0x19,         // Local variable name
    0x1A: 'COLOR_CODNAME',  #= 0x1A,         // Dummy code name
    0x1B: 'COLOR_ASMDIR',   #= 0x1B,         // Assembler directive
    0x1C: 'COLOR_MACRO',    #= 0x1C,         // Macro
    0x1D: 'COLOR_DSTR',     #= 0x1D,         // String constant in data directive
    0x1E: 'COLOR_DCHAR',    #= 0x1E,         // Char constant in data directive
    0x1F: 'COLOR_DNUM',     #= 0x1F,         // Numeric constant in data directive
    0x20: 'COLOR_KEYWORD',  #= 0x20,         // Keywords
    0x21: 'COLOR_REG',      #= 0x21,         // Register name
    0x22: 'COLOR_IMPNAME',  #= 0x22,         // Imported name
    0x23: 'COLOR_SEGNAME',  #= 0x23,         // Segment name
    0x24: 'COLOR_UNKNAME',  #= 0x24,         // Dummy unknown name
    0x25: 'COLOR_CNAME',    #= 0x25,         // Regular code name
    0x26: 'COLOR_UNAME',    #= 0x26,         // Regular unknown name
    0x27: 'COLOR_COLLAPSED',#= 0x27,         // Collapsed line

    #  // Fictive colors
    0x28: 'COLOR_ADDR',     #= 0x28, // hidden address marks
                            #        // The address is represented as 8digit
                            #        // hex number: 01234567
                            #        // It doesn't have COLOR_OFF pair
                            #        // NB: for 64-bit IDA, the address is 16digit

    0x29: 'COLOR_OPND1',    #= COLOR_ADDR+1, // Instruction operand 1
    0x2A: 'COLOR_OPND2',    #= COLOR_ADDR+2, // Instruction operand 2
    0x2B: 'COLOR_OPND3',    #= COLOR_ADDR+3, // Instruction operand 3
    0x2C: 'COLOR_OPND4',    #= COLOR_ADDR+4, // Instruction operand 4
    0x2D: 'COLOR_OPND5',    #= COLOR_ADDR+5, // Instruction operand 5
    0x2E: 'COLOR_OPND6',    #= COLOR_ADDR+6, // Instruction operand 6

    0x32: 'COLOR_UTF8',     #= COLOR_ADDR+10;// Following text is UTF-8 encoded
}


class Symbol(object):
    def __init__(self, type):
        super(Symbol, self).__init__()
        self.type = type

    def __str__(self):
        raise NotImplementedError()


class StringSymbol(Symbol):
    def __init__(self, string):
        super(StringSymbol, self).__init__('string')
        self.string = string

    def __str__(self):
        return 'STRING=' + self.string


class ColorOnSymbol(Symbol):
    def __init__(self, color):
        super(ColorOnSymbol, self).__init__('coloron')
        self.color = ord(color)

    def __str__(self):
        return 'COLORON=' + INV_COLORS[self.color]


class ColorOffSymbol(Symbol):
    def __init__(self, color):
        super(ColorOffSymbol, self).__init__('coloroff')
        self.color = ord(color)

    def __str__(self):
        return 'COLOROFF=' + INV_COLORS[self.color]


class ColorInvSymbol(Symbol):
    def __init__(self):
        super(ColorInvSymbol, self).__init__('colorinv')

    def __str__(self):
        return 'COLORINV'



def lex(curline):
    '''
    split the line returned by `get_custom_viewer_curline` into symbols.
    it pulls out the strings, color directives, and escaped characters.
    
    Args:
      curline (str): a line returned by `ida_kernwin.get_custom_viewer_curline`
    
    Returns:
      generator: generator of Symbol subclass instances
    '''

    offset = 0
    cur_word = []
    while offset < len(curline):

        c = curline[offset]

        if c == ida_lines.COLOR_ON:
            if cur_word:
                yield StringSymbol(''.join(cur_word))
                cur_word = []

            offset += 1
            color = curline[offset]

            yield ColorOnSymbol(color)
            offset += 1

        elif c == ida_lines.COLOR_OFF:
            if cur_word:
                yield StringSymbol(''.join(cur_word))
                cur_word = []

            offset += 1
            color = curline[offset]

            yield ColorOffSymbol(color)
            offset += 1

        elif c == ida_lines.COLOR_ESC:
            if cur_word:
                yield StringSymbol(''.join(cur_word))
                cur_word = []

            offset += 1
            c = curline[offset]

            cur_word.append(c)
            offset += 1

        elif c == ida_lines.COLOR_INV:
            if cur_word:
                yield StringSymbol(''.join(cur_word))
                cur_word = []

            yield ColorInvSymbol()
            offset += 1

        else:
            cur_word.append(c)
            offset += 1


def get_color_at_char(curline, index):
    curlen = 0
    curcolor = 0
    for sym in lex(curline):
        if sym.type == 'string':
            curlen += len(sym.string)
            if curlen >= index:
                return curcolor
        elif sym.type == 'coloron':
            curcolor = sym.color
        elif sym.type == 'coloroff':
            curcolor = 0
        else:
            curcolor = 0

    return curcolor


def get_token_at_char(curline, index):
    curlen = 0
    curcolor = 0
    for sym in lex(curline):
        if sym.type == 'string':
            curlen += len(sym.string)
            if curlen >= index:
                return sym.string
        else:
            continue

    return ''


#### end: idapython_lex_curline
###############################################################################


def enum_function_addrs(fva):
    '''
    yield the effective addresses of each instruction in the given function.
    these addresses are not guaranteed to be in any order.
    
    Args:
      fva (int): the starting address of a function
    
    Returns:
      sequence[int]: the addresses of each instruction
    '''
    f = idaapi.get_func(fva)
    if not f:
        raise ValueError('not a function')

    for block in idaapi.FlowChart(f):
        ea = block.start_ea
        while ea <= block.end_ea:
            yield ea
            ea = ida_bytes.next_head(ea, idc.BADADDR)


def enum_calls_in_function(fva):
    '''
    yield the call instructions in the given function.
    
    Args:
      fva (int): the starting address of a function
    
    Returns:
      sequence[tuple[int, str]]: the address of a call instruction, and the disassembly line at that address
    '''
    for ea in enum_function_addrs(fva):
        if idaapi.is_call_insn(ea):
            disasm = ida_lines.generate_disassembly(ea, 16, True, False)[1][0]
            # replace consequent whitespaces by a single whitespaces
            disasm = re.sub("\s\s+", " ", disasm)
            yield ea, disasm


def enum_string_refs_in_function(fva):
    '''
    yield the string references in the given function.
    
    Args:
      fva (int): the starting address of a function
    
    Returns:
      sequence[tuple[int, int, str]]: tuples of metadata, including:
       - the address of the instruction referencing a string
       - the address of the string
       - the string
    '''
    for ea in enum_function_addrs(fva):
        for ref in idautils.DataRefsFrom(ea):
            stype = ida_nalt.get_str_type(ref)
            if stype < 0 or stype > 7:
                continue

            CALC_MAX_LEN = -1
            try:
                s = ida_bytes.get_strlit_contents(ref, CALC_MAX_LEN, stype).decode("utf-8")
            except UnicodeDecodeError:
                s = str(ida_bytes.get_strlit_contents(ref, CALC_MAX_LEN, stype))

            yield ea, ref, s


def uniq(s):
    '''
    yield the unique items in the given sequence.
    only provide the first copy encountered, skipping subsequent copies.
    
    Args:
      s (sequence[T]): a sequence of things

    Returns:
      sequence[T]: a sequence of the unique copies
    '''
    seen = set([])

    for item in s:
        if item in seen:
            continue

        yield item

        seen.add(item)


def render_function_hint(fva):
    '''
    create a textual report for the call and string references in the given function.
    
    eg.

        3 calls, 4 strings

        calls:
          - call     new
          - call     gethostbyname
          - call     delete
    
        strings:
          - www.google.com
          - www.bing.com
          - www.yahoo.com
          - www.cnn.com
    
    Args:
      fva (int): the starting address of a function

    Returns:
      str: the report
    '''
    ret = []

    # use `uniq` here (vs using a set) cause we want to maintain *some* semblance of order.
    calls = list(uniq(d for f, d in enum_calls_in_function(fva)))
    strings = list(uniq(s for o, r, s in enum_string_refs_in_function(fva)))
    xrefs = [xref.frm for xref in idautils.XrefsTo(fva, ida_xref.XREF_ALL) 
             if ida_bytes.is_code(ida_bytes.get_flags(xref.frm))]

    # this would be a good place to use Jinja2 templating,
    #  but lets not require that external dependency
    title = ida_lines.COLSTR('%d calls, ' % len(calls), ida_lines.SCOLOR_CODNAME)
    title += ida_lines.COLSTR('%s strings, ' % len(strings), ida_lines.SCOLOR_DSTR)
    title += ida_lines.COLSTR('%d xrefs ' % len(xrefs), ida_lines.SCOLOR_DEFAULT)
    ret.append(title)

    ret.append('')
    if calls:
        ret.append(ida_lines.COLSTR('calls:', ida_lines.SCOLOR_DEFAULT))
        for call in calls:
            ret.append('  - ' + call)
        ret.append('')
    
    if strings:
        ret.append(ida_lines.COLSTR('strings:', ida_lines.SCOLOR_DEFAULT))
        for s in strings:
            ret.append('  - "' + ida_lines.COLSTR(s, ida_lines.SCOLOR_DSTR) + '"')

    return '\n'.join(ret)


class CallsHintsHook(ida_kernwin.UI_Hooks):
    def get_custom_viewer_hint(self, view, place):
        try:
            widget = ida_kernwin.get_current_widget()
            if ida_kernwin.get_widget_type(widget) != ida_kernwin.BWN_DISASM:
                return None

            curline = ida_kernwin.get_custom_viewer_curline(view, True)
            
            # sometimes get_custom_viewer_place() returns [x, y] and sometimes [place_t, x, y].
            # we want the place_t.
            viewer_place = ida_kernwin.get_custom_viewer_place(view, True)
            if len(viewer_place) != 3:
                return None

            _, x, y = viewer_place
            ea = place.toea()

            # "color" is a bit of misnomer: its the type of the symbol currently hinted
            color = get_color_at_char(curline, x)
            if color != ida_lines.COLOR_ADDR:
                return None

            # grab the FAR references to code (not necessarilty a branch/call/jump by itself)
            far_code_references = [xref.to for xref in idautils.XrefsFrom(ea, ida_xref.XREF_FAR) 
                                   if ida_bytes.is_code(ida_bytes.get_flags(xref.to))]
            if len(far_code_references) != 1:
                return None

            fva = far_code_references[0]

            # ensure its actually a function
            if not idaapi.get_func(fva):
                return None

            # this magic constant is the number of "important lines" to display by default.
            # the remaining lines get shown if you scroll down while the hint is displayed, revealing more lines.
            return render_function_hint(fva), DEFAULT_IMPORTANT_LINES_NUM
        except Exception as e:
            logger.warning('unexpected exception: %s. Get in touch with @williballenthin.', e, exc_info=True)
            return None


class CallsHintsPlugin(idaapi.plugin_t):
    flags = idaapi.PLUGIN_KEEP
    comment = 'Display the calls and strings referenced by a function as hints.'
    help = 'Display the calls and strings referenced by a function as hints.'
    wanted_name = "CallsHintsPlugin"
    wanted_hotkey = "Ctrl-'"

    def init(self):
        self.hooks = CallsHintsHook()
        if self.hooks.hook():
            return idaapi.PLUGIN_KEEP
        else:
            logger.warning('error setting hooks.')
            return idaapi.PLUGIN_SKIP

    def run(self, arg):
        pass
        

    def term(self):
        self.hooks.unhook()


def PLUGIN_ENTRY():
    return CallsHintsPlugin()

```

`plugins/hint_calls/readme.md`:

```md
# hint_calls

IDA plugin to display the calls and strings referenced by a function as hints.

# installation

copy the python file to `%IDADIR%/plugins/`.

```

`plugins/tag_func.py`:

```py
import logging
from typing import Iterator, List, Optional, Tuple

import ida_ua
import ida_name
import ida_funcs
import ida_idaapi
import ida_kernwin
import ida_dirtree

from ida_dirtree import dirtree_t

logger = logging.getLogger("tag_func")


def dirtree_find(dir, pattern) -> Iterator[ida_dirtree.dirtree_cursor_t]:
    """
    enumerate the matches for the given pattern against the given dirtree.
    this is just a Pythonic helper over the SWIG-generated routines.
    """
    # pattern format:
    #  "*" for all in current directory, does not recurse
    #  "/" for root directory
    #  "/sub_410000" for item by name
    #  "/foo" for directory by name, no trailing slash
    #  "/foo/*" for path prefix
    #      does not recurse beyond the prefix path
    #      matches "/foo/sub_401000" and but not "/foo/bar/sub_4010005"
    #  "/foo/sub_*" for path prefix (matches "/foo/sub_401000")
    #  "*main" for suffix (matches "/_main" because leading / is implied)
    #  "*mai*" for substring (matches "/_main" and "/_main_0" because leading / is implied)
    #
    #  wildcards only seem to match within path components
    #    does *not* work:
    #      "/*/sub_401000"
    #      "*/sub_401000"
    #      "*"
    #
    # to search by name, i guess use pattern "*" and check get_entry_name
    ff = ida_dirtree.dirtree_iterator_t()
    ok = dir.findfirst(ff, pattern)
    while ok:
        yield ff.cursor
        ok = dir.findnext(ff)


def dirtree_join(*parts) -> str:
    return "/".join(parts)


def dirtree_walk(dir: dirtree_t, top: str) -> Iterator[Tuple[str, List[str], List[str]]]:
    """
    like os.walk over the given dirtree.

    yields tuples: (root, [dirs], [files])
    use dirtree_join(*parts) to join root and dir/file entry:

        # print all files
        for root, dirs, files in dirtree_walk(func_dir, "/"):
            for file in files:
                print(dirtree_join(root, file))
    """
    top = top.rstrip("/")
    directories = [top]

    while len(directories) > 0:
        directory = directories.pop(0)

        dirs = []
        files = []

        for cursor in dirtree_find(dir, f"{directory}/*"):
            dirent = dir.resolve_cursor(cursor)
            name = dir.get_entry_name(dirent)

            if dirent.isdir:
                dirs.append(name)
                directories.append(dirtree_join(directory, name))
            else:
                files.append(name)

        yield (directory, dirs, files)


def find_function_dirtree_path(va: int) -> Optional[str]:
    """
    given the address of a function
    find its absolute path within the function dirtree.
    """
    func_dir: dirtree_t = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)

    name = ida_name.get_name(va)
    if not name:
        return None

    for root, _, files in dirtree_walk(func_dir, "/"):
        for file in files:
            if file == name:
                return dirtree_join(root, file)

    return None


def dirtree_mkdirs(dir, path):
    parts = path.split("/")

    for i in range(2, len(parts) + 1):
        prefix = "/".join(parts[:i])

        if not dir.isdir(prefix):
            e = dir.mkdir(prefix)
            if e != ida_dirtree.DTE_OK:
                logger.error("error: %s", ida_dirtree.dirtree_t_errstr(e))
                return e

    return ida_dirtree.DTE_OK


def set_tagged_func_cmt(tag: str, va: int, cmt: str, repeatable: bool):
    func = ida_funcs.get_func(va)
    existing = (ida_funcs.get_func_cmt(func, repeatable) or "").strip()

    prefix = f"{tag}: "
    line = f"{prefix}{cmt}"

    if prefix in existing:
        rest = existing.partition(prefix)[2].partition("\n")[0]
        new = existing.replace(f"{prefix}{rest}", line)
    elif existing == "":
        new = line
    else:
        new = existing + f"\n{line}"

    ida_funcs.set_func_cmt(func, new, repeatable)


def set_func_folder_cmt(va: int, folder: str):
    set_tagged_func_cmt("📁", va, folder, True)


def sync_func_folder_cmts():
    func_dir: dirtree_t = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)
    for root, _, files in dirtree_walk(func_dir, "/"):
        if root == "/" or root == "":
            continue

        tag = root.lstrip("/")
        for file in files:
            va = ida_name.get_name_ea(ida_idaapi.BADADDR, file)
            if va == ida_idaapi.BADADDR:
                continue

            set_func_folder_cmt(va, tag)


def main():
    va = ida_kernwin.get_screen_ea()
    f = ida_funcs.get_func(va)
    if not f:
        logger.error("function not found: 0x%x", va)
        return

    path = find_function_dirtree_path(f.start_ea)
    if not path:
        logger.error("function directory entry not found: 0x%x", f.start_ea)
        return

    func_dir: dirtree_t = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)

    dirent = func_dir.resolve_path(path)
    name = func_dir.get_entry_name(dirent)
    existing_tag = path[:-(len("/") + len(name))].lstrip("/")

    # ask_str(defval, hist, prompt) -> PyObject *
    # I'm not sure what "history id" does.
    tag = ida_kernwin.ask_str(existing_tag, 69, "tag:")
    if not tag:
        return

    tag_path = f"/{tag}"
    if not func_dir.isdir(tag_path):
        logger.info("creating tag: %s", tag)

        e = dirtree_mkdirs(func_dir, tag_path)
        if e != ida_dirtree.DTE_OK:
            logger.error("error: failed to create tag: %s", tag)
            return
 
    else:
        logger.debug("tag exists: %s", tag)

    src_path = path
    src_dirent = func_dir.resolve_path(src_path)
    src_name = func_dir.get_entry_name(src_dirent)

    dst_name = src_name
    dst_path = f"{tag_path}/{dst_name}"

    if src_path == dst_path:
        logger.info("skipping move to itself")
        return

    logger.info("moving %s from %s to %s", src_name, src_path, dst_path)
    e = func_dir.rename(src_path, dst_path)
    if e != ida_dirtree.DTE_OK:
        logger.error("error: %s", ida_dirtree.dirtree_t_errstr(e))
        return

    set_func_folder_cmt(f.start_ea, tag)


class FunctionTagPlugin(ida_idaapi.plugin_t):
    # Mandatory definitions
    PLUGIN_NAME = "Function Tag"
    PLUGIN_VERSION = "1.0.0"
    PLUGIN_AUTHORS = "william.ballenthin@mandiant.com"

    wanted_name = PLUGIN_NAME
    wanted_hotkey = "Z"
    comment = "Quickly organize functions into tags via hotkey"
    version = ""
    flags = 0

    def __init__(self):
        """initialize plugin"""
        pass

    def init(self):
        """called when IDA is loading the plugin"""
        print("Function Tag: loaded")
        sync_func_folder_cmts()
        return ida_idaapi.PLUGIN_OK

    def term(self):
        """called when IDA is unloading the plugin"""
        pass

    def run(self, arg):
        """called when IDA is running the plugin as a script"""
        main()
        return True


def PLUGIN_ENTRY():
    return FunctionTagPlugin()


if __name__ == "__main__":
    sync_func_folder_cmts()
    main()

```

`scripts/add_segment/add_segment.py`:

```py
'''
IDAPython plugin that adds the contents of a file as a new segment in an existing idb.
Prompts the user for:
  - file path
  - segment name
  - segment starting offset
  
Useful for reversing engineering packed software and shellcode.

Author: Willi Ballenthin <william.ballenthin@fireeye.com>
Licence: Apache 2.0
'''
import logging
from collections import namedtuple

import idc
import idaapi
import idautils


logger = logging.getLogger(__name__)


class BadInputError(Exception):
    pass


Segment = namedtuple('SegmentBuffer', ['path', 'name', 'addr'])


def prompt_for_segment():
    ''' :returns: a Segment instance, or raises BadInputError '''
    class MyForm(idaapi.Form):
        def __init__(self):
            idaapi.Form.__init__(self, """STARTITEM 0
add segment by buffer

<##buffer path:{path}>
<##segment name:{name}>
<##segment start address:{addr}>
""",
                                 {
                                     'path': idaapi.Form.FileInput(open=True),
                                     'name': idaapi.Form.StringInput(),
                                     'addr': idaapi.Form.NumericInput(tp=Form.FT_ADDR),
                                 })

        def OnFormChange(self, fid):
            return 1

    f = MyForm()
    f.Compile()
    f.path.value = ""
    f.name.value = ""
    f.addr.value = 0x0
    ok = f.Execute()
    if ok != 1:
        raise BadInputError('user cancelled')

    path = f.path.value
    if path == "" or path is None:
        raise BadInputError('bad path provided')

    if not os.path.exists(path):
        raise BadInputError('file doesn\'t exist')

    name = f.name.value
    if name == "" or name is None:
        raise BadInputError('bad name provided')

    addr = f.addr.value
    f.Free()
    return Segment(path, name, addr)


def main(argv=None):
    if argv is None:
        argv = sys.argv[:]

    try:
        seg = prompt_for_segment()
    except BadInputError:
        logger.error('bad input, exiting...')
        return -1

    with open(seg.path, 'rb') as f:
        buf = f.read()

    seglen = len(buf)
    if seglen % 0x1000 != 0:
        seglen = seglen + (0x1000 - (seglen % 0x1000))

    if not idc.AddSeg(seg.addr, seg.addr + seglen, 0, 1, 0, idaapi.scPub):
        logger.error('failed to add segment: 0x%x', seg.addr)
        return -1

    if not idc.set_segm_name(seg.addr, seg.name):
        logger.warning('failed to rename segment: %s', seg.name)

    if not idc.set_segm_class(seg.addr, 'CODE'):
        logger.warning('failed to set segment class CODE: %s', seg.name)

    if not idc.set_segm_attr(seg.addr, SEGATTR_ALIGN, idc.saRelPara):
        logger.warning('failed to align segment: %s', seg.name)

    ida_bytes.patch_bytes(seg.addr, buf)


class AddSegmentPlugin(idaapi.plugin_t):
    flags = idaapi.PLUGIN_KEEP
    comment = "Add a segment to an IDA .idb from a file."

    help = "Add a segment to an IDA .idb from a file."
    wanted_name = "AddSegment"
    wanted_hotkey = "Alt-F8"

    def init(self):
        return idaapi.PLUGIN_OK

    def run(self, arg):
        main()

    def term(self):
        pass


def PLUGIN_ENTRY():
    return AddSegmentPlugin()


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)
    main()

```

`scripts/add_segment/readme.md`:

```md
# add_segment

IDAPython plugin that adds the contents of a file as a new segment in an existing idb.
Prompts the user for:
  - file path
  - segment name
  - segment starting offset

Useful for reversing engineering packed software and shellcode.

## installation

none

## usage

invoke the script via `File->Script file...`.

```

`scripts/allocate_rwx_page.py`:

```py
import ida_kernwin

import idawilli.dbg


def main():
    size = ida_kernwin.ask_long(0x1000, "size of allocation")
    if not size:
        return

    ptr = idawilli.dbg.allocate_rwx(size)
    print('allocated 0x%x bytes at 0x%x' % (size, ptr))


main()
```

`scripts/color/color.py`:

```py
'''
IDAPython script that colors instructions.

Author: Willi Ballenthin <william.ballenthin@fireeye.com>
Licence: Apache 2.0
'''
import logging
from collections import namedtuple

import ida_settings

import idc
import idaapi
import idautils
import ida_ua
import ida_bytes
import ida_segment


logger = logging.getLogger(__name__)
settings = ida_settings.IDASettings('idawilli.color')

CALL_COLOR = settings.get('colors.instructions.call', 0xD7C2C0)      # blueish
ENCRYPT_COLOR = settings.get('colors.behaviors.encrypt', 0xC0C2D7)   # redish
ANTIANALYSIS_COLOR = settings.get(
    'colors.behaviors.anti-analysis', 0xC0C2D7)  # redish


Segment = namedtuple('Segment', ['start', 'end', 'name'])


def enum_segments():
    for ea in idautils.Segments():
        seg = ida_segment.getseg(ea)
        yield Segment(seg.start_ea, seg.end_ea, seg.name)


def enum_heads():
    for segment in enum_segments():
        for head in idautils.Heads(segment.start, segment.end):
            yield head


def color_head(ea):
    flags = ida_bytes.get_flags(ea)
    if not ida_bytes.is_code(flags):
        return

    mnem = ida_ua.print_insn_mnem(ea)
    if mnem == 'call':
        logger.debug('call: 0x%x', ea)
        idc.set_color(ea, idc.CIC_ITEM, CALL_COLOR)
    elif mnem == 'xor':
        if idc.get_operand_value(ea, 0) != idc.get_operand_value(ea, 1):
            logger.debug('non-zero xor: 0x%x', ea)
            idc.set_color(ea, idc.CIC_ITEM, ENCRYPT_COLOR)
    elif mnem in ('sdit', 'sgdt', 'sldt', 'smsw', 'str', 'in', 'cpuid'):
        logger.debug('anti-vm: 0x%x', ea)
        idc.set_color(ea, idc.CIC_ITEM, ANTIANALYSIS_COLOR)
    elif mnem == 'in':
        if idc.get_operand_value(ea, 0) in ("3", "2D"):
            logger.debug('anti-debug: 0x%x', ea)
            idc.set_color(ea, idc.CIC_ITEM, ANTIANALYSIS_COLOR)
    elif mnem in ('rdtsc', 'icebp'):
        logger.debug('anti-debug: 0x%x', ea)
        idc.set_color(ea, idc.CIC_ITEM, ANTIANALYSIS_COLOR)


def main(argv=None):
    if argv is None:
        argv = sys.argv[:]

    for head in enum_heads():
        color_head(head)


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)
    main()

```

`scripts/deob.py`:

```py
"""
search for and patch out known opaque predicates within IDA Pro workspaces.

just run the script and it will manipulate the open database.
therefore, you should probably create a backup first.
"""
import logging
from pprint import pprint

import ida_idp
import idautils
import ida_auto
import ida_bytes
import ida_segment


logger = logging.getLogger("deob")


def nop_region(ea, size):
    """replace the given range with NOPs"""
    logger.debug("nopping region from 0x%x size 0x%x", ea, size)

    for i in range(ea, ea + size):
        ida_bytes.del_items(i)

    for i in range(ea, ea + size):
        ida_bytes.patch_byte(i, 0x90)

    ida_auto.auto_make_code(ea)


def is_jump_plus_one(ea):
    """
    like:

        .text:00401089                 jmp     short loc_40108C
        .text:00401089 ; ---------------------------------------------------------------------------
        .text:0040108B                 db 0BAh ; º
        .text:0040108C ; ---------------------------------------------------------------------------
        .text:0040108C
        .text:0040108C loc_40108C:                             ; CODE XREF: .text:00401089↑j
        .text:0040108C                 mov     eax, 1
    """
    insn = idautils.DecodeInstruction(ea)
    if insn is None:
        logger.debug("0x%x: failed to decode instruction", ea)
        return False, None

    if insn.get_canon_mnem() != "jmp":
        return False, None

    next_ea = insn.ea + insn.size
    if insn.ops[0].addr != next_ea + 1:
        return False, None

    return True, insn.size + 1


def is_jmp_ret(ea):
    """
    like:

        .text:004010C9                 call    $+5
        .text:004010CE                 add     dword ptr [esp], 6
        .text:004010D2                 retn
        .text:004010D2 ; ---------------------------------------------------------------------------
        .text:004010D3                 db  7Dh ; }
        .text:004010D4 ; ---------------------------------------------------------------------------
        .text:004010D4                 mov     eax, 0
    """
    insn = idautils.DecodeInstruction(ea)
    if insn is None:
        return False, None

    if insn.get_canon_mnem() != "call":
        return False, None

    next_ea = insn.ea + insn.size
    if insn.ops[0].addr != next_ea:
        return False, None

    insn = idautils.DecodeInstruction(next_ea)
    if insn is None:
        return False, None

    if insn.get_canon_mnem() != "add":
        return False, None

    delta = insn.ops[1].value
    target = next_ea + delta

    next_ea = insn.ea + insn.size

    insn = idautils.DecodeInstruction(next_ea)
    if insn is None:
        return False, None

    if insn.get_canon_mnem() != "retn":
        return False, None

    return True, target - ea


def is_stc_jb(ea):
    """
    like:

        .text:00401042                 stc
        .text:00401043                 jb      short loc_401046
        .text:00401043 ; ---------------------------------------------------------------------------
        .text:00401045                 db 0B1h ; ±
        .text:00401046 ; ---------------------------------------------------------------------------
        .text:00401046
        .text:00401046 loc_401046:                             ; CODE XREF: .text:00401043↑j
        .text:00401046                 mov     eax, 0
    """
    insn = idautils.DecodeInstruction(ea)
    if insn is None:
        return False, None

    if insn.get_canon_mnem() != "stc":
        return False, None

    next_ea = insn.ea + insn.size

    insn = idautils.DecodeInstruction(next_ea)
    if insn is None:
        return False, None

    if insn.get_canon_mnem() != "jb":
        return False, None

    if insn.ops[0].addr != insn.ea + insn.size + 1:
        return False, None

    return True, 4


def is_clc_jnb(ea):
    """
    like:

        .text:0040139E                 clc
        .text:0040139F                 jnb     short loc_4013A2
        .text:0040139F ; ---------------------------------------------------------------------------
        .text:004013A1                 db  0Fh
        .text:004013A2 ; ---------------------------------------------------------------------------
        .text:004013A2
        .text:004013A2 loc_4013A2:                             ; CODE XREF: .text:0040139F↑j
        .text:004013A2                 mov     eax, 0x0
    """
    insn = idautils.DecodeInstruction(ea)
    if insn is None:
        return False, None

    if insn.get_canon_mnem() != "clc":
        return False, None

    next_ea = insn.ea + insn.size

    insn = idautils.DecodeInstruction(next_ea)
    if insn is None:
        return False, None

    if insn.get_canon_mnem() != "jnb":
        return False, None

    if insn.ops[0].addr != insn.ea + insn.size + 1:
        return False, None

    return True, 4


SEG_X = 0b001
SEG_W = 0b010
SEG_R = 0b100


OBFUSCATIONS = [
    is_jump_plus_one,
    is_jmp_ret,
    is_stc_jb,
    is_clc_jnb,
]


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)

    for segstart in idautils.Segments():
        seg = ida_segment.getseg(segstart)
        if not (seg.perm & SEG_X):
            continue

        seg_name = ida_segment.get_segm_name(seg)

        for ea in range(seg.start_ea, seg.end_ea):
            for obfuscation in OBFUSCATIONS:
                is_ob, size = obfuscation(ea)
                if not is_ob:
                    continue

                logger.info(
                    "%s: 0x%x: found obfuscation(%s)",
                    seg_name,
                    ea,
                    obfuscation.__name__,
                )
                nop_region(ea, size)

    print("ok")

```

`scripts/find_ptrs/ida_find_ptrs.py`:

```py
import idc
import idautils


def enum_segments():
    for segstart in idautils.Segments():
        segend = idc.get_segm_end(segstart)
        segname = idc.get_segm_name(segstart)
        yield segstart, segend, segname


def find_pointers(start, end):
    for va in range(start, end-0x4):
        ptr = idc.get_wide_dword(va)
        if idc.get_segm_start(ptr) == idc.BADADDR:
            continue

        yield va, ptr


def is_head(va):
    return ida_bytes.is_head(idc.get_full_flags(va))


def get_head(va):
    if is_head(va):
        return va
    else:
        return idc.prev_head(va)


def is_code(va):
    if is_head(va):
        flags = idc.get_full_flags(va)
        return ida_bytes.is_code(flags)
    else:
        head = get_head(va)
        return is_code(head)


CACHED_STRINGS = list(idautils.Strings())
def is_in_string(va):
    for s in CACHED_STRINGS:
        if s.ea <= va < s.ea + s.length:
            return True
    return False


def is_defined(va):
    pass


def is_unknown(va):
    return ida_bytes.is_unknown(idc.get_full_flags(va))


def main():
    for segstart, segend, segname in enum_segments():
        if segname not in ('.text', '.data'):
            continue

        for src, dst in find_pointers(segstart, segend):
            if is_code(src):
                # ignore instructions like:
                #
                #     call    ds:__vbaGenerateBoundsError
                #print('code pointer: 0x%x -> 0x%x' % (src, dst))
                continue

            if is_in_string(src):
                # for example, the following contains 0x444974 (a common valid offset):
                #
                #     text:004245B0 aRequestid    db 'requestID',
                #
                # enable or disable this behavior as you wish
                print('string pointer: 0x%x -> 0x%x' % (src, dst))
                pass
                #continue

            print('pointer from 0x%x to 0x%x' % (src, dst))

            if is_unknown(dst):
                print('destination unknown, making byte: 0x%x' % (dst))
                ida_bytes.create_data(dst, FF_BYTE, 1, ida_idaapi.BADADDR)

            elif is_head(dst):
                # things are good
                pass

            else:
                # need to undefine head, and make byte
                head_va = get_head(dst)
                print('destination overlaps with head: 0x%x' % (head_va))
                ida_bytes.del_items(head_va, dst - head_va)
                ida_bytes.create_data(head_va, FF_BYTE, 1, ida_idaapi.BADADDR)
                ida_bytes.create_data(dst, FF_BYTE, 1, ida_idaapi.BADADDR)

            ida_bytes.del_items(src, 4)
            ida_bytes.create_data(src, FF_DWORD, 4, ida_idaapi.BADADDR)
            # this doesn't seem to always work :-(
            idc.op_plain_offset(src, -1, 0)


if __name__ == '__main__':
    main()

```

`scripts/find_ptrs/readme.md`:

```md
# ida_find_ptrs.py

IDAPython script that scans through the .text section for values that could be pointers (32-bit). 
It marks these elements as such. 
This is useful when IDA Pro's auto-analysis leaves lots of unstructured data lying around.

```

`scripts/fix_ptr_ops/fix_ptr_operands.py`:

```py
import idc
import idautils
import ida_offset

reftype = ida_offset.get_default_reftype(next(idautils.Segments()))

for segea in idautils.Segments():
    for head in idautils.Heads(idc.get_segm_start(segea), idc.get_segm_end(segea)):
        if not ida_bytes.is_code(ida_bytes.get_full_flags(head)):
            continue

        for i in range(2):
            if idc.get_segm_start(idc.get_operand_value(head, i)) == idc.BADADDR:
                continue
            ida_offset.op_offset(head, i, reftype)

print("ok")

```

`scripts/go/go_fixup_fptrs.py`:

```py
"""
when IDA's auto-discovery of functions in 64-bit Windows Go executables fails,
scan for global (.rdata) pointers into the code section (.text) and assume these are function pointers.
"""
import idc
import ida_name
import ida_auto
import ida_bytes
import idautils


def enum_segments():
    for segstart in idautils.Segments():
        segend = idc.get_segm_end(segstart)
        segname = idc.get_segm_name(segstart)
        yield segstart, segend, segname


def find_pointers(start, end):
    for va in range(start, end-0x8):
        ptr = ida_bytes.get_qword(va)
        if idc.get_segm_start(ptr) != idc.BADADDR:
            yield va, ptr, 8
        ptr = ida_bytes.get_dword(va)
        if idc.get_segm_start(ptr) != idc.BADADDR:
            yield va, ptr, 4


def is_head(va):
    return ida_bytes.is_head(idc.get_full_flags(va))


def get_head(va):
    if is_head(va):
        return va
    else:
        return idc.prev_head(va)


def is_code(va):
    if is_head(va):
        flags = idc.get_full_flags(va)
        return ida_bytes.is_code(flags)
    else:
        head = get_head(va)
        return is_code(head)


def is_unknown(va):
    return ida_bytes.is_unknown(idc.get_full_flags(va))


def main():
    for segstart, segend, segname in enum_segments():
        if segname not in ('.rdata', 'UPX1'):
            continue

        print(segname)
        for src, dst, size in find_pointers(segstart, segend):
            if idc.get_segm_name(dst) not in (".text", "UPX0"):
                continue

            if is_code(dst):
                continue

            print("new function pointer: 0x%x -> 0x%x" % (src, dst))

            ida_auto.auto_make_code(dst)
            ida_auto.auto_make_proc(dst)

            ida_bytes.del_items(src, size)
            ida_bytes.create_data(src, idc.FF_QWORD if size == 8 else idc.FF_DWORD, size, idc.BADADDR)
            # this doesn't seem to always work :-(
            idc.op_plain_offset(src, -1, 0)
            ida_name.set_name(src, "j_%s_%x" % (src, dst))

if __name__ == '__main__':
    main()

```

`scripts/go/go_fixup_global_strings.py`:

```py
"""
find and annotate global references to string in 64-bit Windows Go executables.

expect to see the pattern:

    .rdata: qword ptr string -> .rdata
    .rdata: qword size
"""
import idc
import ida_name
import ida_bytes
import idautils


def enum_segments():
    for segstart in idautils.Segments():
        segend = idc.get_segm_end(segstart)
        segname = idc.get_segm_name(segstart)
        yield segstart, segend, segname


def find_pointers(start, end):
    for va in range(start, end-0x8):
        ptr = ida_bytes.get_qword(va)
        if idc.get_segm_start(ptr) != idc.BADADDR:
            yield va, ptr, 8
        ptr = ida_bytes.get_dword(va)
        if idc.get_segm_start(ptr) != idc.BADADDR:
            yield va, ptr, 4


def is_head(va):
    return ida_bytes.is_head(idc.get_full_flags(va))


def get_head(va):
    if is_head(va):
        return va
    else:
        return idc.prev_head(va)


def is_code(va):
    if is_head(va):
        flags = idc.get_full_flags(va)
        return ida_bytes.is_code(flags)
    else:
        head = get_head(va)
        return is_code(head)


def is_unknown(va):
    return ida_bytes.is_unknown(idc.get_full_flags(va))


def main():
    for segstart, segend, segname in enum_segments():
        if segname not in ('.rdata', 'UPX1' ):
            continue

        for src, dst, psize in find_pointers(segstart, segend):
            if idc.get_segm_name(dst) not in (".rdata", "UPX0"):
                continue
                
            if psize == 8:
                size = ida_bytes.get_qword(src + 0x8)
            else:
                size = ida_bytes.get_dword(src + 0x4)
                
            if size > 0x100:
                continue
            if size <= 2:
                continue

            buf = ida_bytes.get_bytes(dst, size)
            if not buf:
                continue

            if b"\x00" in buf:
                continue

            try:
                s = buf.decode("ascii")
            except UnicodeDecodeError:
                continue

            print("string pointer: 0x%x -> 0x%x: %s" % (src, dst, s))

            ida_bytes.del_items(src, 1)
            ida_bytes.set_cmt(dst, s, True)

            # pointer
            ida_bytes.del_items(src, psize)
            ida_bytes.create_data(src, idc.FF_QWORD if size == 8 else idc.FF_DWORD, psize, idc.BADADDR)
            # this doesn't seem to always work :-(
            idc.op_plain_offset(src, -1, 0)
            ida_name.set_name(src, "s_%x" % (src))
            ida_bytes.set_cmt(src, s, True)

            # size
            ida_bytes.del_items(src + psize, psize)
            ida_bytes.create_data(src + psize, idc.FF_QWORD if size == 8 else idc.FF_DWORD, psize, idc.BADADDR)

if __name__ == '__main__':
    main()

```

`scripts/go/go_fixup_inline_strings.py`:

```py
"""
create and annotate references to strings in 64-bit Windows Go executables.

expect to see the assembly pattern:

  lea reg, $string
  mov [stack], reg
  mov [stack], $size
"""
import idc
import ida_ua
import ida_name
import ida_bytes
import idautils


def enum_segments():
    for segstart in idautils.Segments():
        segend = idc.get_segm_end(segstart)
        segname = idc.get_segm_name(segstart)
        yield segstart, segend, segname


def find_pointers(start, end):
    for va in range(start, end-0x8):
        ptr = ida_bytes.get_qword(va)
        if idc.get_segm_start(ptr) == idc.BADADDR:
            continue

        yield va, ptr


def is_head(va):
    return ida_bytes.is_head(idc.get_full_flags(va))


def get_head(va):
    if is_head(va):
        return va
    else:
        return idc.prev_head(va)


def is_code(va):
    if is_head(va):
        flags = idc.get_full_flags(va)
        return ida_bytes.is_code(flags)
    else:
        head = get_head(va)
        return is_code(head)


def main():
    for segstart, segend, segname in enum_segments():
        for head in idautils.Heads(segstart, segend):
            if not is_code(head):
                continue

            # pattern:
            #
            #   lea     rax, unk_6BDF88
            #   mov     [rsp+0], rax
            #   mov     qword ptr [rsp+8], 40h 
            if ida_ua.ua_mnem(head) != "lea":
                continue

            next_head = ida_bytes.next_head(head, idc.BADADDR)
            if ida_ua.ua_mnem(next_head) != "mov":
                continue

            next_head2 = ida_bytes.next_head(next_head, idc.BADADDR)
            if ida_ua.ua_mnem(next_head2) != "mov":
                continue

            dst = idc.get_operand_value(head, 1)
            if idc.get_segm_name(dst) not in (".rdata", "UPX1"):
                continue

            size = idc.get_operand_value(next_head2, 1)

            if size > 0x100:
                continue
            if size <= 2:
                continue

            buf = ida_bytes.get_bytes(dst, size)
            if not buf:
                continue

            if b"\x00" in buf:
                continue

            try:
                s = buf.decode("ascii")
            except UnicodeDecodeError:
                continue

            print("string pointer: 0x%x -> 0x%x: %s" % (head, dst, s))
            ida_bytes.del_items(dst, 1)
            ida_bytes.create_data(dst, idc.FF_BYTE, 1, idc.BADADDR)
            ida_bytes.set_cmt(dst, s, True)
            ida_name.set_name(dst, "s_%x" % (dst))

if __name__ == '__main__':
    main()

```

`scripts/goto_file_offset.py`:

```py
import ida_loader
import ida_idaapi
import ida_kernwin


def main():
    offset = ida_kernwin.ask_addr(0x0, "file offset")
    if not offset:
        return

    ea = ida_loader.get_fileregion_ea(offset)
    if ea == ida_idaapi.BADADDR:
        print('error: EA for file offset not found')
        return

    print('EA for file offset: 0x%x' % (ea))
    ida_kernwin.jumpto(ea)


main()

```

`scripts/goto_rva.py`:

```py
import ida_nalt
import ida_kernwin


def main():
    rva = ida_kernwin.ask_addr(0x0, "RVA")
    if not rva:
        return

    ida_kernwin.jumpto(ida_nalt.get_imagebase() + rva)


main()

```

`scripts/load_file_rwx.py`:

```py
import idc
import ida_kernwin

import idawilli
import idawilli.dbg

# removeme
import ida_idaapi
ida_idaapi.require('idawilli')
ida_idaapi.require('idawilli.dbg')


def main():
    path = ida_kernwin.ask_file(False, "*", "file to load")
    if not path:
        return
        
    with open(path, "rb") as f:
        buf = tuple(f.read())
        
    if len(buf) == 0:
        print("empty file, cancelling")
        return
        
    size = idawilli.align(len(buf), 0x1000)
    print("size: 0x%x" % (len(buf)))
    print("aligned size: 0x%x" % (size))
    
    addr = idawilli.dbg.allocate_rwx(size)
    print("allocated 0x%x bytes at 0x%x" % (size, addr))
        
    idawilli.dbg.patch_bytes(addr, buf)
    print("patched file to 0x%x" % (addr))

    print("ok")
    
main()
```

`scripts/load_map_file.py`:

```py
# This script prompts for the path to a file
#   which contains a two column, whitespace-delimited list
#   
#   addr     function
#   00bca02c ADVAPI32!InitializeSecurityDescriptor
import ida_kernwin
import ida_idaapi
import ida_bytes
import ida_name

    
def get_bitness():
    info = ida_idaapi.get_inf_structure()

    if info.is_64bit():
        return 64
    elif info.is_32bit():
        return 32
    else:
        return 16
      

def make_pointer(ea):
    if get_bitness() == 16:
        ida_bytes.create_word(ea, 2)

    elif get_bitness() == 32:
        ida_bytes.create_dword(ea, 4)

    elif get_bitness() == 64:
        ida_bytes.create_qword(ea, 8)

    else:
        raise RuntimeError("unexpected bitness")
    
# --------------------------------------------------------------------------
class MyForm(ida_kernwin.Form):
    def __init__(self):
        ida_kernwin.Form.__init__(self, r"""select map file
        <#Select an annotation file to open#Browse to open:{iFileOpen}>
        """,
        { 'iFileOpen': ida_kernwin.Form.FileInput(open=True)})      

    def OnFormChange(self, fid):
        return 1

def prompt_file():
    f = ida_kernwin.Form(
        r"""select map file
            <#Select an annotation file to open#Browse to open:{iFileOpen}>
        """,
        { 'iFileOpen': ida_kernwin.Form.FileInput(open=True)})      
    f.Compile()
    f.iFileOpen.value = ""
    ok = f.Execute()
    assert(ok == 1)
    path = f.iFileOpen.value
    f.Free()
    return path
    

with open(prompt_file(), "rb") as f:
    for line in f.read().decode("utf-8").split("\n"):
        line = line.replace("`", "")

        # split by any whitespace
        parts = line.split()

        if len(parts) != 2:
            print("skipping line: " + line)
            continue

        try:
            address = int(parts[0], 0x10)
        except:
            print("skipping line: " + line)
            continue

        function = parts[1].strip()
        if "!" in function:
            dll, _, name = function.partition("!")
        else:
            name = function

        print("%s %s" % (hex(address), name))
        
        make_pointer(address)
        ida_name.set_name(address, name)

print("Done.")
```

`scripts/parse_uuid.py`:

```py
import uuid

import ida_bytes
import ida_kernwin


buf = ida_bytes.get_bytes(ida_kernwin.get_screen_ea(), 0x10)
uid = uuid.UUID(bytes_le=buf)
print(uid)

```

`scripts/resolve_ptrs.py`:

```py
'''
scan all pointers in the segment that contains EA,
checking if they point to an external name.
if so, rename the pointer.

this is intended to be used during debugging of a packed sample.
'''
import idc
import ida_name
import ida_bytes
import ida_segment


# TODO: arch
psize = 4

def get_ptr(ea):
    # TODO: arch
	return ida_bytes.get_dword(ea)
	
    
def make_ptr(ea):
    # TODO: arch
    ida_bytes.del_items(ea, 0, psize)
    return ida_bytes.create_dword(ea, psize)
	
    
def enum_ptrs(start, end):
	for ea in range(start, end, psize):
		yield (ea, get_ptr(ea))
		
		
def enum_segment_ptrs(ea):
	seg = ida_segment.getseg(ea)
	for (ea, ptr) in enum_ptrs(seg.start_ea, seg.end_ea):
		yield (ea, ptr)
		


for ea, ptr in enum_segment_ptrs(idc.get_screen_ea()):
    name = ida_name.get_name(ptr)
    
    if not name:
        continue
        
    if name.startswith('loc_'):
        continue    
       
    print(hex(ea) + ': ' + name)
    
    make_ptr(ea)
    ida_name.set_name(ea, name)

```

`scripts/save_segment.py`:

```py
'''
IDAPython script that saves the content of a segment to a file.
Prompts the user for:
  - segment name
  - file path

Useful for extracting data from memory dumps.

Author: Willi Ballenthin <william.ballenthin@fireeye.com>
Licence: Apache 2.0
'''
import logging
from collections import namedtuple

import idaapi
import ida_bytes
import ida_segment


logger = logging.getLogger(__name__)


class BadInputError(Exception):
    pass


Segment = namedtuple('SegmentBuffer', ['path', 'name'])


def prompt_for_segment():
    ''' :returns: a Segment instance, or raises BadInputError '''
    class MyForm(idaapi.Form):
        def __init__(self):
            idaapi.Form.__init__(self, """STARTITEM 0
add segment by buffer

<##segment name:{name}>
<##output path:{path}>
""",
                                 {
                                     'path': idaapi.Form.FileInput(save=True),
                                     'name': idaapi.Form.StringInput(),
                                 })

        def OnFormChange(self, fid):
            return 1

    f = MyForm()
    f.Compile()
    f.path.value = ""
    f.name.value = ""
    ok = f.Execute()
    if ok != 1:
        raise BadInputError('user cancelled')

    path = f.path.value
    if path == "" or path is None:
        raise BadInputError('bad path provided')

    name = f.name.value
    if name == "" or name is None:
        raise BadInputError('bad name provided')

    f.Free()
    return Segment(path, name)


def main(argv=None):
    if argv is None:
        argv = sys.argv[:]

    try:
        seg_spec = prompt_for_segment()
    except BadInputError:
        logger.error('bad input, exiting...')
        return -1

    seg = ida_segment.get_segm_by_name(seg_spec.name)
    if not seg:
        logger.error("bad segment, exiting...")

    buf = ida_bytes.get_bytes(seg.start_ea, seg.end_ea - seg.start_ea)
    with open(seg_spec.path, "wb") as f:
        f.write(buf)

    logger.info("wrote %x bytes", len(buf))


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)
    main()

```

`scripts/windb_symbols/apply_windbg_symbols.py`:

```py
from idaapi import *
from idc import *

# This script prompts for the path to a file
#   which contains a three column, whitespace-delimited list
#   
#   addr      deref'd  function
#   00bca02c  77dd79c6 ADVAPI32!InitializeSecurityDescriptor


def SetName(ea, s):    
    idaapi.set_name(ea, s)
    
    
def is_32():
    try:
        _ = __EA64__
        return False
    except:
        return True
      

def make_pointer(ea):
    if is_32():
        MakeUnkn(ea, 4)
        MakeDword(ea)
    else:
        MakeUnkn(ea, 8)
        MakeQword(ea)
    
# --------------------------------------------------------------------------
class MyForm(Form):
    def __init__(self):
        self.invert = False
        Form.__init__(self, r"""STARTITEM
<#Select an annotation file to open#Browse to open:{iFileOpen}>
""", { 'iFileOpen': Form.FileInput(open=True), })      

    def OnFormChange(self, fid):
        return 1
    
try:
    f = MyForm()
    f.Compile()
    f.iFileOpen.value = ""
    ok = f.Execute()
    if ok == 1:
        print f.iFileOpen.value
        with open(f.iFileOpen.value, "rb") as g:
            for line in g.read().split("\n"):
                line = line.replace("`", "")
                parts = line.split(" ")
                if len(parts) != 4:
                    continue
                try:
                    address = int(parts[0], 0x10)
                except:
                    continue
                function = parts[3].strip()
                dll, _, name = function.partition("!")
                print "%s %s" % (hex(address), name)
                
                make_pointer(address)
                SetName(address, name)
    f.Free()
except Exception as e:
    print "Unexpected error: ", e
print "Done."

```

`scripts/write_file.py`:

```py
import idc
import ida_kernwin

import idawilli
import idawilli.dbg

# removeme
import ida_idaapi
ida_idaapi.require('idawilli')
ida_idaapi.require('idawilli.dbg')


def main():
    path = ida_kernwin.ask_file(False, "*", "file to load")
    if not path:
        return
        
    with open(path, "rb") as f:
        buf = tuple(f.read())
        
    if len(buf) == 0:
        print("empty file, cancelling")
        return
        
    size = idawilli.align(len(buf), 0x1000)
    print("size: 0x%x" % (len(buf)))
    print("aligned size: 0x%x" % (size))
        
    addr = ida_kernwin.ask_addr(idc.get_screen_ea(), "location to write")
    if not addr:
        return
        
    idawilli.dbg.patch_bytes(addr, buf)

    print("ok")
    
main()
```

`scripts/yara_fn/readme.md`:

```md
# yara_fn

IDAPython script that generates a YARA rule to match against the
basic blocks of the current function. It masks out relocation bytes
and ignores jump instructions (given that we're already trying to
match compiler-specific bytes, this is of arguable benefit).

If python-yara is installed, the IDAPython script also validates that
the generated rule matches at least one segment in the current file.

## installation

none

## usage

invoke the script via `File->Script file...`. review the text written to the output pane.

```

`scripts/yara_fn/yara_fn.py`:

```py
'''
IDAPython script that generates a YARA rule to match against the
basic blocks of the current function. It masks out relocation bytes
and ignores jump instructions (given that we're already trying to
match compiler-specific bytes, this is of arguable benefit).

If python-yara is installed, the IDAPython script also validates that
the generated rule matches at least one segment in the current file.

author: Willi Ballenthin <william.ballenthin@fireeye.com>
'''

import logging
from collections import namedtuple

import idc
import idaapi
import idautils


logger = logging.getLogger(__name__)

BasicBlock = namedtuple('BasicBlock', ['va', 'size'])


# each rule must have at least this many non-masked bytes 
MIN_BB_BYTE_COUNT = 4


def get_basic_blocks(fva):
    '''
    return sequence of `BasicBlock` instances for given function.
    '''
    ret = []
    func = idaapi.get_func(fva)
    if func is None:
        return ret

    for bb in idaapi.FlowChart(func):
        ret.append(BasicBlock(va=bb.start_ea,
                              size=bb.end_ea - bb.start_ea))

    return ret


def get_function(va):
    '''
    return va for first instruction in function that contains given va.
    '''
    return idaapi.get_func(va).start_ea


Rule = namedtuple('Rule', ['name', 'bytes', 'masked_bytes'])


def is_jump(va):
    '''
    return True if the instruction at the given address appears to be a jump.
    '''
    return idc.print_insn_mnem(va).startswith('j')


def get_basic_block_rule(bb):
    '''
    create and format a YARA rule for a single basic block.
    mask relocation bytes into unknown bytes (like '??').
    do not include final instructions if they are jumps.
    '''
    # fetch the instruction start addresses
    insns = []
    va = bb.va
    while va < bb.va + bb.size:
        insns.append(va)
        va = idc.next_head(va)

    # drop the last instruction if its a jump
    if is_jump(insns[-1]):
        insns = insns[:-1]

    bytes = []
    # `masked_bytes` is the list of formatted bytes,
    #   not yet join'd for performance.
    masked_bytes = []
    for va in insns:
        size = idc.get_item_size(va)
        if idaapi.contains_fixups(va, size):
            # fetch the fixup locations within this one instruction.
            fixups = []
            fixupva = idaapi.get_next_fixup_ea(va)
            fixups.append(fixupva)
            # TODO: assume the fixup size is four bytes, probably bad.
            fixupva += 4

            while fixupva < va + size:
                fixupva = idaapi.get_next_fixup_ea(fixupva)
                fixups.append(fixupva)
                # TODO: assume the fixup size is four bytes, probably bad.
                fixupva += 4

            # assume each fixup is four bytes (TODO!),
            #  and compute the addresses of each component byte.
            fixup_byte_addrs = set([])
            for fixup in fixups:
                for i in range(fixup, fixup+4):
                    fixup_byte_addrs.add(i)
            
            # fetch and format each byte of the instruction,
            #  possibly masking it into an unknown byte if its a fixup.
            for i, byte in enumerate(idc.get_bytes(va, size)):
                byte_addr = i + va
                if byte_addr in fixup_byte_addrs:
                    bytes.append(byte)
                    masked_bytes.append('??')
                else:
                    bytes.append(byte)
                    masked_bytes.append('%02X' % (byte))
        elif 'call' in idc.print_insn_mnem(va):
            for i, byte in enumerate(idc.get_bytes(va, size)):
                bytes.append(byte)
                masked_bytes.append('??')
        else:
            for byte in idc.get_bytes(va, size):
                bytes.append(byte)
                masked_bytes.append('%02X' % (byte))

    return Rule('$0x%x' % (bb.va), bytes, masked_bytes)


def format_rules(fva, rules):
    '''
    given the address of a function, and the byte signatures for basic blocks in
     the function, format a complete YARA rule that matches all of the
     basic block signatures.
    '''
    name = idc.get_func_name(fva)

    # some characters aren't valid for YARA rule names
    safe_name = name
    BAD_CHARS = '@ /\\!@#$%^&*()[]{};:\'",./<>?'
    for c in BAD_CHARS:
        safe_name = safe_name.replace(c, '')

    md5 = idautils.GetInputFileMD5().hex()
    ret = []
    ret.append(f'rule a_{md5}_{safe_name}')
    ret.append('{')
    ret.append('  meta:')
    ret.append(f'    sample_md5 = "{md5}"')
    ret.append(f'    function_address = "0x{fva}"')
    ret.append(f'    function_name = "{name}"')
    ret.append('  strings:')
    for rule in rules:
        formatted_rule = ' '.join(rule.masked_bytes)
        ret.append(f'    {rule.name} = {{{formatted_rule}}}')
    ret.append('  condition:')
    ret.append('    all of them')
    ret.append('}')
    return '\n'.join(ret)


def create_yara_rule_for_function(fva):
    '''
    given the address of a function, generate and format a complete YARA rule
     that matches the basic blocks.
    '''
    rules = []
    for bb in get_basic_blocks(fva):
        rule = get_basic_block_rule(bb)

        # ensure there at least MIN_BB_BYTE_COUNT
        #  non-masked bytes in the rule, or ignore it.
        # this will reduce the incidence of many very small matches.
        unmasked_count = len([b for b in rule.masked_bytes if b != '??'])
        if unmasked_count < MIN_BB_BYTE_COUNT:
            continue

        rules.append(rule)

    return format_rules(fva, rules)


def get_segment_buffer(segstart):
    '''
    fetch the bytes of the section that starts at the given address.
    if the entire section cannot be accessed, try smaller regions until it works.
    '''
    segend = idaapi.getseg(segstart).end_ea
    buf = None
    segsize = segend - segstart
    while buf is None:
        buf = idc.get_bytes(segstart, segsize)
        if buf is None:
            segsize -= 0x1000
    return buf


Segment = namedtuple('Segment', ['start', 'size', 'name', 'buf'])


def get_segments():
    '''
    fetch the segments in the current executable.
    '''
    for segstart in idautils.Segments():
         segend = idaapi.getseg(segstart).end_ea
         segsize = segend - segstart
         segname = str(idc.SegName(segstart)).rstrip('\x00')
         segbuf = get_segment_buffer(segstart)
         yield Segment(segstart, segend, segname, segbuf)


class TestDidntRunError(Exception):
    pass


def test_yara_rule(rule):
    '''
    try to match the given rule against each segment in the current exectuable.
    raise TestDidntRunError if its not possible to import the YARA library.
    return True if there's at least one match, False otherwise.
    '''
    try:
        import yara
    except ImportError:
        logger.warning("can't test rule: failed to import python-yara")
        raise TestDidntRunError('python-yara not available')

    r = yara.compile(source=rule)

    for segment in get_segments():
        matches = r.match(data=segment.buf)
        if len(matches) > 0:
            logger.info('generated rule matches section: {segment.name}')
            return True
    return False


def main():
    va = idc.get_screen_ea()
    fva = get_function(va)
    print(('-' * 80))
    rule = create_yara_rule_for_function(fva)
    print(rule)

    '''
    if test_yara_rule(rule):
        print('success: validated the generated rule')
    else:
        print('error: failed to validate generated rule')
    '''


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)
    logging.getLogger().setLevel(logging.DEBUG)
    main()

```

`setup.py`:

```py
#!/usr/bin/env python


import setuptools

setup(name='idawilli',
      version='0.1',
      description='IDA Pro resources, scripts, and configurations.',
      author='Willi Ballenthin',
      author_email='william.ballenthin@fireeye.com',
      license='Apache License (2.0)',
      packages=setuptools.find_packages(),
      classifiers = ["Programming Language :: Python",
                     "Programming Language :: Python :: 2",
                     "Operating System :: OS Independent",
                     "License :: OSI Approved :: Apache Software License"],
     install_requires=[
         'pytest',
     ],
 )


```

`tests/readme.md`:

```md
# tests

here is the code that demonstrates that the `idawilli` module works as advertised.
to run, execute the `test_all.py` IDAPython script within IDA Pro.

```

`tests/test_all.py`:

```py
import os
import logging

import idc
import idaapi
import pytest

import idawilli


logger = logging.getLogger(__name__)


def main():
    logging.basicConfig(level=logging.DEBUG)
    logging.getLogger().setLevel(logging.DEBUG)

    pytest.main(['--capture=sys', os.path.dirname(__file__)])


if __name__ == '__main__':
    main()

```

`themes/colors/adwaita-dark/adwaita-dark.clr`:

```clr
[DISASM]
000000	 //
ff0000	 //Default color
a46534	 //Regular comment
808080	 //Repeatable comment
808080	 //Automatic comment
36342e	 //Instruction
800000	 //Dummy Data Name
a46534	 //Regular Data Name
a46534	 //Demangled Name
800000	 //Punctuation
069a4e	 //Char constant in instruction
00ff00	 //String constant in instruction
069a4e	 //Numeric constant in instruction
2929ef	 //Void operand
069a4e	 //Code reference
ff8080	 //Data reference
0000ff	 //Code reference to tail byte
008080	 //Data reference to tail byte
010101	 //Error or problem
c0c0c0	 //Line prefix
a46534	 //Binary line prefix bytes
a46534	 //Extra line
ff0000	 //Alternative operand
808080	 //Hidden name
ff8080	 //Library function name
008000	 //Local variable name
800000	 //Dummy code name
a46534	 //Assembler directive
800080	 //Macro
069a4e	 //String constant in data directive
008000	 //Char constant in data directive
069a4e	 //Numeric constant in data directive
800000	 //Keywords
800000	 //Register name
2929ef	 //Imported name
008080	 //Segment name
800000	 //Dummy unknown name
cf9f72	 //Regular code name
800000	 //Regular unknown name
a46534	 //Collapsed line
000000	 //Max color number
cfd7d3	 //Line prefix: library function
eceeee	 //Line prefix: regular function
ffff00	 //Line prefix: instruction
000000	 //Line prefix: data
000080	 //Line prefix: unexplored
808080	 //Line prefix: externs
008080	 //Line prefix: current item
2929ef	 //Line prefix: current line
000000	 //Punctuation
ff0000	 //Opcode bytes
000000	 //Manual operand
[NAVBAR]
ffffaa	 //Library function
e8a200	 //Regular function
577ab9	 //Instruction
c0c0c0	 //Data item
6bb6b6	 //Unexplored
ffa6ff	 //External symbol
5b5bff	 //Errors
000000	 //Gaps
7fffff	 //Cursor
00aaff	 //Address
[DEBUG]
ffd060	 //Current IP
ffa0a0	 //Current IP (Enabled)
408020	 //Current IP (Disabled)
ffffcc	 //Current IP (Unavailible)
0000ff	 //Address
00ff00	 //Address (Enabled)
004080	 //Address (Disabled)
0080ff	 //Address (Unavailible)
000000	 //Registers
ff0000	 //Registers (Changed)
800080	 //Registers (Edited)
[ARROW]
c0c0c0	 //Jump in current function
0000ff	 //Jump external to function
000000	 //Jump under the cursor
008000	 //Jump target
ff4040	 //Register target
[GRAPH]
292723	 //Top color
292723	 //Bottom color
535755	 //Normal title
9c5d21	 //Selected title
9c5d21	 //Current title
00ffff	 //Group frame
000000	 //Node shadow
ffffcc	 //Highlight color 1
ccffcc	 //Highlight color 2
0000ff	 //Foreign node
ff0000	 //Normal edge
008000	 //Yes edge
0000ff	 //No edge
ff00ff	 //Highlighted edge
ffff00	 //Current edge
[MISC]
eceeee	 //Message text
ffffff	 //Message background
404080	 //Patched bytes
0080ff	 //Unsaved changes
[OTHER]
4fe9fc	 //Highlight color
eceeee	 //Hint color
[SYNTAX]
cf9f72	1	0	 //Keyword 1
cf9f72	1	0	 //Keyword 2
0000cc	1	0	 //Keyword 3
2929ef	0	0	 //String
069a4e	1	1	 //Comment
cf9f72	1	0	 //Preprocessor
8b8b00	1	0	 //Number

```

`themes/colors/adwaita-dark/readme.md`:

```md
# adwaita-dark

a color theme based on gnome3's adwaita-dark variant.
use with the corresponding skin.


## screenshot

![screenshot](screenshot.png?raw=true "adwaita-dark")


## colors

```
background      #33393b
background (med)   #919494
background (light) #eeeeec
dark            #2E3436
dark (light)    #555753
red             #CC0000
red (light)     #EF2929
green           #4E9A06
green (light)   #8AE234
yellow          #C4A000
yellow (light)  #FCE94F
blue            #3465A4
blue (light)    #729FCF
purple          #75507B
purple (light)  #AD7FA8
cyan            #06989A
cyan (light)    #34E2E2
light           #D3D7CF
light (light)   #EEEEEC
```


```

`themes/colors/readme.md`:

```md
# colors

these are color themes.
install them using `options->colors->import`.

```

`themes/colors/willi/theme.css`:

```css

AskText QLabel#counterlabel
{
    color: grey;
}

AskText QLabel#counterlabel[invalid=true]
{
    color: red;
}

/* make that guy behave as if it were a regular widget, by killing the default QGroupBox spacing */
LabeledWidgetContainer
{
    border: 0;
    padding: 0;
}

QSplitter::handle:horizontal
{
    width: 4px;
}

QSplitter::handle:vertical
{
    height: 4px;
}

DockWidgetTitleButton:!hover
{
    border: none;
}

ActionsInspector QLineEdit
{
    width: 16em;
}

ActionsInspector QKeySequenceEdit
{
    width: 16em;
}

CustomIDAMemo
{
    /* misc */
    qproperty-line-fg-patched-bytes     : #804040;         /* patched bytes (brown-ish) */
    qproperty-line-fg-unsaved-changes   : #FF8000;         /* unsaved changes (orange-ish) */
    qproperty-line-bg-highlight         : #FFFF00;         /* highlighting background */
    qproperty-line-pfx-current-item     : rgba(0, 0, 0, 0);/* Line prefix: Current item (transparent by default) */
    qproperty-line-bgovl-current-line   : rgba(80, 80, 80, 0.15);    /* current line background overlay */
    qproperty-line-bgovl-trace          : rgba(255, 255, 0, 0.20);   /* Trace line background overlay */
    qproperty-line-bgovl-trace-ovl      : rgba(255, 188, 180, 0.40); /* Second trace line background overlay */
    qproperty-line-bgovl-extra-1        : rgba(80, 255, 80, 0.25);   /* Extra background overlay #1 */
    qproperty-line-bgovl-extra-2        : rgba(238, 255, 136, 0.25); /* Extra background overlay #2 */
    qproperty-line-bgovl-extra-3        : rgba(255, 170, 0, 0.4);   /* Extra background overlay #3 */

    /* graph */
    qproperty-graph-bg-top              : white;
    qproperty-graph-bg-bottom           : #E0F8FF;
    qproperty-graph-node-title-normal   : white;
    qproperty-graph-node-title-selected : #B1F9F9;
    qproperty-graph-node-title-current  : #A0CFCF;
    qproperty-graph-node-frame-group    : yellow;
    qproperty-graph-node-shadow         : black;
    qproperty-graph-node-high1          : #CCFFFF;
    qproperty-graph-node-high2          : #CCFFCC;
    qproperty-graph-node-foreign        : red;
    qproperty-graph-edge-normal         : blue;
    qproperty-graph-edge-yes            : green;
    qproperty-graph-edge-no             : red;
    qproperty-graph-edge-high           : fuchsia;
    qproperty-graph-edge-current        : cyan;

    /* bpts */
    qproperty-line-bg-bpt-enabled        : red;
    qproperty-line-bg-bpt-disabled       : lime;
    qproperty-line-bg-bpt-unavailable    : #FF8000;
}

CustomIDAMemo[debugging="true"]
{
    qproperty-line-bg-default            : #CCFFFF;
    qproperty-line-bgovl-current-ip      : rgba(0, 195, 255, .45);
}

CustomIDAMemo[hints="true"]
{
    qproperty-line-bg-default            : #FFFFE1;         /* hints background (pale yellow) */
}

TextArrows
{
    qproperty-jump-in-function          : silver;
    qproperty-jump-external-to-function : red;
    qproperty-jump-under-cursor         : black;
    qproperty-jump-target               : green;
    qproperty-register-target           : #4040FF;
    qproperty-bpt-possible              : #60D0FF;
}

MainMsgList
{
    color            : black;
    background-color : white;
}

TCpuRegs
{
    background-color: #CCFFFF;
    qproperty-register-defined: black;
    qproperty-register-changed: blue;
    qproperty-register-edited: purple;
    qproperty-register-unavailable: gray;
}

TCpuRegs QPushButton
{
    background: transparent;
}

TCpuRegs IDALabel
{
    color: blue;
}

navband_t
{
    qproperty-lib-function : #AAFFFF;
    qproperty-function : #00A2E8;
    qproperty-code : #B97A57;
    qproperty-data : silver;
    qproperty-undefined : #B6B66B;
    qproperty-extern : #FFA6FF;
    qproperty-error : #FF5B5B;
    qproperty-gap : black;
    qproperty-cursor : #FFFF7F;
    qproperty-auto-analysis-cursor : #FFAA00;
    qproperty-lumina-function : #32CD32;
}

TextEdit
{
    qproperty-keyword1-fg: blue;
    qproperty-keyword1-weight: 0;
    qproperty-keyword1-italic: 0;

    qproperty-keyword2-fg: purple;
    qproperty-keyword2-weight: 0;
    qproperty-keyword2-italic: 0;

    qproperty-keyword3-fg: red;
    qproperty-keyword3-weight: 0;
    qproperty-keyword3-italic: 0;

    qproperty-string-fg: darkred;
    qproperty-string-weight: 0;
    qproperty-string-italic: 0;

    qproperty-comment-fg: darkgreen;
    qproperty-comment-weight: 0;
    qproperty-comment-italic: 1;

    qproperty-preprocessor-fg: blue;
    qproperty-preprocessor-weight: 1;
    qproperty-preprocessor-italic: 0;

    qproperty-number-fg: darkcyan;
    qproperty-number-weight: 1;
    qproperty-number-italic: 0;
}

TextEdit text_edit_margin_widget_t
{
    color: grey;
    qproperty-header-color: dimgrey;
}

TChooser
{
    qproperty-highlight-bg-default: yellow;
    qproperty-highlight-bg-selected: #00C0C0;
}


CustomIDAMemo
{
    qproperty-line-fg-default                     : blue;        /* Default                                       */
    qproperty-line-fg-regular-comment             : blue;        /* Regular comment                               */
    qproperty-line-fg-repeatable-comment          : gray;        /* Repeatable commen                             */
    qproperty-line-fg-automatic-comment           : gray;        /* Automatic comment                             */
    qproperty-line-fg-insn                        : navy;        /* Instruction                                   */
    qproperty-line-fg-dummy-data-name             : navy;        /* Dummy Data Name                               */
    qproperty-line-fg-regular-data-name           : blue;        /* Regular Data Name                             */
    qproperty-line-fg-demangled-name              : blue;        /* Demangled Name                                */
    qproperty-line-fg-punctuation                 : navy;        /* Punctuation                                   */
    qproperty-line-fg-charlit-in-insn             : green;       /* Char constant                                 */
    qproperty-line-fg-strlit-in-insn              : lime;        /* String constant                               */
    qproperty-line-fg-numlit-in-insn              : green;       /* Numeric constant                              */
    qproperty-line-fg-void-opnd                   : #FF8000;     /* Void operand                                  */
    qproperty-line-fg-code-xref                   : green;       /* Code reference                                */
    qproperty-line-fg-data-xref                   : #8080FF;     /* Data reference                                */
    qproperty-line-fg-code-xref-to-tail           : red;         /* Code reference to tail byte                   */
    qproperty-line-fg-data-xref-to-tail           : olive;       /* Data reference to tail byte                   */
    qproperty-line-fg-error                       : #010101;     /* Error or problem                              */
    qproperty-line-fg-line-prefix                 : silver;      /* Line prefix                                   */
    qproperty-line-fg-opcode-byte                 : blue;        /* Opcode bytes                                  */
    qproperty-line-fg-extra-line                  : blue;        /* Extra line                                    */
    qproperty-line-fg-alt-opnd                    : blue;        /* Alternative operand                           */
    qproperty-line-fg-hidden                      : gray;        /* Hidden name                                   */
    qproperty-line-fg-libfunc                     : #8080FF;     /* Library function name                         */
    qproperty-line-fg-locvar                      : green;       /* Local variable name                           */
    qproperty-line-fg-dummy-code-name             : navy;        /* Dummy code name                               */
    qproperty-line-fg-asm-directive               : blue;        /* Assembler directive                           */
    qproperty-line-fg-macro                       : purple;      /* Macro                                         */
    qproperty-line-fg-strlit-in-data              : green;       /* String constant in data directive             */
    qproperty-line-fg-charlit-in-data             : green;       /* Char constant in data directive               */
    qproperty-line-fg-numlit-in-data              : #008040;     /* Numeric constant in data directive            */
    qproperty-line-fg-keyword                     : navy;        /* Keywords (offset, byte ptr, near)             */
    qproperty-line-fg-register-name               : navy;        /* Register name                                 */
    qproperty-line-fg-import-name                 : fuchsia;     /* Imported name                                 */
    qproperty-line-fg-segment-name                : olive;       /* Segment name                                  */
    qproperty-line-fg-dummy-unknown-name          : navy;        /* Dummy unknown name                            */
    qproperty-line-fg-code-name                   : blue;        /* Regular Code Name                             */
    qproperty-line-fg-unknown-name                : navy;        /* Regular Unknown Name                          */
    qproperty-line-fg-collapsed-line              : blue;        /* Collapsed line                                */
    qproperty-line-bg-default                     : white;       /* Default background                            */
    qproperty-line-bg-selected                    : #C0BBAF;     /* Selected background                           */
    qproperty-line-pfx-libfunc                    : cyan;        /* Line prefix: Library function                 */
    qproperty-line-pfx-func                       : black;       /* Line prefix: Regular function                 */
    qproperty-line-pfx-insn                       : maroon;      /* Line prefix: Single instruction               */
    qproperty-line-pfx-data                       : gray;        /* Line prefix: Data bytes                       */
    qproperty-line-pfx-unexplored                 : olive;       /* Line prefix: Unexplored byte                  */
    qproperty-line-pfx-extern                     : fuchsia;     /* Line prefix: External name definition segment */
    qproperty-line-pfx-current-line               : blue;        /* Line prefix: Current line                     */
    qproperty-line-pfx-hidden-line                : black;       /* Line prefix: Hidden line                      */
    qproperty-line-pfx-lumina                     : #32CD32;     /* Line prefix: Lumina                           */
}

```

`themes/colors/willi/user.css`:

```css
/* NOTE: This is an autogenerated file; please do not edit. */

CustomIDAMemo
{
    qproperty-line-fg-insn: #2E3436;
    qproperty-line-bg-default: #D3D7CF;
    qproperty-graph-bg-top: #232729;
    qproperty-graph-bg-bottom: #232729;
    qproperty-graph-node-title-normal: #555753;
    qproperty-graph-node-title-selected: #215D9C;
    qproperty-graph-node-title-current: #215D9C;
}

CustomIDAMemo[debugging="true"]
{
    qproperty-line-fg-insn: #2E3436;
    qproperty-graph-bg-top: #232729;
    qproperty-graph-bg-bottom: #232729;
    qproperty-graph-node-title-normal: #555753;
    qproperty-graph-node-title-selected: #215D9C;
    qproperty-graph-node-title-current: #215D9C;
}

CustomIDAMemo[hints="true"]
{
    qproperty-line-fg-insn: #2E3436;
    qproperty-graph-bg-top: #232729;
    qproperty-graph-bg-bottom: #232729;
    qproperty-graph-node-title-normal: #555753;
    qproperty-graph-node-title-selected: #215D9C;
    qproperty-graph-node-title-current: #215D9C;
}
```

`themes/skins/adwaita-dark/manifest.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<theme name="adwaita-dark"
	author="williballenthin"
	version="v1.0"
	preview_image="preview.png"
	notes="Combine with Gnome3 adwaita theme and IDA Pro adwaita-dark color style">
</theme>

```

`themes/skins/adwaita-dark/readme.md`:

```md
# adwaita-dark

an IDA Pro skin based on gnome3's adwaita-dark variant.
use with the corresponding color theme.


## screenshot

![screenshot](preview.png?raw=true "adwaita-dark")


## colors

```
  color palatte:

  (darkest)
   dark-0, light-7    #1B1F20
   dark-1, light-6    #2D3234
   dark-2, light-5    #2E3436
   dark-3, light-4    #33393B
   dark-4, light-3    #919494
   dark-5, light-2    #D3D7CF
   dark-6, light-1    #EEEEEC
   dark-7, light-0    #FFFFFF
  (lightest)

   accent    #215D9C
```

```

`themes/skins/adwaita-dark/stylesheet.qss`:

```qss
/***
  color palatte:

  (darkest)
   dark-0, light-7    #1B1F20
   dark-1, light-6    #2D3234
   dark-2, light-5    #2E3436
   dark-3, light-4    #33393B
   dark-4, light-3    #919494
   dark-5, light-2    #D3D7CF
   dark-6, light-1    #EEEEEC
   dark-7, light-0    #FFFFFF
  (lightest)

   accent    #215D9C
*/


QWidget {
    /* dark-3 */
    background-color: #33393B;

    /* light-1 */
    color: #EEEEEC;
}

QCheckBox {
    /* light-1 */
    background-color: #EEEEEC;
}

QTextEdit {
    border-radius: 2px;

    /* dark-1 */
    background-color: #2D3234;

    /* dark-0 */
    border: 1px solid #1B1F20;
}

QMenuBar {
    /* dark-3 */
    background-color: #33393B;
}

QMenuBar::item {
    /* dark-2 */
    background-color: #2E3436;
}


QMenu::item:selected {
    /* accent */
    background-color: #215D9C;
}

QLineEdit {
    min-height: 20px;
    border-radius: 2px;

    /* dark-0 */
    border: 1px solid #1B1F20;
}

QLineEdit:focus {
    /* accent */
    border: 1px solid #215D9C;
}

QTabBar::tab {
    /* dark-2 */
    background-color: #2E3436;
}

QTabBar::tab:selected {
    /* dark-2 */
    background-color: #2E3436;

    /* accent */
    border-bottom: 2px solid #215D9C;
}

QHeaderView::section {
    /* dark-2 */
    background-color: #2E3436;

    /* dark-1 */
    border-left: 3px solid #2D3234;
}

QTableView {
    /* dark-0 */
    border: 1px solid #1B1F20;

    /* dark-1 */
    background-color: #2D3234;
}

QTableCornerButton::section {
    /* dark-1 */
    background: #2D3234;

    /* dark-0 */
    border: 2px outset #00000;
 }

IDAView, hexview_t, CustomIDAMemo {
    border: none;
}

CustomIDAMemo, EditContainer {
    font-family: "<TEXT_INPUT_FONT_FAMILY>";
    font-size: <TEXT_INPUT_FONT_SIZE>;
    font-style: <TEXT_INPUT_FONT_STYLE>;
    font-weight: <TEXT_INPUT_FONT_WEIGHT>;
}

IDAView {
    font-family: "<DISASSEMBLY_FONT_FAMILY>";
    font-size: <DISASSEMBLY_FONT_SIZE>;
    font-style: <DISASSEMBLY_FONT_STYLE>;
    font-weight: <DISASSEMBLY_FONT_WEIGHT>;
}

hexview_t {
    font-family: "<HEXVIEW_FONT_FAMILY>";
    font-size: <HEXVIEW_FONT_SIZE>;
    font-style: <HEXVIEW_FONT_STYLE>;
    font-weight: <HEXVIEW_FONT_WEIGHT>;
}

/* TODO: DEBUG_REGISTERS, OUTPUT_WINDOW */

QScrollBar {
    width: 10px;
    margin: 0 0 0 0;

    /* dark-3 */
    background-color: #33393B;
}

QScrollBar::sub-line, QScrollBar::add-line {
    width: 0;
    height: 0;
}

QScrollBar::add-page, QScrollBar::sub-page {
    background: none;
}

QScrollBar::handle:vertical {
    min-height: 20px;
}

QScrollBar::handle:horizontal {
    min-width: 20px;
}

QScrollBar::handle {
    /* light-3 */
    background-color: #919494;
    margin: 3px;
    border-radius: 3px;
}

QToolBar {
    border: none;
}

QPushButton {
    text-align: center;
    min-height: 20px;
    min-width: 50px;
    padding: 0 6px 0 6px;
    border-radius: 2px;

    /* dark-0 */
    border: 1px solid #1B1F20;
}

QPushButton:hover, QPushButton:default {
    /* dark-1 */
    border: 1px solid #2D3234;
}

QPushButton:pressed {
    /* accent */
    border: 1px solid #215D9C;
}

QComboBox {
    border-radius: 2px;

    /* dark-0 */
    border: 1px solid #1B1F20;
}

QComboBox > QLineEdit, QComboBox > QLineEdit:hover, QComboBox > QLineEdit:focus {
    border: none;
    min-height: default;
}

QComboBox:focus {
    /* accent */
    border: 1px solid #215D9C;
}

QComboBox::drop-down {
    subcontrol-origin: padding;
    subcontrol-position: top right;
    width: 15px;

    border-left-width: 1px;
    border-left-style: solid;
    /* accent? */
    border-left-color: #215D9C;
}

QComboBox::down-arrow {
    image: url(<SKINDIR>/icons/expand.png);
}

/* Close, maximize and undock button for dock widgets */
IDADockWidget > QWidget > QAbstractButton {
    /* no border */
}

QRadioButton, QLabel, QCheckBox {
    background: transparent;
}

TNavBand > QPushButton, RegJumpButton {
    min-height: 0;
    min-width: 0;
    padding: 0 0 0 0;
    border: none;
}

EditContainer, ChooserContainer, QGroupBox, QListView, QTreeView {
    border-radius: 2px;

    /* dark-0 */
    border: 1px solid #1B1F20;
}

QGroupBox {
    margin-top: 5px;
}

QGroupBox::title {
    subcontrol-origin: margin;
    subcontrol-position: top center;
}

/* Remove border from IDC/Python switch button */
CLIWidget > QGroupBox > QPushButton,
CLIWidget > QGroupBox > QPushButton:hover,
CLIWidget > QGroupBox > QPushButton:focus {
    border: none;
}

CLIWidget > QGroupBox {
    margin-top: 0;
}

QTreeView::item:selected, QListView::item:selected, QTableView::item:selected {
    /* accent */
    background-color: #215D9C;
}

```

`themes/skins/readme.md`:

```md
# skins

skins you can use with the [zyantific/IDASkins](https://github.com/zyantific/IDASkins) plugin.

```

`themes/skins/vscode-dark-wb/adwaita-dark.clr`:

```clr
[DISASM]
000000	 //
ff0000	 //Default color
a46534	 //Regular comment
808080	 //Repeatable comment
808080	 //Automatic comment
36342e	 //Instruction
800000	 //Dummy Data Name
a46534	 //Regular Data Name
a46534	 //Demangled Name
800000	 //Punctuation
069a4e	 //Char constant in instruction
00ff00	 //String constant in instruction
069a4e	 //Numeric constant in instruction
2929ef	 //Void operand
069a4e	 //Code reference
ff8080	 //Data reference
0000ff	 //Code reference to tail byte
008080	 //Data reference to tail byte
010101	 //Error or problem
c0c0c0	 //Line prefix
a46534	 //Binary line prefix bytes
a46534	 //Extra line
ff0000	 //Alternative operand
808080	 //Hidden name
ff8080	 //Library function name
008000	 //Local variable name
800000	 //Dummy code name
a46534	 //Assembler directive
800080	 //Macro
069a4e	 //String constant in data directive
008000	 //Char constant in data directive
069a4e	 //Numeric constant in data directive
800000	 //Keywords
800000	 //Register name
2929ef	 //Imported name
008080	 //Segment name
800000	 //Dummy unknown name
cf9f72	 //Regular code name
800000	 //Regular unknown name
a46534	 //Collapsed line
000000	 //Max color number
cfd7d3	 //Line prefix: library function
eceeee	 //Line prefix: regular function
ffff00	 //Line prefix: instruction
000000	 //Line prefix: data
000080	 //Line prefix: unexplored
808080	 //Line prefix: externs
008080	 //Line prefix: current item
2929ef	 //Line prefix: current line
000000	 //Punctuation
ff0000	 //Opcode bytes
000000	 //Manual operand
[NAVBAR]
ffffaa	 //Library function
e8a200	 //Regular function
577ab9	 //Instruction
c0c0c0	 //Data item
6bb6b6	 //Unexplored
ffa6ff	 //External symbol
5b5bff	 //Errors
000000	 //Gaps
7fffff	 //Cursor
00aaff	 //Address
[DEBUG]
ffd060	 //Current IP
ffa0a0	 //Current IP (Enabled)
408020	 //Current IP (Disabled)
ffffcc	 //Current IP (Unavailible)
0000ff	 //Address
00ff00	 //Address (Enabled)
004080	 //Address (Disabled)
0080ff	 //Address (Unavailible)
000000	 //Registers
ff0000	 //Registers (Changed)
800080	 //Registers (Edited)
[ARROW]
c0c0c0	 //Jump in current function
0000ff	 //Jump external to function
000000	 //Jump under the cursor
008000	 //Jump target
ff4040	 //Register target
[GRAPH]
292723	 //Top color
292723	 //Bottom color
535755	 //Normal title
9c5d21	 //Selected title
9c5d21	 //Current title
00ffff	 //Group frame
000000	 //Node shadow
ffffcc	 //Highlight color 1
ccffcc	 //Highlight color 2
0000ff	 //Foreign node
ff0000	 //Normal edge
008000	 //Yes edge
0000ff	 //No edge
ff00ff	 //Highlighted edge
ffff00	 //Current edge
[MISC]
eceeee	 //Message text
1e1e1e	 //Message background
404080	 //Patched bytes
0080ff	 //Unsaved changes
[OTHER]
4fe9fc	 //Highlight color
eceeee	 //Hint color
[SYNTAX]
cf9f72	1	0	 //Keyword 1
cf9f72	1	0	 //Keyword 2
0000cc	1	0	 //Keyword 3
2929ef	0	0	 //String
069a4e	1	1	 //Comment
cf9f72	1	0	 //Preprocessor
8b8b00	1	0	 //Number

```

`themes/skins/vscode-dark-wb/manifest.json`:

```json
{
    "theme_name": "VSCode dark (wb)",
    "author": "Microsoft (ported by jinmo, edit by wb)",
    "version": "v0.1",
    "preview_image": "preview.png",
    "clr_file": "adwaita-dark.clr",
    "qss_file": "stylesheet.qss"
}
```

`themes/skins/vscode-dark-wb/stylesheet.less`:

```less
@text : #D4D4D4;
@border       : #ccc;
@text_lighter : #fff;
@text_light   : #e7e7e7;
@sans_serif   : 'Segoe UI',
'Helvetica Neue';
@monospace : 'Consolas',
'Menlo';

@tab_font_size: 14px;
@ui_font_size : 14px;

@background_primary : #1E1E1E;
@background_menu    : #252526;
@background_color_4 : #3C3C3C;
@background_color_5 : #333;
@background_color_6 : #505050;
@background_color_7 : #2D3234;
@background_color_9 : #2D2D2D;
@background_color_11: rgba(121, 121, 121, 0.4);
@background_color_12: rgba(100, 100, 100, 0.7);
@background_color_13: #094771;

.disasm-font {
    font-family: "<DISASSEMBLY_FONT_FAMILY>";
    font-size  : <DISASSEMBLY_FONT_SIZE>;
    font-style : <DISASSEMBLY_FONT_STYLE>;
    font-weight: <DISASSEMBLY_FONT_WEIGHT>;
}

.hexview-font {
    font-family: "<HEXVIEW_FONT_FAMILY>";
    font-size  : <HEXVIEW_FONT_SIZE>;
    font-style : <HEXVIEW_FONT_STYLE>;
    font-weight: <HEXVIEW_FONT_WEIGHT>;
}

.text-input-font {
    font-family: "<TEXT_INPUT_FONT_FAMILY>";
    font-size  : <TEXT_INPUT_FONT_SIZE>;
    font-style : <TEXT_INPUT_FONT_STYLE>;
    font-weight: <TEXT_INPUT_FONT_WEIGHT>;
}

/* Common properties */
QWidget {
    background-color: @background_primary;
    color           : @text;
}

IDAView {
    border       : none;
    border-bottom: 1px solid #414141;
    .disasm-font;
}

hexview_t {
    border: none;
    .hexview-font;
}

CustomIDAMemo {
    border: none;
    .text-input-font;
}

QToolBar {
    /* Toolbar */
    background-color: @background_color_5;
    border          : none;
    padding         : 8px;
    spacing         : 8px;

    &:active {
        background-color: @background_color_4;
    }

    QWidget {
        background: transparent;
    }

    &:handle {
        image        : url(<SKINDIR>/icons/drag.png);
        padding-right: 10px;
        padding-left : 0;
        width        : 10px;
    }
}

IDAMainWindow {
    >QStatusBar {
        &:item {
            border: none;
        }

        QWidget {
            font-family : @monospace;
            color       : @text_lighter;
            padding-left: 17px;
        }

        min-height  : 0;
        height      : 27px;
        padding-left: 7px;
        background  : #007acc;
    }
}

QPushButton {
    /* Buttons */
    font-family: @sans_serif;
    text-align : center;
    min-height : 20px;
    min-width  : 50px;
    border     : none;
    background : #0e639c;
    padding    : 2px 14px;

    &:hover {
        background: #17b;
        border    : 1px solid #2D3234;
    }

    &:default {
        border: 1px solid #2D3234;
    }

    &:pressed {
        border: 1px solid #215D9C;
    }
}

QTreeView {
    font-family: @sans_serif;
    border     : 1px solid #1B1F20;

    &:item {
        font-family: @sans_serif;
        font-size  : @ui_font_size;
        height     : 27.5px;

        &:selected {
            background-color: @background_color_13;
        }
    }
}

QLineEdit {
    /* Single line edit */
    font-family: @sans_serif;
    border     : 1px solid transparent;
    background : #272727;
    color      : @border;
    padding    : 4px;

    &:focus {
        border: 1px solid #135785;
    }
}

/* Dock widget without tabs */
QTabBar {
    font-family     : @sans_serif;
    background-color: @background_menu;

    &:tab {
        border-right    : 1px solid #252526;
        background-color: @background_color_9;
        height          : 43px;
        text-transform  : uppercase;
        font-size       : @tab_font_size;
        padding-left    : 16px;
        padding-right   : 16px;

        &:selected {
            background-color: @background_primary;
        }
    }

    &:close-button {
        &:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        &:pressed {
            icon-size: 24px;
            padding  : 1px -1px -1px 1px;
        }

        /* For toolbar */
        image    : url(<SKINDIR>/icons/close.png);
        icon-size: 20px;
        padding  : 0px;
    }
}

QMenuBar {
    /* Menu bar & items */
    font-family     : @sans_serif;
    background-color: @background_color_5;
    padding-left    : 2px;

    &:active {
        background-color: @background_color_4;
    }

    &:item {
        background: transparent;
        color     : @border;
        padding   : 8px 9px;

        &:selected {
            background-color: @background_color_6;
        }
    }
}

QTableView {
    /* Table and headers */
    font-family     : @sans_serif;
    border          : 1px solid #1B1F20;
    background-color: @background_menu;

    &:item {
        font-family: @sans_serif;
        font-size  : @ui_font_size;
        height     : 27.5px;

        &:selected {
            border          : none !important;
            background-color: @background_color_13;
        }
    }

    &:section {
        &:item {
            background: #1e1e1e !important;
        }
    }

    QHeaderView {
        &:section {
            background-color: @background_color_9;
            border          : none;

            &:horizontal {
                padding    : 5px;
                border-left: 1px solid #2D3234;
            }

            &:vertical {
                padding   : 0;
                background: transparent;
            }
        }
    }

    QTableCornerButton {
        &:section {
            background: #2D3234;
            border    : 0px outset #000;
        }
    }
}

QListView {
    &:item {
        font-family: @sans_serif;
        font-size  : @ui_font_size;
        height     : 27.5px;

        &:selected {
            background-color: @background_color_13;
        }
    }

    border: 1px solid #1B1F20;
}

QCheckBox {
    background-color: @text;
}

QCheckBox,
QLabel,
QRadioButton {
    background: transparent;
}

QMenu {
    background-color: @background_menu;
    padding-bottom  : 8px;

    &:item {
        font-weight: 400;
        padding    : 6px 40px 3px 40px;

        &:selected {
            background-color: @background_color_13;
        }
    }

    &:right-arrow {
        image : url(<SKINDIR>/icons/menu.png);
        margin: 5px 15px 5px 5px;
    }

    &:icon {
        padding-left: 20px;
    }

    &:separator {
        height    : 1px;
        background: #616162;
        width     : 1px;
        margin    : 6px;
    }
}

QComboBox {
    /* Combobox which is editable or not editable */
    background: #3c3c3c;
    border    : 1px solid #1B1F20;
    padding   : 4px;

    &:focus,
    &:on {
        border: 1px solid #135785;
        border: 1px solid transparent;
    }

    &:editable {
        border: 1px solid transparent;
    }

    QLineEdit {
        background: transparent;
        border    : 0;
        padding   : 0;
    }

    &:drop-down {
        subcontrol-origin  : padding;
        subcontrol-position: top right;
        border             : none;
        width              : 20px;

        &:editable {
            subcontrol-origin  : padding;
            subcontrol-position: top right;
            border             : none;
            width              : 20px;
        }
    }

    &:down-arrow {
        image : url(<SKINDIR>/icons/expand.png);
        margin: 0;
    }

    >QLineEdit {
        border    : none;
        min-height: default;

        &:hover {
            border    : none;
            min-height: default;
        }

        &:focus {
            border    : none;
            min-height: default;
        }
    }

    QAbstractItemView {
        background                : rgb(60, 60, 60);
        outline                   : none;
        selection-background-color: rgb(6, 47, 74);
    }

    &:focus {
        border: 1px solid #215D9C;
    }

    QLineEdit {
        &:focus {
            border-right: none;
        }
    }
}

QTextEdit {
    /* Multiple line edit */
    background-color: @background_color_7;
    border          : 1px solid #1B1F20;
}

TNavBand>QPushButton,
nav_scroll_button_t {
    border       : none;
    background   : transparent;
    min-height   : default;
    min-width    : default;
    padding      : default;
    border-radius: default;
}

RegJumpButton {
    min-height: 0;
    min-width : 0;
    border    : none;
    padding   : 0;
}

/* Dock widget which has tabs */
DockWidgetTitle {
    font          : @ui_font_size @sans_serif;
    background    : #252526;
    text-transform: uppercase;
    min-height    : 0px;
    height        : 43px;
    padding       : 0px 5px 0px 5px;
    border        : none;

    DockWidgetTitleButton {
        &:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        color     : @text_lighter;
        background: transparent;
        border    : none;
        min-height: 0;
        min-width : 0;
        margin    : 0;
        padding   : 0;

        &[toolTip="Close"] {
            qproperty-icon: url(<SKINDIR>/icons/close.png);
            icon-size     : 20px;
        }

        &[toolTip="Fullscreen"] {
            qproperty-icon: url(<SKINDIR>/icons/fullscreen.png);
            icon-size     : 20px;
        }

        &[toolTip="Float"] {
            qproperty-icon: url(<SKINDIR>/icons/float.png);
            icon-size     : 20px;
        }

    }

}

EditContainer {
    border: 1px solid #1B1F20;
    .text-input-font;
}

QScrollBar {
    /* Scrollbar */
    background-color: @background_primary;
    border          : 0px solid #383838;
    margin          : 0;
    padding         : 0;

    &:horizontal {
        border-top-width: 1px;
        height          : 12px;
    }

    &:vertical {
        border-left-width: 1px;
        width            : 12px;
    }

    &:sub-line {
        width : 0;
        height: 0;
    }

    &:add-line {
        width : 0;
        height: 0;
    }

    &:add-page {
        background: none;
        width     : 0;
        height    : 0;
    }

    &:sub-page {
        background: none;
        width     : 0;
        height    : 0;
    }

    &:handle {
        &:vertical {
            min-height: 20px;
        }

        &:horizontal {
            min-width: 20px;
        }

        background-color: @background_color_11;

        &:hover {
            background-color: @background_color_12;
        }
    }
}

ChooserContainer {
    border: 1px solid #1B1F20;
}

QGroupBox {
    border    : 1px solid #1B1F20;
    margin-top: 5px;

    &:title {
        subcontrol-origin  : margin;
        subcontrol-position: top center;
    }
}

TextArrows {
    border-bottom: 1px solid #414141;
}

IDADockWidget[objectName="Output window"] {
    /* Output window */
    qproperty-windowIcon: url(<SKINDIR>/icons/blank.png);

    DockWidgetTitle {
        background: #1e1e1e;
        color     : @text_light;
        margin    : 0;
    }

    QTextEdit {
        &:focus {
            border: 1px solid #215D9C;
        }
    }

    QLineEdit {
        padding-bottom: 2px;
    }

    QGroupBox {
        QPushButton {
            border        : none;
            text-transform: uppercase;
            min-width     : 70px;

            &:hover {
                border: none;
            }

            &:focus {
                border: none;
            }
        }

        margin  : 0;
        padding : 0;
        border  : none;
    }

}
```

`themes/skins/vscode-dark-wb/stylesheet.qss`:

```qss
.disasm-font {
  font-family: "<DISASSEMBLY_FONT_FAMILY>";
  font-size: <DISASSEMBLY_FONT_SIZE>;
  font-style: <DISASSEMBLY_FONT_STYLE>;
  font-weight: <DISASSEMBLY_FONT_WEIGHT>;
}
.hexview-font {
  font-family: "<HEXVIEW_FONT_FAMILY>";
  font-size: <HEXVIEW_FONT_SIZE>;
  font-style: <HEXVIEW_FONT_STYLE>;
  font-weight: <HEXVIEW_FONT_WEIGHT>;
}
.text-input-font {
  font-family: "<TEXT_INPUT_FONT_FAMILY>";
  font-size: <TEXT_INPUT_FONT_SIZE>;
  font-style: <TEXT_INPUT_FONT_STYLE>;
  font-weight: <TEXT_INPUT_FONT_WEIGHT>;
}
/* Common properties */
QWidget {
  background-color: #1E1E1E;
  color: #D4D4D4;
}
IDAView {
  border: none;
  border-bottom: 1px solid #414141;
  font-family: "<DISASSEMBLY_FONT_FAMILY>";
  font-size: <DISASSEMBLY_FONT_SIZE>;
  font-style: <DISASSEMBLY_FONT_STYLE>;
  font-weight: <DISASSEMBLY_FONT_WEIGHT>;
}
hexview_t {
  border: none;
  font-family: "<HEXVIEW_FONT_FAMILY>";
  font-size: <HEXVIEW_FONT_SIZE>;
  font-style: <HEXVIEW_FONT_STYLE>;
  font-weight: <HEXVIEW_FONT_WEIGHT>;
}
CustomIDAMemo {
  border: none;
  font-family: "<TEXT_INPUT_FONT_FAMILY>";
  font-size: <TEXT_INPUT_FONT_SIZE>;
  font-style: <TEXT_INPUT_FONT_STYLE>;
  font-weight: <TEXT_INPUT_FONT_WEIGHT>;
}
QToolBar {
  /* Toolbar */
  background-color: #333;
  border: none;
  padding: 8px;
  spacing: 8px;
}
QToolBar:active {
  background-color: #3C3C3C;
}
QToolBar QWidget {
  background: transparent;
}
QToolBar:handle {
  image: url(<SKINDIR>/icons/drag.png);
  padding-right: 10px;
  padding-left: 0;
  width: 10px;
}
IDAMainWindow > QStatusBar {
  min-height: 0;
  height: 27px;
  padding-left: 7px;
  background: #007acc;
}
IDAMainWindow > QStatusBar:item {
  border: none;
}
IDAMainWindow > QStatusBar QWidget {
  font-family: 'Consolas', 'Menlo';
  color: #fff;
  padding-left: 17px;
}
QPushButton {
  /* Buttons */
  font-family: 'Segoe UI', 'Helvetica Neue';
  text-align: center;
  min-height: 20px;
  min-width: 50px;
  border: none;
  background: #0e639c;
  padding: 2px 14px;
}
QPushButton:hover {
  background: #17b;
  border: 1px solid #2D3234;
}
QPushButton:default {
  border: 1px solid #2D3234;
}
QPushButton:pressed {
  border: 1px solid #215D9C;
}
QTreeView {
  font-family: 'Segoe UI', 'Helvetica Neue';
  border: 1px solid #1B1F20;
}
QTreeView:item {
  font-family: 'Segoe UI', 'Helvetica Neue';
  font-size: 14px;
  height: 27.5px;
}
QTreeView:item:selected {
  background-color: #094771;
}
QLineEdit {
  /* Single line edit */
  font-family: 'Segoe UI', 'Helvetica Neue';
  border: 1px solid transparent;
  background: #272727;
  color: #ccc;
  padding: 4px;
}
QLineEdit:focus {
  border: 1px solid #135785;
}
/* Dock widget without tabs */
QTabBar {
  font-family: 'Segoe UI', 'Helvetica Neue';
  background-color: #252526;
}
QTabBar:tab {
  border-right: 1px solid #252526;
  background-color: #2D2D2D;
  height: 43px;
  text-transform: uppercase;
  font-size: 14px;
  padding-left: 16px;
  padding-right: 16px;
}
QTabBar:tab:selected {
  background-color: #1E1E1E;
}
QTabBar:close-button {
  /* For toolbar */
  image: url(<SKINDIR>/icons/close.png);
  icon-size: 20px;
  padding: 0px;
}
QTabBar:close-button:hover {
  background: rgba(255, 255, 255, 0.1);
}
QTabBar:close-button:pressed {
  icon-size: 24px;
  padding: 1px -1px -1px 1px;
}
QMenuBar {
  /* Menu bar & items */
  font-family: 'Segoe UI', 'Helvetica Neue';
  background-color: #333;
  padding-left: 2px;
}
QMenuBar:active {
  background-color: #3C3C3C;
}
QMenuBar:item {
  background: transparent;
  color: #ccc;
  padding: 8px 9px;
}
QMenuBar:item:selected {
  background-color: #505050;
}
QTableView {
  /* Table and headers */
  font-family: 'Segoe UI', 'Helvetica Neue';
  border: 1px solid #1B1F20;
  background-color: #252526;
}
QTableView:item {
  font-family: 'Segoe UI', 'Helvetica Neue';
  font-size: 14px;
  height: 27.5px;
}
QTableView:item:selected {
  border: none !important;
  background-color: #094771;
}
QTableView:section:item {
  background: #1e1e1e !important;
}
QTableView QHeaderView:section {
  background-color: #2D2D2D;
  border: none;
}
QTableView QHeaderView:section:horizontal {
  padding: 5px;
  border-left: 1px solid #2D3234;
}
QTableView QHeaderView:section:vertical {
  padding: 0;
  background: transparent;
}
QTableView QTableCornerButton:section {
  background: #2D3234;
  border: 0px outset #000;
}
QListView {
  border: 1px solid #1B1F20;
}
QListView:item {
  font-family: 'Segoe UI', 'Helvetica Neue';
  font-size: 14px;
  height: 27.5px;
}
QListView:item:selected {
  background-color: #094771;
}
QCheckBox {
  background-color: #D4D4D4;
}
QCheckBox,
QLabel,
QRadioButton {
  background: transparent;
}
QMenu {
  background-color: #252526;
  padding-bottom: 8px;
}
QMenu:item {
  font-weight: 400;
  padding: 6px 40px 3px 40px;
}
QMenu:item:selected {
  background-color: #094771;
}
QMenu:right-arrow {
  image: url(<SKINDIR>/icons/menu.png);
  margin: 5px 15px 5px 5px;
}
QMenu:icon {
  padding-left: 20px;
}
QMenu:separator {
  height: 1px;
  background: #616162;
  width: 1px;
  margin: 6px;
}
QComboBox {
  /* Combobox which is editable or not editable */
  background: #3c3c3c;
  border: 1px solid #1B1F20;
  padding: 4px;
}
QComboBox:focus,
QComboBox:on {
  border: 1px solid #135785;
  border: 1px solid transparent;
}
QComboBox:editable {
  border: 1px solid transparent;
}
QComboBox QLineEdit {
  background: transparent;
  border: 0;
  padding: 0;
}
QComboBox:drop-down {
  subcontrol-origin: padding;
  subcontrol-position: top right;
  border: none;
  width: 20px;
}
QComboBox:drop-down:editable {
  subcontrol-origin: padding;
  subcontrol-position: top right;
  border: none;
  width: 20px;
}
QComboBox:down-arrow {
  image: url(<SKINDIR>/icons/expand.png);
  margin: 0;
}
QComboBox > QLineEdit {
  border: none;
  min-height: default;
}
QComboBox > QLineEdit:hover {
  border: none;
  min-height: default;
}
QComboBox > QLineEdit:focus {
  border: none;
  min-height: default;
}
QComboBox QAbstractItemView {
  background: #3c3c3c;
  outline: none;
  selection-background-color: #062f4a;
}
QComboBox:focus {
  border: 1px solid #215D9C;
}
QComboBox QLineEdit:focus {
  border-right: none;
}
QTextEdit {
  /* Multiple line edit */
  background-color: #2D3234;
  border: 1px solid #1B1F20;
}
TNavBand > QPushButton,
nav_scroll_button_t {
  border: none;
  background: transparent;
  min-height: default;
  min-width: default;
  padding: default;
  border-radius: default;
}
RegJumpButton {
  min-height: 0;
  min-width: 0;
  border: none;
  padding: 0;
}
/* Dock widget which has tabs */
DockWidgetTitle {
  font: 14px 'Segoe UI', 'Helvetica Neue';
  background: #252526;
  text-transform: uppercase;
  min-height: 0px;
  height: 43px;
  padding: 0px 5px 0px 5px;
  border: none;
}
DockWidgetTitle DockWidgetTitleButton {
  color: #fff;
  background: transparent;
  border: none;
  min-height: 0;
  min-width: 0;
  margin: 0;
  padding: 0;
}
DockWidgetTitle DockWidgetTitleButton:hover {
  background: rgba(255, 255, 255, 0.1);
}
DockWidgetTitle DockWidgetTitleButton[toolTip="Close"] {
  qproperty-icon: url(<SKINDIR>/icons/close.png);
  icon-size: 20px;
}
DockWidgetTitle DockWidgetTitleButton[toolTip="Fullscreen"] {
  qproperty-icon: url(<SKINDIR>/icons/fullscreen.png);
  icon-size: 20px;
}
DockWidgetTitle DockWidgetTitleButton[toolTip="Float"] {
  qproperty-icon: url(<SKINDIR>/icons/float.png);
  icon-size: 20px;
}
EditContainer {
  border: 1px solid #1B1F20;
  font-family: "<TEXT_INPUT_FONT_FAMILY>";
  font-size: <TEXT_INPUT_FONT_SIZE>;
  font-style: <TEXT_INPUT_FONT_STYLE>;
  font-weight: <TEXT_INPUT_FONT_WEIGHT>;
}
QScrollBar {
  /* Scrollbar */
  background-color: #1E1E1E;
  border: 0px solid #383838;
  margin: 0;
  padding: 0;
}
QScrollBar:horizontal {
  border-top-width: 1px;
  height: 12px;
}
QScrollBar:vertical {
  border-left-width: 1px;
  width: 12px;
}
QScrollBar:sub-line {
  width: 0;
  height: 0;
}
QScrollBar:add-line {
  width: 0;
  height: 0;
}
QScrollBar:add-page {
  background: none;
  width: 0;
  height: 0;
}
QScrollBar:sub-page {
  background: none;
  width: 0;
  height: 0;
}
QScrollBar:handle {
  background-color: rgba(121, 121, 121, 0.4);
}
QScrollBar:handle:vertical {
  min-height: 20px;
}
QScrollBar:handle:horizontal {
  min-width: 20px;
}
QScrollBar:handle:hover {
  background-color: rgba(100, 100, 100, 0.7);
}
ChooserContainer {
  border: 1px solid #1B1F20;
}
QGroupBox {
  border: 1px solid #1B1F20;
  margin-top: 5px;
}
QGroupBox:title {
  subcontrol-origin: margin;
  subcontrol-position: top center;
}
TextArrows {
  border-bottom: 1px solid #414141;
}
IDADockWidget[objectName="Output window"] {
  /* Output window */
  qproperty-windowIcon: url(<SKINDIR>/icons/blank.png);
}
IDADockWidget[objectName="Output window"] DockWidgetTitle {
  background: #1e1e1e;
  color: #e7e7e7;
  margin: 0;
}
IDADockWidget[objectName="Output window"] QTextEdit:focus {
  border: 1px solid #215D9C;
}
IDADockWidget[objectName="Output window"] QLineEdit {
  padding-bottom: 2px;
}
IDADockWidget[objectName="Output window"] QGroupBox {
  margin: 0;
  padding: 0;
  border: none;
}
IDADockWidget[objectName="Output window"] QGroupBox QPushButton {
  border: none;
  text-transform: uppercase;
  min-width: 70px;
}
IDADockWidget[objectName="Output window"] QGroupBox QPushButton:hover {
  border: none;
}
IDADockWidget[objectName="Output window"] QGroupBox QPushButton:focus {
  border: none;
}

```

`themes/skins/vscode-dark-wb/vscode-dark.clr`:

```clr
[DISASM]
000000	 //
55996a	 //Default color
55996a	 //Regular comment
808080	 //Repeatable comment
808080	 //Automatic comment
d4d4d4	 //Instruction
fedc9c	 //Dummy Data Name
fedc9c	 //Regular Data Name
aadcdc	 //Demangled Name
d4d4d4	 //Punctuation
7dbad7	 //Char constant in instruction
00ff00	 //String constant in instruction
55996a	 //Numeric constant in instruction
7dbad7	 //Void operand
55996a	 //Code reference
d69c56	 //Data reference
0014e5	 //Code reference to tail byte
008080	 //Data reference to tail byte
010101	 //Error or problem
c0c0c0	 //Line prefix
a8ceb5	 //Binary line prefix bytes
aadcdc	 //Extra line
ff0000	 //Alternative operand
d4d4d4	 //Hidden name
fedc9c	 //Library function name
fedc9c	 //Local variable name
fedc9c	 //Dummy code name
fedc9c	 //Assembler directive
c086c5	 //Macro
7891ce	 //String constant in data directive
7891ce	 //Char constant in data directive
55996a	 //Numeric constant in data directive
c086c5	 //Keywords
fedc9c	 //Register name
c086c5	 //Imported name
d4d4d4	 //Segment name
fedc9c	 //Dummy unknown name
aadcdc	 //Regular code name
ffff00	 //Regular unknown name
55996a	 //Collapsed line
000000	 //Max color number
1e1e1e	 //Line prefix: library function
784f26	 //Line prefix: regular function
ffff00	 //Line prefix: instruction
d69c56	 //Line prefix: data
000080	 //Line prefix: unexplored
858585	 //Line prefix: externs
008080	 //Line prefix: current item
ff00ff	 //Line prefix: current line
000000	 //Punctuation
d4d4d4	 //Opcode bytes
000000	 //Manual operand
32cd32	 //Error
[NAVBAR]
ffffaa	 //Library function
e8a200	 //Regular function
577ab9	 //Instruction
c0c0c0	 //Data item
6bb6b6	 //Unexplored
c086c5	 //External symbol
5b5bff	 //Errors
000000	 //Gaps
7fffff	 //Cursor
00aaff	 //Address
32cd32	 //Lumina function
[DEBUG]
184b4b	 //Current IP
ffa0a0	 //Current IP (+ enabled breakpoint)
408020	 //Current IP (+ disabled breakpoint)
1e1e1e	 //Default background
0014e5	 //Address (+ enabled breakpoint)
00ff00	 //Address (+ disabled breakpoint)
004080	 //Current IP (+ unavailable breakpoint)
0080ff	 //Address (+ unavailable breakpoint)
858585	 //Registers
d69c56	 //Registers (changed)
800080	 //Registers (edited)
808080	 //Registers (unavailable)
[ARROW]
c0c0c0	 //Jump in current function
0000ff	 //Jump external to function
000000	 //Jump under the cursor
008000	 //Jump target
ff4040	 //Register target
[GRAPH]
3c3c3c	 //Top color
3c3c3c	 //Bottom color
4b4b4b	 //Normal title
f9f9b1	 //Selected title
cfcfa0	 //Current title
00ffff	 //Group frame
000000	 //Node shadow
ffffcc	 //Highlight color 1
ccffcc	 //Highlight color 2
0000ff	 //Foreign node
ff0000	 //Normal edge
008000	 //Yes edge
0000ff	 //No edge
ff00ff	 //Highlighted edge
ffff00	 //Current edge
[MISC]
cccccc	 //Message text
1e1e1e	 //Message background
404080	 //Patched bytes
0080ff	 //Unsaved changes
[OTHER]
403a34	 //Highlight color
262525	 //Hint color
[SYNTAX]
ff0000	0	0	 //Keyword 1
800080	0	0	 //Keyword 2
0000ff	0	0	 //Keyword 3
00008b	0	0	 //String
006400	0	1	 //Comment
ff0000	1	0	 //Preprocessor
8b8b00	1	0	 //Number

```