Project Path: arc_gmh5225_XignCode3-bypass_swaju6of

Source Tree:

```txt
arc_gmh5225_XignCode3-bypass_swaju6of
├── README.md
├── XignCode Client
│   ├── XignCode Client.vcxproj
│   ├── XignCode Client.vcxproj.filters
│   ├── XignCode.cpp
│   ├── XignCode.hpp
│   ├── client.cpp
│   ├── client.hpp
│   ├── export.def
│   └── main.cpp
├── XignCode Host
│   ├── Resources
│   │   └── xigncode.ico
│   ├── XignCode Host.vcxproj
│   ├── XignCode Host.vcxproj.filters
│   ├── XignCode.cpp
│   ├── XignCode.hpp
│   ├── icon1.ico
│   ├── main.cpp
│   ├── resource.hpp
│   ├── resource.rc
│   ├── server.cpp
│   ├── server.hpp
│   ├── session.cpp
│   └── session.hpp
├── XignCode Library
│   ├── ReadMe.txt
│   ├── XignCode Library.vcxproj
│   ├── XignCode Library.vcxproj.filters
│   ├── XignDefs.hpp
│   ├── XignReader.cpp
│   ├── XignReader.hpp
│   ├── XignWriter.cpp
│   └── XignWriter.hpp
└── XignCode3 Bypass.sln

```

`README.md`:

```md
# XignCode3 bypass
A host-based emulator bypass for Wellbia's XignCode3.

Emulates the integrity-check for XignCode3 through a host-application.

* A host application launches and initializes XignCode3, causing XignCode3 to run its anti-hack analysis routines in the scope of that particular parent process. As a result, any attempt at attacking the original application will remain undetected by XignCode3.
* A client application hooks into the XignCode3 files (and exports), forwarding all integry-check requests to the host-application through a local socket in order to generate correct integrity-check responses.

```

`XignCode Client/XignCode Client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{48A6380E-2AD5-485F-A2D4-4E6F245321BC}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>XignCodeClient</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;XIGNCODECLIENT_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;XIGNCODECLIENT_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>..\XignCode Library\</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>export.def</ModuleDefinitionFile>
    </Link>
    <PostBuildEvent>
      <Command>copy /Y "$(TargetDir)$(ProjectName).dll" "G:\Games\MapleStory (Europe)\XignCode\x3.xem"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="client.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="XignCode.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="client.hpp" />
    <ClInclude Include="XignCode.hpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="export.def" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\XignCode Library\XignCode Library.vcxproj">
      <Project>{6d49cfbb-91a8-4da6-af5f-14aafeca091d}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`XignCode Client/XignCode Client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="source">
      <UniqueIdentifier>{ed35e5c1-68ac-41e3-ba4f-b4f2983b389a}</UniqueIdentifier>
    </Filter>
    <Filter Include="XignCode">
      <UniqueIdentifier>{ad08a2a1-5c1c-459a-80d0-52028d560b00}</UniqueIdentifier>
    </Filter>
    <Filter Include="spoof">
      <UniqueIdentifier>{0b02cb95-7183-4144-bbc1-708e99037d1d}</UniqueIdentifier>
    </Filter>
    <Filter Include="network">
      <UniqueIdentifier>{4898fc4d-5634-4c6b-930b-b91ae6188a9d}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="XignCode.cpp">
      <Filter>XignCode</Filter>
    </ClCompile>
    <ClCompile Include="client.cpp">
      <Filter>network</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="XignCode.hpp">
      <Filter>XignCode</Filter>
    </ClInclude>
    <ClInclude Include="client.hpp">
      <Filter>network</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="export.def">
      <Filter>spoof</Filter>
    </None>
  </ItemGroup>
</Project>
```

`XignCode Client/XignCode.cpp`:

```cpp
#include "client.hpp"

#include "XignCode.hpp"

#include "XignReader.hpp"
#include "XignWriter.hpp"

#include <thread>

namespace XignCode
{
	BOOL XIGNAPI _XignCode_initialize(const wchar_t* license_key, const wchar_t* xigncode_directory, int unknown)
	{
		printf("_XignCode_initialize - %ws, %ws, %d\n", license_key, xigncode_directory, unknown);
		return TRUE;
	}
	
	BOOL XIGNAPI _XignCode_uninitialize()
	{
		printf("_XignCode_uninitialize\n");
		return TRUE;
	}

	BOOL XIGNAPI _XignCode_start_service()
	{
		printf("_XignCode_start_service\n");
		return TRUE;
	}

	BOOL XIGNAPI _XignCode_stop_service()
	{
		printf("_XignCode_stop_service\n");
		return TRUE; 
	}
	
	BOOL XIGNAPI _XignCode_make_response(unsigned char* request, unsigned int size, _XignCode_heartbeat_callback_t response_callback, void* unknown)
	{
		static XignWriter writer;
		static DWORD last_tick = 0;

		if (last_tick == 0 || GetTickCount() - last_tick >= 5000)
		{
			last_tick = GetTickCount();

			printf("\n");
			writer.clear();

			std::thread thrd([&](_XignCode_heartbeat_callback_t callback) -> bool
			{
				while (GetTickCount() - last_tick < 5000)
				{
					Sleep(250);
				}
				
				network::client local_client(38666);
			
				bool result = local_client.make_interaction([&](network::client* client) -> bool
				{
					if (!client->write(writer.get().data(), writer.get().size()))
					{
						return false;
					}
					
					unsigned char data[8192];
					int size = client->read(data);
					
					if (!size)
					{
						return false;
					}

					XignReader reader(data, size);
				
					void* pointer = reinterpret_cast<void*>(reader.read<unsigned int>());

					unsigned char response_1[512];
					std::size_t response_1_size = reader.fetch(response_1);
				
					if (!response_1_size)
					{
						return false;
					}
					
					unsigned char response_2[512];
					std::size_t response_2_size = reader.fetch(response_2);
			
					if (!response_2_size)
					{
						return false;
					}
					
					printf("Heartbeat callback returned: %08X\n", callback(pointer, response_1, response_2, response_1_size, 0));
					return true;
				});
			
				printf("interaction returned: %d\n", result);
				return result;
			}, response_callback);

			thrd.detach();
		}
		else
		{
			last_tick = GetTickCount();
		}

		printf("_XignCode_make_response - %08X, %08X, %08X, %08X\n", request, size, response_callback, unknown);

		writer.append(request, size);
		return TRUE;
	}

	BOOL XIGNAPI _XignCode_set_error_callback(_XignCode_error_callback_t error_callback, void* unknown)
	{
		//printf("_XignCode_set_callback - %08X, %08X\n", error_callback, unknown);
		return TRUE;
	}
	
	BOOL XIGNAPI _XignCode_set_option(unsigned int option, void** param)
	{
		//printf("_XignCode_set_option - %08X, %08X\n", option, *param);
		return TRUE;
	}

	unsigned int XIGNAPI _XignCode_function_dispatch(void** function_ptr, FUNCTION_DISPATCH_TYPE function_type)
	{
		switch (function_type)
		{
		case FDT_INITIALIZE:
			*function_ptr = _XignCode_initialize;
			break;
		
		case FDT_UNINITIALIZE:
			*function_ptr = _XignCode_uninitialize;
			break;

		case FDT_START_SERVICE:
			*function_ptr = _XignCode_start_service;
			break;

		case FDT_STOP_SERVICE:
			*function_ptr = _XignCode_stop_service;
			break;

		case FDT_MAKE_RESPONSE:
			*function_ptr = _XignCode_make_response;
			break;
			
		case FDT_SET_ERROR_CALLBACK:
			*function_ptr = _XignCode_set_error_callback;
			break;
		
		case FDT_SET_OPTION:
			*function_ptr = _XignCode_set_option;
			break;

		default:
			printf("FunctionDispatch - function_ptr: %08X, function_type: %08X\n", function_ptr, function_type);
			break;
		}
		
		return 0;
	}
}
```

`XignCode Client/XignCode.hpp`:

```hpp
#pragma once

#include "XignDefs.hpp"

#include <stdio.h>

namespace XignCode
{
	BOOL XIGNAPI _XignCode_initialize(const wchar_t* license_key, const wchar_t* xigncode_directory, int unknown);
	BOOL XIGNAPI _XignCode_uninitialize();

	BOOL XIGNAPI _XignCode_start_service();
	BOOL XIGNAPI _XignCode_stop_service();
	
	BOOL XIGNAPI _XignCode_make_response(unsigned char* request, unsigned int size, _XignCode_heartbeat_callback_t response_callback, void* unknown);
	
	BOOL XIGNAPI _XignCode_set_error_callback(_XignCode_error_callback_t error_callback, void* unknown);
	BOOL XIGNAPI _XignCode_set_option(unsigned int option, void** param);

	unsigned int XIGNAPI _XignCode_function_dispatch(void** function_ptr, FUNCTION_DISPATCH_TYPE function_type);
}
```

`XignCode Client/client.cpp`:

```cpp
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "client.hpp"

#include <WS2tcpip.h>
#pragma comment(lib, "ws2_32")

#include <string>

namespace network
{
	client::client(unsigned short port) 
		: sock(INVALID_SOCKET), port(port)
	{

	}

	client::~client()
	{
		if (this->sock != INVALID_SOCKET)
		{
			this->uninitialize();
		}
	}

	bool client::make_interaction(interaction_handler finalize_handler)
	{
		if (!this->initialize())
		{
			this->output_wsa_error(error_type::connect);
			return false;
		}
		
		bool result = finalize_handler(this);

		this->uninitialize();
		return result;
	}
	
	int client::read(unsigned char* buffer, std::size_t assumed_size)
	{
		unsigned short data_length = 0;
		int data_length_size = this->raw_read(reinterpret_cast<unsigned char*>(&data_length), sizeof(unsigned short));

		if (!data_length_size || data_length_size != sizeof(unsigned short))
		{
			return 0;	
		}
		
		if (assumed_size && data_length != assumed_size)
		{
			return 0;
		}
		
		unsigned char data_buffer[16384];
		
		for (int data_read = 0, offset = 0, data_to_read = data_length; data_to_read > 0; data_to_read -= data_read, offset += data_read)
		{
			data_read = this->raw_read(data_buffer + offset, data_to_read);

			if (!data_read || data_read == SOCKET_ERROR)
			{
				return 0;
			}
		}

		memcpy(buffer, data_buffer, data_length);
		return data_length;
	}
	
	bool client::write(unsigned char const* buffer, std::size_t size)
	{
		unsigned short data_length = static_cast<unsigned short>(size);

		if (!this->raw_write(reinterpret_cast<unsigned char*>(&data_length), sizeof(unsigned short)))
		{
			return false;
		}

		unsigned char* data_buffer = new unsigned char[size];
		memcpy(data_buffer, buffer, size);

		if (!this->raw_write(data_buffer, size))
		{
			delete[] data_buffer;
			return false;
		}

		delete[] data_buffer;
		return true;
	}

	bool client::initialize()
	{
		if (WSAStartup(MAKEWORD(2, 0), new WSADATA))
		{
			return false;
		}

		this->sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

		if (this->sock == INVALID_SOCKET)
		{
			return false;
		}

		sockaddr_in addr;
		addr.sin_family = AF_INET;
		addr.sin_port = htons(this->port);
		addr.sin_addr.s_addr = inet_addr("192.168.1.44"); // inet_addr("127.0.0.1");
		std::fill(addr.sin_zero, addr.sin_zero + sizeof(addr.sin_zero), 0);

		return (connect(this->sock, reinterpret_cast<sockaddr*>(&addr), sizeof(sockaddr_in)) != SOCKET_ERROR);
	}

	bool client::uninitialize()
	{
		return (shutdown(this->sock, SD_BOTH) != SOCKET_ERROR && closesocket(this->sock) != SOCKET_ERROR && WSACleanup() == 0);
	}

	int client::raw_read(unsigned char* buffer, std::size_t size)
	{
		int bytes_read = recv(this->sock, reinterpret_cast<char*>(buffer), size, 0);
		
		if (bytes_read == 0 || bytes_read == SOCKET_ERROR)
		{
			if (bytes_read == SOCKET_ERROR)
			{
				this->output_wsa_error(error_type::read);
			}

			return bytes_read;
		}
		else if (bytes_read < static_cast<int>(size))
		{
			int remaining_bytes_read = recv(this->sock, reinterpret_cast<char*>(buffer + bytes_read), size - bytes_read, 0);
		
			if (remaining_bytes_read == 0 || remaining_bytes_read == SOCKET_ERROR)
			{
				if (remaining_bytes_read == SOCKET_ERROR)
				{
					this->output_wsa_error(error_type::read, false);
				}

				return remaining_bytes_read;
			}

			bytes_read += remaining_bytes_read;
		}

		return bytes_read;
	}

	bool client::raw_write(unsigned char const* buffer, std::size_t size)
	{
		for (int data_sent = 0, offset = 0, data_to_send = size; data_to_send > 0; data_to_send -= data_sent, offset += data_sent)
		{
			data_sent = send(this->sock, reinterpret_cast<const char*>(buffer) + offset, data_to_send, 0);
	
			if (data_sent == 0 || data_sent == SOCKET_ERROR)
			{
				if (data_sent == SOCKET_ERROR)
				{
					this->output_wsa_error(error_type::write);
				}

				return false;
			}
		}

		return true;
	}
	
	void client::output_wsa_error(error_type type, bool first)
	{
		int error_code = WSAGetLastError();

		char error_message[1024];
		memset(error_message, 0, sizeof(error_message));

		strcpy(error_message, "Failed to ");
		
		switch (type)
		{
		case error_type::connect:
			strcat(error_message, "connect to ");
			break;

		case error_type::read:
			strcat(error_message, (first ? "receive (0) data from " : "receive (1) data from "));
			break;

		case error_type::write:
			strcat(error_message, "send data to ");
			break;
		}

		strcat(error_message, "the server.\nReason: ");

		switch (error_code)
		{
		case WSAECONNRESET:
			strcat(error_message, "You've been disconnected; the server terminated the connection.");
			break;

		case WSAETIMEDOUT:
			strcat(error_message, "You've timed out; it took you more than 10 seconds to communicate with the server.");
			break;

		default:
			strcat(error_message, "Unknown. Error code: ");
			strcat(error_message, std::to_string(error_code).c_str());
			strcat(error_message, ".");
			break;
		}
		
		printf("Client networking error: %s\n", error_message);
	}
}
```

`XignCode Client/client.hpp`:

```hpp
#pragma once

#include <WinSock2.h>
#include <Windows.h>

#include <functional>
#include <iostream>

namespace network
{
	enum class error_type
	{
		connect,
		read,
		write
	};

	class client
	{
	protected:
		typedef std::function<bool(client*)> interaction_handler;

	public:
		client(unsigned short port);
		~client();
		
		bool make_interaction(interaction_handler finalize_handler);

		int read(unsigned char* buffer, std::size_t assumed_size = 0);
		bool write(unsigned char const* buffer, std::size_t size);

	protected:
		bool initialize();
		bool uninitialize();

		int raw_read(unsigned char* buffer, std::size_t size);
		bool raw_write(unsigned char const* buffer, std::size_t size);

		void output_wsa_error(error_type type, bool first = true);

	private:
		SOCKET sock;

		std::string hostname;
		unsigned short port;
	};
}
```

`XignCode Client/export.def`:

```def
LIBRARY "XignCode Client"

EXPORTS
	1						= _XignCode_function_dispatch				@1		PRIVATE
```

`XignCode Client/main.cpp`:

```cpp
#pragma once

#include <Windows.h>
#include <stdio.h>

BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	if (fdwReason == DLL_PROCESS_ATTACH)
	{	
		AllocConsole();
		SetConsoleTitle(L"XignCode Client");
		AttachConsole(GetCurrentProcessId());
	
		FILE* pFile = nullptr;
		freopen_s(&pFile, "CON", "r", stdin);
		freopen_s(&pFile, "CON", "w", stdout);
		freopen_s(&pFile, "CON", "w", stderr);
		
		DisableThreadLibraryCalls(hinstDLL);
	}
	else if (fdwReason == DLL_PROCESS_DETACH)
	{
		FreeConsole();
	}

	return TRUE;
}
```

`XignCode Host/XignCode Host.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E8C68252-8308-4B45-A74B-028C8193ACCE}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>XignCodeHost</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>..\XignCode Library\</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="server.cpp" />
    <ClCompile Include="session.cpp" />
    <ClCompile Include="XignCode.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.hpp" />
    <ClInclude Include="server.hpp" />
    <ClInclude Include="session.hpp" />
    <ClInclude Include="XignCode.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="Resources\xigncode.ico" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\XignCode Library\XignCode Library.vcxproj">
      <Project>{6d49cfbb-91a8-4da6-af5f-14aafeca091d}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`XignCode Host/XignCode Host.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="source">
      <UniqueIdentifier>{21463798-7244-4def-bc77-9ebc3f52166c}</UniqueIdentifier>
    </Filter>
    <Filter Include="XignCode">
      <UniqueIdentifier>{91ded9d3-e1fb-41b8-8f57-6ab4de00e938}</UniqueIdentifier>
    </Filter>
    <Filter Include="resource">
      <UniqueIdentifier>{31e95667-2762-432d-8ee0-d77fbdd9c661}</UniqueIdentifier>
    </Filter>
    <Filter Include="resource\icons">
      <UniqueIdentifier>{6bc6e9b1-ef2b-4fa7-9420-6eb4f0a808e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="network">
      <UniqueIdentifier>{3d85bfc6-a931-4417-ba9a-975e3a9c4d3a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="XignCode.cpp">
      <Filter>XignCode</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="server.cpp">
      <Filter>network</Filter>
    </ClCompile>
    <ClCompile Include="session.cpp">
      <Filter>network</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="XignCode.hpp">
      <Filter>XignCode</Filter>
    </ClInclude>
    <ClInclude Include="resource.hpp">
      <Filter>resource</Filter>
    </ClInclude>
    <ClInclude Include="server.hpp">
      <Filter>network</Filter>
    </ClInclude>
    <ClInclude Include="session.hpp">
      <Filter>network</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc">
      <Filter>resource</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Resources\xigncode.ico">
      <Filter>resource\icons</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`XignCode Host/XignCode.cpp`:

```cpp
#include "XignCode.hpp"

namespace XignCode
{
	bool Initialize(std::wstring const& maplestory_directory)
	{
		/* Load MapleStory stub */
		HMODULE maplestory_module = LoadLibraryEx((maplestory_directory + std::wstring(L"\\MapleStory.exe")).c_str(), NULL, DONT_RESOLVE_DLL_REFERENCES);
		
		if (!maplestory_module)
		{
			return false;
		}

		__asm
		{ 
			push eax  
			push ecx
			mov eax,fs:[0x18]
			mov eax,[eax+0x30]
			mov ecx,maplestory_module
			mov [eax+0x08],ecx
			pop ecx
			pop eax
		};
		
		/* Load XignCode */
		std::wstring xigncode_directory = maplestory_directory + L"\\XignCode3";
		HMODULE xigncode_module = LoadLibrary((xigncode_directory + std::wstring(L"\\x3.xem")).c_str());
	
		if (!xigncode_module)
		{
			return false;
		}
		
		/* Get the function dispatch */
		_XignCode_function_dispatch = reinterpret_cast<_XignCode_function_dispatch_t>(GetProcAddress(xigncode_module, reinterpret_cast<LPCSTR>(1)));

		if (!_XignCode_function_dispatch)
		{
			return false;
		}
		
		/* Handle the initialize function */
		_XignCode_initialize_t _XignCode_initialize = nullptr;

		if (_XignCode_function_dispatch(reinterpret_cast<void**>(&_XignCode_initialize), FDT_INITIALIZE) || _XignCode_initialize == nullptr)
		{
			return false;
		}

		if (!_XignCode_initialize(L"bD_cXsyitNtI", xigncode_directory.c_str(), 7))
		{
			return false;
		}

		/* Handle the error callback function */
		_XignCode_set_error_callback_t _XignCode_set_error_callback = nullptr;
		
		if (_XignCode_function_dispatch(reinterpret_cast<void**>(&_XignCode_set_error_callback), FDT_SET_ERROR_CALLBACK) || _XignCode_set_error_callback == nullptr)
		{
			return false;
		}

		_XignCode_error_callback_t _XignCode_error_callback = [](unsigned int error_code, unsigned int param_size, void* param, void* _4) -> unsigned int
		{
			//printf("_XignCode_error_callback: %08X\n", error_code);
			return 0;
		};
		
		if (!_XignCode_set_error_callback(_XignCode_error_callback, 0))
		{
			return false;
		}

		/* Handle the start service function */
		_XignCode_start_service_t _XignCode_start_service = nullptr;

		if (_XignCode_function_dispatch(reinterpret_cast<void**>(&_XignCode_start_service), FDT_START_SERVICE) || _XignCode_start_service == nullptr)
		{
			return false;
		}

		if (!_XignCode_start_service())
		{
			return false;
		}

		return true;
	}
	
	bool Uninitialize()
	{
		/* Handle the stop service function */
		_XignCode_stop_service_t _XignCode_stop_service = nullptr;

		if (_XignCode_function_dispatch(reinterpret_cast<void**>(&_XignCode_stop_service), FDT_STOP_SERVICE) || _XignCode_stop_service == nullptr)
		{
			return false;
		}

		if (!_XignCode_stop_service())
		{
			return false;
		}

		/* Handle the uninitialize function */
		_XignCode_uninitialize_t _XignCode_uninitialize = nullptr;

		if (_XignCode_function_dispatch(reinterpret_cast<void**>(&_XignCode_uninitialize), FDT_UNINITIALIZE) || _XignCode_uninitialize == nullptr)
		{
			return false;
		}

		if (!_XignCode_uninitialize())
		{
			return false;
		}

		return true;
	}

	bool MakeResponse(unsigned char* request, unsigned int size, _XignCode_heartbeat_callback_t heartbeat_callback)
	{
		_XignCode_make_response_t _XignCode_make_response = nullptr;

		if (_XignCode_function_dispatch(reinterpret_cast<void**>(&_XignCode_make_response), FDT_MAKE_RESPONSE) || _XignCode_make_response == nullptr)
		{
			return false;
		}

		if (!_XignCode_make_response(request, size, heartbeat_callback, 0))
		{
			return false;
		}

		return true;
	}
}
```

`XignCode Host/XignCode.hpp`:

```hpp
#pragma once

#include "XignDefs.hpp"

namespace XignCode
{
	static _XignCode_function_dispatch_t _XignCode_function_dispatch = nullptr;

	bool Initialize(std::wstring const& maplestory_directory);
	bool Uninitialize();

	bool MakeResponse(unsigned char* request, unsigned int size, _XignCode_heartbeat_callback_t heartbeat_callback);
}
```

`XignCode Host/main.cpp`:

```cpp
#include <Windows.h>
#include <Windowsx.h>
#include <stdio.h>

#include <iostream>
#include <memory>

#include "resource.hpp"
#include "XignCode.hpp"

#include "server.hpp"

INT APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
	AllocConsole();
	SetConsoleTitle(L"Full Bypass");
	AttachConsole(GetCurrentProcessId());
	
	FILE* pFile = nullptr;
	freopen_s(&pFile, "CON", "r", stdin);
	freopen_s(&pFile, "CON", "w", stdout);
	freopen_s(&pFile, "CON", "w", stderr);

	if (!XignCode::Initialize(L"C:\\MapleStory (Europe)"))
	{
		return 0;
	}
	
	network::server server;
	
	if (!server.initialize(38666))
	{
		return 0;
	}
	
	server.begin_listen();
	return 0;
}
```

`XignCode Host/resource.hpp`:

```hpp
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by resource.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`XignCode Host/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.hpp"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Danish (Denmark) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DAN)
LANGUAGE LANG_DANISH, SUBLANG_DEFAULT

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.hpp\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "Resources\\xigncode.ico"
#endif    // Danish (Denmark) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`XignCode Host/server.cpp`:

```cpp
#include <WinSock2.h>
#pragma comment(lib, "ws2_32")

#include "server.hpp"
#include "session.hpp"

#include <thread>

namespace network
{
	server::server() : sock(INVALID_SOCKET)
	{

	}

	server::~server()
	{
		if (this->sock != INVALID_SOCKET)
		{
			this->uninitialize();
		}
	}

	bool server::initialize(unsigned short port)
	{
		if (WSAStartup(MAKEWORD(2, 0), new WSADATA))
		{
			return false;
		}

		sock = socket(AF_INET, SOCK_STREAM, 0);

		if (this->sock == INVALID_SOCKET)
		{
			return false;
		}

		int opt = 1;
		if (setsockopt(this->sock, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<char*>(&opt), sizeof(opt)) == SOCKET_ERROR)
		{
			return false;
		}

		sockaddr_in addr;
		addr.sin_family = AF_INET;
		addr.sin_port = htons(port);
		addr.sin_addr.s_addr = INADDR_ANY;
		std::fill(addr.sin_zero, addr.sin_zero + sizeof(addr.sin_zero), 0);

		if (bind(this->sock, reinterpret_cast<const sockaddr*>(&addr), sizeof(sockaddr_in)) == SOCKET_ERROR)
		{
			return false;
		}

		if (listen(this->sock, SOMAXCONN) == SOCKET_ERROR)
		{
			return false;
		}

		return true;
	}

	bool server::uninitialize()
	{
		return (closesocket(this->sock) != SOCKET_ERROR && !WSACleanup());
	}

	void server::begin_listen()
	{
		for (;;)
		{
			sockaddr_in sender;
			int len = sizeof(sockaddr_in);

			SOCKET desc = accept(this->sock, reinterpret_cast<sockaddr*>(&sender), &len);

			if (desc == INVALID_SOCKET)
			{
				continue;
			}

			timeval timeout = { SOCKET_TIMEOUT, 0 };

			if (setsockopt(desc, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast<char*>(&timeout), sizeof(timeout)) != SOCKET_ERROR &&
				setsockopt(desc, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast<char*>(&timeout), sizeof(timeout)) != SOCKET_ERROR)
			{
				session::get_instance().close();
				session::get_instance().reset(desc, sender);
				
				if (!session::get_instance().handler())
				{
					closesocket(desc);
				}
			}
		}
	}
}
```

`XignCode Host/server.hpp`:

```hpp
#pragma once

#include <Windows.h>

namespace network
{
	#define SOCKET_TIMEOUT 5

	class server
	{
	public:
		server();
		~server();

		bool initialize(unsigned short port);
		bool uninitialize();

		void begin_listen();

	private:
		SOCKET sock;
	};
}
```

`XignCode Host/session.cpp`:

```cpp
#include "session.hpp"

#include "XignCode.hpp"

#include "XignReader.hpp"
#include "XignWriter.hpp"

namespace network
{
	void session::close()
	{
		if (this->desc)
		{
			closesocket(this->desc);
		}
	}

	void session::reset(SOCKET desc, sockaddr_in const& sender)
	{
		this->desc = desc;
		this->sender = sender;
	}

	bool session::handler()
	{
		if (desc == INVALID_SOCKET)
		{
			return false;
		}

		try
		{
			printf("Connection received..\n");

			unsigned char data[8192];
			int size = this->e_read(data); 

			if (!size)
			{
				return false;
			}

			XignReader reader(data, size);

			unsigned char buffer[512];
			std::size_t buffer_size = 0;

			while (buffer_size = reader.fetch(buffer), buffer_size)
			{
				XignCode::_XignCode_heartbeat_callback_t callback = [](void* pointer, unsigned char* response_1, unsigned char* response_2, unsigned int size, int unknown) -> unsigned int
				{
					XignWriter writer;
					writer.write<unsigned int>(reinterpret_cast<unsigned int>(pointer));
					writer.append(response_1, size);
					writer.append(response_2, size);

					session::get_instance().e_write(writer.get().data(), writer.get().size());
					session::get_instance().close();
					return 0;
				};

				if (!XignCode::MakeResponse(buffer, buffer_size, callback))
				{
					return false;
				}
			}

			return true;
		}
		catch (std::string& exception_string)
		{
			return false;
		}

		return true;
	}
	
	int session::e_read(unsigned char* buffer, std::size_t assumed_size)
	{
		unsigned short data_length = 0;
		int data_length_size = this->raw_read(reinterpret_cast<unsigned char*>(&data_length), sizeof(unsigned short));

		if (!data_length_size || data_length_size != sizeof(unsigned short))
		{
			return 0;	
		}

		if (assumed_size && data_length != assumed_size)
		{
			return 0;
		}

		unsigned char data_buffer[16384];
		
		for (int data_read = 0, offset = 0, data_to_read = data_length; data_to_read > 0; data_to_read -= data_read, offset += data_read)
		{
			data_read = this->raw_read(data_buffer + offset, data_to_read);

			if (!data_read || data_read == SOCKET_ERROR)
			{
				return 0;
			}
		}

		memcpy(buffer, data_buffer, data_length);
		return data_length;
	}
	
	bool session::e_write(unsigned char const* buffer, std::size_t size)
	{
		unsigned short data_length = static_cast<unsigned short>(size);

		if (!this->raw_write(reinterpret_cast<unsigned char*>(&data_length), sizeof(unsigned short)))
		{
			return false;
		}

		unsigned char* data_buffer = new unsigned char[size];
		memcpy(data_buffer, buffer, size);
		
		if (!this->raw_write(data_buffer, size))
		{
			delete[] data_buffer;
			return false;
		}

		delete[] data_buffer;
		return true;
	}

	session::session()
	{

	}

	session::~session()
	{

	}

	int session::raw_read(unsigned char* buffer, std::size_t size)
	{
		int bytes_read = 0;
		
		do
		{
			bytes_read = recv(this->desc, reinterpret_cast<char*>(buffer), size, 0);
		}
		while (bytes_read == SOCKET_ERROR && WSAGetLastError() == WSAEWOULDBLOCK);
		
		if (bytes_read == 0 || bytes_read == SOCKET_ERROR)
		{
			return bytes_read;
		}
		else if (bytes_read < static_cast<int>(size))
		{
			int remaining_bytes_read = 0;
			
			do
			{
				remaining_bytes_read = recv(this->desc, reinterpret_cast<char*>(buffer + bytes_read), size - bytes_read, 0);
			}
			while (remaining_bytes_read == SOCKET_ERROR && WSAGetLastError() == WSAEWOULDBLOCK);
			
			if (remaining_bytes_read == 0 || remaining_bytes_read == SOCKET_ERROR)
			{				
				return remaining_bytes_read;
			}

			bytes_read += remaining_bytes_read;
		}

		return bytes_read;
	}

	bool session::raw_write(unsigned char const* buffer, std::size_t size)
	{
		for (int data_sent = 0, offset = 0, data_to_send = size; data_to_send > 0; data_to_send -= data_sent, offset += data_sent)
		{
			data_sent = send(this->desc, reinterpret_cast<const char*>(buffer) + offset, data_to_send, 0);
	
			if (data_sent == 0 || data_sent == SOCKET_ERROR)
			{				
				return false;
			}
		}

		return true;
	}
}
```

`XignCode Host/session.hpp`:

```hpp
#pragma once

#include <Windows.h>

#include <iostream>
#include <memory>

namespace network
{
	class session
	{
	public:
		static session& get_instance()
		{
			static session instance;
			return instance;
		}
		
		void close();
		void reset(SOCKET desc, sockaddr_in const& sender);

		bool handler();
		
		int e_read(unsigned char* buffer, std::size_t assumed_size = 0);
		bool e_write(unsigned char const* buffer, std::size_t size);

	private:
		session();
		~session();

		int raw_read(unsigned char* buffer, std::size_t size);
		bool raw_write(unsigned char const* buffer, std::size_t size);
		
		SOCKET desc;
		sockaddr_in sender;
	};
}
```

`XignCode Library/ReadMe.txt`:

```txt
========================================================================
    STATIC LIBRARY : XignCode Library Project Overview
========================================================================

AppWizard has created this XignCode Library library project for you.

No source files were created as part of your project.


XignCode Library.vcxproj
    This is the main project file for VC++ projects generated using an Application Wizard.
    It contains information about the version of Visual C++ that generated the file, and
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

XignCode Library.vcxproj.filters
    This is the filters file for VC++ projects generated using an Application Wizard. 
    It contains information about the association between the files in your project 
    and the filters. This association is used in the IDE to show grouping of files with
    similar extensions under a specific node (for e.g. ".cpp" files are associated with the
    "Source Files" filter).

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

```

`XignCode Library/XignCode Library.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="XignDefs.hpp" />
    <ClInclude Include="XignReader.hpp" />
    <ClInclude Include="XignWriter.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="XignReader.cpp" />
    <ClCompile Include="XignWriter.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{6D49CFBB-91A8-4DA6-AF5F-14AAFECA091D}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>XignCodeLibrary</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`XignCode Library/XignCode Library.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="XignCode">
      <UniqueIdentifier>{1969423e-ebff-4989-8ed8-9ff974f804c4}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="XignWriter.hpp">
      <Filter>XignCode</Filter>
    </ClInclude>
    <ClInclude Include="XignReader.hpp">
      <Filter>XignCode</Filter>
    </ClInclude>
    <ClInclude Include="XignDefs.hpp">
      <Filter>XignCode</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="XignWriter.cpp">
      <Filter>XignCode</Filter>
    </ClCompile>
    <ClCompile Include="XignReader.cpp">
      <Filter>XignCode</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`XignCode Library/XignDefs.hpp`:

```hpp
#pragma once

#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <Windows.h>
#include <string>

namespace XignCode
{
	#define XIGNAPI __stdcall

	enum FUNCTION_DISPATCH_TYPE
	{
		FDT_INITIALIZE			= 1,	// 0x01
		FDT_UNINITIALIZE		= 2,	// 0x02

		FDT_START_SERVICE		= 3,	// 0x03
		FDT_STOP_SERVICE		= 4,	// 0x04

		FDT_MAKE_RESPONSE		= 6,	// 0x06
		
		FDT_SET_ERROR_CALLBACK	= 22,	// 0x16
		FDT_SET_OPTION			= 26,	// 0x1A
	};
	
	enum _XclioFid
	{
		XclioFidSysEnterA = 0x0,
		XclioFidSysEnterW = 0x1,
		XclioFidSysExit = 0x2,
		XclioFidInit = 0x3,
		XclioFidCleanup = 0x4,
		XclioFidProbe = 0x5,
		XclioFidProbeEx = 0x6,
		XclioFidCreateCodeBox = 0x7,
		XclioFidCloseCodeBox = 0x8,
		XclioFidProbeCodeBox = 0x9,
		XclioFidProbeCodeBoxEx = 0xA,
		XclioFidEncrypt = 0xB,
		XclioFidDecrypt = 0xC,
		XclioFidRsaCreate = 0xD,
		XclioFidRsaClose = 0xE,
		XclioFidRsaSetPublicKey = 0xF,
		XclioFidRsaSetPrivateKey = 0x10,
		XclioFidRsaPublicEncrypt = 0x11,
		XclioFidRsaPublicDecrypt = 0x12,
		XclioFidRsaPrivateEncrypt = 0x13,
		XclioFidRsaPrivateDecrypt = 0x14,
		XclioFidCheck = 0x15,
		XclioFidRegisterCallback = 0x16,
		XclioFidRsaGenerateKey = 0x17,
		XclioFidRsaFreeBuffer = 0x18,
		XclioFidSetup = 0x19,
		XclioFidSendCommandVa = 0x1A,
	};

	typedef unsigned int (XIGNAPI* _XignCode_function_dispatch_t)(void** function_ptr, FUNCTION_DISPATCH_TYPE function_type);

	typedef unsigned int (XIGNAPI* _XignCode_heartbeat_callback_t)(void* pointer, unsigned char* response_1, unsigned char* response_2, unsigned int size, int unknown);
	typedef unsigned int (XIGNAPI* _XignCode_error_callback_t)(unsigned int error_code, unsigned int param_size, void* param, void* unknown);
	
	typedef BOOL (XIGNAPI* _XignCode_initialize_t)(const wchar_t* license_key, const wchar_t* xigncode_directory, int unknown);
	typedef BOOL (XIGNAPI* _XignCode_uninitialize_t)();

	typedef BOOL (XIGNAPI* _XignCode_start_service_t)();
	typedef BOOL (XIGNAPI* _XignCode_stop_service_t)();

	typedef BOOL (XIGNAPI* _XignCode_make_response_t)(unsigned char* request, unsigned int size, _XignCode_heartbeat_callback_t response_callback, int unknown);
	typedef BOOL (XIGNAPI* _XignCode_set_error_callback_t)(_XignCode_error_callback_t error_callback, void* unknown);
}
```

`XignCode Library/XignReader.cpp`:

```cpp
#include "XignReader.hpp"

XignReader::XignReader(unsigned char* input, std::size_t size) 
	: index(0), buffer(input, input + size)
{

}

XignReader::~XignReader()
{

}

std::size_t XignReader::fetch(unsigned char* output)
{
	std::size_t size = this->read<std::size_t>();

	if (!size)
	{
		return 0;
	}

	if (!this->read_buffer(output, size))
	{
		return 0;
	}

	return size;
}

	
std::vector<unsigned char>& XignReader::get()
{
	return this->buffer;
}
	
bool XignReader::read_buffer(unsigned char* buffer, std::size_t size)
{
	if (!this->check_index(size))
	{
		return false;
	}
		
	memcpy(buffer, this->buffer.data() + this->index, size);
	this->index += size;
	return true;
}

bool XignReader::check_index(std::size_t nSize)
{
	return ((this->index + nSize) <= static_cast<std::size_t>(this->buffer.size()));
}
```

`XignCode Library/XignReader.hpp`:

```hpp
#pragma once

#include <Windows.h>

#include <codecvt>
#include <vector>

class XignReader
{
public:
	XignReader(unsigned char* input, std::size_t size);
	~XignReader();

	std::size_t fetch(unsigned char* output);

	template <typename T>
	T read();
	
	std::vector<unsigned char>& get();
	
private:
	bool read_buffer(unsigned char* buffer, std::size_t size);

	bool check_index(std::size_t nSize);

	std::size_t index;
	std::vector<unsigned char> buffer;
};

template <typename T>
T XignReader::read()
{
	if (this->check_index(sizeof(T)))
	{
		this->index += sizeof(T);
		return *reinterpret_cast<T*>(this->buffer.data() + this->index - sizeof(T));
	}

	return static_cast<T>(0);
}
```

`XignCode Library/XignWriter.cpp`:

```cpp
#include "XignWriter.hpp"

XignWriter::XignWriter()
{
	this->clear();	
}

XignWriter::~XignWriter()
{
	this->clear();		
}

void XignWriter::clear()
{
	this->appends = 0;
	this->buffer.clear();
}

void XignWriter::append(unsigned char* input, std::size_t size)
{
	this->write<std::size_t>(size);
	this->write_buffer(input, size);;
}
	
std::vector<unsigned char>& XignWriter::get()
{
	return this->buffer;
}

void XignWriter::write_buffer(unsigned char* data, std::size_t size)
{
	std::copy(data, data + size, std::back_inserter(this->buffer));
}
```

`XignCode Library/XignWriter.hpp`:

```hpp
#pragma once

#include <Windows.h>

#include <codecvt>
#include <vector>

class XignWriter
{
public:
	XignWriter();
	~XignWriter();

	void clear();
	void append(unsigned char* input, std::size_t size);
	
	template <typename T>
	void write(T input);

	std::vector<unsigned char>& get();

private:
	void write_buffer(unsigned char* data, std::size_t size);

	std::size_t appends;
	std::vector<unsigned char> buffer;
};

template <typename T>
void XignWriter::write(T input)
{
	unsigned char* temp_data = reinterpret_cast<unsigned char*>(&input);
	std::copy(temp_data, temp_data + sizeof(T), std::back_inserter(this->buffer));
}
```

`XignCode3 Bypass.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.21005.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "XignCode Client", "XignCode Client\XignCode Client.vcxproj", "{48A6380E-2AD5-485F-A2D4-4E6F245321BC}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "XignCode Host", "XignCode Host\XignCode Host.vcxproj", "{E8C68252-8308-4B45-A74B-028C8193ACCE}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "XignCode Library", "XignCode Library\XignCode Library.vcxproj", "{6D49CFBB-91A8-4DA6-AF5F-14AAFECA091D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{48A6380E-2AD5-485F-A2D4-4E6F245321BC}.Debug|Win32.ActiveCfg = Debug|Win32
		{48A6380E-2AD5-485F-A2D4-4E6F245321BC}.Debug|Win32.Build.0 = Debug|Win32
		{48A6380E-2AD5-485F-A2D4-4E6F245321BC}.Release|Win32.ActiveCfg = Release|Win32
		{48A6380E-2AD5-485F-A2D4-4E6F245321BC}.Release|Win32.Build.0 = Release|Win32
		{E8C68252-8308-4B45-A74B-028C8193ACCE}.Debug|Win32.ActiveCfg = Debug|Win32
		{E8C68252-8308-4B45-A74B-028C8193ACCE}.Debug|Win32.Build.0 = Debug|Win32
		{E8C68252-8308-4B45-A74B-028C8193ACCE}.Release|Win32.ActiveCfg = Release|Win32
		{E8C68252-8308-4B45-A74B-028C8193ACCE}.Release|Win32.Build.0 = Release|Win32
		{6D49CFBB-91A8-4DA6-AF5F-14AAFECA091D}.Debug|Win32.ActiveCfg = Debug|Win32
		{6D49CFBB-91A8-4DA6-AF5F-14AAFECA091D}.Debug|Win32.Build.0 = Debug|Win32
		{6D49CFBB-91A8-4DA6-AF5F-14AAFECA091D}.Release|Win32.ActiveCfg = Release|Win32
		{6D49CFBB-91A8-4DA6-AF5F-14AAFECA091D}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```