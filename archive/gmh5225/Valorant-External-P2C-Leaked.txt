Project Path: arc_gmh5225_Valorant-External-P2C-Leaked_fi4mqum9

Source Tree:

```txt
arc_gmh5225_Valorant-External-P2C-Leaked_fi4mqum9
├── Includes
│   ├── Includes.rar
│   └── Readme2.mb
├── README.md
└── Valorant
    ├── Aimbot.h
    ├── Auth
    │   ├── auth.hpp
    │   ├── libcurl.lib
    │   └── library_x64.lib
    ├── Driver
    │   ├── driver.h
    │   └── loader.hpp
    ├── Game
    │   ├── cheat.hpp
    │   ├── globals.hpp
    │   ├── sdk.hpp
    │   ├── skStr.h
    │   └── structs.hpp
    ├── Overlay
    │   ├── menu.hpp
    │   └── render.hpp
    ├── Radar.h
    ├── Skeleton.h
    ├── Valorant.aps
    ├── Valorant.rc
    ├── Valorant.vcxproj
    ├── Valorant.vcxproj.filters
    ├── Valorant.vcxproj.user
    ├── Vector3.h
    ├── defs.h
    ├── image1.png
    ├── main.cpp
    ├── resource.h
    └── wav.c

```

`Includes/Readme2.mb`:

```mb
# How to Extract Includes
Open Includes.rar <br>
Extract them in the same folder as the cheat <br>
Your Welcome

```

`README.md`:

```md
# Beef.exe-Valorant-P2C-Leak
Valorant Paste, Bruh <br>

```

`Valorant/Aimbot.h`:

```h
#pragma once
#include <Windows.h>
#include "Driver/Driver.h"

#define UCONST_Pi 3.1415926535
#define RadianToURotation 180.0f / UCONST_Pi


auto GetBone(DWORD_PTR mesh, int id) -> FVector
{
	DWORD_PTR array = Read<uintptr_t>(mesh + offsets::BoneArray);
	if (array == NULL)
		array = Read<uintptr_t>(mesh + offsets::BoneArrayCache);

	FTransform bone = Read<FTransform>(array + (id * 0x30));

	FTransform ComponentToWorld = Read<FTransform>(mesh + offsets::ComponentToWorld);
	D3DMATRIX Matrix;

	Matrix = MatrixMultiplication(bone.ToMatrixWithScale(), ComponentToWorld.ToMatrixWithScale());

	return FVector(Matrix._41, Matrix._42, Matrix._43);
}
FVector VectorToRotation(FVector relativeLocation) // COPY PASTE UC SHIT
{
	constexpr auto radToUnrRot = 57.2957795f;

	return FVector(
		atan2(relativeLocation.z, sqrt((relativeLocation.x * relativeLocation.x) + (relativeLocation.y * relativeLocation.y))) * radToUnrRot,
		atan2(relativeLocation.y, relativeLocation.x) * radToUnrRot,
		0.f);
}
FVector CLAMPEDVECTOR(FVector targetLocation, FVector cameraLocation)
{
	return VectorToRotation(targetLocation - cameraLocation);
}
FVector SMOOTHEDANGLES(FVector rot1, FVector rot2, float smooth)
{
	FVector ret(0, 0, 0);

	ret.x = (rot2.x - rot1.x) / smooth + rot1.x;
	ret.y = (rot2.y - rot1.y) / smooth + rot1.y;
	ret.z = (rot2.z - rot1.z) / smooth + rot1.z;

	return ret;
}
void SMOOTHFACTOR(FVector Target, FVector Camera_rotation, float SmoothFactor)
{

	for (PlayerContrPTR PlayerPTR : PPTR)
	{
		FVector ConvertRotation = Camera_rotation;

		auto ControlRotation = Read<FVector>(PlayerPTR.PCTR + offsets::control_rotation);
		FVector DeltaRotation = ConvertRotation - ControlRotation;

		ConvertRotation = Target - (DeltaRotation * SmoothFactor);

		FVector Smoothed = SMOOTHEDANGLES(Camera_rotation, ConvertRotation, SmoothFactor);
		Write<FVector>(PlayerPTR.PCTR + offsets::control_rotation, Smoothed);
	}
	
}
auto AIMBOT(DWORD_PTR entity) -> void
{
	FVector HITHEAD = GetBone(Read<uint64_t>(entity + offsets::MeshComponent), 8);

	
#include "../Valorant/Game/cheat.hpp"

	std::vector<PlayerContrPTR> PlayerPTR;


	FVector CLAMPEDANGLE = CLAMPEDVECTOR(HITHEAD, CameraLocation);
	for (PlayerContrPTR PlayerPTR : PPTR)
	{
		if (Settings::aimbot::smooth)
		{
			SMOOTHFACTOR(CLAMPEDANGLE, CameraRotation, Settings::aimbot::smoothness);
		}
		else
		Write<FVector>(PlayerPTR.PCTR + offsets::control_rotation, CLAMPEDANGLE);
	}

}

```

`Valorant/Auth/auth.hpp`:

```hpp
#include <Windows.h>
#include <iostream>
#include <vector>
#include <fstream>

namespace KeyAuth {
	class api {
	public:

		std::string name, ownerid, secret, version, url, sslPin;

		api(std::string name, std::string ownerid, std::string secret, std::string version, std::string url, std::string sslPin) : name(name), ownerid(ownerid), secret(secret), version(version), url(url), sslPin(sslPin) {}

		void ban();
		void init();
		void check();
		void log(std::string msg);
		void license(std::string key);
		std::string var(std::string varid);
		std::string webhook(std::string id, std::string params);
		void setvar(std::string var, std::string vardata);
		std::string getvar(std::string var);
		bool checkblack();
		void upgrade(std::string username, std::string key);
		void login(std::string username, std::string password);
		void web_login();
		void button(std::string value);
		std::vector<unsigned char> download(std::string fileid);
		void regstr(std::string username, std::string password, std::string key);

		class data_class {
		public:
			// app data
			std::string numUsers;
			std::string numOnlineUsers;
			std::string numKeys;
			std::string version;
			std::string customerPanelLink;
			// user data
			std::string username;
			std::string ip;
			std::string hwid;
			std::string createdate;
			std::string lastlogin;
			std::vector<std::string> subscriptions;
			std::string expiry;
			// response data
			bool success;
			std::string message;
		};
		data_class data;

	private:
		std::string sessionid, enckey;
	};
}

```

`Valorant/Driver/driver.h`:

```h
#pragma once
#include <TlHelp32.h>
#include <tchar.h>
#include "../Game/skStr.h"
#include "../Game/globals.hpp"
typedef struct _MEMORY_STRUCT
{
	BYTE type;
	LONG target_pid;
	ULONG64 base_address;
	const char* ModuleName;
	void* address;
	LONG size;
	void* output;

	ULONG_PTR Displacement;
	PVOID Buffer;
	ULONG Size;
	float X = 0.0f, Y = 0.0f;
}MEMORY_STRUCT;

NTSTATUS(*NtUserMessageCall)(HWND hWnd, UINT msg, PVOID wParam, PVOID lParam, ULONG_PTR ResultInfo, DWORD dwType, BOOLEAN bAnsi) = nullptr;
HWND ValidHwnd;
UINT MsgKey;

bool InitHandles() {
	LoadLibraryA(skCrypt("user32.dll"));
	LoadLibraryA(skCrypt("win32u.dll"));
	LoadLibraryA(skCrypt("ntdll.dll"));

	*(PVOID*)&NtUserMessageCall = GetProcAddress(
		GetModuleHandleA(skCrypt("win32u.dll")),
		skCrypt("NtUserMessageCall")
	);
	if (!NtUserMessageCall)
		return false;

	srand(GetTickCount64() * GetCurrentProcessId() * GetCurrentThreadId());
	MsgKey = 0xbd4 + (rand() % 0x1ffff);

	ValidHwnd = FindWindowA(skCrypt("WorkerW"), 0);
	if (INVALID_HANDLE_VALUE != ValidHwnd)
		return true;
	return false;
}

int GetProcessThreadNumByID(DWORD dwPID)
{
	HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hProcessSnap == INVALID_HANDLE_VALUE)
		return 0;

	PROCESSENTRY32 pe32 = { 0 };
	pe32.dwSize = sizeof(pe32);
	BOOL bRet = ::Process32First(hProcessSnap, &pe32);;
	while (bRet)
	{
		if (pe32.th32ProcessID == dwPID)
		{
			::CloseHandle(hProcessSnap);
			return pe32.cntThreads;
		}
		bRet = ::Process32Next(hProcessSnap, &pe32);
	}
	return 0;
}

int GetAowProcId()
{
	DWORD dwRet = 0;
	DWORD dwThreadCountMax = 0;
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);
	Process32First(hSnapshot, &pe32);
	do
	{
		if (_tcsicmp(pe32.szExeFile, skCrypt(L"VALORANT-Win64-Shipping.exe").decrypt
		()) == 0)

		{
			DWORD dwTmpThreadCount = GetProcessThreadNumByID(pe32.th32ProcessID);

			if (dwTmpThreadCount > dwThreadCountMax)
			{
				dwThreadCountMax = dwTmpThreadCount;
				dwRet = pe32.th32ProcessID;
			}
		}
	} while (Process32Next(hSnapshot, &pe32));
	CloseHandle(hSnapshot);
	return dwRet;
}

DWORD64 GetBaseAddress()
{
	MEMORY_STRUCT memory_struct = { 0 };
	memory_struct.type = 4;
	memory_struct.target_pid = process_id;
	NtUserMessageCall(ValidHwnd, MsgKey, &memory_struct, 0, 0xDEADBEEF, 16, 0);
	return memory_struct.base_address;
}


NTSTATUS ReadProcessMemory(uint64_t src, void* dest, uint32_t size)
{
	MEMORY_STRUCT memory_struct = { 0 };
	memory_struct.type = 2;
	memory_struct.target_pid = process_id;
	memory_struct.address = reinterpret_cast<void*>(src);
	memory_struct.output = dest;
	memory_struct.size = size;
	return NtUserMessageCall(ValidHwnd, MsgKey, &memory_struct, 0, 0xDEADBEEF, 16, 0);
}

bool ReadGuardedRegion(ULONG_PTR Displacement, PVOID pBuffer, ULONG cbBuffer)
{
	BOOL status = TRUE;

	MEMORY_STRUCT memory_struct = { 0 };
	memory_struct.type = 7;

	if (Displacement > 0x200000)
	{
		status = FALSE;
		goto exit;
	}

	RtlSecureZeroMemory(pBuffer, cbBuffer);
	memory_struct.Displacement = Displacement;
	memory_struct.Buffer = pBuffer;
	memory_struct.Size = cbBuffer;
	status = NtUserMessageCall(ValidHwnd, MsgKey, &memory_struct, 0, 0xDEADBEEF, 16, 0);

	if (!status)
	{
		goto exit;
	}

exit:
	return status;
}

template<typename T>
bool Read(DWORD_PTR Address, T* pBuffer, DWORD Size) {

	auto bRead = FALSE;
	auto Rsh_x24 = (Address >> 0x24);
	if (Rsh_x24 == 0x8 || Rsh_x24 == 0x10)
		bRead = ReadGuardedRegion(DWORD_PTR(Address & 0xFFFFFF), (PVOID)pBuffer, sizeof(T));
	else
		bRead = ReadProcessMemory(Address, (PVOID)pBuffer, sizeof(T));
	return bRead;
}

template<typename T>
T Read(DWORD_PTR Address)
{
	T Buffer{};
	Read(Address, &Buffer, sizeof(T));
	return Buffer;
}

template<typename T>
bool Write(uint64_t address, T buffer)
{
	MEMORY_STRUCT memory_struct = { 0 };
	memory_struct.type = 1;
	memory_struct.target_pid = process_id;
	memory_struct.address = reinterpret_cast<void*>(address);
	memory_struct.size = sizeof(T);
	memory_struct.output = &buffer;
	NtUserMessageCall(ValidHwnd, MsgKey, &memory_struct, 0, 0xDEADBEEF, 16, 0);
	return true;
}

void SetGuardedRegion()
{
	MEMORY_STRUCT memory_struct = { 0 };
	memory_struct.type = 6;
	NtUserMessageCall(ValidHwnd, MsgKey, &memory_struct, 0, 0xDEADBEEF, 16, 0);
}

```

`Valorant/Driver/loader.hpp`:

```hpp
#pragma once

```

`Valorant/Game/cheat.hpp`:

```hpp
#pragma once
#include "sdk.hpp"
#include <iostream>
#include "../Aimbot.h"
#include "../Skeleton.h"
#include "../Radar.h"
#include "../wav.c"
using namespace Globals;
using namespace Camera;
using namespace UNREALENGINE;
SCONTROLROTATION* AControlRotation;
WORLDFACTOR* UWorld;
SGAMEINSTANCE* UGameInstance;
SLOCALPLAYER* ULocalPlayer;
SPLAYERCONTROLLER* APlayerController;
SPAWN* APawn;
SACTOR* APrivatePawn;
SULEVEL* ULevel;
SUSKELETALMESH* USkeletalMeshComponent;
SUSKELETALMESH* SMesh;



auto CacheGame() -> void
{
	while (true)
	{
		std::vector<ValEntity> CachedList;

		auto WorldPtr = decryptWorld(image_base);

		auto ULevelPtr = UWorld->ULevel(WorldPtr);
		auto UGameInstancePtr = UWorld->GameInstance(WorldPtr);

		auto ULocalPlayerPtr = UGameInstance->ULocalPlayer(UGameInstancePtr);
		std::vector<PlayerContrPTR> PlayerPTR;
		auto APlayerControllerPtr = ULocalPlayer->APlayerController(ULocalPlayerPtr);
		PlayerContrPTR PlayerControllerPTR{ APlayerControllerPtr };
		PlayerPTR.push_back(PlayerControllerPTR);
		PPTR.clear();
		PPTR = PlayerPTR;
		std::vector<CameraM> CacheCamera;
		PlayerCameraManager = APlayerController->APlayerCameraManager(APlayerControllerPtr);
		CameraM ABCD{ PlayerCameraManager };
		CacheCamera.push_back(ABCD);
		CRiQC.clear();
		CRiQC = CacheCamera;
		auto MyHUD = APlayerController->AHUD(APlayerControllerPtr);
		
		auto APawnPtr = APlayerController->APawn(APlayerControllerPtr);

		if (APawnPtr != 0)
		{
			MyUniqueID = APawn->UniqueID(APawnPtr);
			MyTeamID = APawn->TeamID(APawnPtr);
			MyRelativeLocation = APawn->RelativeLocation(APawnPtr);
		}

		if (MyHUD != 0)
		{
			auto PlayerArray = ULevel->AActorArray(ULevelPtr);
			
			for (uint32_t i = 0; i < PlayerArray.Count; ++i)
			{
				//uintptr_t Actor = Read<uintptr_t>(PlayerArray + (i * 0x8));
				auto Pawns = PlayerArray[i];


				//CallAimbot(Pawns);
				if (Pawns != APawnPtr)
				{

					if (Settings::misc::option1)
					{
						switch (Settings::misc::enemyselect)
						{
						case 0: 
							if (MyUniqueID == APawn->UniqueID(Pawns) && MyTeamID != APawn->TeamID(Pawns))
							{
								ValEntity Entities{ Pawns };
								CachedList.push_back(Entities);
							}
							break;
						case 1:
							if (MyUniqueID == APawn->UniqueID(Pawns)) //&& MyTeamID != APawn->TeamID(Pawns))
							{
								ValEntity Entities{ Pawns };
								CachedList.push_back(Entities);
							}
							break;
						case 2:
							break;
						}

					}

				}
				
			}
			
			ValList.clear();
			ValList = CachedList;
			Sleep(1000);
		}
	}
}

auto CheatLoop() -> void
{

	if (Settings::aimbot::drawfov)
	{
		DrawAimbotFov(ScreenCenterX, ScreenCenterY, Settings::aimbot::fov, &Col.blue, 1);
	}
	if (Settings::Visuals::FPS)
	{

		ImVec2 abc = ImVec2(0, 0);
		DrawFPS(abc);

	}
	float closestDistance = FLT_MAX;


	for (ValEntity ValEntityList : ValList)
	{
		DWORD_PTR closestPawn1 = NULL;
		auto SkeletalMesh = APrivatePawn->USkeletalMeshComponent(ValEntityList.Actor);
		auto RelativeLocation = APawn->RelativeLocation(ValEntityList.Actor);
		auto RelativeLocationProjected = UNREALENGINE::SDK::ProjectWorldToScreen(RelativeLocation);
		auto CameraManager = Read<uintptr_t>(PlayerCameraManager + offsets::PlayerCameraManager);

		for (CameraM CameraCacheList : CRiQC)
		{

		
			if (Settings::Visuals::fovchanger)
			{
				Write<float>(CameraCacheList.CameraMCRiQ + offsets::CameraFOVChange, Settings::Visuals::fovchangervalue);

			}
		}

		auto RelativePosition = RelativeLocation - CameraLocation;
		auto RelativeDistance = RelativePosition.Length() / 10000 * 2;

		auto HeadBone = UNREALENGINE::SDK::GetEntityBone(SkeletalMesh, 8);
		auto HeadBoneProjected = UNREALENGINE::SDK::ProjectWorldToScreen(HeadBone);
		auto HeadBoneProjected2 = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(HeadBone.x, HeadBone.y, HeadBone.z ));
		auto RootBone = UNREALENGINE::SDK::GetEntityBone(SkeletalMesh, 0);
		auto RootBoneProjected = UNREALENGINE::SDK::ProjectWorldToScreen(RootBone);
		auto RootBoneProjected2 = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(RootBone.x, RootBone.y, RootBone.z - 15));
		auto Distance = MyRelativeLocation.Distance(RelativeLocation);

		auto ControlRotation = AControlRotation->AControlRotation(ValEntityList.Actor);
		float BoxHeight = abs(HeadBoneProjected.y - RootBoneProjected.y);
		float BoxWidth = BoxHeight * 0.40;



		
		auto dx = HeadBoneProjected2.x - (Width / 2);
		auto dy = HeadBoneProjected2.y - (Height / 2);
		auto dist = sqrtf(dx * dx + dy * dy);

		if (dist < Settings::aimbot::fov && dist < closestDistance)
		{
			if (Settings::aimbot::vischeck)
			{
				closestDistance = dist;
				closestPawn1 = ValEntityList.Actor;
			}
			else
			{
				closestDistance = dist;
				closestPawn1 = ValEntityList.Actor;
			}
		}	
		auto Health = APawn->Health(ValEntityList.Actor);
		auto IsVisible = isVisible(SkeletalMesh);
		if (Settings::misc::radar) {

			if (GetAsyncKeyState(VK_F1) & 1) { Settings::bRadar = !Settings::bRadar; }
			if (Settings::bRadar)
			{
				DrawRadar(RelativePosition);
			}

		}
		if (Health <= 0) continue;
		if (Distance < NewFeatures::renderdistance)
		{
			
			if (APawn->bIsDormant(ValEntityList.Actor))
			{
				std::vector<SSkeletal> SkeletalPTR;
				auto GetBones = SMesh->BoneCount(SkeletalMesh);
				SSkeletal SSkeletalPTR{ GetBones };
				SkeletalPTR.push_back(SSkeletalPTR);
				SPTR.clear();
				SPTR = SkeletalPTR;
				if (IsVisible)
				{
	
					if (Settings::Visuals::bSnaplines)
						DrawTracers(RootBoneProjected, ImColor(colors::snaplines[0], colors::snaplines[1], colors::snaplines[2], colors::snaplines[3]));
					if (Settings::Visuals::bBox)
						Draw2DBox(RelativeLocationProjected, BoxWidth, BoxHeight, ImColor(colors::box[0], colors::box[1], colors::box[2], colors::box[3]));

					if (Settings::Visuals::bBoxOutlined)
						DrawOutlinedBox(RelativeLocationProjected, BoxWidth, BoxHeight, ImColor(colors::boxoutline[0], colors::boxoutline[1], colors::boxoutline[2], colors::boxoutline[3]));
					if (Settings::Visuals::HeadCircle)
					{
						DrawCircleFilled3(HeadBoneProjected.x, HeadBoneProjected.y, (HeadBoneProjected.y) / Settings::misc::headsize, ImColor(colors::Head[0], colors::Head[1], colors::Head[2], colors::Head[3]));
					}
				}
				else
				{

					if (Settings::Visuals::bSnaplines)
						DrawTracers(RootBoneProjected, ImColor(colors::snaplinesinvisible[0], colors::snaplinesinvisible[1], colors::snaplinesinvisible[2], colors::snaplinesinvisible[3]));
					if (Settings::Visuals::bBox)
						Draw2DBox(RelativeLocationProjected, BoxWidth, BoxHeight, ImColor(colors::boxinvisible[0], colors::boxinvisible[1], colors::boxinvisible[2], colors::boxinvisible[3]));

					if (Settings::Visuals::bBoxOutlined)
						DrawOutlinedBox(RelativeLocationProjected, BoxWidth, BoxHeight, ImColor(colors::boxoutlineinvisible[0], colors::boxoutlineinvisible[1], colors::boxoutlineinvisible[2], colors::boxoutlineinvisible[3]));

				}

				if (Settings::Visuals::bHealth)
					DrawHealthBar(RelativeLocationProjected, BoxWidth, BoxHeight, Health, RelativeDistance);

				if (Settings::Visuals::bDistance)
					DrawDistance(RootBoneProjected2, Distance);
				if (NewFeatures::ActorCountDebug)
				{
						DrawActorDebug(RootBoneProjected2);
						NewFeatures::curractors = ValList.size();
				}
				if (Settings::aimbot::aimbot)
				{
					if (ValEntityList.Actor != 0)
					{
						if (closestPawn1 && GetAsyncKeyState(hotkeys::aimkey) < 0)
						{
							if (IsVisible) 
							{
								AIMBOT(closestPawn1);
							}
						}
					}
			
				
				}
				if (Settings::Visuals::TDBox)
				{
					if (IsVisible)
					{

						if (HeadBoneProjected2.x != 0 || HeadBoneProjected2.y != 0 || HeadBoneProjected2.z != 0)
						{
							FVector BOTTOMSIDELEFT = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(RootBone.x + 40, RootBone.y - 40, RootBone.z));
							FVector BOTTOMSIDERIGHT = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(RootBone.x - 40, RootBone.y - 40, RootBone.z));
							FVector BOTTOMSIDELEFT1 = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(RootBone.x - 40, RootBone.y + 40, RootBone.z));
							FVector BOTTOMSIDELEFT2 = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(RootBone.x + 40, RootBone.y + 40, RootBone.z));
							FVector TOPSIDELEFT = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(HeadBone.x + 40, HeadBone.y - 40, HeadBone.z + 15));
							FVector TOPSIDERIGHT = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(HeadBone.x - 40, HeadBone.y - 40, HeadBone.z + 15));
							FVector TOPSIDELEFT1 = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(HeadBone.x - 40, HeadBone.y + 40, HeadBone.z + 15));
							FVector TOPSIDELEFT2 = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(HeadBone.x + 40, HeadBone.y + 40, HeadBone.z + 15));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT.x, BOTTOMSIDELEFT.y), ImVec2(TOPSIDELEFT.x, TOPSIDELEFT.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDERIGHT.x, BOTTOMSIDERIGHT.y), ImVec2(TOPSIDERIGHT.x, TOPSIDERIGHT.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT1.x, BOTTOMSIDELEFT1.y), ImVec2(TOPSIDELEFT1.x, TOPSIDELEFT1.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT2.x, BOTTOMSIDELEFT2.y), ImVec2(TOPSIDELEFT2.x, TOPSIDELEFT2.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT.x, BOTTOMSIDELEFT.y), ImVec2(BOTTOMSIDERIGHT.x, BOTTOMSIDERIGHT.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDERIGHT.x, BOTTOMSIDERIGHT.y), ImVec2(BOTTOMSIDELEFT1.x, BOTTOMSIDELEFT1.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT1.x, BOTTOMSIDELEFT1.y), ImVec2(BOTTOMSIDELEFT2.x, BOTTOMSIDELEFT2.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT2.x, BOTTOMSIDELEFT2.y), ImVec2(BOTTOMSIDELEFT.x, BOTTOMSIDELEFT.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(TOPSIDELEFT.x, TOPSIDELEFT.y), ImVec2(TOPSIDERIGHT.x, TOPSIDERIGHT.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(TOPSIDERIGHT.x, TOPSIDERIGHT.y), ImVec2(TOPSIDELEFT1.x, TOPSIDELEFT1.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(TOPSIDELEFT1.x, TOPSIDELEFT1.y), ImVec2(TOPSIDELEFT2.x, TOPSIDELEFT2.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(TOPSIDELEFT2.x, TOPSIDELEFT2.y), ImVec2(TOPSIDELEFT.x, TOPSIDELEFT.y), ImColor(colors::TDBox[0], colors::TDBox[1], colors::TDBox[2], colors::TDBox[3]));
						}
					}
					else
					{
						if (HeadBoneProjected2.x != 0 || HeadBoneProjected2.y != 0 || HeadBoneProjected2.z != 0)
						{
							FVector BOTTOMSIDELEFT = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(RootBone.x + 40, RootBone.y - 40, RootBone.z));
							FVector BOTTOMSIDERIGHT = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(RootBone.x - 40, RootBone.y - 40, RootBone.z));
							FVector BOTTOMSIDELEFT1 = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(RootBone.x - 40, RootBone.y + 40, RootBone.z));
							FVector BOTTOMSIDELEFT2 = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(RootBone.x + 40, RootBone.y + 40, RootBone.z));
							FVector TOPSIDELEFT = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(HeadBone.x + 40, HeadBone.y - 40, HeadBone.z + 15));
							FVector TOPSIDERIGHT = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(HeadBone.x - 40, HeadBone.y - 40, HeadBone.z + 15));
							FVector TOPSIDELEFT1 = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(HeadBone.x - 40, HeadBone.y + 40, HeadBone.z + 15));
							FVector TOPSIDELEFT2 = UNREALENGINE::SDK::ProjectWorldToScreen(FVector(HeadBone.x + 40, HeadBone.y + 40, HeadBone.z + 15));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT.x, BOTTOMSIDELEFT.y), ImVec2(TOPSIDELEFT.x, TOPSIDELEFT.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDERIGHT.x, BOTTOMSIDERIGHT.y), ImVec2(TOPSIDERIGHT.x, TOPSIDERIGHT.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT1.x, BOTTOMSIDELEFT1.y), ImVec2(TOPSIDELEFT1.x, TOPSIDELEFT1.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT2.x, BOTTOMSIDELEFT2.y), ImVec2(TOPSIDELEFT2.x, TOPSIDELEFT2.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT.x, BOTTOMSIDELEFT.y), ImVec2(BOTTOMSIDERIGHT.x, BOTTOMSIDERIGHT.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDERIGHT.x, BOTTOMSIDERIGHT.y), ImVec2(BOTTOMSIDELEFT1.x, BOTTOMSIDELEFT1.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT1.x, BOTTOMSIDELEFT1.y), ImVec2(BOTTOMSIDELEFT2.x, BOTTOMSIDELEFT2.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(BOTTOMSIDELEFT2.x, BOTTOMSIDELEFT2.y), ImVec2(BOTTOMSIDELEFT.x, BOTTOMSIDELEFT.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(TOPSIDELEFT.x, TOPSIDELEFT.y), ImVec2(TOPSIDERIGHT.x, TOPSIDERIGHT.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(TOPSIDERIGHT.x, TOPSIDERIGHT.y), ImVec2(TOPSIDELEFT1.x, TOPSIDELEFT1.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(TOPSIDELEFT1.x, TOPSIDELEFT1.y), ImVec2(TOPSIDELEFT2.x, TOPSIDELEFT2.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
							ImGui::GetForegroundDrawList()->AddLine(ImVec2(TOPSIDELEFT2.x, TOPSIDELEFT2.y), ImVec2(TOPSIDELEFT.x, TOPSIDELEFT.y), ImColor(colors::TDBox1[0], colors::TDBox1[1], colors::TDBox1[2], colors::TDBox1[3]));
						}
					}
				}
				if (Settings::Visuals::Skeleton)
				{
					if (IsVisible)
					{

						
						colors::skeleton[0] = 0.f;
						colors::skeleton[1] = 1.f;
						colors::skeleton[2] = 0.f;
						colors::skeleton[3] = 1.f;



					}
					else
					{
						colors::skeleton[0] = { 1.f };
						colors::skeleton[1] = { 0.f };
						colors::skeleton[2] = { 0.f };
						colors::skeleton[3] = { 1.f };
					}
					renderBones(SkeletalMesh);
				}
			}
		}
	}
	//Sleep(10);
}

```

`Valorant/Game/globals.hpp`:

```hpp
#pragma once
#include <Windows.h>

HWND Entryhwnd = NULL;
int processid = 0;
int process_id;
DWORD64 image_base;
DWORD_PTR PlayerState;
namespace CRiQTest
{
    uintptr_t APlayerController;
    inline uintptr_t g_localplayerpawn;
    inline uintptr_t g_localplayercontroller;
    inline int team_id1;
    uintptr_t Mesh;
}
namespace test
{
    uintptr_t abc;
}
namespace offsets
{
    DWORD
        World_Key = 0x8FB80F8,
        World_State = 0x8FB80C0,
        //
        Gameinstance = 0x1A0,
        Ulevel = 0x38,
        LocalPlayers = 0x40,
        PlayerController = 0x38,
        PlayerCameraManager = 0x478,
        MyHUD = 0x470, //struct AHUD* MyHUD; // 0x470(0x08)
        AcknowledgedPawn = 0x460,
        PlayerState = 0x3f0,
        TeamComponent = 0x628,
        TeamID = 0xf8,
        CameraFOVChange = 0x3f4,// 0x3f4(0x04)
        UniqueID = 0x38,
        FNameID = 0x18,
        AActorArray = 0xa0,
        RootComponent = 0x230,
        RelativeLocation = 0x164,
        MeshComponent = 0x430,
        DamageHandler = 0x9a8,
        bIsDormant = 0x100,
        Health = 0x1b0,
        ComponentToWorld = 0x250,
        BoneArray = 0x5C0,
        BoneArrayCache = BoneArray + 0x10,
        BoneCount = 0x5c8,
        last_submit_time = 0x378,
        last_render_time = last_submit_time + 0x4,
        bone_array = 0x5C0,
        bone_count = bone_array + 0x8,
        control_rotation = 0x440,
        bone_id = 0x30,
        camera_cache = 0x1FE0,
        PlayerCache = 0x10,
        inventory = 0x948,
        ammo_info = 0xFB0,
        current_ammo = 0xFB0,
        current_equipable = 0x228,
        max_ammo = 0x11C,
        ActorCount = 0xB8,
        CameraRotation = 0x126C,
        CameraPosition = 0x1260,
        bone_array_fail = 0x568;
}
namespace colors {

    inline float snaplines[] = { 0.f,1.f,0.f,1.f };
    inline float HP[] = { 0.f,1.f,0.f,1.f };
    inline float snaplinesinvisible[] = { 1.f,0.f,0.f,1.f };
    inline float box[] = { 0.f,1.f,0.f,1.f };
    inline float boxoutline[] = { 0.f,1.f,0.f,1.f };
    inline float boxinvisible[] = { 1.f,0.f,0.f,1.f };
    inline float boxoutlineinvisible[] = { 1.f,0.f,0.f,1.f };
    inline float BLAHBLAH[] = { 0.f,1.f,0.f,1.f };
    inline float skeleton[] = { 0.f,1.f,0.f,1.f };
    inline float skeletoninvisible[] = { 1.f,0.f,0.f,1.f };
    inline float Head[] = { 1.f,0.f,0.f,1.f };
    inline float TDBox[] = { 0.f,1.f,0.f,1.f };
    inline float TDBox1[] = { 1.f,0.f,0.f,1.f };
    inline float radar[] = { 1.f,0.f,1.f,1.f };
    inline float ImGuiCol_Border[] = { 1.f,0.f,0.f,1.f };
    inline float ImGuiCol_TitleBg[] = { 132.f ,0.f,181.f,0.3f };

}
namespace Settings
{
    inline bool bMenu = true;
    inline bool bRadar = false;
    inline bool TEST = false;
    namespace Visuals
    {
        inline float skeletonwidht = 0.5f;
        inline bool bSnaplines = false;
        inline bool bDistance = false;
        inline bool bBox = false;
        inline bool bBoxOutlined = false;
        inline bool HeadCircle = false;
        inline bool bHealth = false;
        inline bool Skeleton = false;
        inline float BoxWidth = 1.0f;
        inline float fovchangervalue;
        inline bool fovchanger = false;
        inline bool ammowarning = false;
        inline int customwarning = 4;
        inline bool isVisibleGlobal;
        inline bool FPS;
        inline bool TDBox = false;
    }
    namespace aimbot
    {
        inline bool aimbot = false;
        inline float fov = 50;
        inline float smoothness = 1.0f;
        inline bool smooth = false;
        inline bool drawfov = false;
        inline bool vischeck = false;
        inline bool filledfov = false;
    }
    namespace misc
    {
        inline bool option1 = true;
        inline float headsize = 0;

        inline int enemyselect = 0;
        inline bool radar = false;
        inline float radarentitysize = 3.0f;
        inline float Size = 256;
        static const char* Teams[]{ "Enemy", "Bots", "None" };
    }
}

namespace NewFeatures
{
    inline float renderdistance = 750;
    inline bool ActorCountDebug = false;
    inline int curractors = 0;
}


```

`Valorant/Game/sdk.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <map>
#include <d3d9types.h>
#include "../Overlay/render.hpp"
#include "../Driver/driver.h"
#include "structs.hpp"
#include <vector>
#include "../defs.h"
using namespace UE4Structs;

namespace Globals
{

	DWORD_PTR
		LocalPlayer,
		PlayerController,
		PlayerCameraManager;

	int MyUniqueID, MyTeamID, BoneCount;
	inline int g_localteamid;
	FVector MyRelativeLocation, closestPawn;

	namespace Camera
	{
		FVector CameraLocation, CameraRotation, TargetRotation;
		float FovAngle;
	}


}

using namespace Globals;
using namespace Camera;


namespace UNREALENGINE
{

	struct SGAMEINSTANCE {
		uintptr_t ULocalPlayer(uintptr_t UGameInstance) {
			auto ULocalPlayerArray = Read<uintptr_t>(UGameInstance + offsets::LocalPlayers);
			return Read<uintptr_t>(ULocalPlayerArray);
		};
	};

	struct SULEVEL {
		TArrayDrink<uintptr_t> AActorArray(uintptr_t ULevel) {
			return Read<TArrayDrink<uintptr_t>>(ULevel + offsets::AActorArray);
		};
	};



	struct SUSKELETALMESH {
		int BoneCount(uintptr_t Mesh) {
			return Read<uintptr_t>(Mesh + offsets::BoneCount);
		};
	};

	struct SLOCALPLAYER {
		uintptr_t APlayerController(uintptr_t ULocalPlayer) {
			return Read<uintptr_t>(ULocalPlayer + offsets::PlayerController);
		};
	};
	struct SACTOR {
		uintptr_t USkeletalMeshComponent(uintptr_t Pawn) {
			return Read<uintptr_t>(Pawn + offsets::MeshComponent);
		};
	};
	struct SPLAYERCONTROLLER {
		uintptr_t APlayerCameraManager(uintptr_t APlayerController) {
			return Read<uintptr_t>(APlayerController + offsets::PlayerCameraManager);
		};
		uintptr_t AHUD(uintptr_t APlayerController) {
			return Read<uintptr_t>(APlayerController + offsets::MyHUD);
		};
		uintptr_t APawn(uintptr_t APlayerController) {
			return Read<uintptr_t>(APlayerController + offsets::AcknowledgedPawn);
		};
	};
	struct SCONTROLROTATION {
		uintptr_t AControlRotation(uintptr_t APlayerController) {
			return Read<uintptr_t>(APlayerController + offsets::control_rotation);
		};
	};
	struct WORLDFACTOR
	{
		uintptr_t GameInstance(uintptr_t GameWorld) {
			return Read<uintptr_t>(GameWorld + offsets::Gameinstance);
		};

		uintptr_t ULevel(uintptr_t World) {
			return Read<uintptr_t>(World + offsets::Ulevel);
		};
	};
	struct SPAWN {
		auto TeamID(uintptr_t APawn) -> int {
			auto PlayerState = Read<uintptr_t>(APawn + offsets::PlayerState);
			auto TeamComponent = Read<uintptr_t>(PlayerState + offsets::TeamComponent);
			return Read<int>(TeamComponent + offsets::TeamID);
		};

		auto UniqueID(uintptr_t APawn) -> int {
			return Read<int>(APawn + offsets::UniqueID);
		};

		auto FNameID(uintptr_t APawn) -> int {
			return Read<int>(APawn + offsets::FNameID);
		};

		auto RelativeLocation(uintptr_t APawn) -> FVector {
			auto RootComponent = Read<uintptr_t>(APawn + offsets::RootComponent);
			return Read<FVector>(RootComponent + offsets::RelativeLocation);
		};

		auto bIsDormant(uintptr_t APawn) -> bool {
			return Read<bool>(APawn + offsets::bIsDormant);
		};

		auto Health(uintptr_t APawn) -> float {
			auto DamageHandler = Read<uintptr_t>(APawn + offsets::DamageHandler);
			return Read<float>(DamageHandler + offsets::Health);
		};
	};

	auto GetWorld(uintptr_t Pointer) -> uintptr_t
	{
		std::uintptr_t uworld_addr = Read<uintptr_t>(Pointer + 0x50);

		unsigned long long uworld_offset;

		if (uworld_addr > 0x10000000000)
		{
			uworld_offset = uworld_addr - 0x10000000000;
		}
		else {
			uworld_offset = uworld_addr - 0x8000000000;
		}

		return Pointer + uworld_offset;
	}
	auto isVisible(DWORD_PTR mesh) -> bool
	{
		float fLastSubmitTime = Read<float>(mesh + offsets::last_submit_time);
		float fLastRenderTimeOnScreen = Read<float>(mesh + offsets::last_render_time);

		const float fVisionTick = 0.06f;
		bool bVisible = fLastRenderTimeOnScreen + fVisionTick >= fLastSubmitTime;

		return bVisible;
	}


	namespace SDK
	{
		auto GetEntityBone(DWORD_PTR mesh, int id) -> FVector
		{
			DWORD_PTR array = Read<uintptr_t>(mesh + offsets::BoneArray);
			if (array == NULL)
				array = Read<uintptr_t>(mesh + offsets::BoneArrayCache);

			FTransform bone = Read<FTransform>(array + (id * 0x30));

			FTransform ComponentToWorld = Read<FTransform>(mesh + offsets::ComponentToWorld);
			D3DMATRIX Matrix;

			Matrix = MatrixMultiplication(bone.ToMatrixWithScale(), ComponentToWorld.ToMatrixWithScale());

			return FVector(Matrix._41, Matrix._42, Matrix._43);
		}

		auto ProjectWorldToScreen(FVector WorldLocation) -> FVector
		{
			FVector Screenlocation = FVector(0, 0, 0);

			auto ViewInfo = Read<FMinimalViewInfo>(PlayerCameraManager + offsets::camera_cache + offsets::PlayerCache);

			CameraLocation = ViewInfo.Location;
			CameraRotation = ViewInfo.Rotation;


			D3DMATRIX tempMatrix = Matrix(CameraRotation, FVector(0, 0, 0));

			FVector vAxisX = FVector(tempMatrix.m[0][0], tempMatrix.m[0][1], tempMatrix.m[0][2]),
				vAxisY = FVector(tempMatrix.m[1][0], tempMatrix.m[1][1], tempMatrix.m[1][2]),
				vAxisZ = FVector(tempMatrix.m[2][0], tempMatrix.m[2][1], tempMatrix.m[2][2]);

			FVector vDelta = WorldLocation - CameraLocation;
			FVector vTransformed = FVector(vDelta.Dot(vAxisY), vDelta.Dot(vAxisZ), vDelta.Dot(vAxisX));

			if (vTransformed.z < 1.f) vTransformed.z = 1.f;

			FovAngle = ViewInfo.FOV;

			float ScreenCenterX = Width / 2.0f;
			float ScreenCenterY = Height / 2.0f;

			Screenlocation.x = ScreenCenterX + vTransformed.x * (ScreenCenterX / tanf(FovAngle * (float)M_PI / 360.f)) / vTransformed.z;
			Screenlocation.y = ScreenCenterY - vTransformed.y * (ScreenCenterX / tanf(FovAngle * (float)M_PI / 360.f)) / vTransformed.z;

			return Screenlocation;
		}

		bool IsVec3Valid(FVector vec3)
		{
			return !(vec3.x == 0 && vec3.y == 0 && vec3.z == 0);
		}
	}
}

uintptr_t decryptWorld(uintptr_t base_address)
{
	const auto key = Read<uintptr_t>(image_base + offsets::World_Key);
	const auto state = Read<State>(image_base + offsets::World_State);
	const auto uworld_ptr = decrypt_uworld(key, (uintptr_t*)&state);
	return Read<uintptr_t>(uworld_ptr);
}

```

`Valorant/Game/skStr.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________

Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file

skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+

							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________

MIT License

Copyright (c) 2020 skadro

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

________________________________________________________________________________*/
```

`Valorant/Game/structs.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <map>
#include <d3d9types.h>
#include <vector>
#include "../Driver/driver.h"

#define M_PI 3.14159265358979323846264338327950288419716939937510

namespace UE4Structs
{
	typedef struct _ValEntity {
		uint64_t Actor;
		int TypeActor;
	}ValEntity;
	std::vector<ValEntity> ValList;
	typedef struct _CameraM {
		uint64_t CameraMCRiQ;
	}CameraM;
	std::vector<CameraM> CRiQC;
	typedef struct _PlayerControllerPTR {
		uint64_t PCTR;
	}PlayerContrPTR;
	std::vector<PlayerContrPTR> PPTR;
	//
	typedef struct _EnemyTeam {
		uint64_t EnemyCheck;
	}EnemyTeam;
	std::vector<EnemyTeam> EEE;
	//
	typedef struct _SSkeletal {
		int Skeletal;
	}SSkeletal;
	std::vector<SSkeletal> SPTR;
	class FVector
	{
	public:
		FVector() : x(0.f), y(0.f), z(0.f)
		{

		}

		FVector(float _x, float _y, float _z) : x(_x), y(_y), z(_z)
		{

		}
		~FVector()
		{

		}

		float x;
		float y;
		float z;
		inline float Length2D() {
			return sqrtf((x * x) + (y * y));
		}
		FVector Clamp()
		{

			FVector clamped = { x, y, 0 };
			while (clamped.y < -180.0f)
				clamped.y += 360.0f;
			while (clamped.y > 180.0f)
				clamped.y -= 360.0f;
			while (clamped.x < -180.0f)
				clamped.x += 360.0f;
			while (clamped.x > 180.0f)
				clamped.x -= 360.0f;
			return clamped;
		}
		inline float Dot(FVector v)
		{
			return x * v.x + y * v.y + z * v.z;
		}

		inline float Distance(FVector v)
		{
			float x = this->x - v.x;
			float y = this->y - v.y;
			float z = this->z - v.z;

			return sqrtf((x * x) + (y * y) + (z * z)) * 0.03048f;
		}

		FVector operator+(FVector v)
		{
			return FVector(x + v.x, y + v.y, z + v.z);
		}

		FVector operator-(FVector v)
		{
			return FVector(x - v.x, y - v.y, z - v.z);
		}

		FVector operator*(float number) const {
			return FVector(x * number, y * number, z * number);
		}

		__forceinline float Magnitude() const {
			return sqrtf(x * x + y * y + z * z);
		}

		inline float Length()
		{
			return sqrtf((x * x) + (y * y) + (z * z));
		}

		__forceinline FVector Normalize() {
			FVector vector;
			float length = this->Magnitude();

			if (length != 0) {
				vector.x = x / length;
				vector.y = y / length;
				vector.z = z / length;
			}
			else {
				vector.x = vector.y = 0.0f;
				vector.z = 1.0f;
			}
			return vector;
		}

		__forceinline FVector& operator+=(const FVector& v) {
			x += v.x;
			y += v.y;
			z += v.z;
			return *this;
		}
	};
	struct State {
	uintptr_t keys[7];
};

	D3DXMATRIX Matrix(FVector rot, FVector origin)
	{
		float radPitch = (rot.x * float(M_PI) / 180.f);
		float radYaw = (rot.y * float(M_PI) / 180.f);
		float radRoll = (rot.z * float(M_PI) / 180.f);

		float SP = sinf(radPitch);
		float CP = cosf(radPitch);
		float SY = sinf(radYaw);
		float CY = cosf(radYaw);
		float SR = sinf(radRoll);
		float CR = cosf(radRoll);

		D3DMATRIX matrix;
		matrix.m[0][0] = CP * CY;
		matrix.m[0][1] = CP * SY;
		matrix.m[0][2] = SP;
		matrix.m[0][3] = 0.f;

		matrix.m[1][0] = SR * SP * CY - CR * SY;
		matrix.m[1][1] = SR * SP * SY + CR * CY;
		matrix.m[1][2] = -SR * CP;
		matrix.m[1][3] = 0.f;

		matrix.m[2][0] = -(CR * SP * CY + SR * SY);
		matrix.m[2][1] = CY * SR - CR * SP * SY;
		matrix.m[2][2] = CR * CP;
		matrix.m[2][3] = 0.f;

		matrix.m[3][0] = origin.x;
		matrix.m[3][1] = origin.y;
		matrix.m[3][2] = origin.z;
		matrix.m[3][3] = 1.f;

		return matrix;
	}

	struct FQuat
	{
		float x;
		float y;
		float z;
		float w;
	};

	struct FTransform
	{
		FQuat rot;
		FVector translation;
		char pad[4];
		FVector scale;
		char pad1[4];

		D3DMATRIX ToMatrixWithScale()
		{
			D3DMATRIX m;
			m._41 = translation.x;
			m._42 = translation.y;
			m._43 = translation.z;

			float x2 = rot.x + rot.x;
			float y2 = rot.y + rot.y;
			float z2 = rot.z + rot.z;

			float xx2 = rot.x * x2;
			float yy2 = rot.y * y2;
			float zz2 = rot.z * z2;
			m._11 = (1.0f - (yy2 + zz2)) * scale.x;
			m._22 = (1.0f - (xx2 + zz2)) * scale.y;
			m._33 = (1.0f - (xx2 + yy2)) * scale.z;

			float yz2 = rot.y * z2;
			float wx2 = rot.w * x2;
			m._32 = (yz2 - wx2) * scale.z;
			m._23 = (yz2 + wx2) * scale.y;

			float xy2 = rot.x * y2;
			float wz2 = rot.w * z2;
			m._21 = (xy2 - wz2) * scale.y;
			m._12 = (xy2 + wz2) * scale.x;

			float xz2 = rot.x * z2;
			float wy2 = rot.w * y2;
			m._31 = (xz2 + wy2) * scale.z;
			m._13 = (xz2 - wy2) * scale.x;

			m._14 = 0.0f;
			m._24 = 0.0f;
			m._34 = 0.0f;
			m._44 = 1.0f;

			return m;
		}
	};
	D3DMATRIX MatrixMultiplication1(D3DMATRIX pM1, D3DMATRIX pM2)
	{
		D3DMATRIX pOut;
		pOut._11 = pM1._11 * pM2._11 + pM1._12 * pM2._21 + pM1._13 * pM2._31 + pM1._14 * pM2._41;
		pOut._12 = pM1._11 * pM2._12 + pM1._12 * pM2._22 + pM1._13 * pM2._32 + pM1._14 * pM2._42;
		pOut._13 = pM1._11 * pM2._13 + pM1._12 * pM2._23 + pM1._13 * pM2._33 + pM1._14 * pM2._43;
		pOut._14 = pM1._11 * pM2._14 + pM1._12 * pM2._24 + pM1._13 * pM2._34 + pM1._14 * pM2._44;
		pOut._21 = pM1._21 * pM2._11 + pM1._22 * pM2._21 + pM1._23 * pM2._31 + pM1._24 * pM2._41;
		pOut._22 = pM1._21 * pM2._12 + pM1._22 * pM2._22 + pM1._23 * pM2._32 + pM1._24 * pM2._42;
		pOut._23 = pM1._21 * pM2._13 + pM1._22 * pM2._23 + pM1._23 * pM2._33 + pM1._24 * pM2._43;
		pOut._24 = pM1._21 * pM2._14 + pM1._22 * pM2._24 + pM1._23 * pM2._34 + pM1._24 * pM2._44;
		pOut._31 = pM1._31 * pM2._11 + pM1._32 * pM2._21 + pM1._33 * pM2._31 + pM1._34 * pM2._41;
		pOut._32 = pM1._31 * pM2._12 + pM1._32 * pM2._22 + pM1._33 * pM2._32 + pM1._34 * pM2._42;
		pOut._33 = pM1._31 * pM2._13 + pM1._32 * pM2._23 + pM1._33 * pM2._33 + pM1._34 * pM2._43;
		pOut._34 = pM1._31 * pM2._14 + pM1._32 * pM2._24 + pM1._33 * pM2._34 + pM1._34 * pM2._44;
		pOut._41 = pM1._41 * pM2._11 + pM1._42 * pM2._21 + pM1._43 * pM2._31 + pM1._44 * pM2._41;
		pOut._42 = pM1._41 * pM2._12 + pM1._42 * pM2._22 + pM1._43 * pM2._32 + pM1._44 * pM2._42;
		pOut._43 = pM1._41 * pM2._13 + pM1._42 * pM2._23 + pM1._43 * pM2._33 + pM1._44 * pM2._43;
		pOut._44 = pM1._41 * pM2._14 + pM1._42 * pM2._24 + pM1._43 * pM2._34 + pM1._44 * pM2._44;

		return pOut;
	}
	D3DMATRIX MatrixMultiplication(D3DMATRIX pM1, D3DMATRIX pM2)
	{
		D3DMATRIX pOut;
		pOut._11 = pM1._11 * pM2._11 + pM1._12 * pM2._21 + pM1._13 * pM2._31 + pM1._14 * pM2._41;
		pOut._12 = pM1._11 * pM2._12 + pM1._12 * pM2._22 + pM1._13 * pM2._32 + pM1._14 * pM2._42;
		pOut._13 = pM1._11 * pM2._13 + pM1._12 * pM2._23 + pM1._13 * pM2._33 + pM1._14 * pM2._43;
		pOut._14 = pM1._11 * pM2._14 + pM1._12 * pM2._24 + pM1._13 * pM2._34 + pM1._14 * pM2._44;
		pOut._21 = pM1._21 * pM2._11 + pM1._22 * pM2._21 + pM1._23 * pM2._31 + pM1._24 * pM2._41;
		pOut._22 = pM1._21 * pM2._12 + pM1._22 * pM2._22 + pM1._23 * pM2._32 + pM1._24 * pM2._42;
		pOut._23 = pM1._21 * pM2._13 + pM1._22 * pM2._23 + pM1._23 * pM2._33 + pM1._24 * pM2._43;
		pOut._24 = pM1._21 * pM2._14 + pM1._22 * pM2._24 + pM1._23 * pM2._34 + pM1._24 * pM2._44;
		pOut._31 = pM1._31 * pM2._11 + pM1._32 * pM2._21 + pM1._33 * pM2._31 + pM1._34 * pM2._41;
		pOut._32 = pM1._31 * pM2._12 + pM1._32 * pM2._22 + pM1._33 * pM2._32 + pM1._34 * pM2._42;
		pOut._33 = pM1._31 * pM2._13 + pM1._32 * pM2._23 + pM1._33 * pM2._33 + pM1._34 * pM2._43;
		pOut._34 = pM1._31 * pM2._14 + pM1._32 * pM2._24 + pM1._33 * pM2._34 + pM1._34 * pM2._44;
		pOut._41 = pM1._41 * pM2._11 + pM1._42 * pM2._21 + pM1._43 * pM2._31 + pM1._44 * pM2._41;
		pOut._42 = pM1._41 * pM2._12 + pM1._42 * pM2._22 + pM1._43 * pM2._32 + pM1._44 * pM2._42;
		pOut._43 = pM1._41 * pM2._13 + pM1._42 * pM2._23 + pM1._43 * pM2._33 + pM1._44 * pM2._43;
		pOut._44 = pM1._41 * pM2._14 + pM1._42 * pM2._24 + pM1._43 * pM2._34 + pM1._44 * pM2._44;

		return pOut;
	}

	struct FMinimalViewInfo {
		FVector Location;
		FVector Rotation;
		float FOV;
	};

	template<class T>
	class TArrayDrink {

	public:
		TArrayDrink() {
			Data = NULL;
			Count = 0;
			Max = 0;
		};

		T operator[](uint64_t i) const {
			return Read<uintptr_t>(((uintptr_t)Data) + i * sizeof(T));
		};

		T* Data;
		unsigned int Count;
		unsigned int Max;
	};
	typedef struct _MyPosition {
		FVector PositionM;
	}MyPosition;
	std::vector<MyPosition> POSXYABC;
	template<class T>
	class TArray
	{
	public:
		int Length() const
		{
			return m_nCount;
		}

		bool IsValid() const
		{
			if (m_nCount > m_nMax)
				return false;
			if (!m_Data)
				return false;
			return true;
		}

		uint64_t GetAddress() const
		{
			return m_Data;
		}

		T GetById(int i)
		{
			return Readv<T>(m_Data + i * 8);
		}

		[[nodiscard]]
		std::vector<T> GetIter(int maxCount = 1000) {
			if (m_nCount > maxCount)
				return {};

			std::vector<T> buffer(m_nCount);
			Readarray<T>(m_Data, buffer.data(), m_nCount);
			return buffer;
		}

	protected:
		uint64_t m_Data;
		uint32_t m_nCount;
		uint32_t m_nMax;
	};
}
namespace ColorStructs
{

	typedef struct
	{
		DWORD R;
		DWORD G;
		DWORD B;
		DWORD A;
	}RGBA;

	class Color
	{
	public:
		RGBA red = { 255,0,0,255 };
		RGBA Magenta = { 255,0,255,255 };
		RGBA yellow = { 255,255,0,255 };
		RGBA grayblue = { 128,128,255,255 };
		RGBA green = { 128,224,0,255 };
		RGBA darkgreen = { 0,224,128,255 };
		RGBA brown = { 192,96,0,255 };
		RGBA pink = { 255,168,255,255 };
		RGBA DarkYellow = { 216,216,0,255 };
		RGBA SilverWhite = { 236,236,236,255 };
		RGBA purple = { 144,0,255,255 };
		RGBA Navy = { 88,48,224,255 };
		RGBA skyblue = { 0,136,255,255 };
		RGBA graygreen = { 128,160,128,255 };
		RGBA blue = { 0,96,192,255 };
		RGBA orange = { 255,128,0,255 };
		RGBA peachred = { 255,80,128,255 };
		RGBA reds = { 255,128,192,255 };
		RGBA darkgray = { 96,96,96,255 };
		RGBA Navys = { 0,0,128,255 };
		RGBA darkgreens = { 0,128,0,255 };
		RGBA darkblue = { 0,128,128,255 };
		RGBA redbrown = { 128,0,0,255 };
		RGBA purplered = { 128,0,128,255 };
		RGBA greens = { 25,255,25,140 };
		RGBA envy = { 0,255,255,255 };
		RGBA black = { 0,0,0,255 };
		RGBA neger = { 215, 240, 180, 255 };
		RGBA negernot = { 222, 180, 200, 255 };
		RGBA gray = { 128,128,128,255 };
		RGBA white = { 255,255,255,255 };
		RGBA blues = { 30,144,255,255 };
		RGBA lightblue = { 135,206,250,255 };
		RGBA Scarlet = { 220, 20, 60, 160 };
		RGBA white_ = { 255,255,255,200 };
		RGBA gray_ = { 128,128,128,200 };
		RGBA black_ = { 0,0,0,200 };
		RGBA red_ = { 255,0,0,200 };
		RGBA Magenta_ = { 255,0,255,200 };
		RGBA yellow_ = { 255,255,0,200 };
		RGBA grayblue_ = { 128,128,255,200 };
		RGBA green_ = { 128,224,0,200 };
		RGBA darkgreen_ = { 0,224,128,200 };
		RGBA brown_ = { 192,96,0,200 };
		RGBA pink_ = { 255,168,255,200 };
		RGBA darkyellow_ = { 216,216,0,200 };
		RGBA silverwhite_ = { 236,236,236,200 };
		RGBA purple_ = { 144,0,255,200 };
		RGBA Blue_ = { 88,48,224,200 };
		RGBA skyblue_ = { 0,136,255,200 };
		RGBA graygreen_ = { 128,160,128,200 };
		RGBA blue_ = { 0,96,192,200 };
		RGBA orange_ = { 255,128,0,200 };
		RGBA pinks_ = { 255,80,128,200 };
		RGBA Fuhong_ = { 255,128,192,200 };
		RGBA darkgray_ = { 96,96,96,200 };
		RGBA Navy_ = { 0,0,128,200 };
		RGBA darkgreens_ = { 0,128,0,200 };
		RGBA darkblue_ = { 0,128,128,200 };
		RGBA redbrown_ = { 128,0,0,200 };
		RGBA purplered_ = { 128,0,128,200 };
		RGBA greens_ = { 0,255,0,200 };
		RGBA envy_ = { 0,255,255,200 };

		RGBA glassblack = { 0, 0, 0, 160 };
		RGBA GlassBlue = { 65,105,225,80 };
		RGBA glassyellow = { 255,255,0,160 };
		RGBA glass = { 200,200,200,60 };

		RGBA filled = { 0, 0, 0, 150 };

		RGBA Plum = { 221,160,221,160 };

	};
	Color Col;
}
```

`Valorant/Overlay/menu.hpp`:

```hpp
#pragma once
namespace hotkeys
{
	int aimkey;
	int airstuckey;
	int instares;
}
static int keystatus = 0;
static int realkey = 0;
bool GetKey(int key)
{
	realkey = key;
	return true;
}
void ChangeKey(void* blank)
{
	keystatus = 1;
	while (true)
	{
		for (int i = 0; i < 0x87; i++)
		{
			if (GetKeyState(i) & 0x8000)
			{
				hotkeys::aimkey = i;
				keystatus = 0;
				return;
			}
		}
	}
}

static const char* keyNames[] =
{
	"< KEY >",
	"Left Mouse",
	"Right Mouse",
	"Cancel",
	"Middle Mouse",
	"Mouse 5",
	"Mouse 4",
	"",
	"Backspace",
	"Tab",
	"",
	"",
	"Clear",
	"Enter",
	"",
	"",
	"Shift",
	"Control",
	"Alt",
	"Pause",
	"Caps",
	"",
	"",
	"",
	"",
	"",
	"",
	"Escape",
	"",
	"",
	"",
	"",
	"Space",
	"Page Up",
	"Page Down",
	"End",
	"Home",
	"Left",
	"Up",
	"Right",
	"Down",
	"",
	"",
	"",
	"Print",
	"Insert",
	"Delete",
	"",
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z",
	"",
	"",
	"",
	"",
	"",
	"Numpad 0",
	"Numpad 1",
	"Numpad 2",
	"Numpad 3",
	"Numpad 4",
	"Numpad 5",
	"Numpad 6",
	"Numpad 7",
	"Numpad 8",
	"Numpad 9",
	"Multiply",
	"Add",
	"",
	"Subtract",
	"Decimal",
	"Divide",
	"F1",
	"F2",
	"F3",
	"F4",
	"F5",
	"F6",
	"F7",
	"F8",
	"F9",
	"F10",
	"F11",
	"F12",
};
static bool Items_ArrayGetter(void* data, int idx, const char** out_text)
{
	const char* const* items = (const char* const*)data;
	if (out_text)
		*out_text = items[idx];
	return true;
}
void HotkeyButton(int aimkey, void* changekey, int status)
{
	const char* preview_value = NULL;
	if (aimkey >= 0 && aimkey < IM_ARRAYSIZE(keyNames))
		Items_ArrayGetter(keyNames, aimkey, &preview_value);

	std::string aimkeys;
	if (preview_value == NULL)
		aimkeys = "Select Key";
	else
		aimkeys = preview_value;

	if (status == 1)
	{

		aimkeys = "Press the Key";
	}
	if (ImGui::Button(aimkeys.c_str(), ImVec2(125, 20)))
	{
		if (status == 0)
		{
			CreateThread(0, 0, (LPTHREAD_START_ROUTINE)changekey, nullptr, 0, nullptr);
		}
	}
}

auto drawmenu() -> void
{
	if (GetAsyncKeyState(VK_INSERT) & 1) { Settings::bMenu = !Settings::bMenu; }

	if (Settings::bMenu)
	{
		static int switchTabs;
		ImGuiIO io = ImGui::GetIO();
		ImGui::Begin(XorStr("        Beef Version : 3.0 - Made With Love By Beef#3348 - Discord.gg/fZaGQfXqug - Tickets For Support").c_str(), NULL, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);
		ImGui::SetWindowSize(XorStr("        Beef Version : 3.0 - Made With Love By Beef#3348 - Discord.gg/fZaGQfXqug - Tickets For Support").c_str(), ImVec2(647.f, 439.f));
		
		ImGui::SetCursorPos({ 10.f,30.f });

		ImGui::BeginChild("child0", { 175.f,398.f }, true);

		ImGui::SetCursorPos({ 18.f,19.f });
		if (ImGui::Button(XorStr("Aimbot").c_str(), { 137.f,47.f }))
		{
			switchTabs = 0;
		}
		ImGui::SetCursorPos({ 18.f,86.f });
		if (ImGui::Button(XorStr("Visual").c_str(), { 137.f,47.f }))
		{
			switchTabs = 1;
		}
		ImGui::SetCursorPos({ 18.f,155.f });
		if (ImGui::Button(XorStr("Misc").c_str(), { 137.f,47.f }))
		{
			switchTabs = 2;
		}
		ImGui::SetCursorPos({ 25.f,372.f });
		ImGui::PushItemWidth(98.000000);
		ImGui::Text(XorStr("Made By -  Beef#3348").c_str());
		ImGui::PopItemWidth();

		ImGui::SetCursorPos({ 17.f,221.f });
		ImGui::PushItemWidth(140.000000);
		ImGui::Text(XorStr("  Discord.gg/fZaGQfXqug").c_str());
		ImGui::PopItemWidth();

		ImGui::SetCursorPos({ 7.f,245.f });
		ImGui::PushItemWidth(161.000000);
		ImGui::Text("             Menu FPS: 60 ", 20000 / io.Framerate);
		ImGui::PopItemWidth();


		ImGui::EndChild();

		switch (switchTabs) {
		case 0:

			ImGui::SetCursorPos({ 194.f,30.f });

			ImGui::BeginChild("child1", { 440.f,398.f }, true);

			ImGui::SetCursorPos({ 13.f,13.f });
			ImGui::Checkbox(XorStr("Aimbot Enable").c_str(), &Settings::aimbot::aimbot);
			HotkeyButton(hotkeys::aimkey, ChangeKey, keystatus);
			ImGui::SetCursorPos({ 13.f,44.f });
			ImGui::PushItemWidth(346.000000);

			ImGui::SetCursorPos({ 13.f,74.f });
			ImGui::Checkbox(XorStr("Enable Smoothing").c_str(), &Settings::aimbot::smooth);
			ImGui::Text(XorStr("Smoothness: ").c_str());
			ImGui::SliderFloat("  ", &Settings::aimbot::smoothness, 1, 5);
			ImGui::PopItemWidth();

			ImGui::SetCursorPos({ 13.f,74.f });
			ImGui::PushItemWidth(346.000000);

			ImGui::PopItemWidth();
			ImGui::SetCursorPos({ 13.f,145.f });
			ImGui::Checkbox(XorStr("Show FOV Circle").c_str(), &Settings::aimbot::drawfov);
			ImGui::Text(XorStr("FOV Value: ").c_str());
			ImGui::SliderFloat("    ", &Settings::aimbot::fov, 10, 300);
			ImGui::SetCursorPos({ 13.f,213.f });
			ImGui::Checkbox(XorStr("Visible Check").c_str(), &Settings::aimbot::vischeck);





			ImGui::EndChild();

			ImGui::SetCursorPos({ 194.f,30.f });

			ImGui::BeginChild("child1", { 440.f,398.f }, true);



			break;
		case 1:
			ImGui::SetCursorPos({ 194.f,30.f });

			ImGui::BeginChild("child1", { 440.f,398.f }, true);

			ImGui::Spacing();
			ImGui::SetCursorPos({ 13.f,20.f });
			ImGui::Checkbox(XorStr("ESP 3D").c_str(), &Settings::Visuals::bBox);
			ImGui::SetCursorPos({ 13.f,50.f });
			ImGui::Checkbox(XorStr("ESP 2D").c_str(), &Settings::Visuals::TDBox);
			ImGui::SetCursorPos({ 13.f,80.f });
			ImGui::Checkbox(XorStr("ESP Corner").c_str(), &Settings::Visuals::bBoxOutlined);
			ImGui::SetCursorPos({ 13.f,110.f });
			ImGui::Checkbox(XorStr("ESP Skeleton").c_str(), &Settings::Visuals::Skeleton);
			ImGui::SetCursorPos({ 13.f,140.f });
			ImGui::Checkbox(XorStr("ESP SnapLine").c_str(), &Settings::Visuals::bSnaplines);
			ImGui::SetCursorPos({ 13.f,170.f });
			ImGui::Checkbox(XorStr("ESP Distance").c_str(), &Settings::Visuals::bDistance);
			ImGui::SetCursorPos({ 13.f,200.f });
			ImGui::Checkbox(XorStr("ESP Health").c_str(), &Settings::Visuals::bHealth);
			ImGui::SetCursorPos({ 13.f,230.f });
			ImGui::Checkbox(XorStr("ESP Head").c_str(), &Settings::Visuals::HeadCircle);
			ImGui::SetCursorPos({ 13.f,260.f });
			
			ImGui::SetCursorPos({ 13.f,290.f });

			ImGui::SetCursorPos({ 13.f,320.f });
			ImGui::SetCursorPos({ 13.f,350.f });

			ImGui::SetCursorPos({ 13.f,380.f });

			ImGui::SetCursorPos({ 13.f,410.f });

			ImGui::SetCursorPos({ 13.f,440.f });

			ImGui::SetCursorPos({ 13.f,470.f });

			ImGui::SetCursorPos({ 13.f,500.f });

			ImGui::SetCursorPos({ 13.f,530.f });

			ImGui::SetCursorPos({ 13.f,560.f });

			ImGui::SetCursorPos({ 13.f,590.f });

			ImGui::EndChild();

			ImGui::SetCursorPos({ 194.f,30.f });

			ImGui::BeginChild("child1", { 440.f,398.f }, true);



			break;
		case 2:
			ImGui::SetCursorPos({ 194.f,30.f });
			ImGui::BeginChild("child1", { 440.f,398.f }, true);
			ImGui::Spacing();
			ImGui::Combo(skCrypt("SELECT ENTITY"), &Settings::misc::enemyselect, Settings::misc::Teams, sizeof(Settings::misc::Teams) / sizeof(*Settings::misc::Teams));
			ImGui::Checkbox("WATERMARK & FPS", &Settings::Visuals::FPS);
			ImGui::Checkbox("DEBUG", &NewFeatures::ActorCountDebug); //still in the works
			ImGui::SliderFloat("HeadBox Size", &Settings::misc::headsize, 100, 35);
			ImGui::SliderFloat("FOV Changer", &Settings::Visuals::fovchangervalue, 0, 1000);
			ImGui::SliderFloat("Radar Entity Size", &Settings::misc::radarentitysize, 1, 5);
			ImGui::SliderFloat("2D Box Thickness", &Settings::Visuals::BoxWidth, 0, 5);
			ImGui::SliderFloat("Radar Size", &Settings::misc::Size, 256, 258);
			ImGui::SliderFloat("Skeleton Thickness", &Settings::Visuals::skeletonwidht, 0, 5);
			ImGui::SliderFloat("Render Distance (m)", &NewFeatures::renderdistance, 0, 750);
			ImGui::TextColored(ImColor(colors::BLAHBLAH[0], colors::BLAHBLAH[1], colors::BLAHBLAH[2], colors::BLAHBLAH[3]), "[DEBUG]: %i ", NewFeatures::curractors);
			ImGui::EndChild();

			break;
		case 3:
			ImGui::SetCursorPos({ 194.f,30.f });

			ImGui::BeginChild("child1", { 440.f,398.f }, true);

			ImGui::SetCursorPos({ 13.f,20.f });
			ImGui::Text(XorStr("Discord Tag : Syntax#1000").c_str());
			ImGui::SetCursorPos({ 13.f,50.f });
			ImGui::Text(XorStr("Discord Server : discord.gg/vhdmNe4VqZ").c_str());
			ImGui::SetCursorPos({ 13.f,80.f });
			ImGui::Text(XorStr("Email : dildoman33@gmail.com ").c_str());



			ImGui::EndChild();

			ImGui::SetCursorPos({ 194.f,30.f });

			ImGui::BeginChild("child1", { 440.f,398.f }, true);

			ImGui::SetCursorPos({ 13.f,213.f });

			ImGui::SetCursorPos({ 13.f,245.f });
			ImGui::EndChild();
			ImGui::End();
		}
	}
}

```

`Valorant/Overlay/render.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <D:\pasting\beef.exe sourcew\Includes\Direct3d\d3dx9.h>
#include <d3d9.h>
#include <D:\pasting\beef.exe sourcew\Includes\Direct3d\d3dx9tex.h>

#include <dwmapi.h>

#include "../../Includes/Imgui/imgui_internal.h"
#include "../../Includes/Imgui/imgui.h"
#include "../../Includes/Imgui/imgui_impl_win32.h"
#include "../../Includes/Imgui/imgui_impl_dx9.h"
#include "../game/globals.hpp"
#include "../Game/structs.hpp"

#pragma comment(lib, "d3dx9.lib")
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "Dwmapi.lib")

IDirect3D9Ex* p_Object = NULL;
IDirect3DDevice9Ex* p_Device = NULL;
D3DPRESENT_PARAMETERS p_Params = { NULL };

HWND MyWnd = NULL;
HWND GameWnd = NULL;
MSG Message = { NULL };

RECT GameRect = { NULL };
D3DPRESENT_PARAMETERS d3dpp;

DWORD ScreenCenterX;
DWORD ScreenCenterY;

static ULONG Width = GetSystemMetrics(SM_CXSCREEN);
static ULONG Height = GetSystemMetrics(SM_CYSCREEN);

WPARAM main_loop();
void render();

void DefaultTheme() {

	ImGuiStyle& s = ImGui::GetStyle();

	const ImColor accentCol = ImColor(255, 0, 0, 255);
	const ImColor bgSecondary = ImColor(255, 0, 0, 255);
	s.Colors[ImGuiCol_WindowBg] = ImColor(32, 32, 32, 255);
	s.Colors[ImGuiCol_ChildBg] = bgSecondary;
	s.Colors[ImGuiCol_FrameBg] = ImColor(65, 64, 64, 255);
	s.Colors[ImGuiCol_FrameBgActive] = ImColor(35, 37, 39, 255);
	s.Colors[ImGuiCol_Border] = ImColor(1, 1, 1, 255);
	s.Colors[ImGuiCol_CheckMark] = ImColor(255, 0, 0, 255);
	s.Colors[ImGuiCol_SliderGrab] = ImColor(255, 0, 0, 255);
	s.Colors[ImGuiCol_SliderGrab] = ImColor(255, 0, 0, 255);
	s.Colors[ImGuiCol_SliderGrabActive] = ImColor(255, 0, 0, 255);
	s.Colors[ImGuiCol_ResizeGrip] = ImColor(24, 24, 24, 255);
	s.Colors[ImGuiCol_Header] = ImColor(0, 0, 0, 255);
	s.Colors[ImGuiCol_HeaderHovered] = ImColor(0, 0, 0, 255);
	s.Colors[ImGuiCol_HeaderActive] = ImColor(0, 0, 0, 255);
	s.Colors[ImGuiCol_TitleBg] = ImColor(0, 0, 0, 255);
	s.Colors[ImGuiCol_TitleBgCollapsed] = ImColor(0, 0, 0, 255);
	s.Colors[ImGuiCol_TitleBgActive] = ImColor(0, 0, 0, 255);
	s.Colors[ImGuiCol_FrameBgHovered] = ImColor(65, 64, 64, 255);
	s.Colors[ImGuiCol_ScrollbarBg] = ImColor(0, 0, 0, 255);
	s.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.80f, 0.80f, 0.83f, 0.31f);
	s.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);
	s.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f);
	s.Colors[ImGuiCol_Header] = ImColor(42, 42, 42, 255);
	s.Colors[ImGuiCol_HeaderHovered] = ImColor(50, 50, 50, 255);
	s.Colors[ImGuiCol_HeaderActive] = ImColor(50, 50, 50, 255);
	s.Colors[ImGuiCol_PopupBg] = ImColor(15, 15, 15, 255);
	s.Colors[ImGuiCol_Button] = ImColor(30, 30, 30, 255);
	s.Colors[ImGuiCol_ButtonHovered] = ImColor(30, 30, 30, 255);
	s.Colors[ImGuiCol_ButtonActive] = ImColor(30, 30, 30, 255);
	s.Colors[ImGuiCol_Text] = ImColor(255, 255, 255, 255);

	s.AntiAliasedFill = true;
	s.AntiAliasedLines = true;

	s.ChildRounding = 0.0f;
	s.FrameBorderSize = 1.0f;
	s.FrameRounding = 0.0f;
	s.PopupRounding = 0.0f;
	s.ScrollbarRounding = 0.0f;
	s.ScrollbarSize = 0.0f;
	s.TabRounding = 0.0f;
	s.WindowRounding = 0.0f;

}

auto init_wndparams(HWND hWnd) -> HRESULT
{
	if (FAILED(Direct3DCreate9Ex(D3D_SDK_VERSION, &p_Object)))
		exit(3);

	ZeroMemory(&p_Params, sizeof(p_Params));
	p_Params.Windowed = TRUE;
	p_Params.SwapEffect = D3DSWAPEFFECT_DISCARD;
	p_Params.hDeviceWindow = hWnd;
	p_Params.MultiSampleQuality = D3DMULTISAMPLE_NONE;
	p_Params.BackBufferFormat = D3DFMT_A8R8G8B8;
	p_Params.BackBufferWidth = Width;
	p_Params.BackBufferHeight = Height;
	p_Params.EnableAutoDepthStencil = TRUE;
	p_Params.AutoDepthStencilFormat = D3DFMT_D16;
	p_Params.PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
	p_Params.FullScreen_RefreshRateInHz = 0;


	if (FAILED(p_Object->CreateDeviceEx(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd, D3DCREATE_HARDWARE_VERTEXPROCESSING, &p_Params, 0, &p_Device))) {
		p_Object->Release();
		exit(4);
	}

	IMGUI_CHECKVERSION();
	ImGui::CreateContext();
	//ImGui::GetIO().Fonts->AddFontDefault();
	ImGuiIO& io = ImGui::GetIO(); (void)io;
	io.IniFilename = NULL;
	io.Fonts->AddFontFromFileTTF("C:\\Windows\\Fonts\\arialbd.ttf", 12);
	ImGuiStyle* style = &ImGui::GetStyle();

	ImVec4* colors = ImGui::GetStyle().Colors;
	colors[ImGuiCol_Text] = ImVec4(0.0f, 1.0f, 1.0f, 1.0f);
	colors[ImGuiCol_TextDisabled] = ImVec4(0.0f, 0.4000000059604645f, 0.407843142747879f, 1.0f);
	colors[ImGuiCol_WindowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.8299999833106995f);
	colors[ImGuiCol_ChildBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
	colors[ImGuiCol_PopupBg] = ImVec4(0.1568627506494522f, 0.239215686917305f, 0.2196078449487686f, 0.6000000238418579f);
	colors[ImGuiCol_Border] = ImVec4(0.0f, 1.0f, 1.0f, 0.6499999761581421f);
	colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
	colors[ImGuiCol_FrameBg] = ImVec4(0.4392156898975372f, 0.800000011920929f, 0.800000011920929f, 0.1800000071525574f);
	colors[ImGuiCol_FrameBgHovered] = ImVec4(0.4392156898975372f, 0.800000011920929f, 0.800000011920929f, 0.2700000107288361f);
	colors[ImGuiCol_FrameBgActive] = ImVec4(0.4392156898975372f, 0.8078431487083435f, 0.8588235378265381f, 0.6600000262260437f);
	colors[ImGuiCol_TitleBg] = ImVec4(0.1372549086809158f, 0.1764705926179886f, 0.2078431397676468f, 0.7300000190734863f);
	colors[ImGuiCol_TitleBgActive] = ImVec4(0.0f, 1.0f, 1.0f, 0.2700000107288361f);
	colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.0f, 0.0f, 0.0f, 0.5400000214576721f);
	colors[ImGuiCol_MenuBarBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.2000000029802322f);
	colors[ImGuiCol_ScrollbarBg] = ImVec4(0.2196078449487686f, 0.2862745225429535f, 0.2980392277240753f, 0.7099999785423279f);
	colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.0f, 1.0f, 1.0f, 0.4399999976158142f);
	colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.0f, 1.0f, 1.0f, 0.7400000095367432f);
	colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.0f, 1.0f, 1.0f, 1.0f);
	colors[ImGuiCol_CheckMark] = ImVec4(0.0f, 1.0f, 1.0f, 0.6800000071525574f);
	colors[ImGuiCol_SliderGrab] = ImVec4(0.0f, 1.0f, 1.0f, 0.3600000143051147f);
	colors[ImGuiCol_SliderGrabActive] = ImVec4(0.0f, 1.0f, 1.0f, 0.7599999904632568f);
	colors[ImGuiCol_Button] = ImVec4(0.0f, 0.6470588445663452f, 0.6470588445663452f, 0.4600000083446503f);
	colors[ImGuiCol_ButtonHovered] = ImVec4(0.007843137718737125f, 1.0f, 1.0f, 0.4300000071525574f);
	colors[ImGuiCol_ButtonActive] = ImVec4(0.0f, 1.0f, 1.0f, 0.6200000047683716f);
	colors[ImGuiCol_Header] = ImVec4(0.0f, 1.0f, 1.0f, 0.3300000131130219f);
	colors[ImGuiCol_HeaderHovered] = ImVec4(0.0f, 1.0f, 1.0f, 0.4199999868869781f);
	colors[ImGuiCol_HeaderActive] = ImVec4(0.0f, 1.0f, 1.0f, 0.5400000214576721f);
	colors[ImGuiCol_Separator] = ImVec4(0.0f, 0.4980392158031464f, 0.4980392158031464f, 0.3300000131130219f);
	colors[ImGuiCol_SeparatorHovered] = ImVec4(0.0f, 0.4980392158031464f, 0.4980392158031464f, 0.4699999988079071f);
	colors[ImGuiCol_SeparatorActive] = ImVec4(0.0f, 0.6980392336845398f, 0.6980392336845398f, 1.0f);
	colors[ImGuiCol_ResizeGrip] = ImVec4(0.0f, 1.0f, 1.0f, 0.5400000214576721f);
	colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.0f, 1.0f, 1.0f, 0.7400000095367432f);
	colors[ImGuiCol_ResizeGripActive] = ImVec4(0.0f, 1.0f, 1.0f, 1.0f);
	colors[ImGuiCol_Tab] = ImVec4(0.1764705926179886f, 0.3490196168422699f, 0.5764706134796143f, 0.8619999885559082f);
	colors[ImGuiCol_TabHovered] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 0.800000011920929f);
	colors[ImGuiCol_TabActive] = ImVec4(0.196078434586525f, 0.407843142747879f, 0.6784313917160034f, 1.0f);
	colors[ImGuiCol_TabUnfocused] = ImVec4(0.06666667014360428f, 0.1019607856869698f, 0.1450980454683304f, 0.9724000096321106f);
	colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1333333402872086f, 0.2588235437870026f, 0.4235294163227081f, 1.0f);
	colors[ImGuiCol_PlotLines] = ImVec4(0.0f, 1.0f, 1.0f, 1.0f);
	colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.0f, 1.0f, 1.0f, 1.0f);
	colors[ImGuiCol_PlotHistogram] = ImVec4(0.0f, 1.0f, 1.0f, 1.0f);
	colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.0f, 1.0f, 1.0f, 1.0f);
	colors[ImGuiCol_TableHeaderBg] = ImVec4(0.1882352977991104f, 0.1882352977991104f, 0.2000000029802322f, 1.0f);
	colors[ImGuiCol_TableBorderStrong] = ImVec4(0.3098039329051971f, 0.3098039329051971f, 0.3490196168422699f, 1.0f);
	colors[ImGuiCol_TableBorderLight] = ImVec4(0.2274509817361832f, 0.2274509817361832f, 0.2470588237047195f, 1.0f);
	colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
	colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.0f, 1.0f, 1.0f, 0.05999999865889549f);
	colors[ImGuiCol_TextSelectedBg] = ImVec4(0.0f, 1.0f, 1.0f, 0.2199999988079071f);
	colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
	colors[ImGuiCol_NavHighlight] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 1.0f);
	colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.699999988079071f);
	colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.2000000029802322f);
	colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.03921568766236305f, 0.09803921729326248f, 0.08627451211214066f, 0.5099999904632568f);
	ImGuiStyle& s = ImGui::GetStyle();
	s.ChildRounding = 0.0f;
	s.FrameBorderSize = 1.0f;
	s.FrameRounding = 0.0f;
	s.PopupRounding = 0.0f;
	s.ScrollbarRounding = 0.0f;
	s.ScrollbarSize = 0.0f;
	s.TabRounding = 0.0f;
	s.WindowRounding = 5.0f;
	ImGui_ImplWin32_Init(hWnd);
	ImGui_ImplDX9_Init(p_Device);
	return S_OK;
}

auto get_process_wnd(uint32_t pid) -> HWND
{
	std::pair<HWND, uint32_t> params = { 0, pid };
	BOOL bResult = EnumWindows([](HWND hwnd, LPARAM lParam) -> BOOL {
		auto pParams = (std::pair<HWND, uint32_t>*)(lParam);
		uint32_t processId = 0;

		if (GetWindowThreadProcessId(hwnd, reinterpret_cast<LPDWORD>(&processId)) && processId == pParams->second) {
			SetLastError((uint32_t)-1);
			pParams->first = hwnd;
			return FALSE;
		}

		return TRUE;

		}, (LPARAM)&params);

	if (!bResult && GetLastError() == -1 && params.first)
		return params.first;

	return NULL;
}

auto cleanup_d3d() -> void
{
	if (p_Device != NULL) {
		p_Device->EndScene();
		p_Device->Release();
	}
	if (p_Object != NULL) {
		p_Object->Release();
	}
}

auto set_window_target() -> void
{
	while (true) {
		GameWnd = get_process_wnd(process_id);
		if (GameWnd) {
			ZeroMemory(&GameRect, sizeof(GameRect));
			GetWindowRect(GameWnd, &GameRect);
			DWORD dwStyle = GetWindowLong(GameWnd, GWL_STYLE);
			if (dwStyle & WS_BORDER)
			{
				GameRect.top += 32;
				Height -= 39;
			}
			ScreenCenterX = Width / 2;
			ScreenCenterY = Height / 2;
			MoveWindow(MyWnd, GameRect.left, GameRect.top, Width, Height, true);
		}
	}
}

auto setup_window() -> void
{
	Sleep(100);
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)set_window_target, 0, 0, 0);

	WNDCLASSEXA wcex = {
		sizeof(WNDCLASSEXA),
		0,
		DefWindowProcA,
		0,
		0,
		nullptr,
		LoadIcon(nullptr, IDI_APPLICATION),
		LoadCursor(nullptr, IDC_ARROW),
		nullptr,
		nullptr,
		("AVeryExternalOverlayx"),
		LoadIcon(nullptr, IDI_APPLICATION)
	};

	RECT Rect;
	GetWindowRect(GetDesktopWindow(), &Rect);

	RegisterClassExA(&wcex);

	MyWnd = CreateWindowExA(NULL, ("AVeryExternalOverlayx"), ("AVeryExternalOverlayx"), WS_POPUP, Rect.left, Rect.top, Rect.right, Rect.bottom, NULL, NULL, wcex.hInstance, NULL);
	SetWindowLong(MyWnd, GWL_EXSTYLE, WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOOLWINDOW);
	SetLayeredWindowAttributes(MyWnd, RGB(0, 0, 0), 255, LWA_ALPHA);

	MARGINS margin = { -1 };
	DwmExtendFrameIntoClientArea(MyWnd, &margin);

	ShowWindow(MyWnd, SW_SHOW);
	UpdateWindow(MyWnd);
}

using namespace ColorStructs;



void DrawFilledRect2(int x, int y, int w, int h, ImColor color)
{
	ImGui::GetForegroundDrawList()->AddRectFilled(ImVec2(x, y), ImVec2(x + w, y + h), color, 0, 0);
}

void DrawCornerBox(float x, float y, float w, float h, const ImColor& color)
{
	ImGui::GetForegroundDrawList()->AddLine(ImVec2(x, y), ImVec2(x + w / 4.f, y), color);
	ImGui::GetForegroundDrawList()->AddLine(ImVec2(x, y), ImVec2(x, y + h / 4.f), color);

	ImGui::GetForegroundDrawList()->AddLine(ImVec2(x + w, y), ImVec2(x + w - w / 4.f, y), color);
	ImGui::GetForegroundDrawList()->AddLine(ImVec2(x + w, y), ImVec2(x + w, y + h / 4.f), color);

	ImGui::GetForegroundDrawList()->AddLine(ImVec2(x, y + h), ImVec2(x + w / 4.f, y + h), color);
	ImGui::GetForegroundDrawList()->AddLine(ImVec2(x, y + h), ImVec2(x, y + h - h / 4.f), color);

	ImGui::GetForegroundDrawList()->AddLine(ImVec2(x + w, y + h), ImVec2(x + w, y + h - h / 4.f), color);
	ImGui::GetForegroundDrawList()->AddLine(ImVec2(x + w, y + h), ImVec2(x + w - w / 4.f, y + h), color);
}

void DrawNormalBox(int x, int y, int w, int h, int borderPx, ImColor color)
{
	DrawFilledRect2(x + borderPx, y, w, borderPx, color);
	DrawFilledRect2(x + w - w + borderPx, y, w, borderPx, color);
	DrawFilledRect2(x, y, borderPx, h, color);
	DrawFilledRect2(x, y + h - h + borderPx * 2, borderPx, h, color);
	DrawFilledRect2(x + borderPx, y + h + borderPx, w, borderPx, color);
	DrawFilledRect2(x + w - w + borderPx, y + h + borderPx, w, borderPx, color);
	DrawFilledRect2(x + w + borderPx, y, borderPx, h, color);
	DrawFilledRect2(x + w + borderPx, y + h - h + borderPx * 2, borderPx, h, color);
}

using namespace UE4Structs;

auto Draw2DBox(FVector RootPosition, float Width, float Height, ImColor Color) -> void
{
	DrawNormalBox(RootPosition.x - Width / 2, RootPosition.y - Height / 2, Width, Height, Settings::Visuals::BoxWidth, Color);
}

void DrawRect(int x, int y, int w, int h, RGBA* color, int thickness)
{
	ImGui::GetForegroundDrawList()->AddRect(ImVec2(x, y), ImVec2(x + w, y + h), ImGui::ColorConvertFloat4ToU32(ImVec4(color->R / 255.0, color->G / 255.0, color->B / 255.0, color->A / 255.0)), 0, 0, thickness);
}
inline auto DrawBorder(float x, float y, float w, float h, float px, RGBA* BorderColor) -> void
{
	DrawRect(x, (y + h - px), w, px, BorderColor, 1 / 2);
	DrawRect(x, y, px, h, BorderColor, 1 / 2);
	DrawRect(x, y, w, px, BorderColor, 1 / 2);
	DrawRect((x + w - px), y, px, h, BorderColor, 1 / 2);
}
inline auto DrawCircleFilled2(int x, int y, int radius, RGBA* color) -> void
{
	ImGui::GetForegroundDrawList()->AddCircleFilled(ImVec2(x, y), radius, ImGui::ColorConvertFloat4ToU32(ImVec4(color->R / 255.0, color->G / 255.0, color->B / 255.0, color->A / 255.0)));
}
inline auto DrawCircleFilled3(int x, int y, int radius, ImColor color) -> void
{
	ImGui::GetForegroundDrawList()->AddCircleFilled(ImVec2(x, y), radius, ImColor(colors::Head[0], colors::Head[1], colors::Head[2], colors::Head[3]));
}
inline auto DrawLineNew12(int x1, int y1, int x2, int y2, RGBA* color, int thickness) -> void
{
	ImGui::GetForegroundDrawList()->AddLine(ImVec2(x1, y1), ImVec2(x2, y2), ImGui::ColorConvertFloat4ToU32(ImVec4(color->R / 255.0, color->G / 255.0, color->B / 255.0, color->A / 255.0)), thickness);
}
auto DrawOutlinedBox(FVector RootPosition, float Width, float Height, ImColor Color) -> void
{
	DrawCornerBox(RootPosition.x - Width / 2, RootPosition.y - Height / 2, Width, Height, Color);
	DrawCornerBox(RootPosition.x - Width / 2 - 1, RootPosition.y - Height / 2 - 1, Width, Height, ImColor(0, 0, 0));
	DrawCornerBox(RootPosition.x - Width / 2 + 1, RootPosition.y - Height / 2 + 1, Width, Height, ImColor(0, 0, 0));
}

auto DrawDistance(FVector Location, float Distance) -> void
{
	char dist[64];
	sprintf_s(dist, "%.fm", Distance);

	ImVec2 TextSize = ImGui::CalcTextSize(dist);
	ImGui::GetForegroundDrawList()->AddText(ImVec2(Location.x - TextSize.x / 2, Location.y - TextSize.y / 2), ImGui::GetColorU32({ 255, 255, 255, 255 }), dist);
}

auto DrawActorDebug(FVector Location) -> void
{

	std::string Out = "[RENDERED " + std::to_string(ValList.size()) + " TIMES]";
	ImVec2 TextSize = ImGui::CalcTextSize(Out.c_str());
	if (NewFeatures::ActorCountDebug == 1 && Settings::Visuals::bDistance == 0)
	{
		ImGui::GetForegroundDrawList()->AddText(ImVec2(Location.x - TextSize.x / 2, Location.y  - TextSize.y / 2), ImGui::GetColorU32({ 255, 255, 255, 255 }), Out.c_str());
	}
	else
	{
		ImGui::GetForegroundDrawList()->AddText(ImVec2(Location.x - TextSize.x / 2, Location.y + 15 - TextSize.y / 2), ImGui::GetColorU32({ 255, 255, 255, 255 }), Out.c_str());

	}
}
auto DrawFPS(ImVec2 Location) -> void
{
	ImGuiIO io = ImGui::GetIO();
	std::string FPS = "FPS (" + std::to_string(io.Framerate) + ") Diego SOFTWARE";
	ImVec2 TextSize = ImGui::CalcTextSize(FPS.c_str());
	ImGui::GetForegroundDrawList()->AddText(ImVec2(Location.x, Location.y), ImGui::GetColorU32({ 132, 0, 181, 255 }), FPS.c_str());

}
auto DrawAimbotFov(int x, int y, int radius, RGBA* color, float segments)
{
	ImGui::GetForegroundDrawList()->AddCircle(ImVec2(x, y), Settings::aimbot::fov,ImGui::GetColorU32({ 255, 255, 255, 255 }), 0, 1);
}
auto DrawALine(const ImVec2& x, const ImVec2 y, ImU32 color, const FLOAT width)
{
	ImGui::GetForegroundDrawList()->AddLine(x, y, color, width);
}
auto DrawALine2(const ImVec2& x, const ImVec2 y, ImU32 color, const FLOAT width)
{
	ImGui::GetForegroundDrawList()->AddLine(x, y, color, width);
}
auto DrawTracers(FVector Target, ImColor Color) -> void
{
	ImGui::GetForegroundDrawList()->AddLine(
		ImVec2(ScreenCenterX, Height),
		ImVec2(Target.x, Target.y),
		Color,
		0.1f
	);
}
struct vertex
{
	FLOAT x, y, z, rhw;
	DWORD color;
};
void DrawCircleFilled23(float x, float y, float r, unsigned int p, DWORD color)
{


	vertex* pVertex = new vertex[p + 1];

	for (unsigned int i = 0; i <= p; ++i)
	{
		pVertex[i].x = x + r * cos(D3DX_PI * (i / (p / 2.f)));
		pVertex[i].y = y + r * sin(D3DX_PI * (i / (p / 2.f)));
		pVertex[i].z = 0;
		pVertex[i].rhw = 0;
		pVertex[i].color = color;

	}

//	pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, p - 1, pVertex, sizeof(vertex));

	delete[] pVertex;
}
auto DrawHealthBar(FVector RootPosition, float Width, float Height, float Health, float RelativeDistance)-> void
{
	auto HPBoxWidth = 1 / RelativeDistance;

	auto HPBox_X = RootPosition.x - Width / 2 - 5 - HPBoxWidth;
	auto HPBox_Y = RootPosition.y - Height / 2 + (Height - Height * (Health / 100));

	int HPBoxHeight = Height * (Health / 100);

	DrawFilledRect2(HPBox_X, HPBox_Y, HPBoxWidth, HPBoxHeight, ImColor(colors::HP[0], colors::HP[1], colors::HP[2], colors::HP[3]));
	DrawRect(HPBox_X - 1, HPBox_Y - 1, HPBoxWidth + 2, HPBoxHeight + 2, &ColorStructs::Col.black, 0.5);
}
```

`Valorant/Radar.h`:

```h
#pragma once
//#include "Game/structs.hpp"
#include "Vector3.h"

inline FVector2D WorldRadar(FVector srcPos, FVector distPos, float yaw, float radarX, float radarY, float size)
{
	auto cosYaw = cos(DegreeToRadian(yaw));
	auto sinYaw = sin(DegreeToRadian(yaw));

	auto deltaX = srcPos.x - distPos.x;
	auto deltaY = srcPos.y - distPos.y;

	auto locationX = (float)(deltaY * cosYaw - deltaX * sinYaw) / 45.f;
	auto locationY = (float)(deltaX * cosYaw + deltaY * sinYaw) / 45.f;

	if (locationX > (size - 2.f))
		locationX = (size - 2.f);
	else if (locationX < -(size - 2.f))
		locationX = -(size - 2.f);

	if (locationY > (size - 6.f))
		locationY = (size - 6.f);
	else if (locationY < -(size - 6.f))
		locationY = -(size - 6.f);

	return FVector2D((int)(-locationX + radarX), (int)(locationY + radarY));
}

static FVector pRadar;
static FVector pRadar1;
static int enemy_size = 3;
inline auto DrawRadar(FVector EntityPos) -> void
{
	auto radar_posX = pRadar.x + 135;
	auto radar_posY = pRadar.y + 135;
	//if (CRiQTest::g_localplayerpawn == 0) return;
	uint64_t LocalRootComp = Read<uint64_t>(LocalPlayer + offsets::RootComponent);
	uint64_t rot = Read<uint64_t>(PlayerController + offsets::CameraRotation);
	FVector LocalPos = Read<FVector>(LocalRootComp + offsets::RelativeLocation);
	auto Radar2D = WorldRadar(LocalPos, EntityPos, rot, radar_posX, radar_posY, 1000.f);

	
	//ImGui::SetWindowSize(ImVec2(Settings::misc::Size, Settings::misc::Size));
	ImGui::SetNextWindowSize(ImVec2(Settings::misc::Size, Settings::misc::Size));
	ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0), ImVec2(FLT_MAX, FLT_MAX));


	//ImGui::SetNextWindowPos(ImVec2(0,0));
	ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 150.0f);
	ImGui::PushStyleVar(ImGuiStyleVar_TabRounding, 150.0f);
	ImGui::PushStyleVar(ImGuiStyleVar_GrabRounding, 150.0f);
	ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 150.0f);
	ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 150.0f);
	//ImGui::Begin("STATIC RADAR", &Settings::bRadar, ImGuiWindowFlags_NoResize  | ImGuiWindowFlags_NoTitleBar);
	ImGui::Begin("STATIC RADAR", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize);

	ImDrawList* draw_list = ImGui::GetWindowDrawList();
	ImVec2 winpos = ImGui::GetWindowPos();
	ImVec2 winsize = ImGui::GetWindowSize();
	draw_list->AddLine(ImVec2(winpos.x + winsize.x * 0.5f, winpos.y), ImVec2(winpos.x + winsize.x * 0.5f, winpos.y + winsize.y), ImColor(70, 70, 70, 255), 0.5f);
	draw_list->AddLine(ImVec2(winpos.x, winpos.y + winsize.y * 0.5f), ImVec2(winpos.x + winsize.x, winpos.y + winsize.y * 0.5f), ImColor(70, 70, 70, 255), 0.5f);

	//draw_list->AddLine(ImVec2(winpos.x + winsize.x * 0.5f, winpos.y + winsize.y * 0.5f), ImVec2(winpos.x, winpos.y), ImColor(90, 90, 90, 255), 0.5f);
	//draw_list->AddLine(ImVec2(winpos.x + winsize.x * 0.5f, winpos.y + winsize.y * 0.5f), ImVec2(winpos.x + winsize.x, winpos.y), ImColor(90, 90, 90, 255), 0.5f);


	//draw_list->DrawCircleFilled22(Radar2D.x, Radar2D.y, 4, ImColor(255, 255, 255, 255));
	draw_list->AddCircleFilled(ImVec2(winpos.x + winsize.x * 0.5f, winpos.y + winsize.y * 0.5f), 3, ImColor(0, 255, 0, 255));

	draw_list->AddCircleFilled(ImVec2(winpos.x + Radar2D.x, winpos.y +Radar2D.y ), Settings::misc::radarentitysize, ImColor(colors::radar[0], colors::radar[1], colors::radar[2], colors::radar[3]));
	//DrawCircleFilled(Radar2D.x, Radar2D.y, 4, &Col.red);
	ImGui::End();
	ImGui::PopStyleVar();
	ImGui::PopStyleVar();
	ImGui::PopStyleVar();
	ImGui::PopStyleVar();
	ImGui::PopStyleVar();
}
```

`Valorant/Skeleton.h`:

```h
#pragma once
#include <Windows.h>
#include "Driver/Driver.h"
#include "../Valorant/Game/structs.hpp"
#include "Game/sdk.hpp"


void DrawLineSimple(FVector first_bone_position, FVector second_bone_position) {

	auto first_bone_screen_position = UNREALENGINE::SDK::ProjectWorldToScreen(first_bone_position);
	if (first_bone_screen_position.x == 0 && first_bone_screen_position.y == 0) return;

	auto second_bone_screen_position = UNREALENGINE::SDK::ProjectWorldToScreen(second_bone_position);
	if (second_bone_screen_position.x == 0 && second_bone_screen_position.y == 0) return;

	//ImColor White = { 0, 49, 164, 255 };
	DrawALine(ImVec2(first_bone_screen_position.x, first_bone_screen_position.y), ImVec2(second_bone_screen_position.x, second_bone_screen_position.y), ImColor(colors::skeleton[0] , colors::skeleton[1] , colors::skeleton[2] , colors::skeleton[3] ),Settings::Visuals::skeletonwidht);
}


void DrawSkeleton(uintptr_t Mesh) {

	//
	FVector vHipOut;
	FVector vHeadBoneOut;
	FVector vNeckOut;
	FVector vUpperArmLeftOut;
	FVector vLeftHandOut;
	FVector vLeftHandOut1;
	FVector vUpperArmRightOut;
	FVector vRightHandOut;
	FVector vRightHandOut1;
	FVector vLeftThighOut;
	FVector vLeftCalfOut;
	FVector vLeftFootOut;
	FVector vRightThighOut;
	FVector vRightCalfOut;
	FVector vRightFootOut;
	//

	int BoneCount = Read<int>(Mesh + offsets::BoneCount);

	if (BoneCount == 0) {
		vHipOut = GetBone(Mesh, 3);

		vHeadBoneOut = GetBone(Mesh, 8);
		vNeckOut = GetBone(Mesh, 7);

		vUpperArmLeftOut = GetBone(Mesh, 11);
		vLeftHandOut = GetBone(Mesh, 12);
		vLeftHandOut1 = GetBone(Mesh, 13);

		vUpperArmRightOut = GetBone(Mesh, 36);
		vRightHandOut = GetBone(Mesh, 37);
		vRightHandOut1 = GetBone(Mesh, 38);



		vLeftThighOut = GetBone(Mesh, 63);
		vLeftCalfOut = GetBone(Mesh, 65);
		vLeftFootOut = GetBone(Mesh, 69);

		vRightThighOut = GetBone(Mesh, 77);
		vRightCalfOut = GetBone(Mesh, 79);
		vRightFootOut = GetBone(Mesh, 83);
	}
	else {
		vHipOut = GetBone(Mesh, 3);

		vHeadBoneOut = GetBone(Mesh, 8);
		vNeckOut = GetBone(Mesh, 7);

		vUpperArmLeftOut = GetBone(Mesh, 11);
		vLeftHandOut = GetBone(Mesh, 12);
		vLeftHandOut1 = GetBone(Mesh, 13);

		vUpperArmRightOut = GetBone(Mesh, 36);
		vRightHandOut = GetBone(Mesh, 37);
		vRightHandOut1 = GetBone(Mesh, 38);



		vLeftThighOut = GetBone(Mesh, 63);
		vLeftCalfOut = GetBone(Mesh, 65);
		vLeftFootOut = GetBone(Mesh, 69);

		vRightThighOut = GetBone(Mesh, 77);
		vRightCalfOut = GetBone(Mesh, 79);
		vRightFootOut = GetBone(Mesh, 83);
	}

		DrawLineSimple(vNeckOut, vHeadBoneOut);
		DrawLineSimple(vHipOut, vNeckOut);
		DrawLineSimple(vUpperArmLeftOut, vNeckOut);
		DrawLineSimple(vUpperArmRightOut, vNeckOut);
		DrawLineSimple(vLeftHandOut, vUpperArmLeftOut);
		DrawLineSimple(vRightHandOut, vUpperArmRightOut);
		DrawLineSimple(vLeftHandOut, vLeftHandOut1);
		DrawLineSimple(vRightHandOut, vRightHandOut1);
		DrawLineSimple(vLeftThighOut, vHipOut);
		DrawLineSimple(vRightThighOut, vHipOut);
		DrawLineSimple(vLeftCalfOut, vLeftThighOut);
		DrawLineSimple(vRightCalfOut, vRightThighOut);
		DrawLineSimple(vLeftFootOut, vLeftCalfOut);
		DrawLineSimple(vRightFootOut, vRightCalfOut);


}

inline auto renderBones(uintptr_t Mesh)  -> void {

	FVector head_position = GetBone(Mesh, 8);
	FVector neck_position;
	FVector chest_position = GetBone(Mesh, 6);
	FVector l_upper_arm_position;
	FVector l_fore_arm_position;
	FVector l_hand_position;
	FVector r_upper_arm_position;
	FVector r_fore_arm_position;
	FVector r_hand_position;
	FVector stomach_position = GetBone(Mesh, 4);
	FVector pelvis_position = GetBone(Mesh, 3);
	FVector l_thigh_position;
	FVector l_knee_position;
	FVector l_foot_position;
	FVector r_thigh_position;
	FVector r_knee_position;
	FVector r_foot_position;
	std::vector<SSkeletal> SKLT;

	for (SSkeletal SKLT : SPTR)
	{
		auto BoneCount = (SKLT.Skeletal);
		//printf("Bones = %i \n", BoneCount);
		
		if (BoneCount == 104) { // MALE & FEMALE

			neck_position = GetBone(Mesh, 19);

			l_upper_arm_position = GetBone(Mesh, 21);
			l_fore_arm_position = GetBone(Mesh, 22);
			l_hand_position = GetBone(Mesh, 23);

			r_upper_arm_position = GetBone(Mesh, 47);
			r_fore_arm_position = GetBone(Mesh, 48);
			r_hand_position = GetBone(Mesh, 49);

			l_thigh_position = GetBone(Mesh, 75);
			l_knee_position = GetBone(Mesh, 76);
			l_foot_position = GetBone(Mesh, 78);

			r_thigh_position = GetBone(Mesh, 82);
			r_knee_position = GetBone(Mesh, 83);
			r_foot_position = GetBone(Mesh, 85);
		}

		else if (BoneCount == 101) {

			neck_position = GetBone(Mesh, 21);

			l_upper_arm_position = GetBone(Mesh, 45);
			l_fore_arm_position = GetBone(Mesh, 42);
			l_hand_position = GetBone(Mesh, 44);

			r_upper_arm_position = GetBone(Mesh, 48);
			r_fore_arm_position = GetBone(Mesh, 67);
			r_hand_position = GetBone(Mesh, 69);

			l_thigh_position = GetBone(Mesh, 75);
			l_knee_position = GetBone(Mesh, 76);
			l_foot_position = GetBone(Mesh, 78);

			r_thigh_position = GetBone(Mesh, 82);
			r_knee_position = GetBone(Mesh, 84);
			r_foot_position = GetBone(Mesh, 85);
		}

		else if (BoneCount == 103) { // BOT

			neck_position = GetBone(Mesh, 9);

			l_upper_arm_position = GetBone(Mesh, 33);
			l_fore_arm_position = GetBone(Mesh, 30);
			l_hand_position = GetBone(Mesh, 32);

			r_upper_arm_position = GetBone(Mesh, 58);
			r_fore_arm_position = GetBone(Mesh, 55);
			r_hand_position = GetBone(Mesh, 57);

			l_thigh_position = GetBone(Mesh, 63);
			l_knee_position = GetBone(Mesh, 65);
			l_foot_position = GetBone(Mesh, 69);

			r_thigh_position = GetBone(Mesh, 77);
			r_knee_position = GetBone(Mesh, 79);
			r_foot_position = GetBone(Mesh, 83);
		}
		else {
			return;
		}
	}



	DrawLineSimple(head_position, neck_position);
	DrawLineSimple(neck_position, chest_position);
	DrawLineSimple(neck_position, l_upper_arm_position);
	DrawLineSimple(l_upper_arm_position, l_fore_arm_position);
	DrawLineSimple(l_fore_arm_position, l_hand_position);
	DrawLineSimple(neck_position, r_upper_arm_position);
	DrawLineSimple(r_upper_arm_position, r_fore_arm_position);
	DrawLineSimple(r_fore_arm_position, r_hand_position);
	DrawLineSimple(chest_position, stomach_position);
	DrawLineSimple(stomach_position, pelvis_position);
	DrawLineSimple(pelvis_position, l_thigh_position);
	DrawLineSimple(l_thigh_position, l_knee_position);
	DrawLineSimple(l_knee_position, l_foot_position);
	DrawLineSimple(pelvis_position, r_thigh_position);
	DrawLineSimple(r_thigh_position, r_knee_position);
	DrawLineSimple(r_knee_position, r_foot_position);
}


```

`Valorant/Valorant.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United Kingdom) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENG)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_UK
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// WAVE
//



#endif    // English (United Kingdom) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Valorant/Valorant.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{101afe41-beeb-4fb0-816c-0c4e5283a567}</ProjectGuid>
    <RootNamespace>PixelFortnite</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
    <ProjectName>Valorant</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>D:\SDKDX\Include;C:\Users\CRiQValo\Downloads\ABCDEFG\ValorantCheatExternal-master\Includes\Auth;..\Includes\Direct3d;$(IncludePath)</IncludePath>
    <LibraryPath>D:\SDKDX\Lib\x64;C:\Users\CRiQValo\Downloads\ABCDEFG\ValorantCheatExternal-master\Includes\Auth;..\Includes\Direct3d;$(LibraryPath)</LibraryPath>
    <ExternalIncludePath>C:\Users\CRiQValo\Downloads\ABCDEFG\ValorantCheatExternal-master\Includes\Auth;$(ExternalIncludePath)</ExternalIncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;CURL_STATICLIB;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <BufferSecurityCheck>true</BufferSecurityCheck>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalLibraryDirectories>C:\Users\CRiQValo\Downloads\ABCDEFG\ValorantCheatExternal-master\Includes\Auth;C:\Users\MellowNight\Desktop\VALORANTGR\UE4 Usermode\Includes\ProxineAuth\curl;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>$(CoreLibraryDependencies);%(AdditionalDependencies);winmm.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Includes\Imgui\imgui.cpp" />
    <ClCompile Include="..\Includes\Imgui\imgui_demo.cpp" />
    <ClCompile Include="..\Includes\Imgui\imgui_draw.cpp" />
    <ClCompile Include="..\Includes\Imgui\imgui_impl_dx9.cpp" />
    <ClCompile Include="..\Includes\Imgui\imgui_impl_win32.cpp" />
    <ClCompile Include="..\Includes\Imgui\imgui_tables.cpp" />
    <ClCompile Include="..\Includes\Imgui\imgui_widgets.cpp" />
    <ClCompile Include="..\Includes\Mapper\Kdmapper\intel_driver.cpp" />
    <ClCompile Include="..\Includes\Mapper\Kdmapper\kdmapper.cpp" />
    <ClCompile Include="..\Includes\Mapper\Kdmapper\portable_executable.cpp" />
    <ClCompile Include="..\Includes\Mapper\Kdmapper\service.cpp" />
    <ClCompile Include="..\Includes\Mapper\Kdmapper\utils.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="wav.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Includes\Auth\auth.hpp" />
    <ClInclude Include="..\Includes\Imgui\imconfig.h" />
    <ClInclude Include="..\Includes\Imgui\imgui.h" />
    <ClInclude Include="..\Includes\Imgui\imgui_impl_dx9.h" />
    <ClInclude Include="..\Includes\Imgui\imgui_impl_win32.h" />
    <ClInclude Include="..\Includes\Imgui\imgui_internal.h" />
    <ClInclude Include="..\Includes\Imgui\imstb_rectpack.h" />
    <ClInclude Include="..\Includes\Imgui\imstb_textedit.h" />
    <ClInclude Include="..\Includes\Imgui\imstb_truetype.h" />
    <ClInclude Include="..\Includes\Mapper\bytes.hpp" />
    <ClInclude Include="..\Includes\Mapper\Kdmapper\intel_driver.hpp" />
    <ClInclude Include="..\Includes\Mapper\Kdmapper\intel_driver_resource.hpp" />
    <ClInclude Include="..\Includes\Mapper\Kdmapper\kdmapper.hpp" />
    <ClInclude Include="..\Includes\Mapper\Kdmapper\nt.hpp" />
    <ClInclude Include="..\Includes\Mapper\Kdmapper\portable_executable.hpp" />
    <ClInclude Include="..\Includes\Mapper\Kdmapper\service.hpp" />
    <ClInclude Include="..\Includes\Mapper\Kdmapper\utils.hpp" />
    <ClInclude Include="..\Includes\strings.hpp" />
    <ClInclude Include="Aimbot.h" />
    <ClInclude Include="defs.h" />
    <ClInclude Include="Driver\Driver.h" />
    <ClInclude Include="Driver\loader.hpp" />
    <ClInclude Include="Game\cheat.hpp" />
    <ClInclude Include="Game\globals.hpp" />
    <ClInclude Include="Game\sdk.hpp" />
    <ClInclude Include="Game\skStr.h" />
    <ClInclude Include="Game\structs.hpp" />
    <ClInclude Include="Overlay\menu.hpp" />
    <ClInclude Include="Overlay\render.hpp" />
    <ClInclude Include="Radar.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Skeleton.h" />
    <ClInclude Include="Vector3.h" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="..\Includes\Auth\libcurl.lib" />
    <Library Include="..\Includes\Auth\library_x64.lib" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Valorant.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Valorant/Valorant.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="..\Includes\Imgui\imgui.cpp">
      <Filter>Framework</Filter>
    </ClCompile>
    <ClCompile Include="..\Includes\Imgui\imgui_demo.cpp">
      <Filter>Framework</Filter>
    </ClCompile>
    <ClCompile Include="..\Includes\Imgui\imgui_draw.cpp">
      <Filter>Framework</Filter>
    </ClCompile>
    <ClCompile Include="..\Includes\Imgui\imgui_impl_dx9.cpp">
      <Filter>Framework</Filter>
    </ClCompile>
    <ClCompile Include="..\Includes\Imgui\imgui_impl_win32.cpp">
      <Filter>Framework</Filter>
    </ClCompile>
    <ClCompile Include="..\Includes\Imgui\imgui_widgets.cpp">
      <Filter>Framework</Filter>
    </ClCompile>
    <ClCompile Include="..\Includes\Imgui\imgui_tables.cpp">
      <Filter>Framework</Filter>
    </ClCompile>
    <ClCompile Include="..\Includes\Mapper\Kdmapper\intel_driver.cpp">
      <Filter>Driver\Resources</Filter>
    </ClCompile>
    <ClCompile Include="..\Includes\Mapper\Kdmapper\kdmapper.cpp">
      <Filter>Driver\Resources</Filter>
    </ClCompile>
    <ClCompile Include="..\Includes\Mapper\Kdmapper\portable_executable.cpp">
      <Filter>Driver\Resources</Filter>
    </ClCompile>
    <ClCompile Include="..\Includes\Mapper\Kdmapper\service.cpp">
      <Filter>Driver\Resources</Filter>
    </ClCompile>
    <ClCompile Include="..\Includes\Mapper\Kdmapper\utils.cpp">
      <Filter>Driver\Resources</Filter>
    </ClCompile>
    <ClCompile Include="wav.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Game\cheat.hpp">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Game\sdk.hpp">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Game\structs.hpp">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Game\globals.hpp">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Imgui\imconfig.h">
      <Filter>Framework</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Imgui\imgui.h">
      <Filter>Framework</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Imgui\imgui_impl_dx9.h">
      <Filter>Framework</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Imgui\imgui_impl_win32.h">
      <Filter>Framework</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Imgui\imgui_internal.h">
      <Filter>Framework</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Imgui\imstb_rectpack.h">
      <Filter>Framework</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Imgui\imstb_textedit.h">
      <Filter>Framework</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Imgui\imstb_truetype.h">
      <Filter>Framework</Filter>
    </ClInclude>
    <ClInclude Include="Overlay\render.hpp">
      <Filter>Game\Overlay</Filter>
    </ClInclude>
    <ClInclude Include="Overlay\menu.hpp">
      <Filter>Game\Overlay</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Mapper\bytes.hpp">
      <Filter>Driver\Resources</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Mapper\Kdmapper\intel_driver.hpp">
      <Filter>Driver\Resources</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Mapper\Kdmapper\intel_driver_resource.hpp">
      <Filter>Driver\Resources</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Mapper\Kdmapper\kdmapper.hpp">
      <Filter>Driver\Resources</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Mapper\Kdmapper\nt.hpp">
      <Filter>Driver\Resources</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Mapper\Kdmapper\portable_executable.hpp">
      <Filter>Driver\Resources</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Mapper\Kdmapper\service.hpp">
      <Filter>Driver\Resources</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\Mapper\Kdmapper\utils.hpp">
      <Filter>Driver\Resources</Filter>
    </ClInclude>
    <ClInclude Include="Driver\Driver.h">
      <Filter>Driver</Filter>
    </ClInclude>
    <ClInclude Include="Driver\loader.hpp">
      <Filter>Driver\Resources</Filter>
    </ClInclude>
    <ClInclude Include="Game\skStr.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="..\Includes\strings.hpp" />
    <ClInclude Include="defs.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Aimbot.h" />
    <ClInclude Include="Vector3.h" />
    <ClInclude Include="Skeleton.h" />
    <ClInclude Include="Radar.h" />
    <ClInclude Include="..\Includes\Auth\auth.hpp">
      <Filter>Auth</Filter>
    </ClInclude>
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Game">
      <UniqueIdentifier>{ed75c461-8a8c-41e2-9551-a85b4de83294}</UniqueIdentifier>
    </Filter>
    <Filter Include="Driver">
      <UniqueIdentifier>{a5b155fc-b019-457e-a4d7-c391f30143d0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Framework">
      <UniqueIdentifier>{7d2a3ee2-ed36-43a4-81ec-8059b47d6c41}</UniqueIdentifier>
    </Filter>
    <Filter Include="Driver\Resources">
      <UniqueIdentifier>{5c9319d3-1c1e-4151-aa31-9cc2c84042cb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Overlay">
      <UniqueIdentifier>{39406d82-fe78-47f5-8e04-b83774d34cd4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Auth">
      <UniqueIdentifier>{1fa90f79-2d1c-41de-8ef8-323f2349d0c1}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Library Include="..\Includes\Auth\libcurl.lib">
      <Filter>Auth</Filter>
    </Library>
    <Library Include="..\Includes\Auth\library_x64.lib">
      <Filter>Auth</Filter>
    </Library>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Valorant.rc" />
  </ItemGroup>
</Project>
```

`Valorant/Valorant.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Valorant/Vector3.h`:

```h
#include <math.h>
#include "../Valorant/Game/structs.hpp"
#include "Game/sdk.hpp"
#define M_PI                       3.14159265358979323846f

#define URotationToRadians(URotation)		((URotation)* (M_PI / 32768.0f))
#define URotationToDegree( URotation )		( ( URotation ) * ( 360.0f / 65536.0f ) ) 

#define DegreeToURotation( Degree )			( ( Degree ) * ( 65536.0f / 360.0f ) )
#define DegreeToRadian( Degree )			( ( Degree ) * ( M_PI / 180.0f ) )

#define RadianToURotation( URotation )		( ( URotation ) * ( 32768.0f / M_PI ) ) 
#define RadianToDegree( Radian )			( ( Radian ) * ( 180.0f / M_PI ) )

#define RAD2DEG( x  )  ( (float)(x) * (float)(180.f / M_PI_F) )

struct alignas(16) FPlane : public FVector
{
    float                                              W;                                                        // 0x000C(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
};
struct Vector2 {
public:
    float x;
    float y;

    inline Vector2() : x(0), y(0) {}
    inline Vector2(float x, float y) : x(x), y(y) {}

    inline float Distance(Vector2 v) {
        return sqrtf(((v.x - x) * (v.x - x) + (v.y - y) * (v.y - y)));
    }

    inline Vector2 operator+(const Vector2& v) const {
        return Vector2(x + v.x, y + v.y);
    }

    inline Vector2 operator-(const Vector2& v) const {
        return Vector2(x - v.x, y - v.y);
    }
};
struct FVector2D {
public:
    float x;
    float y;

    inline FVector2D() : x(0), y(0) {}
    inline FVector2D(float x, float y) : x(x), y(y) {}

    inline float Distance(FVector2D v) {
        return sqrtf(((v.x - x) * (v.x - x) + (v.y - y) * (v.y - y)));
    }

    inline FVector2D operator+(const FVector2D& v) const {
        return FVector2D(x + v.x, y + v.y);
    }

    inline FVector2D operator-(const FVector2D& v) const {
        return FVector2D(x - v.x, y - v.y);
    }

};
struct FMatrix
{
    struct FPlane                                      XPlane;                                                   // 0x0000(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    struct FPlane                                      YPlane;                                                   // 0x0010(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    struct FPlane                                      ZPlane;                                                   // 0x0020(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    struct FPlane                                      WPlane;                                                   // 0x0030(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)

    FMatrix operator*(const FMatrix& pM2)
    {
        FMatrix pOut;
        pOut.XPlane.x = XPlane.x * pM2.XPlane.x + XPlane.y * pM2.YPlane.x + XPlane.z * pM2.ZPlane.x + XPlane.W * pM2.WPlane.x;
        pOut.XPlane.y = XPlane.x * pM2.XPlane.y + XPlane.y * pM2.YPlane.y + XPlane.z * pM2.ZPlane.y + XPlane.W * pM2.WPlane.y;
        pOut.XPlane.z = XPlane.x * pM2.XPlane.z + XPlane.y * pM2.YPlane.z + XPlane.z * pM2.ZPlane.z + XPlane.W * pM2.WPlane.z;
        pOut.XPlane.W = XPlane.x * pM2.XPlane.W + XPlane.y * pM2.YPlane.W + XPlane.z * pM2.ZPlane.W + XPlane.W * pM2.WPlane.W;
        pOut.YPlane.x = YPlane.x * pM2.XPlane.x + YPlane.y * pM2.YPlane.x + YPlane.z * pM2.ZPlane.x + YPlane.W * pM2.WPlane.x;
        pOut.YPlane.y = YPlane.x * pM2.XPlane.y + YPlane.y * pM2.YPlane.y + YPlane.z * pM2.ZPlane.y + YPlane.W * pM2.WPlane.y;
        pOut.YPlane.z = YPlane.x * pM2.XPlane.z + YPlane.y * pM2.YPlane.z + YPlane.z * pM2.ZPlane.z + YPlane.W * pM2.WPlane.z;
        pOut.YPlane.W = YPlane.x * pM2.XPlane.W + YPlane.y * pM2.YPlane.W + YPlane.z * pM2.ZPlane.W + YPlane.W * pM2.WPlane.W;
        pOut.ZPlane.x = ZPlane.x * pM2.XPlane.x + ZPlane.y * pM2.YPlane.x + ZPlane.z * pM2.ZPlane.x + ZPlane.W * pM2.WPlane.x;
        pOut.ZPlane.y = ZPlane.x * pM2.XPlane.y + ZPlane.y * pM2.YPlane.y + ZPlane.z * pM2.ZPlane.y + ZPlane.W * pM2.WPlane.y;
        pOut.ZPlane.z = ZPlane.x * pM2.XPlane.z + ZPlane.y * pM2.YPlane.z + ZPlane.z * pM2.ZPlane.z + ZPlane.W * pM2.WPlane.z;
        pOut.ZPlane.W = ZPlane.x * pM2.XPlane.W + ZPlane.y * pM2.YPlane.W + ZPlane.z * pM2.ZPlane.W + ZPlane.W * pM2.WPlane.W;
        pOut.WPlane.x = WPlane.x * pM2.XPlane.x + WPlane.y * pM2.YPlane.x + WPlane.z * pM2.ZPlane.x + WPlane.W * pM2.WPlane.x;
        pOut.WPlane.y = WPlane.x * pM2.XPlane.y + WPlane.y * pM2.YPlane.y + WPlane.z * pM2.ZPlane.y + WPlane.W * pM2.WPlane.y;
        pOut.WPlane.z = WPlane.x * pM2.XPlane.z + WPlane.y * pM2.YPlane.z + WPlane.z * pM2.ZPlane.z + WPlane.W * pM2.WPlane.z;
        pOut.WPlane.W = WPlane.x * pM2.XPlane.W + WPlane.y * pM2.YPlane.W + WPlane.z * pM2.ZPlane.W + WPlane.W * pM2.WPlane.W;
        return pOut;
    }
};


```

`Valorant/defs.h`:

```h
#ifndef DEFS_H
#define DEFS_H

#if defined(__GNUC__)
typedef          long long ll;
typedef unsigned long long ull;
#define __int64 long long
#define __int32 int
#define __int16 short
#define __int8  char
#define MAKELL(num) num ## LL
#define FMT_64 "ll"
#elif defined(_MSC_VER)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "I64"
#elif defined (__BORLANDC__)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "L"
#else
#error "unknown compiler"
#endif

typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;

// Partially defined types. They are used when the decompiler does not know
// anything about the type except its size.
#define _BYTE  uint8
#define _WORD  uint16
#define _DWORD uint32
#define _QWORD uint64
#if !defined(_MSC_VER)
#define _LONGLONG __int128
#endif

// Non-standard boolean types. They are used when the decompiler can not use
// the standard "bool" type because of the size mistmatch but the possible
// values are only 0 and 1. See also 'BOOL' type below.
typedef int8 _BOOL1;
typedef int16 _BOOL2;
typedef int32 _BOOL4;

//#ifndef _WINDOWS_
//typedef int8 BYTE;
//typedef int16 WORD;
//typedef int32 DWORD;
//typedef int32 LONG;
//typedef int BOOL;       // uppercase BOOL is usually 4 bytes
//#endif
//typedef int64 QWORD;
#ifndef __cplusplus
typedef int bool;       // we want to use bool in our C programs
#endif

#define __pure          // pure function: always returns the same value, has no
// side effects

// Non-returning function
#if defined(__GNUC__)
#define __noreturn  __attribute__((noreturn))
#else
#define __noreturn  __declspec(noreturn)
#endif


#ifndef NULL
#define NULL 0
#endif

// Some convenience macros to make partial accesses nicer
#define LAST_IND(x,part_type)    (sizeof(x)/sizeof(part_type) - 1)
#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN
#  define LOW_IND(x,part_type)   LAST_IND(x,part_type)
#  define HIGH_IND(x,part_type)  0
#else
#  define HIGH_IND(x,part_type)  LAST_IND(x,part_type)
#  define LOW_IND(x,part_type)   0
#endif
// first unsigned macros:
//#define LODWORD(x)  (*((DWORD*)&(x)))  // low dword
//#define HIDWORD(x)  (*((DWORD*)&(x)+1))

#define BYTEn(x, n)   (*((_BYTE*)&(x)+n))
#define WORDn(x, n)   (*((_WORD*)&(x)+n))
#define DWORDn(x, n)  (*((_DWORD*)&(x)+n))

#define LOBYTE(x)  BYTEn(x,LOW_IND(x,_BYTE))
#define LOWORD(x)  WORDn(x,LOW_IND(x,_WORD))
#define LODWORD(x) DWORDn(x,LOW_IND(x,_DWORD))
#define HIBYTE(x)  BYTEn(x,HIGH_IND(x,_BYTE))
#define HIWORD(x)  WORDn(x,HIGH_IND(x,_WORD))
#define HIDWORD(x) DWORDn(x,HIGH_IND(x,_DWORD))
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)
#define BYTE3(x)   BYTEn(x,  3)
#define BYTE4(x)   BYTEn(x,  4)
#define BYTE5(x)   BYTEn(x,  5)
#define BYTE6(x)   BYTEn(x,  6)
#define BYTE7(x)   BYTEn(x,  7)
#define BYTE8(x)   BYTEn(x,  8)
#define BYTE9(x)   BYTEn(x,  9)
#define BYTE10(x)  BYTEn(x, 10)
#define BYTE11(x)  BYTEn(x, 11)
#define BYTE12(x)  BYTEn(x, 12)
#define BYTE13(x)  BYTEn(x, 13)
#define BYTE14(x)  BYTEn(x, 14)
#define BYTE15(x)  BYTEn(x, 15)
#define WORD1(x)   WORDn(x,  1)
#define WORD2(x)   WORDn(x,  2)         // third word of the object, unsigned
#define WORD3(x)   WORDn(x,  3)
#define WORD4(x)   WORDn(x,  4)
#define WORD5(x)   WORDn(x,  5)
#define WORD6(x)   WORDn(x,  6)
#define WORD7(x)   WORDn(x,  7)

// now signed macros (the same but with sign extension)
#define SBYTEn(x, n)   (*((int8*)&(x)+n))
#define SWORDn(x, n)   (*((int16*)&(x)+n))
#define SDWORDn(x, n)  (*((int32*)&(x)+n))

#define SLOBYTE(x)  SBYTEn(x,LOW_IND(x,int8))
#define SLOWORD(x)  SWORDn(x,LOW_IND(x,int16))
#define SLODWORD(x) SDWORDn(x,LOW_IND(x,int32))
#define SHIBYTE(x)  SBYTEn(x,HIGH_IND(x,int8))
#define SHIWORD(x)  SWORDn(x,HIGH_IND(x,int16))
#define SHIDWORD(x) SDWORDn(x,HIGH_IND(x,int32))
#define SBYTE1(x)   SBYTEn(x,  1)
#define SBYTE2(x)   SBYTEn(x,  2)
#define SBYTE3(x)   SBYTEn(x,  3)
#define SBYTE4(x)   SBYTEn(x,  4)
#define SBYTE5(x)   SBYTEn(x,  5)
#define SBYTE6(x)   SBYTEn(x,  6)
#define SBYTE7(x)   SBYTEn(x,  7)
#define SBYTE8(x)   SBYTEn(x,  8)
#define SBYTE9(x)   SBYTEn(x,  9)
#define SBYTE10(x)  SBYTEn(x, 10)
#define SBYTE11(x)  SBYTEn(x, 11)
#define SBYTE12(x)  SBYTEn(x, 12)
#define SBYTE13(x)  SBYTEn(x, 13)
#define SBYTE14(x)  SBYTEn(x, 14)
#define SBYTE15(x)  SBYTEn(x, 15)
#define SWORD1(x)   SWORDn(x,  1)
#define SWORD2(x)   SWORDn(x,  2)
#define SWORD3(x)   SWORDn(x,  3)
#define SWORD4(x)   SWORDn(x,  4)
#define SWORD5(x)   SWORDn(x,  5)
#define SWORD6(x)   SWORDn(x,  6)
#define SWORD7(x)   SWORDn(x,  7)


// Helper functions to represent some assembly instructions.

#ifdef __cplusplus

// compile time assertion
#define __CASSERT_N0__(l) COMPILE_TIME_ASSERT_ ## l
#define __CASSERT_N1__(l) __CASSERT_N0__(l)
#define CASSERT(cnd) typedef char __CASSERT_N1__(__LINE__) [(cnd) ? 1 : -1]

// check that unsigned multiplication does not overflow
template<class T> bool is_mul_ok(T count, T elsize)
{
	CASSERT((T)(-1) > 0); // make sure T is unsigned
	if (elsize == 0 || count == 0)
		return true;
	return count <= ((T)(-1)) / elsize;
}

// multiplication that saturates (yields the biggest value) instead of overflowing
// such a construct is useful in "operator new[]"
template<class T> bool saturated_mul(T count, T elsize)
{
	return is_mul_ok(count, elsize) ? count * elsize : T(-1);
}

#include <stddef.h> // for size_t
#include <cstdint>

// memcpy() with determined behavoir: it always copies
// from the start to the end of the buffer
// note: it copies byte by byte, so it is not equivalent to, for example, rep movsd
inline void* qmemcpy(void* dst, const void* src, size_t cnt)
{
	char* out = (char*)dst;
	const char* in = (const char*)src;
	while (cnt > 0)
	{
		*out++ = *in++;
		--cnt;
	}
	return dst;
}

// Generate a reference to pair of operands
template<class T>  int16 __PAIR__(int8  high, T low) { return (((int16)high) << sizeof(high) * 8) | uint8(low); }
template<class T>  int32 __PAIR__(int16 high, T low) { return (((int32)high) << sizeof(high) * 8) | uint16(low); }
template<class T>  int64 __PAIR__(int32 high, T low) { return (((int64)high) << sizeof(high) * 8) | uint32(low); }
template<class T> uint16 __PAIR__(uint8  high, T low) { return (((uint16)high) << sizeof(high) * 8) | uint8(low); }
template<class T> uint32 __PAIR__(uint16 high, T low) { return (((uint32)high) << sizeof(high) * 8) | uint16(low); }
template<class T> uint64 __PAIR__(uint32 high, T low) { return (((uint64)high) << sizeof(high) * 8) | uint32(low); }

// rotate left
template<class T> T __ROL__(T value, int count)
{
	const uint nbits = sizeof(T) * 8;

	if (count > 0)
	{
		count %= nbits;
		T high = value >> (nbits - count);
		if (T(-1) < 0)
			high &= ~((T(-1) << count));
		value <<= count;
		value |= high;
	}
	else
	{
		count = -count % nbits;
		T low = value << (nbits - count);
		value >>= count;
		value |= low;
	}
	return value;
}

inline uint8  __ROL1__(uint8  value, int count) { return __ROL__((uint8)value, count); }
inline uint16 __ROL2__(uint16 value, int count) { return __ROL__((uint16)value, count); }
inline uint32 __ROL4__(uint32 value, int count) { return __ROL__((uint32)value, count); }
inline uint64 __ROL8__(uint64 value, int count) { return __ROL__((uint64)value, count); }
inline uint8  __ROR1__(uint8  value, int count) { return __ROL__((uint8)value, -count); }
inline uint16 __ROR2__(uint16 value, int count) { return __ROL__((uint16)value, -count); }
inline uint32 __ROR4__(uint32 value, int count) { return __ROL__((uint32)value, -count); }
inline uint64 __ROR8__(uint64 value, int count) { return __ROL__((uint64)value, -count); }

// carry flag of left shift
template<class T> int8 __MKCSHL__(T value, uint count)
{
	const uint nbits = sizeof(T) * 8;
	count %= nbits;

	return (value >> (nbits - count)) & 1;
}

// carry flag of right shift
template<class T> int8 __MKCSHR__(T value, uint count)
{
	return (value >> (count - 1)) & 1;
}

// sign flag
template<class T> int8 __SETS__(T x)
{
	if (sizeof(T) == 1)
		return int8(x) < 0;
	if (sizeof(T) == 2)
		return int16(x) < 0;
	if (sizeof(T) == 4)
		return int32(x) < 0;
	return int64(x) < 0;
}

// overflow flag of subtraction (x-y)
template<class T, class U> int8 __OFSUB__(T x, U y)
{
	if (sizeof(T) < sizeof(U))
	{
		U x2 = x;
		int8 sx = __SETS__(x2);
		return (sx ^ __SETS__(y)) & (sx ^ __SETS__(x2 - y));
	}
	else
	{
		T y2 = y;
		int8 sx = __SETS__(x);
		return (sx ^ __SETS__(y2)) & (sx ^ __SETS__(x - y2));
	}
}

// overflow flag of addition (x+y)
template<class T, class U> int8 __OFADD__(T x, U y)
{
	if (sizeof(T) < sizeof(U))
	{
		U x2 = x;
		int8 sx = __SETS__(x2);
		return ((1 ^ sx) ^ __SETS__(y)) & (sx ^ __SETS__(x2 + y));
	}
	else
	{
		T y2 = y;
		int8 sx = __SETS__(x);
		return ((1 ^ sx) ^ __SETS__(y2)) & (sx ^ __SETS__(x + y2));
	}
}

// carry flag of subtraction (x-y)
template<class T, class U> int8 __CFSUB__(T x, U y)
{
	int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
	if (size == 1)
		return uint8(x) < uint8(y);
	if (size == 2)
		return uint16(x) < uint16(y);
	if (size == 4)
		return uint32(x) < uint32(y);
	return uint64(x) < uint64(y);
}

// carry flag of addition (x+y)
template<class T, class U> int8 __CFADD__(T x, U y)
{
	int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
	if (size == 1)
		return uint8(x) > uint8(x + y);
	if (size == 2)
		return uint16(x) > uint16(x + y);
	if (size == 4)
		return uint32(x) > uint32(x + y);
	return uint64(x) > uint64(x + y);
}



#else
// The following definition is not quite correct because it always returns
// uint64. The above C++ functions are good, though.
#define __PAIR__(high, low) (((uint64)(high)<<sizeof(high)*8) | low)
// For C, we just provide macros, they are not quite correct.
#define __ROL__(x, y) __rotl__(x, y)      // Rotate left
#define __ROR__(x, y) __rotr__(x, y)      // Rotate right
#define __CFSHL__(x, y) invalid_operation // Generate carry flag for (x<<y)
#define __CFSHR__(x, y) invalid_operation // Generate carry flag for (x>>y)
#define __CFADD__(x, y) invalid_operation // Generate carry flag for (x+y)
#define __CFSUB__(x, y) invalid_operation // Generate carry flag for (x-y)
#define __OFADD__(x, y) invalid_operation // Generate overflow flag for (x+y)
#define __OFSUB__(x, y) invalid_operation // Generate overflow flag for (x-y)
#endif

// No definition for rcl/rcr because the carry flag is unknown
#define __RCL__(x, y)    invalid_operation // Rotate left thru carry
#define __RCR__(x, y)    invalid_operation // Rotate right thru carry
#define __MKCRCL__(x, y) invalid_operation // Generate carry flag for a RCL
#define __MKCRCR__(x, y) invalid_operation // Generate carry flag for a RCR
#define __SETP__(x, y)   invalid_operation // Generate parity flag for (x-y)

// In the decompilation listing there are some objects declarared as _UNKNOWN
// because we could not determine their types. Since the C compiler does not
// accept void item declarations, we replace them by anything of our choice,
// for example a char:

#define _UNKNOWN char

//#ifdef _MSC_VER
//#define snprintf _snprintf
//#define vsnprintf _vsnprintf
//#endif

unsigned int decrypt_xor_keys(unsigned __int64 state[7], unsigned int key)
{
	__int64 v2;
	unsigned __int64 v3;
	unsigned __int64 v4;
	unsigned __int64 v5;
	unsigned int v6;
	__int64 v7;
	unsigned int v8;
	int v9;
	unsigned int v10;
	unsigned __int64 v11;

	v2 = key << 25;
	v3 = 0x2545F4914F6CDD1Di64 * (key ^ v2 ^ ((key ^ ((unsigned __int64)key >> 15)) >> 12)) % 7;
	v4 = state[v3];
	v5 = (0x2545F4914F6CDD1Di64 * (key ^ v2 ^ ((key ^ ((unsigned __int64)key >> 15)) >> 12))) >> 32;
	v6 = (unsigned int)v3 % 7;
	if (!((unsigned int)v3 % 7))
	{
		v7 = 2 * ((2 * v4) ^ ((2 * v4) ^ (v4 >> 1)) & 0x5555555555555555i64);
		v4 = v7 ^ (v7 ^ (((2 * v4) ^ ((2 * v4) ^ (v4 >> 1)) & 0x5555555555555555i64) >> 1)) & 0x5555555555555555i64;
	LABEL_5:
		v8 = v5 + v3;
		v9 = 2 * v3;
		goto LABEL_6;
	}

	if (v6 != 1)
	{
		goto LABEL_5;
	}

	v9 = 2 * v3;
	v8 = v5 + v3;
	v4 = ~(unsigned __int64)(unsigned int)(v5 + v3) ^ (v4 - (unsigned int)(v5 + 2 * v3));

LABEL_6:
	if (v6 == 2)
	{
		v4 = __ROL8__((2 * v4) ^ ((2 * v4) ^ (v4 >> 1)) & 0x5555555555555555i64, (unsigned __int8)(v8 % 0x3F) + 1);
	LABEL_8:
		v10 = v9 + v5;
		goto LABEL_9;
	}

	if (v6 != 3)
	{
		goto LABEL_8;
	}

	v10 = v5 + v9;
	v4 = __ROL8__((unsigned int)(v5 + v9) + v4, (unsigned __int8)(v8 % 0x3F) + 1);

LABEL_9:
	switch (v6)
	{
	case 4u:
		v4 ^= v8;
		break;
	case 5u:
		v4 += v8 - (unsigned __int64)v10;
		break;
	case 6u:
		v11 = __ROL8__(v4, (unsigned __int8)(v10 % 0x3F) + 1);
		v4 = (2 * v11) ^ ((2 * v11) ^ (v11 >> 1)) & 0x5555555555555555i64;
		break;
	}

	return *(unsigned int*)(v4 ^ key);
}
__forceinline __int64 decrypt_uworld(const uint32_t key, const uintptr_t* state)
{

	unsigned __int64 v19; // r11
	unsigned __int64 v20; // r8
	unsigned __int64 v21; // r9
	unsigned int v22; // er10
	unsigned __int64 v23; // rcx
	unsigned __int64 v24; // rdx
	unsigned __int64 v25; // rcx
	int v26; // ebx
	unsigned int v27; // ecx
	__int64 v28; // rax
	unsigned __int64 v29; // r8
	unsigned __int64 v30; // r8
	unsigned __int64 v31; // rcx
	unsigned __int64 v32; // rdx
	unsigned __int64 v33; // rcx

	v19 = 2685821657736338717i64
		* ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12))
		% 7;
	v20 = state[v19];
	v21 = (2685821657736338717i64
		* ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12))) >> 32;
	v22 = (unsigned int)v19 % 7;
	if (!((unsigned int)v19 % 7))
	{
		v23 = (2 * (v20 - (unsigned int)(v21 - 1))) ^ ((2 * (v20 - (unsigned int)(v21 - 1))) ^ ((v20
			- (unsigned int)(v21 - 1)) >> 1)) & 0x5555555555555555i64;
		v24 = (4 * v23) ^ ((4 * v23) ^ (v23 >> 2)) & 0x3333333333333333i64;
		v25 = (16 * v24) ^ ((16 * v24) ^ (v24 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
		v20 = __ROL8__((v25 << 8) ^ ((v25 << 8) ^ (v25 >> 8)) & 0xFF00FF00FF00FFi64, 32);
	LABEL_26:
		v26 = 2 * v19;
		goto LABEL_27;
	}
	if (v22 != 1)
		goto LABEL_26;
	v26 = 2 * v19;
	v20 = __ROL8__(v20 - (unsigned int)(2 * v19 + v21), (unsigned __int8)(((int)v21 + (int)v19) % 0x3Fu) + 1);
LABEL_27:
	v27 = v26 + v21;
	if (v22 == 2)
		v20 = ~(v20 - v27);
	switch (v22)
	{
	case 3u:
		v28 = 2 * ((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64);
		v20 = v28 ^ (v28 ^ (((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64) >> 1)) & 0x5555555555555555i64;
		break;
	case 4u:
		v29 = __ROR8__(v20, (unsigned __int8)(v27 % 0x3F) + 1);
		v20 = (2 * v29) ^ ((2 * v29) ^ (v29 >> 1)) & 0x5555555555555555i64;
		break;
	case 5u:
		v30 = __ROR8__(v20, (unsigned __int8)(v27 % 0x3F) + 1);
		v31 = (2 * v30) ^ ((2 * v30) ^ (v30 >> 1)) & 0x5555555555555555i64;
		v32 = (4 * v31) ^ ((4 * v31) ^ (v31 >> 2)) & 0x3333333333333333i64;
		v33 = (16 * v32) ^ ((16 * v32) ^ (v32 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
		v20 = __ROL8__((v33 << 8) ^ ((v33 << 8) ^ (v33 >> 8)) & 0xFF00FF00FF00FFi64, 32);
		break;
	case 6u:
		v20 = ~v20 - (unsigned int)(v21 + v19);
		break;
	}
	return v20 ^ (unsigned int)key;
}
#endif
```

`Valorant/main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <thread>
#include <string>
#include <filesystem>
#include "../Includes/strings.hpp"
#include "overlay/render.hpp"
#include "overlay/menu.hpp"
#include "Game/skStr.h"
#include "game/cheat.hpp"

#include <TlHelp32.h>
#include <string>

#include "driver/driver.h"
#include "Auth/auth.hpp"

std::wstring s2ws(const std::string& str) {
	int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);
	std::wstring wstrTo(size_needed, 0);
	MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstrTo[0], size_needed);
	return wstrTo;
}

int retreiveValProcessId()
{
	//BYTE target_name[] = { 'n','o','t','e','p','a','d','.','e','x','e', 0 };
	BYTE target_name[] = { 'V','A','L','O','R','A','N','T','-','W','i','n','6','4','-','S','h','i','p','p','i','n','g','.','e','x','e', 0 };
	std::wstring process_name = s2ws(std::string((char*)target_name));
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32W entry;
	entry.dwSize = sizeof(entry);

	if (!Process32First(snapshot, &entry)) {
		return 0;
	}

	while (Process32Next(snapshot, &entry)) {
		if (std::wstring(entry.szExeFile) == process_name) {
			return entry.th32ProcessID;
		}
	}

	return 0;
}

#include "../Includes/Mapper/Kdmapper/kdmapper.hpp"
#include "Game/skStr.h"
HANDLE iqvw64e_device_handle;

LONG WINAPI SimplestCrashHandler(EXCEPTION_POINTERS* ExceptionInfo)
{
	std::cout << "[+] Driver Error at 0x" << ExceptionInfo->ExceptionRecord->ExceptionAddress << " by 0x" << std::hex << ExceptionInfo->ExceptionRecord->ExceptionCode << std::endl;

	if (iqvw64e_device_handle)
		intel_driver::Unload(iqvw64e_device_handle);

	return EXCEPTION_EXECUTE_HANDLER;
}

int load_driver()
{
	SetUnhandledExceptionFilter(SimplestCrashHandler);
	if (intel_driver::IsRunning())
	{
		std::cout << "[+] Restart PC!" << std::endl;
		Sleep(500);
	}
	iqvw64e_device_handle = intel_driver::Load();

	NTSTATUS exitCode = 0;
	if (!kdmapper::MapDriver(iqvw64e_device_handle, 0, 0, false, true, 0, 0, 0, &exitCode)) {
		{
			std::cout << "[+] Failed to map the driver!" << std::endl;
			intel_driver::Unload(iqvw64e_device_handle);
			Sleep(500);
			exit(0);
		}
	}
	intel_driver::Unload(iqvw64e_device_handle);

	Sleep(500);
}

auto main() -> NTSTATUS
{
	SetConsoleTitleA("Valorant");
	std::cout << "\nSponsered by Beef.exe\n";
	std::cout << "Only for testing.";
	Sleep(3000);
	system("cls");

	if (GlobalFindAtomA(XorStr("DriverAlreadyLoadedxOKOK").c_str()) == 0)
	{
		load_driver();
		system(XorStr("cls").c_str());
		GlobalAddAtomA(XorStr("DriverAlreadyLoadedxOKOK").c_str());
	}

	if (!InitHandles()) {
		printf(skCrypt("[mapper] failed to initialize communication!\n"));
		return -1;
	}
	system("cls");
	std::cout << "Waiting for valorant bloke.";

	HWND Entryhwnd = NULL;

	while (Entryhwnd == NULL)
	{

		process_id = retreiveValProcessId();;
		Entryhwnd = get_process_wnd(process_id);
		Sleep(500);
	}

	system(XorStr("cls").c_str());

	setup_window();
	init_wndparams(MyWnd);

	image_base = GetBaseAddress();
	printf("Valorant Base Address: 0x%llx\n", image_base);

	if (!image_base) {
		printf(skCrypt("[mapper] failed to get base address of process id -> %d\n"), process_id);
	}

	SetGuardedRegion();
	std::thread(CacheGame).detach();
	while (true) main_loop();

	exit(0);
}

auto render() -> void
{
	ImGui_ImplDX9_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();

	//if (GetAsyncKeyState(VK_F1) & 1) { settings::show_menu = !settings::show_menu; }
	//if (GetAsyncKeyState(VK_INSERT) & 1) { settings::show_radar = !settings::show_radar; }
	CheatLoop();
	drawmenu(); // huge cpu


	ImGui::EndFrame();
	p_Device->SetRenderState(D3DRS_ZENABLE, false);
	p_Device->SetRenderState(D3DRS_ALPHABLENDENABLE, false);
	p_Device->SetRenderState(D3DRS_SCISSORTESTENABLE, false);
	p_Device->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_ARGB(0, 0, 0, 0), 1.0f, 0);

	if (p_Device->BeginScene() >= 0)
	{
		ImGui::Render();
		ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
		p_Device->EndScene();
	}

	HRESULT result = p_Device->Present(NULL, NULL, NULL, NULL);

	if (result == D3DERR_DEVICELOST && p_Device->TestCooperativeLevel() == D3DERR_DEVICENOTRESET)
	{
		ImGui_ImplDX9_InvalidateDeviceObjects();
		p_Device->Reset(&d3dpp);
		ImGui_ImplDX9_CreateDeviceObjects();
	}
	//Sleep(1);
}


auto main_loop() -> WPARAM
{
	static RECT old_rc;
	ZeroMemory(&Message, sizeof(MSG));

	while (Message.message != WM_QUIT)
	{
		if (PeekMessage(&Message, MyWnd, 0, 0, PM_REMOVE)) {
			TranslateMessage(&Message);
			DispatchMessage(&Message);
		}

		HWND hwnd_active = GetForegroundWindow();
		if (GetAsyncKeyState(0x23) & 1)
			exit(8);

		if (hwnd_active == GameWnd) {
			HWND hwndtest = GetWindow(hwnd_active, GW_HWNDPREV);
			SetWindowPos(MyWnd, hwndtest, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
		}
		RECT rc;
		POINT xy;

		ZeroMemory(&rc, sizeof(RECT));
		ZeroMemory(&xy, sizeof(POINT));
		GetClientRect(GameWnd, &rc);
		ClientToScreen(GameWnd, &xy);
		rc.left = xy.x;
		rc.top = xy.y;

		ImGuiIO& io = ImGui::GetIO();
		io.ImeWindowHandle = GameWnd;
		io.DeltaTime = 1.0f / 60.0f;

		POINT p;
		GetCursorPos(&p);
		io.MousePos.x = p.x - xy.x;
		io.MousePos.y = p.y - xy.y;

		if (GetAsyncKeyState(0x1)) {
			io.MouseDown[0] = true;
			io.MouseClicked[0] = true;
			io.MouseClickedPos[0].x = io.MousePos.x;
			io.MouseClickedPos[0].x = io.MousePos.y;
		}
		else io.MouseDown[0] = false;

		if (rc.left != old_rc.left || rc.right != old_rc.right || rc.top != old_rc.top || rc.bottom != old_rc.bottom) {

			old_rc = rc;

			Width = rc.right;
			Height = rc.bottom;

			p_Params.BackBufferWidth = Width;
			p_Params.BackBufferHeight = Height;
			SetWindowPos(MyWnd, (HWND)0, xy.x, xy.y, Width, Height, SWP_NOREDRAW);
			p_Device->Reset(&p_Params);
		}
		render();
	}

	ImGui_ImplDX9_Shutdown();
	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();

	cleanup_d3d();
	DestroyWindow(MyWnd);

	return Message.wParam;
}

```

`Valorant/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Valorant.rc
//
#define IDR_WAVE1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Valorant/wav.c`:

```c
// empty
```