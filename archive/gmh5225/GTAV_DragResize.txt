Project Path: arc_gmh5225_GTAV_DragResize_375o4900

Source Tree:

```txt
arc_gmh5225_GTAV_DragResize_375o4900
├── GTAV_DragResize
│   ├── GTAV_DragResize.vcxproj
│   ├── GTAV_DragResize.vcxproj.filters
│   ├── GTAV_DragResize.vcxproj.user
│   ├── Game.cpp
│   ├── Game.h
│   ├── Main.cpp
│   ├── Types.h
│   ├── Utility
│   │   ├── General.cpp
│   │   ├── General.h
│   │   ├── Logger.cpp
│   │   ├── Logger.h
│   │   ├── MemAddr.cpp
│   │   ├── MemAddr.h
│   │   ├── Pattern.h
│   │   ├── Thread.cpp
│   │   ├── Thread.h
│   │   └── Trace.h
│   ├── WindowHook.cpp
│   ├── WindowHook.h
│   ├── stdafx.cpp
│   └── stdafx.h
├── GTAV_DragResize.sln
└── LICENSE

```

`GTAV_DragResize.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2003
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GTAV_DragResize", "GTAV_DragResize\GTAV_DragResize.vcxproj", "{C943B105-8399-4BAB-8529-BC4AEFFCCC40}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C943B105-8399-4BAB-8529-BC4AEFFCCC40}.Debug|x64.ActiveCfg = Debug|x64
		{C943B105-8399-4BAB-8529-BC4AEFFCCC40}.Debug|x64.Build.0 = Debug|x64
		{C943B105-8399-4BAB-8529-BC4AEFFCCC40}.Release|x64.ActiveCfg = Release|x64
		{C943B105-8399-4BAB-8529-BC4AEFFCCC40}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F7F24B44-3385-47A7-ABB5-CEBB003DDC6A}
	EndGlobalSection
EndGlobal

```

`GTAV_DragResize/GTAV_DragResize.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Game.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="Utility\General.cpp" />
    <ClCompile Include="Utility\Logger.cpp" />
    <ClCompile Include="Utility\MemAddr.cpp" />
    <ClCompile Include="Utility\Thread.cpp" />
    <ClCompile Include="WindowHook.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Game.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="Types.h" />
    <ClInclude Include="Utility\General.h" />
    <ClInclude Include="Utility\Logger.h" />
    <ClInclude Include="Utility\MemAddr.h" />
    <ClInclude Include="Utility\Pattern.h" />
    <ClInclude Include="Utility\Thread.h" />
    <ClInclude Include="Utility\Trace.h" />
    <ClInclude Include="WindowHook.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{C943B105-8399-4BAB-8529-BC4AEFFCCC40}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>GTAVDragResize</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetExt>.asi</TargetExt>
    <OutDir>$(SolutionDir)Build\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)Build\Intermediate\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.asi</TargetExt>
    <OutDir>$(SolutionDir)Build\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)Build\Intermediate\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;GTAVDRAGRESIZE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(TargetPath)" "E:\Program Files\Rockstar Games\Grand Theft Auto V\asi\$(ProjectName).asi"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;GTAVDRAGRESIZE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(TargetPath)" "E:\Program Files\Rockstar Games\Grand Theft Auto V\asi\$(ProjectName).asi"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GTAV_DragResize/GTAV_DragResize.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\Utility">
      <UniqueIdentifier>{fe8fca25-05e4-4bd4-8610-011f5c25fc5c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Utility\General.cpp">
      <Filter>Source Files\Utility</Filter>
    </ClCompile>
    <ClCompile Include="Utility\Logger.cpp">
      <Filter>Source Files\Utility</Filter>
    </ClCompile>
    <ClCompile Include="Utility\MemAddr.cpp">
      <Filter>Source Files\Utility</Filter>
    </ClCompile>
    <ClCompile Include="Utility\Thread.cpp">
      <Filter>Source Files\Utility</Filter>
    </ClCompile>
    <ClCompile Include="Game.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WindowHook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Utility\General.h">
      <Filter>Source Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="Utility\Logger.h">
      <Filter>Source Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="Utility\MemAddr.h">
      <Filter>Source Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="Utility\Pattern.h">
      <Filter>Source Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="Utility\Thread.h">
      <Filter>Source Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="Utility\Trace.h">
      <Filter>Source Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="Game.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Types.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="WindowHook.h">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`GTAV_DragResize/GTAV_DragResize.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`GTAV_DragResize/Game.cpp`:

```cpp
#include "stdafx.h"

static Game g_game;

bool Game::Initialize() {

    auto patternSearch = Utility::BytePattern( "40 38 35 ? ? ? ? 74 21 0F 10 05 ? ? ? ?", false );

    if ( patternSearch.size() <= 0 ) {

        return false;
    }

    auto address = ( uintptr_t )patternSearch.get().get();

    m_pShouldUpdateWindow = ( PBYTE )( *( int32_t* )( address + 3 ) + address + 7 );

    address += 9;

    m_pRenderInfo = ( CRenderSettingsInfo* )( *( int32_t* )( address + 3 ) + address + 7 );

    return true;
}

void Game::UpdateWindowRect( int width, int height ) {

    m_pRenderInfo->width = width;
    m_pRenderInfo->height = height;

    *m_pShouldUpdateWindow = 1;
}

Game * Game::Instance() {

    return &g_game;
}

```

`GTAV_DragResize/Game.h`:

```h
#pragma once
#include "Types.h"

class Game {
    PBYTE m_pShouldUpdateWindow;
    CRenderSettingsInfo * m_pRenderInfo;
  public:
    bool Initialize();
    void UpdateWindowRect( int width, int height );
    static Game * Instance();
};


```

`GTAV_DragResize/Main.cpp`:

```cpp
#include "stdafx.h"

using namespace Utility;

static Thread initThread = Thread( []( ThreadState* s ) {

    HWND windowHandle = nullptr;

    do {
        Sleep( 0 );
    }

    while ( ( windowHandle = ::FindWindow( TARGET_WINDOW, NULL ) ) == nullptr );

    if ( !Game::Instance()->Initialize() ) {

        LOG( "DragResize: Failed to initialize game." );
    }

    if ( !WindowHook::Instance()->Initialize() ) {

        LOG( "DragResize: Failed to initialize window hook." );
    }

    s->shouldExit = 1;
} );

void uninitialize() {

    WindowHook::Instance()->Unintialize();
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     ) {
    switch ( ul_reason_for_call ) {
    case DLL_PROCESS_ATTACH:
        initThread.Run();
        break;
    case DLL_PROCESS_DETACH:
        uninitialize();
        break;
    }
    return TRUE;
}


```

`GTAV_DragResize/Types.h`:

```h
#pragma once

struct CRenderSettingsInfo {
    int width;
    int height;
    char pad[0x8];
};

```

`GTAV_DragResize/Utility/General.cpp`:

```cpp
#include "stdafx.h"
#include <sstream>
#include <iomanip>
#include <ctime>

HMODULE Utility::GetActiveModule() {
    HMODULE hModule = nullptr;

    GetModuleHandleEx( GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
                       reinterpret_cast<LPCSTR>( &GetActiveModule ),
                       &hModule );

    return hModule;
}

std::string Utility::GetModuleName( HMODULE hModule ) {
    TCHAR inBuf[MAX_PATH];

    if ( !hModule )
        hModule = GetActiveModule();

    GetModuleFileName( hModule, inBuf, MAX_PATH );

    auto str = std::string( inBuf );

    auto seperator = str.find_last_of( "\\" );

    if ( seperator != std::string::npos )
        seperator += 1;

    return str.substr( seperator, str.find_last_of( "." ) - seperator );
}

std::string Utility::GetWorkingDirectory() {
    const auto hModule = GetActiveModule();

    TCHAR inBuf[MAX_PATH];

    GetModuleFileName( hModule, inBuf, MAX_PATH );

    auto str = std::string( inBuf );

    auto seperator = str.find_last_of( "\\" );

    if ( seperator != std::string::npos )
        seperator += 1;

    return str.substr( 0, seperator );
}

std::string Utility::GetShortTimeString() {

    time_t t = time( nullptr );

    struct tm timeinfo;

    localtime_s( &timeinfo, &t );

    return va( "%02d:%02d:%02d", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec );
}


std::string Utility::HexString( BYTE * data, int len ) {
    std::stringstream ss;

    for ( int i = 0; i < len; ++i ) {
        ss << "\\x" <<
           std::uppercase <<
           std::setfill( '0' ) <<
           std::setw( 2 ) <<
           std::hex << static_cast<int>( data[i] );
    }
    return ss.str();
}

bool Utility::FileExists( const std::string & fileName ) {
    std::ifstream infile( fileName );
    return infile.good();
}

int Utility::ctol( const char c ) {
    if ( c >= '0' && c <= '9' )
        return c - '0';
    if ( c >= 'A' && c <= 'F' )
        return c - 'A' + 10;
    if ( c >= 'a' && c <= 'f' )
        return c - 'a' + 10;
    throw std::invalid_argument( "Invalid input string" );
}

```

`GTAV_DragResize/Utility/General.h`:

```h
#pragma once

namespace Utility {

HMODULE GetActiveModule();

std::string GetModuleName( HMODULE hModule );

std::string GetWorkingDirectory();

std::string GetShortTimeString();

std::string HexString( BYTE * data, int len );

bool FileExists( const std::string& fileName );

/**
* \brief char to long integer
*/
int ctol( char c );

template<typename ... Args>
std::string va( const std::string& format, Args ... args ) {
    const size_t size = ::snprintf( nullptr, 0, format.c_str(), args ... ) + 1;
    std::unique_ptr<char[]> buf( new char[size] );
    snprintf( buf.get(), size, format.c_str(), args... );
    return std::string( buf.get(), buf.get() + size - 1 );
}
}

```

`GTAV_DragResize/Utility/Logger.cpp`:

```cpp
#include "stdafx.h"

namespace Utility {
char inBuf[90112];

Logger::Logger() : path( GetModuleName( nullptr ) + ".log" )
{ }

void Logger::Write( const char * format, ... ) const {

    va_list va;
    va_start( va, format );
    vsprintf_s( inBuf, format, va );
    va_end( va );

    std::ofstream ofs( path, std::ios::app );

    auto str = Utility::va( "[%s] [LOG] %s\n", GetShortTimeString().c_str(), inBuf );
    ofs << str;
    ofs.close();

#ifdef _DEBUG
    OutputDebugStringA( str.c_str() );
#endif
}

void Logger::Remove() const {

    if ( !FileExists( path ) ) return;

    remove( path.c_str() );
}

Logger::~Logger() {

    Remove();
}
}


```

`GTAV_DragResize/Utility/Logger.h`:

```h
#pragma once

#define LOG(x,...) g_logfile.Write(x, __VA_ARGS__);

namespace Utility {
class Logger sealed {
  public:
    explicit Logger( std::string filename ) : path( filename ) {}
    Logger();
    void Write( const char * format, ... ) const;
    void Remove() const;
    ~Logger();
  private:
    const std::string path;
};

}

static Utility::Logger g_logfile;
```

`GTAV_DragResize/Utility/MemAddr.cpp`:

```cpp
#include "stdafx.h"

namespace Utility {

uintptr_t MemAddr::operator+( const uintptr_t x ) {

    return addr + x;
}

MemAddr::operator void*() const {

    return reinterpret_cast<void*>( addr );
}

MemAddr::operator uintptr_t() const {

    return addr;
}
}

```

`GTAV_DragResize/Utility/MemAddr.h`:

```h
#pragma once

namespace Utility {
class MemAddr {

  public:
    MemAddr() : MemAddr( nullptr ) {}

    MemAddr( const uintptr_t address ) : addr( address ) {}

    MemAddr( LPVOID ptr ) : MemAddr( reinterpret_cast<uintptr_t>( ptr ) ) {}

    uintptr_t addr;

    operator uintptr_t&() {
        return addr;
    }

    uintptr_t operator+( uintptr_t x );

    operator void*() const;

    operator uintptr_t() const;

    MemAddr add( MemAddr m ) const {
        return *this + m;
    }
};
}

```

`GTAV_DragResize/Utility/Pattern.h`:

```h
#pragma once
#include <Psapi.h>
#include <future>
#include "MemAddr.h"

namespace Utility {
template <typename T>
class PatternMatch {
  public:
    MemAddr result;
    PatternMatch( T item ) : result( item ) {};

    T get( const int offset = 0 ) {

        return reinterpret_cast<T>( result.add( offset ).addr );
    }

    T getTargetRel5( const int offset = 0 ) {

        auto addr = reinterpret_cast<T>( result.add( offset ).addr );

        return *reinterpret_cast<int32_t*>( addr + 1 ) + addr + 5;
    }

    T getCall( const int offset = 0 ) {

        auto addr = reinterpret_cast<T>( result.add( offset ).addr );

        return *reinterpret_cast<int32_t*>( addr + 1 ) + addr + 5;
    }

    T getTargetRel6( const int offset = 0 ) {

        auto addr = reinterpret_cast<T>( result.add( offset ).addr );

        return *reinterpret_cast<int32_t*>( addr + 2 ) + addr + 6;
    }

    T getTargetRel7( const int offset = 0 ) {

        auto addr = reinterpret_cast<T>( result.add( offset ).addr );

        return *reinterpret_cast<int32_t*>( addr + 3 ) + addr + 7;
    }

    T getCmp( const int offset = 0 ) {

        auto addr = reinterpret_cast<T>( result.add( offset ).addr );

        return *reinterpret_cast<int32_t*>( addr + 2 ) + addr + 7;
    }

    T getCmp2( const int offset = 0 ) {

        auto addr = reinterpret_cast<T>( result.add( offset ).addr );

        return *reinterpret_cast<int32_t*>( addr + 3 ) + addr + 8;
    }

    T getTargetRel8( const int offset = 0 ) {

        auto addr = reinterpret_cast<T>( result.add( offset ).addr );

        return *reinterpret_cast<int32_t*>( addr + 4 ) + addr + 8;
    }

    T getTargetRel9( const int offset = 0 ) {

        auto addr = reinterpret_cast<T>( result.add( offset ).addr );

        return *reinterpret_cast<int32_t*>( addr + 5 ) + addr + 9;
    }

    T getTargetRel10( const int offset = 0 ) {

        auto addr = reinterpret_cast<T>( result.add( offset ).addr );

        return *reinterpret_cast<int32_t*>( addr + 2 ) + addr + 10;
    }


    explicit operator T&() {
        return result;
    }
    explicit operator T() const {
        return result;
    }
};

template <typename T>
class Pattern {
    char m_patternData[64];
    char m_dataStrMask[64];
    std::string m_moduleName;
    bool m_bFindAllMatches;
    std::vector<PatternMatch<T>> m_vecMatches;

    void search() {
        MODULEINFO module = {};

        GetModuleInformation( GetCurrentProcess(), GetModuleHandle( m_moduleName[0] == '\0' ? nullptr : _T( m_moduleName.c_str() ) ), &module, sizeof( MODULEINFO ) );

        auto address = reinterpret_cast<BYTE*>( module.lpBaseOfDll );

        const auto address_end = address + module.SizeOfImage;

        for ( ; address < address_end; address++ ) {
            if ( bCompare( address, reinterpret_cast<PBYTE>( m_patternData ), m_dataStrMask ) ) {
#if defined(_DEBUG) || defined(RLB_DEBUG)
                LOG( "PatternSearch: Found match (%s : %s) @ %p",
                     HexString( reinterpret_cast<PBYTE>( m_patternData ), static_cast<int>( strlen( m_dataStrMask ) ) ).c_str(), m_dataStrMask, address );
#endif
                m_vecMatches.push_back( PatternMatch<T>( reinterpret_cast<T>( address ) ) );

                if ( !m_bFindAllMatches )
                    return;
            }
        }
#if defined(_DEBUG) || defined(RLB_DEBUG)
        if ( m_vecMatches.empty() )
            LOG( "PatternSearch: failed to find address in module (%s : %s)",
                 HexString( reinterpret_cast<PBYTE>( m_patternData ), static_cast<int>( strlen( m_dataStrMask ) ) ).c_str(), m_dataStrMask );
#endif
    }

    static void convert( const char * idaPattern, char * outBytes, char * outMask ) {
        int i = 0;
        auto str = &idaPattern[0];
        while ( *str != 0 ) {
            if ( *str != ' ' ) {
                if ( *str == '?' ) {
                    outBytes[i] = '\x00';
                    outMask[i] = *str;
                    //while (*str == '?')
                    //	str++;
                } else {
                    outBytes[i] = ctol( *str ) * 16 + ctol( str[1] );
                    outMask[i] = 'x';
                    str++;
                }

                i++;
            }
            str++;
        }

        outMask[i] = '\0';
    }

    static bool bCompare( const BYTE* pData, const BYTE* bMask, const char* szMask ) {
        for ( ; *szMask; ++szMask, ++pData, ++bMask )
            if ( *szMask == 'x' && *pData != *bMask )
                return false;
        return ( *szMask ) == NULL;
    }

  public:
    Pattern( const BYTE* bMask, const char* szMask, const bool findAllMatches = false ) : m_bFindAllMatches( findAllMatches ) {
        m_moduleName = std::string();
        memcpy( m_patternData, bMask, sizeof( m_patternData ) );
        strncpy_s( m_dataStrMask, szMask, sizeof( m_dataStrMask ) );
        search();
    }

    Pattern( const std::string& patternString, const bool findAllMatches = false ) : m_bFindAllMatches( findAllMatches ) {
        m_moduleName = std::string();
        convert( patternString.c_str(), m_patternData, m_dataStrMask );
        search();
    }

    Pattern( const std::string& patternString, const std::string& moduleName, const bool findAllMatches = false ) : m_bFindAllMatches( findAllMatches ) {
        m_moduleName = moduleName;
        convert( patternString.c_str(), m_patternData, m_dataStrMask );
        search();
    }


    PatternMatch<T> first() {
        return m_vecMatches.size() > 0 ? m_vecMatches.at( 0 ) : 0;
    }

    PatternMatch<T> get( int index = 0 ) {
        return m_vecMatches.size() > index ? m_vecMatches.at( index ) : 0;
    }

    size_t size() {
        return m_vecMatches.size();
    }
};

class BytePattern : public Pattern<BYTE*> {
  public:
    BytePattern( const BYTE* bMask, const char* szMask, const bool findAllMatches = false ) :
        Pattern<BYTE*>( bMask, szMask, findAllMatches ) {}

    BytePattern( const std::string& patternString, const bool findAllMatches = false ) :
        Pattern<BYTE*>( patternString, findAllMatches ) {}

    BytePattern( const std::string& patternString, const char * moduleName, const bool findAllMatches = false ) :
        Pattern<BYTE*>( patternString, moduleName, findAllMatches ) {}
};
}

```

`GTAV_DragResize/Utility/Thread.cpp`:

```cpp
#include "stdafx.h"

namespace Utility {

Thread::Thread() : m_handle( nullptr )
{ }

Thread::Thread( const ThreadCallback callback ) : Thread( callback, nullptr )
{ }

Thread::Thread( const ThreadCallback callback, const LPVOID param ) :
    m_info( ThreadState( param ), callback ), m_handle( nullptr ) { }

DWORD Thread::ThreadStart( const LPVOID pParam ) {

    auto info = reinterpret_cast<ThreadInfo*>( pParam );

    info->m_state.running = 1;

    do {
        if ( info->m_callback ) {
            info->m_callback( &info->m_state );
        }
    } while ( !info->m_state.shouldExit );

    info->m_state.running = 0;

    return 0;
}

Thread::~Thread() {

    Exit();
}
}

```

`GTAV_DragResize/Utility/Thread.h`:

```h
#pragma once

namespace Utility {
union ThreadParameter {
    ThreadParameter( const int value ) : integer( value ) {}
    ThreadParameter( void * obj ) : object( obj ) {}
    int integer;
    void * object;
};

struct ThreadState {
    ThreadState() : ThreadState( NULL ) {}
    ThreadState( ThreadParameter param ) : running( false ), parameter( param ) {}
    BOOL running, shouldExit = false;
    ThreadParameter parameter;
};

typedef void( *ThreadCallback )( ThreadState * pState );

struct ThreadInfo {
    ThreadInfo( const ThreadState state, const ThreadCallback callback ) :
        m_state( state ), m_callback( callback ) {}
    ThreadInfo() : ThreadInfo( ThreadState(), nullptr ) {}
    ThreadState m_state;
    ThreadCallback m_callback;
};

class Thread {
    ThreadInfo m_info;
    HANDLE m_handle;
    static DWORD WINAPI ThreadStart( LPVOID pParam );

  public:
    Thread();

    Thread( ThreadCallback callback );

    Thread( ThreadCallback callback, LPVOID param );

    void Run() {
        Run( THREAD_PRIORITY_NORMAL );
    }

    void Run( const int nPriority ) {
        Run( nPriority, NULL );
    }

    void Run( const int nPriority, const ThreadParameter parameter ) {

        m_info.m_state.parameter = parameter;

        m_handle = CreateThread( nullptr, NULL, ThreadStart, &m_info, NULL, nullptr );

        SetThreadPriority( m_handle, nPriority );

        SetThreadPriorityBoost( m_handle, TRUE );
    }

    void Exit() {
        m_info.m_state.shouldExit = true;
    }

    void Kill() {
        if ( m_handle ) {
            TerminateThread( m_handle, 0 );

            m_handle = nullptr;
        }
    }

    bool IsRunning() const {
        return m_info.m_state.running != 0;
    }

    ~Thread();
};
}

```

`GTAV_DragResize/Utility/Trace.h`:

```h
#pragma once

static __forceinline void StackTrace( const char * prefix ) {

    PVOID pFrames[USHRT_MAX];

    const auto count = RtlCaptureStackBackTrace( 0, USHRT_MAX, pFrames, NULL );

    FILE * file;

    char buf[MAX_PATH];

    sprintf_s( buf, "stacktrace_%s_%llu.txt", prefix, GetTickCount64() );

    fopen_s( &file, buf, "w" );

    const auto pModuleBase = ( ULONG64 )GetModuleHandleA( nullptr );

    for ( int ndx = 0; ndx < count; ndx++ )
        fprintf( file, "Trace %3d %016llx\n", ndx, ( ULONG64 )pFrames[ndx] );

    fclose( file );
}

```

`GTAV_DragResize/WindowHook.cpp`:

```cpp
#include "stdafx.h"

static WNDPROC oWndProc;

static WindowHook g_WindowHook;

LRESULT CALLBACK MainWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) {
    // Forward hwnd on because we can get messages (e.g., WM_CREATE)
    // before CreateWindow returns, and thus before mhMainWnd is valid.
    return WindowHook::Instance()->WndProc( hwnd, msg, wParam, lParam );
}

bool WindowHook::Initialize() {

    m_windowHandle = ::FindWindow( TARGET_WINDOW, NULL );

    SetWindowLongPtr( m_windowHandle, GWL_STYLE, GetWindowLongPtr( m_windowHandle, GWL_STYLE ) | WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX );

    oWndProc = ( WNDPROC )SetWindowLongPtr( m_windowHandle, GWLP_WNDPROC, ( LONG_PTR )MainWndProc );

    return true;
}

void WindowHook::Unintialize() {

    SetWindowLongPtr( m_windowHandle, GWLP_WNDPROC, ( LONG_PTR )oWndProc );
}

void WindowHook::OnResize() {

#ifdef _DEBUG
    LOG( "DragResize: Changing window size..." );
#endif

    RECT rect;

    GetClientRect( m_windowHandle, &rect );

    int width = rect.right - rect.left;
    int height = rect.bottom - rect.top;

    if ( height > width ) // game freaks out if we don't handle this
	return;

    Game::Instance()->UpdateWindowRect( width, height );
}

LRESULT WindowHook::WndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) {

    switch ( uMsg ) {
    case WM_ACTIVATE:
        SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
        break;

    case WM_SIZING:
        return 0;

    case WM_SIZE:
		if (!m_bInSizeMove)
			OnResize();
        break;

    case WM_ENTERSIZEMOVE:
        m_bInSizeMove = true;
        break;

    case WM_EXITSIZEMOVE:
        m_bInSizeMove = false;
        OnResize();
        break;

    case WM_GETMINMAXINFO:
        reinterpret_cast<MINMAXINFO*>( lParam )->ptMinTrackSize.x = WINDOW_MIN_WIDTH;
        reinterpret_cast<MINMAXINFO*>( lParam )->ptMinTrackSize.y = WINDOW_MIN_HEIGHT;
        return 0;

    default:
        break;
    }

    return CallWindowProc( oWndProc, hwnd, uMsg, wParam, lParam );
}

HWND WindowHook::MainWnd() const {

    return m_windowHandle;
}

WindowHook * WindowHook::Instance() {

    return &g_WindowHook;
}

```

`GTAV_DragResize/WindowHook.h`:

```h
#pragma once
#define TARGET_WINDOW "grcWindow"
#define WINDOW_MIN_WIDTH 100
#define WINDOW_MIN_HEIGHT 100

class WindowHook {
    HWND m_windowHandle;
    bool m_bInSizeMove = false;
  public:
    bool Initialize();
    void Unintialize();
    void OnResize();

    virtual LRESULT WndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

    HWND      MainWnd() const;

    static WindowHook * Instance();
};


```

`GTAV_DragResize/stdafx.cpp`:

```cpp
#include "stdafx.h"

```

`GTAV_DragResize/stdafx.h`:

```h
#pragma once

#include <windows.h>
#include <tchar.h>
#include <cstdio>
#include <string>
#include <fstream>

#include "Utility/General.h"
#include "Utility/Logger.h"
#include "Utility/MemAddr.h"
#include "Utility/Pattern.h"
#include "Utility/Thread.h"
#include "Utility/Trace.h"

#include "Game.h"
#include "WindowHook.h"

```

`LICENSE`:

```
MIT License

Copyright (c) 2018 Cameron Berry

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```