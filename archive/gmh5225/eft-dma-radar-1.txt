Project Path: arc_gmh5225_eft-dma-radar-1_w6tomyuq

Source Tree:

```txt
arc_gmh5225_eft-dma-radar-1_w6tomyuq
├── FTD3XX.dll
├── LICENSE
├── Maps
│   ├── Customs.json
│   ├── Customs.png
│   ├── Factory.json
│   ├── Factory.png
│   ├── Interchange.json
│   ├── Interchange.png
│   ├── Labs.json
│   ├── Labs_0f.png
│   ├── Labs_1f.png
│   ├── Labs_2f.png
│   ├── Lighthouse.json
│   ├── Lighthouse.png
│   ├── Reserve.json
│   ├── Reserve.png
│   ├── Shoreline.json
│   ├── Shoreline.png
│   ├── Woods.json
│   └── Woods.png
├── README.md
├── Source
│   ├── Game.cs
│   ├── LootEngine.cs
│   ├── MainForm.Designer.cs
│   ├── MainForm.cs
│   ├── MainForm.resx
│   ├── Memory.cs
│   ├── Misc.cs
│   ├── Objects.cs
│   ├── Offsets.cs
│   ├── Player.cs
│   ├── Program.cs
│   ├── RegisteredPlayers.cs
│   ├── TarkovMarketManager.cs
│   └── vmmsharp
│       ├── vmmdll.h
│       └── vmmsharp.cs
├── eft-dma-radar.csproj
├── eft-dma-radar.sln
├── leechcore.dll
└── vmm.dll

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Frost

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Maps/Customs.json`:

```json
{
	"x": 2254,
	"y": 1916,
	"z": 0,
	"scale": 3.731,
	"maps": [
		{
			"Item1": -100,
			"Item2": "Maps\\Customs.png"
		}
	]
}
```

`Maps/Factory.json`:

```json
{
	"x": 2575,
	"y": 1901,
	"z": 0,
	"scale": 18.62,
	"maps": [
		{
			"Item1": -100,
			"Item2": "Maps\\Factory.png"
		}
	]
}
```

`Maps/Interchange.json`:

```json
{
	"x": 1444,
	"y": 586,
	"z": 0,
	"scale": 1.29,
	"maps": [
		{
			"Item1": -100,
			"Item2": "Maps\\Interchange.png"
		}
	]
}
```

`Maps/Labs.json`:

```json
{
	"x": 3107,
	"y": -1062,
	"z": 0,
	"scale": 8.22,
	"maps": [
		{
			"Item1": -100,
			"Item2": "Maps\\Labs_0f.png"
		},
				{
			"Item1": -1,
			"Item2": "Maps\\Labs_1f.png"
		}
		,
				{
			"Item1": 3,
			"Item2": "Maps\\Labs_2f.png"
		}
	]
}
```

`Maps/Lighthouse.json`:

```json
{
	"x": 2937,
	"y": 1250,
	"z": 0,
	"scale": 1.91,
	"maps": [
		{
			"Item1": -100,
			"Item2": "Maps\\Lighthouse.png"
		}
	]
}
```

`Maps/Reserve.json`:

```json
{"x":1761,"y":1272,"z":0,"scale":3.63,"maps":[{"Item1":-100,"Item2":"Maps\\Reserve.png"}]}
```

`Maps/Shoreline.json`:

```json
{
	"x": 3680,
	"y": 1992,
	"z": 0,
	"scale": 2.765,
	"maps": [
		{
			"Item1": -100,
			"Item2": "Maps\\Shoreline.png"
		}
	]
}
```

`Maps/Woods.json`:

```json
{
	"x": 3600,
	"y": 1720,
	"z": 0,
	"scale": 3.6,
	"maps": [
		{
			"Item1": -100,
			"Item2": "Maps\\Woods.png"
		}
	]
}
```

`README.md`:

```md
# EFT DMA Radar
2D-Map DMA Radar for EFT

[UC Forum Thread](https://www.unknowncheats.me/forum/escape-from-tarkov/482418-2d-map-dma-radar-wip.html)

### Instructions
1. You need a DMA Device (Screamer, Raptor DMA,etc.) installed on your game PC with (hopefully) good/safe firmware. Don't ask me how.
2. Build/compile the app for Release x64.
3. Import any maps you would like to use in the Maps Folder, and be sure to have a .JSON config file for each set of maps.
4. Run the program on your 2nd PC (NOT GAME PC!!!) that has the DMA USB Cable plugged into. Click the Map button to cycle through maps if you need.
5. Recommend the following Game PC Settings:
   - Disable your system page file
   - Turn off automatic ram cleaner (in EFT Settings)
   - Turn on MIP Streaming (in EFT settings)

### Map JSON Info
The x,y values in the Map JSON should be the bitmap pixel coordinates for the "origin" location in game (this is where the unity coordinates are 0,0). Tweak scale as needed to ensure proper spacing.
The maps list takes a Tuple<float,string> where the float is the minimum height to display the corresponding map file (string). This allows for layered maps on like Interchange/Labs.

### Demo
![Demo](https://user-images.githubusercontent.com/42287509/153343812-2e8123d8-2c51-41e3-8db6-98d994a5772e.png)

```

`Source/Game.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Diagnostics;

namespace eft_dma_radar
{

    /// <summary>
    /// Class containing Game (Raid) instance.
    /// </summary>
    public class Game
    {
        private readonly ulong _unityBase;
        private GameObjectManager _gom;
        private ulong _localGameWorld;
        private LootEngine _lootEngine;
        private RegisteredPlayers _rgtPlayers;
        private bool _inGame = false;
        public bool InGame
        {
            get
            {
                return Volatile.Read(ref _inGame);
            }
        }
        public ConcurrentDictionary<string, Player> Players
        {
            get
            {
                return _rgtPlayers?.Players;
            }
        }
        public List<LootItem> Loot
        {
            get
            {
                return _lootEngine?.Loot;
            }
        }

        public Game(ulong unityBase)
        {
            _unityBase = unityBase;
        }

        /// <summary>
        /// Waits until Raid has started before returning to caller.
        /// </summary>
        public void WaitForGame()
        {
            while (true)
            {
                if (GetGOM() && GetLGW())
                {
                    Thread.Sleep(1000);
                    break;
                }
                Thread.Sleep(3500);
            }
            Debug.WriteLine("Raid has started!");
            _inGame = true;
        }

        /// <summary>
        /// Helper method to locate Game World object.
        /// </summary>
        private ulong GetObjectFromList(ulong listPtr, ulong lastObjectPtr, string objectName)
        {
            var activeObject = Memory.ReadStruct<BaseObject>(Memory.ReadPtr(listPtr));
            var lastObject = Memory.ReadStruct<BaseObject>(Memory.ReadPtr(lastObjectPtr));

            if (activeObject.obj != 0x0)
            {
                while (activeObject.obj != 0x0 && activeObject.obj != lastObject.obj)
                {
                    var objectNamePtr = Memory.ReadPtr(activeObject.obj + Offsets.UnityObject_Name);
                    var objectNameStr = Memory.ReadString(objectNamePtr, 24);
                    if (objectNameStr.Contains(objectName, StringComparison.OrdinalIgnoreCase))
                    {
                        Debug.WriteLine($"Found object {objectNameStr}");
                        return activeObject.obj;
                    }

                    activeObject = Memory.ReadStruct<BaseObject>(activeObject.nextObjectLink); // Read next object
                }
            }
            Debug.WriteLine($"Couldn't find object {objectName}");
            return 0;
        }

        /// <summary>
        /// Gets Game Object Manager structure.
        /// </summary>
        private bool GetGOM()
        {
            try
            {
                var addr = Memory.ReadPtr(_unityBase + Offsets.ModuleBase_GameObjectManager);
                _gom = Memory.ReadStruct<GameObjectManager>(addr);
                Debug.WriteLine($"Found Game Object Manager at 0x{addr.ToString("X")}");
                return true;
            }
            catch (DMAShutdown) { throw; }
            catch (Exception ex)
            {
                throw new GameNotRunningException($"ERROR getting Game Object Manager, game may not be running: {ex}");
            }
        }

        /// <summary>
        /// Gets Local Game World address.
        /// </summary>
        private bool GetLGW()
        {
            try
            {
                ulong activeNodes = Memory.ReadPtr(_gom.ActiveNodes);
                ulong lastActiveNode = Memory.ReadPtr(_gom.LastActiveNode);
                var gameWorld = GetObjectFromList(activeNodes, lastActiveNode, "GameWorld");
                if (gameWorld == 0) throw new Exception("Unable to find GameWorld Object, likely not in raid.");
                _localGameWorld = Memory.ReadPtrChain(gameWorld, Offsets.GameWorld_LocalGameWorld); // Game world >> Local Game World
                var rgtPlayers = new RegisteredPlayers(Memory.ReadPtr(_localGameWorld + Offsets.RegisteredPlayers));
                if (rgtPlayers.PlayerCount > 1) // Make sure not in hideout,etc.
                {
                    _rgtPlayers = rgtPlayers;
                    return true;
                }
                else
                {
                    Debug.WriteLine("ERROR - Local Game World does not contain players (hideout?)");
                    return false;
                }
            }
            catch (DMAShutdown) { throw; }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR getting Local Game World: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Main Game Loop executed by Memory Worker Thread. Updates player list, and updates all player values.
        /// </summary>
        public void GameLoop()
        {
            try
            {
                int playerCount = _rgtPlayers.PlayerCount;
                if (playerCount < 1 || playerCount > 1024)
                {
                    Debug.WriteLine("Raid has ended!");
                    _inGame = false;
                    return;
                }
                _rgtPlayers.UpdateList(); // Check for new players, add to list
                _rgtPlayers.UpdateAllPlayers(); // Update all player locations,etc.
                if (_lootEngine is null)
                {
                    _lootEngine = new LootEngine(_localGameWorld);
                }
            }
            catch
            {
                _inGame = false;
                throw;
            }
        }
    }

    public class GameNotRunningException : Exception
    {
        public GameNotRunningException()
        {
        }

        public GameNotRunningException(string message)
            : base(message)
        {
        }

        public GameNotRunningException(string message, Exception inner)
            : base(message, inner)
        {
        }
    }
}

```

`Source/LootEngine.cs`:

```cs
using SkiaSharp;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace eft_dma_radar
{
    public class LootEngine
    {
        private List<LootItem> _loot = new();
        private readonly ulong _localGameWorld;

        public List<LootItem> Loot
        {
            get { return _loot; }
        }

        public LootEngine(ulong localGameWorld)
        {
            _localGameWorld = localGameWorld;
            UpdateLoot();
        }

        private void UpdateLoot()
        {
            var lootlistPtr = Memory.ReadPtr(_localGameWorld + Offsets.LOOT_LIST);
            var lootListEntity = Memory.ReadPtr(lootlistPtr + Offsets.LOOT_LIST_ENTITY);
            var countLootListObjects = Memory.ReadInt(lootListEntity + 0x18);

            Debug.WriteLine("Parsing loot...");
            for (int i = 0; i < countLootListObjects; i++)
            {
                try
                {
                    //Get Loot Item
                    var lootObjectsEntity = Memory.ReadPtr(lootListEntity + Offsets.LOOT_OBJECTS_ENTITY_BASE + (ulong)(0x8 * i));
                    var unkownPtr = Memory.ReadPtr(lootObjectsEntity + 0x10);
                    var interactiveClass = Memory.ReadPtr(unkownPtr + 0x28);
                    var baseObject = Memory.ReadPtr(interactiveClass + 0x10);
                    var gameObject = Memory.ReadPtr(baseObject + 0x30);
                    var pGameObjectName = Memory.ReadPtr(gameObject + 0x60);
                    var name = Memory.ReadString(pGameObjectName, 64).ToLower(); //this represents the BSG name, it's not clean text though

                    if (name.Contains("script") || name.Contains("lootcorpse_playersuperior"))
                    {
                        //skip these. These are scripts which I think are things like landmines but not sure
                    }
                    else
                    {
                        //Get Position
                        var objectClass = Memory.ReadPtr(gameObject + 0x30);
                        var pointerToTransform_1 = Memory.ReadPtr(objectClass + 0x8);
                        var pointerToTransform_2 = Memory.ReadPtr(pointerToTransform_1 + 0x28);
                        var pos = GetPosition(pointerToTransform_2);

                        //the WORST method to figure out if an item is a container...but no better solution now
                        bool container = false;
                        //try
                        //{
                        //    var xx = Memory.ReadPtr(interactiveClass + 0x50);
                        //    var yy = Memory.ReadPtr(xx + 0x40);
                        //    bool zz = Memory.ReadBool(yy + 0x94);
                        //    if (xx == 0)
                        //    {
                        //        container = true;
                        //    }
                        //}
                        //catch { container = true; }

                        if (Offsets.CONTAINERS.Any(x => name.Contains(x.ToLower())))
                        {
                            container = true;
                        }

                        //If the item is a Static Container like weapon boxes, barrels, caches, safes, airdrops etc
                        if (Offsets.CONTAINERS.Any(x => name.Contains(x)) || container)
                        {
                            //Grid Logic for static containers so that we can see what's inside
                            try
                            {
                                var itemOwner = Memory.ReadPtr(interactiveClass + 0x108);
                                var item = Memory.ReadPtr(itemOwner + 0xa0);
                                var grids = Memory.ReadPtr(item + 0x68);
                                GetItemsInGrid(grids, "ignore", pos);
                            }
                            catch
                            {
                            }
                        }
                        //If the item is NOT a Static Container
                        else
                        {
                            var item = Memory.ReadPtr(interactiveClass + 0x50); //EFT.InventoryLogic.Item
                            var itemTemplate = Memory.ReadPtr(item + 0x40); //EFT.InventoryLogic.ItemTemplate
                            bool questItem = Memory.ReadBool(itemTemplate + 0x94);

                            //If NOT a quest item. Quest items are like the quest related things you need to find like the pocket watch or Jaeger's Letter etc. We want to ignore these quest items.
                            if (!questItem)
                            {
                                var BSGIdPtr = Memory.ReadPtr(itemTemplate + 0x50);
                                var id = Memory.ReadUnityString(BSGIdPtr);

                                //If the item is a corpose
                                if (id.Equals("55d7217a4bdc2d86028b456d")) // Corpse
                                {
                                    _loot.Add(new LootItem
                                    {
                                        Position = pos,
                                        Name = "Corpse"
                                    });
                                }
                                //Finally we must have found a loose loot item, eg a keycard, backpack, gun, salewa. Anything not in a container or corpse.
                                else
                                {

                                    //Grid Logic for loose loot because some loose loot have items inside, eg a backpack or docs case. We want to check those items too. But not all loose loot have items inside, so we have a try-catch below
                                    try
                                    {
                                        var grids = Memory.ReadPtr(item + 0x68);
                                        GetItemsInGrid(grids, id, pos);
                                    }
                                    catch
                                    {
                                        //The loot item we found does not have any grids so it's basically like a keycard or a ledx etc. Therefore add it to our loot dictionary.
                                        if (TarkovMarketManager.ItemFilter.TryGetValue(id, out var filter))
                                        {
                                            int itemValue = 0;
                                            if (filter.avg24hPrice > filter.traderPrice)
                                                itemValue = filter.avg24hPrice;
                                            else
                                                itemValue = filter.traderPrice;
                                            _loot.Add(new LootItem
                                            {
                                                Name = filter.shortName,
                                                Position = pos,
                                                BSGId = id,
                                                Value = itemValue
                                            });
                                        }
                                    }

                                    //Slot Logic - some loose loot have slots, eg a DVL will have a barrel slot, a mag slot etc
                                    try
                                    {
                                        //I haven't finished coding this yet
                                        //var slots = Memory.ReadPtr(item + 0x70);
                                        //GetItemsInSlot(slots, id, pos);
                                    }
                                    catch
                                    {
                                    }
                                }
                            }
                        }
                    }
                }
                catch { }
            }
            Debug.WriteLine("Loot parsing completed");
        }

        ///This method recursively searches grids. Grids work as follows:
        ///Take a Groundcache which holds a Blackrock which holds a pistol.
        ///The Groundcache will have 1 grid array, this method searches for whats inside that grid.
        ///Then it finds a Blackrock. This method then invokes itself recursively for the Blackrock.
        ///The Blackrock has 11 grid arrays (not to be confused with slots!! - a grid array contains slots. Look at the blackrock and you'll see it has 20 slots but 11 grids).
        ///In one of those grid arrays is a pistol. This method would recursively search through each item it finds
        ///To Do: add slot logic, so we can recursively search through the pistols slots...maybe it has a high value scope or something.
        private void GetItemsInGrid(ulong gridsArrayPtr, string id, Vector3 pos)
        {
            var gridsArray = new MemArray(gridsArrayPtr);

            if (TarkovMarketManager.ItemFilter.TryGetValue(id, out var filter))
            {
                int itemValue = 0;
                if (filter.avg24hPrice > filter.traderPrice)
                    itemValue = filter.avg24hPrice;
                else
                    itemValue = filter.traderPrice;
                _loot.Add(new LootItem
                {
                    Name = filter.shortName,
                    Position = pos,
                    BSGId = id,
                    Value = itemValue
                });
            }

            // Check all sections of the container
            foreach (var grid in gridsArray.Data)
            {

                var gridEnumerableClass = Memory.ReadPtr(grid + 0x40); // -.GClass178A->gClass1797_0x40 // Offset: 0x0040 (Type: -.GClass1797)

                var itemListPtr = Memory.ReadPtr(gridEnumerableClass + 0x18); // -.GClass1797->list_0x18 // Offset: 0x0018 (Type: System.Collections.Generic.List<Item>)
                var itemList = new MemList(itemListPtr);

                foreach (var childItem in itemList.Data)
                {
                    try
                    {
                        var childItemTemplate = Memory.ReadPtr(childItem + 0x40); // EFT.InventoryLogic.Item->_template // Offset: 0x0038 (Type: EFT.InventoryLogic.ItemTemplate)
                        var childItemIdPtr = Memory.ReadPtr(childItemTemplate + 0x50);
                        var childItemIdStr = Memory.ReadUnityString(childItemIdPtr).Replace("\\0", "");

                        // Check to see if the child item has children
                        var childGridsArrayPtr = Memory.ReadPtr(childItem + 0x68);   // -.GClassXXXX->Grids // Offset: 0x0068 (Type: -.GClass1497[])
                        GetItemsInGrid(childGridsArrayPtr, childItemIdStr, pos);        // Recursively add children to the entity
                    }
                    catch (Exception ee) { }
                }

            }
        }
        private unsafe Vector3 GetPosition(ulong transform)
        {
            IntPtr pMatricesBufPtr = new(); // 0
            IntPtr pIndicesBufPtr = new(); // 0
            try
            {
                ulong transform_internal = Memory.ReadPtr(transform + 0x10);
                ulong pMatrix = Memory.ReadPtr(transform_internal + 0x38);
                ulong matrix_list_base = Memory.ReadPtr(pMatrix + 0x18);
                ulong dependency_index_table_base = Memory.ReadPtr(pMatrix + 0x20);
                int index = Memory.ReadInt(transform_internal + 0x40);

                pMatricesBufPtr = Marshal.AllocHGlobal(sizeof(Matrix34) * index + sizeof(Matrix34));
                Memory.ReadBuffer(matrix_list_base, pMatricesBufPtr, sizeof(Matrix34) * index + sizeof(Matrix34));
                pIndicesBufPtr = Marshal.AllocHGlobal(sizeof(int) * index + sizeof(int));
                Memory.ReadBuffer(dependency_index_table_base, pIndicesBufPtr, sizeof(int) * index + sizeof(int));
                void* pMatricesBuf = pMatricesBufPtr.ToPointer();
                void* pIndicesBuf = pIndicesBufPtr.ToPointer();

                Vector4 result = *(Vector4*)((UInt64)pMatricesBuf + 0x30 * (UInt64)index);
                int index_relation = *(int*)((UInt64)pIndicesBuf + 0x4 * (UInt64)index);

                Vector4 xmmword_1410D1340 = new Vector4(-2.0f, 2.0f, -2.0f, 0.0f);
                Vector4 xmmword_1410D1350 = new Vector4(2.0f, -2.0f, -2.0f, 0.0f);
                Vector4 xmmword_1410D1360 = new Vector4(-2.0f, -2.0f, 2.0f, 0.0f);

                int iterations = 0;
                while (index_relation >= 0)
                {
                    if (iterations > 50) throw new Exception("Max SIMD iterations");
                    Matrix34 matrix34 = *(Matrix34*)((UInt64)pMatricesBuf + 0x30 * (UInt64)index_relation);

                    Vector4 v10 = matrix34.vec2 * result;
                    Vector4 v11 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(0)));
                    Vector4 v12 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(85)));
                    Vector4 v13 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(-114)));
                    Vector4 v14 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(-37)));
                    Vector4 v15 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(-86)));
                    Vector4 v16 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(113)));
                    result = (((((((v11 * xmmword_1410D1350) * v13) - ((v12 * xmmword_1410D1360) * v14)) * Shuffle(v10, (ShuffleSel)(-86))) +
                        ((((v15 * xmmword_1410D1360) * v14) - ((v11 * xmmword_1410D1340) * v16)) * Shuffle(v10, (ShuffleSel)(85)))) +
                        (((((v12 * xmmword_1410D1340) * v16) - ((v15 * xmmword_1410D1350) * v13)) * Shuffle(v10, (ShuffleSel)(0))) + v10)) + matrix34.vec0);
                    index_relation = *(int*)((UInt64)pIndicesBuf + 0x4 * (UInt64)index_relation);
                    iterations++;
                }

                return new Vector3(result.X, result.Z, result.Y);
            }
            finally // Free mem
            {
                if (pMatricesBufPtr.ToInt64() != 0) Marshal.FreeHGlobal(pMatricesBufPtr);
                if (pIndicesBufPtr.ToInt64() != 0) Marshal.FreeHGlobal(pIndicesBufPtr);
            }
        }

        private static unsafe Vector4 Shuffle(Vector4 v1, ShuffleSel sel)
        {
            var ptr = (float*)&v1;
            var idx = (int)sel;
            return new Vector4(*(ptr + ((idx >> 0) & 0x3)), *(ptr + ((idx >> 2) & 0x3)), *(ptr + ((idx >> 4) & 0x3)),
                *(ptr + ((idx >> 6) & 0x3)));
        }
    }

    //Helper class or struct
    public class MemArray
    {
        public ulong Address { get; }
        public int Count { get; }
        public ulong[] Data { get; }

        public MemArray(ulong address)
        {
            var type = typeof(ulong);

            Address = address;
            Count = Memory.ReadInt(address + 0x18);
            var arrayBase = address + 0x20;
            var tSize = (uint)Marshal.SizeOf(type);

            // Rudimentary sanity check
            if (Count > 4096 || Count < 0)
                Count = 0;

            var retArray = new ulong[Count];

            for (uint i = 0; i < Count; i++)
            {
                retArray[i] = Memory.ReadPtr(arrayBase + i * tSize);
            }

            Data = retArray;
        }
    }


    //Helper class or struct
    public class MemList
    {
        public ulong Address { get; }

        public int Count { get; }

        public List<ulong> Data { get; }

        public MemList(ulong address)
        {
            var type = typeof(ulong);

            Address = address;
            Count = Memory.ReadInt(address + 0x18);

            if (Count > 4096 || Count < 0)
                Count = 0;

            var arrayBase = Memory.ReadPtr(address + 0x10) + 0x20;
            var tSize = (uint)Marshal.SizeOf(type);
            var retList = new List<ulong>(Count);

            for (uint i = 0; i < Count; i++)
            {
                retList.Add(Memory.ReadPtr(arrayBase + i * tSize));
            }

            Data = retList;
        }
    }
    public class LootItem
    {
        public string Name { get; set; }
        public int Value { get; set; } = 0;
        public string BSGId { get; set; }
        public Vector3 Position { get; set; }
        public bool InContainer { get; set; }

    }
}
```

`Source/MainForm.Designer.cs`:

```cs
using SkiaSharp.Views.Desktop;

namespace eft_dma_radar
{
    partial class MainForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.tabPage1 = new System.Windows.Forms.TabPage();
            this.groupBox_MapSetup = new System.Windows.Forms.GroupBox();
            this.button_MapSetupApply = new System.Windows.Forms.Button();
            this.textBox_mapScale = new System.Windows.Forms.TextBox();
            this.label5 = new System.Windows.Forms.Label();
            this.textBox_mapY = new System.Windows.Forms.TextBox();
            this.label4 = new System.Windows.Forms.Label();
            this.textBox_mapX = new System.Windows.Forms.TextBox();
            this.label_Pos = new System.Windows.Forms.Label();
            this.tabPage2 = new System.Windows.Forms.TabPage();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.checkBox_Aimview = new System.Windows.Forms.CheckBox();
            this.button_Restart = new System.Windows.Forms.Button();
            this.checkBox_MapSetup = new System.Windows.Forms.CheckBox();
            this.checkBox_Loot = new System.Windows.Forms.CheckBox();
            this.label1 = new System.Windows.Forms.Label();
            this.trackBar_Zoom = new System.Windows.Forms.TrackBar();
            this.label2 = new System.Windows.Forms.Label();
            this.trackBar_AimLength = new System.Windows.Forms.TrackBar();
            this.label_Map = new System.Windows.Forms.Label();
            this.button_Map = new System.Windows.Forms.Button();
            this.bindingSource1 = new System.Windows.Forms.BindingSource(this.components);
            this.tabControl1.SuspendLayout();
            this.tabPage1.SuspendLayout();
            this.groupBox_MapSetup.SuspendLayout();
            this.tabPage2.SuspendLayout();
            this.groupBox1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.trackBar_Zoom)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.trackBar_AimLength)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.bindingSource1)).BeginInit();
            this.SuspendLayout();
            // 
            // tabControl1
            // 
            this.tabControl1.Controls.Add(this.tabPage1);
            this.tabControl1.Controls.Add(this.tabPage2);
            this.tabControl1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tabControl1.Location = new System.Drawing.Point(0, 0);
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.Size = new System.Drawing.Size(1336, 1061);
            this.tabControl1.TabIndex = 8;
            // 
            // tabPage1
            // 
            this.tabPage1.Controls.Add(this.groupBox_MapSetup);
            this.tabPage1.Location = new System.Drawing.Point(4, 24);
            this.tabPage1.Name = "tabPage1";
            this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage1.Size = new System.Drawing.Size(1328, 1033);
            this.tabPage1.TabIndex = 0;
            this.tabPage1.Text = "Radar";
            this.tabPage1.UseVisualStyleBackColor = true;
            // 
            // groupBox_MapSetup
            // 
            this.groupBox_MapSetup.Controls.Add(this.button_MapSetupApply);
            this.groupBox_MapSetup.Controls.Add(this.textBox_mapScale);
            this.groupBox_MapSetup.Controls.Add(this.label5);
            this.groupBox_MapSetup.Controls.Add(this.textBox_mapY);
            this.groupBox_MapSetup.Controls.Add(this.label4);
            this.groupBox_MapSetup.Controls.Add(this.textBox_mapX);
            this.groupBox_MapSetup.Controls.Add(this.label_Pos);
            this.groupBox_MapSetup.Location = new System.Drawing.Point(8, 6);
            this.groupBox_MapSetup.Name = "groupBox_MapSetup";
            this.groupBox_MapSetup.Size = new System.Drawing.Size(327, 175);
            this.groupBox_MapSetup.TabIndex = 11;
            this.groupBox_MapSetup.TabStop = false;
            this.groupBox_MapSetup.Text = "Map Setup";
            this.groupBox_MapSetup.Visible = false;
            // 
            // button_MapSetupApply
            // 
            this.button_MapSetupApply.Location = new System.Drawing.Point(6, 143);
            this.button_MapSetupApply.Name = "button_MapSetupApply";
            this.button_MapSetupApply.Size = new System.Drawing.Size(75, 23);
            this.button_MapSetupApply.TabIndex = 16;
            this.button_MapSetupApply.Text = "Apply";
            this.button_MapSetupApply.UseVisualStyleBackColor = true;
            this.button_MapSetupApply.Click += new System.EventHandler(this.button_MapSetupApply_Click);
            // 
            // textBox_mapScale
            // 
            this.textBox_mapScale.Location = new System.Drawing.Point(46, 101);
            this.textBox_mapScale.Name = "textBox_mapScale";
            this.textBox_mapScale.Size = new System.Drawing.Size(50, 23);
            this.textBox_mapScale.TabIndex = 15;
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(6, 104);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(34, 15);
            this.label5.TabIndex = 14;
            this.label5.Text = "Scale";
            // 
            // textBox_mapY
            // 
            this.textBox_mapY.Location = new System.Drawing.Point(102, 67);
            this.textBox_mapY.Name = "textBox_mapY";
            this.textBox_mapY.Size = new System.Drawing.Size(50, 23);
            this.textBox_mapY.TabIndex = 13;
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(6, 70);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(24, 15);
            this.label4.TabIndex = 12;
            this.label4.Text = "X,Y";
            // 
            // textBox_mapX
            // 
            this.textBox_mapX.Location = new System.Drawing.Point(46, 67);
            this.textBox_mapX.Name = "textBox_mapX";
            this.textBox_mapX.Size = new System.Drawing.Size(50, 23);
            this.textBox_mapX.TabIndex = 11;
            // 
            // label_Pos
            // 
            this.label_Pos.AutoSize = true;
            this.label_Pos.Location = new System.Drawing.Point(7, 19);
            this.label_Pos.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label_Pos.Name = "label_Pos";
            this.label_Pos.Size = new System.Drawing.Size(43, 15);
            this.label_Pos.TabIndex = 10;
            this.label_Pos.Text = "coords";
            // 
            // tabPage2
            // 
            this.tabPage2.Controls.Add(this.groupBox1);
            this.tabPage2.Location = new System.Drawing.Point(4, 24);
            this.tabPage2.Name = "tabPage2";
            this.tabPage2.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage2.Size = new System.Drawing.Size(1328, 1033);
            this.tabPage2.TabIndex = 1;
            this.tabPage2.Text = "Settings";
            this.tabPage2.UseVisualStyleBackColor = true;
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.checkBox_Aimview);
            this.groupBox1.Controls.Add(this.button_Restart);
            this.groupBox1.Controls.Add(this.checkBox_MapSetup);
            this.groupBox1.Controls.Add(this.checkBox_Loot);
            this.groupBox1.Controls.Add(this.label1);
            this.groupBox1.Controls.Add(this.trackBar_Zoom);
            this.groupBox1.Controls.Add(this.label2);
            this.groupBox1.Controls.Add(this.trackBar_AimLength);
            this.groupBox1.Controls.Add(this.label_Map);
            this.groupBox1.Controls.Add(this.button_Map);
            this.groupBox1.Dock = System.Windows.Forms.DockStyle.Left;
            this.groupBox1.Location = new System.Drawing.Point(3, 3);
            this.groupBox1.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Padding = new System.Windows.Forms.Padding(4, 3, 4, 3);
            this.groupBox1.Size = new System.Drawing.Size(525, 1027);
            this.groupBox1.TabIndex = 8;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Radar Config";
            // 
            // checkBox_Aimview
            // 
            this.checkBox_Aimview.AutoSize = true;
            this.checkBox_Aimview.Location = new System.Drawing.Point(187, 107);
            this.checkBox_Aimview.Name = "checkBox_Aimview";
            this.checkBox_Aimview.Size = new System.Drawing.Size(127, 19);
            this.checkBox_Aimview.TabIndex = 19;
            this.checkBox_Aimview.Text = "Show Aimview (F4)";
            this.checkBox_Aimview.UseVisualStyleBackColor = true;
            this.checkBox_Aimview.CheckedChanged += new System.EventHandler(this.checkBox_Aimview_CheckedChanged);
            // 
            // button_Restart
            // 
            this.button_Restart.Location = new System.Drawing.Point(158, 33);
            this.button_Restart.Name = "button_Restart";
            this.button_Restart.Size = new System.Drawing.Size(94, 27);
            this.button_Restart.TabIndex = 18;
            this.button_Restart.Text = "Restart Game";
            this.button_Restart.UseVisualStyleBackColor = true;
            this.button_Restart.Click += new System.EventHandler(this.button_Restart_Click);
            // 
            // checkBox_MapSetup
            // 
            this.checkBox_MapSetup.AutoSize = true;
            this.checkBox_MapSetup.Location = new System.Drawing.Point(38, 132);
            this.checkBox_MapSetup.Name = "checkBox_MapSetup";
            this.checkBox_MapSetup.Size = new System.Drawing.Size(153, 19);
            this.checkBox_MapSetup.TabIndex = 9;
            this.checkBox_MapSetup.Text = "Show Map Setup Helper";
            this.checkBox_MapSetup.UseVisualStyleBackColor = true;
            this.checkBox_MapSetup.CheckedChanged += new System.EventHandler(this.checkBox_MapSetup_CheckedChanged);
            // 
            // checkBox_Loot
            // 
            this.checkBox_Loot.AutoSize = true;
            this.checkBox_Loot.Location = new System.Drawing.Point(38, 107);
            this.checkBox_Loot.Name = "checkBox_Loot";
            this.checkBox_Loot.Size = new System.Drawing.Size(105, 19);
            this.checkBox_Loot.TabIndex = 17;
            this.checkBox_Loot.Text = "Show Loot (F3)";
            this.checkBox_Loot.UseVisualStyleBackColor = true;
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(201, 166);
            this.label1.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(111, 15);
            this.label1.TabIndex = 16;
            this.label1.Text = "Zoom (F1 in F2 out)";
            // 
            // trackBar_Zoom
            // 
            this.trackBar_Zoom.LargeChange = 1;
            this.trackBar_Zoom.Location = new System.Drawing.Point(237, 185);
            this.trackBar_Zoom.Maximum = 100;
            this.trackBar_Zoom.Minimum = 1;
            this.trackBar_Zoom.Name = "trackBar_Zoom";
            this.trackBar_Zoom.Orientation = System.Windows.Forms.Orientation.Vertical;
            this.trackBar_Zoom.Size = new System.Drawing.Size(45, 403);
            this.trackBar_Zoom.TabIndex = 15;
            this.trackBar_Zoom.Value = 100;
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(104, 166);
            this.label2.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(83, 15);
            this.label2.TabIndex = 13;
            this.label2.Text = "Player Aimline";
            // 
            // trackBar_AimLength
            // 
            this.trackBar_AimLength.LargeChange = 50;
            this.trackBar_AimLength.Location = new System.Drawing.Point(119, 185);
            this.trackBar_AimLength.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            this.trackBar_AimLength.Maximum = 1000;
            this.trackBar_AimLength.Minimum = 10;
            this.trackBar_AimLength.Name = "trackBar_AimLength";
            this.trackBar_AimLength.Orientation = System.Windows.Forms.Orientation.Vertical;
            this.trackBar_AimLength.Size = new System.Drawing.Size(45, 403);
            this.trackBar_AimLength.SmallChange = 5;
            this.trackBar_AimLength.TabIndex = 11;
            this.trackBar_AimLength.Value = 500;
            // 
            // label_Map
            // 
            this.label_Map.AutoSize = true;
            this.label_Map.Location = new System.Drawing.Point(54, 63);
            this.label_Map.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.label_Map.Name = "label_Map";
            this.label_Map.Size = new System.Drawing.Size(79, 15);
            this.label_Map.TabIndex = 8;
            this.label_Map.Text = "DEFAULTMAP";
            // 
            // button_Map
            // 
            this.button_Map.Location = new System.Drawing.Point(44, 33);
            this.button_Map.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            this.button_Map.Name = "button_Map";
            this.button_Map.Size = new System.Drawing.Size(107, 27);
            this.button_Map.TabIndex = 7;
            this.button_Map.Text = "Toggle Map (F5)";
            this.button_Map.UseVisualStyleBackColor = true;
            this.button_Map.Click += new System.EventHandler(this.button_Map_Click);
            // 
            // MainForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 15F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(1336, 1061);
            this.Controls.Add(this.tabControl1);
            this.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            this.Name = "MainForm";
            this.Text = "EFT Radar";
            this.tabControl1.ResumeLayout(false);
            this.tabPage1.ResumeLayout(false);
            this.groupBox_MapSetup.ResumeLayout(false);
            this.groupBox_MapSetup.PerformLayout();
            this.tabPage2.ResumeLayout(false);
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.trackBar_Zoom)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.trackBar_AimLength)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.bindingSource1)).EndInit();
            this.ResumeLayout(false);

        }

        #endregion

        private TabControl tabControl1;
        private TabPage tabPage1;
        private TabPage tabPage2;
        private GroupBox groupBox1;
        private Label label2;
        private TrackBar trackBar_AimLength;
        private Label label_Map;
        private Button button_Map;
        private Label label_Pos;
        private Label label1;
        private TrackBar trackBar_Zoom;
        private CheckBox checkBox_Loot;
        private CheckBox checkBox_MapSetup;
        private Button button_Restart;
        private GroupBox groupBox_MapSetup;
        private Button button_MapSetupApply;
        private TextBox textBox_mapScale;
        private Label label5;
        private TextBox textBox_mapY;
        private Label label4;
        private TextBox textBox_mapX;
        private BindingSource bindingSource1;
        private CheckBox checkBox_Aimview;
    }
}


```

`Source/MainForm.cs`:

```cs
using SkiaSharp;
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Numerics;
using SkiaSharp.Views.Desktop;

namespace eft_dma_radar
{
    public partial class MainForm : Form
    {
        private readonly SKGLControl mapCanvas;
        private readonly SKGLControl aimView;
        private readonly Stopwatch _fpsWatch = new Stopwatch();
        private int _fps = 0;

        private readonly object _renderLock = new object();
        private readonly System.Timers.Timer _mapChangeTimer = new System.Timers.Timer(900);
        private readonly List<Map> _allMaps; // Contains all maps from \\Maps folder
        private readonly Config _config;
        private int _mapIndex = 0;
        private Map _currentMap; // Current Selected Map
        private int _mapLayerIndex = 0;
        private SKBitmap[] _loadedMap;
        private float _xScale = 0;
        private float _yScale = 0;
        private const float _fov = 30;
        private const int _maxDist = 300;
        private bool InGame
        {
            get
            {
                return Memory.InGame;
            }
        }
        private Player CurrentPlayer
        {
            get
            {
                return Memory.Players.FirstOrDefault(x => x.Value.Type is PlayerType.CurrentPlayer).Value;
            }
        }
        private ConcurrentDictionary<string, Player> AllPlayers
        {
            get
            {
                return Memory.Players;
            }
        }
        private List<LootItem> Loot
        {
            get
            {
                return Memory.Loot;
            }
        }

        private readonly SKPaint _mapPaint = new SKPaint()
        {
            IsAntialias = true,
            FilterQuality = SKFilterQuality.High
        };
        private readonly SKPaint _paintGreen = new SKPaint()
        {
            Color = SKColors.Green,
            StrokeWidth = 3,
            Style = SKPaintStyle.Stroke,
        };
        private readonly SKPaint _paintLtGreen = new SKPaint()
        {
            Color = SKColors.LimeGreen,
            StrokeWidth = 3,
            Style = SKPaintStyle.Stroke,
        };
        private readonly SKPaint _textLtGreen = new SKPaint()
        {
            Color = SKColors.LimeGreen,
            IsStroke = false,
            TextSize = 12,
            TextEncoding = SKTextEncoding.Utf8,
            IsAntialias = true,
            Typeface = SKTypeface.FromFamilyName("Arial", SKFontStyle.Bold)
        };
        private readonly SKPaint _paintRed = new SKPaint()
        {
            Color = SKColors.Red,
            StrokeWidth = 3,
            Style = SKPaintStyle.Stroke,
        };
        private readonly SKPaint _textRed = new SKPaint()
        {
            Color = SKColors.Red,
            IsStroke = false,
            TextSize = 12,
            TextEncoding = SKTextEncoding.Utf8,
            IsAntialias = true,
            Typeface = SKTypeface.FromFamilyName("Arial", SKFontStyle.Bold)
        };
        private readonly SKPaint _paintYellow = new SKPaint()
        {
            Color = SKColors.Yellow,
            StrokeWidth = 3,
            Style = SKPaintStyle.Stroke,
        };
        private readonly SKPaint _textYellow = new SKPaint()
        {
            Color = SKColors.Yellow,
            IsStroke = false,
            TextSize = 12,
            TextEncoding = SKTextEncoding.Utf8,
            IsAntialias = true,
            Typeface = SKTypeface.FromFamilyName("Arial", SKFontStyle.Bold)
        };
        private readonly SKPaint _paintViolet = new SKPaint()
        {
            Color = SKColors.Fuchsia,
            StrokeWidth = 3,
            Style = SKPaintStyle.Stroke
        };
        private readonly SKPaint _textViolet = new SKPaint()
        {
            Color = SKColors.Fuchsia,
            IsStroke = false,
            TextSize = 12,
            TextEncoding = SKTextEncoding.Utf8,
            IsAntialias = true,
            Typeface = SKTypeface.FromFamilyName("Arial", SKFontStyle.Bold)
        };
        private readonly SKPaint _paintWhite = new SKPaint()
        {
            Color = SKColors.White,
            StrokeWidth = 3,
            Style = SKPaintStyle.Stroke,
        };
        private readonly SKPaint _textWhite = new SKPaint()
        {
            Color = SKColors.White,
            IsStroke = false,
            TextSize = 12,
            TextEncoding = SKTextEncoding.Utf8,
            IsAntialias = true,
            Typeface = SKTypeface.FromFamilyName("Arial", SKFontStyle.Bold)
        };
        private readonly SKPaint _paintBlack = new SKPaint()
        {
            Color = SKColors.Black,
            StrokeWidth = 3,
            Style = SKPaintStyle.Stroke,
        };
        private readonly SKPaint _paintLoot = new SKPaint()
        {
            Color = SKColors.WhiteSmoke,
            StrokeWidth = 3,
            Style = SKPaintStyle.Fill
        };
        private readonly SKPaint _paintImportantLoot = new SKPaint()
        {
            Color = SKColors.Turquoise,
            StrokeWidth = 3,
            Style = SKPaintStyle.Fill
        };
        private readonly SKPaint _lootText = new SKPaint()
        {
            Color = SKColors.WhiteSmoke,
            IsStroke = false,
            TextSize = 13,
            TextEncoding = SKTextEncoding.Utf8,
            IsAntialias = true,
            Typeface = SKTypeface.FromFamilyName("Arial")
        };
        private readonly SKPaint _importantLootText = new SKPaint()
        {
            Color = SKColors.Turquoise,
            IsStroke = false,
            TextSize = 13,
            TextEncoding = SKTextEncoding.Utf8,
            IsAntialias = true,
            Typeface = SKTypeface.FromFamilyName("Arial")
        };
        private readonly SKPaint _paintWhiteAimView = new SKPaint()
        {
            Color = SKColors.White,
            StrokeWidth = 1,
            Style = SKPaintStyle.Stroke,
        };
        private readonly SKPaint _paintRedAimView = new SKPaint()
        {
            Color = SKColors.Red,
            StrokeWidth = 1,
            Style = SKPaintStyle.Fill,
        };


        /// <summary>
        /// Constructor.
        /// </summary>
        public MainForm()
        {
            InitializeComponent();
            // init skia
            mapCanvas = new SKGLControl();
            mapCanvas.Size = new System.Drawing.Size(50, 50);
            mapCanvas.Dock = DockStyle.Fill;
            tabPage1.Controls.Add(mapCanvas);

            aimView = new SKGLControl();
            aimView.Size = new System.Drawing.Size(200, 200);
            aimView.Location = new System.Drawing.Point(0, tabPage1.Height - 200);
            mapCanvas.Controls.Add(aimView);
            aimView.Visible = false;

            if (Config.TryLoadConfig(out _config) is not true) _config = new Config();
            LoadConfig();
            _allMaps = new List<Map>();
            LoadMaps();
            _mapChangeTimer.AutoReset = false;
            _mapChangeTimer.Elapsed += _mapChangeTimer_Elapsed;

            this.DoubleBuffered = true; // Prevent flickering
            this.mapCanvas.PaintSurface += mapCanvas_OnPaint;
            this.aimView.PaintSurface += AimView_PaintSurface;
            this.Shown += MainForm_Shown;
            this.Resize += MainForm_Resize;
            _fpsWatch.Start(); // fps counter
        }

        private void MainForm_Resize(object sender, EventArgs e)
        {
            aimView.Size = new System.Drawing.Size(200, 200);
            aimView.Location = new System.Drawing.Point(0, tabPage1.Height - 200);
        }

        private async void MainForm_Shown(object sender, EventArgs e)
        {
            while (mapCanvas.GRContext is null) await Task.Delay(1);
            mapCanvas.GRContext.SetResourceCacheLimit(503316480); // Fixes low FPS on big maps
            while (true)
            {
                await Task.Delay(1);
                mapCanvas.Invalidate();
                if (aimView.Visible) aimView.Refresh();
            }
        }

        /// <summary>
        /// Load previously set GUI Configuraiton values.
        /// </summary>
        private void LoadConfig()
        {
            trackBar_AimLength.Value = _config.PlayerAimLineLength;
            checkBox_Loot.Checked = _config.LootEnabled;
            trackBar_Zoom.Value = _config.DefaultZoom;
        }

        /// <summary>
        /// Load map files (.PNG) and Configs (.JSON) from \\Maps folder.
        /// </summary>
        private void LoadMaps()
        {
            var dir = new DirectoryInfo($"{Environment.CurrentDirectory}\\Maps");
            if (!dir.Exists) dir.Create();
            var configs = dir.GetFiles("*.json"); // Get all PNG Files
            if (configs.Length == 0) throw new IOException("Maps folder is empty!");
            foreach (var config in configs)
            {
                var name = Path.GetFileNameWithoutExtension(config.Name); // map name ex. 'CUSTOMS' w/o extension
                _allMaps.Add(new Map
                (
                    name.ToUpper(),
                    MapConfig.LoadFromFile(config.FullName),
                    config.FullName)
                );
            }
            try
            {
                _currentMap = _allMaps[0];
                _loadedMap = new SKBitmap[_currentMap.ConfigFile.Maps.Count];
                for (int i = 0; i < _loadedMap.Length; i++)
                {
                    using (var stream = File.Open(_currentMap.ConfigFile.Maps[i].Item2, FileMode.Open, FileAccess.Read))
                    {
                        _loadedMap[i] = SKBitmap.Decode(stream);
                    }
                }
                label_Map.Text = _currentMap.Name;
            }
            catch (Exception ex)
            {
                throw new Exception($"ERROR loading {_currentMap.ConfigFile.Maps[0].Item2}: {ex}");
            }
        }

        /// <summary>
        /// Draw/Render on Map Canvas
        /// </summary>
        private void mapCanvas_OnPaint(object sender, SKPaintGLSurfaceEventArgs e)
        {
            lock (_renderLock)
            {
                if (_fpsWatch.ElapsedMilliseconds >= 1000)
                {
                    mapCanvas.GRContext.PurgeResources(); // Seems to fix mem leak issue on increasing resource cache
                    this.Text = $"EFT Radar ({_fps} fps) ({Memory.Ticks} mem/s)";
                    _fpsWatch.Restart();
                    _fps = 0;
                }
                else _fps++;
                SKSurface surface = e.Surface;
                SKCanvas canvas = surface.Canvas;
                canvas.Clear();
                Player currentPlayer;
                if (this.InGame && (currentPlayer = this.CurrentPlayer) is not null)
                {
                    try
                    {
                        // Get main player location
                        var currentPlayerRawPos = currentPlayer.Position;
                        var currentPlayerDirection = Deg2Rad(currentPlayer.Direction);
                        var currentPlayerPos = VectorToMapPos(currentPlayerRawPos);
                        if (groupBox_MapSetup.Visible) // Print coordinates (to make it easy to setup JSON configs)
                        {
                            label_Pos.Text = $"Unity X,Y,Z: {currentPlayer.Position.X},{currentPlayer.Position.Y},{currentPlayer.Position.Z}\n" +
                                $"Bitmap X,Y: {currentPlayerPos.X},{currentPlayerPos.Y}";
                        }
                        for (int i = _loadedMap.Length; i > 0; i--)
                        {
                            if (currentPlayerPos.Height > _currentMap.ConfigFile.Maps[i-1].Item1)
                            {
                                _mapLayerIndex = i - 1;
                                break;
                            }
                        }

                        // Prepare to draw bitmap
                        var bounds = GetMapBounds(currentPlayerPos);
                        var dest = new SKRect()
                        {
                            Left = mapCanvas.Left,
                            Right = mapCanvas.Right,
                            Top = mapCanvas.Top,
                            Bottom = mapCanvas.Bottom
                        };
                        canvas.DrawBitmap(_loadedMap[_mapLayerIndex], bounds, dest, _mapPaint);

                        // Draw Main Player  
                        {
                            var zoomedCurrentPlayerPos = GetZoomedPosOffset(currentPlayerPos, bounds); // always true
                            canvas.DrawCircle(zoomedCurrentPlayerPos.GetPoint(), 6, _paintGreen);
                            var point1 = new SKPoint(zoomedCurrentPlayerPos.X, zoomedCurrentPlayerPos.Y);
                            var point2 = new SKPoint((float)(zoomedCurrentPlayerPos.X + Math.Cos(currentPlayerDirection) * trackBar_AimLength.Value), (float)(zoomedCurrentPlayerPos.Y + Math.Sin(currentPlayerDirection) * trackBar_AimLength.Value));
                            canvas.DrawLine(point1, point2, _paintGreen);
                        }

                        // Draw other players
                        var allPlayers = this.AllPlayers;
                        if (allPlayers is not null)
                        {
                            var friendlies = allPlayers.Where(x => x.Value.Type is PlayerType.CurrentPlayer
                            || x.Value.Type is PlayerType.Teammate);
                            foreach (KeyValuePair<string, Player> player in allPlayers) // Draw PMCs
                            {
                                if (player.Value.Type is PlayerType.CurrentPlayer) continue; // Already drawn current player, move on
                                if (!player.Value.IsActive && player.Value.IsAlive) continue; // Skip exfil'd players
                                var playerPos = VectorToMapPos(player.Value.Position);
                                var zoomedPlayerPos =  GetZoomedPosOffset(playerPos, bounds);
                                var playerDirection = Deg2Rad(player.Value.Direction);
                                var aimLength = 15;
                                if (player.Value.IsAlive is false)
                                { // Draw 'X' death marker
                                    canvas.DrawLine(new SKPoint(zoomedPlayerPos.X - 6, zoomedPlayerPos.Y + 6), new SKPoint(zoomedPlayerPos.X + 6, zoomedPlayerPos.Y - 6), _paintBlack);
                                    canvas.DrawLine(new SKPoint(zoomedPlayerPos.X - 6, zoomedPlayerPos.Y - 6), new SKPoint(zoomedPlayerPos.X + 6, zoomedPlayerPos.Y + 6), _paintBlack);
                                    continue;
                                }
                                else if (player.Value.Type is not PlayerType.Teammate)
                                {
                                    foreach (var friendly in friendlies)
                                    {
                                        var friendlyDist = Vector3.Distance(player.Value.Position, friendly.Value.Position);
                                        if (friendlyDist > 300) continue; // max range, no lines across entire map
                                        var friendlyPos = VectorToMapPos(friendly.Value.Position);
                                        if (IsFacingPlayer(playerPos.GetPoint(),
                                            player.Value.Direction - 90, // remove deg offset
                                            friendlyPos.GetPoint()))
                                        {
                                            aimLength = 1000; // Lengthen aimline
                                            break;
                                        }
                                    }
                                }
                                else if (player.Value.Type is PlayerType.Teammate)
                                    aimLength = trackBar_AimLength.Value; // Allies use player's aim length
                                { // Draw
                                    var plyrHeight = playerPos.Height - currentPlayerPos.Height;
                                    var plyrDist = Math.Sqrt((Math.Pow(currentPlayerRawPos.X - player.Value.Position.X, 2) + Math.Pow(currentPlayerRawPos.Y - player.Value.Position.Y, 2)));
                                    canvas.DrawText($"L{player.Value.Lvl}:{player.Value.Name} ({player.Value.Health})", zoomedPlayerPos.GetNamePoint(9, 3), GetText(player.Value.Type));
                                    canvas.DrawText($"H: {(int)Math.Round(plyrHeight)} D: {(int)Math.Round(plyrDist)}", zoomedPlayerPos.GetNamePoint(9, 15), GetText(player.Value.Type));
                                    canvas.DrawCircle(zoomedPlayerPos.GetPoint(), 6, GetPaint(player.Value.Type)); // smaller circle
                                    var point1 = new SKPoint(zoomedPlayerPos.X, zoomedPlayerPos.Y);
                                    var point2 = new SKPoint((float)(zoomedPlayerPos.X + Math.Cos(playerDirection) * aimLength), (float)(zoomedPlayerPos.Y + Math.Sin(playerDirection) * aimLength));
                                    canvas.DrawLine(point1, point2, GetPaint(player.Value.Type));
                                }
                            }
                            // Draw loot (if enabled)
                            if (checkBox_Loot.Checked)
                            {
                                var loot = this.Loot;
                                if (loot is not null) foreach (var item in loot)
                                    {
                                        SKPaint paint;
                                        SKPaint text;
                                        if (item.Value >= 300000)
                                        {
                                            paint = _paintImportantLoot;
                                            text = _importantLootText;
                                        }
                                        else
                                        {
                                            paint = _paintLoot;
                                            text = _lootText;
                                        }
                                        var mapPos = VectorToMapPos(item.Position);
                                        var mapPosZoom = GetZoomedPosOffset(mapPos, bounds);
                                        var heightDiff = item.Position.Z - currentPlayerPos.Height;
                                        if (heightDiff > 2)
                                        {
                                            using var path = mapPosZoom.GetUpArrow();
                                            canvas.DrawPath(path, paint);
                                        }
                                        else if (heightDiff < -2)
                                        {
                                            using var path = mapPosZoom.GetDownArrow();
                                            canvas.DrawPath(path, paint);
                                        }
                                        else
                                        {
                                            canvas.DrawCircle(mapPosZoom.GetPoint(), 5, paint);
                                        }
                                        canvas.DrawText($"{item.Name} ({item.Value / 1000}K)", mapPosZoom.GetNamePoint(7, 3), text);
                                    }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine($"ERROR rendering next frame: {ex}");
                    }
                }
                canvas.Flush(); // commit to GPU
            }
        }

        /// <summary>
        /// Provides zoomed map bounds (centers on player).
        /// </summary>
        private SKRect GetMapBounds(MapPosition pos)
        {
            var zoom = new ZoomLevel()
            {
                Width = _loadedMap[_mapLayerIndex].Width * (.01f * trackBar_Zoom.Value),
                Height = _loadedMap[_mapLayerIndex].Height * (.01f * trackBar_Zoom.Value)
            };

            var bounds = new SKRect(pos.X - zoom.Width / 2,
                pos.Y - zoom.Height / 2,
                pos.X + zoom.Width / 2,
                pos.Y + zoom.Height / 2)
                .AspectFill(new SKSize(mapCanvas.Width, mapCanvas.Height));

            _xScale = (float)mapCanvas.Width / (float)bounds.Width; // Set scale for this frame
            _yScale = (float)mapCanvas.Height / (float)bounds.Height; // Set scale for this frame
            return bounds;
        }

        /// <summary>
        /// Checks if provided location is within current zoomed map bounds, and provides offset coordinates.
        /// </summary>
        private MapPosition GetZoomedPosOffset(MapPosition location, SKRect bounds)
        {
            return new MapPosition()
            {
                X = (location.X - bounds.Left) * _xScale,
                Y = (location.Y - bounds.Top) * _yScale,
                Height = location.Height
            };
        }

        /// <summary>
        /// Determines if an aggressor player is facing a friendly player.
        /// </summary>
        private static bool IsFacingPlayer(SKPoint aggressor, double aggressorAngle, SKPoint target)
        {
            var radian = Math.Atan2((target.Y - aggressor.Y), (target.X - aggressor.X));
            var angle = Math.Abs((radian * (180 / Math.PI) + 360) % 360);
            var diff = Math.Max(angle, aggressorAngle) - Math.Min(angle, aggressorAngle);
            if (diff < 5) return true; // Modify constant for degrees variance (aiming near)
            else return false;
        }

        /// <summary>
        /// Gets drawing paintbrush based on PlayerType.
        /// </summary>
        private SKPaint GetPaint(PlayerType playerType)
        {
            if (playerType is PlayerType.Teammate) return _paintLtGreen;
            else if (playerType is PlayerType.PMC) return _paintRed;
            else if (playerType is PlayerType.PlayerScav) return _paintWhite;
            else if (playerType is PlayerType.AIBoss) return _paintViolet;
            else if (playerType is PlayerType.AIScav) return _paintYellow;
            else return _paintRed; // Default
        }
        /// <summary>
        /// Gets typing paintbrush based on PlayerType.
        /// </summary>
        private SKPaint GetText(PlayerType playerType)
        {
            if (playerType is PlayerType.Teammate) return _textLtGreen;
            else if (playerType is PlayerType.PMC) return _textRed;
            else if (playerType is PlayerType.PlayerScav) return _textWhite;
            else if (playerType is PlayerType.AIBoss) return _textViolet;
            else if (playerType is PlayerType.AIScav) return _textYellow;
            else return _textRed; // Default
        }

        /// <summary>
        /// Convert degrees to radians in order to calculate drawing angles.
        /// </summary>
        private static double Deg2Rad(float deg)
        {
            deg = deg - 90; // Degrees offset needed for game
            return (Math.PI / 180) * deg;
        }

        /// <summary>
        /// Convert game positional values to UI Map Coordinates.
        /// </summary>
        private MapPosition VectorToMapPos(Vector3 vector)
        {
            var zeroX = _currentMap.ConfigFile.X;
            var zeroY = _currentMap.ConfigFile.Y;
            var scale = _currentMap.ConfigFile.Scale;

            var x = zeroX + (vector.X * scale);
            var y = zeroY - (vector.Y * scale); // Invert 'Y' unity 0,0 bottom left, C# top left
            return new MapPosition()
            {
                X = x,
                Y = y,
                Height = vector.Z // Keep as float, calculation done later
            };
        }

        /// <summary>
        /// Toggles currently selected map.
        /// </summary>
        private void ToggleMap()
        {
            if (!button_Map.Enabled) return;
            if (_mapIndex == _allMaps.Count - 1) _mapIndex = 0; // Start over when end of maps reached
            else _mapIndex++; // Move onto next map
            label_Map.Text = _allMaps[_mapIndex].Name;
            _mapChangeTimer.Reset(); // Start delay
        }

        /// <summary>
        /// Executes map change after a short delay, in case switching through maps quickly to reduce UI lag.
        /// </summary>
        private void _mapChangeTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
        {
            this.BeginInvoke(new MethodInvoker(delegate
            {
                button_Map.Enabled = false;
                button_Map.Text = "Loading...";
            }));
            lock (_renderLock)
            {
                try
                {
                    _currentMap = _allMaps[_mapIndex]; // Swap map
                    if (_loadedMap is not null)
                    {
                        foreach (var map in _loadedMap) map?.Dispose();
                    }
                    _loadedMap = new SKBitmap[_currentMap.ConfigFile.Maps.Count];
                    for (int i = 0; i < _loadedMap.Length; i++)
                    {
                        using (var stream = File.Open(_currentMap.ConfigFile.Maps[i].Item2, FileMode.Open, FileAccess.Read))
                        {
                            _loadedMap[i] = SKBitmap.Decode(stream);
                        }
                    }
                    _mapLayerIndex = 0;
                }
                catch (Exception ex)
                {
                    throw new Exception($"ERROR loading {_currentMap.ConfigFile.Maps[0].Item2}: {ex}");
                }
                finally
                {
                    this.BeginInvoke(new MethodInvoker(delegate
                    {
                        button_Map.Enabled = true;
                        button_Map.Text = "Toggle Map (F5)";
                    }));
                }
            }
        }

        private void button_Map_Click(object sender, EventArgs e)
        {
            ToggleMap();
        }

        protected override void OnFormClosing(FormClosingEventArgs e) // Raised on Close()
        {
            try
            {
                _config.PlayerAimLineLength = trackBar_AimLength.Value;
                _config.LootEnabled = checkBox_Loot.Checked;
                _config.DefaultZoom = trackBar_Zoom.Value;
                Config.SaveConfig(_config);
                Memory.Shutdown();
            }
            finally { base.OnFormClosing(e); }
        }

        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            if (keyData == (Keys.F1))
            {
                if (trackBar_Zoom.Value - 5 >= 1) trackBar_Zoom.Value -= 5;
                else trackBar_Zoom.Value = 1;
                return true;
            }
            else if (keyData == (Keys.F2))
            {
                if (trackBar_Zoom.Value + 5 <= 100) trackBar_Zoom.Value += 5;
                else trackBar_Zoom.Value = 100;
                return true;
            }
            else if (keyData == (Keys.F3))
            {
                this.checkBox_Loot.Checked = !this.checkBox_Loot.Checked; // Toggle loot
                return true;
            }
            else if (keyData == (Keys.F4))
            {
                this.checkBox_Aimview.Checked = !this.checkBox_Aimview.Checked; // Toggle aimview
                return true;
            }
            else if (keyData == (Keys.F5))
            {
                ToggleMap();
                return true;
            }
            return base.ProcessCmdKey(ref msg, keyData);
        }

        private void checkBox_Aimview_CheckedChanged(object sender, EventArgs e)
        {
            aimView.Visible = checkBox_Aimview.Checked;
        }

        private void checkBox_MapSetup_CheckedChanged(object sender, EventArgs e)
        {
            if (checkBox_MapSetup.Checked)
            {
                groupBox_MapSetup.Visible = true;
                textBox_mapX.Text = _currentMap.ConfigFile.X.ToString();
                textBox_mapY.Text = _currentMap.ConfigFile.Y.ToString();
                textBox_mapScale.Text = _currentMap.ConfigFile.Scale.ToString();
            }
            else groupBox_MapSetup.Visible = false;
        }

        private void button_Restart_Click(object sender, EventArgs e)
        {
            Memory.Restart();
        }

        private void button_MapSetupApply_Click(object sender, EventArgs e)
        {
            if (float.TryParse(textBox_mapX.Text, out float x) &&
                float.TryParse(textBox_mapY.Text, out float y) &&
                float.TryParse(textBox_mapScale.Text, out float scale))
            {
                lock (_renderLock)
                {
                    _currentMap.ConfigFile.X = x;
                    _currentMap.ConfigFile.Y = y;
                    _currentMap.ConfigFile.Scale = scale;
                    _currentMap.ConfigFile.Save(_currentMap);
                }
            }
            else
            {
                throw new Exception("INVALID float values in Map Setup.");
            }
        }


        /// 3d Aimview stuff
        /// 
        private void AimView_PaintSurface(object sender, SKPaintGLSurfaceEventArgs e)
        {
            SKSurface surface = e.Surface;
            SKCanvas canvas = surface.Canvas;
            canvas.Clear(); // clear last frame
            try
            {
                Player me;
                ConcurrentDictionary<string, Player> players;
                if (this.InGame 
                    && (me = this.CurrentPlayer) is not null 
                    && (players = this.AllPlayers) is not null)
                {
                    var normalizedDirection = -me.Direction + 90;
                    if (normalizedDirection < 0) normalizedDirection = normalizedDirection + 360;
                    var playersInFOV = players.Where(x => x.Value.IsAlive && x.Value.IsAlive && x.Value.Type != PlayerType.CurrentPlayer); //GetPlayersInFOV(30, me, normalizedDirection);

                    var pitch = me.Pitch;
                    if (pitch >= 270)
                    {
                        pitch = 360 - pitch;
                    }
                    else
                    {
                        pitch = -pitch;
                    }

                    canvas.DrawLine(0, aimView.Height / 2, aimView.Width, aimView.Height / 2, _paintWhiteAimView);
                    canvas.DrawLine(aimView.Width / 2, 0, aimView.Width / 2, aimView.Height, _paintWhiteAimView);

                    foreach (var kvp in playersInFOV)
                    {
                        var player = kvp.Value;
                        float heighDiff = player.Position.Z - me.Position.Z;
                        float dist = (float)Math.Sqrt((Math.Pow(me.Position.X - player.Position.X, 2) + Math.Pow(me.Position.Y - player.Position.Y, 2)));
                        float angleY = (float)(180 / Math.PI * Math.Atan(heighDiff / dist)) - pitch;
                        float y = angleY / _fov * aimView.Height + aimView.Height / 2;

                        float opposite = (player.Position.Y - me.Position.Y);
                        float adjacent = player.Position.X - me.Position.X;
                        float angleX = (float)(180 / Math.PI * Math.Atan(opposite / adjacent));

                        if (adjacent < 0 && opposite > 0)
                        {
                            angleX = 180 + angleX;
                        }
                        else if (adjacent < 0 && opposite < 0)
                        {
                            angleX = 180 + angleX;
                        }
                        else if (adjacent > 0 && opposite < 0)
                        {
                            angleX = 360 + angleX;
                        }
                        angleX = angleX - normalizedDirection;
                        float x = angleX / _fov * aimView.Width + aimView.Width / 2;

                        canvas.DrawCircle(aimView.Width - x, aimView.Height - y, 10 * (1 - dist / _maxDist), _paintRedAimView);
                    }
                }
            } catch { }
            canvas.Flush(); // commit current frame to gpu
        }
    }
}

```

`Source/MainForm.resx`:

```resx
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="bindingSource1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`Source/Memory.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using vmmsharp;

namespace eft_dma_radar
{
    internal static class Memory
    {
        private static volatile bool _running = false;
        private static volatile bool _restart = false;
        private static readonly Thread _worker;
        private static uint _pid;
        private static ulong _unityBase;
        private static Game _game;
        private static int _ticks = 0;
        private static readonly Stopwatch _tickSw = new();
        public static int Ticks = 0;
        public static bool InGame
        {
            get
            {
                return _game?.InGame ?? false;
            }
        }
        public static ConcurrentDictionary<string, Player> Players
        {
            get
            {
                return _game?.Players;
            }
        }
        public static List<LootItem> Loot
        {
            get
            {
                return _game?.Loot;
            }
        }

        /// <summary>
        /// Constructor
        /// </summary>
        static Memory()
        {
            try
            {
                Debug.WriteLine("Loading memory module...");
                if (!File.Exists("mmap.txt"))
                {
                    Debug.WriteLine("No MemMap, attempting to generate...");
                    if (!vmm.Initialize("-printf", "-v", "-device", "FPGA"))
                        throw new DMAException("Unable to initialize DMA Device while attempting to generate MemMap!");
                    GetMemMap();
                    vmm.Close(); // Close back down, re-init w/ map
                }
                if (!vmm.Initialize("-printf", "-v", "-device", "FPGA", "-memmap", "mmap.txt")) // Initialize DMA device
                    throw new DMAException("ERROR initializing DMA Device! If you do not have a memory map (mmap.txt) edit the constructor in Memory.cs");
                Debug.WriteLine("Starting Memory worker thread...");
                _worker = new Thread(() => Worker()) { IsBackground = true };
                _worker.Start(); // Start new background thread to do memory operations on
                _running = true;
                Program.ShowWindow(Program.GetConsoleWindow(), 0); // Hide console if successful
                _tickSw.Start();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), "DMA Init", MessageBoxButtons.OK, MessageBoxIcon.Error);
                Environment.Exit(-1);
            }
        }

        /// <summary>
        /// Main worker thread to perform DMA Reads on.
        /// </summary>
        private static void Worker()
        {
            try
            {
                while (true)
                {
                    while (true) // Startup loop
                    {
                        if (GetPid()
                        && GetModuleBase()
                        )
                        {
                            Debug.WriteLine($"EFT startup successful!");
                            break;
                        }
                        else
                        {
                            Debug.WriteLine("EFT startup failed, trying again in 15 seconds...");
                            Thread.Sleep(15000);
                        }
                    }
                    while (true) // Game is running
                    {
                        _game = new Game(_unityBase);
                        try
                        {
                            _game.WaitForGame();
                            while (_game.InGame)
                            {
                                if (_tickSw.Elapsed.TotalMilliseconds > 1000)
                                {
                                    Interlocked.Exchange(ref Ticks, _ticks);
                                    _ticks = 0;
                                    _tickSw.Restart();
                                }
                                else _ticks++;
                                if (_restart)
                                {
                                    Debug.WriteLine("Restarting game... getting fresh gameworld");
                                    _restart = false;
                                    break;
                                }
                                _game.GameLoop();
                            }
                        }
                        catch (GameNotRunningException) { break; }
                        catch (DMAShutdown) { throw; }
                        catch (Exception ex)
                        {
                            Debug.WriteLine($"Unhandled exception in Game Loop: {ex}");
                        }
                        finally { Thread.Sleep(100); }
                    }
                    Debug.WriteLine("Game is no longer running! Attempting to restart...");
                }
            }
            catch (DMAShutdown) { Debug.WriteLine("Memory Thread closing down due to DMA Shutdown..."); } // Shutdown Thread Gracefully
            catch (Exception ex)
            {
                MessageBox.Show($"FATAL ERROR on Memory Thread: {ex}");
                Environment.Exit(-1); // Forcefully close process, app will need to be restarted
            }
        }

        /// <summary>
        /// Sets restart flag to re-initialize the game/pointers from the bottom up.
        /// </summary>
        public static void Restart()
        {
            if (_restart is false)
            {
                _restart = true;
            }
        }

        /// <summary>
        /// Generates a Physical Memory Map (mmap.txt) to enhance performance/safety.
        /// </summary>
        private static void GetMemMap()
        {
            try
            {
                var map = vmm.Map_GetPhysMem();
                if (map.Length == 0) throw new Exception("Map_GetPhysMem() returned no entries!");
                string mapOut = "";
                for (int i = 0; i < map.Length; i++)
                {
                    mapOut += $"{i.ToString("D4")}  {map[i].pa.ToString("x")}  -  {(map[i].pa + map[i].cb - 1).ToString("x")}  ->  {map[i].pa.ToString("x")}\n";
                }
                File.WriteAllText("mmap.txt", mapOut);
            }
            catch (Exception ex)
            {
                throw new DMAException("Unable to generate MemMap!", ex);
            }
        }

        /// <summary>
        /// Gets EFT Process ID.
        /// </summary>
        private static bool GetPid()
        {
            try
            {
                ThrowIfDMAShutdown();
                vmm.PidGetFromName("EscapeFromTarkov.exe", out _pid);
                if (_pid == 0) throw new DMAException("Unable to obtain PID. Game may not be running.");
                else
                {
                    Debug.WriteLine($"EscapeFromTarkov.exe is running at PID {_pid}");
                    return true;
                }
            }
            catch (DMAShutdown) { throw; }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR getting PID: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Gets module base entry address for UnityPlayer.dll
        /// </summary>
        private static bool GetModuleBase()
        {
            try
            {
                ThrowIfDMAShutdown();
                _unityBase = vmm.ProcessGetModuleBase(_pid, "UnityPlayer.dll");
                if (_unityBase == 0) throw new DMAException("Unable to obtain Base Module Address. Game may not be running");
                else
                {
                    Debug.WriteLine($"Found UnityPlayer.dll at 0x{_unityBase.ToString("x")}");
                    return true;
                }
            }
            catch (DMAShutdown) { throw; }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR getting module base: {ex}");
                return false;
            }
        }

        /// <summary>
        /// Performs multiple reads in one sequence, significantly faster than single reads.
        /// </summary>
        // Credit to asmfreak https://www.unknowncheats.me/forum/3345474-post27.html
        public static void ReadScatter(ScatterReadEntry[] entries, Dictionary<int, Dictionary<int, ScatterReadEntry>> results)
        {
            ThrowIfDMAShutdown();
            var toScatter = new List<ulong>();
            var toSkip = new HashSet<int>();
            for (int i = 0; i < entries.Length; i++)
            {
                if (entries[i].Addr is not null)
                {
                    var addrType = entries[i].Addr.GetType();
                    if (addrType == typeof(ScatterReadEntry))
                    {
                        var item = (ScatterReadEntry)entries[i].Addr;
                        if (item.Result is not null)
                        {
                            entries[i].Addr = (ulong)item.Result;
                        }
                        else entries[i].Addr = (ulong)0x0;
                    }
                }
                else entries[i].Addr = (ulong)0x0;
                if ((ulong)entries[i].Addr == 0x0)
                {
                    toSkip.Add(i);
                    entries[i].Result = null;
                    results[entries[i].Index].Add(entries[i].Id, entries[i]);
                    continue;
                }

                entries[i].Addr = (ulong)entries[i].Addr + entries[i].Offset;

                ulong dwAddress = (ulong)entries[i].Addr;

                if (entries[i].Size is not null)
                {
                    var sizeType = entries[i].Size.GetType();
                    if (sizeType == typeof(ScatterReadEntry))
                    {
                        var item = (ScatterReadEntry)entries[i].Size;
                        if (item.Result is not null)
                        {
                            entries[i].Size = (int)item.Result;
                        }
                        else entries[i].Size = (int)0;
                    }
                }
                else entries[i].Size = (int)0;
                uint size;
                if ((uint)(int)entries[i].Size > 0)
                    size = (uint)(int)entries[i].Size * (uint)entries[i].SizeMult;
                else size = (uint)Marshal.SizeOf(entries[i].Type);

                //get the number of pages
                uint dwNumPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(dwAddress, size);

                //loop all the pages we would need
                for (int p = 0; p < dwNumPages; p++)
                {
                    toScatter.Add(PAGE_ALIGN(dwAddress));
                }
            }
            var scatters = vmm.MemReadScatter(_pid, vmm.FLAG_NOCACHE, toScatter.ToArray());

            int index = 0;
            for (int i = 0; i < entries.Length; i++)
            {
                if (toSkip.Contains(i))
                {
                    continue;
                }
                bool isFailed = false;
                ulong dwAdd = (ulong)entries[i].Addr;

                uint dwPageOffset = BYTE_OFFSET(dwAdd);

                uint size;
                if ((uint)(int)entries[i].Size > 0)
                    size = (uint)(int)entries[i].Size * (uint)entries[i].SizeMult;
                else size = (uint)Marshal.SizeOf(entries[i].Type);
                byte[] buffer = new byte[size];
                int bytesRead = 0;
                uint cb = Math.Min(size, (uint)PAGE_SIZE - dwPageOffset);

                uint dwNumPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(dwAdd, size);

                for (int p = 0; p < dwNumPages; p++)
                {
                    if (scatters[index].f)
                    {
                        Buffer.BlockCopy(scatters[index].pb, (int)dwPageOffset, buffer, bytesRead, (int)cb);
                        bytesRead += (int)cb;
                    }
                    else
                        isFailed = true;

                    cb = (uint)PAGE_SIZE;
                    if (((dwPageOffset + size) & 0xfff) != 0)
                        cb = ((dwPageOffset + size) & 0xfff);

                    dwPageOffset = 0;
                    index++;
                }
                try
                {
                    if (isFailed) throw new DMAException("Scatter read failed!");
                    else if (bytesRead != size) throw new DMAException("Incomplete buffer read!");
                    else if (entries[i].Type == typeof(ulong))
                    {
                        entries[i].Result = BitConverter.ToUInt64(buffer);
                    }
                    else if (entries[i].Type == typeof(float))
                    {
                        entries[i].Result = BitConverter.ToSingle(buffer);
                    }
                    else if (entries[i].Type == typeof(int))
                    {
                        entries[i].Result = BitConverter.ToInt32(buffer);
                    }
                    else if (entries[i].Type == typeof(bool))
                    {
                        entries[i].Result = BitConverter.ToBoolean(buffer);
                    }
                    else if (entries[i].Type == typeof(IntPtr))
                    {
                        var memBuf = Marshal.AllocHGlobal((int)size); // alloc memory (must free later)
                        Marshal.Copy(buffer, 0, memBuf, (int)size); // Copy to mem buffer
                        entries[i].Result = memBuf; // Store ref to mem buffer
                    }
                    else if (entries[i].Type == typeof(string)) // Default String
                    {
                        entries[i].Result = Encoding.Default.GetString(buffer);
                    }
                    else if (entries[i].Type == typeof(UnityString)) // Unity String
                    {
                        entries[i].Result = Encoding.Unicode.GetString(buffer);
                    }
                }
                catch (Exception ex)
                {
                    entries[i].Result = null;
                    Debug.WriteLine($"Error parsing result from Scatter Read at index {i}: {ex}");
                }
                finally
                {
                    results[entries[i].Index].Add(entries[i].Id, entries[i]);
                }
            }
        }

        /// <summary>
        /// Copy 'n' bytes to unmanaged memory. Caller is responsible for freeing memory.
        /// </summary>
        public static void ReadBuffer(ulong addr, IntPtr bufPtr, int size)
        {
            ThrowIfDMAShutdown();
            var readBuf = vmm.MemRead(_pid, addr, (uint)size, vmm.FLAG_NOCACHE);
            if (readBuf.Length != size) throw new DMAException("Incomplete buffer read!");
            Marshal.Copy(readBuf
                , 0, bufPtr, size);
        }

        /// <summary>
        /// Read a chain of pointers.
        /// </summary>
        public static ulong ReadPtrChain(ulong ptr, uint[] offsets)
        {
            ulong addr = 0;
            try { addr = ReadPtr(ptr + offsets[0]); }
            catch (Exception ex) { throw new DMAException($"ERROR reading pointer chain at index 0, addr 0x{ptr.ToString("X")} + 0x{offsets[0].ToString("X")}", ex); }
            for (int i = 1; i < offsets.Length; i++)
            {
                try { addr = ReadPtr(addr + offsets[i]); }
                catch (Exception ex) { throw new DMAException($"ERROR reading pointer chain at index {i}, addr 0x{addr.ToString("X")} + 0x{offsets[i].ToString("X")}", ex); }
            }
            return addr;
        }
        /// <summary>
        /// Resolves a pointer and returns the memory address it points to.
        /// </summary>
        public static ulong ReadPtr(ulong ptr)
        {
            var addr = ReadUlong(ptr);
            if (addr == 0) throw new DMAException("NULL pointer returned!");
            else return addr;
        }


        public static ulong ReadUlong(ulong addr)
        {
            try
            {
                ThrowIfDMAShutdown();
                return BitConverter.ToUInt64(vmm.MemRead(_pid, addr, 8, vmm.FLAG_NOCACHE), 0);
            }
            catch (Exception ex)
            {
                throw new DMAException($"ERROR reading UInt64 at 0x{addr.ToString("X")}", ex);
            }
        }

        public static long ReadLong(ulong addr) // read 8 bytes (int64)
        {
            try
            {
                ThrowIfDMAShutdown();
                return BitConverter.ToInt64(vmm.MemRead(_pid, addr, 8, vmm.FLAG_NOCACHE), 0);
            }
            catch (Exception ex)
            {
                throw new DMAException($"ERROR reading Int64 at 0x{addr.ToString("X")}", ex);
            }
        }
        public static int ReadInt(ulong addr) // read 4 bytes (int32)
        {
            try
            {
                ThrowIfDMAShutdown();
                return BitConverter.ToInt32(vmm.MemRead(_pid, addr, 4, vmm.FLAG_NOCACHE), 0);
            }
            catch (Exception ex)
            {
                throw new DMAException($"ERROR reading Int32 at 0x{addr.ToString("X")}", ex);
            }
        }
        public static uint ReadUint(ulong addr) // read 4 bytes (uint32)
        {
            try
            {
                ThrowIfDMAShutdown();
                return BitConverter.ToUInt32(vmm.MemRead(_pid, addr, 4, vmm.FLAG_NOCACHE), 0);
            }
            catch (Exception ex)
            {
                throw new DMAException($"ERROR reading Uint32 at 0x{addr.ToString("X")}", ex);
            }
        }
        public static float ReadFloat(ulong addr) // read 4 bytes (float)
        {
            try
            {
                ThrowIfDMAShutdown();
                return BitConverter.ToSingle(vmm.MemRead(_pid, addr, 4, vmm.FLAG_NOCACHE), 0);
            }
            catch (Exception ex)
            {
                throw new DMAException($"ERROR reading float at 0x{addr.ToString("X")}", ex);
            }
        }
        public static double ReadDouble(ulong addr) // read 8 bytes (double)
        {
            try
            {
                ThrowIfDMAShutdown();
                return BitConverter.ToDouble(vmm.MemRead(_pid, addr, 8, vmm.FLAG_NOCACHE), 0);
            }
            catch (Exception ex)
            {
                throw new DMAException($"ERROR reading double at 0x{addr.ToString("X")}", ex);
            }
        }
        public static bool ReadBool(ulong addr) // read 1 byte (bool)
        {
            try
            {
                ThrowIfDMAShutdown();
                return BitConverter.ToBoolean(vmm.MemRead(_pid, addr, 1, vmm.FLAG_NOCACHE), 0);
            }
            catch (Exception ex)
            {
                throw new DMAException($"ERROR reading boolean at 0x{addr.ToString("X")}", ex);
            }
        }

        public static T ReadStruct<T>(ulong addr) // Read structure from memory location
        {
            int size = Marshal.SizeOf(typeof(T));
            var mem = Marshal.AllocHGlobal(size); // alloc mem
            try
            {
                ThrowIfDMAShutdown();
                var buffer = vmm.MemRead(_pid, addr, (uint)size, vmm.FLAG_NOCACHE);
                if (buffer.Length != size) throw new DMAException("Incomplete buffer read!");
                Marshal.Copy(buffer, 0, mem, size); // Read to pointer location
                return (T)Marshal.PtrToStructure(mem, typeof(T)); // Convert bytes to struct
            }
            catch (Exception ex)
            {
                throw new DMAException($"ERROR reading struct at 0x{addr.ToString("X")}", ex);
            }
            finally
            {
                Marshal.FreeHGlobal(mem); // free mem
            }
        }
        /// <summary>
        /// Read 'n' bytes at specified address and convert directly to a string.
        /// </summary>
        public static string ReadString(ulong addr, uint size) // read n bytes (string)
        {
            try
            {
                ThrowIfDMAShutdown();
                return Encoding.Default.GetString(
                    vmm.MemRead(_pid, addr, size, vmm.FLAG_NOCACHE));
            }
            catch (Exception ex)
            {
                throw new DMAException($"ERROR reading string at 0x{addr.ToString("X")}", ex);
            }
        }

        /// <summary>
        /// Read UnityEngineString structure
        /// </summary>
        public static string ReadUnityString(ulong addr)
        {
            try
            {
                ThrowIfDMAShutdown();
                var length = (uint)ReadInt(addr + Offsets.UnityString_Len);
                return Encoding.Unicode.GetString(
                    vmm.MemRead(_pid, addr + Offsets.UnityString_Value, length * 2, vmm.FLAG_NOCACHE));
            }
            catch (Exception ex)
            {
                throw new DMAException($"ERROR reading UnityString at 0x{addr.ToString("X")}", ex);
            }
        }

        /// <summary>
        /// Close down DMA Device Connection.
        /// </summary>
        public static void Shutdown()
        {
            if (_running)
            {
                Debug.WriteLine("Closing down DMA Connection...");
                _running = false;
                vmm.Close();
            }
        }

        private static void ThrowIfDMAShutdown()
        {
            if (!_running) throw new DMAShutdown("DMA Device is no longer initialized!");
        }


        /// Mem Align Functions Ported from Win32 (C++)
        private const ulong PAGE_SIZE = 0x1000;
        private const int PAGE_SHIFT = 12;

        /// <summary>
        /// The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
        /// virtual address for that page.
        /// </summary>
        private static ulong PAGE_ALIGN(ulong va)
        {
            return (va & ~(PAGE_SIZE - 1));
        }
        /// <summary>
        /// The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and size and returns the number of pages spanned by the size.
        /// </summary>
        private static uint ADDRESS_AND_SIZE_TO_SPAN_PAGES(ulong va, uint size)
        {
            return (uint)((BYTE_OFFSET(va) + (size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT);
        }

        /// <summary>
        /// The BYTE_OFFSET macro takes a virtual address and returns the byte offset
        /// of that address within the page.
        /// </summary>
        private static uint BYTE_OFFSET(ulong va)
        {
            return (uint)(va & (PAGE_SIZE - 1));
        }
    }

    public class DMAException : Exception
    {
        public DMAException()
        {
        }

        public DMAException(string message)
            : base(message)
        {
        }

        public DMAException(string message, Exception inner)
            : base(message, inner)
        {
        }
    }

    public class DMAShutdown : Exception
    {
        public DMAShutdown()
        {
        }

        public DMAShutdown(string message)
            : base(message)
        {
        }

        public DMAShutdown(string message, Exception inner)
            : base(message, inner)
        {
        }
    }

}

```

`Source/Misc.cs`:

```cs
using System;

namespace eft_dma_radar
{
    public static class Misc
    {
        public static readonly Dictionary<string, string> Bosses = new Dictionary<string, string>()
        {
            ["Решала"] = "Reshala",
            ["Килла"] = "Killa",
            ["Тагилла"] = "Tagilla",
            ["Санитар"] = "Sanitar",
            ["Глухарь"] = "Gluhar",
            ["Штурман"] = "Shturman"
        };
    }
    public static class Extensions
    {
        public static void Reset(this System.Timers.Timer t)
        {
            t.Stop();
            t.Start();
        }
        public static bool Contains(this string source, string toCheck, StringComparison comp)
        {
            return source?.IndexOf(toCheck, comp) >= 0;
        }
    }

    public enum ShuffleSel
    {
        XFromX,
        XFromY,
        XFromZ,
        XFromW,

        YFromX = 0x00,
        YFromY = 0x04,
        YFromZ = 0x08,
        YFromW = 0x0C,

        ZFromX = 0x00,
        ZFromY = 0x10,
        ZFromZ = 0x20,
        ZFromW = 0x30,

        WFromX = 0x00,
        WFromY = 0x40,
        WFromZ = 0x80,
        WFromW = 0xC0,

        ExpandX = XFromX | YFromX | ZFromX | WFromX,
        ExpandY = XFromY | YFromY | ZFromY | WFromY,
        ExpandZ = XFromZ | YFromZ | ZFromZ | WFromZ,
        ExpandW = XFromW | YFromW | ZFromW | WFromW,

        ExpandXY = XFromX | YFromX | ZFromY | WFromY,
        ExpandZW = XFromZ | YFromZ | ZFromW | WFromW,

        ExpandInterleavedXY = XFromX | YFromY | ZFromX | WFromY,
        ExpandInterleavedZW = XFromZ | YFromW | ZFromZ | WFromW,

        RotateRight = XFromY | YFromZ | ZFromW | WFromX,
        RotateLeft = XFromW | YFromX | ZFromY | WFromZ,

        Swap = XFromW | YFromZ | ZFromY | WFromX
    }

}

```

`Source/Objects.cs`:

```cs
using System.Text.Json;
using System.Diagnostics;
using System.Numerics;
using System.Text.Json.Serialization;
using SkiaSharp;

namespace eft_dma_radar
{

    // GUI Testing Structures, may change

    public class DebugStopwatch
    {
        private readonly Stopwatch _sw;
        private readonly string _name;

        public DebugStopwatch(string name = null)
        {
            _name = name;
            _sw = new Stopwatch();
            _sw.Start();
        }

        public void Stop()
        {
            _sw.Stop();
            TimeSpan ts = _sw.Elapsed;
            Debug.WriteLine($"{_name} Stopwatch Runtime: {ts.Milliseconds}ms");
        }
    }

    /// <summary>
    /// Defines Player Unit Type (Player,PMC,Scav,etc.)
    /// </summary>
    public enum PlayerType
    {
        Default,
        CurrentPlayer,
        Teammate,
        PMC, // side 0x1 0x2
        AIScav, // side 0x4
        AIBoss, // ToDo
        PlayerScav // side 0x4
    }

    /// <summary>
    /// Defines map position for the UI Map.
    /// </summary>
    public struct MapPosition
    {
        public float X;
        public float Y;
        public float Height; // Z

        /// <summary>
        /// Get exact player location.
        /// </summary>
        public SKPoint GetPoint()
        {
            return new SKPoint(X, Y);
        }

        /// <summary>
        /// Gets Point where player name should be drawn.
        /// </summary>
        public SKPoint GetNamePoint(int xOff = 0, int yOff = 0)
        {
            return new SKPoint(X + xOff, Y + yOff);
        }

        /// <summary>
        /// Gets up arrow where loot is. IDisposable.
        /// </summary>
        public SKPath GetUpArrow()
        {
            SKPath path = new SKPath();
            path.MoveTo(X, Y);
            path.LineTo(X - 6, Y + 6);
            path.LineTo(X + 6, Y + 6);
            path.Close();

            return path;
        }

        /// <summary>
        /// Gets down arrow where loot is. IDisposable.
        /// </summary>
        public SKPath GetDownArrow()
        {
            SKPath path = new SKPath();
            path.MoveTo(X, Y);
            path.LineTo(X - 6, Y - 6);
            path.LineTo(X + 6, Y - 6);
            path.Close();

            return path;
        }
    }

    /// <summary>
    /// Defines a Map for use in the GUI.
    /// </summary>
    public class Map
    {
        public readonly string Name;
        public readonly MapConfig ConfigFile;
        public readonly string ConfigFilePath;

        public Map(string name, MapConfig config, string configPath)
        {
            Name = name;
            ConfigFile = config;
            ConfigFilePath = configPath;
        }
    }

    /// <summary>
    /// Defines a .JSON Map Config File
    /// </summary>
    public class MapConfig
    {
        [JsonPropertyName("x")]
        public float X { get; set; }
        [JsonPropertyName("y")]
        public float Y { get; set; }
        [JsonPropertyName("z")]
        public float Z { get; set; }
        [JsonPropertyName("scale")]
        public float Scale { get; set; }
        /// <summary>
        /// * This List contains the path to the map file(s), and a minimum height (Z) value.
        /// * Each tuple consists of Item1: (float)MIN_HEIGHT, Item2: (string>MAP_PATH
        /// * This list will be iterated backwards, and if the current player height (Z) is above the float
        /// value, then that map layer will be drawn. This will allow having different bitmaps at different
        /// heights.
        /// * If using only a single map (no layers), set the float value to something very low like -100.
        /// </summary>
        [JsonPropertyName("maps")]
        public List<Tuple<float, string>> Maps { get; set; }


        public static MapConfig LoadFromFile(string file)
        {
            var json = File.ReadAllText(file);
            return JsonSerializer.Deserialize<MapConfig>(json);
        }

        public void Save(Map map)
        {
            var json = JsonSerializer.Serialize<MapConfig>(this);
            File.WriteAllText(map.ConfigFilePath, json);
        }
    }

    public class Config
    {
        [JsonPropertyName("playerAimLine")]
        public int PlayerAimLineLength { get; set; }
        [JsonPropertyName("defaultZoom")]
        public int DefaultZoom { get; set; }
        [JsonPropertyName("lootEnabled")]
        public bool LootEnabled { get; set; }

        public Config()
        {
            PlayerAimLineLength = 10;
            DefaultZoom = 100;
            LootEnabled = true;
        }

        public static bool TryLoadConfig(out Config config)
        {
            try
            {
                if (!File.Exists("Config.json")) throw new FileNotFoundException("Config.json does not exist!");
                var json = File.ReadAllText("Config.json");
                config = JsonSerializer.Deserialize<Config>(json);
                return true;
            }
            catch
            {
                config = null;
                return false;
            }
        }
        public static void SaveConfig(Config config)
        {
            var json = JsonSerializer.Serialize<Config>(config);
            File.WriteAllText("Config.json", json);
        }
    }

    /// <summary>
    /// Top level object defining a scatter read operation. Create one of these in a local context.
    /// </summary>
    public class ScatterReadMap
    {
        private readonly List<ScatterReadRound> Rounds = new();
        /// <summary>
        /// Contains results from Scatter Read after Execute() is performed. First key is Index, Second Key ID.
        /// </summary>
        public Dictionary<int, Dictionary<int, ScatterReadEntry>> Results = new();

        /// <summary>
        /// Executes Scatter Read operation as defined per the map.
        /// </summary>
        public void Execute(int indexCount)
        {
            for (int i = 0; i < indexCount; i++) // Add dict for each index
            {
                Results.Add(i, new Dictionary<int, ScatterReadEntry>());
            }
            foreach (var round in Rounds)
            {
                round.Run();
            }
        }
        /// <summary>
        /// Add scatter read rounds to the operation. Each round is a successive scatter read, you may need multiple
        /// rounds if you have reads dependent on earlier scatter reads result(s).
        /// </summary>
        /// <returns>ScatterReadRound object.</returns>
        public ScatterReadRound AddRound()
        {
            var round = new ScatterReadRound(this);
            Rounds.Add(round);
            return round;
        }
    }

    /// <summary>
    /// Defines a scatter read round. Each round will execute a single scatter read. If you have reads that
    /// are dependent on previous reads (chained pointers for example), you may need multiple rounds.
    /// </summary>
    public class ScatterReadRound
    {
        private readonly ScatterReadMap _map;
        private readonly List<ScatterReadEntry> Entries = new();
        public ScatterReadRound(ScatterReadMap map)
        {
            _map = map;
        }

        /// <summary>
        /// Adds a single Scatter Read Entry.
        /// </summary>
        /// <param name="index">For loop index this is associated with.</param>
        /// <param name="id">Random ID number to identify the entry's purpose.</param>
        /// <param name="addr">Address to read from (you can pass a ScatterReadEntry from an earlier round, 
        /// and it will use the result).</param>
        /// <param name="type">Type of object to read.</param>
        /// <param name="size">Size of oject to read (ONLY for reference types, value types get size from
        /// Type). You canc pass a ScatterReadEntry from an earlier round and it will use the Result.</param>
        /// <param name="offset">Optional offset to add to address (usually in the event that you pass a
        /// ScatterReadEntry to the Addr field).</param>
        /// <returns></returns>
        public ScatterReadEntry AddEntry(int index, int id, object addr, Type type, object size = null, uint offset = 0x0)
        {
            if (size is null) size = (int)0;
            var entry = new ScatterReadEntry()
            {
                Index = index,
                Id = id,
                Addr = addr,
                Type = type,
                Size = size,
                Offset = offset
            };
            Entries.Add(entry);
            return entry;
        }

        /// <summary>
        /// Internal use only do not use.
        /// </summary>
        public void Run()
        {
            Memory.ReadScatter(Entries.ToArray(), _map.Results);
        }
    }

    /// <summary>
    /// Single scatter read entry. Use ScatterReadRound.AddEntry() to construct this class.
    /// </summary>
    public class ScatterReadEntry
    {
        /// <summary>
        /// for loop index this is associated with
        /// </summary>
        public int Index;
        /// <summary>
        /// Random identifier code (1 = PlayerBase, 2 = PlayerProfile, etc.)
        /// </summary>
        public int Id;
        /// <summary>
        /// Can be an ulong or another ScatterReadEntry
        /// </summary>
        public object Addr = (ulong)0x0;
        /// <summary>
        /// Offset amount to be added to Address.
        /// </summary>
        public uint Offset = 0x0;
        /// <summary>
        /// Defines the type. For value types is also used to determine the size.
        /// </summary>
        public Type Type;
        /// <summary>
        /// Can be an int32 or another ScatterReadEntry
        /// </summary>
        public object Size;
        /// <summary>
        /// Multiplies size by this value (ex: unity strings *2). Default: 1
        /// </summary>
        public int SizeMult = 1;
        /// <summary>
        /// Result is stored here, must cast to unbox.
        /// </summary>
        public object Result;
    }

    /// <summary>
    /// Type placeholder for scatter reads. Not for use.
    /// </summary>
    public struct UnityString
    {
    }

    public struct ZoomLevel
    {
        public float Width;
        public float Height;
    }

    // EFT/Unity Structures (WIP)
    public struct GameObjectManager
    {
        public ulong LastTaggedNode; // 0x0

        public ulong TaggedNodes; // 0x8

        public ulong LastMainCameraTaggedNode; // 0x10

        public ulong MainCameraTaggedNodes; // 0x18

        public ulong LastActiveNode; // 0x20

        public ulong ActiveNodes; // 0x28

    }

    public struct BaseObject
    {
        public ulong previousObjectLink; //0x0000
        public ulong nextObjectLink; //0x0008
        public ulong obj; //0x0010
	};


    public struct Matrix34
    {
        public Vector4 vec0;
        public Vector4 vec1;
        public Vector4 vec2;

    }

}

```

`Source/Offsets.cs`:

```cs
namespace eft_dma_radar
{
    internal static class Offsets
    {
        public const uint ModuleBase_GameObjectManager = 0x17F8D28;
        public static readonly uint[] GameWorld_LocalGameWorld = new uint[] { 0x30, 0x18, 0x28 };
        
        public const uint RegisteredPlayers = 0x80;
        public const uint RegisteredPlayers_Count = 0x18;

        public const uint PlayerBase_Profile = 0x4B8;
        public const uint PlayerBase_MovementContext = 0x40;
        public const uint PlayerBase_IsLocalPlayer = 0x7F7;
        public static readonly uint[] PlayerBase_HealthController = new uint[] { 0x4F0, 0x50, Offsets.UnityDictBase };

        public const uint MovementContext_Direction = 0x22C;

        public static readonly uint[] Transform_TransformInternal = new uint[] { 0xA8, 0x28, 0x28, 0x10, 0x20, 0x10 };
        public const uint TransformInternal_TransfPMatrix = 0x38;
        //public const uint PlayerTransformInternal_Index = 0x40;
        public const uint TransfPMatrix_TransformDependencyIndexTableBase = 0x20;

        public const uint HealthEntry = 0x10;
        public const uint HealthEntry_Value = 0x10;

        public const uint PlayerProfile_PlayerId = 0x10;
        public const uint PlayerProfile_PlayerInfo = 0x28;

        public const uint PlayerInfo_PlayerName = 0x10;
        public const uint PlayerInfo_Experience = 0x74;
        public const uint PlayerInfo_PlayerSide = 0x58;
        public const uint PlayerInfo_RegDate = 0x5C;

        public const uint UnityDictBase = 0x18;

        public const uint UnityListBase = 0x10;
        public const uint UnityListBase_Start = 0x20;

        public const uint UnityString_Len = 0x10;
        public const uint UnityString_Value = 0x14;

        public const uint UnityObject_Name = 0x60;

        //Loot Stuff
        public const uint LOOT_LIST = 0x60;
        public const uint LOOT_LIST_ENTITY = 0x10;
        public const uint LOOT_LIST_COUNT = 0x18;
        public const uint LOOT_OBJECTS_ENTITY_BASE = 0x20;
        public const uint UNKOWN_PTR = 0x10;
        public const uint INTERACTIVE_CLASS = 0x28;
        public const uint BASE_OBJECT = 0x10;
        public const uint GAME_OBJECT = 0x30;
        public const uint GAME_OBJECT_NAME_PTR = 0x60;
        public static readonly string[] CONTAINERS = new string[] { "body", "XXXcap", "Ammo_crate_Cap", "Grenade_box_Door", "Medical_Door", "Toolbox_Door", "card_file_box", "cover_", "lootable", "scontainer_Blue_Barrel_Base_Cap", "scontainer_wood_CAP", "suitcase_plastic_lootable_open", "weapon_box_cover" };


        public static readonly Dictionary<int, int> EXP_TABLE = new Dictionary<int, int>
        {
            {0, 1},
            {1000, 2},
            {4017, 3},
            {8432, 4},
            {14256, 5},
            {21477, 6},
            {30023, 7},
            {39936, 8},
            {51204, 9},
            {63723, 10},
            {77563, 11},
            {92713, 12},
            {111881, 13},
            {134674, 14},
            {161139, 15},
            {191417, 16},
            {225194, 17},
            {262366, 18},
            {302484, 19},
            {345751, 20},
            {391649, 21},
            {440444, 22},
            {492366, 23},
            {547896, 24},
            {609066, 25},
            {675913, 26},
            {748474, 27},
            {826786, 28},
            {910885, 29},
            {1000809, 30},
            {1096593, 31},
            {1198275, 32},
            {1309251, 33},
            {1429580, 34},
            {1559321, 35},
            {1698532, 36},
            {1847272, 37},
            {2005600, 38},
            {2173575, 39},
            {2351255, 40},
            {2538699, 41},
            {2735966, 42},
            {2946585, 43},
            {3170637, 44},
            {3408202, 45},
            {3659361, 46},
            {3924195, 47},
            {4202784, 48},
            {4495210, 49},
            {4801553, 50},
            {5121894, 51},
            {5456314, 52},
            {5809667, 53},
            {6182063, 54},
            {6573613, 55},
            {6984426, 56},
            {7414613, 57},
            {7864284, 58},
            {8333549, 59},
            {8831052, 60},
            {9360623, 61},
            {9928578, 62},
            {10541848, 63},
            {11206300, 64},
            {11946977, 65},
            {12789143, 66},
            {13820522, 67},
            {15229487, 68},
            {17206065, 69},
            {19706065, 70},
            {22706065, 71},
            {26206065, 72},
            {30206065, 73},
            {34706065, 74},
            {39706065, 75},
        };
    }
}

```

`Source/Player.cs`:

```cs
using System;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.InteropServices;

namespace eft_dma_radar
{
    /// <summary>
    /// Class containing Game Player Data. Use lock() when accessing instances of this class.
    /// </summary>
    public class Player
    {
        private static readonly List<string> _teammates;
        //private static string _currentPlayerGroupID = String.Empty;
        public readonly string Name;
        public readonly int Lvl = 0;
        public readonly PlayerType Type;
        //public readonly string GroupID; // ToDo not working
        private readonly ulong _playerBase;
        private readonly ulong _playerProfile;
        private readonly ulong _playerInfo;
        public readonly ulong[] BodyParts;
        public readonly ulong MovementContext;
        public ulong PlayerTransformInternal;
        public ulong PlayerTransformMatrixListBase;
        public ulong PlayerTransformDependencyIndexTableBase;
        public int Health = -1;
        public bool MayBeDead = false;
        public bool IsAlive = true;
        public bool IsActive = true;
        public Vector3 Position = new Vector3(0, 0, 0);
        public float Direction = 0f;
        public float Pitch = 0f;

        static Player()
        {
            _teammates = new();
            if (File.Exists("teammates.txt"))
            {
                _teammates = File.ReadAllLines("teammates.txt").ToList();
            }
            else File.Create("teammates.txt");
        }

        public Player(ulong playerBase, ulong playerProfile)
        {
            try
            {
                _playerBase = playerBase;
                _playerProfile = playerProfile;
                _playerInfo = Memory.ReadPtr(playerProfile + Offsets.PlayerProfile_PlayerInfo);
                var healthController = Memory.ReadPtrChain(_playerBase, Offsets.PlayerBase_HealthController);
                BodyParts = new ulong[7];
                for (uint i = 0; i < 7; i++)
                {                                                                          //dict
                    BodyParts[i] = Memory.ReadPtrChain(healthController, new uint[] { 0x30 + (i * 0x18), Offsets.HealthEntry });
                }
                MovementContext = Memory.ReadPtr(_playerBase + Offsets.PlayerBase_MovementContext);
                PlayerTransformInternal = Memory.ReadPtrChain(_playerBase, Offsets.Transform_TransformInternal);
                var playersTransfPMatrix = Memory.ReadPtr(PlayerTransformInternal + Offsets.TransformInternal_TransfPMatrix);
                PlayerTransformMatrixListBase = Memory.ReadPtr(playersTransfPMatrix + Offsets.UnityDictBase);
                PlayerTransformDependencyIndexTableBase = Memory.ReadPtr(playersTransfPMatrix + Offsets.TransfPMatrix_TransformDependencyIndexTableBase);
                //var grpPtr = Memory.ReadPtr(_playerInfo + 0x18);
                //GroupID = Memory.ReadString(grpPtr, 8);
                var namePtr = Memory.ReadPtr(_playerInfo + Offsets.PlayerInfo_PlayerName);
                Name = Memory.ReadUnityString(namePtr);
                var isLocalPlayer = Memory.ReadBool(_playerBase + Offsets.PlayerBase_IsLocalPlayer);
                if (isLocalPlayer)
                {
                    Type = PlayerType.CurrentPlayer;
                    //_currentPlayerGroupID = GroupID;
                }
                //else if (GroupID == _currentPlayerGroupID) Type = PlayerType.Teammate;
                else
                {
                    var playerSide = Memory.ReadInt(_playerInfo + Offsets.PlayerInfo_PlayerSide); // Scav, PMC, etc.
                    if (playerSide == 0x4)
                    {
                        var regDate = Memory.ReadInt(_playerInfo + Offsets.PlayerInfo_RegDate); // Bots wont have 'reg date'
                        if (regDate == 0)
                        {
                            if (Misc.Bosses.ContainsKey(Name))
                            {
                                Name = Misc.Bosses[Name];
                                Type = PlayerType.AIBoss;
                            }
                            else Type = PlayerType.AIScav;
                        }
                        else Type = PlayerType.PlayerScav;
                    }
                    else if (playerSide == 0x1 || playerSide == 0x2)
                    {
                        if (_teammates.Contains(Name)) Type = PlayerType.Teammate;
                        else Type = PlayerType.PMC;
                        var exp = Memory.ReadInt(_playerInfo + Offsets.PlayerInfo_Experience);
                        Lvl = Offsets.EXP_TABLE.Where(x => x.Key > exp).FirstOrDefault().Value - 1;
                    }
                    else Type = PlayerType.Default;
                }
                Debug.WriteLine($"Player {Name} allocated.");
            }
            catch (Exception ex)
            {
                throw new DMAException($"ERROR during Player constructor for base addr 0x{playerBase.ToString("X")}", ex);
            }
        }

        /// <summary>
        ///  Update Player Information (only call from Memory Thread)
        /// </summary>
        public void Update()
        {
            if (IsAlive && IsActive) // Only update if alive/in-raid
            {
                SetPosition();
                SetDirection();
                SetHealth();
            }
        }

        /// <summary>
        /// Get current player health.
        /// </summary>
        public void SetHealth(float?[] values = null)
        {
            try
            {
                float totalHealth = 0;
                for (uint i = 0; i < BodyParts.Length; i++)
                {
                    float health;
                    if (values is null) health = Memory.ReadFloat(BodyParts[i] + Offsets.HealthEntry_Value);
                    else
                    {
                        health = (float)values[i];
                    }
                    totalHealth += health;
                    if (i == 0 || i == 1) // Head/thorax
                    {
                        if (health == 0f)
                        {
                            this.MayBeDead = true;
                            return;
                        }
                    }
                }
                this.Health = (int)Math.Round(totalHealth);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR getting Player {Name} Health: {ex}");
            }
        }

        public void SetDirection(float? deg = null)
        {
            try
            {
                if (deg is null) deg = Memory.ReadFloat(MovementContext + Offsets.MovementContext_Direction);
                if (deg < 0)
                {
                    this.Direction = 360f + (float)deg;
                    return;
                }
                this.Direction = (float)deg;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR getting Player {Name} Direction: {ex}");
            }
        }

        public void SetPitch(float? deg = null)
        {
            try
            {
                if (deg is null) deg = Memory.ReadFloat(MovementContext + Offsets.MovementContext_Direction + 0x4);
                if (deg < 0)
                {
                    this.Pitch = 360f + (float)deg;
                    return;
                }
                this.Pitch = (float)deg;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR getting Player {Name} Pitch: {ex}");
            }
        }

        /// <summary>
        /// Converts player transform to X,Y,Z coordinates (Vector3)
        /// </summary>
        public unsafe void SetPosition(object[] ptrs = null)
        {
            IntPtr pMatricesBufPtr = new(); // 0
            IntPtr pIndicesBufPtr = new(); // 0
            int index = 1; // Always seems to be 1
            try
            {
                if (ptrs is null) // Read on demand
                {
                    pMatricesBufPtr = Marshal.AllocHGlobal(sizeof(Matrix34) * index + sizeof(Matrix34));
                    Memory.ReadBuffer(PlayerTransformMatrixListBase, pMatricesBufPtr, sizeof(Matrix34) * index + sizeof(Matrix34));
                    pIndicesBufPtr = Marshal.AllocHGlobal(sizeof(int) * index + sizeof(int));
                    Memory.ReadBuffer(PlayerTransformDependencyIndexTableBase, pIndicesBufPtr, sizeof(int) * index + sizeof(int));
                }
                else // Scatter read
                {
                    if (ptrs[0] is null || ptrs[1] is null)
                        throw new NullReferenceException("Scatter Read parameter(s) are null!");
                    pMatricesBufPtr = (IntPtr)ptrs[0];
                    pIndicesBufPtr = (IntPtr)ptrs[1];
                }
                void* pMatricesBuf = pMatricesBufPtr.ToPointer();
                void* pIndicesBuf = pIndicesBufPtr.ToPointer();
                
                Vector4 result = *(Vector4*)((UInt64)pMatricesBuf + 0x30 * (UInt64)index);
                int index_relation = *(int*)((UInt64)pIndicesBuf + 0x4 * (UInt64)index);

                Vector4 xmmword_1410D1340 = new Vector4(-2.0f, 2.0f, -2.0f, 0.0f);
                Vector4 xmmword_1410D1350 = new Vector4(2.0f, -2.0f, -2.0f, 0.0f);
                Vector4 xmmword_1410D1360 = new Vector4(-2.0f, -2.0f, 2.0f, 0.0f);

                int iterations = 0;
                while (index_relation >= 0)
                {
                    if (iterations > 10) throw new Exception("Max SIMD iterations");
                    if (index_relation > 1) throw new Exception("Invalid Index Relation!");
                    Matrix34 matrix34 = *(Matrix34*)((UInt64)pMatricesBuf + 0x30 * (UInt64)index_relation);

                    Vector4 v10 = matrix34.vec2 * result;
                    Vector4 v11 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(0)));
                    Vector4 v12 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(85)));
                    Vector4 v13 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(-114)));
                    Vector4 v14 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(-37)));
                    Vector4 v15 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(-86)));
                    Vector4 v16 = (Vector4)(Shuffle(matrix34.vec1, (ShuffleSel)(113)));
                    result = (((((((v11 * xmmword_1410D1350) * v13) - ((v12 * xmmword_1410D1360) * v14)) * Shuffle(v10, (ShuffleSel)(-86))) +
                        ((((v15 * xmmword_1410D1360) * v14) - ((v11 * xmmword_1410D1340) * v16)) * Shuffle(v10, (ShuffleSel)(85)))) +
                        (((((v12 * xmmword_1410D1340) * v16) - ((v15 * xmmword_1410D1350) * v13)) * Shuffle(v10, (ShuffleSel)(0))) + v10)) + matrix34.vec0);
                    index_relation = *(int*)((UInt64)pIndicesBuf + 0x4 * (UInt64)index_relation);
                    iterations++;
                }

                this.Position = new Vector3(result.X, result.Z, result.Y);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR getting Player {Name} Position: {ex}");
                try 
                { 
                    PlayerTransformInternal = Memory.ReadPtrChain(_playerBase, Offsets.Transform_TransformInternal);
                    var playersTransfPMatrix = Memory.ReadPtr(PlayerTransformInternal + Offsets.TransformInternal_TransfPMatrix);
                    PlayerTransformMatrixListBase = Memory.ReadPtr(playersTransfPMatrix + Offsets.UnityDictBase);
                    PlayerTransformDependencyIndexTableBase = Memory.ReadPtr(playersTransfPMatrix + Offsets.TransfPMatrix_TransformDependencyIndexTableBase);
                } // Update pointers
                catch { }
            }
            finally // Free mem
            {
                if (pMatricesBufPtr.ToInt64() != 0) Marshal.FreeHGlobal(pMatricesBufPtr);
                if (pIndicesBufPtr.ToInt64() != 0) Marshal.FreeHGlobal(pIndicesBufPtr);
            }
        }

        private static unsafe Vector4 Shuffle(Vector4 v1, ShuffleSel sel)
        {
            var ptr = (float*)&v1;
            var idx = (int)sel;
            return new Vector4(*(ptr + ((idx >> 0) & 0x3)), *(ptr + ((idx >> 2) & 0x3)), *(ptr + ((idx >> 4) & 0x3)),
                *(ptr + ((idx >> 6) & 0x3)));
        }
    }
}

```

`Source/Program.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace eft_dma_radar
{
    internal static class Program
    {
        private static Mutex _mutex;
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Console.OutputEncoding = System.Text.Encoding.Unicode; // allow russian chars
            try
            {
                _mutex = new Mutex(true, "9A19103F-16F7-4668-BE54-9A1E7A4F7556", out bool singleton);
                if (singleton)
                {
                    TarkovMarketManager.UpdateMarketItems();
                    ApplicationConfiguration.Initialize();
					Application.Run(new MainForm());
                }
                else
                {
                    throw new Exception("The Application Is Already Running!");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), "EFT Radar", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }


        [DllImport("user32.dll")]
        public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
        [DllImport("kernel32.dll")]
        public static extern IntPtr GetConsoleWindow();
    }
}

```

`Source/RegisteredPlayers.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace eft_dma_radar
{
    public class RegisteredPlayers
    {
        private readonly ulong _base;
        private readonly ulong _listBase;
        private readonly HashSet<string> _registered;
        private ConcurrentDictionary<string, Player> _players; // backing field
        private readonly Stopwatch _regSw = new();
        private readonly Stopwatch _healthSw = new();
        public ConcurrentDictionary<string, Player> Players
        {
            get
            {
                return Volatile.Read(ref _players);
            }
        }
        public int PlayerCount
        {
            get
            {
                return Memory.ReadInt(_base + Offsets.RegisteredPlayers_Count);
            }
        }

        public RegisteredPlayers(ulong baseAddr)
        {
            _base = baseAddr;
            _listBase = Memory.ReadPtr(_base + Offsets.UnityListBase);
            _registered = new HashSet<string>();
            _players = new ConcurrentDictionary<string, Player>();
            _regSw.Start();
            _healthSw.Start();
        }

        /// <summary>
        /// Updates the ConcurrentDictionary of 'Players'
        /// </summary>
        public void UpdateList()
        {
            try
            {
                if (_regSw.ElapsedMilliseconds < 500) return; // Update every 500ms
                _registered.Clear();
                var count = this.PlayerCount; // cache count
                var scatterMap = new ScatterReadMap();
                var round1 = scatterMap.AddRound();
                var round2 = scatterMap.AddRound();
                var round3 = scatterMap.AddRound();
                var round4 = scatterMap.AddRound();
                var round5 = scatterMap.AddRound();
                for (int i = 0; i < count; i++)
                {
                    var playerBase = round1.AddEntry(i,
                        0,
                        _listBase + Offsets.UnityListBase_Start + (uint)(i * 0x8),
                        typeof(ulong));
                    var playerProfile = round2.AddEntry(i, 1, playerBase,
                        typeof(ulong), 0, Offsets.PlayerBase_Profile);

                    var playerId = round3.AddEntry(i, 2, playerProfile, typeof(ulong),
                        0, Offsets.PlayerProfile_PlayerId);
                    var playerIdLen = round4.AddEntry(i, 3, playerId, typeof(int),
                        0, Offsets.UnityString_Len);
                    var playerIdStr = round5.AddEntry(i, 4, playerId, typeof(UnityString),
                        playerIdLen, Offsets.UnityString_Value);
                    playerIdStr.SizeMult = 2; // Unity String twice the length
                }
                scatterMap.Execute(count);
                for (int i = 0; i < count; i++)
                {
                    try
                    {
                        var id = (string)scatterMap.Results[i][4].Result;
                        var playerBase = (ulong)scatterMap.Results[i][0].Result;
                        var playerProfile = (ulong)scatterMap.Results[i][1].Result;
                        if (id is null || id == String.Empty) throw new Exception("Invalid Player ID!");
                        if (!_players.ContainsKey(id))
                        {
                            var player = new Player((ulong)playerBase, (ulong)playerProfile); // allocate player object
                            _players.TryAdd(id, player);
                        }
                        else
                        {
                            _players[id].IsActive = true;
                            _players[id].IsAlive = true;
                            _players[id].MayBeDead = false;
                        }
                        _registered.Add(id);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine($"ERROR allocating player at index {i}: {ex}");
                    }
                }
                var inactivePlayers = _players.Where(x => !_registered.Contains(x.Key));
                foreach (KeyValuePair<string, Player> player in inactivePlayers)
                {
                    player.Value.Update();
                    player.Value.IsActive = false;
                    if (player.Value.MayBeDead) player.Value.IsAlive = false;
                }
                _regSw.Restart();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR iterating registered players: {ex}");
            }
        }

        /// <summary>
        /// Updates all 'Player' values (Position,health,direction,etc.)
        /// </summary>
        public void UpdateAllPlayers()
        {
            try
            {
                var players = _players.Where(x => x.Value.IsActive && x.Value.IsAlive).ToArray();
                bool checkHealth = _healthSw.ElapsedMilliseconds > 250;
                var scatterMap = new ScatterReadMap();
                var round1 = scatterMap.AddRound();
                for (int i = 0; i < players.Length; i++)
                {
                    var dir = round1.AddEntry(i, 0, players[i].Value.MovementContext + Offsets.MovementContext_Direction,
                        typeof(float), null);
                    var pitch = round1.AddEntry(i, 1, players[i].Value.MovementContext + Offsets.MovementContext_Direction + 0x4,
                        typeof(float));
                    if (checkHealth) for (int p = 0; p < 7; p++)
                    {
                        var health = round1.AddEntry(i, 2 + p, players[i].Value.BodyParts[p] + Offsets.HealthEntry_Value,
                            typeof(float), null);
                    }
                    var pos1 = round1.AddEntry(i, 9, players[i].Value.PlayerTransformMatrixListBase,
                        typeof(IntPtr), Marshal.SizeOf(typeof(Matrix34)) * 1 + Marshal.SizeOf(typeof(Matrix34)));
                    var pos2 = round1.AddEntry(i, 10, players[i].Value.PlayerTransformDependencyIndexTableBase,
                        typeof(IntPtr), Marshal.SizeOf(typeof(int)) * 1 + Marshal.SizeOf(typeof(int)));
                }
                scatterMap.Execute(players.Length);

                for (int i = 0; i < players.Length; i++)
                {
                    var dir = (float?)scatterMap.Results[i][0].Result;
                    var pitch = (float?)scatterMap.Results[i][1].Result;
                    players[i].Value.SetDirection(dir);
                    players[i].Value.SetPitch(pitch);
                    if (checkHealth)
                    {
                        float?[] bodyParts = new float?[7];
                        for (int p = 0; p < 7; p++)
                        {
                            bodyParts[p] = (float?)scatterMap.Results[i][2 + p].Result;
                        }
                        players[i].Value.SetHealth(bodyParts);
                    }
                    object[] ptrs = new object[2]
                    {
                            scatterMap.Results[i][9].Result,
                            scatterMap.Results[i][10].Result
                    };
                    players[i].Value.SetPosition(ptrs);
                }
                if (checkHealth) _healthSw.Restart();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR updating All Players: {ex}");
            }
        }
    }
}

```

`Source/TarkovMarketManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using System.IO;

namespace eft_dma_radar
{
    internal static class TarkovMarketManager
    {
        private static Dictionary<string, TarkovMarketItem> _filteredItems = new Dictionary<string, TarkovMarketItem>();

        public static Dictionary<string, TarkovMarketItem> ItemFilter
        {
            get
            {
                return _filteredItems;
            }
        }
        public static void UpdateMarketItems()
        {
            var marketItems = new List<TarkovMarketItem>();
            if (!File.Exists("market.json") ||
File.GetLastWriteTime("market.json").AddHours(24) < DateTime.Now)
            {
                using (WebClient client = new WebClient())
                {
                    WebRequest request = WebRequest.Create(@"https://market_master.filter-editor.com/data/marketData_en.json");
                    using WebResponse response = request.GetResponse();
                    string json = client.DownloadString(response.ResponseUri);
                    marketItems = JsonSerializer.Deserialize<List<TarkovMarketItem>>(json);
                    File.WriteAllText("market.json", json);
                }
            }
            else
            {
                var json = File.ReadAllText("market.json");
                marketItems = JsonSerializer.Deserialize<List<TarkovMarketItem>>(json);
            }

#pragma warning disable CS8604 // Possible null reference argument.
            var items = marketItems.Where(x => x.avg24hPrice > 50000 || x.traderPrice > 50000);
            foreach (var item in items)
            {
                _filteredItems.TryAdd(item.bsgId, item);
            }
#pragma warning restore CS8604 // Possible null reference argument.
        }
    }

    public class TarkovMarketItem
    {
        public string uid { get; set; }
        public string name { get; set; }
        public List<string> tags { get; set; }
        public string shortName { get; set; }
        public int price { get; set; }
        public int basePrice { get; set; }
        public int avg24hPrice { get; set; }
        public int avg7daysPrice { get; set; }
        public string traderName { get; set; }
        public int traderPrice { get; set; }
        public string traderPriceCur { get; set; }
        public DateTime updated { get; set; }
        public int slots { get; set; }
        public double diff24h { get; set; }
        public double diff7days { get; set; }
        public string icon { get; set; }
        public string link { get; set; }
        public string wikiLink { get; set; }
        public string img { get; set; }
        public string imgBig { get; set; }
        public string bsgId { get; set; }
        public bool isFunctional { get; set; }
        public string reference { get; set; }
        public string apiKey { get; set; }
    }
}
```

`Source/vmmsharp/vmmdll.h`:

```h
// vmmdll.h : header file to include in projects that use vmm.dll / vmm.so
// 
// Windows may access both UTF-8 *U and Wide-Char *W versions of functions
// while Linux may only access UTF-8 versions. Some functionality may also
// be degraded or unavailable on Linux.
//
// (c) Ulf Frisk, 2018-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
// Header Version: 4.5
//

#include "leechcore.h"

#ifndef __VMMDLL_H__
#define __VMMDLL_H__
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifdef _WIN32

#include <Windows.h>
#undef EXPORTED_FUNCTION
#define EXPORTED_FUNCTION
typedef unsigned __int64                    QWORD, *PQWORD;

#endif /* _WIN32 */
#ifdef LINUX

#include <inttypes.h>
#include <stdlib.h>
#undef EXPORTED_FUNCTION
#define EXPORTED_FUNCTION                   __attribute__((visibility("default")))
typedef void                                VOID, *PVOID, *HANDLE, **PHANDLE, *HMODULE;
typedef long long unsigned int              QWORD, *PQWORD, ULONG64, *PULONG64;
typedef size_t                              SIZE_T, *PSIZE_T;
typedef uint64_t                            FILETIME, *PFILETIME;
typedef uint32_t                            DWORD, *PDWORD, *LPDWORD, BOOL, *PBOOL, NTSTATUS;
typedef uint16_t                            WORD, *PWORD;
typedef uint8_t                             BYTE, *PBYTE, *LPBYTE, UCHAR;
typedef char                                CHAR, *PCHAR, *LPSTR, *LPCSTR;
typedef uint16_t                            WCHAR, *PWCHAR, *LPWSTR, *LPCWSTR;
#define MAX_PATH                            260
#define _In_
#define _In_z_
#define _In_opt_
#define _In_reads_(x)
#define _In_reads_opt_(x)
#define _Inout_
#define _Inout_bytecount_(x)
#define _Inout_opt_
#define _Inout_updates_opt_(x)
#define _Out_
#define _Out_opt_
#define _Out_writes_(x)
#define _Out_writes_bytes_opt_(x)
#define _Out_writes_opt_(x)
#define _Out_writes_to_(x,y)
#define _When_(x,y)
#define _Frees_ptr_opt_
#define _Post_ptr_invalid_
#define _Check_return_opt_
#define _Printf_format_string_
#define _Success_(x)

#endif /* LINUX */



//-----------------------------------------------------------------------------
// INITIALIZATION FUNCTIONALITY BELOW:
// Choose one way of initializing the VMM / MemProcFS.
//-----------------------------------------------------------------------------

/*
* Initialize VMM.DLL with command line parameters. For a more detailed info
* about the parameters please see github wiki for MemProcFS and LeechCore.
* NB! LeechCore initialization parameters are _also_ valid to this function.
* Important parameters are:
*    -printf = show printf style outputs.
*    -v -vv -vvv = extra verbosity levels.
*    -device = device as on format for LeechCore - please see leechcore.h or
*              Github documentation for additional information. Some values
*              are: <file>, fpga, usb3380, hvsavedstate, totalmeltdown, pmem
*    -remote = remote LeechCore instance - please see leechcore.h or Github
*              documentation for additional information.
*    -norefresh = disable background refreshes (even if backing memory is
*              volatile memory).
*    -memmap = specify a physical memory map given by file or specify 'auto'.
*              example: -memmap c:\\temp\\my_custom_memory_map.txt
*              example: -memmap auto
*    -pagefile[0-9] = page file(s) to use in addition to physical memory.
*              Normally pagefile.sys have index 0 and swapfile.sys index 1.
*              Page files are in constant flux - do not use if time diff
*              between memory dump and page files are more than few minutes.
*              Example: 'pagefile0 swapfile.sys'
*    -symbolserverdisable = disable symbol server until user change.
*              This parameter will take precedence over registry settings.
*    -waitinitialize = Wait for initialization to complete before returning.
*              Normal use is that some initialization is done asynchronously
*              and may not be completed when initialization call is completed.
*              This includes virtual memory compression, registry and more.
*              Example: '-waitinitialize'
*    -userinteract = allow vmm.dll to, on the console, query the user for
*              information such as, but not limited to, leechcore device options.
*              Default: user interaction = disabled.
*    -forensic = start a forensic scan of the physical memory immediately after
*              startup if possible. Allowed parameter values range from 0-4.
*              Note! forensic mode is not available for live memory.
*              1 = forensic mode with in-memory sqlite database.
*              2 = forensic mode with temp sqlite database deleted upon exit.
*              3 = forensic mode with temp sqlite database remaining upon exit.
*              4 = forensic mode with static named sqlite database (vmm.sqlite3).
*              Example -forensic 4
*
* -- argc
* -- argv
* -- ppLcErrorInfo = optional pointer to receive a function allocated memory of
*              struct LC_CONFIG_ERRORINFO with extended error information upon
*              failure. Any memory received should be free'd by caller by
*              calling LcMemFree().
* -- return = success/fail
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Initialize(_In_ DWORD argc, _In_ LPSTR argv[]);

EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_InitializeEx(_In_ DWORD argc, _In_ LPSTR argv[], _Out_opt_ PPLC_CONFIG_ERRORINFO ppLcErrorInfo);

/*
* Close an initialized instance of VMM.DLL and clean up all allocated resources
* including plugins, linked PCILeech.DLL and other memory resources.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Close();

/*
* Free memory allocated by the VMMDLL.
* -- pvMem
*/
EXPORTED_FUNCTION
VOID VMMDLL_MemFree(_Frees_ptr_opt_ PVOID pvMem);



//-----------------------------------------------------------------------------
// CONFIGURATION SETTINGS BELOW:
// Configure MemProcFS or the underlying memory
// acquisition devices.
//-----------------------------------------------------------------------------

/*
* Options used together with the functions: VMMDLL_ConfigGet & VMMDLL_ConfigSet
* Options are defined with either: VMMDLL_OPT_* in this header file or as
* LC_OPT_* in leechcore.h
* For more detailed information check the sources for individual device types.
*/
#define VMMDLL_OPT_CORE_PRINTF_ENABLE                   0x4000000100000000  // RW
#define VMMDLL_OPT_CORE_VERBOSE                         0x4000000200000000  // RW
#define VMMDLL_OPT_CORE_VERBOSE_EXTRA                   0x4000000300000000  // RW
#define VMMDLL_OPT_CORE_VERBOSE_EXTRA_TLP               0x4000000400000000  // RW
#define VMMDLL_OPT_CORE_MAX_NATIVE_ADDRESS              0x4000000800000000  // R

#define VMMDLL_OPT_CORE_SYSTEM                          0x2000000100000000  // R
#define VMMDLL_OPT_CORE_MEMORYMODEL                     0x2000000200000000  // R

#define VMMDLL_OPT_CONFIG_IS_REFRESH_ENABLED            0x2000000300000000  // R - 1/0
#define VMMDLL_OPT_CONFIG_TICK_PERIOD                   0x2000000400000000  // RW - base tick period in ms
#define VMMDLL_OPT_CONFIG_READCACHE_TICKS               0x2000000500000000  // RW - memory cache validity period (in ticks)
#define VMMDLL_OPT_CONFIG_TLBCACHE_TICKS                0x2000000600000000  // RW - page table (tlb) cache validity period (in ticks)
#define VMMDLL_OPT_CONFIG_PROCCACHE_TICKS_PARTIAL       0x2000000700000000  // RW - process refresh (partial) period (in ticks)
#define VMMDLL_OPT_CONFIG_PROCCACHE_TICKS_TOTAL         0x2000000800000000  // RW - process refresh (full) period (in ticks)
#define VMMDLL_OPT_CONFIG_VMM_VERSION_MAJOR             0x2000000900000000  // R
#define VMMDLL_OPT_CONFIG_VMM_VERSION_MINOR             0x2000000A00000000  // R
#define VMMDLL_OPT_CONFIG_VMM_VERSION_REVISION          0x2000000B00000000  // R
#define VMMDLL_OPT_CONFIG_STATISTICS_FUNCTIONCALL       0x2000000C00000000  // RW - enable function call statistics (.status/statistics_fncall file)
#define VMMDLL_OPT_CONFIG_IS_PAGING_ENABLED             0x2000000D00000000  // RW - 1/0

#define VMMDLL_OPT_WIN_VERSION_MAJOR                    0x2000010100000000  // R
#define VMMDLL_OPT_WIN_VERSION_MINOR                    0x2000010200000000  // R
#define VMMDLL_OPT_WIN_VERSION_BUILD                    0x2000010300000000  // R
#define VMMDLL_OPT_WIN_SYSTEM_UNIQUE_ID                 0x2000010400000000  // R

#define VMMDLL_OPT_FORENSIC_MODE                        0x2000020100000000  // RW - enable/retrieve forensic mode type [0-4].

#define VMMDLL_OPT_REFRESH_ALL                          0x2001ffff00000000  // W - refresh all caches
#define VMMDLL_OPT_REFRESH_FREQ_MEM                     0x2001000200000000  // W - refresh memory cache (excl. TLB) [partial 33%/call]
#define VMMDLL_OPT_REFRESH_FREQ_TLB                     0x2001000400000000  // W - refresh page table (TLB) cache [partial 33%/call]
#define VMMDLL_OPT_REFRESH_FREQ_FAST                    0x2001040000000000  // W - refresh fast frequency - incl. partial process refresh
#define VMMDLL_OPT_REFRESH_FREQ_MEDIUM                  0x2001000100000000  // W - refresh medium frequency - incl. full process refresh
#define VMMDLL_OPT_REFRESH_FREQ_SLOW                    0x2001001000000000  // W - refresh slow frequency.
#define VMMDLL_OPT_REFRESH_PROCESS                      0x2001000100000000  // W - DEPRECATED: refresh process listings
#define VMMDLL_OPT_REFRESH_READ                         0x2001000200000000  // W - DEPRECATED: refresh physical read cache
#define VMMDLL_OPT_REFRESH_TLB                          0x2001000400000000  // W - DEPRECATED: refresh page table (TLB) cache
#define VMMDLL_OPT_REFRESH_PAGING                       0x2001000800000000  // W - DEPRECATED: refresh virtual memory 'paging' cache
#define VMMDLL_OPT_REFRESH_REGISTRY                     0x2001001000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_USER                         0x2001002000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_PHYSMEMMAP                   0x2001004000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_PFN                          0x2001008000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_OBJ                          0x2001010000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_NET                          0x2001020000000000  // W - DEPRECATED:

static LPCSTR VMMDLL_MEMORYMODEL_TOSTRING[4] = { "N/A", "X86", "X86PAE", "X64" };

typedef enum tdVMMDLL_MEMORYMODEL_TP {
    VMMDLL_MEMORYMODEL_NA       = 0,
    VMMDLL_MEMORYMODEL_X86      = 1,
    VMMDLL_MEMORYMODEL_X86PAE   = 2,
    VMMDLL_MEMORYMODEL_X64      = 3
} VMMDLL_MEMORYMODEL_TP;

typedef enum tdVMMDLL_SYSTEM_TP {
    VMMDLL_SYSTEM_UNKNOWN_X64   = 1,
    VMMDLL_SYSTEM_WINDOWS_X64   = 2,
    VMMDLL_SYSTEM_UNKNOWN_X86   = 3,
    VMMDLL_SYSTEM_WINDOWS_X86   = 4
} VMMDLL_SYSTEM_TP;

/*
* Set a device specific option value. Please see defines VMMDLL_OPT_* for infor-
* mation about valid option values. Please note that option values may overlap
* between different device types with different meanings.
* -- fOption
* -- pqwValue = pointer to ULONG64 to receive option value.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_ConfigGet(_In_ ULONG64 fOption, _Out_ PULONG64 pqwValue);

/*
* Set a device specific option value. Please see defines VMMDLL_OPT_* for infor-
* mation about valid option values. Please note that option values may overlap
* between different device types with different meanings.
* -- fOption
* -- qwValue
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_ConfigSet(_In_ ULONG64 fOption, _In_ ULONG64 qwValue);



//-----------------------------------------------------------------------------
// FORWARD DECLARATIONS:
//-----------------------------------------------------------------------------

typedef struct tdVMMDLL_MAP_PFN *PVMMDLL_MAP_PFN;



//-----------------------------------------------------------------------------
// LINUX SPECIFIC DEFINES:
//-----------------------------------------------------------------------------
#ifdef LINUX

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;
#endif /* LINUX */



//-----------------------------------------------------------------------------
// VFS - VIRTUAL FILE SYSTEM FUNCTIONALITY BELOW:
// NB! VFS FUNCTIONALITY REQUIRES PLUGINS TO BE INITIALIZED
//     WITH CALL TO VMMDLL_InitializePlugins().
// This is the core of MemProcFS. All implementation and analysis towards
// the virtual file system (vfs) is possible by using functionality below. 
//-----------------------------------------------------------------------------

#define VMMDLL_STATUS_SUCCESS                       ((NTSTATUS)0x00000000L)
#define VMMDLL_STATUS_UNSUCCESSFUL                  ((NTSTATUS)0xC0000001L)
#define VMMDLL_STATUS_END_OF_FILE                   ((NTSTATUS)0xC0000011L)
#define VMMDLL_STATUS_FILE_INVALID                  ((NTSTATUS)0xC0000098L)
#define VMMDLL_STATUS_FILE_SYSTEM_LIMITATION        ((NTSTATUS)0xC0000427L)

#define VMMDLL_VFS_FILELIST_EXINFO_VERSION          1
#define VMMDLL_VFS_FILELIST_VERSION                 2
#define VMMDLL_VFS_FILELISTBLOB_VERSION             0xf88f0001

typedef struct tdVMMDLL_VFS_FILELIST_EXINFO {
    DWORD dwVersion;
    BOOL fCompressed;                   // set flag FILE_ATTRIBUTE_COMPRESSED - (no meaning but shows gui artifact in explorer.exe)
    union {
        FILETIME ftCreationTime;        // 0 = default time
        QWORD qwCreationTime;
    };
    union {
        FILETIME ftLastAccessTime;      // 0 = default time
        QWORD qwLastAccessTime;
    };
    union {
        FILETIME ftLastWriteTime;       // 0 = default time
        QWORD qwLastWriteTime;
    };
} VMMDLL_VFS_FILELIST_EXINFO, *PVMMDLL_VFS_FILELIST_EXINFO;

typedef struct tdVMMDLL_VFS_FILELIST2 {
    DWORD dwVersion;
    VOID(*pfnAddFile)     (_Inout_ HANDLE h, _In_ LPSTR uszName, _In_ ULONG64 cb, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
    VOID(*pfnAddDirectory)(_Inout_ HANDLE h, _In_ LPSTR uszName, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
    HANDLE h;
} VMMDLL_VFS_FILELIST2, *PVMMDLL_VFS_FILELIST2;

typedef struct tdVMMDLL_VFS_FILELISTBLOB_ENTRY {
    ULONG64 ouszName;                       // byte offset to string from VMMDLL_VFS_FILELISTBLOB.uszMultiText
    ULONG64 cbFileSize;                     // -1 == directory
    VMMDLL_VFS_FILELIST_EXINFO ExInfo;      // optional ExInfo
} VMMDLL_VFS_FILELISTBLOB_ENTRY, *PVMMDLL_VFS_FILELISTBLOB_ENTRY;

typedef struct tdVMMDLL_VFS_FILELISTBLOB {
    DWORD dwVersion;                        // VMMDLL_VFS_FILELISTBLOB_VERSION
    DWORD cbStruct;
    DWORD cFileEntry;
    DWORD cbMultiText;
    union {
        LPSTR uszMultiText;
        QWORD _Reserved;
    };
    DWORD _FutureUse[8];
    VMMDLL_VFS_FILELISTBLOB_ENTRY FileEntry[0];
} VMMDLL_VFS_FILELISTBLOB, *PVMMDLL_VFS_FILELISTBLOB;

/*
* Helper functions for callbacks into the VMM_VFS_FILELIST2 structure.
*/
EXPORTED_FUNCTION
VOID VMMDLL_VfsList_AddFile(_In_ HANDLE pFileList, _In_ LPSTR uszName, _In_ ULONG64 cb, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
VOID VMMDLL_VfsList_AddFileW(_In_ HANDLE pFileList, _In_ LPWSTR wszName, _In_ ULONG64 cb, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
EXPORTED_FUNCTION
VOID VMMDLL_VfsList_AddDirectory(_In_ HANDLE pFileList, _In_ LPSTR uszName, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
VOID VMMDLL_VfsList_AddDirectoryW(_In_ HANDLE pFileList, _In_ LPWSTR wszName, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
EXPORTED_FUNCTION BOOL VMMDLL_VfsList_IsHandleValid(_In_ HANDLE pFileList);

/*
* List a directory of files in MemProcFS. Directories and files will be listed
* by callbacks into functions supplied in the pFileList parameter.
* If information of an individual file is needed it's neccessary to list all
* files in its directory.
* -- [uw]szPath
* -- pFileList
* -- return
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_VfsListU(_In_ LPSTR  uszPath, _Inout_ PVMMDLL_VFS_FILELIST2 pFileList);
_Success_(return) BOOL VMMDLL_VfsListW(_In_ LPWSTR wszPath, _Inout_ PVMMDLL_VFS_FILELIST2 pFileList);

/*
* List a directory of files in MemProcFS and return a VMMDLL_VFS_FILELISTBLOB.
* CALLER FREE: VMMDLL_MemFree(return)
* -- uszPath
* -- return
*/
EXPORTED_FUNCTION
_Success_(return != NULL) PVMMDLL_VFS_FILELISTBLOB VMMDLL_VfsListBlobU(_In_ LPSTR uszPath);

/*
* Read select parts of a file in MemProcFS.
* -- [uw]szFileName
* -- pb
* -- cb
* -- pcbRead
* -- cbOffset
* -- return
*
*/
EXPORTED_FUNCTION
NTSTATUS VMMDLL_VfsReadU(_In_ LPSTR  uszFileName, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);
NTSTATUS VMMDLL_VfsReadW(_In_ LPWSTR wszFileName, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);

/*
* Write select parts to a file in MemProcFS.
* -- [uw]szFileName
* -- pb
* -- cb
* -- pcbWrite
* -- cbOffset
* -- return
*/
EXPORTED_FUNCTION
NTSTATUS VMMDLL_VfsWriteU(_In_ LPSTR  uszFileName, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);
NTSTATUS VMMDLL_VfsWriteW(_In_ LPWSTR wszFileName, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);

/*
* Utility functions for MemProcFS read/write towards different underlying data
* representations.
*/
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromPBYTE(_In_ PBYTE pbFile, _In_ ULONG64 cbFile, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromQWORD(_In_ ULONG64 qwValue, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset, _In_ BOOL fPrefix);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromDWORD(_In_ DWORD dwValue, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset, _In_ BOOL fPrefix);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromBOOL(_In_ BOOL fValue, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsWriteFile_BOOL(_Inout_ PBOOL pfTarget, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsWriteFile_DWORD(_Inout_ PDWORD pdwTarget, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset, _In_ DWORD dwMinAllow);



//-----------------------------------------------------------------------------
// PLUGIN MANAGER FUNCTIONALITY BELOW:
// Function and structures to initialize and use MemProcFS plugin functionality.
// The plugin manager is started by a call to function:
// VMM_VfsInitializePlugins. Each built-in plugin and external plugin of which
// the DLL name matches m_*.dll will receive a call to its InitializeVmmPlugin
// function. The plugin/module may decide to call pfnPluginManager_Register to
// register plugins in the form of different names one or more times.
// Example of registration function in a plugin DLL below: 
// 'VOID InitializeVmmPlugin(_In_ PVMM_PLUGIN_REGINFO pRegInfo)'
//-----------------------------------------------------------------------------

/*
* Initialize all potential plugins, both built-in and external, that maps into
* MemProcFS. Please note that plugins are not loaded by default - they have to
* be explicitly loaded by calling this function. They will be unloaded on a
* general close of the vmm dll.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_InitializePlugins();

#define VMMDLL_PLUGIN_CONTEXT_MAGIC                 0xc0ffee663df9301c
#define VMMDLL_PLUGIN_CONTEXT_VERSION               4
#define VMMDLL_PLUGIN_REGINFO_MAGIC                 0xc0ffee663df9301d
#define VMMDLL_PLUGIN_REGINFO_VERSION               13
#define VMMDLL_PLUGIN_FORENSIC_JSONDATA_VERSION     0xc0ee0001

#define VMMDLL_PLUGIN_NOTIFY_VERBOSITYCHANGE        0x01
#define VMMDLL_PLUGIN_NOTIFY_REFRESH_FAST           0x05    // refresh fast event   - at partial process refresh.
#define VMMDLL_PLUGIN_NOTIFY_REFRESH_MEDIUM         0x02    // refresh medium event - at full process refresh.
#define VMMDLL_PLUGIN_NOTIFY_REFRESH_SLOW           0x04    // refresh slow event   - at registry refresh.

#define VMMDLL_PLUGIN_NOTIFY_FORENSIC_INIT          0x01000100
#define VMMDLL_PLUGIN_NOTIFY_FORENSIC_INIT_COMPLETE 0x01000200

typedef HANDLE                                      *PVMMDLL_PLUGIN_INTERNAL_CONTEXT;

typedef struct tdVMMDLL_PLUGIN_CONTEXT {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    DWORD dwPID;
    PVOID pProcess;
    LPSTR uszModule;
    LPSTR uszPath;
    PVOID pvReserved1;
    PVMMDLL_PLUGIN_INTERNAL_CONTEXT ctxM;       // optional internal module context.
} VMMDLL_PLUGIN_CONTEXT, *PVMMDLL_PLUGIN_CONTEXT;

typedef struct tdVMMDLL_PLUGIN_FORENSIC_JSONDATA {
    DWORD dwVersion;        // must equal VMMDLL_PLUGIN_FORENSIC_JSONDATA_VERSION
    BOOL fVerbose;
    LPSTR szjType;          // log type/name (json encoded)
    DWORD i;
    DWORD dwPID;
    QWORD vaObj;
    BOOL fva[2];            // log va even if zero
    QWORD va[2];
    BOOL fNum[2];           // log num even if zero
    QWORD qwNum[2];
    BOOL fHex[2];           // log hex even if zero
    QWORD qwHex[2];
    // str: will be prioritized in order: szu > wsz.
    LPCSTR usz[2];          // str: utf-8 encoded
    LPCWSTR wsz[2];         // str: wide
    BYTE _Reserved[0x4000+256];
} VMMDLL_PLUGIN_FORENSIC_JSONDATA, *PVMMDLL_PLUGIN_FORENSIC_JSONDATA;

typedef struct tdVMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM {
    DWORD cMEMs;
    BOOL fValid;
    QWORD paBase;
    PPMEM_SCATTER ppMEMs;
    PVMMDLL_MAP_PFN pPfnMap;
} VMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM, *PVMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM;

typedef struct tdVMMDLL_PLUGIN_REGINFO {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    VMMDLL_MEMORYMODEL_TP tpMemoryModel;
    VMMDLL_SYSTEM_TP tpSystem;
    HMODULE hDLL;
    BOOL(*pfnPluginManager_Register)(struct tdVMMDLL_PLUGIN_REGINFO *pPluginRegInfo);
    DWORD _Reserved[32];
    // python plugin information - not for general use
    struct {
        BOOL fPythonStandalone;
        DWORD _Reserved;
        HMODULE hReservedDllPython3;
        HMODULE hReservedDllPython3X;
    } python;
    // general plugin registration info to be filled out by the plugin below:
    struct {
        PVMMDLL_PLUGIN_INTERNAL_CONTEXT ctxM;   // optional internal module context [must be cleaned by pfnClose() call].
        CHAR uszPathName[128];
        BOOL fRootModule;
        BOOL fProcessModule;
        BOOL fRootModuleHidden;
        BOOL fProcessModuleHidden;
        CHAR sTimelineNameShort[6];
        CHAR _Reserved[2];
        CHAR uszTimelineFile[32];
        CHAR _Reserved2[32];
    } reg_info;
    // function plugin registration info to be filled out by the plugin below:
    struct {
        BOOL(*pfnList)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _Inout_ PHANDLE pFileList);
        NTSTATUS(*pfnRead)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead,  _In_ ULONG64 cbOffset);
        NTSTATUS(*pfnWrite)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);
        VOID(*pfnNotify)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _In_ DWORD fEvent, _In_opt_ PVOID pvEvent, _In_opt_ DWORD cbEvent);
        VOID(*pfnClose)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP);
        BOOL(*pfnVisibleModule)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP);
        PVOID pvReserved[10];
    } reg_fn;
    // Optional forensic plugin functionality for forensic (more comprehensive)
    // analysis of various data. Functions are optional. Functions are called
    // in single-threaded mode regards to the plugin itself - but 'ingest'
    // functions are called in-parallel multi-threaded between plugins.
    // Functions are called in the order of:
    // pfnInitialize(), pfnIngest*(), pfnTimeline(), pfnLogJSON(), pfnFinalize()
    struct {
        PVOID(*pfnInitialize)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP);
        VOID(*pfnFinalize)(_In_opt_ PVOID ctxfc);
        VOID(*pfnTimeline)(
            _In_opt_ PVOID ctxfc,
            _In_ HANDLE hTimeline,
            _In_ VOID(*pfnAddEntry)(_In_ HANDLE hTimeline, _In_ QWORD ft, _In_ DWORD dwAction, _In_ DWORD dwPID, _In_ DWORD dwData32, _In_ QWORD qwData64, _In_ LPSTR uszText),
            _In_ VOID(*pfnEntryAddBySql)(_In_ HANDLE hTimeline, _In_ DWORD cEntrySql, _In_ LPSTR *pszEntrySql));
        VOID(*pfnIngestPhysmem)(_In_opt_ PVOID ctxfc, _In_ PVMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM pIngestPhysmem);
        VOID(*pfnIngestFinalize)(_In_opt_ PVOID ctxfc);
        PVOID pvReserved[10];
        VOID(*pfnLogJSON)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _In_ VOID(*pfnLogJSON)(_In_ PVMMDLL_PLUGIN_FORENSIC_JSONDATA pData));
    } reg_fnfc;
    // Additional system information - read/only by the plugins.
    struct {
        BOOL f32;
        DWORD dwVersionMajor;
        DWORD dwVersionMinor;
        DWORD dwVersionBuild;
        DWORD _Reserved[32];
    } sysinfo;
} VMMDLL_PLUGIN_REGINFO, *PVMMDLL_PLUGIN_REGINFO;



//-----------------------------------------------------------------------------
// VMM CORE FUNCTIONALITY BELOW:
// Vmm core functaionlity such as read (and write) to both virtual and physical
// memory. NB! writing will only work if the target is supported - i.e. not a
// memory dump file...
// To read physical memory specify dwPID as (DWORD)-1
//-----------------------------------------------------------------------------

#define VMMDLL_PID_PROCESS_WITH_KERNELMEMORY        0x80000000      // Combine with dwPID to enable process kernel memory (NB! use with extreme care).

// FLAG used to supress the default read cache in calls to VMM_MemReadEx()
// which will lead to the read being fetched from the target system always.
// Cached page tables (used for translating virtual2physical) are still used.
#define VMMDLL_FLAG_NOCACHE                         0x0001  // do not use the data cache (force reading from memory acquisition device)
#define VMMDLL_FLAG_ZEROPAD_ON_FAIL                 0x0002  // zero pad failed physical memory reads and report success if read within range of physical memory.
#define VMMDLL_FLAG_FORCECACHE_READ                 0x0008  // force use of cache - fail non-cached pages - only valid for reads, invalid with VMM_FLAG_NOCACHE/VMM_FLAG_ZEROPAD_ON_FAIL.
#define VMMDLL_FLAG_NOPAGING                        0x0010  // do not try to retrieve memory from paged out memory from pagefile/compressed (even if possible)
#define VMMDLL_FLAG_NOPAGING_IO                     0x0020  // do not try to retrieve memory from paged out memory if read would incur additional I/O (even if possible).
#define VMMDLL_FLAG_NOCACHEPUT                      0x0100  // do not write back to the data cache upon successful read from memory acquisition device.
#define VMMDLL_FLAG_CACHE_RECENT_ONLY               0x0200  // only fetch from the most recent active cache region when reading.
#define VMMDLL_FLAG_NO_PREDICTIVE_READ              0x0400  // do not perform additional predictive page reads (default on smaller requests).

/*
* Read memory in various non-contigious locations specified by the pointers to
* the items in the ppMEMs array. Result for each unit of work will be given
* individually. No upper limit of number of items to read, but no performance
* boost will be given if above hardware limit. Max size of each unit of work is
* one 4k page (4096 bytes). Reads must not cross 4k page boundaries. Reads must
* start at even DWORDs (4-bytes).
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- ppMEMs = array of scatter read headers.
* -- cpMEMs = count of ppMEMs.
* -- flags = optional flags as given by VMMDLL_FLAG_*
* -- return = the number of successfully read items.
*/
EXPORTED_FUNCTION
DWORD VMMDLL_MemReadScatter(_In_ DWORD dwPID, _Inout_ PPMEM_SCATTER ppMEMs, _In_ DWORD cpMEMs, _In_ DWORD flags);

/*
* Read a single 4096-byte page of memory.
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pbPage
* -- return = success/fail (depending if all requested bytes are read or not).
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemReadPage(_In_ DWORD dwPID, _In_ ULONG64 qwA, _Inout_bytecount_(4096) PBYTE pbPage);

/*
* Read a contigious arbitrary amount of memory.
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pb
* -- cb
* -- return = success/fail (depending if all requested bytes are read or not).
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemRead(_In_ DWORD dwPID, _In_ ULONG64 qwA, _Out_writes_(cb) PBYTE pb, _In_ DWORD cb);

/*
* Read a contigious amount of memory and report the number of bytes read in pcbRead.
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pb
* -- cb
* -- pcbRead
* -- flags = flags as in VMMDLL_FLAG_*
* -- return = success/fail. NB! reads may report as success even if 0 bytes are
*        read - it's recommended to verify pcbReadOpt parameter.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemReadEx(_In_ DWORD dwPID, _In_ ULONG64 qwA, _Out_writes_(cb) PBYTE pb, _In_ DWORD cb, _Out_opt_ PDWORD pcbReadOpt, _In_ ULONG64 flags);

/*
* Prefetch a number of addresses (specified in the pA array) into the memory
* cache. This function is to be used to batch larger known reads into local
* cache before making multiple smaller reads - which will then happen from
* the cache. Function exists for performance reasons.
* -- dwPID = PID of target process, (DWORD)-1 for physical memory.
* -- pPrefetchAddresses = array of addresses to read into cache.
* -- cPrefetchAddresses
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemPrefetchPages(_In_ DWORD dwPID, _In_reads_(cPrefetchAddresses) PULONG64 pPrefetchAddresses, _In_ DWORD cPrefetchAddresses);

/*
* Write a contigious arbitrary amount of memory. Please note some virtual memory
* such as pages of executables (such as DLLs) may be shared between different
* virtual memory over different processes. As an example a write to kernel32.dll
* in one process is likely to affect kernel32 in the whole system - in all
* processes. Heaps and Stacks and other memory are usually safe to write to.
* Please take care when writing to memory!
* -- dwPID = PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pb
* -- cb
* -- return = TRUE on success, FALSE on partial or zero write.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemWrite(_In_ DWORD dwPID, _In_ ULONG64 qwA, _In_reads_(cb) PBYTE pb, _In_ DWORD cb);

/*
* Translate a virtual address to a physical address by walking the page tables
* of the specified process.
* -- dwPID
* -- qwVA
* -- pqwPA
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemVirt2Phys(_In_ DWORD dwPID, _In_ ULONG64 qwVA, _Out_ PULONG64 pqwPA);



//-----------------------------------------------------------------------------
// SIMPLIFIED EASIER TO USE READ SCATTER MEMORY FUNCTIONALITY BELOW:
// The flow is as following:
// 1. Call VMMDLL_Scatter_Initialize to initialize handle.
// 2. Populate memory ranges with multiple calls to VMMDLL_Scatter_Prepare
//    and/or VMMDLL_Scatter_PrepareEx functions. The memory buffer given to
//    VMMDLL_Scatter_PrepareEx will be populated with contents in step (3).
// 3. Retrieve the memory by calling VMMDLL_Scatter_ExecuteRead function.
// 4. If VMMDLL_Scatter_Prepare was used (i.e. not VMMDLL_Scatter_PrepareEx)
//    then retrieve the memory read in (3).
// 5. Clear the handle for reuse by calling VMMDLL_Scatter_Clear alternatively
//    Close the handle to free resources with VMMDLL_Scatter_CloseHandle.
// NB! buffers given to VMMDLL_Scatter_PrepareEx must not be free'd before
//     handle is closed since it may be used internally.
// NB! VMMDLL_Scatter_ExecuteRead may be called at a later point in time to
//     update (re-read) previously read data.
// NB! larger reads (up to 1 GB max) are supported but not recommended.
//-----------------------------------------------------------------------------
typedef HANDLE      VMMDLL_SCATTER_HANDLE;

/*
* Initialize a scatter handle which is used to call VMMDLL_Scatter_* functions.
* CALLER CLOSE: VMMDLL_Scatter_CloseHandle(return)
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- flags = optional flags as given by VMMDLL_FLAG_*
* -- return = handle to be used in VMMDLL_Scatter_* functions.
*/
EXPORTED_FUNCTION _Success_(return != NULL)
VMMDLL_SCATTER_HANDLE VMMDLL_Scatter_Initialize(_In_ DWORD dwPID, _In_ DWORD flags);

/*
* Prepare (add) a memory range for reading. The memory may after a call to
* VMMDLL_Scatter_ExecuteRead() be retrieved with VMMDLL_Scatter_Read().
* -- hS
* -- va = start address of the memory range to read.
* -- cb = size of memory range to read.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Scatter_Prepare(_In_ VMMDLL_SCATTER_HANDLE hS, _In_ QWORD va, _In_ DWORD cb);

/*
* Prepare (add) a memory range for reading. The buffer pb and the read length
* *pcbRead will be populated when VMMDLL_Scatter_ExecuteRead() is later called.
* NB! the buffer pb must not be deallocated before VMMDLL_Scatter_CloseHandle()
*     has been called since it's used internally by the scatter functionality!
* -- hS
* -- va = start address of the memory range to read.
* -- cb = size of memory range to read.
* -- pb = buffer to populate with read memory when calling VMMDLL_Scatter_ExecuteRead()
* -- pcbRead = pointer to be populated with number of bytes successfully read.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Scatter_PrepareEx(_In_ VMMDLL_SCATTER_HANDLE hS, _In_ QWORD va, _In_ DWORD cb, _Out_writes_opt_(cb) PBYTE pb, _Out_opt_ PDWORD pcbRead);

/*
* Retrieve the memory ranges previously populated with calls to the
* VMMDLL_Scatter_Prepare* functions.
* -- hS
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Scatter_ExecuteRead(_In_ VMMDLL_SCATTER_HANDLE hS);

/*
* Read out memory in previously populated ranges. This function should only be
* called after the memory has been retrieved using VMMDLL_Scatter_ExecuteRead().
* -- hS
* -- va
* -- cb
* -- pb
* -- pcbRead
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Scatter_Read(_In_ VMMDLL_SCATTER_HANDLE hS, _In_ QWORD va, _In_ DWORD cb, _Out_writes_opt_(cb) PBYTE pb, _Out_opt_ PDWORD pcbRead);

/*
* Clear/Reset the handle for use in another subsequent read scatter operation.
* -- hS = the scatter handle to clear for reuse.
* -- dwPID
* -- flags
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Scatter_Clear(_In_ VMMDLL_SCATTER_HANDLE hS, _In_ DWORD dwPID, _In_ DWORD flags);

/*
* Close the scatter handle and free the resources it uses.
* -- hS = the scatter handle to close.
*/
EXPORTED_FUNCTION
VOID VMMDLL_Scatter_CloseHandle(_In_opt_ _Post_ptr_invalid_ VMMDLL_SCATTER_HANDLE hS);



//-----------------------------------------------------------------------------
// VMM PROCESS MAP FUNCTIONALITY BELOW:
// Functionality for retrieving process related collections of items such as
// page table map (PTE), virtual address descriptor map (VAD), loaded modules,
// heaps and threads.
//-----------------------------------------------------------------------------

#define VMMDLL_MAP_PTE_VERSION              2
#define VMMDLL_MAP_VAD_VERSION              6
#define VMMDLL_MAP_VADEX_VERSION            3
#define VMMDLL_MAP_MODULE_VERSION           5
#define VMMDLL_MAP_UNLOADEDMODULE_VERSION   2
#define VMMDLL_MAP_EAT_VERSION              2
#define VMMDLL_MAP_IAT_VERSION              2
#define VMMDLL_MAP_HEAP_VERSION             2
#define VMMDLL_MAP_THREAD_VERSION           3
#define VMMDLL_MAP_HANDLE_VERSION           2
#define VMMDLL_MAP_POOL_VERSION             1
#define VMMDLL_MAP_NET_VERSION              3
#define VMMDLL_MAP_PHYSMEM_VERSION          2
#define VMMDLL_MAP_USER_VERSION             2
#define VMMDLL_MAP_SERVICE_VERSION          3

// flags to check for existence in the fPage field of VMMDLL_MAP_PTEENTRY
#define VMMDLL_MEMMAP_FLAG_PAGE_W          0x0000000000000002
#define VMMDLL_MEMMAP_FLAG_PAGE_NS         0x0000000000000004
#define VMMDLL_MEMMAP_FLAG_PAGE_NX         0x8000000000000000
#define VMMDLL_MEMMAP_FLAG_PAGE_MASK       0x8000000000000006

typedef enum tdVMMDLL_PTE_TP {
    VMMDLL_PTE_TP_NA = 0,
    VMMDLL_PTE_TP_HARDWARE = 1,
    VMMDLL_PTE_TP_TRANSITION = 2,
    VMMDLL_PTE_TP_PROTOTYPE = 3,
    VMMDLL_PTE_TP_DEMANDZERO = 4,
    VMMDLL_PTE_TP_COMPRESSED = 5,
    VMMDLL_PTE_TP_PAGEFILE = 6,
} VMMDLL_PTE_TP, *PVMMDLL_PTE_TP;

typedef struct tdVMMDLL_MAP_PTEENTRY {
    QWORD vaBase;
    QWORD cPages;
    QWORD fPage;
    BOOL  fWoW64;
    DWORD _FutureUse1;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _Reserved1;
    DWORD cSoftware;    // # software (non active) PTEs in region
} VMMDLL_MAP_PTEENTRY, *PVMMDLL_MAP_PTEENTRY;

typedef struct tdVMMDLL_MAP_VADENTRY {
    QWORD vaStart;
    QWORD vaEnd;
    QWORD vaVad;
    // DWORD 0
    DWORD VadType           : 3;   // Pos 0
    DWORD Protection        : 5;   // Pos 3
    DWORD fImage            : 1;   // Pos 8
    DWORD fFile             : 1;   // Pos 9
    DWORD fPageFile         : 1;   // Pos 10
    DWORD fPrivateMemory    : 1;   // Pos 11
    DWORD fTeb              : 1;   // Pos 12
    DWORD fStack            : 1;   // Pos 13
    DWORD fSpare            : 2;   // Pos 14
    DWORD HeapNum           : 7;   // Pos 16
    DWORD fHeap             : 1;   // Pos 23
    DWORD cwszDescription   : 8;   // Pos 24
    // DWORD 1
    DWORD CommitCharge      : 31;   // Pos 0
    DWORD MemCommit         : 1;    // Pos 31
    DWORD u2;
    DWORD cbPrototypePte;
    QWORD vaPrototypePte;
    QWORD vaSubsection;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse1;
    DWORD _Reserved1;
    QWORD vaFileObject;             // only valid if fFile/fImage _and_ after wszText is initialized
    DWORD cVadExPages;              // number of "valid" VadEx pages in this VAD.
    DWORD cVadExPagesBase;          // number of "valid" VadEx pages in "previous" VADs
    QWORD _Reserved2;
} VMMDLL_MAP_VADENTRY, *PVMMDLL_MAP_VADENTRY;

typedef struct tdVMMDLL_MAP_VADEXENTRY {
    VMMDLL_PTE_TP tp;
    DWORD iPML;
    QWORD va;
    QWORD pa;
    QWORD pte;
    struct {
        DWORD _Reserved1;
        VMMDLL_PTE_TP tp;
        QWORD pa;
        QWORD pte;
    } proto;
    QWORD vaVadBase;
} VMMDLL_MAP_VADEXENTRY, *PVMMDLL_MAP_VADEXENTRY;

typedef enum tdVMMDLL_MODULE_TP {
    VMMDLL_MODULE_TP_NORMAL = 0,
    VMMDLL_MODULE_TP_DATA = 1,
    VMMDLL_MODULE_TP_NOTLINKED = 2,
    VMMDLL_MODULE_TP_INJECTED = 3,
} VMMDLL_MODULE_TP;

typedef struct tdVMMDLL_MAP_MODULEENTRY {
    QWORD vaBase;
    QWORD vaEntry;
    DWORD cbImageSize;
    BOOL  fWoW64;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _Reserved3;
    DWORD _Reserved4;
    union { LPSTR  uszFullName; LPWSTR wszFullName; };      // U/W dependant
    VMMDLL_MODULE_TP tp;
    DWORD cbFileSizeRaw;
    DWORD cSection;
    DWORD cEAT;
    DWORD cIAT;
    DWORD _Reserved2;
    QWORD _Reserved1[2];
} VMMDLL_MAP_MODULEENTRY, *PVMMDLL_MAP_MODULEENTRY;

typedef struct tdVMMDLL_MAP_UNLOADEDMODULEENTRY {
    QWORD vaBase;
    DWORD cbImageSize;
    BOOL  fWoW64;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse1;
    DWORD dwCheckSum;               // user-mode only
    DWORD dwTimeDateStamp;          // user-mode only
    DWORD _Reserved1;
    QWORD ftUnload;                 // kernel-mode only
} VMMDLL_MAP_UNLOADEDMODULEENTRY, *PVMMDLL_MAP_UNLOADEDMODULEENTRY;

typedef struct tdVMMDLL_MAP_EATENTRY {
    QWORD vaFunction;
    DWORD dwOrdinal;
    DWORD oFunctionsArray;          // PIMAGE_EXPORT_DIRECTORY->AddressOfFunctions[oFunctionsArray]
    DWORD oNamesArray;              // PIMAGE_EXPORT_DIRECTORY->AddressOfNames[oNamesArray]
    DWORD _FutureUse1;
    union { LPSTR  uszFunction; LPWSTR wszFunction; };      // U/W dependant
} VMMDLL_MAP_EATENTRY, *PVMMDLL_MAP_EATENTRY;

typedef struct tdVMMDLL_MAP_IATENTRY {
    QWORD vaFunction;
    union { LPSTR  uszFunction; LPWSTR wszFunction; };      // U/W dependant
    DWORD _FutureUse1;
    DWORD _FutureUse2;
    union { LPSTR  uszModule; LPWSTR wszModule; };          // U/W dependant
    struct {
        BOOL f32;
        WORD wHint;
        WORD _Reserved1;
        DWORD rvaFirstThunk;
        DWORD rvaOriginalFirstThunk;
        DWORD rvaNameModule;
        DWORD rvaNameFunction;
    } Thunk;
} VMMDLL_MAP_IATENTRY, *PVMMDLL_MAP_IATENTRY;

typedef struct tdVMMDLL_MAP_HEAPENTRY {
    QWORD vaHeapSegment;
    DWORD cPages;
    DWORD cPagesUnCommitted : 24;
    DWORD HeapId : 7;
    DWORD fPrimary : 1;
} VMMDLL_MAP_HEAPENTRY, *PVMMDLL_MAP_HEAPENTRY;

typedef struct tdVMMDLL_MAP_THREADENTRY {
    DWORD dwTID;
    DWORD dwPID;
    DWORD dwExitStatus;
    UCHAR bState;
    UCHAR bRunning;
    UCHAR bPriority;
    UCHAR bBasePriority;
    QWORD vaETHREAD;
    QWORD vaTeb;
    QWORD ftCreateTime;
    QWORD ftExitTime;
    QWORD vaStartAddress;
    QWORD vaStackBaseUser;          // value from _NT_TIB / _TEB
    QWORD vaStackLimitUser;         // value from _NT_TIB / _TEB
    QWORD vaStackBaseKernel;
    QWORD vaStackLimitKernel;
    QWORD vaTrapFrame;
    QWORD vaRIP;                    // RIP register (if user mode)
    QWORD vaRSP;                    // RSP register (if user mode)
    QWORD qwAffinity;
    DWORD dwUserTime;
    DWORD dwKernelTime;
    UCHAR bSuspendCount;
    UCHAR _FutureUse1[3];
    DWORD _FutureUse2[15];
} VMMDLL_MAP_THREADENTRY, *PVMMDLL_MAP_THREADENTRY;

typedef struct tdVMMDLL_MAP_HANDLEENTRY {
    QWORD vaObject;
    DWORD dwHandle;
    DWORD dwGrantedAccess : 24;
    DWORD iType : 8;
    QWORD qwHandleCount;
    QWORD qwPointerCount;
    QWORD vaObjectCreateInfo;
    QWORD vaSecurityDescriptor;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse2;
    DWORD dwPID;
    DWORD dwPoolTag;
    DWORD _FutureUse[5];
    union { LPSTR  uszType; LPWSTR wszType; QWORD _Pad1; }; // U/W dependant
} VMMDLL_MAP_HANDLEENTRY, *PVMMDLL_MAP_HANDLEENTRY;

typedef enum tdVMMDLL_MAP_POOL_TYPE {
    VMMDLL_MAP_POOL_TYPE_Unknown         = 0,
    VMMDLL_MAP_POOL_TYPE_NonPagedPool    = 1,
    VMMDLL_MAP_POOL_TYPE_NonPagedPoolNx  = 2,
    VMMDLL_MAP_POOL_TYPE_PagedPool       = 3
} VMMDLL_MAP_POOL_TYPE;

typedef enum tdVMM_MAP_POOL_TYPE_SUBSEGMENT {
    VMM_MAP_POOL_TYPE_SUBSEGMENT_UNKNOWN = 0,
    VMM_MAP_POOL_TYPE_SUBSEGMENT_NA      = 1,
    VMM_MAP_POOL_TYPE_SUBSEGMENT_BIG     = 2,
    VMM_MAP_POOL_TYPE_SUBSEGMENT_LARGE   = 3,
    VMM_MAP_POOL_TYPE_SUBSEGMENT_VS      = 4,
    VMM_MAP_POOL_TYPE_SUBSEGMENT_LFH     = 5
} VMM_MAP_POOL_TYPE_SUBSEGMENT;

typedef struct tdVMMDLL_MAP_POOLENTRYTAG {
    union {
        CHAR szTag[5];
        struct {
            DWORD dwTag;
            DWORD _Filler;
            DWORD cEntry;
            DWORD iTag2Map;
        };
    };
} VMMDLL_MAP_POOLENTRYTAG, *PVMMDLL_MAP_POOLENTRYTAG;

typedef struct tdVMMDLL_MAP_POOLENTRY {
    QWORD va;
    union {
        CHAR szTag[5];
        struct {
            DWORD dwTag;
            BYTE _ReservedZero;
            BYTE fAlloc;
            BYTE tpPool;    // VMMDLL_MAP_POOL_TYPE
            BYTE tpSS;      // VMMDLL_MAP_POOL_TYPE_SUBSEGMENT
        };
    };
    DWORD cb;
    DWORD _Filler;
} VMMDLL_MAP_POOLENTRY, *PVMMDLL_MAP_POOLENTRY;

typedef struct tdVMMDLL_MAP_NETENTRY {
    DWORD dwPID;
    DWORD dwState;
    WORD _FutureUse3[3];
    WORD AF;                        // address family (IPv4/IPv6)
    struct {
        BOOL fValid;
        WORD _Reserved;
        WORD port;
        BYTE pbAddr[16];            // ipv4 = 1st 4 bytes, ipv6 = all bytes
        union { LPSTR  uszText; LPWSTR wszText; };          // U/W dependant
    } Src;
    struct {
        BOOL fValid;
        WORD _Reserved;
        WORD port;
        BYTE pbAddr[16];            // ipv4 = 1st 4 bytes, ipv6 = all bytes
        union { LPSTR  uszText; LPWSTR wszText; };          // U/W dependant
    } Dst;
    QWORD vaObj;
    QWORD ftTime;
    DWORD dwPoolTag;
    DWORD _FutureUse4;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse2[4];
} VMMDLL_MAP_NETENTRY, *PVMMDLL_MAP_NETENTRY;

typedef struct tdVMMDLL_MAP_PHYSMEMENTRY {
    QWORD pa;
    QWORD cb;
} VMMDLL_MAP_PHYSMEMENTRY, *PVMMDLL_MAP_PHYSMEMENTRY;

typedef struct tdVMMDLL_MAP_USERENTRY {
    DWORD _FutureUse1[2];
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    ULONG64 vaRegHive;
    union { LPSTR  uszSID; LPWSTR wszSID; };                // U/W dependant
    DWORD _FutureUse2[2];
} VMMDLL_MAP_USERENTRY, *PVMMDLL_MAP_USERENTRY;

typedef struct tdVMMDLL_MAP_SERVICEENTRY {
    QWORD vaObj;
    DWORD dwOrdinal;
    DWORD dwStartType;
    SERVICE_STATUS ServiceStatus;
    union { LPSTR  uszServiceName; LPWSTR wszServiceName; QWORD _Reserved1; };  // U/W dependant
    union { LPSTR  uszDisplayName; LPWSTR wszDisplayName; QWORD _Reserved2; };  // U/W dependant
    union { LPSTR  uszPath;        LPWSTR wszPath;        QWORD _Reserved3; };  // U/W dependant
    union { LPSTR  uszUserTp;      LPWSTR wszUserTp;      QWORD _Reserved4; };  // U/W dependant
    union { LPSTR  uszUserAcct;    LPWSTR wszUserAcct;    QWORD _Reserved5; };  // U/W dependant
    union { LPSTR  uszImagePath;   LPWSTR wszImagePath;   QWORD _Reserved6; };  // U/W dependant
    DWORD dwPID;
    DWORD _FutureUse1;
    QWORD _FutureUse2;
} VMMDLL_MAP_SERVICEENTRY, *PVMMDLL_MAP_SERVICEENTRY;

typedef struct tdVMMDLL_MAP_PTE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // NULL or multi-wstr pointed into by VMMDLL_MAP_VADENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_PTEENTRY pMap[];     // map entries.
} VMMDLL_MAP_PTE, *PVMMDLL_MAP_PTE;

typedef struct tdVMMDLL_MAP_VAD {
    DWORD dwVersion;
    DWORD _Reserved1[4];
    DWORD cPage;                    // # pages in vad map.
    PBYTE pbMultiText;              // NULL or multi-wstr pointed into by VMMDLL_MAP_VADENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_VADENTRY pMap[];     // map entries.
} VMMDLL_MAP_VAD, *PVMMDLL_MAP_VAD;

typedef struct tdVMMDLL_MAP_VADEX {
    DWORD dwVersion;
    DWORD _Reserved1[4];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_VADEXENTRY pMap[];   // map entries.
} VMMDLL_MAP_VADEX, *PVMMDLL_MAP_VADEX;

typedef struct tdVMMDLL_MAP_MODULE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_MODULEENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_MODULEENTRY pMap[];  // map entries.
} VMMDLL_MAP_MODULE, *PVMMDLL_MAP_MODULE;

typedef struct tdVMMDLL_MAP_UNLOADEDMODULE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_MODULEENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_UNLOADEDMODULEENTRY pMap[];  // map entries.
} VMMDLL_MAP_UNLOADEDMODULE, *PVMMDLL_MAP_UNLOADEDMODULE;

typedef struct tdVMMDLL_MAP_EAT {
    DWORD dwVersion;
    DWORD dwOrdinalBase;
    DWORD cNumberOfNames;
    DWORD cNumberOfFunctions;
    DWORD _Reserved1[4];
    QWORD vaModuleBase;
    QWORD vaAddressOfFunctions;
    QWORD vaAddressOfNames;
    PBYTE pbMultiText;              // multi-str pointed into by VMM_MAP_EATENTRY.wszFunction
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_EATENTRY pMap[];     // map entries.
} VMMDLL_MAP_EAT, *PVMMDLL_MAP_EAT;

typedef struct tdVMMDLL_MAP_IAT {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    QWORD vaModuleBase;
    PBYTE pbMultiText;              // multi-str pointed into by VMM_MAP_EATENTRY.[wszFunction|wszModule]
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_IATENTRY pMap[];     // map entries.
} VMMDLL_MAP_IAT, *PVMMDLL_MAP_IAT;

typedef struct tdVMMDLL_MAP_HEAP {
    DWORD dwVersion;
    DWORD _Reserved1[8];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_HEAPENTRY pMap[];    // map entries.
} VMMDLL_MAP_HEAP, *PVMMDLL_MAP_HEAP;

typedef struct tdVMMDLL_MAP_THREAD {
    DWORD dwVersion;
    DWORD _Reserved[8];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_THREADENTRY pMap[];  // map entries.
} VMMDLL_MAP_THREAD, *PVMMDLL_MAP_THREAD;

typedef struct tdVMMDLL_MAP_HANDLE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_HANDLEENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_HANDLEENTRY pMap[];  // map entries.
} VMMDLL_MAP_HANDLE, *PVMMDLL_MAP_HANDLE;

typedef struct tdVMMDLL_MAP_POOL {
    DWORD dwVersion;
    DWORD _Reserved1[7];
    PDWORD piTag2Map;               // dword map array (size: cMap): tag index to map index.
    PVMMDLL_MAP_POOLENTRYTAG pTag;  // tag entries.
    DWORD cTag;                     // # tag entries.
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_POOLENTRY pMap[];    // map entries.
} VMMDLL_MAP_POOL, *PVMMDLL_MAP_POOL;

typedef struct tdVMMDLL_MAP_NET {
    DWORD dwVersion;
    DWORD _Reserved1;
    PBYTE pbMultiText;              // multi-wstr pointed into by VMM_MAP_NETENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_NETENTRY pMap[];     // map entries.
} VMMDLL_MAP_NET, *PVMMDLL_MAP_NET;

typedef struct tdVMMDLL_MAP_PHYSMEM {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    DWORD cMap;                     // # map entries.
    DWORD _Reserved2;
    VMMDLL_MAP_PHYSMEMENTRY pMap[]; // map entries.
} VMMDLL_MAP_PHYSMEM, *PVMMDLL_MAP_PHYSMEM;

typedef struct tdVMMDLL_MAP_USER {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_USERENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_USERENTRY pMap[];    // map entries.
} VMMDLL_MAP_USER, *PVMMDLL_MAP_USER;

typedef struct tdVMMDLL_MAP_SERVICE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_SERVICEENTRY.wsz*
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_SERVICEENTRY pMap[]; // map entries.
} VMMDLL_MAP_SERVICE, *PVMMDLL_MAP_SERVICE;

/*
* Retrieve the memory map entries based on hardware page tables (PTE) for the
* process. If pPteMap is set to NULL the number of bytes required will be
* returned in parameter pcbPteMap.
* Entries returned are sorted on VMMDLL_MAP_PTEENTRY.vaBase
* -- dwPID
* -- pPteMap = buffer of minimum byte length *pcbPteMap or NULL.
* -- pcbPteMap = pointer to byte count of pPteMap buffer.
* -- fIdentifyModules = try identify modules as well (= slower)
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetPteU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbPteMap) PVMMDLL_MAP_PTE pPteMap, _Inout_ PDWORD pcbPteMap, _In_ BOOL fIdentifyModules);
_Success_(return) BOOL VMMDLL_Map_GetPteW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbPteMap) PVMMDLL_MAP_PTE pPteMap, _Inout_ PDWORD pcbPteMap, _In_ BOOL fIdentifyModules);

/*
* Retrieve memory map entries based on virtual address descriptor (VAD) for
* the process. If pVadMap is set to NULL the number of bytes required
* will be returned in parameter pcbVadMap.
* Entries returned are sorted on VMMDLL_MAP_VADENTRY.vaStart
* -- dwPID
* -- pVadMap = buffer of minimum byte length *pcbVadMap or NULL.
* -- pcbVadMap = pointer to byte count of pVadMap buffer.
* -- fIdentifyModules = try identify modules as well (= slower)
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetVadU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbVadMap) PVMMDLL_MAP_VAD pVadMap, _Inout_ PDWORD pcbVadMap, _In_ BOOL fIdentifyModules);
_Success_(return) BOOL VMMDLL_Map_GetVadW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbVadMap) PVMMDLL_MAP_VAD pVadMap, _Inout_ PDWORD pcbVadMap, _In_ BOOL fIdentifyModules);

/*
* Retrieve extended memory map information about a select sub-set of the memory
* map. If pVadExMap is set to NULL the number of bytes required will be
* returned in the parameter pcbVadExMap.
* -- dwPID
* -- pVadExMap = buffer of minimum byte length *pcbVadExMap or NULL.
* -- pcbVadExMap = pointer to byte count of pVadExMap buffer.
* -- oPage = offset in number of pages from process start.
* -- cPage = number of pages to process from oPages base.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Map_GetVadEx(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbVadExMap) PVMMDLL_MAP_VADEX pVadExMap, _Inout_ PDWORD pcbVadExMap, _In_ DWORD oPage, _In_ DWORD cPage);

/*
* Retrieve the modules (.dlls) for the specified process. If pModuleMap is set
* to NULL the number of bytes required will be returned in parameter pcbModuleMap.
* -- dwPID
* -- pModuleMap = buffer of minimum byte length *pcbModuleMap or NULL.
* -- pcbModuleMap = pointer to byte count of pModuleMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetModuleU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbModuleMap) PVMMDLL_MAP_MODULE pModuleMap, _Inout_ PDWORD pcbModuleMap);
_Success_(return) BOOL VMMDLL_Map_GetModuleW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbModuleMap) PVMMDLL_MAP_MODULE pModuleMap, _Inout_ PDWORD pcbModuleMap);

/*
* Retrieve a module (.dll) entry given a process and module name.
* If pModuleMapEntry is set to NULL the number of bytes required
* will be returned in parameter pcbModuleMapEntry.
* If pcbModuleMapEntry is set to NULL the pModuleMapEntry is assumed to be of
* size sizeof(VMMDLL_MAP_MODULEENTRY) and data without names will be copied.
* -- dwPID
* -- [uw]szModuleName = module name (or ""/NULL for 1st module entry).
* -- pModuleMapEntry = buffer of minimum byte length *pcbModuleMapEntry or NULL.
* -- pcbModuleMapEntry = pointer to byte count of pModuleMapEntry buffer or NULL.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetModuleFromNameU(_In_ DWORD dwPID, _In_opt_ LPSTR  uszModuleName, _Out_writes_bytes_opt_(*pcbModuleMapEntry) PVMMDLL_MAP_MODULEENTRY pModuleMapEntry, _Inout_opt_ PDWORD pcbModuleMapEntry);
_Success_(return) BOOL VMMDLL_Map_GetModuleFromNameW(_In_ DWORD dwPID, _In_opt_ LPWSTR wszModuleName, _Out_writes_bytes_opt_(*pcbModuleMapEntry) PVMMDLL_MAP_MODULEENTRY pModuleMapEntry, _Inout_opt_ PDWORD pcbModuleMapEntry);

/*
* Retrieve the unloaded modules (.dll/.sys) for the specified process. If
* pUnloadedModuleMap is set to NULL the number of bytes required will be
* returned in parameter pcbUnloadedModuleMap.
* -- dwPID
* -- pUnloadedModuleMap = buffer of minimum byte length *pcbUnloadedModuleMap or NULL.
* -- pcbUnloadedModuleMap = pointer to byte count of pUnloadedModuleMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetUnloadedModuleU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbUnloadedModuleMap) PVMMDLL_MAP_UNLOADEDMODULE pUnloadedModuleMap, _Inout_ PDWORD pcbUnloadedModuleMap);
_Success_(return) BOOL VMMDLL_Map_GetUnloadedModuleW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbUnloadedModuleMap) PVMMDLL_MAP_UNLOADEDMODULE pUnloadedModuleMap, _Inout_ PDWORD pcbUnloadedModuleMap);

/*
* Retrieve the module exported functions from the export address table (EAT).
* If pEatMap is set to NULL the number of bytes required will be returned in
* parameter pcbEatMap.
* -- dwPID
* -- [uw]szModuleName
* -- pEatMap = buffer of minimum byte length *pcbEatMap or NULL.
* -- pcbEatMap = pointer to byte count of pEatMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetEATU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _Out_writes_bytes_opt_(*pcbEatMap) PVMMDLL_MAP_EAT pEatMap, _Inout_ PDWORD pcbEatMap);
_Success_(return) BOOL VMMDLL_Map_GetEATW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _Out_writes_bytes_opt_(*pcbEatMap) PVMMDLL_MAP_EAT pEatMap, _Inout_ PDWORD pcbEatMap);

/*
* Retrieve the module imported functions from the import address table (IAT).
* If pIatMap is set to NULL the number of bytes required will be returned in
* parameter pcbIatMap.
* -- dwPID
* -- [uw]szModuleName
* -- pIatMap = buffer of minimum byte length *pcbIatMap or NULL.
* -- pcbIatMap = pointer to byte count of pIatMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetIATU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _Out_writes_bytes_opt_(*pcbIatMap) PVMMDLL_MAP_IAT pIatMap, _Inout_ PDWORD pcbIatMap);
_Success_(return) BOOL VMMDLL_Map_GetIATW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _Out_writes_bytes_opt_(*pcbIatMap) PVMMDLL_MAP_IAT pIatMap, _Inout_ PDWORD pcbIatMap);

/*
* Retrieve the heaps for the specified process. If pHeapMap is set to NULL
* the number of bytes required will be returned in parameter pcbHeapMap.
* -- dwPID
* -- pHeapMap = buffer of minimum byte length *pcbHeapMap or NULL.
* -- pcbHeapMap = pointer to byte count of pHeapMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetHeap(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbHeapMap) PVMMDLL_MAP_HEAP pHeapMap, _Inout_ PDWORD pcbHeapMap);

/*
* Retrieve the threads for the specified process. If pThreadMap is set to NULL
* the number of bytes required will be returned in parameter pcbThreadMap.
* Entries returned are sorted on VMMDLL_MAP_THREADENTRY.dwTID
* -- dwPID
* -- pThreadMap = buffer of minimum byte length *pcbThreadMap or NULL.
* -- pcbThreadMap = pointer to byte count of pThreadMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetThread(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbThreadMap) PVMMDLL_MAP_THREAD pThreadMap, _Inout_ PDWORD pcbThreadMap);

/*
* Retrieve the handles for the specified process. If pHandleMap is set to NULL
* the number of bytes required will be returned in parameter pcbHandleMap.
* Entries returned are sorted on VMMDLL_MAP_HANDLEENTRY.dwHandle
* -- dwPID
* -- pHandleMap = buffer of minimum byte length *pcbHandleMap or NULL.
* -- pcbHandleMap = pointer to byte count of pHandleMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetHandleU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbHandleMap) PVMMDLL_MAP_HANDLE pHandleMap, _Inout_ PDWORD pcbHandleMap);
_Success_(return) BOOL VMMDLL_Map_GetHandleW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbHandleMap) PVMMDLL_MAP_HANDLE pHandleMap, _Inout_ PDWORD pcbHandleMap);

/*
* Retrieve the physical memory ranges from the physical memory map that Windows
* have enumerated.
* -- pPhysMemMap = buffer of minimum byte length *pcbPhysMemMap or NULL.
* -- pcbPhysMemMap = pointer to byte count of pPhysMemMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetPhysMem(_Out_writes_bytes_opt_(*pcbPhysMemMap) PVMMDLL_MAP_PHYSMEM pPhysMemMap, _Inout_ PDWORD pcbPhysMemMap);

/*
* Retrieve the pool map - consisting of kernel allocated pool entries.
* The pool map pMap is sorted by allocation virtual address.
* The pool map pTag is sorted by pool tag.
* NB! The pool map may contain both false negatives/positives.
* -- pPoolMap = buffer of minimum byte length *pcbPoolMap or NULL.
* -- pcbPoolMap = pointer to byte count of pPoolMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetPool(_Out_writes_bytes_opt_(*pcbPoolMap) PVMMDLL_MAP_POOL pPoolMap, _Inout_ PDWORD pcbPoolMap);

/*
* Retrieve the network connection map - consisting of active network connections,
* listening sockets and other networking functionality.
* -- pNetMap = buffer of minimum byte length *pcbNetMap or NULL.
* -- pcbNetMap = pointer to byte count of pNetMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetNetU(_Out_writes_bytes_opt_(*pcbNetMap) PVMMDLL_MAP_NET pNetMap, _Inout_ PDWORD pcbNetMap);
_Success_(return) BOOL VMMDLL_Map_GetNetW(_Out_writes_bytes_opt_(*pcbNetMap) PVMMDLL_MAP_NET pNetMap, _Inout_ PDWORD pcbNetMap);

/*
* Retrieve the non well known users that are detected in the target system.
* NB! There may be more users in the system than the ones that are detected,
* only users with mounted registry hives may currently be detected - this is
* the normal behaviour for users with active processes.
* -- pUserMap = buffer of minimum byte length *pcbUserMap or NULL.
* -- pcbUserMap = pointer to byte count of pUserMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetUsersU(_Out_writes_bytes_opt_(*pcbUserMap) PVMMDLL_MAP_USER pUserMap, _Inout_ PDWORD pcbUserMap);
_Success_(return) BOOL VMMDLL_Map_GetUsersW(_Out_writes_bytes_opt_(*pcbUserMap) PVMMDLL_MAP_USER pUserMap, _Inout_ PDWORD pcbUserMap);

/*
* Retrieve the services currently known by the service control manager (SCM).
* -- pServiceMap = buffer of minimum byte length *pcbServiceMap or NULL.
* -- pcbServiceMap = pointer to byte count of pServiceMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetServicesU(_Out_writes_bytes_opt_(*pcbServiceMap) PVMMDLL_MAP_SERVICE pServiceMap, _Inout_ PDWORD pcbServiceMap);
_Success_(return) BOOL VMMDLL_Map_GetServicesW(_Out_writes_bytes_opt_(*pcbServiceMap) PVMMDLL_MAP_SERVICE pServiceMap, _Inout_ PDWORD pcbServiceMap);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC PAGE FRAME NUMBER (PFN) FUNCTIONALITY BELOW
//-----------------------------------------------------------------------------

#define VMMDLL_MAP_PFN_VERSION              1

static LPCSTR VMMDLL_PFN_TYPE_TEXT[] = { "Zero", "Free", "Standby", "Modifiy", "ModNoWr", "Bad", "Active", "Transit" };
static LPCSTR VMMDLL_PFN_TYPEEXTENDED_TEXT[] = { "-", "Unused", "ProcPriv", "PageTable", "LargePage", "DriverLock", "Shareable", "File" };

typedef enum tdVMMDLL_MAP_PFN_TYPE {
    VmmDll_PfnTypeZero = 0,
    VmmDll_PfnTypeFree = 1,
    VmmDll_PfnTypeStandby = 2,
    VmmDll_PfnTypeModified = 3,
    VmmDll_PfnTypeModifiedNoWrite = 4,
    VmmDll_PfnTypeBad = 5,
    VmmDll_PfnTypeActive = 6,
    VmmDll_PfnTypeTransition = 7
} VMMDLL_MAP_PFN_TYPE;

typedef enum tdVMMDLL_MAP_PFN_TYPEEXTENDED {
    VmmDll_PfnExType_Unknown = 0,
    VmmDll_PfnExType_Unused = 1,
    VmmDll_PfnExType_ProcessPrivate = 2,
    VmmDll_PfnExType_PageTable = 3,
    VmmDll_PfnExType_LargePage = 4,
    VmmDll_PfnExType_DriverLocked = 5,
    VmmDll_PfnExType_Shareable = 6,
    VmmDll_PfnExType_File = 7,
} VMMDLL_MAP_PFN_TYPEEXTENDED;

typedef struct tdVMMDLL_MAP_PFNENTRY {
    DWORD dwPfn;
    VMMDLL_MAP_PFN_TYPEEXTENDED tpExtended;
    struct {        // Only valid if active non-prototype PFN
        union {
            DWORD dwPid;
            DWORD dwPfnPte[5];  // PFN of paging levels 1-4 (x64)
        };
        QWORD va;               // valid if non-zero
    } AddressInfo;
    QWORD vaPte;
    QWORD OriginalPte;
    union {
        DWORD _u3;
        struct {
            WORD ReferenceCount;
            // MMPFNENTRY
            BYTE PageLocation       : 3;    // Pos 0  - VMMDLL_MAP_PFN_TYPE
            BYTE WriteInProgress    : 1;    // Pos 3
            BYTE Modified           : 1;    // Pos 4
            BYTE ReadInProgress     : 1;    // Pos 5
            BYTE CacheAttribute     : 2;    // Pos 6
            BYTE Priority           : 3;    // Pos 0
            BYTE Rom_OnProtectedStandby : 1;// Pos 3
            BYTE InPageError        : 1;    // Pos 4
            BYTE KernelStack_SystemChargedPage : 1; // Pos 5
            BYTE RemovalRequested   : 1;    // Pos 6
            BYTE ParityError        : 1;    // Pos 7
        };
    };
    union {
        QWORD _u4;
        struct {
            DWORD PteFrame;
            DWORD PteFrameHigh      : 4;    // Pos 32
            DWORD _Reserved         : 21;   // Pos 36
            DWORD PrototypePte      : 1;    // Pos 57
            DWORD PageColor         : 6;    // Pos 58
        };
    };
    DWORD _FutureUse[6];
} VMMDLL_MAP_PFNENTRY, *PVMMDLL_MAP_PFNENTRY;

typedef struct tdVMMDLL_MAP_PFN {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_PFNENTRY pMap[];     // map entries.
} VMMDLL_MAP_PFN, *PVMMDLL_MAP_PFN;

/*
* Retrieve information about scattered PFNs. The PFNs are returned in order of
* in which they are stored in the pPfns set.
* -- pPfns
* -- cPfns
* -- pPfnMap = buffer of minimum byte length *pcbPfnMap or NULL.
* -- pcbPfnMap = pointer to byte count of pPhysMemMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Map_GetPfn(_In_ DWORD pPfns[], _In_ DWORD cPfns, _Out_writes_bytes_opt_(*pcbPfnMap) PVMMDLL_MAP_PFN pPfnMap, _Inout_ PDWORD pcbPfnMap);



//-----------------------------------------------------------------------------
// VMM PROCESS FUNCTIONALITY BELOW:
// Functionality below is mostly relating to Windows processes.
//-----------------------------------------------------------------------------

/*
* Retrieve an active process given it's name. Please note that if multiple
* processes with the same name exists only one will be returned. If required to
* parse all processes with the same name please iterate over the PID list by
* calling VMMDLL_PidList together with VMMDLL_ProcessGetInformation.
* -- szProcName = process name case insensitive.
* -- pdwPID = pointer that will receive PID on success.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PidGetFromName(_In_ LPSTR szProcName, _Out_ PDWORD pdwPID);

/*
* List the PIDs in the system.
* -- pPIDs = DWORD array of at least number of PIDs in system, or NULL.
* -- pcPIDs = size of (in number of DWORDs) pPIDs array on entry, number of PIDs in system on exit.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PidList(_Out_writes_opt_(*pcPIDs) PDWORD pPIDs, _Inout_ PULONG64 pcPIDs); 

#define VMMDLL_PROCESS_INFORMATION_MAGIC        0xc0ffee663df9301e
#define VMMDLL_PROCESS_INFORMATION_VERSION      6

typedef struct tdVMMDLL_PROCESS_INFORMATION {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    VMMDLL_MEMORYMODEL_TP tpMemoryModel;    // as given by VMMDLL_MEMORYMODEL_* enum
    VMMDLL_SYSTEM_TP tpSystem;              // as given by VMMDLL_SYSTEM_* enum
    BOOL fUserOnly;                         // only user mode pages listed
    DWORD dwPID;
    DWORD dwPPID;
    DWORD dwState;
    CHAR szName[16];
    CHAR szNameLong[64];
    ULONG64 paDTB;
    ULONG64 paDTB_UserOpt;                  // may not exist
    struct {
        ULONG64 vaEPROCESS;
        ULONG64 vaPEB;
        ULONG64 _Reserved1;
        BOOL fWow64;
        DWORD vaPEB32;                  // WoW64 only
        DWORD dwSessionId;
        ULONG64 qwLUID;
        CHAR szSID[MAX_PATH];
    } win;
} VMMDLL_PROCESS_INFORMATION, *PVMMDLL_PROCESS_INFORMATION;

/*
* Retrieve various process information from a PID. Process information such as
* name, page directory bases and the process state may be retrieved.
* -- dwPID
* -- pProcessInformation = if null, size is given in *pcbProcessInfo
* -- pcbProcessInformation = size of pProcessInfo (in bytes) on entry and exit
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_ProcessGetInformation(_In_ DWORD dwPID, _Inout_opt_ PVMMDLL_PROCESS_INFORMATION pProcessInformation, _In_ PSIZE_T pcbProcessInformation);

#define VMMDLL_PROCESS_INFORMATION_OPT_STRING_PATH_KERNEL           1
#define VMMDLL_PROCESS_INFORMATION_OPT_STRING_PATH_USER_IMAGE       2
#define VMMDLL_PROCESS_INFORMATION_OPT_STRING_CMDLINE               3

/*
* Retrieve a string value belonging to a process. The function allocates a new
* string buffer and returns the requested string in it. The string is always
* NULL terminated. On failure NULL is returned.
* NB! CALLER IS RESPONSIBLE FOR VMMDLL_MemFree return value!
* CALLER FREE: VMMDLL_MemFree(return)
* -- dwPID
* -- fOptionString = string value to retrieve as given by VMMDLL_PROCESS_INFORMATION_OPT_STRING_*
* -- return - fail: NULL, success: the string - NB! must be VMMDLL_MemFree'd by caller!
*/
EXPORTED_FUNCTION
LPSTR VMMDLL_ProcessGetInformationString(_In_ DWORD dwPID, _In_ DWORD fOptionString);

/*
* Retrieve information about: Data Directories, Sections, Export Address Table
* and Import Address Table (IAT).
* If the pData == NULL upon entry the number of entries of the pData array must
* have in order to be able to hold the data is returned.
* -- dwPID
* -- [uw]szModule
* -- pData
* -- cData
* -- pcData
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_ProcessGetDirectoriesU(_In_ DWORD dwPID, _In_ LPSTR  uszModule, _Out_writes_(16) PIMAGE_DATA_DIRECTORY pData, _In_ DWORD cData, _Out_ PDWORD pcData);
_Success_(return) BOOL VMMDLL_ProcessGetDirectoriesW(_In_ DWORD dwPID, _In_ LPWSTR wszModule, _Out_writes_(16) PIMAGE_DATA_DIRECTORY pData, _In_ DWORD cData, _Out_ PDWORD pcData);
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_ProcessGetSectionsU(_In_ DWORD dwPID, _In_ LPSTR  uszModule, _Out_opt_ PIMAGE_SECTION_HEADER pData, _In_ DWORD cData, _Out_ PDWORD pcData);
_Success_(return) BOOL VMMDLL_ProcessGetSectionsW(_In_ DWORD dwPID, _In_ LPWSTR wszModule, _Out_opt_ PIMAGE_SECTION_HEADER pData, _In_ DWORD cData, _Out_ PDWORD pcData);

/*
* Retrieve the virtual address of a given function inside a process/module.
* -- dwPID
* -- [uw]szModuleName
* -- szFunctionName
* -- return = virtual address of function, zero on fail.
*/
EXPORTED_FUNCTION
ULONG64 VMMDLL_ProcessGetProcAddressU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _In_ LPSTR szFunctionName);
ULONG64 VMMDLL_ProcessGetProcAddressW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _In_ LPSTR szFunctionName);

/*
* Retrieve the base address of a given module.
* -- dwPID
* -- [uw]szModuleName
* -- return = virtual address of module base, zero on fail.
*/
EXPORTED_FUNCTION
ULONG64 VMMDLL_ProcessGetModuleBaseU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName);
ULONG64 VMMDLL_ProcessGetModuleBaseW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC DEBUGGING / SYMBOL FUNCTIONALITY BELOW:
//-----------------------------------------------------------------------------

/*
* Load a .pdb symbol file and return its associated module name upon success.
* -- dwPID
* -- vaModuleBase
* -- szModuleName = buffer to receive module name upon success.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbLoad(_In_ DWORD dwPID, _In_ ULONG64 vaModuleBase, _Out_writes_(MAX_PATH) LPSTR szModuleName);

/*
* Retrieve a symbol virtual address given a module name and a symbol name.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- cbSymbolAddressOrOffset = symbol virtual address or symbol offset.
* -- szSymbolName = buffer to receive symbol name upon success.
* -- pdwSymbolDisplacement = displacement from the beginning of the symbol.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbSymbolName(_In_ LPSTR szModule, _In_ QWORD cbSymbolAddressOrOffset, _Out_writes_(MAX_PATH) LPSTR szSymbolName, _Out_opt_ PDWORD pdwSymbolDisplacement);

/*
* Retrieve a symbol virtual address given a module name and a symbol name.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- szSymbolName
* -- pvaSymbolAddress
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbSymbolAddress(_In_ LPSTR szModule, _In_ LPSTR szSymbolName, _Out_ PULONG64 pvaSymbolAddress);

/*
* Retrieve a type size given a module name and a type name.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- szTypeName
* -- pcbTypeSize
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbTypeSize(_In_ LPSTR szModule, _In_ LPSTR szTypeName, _Out_ PDWORD pcbTypeSize);

/*
* Locate the offset of a type child - typically a sub-item inside a struct.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- uszTypeName
* -- uszTypeChildName
* -- pcbTypeChildOffset
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbTypeChildOffset(_In_ LPSTR szModule, _In_ LPSTR uszTypeName, _In_ LPSTR uszTypeChildName, _Out_ PDWORD pcbTypeChildOffset);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC REGISTRY FUNCTIONALITY BELOW:
//-----------------------------------------------------------------------------

#define VMMDLL_REGISTRY_HIVE_INFORMATION_MAGIC      0xc0ffee653df8d01e
#define VMMDLL_REGISTRY_HIVE_INFORMATION_VERSION    3

typedef struct td_VMMDLL_REGISTRY_HIVE_INFORMATION {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    BYTE _FutureReserved1[0x14];
    ULONG64 vaCMHIVE;
    ULONG64 vaHBASE_BLOCK;
    DWORD cbLength;
    CHAR uszName[128];
    CHAR uszNameShort[32 + 1];
    CHAR uszHiveRootPath[MAX_PATH];
    QWORD _FutureReserved[0x10];
} VMMDLL_REGISTRY_HIVE_INFORMATION, *PVMMDLL_REGISTRY_HIVE_INFORMATION;

/*
* Retrieve information about the registry hives in the target system.
* -- pHives = buffer of cHives * sizeof(VMMDLL_REGISTRY_HIVE_INFORMATION) to receive information about all hives. NULL to receive # hives in pcHives.
* -- cHives
* -- pcHives = if pHives == NULL: # total hives. if pHives: # read hives.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_HiveList(_Out_writes_(cHives) PVMMDLL_REGISTRY_HIVE_INFORMATION pHives, _In_ DWORD cHives, _Out_ PDWORD pcHives);

/*
* Read a contigious arbitrary amount of registry hive memory and report the
* number of bytes read in pcbRead.
* NB! Address space does not include regf registry hive file header!
* -- vaCMHive
* -- ra
* -- pb
* -- cb
* -- pcbReadOpt
* -- flags = flags as in VMMDLL_FLAG_*
* -- return = success/fail. NB! reads may report as success even if 0 bytes are
*        read - it's recommended to verify pcbReadOpt parameter.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_HiveReadEx(_In_ ULONG64 vaCMHive, _In_ DWORD ra, _Out_ PBYTE pb, _In_ DWORD cb, _Out_opt_ PDWORD pcbReadOpt, _In_ ULONG64 flags);

/*
* Write a virtually contigious arbitrary amount of memory to a registry hive.
* NB! Address space does not include regf registry hive file header!
* -- vaCMHive
* -- ra
* -- pb
* -- cb
* -- return = TRUE on success, FALSE on partial or zero write.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_HiveWrite(_In_ ULONG64 vaCMHive, _In_ DWORD ra, _In_ PBYTE pb, _In_ DWORD cb);

/*
* Enumerate registry sub keys - similar to WINAPI function 'RegEnumKeyExW.'
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- uszFullPathKey
* -- dwIndex = sub-key index 0..N (-1 for key).
* -- lpName
* -- lpcchName
* -- lpftLastWriteTime
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_EnumKeyExU(
    _In_ LPSTR uszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchName) LPSTR lpName,
    _Inout_ LPDWORD lpcchName,
    _Out_opt_ PFILETIME lpftLastWriteTime
);

/*
* Enumerate registry values given a registry key - similar to WINAPI function
* 'EnumValueW'. Please consult WINAPI function documentation for information.
* May be called in two ways:
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- uszFullPathKey
* -- dwIndex
* -- lpValueName
* -- lpcchValueName
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_EnumValueU(
    _In_ LPSTR uszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchValueName) LPSTR lpValueName,
    _Inout_ LPDWORD lpcchValueName,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _Inout_opt_ LPDWORD lpcbData
);

/*
* Query a registry value given a registry key/value path - similar to WINAPI
* function 'RegQueryValueEx'.
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey\Value'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey\'             (orphan key and default value)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey\Value'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey\Value'    (orphan key value)
* -- uszFullPathKeyValue
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_QueryValueExU(
    _In_ LPSTR uszFullPathKeyValue,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _When_(lpData == NULL, _Out_opt_) _When_(lpData != NULL, _Inout_opt_) LPDWORD lpcbData
);

/*
* Enumerate registry sub keys - similar to WINAPI function 'RegEnumKeyExW.'
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- wszFullPathKey
* -- dwIndex = sub-key index 0..N (-1 for key).
* -- lpName
* -- lpcchName
* -- lpftLastWriteTime
* -- return
*/
_Success_(return)
BOOL VMMDLL_WinReg_EnumKeyExW(
    _In_ LPWSTR wszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchName) LPWSTR lpName,
    _Inout_ LPDWORD lpcchName,
    _Out_opt_ PFILETIME lpftLastWriteTime
);

/*
* Enumerate registry values given a registry key - similar to WINAPI function
* 'EnumValueW'. Please consult WINAPI function documentation for information.
* May be called in two ways:
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- wszFullPathKey
* -- dwIndex
* -- lpValueName
* -- lpcchValueName
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
_Success_(return)
BOOL VMMDLL_WinReg_EnumValueW(
    _In_ LPWSTR wszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchValueName) LPWSTR lpValueName,
    _Inout_ LPDWORD lpcchValueName,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _Inout_opt_ LPDWORD lpcbData
);

/*
* Query a registry value given a registry key/value path - similar to WINAPI
* function 'RegQueryValueEx'.
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey\Value'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey\'             (orphan key and default value)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey\Value'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey\Value'    (orphan key value)
* -- wszFullPathKeyValue
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
_Success_(return)
BOOL VMMDLL_WinReg_QueryValueExW(
    _In_ LPWSTR wszFullPathKeyValue,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _When_(lpData == NULL, _Out_opt_) _When_(lpData != NULL, _Inout_opt_) LPDWORD lpcbData
);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC UTILITY FUNCTIONS BELOW:
//-----------------------------------------------------------------------------

typedef struct tdVMMDLL_WIN_THUNKINFO_IAT {
    BOOL fValid;
    BOOL f32;               // if TRUE fn is a 32-bit/4-byte entry, otherwise 64-bit/8-byte entry.
    ULONG64 vaThunk;        // address of import address table 'thunk'.
    ULONG64 vaFunction;     // value if import address table 'thunk' == address of imported function.
    ULONG64 vaNameModule;   // address of name string for imported module.
    ULONG64 vaNameFunction; // address of name string for imported function.
} VMMDLL_WIN_THUNKINFO_IAT, *PVMMDLL_WIN_THUNKINFO_IAT;

/*
* Retrieve information about the import address table IAT thunk for an imported
* function. This includes the virtual address of the IAT thunk which is useful
* for hooking.
* -- dwPID
* -- [uw]szModuleName
* -- szImportModuleName
* -- szImportFunctionName
* -- pThunkIAT
* -- return
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_WinGetThunkInfoIATU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _In_ LPSTR szImportModuleName, _In_ LPSTR szImportFunctionName, _Out_ PVMMDLL_WIN_THUNKINFO_IAT pThunkInfoIAT);
_Success_(return) BOOL VMMDLL_WinGetThunkInfoIATW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _In_ LPSTR szImportModuleName, _In_ LPSTR szImportFunctionName, _Out_ PVMMDLL_WIN_THUNKINFO_IAT pThunkInfoIAT);



//-----------------------------------------------------------------------------
// VMM UTIL FUNCTIONALITY BELOW:
//-----------------------------------------------------------------------------

/*
* Fill a human readable hex ascii memory dump into the caller supplied sz buffer.
* -- pb
* -- cb
* -- cbInitialOffset = offset, must be max 0x1000 and multiple of 0x10.
* -- sz = buffer to fill, NULL to retrieve buffer size in pcsz parameter.
* -- pcsz = IF sz==NULL :: size of buffer (including space for terminating NULL) on exit
*           IF sz!=NULL :: size of buffer on entry, size of characters (excluding terminating NULL) on exit.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_UtilFillHexAscii(
    _In_reads_opt_(cb) PBYTE pb,
    _In_ DWORD cb,
    _In_ DWORD cbInitialOffset,
    _Out_writes_opt_(*pcsz) LPSTR sz,
    _Inout_ PDWORD pcsz
);



//-----------------------------------------------------------------------------
// DEFAULT (WINDOWS ONLY) COMPATIBILITY FUNCTION DEFINITIONS BELOW:
//-----------------------------------------------------------------------------

#ifdef _WIN32
#define VMMDLL_VfsList                  VMMDLL_VfsListW
#define VMMDLL_VfsRead                  VMMDLL_VfsReadW
#define VMMDLL_VfsWrite                 VMMDLL_VfsWriteW
#define VMMDLL_ProcessGetDirectories    VMMDLL_ProcessGetDirectoriesW
#define VMMDLL_ProcessGetSections       VMMDLL_ProcessGetSectionsW
#define VMMDLL_ProcessGetProcAddress    VMMDLL_ProcessGetProcAddressW
#define VMMDLL_ProcessGetModuleBase     VMMDLL_ProcessGetModuleBaseW
#define VMMDLL_Map_GetPte               VMMDLL_Map_GetPteW
#define VMMDLL_Map_GetVad               VMMDLL_Map_GetVadW
#define VMMDLL_Map_GetModule            VMMDLL_Map_GetModuleW
#define VMMDLL_Map_GetModuleFromName    VMMDLL_Map_GetModuleFromNameW
#define VMMDLL_Map_GetUnloadedModule    VMMDLL_Map_GetUnloadedModuleW
#define VMMDLL_Map_GetEAT               VMMDLL_Map_GetEATW
#define VMMDLL_Map_GetIAT               VMMDLL_Map_GetIATW
#define VMMDLL_Map_GetHandle            VMMDLL_Map_GetHandleW
#define VMMDLL_Map_GetNet               VMMDLL_Map_GetNetW
#define VMMDLL_Map_GetUsers             VMMDLL_Map_GetUsersW
#define VMMDLL_Map_GetServices          VMMDLL_Map_GetServicesW
#define VMMDLL_WinGetThunkInfoIAT       VMMDLL_WinGetThunkInfoIATW
#endif /* _WIN32 */

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* __VMMDLL_H__ */

```

`Source/vmmsharp/vmmsharp.cs`:

```cs
using System;
using System.Text;
using System.Runtime.InteropServices;
using System.Collections.Generic;

/*  
 *  C# API wrapper 'vmmsharp' for MemProcFS 'vmm.dll' and LeechCore 'leechcore.dll' APIs.
 *  
 *  Please see the example project in vmm_example.cs for additional information.
 *  
 *  Please consult the C/C++ header files vmmdll.h and leechcore.h for information about
 *  parameters and API usage.
 *  
 *  (c) Ulf Frisk, 2020-2022
 *  Author: Ulf Frisk, pcileech@frizk.net
 *  
 *  Version 3.10
 *  
 */

namespace vmmsharp
{
    public struct MEM_SCATTER
    {
        public bool f;
        public ulong qwA;
        public byte[] pb;
    }

    public static class lc
    {
        public static ulong OPT_CORE_PRINTF_ENABLE =            0x4000000100000000;
        public static ulong OPT_CORE_VERBOSE =                  0x4000000200000000;
        public static ulong OPT_CORE_VERBOSE_EXTRA =            0x4000000300000000;
        public static ulong OPT_CORE_VERBOSE_EXTRA_TLP =        0x4000000400000000;
        public static ulong OPT_CORE_VERSION_MAJOR =            0x4000000500000000;
        public static ulong OPT_CORE_VERSION_MINOR =            0x4000000600000000;
        public static ulong OPT_CORE_VERSION_REVISION =         0x4000000700000000;
        public static ulong OPT_CORE_ADDR_MAX =                 0x1000000800000000;

        public static ulong OPT_MEMORYINFO_VALID =              0x0200000100000000;
        public static ulong OPT_MEMORYINFO_FLAG_32BIT =         0x0200000300000000;
        public static ulong OPT_MEMORYINFO_FLAG_PAE =           0x0200000400000000;
        public static ulong OPT_MEMORYINFO_OS_VERSION_MINOR =   0x0200000500000000;
        public static ulong OPT_MEMORYINFO_OS_VERSION_MAJOR =   0x0200000600000000;
        public static ulong OPT_MEMORYINFO_OS_DTB =             0x0200000700000000;
        public static ulong OPT_MEMORYINFO_OS_PFN =             0x0200000800000000;
        public static ulong OPT_MEMORYINFO_OS_PsLoadedModuleList = 0x0200000900000000;
        public static ulong OPT_MEMORYINFO_OS_PsActiveProcessHead = 0x0200000a00000000;
        public static ulong OPT_MEMORYINFO_OS_MACHINE_IMAGE_TP = 0x0200000b00000000;
        public static ulong OPT_MEMORYINFO_OS_NUM_PROCESSORS =  0x0200000c00000000;
        public static ulong OPT_MEMORYINFO_OS_SYSTEMTIME =      0x0200000d00000000;
        public static ulong OPT_MEMORYINFO_OS_UPTIME =          0x0200000e00000000;
        public static ulong OPT_MEMORYINFO_OS_KERNELBASE =      0x0200000f00000000;
        public static ulong OPT_MEMORYINFO_OS_KERNELHINT =      0x0200001000000000;
        public static ulong OPT_MEMORYINFO_OS_KdDebuggerDataBlock = 0x0200001100000000;

        public static ulong OPT_FPGA_PROBE_MAXPAGES =           0x0300000100000000;
        public static ulong OPT_FPGA_MAX_SIZE_RX =              0x0300000300000000;
        public static ulong OPT_FPGA_MAX_SIZE_TX =              0x0300000400000000;
        public static ulong OPT_FPGA_DELAY_PROBE_READ =         0x0300000500000000;
        public static ulong OPT_FPGA_DELAY_PROBE_WRITE =        0x0300000600000000;
        public static ulong OPT_FPGA_DELAY_WRITE =              0x0300000700000000;
        public static ulong OPT_FPGA_DELAY_READ =               0x0300000800000000;
        public static ulong OPT_FPGA_RETRY_ON_ERROR =           0x0300000900000000;
        public static ulong OPT_FPGA_DEVICE_ID =                0x0300008000000000;
        public static ulong OPT_FPGA_FPGA_ID =                  0x0300008100000000;
        public static ulong OPT_FPGA_VERSION_MAJOR =            0x0300008200000000;
        public static ulong OPT_FPGA_VERSION_MINOR =            0x0300008300000000;
        public static ulong OPT_FPGA_ALGO_TINY =                0x0300008400000000;
        public static ulong OPT_FPGA_ALGO_SYNCHRONOUS =         0x0300008500000000;

        public static ulong CMD_FPGA_WRITE_TLP =                0x0000010100000000;
        public static ulong CMD_FPGA_LISTEN_TLP =               0x0000010200000000;
        public static ulong CMD_FPGA_PCIECFGSPACE =             0x0000010300000000;
        public static ulong CMD_FPGA_CFGREGPCIE =               0x0000010400000000;
        public static ulong CMD_FPGA_CFGREGCFG =                0x0000010500000000;
        public static ulong CMD_FPGA_CFGREGDRP =                0x0000010600000000;
        public static ulong CMD_FPGA_CFGREGCFG_MARKWR =         0x0000010700000000;
        public static ulong CMD_FPGA_CFGREGPCIE_MARKWR =        0x0000010800000000;
        public static ulong CMD_FPGA_PCIECFGSPACE_WR =          0x0000010900000000;
        public static ulong CMD_FPGA_CFGREG_DEBUGPRINT =        0x0000010a00000000;
        public static ulong CMD_FPGA_PROBE =                    0x0000010b00000000;

        public static ulong CMD_FILE_DUMPHEADER_GET =           0x0000020100000000;

        public static ulong CMD_STATISTICS_GET =                0x4000010000000000;
        public static ulong CMD_MEMMAP_GET =                    0x4000020000000000;
        public static ulong CMD_MEMMAP_SET =                    0x4000030000000000;

        public static ulong CMD_AGENT_EXEC_PYTHON =             0x8000000100000000;
        public static ulong CMD_AGENT_EXIT_PROCESS =            0x8000000200000000;

        public static uint CONFIG_VERSION =                     0xc0fd0002;
        public static uint CONFIG_ERRORINFO_VERSION =           0xc0fe0001;

        public static uint CONFIG_PRINTF_ENABLED =              0x01;
        public static uint CONFIG_PRINTF_V =                    0x02;
        public static uint CONFIG_PRINTF_VV =                   0x04;
        public static uint CONFIG_PRINTF_VVV =                  0x08;

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct CONFIG
        {
            public uint dwVersion;
            public uint dwPrintfVerbosity;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)] public string szDevice;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)] public string szRemote;
            public IntPtr pfn_printf_opt;
            public ulong paMax;
            public bool fVolatile;
            public bool fWritable;
            public bool fRemote;
            public bool fRemoteDisableCompress;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)] public string szDeviceName;
        }

        public struct CONFIG_ERRORINFO
        {
            public bool fValid;
            public bool fUserInputRequest;
            public string strUserText;
        }

        public static unsafe ulong Create(ref CONFIG pLcCreateConfig, out CONFIG_ERRORINFO ConfigErrorInfo)
        {
            IntPtr pLcErrorInfo;
            int cbERROR_INFO = System.Runtime.InteropServices.Marshal.SizeOf(typeof(lci.LC_CONFIG_ERRORINFO));
            ulong hLC = lci.LcCreateEx(ref pLcCreateConfig, out pLcErrorInfo);
            long vaLcCreateErrorInfo = pLcErrorInfo.ToInt64();
            ConfigErrorInfo = new CONFIG_ERRORINFO();
            ConfigErrorInfo.strUserText = "";
            if (vaLcCreateErrorInfo == 0) {
                return hLC;
            }
            lci.LC_CONFIG_ERRORINFO e = Marshal.PtrToStructure<lci.LC_CONFIG_ERRORINFO>(pLcErrorInfo);
            if(e.dwVersion == CONFIG_ERRORINFO_VERSION)
            {
                ConfigErrorInfo.fValid = true;
                ConfigErrorInfo.fUserInputRequest = e.fUserInputRequest;
                if(e.cwszUserText > 0)
                {
                    ConfigErrorInfo.strUserText = Marshal.PtrToStringUni((System.IntPtr)(vaLcCreateErrorInfo + cbERROR_INFO));
                }
            }
            lci.LcMemFree(pLcErrorInfo);
            return hLC;
        }

        public static ulong Create(ref CONFIG pLcCreateConfig)
        {
            CONFIG_ERRORINFO ErrorInfo;
            return Create(ref pLcCreateConfig, out ErrorInfo);
        }

        [DllImport("leechcore.dll", EntryPoint = "LcClose")]
        public static extern void Close(ulong hLC);

        public static unsafe byte[] Read(ulong hLC, ulong pa, uint cb)
        {
            byte[] data = new byte[cb];
            fixed (byte* pb = data)
            {
                bool result = lci.LcRead(hLC, pa, cb, pb);
                return result ? data : null;
            }
        }

        public static unsafe MEM_SCATTER[] ReadScatter(ulong hLC, params ulong[] qwA)
        {
            int i;
            long vappMEMs, vapMEM;
            IntPtr pMEM, pMEM_qwA, pppMEMs;
            if (!lci.LcAllocScatter1((uint)qwA.Length, out pppMEMs))
            {
                return null;
            }
            vappMEMs = pppMEMs.ToInt64();
            for (i = 0; i < qwA.Length; i++)
            {
                vapMEM = Marshal.ReadIntPtr(new IntPtr(vappMEMs + i * 8)).ToInt64();
                pMEM_qwA = new IntPtr(vapMEM + 8);
                Marshal.WriteInt64(pMEM_qwA, (long)(qwA[i] & ~(ulong)0xfff));
            }
            MEM_SCATTER[] MEMs = new MEM_SCATTER[qwA.Length];
            lci.LcReadScatter(hLC, (uint)MEMs.Length, pppMEMs);
            for (i = 0; i < MEMs.Length; i++)
            {
                pMEM = Marshal.ReadIntPtr(new IntPtr(vappMEMs + i * 8));
                lci.LC_MEM_SCATTER n = Marshal.PtrToStructure<lci.LC_MEM_SCATTER>(pMEM);
                MEMs[i].f = n.f;
                MEMs[i].qwA = n.qwA;
                MEMs[i].pb = new byte[0x1000];
                Marshal.Copy(n.pb, MEMs[i].pb, 0, 0x1000);
            }
            lci.LcMemFree(pppMEMs);
            return MEMs;
        }

        public static unsafe bool Write(ulong hLC, ulong pa, byte[] data)
        {
            fixed (byte* pb = data)
            {
                return lci.LcWrite(hLC, pa, (uint)data.Length, pb);
            }
        }

        public static unsafe void WriteScatter(ulong hLC, ref MEM_SCATTER[] MEMs)
        {
            int i;
            long vappMEMs, vapMEM;
            IntPtr pMEM, pMEM_f, pMEM_qwA, pMEM_pb, pppMEMs;
            for (i = 0; i < MEMs.Length; i++)
            {
                if((MEMs[i].pb == null) || (MEMs[i].pb.Length != 0x1000))
                {
                    return;
                }
            }
            if (!lci.LcAllocScatter1((uint)MEMs.Length, out pppMEMs))
            {
                return;
            }
            vappMEMs = pppMEMs.ToInt64();
            for (i = 0; i < MEMs.Length; i++)
            {
                vapMEM = Marshal.ReadIntPtr(new IntPtr(vappMEMs + i * 8)).ToInt64();
                pMEM_f = new IntPtr(vapMEM + 4);
                pMEM_qwA = new IntPtr(vapMEM + 8);
                pMEM_pb = Marshal.ReadIntPtr(new IntPtr(vapMEM + 16));
                Marshal.WriteInt32(pMEM_f, MEMs[i].f ? 1 : 0);
                Marshal.WriteInt64(pMEM_qwA, (long)(MEMs[i].qwA & ~(ulong)0xfff));
                Marshal.Copy(MEMs[i].pb, 0, pMEM_pb, MEMs[i].pb.Length);
            }
            lci.LcWriteScatter(hLC, (uint)MEMs.Length, pppMEMs);
            for (i = 0; i < MEMs.Length; i++)
            {
                pMEM = Marshal.ReadIntPtr(new IntPtr(vappMEMs + i * 8));
                lci.LC_MEM_SCATTER n = Marshal.PtrToStructure<lci.LC_MEM_SCATTER>(pMEM);
                MEMs[i].f = n.f;
                MEMs[i].qwA = n.qwA;
            }
            lci.LcMemFree(pppMEMs);
        }

        [DllImport("leechcore.dll", EntryPoint = "LcGetOption")]
        public static extern bool GetOption(ulong hLC, ulong fOption, out ulong pqwValue);

        [DllImport("leechcore.dll", EntryPoint = "LcSetOption")]
        public static extern bool SetOption(ulong hLC, ulong fOption, ulong qwValue);

        public static unsafe bool Command(ulong hLC, ulong fOption, byte[] DataIn, out byte[] DataOut)
        {
            bool result;
            uint cbDataOut;
            IntPtr PtrDataOut;
            DataOut = null;
            if(DataIn == null)
            {
                result = lci.LcCommand(hLC, fOption, 0, null, out PtrDataOut, out cbDataOut);
            } else
            {
                fixed (byte* pbDataIn = DataIn)
                {
                    result = lci.LcCommand(hLC, fOption, (uint)DataIn.Length, pbDataIn, out PtrDataOut, out cbDataOut);
                }
            }
            if(!result) { return false; }
            DataOut = new byte[cbDataOut];
            if(cbDataOut > 0)
            {
                Marshal.Copy(PtrDataOut, DataOut, 0, (int)cbDataOut);
                lci.LcMemFree(PtrDataOut);
            }
            return true;
        }
    }

    public static class vmm
    {
        //---------------------------------------------------------------------
        // CORE FUNCTIONALITY BELOW:
        //---------------------------------------------------------------------

        public static ulong OPT_CORE_PRINTF_ENABLE =             0x4000000100000000;  // RW
        public static ulong OPT_CORE_VERBOSE =                   0x4000000200000000;  // RW
        public static ulong OPT_CORE_VERBOSE_EXTRA =             0x4000000300000000;  // RW
        public static ulong OPT_CORE_VERBOSE_EXTRA_TLP =         0x4000000400000000;  // RW
        public static ulong OPT_CORE_MAX_NATIVE_ADDRESS =        0x4000000800000000;  // R

        public static ulong OPT_CORE_SYSTEM =                    0x2000000100000000;  // R
        public static ulong OPT_CORE_MEMORYMODEL =               0x2000000200000000;  // R

        public static ulong OPT_CONFIG_IS_REFRESH_ENABLED =      0x2000000300000000;  // R - 1/0
        public static ulong OPT_CONFIG_TICK_PERIOD =             0x2000000400000000;  // RW - base tick period in ms
        public static ulong OPT_CONFIG_READCACHE_TICKS =         0x2000000500000000;  // RW - memory cache validity period (in ticks)
        public static ulong OPT_CONFIG_TLBCACHE_TICKS =          0x2000000600000000;  // RW - page table (tlb) cache validity period (in ticks)
        public static ulong OPT_CONFIG_PROCCACHE_TICKS_PARTIAL = 0x2000000700000000; // RW - process refresh (partial) period (in ticks)
        public static ulong OPT_CONFIG_PROCCACHE_TICKS_TOTAL =   0x2000000800000000;  // RW - process refresh (full) period (in ticks)
        public static ulong OPT_CONFIG_VMM_VERSION_MAJOR =       0x2000000900000000;  // R
        public static ulong OPT_CONFIG_VMM_VERSION_MINOR =       0x2000000A00000000;  // R
        public static ulong OPT_CONFIG_VMM_VERSION_REVISION =    0x2000000B00000000;  // R
        public static ulong OPT_CONFIG_STATISTICS_FUNCTIONCALL = 0x2000000C00000000; // RW - enable function call statistics (.status/statistics_fncall file)
        public static ulong OPT_CONFIG_IS_PAGING_ENABLED =       0x2000000D00000000;  // RW - 1/0

        public static ulong OPT_WIN_VERSION_MAJOR =              0x2000010100000000;  // R
        public static ulong OPT_WIN_VERSION_MINOR =              0x2000010200000000;  // R
        public static ulong OPT_WIN_VERSION_BUILD =              0x2000010300000000;  // R

        public static ulong OPT_FORENSIC_MODE =                  0x2000020100000000;  // RW - enable/retrieve forensic mode type [0-4].

        public static ulong OPT_REFRESH_ALL =                    0x2001ffff00000000;  // W - refresh all caches
        public static ulong OPT_REFRESH_FREQ_FAST =              0x2001040000000000;  // W - refresh fast frequency (including partial process listings)
        public static ulong OPT_REFRESH_FREQ_MEDIUM =            0x2001000100000000;  // W - refresh medium frequency (including full process listings)
        public static ulong OPT_REFRESH_FREQ_SLOW =              0x2001001000000000;  // W - refresh slow frequency (including registry)
        public static ulong OPT_REFRESH_READ =                   0x2001000200000000;  // W - refresh physical read cache
        public static ulong OPT_REFRESH_TLB =                    0x2001000400000000;  // W - refresh page table (TLB) cache
        public static ulong OPT_REFRESH_PAGING =                 0x2001000800000000;  // W - refresh virtual memory 'paging' cache
        public static ulong OPT_REFRESH_USER =                   0x2001002000000000;  // W
        public static ulong OPT_REFRESH_PHYSMEMMAP =             0x2001004000000000;  // W
        public static ulong OPT_REFRESH_PFN =                    0x2001008000000000;  // W
        public static ulong OPT_REFRESH_OBJ =                    0x2001010000000000;  // W
        public static ulong OPT_REFRESH_NET =                    0x2001020000000000;  // W


        public enum MEMORYMODEL_TP
        {
            MEMORYMODEL_NA = 0,
            MEMORYMODEL_X86 = 1,
            MEMORYMODEL_X86PAE = 2,
            MEMORYMODEL_X64 = 3
        }

        public enum SYSTEM_TP
        {
            SYSTEM_UNKNOWN_X64 = 1,
            SYSTEM_WINDOWS_X64 = 2,
            SYSTEM_UNKNOWN_X86 = 3,
            SYSTEM_WINDOWS_X86 = 4
        }

        public static unsafe bool Initialize(out lc.CONFIG_ERRORINFO ConfigErrorInfo, params string[] args)
        {
            IntPtr pLcErrorInfo;
            int cbERROR_INFO = System.Runtime.InteropServices.Marshal.SizeOf(typeof(lci.LC_CONFIG_ERRORINFO));
            bool fResult = vmmi.VMMDLL_InitializeEx(args.Length, args, out pLcErrorInfo);
            long vaLcCreateErrorInfo = pLcErrorInfo.ToInt64();
            ConfigErrorInfo = new lc.CONFIG_ERRORINFO();
            ConfigErrorInfo.strUserText = "";
            if (vaLcCreateErrorInfo == 0)
            {
                return fResult;
            }
            lci.LC_CONFIG_ERRORINFO e = Marshal.PtrToStructure<lci.LC_CONFIG_ERRORINFO>(pLcErrorInfo);
            if (e.dwVersion == lc.CONFIG_ERRORINFO_VERSION)
            {
                ConfigErrorInfo.fValid = true;
                ConfigErrorInfo.fUserInputRequest = e.fUserInputRequest;
                if (e.cwszUserText > 0)
                {
                    ConfigErrorInfo.strUserText = Marshal.PtrToStringUni((System.IntPtr)(vaLcCreateErrorInfo + cbERROR_INFO));
                }
            }
            lci.LcMemFree(pLcErrorInfo);
            return fResult;
        }

        public static bool Initialize(params string[] args)
        {
            lc.CONFIG_ERRORINFO ErrorInfo;
            return Initialize(out ErrorInfo, args);
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Close")]
        public static extern bool Close();

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_ConfigGet")]
        public static extern bool ConfigGet(ulong fOption, out ulong pqwValue);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_ConfigSet")]
        public static extern bool ConfigSet(ulong fOption, ulong qwValue);

        //---------------------------------------------------------------------
        // VFS (VIRTUAL FILE SYSTEM) FUNCTIONALITY BELOW:
        //---------------------------------------------------------------------

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public struct VMMDLL_VFS_FILELIST_EXINFO
        {
            public uint dwVersion;
            public bool fCompressed;
            public ulong ftCreationTime;
            public ulong ftLastAccessTime;
            public ulong ftLastWriteTime;
        }

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate bool VfsCallBack_AddFile(ulong h, [MarshalAs(UnmanagedType.LPUTF8Str)] string wszName, ulong cb, IntPtr pExInfo);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate bool VfsCallBack_AddDirectory(ulong h, [MarshalAs(UnmanagedType.LPUTF8Str)] string wszName, IntPtr pExInfo);

        public static bool VfsList(string wszPath, ulong h, VfsCallBack_AddFile CallbackFile, VfsCallBack_AddDirectory CallbackDirectory)
        {
            vmmi.VMMDLL_VFS_FILELIST FileList;
            FileList.dwVersion = vmmi.VMMDLL_VFS_FILELIST_VERSION;
            FileList.h = h;
            FileList._Reserved = 0;
            FileList.pfnAddFile = Marshal.GetFunctionPointerForDelegate(CallbackFile);
            FileList.pfnAddDirectory = Marshal.GetFunctionPointerForDelegate(CallbackDirectory);
            return vmmi.VMMDLL_VfsList(wszPath, ref FileList);
        }

        public static unsafe uint VfsRead(string wszFileName, uint cb, ulong cbOffset, out byte[] pbData)
        {
            uint nt, cbRead = 0;
            byte[] data = new byte[cb];
            fixed (byte* pb = data)
            {
                nt = vmmi.VMMDLL_VfsRead(wszFileName, pb, cb, out cbRead, cbOffset);
                pbData = new byte[cbRead];
                if (cbRead > 0)
                {
                    Buffer.BlockCopy(data, 0, pbData, 0, (int)cbRead);
                }
                return nt;
            }
        }

        public static unsafe uint VfsWrite(string wszFileName, byte[] pbData, ulong cbOffset)
        {
            uint cbRead = 0;
            fixed (byte* pb = pbData)
            {
                return vmmi.VMMDLL_VfsWrite(wszFileName, pb, (uint)pbData.Length, out cbRead, cbOffset);
            }
        }

        //---------------------------------------------------------------------
        // PLUGIN FUNCTIONALITY BELOW:
        //---------------------------------------------------------------------

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_InitializePlugins")]
        public static extern bool InitializePlugins();

        //---------------------------------------------------------------------
        // MEMORY READ/WRITE FUNCTIONALITY BELOW:
        //---------------------------------------------------------------------

        public static uint PID_PROCESS_WITH_KERNELMEMORY =  0x80000000;      // Combine with dwPID to enable process kernel memory (NB! use with extreme care).

        public static uint FLAG_NOCACHE =                   0x0001;  // do not use the data cache (force reading from memory acquisition device)
        public static uint FLAG_ZEROPAD_ON_FAIL =           0x0002;  // zero pad failed physical memory reads and report success if read within range of physical memory.
        public static uint FLAG_FORCECACHE_READ =           0x0008;  // force use of cache - fail non-cached pages - only valid for reads, invalid with VMM_FLAG_NOCACHE/VMM_FLAG_ZEROPAD_ON_FAIL.
        public static uint FLAG_NOPAGING =                  0x0010;  // do not try to retrieve memory from paged out memory from pagefile/compressed (even if possible)
        public static uint FLAG_NOPAGING_IO =               0x0020;  // do not try to retrieve memory from paged out memory if read would incur additional I/O (even if possible).
        public static uint FLAG_NOCACHEPUT =                0x0100;  // do not write back to the data cache upon successful read from memory acquisition device.
        public static uint FLAG_CACHE_RECENT_ONLY =         0x0200;  // only fetch from the most recent active cache region when reading.

        public static unsafe MEM_SCATTER[] MemReadScatter(uint pid, uint flags, params ulong[] qwA)
        {
            int i;
            long vappMEMs, vapMEM;
            IntPtr pMEM, pMEM_qwA, pppMEMs;
            if (!lci.LcAllocScatter1((uint)qwA.Length, out pppMEMs))
            {
                return null;
            }
            vappMEMs = pppMEMs.ToInt64();
            for (i = 0; i < qwA.Length; i++)
            {
                vapMEM = Marshal.ReadIntPtr(new IntPtr(vappMEMs + i * 8)).ToInt64();
                pMEM_qwA = new IntPtr(vapMEM + 8);
                Marshal.WriteInt64(pMEM_qwA, (long)(qwA[i] & ~(ulong)0xfff));
            }
            MEM_SCATTER[] MEMs = new MEM_SCATTER[qwA.Length];
            vmmi.VMMDLL_MemReadScatter(pid, pppMEMs, (uint)MEMs.Length, flags);
            for (i = 0; i < MEMs.Length; i++)
            {
                pMEM = Marshal.ReadIntPtr(new IntPtr(vappMEMs + i * 8));
                lci.LC_MEM_SCATTER n = Marshal.PtrToStructure<lci.LC_MEM_SCATTER>(pMEM);
                MEMs[i].f = n.f;
                MEMs[i].qwA = n.qwA;
                MEMs[i].pb = new byte[0x1000];
                Marshal.Copy(n.pb, MEMs[i].pb, 0, 0x1000);
            }
            lci.LcMemFree(pppMEMs);
            return MEMs;
        }

        public static unsafe byte[] MemRead(uint pid, ulong qwA, uint cb, uint flags = 0)
        {
            uint cbRead;
            byte[] data = new byte[cb];
            fixed (byte* pb = data)
            {
                if(!vmmi.VMMDLL_MemReadEx(pid, qwA, pb, cb, out cbRead, flags))
                {
                    return null;
                }
            }
            if (cbRead != cb)
            {
                Array.Resize<byte>(ref data, (int)cbRead);
            }
            return data;
        }

        public static unsafe bool MemPrefetchPages(uint pid, ulong[] qwA)
        {
            byte[] data = new byte[qwA.Length * sizeof(ulong)];
            System.Buffer.BlockCopy(qwA, 0, data, 0, data.Length);
            fixed (byte* pb = data)
            {
                return vmmi.VMMDLL_MemPrefetchPages(pid, pb, (uint)qwA.Length);
            }
        }

        public static unsafe bool MemWrite(uint pid, ulong qwA, byte[] data)
        {
            fixed (byte* pb = data)
            {
                return vmmi.VMMDLL_MemWrite(pid, qwA, pb, (uint)data.Length);
            }
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_MemVirt2Phys")]
        public static extern bool MemVirt2Phys(uint dwPID, ulong qwVA, out ulong pqwPA);



        //---------------------------------------------------------------------
        // PROCESS FUNCTIONALITY BELOW:
        //---------------------------------------------------------------------

        public struct PROCESS_INFORMATION
        {
            public bool fValid;
            public uint tpMemoryModel;
            public uint tpSystem;
            public bool fUserOnly;
            public uint dwPID;
            public uint dwPPID;
            public uint dwState;
            public string szName;
            public string szNameLong;
            public ulong paDTB;
            public ulong paDTB_UserOpt;
            public ulong vaEPROCESS;
            public ulong vaPEB;
            public bool fWow64;
            public uint vaPEB32;
            public uint dwSessionId;
            public ulong qwLUID;
            public string szSID;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_PidGetFromName")]
        public static extern bool PidGetFromName([MarshalAs(UnmanagedType.LPStr)] string szProcName, out uint pdwPID);

        public static unsafe uint[] PidList()
        {
            bool result;
            ulong c = 0;
            result = vmmi.VMMDLL_PidList(null, ref c);
            if (!result || (c == 0)) { return new uint[0]; }
            fixed (byte* pb = new byte[c * 4])
            {
                result = vmmi.VMMDLL_PidList(pb, ref c);
                if (!result || (c == 0)) { return new uint[0]; }
                uint[] m = new uint[c];
                for (ulong i = 0; i < c; i++)
                {
                    m[i] = (uint)Marshal.ReadInt32((System.IntPtr)(pb + i * 4));
                }
                return m;
            }
        }

        public static unsafe PROCESS_INFORMATION ProcessGetInformation(uint pid)
        {
            bool result;
            ulong cbENTRY = (ulong)System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_PROCESS_INFORMATION));
            fixed (byte* pb = new byte[cbENTRY])
            {
                Marshal.WriteInt64(new IntPtr(pb + 0), (long)vmmi.VMMDLL_PROCESS_INFORMATION_MAGIC);
                Marshal.WriteInt16(new IntPtr(pb + 8), (short)vmmi.VMMDLL_PROCESS_INFORMATION_VERSION);
                result = vmmi.VMMDLL_ProcessGetInformation(pid, pb, ref cbENTRY);
                if (!result) { return new PROCESS_INFORMATION(); }
                vmmi.VMMDLL_PROCESS_INFORMATION n = Marshal.PtrToStructure<vmmi.VMMDLL_PROCESS_INFORMATION>((System.IntPtr)pb);
                if (n.wVersion != vmmi.VMMDLL_PROCESS_INFORMATION_VERSION) { return new PROCESS_INFORMATION(); }
                PROCESS_INFORMATION e;
                e.fValid = true;
                e.tpMemoryModel = n.tpMemoryModel;
                e.tpSystem = n.tpSystem;
                e.fUserOnly = n.fUserOnly;
                e.dwPID = n.dwPID;
                e.dwPPID = n.dwPPID;
                e.dwState = n.dwState;
                e.szName = n.szName;
                e.szNameLong = n.szNameLong;
                e.paDTB = n.paDTB;
                e.paDTB_UserOpt = n.paDTB_UserOpt;
                e.vaEPROCESS = n.vaEPROCESS;
                e.vaPEB = n.vaPEB;
                e.fWow64 = n.fWow64;
                e.vaPEB32 = n.vaPEB32;
                e.dwSessionId = n.dwSessionId;
                e.qwLUID = n.qwLUID;
                e.szSID = n.szSID;
                return e;
            }
        }

        public static uint VMMDLL_PROCESS_INFORMATION_OPT_STRING_PATH_KERNEL = 1;
        public static uint VMMDLL_PROCESS_INFORMATION_OPT_STRING_PATH_USER_IMAGE = 2;
        public static uint VMMDLL_PROCESS_INFORMATION_OPT_STRING_CMDLINE = 3;

        public static unsafe string ProcessGetInformationString(uint pid, uint fOptionString)
        {
            byte* pb = vmmi.VMMDLL_ProcessGetInformationString(pid, fOptionString);
            if (pb == null) { return ""; }
            string s = Marshal.PtrToStringAnsi((System.IntPtr)pb);
            vmmi.VMMDLL_MemFree(pb);
            return s;
        }

        public struct IMAGE_SECTION_HEADER
        {
            public string Name;
            public uint MiscPhysicalAddressOrVirtualSize;
            public uint VirtualAddress;
            public uint SizeOfRawData;
            public uint PointerToRawData;
            public uint PointerToRelocations;
            public uint PointerToLinenumbers;
            public ushort NumberOfRelocations;
            public ushort NumberOfLinenumbers;
            public uint Characteristics;
        }

        public struct IMAGE_DATA_DIRECTORY
        {
            public string name;
            public uint VirtualAddress;
            public uint Size;
        }

        public static unsafe IMAGE_DATA_DIRECTORY[] ProcessGetDirectories(uint pid, string wszModule)
        {
            string[] PE_DATA_DIRECTORIES = new string[16] { "EXPORT", "IMPORT", "RESOURCE", "EXCEPTION", "SECURITY", "BASERELOC", "DEBUG", "ARCHITECTURE", "GLOBALPTR", "TLS", "LOAD_CONFIG", "BOUND_IMPORT", "IAT", "DELAY_IMPORT", "COM_DESCRIPTOR", "RESERVED" };
            bool result;
            uint cData;
            uint cbENTRY = (uint)System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_IMAGE_DATA_DIRECTORY));
            fixed (byte* pb = new byte[16 * cbENTRY])
            {
                result = vmmi.VMMDLL_ProcessGetDirectories(pid, wszModule, pb, 16, out cData);
                if (!result || (cData != 16)) { return new IMAGE_DATA_DIRECTORY[0]; }
                IMAGE_DATA_DIRECTORY[] m = new IMAGE_DATA_DIRECTORY[16];
                for (int i = 0; i < 16; i++)
                {
                    vmmi.VMMDLL_IMAGE_DATA_DIRECTORY n = Marshal.PtrToStructure<vmmi.VMMDLL_IMAGE_DATA_DIRECTORY>((System.IntPtr)(pb + i * cbENTRY));
                    IMAGE_DATA_DIRECTORY e;
                    e.name = PE_DATA_DIRECTORIES[i];
                    e.VirtualAddress = n.VirtualAddress;
                    e.Size = n.Size;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe IMAGE_SECTION_HEADER[] ProcessGetSections(uint pid, string wszModule)
        {
            bool result;
            uint cData;
            uint cbENTRY = (uint)System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_IMAGE_SECTION_HEADER));
            result = vmmi.VMMDLL_ProcessGetSections(pid, wszModule, null, 0, out cData);
            if(!result || (cData == 0)) { return new IMAGE_SECTION_HEADER[0]; }
            fixed (byte* pb = new byte[cData * cbENTRY])
            {
                result = vmmi.VMMDLL_ProcessGetSections(pid, wszModule, pb, cData, out cData);
                if (!result || (cData == 0)) { return new IMAGE_SECTION_HEADER[0]; }
                IMAGE_SECTION_HEADER[] m = new IMAGE_SECTION_HEADER[cData];
                for (int i = 0; i < cData; i++)
                {
                    vmmi.VMMDLL_IMAGE_SECTION_HEADER n = Marshal.PtrToStructure<vmmi.VMMDLL_IMAGE_SECTION_HEADER>((System.IntPtr)(pb + i * cbENTRY));
                    IMAGE_SECTION_HEADER e;
                    e.Name = n.Name;
                    e.MiscPhysicalAddressOrVirtualSize = n.MiscPhysicalAddressOrVirtualSize;
                    e.VirtualAddress = n.VirtualAddress;
                    e.SizeOfRawData = n.SizeOfRawData;
                    e.PointerToRawData = n.PointerToRawData;
                    e.PointerToRelocations = n.PointerToRelocations;
                    e.PointerToLinenumbers = n.PointerToLinenumbers;
                    e.NumberOfRelocations = n.NumberOfRelocations;
                    e.NumberOfLinenumbers = n.NumberOfLinenumbers;
                    e.Characteristics = n.Characteristics;
                    m[i] = e;
                }
                return m;
            }
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_ProcessGetProcAddressW")]
        public static extern ulong ProcessGetProcAddress(uint pid, [MarshalAs(UnmanagedType.LPWStr)] string wszModuleName, [MarshalAs(UnmanagedType.LPStr)] string szFunctionName);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_ProcessGetModuleBaseW")]
        public static extern ulong ProcessGetModuleBase(uint pid, [MarshalAs(UnmanagedType.LPWStr)] string wszModuleName);



        //---------------------------------------------------------------------
        // WINDOWS SPECIFIC DEBUGGING / SYMBOL FUNCTIONALITY BELOW:
        //---------------------------------------------------------------------

        public static unsafe bool PdbLoad(uint pid, ulong vaModuleBase, out string szModuleName)
        {
            szModuleName = "";
            byte[] data = new byte[260];
            fixed (byte* pb = data)
            {
                bool result = vmmi.VMMDLL_PdbLoad(pid, vaModuleBase, pb);
                if(!result) { return false; }
                szModuleName = Encoding.UTF8.GetString(data);
                szModuleName = szModuleName.Substring(0, szModuleName.IndexOf((char)0));
            }
            return true;
        }

        public static unsafe bool PdbSymbolName(string szModule, ulong cbSymbolAddressOrOffset, out string szSymbolName, out uint pdwSymbolDisplacement)
        {
            szSymbolName = "";
            pdwSymbolDisplacement = 0;
            byte[] data = new byte[260];
            fixed (byte* pb = data)
            {
                bool result = vmmi.VMMDLL_PdbSymbolName(szModule, cbSymbolAddressOrOffset, pb, out pdwSymbolDisplacement);
                if (!result) { return false; }
                szSymbolName = Encoding.UTF8.GetString(data);
                szSymbolName = szSymbolName.Substring(0, szSymbolName.IndexOf((char)0));
            }
            return true;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_PdbSymbolAddress")]
        public static extern bool PdbSymbolAddress([MarshalAs(UnmanagedType.LPStr)] string szModule, [MarshalAs(UnmanagedType.LPStr)] string szSymbolName, out ulong pvaSymbolAddress);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_PdbTypeSize")]
        public static extern bool PdbTypeSize([MarshalAs(UnmanagedType.LPStr)] string szModule, [MarshalAs(UnmanagedType.LPStr)] string szTypeName, out uint pcbTypeSize);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_PdbTypeChildOffset")]
        public static extern bool PdbTypeChildOffset([MarshalAs(UnmanagedType.LPStr)] string szModule, [MarshalAs(UnmanagedType.LPStr)] string szTypeName, [MarshalAs(UnmanagedType.LPStr)] string wszTypeChildName, out uint pcbTypeChildOffset);





        //---------------------------------------------------------------------
        // "MAP" FUNCTIONALITY BELOW:
        //---------------------------------------------------------------------

        public static ulong MEMMAP_FLAG_PAGE_W =    0x0000000000000002;
        public static ulong MEMMAP_FLAG_PAGE_NS =   0x0000000000000004;
        public static ulong MEMMAP_FLAG_PAGE_NX =   0x8000000000000000;
        public static ulong MEMMAP_FLAG_PAGE_MASK = 0x8000000000000006;

        public struct MAP_PTEENTRY
        {
            public ulong vaBase;
            public ulong vaEnd;
            public ulong cbSize;
            public ulong cPages;
            public ulong fPage;
            public bool fWoW64;
            public string wszText;
            public uint cSoftware;
        }

        public struct MAP_VADENTRY
        {
            public ulong vaStart;
            public ulong vaEnd;
            public ulong vaVad;
            public ulong cbSize;
            public uint VadType;
            public uint Protection;
            public bool fImage;
            public bool fFile;
            public bool fPageFile;
            public bool fPrivateMemory;
            public bool fTeb;
            public bool fStack;
            public uint fSpare;
            public uint HeapNum;
            public bool fHeap;
            public uint cwszDescription;
            public uint CommitCharge;
            public bool MemCommit;
            public uint u2;
            public uint cbPrototypePte;
            public ulong vaPrototypePte;
            public ulong vaSubsection;
            public string wszText;
            public ulong vaFileObject;
            public uint cVadExPages;
            public uint cVadExPagesBase;
        }

        public struct MAP_VADEXENTRY_PROTOTYPE
        {
            public uint tp;
            public ulong pa;
            public ulong pte;
        }

        public struct MAP_VADEXENTRY
        {
            public uint tp;
            public uint iPML;
            public ulong va;
            public ulong pa;
            public ulong pte;
            public MAP_VADEXENTRY_PROTOTYPE proto;
            public ulong vaVadBase;
        }

        public static uint MAP_MODULEENTRY_TP_NORMAL    = 0;
        public static uint VMMDLL_MODULE_TP_DATA        = 1;
        public static uint VMMDLL_MODULE_TP_NOTLINKED   = 2;
        public static uint VMMDLL_MODULE_TP_INJECTED    = 3;

        public struct MAP_MODULEENTRY
        {
            public bool fValid;
            public ulong vaBase;
            public ulong vaEntry;
            public uint cbImageSize;
            public bool fWow64;
            public string wszText;
            public string wszFullName;
            public uint tp;
            public uint cbFileSizeRaw;
            public uint cSection;
            public uint cEAT;
            public uint cIAT;
        }

        public struct MAP_UNLOADEDMODULEENTRY
        {
            public ulong vaBase;
            public uint cbImageSize;
            public bool fWow64;
            public string wszText;
            public uint dwCheckSum;         // user-mode only
            public uint dwTimeDateStamp;    // user-mode only
            public ulong ftUnload;          // kernel-mode only
        }

        public struct MAP_EATINFO
        {
            public bool fValid; 
            public ulong vaModuleBase;
            public ulong vaAddressOfFunctions;
            public ulong vaAddressOfNames;
            public uint cNumberOfFunctions;
            public uint cNumberOfNames;
            public uint dwOrdinalBase;
        }

        public struct MAP_EATENTRY
        {
            public ulong vaFunction;
            public uint dwOrdinal;
            public uint oFunctionsArray;
            public uint oNamesArray;
            public string wszFunction;
        }

        public struct MAP_IATENTRY
        {
            public ulong vaFunction;
            public ulong vaModule;
            public string wszFunction;
            public string wszModule;
            public bool f32;
            public ushort wHint;
            public uint rvaFirstThunk;
            public uint rvaOriginalFirstThunk;
            public uint rvaNameModule;
            public uint rvaNameFunction;
        }

        public struct MAP_HEAPENTRY
        {
            public ulong vaHeapSegment;
            public uint cPages;
            public uint cPagesUnCommitted;
            public uint HeapId;
            public bool fPrimary;
        }

        public struct MAP_THREADENTRY
        {
            public uint dwTID;
            public uint dwPID;
            public uint dwExitStatus;
            public byte bState;
            public byte bRunning;
            public byte bPriority;
            public byte bBasePriority;
            public ulong vaETHREAD;
            public ulong vaTeb;
            public ulong ftCreateTime;
            public ulong ftExitTime;
            public ulong vaStartAddress;
            public ulong vaStackBaseUser;
            public ulong vaStackLimitUser;
            public ulong vaStackBaseKernel;
            public ulong vaStackLimitKernel;
            public ulong vaTrapFrame;
            public ulong vaRIP;
            public ulong vaRSP;
            public ulong qwAffinity;
            public uint dwUserTime;
            public uint dwKernelTime;
            public byte bSuspendCount;
        }

        public struct MAP_HANDLEENTRY
        {
            public ulong vaObject;
            public uint dwHandle;
            public uint dwGrantedAccess;
            public uint iType;
            public ulong qwHandleCount;
            public ulong qwPointerCount;
            public ulong vaObjectCreateInfo;
            public ulong vaSecurityDescriptor;
            public string wszText;
            public uint dwPID;
            public uint dwPoolTag;
            public string wszType;
        }

        public struct MAP_NETENTRY_ADDR
        {
            public bool fValid;
            public ushort port;
            public byte[] pbAddr;
            public string wszText;
        }

        public struct MAP_NETENTRY
        {
            public uint dwPID;
            public uint dwState;
            public uint dwPoolTag;
            public ushort AF;
            public MAP_NETENTRY_ADDR src;
            public MAP_NETENTRY_ADDR dst;
            public ulong vaObj;
            public ulong ftTime;
            public string wszText;
        }

        public struct MAP_PHYSMEMENTRY
        {
            public ulong pa;
            public ulong cb;
        }
        
        public struct MAP_USERENTRY
        {
            public string szSID;
            public string wszText;
            public ulong vaRegHive;
        }

        public struct MAP_SERVICEENTRY
        {
            public ulong vaObj;
            public uint dwPID;
            public uint dwOrdinal;
            public string wszServiceName;
            public string wszDisplayName;
            public string wszPath;
            public string wszUserTp;
            public string wszUserAcct;
            public string wszImagePath;
            public uint dwStartType;
            public uint dwServiceType;
            public uint dwCurrentState;
            public uint dwControlsAccepted;
            public uint dwWin32ExitCode;
            public uint dwServiceSpecificExitCode;
            public uint dwCheckPoint;
            public uint dwWaitHint;
        }

        public enum MAP_PFN_TYPE
        {
            Zero = 0,
            Free = 1,
            Standby = 2,
            Modified = 3,
            ModifiedNoWrite = 4,
            Bad = 5,
            Active = 6,
            Transition = 7
        }

        public enum MAP_PFN_TYPEEXTENDED
        {
            Unknown = 0,
            Unused = 1,
            ProcessPrivate = 2,
            PageTable = 3,
            LargePage = 4,
            DriverLocked = 5,
            Shareable = 6,
            File = 7,
        }

        public struct MAP_PFNENTRY
        {
            public uint dwPfn;
            public MAP_PFN_TYPE tp;
            public MAP_PFN_TYPEEXTENDED tpExtended;
            public ulong va;
            public ulong vaPte;
            public ulong OriginalPte;
            public uint dwPID;
            public bool fPrototype;
            public bool fModified;
            public bool fReadInProgress;
            public bool fWriteInProgress;
            public byte priority;
        }

        public static unsafe MAP_PTEENTRY[] Map_GetPte(uint pid, bool fIdentifyModules = true)
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_PTE));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_PTEENTRY));
            result = vmmi.VMMDLL_Map_GetPte(pid, null, ref cb, fIdentifyModules);
            if (!result || (cb == 0)) { return new MAP_PTEENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetPte(pid, pb, ref cb, fIdentifyModules);
                if (!result) { return new MAP_PTEENTRY[0]; }
                vmmi.VMMDLL_MAP_PTE pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_PTE>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_PTE_VERSION) { return new MAP_PTEENTRY[0]; }
                MAP_PTEENTRY[] m = new MAP_PTEENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_PTEENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_PTEENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_PTEENTRY e;
                    e.vaBase = n.vaBase;
                    e.vaEnd = n.vaBase + (n.cPages << 12) - 1;
                    e.cbSize = n.cPages << 12;
                    e.cPages = n.cPages;
                    e.fPage = n.fPage;
                    e.fWoW64 = n.fWoW64;
                    e.wszText = n.wszText;
                    e.cSoftware = n.cSoftware;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_VADENTRY[] Map_GetVad(uint pid, bool fIdentifyModules = true)
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_VAD));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_VADENTRY));
            result = vmmi.VMMDLL_Map_GetVad(pid, null, ref cb, fIdentifyModules);
            if (!result || (cb == 0)) { return new MAP_VADENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetVad(pid, pb, ref cb, fIdentifyModules);
                if (!result) { return new MAP_VADENTRY[0]; }
                vmmi.VMMDLL_MAP_VAD pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_VAD>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_VAD_VERSION) { return new MAP_VADENTRY[0]; }
                MAP_VADENTRY[] m = new MAP_VADENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_VADENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_VADENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_VADENTRY e;
                    e.vaStart = n.vaStart;
                    e.vaEnd = n.vaEnd;
                    e.cbSize = n.vaEnd + 1 - n.vaStart;
                    e.vaVad = n.vaVad;
                    e.VadType = n.dw0 & 0x07;
                    e.Protection = (n.dw0 >> 3) & 0x1f;
                    e.fImage = ((n.dw0 >> 8) & 1) == 1;
                    e.fFile = ((n.dw0 >> 9) & 1) == 1;
                    e.fPageFile = ((n.dw0 >> 10) & 1) == 1;
                    e.fPrivateMemory = ((n.dw0 >> 11) & 1) == 1;
                    e.fTeb = ((n.dw0 >> 12) & 1) == 1;
                    e.fStack = ((n.dw0 >> 13) & 1) == 1;
                    e.fSpare = (n.dw0 >> 14) & 0x03;
                    e.HeapNum = (n.dw0 >> 16) & 0x1f;
                    e.fHeap = ((n.dw0 >> 23) & 1) == 1;
                    e.cwszDescription = (n.dw0 >> 24) & 0xff;
                    e.CommitCharge = n.dw1 & 0x7fffffff;
                    e.MemCommit = ((n.dw1 >> 31) & 1) == 1;
                    e.u2 = n.u2;
                    e.cbPrototypePte = n.cbPrototypePte;
                    e.vaPrototypePte = n.vaPrototypePte;
                    e.vaSubsection = n.vaSubsection;
                    e.wszText = n.wszText;
                    e.vaFileObject = n.vaFileObject;
                    e.cVadExPages = n.cVadExPages;
                    e.cVadExPagesBase = n.cVadExPagesBase;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_VADEXENTRY[] Map_GetVadEx(uint pid, uint oPages, uint cPages)
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_VADEX));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_VADEXENTRY));
            result = vmmi.VMMDLL_Map_GetVadEx(pid, null, ref cb, oPages, cPages);
            if (!result || (cb == 0)) { return new MAP_VADEXENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetVadEx(pid, pb, ref cb, oPages, cPages);
                if (!result) { return new MAP_VADEXENTRY[0]; }
                vmmi.VMMDLL_MAP_VADEX pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_VADEX>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_VADEX_VERSION) { return new MAP_VADEXENTRY[0]; }
                MAP_VADEXENTRY[] m = new MAP_VADEXENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_VADEXENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_VADEXENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_VADEXENTRY e;
                    e.tp = n.tp;
                    e.iPML = n.iPML;
                    e.va = n.va;
                    e.pa = n.pa;
                    e.pte = n.pte;
                    e.proto.tp = n.proto_tp;
                    e.proto.pa = n.proto_pa;
                    e.proto.pte = n.proto_pte;
                    e.vaVadBase = n.vaVadBase;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_MODULEENTRY[] Map_GetModule(uint pid)
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_MODULE));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_MODULEENTRY));
            result = vmmi.VMMDLL_Map_GetModule(pid, null, ref cb);
            if(!result || (cb == 0)) { return new MAP_MODULEENTRY[0]; }
            fixed(byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetModule(pid, pb, ref cb);
                if(!result) { return new MAP_MODULEENTRY[0]; }
                vmmi.VMMDLL_MAP_MODULE pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_MODULE>((System.IntPtr)pb);
                if(pm.dwVersion != vmmi.VMMDLL_MAP_MODULE_VERSION) { return new MAP_MODULEENTRY[0]; }
                MAP_MODULEENTRY[] m = new MAP_MODULEENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_MODULEENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_MODULEENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_MODULEENTRY e;
                    e.fValid = true;
                    e.vaBase = n.vaBase;
                    e.vaEntry = n.vaEntry;
                    e.cbImageSize = n.cbImageSize;
                    e.fWow64 = n.fWow64;
                    e.wszText = n.wszText;
                    e.wszFullName = n.wszFullName;
                    e.tp = n.tp;
                    e.cbFileSizeRaw = n.cbFileSizeRaw;
                    e.cSection = n.cSection;
                    e.cEAT = n.cEAT;
                    e.cIAT = n.cIAT;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_MODULEENTRY Map_GetModuleFromName(uint pid, string wszModuleName)
        {
            bool result;
            uint cbENTRY = 0;
            result = vmmi.VMMDLL_Map_GetModuleFromName(pid, wszModuleName, null, ref cbENTRY);
            if (!result || (cbENTRY == 0)) { return new MAP_MODULEENTRY(); }
            fixed (byte* pb = new byte[cbENTRY])
            {
                result = vmmi.VMMDLL_Map_GetModuleFromName(pid, wszModuleName, pb, ref cbENTRY);
                if (!result) { return new MAP_MODULEENTRY(); }
                vmmi.VMMDLL_MAP_MODULEENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_MODULEENTRY>((System.IntPtr)pb);
                MAP_MODULEENTRY e;
                e.fValid = true;
                e.vaBase = n.vaBase;
                e.vaEntry = n.vaEntry;
                e.cbImageSize = n.cbImageSize;
                e.fWow64 = n.fWow64;
                e.wszText = wszModuleName;
                e.wszFullName = n.wszFullName;
                e.tp = n.tp;
                e.cbFileSizeRaw = n.cbFileSizeRaw;
                e.cSection = n.cSection;
                e.cEAT = n.cEAT;
                e.cIAT = n.cIAT;
                return e;
            }
        }

        public static unsafe MAP_UNLOADEDMODULEENTRY[] Map_GetUnloadedModule(uint pid)
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_UNLOADEDMODULE));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_UNLOADEDMODULEENTRY));
            result = vmmi.VMMDLL_Map_GetUnloadedModule(pid, null, ref cb);
            if (!result || (cb == 0)) { return new MAP_UNLOADEDMODULEENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetUnloadedModule(pid, pb, ref cb);
                if (!result) { return new MAP_UNLOADEDMODULEENTRY[0]; }
                vmmi.VMMDLL_MAP_UNLOADEDMODULE pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_UNLOADEDMODULE>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_UNLOADEDMODULE_VERSION) { return new MAP_UNLOADEDMODULEENTRY[0]; }
                MAP_UNLOADEDMODULEENTRY[] m = new MAP_UNLOADEDMODULEENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_UNLOADEDMODULEENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_UNLOADEDMODULEENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_UNLOADEDMODULEENTRY e;
                    e.vaBase = n.vaBase;
                    e.cbImageSize = n.cbImageSize;
                    e.fWow64 = n.fWow64;
                    e.wszText = n.wszText;
                    e.dwCheckSum = n.dwCheckSum;
                    e.dwTimeDateStamp = n.dwTimeDateStamp;
                    e.ftUnload = n.ftUnload;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_EATENTRY[] Map_GetEAT(uint pid, string wszModule, out MAP_EATINFO EatInfo)
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_EAT));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_EATENTRY));
            EatInfo = new MAP_EATINFO();
            result = vmmi.VMMDLL_Map_GetEAT(pid, wszModule, null, ref cb);
            if (!result || (cb == 0)) { return new MAP_EATENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetEAT(pid, wszModule, pb, ref cb);
                if (!result) { return new MAP_EATENTRY[0]; }
                vmmi.VMMDLL_MAP_EAT pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_EAT>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_EAT_VERSION) { return new MAP_EATENTRY[0]; }
                MAP_EATENTRY[] m = new MAP_EATENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_EATENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_EATENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_EATENTRY e;
                    e.vaFunction = n.vaFunction;
                    e.dwOrdinal = n.dwOrdinal;
                    e.oFunctionsArray = n.oFunctionsArray;
                    e.oNamesArray = n.oNamesArray;
                    e.wszFunction = n.wszFunction;
                    m[i] = e;
                }
                EatInfo.fValid = true;
                EatInfo.vaModuleBase = pm.vaModuleBase;
                EatInfo.vaAddressOfFunctions = pm.vaAddressOfFunctions;
                EatInfo.vaAddressOfNames = pm.vaAddressOfNames;
                EatInfo.cNumberOfFunctions = pm.cNumberOfFunctions;
                EatInfo.cNumberOfNames = pm.cNumberOfNames;
                EatInfo.dwOrdinalBase = pm.dwOrdinalBase;
                return m;
            }
        }

        public static unsafe MAP_IATENTRY[] Map_GetIAT(uint pid, string wszModule)
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_IAT));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_IATENTRY));
            result = vmmi.VMMDLL_Map_GetIAT(pid, wszModule, null, ref cb);
            if (!result || (cb == 0)) { return new MAP_IATENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetIAT(pid, wszModule, pb, ref cb);
                if (!result) { return new MAP_IATENTRY[0]; }
                vmmi.VMMDLL_MAP_IAT pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_IAT>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_IAT_VERSION) { return new MAP_IATENTRY[0]; }
                MAP_IATENTRY[] m = new MAP_IATENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_IATENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_IATENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_IATENTRY e;
                    e.vaFunction = n.vaFunction;
                    e.wszFunction = n.wszFunction;
                    e.wszModule = n.wszModule;
                    e.f32 = n.f32;
                    e.wHint = n.wHint;
                    e.rvaFirstThunk = n.rvaFirstThunk;
                    e.rvaOriginalFirstThunk = n.rvaOriginalFirstThunk;
                    e.rvaNameModule = n.rvaNameModule;
                    e.rvaNameFunction = n.rvaNameFunction;
                    e.vaModule = pm.vaModuleBase;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_HEAPENTRY[] Map_GetHeap(uint pid)
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_HEAP));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_HEAPENTRY));
            result = vmmi.VMMDLL_Map_GetHeap(pid, null, ref cb);
            if (!result || (cb == 0)) { return new MAP_HEAPENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetHeap(pid, pb, ref cb);
                if (!result) { return new MAP_HEAPENTRY[0]; }
                vmmi.VMMDLL_MAP_HEAP pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_HEAP>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_HEAP_VERSION) { return new MAP_HEAPENTRY[0]; }
                MAP_HEAPENTRY[] m = new MAP_HEAPENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_HEAPENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_HEAPENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_HEAPENTRY e;
                    e.vaHeapSegment = n.vaHeapSegment;
                    e.cPages = n.cPages;
                    e.cPagesUnCommitted = n.cPagesUnCommitted_HeapId_fPrimary & 0x00ffffff;
                    e.HeapId = (n.cPagesUnCommitted_HeapId_fPrimary >> 24) & 0x7f;
                    e.fPrimary = (n.cPagesUnCommitted_HeapId_fPrimary >> 31) == 1;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_THREADENTRY[] Map_GetThread(uint pid)
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_THREAD));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_THREADENTRY));
            result = vmmi.VMMDLL_Map_GetThread(pid, null, ref cb);
            if (!result || (cb == 0)) { return new MAP_THREADENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetThread(pid, pb, ref cb);
                if (!result) { return new MAP_THREADENTRY[0]; }
                vmmi.VMMDLL_MAP_THREAD pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_THREAD>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_THREAD_VERSION) { return new MAP_THREADENTRY[0]; }
                MAP_THREADENTRY[] m = new MAP_THREADENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_THREADENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_THREADENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_THREADENTRY e;
                    e.dwTID = n.dwTID;
                    e.dwPID = n.dwPID;
                    e.dwExitStatus = n.dwExitStatus;
                    e.bState = n.bState;
                    e.bRunning = n.bRunning;
                    e.bPriority = n.bPriority;
                    e.bBasePriority = n.bBasePriority;
                    e.vaETHREAD = n.vaETHREAD;
                    e.vaTeb = n.vaTeb;
                    e.ftCreateTime = n.ftCreateTime;
                    e.ftExitTime = n.ftExitTime;
                    e.vaStartAddress = n.vaStartAddress;
                    e.vaStackBaseUser = n.vaStackBaseUser;
                    e.vaStackLimitUser = n.vaStackLimitUser;
                    e.vaStackBaseKernel = n.vaStackBaseKernel;
                    e.vaStackLimitKernel = n.vaStackLimitKernel;
                    e.vaTrapFrame = n.vaTrapFrame;
                    e.vaRIP = n.vaRIP;
                    e.vaRSP = n.vaRSP;
                    e.qwAffinity = n.qwAffinity;
                    e.dwUserTime = n.dwUserTime;
                    e.dwKernelTime = n.dwKernelTime;
                    e.bSuspendCount = n.bSuspendCount;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_HANDLEENTRY[] Map_GetHandle(uint pid)
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_HANDLE));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_HANDLEENTRY));
            result = vmmi.VMMDLL_Map_GetHandle(pid, null, ref cb);
            if (!result || (cb == 0)) { return new MAP_HANDLEENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetHandle(pid, pb, ref cb);
                if (!result) { return new MAP_HANDLEENTRY[0]; }
                vmmi.VMMDLL_MAP_HANDLE pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_HANDLE>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_HANDLE_VERSION) { return new MAP_HANDLEENTRY[0]; }
                MAP_HANDLEENTRY[] m = new MAP_HANDLEENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_HANDLEENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_HANDLEENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_HANDLEENTRY e;
                    e.vaObject = n.vaObject;
                    e.dwHandle = n.dwHandle;
                    e.dwGrantedAccess = n.dwGrantedAccess_iType & 0x00ffffff;
                    e.iType = n.dwGrantedAccess_iType >> 24;
                    e.qwHandleCount = n.qwHandleCount;
                    e.qwPointerCount = n.qwPointerCount;
                    e.vaObjectCreateInfo = n.vaObjectCreateInfo;
                    e.vaSecurityDescriptor = n.vaSecurityDescriptor;
                    e.wszText = n.wszText;
                    e.dwPID = n.dwPID;
                    e.dwPoolTag = n.dwPoolTag;
                    e.wszType = n.wszType;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_NETENTRY[] Map_GetNet()
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_NET));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_NETENTRY));
            result = vmmi.VMMDLL_Map_GetNet(null, ref cb);
            if (!result || (cb == 0)) { return new MAP_NETENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetNet(pb, ref cb);
                if (!result) { return new MAP_NETENTRY[0]; }
                vmmi.VMMDLL_MAP_NET pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_NET>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_NET_VERSION) { return new MAP_NETENTRY[0]; }
                MAP_NETENTRY[] m = new MAP_NETENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_NETENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_NETENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_NETENTRY e;
                    e.dwPID = n.dwPID;
                    e.dwState = n.dwState;
                    e.dwPoolTag = n.dwPoolTag;
                    e.AF = n.AF;
                    e.src.fValid = n.src_fValid;
                    e.src.port = n.src_port;
                    e.src.pbAddr = n.src_pbAddr;
                    e.src.wszText = n.src_wszText;
                    e.dst.fValid = n.dst_fValid;
                    e.dst.port = n.dst_port;
                    e.dst.pbAddr = n.dst_pbAddr;
                    e.dst.wszText = n.dst_wszText;
                    e.vaObj = n.vaObj;
                    e.ftTime = n.ftTime;
                    e.wszText = n.wszText;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_PHYSMEMENTRY[] Map_GetPhysMem()
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_PHYSMEM));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_PHYSMEMENTRY));
            result = vmmi.VMMDLL_Map_GetPhysMem(null, ref cb);
            if (!result || (cb == 0)) { return new MAP_PHYSMEMENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetPhysMem(pb, ref cb);
                if (!result) { return new MAP_PHYSMEMENTRY[0]; }
                vmmi.VMMDLL_MAP_PHYSMEM pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_PHYSMEM>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_PHYSMEM_VERSION) { return new MAP_PHYSMEMENTRY[0]; }
                MAP_PHYSMEMENTRY[] m = new MAP_PHYSMEMENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_PHYSMEMENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_PHYSMEMENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_PHYSMEMENTRY e;
                    e.pa = n.pa;
                    e.cb = n.cb;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_USERENTRY[] Map_GetUsers()
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_USER));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_USERENTRY));
            result = vmmi.VMMDLL_Map_GetUsers(null, ref cb);
            if (!result || (cb == 0)) { return new MAP_USERENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetUsers(pb, ref cb);
                if (!result) { return new MAP_USERENTRY[0]; }
                vmmi.VMMDLL_MAP_USER pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_USER>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_USER_VERSION) { return new MAP_USERENTRY[0]; }
                MAP_USERENTRY[] m = new MAP_USERENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_USERENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_USERENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_USERENTRY e;
                    e.szSID = n.wszSID;
                    e.wszText = n.wszText;
                    e.vaRegHive = n.vaRegHive;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_SERVICEENTRY[] Map_GetServices()
        {
            bool result;
            uint cb = 0;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_SERVICE));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_SERVICEENTRY));
            result = vmmi.VMMDLL_Map_GetServices(null, ref cb);
            if (!result || (cb == 0)) { return new MAP_SERVICEENTRY[0]; }
            fixed (byte* pb = new byte[cb])
            {
                result = vmmi.VMMDLL_Map_GetServices(pb, ref cb);
                if (!result) { return new MAP_SERVICEENTRY[0]; }
                vmmi.VMMDLL_MAP_SERVICE pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_SERVICE>((System.IntPtr)pb);
                if (pm.dwVersion != vmmi.VMMDLL_MAP_SERVICE_VERSION) { return new MAP_SERVICEENTRY[0]; }
                MAP_SERVICEENTRY[] m = new MAP_SERVICEENTRY[pm.cMap];
                for (int i = 0; i < pm.cMap; i++)
                {
                    vmmi.VMMDLL_MAP_SERVICEENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_SERVICEENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                    MAP_SERVICEENTRY e;
                    e.vaObj = n.vaObj;
                    e.dwPID = n.dwPID;
                    e.dwOrdinal = n.dwOrdinal;
                    e.wszServiceName = n.wszServiceName;
                    e.wszDisplayName = n.wszDisplayName;
                    e.wszPath = n.wszPath;
                    e.wszUserTp = n.wszUserTp;
                    e.wszUserAcct = n.wszUserAcct;
                    e.wszImagePath = n.wszImagePath;
                    e.dwStartType = n.dwStartType;
                    e.dwServiceType = n.dwServiceType;
                    e.dwCurrentState = n.dwCurrentState;
                    e.dwControlsAccepted = n.dwControlsAccepted;
                    e.dwWin32ExitCode = n.dwWin32ExitCode;
                    e.dwServiceSpecificExitCode = n.dwServiceSpecificExitCode;
                    e.dwCheckPoint = n.dwCheckPoint;
                    e.dwWaitHint = n.dwWaitHint;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe MAP_PFNENTRY[] Map_GetPfn(params uint[] pfns)
        {
            bool result;
            uint cbPfns;
            int cbMAP = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_PFN));
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_MAP_PFNENTRY));
            if (pfns.Length == 0) { return new MAP_PFNENTRY[0]; }
            byte[] dataPfns = new byte[pfns.Length * sizeof(uint)];
            System.Buffer.BlockCopy(pfns, 0, dataPfns, 0, dataPfns.Length);
            fixed (byte* pbPfns = dataPfns)
            {
                cbPfns = (uint)(cbMAP + pfns.Length * cbENTRY);
                fixed (byte* pb = new byte[cbPfns])
                {
                    result =
                        vmmi.VMMDLL_Map_GetPfn(pbPfns, (uint)pfns.Length, null, ref cbPfns) &&
                        vmmi.VMMDLL_Map_GetPfn(pbPfns, (uint)pfns.Length, pb, ref cbPfns);
                    if (!result) { return new MAP_PFNENTRY[0]; }
                    vmmi.VMMDLL_MAP_PFN pm = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_PFN>((System.IntPtr)pb);
                    if (pm.dwVersion != vmmi.VMMDLL_MAP_PFN_VERSION) { return new MAP_PFNENTRY[0]; }
                    MAP_PFNENTRY[] m = new MAP_PFNENTRY[pm.cMap];
                    for (int i = 0; i < pm.cMap; i++)
                    {
                        vmmi.VMMDLL_MAP_PFNENTRY n = Marshal.PtrToStructure<vmmi.VMMDLL_MAP_PFNENTRY>((System.IntPtr)(pb + cbMAP + i * cbENTRY));
                        MAP_PFNENTRY e = new MAP_PFNENTRY();
                        e.dwPfn = n.dwPfn;
                        e.tp = (MAP_PFN_TYPE)(n._u3 & 0x07);
                        e.tpExtended = (MAP_PFN_TYPEEXTENDED)n.tpExtended;
                        e.vaPte = n.vaPte;
                        e.OriginalPte = n.OriginalPte;
                        e.fModified = ((n._u3 >> 20) & 1) == 1;
                        e.fReadInProgress = ((n._u3 >> 21) & 1) == 1;
                        e.fWriteInProgress = ((n._u3 >> 19) & 1) == 1;
                        e.priority = (byte)((n._u3 >> 24) & 7);
                        e.fPrototype = ((n._u4 >> 57) & 1) == 1;
                        if ((e.tp == MAP_PFN_TYPE.Active) && !e.fPrototype)
                        {
                            e.va = n.va;
                            e.dwPID = n.dwPfnPte[0];
                        }
                        m[i] = e;
                    }
                    return m;
                }
            }
        }



        //---------------------------------------------------------------------
        // REGISTRY FUNCTIONALITY BELOW:
        //---------------------------------------------------------------------

        public struct REGISTRY_HIVE_INFORMATION
        {
            public ulong vaCMHIVE;
            public ulong vaHBASE_BLOCK;
            public uint cbLength;
            public string szName;
            public string szNameShort;
            public string szHiveRootPath;
        }

        public struct REGISTRY_KEY_ENUM
        {
            public string name;
            public ulong ftLastWriteTime;
        }

        public struct REGISTRY_VALUE_ENUM
        {
            public string name;
            public uint type;
            public uint cbData;
        }

        public struct REGISTRY_ENUM
        {
            public string wszFullPathKey;
            public List<REGISTRY_KEY_ENUM> KeyList;
            public List<REGISTRY_VALUE_ENUM> ValueList;
        }

        public static unsafe REGISTRY_HIVE_INFORMATION[] RegHiveList()
        {
            bool result;
            uint cHives;
            int cbENTRY = System.Runtime.InteropServices.Marshal.SizeOf(typeof(vmmi.VMMDLL_REGISTRY_HIVE_INFORMATION));
            result = vmmi.VMMDLL_WinReg_HiveList(null, 0, out cHives);
            if (!result || (cHives == 0)) { return new REGISTRY_HIVE_INFORMATION[0]; }
            fixed (byte* pb = new byte[cHives * cbENTRY])
            {
                result = vmmi.VMMDLL_WinReg_HiveList(pb, cHives, out cHives);
                if (!result) { return new REGISTRY_HIVE_INFORMATION[0]; }
                REGISTRY_HIVE_INFORMATION[] m = new REGISTRY_HIVE_INFORMATION[cHives];
                for (int i = 0; i < cHives; i++)
                {
                    vmmi.VMMDLL_REGISTRY_HIVE_INFORMATION n = Marshal.PtrToStructure<vmmi.VMMDLL_REGISTRY_HIVE_INFORMATION>((System.IntPtr)(pb + i * cbENTRY));
                    REGISTRY_HIVE_INFORMATION e;
                    e.vaCMHIVE = n.vaCMHIVE;
                    e.vaHBASE_BLOCK = n.vaHBASE_BLOCK;
                    e.cbLength = n.cbLength;
                    e.szName = System.Text.Encoding.UTF8.GetString(n.szName);
                    e.szName = e.szName.Substring(0, e.szName.IndexOf((char)0));
                    e.szNameShort = n.wszNameShort;
                    e.szHiveRootPath = n.wszHiveRootPath;
                    m[i] = e;
                }
                return m;
            }
        }

        public static unsafe byte[] RegHiveRead(ulong vaCMHIVE, uint ra, uint cb, uint flags = 0)
        {
            uint cbRead;
            byte[] data = new byte[cb];
            fixed (byte* pb = data)
            {
                if(!vmmi.VMMDLL_WinReg_HiveReadEx(vaCMHIVE, ra, pb, cb, out cbRead, flags))
                {
                    return null;
                }
            }
            if(cbRead != cb)
            {
                Array.Resize<byte>(ref data, (int)cbRead);
            }
            return data;
        }


        public static unsafe bool RegHiveWrite(ulong vaCMHIVE, uint ra, byte[] data)
        {
            fixed (byte* pb = data)
            {
                return vmmi.VMMDLL_WinReg_HiveWrite(vaCMHIVE, ra, pb, (uint)data.Length);
            }
        }

        public static unsafe REGISTRY_ENUM RegEnum(string wszFullPathKey)
        {
            uint i, cchName, lpType, cbData = 0;
            ulong ftLastWriteTime;
            REGISTRY_ENUM re = new REGISTRY_ENUM();
            re.wszFullPathKey = wszFullPathKey;
            re.KeyList = new List<REGISTRY_KEY_ENUM>();
            re.ValueList = new List<REGISTRY_VALUE_ENUM>();
            fixed (byte* pb = new byte[0x1000])
            {
                i = 0;
                cchName = 0x800;
                while (vmmi.VMMDLL_WinReg_EnumKeyExW(wszFullPathKey, i, pb, ref cchName, out ftLastWriteTime))
                {
                    REGISTRY_KEY_ENUM e = new REGISTRY_KEY_ENUM();
                    e.ftLastWriteTime = ftLastWriteTime;
                    e.name = new string((sbyte*)pb, 0, 2 * (int)Math.Max(1, cchName) - 2, Encoding.Unicode);
                    re.KeyList.Add(e);
                    i++;
                    cchName = 0x800;
                }
                i = 0;
                cchName = 0x800;
                while (vmmi.VMMDLL_WinReg_EnumValueW(wszFullPathKey, i, pb, ref cchName, out lpType, null, ref cbData))
                {
                    REGISTRY_VALUE_ENUM e = new REGISTRY_VALUE_ENUM();
                    e.type = lpType;
                    e.cbData = cbData;
                    e.name = new string((sbyte*)pb, 0, 2 * (int)Math.Max(1, cchName) - 2, Encoding.Unicode);
                    re.ValueList.Add(e);
                    i++;
                    cchName = 0x800;
                }
            }
            return re;
        }

        public static unsafe byte[] RegValueRead(string wszFullPathKeyValue, out uint tp)
        {
            bool result;
            uint cb = 0;
            result = vmmi.VMMDLL_WinReg_QueryValueExW(wszFullPathKeyValue, out tp, null, ref cb);
            if(!result)
            {
                return null;
            }
            byte[] data = new byte[cb];
            fixed (byte* pb = data)
            {
                result = vmmi.VMMDLL_WinReg_QueryValueExW(wszFullPathKeyValue, out tp, pb, ref cb);
                return result ? data : null;
            }
        }
    }



    internal static class lci
    {
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct LC_CONFIG_ERRORINFO
        {
            internal uint dwVersion;
            internal uint cbStruct;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)] internal uint[] _FutureUse;
            internal bool fUserInputRequest;
            internal uint cwszUserText;
            // szUserText
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct LC_MEM_SCATTER
        {
            internal uint version;
            internal bool f;
            internal ulong qwA;
            internal IntPtr pb;
            internal uint cb;
            internal uint iStack;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 12)] internal ulong[] vStack;
        }

        [DllImport("leechcore.dll", EntryPoint = "LcCreateEx")]
        public static extern ulong LcCreateEx(ref lc.CONFIG pLcCreateConfig, out IntPtr ppLcCreateErrorInfo);

        [DllImport("leechcore.dll", EntryPoint = "LcMemFree")]
        internal static extern unsafe void LcMemFree(IntPtr pv);

        [DllImport("leechcore.dll", EntryPoint = "LcAllocScatter1")]
        internal static extern unsafe bool LcAllocScatter1(uint cMEMs, out IntPtr pppMEMs);

        [DllImport("leechcore.dll", EntryPoint = "LcRead")]
        internal static extern unsafe bool LcRead(ulong hLC, ulong pa, uint cb, byte* pb);

        [DllImport("leechcore.dll", EntryPoint = "LcReadScatter")]
        internal static extern unsafe void LcReadScatter(ulong hLC, uint cMEMs, IntPtr ppMEMs);

        [DllImport("leechcore.dll", EntryPoint = "LcWrite")]
        internal static extern unsafe bool LcWrite(ulong hLC, ulong pa, uint cb, byte* pb);

        [DllImport("leechcore.dll", EntryPoint = "LcWriteScatter")]
        internal static extern unsafe void LcWriteScatter(ulong hLC, uint cMEMs, IntPtr ppMEMs);

        [DllImport("leechcore.dll", EntryPoint = "LcCommand")]
        internal static extern unsafe bool LcCommand(ulong hLC, ulong fOption, uint cbDataIn, byte* pbDataIn, out IntPtr ppbDataOut, out uint pcbDataOut);
    }



    internal static class vmmi
    {
        internal static ulong MAX_PATH =                     260;
        internal static uint VMMDLL_MAP_PTE_VERSION =        2;
        internal static uint VMMDLL_MAP_VAD_VERSION =        6;
        internal static uint VMMDLL_MAP_VADEX_VERSION =      3;
        internal static uint VMMDLL_MAP_MODULE_VERSION =     5;
        internal static uint VMMDLL_MAP_UNLOADEDMODULE_VERSION = 2;
        internal static uint VMMDLL_MAP_EAT_VERSION =        2;
        internal static uint VMMDLL_MAP_IAT_VERSION =        2;
        internal static uint VMMDLL_MAP_HEAP_VERSION =       2;
        internal static uint VMMDLL_MAP_THREAD_VERSION =     3;
        internal static uint VMMDLL_MAP_HANDLE_VERSION =     2;
        internal static uint VMMDLL_MAP_NET_VERSION =        3;
        internal static uint VMMDLL_MAP_PHYSMEM_VERSION =    2;
        internal static uint VMMDLL_MAP_USER_VERSION =       2;
        internal static uint VMMDLL_MAP_PFN_VERSION =        1;
        internal static uint VMMDLL_MAP_SERVICE_VERSION =    3;



        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Initialize")]
        internal static extern bool VMMDLL_Initialize(
            int argc,
            string[] argv);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_InitializeEx")]
        internal static extern bool VMMDLL_InitializeEx(
            int argc,
            string[] argv,
            out IntPtr ppLcErrorInfo);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_MemFree")]
        internal static extern unsafe bool VMMDLL_MemFree(
            byte* pvMem);



        // VFS (VIRTUAL FILE SYSTEM) FUNCTIONALITY BELOW:

        internal static uint VMMDLL_VFS_FILELIST_EXINFO_VERSION =   1;
        internal static uint VMMDLL_VFS_FILELIST_VERSION =          2;

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_VFS_FILELIST
        {
            internal uint dwVersion;
            internal uint _Reserved;
            internal IntPtr pfnAddFile;
            internal IntPtr pfnAddDirectory;
            internal ulong h;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_VfsListU")]
        internal static extern unsafe bool VMMDLL_VfsList(
            [MarshalAs(UnmanagedType.LPUTF8Str)] string wcsPath,
            ref VMMDLL_VFS_FILELIST pFileList);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_VfsReadU")]
        internal static extern unsafe uint VMMDLL_VfsRead(
            [MarshalAs(UnmanagedType.LPUTF8Str)] string wcsFileName,
            byte* pb,
            uint cb,
            out uint pcbRead,
            ulong cbOffset);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_VfsWriteU")]
        internal static extern unsafe uint VMMDLL_VfsWrite(
            [MarshalAs(UnmanagedType.LPUTF8Str)] string wcsFileName,
            byte* pb,
            uint cb,
            out uint pcbRead,
            ulong cbOffset);



        // MEMORY READ/WRITE FUNCTIONALITY BELOW:

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_MemReadScatter")]
        internal static extern unsafe uint VMMDLL_MemReadScatter(
            uint dwPID,
            IntPtr ppMEMs,
            uint cpMEMs,
            uint flags);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_MemReadEx")]
        internal static extern unsafe bool VMMDLL_MemReadEx(
            uint dwPID,
            ulong qwA,
            byte* pb,
            uint cb,
            out uint pcbReadOpt,
            uint flags);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_MemPrefetchPages")]
        internal static extern unsafe bool VMMDLL_MemPrefetchPages(
            uint dwPID,
            byte* pPrefetchAddresses,
            uint cPrefetchAddresses);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_MemWrite")]
        internal static extern unsafe bool VMMDLL_MemWrite(
            uint dwPID,
            ulong qwA,
            byte* pb,
            uint cb);



        // PROCESS FUNCTIONALITY BELOW:

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_PidList")]
        internal static extern unsafe bool VMMDLL_PidList(byte* pPIDs, ref ulong pcPIDs);

        internal static ulong VMMDLL_PROCESS_INFORMATION_MAGIC =        0xc0ffee663df9301e;
        internal static ushort VMMDLL_PROCESS_INFORMATION_VERSION =     6;

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal struct VMMDLL_PROCESS_INFORMATION
        {
            internal ulong magic;
            internal ushort wVersion;
            internal ushort wSize;
            internal uint tpMemoryModel;
            internal uint tpSystem;
            internal bool fUserOnly;
            internal uint dwPID;
            internal uint dwPPID;
            internal uint dwState;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)] internal string szName;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)] internal string szNameLong;
            internal ulong paDTB;
            internal ulong paDTB_UserOpt;
            internal ulong vaEPROCESS;
            internal ulong vaPEB;
            internal ulong _Reserved1;
            internal bool fWow64;
            internal uint vaPEB32;
            internal uint dwSessionId;
            internal ulong qwLUID;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)] internal string szSID;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_ProcessGetInformation")]
        internal static extern unsafe bool VMMDLL_ProcessGetInformation(
            uint dwPID,
            byte* pProcessInformation,
            ref ulong pcbProcessInformation);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_ProcessGetInformationString")]
        internal static extern unsafe byte* VMMDLL_ProcessGetInformationString(
            uint dwPID,
            uint fOptionString);

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal struct VMMDLL_IMAGE_SECTION_HEADER
        {
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 8)] internal string Name;
            internal uint MiscPhysicalAddressOrVirtualSize;
            internal uint VirtualAddress;
            internal uint SizeOfRawData;
            internal uint PointerToRawData;
            internal uint PointerToRelocations;
            internal uint PointerToLinenumbers;
            internal ushort NumberOfRelocations;
            internal ushort NumberOfLinenumbers;
            internal uint Characteristics;
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_IMAGE_DATA_DIRECTORY
        {
            internal uint VirtualAddress;
            internal uint Size;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_ProcessGetDirectoriesW")]
        internal static extern unsafe bool VMMDLL_ProcessGetDirectories(
            uint dwPID,
            [MarshalAs(UnmanagedType.LPWStr)] string wszModule,
            byte* pData,
            uint cData,
            out uint pcData);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_ProcessGetSectionsW")]
        internal static extern unsafe bool VMMDLL_ProcessGetSections(
            uint dwPID,
            [MarshalAs(UnmanagedType.LPWStr)] string wszModule,
            byte* pData,
            uint cData,
            out uint pcData);



        // WINDOWS SPECIFIC DEBUGGING / SYMBOL FUNCTIONALITY BELOW:

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_PdbLoad")]
        internal static extern unsafe bool VMMDLL_PdbLoad(
            uint dwPID,
            ulong vaModuleBase,
            byte* pModuleMapEntry);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_PdbSymbolName")]
        internal static extern unsafe bool VMMDLL_PdbSymbolName(
            [MarshalAs(UnmanagedType.LPStr)] string szModule,
            ulong cbSymbolAddressOrOffset,
            byte* szSymbolName,
            out uint pdwSymbolDisplacement);



        // VMMDLL_Map_GetPte

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_PTEENTRY
        {
            internal ulong vaBase;
            internal ulong cPages;
            internal ulong fPage;
            internal bool fWoW64;
            internal uint _FutureUse1;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszText;
            internal uint _Reserved1;
            internal uint cSoftware;
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_PTE
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)] internal uint[] _Reserved1;
            internal ulong pbMultiText;
            internal uint cbMultiText;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetPteW")]
        internal static extern unsafe bool VMMDLL_Map_GetPte(
            uint dwPid,
            byte* pPteMap,
            ref uint pcbPteMap,
            bool fIdentifyModules);



        // VMMDLL_Map_GetVad

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_VADENTRY
        {
            internal ulong vaStart;
            internal ulong vaEnd;
            internal ulong vaVad;
            internal uint dw0;
            internal uint dw1;
            internal uint u2;
            internal uint cbPrototypePte;
            internal ulong vaPrototypePte;
            internal ulong vaSubsection;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszText;
            internal uint _FutureUse1;
            internal uint _Reserved1;
            internal ulong vaFileObject;
            internal uint cVadExPages;
            internal uint cVadExPagesBase;
            internal ulong _Reserved2;
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_VAD
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)] internal uint[] _Reserved1;
            internal uint cPage;
            internal ulong pbMultiText;
            internal uint cbMultiText;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetVadW")]
        internal static extern unsafe bool VMMDLL_Map_GetVad(
            uint dwPid,
            byte* pVadMap,
            ref uint pcbVadMap,
            bool fIdentifyModules);



        // VMMDLL_Map_GetVadEx

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_VADEXENTRY
        {
            internal uint tp;
            internal uint iPML;
            internal ulong va;
            internal ulong pa;
            internal ulong pte;
            internal uint _Reserved1;
            internal uint proto_tp;
            internal ulong proto_pa;
            internal ulong proto_pte;
            internal ulong vaVadBase;
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_VADEX
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)] internal uint[] _Reserved1;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetVadEx")]
        internal static extern unsafe bool VMMDLL_Map_GetVadEx(
            uint dwPid,
            byte* pVadMap,
            ref uint pcbVadMap,
            uint oPage,
            uint cPage);



        // VMMDLL_Map_GetModule

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_MODULEENTRY
        {
            internal ulong vaBase;
            internal ulong vaEntry;
            internal uint cbImageSize;
            internal bool fWow64;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszText;
            internal uint _Reserved3;
            internal uint _Reserved4;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszFullName;
            internal uint tp;
            internal uint cbFileSizeRaw;
            internal uint cSection;
            internal uint cEAT;
            internal uint cIAT;
            internal uint _Reserved2;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)] internal ulong[] _Reserved1;
        }

        internal struct VMMDLL_MAP_MODULE
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)] internal uint[] _Reserved1;
            internal ulong pbMultiText;
            internal uint cbMultiText;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetModuleW")]
        internal static extern unsafe bool VMMDLL_Map_GetModule(uint dwPid, byte* pModuleMap, ref uint pcbModuleMap);

        // VMMDLL_Map_GetModuleFromName

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetModuleFromNameW")]
        internal static extern unsafe bool VMMDLL_Map_GetModuleFromName(
            uint dwPID,
            [MarshalAs(UnmanagedType.LPWStr)] string wszModuleName,
            byte* pModuleMapEntry,
            ref uint pcbModuleMapEntry);



        // VMMDLL_Map_GetUnloadedModule

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_UNLOADEDMODULEENTRY
        {
            internal ulong vaBase;
            internal uint cbImageSize;
            internal bool fWow64;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszText;
            internal uint _FutureUse1;
            internal uint dwCheckSum;
            internal uint dwTimeDateStamp;
            internal uint _Reserved1;
            internal ulong ftUnload;
        }

        internal struct VMMDLL_MAP_UNLOADEDMODULE
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)] internal uint[] _Reserved1;
            internal ulong pbMultiText;
            internal uint cbMultiText;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetUnloadedModuleW")]
        internal static extern unsafe bool VMMDLL_Map_GetUnloadedModule(uint dwPid, byte* pModuleMap, ref uint pcbModuleMap);
        
        
        
        // VMMDLL_Map_GetEAT

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_EATENTRY
        {
            internal ulong vaFunction;
            internal uint dwOrdinal;
            internal uint oFunctionsArray;
            internal uint oNamesArray;
            internal uint _FutureUse1;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszFunction;
        }

        internal struct VMMDLL_MAP_EAT
        {
            internal uint dwVersion;
            internal uint dwOrdinalBase;
            internal uint cNumberOfNames;
            internal uint cNumberOfFunctions;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)] internal uint[] _Reserved1;
            internal ulong vaModuleBase;
            internal ulong vaAddressOfFunctions;
            internal ulong vaAddressOfNames;
            internal ulong pbMultiText;
            internal uint cbMultiText;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetEATW")]
        internal static extern unsafe bool VMMDLL_Map_GetEAT(
            uint dwPid,
            [MarshalAs(UnmanagedType.LPWStr)] string wszModuleName,
            byte* pEatMap,
            ref uint pcbEatMap);



        // VMMDLL_Map_GetIAT

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_IATENTRY
        {
            internal ulong vaFunction;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszFunction;
            internal uint _FutureUse1;
            internal uint _FutureUse2;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszModule;
            internal bool f32;
            internal ushort wHint;
            internal ushort _Reserved1;
            internal uint rvaFirstThunk;
            internal uint rvaOriginalFirstThunk;
            internal uint rvaNameModule;
            internal uint rvaNameFunction;
        }

        internal struct VMMDLL_MAP_IAT
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)] internal uint[] _Reserved1;
            internal ulong vaModuleBase;
            internal ulong pbMultiText;
            internal uint cbMultiText;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetIATW")]
        internal static extern unsafe bool VMMDLL_Map_GetIAT(
            uint dwPid,
            [MarshalAs(UnmanagedType.LPWStr)] string wszModuleName,
            byte* pIatMap,
            ref uint pcbIatMap);



        // VMMDLL_Map_GetHeap

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_HEAPENTRY
        {
            internal ulong vaHeapSegment;
            internal uint cPages;
            internal uint cPagesUnCommitted_HeapId_fPrimary;
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_HEAP
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)] internal uint[] _Reserved1;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetHeap")]
        internal static extern unsafe bool VMMDLL_Map_GetHeap(
            uint dwPid,
            byte* pHeapMap,
            ref uint pcbHeapMap);



        // VMMDLL_Map_GetThread

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_THREADENTRY
        {
            internal uint dwTID;
            internal uint dwPID;
            internal uint dwExitStatus;
            internal byte bState;
            internal byte bRunning;
            internal byte bPriority;
            internal byte bBasePriority;
            internal ulong vaETHREAD;
            internal ulong vaTeb;
            internal ulong ftCreateTime;
            internal ulong ftExitTime;
            internal ulong vaStartAddress;
            internal ulong vaStackBaseUser;          // value from _NT_TIB / _TEB
            internal ulong vaStackLimitUser;         // value from _NT_TIB / _TEB
            internal ulong vaStackBaseKernel;
            internal ulong vaStackLimitKernel;
            internal ulong vaTrapFrame;
            internal ulong vaRIP;                    // RIP register (if user mode)
            internal ulong vaRSP;                    // RSP register (if user mode)
            internal ulong qwAffinity;
            internal uint dwUserTime;
            internal uint dwKernelTime;
            internal byte bSuspendCount;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)] internal byte[] _FutureUse1;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 15)] internal uint[] _FutureUse2;
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_THREAD
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)] internal uint[] _Reserved1;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetThread")]
        internal static extern unsafe bool VMMDLL_Map_GetThread(
            uint dwPid,
            byte* pThreadMap,
            ref uint pcbThreadMap);



        // VMMDLL_Map_GetHandle

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_HANDLEENTRY
        {
            internal ulong vaObject;
            internal uint dwHandle;
            internal uint dwGrantedAccess_iType;
            internal ulong qwHandleCount;
            internal ulong qwPointerCount;
            internal ulong vaObjectCreateInfo;
            internal ulong vaSecurityDescriptor;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszText;
            internal uint _FutureUse2;
            internal uint dwPID;
            internal uint dwPoolTag;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)] internal uint[] _FutureUse;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszType;
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_HANDLE
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)] internal uint[] _Reserved1;
            internal ulong pbMultiText;
            internal uint cbMultiText;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetHandleW")]
        internal static extern unsafe bool VMMDLL_Map_GetHandle(
            uint dwPid,
            byte* pHandleMap,
            ref uint pcbHandleMap);



        // VMMDLL_Map_GetNet

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_NETENTRY
        {
            internal uint dwPID;
            internal uint dwState;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)] internal ushort[] _FutureUse3;
            internal ushort AF;
            // src
            internal bool src_fValid;
            internal ushort src__Reserved1;
            internal ushort src_port;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)] internal byte[] src_pbAddr;
            [MarshalAs(UnmanagedType.LPWStr)] internal string src_wszText;
            // dst
            internal bool dst_fValid;
            internal ushort dst__Reserved1;
            internal ushort dst_port;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)] internal byte[] dst_pbAddr;
            [MarshalAs(UnmanagedType.LPWStr)] internal string dst_wszText;
            //
            internal ulong vaObj;
            internal ulong ftTime;
            internal uint dwPoolTag;
            internal uint _FutureUse4;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszText;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)] internal uint[] _FutureUse2;
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_NET
        {
            internal uint dwVersion;
            internal uint _Reserved1;
            internal ulong pbMultiText;
            internal uint cbMultiText;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetNetW")]
        internal static extern unsafe bool VMMDLL_Map_GetNet(
            byte* pNetMap,
            ref uint pcbNetMap);
        
        
        
        // VMMDLL_Map_GetPhysMem

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_PHYSMEMENTRY
        {
            internal ulong pa;
            internal ulong cb;
        }
        
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_PHYSMEM
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)] internal uint[] _Reserved1;
            internal uint cMap;
            internal uint _Reserved2;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetPhysMem")]
        internal static extern unsafe bool VMMDLL_Map_GetPhysMem(
            byte* pNetMap,
            ref uint pcbNetMap);



        // VMMDLL_Map_GetUsers

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal struct VMMDLL_MAP_USERENTRY
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)] internal uint[] _FutureUse1;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszText;
            internal ulong vaRegHive;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszSID;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)] internal uint[] _FutureUse2;
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_USER
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)] internal uint[] _Reserved1;
            internal ulong pbMultiText;
            internal uint cbMultiText;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetUsersW")]
        internal static extern unsafe bool VMMDLL_Map_GetUsers(
            byte* pbUserMap,
            ref uint pcbUserMap);



        // VMMDLL_Map_GetServuces

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_SERVICEENTRY
        {
            internal ulong vaObj;
            internal uint dwOrdinal;
            internal uint dwStartType;
            // SERVICE_STATUS START
            internal uint dwServiceType;
            internal uint dwCurrentState;
            internal uint dwControlsAccepted;
            internal uint dwWin32ExitCode;
            internal uint dwServiceSpecificExitCode;
            internal uint dwCheckPoint;
            internal uint dwWaitHint;
            // SERVICE_STATUS END
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszServiceName;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszDisplayName;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszPath;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszUserTp;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszUserAcct;
            [MarshalAs(UnmanagedType.LPWStr)] internal string wszImagePath;
            internal uint dwPID;
            internal uint _FutureUse1;
            internal ulong _FutureUse2;
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_SERVICE
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)] internal uint[] _Reserved1;
            internal ulong pbMultiText;
            internal uint cbMultiText;
            internal uint cMap;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetServicesW")]
        internal static extern unsafe bool VMMDLL_Map_GetServices(
            byte* pbServiceMap,
            ref uint pcbServiceMap);



        // VMMDLL_Map_GetPfn

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_PFNENTRY
        {
            internal uint dwPfn;
            internal uint tpExtended;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)] internal uint[] dwPfnPte;
            internal ulong va;
            internal ulong vaPte;
            internal ulong OriginalPte;
            internal uint _u3;
            internal ulong _u4;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)] internal uint[] _FutureUse;
        }

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        internal struct VMMDLL_MAP_PFN
        {
            internal uint dwVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)] internal uint[] _Reserved1;
            internal uint cMap;
            internal uint _Reserved2;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_Map_GetPfn")]
        internal static extern unsafe bool VMMDLL_Map_GetPfn(
            byte* pPfns,
            uint cPfns,
            byte* pPfnMap,
            ref uint pcbPfnMap);



        // REGISTRY FUNCTIONALITY BELOW:

        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        internal struct VMMDLL_REGISTRY_HIVE_INFORMATION
        {
            internal ulong magic;
            internal ushort wVersion;
            internal ushort wSize;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 0x14)] internal byte[] _FutureReserved1;
            internal ulong vaCMHIVE;
            internal ulong vaHBASE_BLOCK;
            internal uint cbLength;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)] internal byte[] szName;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 33)] internal string wszNameShort;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)] internal string wszHiveRootPath;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 0x10)] internal ulong[] _FutureReserved;
        }

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_WinReg_HiveList")]
        internal static extern unsafe bool VMMDLL_WinReg_HiveList(
            byte* pHives,
            uint cHives,
            out uint pcHives);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_WinReg_HiveReadEx")]
        internal static extern unsafe bool VMMDLL_WinReg_HiveReadEx(
            ulong vaCMHive,
            uint ra,
            byte* pb,
            uint cb,
            out uint pcbReadOpt,
            uint flags);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_WinReg_HiveWrite")]
        internal static extern unsafe bool VMMDLL_WinReg_HiveWrite(
            ulong vaCMHive,
            uint ra,
            byte* pb,
            uint cb);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_WinReg_EnumKeyExW")]
        internal static extern unsafe bool VMMDLL_WinReg_EnumKeyExW(
            [MarshalAs(UnmanagedType.LPWStr)] string wszFullPathKey,
            uint dwIndex,
            byte* lpName,
            ref uint lpcchName,
            out ulong lpftLastWriteTime);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_WinReg_EnumValueW")]
        internal static extern unsafe bool VMMDLL_WinReg_EnumValueW(
            [MarshalAs(UnmanagedType.LPWStr)] string wszFullPathKey,
            uint dwIndex,
            byte* lpValueName,
            ref uint lpcchValueName,
            out uint lpType,
            byte* lpData,
            ref uint lpcbData);

        [DllImport("vmm.dll", EntryPoint = "VMMDLL_WinReg_QueryValueExW")]
        internal static extern unsafe bool VMMDLL_WinReg_QueryValueExW(
            [MarshalAs(UnmanagedType.LPWStr)] string wszFullPathKeyValue,
            out uint lpType,
            byte* lpData,
            ref uint lpcbData);
    }
}

```

`eft-dma-radar.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0-windows</TargetFramework>
    <RootNamespace>eft_dma_radar</RootNamespace>
    <Nullable>warnings</Nullable>
    <UseWindowsForms>true</UseWindowsForms>
    <ImplicitUsings>enable</ImplicitUsings>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
    <Platforms>x64</Platforms>
  </PropertyGroup>

  <ItemGroup>
    <None Remove="FTD3XX.dll" />
    <None Remove="leechcore.dll" />
    <None Remove="Maps\Customs.json" />
    <None Remove="Maps\Customs.png" />
    <None Remove="Maps\Factory.json" />
    <None Remove="Maps\Factory.png" />
    <None Remove="Maps\Interchange.json" />
    <None Remove="Maps\Interchange.png" />
    <None Remove="Maps\Labs.json" />
    <None Remove="Maps\Labs_0f.png" />
    <None Remove="Maps\Labs_1f.png" />
    <None Remove="Maps\Labs_2f.png" />
    <None Remove="Maps\Lighthouse.json" />
    <None Remove="Maps\Lighthouse.png" />
    <None Remove="Maps\Reserve.json" />
    <None Remove="Maps\Reserve.png" />
    <None Remove="Maps\Shoreline.json" />
    <None Remove="Maps\Shoreline.png" />
    <None Remove="Maps\Woods.json" />
    <None Remove="Maps\Woods.png" />
    <None Remove="vmm.dll" />
  </ItemGroup>

  <ItemGroup>
    <Content Include="FTD3XX.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="leechcore.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Customs.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Customs.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Factory.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Factory.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Interchange.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Interchange.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Labs.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Labs_0f.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Labs_1f.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Labs_2f.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Lighthouse.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Lighthouse.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Reserve.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Reserve.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Shoreline.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Shoreline.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Woods.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="Maps\Woods.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="vmm.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="SkiaSharp" Version="2.80.3" />
    <PackageReference Include="SkiaSharp.Views.WindowsForms" Version="2.80.3" />
  </ItemGroup>

</Project>
```

`eft-dma-radar.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31912.275
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "eft-dma-radar", "eft-dma-radar.csproj", "{56E6577A-CAF7-402F-8590-5B6DEE34F918}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{56E6577A-CAF7-402F-8590-5B6DEE34F918}.Debug|x64.ActiveCfg = Debug|x64
		{56E6577A-CAF7-402F-8590-5B6DEE34F918}.Debug|x64.Build.0 = Debug|x64
		{56E6577A-CAF7-402F-8590-5B6DEE34F918}.Release|x64.ActiveCfg = Release|x64
		{56E6577A-CAF7-402F-8590-5B6DEE34F918}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9FE05244-9482-47D1-B12C-9357E58CD3AB}
	EndGlobalSection
EndGlobal

```