Project Path: arc_gmh5225_integrity_experiments_gnbhyqtf

Source Tree:

```txt
arc_gmh5225_integrity_experiments_gnbhyqtf
├── README.md
├── integrity_experiments
│   ├── integrity.h
│   ├── integrity_experiments.vcxproj
│   ├── integrity_experiments.vcxproj.filters
│   └── main.cc
└── integrity_experiments.sln

```

`README.md`:

```md
# integrity_experiments
A (simple) integrity checking system in the form of MSVC macros, PRs are welcome.

## What is this?
A header only "library" I wrote some time ago when experimenting with integrity checking using macros. Works best if used along a virtualizing packer as a second layer of integrity checks.

## Some tips
Works best on non-inlined functions, preferably side by side with a code virtualizing packer. 

For the best results, you're going to want to put several integrity checking macros all over your program in your core algorithms, preferably wrapped in virtualization macros, depending on your packer of choice.

Something like this can help when you're using pre-built libraries or simple OS libraries and you cannot rely on them not having been tampered with.
```

`integrity_experiments.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32616.157
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "integrity_experiments", "integrity_experiments\integrity_experiments.vcxproj", "{9E50FC40-901A-470C-968C-ACDC38745A51}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9E50FC40-901A-470C-968C-ACDC38745A51}.Debug|x64.ActiveCfg = Debug|x64
		{9E50FC40-901A-470C-968C-ACDC38745A51}.Debug|x64.Build.0 = Debug|x64
		{9E50FC40-901A-470C-968C-ACDC38745A51}.Debug|x86.ActiveCfg = Debug|Win32
		{9E50FC40-901A-470C-968C-ACDC38745A51}.Debug|x86.Build.0 = Debug|Win32
		{9E50FC40-901A-470C-968C-ACDC38745A51}.Release|x64.ActiveCfg = Release|x64
		{9E50FC40-901A-470C-968C-ACDC38745A51}.Release|x64.Build.0 = Release|x64
		{9E50FC40-901A-470C-968C-ACDC38745A51}.Release|x86.ActiveCfg = Release|Win32
		{9E50FC40-901A-470C-968C-ACDC38745A51}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {92C5E042-13F2-464F-8537-6D48418BC9E1}
	EndGlobalSection
EndGlobal

```

`integrity_experiments/integrity.h`:

```h
#pragma once
#include <Windows.h>

#include <iostream>
#include <string>
#include <vector>

/// Size of a memory page.
#define PAGE_SIZE 0x1000

/// Aligns a memory address to the start of its corresponding page (this system
/// saves entire pages into memory, since it's not capable of understanding
/// where a function starts and where a function ends reliably, especially with
/// optimizations enabled).
#define PAGE_ALIGN(address)                                                    \
  (uint8_t *)(reinterpret_cast<uint64_t>(address) -                            \
              (reinterpret_cast<uint64_t>(address) % PAGE_SIZE))

/// Declares the data structure necessary to store a function's memory page.
#define DECLARE_FUNCTION_DATA(name)                                            \
  static uint8_t function_page_data_##name[PAGE_SIZE];

/// Loads a function's code into its corresponding xorred memory page which will
/// be used for integrity checking purposes.
#define LOAD_FUNCTION_DATA(space, name)                                        \
  {                                                                            \
    uint8_t *address_##name = PAGE_ALIGN((uint8_t *)&name);                    \
    for (auto i = 0; i < PAGE_SIZE; i++) {                                     \
      space::function_page_data_##name[i] = address_##name[i] ^ __TIME__[0];   \
    }                                                                          \
  }

/// Checks if a function's code matches that of its corresponding xorred memory
/// page's.
#define CHECK_FUNCTION_DATA(space, name, action)                               \
  {                                                                            \
    uint8_t *address_##name = PAGE_ALIGN((uint8_t *)&name);                    \
    for (auto i = 0; i < PAGE_SIZE; i++) {                                     \
      if (address_##name[i] !=                                                 \
          (space::function_page_data_##name[i] ^ __TIME__[0])) {               \
        action;                                                                \
        break;                                                                 \
      }                                                                        \
    }                                                                          \
  }

/// Instead of checking if a function's code matches its corresponding xorred
/// memory page's, this code simply extracts the code of the page from memory
/// and writes it back to the function's.
#define HEAL_FUNCTION_DATA(space, name)                                        \
  {                                                                            \
    auto address_##name = PAGE_ALIGN((uint8_t *)&name);                        \
    DWORD old_protection_##name;                                               \
    VirtualProtect(address_##name, PAGE_SIZE, PAGE_EXECUTE_READWRITE,          \
                   &old_protection_##name);                                    \
                                                                               \
    for (auto i = 0; i < PAGE_SIZE; i++) {                                     \
      if (address_##name[i] !=                                                 \
          (space::function_page_data_##name[i] ^ __TIME__[0])) {               \
        address_##name[i] = space::function_page_data_##name[i] ^ __TIME__[0]; \
      }                                                                        \
    }                                                                          \
    VirtualProtect(address_##name, PAGE_SIZE, old_protection_##name,           \
                   &old_protection_##name);                                    \
  }

/// Checks if a function's integrity has been violated, then calls it, executing
/// any action that should be executed if the function's code has been patched
/// too.
#define CHECKED_FUNCTION_CALL(space, name, action, ...)                        \
  [&]() {                                                                      \
    CHECK_FUNCTION_DATA(space, name, action);                                  \
    return name(__VA_ARGS__);                                                  \
  }();

/// Heals a function (removes patches) then calls it.
#define FORCED_FUNCTION_CALL(space, name, ...)                                 \
  [&]() {                                                                      \
    HEAL_FUNCTION_DATA(space, name);                                           \
    return name(__VA_ARGS__);                                                  \
  }();
```

`integrity_experiments/integrity_experiments.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{9e50fc40-901a-470c-968c-acdc38745a51}</ProjectGuid>
    <RootNamespace>integrityexperiments</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cc" />
  </ItemGroup>
  <ItemGroup>
    <None Include=".clang-format" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="integrity.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`integrity_experiments/integrity_experiments.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cc">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include=".clang-format" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="integrity.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`integrity_experiments/main.cc`:

```cc
#include "integrity.h"

#include <array>

/// Macro that enables or disables the printing macros from this file.
#define LOG_DATA 1

#if LOG_DATA
#define LOG(...)                                                               \
  std::printf(__VA_ARGS__);                                                    \
  std::printf("\n")
#else
#define LOG
#endif

/// <summary>
/// Example function which will be patched and called to demonstrate this PoC's
/// functionality.
/// </summary>
/// <param name="a">First number to be added</param>
/// <param name="b">Second number to be added</param>
/// <returns>The sum of both numbers.</returns>
int addition(int a, int b) { return a + b; }

/// <summary>
/// Namespace used to store all the integrity checks data.
/// </summary>
namespace IntegrityChecksTable {
DECLARE_FUNCTION_DATA(addition);
} // namespace IntegrityChecksTable

/// <summary>
/// Patches the addition function by changing the page protection to rwx, then
/// patching in assembly equivalent to:
///
/// int addition() { return 1337; }
///
/// Then changes back the code page's protection back to what it was before.
/// </summary>
void patch_addition() {
  LOG("Patching addition...");

  // patch the function now, because we're evil haxxors
  DWORD old;
  VirtualProtect(addition, PAGE_SIZE, PAGE_EXECUTE_READWRITE, &old);

  // movabs rax, 1337 ; dec
  // ret
  std::array<uint8_t, 11> return_1337_shell = {
      0x48, 0xB8, 0x39, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3};

  // overwrite the addition function to always return 1337
  for (auto i = 0; i < return_1337_shell.size(); i++) {
    reinterpret_cast<uint8_t *>(addition)[i] = return_1337_shell[i];
  }

  VirtualProtect(addition, PAGE_SIZE, old, &old);
}

/// <summary>
/// Code that executes if the addition code has been tampered with.
/// </summary>
void addition_tampered() { LOG("The addition code has been tampered with!"); }

int main() {
  // load data in xorred data buffer containing its code
  LOAD_FUNCTION_DATA(IntegrityChecksTable, addition);
  // check that the data matches the function's actual code
  CHECK_FUNCTION_DATA(IntegrityChecksTable, addition, addition_tampered());

  // run the function
  LOG("Addition result %d", addition(5, 5));

  // patch the function
  patch_addition();

  // the program should now say that the addition function has been tampered
  // with
  CHECK_FUNCTION_DATA(IntegrityChecksTable, addition, addition_tampered());

  // but wait, we can force call it (the function will be healed and called)
  auto result = FORCED_FUNCTION_CALL(IntegrityChecksTable, addition, 5, 5);
  LOG("Healed addition result %d", result);

  // patch it again!
  patch_addition();

  // alternatively, we can have some other code execute if the function has been
  // tampered with (we will still get the results from the tampered function,
  // instead of receiving genuine results from a healed function).
  auto tampered_result = CHECKED_FUNCTION_CALL(IntegrityChecksTable, addition,
                                               addition_tampered(), 5, 5);
  LOG("Tampered addition results %d", tampered_result);
}
```