Project Path: arc_gmh5225_apex_legends_sdk_l6c1ig4l

Source Tree:

```txt
arc_gmh5225_apex_legends_sdk_l6c1ig4l
├── LICENSE
├── README.md
├── dynamic_crypt.cpp
├── game_client.cpp
├── game_client.hpp
├── game_version.cpp
├── heartbeat.cpp
├── local_stats.cpp
├── merged_gamelib.cpp
├── name_list.cpp
├── server_info.cpp
├── sync_check.cpp
└── view_render.cpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Ayman Talhaoui

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# apex_legends_sdk
still updated 7th of september 2022

```

`dynamic_crypt.cpp`:

```cpp
// dynamic_crypt.cpp

__int64 __fastcall encrypt_dynamic_values(_QWORD* a1) // 53 55 56 57 41 54 41 55 41 56 41 57 48 89 CF 48 8B 77 10 
{
    _QWORD* v1; // rdi
    __int64 v2; // rcx
    __int64 v3; // rbp
    __int64 v4; // rsi
    __int64 v5; // rcx
    char v6; // cc
    __int64 v7; // rcx
    unsigned __int64 v8; // rbx
    unsigned __int64 v9; // rdx
    __int64 v10; // rax
    unsigned __int64 v11; // rbx
    __int64 v12; // rax
    __int64 v13; // rax
    __int64 v14; // rax
    unsigned __int64 v15; // rdx
    __int64 v16; // rax
    __int64 v17; // rax
    __int64 v18; // rsi
    __int64 i; // rcx
    __int64 result; // rax
    __int64 v21; // rdi
    __int64 v22; // rcx
    __int64 j; // rcx
    __int64 k; // rcx
    unsigned __int64 v25; // rdx
    __int64 v26; // rax
    unsigned __int64 v27; // rbx
    __int64 v28; // rax
    __int64 v29; // rax

    memset(a1 + 4, 0, 0x1000ui64);
    v1 = a1;
    v2 = a1[1];
    v3 = (__int64)(v1 + 4);
    v4 = *v1 + v2 - 24;
    v5 = -v2;
    v6 = (v5 + 24 < 0) ^ __OFADD__(24i64, v5);
    v7 = v5 + 24;
    if (v6)
    {
        v8 = *(_QWORD*)(v4 + v7);
        do
        {
            while (1)
            {
                while (1)
                {
                    v9 = *(_QWORD*)(v4 + v7 + 8);
                    if (v8 == v9)
                        break;
                    ++* (_DWORD*)(v3 + 4i64 * (unsigned __int8)v8);
                    v10 = BYTE1(v8);
                    v11 = v8 >> 16;
                    ++* (_DWORD*)(v3 + 4 * v10 + 1024);
                    ++* (_DWORD*)(v3 + 4i64 * (unsigned __int8)v11 + 2048);
                    v12 = BYTE1(v11);
                    v11 >>= 16;
                    ++* (_DWORD*)(v3 + 4 * v12 + 3072);
                    ++* (_DWORD*)(v3 + 4i64 * (unsigned __int8)v11);
                    v13 = BYTE1(v11);
                    LODWORD(v11) = (unsigned int)v11 >> 16;
                    ++* (_DWORD*)(v3 + 4 * v13 + 1024);
                    ++* (_DWORD*)(v3 + 4i64 * (unsigned __int8)v11 + 2048);
                    ++* (_DWORD*)(v3 + 4i64 * BYTE1(v11) + 3072);
                    v8 = *(_QWORD*)(v4 + v7 + 16);
                    ++* (_DWORD*)(v3 + 4i64 * (unsigned __int8)v9);
                    v14 = BYTE1(v9);
                    v15 = v9 >> 16;
                    ++* (_DWORD*)(v3 + 4 * v14 + 1024);
                    ++* (_DWORD*)(v3 + 4i64 * (unsigned __int8)v15 + 2048);
                    v16 = BYTE1(v15);
                    v15 >>= 16;
                    ++* (_DWORD*)(v3 + 4 * v16 + 3072);
                    ++* (_DWORD*)(v3 + 4i64 * (unsigned __int8)v15);
                    v17 = BYTE1(v15);
                    LODWORD(v15) = (unsigned int)v15 >> 16;
                    ++* (_DWORD*)(v3 + 4 * v17 + 1024);
                    ++* (_DWORD*)(v3 + 4i64 * (unsigned __int8)v15 + 2048);
                    ++* (_DWORD*)(v3 + 4i64 * BYTE1(v15) + 3072);
                    v7 += 16i64;
                    if (v7 >= 0)
                        goto LABEL_5;
                }
                v25 = v8 ^ (*(_QWORD*)(v4 + v7 + 8) << 8);
                if (v25 >= 0x100)
                    break;
                *(_DWORD*)(v3 + 4 * v25) += 16;
                v8 = *(_QWORD*)(v4 + v7 + 16);
                v7 += 16i64;
                if (v7 >= 0)
                    goto LABEL_5;
            }
            *(_DWORD*)(v3 + 4i64 * (unsigned __int8)v8) += 2;
            v26 = BYTE1(v8);
            v27 = v8 >> 16;
            *(_DWORD*)(v3 + 4 * v26 + 1024) += 2;
            *(_DWORD*)(v3 + 4i64 * (unsigned __int8)v27 + 2048) += 2;
            v28 = BYTE1(v27);
            v27 >>= 16;
            *(_DWORD*)(v3 + 4 * v28 + 3072) += 2;
            *(_DWORD*)(v3 + 4i64 * (unsigned __int8)v27) += 2;
            v29 = BYTE1(v27);
            LODWORD(v27) = (unsigned int)v27 >> 16;
            *(_DWORD*)(v3 + 4 * v29 + 1024) += 2;
            *(_DWORD*)(v3 + 4i64 * (unsigned __int8)v27 + 2048) += 2;
            *(_DWORD*)(v3 + 4i64 * BYTE1(v27) + 3072) += 2;
            v8 = *(_QWORD*)(v4 + v7 + 16);
            v7 += 16i64;
        } while (v7 < 0);
    }
LABEL_5:
    v18 = v4 + 24;
    for (i = v7 - 24; i; ++i)
        ++* (_DWORD*)(v3 + 4i64 * *(unsigned __int8*)(v18 + i));
    result = v1[3];
    v21 = v1[2];
    v22 = 4 * (unsigned int)(unsigned __int16)result;
    if (result & 0x10000)
    {
        while (v22 & 0xF)
        {
            result = (unsigned int)(*(_DWORD*)(v3 + v22 + 3072)
                + *(_DWORD*)(v3 + v22 + 2048)
                + *(_DWORD*)(v3 + v22 + 1024)
                + *(_DWORD*)(v3 + v22)
                + *(_DWORD*)(v21 + v22));
            *(_DWORD*)(v21 + v22) = result;
            v22 = (unsigned int)(v22 - 4);
        }
        for (j = (unsigned int)(v22 - 16); (int)j >= 0; j = (unsigned int)(j - 16))
            _mm_storeu_si128(
                (__m128i*)(v21 + j),
                _mm_add_epi32(
                    _mm_add_epi32(
                        _mm_add_epi32(
                            _mm_add_epi32(_mm_load_si128((const __m128i*)(v21 + j)), *(__m128i*)(v3 + j)),
                            *(__m128i*)(v3 + j + 1024)),
                        *(__m128i*)(v3 + j + 2048)),
                    *(__m128i*)(v3 + j + 3072)));
    }
    else
    {
        while (v22 & 0xF)
        {
            result = (unsigned int)(*(_DWORD*)(v3 + v22 + 3072)
                + *(_DWORD*)(v3 + v22 + 2048)
                + *(_DWORD*)(v3 + v22 + 1024)
                + *(_DWORD*)(v3 + v22));
            *(_DWORD*)(v21 + v22) = result;
            v22 = (unsigned int)(v22 - 4);
        }
        for (k = (unsigned int)(v22 - 16); (int)k >= 0; k = (unsigned int)(k - 16))
            _mm_storeu_si128(
                (__m128i*)(v21 + k),
                _mm_add_epi32(
                    _mm_add_epi32(
                        _mm_add_epi32(_mm_load_si128((const __m128i*)(v3 + k)), *(__m128i*)(v3 + k + 1024)),
                        *(__m128i*)(v3 + k + 2048)),
                    *(__m128i*)(v3 + k + 3072)));
    }
    return result;
}
```

`game_client.cpp`:

```cpp
// #STR: "CreateGameClient", "GameClientInterfaceV012", "CreateClientAuth", "ClientAuthInterfaceV001", "EasyAntiCheat_x64.dll"

// game_client.cpp

char uac::create_game_client()
{
    __int64 v0; // rax
    __int64(__fastcall * v1)(const char*); // rax
    __int64(__fastcall * v2)(const char*); // rax
    void(__fastcall * **v3)(_QWORD); // rax
    __int64 v4; // rdi
    __int64 v5; // rsi
    _WORD* v6; // rax
    __int64 v7; // rbx
    __int64 v8; // rdx
    int v9; // ecx
    __int64 v10; // rax
    char* v11; // rax
    __int16 v13; // [rsp+1Ah] [rbp-BEh]
    char v14[4]; // [rsp+1Ch] [rbp-BCh]
    __int16 v15[88]; // [rsp+20h] [rbp-B8h]
    char v16[8]; // [rsp+E0h] [rbp+8h]

    v0 = sub_7FF64EB2F960("EasyAntiCheat_x64.dll");
    qword_7FF659DE9B58 = v0;
    if (!v0)
        return 0;
    v1 = (__int64(__fastcall*)(const char*))MEMORY[0x7FF8EC52AEC0](v0, "CreateGameClient");
    if (!v1
        || (qword_7FF659DE9B48 = v1("GameClientInterfaceV012")) == 0
        || (v2 = (__int64(__fastcall*)(const char*))MEMORY[0x7FF8EC52AEC0](qword_7FF659DE9B58, "CreateClientAuth")) == 0i64
        || (v3 = (void(__fastcall***)(_QWORD))v2("ClientAuthInterfaceV001"), (qword_7FF659DE9B60 = (__int64)v3) == 0))
    {
        sub_7FF64E9392B0();
        return 0;
    }
    (**v3)(v3);
    v4 = sub_7FF64EB22430();
    v5 = sub_7FF64EB22240(v4);
    if (!(unsigned int)MEMORY[0x7FF8EC52E370](v15, 85i64))
        goto LABEL_28;
    v6 = (_WORD*)sub_7FF64F4BF218(v15, L"-x-");
    if (v6)
        *v6 = 0;
    v7 = -1i64;
    v8 = -1i64;
    do
        ++v8;
    while (v15[v8]);
    v9 = v8 - 1;
    v10 = (int)v8 - 1;
    if ((int)v8 - 1 >= 0)
    {
        while (v15[v10] != 95)
        {
            --v9;
            if (--v10 < 0)
                goto LABEL_16;
        }
        v8 = v9;
        v15[v9] = 0;
    }
LABEL_16:
    if (v8 < 3)
        goto LABEL_28;
    if (*(&v13 + v8) != 45)
        goto LABEL_28;
    (*(void(__fastcall**)(void*, char*, char*, __int64))(*(_QWORD*)off_7FF655BB6D08 + 112i64))(
        off_7FF655BB6D08,
        &v14[2 * v8],
        v16,
        3i64);
    do
        ++v7;
    while (v16[v7]);
    if (v7 == 2)
        v11 = v16;
    else
        LABEL_28:
    v11 = (char*)sub_7FF64EB22270(v4);
    (*(void(__fastcall**)(__int64, __int64, char*))(*(_QWORD*)qword_7FF659DE9B48 + 80i64))(
        qword_7FF659DE9B48,
        v5,
        v11);
    (**(void(__fastcall***)(__int64, __int64(__fastcall*)(), __int64(__fastcall*)(), _QWORD))qword_7FF659DE9B48)(
        qword_7FF659DE9B48,
        sub_7FF64E866FE0,
        nullsub_1,
        0i64);
    return 1;
}
```

`game_client.hpp`:

```hpp
#pragma once

namespace uac
{
	char create_game_client();
}
```

`game_version.cpp`:

```cpp
// game_version.h

char* get_apex_version()
{
    char* v0; // rdx -> allocated at static part of asm address list (list at object + 0x4180)

    if (valid_bytes)
        return char_buffer;
    valid_bytes = 1;
    if (!(unsigned __int8)log_to_file("gameversion.txt", char_buffer, 0x80i64))// log_to_file(const char* created_file, char buffer, int dest_size)
        strcpy(char_buffer, "(dev)");
    if (HIDWORD((*valid_size)[13]))
    {
        v0 = &char_buffer[-1];
        while (*++v0 != 0)
            ;
        strcpy(v0, " - spinner_debug_info");
    }
    return char_buffer;
}
```

`heartbeat.cpp`:

```cpp
// [removed]

// this file could give a lot of information to cheaters
```

`local_stats.cpp`:

```cpp
// [removed]

// this file could give a lot of information to cheaters
```

`merged_gamelib.cpp`:

```cpp
// [removed]

// this file could give a lot of information to cheaters
```

`name_list.cpp`:

```cpp
// name_list.cpp

// internal users, use engine GetPlayerName
// external users, reverse engine GetPlayerName and replace by your rpm calls. will give you namelist too btw

__int64 __fastcall obtain_name_list(__int64 a1)
{
    __int64 v1; // rdi
    int v2; // edx
    char v3; // al
    char v4; // bl
    __int64 result; // rax

    v1 = a1;
    if (*off_7FF655BB8570[0] == &CEngineClient::vftable)
    {
        if (dword_7FF655BB73E0 != 1)
            goto LABEL_14;
        v2 = HIDWORD((*off_7FF64FA9EA18)[13]);
        v3 = v2 != 0;
        if (v2 < 0)
            v3 = byte_7FF657493154;
        if (v3)
            v4 = 1;
        else
            LABEL_14:
        v4 = 0;
    }
    else
    {
        v4 = (*((__int64 (**)(void)) * off_7FF655BB8570[0] + 166))();
    }
    sub_7FF64EC5CFC0(v1);
    if (v4)
        result = name_list[2 * *(int*)(v1 + 56) - 2];// name_list = CCheat::Variables.Get()->NameListObject
    else
        result = name_list[2 * *(int*)(v1 + 56) - 1];
    return result;
}

```

`server_info.cpp`:

```cpp
// [removed]

// this file could give a lot of information to cheaters
```

`sync_check.cpp`:

```cpp
// [removed]

// this file could give a lot of information to cheaters
```

`view_render.cpp`:

```cpp
// view_render.cpp

char __fastcall init_view_render(__int64 a1, __int64 a2)
{
    (*(void(__fastcall**)(__int64, _QWORD, __int64))(*(_QWORD*)view_render + 0x200i64))(
        view_render,
        *(unsigned __int16*)(a1 + 12),
        a2);
    return 1;
}
```