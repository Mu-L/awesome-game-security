Project Path: arc_gmh5225_Fortnite-Leak5_l5hmy3ii

Source Tree:

```txt
arc_gmh5225_Fortnite-Leak5_l5hmy3ii
├── README.md
├── dllmain.cpp
├── features.hpp
├── fortnight.sln
├── fortnight.vcxproj
├── fortnight.vcxproj.filters
├── fortnight.vcxproj.user
├── includes.hpp
├── lazy.hpp
├── minhook
│   └── include
│       └── MinHook.h
├── overlay.cpp
├── overlay.hpp
├── sdk.hpp
├── spoofcall.asm
├── spoofcall.hpp
├── utilities.hpp
├── vectors.h
└── xorstr.hpp

```

`README.md`:

```md
**The basic source that INFARCTED.CC uses.**

 EFK had a few roles in 4u4play then started ratting and got banned. Now sells my version of androids self-leak just without the SDK, community does shit to people

```

`dllmain.cpp`:

```cpp
#include "includes.hpp"


void InitObjects()
{
    //Engine Render
    sdk::cached::objects::K2_DrawLine = sdk::objects::find_object(xorstr(L"Engine.Canvas.K2_DrawLine"));
    if (!sdk::cached::objects::K2_DrawLine) return;

    sdk::cached::objects::K2_DrawBox = sdk::objects::find_object(xorstr(L"Engine.Canvas.K2_DrawBox"));
    if (!sdk::cached::objects::K2_DrawBox) return;

    sdk::cached::objects::Font = sdk::objects::find_object(xorstr(L"/Engine/EngineFonts/Roboto.Roboto"));
    if (!sdk::cached::objects::Font) return;

    sdk::cached::objects::K2_DrawText = sdk::objects::find_object(xorstr(L"Engine.Canvas.K2_DrawText"));
    if (!sdk::cached::objects::K2_DrawText) return;

    sdk::cached::objects::K2_TextSize = sdk::objects::find_object(xorstr(L"Engine.Canvas.K2_TextSize"));
    if (!sdk::cached::objects::K2_TextSize) return;

    //Main Functions
    sdk::cached::objects::WasInputKeyJustPressed = sdk::objects::find_object(xorstr(L"Engine.PlayerController.WasInputKeyJustPressed"));
    if (!sdk::cached::objects::WasInputKeyJustPressed) return;

    sdk::cached::objects::IsInputKeyDown = sdk::objects::find_object(xorstr(L"Engine.PlayerController.IsInputKeyDown"));
    if (!sdk::cached::objects::IsInputKeyDown) return;

    sdk::cached::objects::GetMousePosition = sdk::objects::find_object(xorstr(L"Engine.PlayerController.GetMousePosition"));
    if (!sdk::cached::objects::GetMousePosition) return;

    sdk::cached::objects::dingus = sdk::objects::find_object(xorstr(L"PlayerPawn_Athena.PlayerPawn_Athena_C_.ApplyPawnHighlight"));
    if (!sdk::cached::objects::dingus) return;

    sdk::cached::objects::GetActorBounds = sdk::objects::find_object(xorstr(L"Engine.Actor.GetActorBounds"));
    if (!sdk::cached::objects::GetActorBounds) return;

    sdk::cached::objects::K2_SetActorLocation = sdk::objects::find_object(xorstr(L"Engine.Actor.K2_SetActorLocation"));
    if (!sdk::cached::objects::K2_SetActorLocation) return;

    sdk::cached::objects::GetMuzzleLocation = sdk::objects::find_object(xorstr(L"FortniteGame.FortWeapon.GetMuzzleLocation"));
    if (!sdk::cached::objects::GetMuzzleLocation) return;

    sdk::cached::objects::GetVelocity = sdk::objects::find_object(xorstr(L"Engine.Actor.GetVelocity"));
    if (!sdk::cached::objects::GetVelocity) return;

    sdk::cached::objects::ClientSetCameraMode = sdk::objects::find_object(xorstr(L"Engine.PlayerController.ClientSetCameraMode"));
    if (!sdk::cached::objects::ClientSetCameraMode) return;

    sdk::cached::objects::SetVisibility = sdk::objects::find_object(xorstr(L"Engine.SceneComponent.SetVisibility"));
    if (!sdk::cached::objects::SetVisibility) return;

    sdk::cached::objects::SetWeaponVisibility = sdk::objects::find_object(xorstr(L"FortniteGame.FortWeapon.SetWeaponVisibility"));
    if (!sdk::cached::objects::SetWeaponVisibility) return;

    sdk::cached::objects::SetCharacterBodyVisibilityForPossession = sdk::objects::find_object(xorstr(L"FortniteGame.FortPlayerPawnAthena.SetCharacterBodyVisibilityForPossession"));
    if (!sdk::cached::objects::SetCharacterBodyVisibilityForPossession) return;

    sdk::cached::objects::ClientSetViewTarget = sdk::objects::find_object(xorstr(L"Engine.PlayerController.ClientSetViewTarget"));
    if (!sdk::cached::objects::ClientSetViewTarget) return;

    sdk::cached::objects::GetPlatform = sdk::objects::find_object(xorstr(L"FortniteGame.FortPlayerState.GetPlatform"));
    if (!sdk::cached::objects::GetPlatform) return;

    sdk::cached::objects::IsDead = sdk::objects::find_object(xorstr(L"FortniteGame.FortPawn.IsDead"));
    if (!sdk::cached::objects::IsDead) return;


    //Floating
    sdk::cached::objects::StartFloating = sdk::objects::find_object(xorstr(L"FortniteGame.FortPlayerPawn.StartFloating"));
    if (!sdk::cached::objects::StartFloating) return;

    sdk::cached::objects::EndFloating = sdk::objects::find_object(xorstr(L"FortniteGame.FortPlayerPawn.EndFloating"));
    if (!sdk::cached::objects::EndFloating) return;


    //SetTimeOfDay
    sdk::cached::objects::FortKismetLibrary = sdk::objects::find_object(xorstr(L"FortniteGame.FortKismetLibrary"));
    if (!sdk::cached::objects::FortKismetLibrary) return;

    sdk::cached::objects::SetTimeOfDay = sdk::objects::find_object(xorstr(L"FortniteGame.FortKismetLibrary.SetTimeOfDay"));
    if (!sdk::cached::objects::SetTimeOfDay) return;


    //ConvertToFName
    sdk::cached::objects::KismetStringLibrary = sdk::objects::find_object(xorstr(L"Engine.KismetStringLibrary"));
    if (!sdk::cached::objects::KismetStringLibrary) return;

    sdk::cached::objects::Conv_StringToName = sdk::objects::find_object(xorstr(L"Engine.KismetStringLibrary.Conv_StringToName"));
    if (!sdk::cached::objects::Conv_StringToName) return;



    //Actors Classes
    sdk::cached::classes::FortPlayerPawnAthena = sdk::objects::find_object(xorstr(L"FortniteGame.FortPlayerPawnAthena"));
    if (!sdk::cached::classes::FortPlayerPawnAthena) return;

    sdk::cached::classes::FortPickup = sdk::objects::find_object(xorstr(L"FortniteGame.FortPickupAthena"));
    if (!sdk::cached::classes::FortPickup) return;

    sdk::cached::classes::BuildingContainer = sdk::objects::find_object(xorstr(L"FortniteGame.BuildingContainer"));
    if (!sdk::cached::classes::BuildingContainer) return;

    sdk::cached::classes::FortProjectileBase = sdk::objects::find_object(xorstr(L"FortniteGame.FortProjectileBase"));
    if (!sdk::cached::classes::FortProjectileBase) return;


    return;
}

void Init()
{
    // Image Info
    sdk::cached::Base = utilities::imageBase();

    // UWorld
    sdk::cached::UWorld = utilities::scan(sdk::cached::Base, xorstr("48 89 05 ? ? ? ? 48 8B 4B 78"));
    sdk::cached::UWorld = RELATIVE(sdk::cached::UWorld, 7);
    if (!sdk::cached::UWorld) return;

    // FreeFn
    sdk::cached::FreeFn = utilities::scan(sdk::cached::Base, xorstr("48 85 C9 0F 84 ? ? ? ? 53 48 83 EC 20 48 89 7C 24 30 48 8B D9 48 8B 3D ? ? ? ? 48 85 FF 0F 84 ? ? ? ? 48 8B 07 4C 8B 40 30 48 8D 05 ? ? ? ? 4C 3B C0"));
    if (!sdk::cached::FreeFn) return;

    // GetObjectName
    sdk::cached::GetNameByIndex = utilities::scan(sdk::cached::Base, xorstr("48 89 5C 24 ? 48 89 6C 24 ? 56 57 41 56 48 81 EC ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 84 24 ? ? ? ? 48 8B F2 4C 8B F1 E8 ? ? ? ? 45 8B 06 33 ED 41 0F B7 16 41 C1 E8 10 89 54 24 24 44 89 44 24 ? 48 8B 4C 24 ? 48 C1 E9 20 8D 3C 09 4A 03 7C C0 ? 0F B7 17 C1 EA 06 41 39 6E 04"));
    if (!sdk::cached::GetNameByIndex) return;

    //GObjects
    auto objects = utilities::scan(sdk::cached::Base, xorstr("48 8B 05 ? ? ? ? 48 8B 0C C8 48 8B 04 D1"));
    sdk::classes::objects = decltype(sdk::classes::objects)(RELATIVE(objects, 7));

    // LineSightOfTo
    sdk::cached::LineSightOfTo = utilities::scan(sdk::cached::Base, xorstr("48 8B C4 48 89 58 ? 55 56 57 41 54 41 55 41 56 41 57 48 8D 6C 24 ? 48 81 EC ? ? ? ? 0F 29 70 ? 0F 29 78 ? 44 0F 29 40 ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 45 ? 45 8A E9"));
    if (!sdk::cached::LineSightOfTo) return;

    // GetBoneMatrix
    sdk::cached::GetBoneMatrix = utilities::scan(sdk::cached::Base, xorstr("E8 ? ? ? ? 48 8B 47 30 F3 0F 10 45"));
    sdk::cached::GetBoneMatrix = RELATIVE(sdk::cached::GetBoneMatrix, 5);
    if (!sdk::cached::GetBoneMatrix) return;

    // ProjectWorldToScreen
    sdk::cached::ProjectWorldToScreen = utilities::scan(sdk::cached::Base, xorstr("40 53 55 56 57 41 56 41 57 48 81 EC ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 84 24 ? ? ? ? 33 DB"));
    if (!sdk::cached::ProjectWorldToScreen) return;

    //InitObjects
    InitObjects();

    //Render
    overlay::Init();
}

bool __stdcall DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    if (ul_reason_for_call != DLL_PROCESS_ATTACH) return false;

    Init();

    return true;
}
```

`features.hpp`:

```hpp
#pragma once

namespace exploitsVars {
	AFortPawn* TargetPawn;
	sdk::structs::FRotator o_CamRot;
}

namespace exploitsFunctions {

	void(*o_GetViewPoint)(uintptr_t, sdk::structs::FMinimalViewInfo*, BYTE) = nullptr;
	void hk_GetViewPoint(uintptr_t this_LocalPlayer, sdk::structs::FMinimalViewInfo* OutViewInfo, BYTE StereoPass)
	{
		if (fakeunload) {
			return o_GetViewPoint(this_LocalPlayer, OutViewInfo, StereoPass);
		}

		o_GetViewPoint(this_LocalPlayer, OutViewInfo, StereoPass);

		if (Settings.aimConfigsPlayers.Silent)
		{
			if (GetAsyncKeyState(VK_RBUTTON)) {
				OutViewInfo->Rotation = exploitsVars::o_CamRot;
			}
		}

		OutViewInfo->FOV = 100.f;
	}

	sdk::structs::FVector calculate_prediction(AFortPawn* LocalPawn, AFortPawn* Target)
	{
		//Get the enemy location
		auto targetPosition = Target->GetBone(68);

		//Get the local location
		auto localPosition = LocalPawn->GetBone(68);

		//Calculate the difference
		sdk::structs::FVector Difference = targetPosition;
		Difference.X -= localPosition.X;
		Difference.Y -= localPosition.Y;
		Difference.Z -= localPosition.Z;
		
		//Calculate the distance
		float dist = utilities::custom_sqrtf(Difference.X * Difference.X + Difference.Y * Difference.Y + Difference.Z * Difference.Z);

		//Calculate the Scale Value
		auto Ping = LocalPawn->PlayerState()->CompressedPing() * 4;
		auto ScaleValue = float(Ping) + float(dist * 0.0193f);
		if (ScaleValue < 1.0f) ScaleValue = 1.0;
		
		//Get the enemy velocity
		auto Velocity = Target->GetVelocity();

		//Calculate the velocity
		float fVelocity = utilities::custom_sqrtf(Velocity.X * Velocity.X + Velocity.Y * Velocity.Y + Velocity.Z * Velocity.Z);

		if (fVelocity > 100.0f) 
		{
			Velocity.X *= ScaleValue / fVelocity; Velocity.Y *= ScaleValue / fVelocity; Velocity.Z *= ScaleValue / fVelocity;

			//Add the calculated values to the original target location
			targetPosition.X += Velocity.X;
			targetPosition.Y += Velocity.Y;
			targetPosition.Z += Velocity.Z;
		}

		return targetPosition;

	}
	
	void(*o_GetPlayerViewPoint)(uintptr_t, sdk::structs::FVector*, sdk::structs::FRotator*) = nullptr;
	void hk_GetPlayerViewPoint(uintptr_t this_PlayerController, sdk::structs::FVector* Location, sdk::structs::FRotator* Rotation) {

		if (fakeunload) {
			return o_GetPlayerViewPoint(this_PlayerController, Location, Rotation);
		}

		o_GetPlayerViewPoint(this_PlayerController, Location, Rotation);

		if (Settings.aimConfigsPlayers.Memory || Settings.aimConfigsPlayers.Silent)
		{
			exploitsVars::o_CamRot = *Rotation;

			sdk::cached::PlayerController = ((UWorld*)(utilities::read<uintptr_t>(sdk::cached::UWorld)))->OwningGameInstance()->LocalPlayers()->LocalPlayer()->PlayerController();
			auto LocalPawn = sdk::cached::PlayerController->LocalPawn();
			if (LocalPawn)
			{
				if (GetAsyncKeyState(VK_RBUTTON))
				{
					if (exploitsVars::TargetPawn)
					{

						auto rootHead = exploitsVars::TargetPawn->GetBone(68);
						sdk::structs::FVector camloc = *Location;

						if (Settings.aimConfigsPlayers.SniperPrediction)
						{
							rootHead = calculate_prediction(LocalPawn, exploitsVars::TargetPawn);
						}

						sdk::structs::FVector VectorPos;
						VectorPos.X = rootHead.X - camloc.X;
						VectorPos.Y = rootHead.Y - camloc.Y;
						VectorPos.Z = rootHead.Z - camloc.Z;

						float distance = (double)(utilities::custom_sqrtf(VectorPos.X * VectorPos.X + VectorPos.Y * VectorPos.Y + VectorPos.Z * VectorPos.Z));

						sdk::structs::FRotator rot;
						rot.Pitch = -((utilities::custom_acosf(VectorPos.Z / distance) * (float)(180.0f / 3.14159265358979323846264338327950288419716939937510)) - 90.f);
						rot.Yaw = utilities::custom_atan2f(VectorPos.Y, VectorPos.X) * (float)(180.0f / 3.14159265358979323846264338327950288419716939937510);
						rot.Roll = 0;

						*Rotation = rot;
					}
				}
			}
		}
	}
}




bool Floating_Disabled = true;
bool FirstCamera_Disabled = true;







int PlayersCpp() {

	AFortPawn* closestActor = 0;
	float closestDist = FLT_MAX;

	auto GWorld = utilities::read<uintptr_t>(sdk::cached::UWorld);
	auto World = (UWorld*)GWorld;
	sdk::cached::PlayerController = World->OwningGameInstance()->LocalPlayers()->LocalPlayer()->PlayerController();
	auto LocalPawn = sdk::cached::PlayerController->LocalPawn();

	auto PersistentLevel = World->PersistentLevel();


	
	sdk::structs::FVector LocalPawn_loc = LocalPawn->GetBone(68);


	auto levels = World->Levels();

	for (int a = 0; a < levels.Num(); a++)
	{
		auto actors = levels[a]->ActorArray();

		for (int i = 0; i < actors.Num(); i++)
		{
			auto actor = actors[i];
			if (!actor || actor == LocalPawn)
				continue;


			if (Settings.aimConfigsPlayers.BulletTP)
			{
				if (closestActor)
				{
					if (actor->IsA(sdk::cached::classes::FortProjectileBase))
					{
						if (utilities::custom_wcsstr(actor->ObjectName(), xorstr(L"B_Prj_Bullet_Sniper")))
						{
							actor->K2_SetActorLocation(closestActor->GetBone(68), false, true); //68
						}
					}
				}
			}

			if (actor->IsA(sdk::cached::classes::FortPlayerPawnAthena))
			{
				if (actor->IsDead()) continue;

				if (Settings.exploitsConfigs.Chams)
				{
					actor->Dingus(color(255.f, 0.f, 0.f, 255.f), color(255.f, 0.f, 0.f, 255.f));
				}
				if (Settings.exploitsConfigs.HeatMapChams)
				{
					actor->Dingus(color(1.f, 0.f, 0.f, 1.f), color(0.f, 1.f, 0.f, 1.f));
				}



				auto isVisible = sdk::cached::PlayerController->IsVisible(actor);

				auto WorldHead = actor->GetBone(68);
				auto Head = sdk::cached::PlayerController->WorldToScreen(WorldHead);

				if (LocalPawn) {

					auto dx = Head.x - (width / 2);
					auto dy = Head.y - (height / 2);
					auto dist = utilities::custom_sqrtf(dx * dx + dy * dy);

					if (dist < Settings.aimConfigsPlayers.FovCircle && dist < closestDist) {
						closestDist = dist;
						closestActor = actor;
					}
				}


				auto Top = sdk::cached::PlayerController->WorldToScreen({ WorldHead.X, WorldHead.Y, WorldHead.Z + 20 });
				auto Bottom = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(0));

				float TextOffset_Top = Top.y + 5;
				float TextOffset_Bottom = Bottom.y;

				color col = color(1.f, 0, 0, 1.f);

				//if (isVisible)
				//	col = color(0, 255, 0, 255);

				if (Settings.visualsConfigsPlayers.ESP)
				{
					if (Settings.visualsConfigsPlayers.Box2D)
					{
						float Height = Bottom.y - Top.y;
						float Width = Height * 0.55;

						Vector2 min;
						min.x = Bottom.x + Width / 2;
						min.y = Bottom.y;

						Vector2 max;
						max.x = Top.x - Width / 2;
						max.y = Top.y;

						Vector2 size;
						size.x = min.x - max.x;
						size.y = min.y - max.y;

						Render::DrawRect(max, size, col);
					}

					if (Settings.visualsConfigsPlayers.Box3D)
					{
						sdk::structs::FVector WorldOrigin;
						sdk::structs::FVector WorldBoxExtent;
						actor->GetActorBounds(bool(LocalPawn), false, &WorldOrigin, &WorldBoxExtent);

						Render::Box3D(sdk::cached::PlayerController, WorldOrigin, WorldBoxExtent, col);
					}


					if (Settings.visualsConfigsPlayers.Skeleton)
					{
						auto head = Head;
						auto neck = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(66));
						auto rightChest = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(8));
						auto leftChest = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(37));
						auto leftShoulder = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(38));
						auto rightShoulder = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(9));
						auto leftElbow = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(94));
						auto rightElbow = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(10));
						auto leftWrist = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(62));
						auto rightWrist = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(33));
						auto pelvis = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(2));
						auto leftAss = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(76));
						auto rightAss = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(69));
						auto leftKnee = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(77));
						auto rightKnee = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(70));
						auto leftAnkle = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(78));
						auto rightAnkle = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(71));

						Render::DrawLine(neck, leftChest, col, 1, true);
						Render::DrawLine(neck, rightChest, col, 1, true);
						Render::DrawLine(leftChest, leftShoulder, col, 1, true);
						Render::DrawLine(rightChest, rightShoulder, col, 1, true);
						Render::DrawLine(leftShoulder, leftElbow, col, 1, true);
						Render::DrawLine(rightShoulder, rightElbow, col, 1, true);
						Render::DrawLine(leftElbow, leftWrist, col, 1, true);
						Render::DrawLine(rightElbow, rightWrist, col, 1, true);
						Render::DrawLine(neck, pelvis, col, 1, true);
						Render::DrawLine(pelvis, leftAss, col, 1, true);
						Render::DrawLine(pelvis, rightAss, col, 1, true);
						Render::DrawLine(leftAss, leftKnee, col, 1, true);
						Render::DrawLine(rightAss, rightKnee, col, 1, true);
						Render::DrawLine(leftKnee, leftAnkle, col, 1, true);
						Render::DrawLine(rightKnee, rightAnkle, col, 1, true);
					}

					if (Settings.visualsConfigsPlayers.Lines)
					{
						auto enemyScreen = sdk::cached::PlayerController->WorldToScreen(actor->GetBone(2));

						Render::DrawLine(Vector2(width / 2, height), enemyScreen, col, 1, true);
					}

					if (Settings.visualsConfigsPlayers.Names)
					{
						auto name = xorstr(L"kreugher_1337");

						TextOffset_Top -= sdk::cached::Canvas->K2_TextSize(name).y;
						Vector2 calculation = Vector2(Top.x, TextOffset_Top);

						Render::DrawStrokeText(calculation, col, name);
					}

					if (Settings.visualsConfigsPlayers.Weapon)
					{
						auto weapon_data = actor->CurrentWeapon()->WeaponData();
						if (!weapon_data) continue;

						auto _name = weapon_data->DisplayName();
						if (!_name) continue;

						auto tier = weapon_data->Tier();
						auto name = _name->c_str();
						if (!name) continue;

						TextOffset_Bottom += sdk::cached::Canvas->K2_TextSize(name).y;
						auto calculation = Vector2(Bottom.x, TextOffset_Bottom);

						Render::DrawStrokeText(calculation, utilities::getColorFromTier(tier), name);
					}

					if (Settings.visualsConfigsPlayers.Distance)
					{
						int dist = WorldHead.getDistance(LocalPawn_loc);

						auto text = std::wstring(xorstr(L"[")) + std::to_wstring(dist) + std::wstring(xorstr(L"m]"));

						TextOffset_Bottom += sdk::cached::Canvas->K2_TextSize(text.c_str()).y;
						auto calculation = Vector2(Bottom.x, TextOffset_Bottom);

						Render::DrawStrokeText(calculation, col, text.c_str());
					}

					if (Settings.visualsConfigsPlayers.Platform)
					{
						auto platform = actor->PlayerState()->GetPlatform();
						if (!platform.IsValid()) continue;

						auto platform_name = platform.c_str();

						if (utilities::custom_wcsstr(platform_name, xorstr(L"PSN"))) {
							Render::DrawStrokeText(Head, color(1.f, 1.f, 0.f, 1.f), xorstr(L"PlayStation"));
						}
						else if (utilities::custom_wcsstr(platform_name, xorstr(L"XBL"))) {
							Render::DrawStrokeText(Head, color(1.f, 1.f, 0.f, 1.f), xorstr(L"Xbox"));
						}
						else if (utilities::custom_wcsstr(platform_name, xorstr(L"WIN"))) {
							Render::DrawStrokeText(Head, color(1.f, 1.f, 0.f, 1.f), xorstr(L"Windows"));
						}
						else if (utilities::custom_wcsstr(platform_name, xorstr(L"MAC"))) {
							Render::DrawStrokeText(Head, color(1.f, 1.f, 0.f, 1.f), xorstr(L"MacOS"));
						}
						else if (utilities::custom_wcsstr(platform_name, xorstr(L"LNX"))) {
							Render::DrawStrokeText(Head, color(1.f, 1.f, 0.f, 1.f), xorstr(L"Linux"));
						}
						else if (utilities::custom_wcsstr(platform_name, xorstr(L"IOS"))) {
							Render::DrawStrokeText(Head, color(1.f, 1.f, 0.f, 1.f), xorstr(L"Ios"));
						}
						else if (utilities::custom_wcsstr(platform_name, xorstr(L"AND"))) {
							Render::DrawStrokeText(Head, color(1.f, 1.f, 0.f, 1.f), xorstr(L"Android"));
						}
						else if (utilities::custom_wcsstr(platform_name, xorstr(L"SWT"))) {
							Render::DrawStrokeText(Head, color(1.f, 1.f, 0.f, 1.f), xorstr(L"NintendoSwitch"));
						}
						else {
							Render::DrawStrokeText(Head, color(1.f, 1.f, 0.f, 1.f), platform_name);
						}
					}
				}
			}

			if (Settings.visualsConfigsWorld.ESP)
			{
				if (Settings.visualsConfigsWorld.Loot)
				{
					if (actor->IsA(sdk::cached::classes::FortPickup))
					{
						auto loc = actor->RootComponent()->RelativeLocation();

						int dist = loc.getDistance(LocalPawn_loc);
						if (dist > 120) continue;

						auto item = actor->ItemDefinition();
						if (!item) continue;

						auto _name = item->DisplayName();
						if (!_name) continue;

						auto name = _name->c_str();
						if (!name) continue;

						if (utilities::custom_wcsstr(name, xorstr(L"Ammo: "))) continue;

						auto screen = sdk::cached::PlayerController->WorldToScreen(loc);
						Render::DrawStrokeText(screen, utilities::getColorFromTier(item->Tier()), (std::wstring(name) + xorstr(L" [") + std::to_wstring(dist) + xorstr(L"m]")).c_str());
					}
				}

				if (Settings.visualsConfigsWorld.Chest || Settings.visualsConfigsWorld.AmmoBox)
				{
					if (actor->IsA(sdk::cached::classes::BuildingContainer))
					{
						auto loc = actor->RootComponent()->RelativeLocation();

						int dist = loc.getDistance(LocalPawn_loc);
						if (dist > 120) continue;

						//Get Classes the first time
						if (!sdk::cached::classes::Tiered_Chest)
						{
							auto currentClass = ((sdk::classes::UObject*)actor)->Class;
							auto currentClassName = sdk::objects::get_object_name((sdk::classes::UObject*)currentClass);
							if (utilities::custom_wcsstr(currentClassName, xorstr(L"Tiered_Chest")))
							{
								sdk::cached::classes::Tiered_Chest = PVOID(currentClass);
							}
						}
						if (!sdk::cached::classes::Tiered_Ammo)
						{
							auto currentClass = ((sdk::classes::UObject*)actor)->Class;
							auto currentClassName = sdk::objects::get_object_name((sdk::classes::UObject*)currentClass);
							if (utilities::custom_wcsstr(currentClassName, xorstr(L"Tiered_Ammo")))
							{
								sdk::cached::classes::Tiered_Ammo = PVOID(currentClass);
							}
						}

						if (actor->bAlreadySearched()) continue;

						auto screen = sdk::cached::PlayerController->WorldToScreen(loc);

						if (Settings.visualsConfigsWorld.Chest)
						{
							if (sdk::cached::classes::Tiered_Chest && actor->IsA(sdk::cached::classes::Tiered_Chest))
							{
								Render::DrawStrokeText(screen, color(1.f, 1.f, 0, 1.f), (std::wstring(xorstr(L"Chest")) + xorstr(L" [") + std::to_wstring(dist) + xorstr(L"m]")).c_str());
							}
						}

						if (Settings.visualsConfigsWorld.AmmoBox)
						{
							if (sdk::cached::classes::Tiered_Ammo && actor->IsA(sdk::cached::classes::Tiered_Ammo))
							{
								Render::DrawStrokeText(screen, color(1.f, 1.f, 1.f, 1.f), (std::wstring(xorstr(L"AmmoBox")) + xorstr(L" [") + std::to_wstring(dist) + xorstr(L"m]")).c_str());
							}
						}
					}
				}
				
			}
		}

		
	}


	if (LocalPawn)
	{
		if (closestActor)
		{
			sdk::structs::FViewTargetTransitionParams TransitionParams;
			TransitionParams.BlendTime = 1.f;
			TransitionParams.BlendExp = 2.f;
			TransitionParams.BlendFunction = sdk::structs::EViewTargetBlendFunction::VTBlend_EaseIn;
			TransitionParams.bLockOutgoing = true;

			if (GetAsyncKeyState(VK_F8) & 1)
			{
				sdk::cached::PlayerController->ClientSetViewTarget(closestActor, TransitionParams);
			}
			if (GetAsyncKeyState(VK_F9) & 1)
			{
				sdk::cached::PlayerController->ClientSetViewTarget(LocalPawn, TransitionParams);
			}
			

			//if (GetAsyncKeyState(VK_RBUTTON))
				exploitsVars::TargetPawn = closestActor;
			//else
			//	exploitsVars::TargetPawn = 0;


			if (Settings.visualsConfigsPlayers.ESP)
			{
				if (Settings.visualsConfigsPlayers.TargetLine)
				{
					if (GetAsyncKeyState(VK_RBUTTON))
					{
						auto weapon = LocalPawn->CurrentWeapon();
						if (!weapon) return false;

						auto weapon_data = LocalPawn->CurrentWeapon()->WeaponData();
						if (!weapon_data) return false;

						auto _name = weapon_data->DisplayName();
						if (!_name) return false;

						auto name = _name->c_str();
						if (!name) return false;

						if (!utilities::custom_wcsstr(name, xorstr(L"Harvesting")))
						{
							sdk::structs::FVector WorldMuzzle = weapon->GetMuzzleLocation(0);
							auto localScreen = sdk::cached::PlayerController->WorldToScreen(WorldMuzzle);

							auto enemyScreen = sdk::cached::PlayerController->WorldToScreen(closestActor->GetBone(2));


							color col = color(1.f, 0, 0, 1.f);

							if (utilities::IsInScreen(localScreen) && utilities::IsInScreen(enemyScreen))
								Render::DrawLine(localScreen, enemyScreen, col, 1);
						}
					}					
				}
			}
		}
		else
			exploitsVars::TargetPawn = 0;



		if (Settings.exploitsConfigs.DayTime)
		{
			World->SetTimeOfDay(Settings.exploitsConfigs.DayTime_value);
		}

		if (Settings.exploitsConfigs.Floating)
		{
			LocalPawn->StartFloating();
			Floating_Disabled = false;
		}
		else {
			if (!Floating_Disabled)
			{
				LocalPawn->EndFloating();
				Floating_Disabled = true;
			}
		}


		if (Settings.exploitsConfigs.FirstCamera)
		{
			sdk::cached::PlayerController->ClientSetCameraMode(sdk::objects::Conv_StringToName(xorstr(L"FirstPerson")));
			LocalPawn->SetCharacterBodyVisibilityForPossession(false);
			FirstCamera_Disabled = false;
		}
		else {
			if (!FirstCamera_Disabled)
			{
				sdk::cached::PlayerController->ClientSetCameraMode(sdk::objects::Conv_StringToName(xorstr(L"Default")));
				LocalPawn->SetCharacterBodyVisibilityForPossession(true);
				FirstCamera_Disabled = true;
			}
		}
		

	}
	else
		exploitsVars::TargetPawn = 0;

	//Return inGame
	return bool(LocalPawn);
}
```

`fortnight.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "fortnight", "fortnight.vcxproj", "{21F4B5BB-C0FC-4F49-BC65-9C714EFB45A3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{21F4B5BB-C0FC-4F49-BC65-9C714EFB45A3}.Debug|x64.ActiveCfg = Debug|x64
		{21F4B5BB-C0FC-4F49-BC65-9C714EFB45A3}.Debug|x64.Build.0 = Debug|x64
		{21F4B5BB-C0FC-4F49-BC65-9C714EFB45A3}.Debug|x86.ActiveCfg = Debug|Win32
		{21F4B5BB-C0FC-4F49-BC65-9C714EFB45A3}.Debug|x86.Build.0 = Debug|Win32
		{21F4B5BB-C0FC-4F49-BC65-9C714EFB45A3}.Release|x64.ActiveCfg = Release|x64
		{21F4B5BB-C0FC-4F49-BC65-9C714EFB45A3}.Release|x64.Build.0 = Release|x64
		{21F4B5BB-C0FC-4F49-BC65-9C714EFB45A3}.Release|x86.ActiveCfg = Release|Win32
		{21F4B5BB-C0FC-4F49-BC65-9C714EFB45A3}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0D36AC7F-4425-4425-93FF-6CE39EA69F97}
	EndGlobalSection
EndGlobal

```

`fortnight.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{21f4b5bb-c0fc-4f49-bc65-9c714efb45a3}</ProjectGuid>
    <RootNamespace>fortnight</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>./;$(IncludePath);C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;</IncludePath>
    <TargetName>fortnight</TargetName>
    <LibraryPath>$(LibraryPath);C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x64;</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="minhook\src\buffer.c" />
    <ClCompile Include="minhook\src\hde\hde32.c" />
    <ClCompile Include="minhook\src\hde\hde64.c" />
    <ClCompile Include="minhook\src\hook.c" />
    <ClCompile Include="minhook\src\trampoline.c" />
    <ClCompile Include="overlay.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="features.hpp" />
    <ClInclude Include="includes.hpp" />
    <ClInclude Include="lazy.hpp" />
    <ClInclude Include="minhook\include\MinHook.h" />
    <ClInclude Include="minhook\src\buffer.h" />
    <ClInclude Include="minhook\src\hde\hde32.h" />
    <ClInclude Include="minhook\src\hde\hde64.h" />
    <ClInclude Include="minhook\src\hde\pstdint.h" />
    <ClInclude Include="minhook\src\hde\table32.h" />
    <ClInclude Include="minhook\src\hde\table64.h" />
    <ClInclude Include="minhook\src\trampoline.h" />
    <ClInclude Include="overlay.hpp" />
    <ClInclude Include="render\renderer.h" />
    <ClInclude Include="sdk.hpp" />
    <ClInclude Include="spoofcall.hpp" />
    <ClInclude Include="utilities.hpp" />
    <ClInclude Include="vectors.h" />
    <ClInclude Include="xorstr.hpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="spoofcall.asm" />
  </ItemGroup>
  <ItemGroup>
    <None Include="minhook\dll_resources\MinHook.def" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="minhook\dll_resources\MinHook.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`fortnight.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="File di origine">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="File di intestazione">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="File di intestazione\spoofing">
      <UniqueIdentifier>{3a139a98-c6c1-4ea7-a93d-a071394860cb}</UniqueIdentifier>
    </Filter>
    <Filter Include="File di intestazione\framework">
      <UniqueIdentifier>{d5141415-f9f7-4ace-8d1d-1175ac9673a7}</UniqueIdentifier>
    </Filter>
    <Filter Include="File di intestazione\overlay">
      <UniqueIdentifier>{2d0935ea-f249-4d29-9431-5b91aaa46268}</UniqueIdentifier>
    </Filter>
    <Filter Include="File di intestazione\render">
      <UniqueIdentifier>{60ad5036-0d7e-4526-9695-1f7af12c25bd}</UniqueIdentifier>
    </Filter>
    <Filter Include="mintest">
      <UniqueIdentifier>{31ccc6f4-1422-4989-860c-ab092979b421}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>File di origine</Filter>
    </ClCompile>
    <ClCompile Include="overlay.cpp">
      <Filter>File di intestazione\overlay</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\buffer.c">
      <Filter>mintest</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\hde\hde32.c">
      <Filter>mintest</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\hde\hde64.c">
      <Filter>mintest</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\hook.c">
      <Filter>mintest</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\trampoline.c">
      <Filter>mintest</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.hpp">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="lazy.hpp">
      <Filter>File di intestazione\spoofing</Filter>
    </ClInclude>
    <ClInclude Include="sdk.hpp">
      <Filter>File di intestazione\framework</Filter>
    </ClInclude>
    <ClInclude Include="overlay.hpp">
      <Filter>File di intestazione\overlay</Filter>
    </ClInclude>
    <ClInclude Include="utilities.hpp">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="xorstr.hpp">
      <Filter>File di intestazione\spoofing</Filter>
    </ClInclude>
    <ClInclude Include="spoofcall.hpp">
      <Filter>File di intestazione\spoofing</Filter>
    </ClInclude>
    <ClInclude Include="render\renderer.h">
      <Filter>File di intestazione\render</Filter>
    </ClInclude>
    <ClInclude Include="features.hpp">
      <Filter>File di intestazione\framework</Filter>
    </ClInclude>
    <ClInclude Include="vectors.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="minhook\include\MinHook.h">
      <Filter>mintest</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\buffer.h">
      <Filter>mintest</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\hde32.h">
      <Filter>mintest</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\hde64.h">
      <Filter>mintest</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\pstdint.h">
      <Filter>mintest</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\table32.h">
      <Filter>mintest</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\table64.h">
      <Filter>mintest</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\trampoline.h">
      <Filter>mintest</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="spoofcall.asm">
      <Filter>File di intestazione\spoofing</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <None Include="minhook\dll_resources\MinHook.def">
      <Filter>mintest</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="minhook\dll_resources\MinHook.rc">
      <Filter>mintest</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`fortnight.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`includes.hpp`:

```hpp
#pragma once
#include <Windows.h>
//#include <winternl.h>
#include <iostream>
#include <vector>
#include <thread>
#include <string>
#include <d3d11.h>
#pragma comment(lib, "d3d11.lib")


// spoofing & utils
#include "xorstr.hpp"
#include "lazy.hpp"
#include "spoofcall.hpp"

//utils
#include "vectors.h"
#include "utilities.hpp"

//Sdk
#include "sdk.hpp"


//overlay
#include "overlay.hpp"

```

`lazy.hpp`:

```hpp
/*
 * Copyright 2018-2020 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 // documentation is available at https://github.com/JustasMasiulis/lazy_importer

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP

#define LI_FN(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<::li::detail::khash(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<::li::detail::khash(name)>()

// NOTE only std::forward is used from this header.
// If there is a need to eliminate this dependency the function itself is very small.

#include <utility>
#include <cstddef>
#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif

#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_TOLOWER(c) (c >= 'A' && c <= 'Z' ? (c | (1 << 5)) : c)
#else
#define LAZY_IMPORTER_TOLOWER(c) (c)
#endif

namespace li {
    namespace detail {

        template<class First, class Second>
        struct pair {
            First  first;
            Second second;
        };

        namespace win {

            struct LIST_ENTRY_T {
                const char* Flink;
                const char* Blink;
            };

            struct UNICODE_STRING_T {
                unsigned short Length;
                unsigned short MaximumLength;
                wchar_t* Buffer;
            };

            struct PEB_LDR_DATA_T {
                unsigned long Length;
                unsigned long Initialized;
                const char* SsHandle;
                LIST_ENTRY_T  InLoadOrderModuleList;
            };

            struct PEB_T {
                unsigned char   Reserved1[ 2 ];
                unsigned char   BeingDebugged;
                unsigned char   Reserved2[ 1 ];
                const char* Reserved3[ 2 ];
                PEB_LDR_DATA_T* Ldr;
            };

            struct LDR_DATA_TABLE_ENTRY_T {
                LIST_ENTRY_T InLoadOrderLinks;
                LIST_ENTRY_T InMemoryOrderLinks;
                LIST_ENTRY_T InInitializationOrderLinks;
                const char* DllBase;
                const char* EntryPoint;
                union {
                    unsigned long SizeOfImage;
                    const char* _dummy;
                };
                UNICODE_STRING_T FullDllName;
                UNICODE_STRING_T BaseDllName;

                LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                    load_order_next( ) const noexcept
                {
                    return reinterpret_cast< const LDR_DATA_TABLE_ENTRY_T* >(
                        InLoadOrderLinks.Flink );
                }
            };

            struct IMAGE_DOS_HEADER { // DOS .EXE header
                unsigned short e_magic; // Magic number
                unsigned short e_cblp; // Bytes on last page of file
                unsigned short e_cp; // Pages in file
                unsigned short e_crlc; // Relocations
                unsigned short e_cparhdr; // Size of header in paragraphs
                unsigned short e_minalloc; // Minimum extra paragraphs needed
                unsigned short e_maxalloc; // Maximum extra paragraphs needed
                unsigned short e_ss; // Initial (relative) SS value
                unsigned short e_sp; // Initial SP value
                unsigned short e_csum; // Checksum
                unsigned short e_ip; // Initial IP value
                unsigned short e_cs; // Initial (relative) CS value
                unsigned short e_lfarlc; // File address of relocation table
                unsigned short e_ovno; // Overlay number
                unsigned short e_res[ 4 ]; // Reserved words
                unsigned short e_oemid; // OEM identifier (for e_oeminfo)
                unsigned short e_oeminfo; // OEM information; e_oemid specific
                unsigned short e_res2[ 10 ]; // Reserved words
                long           e_lfanew; // File address of new exe header
            };

            struct IMAGE_FILE_HEADER {
                unsigned short Machine;
                unsigned short NumberOfSections;
                unsigned long  TimeDateStamp;
                unsigned long  PointerToSymbolTable;
                unsigned long  NumberOfSymbols;
                unsigned short SizeOfOptionalHeader;
                unsigned short Characteristics;
            };

            struct IMAGE_EXPORT_DIRECTORY {
                unsigned long  Characteristics;
                unsigned long  TimeDateStamp;
                unsigned short MajorVersion;
                unsigned short MinorVersion;
                unsigned long  Name;
                unsigned long  Base;
                unsigned long  NumberOfFunctions;
                unsigned long  NumberOfNames;
                unsigned long  AddressOfFunctions; // RVA from base of image
                unsigned long  AddressOfNames; // RVA from base of image
                unsigned long  AddressOfNameOrdinals; // RVA from base of image
            };

            struct IMAGE_DATA_DIRECTORY {
                unsigned long VirtualAddress;
                unsigned long Size;
            };

            struct IMAGE_OPTIONAL_HEADER64 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long long   ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long long   SizeOfStackReserve;
                unsigned long long   SizeOfStackCommit;
                unsigned long long   SizeOfHeapReserve;
                unsigned long long   SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[ 16 ];
            };

            struct IMAGE_OPTIONAL_HEADER32 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long        BaseOfData;
                unsigned long        ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long        SizeOfStackReserve;
                unsigned long        SizeOfStackCommit;
                unsigned long        SizeOfHeapReserve;
                unsigned long        SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[ 16 ];
            };

            struct IMAGE_NT_HEADERS {
                unsigned long     Signature;
                IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
                IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
                IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
            };

        } // namespace win

        // hashing stuff
        struct hash_t {
            using value_type = unsigned long;
            constexpr static value_type         offset = 2166136261;
            constexpr static value_type         prime = 16777619;
            constexpr static unsigned long long prime64 = prime;

            LAZY_IMPORTER_FORCEINLINE constexpr static value_type single( value_type value,
                char c ) noexcept
            {
                return static_cast< hash_t::value_type >(
                    ( value ^ LAZY_IMPORTER_TOLOWER( c ) ) *
                    static_cast< unsigned long long >( prime ) );
            }
        };

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE constexpr hash_t::value_type
            khash( const CharT* str, hash_t::value_type value = hash_t::offset ) noexcept
        {
            return ( *str ? khash( str + 1, hash_t::single( value, *str ) ) : value );
        }

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash( const CharT* str ) noexcept
        {
            hash_t::value_type value = hash_t::offset;

            for ( ;;) {
                char c = *str++;
                if ( !c )
                    return value;
                value = hash_t::single( value, c );
            }
        }

        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(
            const win::UNICODE_STRING_T& str ) noexcept
        {
            auto       first = str.Buffer;
            const auto last = first + ( str.Length / sizeof( wchar_t ) );
            auto       value = hash_t::offset;
            for ( ; first != last; ++first )
                value = hash_t::single( value, static_cast< char >( *first ) );

            return value;
        }

        LAZY_IMPORTER_FORCEINLINE pair<hash_t::value_type, hash_t::value_type> hash_forwarded(
            const char* str ) noexcept
        {
            pair<hash_t::value_type, hash_t::value_type> module_and_function {
                hash_t::offset, hash_t::offset
            };

            for ( ; *str != '.'; ++str )
                module_and_function.first = hash_t::single( module_and_function.first, *str );

            ++str;

            for ( ; *str; ++str )
                module_and_function.second = hash_t::single( module_and_function.second, *str );

            return module_and_function;
        }


        // some helper functions
        LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb( ) noexcept
        {
#if defined(_M_X64) || defined(__amd64__)
            return reinterpret_cast< const win::PEB_T* >( __readgsqword( 0x60 ) );
#elif defined(_M_IX86) || defined(__i386__)
            return reinterpret_cast< const win::PEB_T* >( __readfsdword( 0x30 ) );
#elif defined(_M_ARM) || defined(__arm__)
            return *reinterpret_cast< const win::PEB_T** >( _MoveFromCoprocessor( 15, 0, 13, 0, 2 ) + 0x30 );
#elif defined(_M_ARM64) || defined(__aarch64__)
            return *reinterpret_cast< const win::PEB_T** >( __getReg( 18 ) + 0x60 );
#elif defined(_M_IA64) || defined(__ia64__)
            return *reinterpret_cast< const win::PEB_T** >( static_cast< char* >( _rdteb( ) ) + 0x60 );
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
        }

        LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr( )
        {
            return reinterpret_cast< const win::PEB_LDR_DATA_T* >( peb( )->Ldr );
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
            const char* base ) noexcept
        {
            return reinterpret_cast< const win::IMAGE_NT_HEADERS* >(
                base + reinterpret_cast< const win::IMAGE_DOS_HEADER* >( base )->e_lfanew );
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
            const char* base ) noexcept
        {
            return reinterpret_cast< const win::IMAGE_EXPORT_DIRECTORY* >(
                base + nt_headers( base )->OptionalHeader.DataDirectory->VirtualAddress );
        }

        LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry( ) noexcept
        {
            return reinterpret_cast< const win::LDR_DATA_TABLE_ENTRY_T* >(
                ldr( )->InLoadOrderModuleList.Flink );
        }

        struct exports_directory {
            const char* _base;
            const win::IMAGE_EXPORT_DIRECTORY* _ied;
            unsigned long                      _ied_size;

        public:
            using size_type = unsigned long;

            LAZY_IMPORTER_FORCEINLINE
                exports_directory( const char* base ) noexcept : _base( base )
            {
                const auto ied_data_dir = nt_headers( base )->OptionalHeader.DataDirectory[ 0 ];
                _ied = reinterpret_cast< const win::IMAGE_EXPORT_DIRECTORY* >(
                    base + ied_data_dir.VirtualAddress );
                _ied_size = ied_data_dir.Size;
            }

            LAZY_IMPORTER_FORCEINLINE explicit operator bool( ) const noexcept
            {
                return reinterpret_cast< const char* >( _ied ) != _base;
            }

            LAZY_IMPORTER_FORCEINLINE size_type size( ) const noexcept
            {
                return _ied->NumberOfNames;
            }

            LAZY_IMPORTER_FORCEINLINE const char* base( ) const noexcept { return _base; }
            LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied( ) const noexcept
            {
                return _ied;
            }

            LAZY_IMPORTER_FORCEINLINE const char* name( size_type index ) const noexcept
            {
                return reinterpret_cast< const char* >(
                    _base + reinterpret_cast< const unsigned long* >(
                        _base + _ied->AddressOfNames )[ index ] );
            }

            LAZY_IMPORTER_FORCEINLINE const char* address( size_type index ) const noexcept
            {
                const auto* const rva_table =
                    reinterpret_cast< const unsigned long* >( _base + _ied->AddressOfFunctions );

                const auto* const ord_table = reinterpret_cast< const unsigned short* >(
                    _base + _ied->AddressOfNameOrdinals );

                return _base + rva_table[ ord_table[ index ] ];
            }

            LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
                const char* export_address ) const noexcept
            {
                const auto ui_ied = reinterpret_cast< const char* >( _ied );
                return ( export_address > ui_ied && export_address < ui_ied + _ied_size );
            }
        };

        struct safe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
            value_type* value;
            value_type* head;

            LAZY_IMPORTER_FORCEINLINE safe_module_enumerator( ) noexcept
                : safe_module_enumerator( ldr_data_entry( ) )
            {}

            LAZY_IMPORTER_FORCEINLINE
                safe_module_enumerator( const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr ) noexcept
                : value( ldr->load_order_next( ) ), head( value )
            {}

            LAZY_IMPORTER_FORCEINLINE void reset( ) noexcept
            {
                value = head->load_order_next( );
            }

            LAZY_IMPORTER_FORCEINLINE bool next( ) noexcept
            {
                value = value->load_order_next( );

                return value != head && value->DllBase;
            }
        };

        struct unsafe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
            value_type value;

            LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator( ) noexcept
                : value( ldr_data_entry( ) )
            {}

            LAZY_IMPORTER_FORCEINLINE void reset( ) noexcept { value = ldr_data_entry( ); }

            LAZY_IMPORTER_FORCEINLINE bool next( ) noexcept
            {
                value = value->load_order_next( );
                return true;
            }
        };

        // provides the cached functions which use Derive classes methods
        template<class Derived, class DefaultType = void*>
        class lazy_base {
        protected:
            // This function is needed because every templated function
            // with different args has its own static buffer
            LAZY_IMPORTER_FORCEINLINE static void*& _cache( ) noexcept
            {
                static void* value = nullptr;
                return value;
            }

        public:
            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe( ) noexcept
            {
                return Derived::template get<T, safe_module_enumerator>( );
            }

            template<class T = DefaultType, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T cached( ) noexcept
            {
                auto& cached = _cache( );
                if ( !cached )
                    cached = Derived::template get<void*, Enum>( );

                return ( T ) ( cached );
            }

            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe_cached( ) noexcept
            {
                return cached<T, safe_module_enumerator>( );
            }
        };

        template<hash_t::value_type Hash>
        struct lazy_module : lazy_base<lazy_module<Hash>> {
            template<class T = void*, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T get( ) noexcept
            {
                Enum e;
                do {
                    if ( hash( e.value->BaseDllName ) == Hash )
                        return ( T ) ( e.value->DllBase );
                } while ( e.next( ) );
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in( Ldr ldr ) noexcept
            {
                safe_module_enumerator e( ( const detail::win::LDR_DATA_TABLE_ENTRY_T* ) ( ldr ) );
                do {
                    if ( hash( e.value->BaseDllName ) == Hash )
                        return ( T ) ( e.value->DllBase );
                } while ( e.next( ) );
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in_cached( Ldr ldr ) noexcept
            {
                auto& cached = lazy_base<lazy_module<Hash>>::_cache( );
                if ( !cached )
                    cached = in( ldr );

                return ( T ) ( cached );
            }
        };

        template<hash_t::value_type Hash, class T>
        struct lazy_function : lazy_base<lazy_function<Hash, T>, T> {
            using base_type = lazy_base<lazy_function<Hash, T>, T>;

            template<class... Args>
            LAZY_IMPORTER_FORCEINLINE decltype( auto ) operator()( Args&&... args ) const
            {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
                return get( )( std::forward<Args>( args )... );
#else
                return this->cached( )( std::forward<Args>( args )... );
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F get( ) noexcept
            {
                // for backwards compatability.
                // Before 2.0 it was only possible to resolve forwarded exports when
                // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
                return forwarded<F, Enum>( );
#else

                Enum e;

                do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                    if ( !e.value->DllBase || !e.value->FullDllName.Length )
                        continue;
#endif

                    const exports_directory exports( e.value->DllBase );

                    if ( exports ) {
                        auto export_index = exports.size( );
                        while ( export_index-- )
                            if ( hash( exports.name( export_index ) ) == Hash )
                                return ( F ) ( exports.address( export_index ) );
                    }
                } while ( e.next( ) );
                return {};
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded( ) noexcept
            {
                detail::win::UNICODE_STRING_T name;
                hash_t::value_type            module_hash = 0;
                auto                          function_hash = Hash;

                Enum e;
                do {
                    name = e.value->BaseDllName;
                    name.Length -= 8; // get rid of .dll extension

                    if ( !module_hash || hash( name ) == module_hash ) {
                        const exports_directory exports( e.value->DllBase );

                        if ( exports ) {
                            auto export_index = exports.size( );
                            while ( export_index-- )
                                if ( hash( exports.name( export_index ) ) == function_hash ) {
                                    const auto addr = exports.address( export_index );

                                    if ( exports.is_forwarded( addr ) ) {
                                        auto hashes = hash_forwarded(
                                            reinterpret_cast< const char* >( addr ) );

                                        function_hash = hashes.second;
                                        module_hash = hashes.first;

                                        e.reset( );
                                        break;
                                    }
                                    return ( F ) ( addr );
                                }
                        }
                    }
                } while ( e.next( ) );
                return {};
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe( ) noexcept
            {
                return forwarded<F, safe_module_enumerator>( );
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_cached( ) noexcept
            {
                auto& value = base_type::_cache( );
                if ( !value )
                    value = forwarded<void*, Enum>( );
                return ( F ) ( value );
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached( ) noexcept
            {
                return forwarded_cached<F, safe_module_enumerator>( );
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in( Module m ) noexcept
            {
                if ( IsSafe && !m )
                    return {};

                const exports_directory exports( ( const char* ) ( m ) );
                if ( IsSafe && !exports )
                    return {};

                for ( unsigned long i {};; ++i ) {
                    if ( IsSafe && i == exports.size( ) )
                        break;

                    if ( hash( exports.name( i ) ) == Hash )
                        return ( F ) ( exports.address( i ) );
                }
                return {};
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe( Module m ) noexcept
            {
                return in<F, true>( m );
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_cached( Module m ) noexcept
            {
                auto& value = base_type::_cache( );
                if ( !value )
                    value = in<void*, IsSafe>( m );
                return ( F ) ( value );
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe_cached( Module m ) noexcept
            {
                return in_cached<F, true>( m );
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt( ) noexcept
            {
                return in<F>( ldr_data_entry( )->load_order_next( )->DllBase );
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe( ) noexcept
            {
                return in_safe<F>( ldr_data_entry( )->load_order_next( )->DllBase );
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_cached( ) noexcept
            {
                return in_cached<F>( ldr_data_entry( )->load_order_next( )->DllBase );
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached( ) noexcept
            {
                return in_safe_cached<F>( ldr_data_entry( )->load_order_next( )->DllBase );
            }
        };

    }
} // namespace li::detail

#endif // include guard
```

`minhook/include/MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a Hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget    [in]  A pointer to the target function, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    //   ppTarget   [out] A pointer to the target function, which will be used
    //                    with other functions.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif


```

`overlay.cpp`:

```cpp
#pragma once
#include "includes.hpp"
#include "overlay.hpp"
#include "render/renderer.h"
#include "features.hpp"
#include "minhook/include/MinHook.h"

// main variables
bool						bExecuteOnce = true;
bool						showMenu = true;


// tick
void Loop()
{
	Render::DrawCircle(Vector2(width / 2, height / 2), Settings.aimConfigsPlayers.FovCircle, color(1.f, 1.f, 1.f, 1.f));

	//Fortnite
	boolean inGame = PlayersCpp();

	if (inGame)
		Render::DrawFilledCircle({ 20, 20 }, 5, color(0, 255, 0, 255));
	else
		Render::DrawFilledCircle({ 20, 20 }, 5, color(255, 0, 0, 255));
}


VOID(*PostRender_O)(uintptr_t _this, uintptr_t Canvas) = nullptr;


Vector2 mousePos;

bool inArea(Vector2 area1, Vector2 area2) {
    if (mousePos.x >= area1.x && mousePos.x <= area2.x && mousePos.y >= area1.y && mousePos.y <= area2.y)
        return true;
    else
        return false;
}




void CustomTab(float x, float& y, const wchar_t* content, bool& config) {

    y += 30.f;
    Render::DrawStrokeText(Vector2(x, y), color(1.f, 1.f, 1.f, 1.f), content, false, false, false);

    //Render::DrawRect(Vector2(x + 195 - 2, y - 2), Vector2(21, 21), color(1.f, 1.f, 0.f, 1.f));
    if (inArea(Vector2(x + 195 - 2, y - 2), Vector2(x + 195 + 19, y + 19)))
        if (GetAsyncKeyState(VK_LBUTTON) & 1)
            config = !config;

    if (config)
        Render::DrawStrokeText(Vector2(x + 195, y), color(0.f, 0.4, 0.f, 1.f), xorstr(L"On"), false, false, false);
    else 
        Render::DrawStrokeText(Vector2(x + 195, y), color(1.f, 0.1f, 0.1f, 1.f), xorstr(L"Off"), false, false, false);
}


VOID PostRender(uintptr_t _this, uintptr_t Canvas)
{
	if (fakeunload or !Canvas) {
		return PostRender_O(_this, Canvas);
	}

	if (bExecuteOnce) {
        sdk::cached::Canvas = (UCanvas*)(Canvas);
        width = sdk::cached::Canvas->SizeX();
        height = sdk::cached::Canvas->SizeY();


        sdk::cached::PlayerController = ((UWorld*)(utilities::read<uintptr_t>(sdk::cached::UWorld)))->OwningGameInstance()->LocalPlayers()->LocalPlayer()->PlayerController();

        sdk::cached::keys::LButton.KeyName = sdk::structs::FName{ sdk::objects::Conv_StringToName(xorstr(L"LeftMouseButton")).ComparisonIndex, 0 };
        sdk::cached::keys::Insert.KeyName = sdk::structs::FName{ sdk::objects::Conv_StringToName(xorstr(L"Insert")).ComparisonIndex, 0 };

		bExecuteOnce = false;
	}

    sdk::cached::PlayerController = ((UWorld*)(utilities::read<uintptr_t>(sdk::cached::UWorld)))->OwningGameInstance()->LocalPlayers()->LocalPlayer()->PlayerController();

    if (GetAsyncKeyState(VK_INSERT) & 1) {
        showMenu = !showMenu;
    }

    Loop();
    
    if (showMenu)
    {
        mousePos = sdk::cached::PlayerController->GetMousePosition();

        static Vector2 menuPos = Vector2(35, 50);
        static Vector2 dragPos;

        float width = 260;
        float height = 910;

        Render::DrawFilledRect(Vector2(menuPos.x - 15, menuPos.y), Vector2(width, height), color(0.005f, 0.005f, 0.005f, 1.f), false);
        Render::DrawRect(Vector2(menuPos.x - 15, menuPos.y), Vector2(width, height), color(0.1f, 0.f, 1.f, 1.f), 1, false);
        Render::DrawStrokeText(Vector2(menuPos.x, menuPos.y + 5), color(1.f, 1.f, 0.f, 1.f), xorstr(L"Fartnight"), false, false, false);

        float tmp_y = menuPos.y;

        //Players ESP
        tmp_y += 48;
        Render::DrawStrokeText(Vector2(menuPos.x, tmp_y), color(0.1f, 0.f, 1.f, 1.f), xorstr(L"Players ESP"), false, false, false);
        CustomTab(menuPos.x, tmp_y, xorstr(L"ESP: "), Settings.visualsConfigsPlayers.ESP);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Box2D: "), Settings.visualsConfigsPlayers.Box2D);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Box3D: "), Settings.visualsConfigsPlayers.Box3D);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Skeleton: "), Settings.visualsConfigsPlayers.Skeleton);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Lines: "), Settings.visualsConfigsPlayers.Lines);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Names: "), Settings.visualsConfigsPlayers.Names);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Weapon: "), Settings.visualsConfigsPlayers.Weapon);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Distance: "), Settings.visualsConfigsPlayers.Distance);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Platform: "), Settings.visualsConfigsPlayers.Platform);
        CustomTab(menuPos.x, tmp_y, xorstr(L"TargetLine: "), Settings.visualsConfigsPlayers.TargetLine);


        //Players Aimbot
        tmp_y += 48;
        Render::DrawStrokeText(Vector2(menuPos.x, tmp_y), color(0.1f, 0.f, 1.f, 1.f), xorstr(L"Players Aimbot"), false, false, false);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Memory: "), Settings.aimConfigsPlayers.Memory);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Silent: "), Settings.aimConfigsPlayers.Silent);
        CustomTab(menuPos.x, tmp_y, xorstr(L"BulletTP: "), Settings.aimConfigsPlayers.BulletTP);
        CustomTab(menuPos.x, tmp_y, xorstr(L"SniperPrediction: "), Settings.aimConfigsPlayers.SniperPrediction);


        //World ESP
        tmp_y += 48;
        Render::DrawStrokeText(Vector2(menuPos.x, tmp_y), color(0.1f, 0.f, 1.f, 1.f), xorstr(L"World ESP"), false, false, false);
        CustomTab(menuPos.x, tmp_y, xorstr(L"ESP: "), Settings.visualsConfigsWorld.ESP);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Loot: "), Settings.visualsConfigsWorld.Loot);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Chest: "), Settings.visualsConfigsWorld.Chest);
        CustomTab(menuPos.x, tmp_y, xorstr(L"AmmoBox: "), Settings.visualsConfigsWorld.AmmoBox);


        //Exploits
        tmp_y += 48;
        Render::DrawStrokeText(Vector2(menuPos.x, tmp_y), color(0.1f, 0.f, 1.f, 1.f), xorstr(L"Exploits"), false, false, false);
        CustomTab(menuPos.x, tmp_y, xorstr(L"DayTime: "), Settings.exploitsConfigs.DayTime);
        CustomTab(menuPos.x, tmp_y, xorstr(L"FirstCamera: "), Settings.exploitsConfigs.FirstCamera);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Floating: "), Settings.exploitsConfigs.Floating);
        CustomTab(menuPos.x, tmp_y, xorstr(L"Chams: "), Settings.exploitsConfigs.Chams);
        CustomTab(menuPos.x, tmp_y, xorstr(L"HeatMapChams: "), Settings.exploitsConfigs.HeatMapChams);
        

        if (inArea(Vector2(menuPos.x - 15, menuPos.y), Vector2(menuPos.x + width, menuPos.y + height))) {
            if (GetAsyncKeyState(VK_LBUTTON)) {

                auto mousePos_tmp = mousePos;
                mousePos_tmp.x -= width; //sizex
                mousePos_tmp.y -= height; //sizey

                if (dragPos.x == 0)
                {
                    dragPos.x = (mousePos_tmp.x - menuPos.x);
                    dragPos.y = (mousePos_tmp.y - menuPos.y);
                }
                menuPos.x = mousePos_tmp.x - dragPos.x;
                menuPos.y = mousePos_tmp.y - dragPos.y;
            }
            else
                dragPos = Vector2(0, 0);
        }
        else
            dragPos = Vector2(0, 0);
    }

    
    Settings.aimConfigsPlayers.FovCircle = 1200;



	if (GetAsyncKeyState(VK_F7))
	{
		fakeunload = true;
	}
	
	return PostRender_O(_this, Canvas);
}

void VirtualTableFunctionSwap(void* VTable, void* FunctionToSwap, void** pOriginal, int Index)
{
    DWORD Old;

    void* pVTableFunction = (void*)((uint64_t)VTable + Index);
    *pOriginal = *(PVOID*)(pVTableFunction);

    VirtualProtectEx((HANDLE)-1, pVTableFunction, 8, PAGE_EXECUTE_READWRITE, &Old);
    *(PVOID*)pVTableFunction = FunctionToSwap;
    VirtualProtectEx((HANDLE)-1, pVTableFunction, 8, Old, &Old);
}


uint32_t overlay::Init()
{
	MessageBoxA(0, xorstr("Init"), 0, MB_ICONINFORMATION);

	auto LocalPlayer = ((UWorld*)(utilities::read<uintptr_t>(sdk::cached::UWorld)))->OwningGameInstance()->LocalPlayers()->LocalPlayer();
	if (!LocalPlayer) return FALSE;

	auto UViewportClient = utilities::read<uintptr_t>(uintptr_t(LocalPlayer) + 0x70);
	if (!UViewportClient) return FALSE;


    //PostRender
	void** PostRender_VTable = *(void***)(UViewportClient);
    DWORD OldProtection;
	VirtualProtect(&PostRender_VTable[107], 8, PAGE_EXECUTE_READWRITE, &OldProtection);
	PostRender_O = decltype(PostRender_O)(PostRender_VTable[107]);
	PostRender_VTable[107] = &PostRender;
	VirtualProtect(&PostRender_VTable[107], 8, OldProtection, &OldProtection);


    //GetPlayerViewPoint
    auto GetPlayerViewPoint_VFTable = *(uintptr_t*)(uintptr_t(LocalPlayer->PlayerController()));
    auto GetPlayerViewPoint_addr = *(uintptr_t*)(GetPlayerViewPoint_VFTable + 0x788);

    //GetViewPoint
    auto GetViewPoint_VFTable = *(uintptr_t*)(uintptr_t(LocalPlayer));

    
    MH_Initialize();

    //GetPlayerViewPoint
    MH_CreateHook((PVOID)GetPlayerViewPoint_addr, exploitsFunctions::hk_GetPlayerViewPoint, reinterpret_cast<PVOID*>(&exploitsFunctions::o_GetPlayerViewPoint));
    MH_EnableHook((PVOID)GetPlayerViewPoint_addr);

    //GetViewPoint
    VirtualTableFunctionSwap((void*)GetViewPoint_VFTable, exploitsFunctions::hk_GetViewPoint, (void**)&exploitsFunctions::o_GetViewPoint, 0x2B0);

    MessageBoxA(0, xorstr("Done"), 0, MB_ICONINFORMATION);




	return TRUE;
}
```

`overlay.hpp`:

```hpp
#pragma once
#include "includes.hpp"

namespace overlay
{
	uint32_t Init();
}
```

`sdk.hpp`:

```hpp
#pragma once
#include <fstream>

namespace sdk::cached
{
	inline uintptr_t Base = 0;
	inline uintptr_t UWorld = 0;
	inline uintptr_t FreeFn = 0;
	inline uintptr_t GetNameByIndex = 0;
	inline uintptr_t LineSightOfTo = 0;
	inline uintptr_t GetBoneMatrix = 0;
	inline uintptr_t ProjectWorldToScreen = 0;

	namespace objects
	{
		//Engine Render
		inline PVOID Font = 0;
		inline PVOID K2_DrawLine = 0;
		inline PVOID K2_DrawBox = 0;
		inline PVOID K2_DrawText = 0;
		inline PVOID K2_TextSize = 0;

		//Main Functions
		inline PVOID WasInputKeyJustPressed = 0;
		inline PVOID IsInputKeyDown = 0;
		inline PVOID GetMousePosition = 0;
		inline PVOID dingus = 0;
		inline PVOID GetActorBounds = 0;
		inline PVOID K2_SetActorLocation = 0;
		inline PVOID GetMuzzleLocation = 0;
		inline PVOID GetVelocity = 0;
		inline PVOID ClientSetCameraMode = 0;
		inline PVOID SetVisibility = 0;
		inline PVOID SetWeaponVisibility = 0;
		inline PVOID SetCharacterBodyVisibilityForPossession = 0;
		inline PVOID ClientSetViewTarget = 0;
		inline PVOID GetPlatform = 0;
		inline PVOID IsDead = 0;

		//Floating
		inline PVOID StartFloating = 0;
		inline PVOID EndFloating = 0;

		//SetTimeOfDay
		inline PVOID FortKismetLibrary = 0;
		inline PVOID SetTimeOfDay = 0;

		//ConvertToFName
		inline PVOID KismetStringLibrary = 0;
		inline PVOID Conv_StringToName = 0;
	}

	namespace classes
	{
		//Actors Classes
		inline PVOID FortPlayerPawnAthena = 0;
		inline PVOID FortPickup = 0;
		inline PVOID BuildingContainer = 0;
		inline PVOID FortProjectileBase = 0;

		//Not real classes in ue4
		inline PVOID Tiered_Chest = 0;
		inline PVOID Tiered_Ammo = 0;
	}
}



namespace sdk::structs
{
	struct FMatrix
	{
		float M[ 4 ][ 4 ];
	};
	static FMatrix* myMatrix = new FMatrix( );

	template<class T>
	struct TArray
	{
		friend struct FString;

	public:
		inline TArray( )
		{
			Data = nullptr;
			Count = Max = 0;
		};

		inline int Num( ) const
		{
			return Count;
		};

		inline T& operator[]( int i )
		{
			return Data[ i ];
		};

		inline const T& operator[]( int i ) const
		{
			return Data[ i ];
		};

		inline bool IsValidIndex( int i ) const
		{
			return i < Num( );
		}

	private:
		T* Data;
		int32_t Count;
		int32_t Max;
	};

	struct FString : private TArray<wchar_t>
	{
		inline FString( )
		{
		};

		FString( const wchar_t* other )
		{
			Max = Count = *other ? utilities::custom_wcslen( other ) + 1 : 0;

			if ( Count )
			{
				Data = const_cast< wchar_t* >( other );
			}
		};

		inline bool IsValid( ) const
		{
			return Data != nullptr;
		}

		inline const wchar_t* c_str( ) const
		{
			return Data;
		}
	};

	struct FName
	{
		uint32_t ComparisonIndex;
		uint32_t DisplayIndex;
	};

	struct FKey
	{
		FName KeyName;
		unsigned char Padding_00[0x10];
	};

	struct FLinearColor
	{
		float R;
		float G;
		float B;
		float A;
	};

	struct FVector2D
	{
		float X;
		float Y;
	};

	struct FVector
	{
		float X;
		float Y;
		float Z;

		inline float getDistance(const sdk::structs::FVector cmp) {
			if (cmp.X == 0 || cmp.Y == 0 || cmp.Z == 0) return 0;

			float dx = (this->X - cmp.X);
			float dy = (this->Y - cmp.Y);
			float dz = (this->Z - cmp.Z);

			int tmp = (utilities::custom_sqrtf((dx * dx) + (dy * dy) + (dz * dz)));
			return (int)(tmp / 100);
		}
	};

	struct FRotator
	{
		float Pitch;
		float Yaw;
		float Roll;
	};

	struct FMinimalViewInfo {
		sdk::structs::FVector Location;
		sdk::structs::FRotator Rotation;
		float FOV;
		float OrthoWidth;
		float OrthoNearClipPlane;
		float OrthoFarClipPlane;
		float AspectRatio;
	};

	class FText {
	private:
		char _padding_[0x28];
		PWCHAR Name;
		DWORD Length;
	public:

		inline PWCHAR c_str() {
			return Name;
		}
	};

	struct FPawnHighlight
	{
		float                                              Priority_28_E2E1B5344846E187B9C11B863A7F0698;             // 0x0000(0x0004) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
		FLinearColor                                Inner_21_4CC2801147EA190DE16F59B34F36853E;                // 0x0004(0x0010) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
		FLinearColor                                Outer_22_5A1D7D0543D303E8B54B66A7F7BD2E2E;                // 0x0014(0x0010) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
		float                                              FresnelBrightness_23_52B0F96447FF640F47DF2895B0602E92;    // 0x0024(0x0004) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
		float                                              FresnelExponent_24_B427CF0C441AA37ED49833BF7579DE6D;      // 0x0028(0x0004) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
		float                                              UsesPulse_25_E29229F64E540F0617E4C4987AD77605;            // 0x002C(0x0004) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
	};

	struct FViewTargetTransitionParams
	{
		float BlendTime;
		int BlendFunction;
		float BlendExp;
		bool bLockOutgoing;
	};

	enum EViewTargetBlendFunction
	{		
		VTBlend_Linear, // Camera does a simple linear interpolation.
		VTBlend_Cubic, // Camera has a slight ease in and ease out, but amount of ease cannot be tweaked.
		VTBlend_EaseIn, // Camera immediately accelerates, but smoothly decelerates into the target.  Ease amount controlled by BlendExp.
		VTBlend_EaseOut, // Camera smoothly accelerates, but does not decelerate into the target.  Ease amount controlled by BlendExp.
		VTBlend_EaseInOut, // Camera smoothly accelerates and decelerates.  Ease amount controlled by BlendExp.
		VTBlend_PreBlended, // The game's camera system has already performed the blending. Engine should not blend at all
		VTBlend_MAX,
	};

	class AHUD
	{
	public:
		unsigned char Padding_d24Be[0x228];
		char bLostFocusPaused : 1; // 0x228(0x1)
		char bShowHUD : 1; // 0x228(0x1)
		char bShowDebugInfo : 1; // 0x228(0x1)
		unsigned char UnknownBuffer_HaB72 : 5; // 0x228(0x1)
		unsigned char UnknownBuffer_7vY26[0x3]; // 0x229(0x3)
		int32_t CurrentTargetIndex; // 0x22c(0x4)
		char bShowHitBoxDebugInfo : 1; // 0x230(0x1)
		char bShowOverlays : 1; // 0x230(0x1)
		char bEnableDebugTextShadow : 1; // 0x230(0x1)
		unsigned char UnknownBuffer_2aNx7 : 5; // 0x230(0x1)
		unsigned char UnknownBuffer_8HAfk[0x7]; // 0x231(0x7)
		TArray<struct AActor*> PostRenderedActors; // 0x238(0x10)
		unsigned char UnknownBuffer_h7Nua[0x8]; // 0x248(0x8)
		TArray<struct FName> DebugDisplay; // 0x250(0x10)
		TArray<struct FName> ToggledDebugCategories; // 0x260(0x10)
		uintptr_t Canvas; // 0x270(0x8)
		uintptr_t DebugCanvas; // 0x278(0x8)
	};
}

namespace sdk::classes
{
	class UClass {
	public:
		BYTE _padding_0[ 0x40 ];
		UClass* SuperClass;
	};

	class UObject {
	public:
		PVOID VTableObject;
		DWORD ObjectFlags;
		DWORD InternalIndex;
		UClass* Class;
		BYTE _padding_0[ 0x8 ];
		UObject* Outer;

		inline BOOLEAN IsA( PVOID parentClass )
		{
			for ( auto super = this->Class; super; super = super->SuperClass )
				if ( super == parentClass )
					return true;

			return false;
		}
	};

	class FUObjectItem {
	public:
		UObject* Object;
		DWORD Flags;
		DWORD ClusterIndex;
		DWORD SerialNumber;
		DWORD SerialNumber2;
	};

	class TUObjectArray {
	public:
		FUObjectItem* Objects[ 9 ];
	};

	class GObjects {
	public:
		TUObjectArray* ObjectArray;
		BYTE _padding_0[ 0xC ];
		DWORD ObjectCount;
	};

	inline GObjects* objects = nullptr;
}

namespace sdk::objects
{
	inline void free_object( uintptr_t address )
	{
		if (!utilities::isValidPointer(address)) return;
		auto function = reinterpret_cast<void(__fastcall*)(__int64)>(cached::FreeFn);
		return SpoofCall(function, (__int64)address);
	}

	inline const wchar_t* get_name_by_index(int idx)
	{
		std::wstring name = xorstr(L"");

		if (!idx) return xorstr(L"");

		auto function = reinterpret_cast<structs::FString * (__fastcall*)(int* index, structs::FString * res)>(cached::GetNameByIndex);

		int index = idx;

		structs::FString fObjectName;
		SpoofCall(function, &index, &fObjectName);

		if (!fObjectName.IsValid()) return xorstr(L"");

		auto objectName = fObjectName.c_str();

		name = objectName;
		free_object((uintptr_t)fObjectName.c_str());

		return name.c_str();
	}

	inline const wchar_t* get_object_name(classes::UObject* object)
	{
		std::wstring name = xorstr(L"");

		if (!object) return xorstr(L"");

		auto function = reinterpret_cast<structs::FString * (__fastcall*)(int* index, structs::FString * res)>(cached::GetNameByIndex);

		int index = utilities::read<int>(reinterpret_cast<uint64_t>(object) + 0x18);

		structs::FString fObjectName;
		SpoofCall(function, &index, &fObjectName);

		if (!fObjectName.IsValid()) return xorstr(L"");

		auto objectName = fObjectName.c_str();

		name = objectName;
		free_object((uintptr_t)fObjectName.c_str());

		return name.c_str();
	}

	inline const wchar_t* get_full_object_name(classes::UObject* object)
	{
		std::wstring name = xorstr(L"");

		for (auto i = 0; object; object = object->Outer, i++)
		{
			if (!object) return xorstr(L"");

			auto function = reinterpret_cast<structs::FString * (__fastcall*)(int* index, structs::FString * res)>(cached::GetNameByIndex);

			int index = utilities::read<int>(reinterpret_cast<uint64_t>(object) + 0x18);

			structs::FString fObjectName;
			SpoofCall(function, &index, &fObjectName);

			if (!fObjectName.IsValid()) break;

			auto objectName = fObjectName.c_str();

			name = objectName + std::wstring(i > 0 ? xorstr(L".") : xorstr(L"")) + name;
			free_object((uintptr_t)fObjectName.c_str());
		}

		return name.c_str();
	}

	inline void NumChunks(sdk::classes::TUObjectArray* ObjectArray, int* start, int* end)
	{
		int cStart = 0, cEnd = 0;

		if (!cEnd)
		{
			while (true)
			{
				if (ObjectArray->Objects[cStart] == nullptr)
				{
					cStart++;
				}
				else
				{
					break;
				}
			}

			cEnd = cStart;
			while (true)
			{
				if (ObjectArray->Objects[cEnd] == nullptr)
				{
					break;
				}
				cEnd++;
			}
		}

		*start = cStart;
		*end = cEnd;
	}

	inline sdk::classes::UObject* GetObjByIndex(sdk::classes::TUObjectArray* ObjectArray, int32_t index)
	{
		int cStart = 0, cEnd = 0;
		int chunkIndex, chunkSize = 0xFFFF, chunkPos;
		sdk::classes::FUObjectItem* Object;

		NumChunks(ObjectArray , &cStart, &cEnd);

		chunkIndex = index / chunkSize;
		if (chunkSize * chunkIndex != 0 &&
			chunkSize * chunkIndex == index)
		{
			chunkIndex--;
		}

		chunkPos = cStart + chunkIndex;
		if (chunkPos < cEnd)
		{
			Object = ObjectArray->Objects[chunkPos] + (index - chunkSize * chunkIndex);
			if (!Object) { return nullptr; }

			return Object->Object;
		}

		return nullptr;
	}


	inline const wchar_t* fix_objectname(const wchar_t* objname)
	{
		wchar_t* _4 = (wchar_t*)objname;

		for (int i = 0; i < utilities::custom_wcslen(_4); i++)
		{
			if (_4[i] == L'_')
			{
				if (_4[i + 1] == L'0' ||
					_4[i + 1] == L'1' ||
					_4[i + 1] == L'2' ||
					_4[i + 1] == L'3' ||
					_4[i + 1] == L'4' ||
					_4[i + 1] == L'5' ||
					_4[i + 1] == L'6' ||
					_4[i + 1] == L'7' ||
					_4[i + 1] == L'8' ||
					_4[i + 1] == L'9')
					_4[i] = L'$';

				for (int idx = 1; idx < 7; idx++) {

					if (_4[i + idx] == L'.') break;

					if (_4[i + idx] == L'0' ||
						_4[i + idx] == L'1' ||
						_4[i + idx] == L'2' ||
						_4[i + idx] == L'3' ||
						_4[i + idx] == L'4' ||
						_4[i + idx] == L'5' ||
						_4[i + idx] == L'6' ||
						_4[i + idx] == L'7' ||
						_4[i + idx] == L'8' ||
						_4[i + idx] == L'9') {
						_4[i + idx] = L'$';
					}
				}

			}
		}

		std::wstring str = _4;
		str.erase(std::remove(str.begin(), str.end(), '$'), str.end());
		return str.c_str();
	}

	inline PVOID find_object(const wchar_t* objectname)
	{
		for (auto index = 0x0; index < classes::objects->ObjectCount; index++)
		{
			auto object = GetObjByIndex(classes::objects->ObjectArray, index);
			const wchar_t* tmp_name = get_full_object_name(object);
			const wchar_t* name = fix_objectname(tmp_name);

			if ((utilities::custom_wcsstr(name, objectname)))
			{
				return object;
			}				
		}

		return 0;
	}

	inline bool process_event(uintptr_t address, void* fnobject, void* parms)
	{
		if (!utilities::isValidPointer(address)) return false;
		auto index = *reinterpret_cast<void***>(address); if (!index) return false;
		auto fProcessEvent = static_cast<void(*)(void* address, void* fnobject, void* parms)>(index[0x4B]); if (!fProcessEvent) return false;
		SpoofCall(fProcessEvent, (void*)address, (void*)fnobject, (void*)parms);
		return true;
	}

	inline sdk::structs::FName Conv_StringToName(const wchar_t* String)
	{
		struct
		{
			sdk::structs::FString                                     inString;                                                 // (Parm, ZeroConstructor)
			sdk::structs::FName                                       ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		params.inString = String;

		sdk::objects::process_event((uintptr_t)sdk::cached::objects::KismetStringLibrary, sdk::cached::objects::Conv_StringToName, &params);

		return params.ReturnValue;
	}
}


// Structs

class APlayerState {
public:
	uintptr_t TeamIndex() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return utilities::read<uintptr_t>((uintptr_t)this + 0xF28);
	}

	char CompressedPing() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return utilities::read<char>((uintptr_t)this + 0x220);
	}

	sdk::structs::FString GetPlatform()
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return xorstr(L"");
		
		struct
		{
			sdk::structs::FString                                     ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm)
		} params;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::GetPlatform, &params);

		return params.ReturnValue;
	}
};


class AFortItemDefinition {
public:
	sdk::structs::FText* DisplayName() {
		if (!utilities::isValidPointer((uintptr_t)this)) return {};
		return reinterpret_cast<sdk::structs::FText*>(*(uintptr_t*)((uintptr_t)this + 0x88));
	}

	UINT8 Tier() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return utilities::read<UINT8>((uintptr_t)this + 0x6C);
	}
};

class AFortWeapon {
public:
	AFortItemDefinition* WeaponData() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (AFortItemDefinition*)(utilities::read<uintptr_t>((uintptr_t)this + 0x378));
	}

	sdk::structs::FVector GetMuzzleLocation(int PatternIndex)
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return { 0, 0, 0 };

		struct
		{
			int								PatternIndex;
			sdk::structs::FVector			ReturnValue;
		} params;

		params.PatternIndex = PatternIndex;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::GetMuzzleLocation, &params);

		return params.ReturnValue;
	}

	void SetWeaponVisibility(bool bDesiredVisibility, bool bForceUpdate)
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return;

		struct
		{
			bool                                               bDesiredVisibility;                                       // (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
			bool                                               bForceUpdate;                                             // (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
		} params;

		params.bDesiredVisibility = bDesiredVisibility;
		params.bForceUpdate = bForceUpdate;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::SetWeaponVisibility, &params);
	}
};

class ARootComponent {
public:

	sdk::structs::FVector RelativeLocation() {
		if (!utilities::isValidPointer((uintptr_t)this)) return { 0, 0, 0 };
		return utilities::read<sdk::structs::FVector>((uintptr_t)this + 0x11C);
	}

	void SetVisibility(bool bNewVisibility, bool bPropagateToChildren)
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return;

		struct
		{
			bool                                               bNewVisibility;                                           // (Parm, ZeroConstructor, IsPlainOldData)
			bool                                               bPropagateToChildren;                                     // (Parm, ZeroConstructor, IsPlainOldData)
		} params;

		params.bNewVisibility = bNewVisibility;
		params.bPropagateToChildren = bPropagateToChildren;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::SetVisibility, &params);
	}
};

class UFortItemDefinition {
public:
	sdk::structs::FText* DisplayName() {
		if (!utilities::isValidPointer(uintptr_t(this))) return 0;
		return reinterpret_cast<sdk::structs::FText*>(utilities::read<uintptr_t>((uintptr_t)this + 0x88));
	}

	BYTE Tier() {
		if (!utilities::isValidPointer(uintptr_t(this))) return false;
		return utilities::read<BYTE>((uintptr_t)this + 0x6C);
	}
};

class AFortPawn {
public:
	const wchar_t* ObjectName() {
		if (!utilities::isValidPointer((uintptr_t)this)) return xorstr(L"");
		return sdk::objects::get_object_name((sdk::classes::UObject*)this);
	}

	uintptr_t Mesh() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return utilities::read<uintptr_t>((uintptr_t)this + 0x280);
	}

	UFortItemDefinition* ItemDefinition() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (UFortItemDefinition*)(utilities::read<uintptr_t>((uintptr_t)this + (0x2A0 + 0x18)));
	}

	BOOL bAlreadySearched() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return ((utilities::read<BYTE>((uintptr_t)this + 0xdf1) >> 7) & 1); //BuildingContainer.bAlreadySearched
	}

	AFortWeapon* CurrentWeapon() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (AFortWeapon*)(utilities::read<uintptr_t>((uintptr_t)this + 0x5F8));
	}

	ARootComponent* RootComponent() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (ARootComponent*)(utilities::read<uintptr_t>((uintptr_t)this + 0x130));
	}

	APlayerState* PlayerState() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (APlayerState*)(utilities::read<uintptr_t>((uintptr_t)this + 0x238));
	}

	BOOL IsA(PVOID parentClass)
	{
		if (!utilities::isValidPointer(uintptr_t(this))) return false;

		sdk::classes::UObject* object = (sdk::classes::UObject*)this;
		for (auto super = object->Class; super; super = super->SuperClass)
			if (super == parentClass)
				return true;

		return false;
	}

	void Dingus(color InnerCol, color OuterCol)
	{
		if (!utilities::isValidPointer(uintptr_t(this))) return;
		
		struct APlayerPawn_Athena_C_ApplyPawnHighlight_Params
		{
			uintptr_t Source;                                                   // (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FPawnHighlight                              HitGlow;                                                  // (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData)
		} params;

		sdk::structs::FPawnHighlight HitGlow;

		HitGlow.FresnelBrightness_23_52B0F96447FF640F47DF2895B0602E92 = 0.f;
		HitGlow.FresnelExponent_24_B427CF0C441AA37ED49833BF7579DE6D = 0;
		HitGlow.Inner_21_4CC2801147EA190DE16F59B34F36853E = { (float)InnerCol.R, (float)InnerCol.G, (float)InnerCol.B, (float)InnerCol.A };//{ 1.f, 0.f, 0.f, 1.f };//{ (float)col.R, (float)col.G, (float)col.B, (float)col.A };
		HitGlow.Outer_22_5A1D7D0543D303E8B54B66A7F7BD2E2E = { (float)OuterCol.R, (float)OuterCol.G, (float)OuterCol.B, (float)OuterCol.A };//{ 0.f, 1.f, 0.f, 1.f };//{ (float)col.R, (float)col.G, (float)col.B, (float)col.A };
		HitGlow.Priority_28_E2E1B5344846E187B9C11B863A7F0698 = 0.f;
		HitGlow.UsesPulse_25_E29229F64E540F0617E4C4987AD77605 = 0.f;


		params.Source = uintptr_t(this);
		params.HitGlow = HitGlow;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::dingus, &params);

	}

	BOOL K2_SetActorLocation(const sdk::structs::FVector NewLocation, bool bSweep, bool bTeleport)
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;

		struct
		{
			sdk::structs::FVector			NewLocation;
			bool							bSweep;
			int								SweepHitResult;
			bool							bTeleport;
			bool							ReturnValue;
		} params;

		params.NewLocation = NewLocation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		sdk::objects::process_event((uintptr_t)this, sdk::cached::objects::K2_SetActorLocation, &params);

		return params.ReturnValue;
	}

	void GetActorBounds(bool bOnlyCollidingComponents, bool bIncludeFromChildActors, sdk::structs::FVector* Origin, sdk::structs::FVector* BoxExtent)
	{
		if (!utilities::isValidPointer(uintptr_t(this))) return;
		
		struct
		{
			bool							bOnlyCollidingComponents;
			sdk::structs::FVector			Origin;
			sdk::structs::FVector			BoxExtent;
			bool							bIncludeFromChildActors;
		} params;

		params.bOnlyCollidingComponents = bOnlyCollidingComponents;
		params.bIncludeFromChildActors = bIncludeFromChildActors;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::GetActorBounds, &params);

		if (Origin != nullptr)
			*Origin = params.Origin;
		if (BoxExtent != nullptr)
			*BoxExtent = params.BoxExtent;
	}
	
	sdk::structs::FVector GetBone(int Id)
	{
		if(!utilities::isValidPointer(uintptr_t(this))) return { 0, 0, 0 };

		auto mesh = Mesh();
		if (!mesh) return { 0, 0, 0 };

		auto function = ((sdk::structs::FMatrix * (__fastcall*)(uintptr_t, sdk::structs::FMatrix*, int))(sdk::cached::GetBoneMatrix));
		SpoofCall(function, mesh, sdk::structs::myMatrix, Id);

		return { sdk::structs::myMatrix->M[3][0], sdk::structs::myMatrix->M[3][1], sdk::structs::myMatrix->M[3][2] };
	}

	sdk::structs::FVector GetVelocity()
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return { 0, 0, 0 };

		struct
		{
			sdk::structs::FVector                                     ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		sdk::objects::process_event((uintptr_t)this, sdk::cached::objects::GetVelocity, &params);

		return params.ReturnValue;
	}

	BOOL SetCharacterBodyVisibilityForPossession(bool bVisible)
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;

		struct
		{
			bool                                               bVisible;                                                 // (Parm, ZeroConstructor, IsPlainOldData)
			bool                                               ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		params.bVisible = bVisible;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::SetCharacterBodyVisibilityForPossession, &params);

		return params.ReturnValue;
	}

	VOID StartFloating()
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return;

		struct
		{
		} params;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::StartFloating, &params);
	}

	VOID EndFloating()
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return;

		struct
		{
		} params;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::EndFloating, &params);
	}

	bool IsDead()
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return false;
		
		struct
		{
			bool                                               ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::IsDead, &params);

		return params.ReturnValue;
	}
};

class APlayerController {
public:
	AFortPawn* LocalPawn() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (AFortPawn*)(utilities::read<uintptr_t>((uintptr_t)this + 0x2A8));
	}

	BOOL IsVisible(PVOID TargetActor) {
		//if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		//if (!utilities::isValidPointer((uintptr_t)TargetActor)) return 0;

		//sdk::structs::FVector ViewPoint;
		//auto LineOfSight = reinterpret_cast<bool(__fastcall*)(PVOID PlayerController, PVOID TargetActor, sdk::structs::FVector* ViewPoint)>(sdk::cached::LineSightOfTo);
		//return SpoofCall(LineOfSight, (PVOID)this, TargetActor, &ViewPoint);
		return true;
	}

	Vector2 WorldToScreen(sdk::structs::FVector WorldLocation)
	{
		if (!utilities::isValidPointer(uintptr_t(this))) return Vector2(0, 0);

		sdk::structs::FVector2D Output;

		auto WorldToScreen = reinterpret_cast<bool(__fastcall*)(uintptr_t, sdk::structs::FVector, sdk::structs::FVector2D*, char)>(sdk::cached::ProjectWorldToScreen);
		SpoofCall(WorldToScreen, (uintptr_t)this, WorldLocation, &Output, (char)0);

		return { Output.X, Output.Y };
	}

	VOID ClientSetCameraMode(sdk::structs::FName NewCamMode)
	{
		if (!utilities::isValidPointer(uintptr_t(this))) return;

		struct
		{
			sdk::structs::FName                                       NewCamMode;                                               // (Parm, ZeroConstructor, IsPlainOldData)
		} params;

		params.NewCamMode = NewCamMode;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::ClientSetCameraMode, &params);
	}

	VOID ClientSetViewTarget(AFortPawn* Actor, sdk::structs::FViewTargetTransitionParams TransitionParams)
	{
		if (!utilities::isValidPointer(uintptr_t(this))) return;

		struct
		{
			uintptr_t A;                                                        // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FViewTargetTransitionParams                 TransitionParams;                                         // (Parm) FViewTargetTransitionParams
		} params;

		params.A = uintptr_t(Actor);
		params.TransitionParams = TransitionParams;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::ClientSetViewTarget, &params);
	}

	bool WasInputKeyJustPressed(sdk::structs::FKey Key)
	{		
		if (!utilities::isValidPointer(uintptr_t(this))) return false;

		struct
		{
			sdk::structs::FKey                                        Key;                                                      // (Parm)
			bool                                               ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		params.Key = Key;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::WasInputKeyJustPressed, &params);

		return params.ReturnValue;
		
	}

	bool IsInputKeyDown(sdk::structs::FKey Key)
	{		
		if (!utilities::isValidPointer(uintptr_t(this))) return false;
		
		struct APlayerController_IsInputKeyDown_Params
		{
			sdk::structs::FKey                                        Key;                                                      // (Parm)
			bool                                               ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		params.Key = Key;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::IsInputKeyDown, &params);

		return params.ReturnValue;
		
	}

	Vector2 GetMousePosition()
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return { 0, 0 };
		
		struct
		{
			float                                              LocationX;                                                // (Parm, OutParm, ZeroConstructor, IsPlainOldData)
			float                                              LocationY;                                                // (Parm, OutParm, ZeroConstructor, IsPlainOldData)
			bool                                               ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::GetMousePosition, &params);

		Vector2 ret;
		ret.x = params.LocationX;
		ret.y = params.LocationY;

		return ret;
	}
};

class ULocalPlayer {
public:
	APlayerController* PlayerController() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (APlayerController*)(utilities::read<uintptr_t>((uintptr_t)this + 0x30));
	}
};

class ULocalPlayers {
public:
	ULocalPlayer* LocalPlayer() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (ULocalPlayer*)(utilities::read<uintptr_t>((uintptr_t)this));
	}
};

class UGameInstance {
public:
	ULocalPlayers* LocalPlayers() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (ULocalPlayers*)(utilities::read<uintptr_t>((uintptr_t)this + 0x38));
	}
};

class AActors {
public:
	AFortPawn* GetCurrentActor(int i) {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (AFortPawn*)(utilities::read<uintptr_t>((uintptr_t)this + i * sizeof(uintptr_t)));
	}
};

class ULevel {
public:
	AActors* Actors() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (AActors*)(utilities::read<uintptr_t>((uintptr_t)this + 0x98));
	}

	INT ActorCount() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (int)(utilities::read<uintptr_t>((uintptr_t)this + 0xA0));
	}

	sdk::structs::TArray<AFortPawn*> ActorArray() {
		if (!utilities::isValidPointer((uintptr_t)this)) return {};
		return utilities::read<sdk::structs::TArray<AFortPawn*>>((uintptr_t)this + 0x98);
	}	
};

class UWorld {
public:

	UGameInstance* OwningGameInstance() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (UGameInstance*)(utilities::read<uintptr_t>((uintptr_t)this + 0x190));
	}

	ULevel* PersistentLevel() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return (ULevel*)(utilities::read<uintptr_t>((uintptr_t)this + 0x30));
	}

	sdk::structs::TArray<ULevel*> Levels() {
		if (!utilities::isValidPointer((uintptr_t)this)) return {};
		return utilities::read<sdk::structs::TArray<ULevel*>>((uintptr_t)this + 0x148);
	}

	VOID SetTimeOfDay(float TimeOfDay)
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return;
		
		struct
		{
			uintptr_t WorldContextObject;                                       // (Parm, ZeroConstructor, IsPlainOldData)
			float                                              TimeOfDay;                                                // (Parm, ZeroConstructor, IsPlainOldData)
		} params;

		params.WorldContextObject = uintptr_t(this);
		params.TimeOfDay = TimeOfDay;

		sdk::objects::process_event(uintptr_t(sdk::cached::objects::FortKismetLibrary), sdk::cached::objects::SetTimeOfDay, &params);

	}
};

class UCanvas {
public:

	int32_t SizeX() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return utilities::read<int32_t>((uintptr_t)this + 0x40);
	}

	int32_t SizeY() {
		if (!utilities::isValidPointer((uintptr_t)this)) return 0;
		return utilities::read<int32_t>((uintptr_t)this + 0x44);
	}

	void K2_DrawLine(Vector2 ScreenPositionA, Vector2 ScreenPositionB, float Thickness, color RenderColor)
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return;
		
		struct
		{
			sdk::structs::FVector2D                                   ScreenPositionA;                                          // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FVector2D                                   ScreenPositionB;                                          // (Parm, ZeroConstructor, IsPlainOldData)
			float                                              Thickness;                                                // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FLinearColor                                RenderColor;                                              // (Parm, ZeroConstructor, IsPlainOldData)
		} params;

		params.ScreenPositionA = { ScreenPositionA.x, ScreenPositionA.y };
		params.ScreenPositionB = { ScreenPositionB.x, ScreenPositionB.y };
		params.Thickness = Thickness;
		params.RenderColor = { (float)RenderColor.R, (float)RenderColor.G, (float)RenderColor.B, (float)RenderColor.A };

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::K2_DrawLine, &params);
	}

	void K2_DrawBox(Vector2 ScreenPosition, Vector2 ScreenSize, float Thickness, color RenderColor)
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return;
		
		struct
		{
			sdk::structs::FVector2D                                   ScreenPosition;                                           // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FVector2D                                   ScreenSize;                                               // (Parm, ZeroConstructor, IsPlainOldData)
			float                                              Thickness;                                                // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FLinearColor                                RenderColor;                                              // (Parm, ZeroConstructor, IsPlainOldData)
		} params;

		params.ScreenPosition = { ScreenPosition.x, ScreenPosition.y };
		params.ScreenSize = { ScreenSize.x, ScreenSize.y };
		params.Thickness = Thickness;
		params.RenderColor = { (float)RenderColor.R, (float)RenderColor.G, (float)RenderColor.B, (float)RenderColor.A };

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::K2_DrawBox, &params);
	}

	void K2_DrawText(Vector2 ScreenPosition, color RenderColor, sdk::structs::FString RenderText, bool bCentered = true, bool bOutlined = true)
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return;
		
		struct
		{
			uintptr_t RenderFont;                                               // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FString                                     RenderText;                                               // (Parm, ZeroConstructor)
			sdk::structs::FVector2D                                   ScreenPosition;                                           // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FVector2D                                   Scale;                                                    // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FLinearColor                                RenderColor;                                              // (Parm, ZeroConstructor, IsPlainOldData)
			float                                              Kerning;                                                  // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FLinearColor                                ShadowColor;                                              // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FVector2D                                   ShadowOffset;                                             // (Parm, ZeroConstructor, IsPlainOldData)
			bool                                               bCentreX;                                                 // (Parm, ZeroConstructor, IsPlainOldData)
			bool                                               bCentreY;                                                 // (Parm, ZeroConstructor, IsPlainOldData)
			bool                                               bOutlined;                                                // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FLinearColor                                OutlineColor;                                             // (Parm, ZeroConstructor, IsPlainOldData)
		} params;

		params.RenderFont = uintptr_t(sdk::cached::objects::Font);
		params.RenderText = RenderText;
		params.ScreenPosition = { ScreenPosition.x, ScreenPosition.y };
		params.Scale = { 0.6f, 0.6f };
		params.RenderColor = { (float)RenderColor.R, (float)RenderColor.G, (float)RenderColor.B, (float)RenderColor.A };
		params.Kerning = false;
		params.ShadowColor = { 0.f, 0.f, 0.f, 0.f };
		params.ShadowOffset = { ScreenPosition.x + 1, ScreenPosition.y + 1 };

		if (bCentered)
		{
			params.bCentreX = true;
			params.bCentreY = true;
		}
		else
		{
			params.bCentreX = false;
			params.bCentreY = false;
		}

		params.bOutlined = bOutlined;
		params.OutlineColor = { 0.0f, 0.0f, 0.0f, 1.f };

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::K2_DrawText, &params);
	}

	Vector2 K2_TextSize(sdk::structs::FString RenderText)
	{
		if (!utilities::isValidPointer((uintptr_t)this)) return { 0, 0 };
		
		struct
		{
			uintptr_t RenderFont;                                               // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FString                                     RenderText;                                               // (Parm, ZeroConstructor)
			sdk::structs::FVector2D                                   Scale;                                                    // (Parm, ZeroConstructor, IsPlainOldData)
			sdk::structs::FVector2D                                   ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		params.RenderFont = uintptr_t(sdk::cached::objects::Font);
		params.RenderText = RenderText;
		params.Scale = { 0.6f, 0.6f };

		sdk::objects::process_event(uintptr_t(this), sdk::cached::objects::K2_TextSize, &params);

		return { params.ReturnValue.X, params.ReturnValue.Y };
	}
};

namespace sdk::cached
{
	inline UCanvas* Canvas = 0;
	inline APlayerController* PlayerController;

	namespace keys
	{
		inline sdk::structs::FKey LButton;
		inline sdk::structs::FKey Insert;
	}
}
```

`spoofcall.asm`:

```asm
PUBLIC _spoofer_stub
 
.code
 
_spoofer_stub PROC
    pop r11
    add rsp, 8
    mov rax, [rsp + 24]
    
    mov r10, [rax]
    mov [rsp], r10
    
    mov r10, [rax + 8] 
    mov [rax + 8], r11 
 
    mov [rax + 16], rsi
    lea rsi, fixup
    mov [rax], rsi
    mov rsi, rax
    
    jmp r10
 
fixup:
    sub rsp, 16
    mov rcx, rsi
    mov rsi, [rcx + 16]
    jmp QWORD PTR [rcx + 8]
_spoofer_stub ENDP
 
END 
```

`spoofcall.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <iostream>
#include <algorithm>

namespace detail
{
	extern "C" void* _spoofer_stub();

	template <typename Ret, typename... Args>
	static inline auto shellcode_stub_helper(
		const void* shell,
		Args... args
	) -> Ret
	{
		auto fn = (Ret(*)(Args...))(shell);
		return fn(args...);
	}

	template <std::size_t Argc, typename>
	struct argument_remapper
	{
		template<
			typename Ret,
			typename First,
			typename Second,
			typename Third,
			typename Fourth,
			typename... Pack
		>
			static auto do_call(const void* shell, void* shell_param, First first, Second second,
				Third third, Fourth fourth, Pack... pack) -> Ret
		{
			return shellcode_stub_helper< Ret, First, Second, Third, Fourth, void*, void*, Pack... >(shell, first, second, third, fourth, shell_param, nullptr, pack...);
		}
	};

	template <std::size_t Argc>
	struct argument_remapper<Argc, std::enable_if_t<Argc <= 4>>
	{
		template<
			typename Ret,
			typename First = void*,
			typename Second = void*,
			typename Third = void*,
			typename Fourth = void*
		>
			static auto do_call(
				const void* shell,
				void* shell_param,
				First first = First{},
				Second second = Second{},
				Third third = Third{},
				Fourth fourth = Fourth{}
			) -> Ret
		{
			return shellcode_stub_helper<
				Ret,
				First,
				Second,
				Third,
				Fourth,
				void*,
				void*
			>(
				shell,
				first,
				second,
				third,
				fourth,
				shell_param,
				nullptr
				);
		}
	};
}

template <typename Ret, typename... Args>
static inline auto SpoofCall(Ret(*fn)(Args...), Args... args) -> Ret
{
	static const void* jmprbx = nullptr;
	if (!jmprbx) {
		const auto ntdll = reinterpret_cast<const unsigned char*>(*(uintptr_t*)(__readgsqword(0x60) + 0x10)); //base
		const auto dos = reinterpret_cast<const IMAGE_DOS_HEADER*>(ntdll);
		const auto nt = reinterpret_cast<const IMAGE_NT_HEADERS*>(ntdll + dos->e_lfanew);
		const auto sections = IMAGE_FIRST_SECTION(nt);
		const auto num_sections = nt->FileHeader.NumberOfSections;

		constexpr char section_name[5]{ '.', 't', 'e', 'x', 't' };
		const auto     section = std::find_if(sections, sections + num_sections, [&](const auto& s) {
			return std::equal(s.Name, s.Name + 5, section_name);
			});

		constexpr unsigned char instr_bytes[2]{ 0xFF, 0x26 };
		const auto              va = ntdll + section->VirtualAddress;
		jmprbx = std::search(va, va + section->Misc.VirtualSize, instr_bytes, instr_bytes + 2);
	}

	struct shell_params
	{
		const void* trampoline;
		void* function;
		void* rdx;
	};

	shell_params p
	{
		jmprbx,
		reinterpret_cast<void*>(fn)
	};

	using mapper = detail::argument_remapper<sizeof...(Args), void>;
	return mapper::template do_call<Ret, Args...>((const void*)&detail::_spoofer_stub, &p, args...);
}
```

`utilities.hpp`:

```hpp
#pragma once

static float width;
static float height;

class color
{
public:
	float R, G, B, A;

	color()
	{
		R = G = B = A = 0;
	}

	color(float R, float G, float B, float A)
	{
		this->R = R;
		this->G = G;
		this->B = B;
		this->A = A;
	}
};



static bool fakeunload = false;



#define RELATIVE(addr, size) ((uintptr_t)((UINT_PTR)(addr) + *(PINT)((UINT_PTR)(addr) + ((size) - sizeof(INT))) + (size)))

namespace utilities
{
	inline BOOL IsInScreen(Vector2 Pos) {
		if (((Pos.x <= 0 or Pos.x > width) and (Pos.y <= 0 or Pos.y > height)) or ((Pos.x <= 0 or Pos.x > width) or (Pos.y <= 0 or Pos.y > height))) {
			return FALSE;
		}
		else {
			return TRUE;
		}
	}

	inline color getColorFromTier(BYTE Tier) {
		color color = { 1.f, 1.f, 0.9f, 1.f };

		if (Tier == 1)
			color = { 1.f, 1.f, 0.9f, 1.f };
		else if (Tier == 2)
			color = { 0.0f, 0.95f, 0.0f, 1.f };
		else if (Tier == 3)
			color = { 0.4f, 0.65f, 1.0f, 1.f };
		else if (Tier == 4)
			color = { 0.7f, 0.25f, 0.85f, 1.f };
		else if (Tier == 5)
			color = { 0.85f, 0.65f, 0.0f, 1.f };

		return color;
	}

	inline uintptr_t imageBase()
	{
		return *(uintptr_t*)(__readgsqword(0x60) + 0x10);
	}

	inline bool isValidPointer(uintptr_t address)
	{
		if (!SpoofCall(IsBadWritePtr, (LPVOID)address, (UINT_PTR)8))
			return true;
		else
			return false;
	}

	template <typename R>
	inline R read(uintptr_t address)
	{
		R buffer{};

		if (!isValidPointer(address))
			return buffer;

		buffer = *(R*)address;

		return buffer;
	}

	template <typename W>
	inline void write(uintptr_t address, const W& value)
	{
		W buffer{};

		if (!isValidPointer(address))
			return;

		*(W*)address = value;
	}


	inline float custom_sqrtf(float _X)
	{
		return _mm_cvtss_f32(_mm_sqrt_ss(_mm_set_ss(_X)));
	}

	inline float custom_sinf(float _X)
	{
		return _mm_cvtss_f32(_mm_sin_ps(_mm_set_ss(_X)));
	}

	inline float custom_cosf(float _X)
	{
		return _mm_cvtss_f32(_mm_cos_ps(_mm_set_ss(_X)));
	}

	inline float custom_acosf(float _X)
	{
		return _mm_cvtss_f32(_mm_acos_ps(_mm_set_ss(_X)));
	}

	inline float custom_tanf(float _X)
	{
		return _mm_cvtss_f32(_mm_tan_ps(_mm_set_ss(_X)));
	}

	inline float custom_atan2f(float _X, float _Y)
	{
		return _mm_cvtss_f32(_mm_atan2_ps(_mm_set_ss(_X), _mm_set_ss(_Y)));
	}

	inline int custom_compare(const char* X, const char* Y)
	{
		while (*X && *Y) {
			if (*X != *Y) {
				return 0;
			}
			X++;
			Y++;
		}

		return (*Y == '\0');
	}

	inline int custom_wcompare(const wchar_t* X, const wchar_t* Y)
	{
		while (*X && *Y) {
			if (*X != *Y) {
				return 0;
			}
			X++;
			Y++;
		}

		return (*Y == L'\0');
	}
	
	inline const wchar_t* custom_wcsstr(const wchar_t* X, const wchar_t* Y)
	{
		while (*X != L'\0') {
			if ((*X == *Y) && custom_wcompare(X, Y)) {
				return X;
			}
			X++;
		}
		return NULL;
	}

	inline const char* custom_strstr(const char* X, const char* Y)
	{
		while (*X != '\0') {
			if ((*X == *Y) && custom_compare(X, Y)) {
				return X;
			}
			X++;
		}
		return NULL;
	}

	inline int custom_strlen(const char* string)
	{
		int cnt = 0;
		if (string)
		{
			for (; *string != 0; ++string) ++cnt;
		}
		return cnt;
	}

	inline int custom_wcslen(const wchar_t* string)
	{
		int cnt = 0;
		if (string)
		{
			for (; *string != 0; ++string) ++cnt;
		}
		return cnt;
	}

	inline uintptr_t scan(uintptr_t pModuleBaseAddress, const char* sSignature)
	{
		static auto patternToByte = [](const char* pattern)
		{
			auto       bytes = std::vector<int>{};
			const auto start = const_cast<char*>(pattern);
			const auto end = const_cast<char*>(pattern) + custom_strlen(pattern);

			for (auto current = start; current < end; ++current)
			{
				if (*current == '?')
				{
					++current;
					if (*current == '?')
						++current;
					bytes.push_back(-1);
				}
				else
					bytes.push_back(SpoofCall(strtoul, (const char*)current, &current, 16));
			}
			return bytes;
		};

		const auto dosHeader = (PIMAGE_DOS_HEADER)pModuleBaseAddress;
		const auto ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)pModuleBaseAddress + dosHeader->e_lfanew);

		const auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;
		auto       patternBytes = patternToByte(sSignature);
		const auto scanBytes = reinterpret_cast<std::uint8_t*>(pModuleBaseAddress);

		const auto s = patternBytes.size();
		const auto d = patternBytes.data();

		for (auto i = 0ul; i < sizeOfImage - s; ++i)
		{
			bool found = true;

			for (auto j = 0ul; j < s; ++j)
			{
				if (scanBytes[i + j] != d[j] && d[j] != -1)
				{
					found = false;
					break;
				}
			}

			if (found)
			{
				return reinterpret_cast<uintptr_t>(&scanBytes[i]);
			}
		}

		return NULL;
	}
}

//Settings
struct {

	struct aimPlayers {

		bool Memory;
		bool Silent;
		int FovCircle;
		bool BulletTP;
		bool SniperPrediction;

	} aimConfigsPlayers;

	struct exploits {

		bool DayTime;
		float DayTime_value;
		bool FirstCamera;
		bool Floating;
		bool Chams;
		bool HeatMapChams;

	} exploitsConfigs;

	struct visualsPlayers {

		bool ESP;
		bool Box2D;
		bool Box3D;
		bool Skeleton;
		bool Lines;
		bool Names;
		bool Weapon;
		bool Distance;
		bool Platform;
		bool TargetLine;

	} visualsConfigsPlayers;

	struct visualsWorld {

		bool ESP;
		bool Loot;
		bool Chest;
		bool AmmoBox;

	} visualsConfigsWorld;

} Settings;
```

`vectors.h`:

```h
#pragma once

//Vector2
class Vector2
{
public:
	float x, y;
	Vector2()
	{
		x = y = 0.f;
	}

	Vector2(float _x, float _y)
	{
		x = _x;
		y = _y;
	}
};

//Vector3
class Vector3
{
public:
	float x, y, z;
	Vector3()
	{
		x = y = z = 0.f;
	}

	Vector3(float _x, float _y, float _z)
	{
		x = _x;
		y = _y;
		z = _z;
	}

	Vector3 operator+(const Vector3& v) {
		return Vector3{ x + v.x, y + v.y, z + v.z };
	}

	Vector3 operator-(const Vector3& v) {
		return Vector3{ x - v.x, y - v.y, z - v.z };
	}

	Vector3 operator*(const float v) {
		return Vector3{ x * v, y * v, z * v };
	}

	Vector3 operator/(const float fl) const {
		return Vector3(x / fl, y / fl, z / fl);
	}
};

//Vector4
class Vector4
{
public:
	float x, y, z, w;
	Vector4()
	{
		x = y = z = w = 0.f;
	}

	Vector4(float _x, float _y, float _z, float _w)
	{
		x = _x;
		y = _y;
		z = _z;
		w = _w;
	}
};
```

`xorstr.hpp`:

```hpp
/*
 * Copyright 2017 - 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>

#define JM_XORSTR_DISABLE_AVX_INTRINSICS

#define xorstr_(str)                                             \
    ::jm::make_xorstr(                                           \
        []() { return str; },                                    \
        std::make_index_sequence<sizeof(str) / sizeof(*str)>{},  \
        std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define xorstr(str) xorstr_(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline))
#endif

 // you can define this macro to get possibly faster code on gcc/clang
 // at the expense of constants being put into data section.
#if !defined(XORSTR_ALLOW_DATA)
// MSVC - no volatile
// GCC and clang - volatile everywhere
#if defined(__clang__) || defined(__GNUC__)
#define XORSTR_VOLATILE volatile
#endif

#endif
#ifndef XORSTR_VOLATILE
#define XORSTR_VOLATILE
#endif

namespace jm {

    namespace detail {

        template<std::size_t S>
        struct unsigned_;

        template<>
        struct unsigned_<1> {
            using type = std::uint8_t;
        };
        template<>
        struct unsigned_<2> {
            using type = std::uint16_t;
        };
        template<>
        struct unsigned_<4> {
            using type = std::uint32_t;
        };

        template<auto C, auto...>
        struct pack_value_type {
            using type = decltype(C);
        };

        template<std::size_t Size>
        constexpr std::size_t _buffer_size() {
            return ((Size / 16) + (Size % 16 != 0)) * 2;
        }

        template<auto... Cs>
        struct tstring_ {
            using value_type = typename pack_value_type<Cs...>::type;
            constexpr static std::size_t size = sizeof...(Cs);
            constexpr static value_type  str[size] = { Cs... };

            constexpr static std::size_t buffer_size = _buffer_size<sizeof(str)>();
            constexpr static std::size_t buffer_align =
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((sizeof(str) > 16) ? 32 : 16);
#else
                16;
#endif
        };

        template<std::size_t I, std::uint64_t K>
        struct _ki {
            constexpr static std::size_t   idx = I;
            constexpr static std::uint64_t key = K;
        };

        template<std::uint32_t Seed>
        constexpr std::uint32_t key4() noexcept {
            std::uint32_t value = Seed;
            for (char c : __TIME__)
                value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
            return value;
        }

        template<std::size_t S>
        constexpr std::uint64_t key8() {
            constexpr auto first_part = key4<2166136261 + S>();
            constexpr auto second_part = key4<first_part>();
            return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
        }

        // clang and gcc try really hard to place the constants in data
        // sections. to counter that there was a need to create an intermediate
        // constexpr string and then copy it into a non constexpr container with
        // volatile storage so that the constants would be placed directly into
        // code.
        template<class T, std::uint64_t... Keys>
        struct string_storage {
            std::uint64_t storage[T::buffer_size];

            XORSTR_FORCEINLINE constexpr string_storage() noexcept : storage{ Keys... } {
                using cast_type =
                    typename unsigned_<sizeof(typename T::value_type)>::type;
                constexpr auto value_size = sizeof(typename T::value_type);
                // puts the string into 64 bit integer blocks in a constexpr
                // fashion
                for (std::size_t i = 0; i < T::size; ++i)
                    storage[i / (8 / value_size)] ^=
                    (std::uint64_t{ static_cast<cast_type>(T::str[i]) }
                << ((i % (8 / value_size)) * 8 * value_size));
            }
        };

    } // namespace detail

    template<class T, class... Keys>
    class xor_string {
        alignas(T::buffer_align) std::uint64_t _storage[T::buffer_size];

        // _single functions needed because MSVC crashes without them
        XORSTR_FORCEINLINE void _crypt_256_single(const std::uint64_t* keys,
            std::uint64_t* storage) noexcept

        {
            _mm256_store_si256(
                reinterpret_cast<__m256i*>(storage),
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(storage)),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_256(const std::uint64_t* keys,
            std::index_sequence<Idxs...>) noexcept {
            (_crypt_256_single(keys + Idxs * 4, _storage + Idxs * 4), ...);
        }

        XORSTR_FORCEINLINE void _crypt_128_single(const std::uint64_t* keys,
            std::uint64_t* storage) noexcept {
            _mm_store_si128(
                reinterpret_cast<__m128i*>(storage),
                _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(storage)),
                    _mm_load_si128(reinterpret_cast<const __m128i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_128(const std::uint64_t* keys,
            std::index_sequence<Idxs...>) noexcept {
            (_crypt_128_single(keys + Idxs * 2, _storage + Idxs * 2), ...);
        }

        // loop generates vectorized code which places constants in data dir
        XORSTR_FORCEINLINE constexpr void _copy() noexcept {
            constexpr detail::string_storage<T, Keys::key...> storage;
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(_storage))[Keys::idx] =
                    storage.storage[Keys::idx]... });
        }

    public:
        using value_type = typename T::value_type;
        using size_type = std::size_t;
        using pointer = value_type*;
        using const_pointer = const pointer;

        XORSTR_FORCEINLINE xor_string() noexcept { _copy(); }

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept {
            return T::size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept {
            alignas(T::buffer_align) std::uint64_t keys[T::buffer_size];
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(keys))[Keys::idx] =
                    Keys::key... });

            _copy();

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            _crypt_256(keys, std::make_index_sequence<T::buffer_size / 4>{});
            if constexpr (T::buffer_size % 4 != 0)
                _crypt_128(keys, std::index_sequence<T::buffer_size / 2 - 1>{});
#else
            _crypt_128(keys, std::make_index_sequence<T::buffer_size / 2>{});
#endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept {
            return reinterpret_cast<const_pointer>(_storage);
        }

        XORSTR_FORCEINLINE const_pointer crypt_get() noexcept {
            crypt();
            return reinterpret_cast<const_pointer>(_storage);
        }
    };

    template<class Tstr, std::size_t... StringIndices, std::size_t... KeyIndices>
    XORSTR_FORCEINLINE constexpr auto
        make_xorstr(Tstr str_lambda,
            std::index_sequence<StringIndices...>,
            std::index_sequence<KeyIndices...>) noexcept {
        return xor_string<detail::tstring_<str_lambda()[StringIndices]...>,
            detail::_ki<KeyIndices, detail::key8<KeyIndices>()>...>{};
    }

} // namespace jm

#endif // include guard
```