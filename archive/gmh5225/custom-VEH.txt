Project Path: arc_gmh5225_custom-VEH_e9k9le2d

Source Tree:

```txt
arc_gmh5225_custom-VEH_e9k9le2d
├── README.md
├── custom veh
│   ├── custom veh.vcxproj
│   ├── custom veh.vcxproj.filters
│   ├── custom_veh
│   │   ├── custom_veh.cpp
│   │   ├── custom_veh.hpp
│   │   └── ud.hpp
│   ├── includes
│   │   ├── MinHook.h
│   │   └── lib
│   │       ├── libMinHook.x64.lib
│   │       └── libMinHook.x86.lib
│   └── main.cpp
└── custom veh.sln

```

`README.md`:

```md
# custom-VEH
custom vectored exception handlers for x86 and x64.

I'm sure this has been done before, and is likely well documented.


I didn't bother checking because my entire goal in this project was to see how easy it would be to pull this off.


I had fun doing this and it only took about an hour, so I'm sure there's likely to be issues with either my documentation or code, let me know in the issues if you see any.

# What is this?
This is a library allowing you to create custom vectored exception handlers that're faster than normal ones, and run before any vanilla handlers do.

These handlers are stored in a deque container as function pointers, outside of `LdrpVectorHandlerList`, being easier to manage and smaller while also being hard to manipulate outside of your process or dll.

# Usage
## Defining a handler
* You may define a custom exception handler with this format,
* from that point on the code of the handler works exactly like a normal one
```cpp
std::uint32_t custom_handler(PEXCEPTION_POINTERS info)
{
	std::cout << "I'm ran first!\n";

	return EXCEPTION_CONTINUE_SEARCH;
}
```

## Initializing the custom handler
```cpp
custom_veh::start_custom_handler();                   // call this exactly once in your program
custom_veh::add_vectored_handler(&custom_handler);    // call this to add a handler

custom_veh::remove_vectored_handler(&custom_handler);  // call this to remove a custom handler from execution
```

# How it works
this code hooks the function `RtlpCallVectoredHandlers` defined in ntdll.dll to call the user defined handlers
before the original VEHs are ran. Allowing it to run custom handlers not located in `LdrpVectorHandlerList` so vanilla handlers cannot be ran before custom ones.

# Reverse engineering and updating for future versions
Now the method behind actually retrieving `RtlpCallVectoredHandlers` is not very adaptable for future or older versions of ntdll with updates to `KiUserExceptionDispatcher` or `RtlDispatchException`.

The examples I'm going to show are performed on System32's ntdll, which is different from SYSWOW64's ntdll.
The System32 dll is meant for x64 programs, while SYSWOW64's dll is specific to x86 programs, however the process is the same for both.

Firstly, I went to `RtlAddVectoredExceptionHandler` to see how it worked, and saw that it was just a wrapper around `RtlpAddVectoredHandler`
![RtlAddVectoredExceptionHandler](https://i.imgur.com/afWGb3u.png)

## RtlpAddVectoredHandler
Then, going into `RtlpAddVectoredHandler`, I looked for where it referenced a handler list, which I'd quickly found.
![Vectored handler list](https://i.imgur.com/KWZ0SHq.png)

Next, I went to cross reference it to see where it was used and possibly find where the handlers are called.

And I easily found it in the xrefs.
![Vectored handler list xrefs](https://i.imgur.com/ODst0rQ.png)

Now in `RtlpCallVectoredHandlers` the first thing I wanted to identify were the arguments.

By referencing a1 and a2, I found out that they were just `ExceptionRecord` and `ExceptionContext` because they were being moved into what was obviously an `EXCEPTION_POINTERS` struct.

![ExceptionPointers struct](https://i.imgur.com/fA1qie8.png)

As for a3, I discovered that it was just a base index, which started at 1 on first calls for VectoredContinueHandlers, but starts at 0 for VectoredExceptionHandlers, so I named it `base_idx`.

And for handler calls, I saw that it was decoding a pointer to retrieve the handler pointer, then calling it with our ExceptionPointers.
![Handler calls](https://i.imgur.com/xtci1vk.png)

Finally, the result of the handler is compared with -1 (EXCEPTION_CONTINUE_EXECUTION), if true it removes the list entry and stops executing all other handlers and returns true, otherwise continues search. 
![Handler result](https://i.imgur.com/qXWLG8F.png)

## RtlDispatchException
After reversing `RtlpCallVectoredHandlers` I cross referenced to see how information is passed, and how I can retrieve it.

The only reference to it was `RtlDispatchException`.

I ignored a large part of this function since a big chunk had nothing to do with the information I needed,

but I did reverse the barebones to it.

Firstly, it's first 2 arguments are `ExceptionRecord` and `ExceptionContext` as they're passed to `RtlpCallVectoredHandlers`.

It calls `RtlpCallVectoredHandlers` passing 0 for the base, calling Exception handlers, if it returns false it prepares info for exception.

If the call returns true it runs through Continue handlers then returns true.

![Handler call](https://i.imgur.com/WJaMP65.png)

![continue_execution label](https://i.imgur.com/o3t4kLI.png)

##  KiUserExceptionDispatcher
This was the last function I referenced back to, and it was imported.

It prepares exception info passing `ExceptionRecord` into `rcx`, and `ExceptionContext` into `rdx`.
![Exception info preperation](https://i.imgur.com/f04dxG8.png)

Next, it calls `RtlDispatchException` and checks the result, if the result is true it calls `RtlGuardRestoreContext` (on x86 `ZwContinue`), which continues execution using information from `ExceptionContext`.
![Context restoration](https://i.imgur.com/SjUXW4e.png)

If the result evaluates to false (meaning no handlers continued execution) it calls `ZwRaiseException`, which will pass ExceptionCode and terminate the UM process.
![ZwRaiseException](https://i.imgur.com/coBk7D2.png)

## Updating
Self explanatory, go to `KiUserExceptionDispatcher`, subtract the `RtlDispatchException` call address from the start address, and update the offset.
Then go inside of `RtlDispatchException` and subtract the first `RtlpCallVectoredHandlers` call address from the start address, and update the offset.

```

`custom veh.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32319.34
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "custom veh", "custom veh\custom veh.vcxproj", "{C354C9D1-4B29-4ACE-B70C-4D5751F0FBC4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C354C9D1-4B29-4ACE-B70C-4D5751F0FBC4}.Debug|x64.ActiveCfg = Debug|x64
		{C354C9D1-4B29-4ACE-B70C-4D5751F0FBC4}.Debug|x64.Build.0 = Debug|x64
		{C354C9D1-4B29-4ACE-B70C-4D5751F0FBC4}.Debug|x86.ActiveCfg = Debug|Win32
		{C354C9D1-4B29-4ACE-B70C-4D5751F0FBC4}.Debug|x86.Build.0 = Debug|Win32
		{C354C9D1-4B29-4ACE-B70C-4D5751F0FBC4}.Release|x64.ActiveCfg = Release|x64
		{C354C9D1-4B29-4ACE-B70C-4D5751F0FBC4}.Release|x64.Build.0 = Release|x64
		{C354C9D1-4B29-4ACE-B70C-4D5751F0FBC4}.Release|x86.ActiveCfg = Release|Win32
		{C354C9D1-4B29-4ACE-B70C-4D5751F0FBC4}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1247F693-E2F3-494C-8EA5-7B68502A92CC}
	EndGlobalSection
EndGlobal

```

`custom veh/custom veh.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c354c9d1-4b29-4ace-b70c-4d5751f0fbc4}</ProjectGuid>
    <RootNamespace>customveh</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(ProjectDir)/includes;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)/includes/lib;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)/includes;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)/includes/lib;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(ProjectDir)/includes;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)/includes/lib;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)/includes;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)/includes/lib;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="custom_veh\custom_veh.hpp" />
    <ClInclude Include="custom_veh\ud.hpp" />
    <ClInclude Include="includes\MinHook.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="custom_veh\custom_veh.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="includes\lib\libMinHook.x64.lib" />
    <Library Include="includes\lib\libMinHook.x86.lib" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`custom veh/custom veh.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="custom_veh\custom_veh.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="custom_veh\ud.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="includes\MinHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="custom_veh\custom_veh.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Library Include="includes\lib\libMinHook.x86.lib" />
    <Library Include="includes\lib\libMinHook.x64.lib" />
  </ItemGroup>
</Project>
```

`custom veh/custom_veh/custom_veh.cpp`:

```cpp
#include "custom_veh.hpp"
#include "ud.hpp"

#include <MinHook.h>
#include <stdexcept>

#define VEH_SHOULD_THROW true

#if VEH_SHOULD_THROW
#define VEH_EXCEPT( msg ) throw std::runtime_error( msg )
#else
#define VEH_EXCEPT( msg ) return false
#endif

bool custom_veh::add_vectored_handler( vectored_handler_t handler, bool first )
{
	if ( std::find( g_vectored_handlers.begin( ), g_vectored_handlers.end( ), handler ) == g_vectored_handlers.end( ) )
		return ( first ? g_vectored_handlers.push_front( handler ) : g_vectored_handlers.push_back( handler ) ), true;

	VEH_EXCEPT( ud_xorstr_c( "handler already present" ) );
}

bool custom_veh::remove_vectored_handler( vectored_handler_t handler )
{
	const auto it = std::find( g_vectored_handlers.begin( ), g_vectored_handlers.end( ), handler );
	
	if ( it != g_vectored_handlers.end( ) )
		return g_vectored_handlers.erase( it ), true;
	
	VEH_EXCEPT( ud_xorstr_c( "handler not present" ) );
}

#pragma optimize( "", off )
static bool( __fastcall* call_trampoline )( EXCEPTION_RECORD*, CONTEXT* );
static bool __fastcall call_vectored_handlers( EXCEPTION_RECORD* record, CONTEXT* ctx )
{
	for ( auto callback : custom_veh::g_vectored_handlers )
	{
		EXCEPTION_POINTERS info{ record, ctx };
		const auto status = callback( &info );
			
		if ( status != EXCEPTION_CONTINUE_SEARCH )
			return status == EXCEPTION_CONTINUE_EXECUTION;
	}

	return call_trampoline( record, ctx );
}

bool custom_veh::start_veh( )
{
	const ud::module_t ntdll{ ud_xorstr( "ntdll.dll" ) };
	
#if defined( _M_IX86 )
	const auto rtl_call_handlers = reinterpret_cast< void* >( *ntdll.find_pattern( ud_xorstr( "FC FE FF FF 8B FF 55 8B EC" ) ) + 4 );
#else
	const auto rtl_call_handlers = *ntdll.find_pattern< void* >( ud_xorstr( "40 55 56 57 41 54 41 55 41 56 41 57 48 81 EC D0" ) );
#endif

	if ( !rtl_call_handlers )
		VEH_EXCEPT( ud_xorstr_c( "rtl_call_handlers not found" ) );

	if ( MH_Initialize( ) )
		VEH_EXCEPT( ud_xorstr_c( "MH_Initialize failed" ) );

	if ( MH_CreateHook( rtl_call_handlers, &call_vectored_handlers, reinterpret_cast< void** >( &call_trampoline ) ) )
		VEH_EXCEPT( ud_xorstr_c( "MH_CreateHook failed" ) );

	if ( MH_EnableHook( rtl_call_handlers ) )
		VEH_EXCEPT( ud_xorstr_c( "MH_EnableHook failed" ) );

	return true;
}

#pragma optimize( "", on )

```

`custom veh/custom_veh/custom_veh.hpp`:

```hpp
#pragma once
#include <deque>
#include <cstdint>

#include <Windows.h>

namespace custom_veh
{
	using vectored_handler_t = std::uint32_t( * )( EXCEPTION_POINTERS* );
	
	static std::deque< vectored_handler_t > g_vectored_handlers;
	
	bool add_vectored_handler( vectored_handler_t handler, bool first = true );
	bool remove_vectored_handler( vectored_handler_t handler );

	bool start_veh( );
}
```

`custom veh/custom_veh/ud.hpp`:

```hpp
#pragma once
#include <optional>
#include <string>
#include <vector>
#include <array>
#include <algorithm>
#include <string_view>
#include <fstream>

#include <Windows.h>
#include <winternl.h>

#if defined(_MSC_VER)
#define UD_FORCEINLINE __forceinline
#pragma warning( push )
#pragma warning( disable : 4244 4083 )
#else
#define UD_FORCEINLINE __attribute__( ( always_inline ) )
#endif

#define ud_encode_c( str ) ud::rot::decode( ud::rot::rot_t<str>{ } ).data
#define ud_encode( str ) std::string_view{ ud_encode_c( str ) }

#define ud_xorstr_c( str ) ud::xorstr::decrypt( ud::xorstr::xorstr_t< str, __COUNTER__ + 1 ^ 0x90 >{ } ).data
#define ud_xorstr( str ) std::string_view{ ud_xorstr_c( str ) }

#define ud_stack_str( str ) ud::details::comp_string_t{ str }.data

// settings defined below, preprocessed due to compiler errors present even with "if constexpr"
#define UD_USE_SEH false

namespace ud
{
	namespace details
	{
		struct PEB_LDR_DATA
		{
			unsigned long dummy_0;
			unsigned long dummy_1;
			const char* dummy_2;
			LIST_ENTRY* in_load_order_module_list;
		};

		struct LDR_DATA_TABLE_ENTRY32
		{
			LIST_ENTRY InLoadOrderLinks;

			std::uint8_t pad[ 16 ];
			std::uintptr_t dll_base;
			std::uintptr_t entry_point;
			std::size_t size_of_image;

			UNICODE_STRING full_name;
			UNICODE_STRING base_name;
		};

		struct LDR_DATA_TABLE_ENTRY64
		{
			LIST_ENTRY InLoadOrderLinks;
			LIST_ENTRY dummy_0;
			LIST_ENTRY dummy_1;

			std::uintptr_t dll_base;
			std::uintptr_t entry_point;
			union {
				unsigned long size_of_image;
				const char* _dummy;
			};

			UNICODE_STRING full_name;
			UNICODE_STRING base_name;
		};

#ifdef _M_X64
		using LDR_DATA_TABLE_ENTRY = LDR_DATA_TABLE_ENTRY64;
#else
		using LDR_DATA_TABLE_ENTRY = LDR_DATA_TABLE_ENTRY32;
#endif

		template < std::size_t sz >
		struct comp_string_t
		{
			std::size_t size = sz;
			char data[ sz ]{ };

			comp_string_t( ) = default;
			consteval comp_string_t( const char( &str )[ sz ] )
			{
				std::copy_n( str, sz, data );
			}
		};

		inline constexpr std::uint64_t multiplier = 0x5bd1e995;
		inline consteval std::uint64_t get_seed( )
		{
			constexpr auto time_str = __TIME__;
			constexpr auto time_len = sizeof( __TIME__ ) - 1;

			constexpr auto time_int = [ ] ( const char* const str, const std::size_t len )
			{
				auto res = 0ull;
				for ( auto i = 0u; i < len; ++i )
					if ( str[ i ] >= '0' && str[ i ] <= '9' )
						res = res * 10 + str[ i ] - '0';

				return res;
			}( time_str, time_len );

			return time_int;
		}

		template < auto v >
		struct constant_t
		{
			enum : decltype( v )
			{
				value = v
			};
		};

		template < auto v >
		inline constexpr auto constant_v = constant_t< v >::value;

#undef max
#undef min

		template < std::uint32_t seq >
		consteval std::uint64_t recursive_random( )
		{
			constexpr auto seed = get_seed( );
			constexpr auto mask = std::numeric_limits< std::uint64_t >::max( );

			constexpr auto x = ( ( seq * multiplier ) + seed ) & mask;
			constexpr auto x_prime = ( x >> 0x10 ) | ( x << 0x10 );

			return constant_v< x_prime >;
		}
	}

	inline std::optional< std::string > get_dialogue_path( const std::string_view type = "", const HWND wnd = nullptr )
	{
		OPENFILENAMEA ofn;
		char path[ MAX_PATH ]{ };

		ZeroMemory( &ofn, sizeof( ofn ) );
		ofn.lStructSize = sizeof( ofn );
		ofn.hwndOwner = wnd;
		ofn.lpstrFilter = type.empty( ) ? "All Files (*.*)\0*.*\0" : type.data( );
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

		if ( GetOpenFileNameA( &ofn ) )
			return { path };

		return std::nullopt;
	}

	inline std::optional< std::string > read_file( const std::string_view path )
	{
		std::ifstream file( path.data( ) );
		if ( !file.is_open( ) )
			return std::nullopt;

		std::string content;
		file.seekg( 0, std::ios::end );
		content.reserve( file.tellg( ) );
		file.seekg( 0, std::ios::beg );

		content.assign( std::istreambuf_iterator< char >( file ), std::istreambuf_iterator< char >( ) );
		return content;
	}

	inline std::optional< std::pair< std::string, std::string > > read_dialogue( const std::string_view type = "", const HWND wnd = nullptr )
	{
		const auto path = get_dialogue_path( type, wnd );
		if ( !path )
			return std::nullopt;

		const auto content = read_file( *path );
		if ( !content )
			return std::nullopt;

		return std::make_pair( *path, *content );
	}

	template< typename ty >
	std::optional< ty > get_window_prop( const HWND wnd, const char* const prop )
	{
		const auto allocation = GetPropA( wnd, prop );

		return allocation ? std::make_optional( *reinterpret_cast< ty* >( allocation ) ) : std::nullopt;
	}

	template < typename ty >
	void set_window_prop( const HWND wnd, const char* const prop, const ty value )
	{
		std::unique_ptr< void, decltype( &LocalFree ) > x = { LocalAlloc( LMEM_ZEROINIT, sizeof( ty ) ), &LocalFree };
		if ( !x )
			return;

		*reinterpret_cast< ty* >( x.get( ) ) = value;
		SetPropA( wnd, prop, x.get( ) );
	}

	template < typename ty = std::uintptr_t >
	std::optional< ty > find_pattern_primitive( const std::uintptr_t start, const std::uintptr_t end, const std::string_view pattern )
	{
		std::vector< std::pair< bool, std::uint8_t > > bytes;

		for ( auto it = pattern.begin( ); it != pattern.end( ); ++it )
		{
			if ( *it == ' ' )
				continue;

			else if ( *it == '?' )
			{
				if ( it + 1 < pattern.end( ) && *( it + 1 ) == '?' )
				{
					bytes.push_back( { true, 0x00 } );
					++it;
				}

				else
					bytes.push_back( { false, 0x00 } );
			}

			else
			{
				if ( it + 1 == pattern.end( ) )
					break;

				const auto get_byte = [ ] ( const std::string x ) -> std::uint8_t
				{
					return static_cast< std::uint8_t >( std::stoul( x, nullptr, 16 ) );
				};

				bytes.emplace_back( false, get_byte( std::string( it - 1, ( ++it ) + 1 ) ) );
			}
		}

		for ( auto i = reinterpret_cast< const std::uint8_t* >( start ); i < reinterpret_cast< const std::uint8_t* >( end ); )
		{
			auto found = true;
			for ( const auto [is_wildcard, byte] : bytes )
			{
				++i;

				if ( is_wildcard )
					continue;

				if ( *i != byte )
				{
					found = false;
					break;
				}
			}

			if ( found )
				return ty( i - bytes.size( ) + 1 );
		}

		return std::nullopt;
	}

	struct segment_t
	{
		std::string_view name = "";
		std::uintptr_t start{ }, end{ };
		std::size_t size{ };

		template < typename ty = std::uintptr_t >
		std::optional< ty > find_pattern( const std::string_view pattern ) const
		{
			return find_pattern_primitive< ty >( start, end, pattern );
		}

		segment_t( const std::string_view segment_name )
		{
			init( GetModuleHandle( nullptr ), segment_name );
		}

		segment_t( const void* const module, const std::string_view segment_name )
		{
			init( module, segment_name );
		}

		segment_t( const void* const handle, const IMAGE_SECTION_HEADER* section )
		{
			init( handle, section );
		}

	private:
		void init( const void* const handle, const IMAGE_SECTION_HEADER* section )
		{
			name = std::string_view( reinterpret_cast< const char* >( section->Name ), 8 );
			start = reinterpret_cast< std::uintptr_t >( handle ) + section->VirtualAddress;
			end = start + section->Misc.VirtualSize;
			size = section->Misc.VirtualSize;
		}

		void init( const void* const handle, const std::string_view segment_name )
		{
			const auto dos = reinterpret_cast< const IMAGE_DOS_HEADER* >( handle );
			const auto nt = reinterpret_cast< const IMAGE_NT_HEADERS* >( reinterpret_cast< const std::uint8_t* >( handle ) + dos->e_lfanew );

			const auto section = reinterpret_cast< const IMAGE_SECTION_HEADER* >( reinterpret_cast< const std::uint8_t* >( &nt->OptionalHeader ) + nt->FileHeader.SizeOfOptionalHeader );

			for ( auto i = 0u; i < nt->FileHeader.NumberOfSections; ++i )
			{
				if ( std::string_view( reinterpret_cast< const char* >( section[ i ].Name ), 8 ).find( segment_name ) != std::string_view::npos )
				{
					start = reinterpret_cast< std::uintptr_t >( handle ) + section[ i ].VirtualAddress;
					end = start + section[ i ].Misc.VirtualSize;
					size = section[ i ].Misc.VirtualSize;
					name = segment_name;
					return;
				}
			}

			throw std::runtime_error( "Segment not found" );
		}
	};

#pragma code_seg( push, ".text" )
	template < auto... bytes>
	struct shellcode_t
	{
		static constexpr std::size_t size = sizeof...( bytes );
		__declspec( allocate( ".text" ) ) static constexpr std::uint8_t data[ ]{ bytes... };
	};
#pragma code_seg( pop )

	template < typename ty, auto... bytes >
	constexpr ty make_shellcode( )
	{
		return reinterpret_cast< const ty >( &shellcode_t< bytes... >::data );
	}

	template < std::uint8_t... bytes >
	UD_FORCEINLINE constexpr void emit( )
	{
#if defined( __clang__ ) || defined( __GNUC__ )
		constexpr std::uint8_t data[ ]{ bytes... };

		for ( auto i = 0u; i < sizeof...( bytes ); ++i )
			__asm volatile( ".byte %c0\t\n" :: "i" ( data[ i ] ) );
#endif
	}

	template < std::size_t size, std::uint32_t seed = __COUNTER__ + 0x69, std::size_t count = 0 >
	UD_FORCEINLINE constexpr void emit_random( )
	{
		if constexpr ( count < size )
		{
			constexpr auto random = details::recursive_random< seed >( );
			emit< static_cast< std::uint8_t >( random ) >( );
			emit_random< size, static_cast< std::uint32_t >( random )* seed, count + 1 >( );
		}
	}

	inline bool is_valid_page( const void* const data, const std::uint32_t flags = PAGE_READWRITE )
	{
		MEMORY_BASIC_INFORMATION mbi{ };

		if ( !VirtualQuery( data, &mbi, sizeof( mbi ) ) )
			return false;

		return mbi.Protect & flags;
	}

	struct export_t
	{
		std::string_view name = "";
		std::uint16_t ordinal{ };
		std::uintptr_t address{ };
	};

	struct module_t
	{
		std::string name;
		std::uintptr_t start, end;
		std::size_t size;

		std::vector< export_t > get_exports( ) const
		{
			const auto dos = reinterpret_cast< const IMAGE_DOS_HEADER* >( start );
			const auto nt = reinterpret_cast< const IMAGE_NT_HEADERS* >( start + dos->e_lfanew );

			const auto directory_header = nt->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];
			if ( !directory_header.VirtualAddress )
				return { };

			const auto export_dir = reinterpret_cast< const IMAGE_EXPORT_DIRECTORY* >( start + directory_header.VirtualAddress );
			const auto name_table = reinterpret_cast< const std::uint32_t* >( start + export_dir->AddressOfNames );
			const auto ord_table = reinterpret_cast< const std::uint16_t* >( start + export_dir->AddressOfNameOrdinals );
			const auto addr_table = reinterpret_cast< const std::uint32_t* >( start + export_dir->AddressOfFunctions );

			std::vector< export_t > exports( export_dir->NumberOfNames );

			for ( auto i = 0u; i < export_dir->NumberOfNames; ++i )
			{
				const auto name = reinterpret_cast< const char* >( start + name_table[ i ] );
				const auto ord = ord_table[ i ];
				const auto addr = start + addr_table[ ord ];

				exports[ i ] = { name, ord, addr };
			}

			return exports;
		}

		std::vector< segment_t > get_segments( ) const
		{
			const auto dos = reinterpret_cast< const IMAGE_DOS_HEADER* >( start );
			const auto nt = reinterpret_cast< const IMAGE_NT_HEADERS* >( start + dos->e_lfanew );

			const auto section = reinterpret_cast< const IMAGE_SECTION_HEADER* >( reinterpret_cast< const std::uint8_t* >( &nt->OptionalHeader ) + nt->FileHeader.SizeOfOptionalHeader );

			std::vector< segment_t > segments;
			segments.reserve( nt->FileHeader.NumberOfSections );

			for ( auto i = 0u; i < nt->FileHeader.NumberOfSections; ++i )
			{
				const segment_t seg( dos, &section[ i ] );
				segments.push_back( seg );
			}

			return segments;
		}

		std::vector< export_t > get_imports( ) const
		{
			const auto dos = reinterpret_cast< const IMAGE_DOS_HEADER* >( start );
			const auto nt = reinterpret_cast< const IMAGE_NT_HEADERS* >( start + dos->e_lfanew );

			const auto directory_header = &nt->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ];
			if ( !directory_header->VirtualAddress )
				return { };

			const auto import_dir = reinterpret_cast< const IMAGE_IMPORT_DESCRIPTOR* >( start + directory_header->VirtualAddress );
			std::vector< export_t > imports;

			for ( auto i = 0u;; ++i )
			{
				if ( !import_dir[ i ].OriginalFirstThunk )
					break;

				const auto directory = &import_dir[ i ];

				const auto name_table = reinterpret_cast< const std::uint32_t* >( start + directory->OriginalFirstThunk );
				const auto addr_table = reinterpret_cast< const std::uint32_t* >( start + directory->FirstThunk );

				for ( auto j = 0u;; ++j )
				{
					if ( !addr_table[ j ] )
						break;

					if ( !name_table[ j ] )
						continue;

					std::string_view name;

					constexpr auto name_alignment = 2;

					const auto addr = &addr_table[ j ];
					const auto name_ptr = reinterpret_cast< const char* >( start + name_table[ j ] ) + name_alignment;

#if UD_USE_SEH
						// using SEH here is not a very good solution
						// however, it's faster than querying that page protection to see if it's readable
						__try
						{
							name = name_ptr;
						}
						__except ( EXCEPTION_EXECUTE_HANDLER )
						{
							name = "";
						}
#else
						// runtime overhead of ~3us compared to SEH on single calls
						// on bulk calls it can go up to ~300-500us 
						name = is_valid_page( name_ptr, PAGE_READONLY ) ? name_ptr : "";
#endif

					// emplace_back doesn't allow for implicit conversion, so we have to do it manually
					imports.push_back( { name, static_cast< std::uint16_t >( j ), reinterpret_cast< std::uintptr_t >( addr ) } );
				}
			}

			return imports;
		}

		template < typename ty = std::uintptr_t >
		ty get_address( const std::string_view name ) const
		{
			for ( const auto& export_ : get_exports( ) )
			{
				if ( export_.name.find( name ) != std::string_view::npos )
					return ty( export_.address );
			}

			return 0;
		}

		template < typename ty = std::uintptr_t >
		std::optional< ty > find_pattern( const std::string_view pattern ) const
		{
			return find_pattern_primitive< ty >( start, end, pattern );
		}

		module_t( )
		{
			init( GetModuleHandle( nullptr ) );
		}

		module_t( void* const handle )
		{
			init( handle );
		}

		module_t( const std::string_view module_name )
		{
			init( GetModuleHandleA( module_name.data( ) ) );
		}

	private:
		void* module;

		void init( void* const handle )
		{
			module = handle;

			const auto dos = reinterpret_cast< const IMAGE_DOS_HEADER* >( handle );
			const auto nt = reinterpret_cast< const IMAGE_NT_HEADERS* >( reinterpret_cast< const std::uint8_t* >( handle ) + dos->e_lfanew );

			start = reinterpret_cast< std::uintptr_t >( handle );
			end = start + nt->OptionalHeader.SizeOfImage;
			size = nt->OptionalHeader.SizeOfImage;

			char buffer[ MAX_PATH ];
			const auto sz = GetModuleFileNameA( static_cast< HMODULE >( handle ), buffer, MAX_PATH );

			name = sz ? std::string{ buffer, sz } : std::string{ };
		}
	};

	inline std::vector< module_t > get_modules( )
	{
		std::vector< module_t > result;

#ifdef _M_X64
		const auto peb = reinterpret_cast< const PEB* >( __readgsqword( 0x60 ) );
#else
		const auto peb = reinterpret_cast< const PEB* >( __readfsdword( 0x30 ) );
#endif

		const auto modules = reinterpret_cast< const LIST_ENTRY* >( peb->Ldr->InMemoryOrderModuleList.Flink );
		for ( auto i = modules->Flink; i != modules; i = i->Flink )
		{
			const auto entry = reinterpret_cast< const LDR_DATA_TABLE_ENTRY* >( i );

			if ( entry->Reserved2[ 0 ] || entry->DllBase )
				result.emplace_back( entry->Reserved2[ 0 ] ? entry->Reserved2[ 0 ] : entry->DllBase );
		}

		return result;
	}

	inline std::optional< module_t > get_module_at_address( const std::uintptr_t address )
	{
		for ( const auto& module : get_modules( ) )
		{
			if ( module.start <= address && address < module.end )
				return module;
		}

		return std::nullopt;
	}

	inline std::optional< export_t > get_export( const std::uintptr_t address )
	{
		for ( const auto& module : get_modules( ) )
		{
			if ( module.start <= address && address < module.end )
			{
				const auto exports = module.get_exports( );
				for ( const auto& export_ : exports )
				{
					if ( export_.address == address )
						return export_;
				}
			}
		}

		return std::nullopt;
	}

	namespace rot
	{
		template < details::comp_string_t str >
		struct rot_t
		{
			char rotted[ str.size ];

			consteval const char* encoded( ) const
			{
				return rotted;
			}

			consteval rot_t( )
			{
				for ( auto i = 0u; i < str.size; ++i )
				{
					const auto c = str.data[ i ];
					const auto set = c >= 'A' && c <= 'Z' ? 'A' : c >= 'a' && c <= 'z' ? 'a' : c;

					if ( set == 'a' || set == 'A' )
						rotted[ i ] = ( c - set - 13 + 26 ) % 26 + set;

					else
						rotted[ i ] = c;
				}
			}
		};

		template < details::comp_string_t str >
		UD_FORCEINLINE details::comp_string_t< str.size > decode( rot_t< str > encoded )
		{
			details::comp_string_t< str.size > result{ };

			for ( auto i = 0u; i < str.size; ++i )
			{
				const auto c = encoded.rotted[ i ];
				const auto set = c >= 'A' && c <= 'Z' ? 'A' : c >= 'a' && c <= 'z' ? 'a' : c;

				if ( set == 'a' || set == 'A' )
					result.data[ i ] = ( c - set - 13 + 26 ) % 26 + set;

				else
					result.data[ i ] = c;
			}

			return result;
		}
	}

	namespace fnv
	{
		inline constexpr std::uint32_t fnv_1a( const char* const str, const std::size_t size )
		{
			constexpr auto prime = 16777619u;

			std::uint32_t hash = 2166136261;

			for ( auto i = 0u; i < size; ++i )
			{
				hash ^= str[ i ];
				hash *= prime;
			}

			return hash;
		}

		inline constexpr std::uint32_t fnv_1a( const std::string_view str )
		{
			return fnv_1a( str.data( ), str.size( ) );
		}

		template < details::comp_string_t str >
		consteval std::uint32_t fnv_1a( )
		{
			return fnv_1a( str.data, str.size );
		}
	}

	namespace xorstr
	{
		template < details::comp_string_t str, std::uint32_t key_multiplier >
		struct xorstr_t
		{
			char xored[ str.size ];

			consteval std::uint64_t xor_key( ) const
			{
				return details::recursive_random< key_multiplier >( );
			}

			consteval xorstr_t( )
			{
				for ( auto i = 0u; i < str.size; ++i )
					xored[ i ] = str.data[ i ] ^ xor_key( );
			}
		};

		template < details::comp_string_t str, std::uint32_t key_multiplier >
		UD_FORCEINLINE details::comp_string_t< str.size > decrypt( xorstr_t< str, key_multiplier > enc )
		{
			details::comp_string_t< str.size > result{ };

			for ( auto i = 0u; i < str.size; ++i )
			{
				const auto c = enc.xored[ i ];

				result.data[ i ] = c ^ enc.xor_key( );
			}

			return result;
		}
	}
}

template < std::size_t size >
UD_FORCEINLINE std::ostream& operator<<( std::ostream& os, const ud::details::comp_string_t< size >& str )
{
	return os << std::string_view{ str.data, str.size };
}

#if defined( _MSC_VER )
#pragma warning( pop )
#endif
```

`custom veh/includes/MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a Hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget    [in]  A pointer to the target function, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    //   ppTarget   [out] A pointer to the target function, which will be used
    //                    with other functions.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif


```

`custom veh/main.cpp`:

```cpp
#include <iostream>
#include <Windows.h>

#include "custom_veh/custom_veh.hpp"

std::uint32_t custom_handler( PEXCEPTION_POINTERS info )
{
	std::cout << "I'm ran first!\n";

	return EXCEPTION_CONTINUE_SEARCH;
}

LONG WINAPI vanilla_handler( PEXCEPTION_POINTERS info )
{
	std::cout << "I'm ran second!\n";

	return EXCEPTION_CONTINUE_EXECUTION;
}

std::uint32_t custom_handler2( PEXCEPTION_POINTERS info )
{
	std::cout << std::hex << info->ExceptionRecord->ExceptionCode << " is handled!\n";

	return EXCEPTION_CONTINUE_EXECUTION;
}

void redir( )
{
	std::cout << "cf redir\n";

	RaiseException( 0x1337, 0, 0, nullptr );
}

int main( )
{
	custom_veh::start_veh( );
		
	custom_veh::add_vectored_handler( &custom_handler );
	AddVectoredExceptionHandler( TRUE, &vanilla_handler );
	RaiseException( 0x90, 0, 0, nullptr );

	std::cout << "I'm executed!\n";

	custom_veh::add_vectored_handler( &custom_handler2 );
	RaiseException( 0xffaded, 0, 0, nullptr );

	std::cout << "I'm continued before vanilla handlers execution!\n";

}
```