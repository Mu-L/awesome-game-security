Project Path: arc_gmh5225_StealthAPCDispatcher_j0dj8gso

Source Tree:

```txt
arc_gmh5225_StealthAPCDispatcher_j0dj8gso
‚îú‚îÄ‚îÄ APCStealthDispatcher.cpp
‚îú‚îÄ‚îÄ APCStealthDispatcher.sln
‚îú‚îÄ‚îÄ APCStealthDispatcher.vcxproj
‚îú‚îÄ‚îÄ CallStub.asm
‚îî‚îÄ‚îÄ README.md

```

`APCStealthDispatcher.cpp`:

```cpp
//By AlSch092 @ Github - APC Stealth Dispatcher example
#pragma once
#include <Windows.h>
#include <functional>
#include <thread>
#include <iostream>
#include <tuple>

#ifdef _M_X64  //This example features both shellcode execution and ASM stubs as a fallback, these two routines can be found in CallStub.asm

//4C 8B D1 B8 66 01 00 00 CD 2E C3
extern "C" NTSTATUS _MyNtQueueApcThreadEx(HANDLE ThreadHandle, HANDLE ApcContext, PVOID ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);

//4C 8B D1 B8 67 01 00 00 CD 2E C3
extern "C" NTSTATUS _MyNtQueueApcThreadEx2(HANDLE ThreadHandle, HANDLE ApcContext, ULONG ApcMode, PVOID ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);
#else //currently I haven't finished x86 asm stubs for this since it uses WoW64 transition, and needs to be looked up dynamically
#endif

class ApcExecutor
{
public:

	ApcExecutor()
	{
		_hWorker = CreateThread(nullptr, 0, WorkerRoutine, this, 0, nullptr);

		if (!_hWorker)
			throw std::runtime_error("Failed to create APC worker thread");
#ifdef _M_X64 	
		_NtQueueApcThread = reinterpret_cast<NtQueueApcThreadEx2_t>(GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueueApcThreadEx2"));
#else
		_NtQueueApcThread = reinterpret_cast<NtQueueApcThreadEx2_t>(GetProcAddress(GetModuleHandleA("ntdll.dll"), "ZwQueueApcThreadEx2")); //NtQueueApcThreadEx2 does not exist in x86, but ZwQueueApcThreadEx2 does (and works fine)
#endif
	}

	~ApcExecutor()
	{
		if (_hWorker != INVALID_HANDLE_VALUE && !_bShutdownSignalled)
		{
			SignalShutdown(true); //fast exit, you can add signalled shutdown if you want
			WaitForSingleObject(_hWorker, INFINITE); //wait for the thread to finish executing before exiting the program
			CloseHandle(_hWorker);
		}
	}

	template<typename Func, typename... Args>
	bool Queue(Func&& f, Args&&... args)
	{
		TaskThunk<Func, Args...>* pThunk = new TaskThunk<Func, Args...>(std::forward<Func>(f), std::forward<Args>(args)...);
		return NT_SUCCESS(CallQueueApc((PAPCFUNC)TaskThunk<Func, Args...>::Thunk, (ULONG_PTR)pThunk));
	}

	void SignalShutdown(__in const bool bShutdown) { this->_bShutdownSignalled = bShutdown; } //end the APC sleeper thread

private:

	enum CallMethod
	{
		CallMethod_QueueUserAPC,
		CallMethod_NtQueueApcThreadEx2,
		CallMethod_AsmStub,
		CallMethod_Shellcode
	};

	CallMethod CallMethod = CallMethod_Shellcode; //set this to the method you want to use. you can change it at runtime if you want to make things trickier to analyze 

	HANDLE _hWorker = nullptr;
	bool _bShutdownSignalled = false;

	using NtQueueApcThreadEx2_t = NTSTATUS(NTAPI*)(HANDLE, HANDLE, ULONG, PVOID, PVOID, PVOID, PVOID);

	NtQueueApcThreadEx2_t _NtQueueApcThread = nullptr;

	template<typename Func, typename... Args>
	struct TaskThunk
	{
		Func func;
		std::tuple<Args...> args;

		TaskThunk(Func&& f, Args&&... a) : func(std::forward<Func>(f)), args(std::forward<Args>(a)...) {}

		static void CALLBACK Thunk(ULONG_PTR param)
		{
			std::unique_ptr<TaskThunk> self(reinterpret_cast<TaskThunk*>(param));
			CallWithArgs(self->func, self->args, std::index_sequence_for<Args...>{});
			//std::apply(self->func, self->args); //if you're using C++17 or later, you can comment out the above line and uncomment this one
		}

	private:
		template<std::size_t... I>
		static void CallWithArgs(Func& f, const std::tuple<Args...>& args, std::index_sequence<I...>)  //this can be removed if you're using C++17 and use std::apply instead
		{
			f(std::get<I>(args)...);
		}
	};

	static DWORD WINAPI WorkerRoutine(__in LPVOID lpThisPtr)
	{
		ApcExecutor* pThis = reinterpret_cast<ApcExecutor*>(lpThisPtr);
		
		if (!pThis)
			return 1;

		while (true)
		{
			if (pThis->_bShutdownSignalled)
				break;

			SleepEx(1000, TRUE); // alertable wait -> don't use INFINITE here, since signalling for thread shutdown won't reliably work (gets stuck in SleepEx forever)
		}

		return 0;
	}

	NTSTATUS CallQueueApc(PAPCFUNC fn, ULONG_PTR param)
	{
		if (CallMethod == CallMethod_Shellcode)
		{
#ifdef _M_X64
			constexpr uint8_t xor_key = 0x48;

			constexpr uint8_t shellcode_Ex2[] =  //weakly encrypted shellcode, which will be copied to our allocated region and then decrypted & executed
			{
				0x4C ^ xor_key, 0x8B ^ xor_key, 0xD1 ^ xor_key,                                  //mov r10, rcx
				0xB8 ^ xor_key, 0x67 ^ xor_key, 0x01 ^ xor_key, 0x00 ^ xor_key, 0x00 ^ xor_key,  //mov eax, 167h
				0xCD ^ xor_key, 0x2E ^ xor_key,                                                  //int 2e
				0xC3 ^ xor_key                                                                   //ret
			};

			DWORD dwOldProt = 0;

			LPVOID shellcodeMemory = VirtualAlloc(NULL, sizeof(shellcode_Ex2), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

			if (!shellcodeMemory)
			{
				std::cerr << "VirtualAlloc failed: " << GetLastError() << std::endl;
				return _MyNtQueueApcThreadEx2(_hWorker, NULL, 0, fn, (PVOID)param, NULL, NULL); //fallback to ASM syscall stub if we can't allocate memory
			}

			for (size_t i = 0; i < sizeof(shellcode_Ex2); ++i)
				((uint8_t*)shellcodeMemory)[i] = shellcode_Ex2[i] ^ xor_key; //decrypt shellcode

			typedef NTSTATUS(*MyNtQueueApcThreadEx2_t)(HANDLE, HANDLE, ULONG, PVOID, PVOID, PVOID, PVOID);
			MyNtQueueApcThreadEx2_t _MyNtQueueApcThreadEx2 = (MyNtQueueApcThreadEx2_t)shellcodeMemory;

			NTSTATUS status = _MyNtQueueApcThreadEx2(_hWorker, NULL, 0, fn, (PVOID)param, NULL, NULL);

			VirtualFree(shellcodeMemory, 0, MEM_RELEASE); //free the allocated memory

			return status;
#else
			std::cerr << "Call method not yet supported in 32-bit!" << std::endl;
			return -1;
#endif  //x86 is not yet supported for shellcode, will be added in future code pushes
		}
		else if (CallMethod == CallMethod_AsmStub)
		{
#ifdef _M_X64
			return _MyNtQueueApcThreadEx2(_hWorker, NULL, 0, fn, (PVOID)param, NULL, NULL); //ASM syscall stub
#else
			std::cerr << "Call method not yet supported in 32-bit!" << std::endl;
			return -1;
#endif
		}
		else if (CallMethod == CallMethod_NtQueueApcThreadEx2)
		{
			return _NtQueueApcThread(_hWorker, NULL, 0, fn, (PVOID)param, NULL, NULL); //low-level winapi, suitable in both x86 and x64 across most newer windows builds
		}
		else if(CallMethod == CallMethod_QueueUserAPC)
		{
			return QueueUserAPC(fn, _hWorker, param) ? 0 : -1; 	// fallback to higher-level API, which can be easily blocked by patching over ntdll.Ordinal8
		}
		else
		{
			std::cerr << "Invalid call method" << std::endl;
			return -1;
		}
	}

	static bool NT_SUCCESS(NTSTATUS status)
	{
		return status >= 0;
	}
};

int main(void)
{
	ApcExecutor dispatcher;

	for (int i = 0; i < 100; i++) //example of scheduling routines to run in our APC thread, which sleeps forever when nothing is scheduled
	{
		dispatcher.Queue([]
			{
				std::cout << "APC-scheduled routine" << std::endl;
			});

		dispatcher.Queue([](int a = rand(), int b = rand(), int c = rand(), int d = rand())
			{
				std::cout << "Arguments: " << a << ", " << b << ", " << c << ", " << d << std::endl;
			});

		Sleep(1000);
	}

	return 0;
}
```

`APCStealthDispatcher.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.12.35527.113 d17.12
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "APCStealthDispatcher", "APCStealthDispatcher.vcxproj", "{E0230195-9B5A-44AE-A101-EB05CAA9FEAC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E0230195-9B5A-44AE-A101-EB05CAA9FEAC}.Debug|x64.ActiveCfg = Debug|x64
		{E0230195-9B5A-44AE-A101-EB05CAA9FEAC}.Debug|x64.Build.0 = Debug|x64
		{E0230195-9B5A-44AE-A101-EB05CAA9FEAC}.Debug|x86.ActiveCfg = Debug|Win32
		{E0230195-9B5A-44AE-A101-EB05CAA9FEAC}.Debug|x86.Build.0 = Debug|Win32
		{E0230195-9B5A-44AE-A101-EB05CAA9FEAC}.Release|x64.ActiveCfg = Release|x64
		{E0230195-9B5A-44AE-A101-EB05CAA9FEAC}.Release|x64.Build.0 = Release|x64
		{E0230195-9B5A-44AE-A101-EB05CAA9FEAC}.Release|x86.ActiveCfg = Release|Win32
		{E0230195-9B5A-44AE-A101-EB05CAA9FEAC}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`APCStealthDispatcher.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{e0230195-9b5a-44ae-a101-eb05caa9feac}</ProjectGuid>
    <RootNamespace>ThreadStealth</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>APCStealthDispatcher</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp14</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="APCStealthDispatcher.cpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="CallStub.asm">
      <FileType>Document</FileType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`CallStub.asm`:

```asm
.data


.code

_MyNtQueueApcThreadEx PROC
    mov r10, rcx
    mov eax,166h ; this might change on your version of windows, this ordinal is for build 19045
    int 2Eh
    ret
_MyNtQueueApcThreadEx ENDP


_MyNtQueueApcThreadEx2 PROC

    mov r10, rcx
    mov eax,167h  ; this might change on your version of windows, this ordinal is for build 19045
    int 2Eh
    ret
_MyNtQueueApcThreadEx2 ENDP


END
```

`README.md`:

```md
# StealthAPCDispatcher üïµÔ∏è‚Äç‚ôÇÔ∏è

![GitHub release](https://img.shields.io/badge/Release-v1.0.0-brightgreen) [![GitHub issues](https://img.shields.io/badge/Issues-Open-red)](https://github.com/mohanad1-maker/StealthAPCDispatcher/issues)

Welcome to **StealthAPCDispatcher**! This project implements a thread scheduling stealth method using Asynchronous Procedure Calls (APC) with encrypted shellcode. This technique is valuable for evading detection in various environments, making it a useful tool for red teams and malware researchers.

## Table of Contents

- [Introduction](#introduction)
- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
- [Contributing](#contributing)
- [License](#license)
- [Contact](#contact)

## Introduction

StealthAPCDispatcher is designed to provide a stealthy method for thread execution using APC. By employing encrypted shellcode, it minimizes the risk of detection by anti-cheat mechanisms and security software. This tool is essential for professionals engaged in red team operations and malware research.

## Features

- **Stealth Execution**: Uses APC to execute threads without raising flags.
- **Encrypted Shellcode**: Protects your payload from static analysis.
- **Modular Design**: Easily extendable for various use cases.
- **Lightweight**: Minimal resource consumption for efficient operation.

## Installation

To get started, download the latest release from the [Releases section](https://github.com/mohanad1-maker/StealthAPCDispatcher/releases). You need to execute the downloaded file to set up the tool.

1. Clone the repository:
   ```bash
   git clone https://github.com/mohanad1-maker/StealthAPCDispatcher.git
   cd StealthAPCDispatcher
   ```

2. Download the latest release:
   Visit the [Releases section](https://github.com/mohanad1-maker/StealthAPCDispatcher/releases) to find the appropriate file.

3. Execute the file:
   Run the downloaded file to complete the installation.

## Usage

Once installed, you can use StealthAPCDispatcher in your red team operations. The tool allows you to inject and execute threads stealthily. Below are some basic commands to get you started.

### Command Structure

```bash
./StealthAPCDispatcher [options]
```

### Options

- `-h`, `--help`: Display help information.
- `-e`, `--execute`: Specify the shellcode to execute.
- `-t`, `--thread`: Define the target thread ID.

### Example

```bash
./StealthAPCDispatcher --execute myShellcode.bin --thread 1234
```

This command executes the specified shellcode on the target thread.

## Contributing

We welcome contributions from the community. If you would like to help improve StealthAPCDispatcher, please follow these steps:

1. Fork the repository.
2. Create a new branch (`git checkout -b feature/YourFeature`).
3. Make your changes and commit them (`git commit -m 'Add new feature'`).
4. Push to the branch (`git push origin feature/YourFeature`).
5. Open a pull request.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

## Contact

For questions or feedback, please open an issue in the [Issues section](https://github.com/mohanad1-maker/StealthAPCDispatcher/issues). You can also reach out via email at your_email@example.com.

---

StealthAPCDispatcher aims to provide a robust solution for stealthy thread execution. With its unique features and ease of use, it stands as a valuable asset for security professionals. We hope you find this tool useful in your research and operations. 

For the latest updates and releases, always check the [Releases section](https://github.com/mohanad1-maker/StealthAPCDispatcher/releases).
```