Project Path: arc_gmh5225_KernelSnippets_182bfqc6

Source Tree:

```txt
arc_gmh5225_KernelSnippets_182bfqc6
├── MmIsAddressValid.h
└── VGK_SwapContextHk.h

```

`MmIsAddressValid.h`:

```h
#define PAGE_OFFSET_MASK 0xFFF
#define PAGE_SIZE 0x1000
#define PML4_SHIFT 39
#define PDP_SHIFT 30
#define PD_SHIFT 21
#define PT_SHIFT 12
#define PML4_MASK 0x1FF
#define PDP_MASK 0x1FF
#define PD_MASK 0x1FF
#define PT_MASK 0x1FF

ULONG_PTR ReadPhysicalAddress(ULONG_PTR Address) {
    PHYSICAL_ADDRESS pa;
    pa.QuadPart = Address;
    PVOID Mapped = MmMapIoSpace(pa, PAGE_SIZE, MmNonCached);
    if (!Mapped) return 0;

    ULONG_PTR value = *(volatile ULONG_PTR*)Mapped;
    MmUnmapIoSpace(Mapped, PAGE_SIZE);
    return value;
}

BOOLEAN MmIsAddressValid(PVOID VirtualAddress, ULONG_PTR CustomCr3 = 0) {
    ULONG_PTR address = (ULONG_PTR)VirtualAddress;
    ULONG_PTR cr3 = CustomCr3 ? CustomCr3 : __readcr3();

    ULONG_PTR pml4Index = (address >> PML4_SHIFT) & PML4_MASK;
    ULONG_PTR pdpIndex = (address >> PDP_SHIFT) & PDP_MASK;
    ULONG_PTR pdIndex = (address >> PD_SHIFT) & PD_MASK;
    ULONG_PTR ptIndex = (address >> PT_SHIFT) & PT_MASK;

    ULONG_PTR pml4Base = cr3 & ~PAGE_OFFSET_MASK;
    ULONG_PTR pml4Entry = ReadPhysicalAddress(pml4Base + (pml4Index * sizeof(ULONG_PTR)));
    if (!(pml4Entry & 1)) return FALSE;

    ULONG_PTR pdpBase = pml4Entry & ~PAGE_OFFSET_MASK;
    ULONG_PTR pdpEntry = ReadPhysicalAddress(pdpBase + (pdpIndex * sizeof(ULONG_PTR)));
    if (!(pdpEntry & 1)) return FALSE;

    ULONG_PTR pdBase = pdpEntry & ~PAGE_OFFSET_MASK;
    ULONG_PTR pdEntry = ReadPhysicalAddress(pdBase + (pdIndex * sizeof(ULONG_PTR)));
    if (!(pdEntry & 1)) return FALSE;

    ULONG_PTR ptBase = pdEntry & ~PAGE_OFFSET_MASK;
    ULONG_PTR ptEntry = ReadPhysicalAddress(ptBase + (ptIndex * sizeof(ULONG_PTR)));
    if (!(ptEntry & 1)) return FALSE;

    return TRUE;
}

```

`VGK_SwapContextHk.h`:

```h
void VGK_WhitelistThread_SwapContextHk(uint64_t CurrentThread) 
{
    uint64_t currentCR3 = __readcr3();
    if (currentCR3 != GameProcessCR3) {
        return; 
    }

    // check if the current thread is whitelisted to allow memory context switching
    bool isThreadAllowedToWriteCR3 = false;
    AcquireSpinLock();
    if (WhitelistedThreadCount > 0) {
        for (uint32_t i = 0; i < WhitelistedThreadCount; ++i) {
            if (CurrentThread == *reinterpret_cast<uint64_t*>(WhitelistedThreadsArray + 8 * i)) {
                isThreadAllowedToWriteCR3 = true;
                break;
            }
        }
    }
    ReleaseSpinLock();

    if (!isThreadAllowedToWriteCR3) {
        return;
    }

    // prepare a new CR3 context for the whitelisted thread
    _disable(); 

    // copy the current game CR3 page directory to the cloned CR3
    custom_memcpy(reinterpret_cast<void*>(ClonedCR3), reinterpret_cast<void*>(GameProcessCR3), 0x1000);

    // set up a shadow page table entry for the cloned CR3
    *reinterpret_cast<uint64_t*>(ClonedCR3 + 8 * FreePML4Index) = ShadowPageTableEntry;

    // write the cloned CR3 if the thread is allowed to change memory context
    if (isThreadAllowedToWriteCR3) {
        __writecr3(ClonedCR3);
    }

    // iterate over the page table array and clear access permissions based on the access byte
    uint64_t clientPageTable = reinterpret_cast<uint64_t>(PageTableArray);
    uint64_t adjustedAccessAddress = GameProcessCR3 ^ PageTableArray[PageAccessByte];

    // loop through each PML4 entry
    for (uint64_t i = 0; i < 512; ++i) { 
        uint64_t entry = *reinterpret_cast<uint64_t*>(clientPageTable + 8 * i);
        // check if the page table entry is valid
        if ((entry & 1) != 0) {
            uint64_t entryIndex = (entry >> 12) & 0xFFFFFFFFF;
            *reinterpret_cast<uint64_t*>(adjustedAccessAddress + 48 * entryIndex) &= ~1ULL; // clear access bit
        }
    }

    // flush the tlb if required
    if (ShouldFlushTLB) {
        uint64_t originalCR4 = __readcr4();
        __writecr4(originalCR4 ^ 0x80);
        __writecr4(originalCR4); 
    }

    _enable();
}

```