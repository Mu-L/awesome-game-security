Project Path: arc_gmh5225_query-gpu-name-rs_h25b_jgt

Source Tree:

```txt
arc_gmh5225_query-gpu-name-rs_h25b_jgt
├── Cargo.lock
├── Cargo.toml
├── README.md
└── src
    └── main.rs

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "query_gpu_name"
version = "0.1.0"
dependencies = [
 "windows",
]

[[package]]
name = "windows"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e686886bc078bc1b0b600cac0147aadb815089b6e4da64016cbd754b6342700f"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

```

`Cargo.toml`:

```toml
[package]
name = "query_gpu_name"
version = "0.1.0"
edition = "2021"

[dependencies]
windows = { version = "0.48", features = [
    "Win32_Foundation",
    "Win32_Devices_DeviceAndDriverInstallation",
    "Win32_System_Registry",
    "Win32_UI_Shell",
    "Win32_System_SystemServices",
] } 
```

`README.md`:

```md
## Run
```
cargo run --release
```


## Logs
```
GPU Information Summary:
------------------------
GPU #1
Vendor: AMD
Driver: amdkmdag
Driver Path: C:\Windows\system32\drivers\amdkmdag.sys
------------------------
```

```

`src/main.rs`:

```rs
use std::path::PathBuf;
use windows::{
    core::{GUID, PCSTR},
    Win32::{
        Devices::DeviceAndDriverInstallation::{
            SetupDiDestroyDeviceInfoList, SetupDiEnumDeviceInfo, SetupDiGetClassDevsA,
            SetupDiGetDeviceRegistryPropertyA, DIGCF_PRESENT, SPDRP_SERVICE, SP_DEVINFO_DATA,
        },
        Foundation::{ERROR_SUCCESS, INVALID_HANDLE_VALUE},
        System::Registry::{
            RegCloseKey, RegOpenKeyExA, RegQueryValueExA, HKEY, HKEY_LOCAL_MACHINE, KEY_READ,
            KEY_WOW64_64KEY, REG_EXPAND_SZ, REG_SZ, REG_VALUE_TYPE,
        },
        UI::Shell::{SHGetFolderPathA, CSIDL_SYSTEM, SHGFP_TYPE_CURRENT},
    },
};

fn get_system_dir() -> Option<PathBuf> {
    let mut sys_dir = [0u8; 260];
    unsafe {
        if SHGetFolderPathA(
            None,
            37, // CSIDL_SYSTEM = 37 (0x25)
            None,
            SHGFP_TYPE_CURRENT.0 as u32,
            &mut sys_dir,
        )
        .is_ok()
        {
            let path = std::str::from_utf8(&sys_dir)
                .ok()?
                .trim_matches(char::from(0));
            Some(PathBuf::from(path))
        } else {
            None
        }
    }
}

#[derive(Debug)]
struct GpuInfo {
    vendor: String,
    name: String,
    driver_path: String,
}

fn identify_gpu_vendor(driver_filename: &str) -> Option<String> {
    if driver_filename.to_lowercase().contains("amdkmdag") {
        Some("AMD".to_string())
    } else if driver_filename.to_lowercase().contains("nvlddmkm") {
        Some("NVIDIA".to_string())
    } else if driver_filename.to_lowercase().contains("igdkmd") {
        Some("Intel".to_string())
    } else {
        None
    }
}

fn get_gpu_name(driver_path: &str) -> String {
    PathBuf::from(driver_path)
        .file_name()
        .and_then(|name| name.to_str())
        .map(|name| name.trim_end_matches(".sys").to_string())
        .unwrap_or_else(|| "Unknown".to_string())
}

fn main() {
    let display_guid = GUID::from_values(
        0x4d36e968,
        0xe325,
        0x11ce,
        [0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18],
    );

    let device_info =
        unsafe { SetupDiGetClassDevsA(Some(&display_guid), PCSTR::null(), None, DIGCF_PRESENT) }
            .unwrap();

    if device_info.0 == INVALID_HANDLE_VALUE.0 {
        println!("Error: Failed to get device info");
        return;
    }

    let mut service_names = Vec::new();
    let mut device_index = 0;

    loop {
        let mut device_data = SP_DEVINFO_DATA {
            cbSize: std::mem::size_of::<SP_DEVINFO_DATA>() as u32,
            ..Default::default()
        };

        if unsafe { !SetupDiEnumDeviceInfo(device_info, device_index, &mut device_data).as_bool() }
        {
            break;
        }

        let mut buffer_size = 0u32;
        unsafe {
            SetupDiGetDeviceRegistryPropertyA(
                device_info,
                &device_data,
                SPDRP_SERVICE,
                None,
                None,
                Some(&mut buffer_size),
            );
        }

        if buffer_size > 0 {
            let mut buffer = vec![0u8; buffer_size as usize];
            let success = unsafe {
                SetupDiGetDeviceRegistryPropertyA(
                    device_info,
                    &device_data,
                    SPDRP_SERVICE,
                    None,
                    Some(buffer.as_mut_slice()),
                    Some(&mut buffer_size),
                )
            };

            if success.as_bool() {
                if let Ok(service_name) = String::from_utf8(buffer) {
                    service_names.push(service_name.trim_matches(char::from(0)).to_string());
                }
            }
        }

        device_index += 1;
    }

    unsafe { SetupDiDestroyDeviceInfoList(device_info) };

    if service_names.is_empty() {
        println!("Error: No display adapter found");
        return;
    }

    let services_key = "SYSTEM\\CurrentControlSet\\services\0";
    let mut driver_paths = Vec::new();

    for service_name in service_names {
        let reg_key_path = format!(
            "{}\\{}\0",
            services_key.trim_matches(char::from(0)),
            service_name
        );
        let mut reg_key = HKEY::default();

        let status = unsafe {
            RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                PCSTR::from_raw(reg_key_path.as_ptr()),
                0,
                KEY_READ | KEY_WOW64_64KEY,
                &mut reg_key,
            )
        };

        if status != ERROR_SUCCESS {
            continue;
        }

        let mut value_type = REG_VALUE_TYPE::default();
        let mut value_size = 0u32;
        let image_path_key = "ImagePath\0";

        let status = unsafe {
            RegQueryValueExA(
                reg_key,
                PCSTR::from_raw(image_path_key.as_ptr()),
                None,
                Some(&mut value_type as *mut _),
                None,
                Some(&mut value_size),
            )
        };

        if status == ERROR_SUCCESS {
            let mut buffer = vec![0u8; value_size as usize];
            let status = unsafe {
                RegQueryValueExA(
                    reg_key,
                    PCSTR::from_raw(image_path_key.as_ptr()),
                    None,
                    Some(&mut value_type as *mut _),
                    Some(buffer.as_mut_ptr()),
                    Some(&mut value_size),
                )
            };

            if status == ERROR_SUCCESS
                && (value_type == REG_VALUE_TYPE(REG_SZ.0)
                    || value_type == REG_VALUE_TYPE(REG_EXPAND_SZ.0))
            {
                if let Ok(path) = String::from_utf8(buffer) {
                    driver_paths.push(path.trim_matches(char::from(0)).to_string());
                }
            }
        }

        unsafe { RegCloseKey(reg_key) };
    }

    if driver_paths.is_empty() {
        println!("Error: No GPU driver found");
        return;
    }

    let mut drivers_dir = match get_system_dir() {
        Some(path) => path,
        None => {
            println!("Error: Failed to get system directory");
            return;
        }
    };
    drivers_dir.push("drivers");

    let mut gpu_infos = Vec::new();

    for driver_path in driver_paths {
        if let Some(file_name) = PathBuf::from(&driver_path).file_name() {
            let file_name_str = file_name.to_string_lossy().to_string();
            if let Some(vendor) = identify_gpu_vendor(&file_name_str) {
                let mut full_path = drivers_dir.clone();
                full_path.push(&file_name);

                let gpu_info = GpuInfo {
                    vendor,
                    name: get_gpu_name(&file_name_str),
                    driver_path: full_path.display().to_string(),
                };
                gpu_infos.push(gpu_info);
            }
        }
    }

    if gpu_infos.is_empty() {
        println!("No recognized GPU found");
    } else {
        println!("\nGPU Information Summary:");
        println!("------------------------");
        for (index, gpu) in gpu_infos.iter().enumerate() {
            println!("GPU #{}", index + 1);
            println!("Vendor: {}", gpu.vendor);
            println!("Driver: {}", gpu.name);
            println!("Driver Path: {}", gpu.driver_path);
            println!("------------------------");
        }
    }
}

```